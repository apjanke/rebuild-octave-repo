# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1265910106 18000
#      Thu Feb 11 12:41:46 2010 -0500
# Node ID 57a59eae83cc631f1d74adad1bffc74ca0c37573
# Parent  07ebe522dac2276527d2a31e8704cd28acd430e5
untabify src C++ source files

diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -42,28 +42,28 @@ Cell::Cell (const string_vector& sv, boo
 {
   octave_idx_type n = sv.length ();
 
   if (n > 0)
     {
       resize (dim_vector (n, 1));
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  std::string s = sv[i];
+        {
+          std::string s = sv[i];
 
-	  if (trim)
-	    {
-	      size_t pos = s.find_last_not_of (' ');
+          if (trim)
+            {
+              size_t pos = s.find_last_not_of (' ');
 
-	      s = (pos == std::string::npos) ? "" : s.substr (0, pos+1);
-	    }
+              s = (pos == std::string::npos) ? "" : s.substr (0, pos+1);
+            }
 
-	  elem(i,0) = s;
-	}
+          elem(i,0) = s;
+        }
     }
 }
 
 Cell::Cell (const Array<std::string>& sa)
   : Array<octave_value> (sa.dims ())
 {
   octave_idx_type n = sa.numel ();
 
@@ -84,45 +84,45 @@ Cell::Cell (const dim_vector& dv, const 
 
   if (n > 0)
     {
       octave_idx_type m = numel ();
 
       octave_idx_type len = n > m ? m : n;
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  std::string s = sv[i];
+        {
+          std::string s = sv[i];
 
-	  if (trim)
-	    {
-	      size_t pos = s.find_last_not_of (' ');
+          if (trim)
+            {
+              size_t pos = s.find_last_not_of (' ');
 
-	      s = (pos == std::string::npos) ? "" : s.substr (0, pos+1);
-	    }
+              s = (pos == std::string::npos) ? "" : s.substr (0, pos+1);
+            }
 
-	  elem(i) = s;
-	}
+          elem(i) = s;
+        }
     }
 }
 
 bool
 Cell::is_cellstr (void) const
 {
   bool retval = true;
 
   octave_idx_type n = numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (! elem(i).is_string ())
-	{
-	  retval = false;
-	  break;
-	}
+        {
+          retval = false;
+          break;
+        }
     }
 
   return retval;
 }
 
 Array<std::string>
 Cell::cellstr_value (void) const
 {
@@ -146,63 +146,63 @@ Cell::index (const octave_value_list& id
   switch (n)
     {
     case 0:
       retval = *this;
       break;
 
     case 1:
       {
-	idx_vector i = idx_arg(0).index_vector ();
+        idx_vector i = idx_arg(0).index_vector ();
 
-	if (! error_state)
-	  retval = Array<octave_value>::index (i, resize_ok, resize_fill_value ());
+        if (! error_state)
+          retval = Array<octave_value>::index (i, resize_ok, resize_fill_value ());
       }
       break;
 
     case 2:
       {
-	idx_vector i = idx_arg(0).index_vector ();
+        idx_vector i = idx_arg(0).index_vector ();
 
-	if (! error_state)
-	  {
-	    idx_vector j = idx_arg(1).index_vector ();
+        if (! error_state)
+          {
+            idx_vector j = idx_arg(1).index_vector ();
 
-	    if (! error_state)
-	      retval = Array<octave_value>::index (i, j, resize_ok,
+            if (! error_state)
+              retval = Array<octave_value>::index (i, j, resize_ok,
                                                     resize_fill_value ());
-	  }
+          }
       }
       break;
 
     default:
       {
-	Array<idx_vector> iv (n);
+        Array<idx_vector> iv (n);
 
-	for (octave_idx_type i = 0; i < n; i++)
-	  {
-	    iv(i) = idx_arg(i).index_vector ();
+        for (octave_idx_type i = 0; i < n; i++)
+          {
+            iv(i) = idx_arg(i).index_vector ();
 
-	    if (error_state)
-	      break;
-	  }
+            if (error_state)
+              break;
+          }
 
-	if (!error_state)
-	  retval = Array<octave_value>::index (iv, resize_ok,
+        if (!error_state)
+          retval = Array<octave_value>::index (iv, resize_ok,
                                                 resize_fill_value ());
       }
       break;
     }
 
   return retval;
 }
 
 Cell&
 Cell::assign (const octave_value_list& idx_arg, const Cell& rhs,
-	      const octave_value& fill_val)
+              const octave_value& fill_val)
 
 {
   octave_idx_type len = idx_arg.length ();
 
   Array<idx_vector> ra_idx (len);
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx(i) = idx_arg(i).index_vector ();
@@ -238,26 +238,26 @@ Cell::nnz (void) const
 Cell
 Cell::column (octave_idx_type i) const
 {
   Cell retval;
 
   if (ndims () < 3)
     {
       if (i < 0 || i >= cols ())
-	error ("invalid column selection");
+        error ("invalid column selection");
       else
-	{
-	  octave_idx_type nr = rows ();
+        {
+          octave_idx_type nr = rows ();
 
-	  retval.resize (dim_vector (nr, 1));
+          retval.resize (dim_vector (nr, 1));
 
-	  for (octave_idx_type j = 0; j < nr; j++)
-	    retval.xelem (j) = elem (j, i);
-	}
+          for (octave_idx_type j = 0; j < nr; j++)
+            retval.xelem (j) = elem (j, i);
+        }
     }
   else
     error ("Cell::column: requires 2-d cell array");
 
   return retval;
 }
 
 Cell
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,42 @@
+2010-02-11  John W. Eaton  <jwe@octave.org>
+
+	* Cell.cc, bitfcns.cc, c-file-ptr-stream.cc, comment-list.cc,
+	data.cc, debug.cc, defaults.cc, defun.cc, dirfns.cc, display.cc,
+	dynamic-ld.cc, error.cc, file-io.cc, gl-render.cc,
+	gl2ps-renderer.cc, graphics.cc, gripes.cc, help.cc, input.cc,
+	load-path.cc, load-save.cc, ls-ascii-helper.cc, ls-hdf5.cc,
+	ls-mat-ascii.cc, ls-mat4.cc, ls-mat5.cc, ls-oct-ascii.cc,
+	ls-oct-binary.cc, mex.cc, oct-fstrm.cc, oct-hist.cc,
+	oct-lvalue.cc, oct-map.cc, oct-obj.cc, oct-prcstrm.cc,
+	oct-procbuf.cc, oct-stream.cc, oct-strstrm.cc, octave.cc,
+	ov-base-diag.cc, ov-base-int.cc, ov-base-mat.cc,
+	ov-base-scalar.cc, ov-base-sparse.cc, ov-base.cc,
+	ov-bool-mat.cc, ov-bool-sparse.cc, ov-bool.cc, ov-builtin.cc,
+	ov-cell.cc, ov-ch-mat.cc, ov-class.cc, ov-colon.cc,
+	ov-complex.cc, ov-cx-diag.cc, ov-cx-mat.cc, ov-cx-sparse.cc,
+	ov-dld-fcn.cc, ov-fcn-handle.cc, ov-fcn-inline.cc, ov-float.cc,
+	ov-flt-complex.cc, ov-flt-cx-diag.cc, ov-flt-cx-mat.cc,
+	ov-flt-re-diag.cc, ov-flt-re-mat.cc, ov-int16.cc, ov-int32.cc,
+	ov-int64.cc, ov-int8.cc, ov-mex-fcn.cc, ov-perm.cc, ov-range.cc,
+	ov-re-diag.cc, ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc,
+	ov-str-mat.cc, ov-struct.cc, ov-typeinfo.cc, ov-uint16.cc,
+	ov-uint32.cc, ov-uint64.cc, ov-uint8.cc, ov-usr-fcn.cc, ov.cc,
+	pager.cc, pr-output.cc, procstream.cc, pt-arg-list.cc,
+	pt-assign.cc, pt-binop.cc, pt-bp.cc, pt-cbinop.cc, pt-cell.cc,
+	pt-check.cc, pt-cmd.cc, pt-colon.cc, pt-const.cc, pt-decl.cc,
+	pt-eval.cc, pt-except.cc, pt-exp.cc, pt-fcn-handle.cc, pt-id.cc,
+	pt-idx.cc, pt-jump.cc, pt-loop.cc, pt-mat.cc, pt-misc.cc,
+	pt-pr-code.cc, pt-select.cc, pt-stmt.cc, pt-unop.cc,
+	sighandlers.cc, sparse-xdiv.cc, sparse-xpow.cc, strfns.cc,
+	symtab.cc, syscalls.cc, sysdep.cc, toplev.cc, txt-eng-ft.cc,
+	utils.cc, variables.cc, xdiv.cc, xpow.cc, oct-parse.yy, lex.ll:
+	Untabify.
+
 2010-02-11  John W. Eaton  <jwe@octave.org>
 
 	* Cell.h, base-list.h, c-file-ptr-stream.h, comment-list.h,
 	debug.h, defun-int.h, dynamic-ld.h, error.h, gl-render.h,
 	gl2ps-renderer.h, gripes.h, load-path.h, load-save.h, ls-hdf5.h,
 	ls-mat-ascii.h, ls-mat4.h, ls-mat5.h, ls-oct-ascii.h,
 	ls-oct-binary.h, oct-fstrm.h, oct-iostrm.h, oct-lvalue.h,
 	oct-map.h, oct-obj.h, oct-prcstrm.h, oct-stdstrm.h,
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -42,224 +42,224 @@ along with Octave; see the file COPYING.
 #include "ov-re-mat.h"
 #include "ov-bool.h"
 
 // FIXME -- could probably eliminate some code duplication by
 // clever use of templates.
 
 #define BITOPX(OP, FNAME, RET) \
       { \
-	int nelx = x.numel (); \
-	int nely = y.numel (); \
+        int nelx = x.numel (); \
+        int nely = y.numel (); \
  \
-	bool is_scalar_op = (nelx == 1 || nely == 1); \
+        bool is_scalar_op = (nelx == 1 || nely == 1); \
  \
-	dim_vector dvx = x.dims (); \
-	dim_vector dvy = y.dims (); \
+        dim_vector dvx = x.dims (); \
+        dim_vector dvy = y.dims (); \
  \
-	bool is_array_op = (dvx == dvy); \
+        bool is_array_op = (dvx == dvy); \
  \
-	if (is_array_op || is_scalar_op) \
-	  { \
-	    RET result; \
+        if (is_array_op || is_scalar_op) \
+          { \
+            RET result; \
  \
-	    if (nelx != 1) \
-	      result.resize (dvx); \
-	    else \
-	      result.resize (dvy); \
+            if (nelx != 1) \
+              result.resize (dvx); \
+            else \
+              result.resize (dvy); \
  \
-	    for (int i = 0; i < nelx; i++) \
-	      if (is_scalar_op) \
-		for (int k = 0; k < nely; k++) \
-		  result(i+k) = x(i) OP y(k); \
-	      else \
-		result(i) = x(i) OP y(i); \
+            for (int i = 0; i < nelx; i++) \
+              if (is_scalar_op) \
+                for (int k = 0; k < nely; k++) \
+                  result(i+k) = x(i) OP y(k); \
+              else \
+                result(i) = x(i) OP y(i); \
  \
-	      retval = result; \
-	  } \
-	else \
-	  error ("%s: size of x and y must match, or one operand must be a scalar", FNAME); \
+              retval = result; \
+          } \
+        else \
+          error ("%s: size of x and y must match, or one operand must be a scalar", FNAME); \
       }
 
 #define BITOP(OP, FNAME) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
   if (nargin == 2) \
     { \
       if ((args(0).class_name () == octave_scalar::static_class_name ()) \
-	  || (args(0).class_name () == octave_bool::static_class_name ()) \
-	  || (args(1).class_name () == octave_scalar::static_class_name ()) \
-	  || (args(1).class_name () == octave_bool::static_class_name ())) \
-	{ \
-	  bool arg0_is_int = (args(0).class_name () !=	\
-			      octave_scalar::static_class_name () && \
-			      args(0).class_name () != \
-			      octave_bool::static_class_name ()); \
-	  bool arg1_is_int = (args(1).class_name () !=	\
-			      octave_scalar::static_class_name () && \
-			      args(1).class_name () != \
-			      octave_bool::static_class_name ()); \
-	  \
-	  if (! (arg0_is_int || arg1_is_int))	\
-	    { \
-	      uint64NDArray x (args(0).array_value ()); \
-	      uint64NDArray y (args(1).array_value ());	\
-	      if (! error_state) \
-		BITOPX (OP, FNAME, uint64NDArray); \
-	      retval = retval.array_value (); \
-	    } \
-	  else \
-	    { \
-	      int p = (arg0_is_int ? 1 : 0); \
-	      int q = (arg0_is_int ? 0 : 1); \
+          || (args(0).class_name () == octave_bool::static_class_name ()) \
+          || (args(1).class_name () == octave_scalar::static_class_name ()) \
+          || (args(1).class_name () == octave_bool::static_class_name ())) \
+        { \
+          bool arg0_is_int = (args(0).class_name () !=  \
+                              octave_scalar::static_class_name () && \
+                              args(0).class_name () != \
+                              octave_bool::static_class_name ()); \
+          bool arg1_is_int = (args(1).class_name () !=  \
+                              octave_scalar::static_class_name () && \
+                              args(1).class_name () != \
+                              octave_bool::static_class_name ()); \
+          \
+          if (! (arg0_is_int || arg1_is_int))   \
+            { \
+              uint64NDArray x (args(0).array_value ()); \
+              uint64NDArray y (args(1).array_value ()); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, uint64NDArray); \
+              retval = retval.array_value (); \
+            } \
+          else \
+            { \
+              int p = (arg0_is_int ? 1 : 0); \
+              int q = (arg0_is_int ? 0 : 1); \
  \
-	      NDArray dx = args(p).array_value (); \
+              NDArray dx = args(p).array_value (); \
  \
-	      if (args(q).type_id () == octave_uint64_matrix::static_type_id () \
-		  || args(q).type_id () == octave_uint64_scalar::static_type_id ()) \
-		{ \
-		  uint64NDArray x (dx); \
-		  uint64NDArray y = args(q).uint64_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, uint64NDArray); \
-		 } \
-	      else if (args(q).type_id () == octave_uint32_matrix::static_type_id () \
-		       || args(q).type_id () == octave_uint32_scalar::static_type_id ()) \
-		{ \
-		  uint32NDArray x (dx); \
-		  uint32NDArray y = args(q).uint32_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, uint32NDArray); \
-		} \
-	      else if (args(q).type_id () == octave_uint16_matrix::static_type_id () \
-		       || args(q).type_id () == octave_uint16_scalar::static_type_id ()) \
-		{ \
-		  uint16NDArray x (dx); \
-		  uint16NDArray y = args(q).uint16_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, uint16NDArray); \
-		} \
-	      else if (args(q).type_id () == octave_uint8_matrix::static_type_id () \
-		       || args(q).type_id () == octave_uint8_scalar::static_type_id ()) \
-		{ \
-		  uint8NDArray x (dx); \
-		  uint8NDArray y = args(q).uint8_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, uint8NDArray); \
-		} \
-	      else if (args(q).type_id () == octave_int64_matrix::static_type_id () \
-		       || args(q).type_id () == octave_int64_scalar::static_type_id ()) \
-		{ \
-		  int64NDArray x (dx); \
-		  int64NDArray y = args(q).int64_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, int64NDArray); \
-		} \
-	      else if (args(q).type_id () == octave_int32_matrix::static_type_id () \
-		       || args(q).type_id () == octave_int32_scalar::static_type_id ()) \
-		{ \
-		  int32NDArray x (dx); \
-		  int32NDArray y = args(q).int32_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, int32NDArray); \
-		} \
-	      else if (args(q).type_id () == octave_int16_matrix::static_type_id () \
-		       || args(q).type_id () == octave_int16_scalar::static_type_id ()) \
-		{ \
-		  int16NDArray x (dx); \
-		  int16NDArray y = args(q).int16_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, int16NDArray); \
-		} \
-	      else if (args(q).type_id () == octave_int8_matrix::static_type_id () \
-		       || args(q).type_id () == octave_int8_scalar::static_type_id ()) \
-		{ \
-		  int8NDArray x (dx); \
-		  int8NDArray y = args(q).int8_array_value (); \
-		  if (! error_state) \
-		    BITOPX (OP, FNAME, int8NDArray); \
-		} \
-	      else \
-		error ("%s: invalid operand type", FNAME); \
-	    } \
-	} \
+              if (args(q).type_id () == octave_uint64_matrix::static_type_id () \
+                  || args(q).type_id () == octave_uint64_scalar::static_type_id ()) \
+                { \
+                  uint64NDArray x (dx); \
+                  uint64NDArray y = args(q).uint64_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, uint64NDArray); \
+                 } \
+              else if (args(q).type_id () == octave_uint32_matrix::static_type_id () \
+                       || args(q).type_id () == octave_uint32_scalar::static_type_id ()) \
+                { \
+                  uint32NDArray x (dx); \
+                  uint32NDArray y = args(q).uint32_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, uint32NDArray); \
+                } \
+              else if (args(q).type_id () == octave_uint16_matrix::static_type_id () \
+                       || args(q).type_id () == octave_uint16_scalar::static_type_id ()) \
+                { \
+                  uint16NDArray x (dx); \
+                  uint16NDArray y = args(q).uint16_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, uint16NDArray); \
+                } \
+              else if (args(q).type_id () == octave_uint8_matrix::static_type_id () \
+                       || args(q).type_id () == octave_uint8_scalar::static_type_id ()) \
+                { \
+                  uint8NDArray x (dx); \
+                  uint8NDArray y = args(q).uint8_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, uint8NDArray); \
+                } \
+              else if (args(q).type_id () == octave_int64_matrix::static_type_id () \
+                       || args(q).type_id () == octave_int64_scalar::static_type_id ()) \
+                { \
+                  int64NDArray x (dx); \
+                  int64NDArray y = args(q).int64_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, int64NDArray); \
+                } \
+              else if (args(q).type_id () == octave_int32_matrix::static_type_id () \
+                       || args(q).type_id () == octave_int32_scalar::static_type_id ()) \
+                { \
+                  int32NDArray x (dx); \
+                  int32NDArray y = args(q).int32_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, int32NDArray); \
+                } \
+              else if (args(q).type_id () == octave_int16_matrix::static_type_id () \
+                       || args(q).type_id () == octave_int16_scalar::static_type_id ()) \
+                { \
+                  int16NDArray x (dx); \
+                  int16NDArray y = args(q).int16_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, int16NDArray); \
+                } \
+              else if (args(q).type_id () == octave_int8_matrix::static_type_id () \
+                       || args(q).type_id () == octave_int8_scalar::static_type_id ()) \
+                { \
+                  int8NDArray x (dx); \
+                  int8NDArray y = args(q).int8_array_value (); \
+                  if (! error_state) \
+                    BITOPX (OP, FNAME, int8NDArray); \
+                } \
+              else \
+                error ("%s: invalid operand type", FNAME); \
+            } \
+        } \
       else if (args(0).class_name () == args(1).class_name ()) \
-	{ \
-	  if (args(0).type_id () == octave_uint64_matrix::static_type_id () \
-	      || args(0).type_id () == octave_uint64_scalar::static_type_id ()) \
-	    { \
-	      uint64NDArray x = args(0).uint64_array_value (); \
-	      uint64NDArray y = args(1).uint64_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, uint64NDArray); \
-	    } \
-	  else if (args(0).type_id () == octave_uint32_matrix::static_type_id () \
-		   || args(0).type_id () == octave_uint32_scalar::static_type_id ()) \
-	    { \
-	      uint32NDArray x = args(0).uint32_array_value (); \
-	      uint32NDArray y = args(1).uint32_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, uint32NDArray); \
-	    } \
-	  else if (args(0).type_id () == octave_uint16_matrix::static_type_id () \
-		   || args(0).type_id () == octave_uint16_scalar::static_type_id ()) \
-	    { \
-	      uint16NDArray x = args(0).uint16_array_value (); \
-	      uint16NDArray y = args(1).uint16_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, uint16NDArray); \
-	    } \
-	  else if (args(0).type_id () == octave_uint8_matrix::static_type_id () \
-		   || args(0).type_id () == octave_uint8_scalar::static_type_id ()) \
-	    { \
-	      uint8NDArray x = args(0).uint8_array_value (); \
-	      uint8NDArray y = args(1).uint8_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, uint8NDArray); \
-	    } \
-	  else if (args(0).type_id () == octave_int64_matrix::static_type_id () \
-		   || args(0).type_id () == octave_int64_scalar::static_type_id ()) \
-	    { \
-	      int64NDArray x = args(0).int64_array_value (); \
-	      int64NDArray y = args(1).int64_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, int64NDArray); \
-	    } \
-	  else if (args(0).type_id () == octave_int32_matrix::static_type_id () \
-		   || args(0).type_id () == octave_int32_scalar::static_type_id ()) \
-	    { \
-	      int32NDArray x = args(0).int32_array_value (); \
-	      int32NDArray y = args(1).int32_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, int32NDArray); \
-	    } \
-	  else if (args(0).type_id () == octave_int16_matrix::static_type_id () \
-		   || args(0).type_id () == octave_int16_scalar::static_type_id ()) \
-	    { \
-	      int16NDArray x = args(0).int16_array_value (); \
-	      int16NDArray y = args(1).int16_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, int16NDArray); \
-	    } \
-	  else if (args(0).type_id () == octave_int8_matrix::static_type_id () \
-		   || args(0).type_id () == octave_int8_scalar::static_type_id ()) \
-	    { \
-	      int8NDArray x = args(0).int8_array_value (); \
-	      int8NDArray y = args(1).int8_array_value (); \
-	      if (! error_state) \
-		BITOPX (OP, FNAME, int8NDArray); \
-	    } \
-	  else \
-	    error ("%s: invalid operand type", FNAME); \
-	} \
+        { \
+          if (args(0).type_id () == octave_uint64_matrix::static_type_id () \
+              || args(0).type_id () == octave_uint64_scalar::static_type_id ()) \
+            { \
+              uint64NDArray x = args(0).uint64_array_value (); \
+              uint64NDArray y = args(1).uint64_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, uint64NDArray); \
+            } \
+          else if (args(0).type_id () == octave_uint32_matrix::static_type_id () \
+                   || args(0).type_id () == octave_uint32_scalar::static_type_id ()) \
+            { \
+              uint32NDArray x = args(0).uint32_array_value (); \
+              uint32NDArray y = args(1).uint32_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, uint32NDArray); \
+            } \
+          else if (args(0).type_id () == octave_uint16_matrix::static_type_id () \
+                   || args(0).type_id () == octave_uint16_scalar::static_type_id ()) \
+            { \
+              uint16NDArray x = args(0).uint16_array_value (); \
+              uint16NDArray y = args(1).uint16_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, uint16NDArray); \
+            } \
+          else if (args(0).type_id () == octave_uint8_matrix::static_type_id () \
+                   || args(0).type_id () == octave_uint8_scalar::static_type_id ()) \
+            { \
+              uint8NDArray x = args(0).uint8_array_value (); \
+              uint8NDArray y = args(1).uint8_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, uint8NDArray); \
+            } \
+          else if (args(0).type_id () == octave_int64_matrix::static_type_id () \
+                   || args(0).type_id () == octave_int64_scalar::static_type_id ()) \
+            { \
+              int64NDArray x = args(0).int64_array_value (); \
+              int64NDArray y = args(1).int64_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, int64NDArray); \
+            } \
+          else if (args(0).type_id () == octave_int32_matrix::static_type_id () \
+                   || args(0).type_id () == octave_int32_scalar::static_type_id ()) \
+            { \
+              int32NDArray x = args(0).int32_array_value (); \
+              int32NDArray y = args(1).int32_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, int32NDArray); \
+            } \
+          else if (args(0).type_id () == octave_int16_matrix::static_type_id () \
+                   || args(0).type_id () == octave_int16_scalar::static_type_id ()) \
+            { \
+              int16NDArray x = args(0).int16_array_value (); \
+              int16NDArray y = args(1).int16_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, int16NDArray); \
+            } \
+          else if (args(0).type_id () == octave_int8_matrix::static_type_id () \
+                   || args(0).type_id () == octave_int8_scalar::static_type_id ()) \
+            { \
+              int8NDArray x = args(0).int8_array_value (); \
+              int8NDArray y = args(1).int8_array_value (); \
+              if (! error_state) \
+                BITOPX (OP, FNAME, int8NDArray); \
+            } \
+          else \
+            error ("%s: invalid operand type", FNAME); \
+        } \
       else \
-	error ("%s: must have matching operand types", FNAME); \
+        error ("%s: must have matching operand types", FNAME); \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (bitand, args, ,
   "-*- texinfo -*-\n\
@@ -329,82 +329,82 @@ bitshift (float a, int n, int64_t mask)
 // shift.
 
 #define DO_BITSHIFT(T) \
   if (! error_state) \
     { \
       double d1, d2; \
  \
       if (n.all_integers (d1, d2)) \
-	{ \
-	  int m_nel = m.numel (); \
-	  int n_nel = n.numel (); \
+        { \
+          int m_nel = m.numel (); \
+          int n_nel = n.numel (); \
  \
-	  bool is_scalar_op = (m_nel == 1 || n_nel == 1); \
+          bool is_scalar_op = (m_nel == 1 || n_nel == 1); \
  \
-	  dim_vector m_dv = m.dims (); \
-	  dim_vector n_dv = n.dims (); \
+          dim_vector m_dv = m.dims (); \
+          dim_vector n_dv = n.dims (); \
  \
-	  bool is_array_op = (m_dv == n_dv); \
+          bool is_array_op = (m_dv == n_dv); \
  \
-	  if (is_array_op || is_scalar_op) \
-	    { \
-	      T ## NDArray result; \
+          if (is_array_op || is_scalar_op) \
+            { \
+              T ## NDArray result; \
  \
-	      if (m_nel != 1) \
-		result.resize (m_dv); \
-	      else \
-		result.resize (n_dv); \
+              if (m_nel != 1) \
+                result.resize (m_dv); \
+              else \
+                result.resize (n_dv); \
  \
-	      for (int i = 0; i < m_nel; i++) \
-		if (is_scalar_op) \
-		  for (int k = 0; k < n_nel; k++) \
-		    if (static_cast<int> (n(k)) >= bits_in_type) \
-		      result(i+k) = 0; \
-		    else \
-		      result(i+k) = bitshift (m(i), static_cast<int> (n(k)), mask); \
-		else \
-		  if (static_cast<int> (n(i)) >= bits_in_type) \
-		    result(i) = 0;					\
-		  else 						\
-		    result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
+              for (int i = 0; i < m_nel; i++) \
+                if (is_scalar_op) \
+                  for (int k = 0; k < n_nel; k++) \
+                    if (static_cast<int> (n(k)) >= bits_in_type) \
+                      result(i+k) = 0; \
+                    else \
+                      result(i+k) = bitshift (m(i), static_cast<int> (n(k)), mask); \
+                else \
+                  if (static_cast<int> (n(i)) >= bits_in_type) \
+                    result(i) = 0;                                      \
+                  else                                          \
+                    result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
  \
-	      retval = result; \
-	    } \
-	  else \
-	    error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
-	} \
+              retval = result; \
+            } \
+          else \
+            error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
+        } \
       else \
-	error ("bitshift: expecting second argument to be integer"); \
+        error ("bitshift: expecting second argument to be integer"); \
     }
 
 #define DO_UBITSHIFT(T, N) \
   do \
     { \
       int bits_in_type = octave_ ## T :: nbits (); \
       T ## NDArray m = m_arg.T ## _array_value (); \
-	octave_ ## T mask = octave_ ## T::max (); \
+        octave_ ## T mask = octave_ ## T::max (); \
       if ((N) < bits_in_type) \
-	mask = bitshift (mask, (N) - bits_in_type); \
+        mask = bitshift (mask, (N) - bits_in_type); \
       else if ((N) < 1) \
-	mask = 0; \
+        mask = 0; \
       DO_BITSHIFT (T); \
     } \
   while (0)
 
 #define DO_SBITSHIFT(T, N) \
   do \
     { \
       int bits_in_type = octave_ ## T :: nbits (); \
       T ## NDArray m = m_arg.T ## _array_value (); \
-	octave_ ## T mask = octave_ ## T::max (); \
+        octave_ ## T mask = octave_ ## T::max (); \
       if ((N) < bits_in_type) \
-	mask = bitshift (mask, (N) - bits_in_type); \
+        mask = bitshift (mask, (N) - bits_in_type); \
       else if ((N) < 1) \
-	mask = 0; \
+        mask = 0; \
       mask = mask | octave_ ## T :: min (); /* FIXME: 2's complement only? */ \
       DO_BITSHIFT (T); \
     } \
   while (0)
 
 DEFUN (bitshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitshift (@var{a}, @var{k})\n\
@@ -443,73 +443,73 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
 
   if (nargin == 2 || nargin == 3)
     {
       int nbits = 64;
       
       NDArray n = args(1).array_value ();
 
       if (error_state)
-	error ("bitshift: expecting integer as second argument");
+        error ("bitshift: expecting integer as second argument");
       else
-	{
-	  if (nargin == 3)
-	    {
-	      // FIXME -- for compatibility, we should accept an array
-	      // or a scalar as the third argument.
-	      if (args(2).numel () > 1)
-		error ("bitshift: expecting scalar integer as third argument");
-	      else
-		{
-		  nbits = args(2).int_value ();
-	  
-		  if (error_state)
-		    error ("bitshift: expecting integer as third argument");
-		  else if (nbits < 0)
-		    error ("bitshift: number of bits to mask must be positive");
-		}
-	    }
-	}
+        {
+          if (nargin == 3)
+            {
+              // FIXME -- for compatibility, we should accept an array
+              // or a scalar as the third argument.
+              if (args(2).numel () > 1)
+                error ("bitshift: expecting scalar integer as third argument");
+              else
+                {
+                  nbits = args(2).int_value ();
+          
+                  if (error_state)
+                    error ("bitshift: expecting integer as third argument");
+                  else if (nbits < 0)
+                    error ("bitshift: number of bits to mask must be positive");
+                }
+            }
+        }
 
       if (error_state)
-	return retval;
+        return retval;
 
       octave_value m_arg = args(0);
       std::string cname = m_arg.class_name ();
 
       if (cname == "uint8")
-	DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
+        DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
       else if (cname == "uint16")
-	DO_UBITSHIFT (uint16, nbits < 16 ? nbits : 16);
+        DO_UBITSHIFT (uint16, nbits < 16 ? nbits : 16);
       else if (cname == "uint32")
-	DO_UBITSHIFT (uint32, nbits < 32 ? nbits : 32);
+        DO_UBITSHIFT (uint32, nbits < 32 ? nbits : 32);
       else if (cname == "uint64")
-	DO_UBITSHIFT (uint64, nbits < 64 ? nbits : 64);
+        DO_UBITSHIFT (uint64, nbits < 64 ? nbits : 64);
       else if (cname == "int8")
-	DO_SBITSHIFT (int8, nbits < 8 ? nbits : 8);
+        DO_SBITSHIFT (int8, nbits < 8 ? nbits : 8);
       else if (cname == "int16")
-	DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
+        DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
       else if (cname == "int32")
-	DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
+        DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
       else if (cname == "int64")
-	DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
+        DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
       else if (cname == "double")
-	{
-	  nbits = (nbits < 53 ? nbits : 53);
-	  int64_t mask = 0x1FFFFFFFFFFFFFLL;
-	  if (nbits < 53)
-	    mask = mask >> (53 - nbits);
-	  else if (nbits < 1)
-	    mask = 0;
-	  int bits_in_type = 64;
-	  NDArray m = m_arg.array_value ();
-	  DO_BITSHIFT ( );
-	}
+        {
+          nbits = (nbits < 53 ? nbits : 53);
+          int64_t mask = 0x1FFFFFFFFFFFFFLL;
+          if (nbits < 53)
+            mask = mask >> (53 - nbits);
+          else if (nbits < 1)
+            mask = 0;
+          int bits_in_type = 64;
+          NDArray m = m_arg.array_value ();
+          DO_BITSHIFT ( );
+        }
       else
-	error ("bitshift: not defined for %s objects", cname.c_str ());
+        error ("bitshift: not defined for %s objects", cname.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (bitmax, args, ,
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -68,21 +68,21 @@ c_file_ptr_buf::int_type
 c_file_ptr_buf::underflow_common (bool bump)
 {
   if (f)
     {
       int_type c = fgetc (f);
 
       if (! bump
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
-	  && c != traits_type::eof ())
+          && c != traits_type::eof ())
 #else
-	  && c != EOF)
+          && c != EOF)
 #endif
-	ungetc (c, f);
+        ungetc (c, f);
 
       return c;
     }
   else
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
     return traits_type::eof ();
 #else
     return EOF;
@@ -117,25 +117,25 @@ c_file_ptr_buf::xsgetn (char *s, std::st
   else
     return 0;
 }
 
 static inline int
 seekdir_to_whence (std::ios::seekdir dir)
 {
   return ((dir == std::ios::beg) ? SEEK_SET :
-	  (dir == std::ios::cur) ? SEEK_CUR :
-	  (dir == std::ios::end) ? SEEK_END :
-	  dir);
+          (dir == std::ios::cur) ? SEEK_CUR :
+          (dir == std::ios::end) ? SEEK_END :
+          dir);
 }
 
 std::streampos
 c_file_ptr_buf::seekoff (std::streamoff /* offset */,
-			 std::ios::seekdir /* dir */,
-			 std::ios::openmode)
+                         std::ios::seekdir /* dir */,
+                         std::ios::openmode)
 {
   // FIXME
 #if 0
   if (f)
     {
       fseek (f, offset, seekdir_to_whence (dir));
 
       return ftell (f);
@@ -222,21 +222,21 @@ c_zfile_ptr_buf::int_type
 c_zfile_ptr_buf::underflow_common (bool bump)
 {
   if (f)
     {
       int_type c = gzgetc (f);
 
       if (! bump
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
-	  && c != traits_type::eof ())
+          && c != traits_type::eof ())
 #else
-	  && c != EOF)
+          && c != EOF)
 #endif
-	gzungetc (c, f);
+        gzungetc (c, f);
 
       return c;
     }
   else
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
     return traits_type::eof ();
 #else
     return EOF;
@@ -269,18 +269,18 @@ c_zfile_ptr_buf::xsgetn (char *s, std::s
   if (f)
     return gzread (f, s, n);
   else
     return 0;
 }
 
 std::streampos
 c_zfile_ptr_buf::seekoff (std::streamoff /* offset */,
-			  std::ios::seekdir /* dir */,
-			  std::ios::openmode)
+                          std::ios::seekdir /* dir */,
+                          std::ios::openmode)
 {
   // FIXME
 #if 0
   if (f)
     {
       gzseek (f, offset, seekdir_to_whence (dir));
 
       return gztell (f);
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -61,31 +61,31 @@ octave_comment_buffer::instance_ok (void
       retval = false;
     }
 
   return retval;
 }
 
 void
 octave_comment_buffer::append (const std::string& s,
-			       octave_comment_elt::comment_type t)
+                               octave_comment_elt::comment_type t)
 {
   if (instance_ok ())
     instance->do_append (s, t);
 }
 
 octave_comment_list *
 octave_comment_buffer::get_comment (void)
 {
   return (instance_ok ()) ? instance->do_get_comment () : 0;
 }
 
 void
 octave_comment_buffer::do_append (const std::string& s,
-				  octave_comment_elt::comment_type t)
+                                  octave_comment_elt::comment_type t)
 {
   comment_list->append(s, t);
 }
 
 octave_comment_list *
 octave_comment_buffer::do_get_comment (void)
 {
   octave_comment_list *retval = 0;
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -87,19 +87,19 @@ along with Octave; see the file COPYING.
  \
   if (nargin == 1 || nargin == 2) \
     { \
       int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
       if (! error_state) \
         { \
           if (dim >= -1) \
-	    retval = args(0).FCN (dim); \
+            retval = args(0).FCN (dim); \
           else \
-	    error (#FCN ": invalid dimension argument = %d", dim + 1); \
+            error (#FCN ": invalid dimension argument = %d", dim + 1); \
         } \
       else \
         error (#FCN ": expecting dimension argument to be an integer"); \
     } \
   else \
     print_usage (); \
  \
   return retval
@@ -325,46 +325,46 @@ map_d_s (d_dd_fcn f, double x, const Spa
   SparseMatrix retval;
   double f_zero = f (x, 0.);
 
   if (f_zero != 0)
     {
       retval = SparseMatrix (nr, nc, f_zero);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
-	  {
-	    octave_quit ();
-	    retval.data (y.ridx(i) + j * nr) = f (x, y.data (i));
-	  } 
+        for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
+          {
+            octave_quit ();
+            retval.data (y.ridx(i) + j * nr) = f (x, y.data (i));
+          } 
 
       retval.maybe_compress (true);
     }
   else
     {
       octave_idx_type nz = y.nnz ();
       retval = SparseMatrix (nr, nc, nz);
       octave_idx_type ii = 0;
       retval.cidx (ii) = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
-	    {
-	      octave_quit ();
-	      double val = f (x, y.data (i));
-
-	      if (val != 0.0)
-		{
-		  retval.data (ii) = val;
-		  retval.ridx (ii++) = y.ridx (i);
-		}
-	    } 
-	  retval.cidx (j + 1) = ii;
-	}
+        {
+          for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
+            {
+              octave_quit ();
+              double val = f (x, y.data (i));
+
+              if (val != 0.0)
+                {
+                  retval.data (ii) = val;
+                  retval.ridx (ii++) = y.ridx (i);
+                }
+            } 
+          retval.cidx (j + 1) = ii;
+        }
 
       retval.maybe_compress (false);
     }
 
   return retval;
 }
 
 static SparseMatrix
@@ -375,46 +375,46 @@ map_s_d (d_dd_fcn f, const SparseMatrix&
   SparseMatrix retval;
   double f_zero = f (0., y);
 
   if (f_zero != 0)
     {
       retval = SparseMatrix (nr, nc, f_zero);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = x.cidx (j); i < x.cidx (j+1); i++)
-	  {
-	    octave_quit ();
-	    retval.data (x.ridx(i) + j * nr) = f (x.data (i), y);
-	  } 
+        for (octave_idx_type i = x.cidx (j); i < x.cidx (j+1); i++)
+          {
+            octave_quit ();
+            retval.data (x.ridx(i) + j * nr) = f (x.data (i), y);
+          } 
 
       retval.maybe_compress (true);
     }
   else
     {
       octave_idx_type nz = x.nnz ();
       retval = SparseMatrix (nr, nc, nz);
       octave_idx_type ii = 0;
       retval.cidx (ii) = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = x.cidx (j); i < x.cidx (j+1); i++)
-	    {
-	      octave_quit ();
-	      double val = f (x.data (i), y);
-
-	      if (val != 0.0)
-		{
-		  retval.data (ii) = val;
-		  retval.ridx (ii++) = x.ridx (i);
-		}
-	    } 
-	  retval.cidx (j + 1) = ii;
-	}
+        {
+          for (octave_idx_type i = x.cidx (j); i < x.cidx (j+1); i++)
+            {
+              octave_quit ();
+              double val = f (x.data (i), y);
+
+              if (val != 0.0)
+                {
+                  retval.data (ii) = val;
+                  retval.ridx (ii++) = x.ridx (i);
+                }
+            } 
+          retval.cidx (j + 1) = ii;
+        }
 
       retval.maybe_compress (false);
     }
 
   return retval;
 }
 
 static SparseMatrix
@@ -432,111 +432,111 @@ map_s_s (d_dd_fcn f, const SparseMatrix&
   double f_zero = f (0., 0.);
 
   if (f_zero != 0)
     {
       retval = SparseMatrix (nr, nc, f_zero);
       octave_idx_type k1 = 0, k2 = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  while (k1 < x.cidx(j+1) && k2 < y.cidx(j+1))
-	    {
-	      octave_quit ();
-	      if (k1 >= x.cidx(j+1))
-		{
-		  retval.data (y.ridx(k2) + j * nr) = f (0.0, y.data (k2));
-		  k2++;
-		}
-	      else if (k2 >= y.cidx(j+1))
-		{
-		  retval.data (x.ridx(k1) + j * nr) = f (x.data (k1), 0.0);
-		  k1++;
-		}
-	      else
-		{
-		  octave_idx_type rx = x.ridx(k1);
-		  octave_idx_type ry = y.ridx(k2);
-
-		  if (rx < ry)
-		    {
-		      retval.data (rx + j * nr) = f (x.data (k1), 0.0);
-		      k1++;
-		    }
-		  else if (rx > ry)
-		    {
-		      retval.data (ry + j * nr) = f (0.0, y.data (k2));
-		      k2++;
-		    }
-		  else
-		    {
-		      retval.data (ry + j * nr) = f (x.data (k1), y.data (k2));
-		      k1++;
-		      k2++;
-		    }
-		}
-	    }
-	}
+        {
+          while (k1 < x.cidx(j+1) && k2 < y.cidx(j+1))
+            {
+              octave_quit ();
+              if (k1 >= x.cidx(j+1))
+                {
+                  retval.data (y.ridx(k2) + j * nr) = f (0.0, y.data (k2));
+                  k2++;
+                }
+              else if (k2 >= y.cidx(j+1))
+                {
+                  retval.data (x.ridx(k1) + j * nr) = f (x.data (k1), 0.0);
+                  k1++;
+                }
+              else
+                {
+                  octave_idx_type rx = x.ridx(k1);
+                  octave_idx_type ry = y.ridx(k2);
+
+                  if (rx < ry)
+                    {
+                      retval.data (rx + j * nr) = f (x.data (k1), 0.0);
+                      k1++;
+                    }
+                  else if (rx > ry)
+                    {
+                      retval.data (ry + j * nr) = f (0.0, y.data (k2));
+                      k2++;
+                    }
+                  else
+                    {
+                      retval.data (ry + j * nr) = f (x.data (k1), y.data (k2));
+                      k1++;
+                      k2++;
+                    }
+                }
+            }
+        }
 
       retval.maybe_compress (true);
     }
   else
     {
       octave_idx_type nz = x.nnz () + y.nnz ();
       retval = SparseMatrix (nr, nc, nz);
       octave_idx_type ii = 0;
       retval.cidx (ii) = 0;
       octave_idx_type k1 = 0, k2 = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  while (k1 < x.cidx(j+1) && k2 < y.cidx(j+1))
-	    {
-	      octave_quit ();
-	      double val;
-	      octave_idx_type r;
-	      if (k1 >= x.cidx(j+1))
-		{
-		  r = y.ridx (k2);
-		  val = f (0.0, y.data (k2++));
-		}
-	      else if (k2 >= y.cidx(j+1))
-		{
-		  r = x.ridx (k1);
-		  val = f (x.data (k1++), 0.0);
-		}
-	      else
-		{
-		  octave_idx_type rx = x.ridx(k1);
-		  octave_idx_type ry = y.ridx(k2);
-
-		  if (rx < ry)
-		    {
-		      r = x.ridx (k1);
-		      val = f (x.data (k1++), 0.0);
-		    }
-		  else if (rx > ry)
-		    {
-		      r = y.ridx (k2);
-		      val = f (0.0, y.data (k2++));
-		    }
-		  else
-		    {
-		      r = y.ridx (k2);
-		      val = f (x.data (k1++), y.data (k2++));
-		    }
-		}
-	      if (val != 0.0)
-		{
-		  retval.data (ii) = val;
-		  retval.ridx (ii++) = r;
-		}
-	    }
-	  retval.cidx (j + 1) = ii;
-	}
+        {
+          while (k1 < x.cidx(j+1) && k2 < y.cidx(j+1))
+            {
+              octave_quit ();
+              double val;
+              octave_idx_type r;
+              if (k1 >= x.cidx(j+1))
+                {
+                  r = y.ridx (k2);
+                  val = f (0.0, y.data (k2++));
+                }
+              else if (k2 >= y.cidx(j+1))
+                {
+                  r = x.ridx (k1);
+                  val = f (x.data (k1++), 0.0);
+                }
+              else
+                {
+                  octave_idx_type rx = x.ridx(k1);
+                  octave_idx_type ry = y.ridx(k2);
+
+                  if (rx < ry)
+                    {
+                      r = x.ridx (k1);
+                      val = f (x.data (k1++), 0.0);
+                    }
+                  else if (rx > ry)
+                    {
+                      r = y.ridx (k2);
+                      val = f (0.0, y.data (k2++));
+                    }
+                  else
+                    {
+                      r = y.ridx (k2);
+                      val = f (x.data (k1++), y.data (k2++));
+                    }
+                }
+              if (val != 0.0)
+                {
+                  retval.data (ii) = val;
+                  retval.ridx (ii++) = r;
+                }
+            }
+          retval.cidx (j + 1) = ii;
+        }
 
       retval.maybe_compress (false);
     }
 
   return retval;
 }
 
 DEFUN (atan2, args, ,
@@ -549,168 +549,168 @@ and orientation.\n\
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       if (args(0).is_integer_type () || args(1).is_integer_type ())
-	error ("atan2: not defined for integer types");
+        error ("atan2: not defined for integer types");
       else
-	{
-	  octave_value arg_y = args(0);
-	  octave_value arg_x = args(1);
-
-	  dim_vector y_dims = arg_y.dims ();
-	  dim_vector x_dims = arg_x.dims ();
-
-	  bool y_is_scalar = y_dims.all_ones ();
-	  bool x_is_scalar = x_dims.all_ones ();
-
-	  bool is_float = arg_y.is_single_type () || arg_x.is_single_type ();
-
-	  if (y_is_scalar && x_is_scalar)
-	    {
-	      if (is_float)
-		{
-		  float y = arg_y.float_value ();
-
-		  if (! error_state)
-		    {
-		      float x = arg_x.float_value ();
-
-		      if (! error_state)
-			retval = atan2f (y, x);
-		    }
-		}
-	      else
-		{
-		  double y = arg_y.double_value ();
-
-		  if (! error_state)
-		    {
-		      double x = arg_x.double_value ();
-
-		      if (! error_state)
-			retval = atan2 (y, x);
-		    }
-		}
-	    }
-	  else if (y_is_scalar)
-	    {
-	      if (is_float)
-		{
-		  float y = arg_y.float_value ();
-
-		  if (! error_state)
-		    {
-		      // Even if x is sparse return a full matrix here
-		      FloatNDArray x = arg_x.float_array_value ();
-
-		      if (! error_state)
-			retval = map_f_fm (atan2f, y, x);
-		    }
-		}
-	      else
-		{
-		  double y = arg_y.double_value ();
-
-		  if (! error_state)
-		    {
-		      // Even if x is sparse return a full matrix here
-		      NDArray x = arg_x.array_value ();
-
-		      if (! error_state)
-			retval = map_d_m (atan2, y, x);
-		    }
-		}
-	    }
-	  else if (x_is_scalar)
-	    {
-	      if (arg_y.is_sparse_type ())
-		{
-		  SparseMatrix y = arg_y.sparse_matrix_value ();
-
-		  if (! error_state)
-		    {
-		      double x = arg_x.double_value ();
-		      
-		      if (! error_state)
-			retval = map_s_d (atan2, y, x);
-		    }
-		}
-	      else if (is_float)
-		{
-		  FloatNDArray y = arg_y.float_array_value ();
-		  
-		  if (! error_state)
-		    {
-		      float x = arg_x.float_value ();
-
-		      if (! error_state)
-			retval = map_fm_f (atan2f, y, x);
-		    }
-		}
-	      else
-		{
-		  NDArray y = arg_y.array_value ();
-
-		  if (! error_state)
-		    {
-		      double x = arg_x.double_value ();
-
-		      if (! error_state)
-			retval = map_m_d (atan2, y, x);
-		    }
-		}
-	    }
-	  else if (y_dims == x_dims)
-	    {
-	      // Even if y is sparse return a full matrix here
-	      if (arg_x.is_sparse_type ())
-		{
-		  SparseMatrix y = arg_y.sparse_matrix_value ();
-
-		  if (! error_state)
-		    {
-		      SparseMatrix x = arg_x.sparse_matrix_value ();
-
-		      if (! error_state)
-			retval = map_s_s (atan2, y, x);
-		    }
-		}
-	      else if (is_float)
-		{
-		  FloatNDArray y = arg_y.array_value ();
-
-		  if (! error_state)
-		    {
-		      FloatNDArray x = arg_x.array_value ();
-
-		      if (! error_state)
-			retval = map_fm_fm (atan2f, y, x);
-		    }
-		}
-	      else
-		{
-		  NDArray y = arg_y.array_value ();
-
-		  if (! error_state)
-		    {
-		      NDArray x = arg_x.array_value ();
-
-		      if (! error_state)
-			retval = map_m_m (atan2, y, x);
-		    }
-		}
-	    }
-	  else
-	    error ("atan2: nonconformant matrices");
-	}
+        {
+          octave_value arg_y = args(0);
+          octave_value arg_x = args(1);
+
+          dim_vector y_dims = arg_y.dims ();
+          dim_vector x_dims = arg_x.dims ();
+
+          bool y_is_scalar = y_dims.all_ones ();
+          bool x_is_scalar = x_dims.all_ones ();
+
+          bool is_float = arg_y.is_single_type () || arg_x.is_single_type ();
+
+          if (y_is_scalar && x_is_scalar)
+            {
+              if (is_float)
+                {
+                  float y = arg_y.float_value ();
+
+                  if (! error_state)
+                    {
+                      float x = arg_x.float_value ();
+
+                      if (! error_state)
+                        retval = atan2f (y, x);
+                    }
+                }
+              else
+                {
+                  double y = arg_y.double_value ();
+
+                  if (! error_state)
+                    {
+                      double x = arg_x.double_value ();
+
+                      if (! error_state)
+                        retval = atan2 (y, x);
+                    }
+                }
+            }
+          else if (y_is_scalar)
+            {
+              if (is_float)
+                {
+                  float y = arg_y.float_value ();
+
+                  if (! error_state)
+                    {
+                      // Even if x is sparse return a full matrix here
+                      FloatNDArray x = arg_x.float_array_value ();
+
+                      if (! error_state)
+                        retval = map_f_fm (atan2f, y, x);
+                    }
+                }
+              else
+                {
+                  double y = arg_y.double_value ();
+
+                  if (! error_state)
+                    {
+                      // Even if x is sparse return a full matrix here
+                      NDArray x = arg_x.array_value ();
+
+                      if (! error_state)
+                        retval = map_d_m (atan2, y, x);
+                    }
+                }
+            }
+          else if (x_is_scalar)
+            {
+              if (arg_y.is_sparse_type ())
+                {
+                  SparseMatrix y = arg_y.sparse_matrix_value ();
+
+                  if (! error_state)
+                    {
+                      double x = arg_x.double_value ();
+                      
+                      if (! error_state)
+                        retval = map_s_d (atan2, y, x);
+                    }
+                }
+              else if (is_float)
+                {
+                  FloatNDArray y = arg_y.float_array_value ();
+                  
+                  if (! error_state)
+                    {
+                      float x = arg_x.float_value ();
+
+                      if (! error_state)
+                        retval = map_fm_f (atan2f, y, x);
+                    }
+                }
+              else
+                {
+                  NDArray y = arg_y.array_value ();
+
+                  if (! error_state)
+                    {
+                      double x = arg_x.double_value ();
+
+                      if (! error_state)
+                        retval = map_m_d (atan2, y, x);
+                    }
+                }
+            }
+          else if (y_dims == x_dims)
+            {
+              // Even if y is sparse return a full matrix here
+              if (arg_x.is_sparse_type ())
+                {
+                  SparseMatrix y = arg_y.sparse_matrix_value ();
+
+                  if (! error_state)
+                    {
+                      SparseMatrix x = arg_x.sparse_matrix_value ();
+
+                      if (! error_state)
+                        retval = map_s_s (atan2, y, x);
+                    }
+                }
+              else if (is_float)
+                {
+                  FloatNDArray y = arg_y.array_value ();
+
+                  if (! error_state)
+                    {
+                      FloatNDArray x = arg_x.array_value ();
+
+                      if (! error_state)
+                        retval = map_fm_fm (atan2f, y, x);
+                    }
+                }
+              else
+                {
+                  NDArray y = arg_y.array_value ();
+
+                  if (! error_state)
+                    {
+                      NDArray x = arg_x.array_value ();
+
+                      if (! error_state)
+                        retval = map_m_m (atan2, y, x);
+                    }
+                }
+            }
+          else
+            error ("atan2: nonconformant matrices");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -754,225 +754,225 @@ avoids overflows for large values of @va
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       if (args(0).is_integer_type () || args(1).is_integer_type ())
-	error ("hypot: not defined for integer types");
+        error ("hypot: not defined for integer types");
       else
-	{
-	  octave_value arg_x = args(0);
-	  octave_value arg_y = args(1);
-
-	  dim_vector x_dims = arg_x.dims ();
-	  dim_vector y_dims = arg_y.dims ();
-
-	  bool x_is_scalar = x_dims.all_ones ();
-	  bool y_is_scalar = y_dims.all_ones ();
-
-	  bool is_float = arg_y.is_single_type () || arg_x.is_single_type ();
-
-	  if (y_is_scalar && x_is_scalar)
-	    {
-	      if (is_float)
-		{
-		  float x;
-		  if (arg_x.is_complex_type ())
-		    x = abs (arg_x.float_complex_value ());
-		  else
-		    x = arg_x.float_value ();
-
-		  if (! error_state)
-		    {
-		      float y;
-		      if (arg_y.is_complex_type ())
-			y = abs (arg_y.float_complex_value ());
-		      else
-			y = arg_y.float_value ();
-
-		      if (! error_state)
-			retval = hypotf (x, y);
-		    }
-		}
-	      else
-		{
-		  double x;
-		  if (arg_x.is_complex_type ())
-		    x = abs (arg_x.complex_value ());
-		  else
-		    x = arg_x.double_value ();
-
-		  if (! error_state)
-		    {
-		      double y;
-		      if (arg_y.is_complex_type ())
-			y = abs (arg_y.complex_value ());
-		      else
-			y = arg_y.double_value ();
-
-		      if (! error_state)
-			retval = hypot (x, y);
-		    }
-		}
-	    }
-	  else if (y_is_scalar)
-	    {
-	      if (is_float)
-		{
-		  FloatNDArray x;
-		  if (arg_x.is_complex_type ())
-		    x = arg_x.float_complex_array_value ().abs ();
-		  else
-		    x = arg_x.float_array_value ();
-
-		  if (! error_state)
-		    {
-		      float y;
-		      if (arg_y.is_complex_type ())
-			y = abs (arg_y.float_complex_value ());
-		      else
-			y = arg_y.float_value ();
-
-		      if (! error_state)
-			retval = map_fm_f (hypotf, x, y);
-		    }
-		}
-	      else
-		{
-		  NDArray x;
-		  if (arg_x.is_complex_type ())
-		    x = arg_x.complex_array_value ().abs ();
-		  else
-		    x = arg_x.array_value ();
-
-		  if (! error_state)
-		    {
-		      double y;
-		      if (arg_y.is_complex_type ())
-			y = abs (arg_y.complex_value ());
-		      else
-			y = arg_y.double_value ();
-
-		      if (! error_state)
-			retval = map_m_d (hypot, x, y);
-		    }
-		}
-	    }
-	  else if (x_is_scalar)
-	    {
-	      if (is_float)
-		{
-		  float x;
-		  if (arg_x.is_complex_type ())
-		    x = abs (arg_x.float_complex_value ());
-		  else
-		    x = arg_x.float_value ();
-
-		  if (! error_state)
-		    {
-		      FloatNDArray y;
-		      if (arg_y.is_complex_type ())
-			y = arg_y.float_complex_array_value ().abs ();
-		      else
-			y = arg_y.float_array_value ();
-
-		      if (! error_state)
-			retval = map_f_fm (hypotf, x, y);
-		    }
-		}
-	      else
-		{
-		  double x;
-		  if (arg_x.is_complex_type ())
-		    x = abs (arg_x.complex_value ());
-		  else
-		    x = arg_x.double_value ();
-
-		  if (! error_state)
-		    {
-		      NDArray y;
-		      if (arg_y.is_complex_type ())
-			y = arg_y.complex_array_value ().abs ();
-		      else
-			y = arg_y.array_value ();
-
-		      if (! error_state)
-			retval = map_d_m (hypot, x, y);
-		    }
-		}
-	    }
-	  else if (y_dims == x_dims)
-	    {
-	      if (arg_x.is_sparse_type () && arg_y.is_sparse_type ())
-		{
-		  SparseMatrix x;
-		  if (arg_x.is_complex_type ())
-		    x = arg_x.sparse_complex_matrix_value ().abs ();
-		  else
-		    x = arg_x.sparse_matrix_value ();
-
-		  if (! error_state)
-		    {
-		      SparseMatrix y;
-		      if (arg_y.is_complex_type ())
-			y = arg_y.sparse_complex_matrix_value ().abs ();
-		      else
-			y = arg_y.sparse_matrix_value ();
-
-		      if (! error_state)
-			retval = map_s_s (hypot, x, y);
-		    }
-		}
-	      else if (is_float)
-		{
-		  FloatNDArray x;
-		  if (arg_x.is_complex_type ())
-		    x = arg_x.float_complex_array_value ().abs ();
-		  else
-		    x = arg_x.float_array_value ();
-
-		  if (! error_state)
-		    {
-		      FloatNDArray y;
-		      if (arg_y.is_complex_type ())
-			y = arg_y.float_complex_array_value ().abs ();
-		      else
-			y = arg_y.float_array_value ();
-
-		      if (! error_state)
-			retval = map_fm_fm (hypotf, x, y);
-		    }
-		}
-	      else
-		{
-		  NDArray x;
-		  if (arg_x.is_complex_type ())
-		    x = arg_x.complex_array_value ().abs ();
-		  else
-		    x = arg_x.array_value ();
-
-		  if (! error_state)
-		    {
-		      NDArray y;
-		      if (arg_y.is_complex_type ())
-			y = arg_y.complex_array_value ().abs ();
-		      else
-			y = arg_y.array_value ();
-
-		      if (! error_state)
-			retval = map_m_m (hypot, x, y);
-		    }
-		}
-	    }
-	  else
-	    error ("hypot: nonconformant matrices");
-	}
+        {
+          octave_value arg_x = args(0);
+          octave_value arg_y = args(1);
+
+          dim_vector x_dims = arg_x.dims ();
+          dim_vector y_dims = arg_y.dims ();
+
+          bool x_is_scalar = x_dims.all_ones ();
+          bool y_is_scalar = y_dims.all_ones ();
+
+          bool is_float = arg_y.is_single_type () || arg_x.is_single_type ();
+
+          if (y_is_scalar && x_is_scalar)
+            {
+              if (is_float)
+                {
+                  float x;
+                  if (arg_x.is_complex_type ())
+                    x = abs (arg_x.float_complex_value ());
+                  else
+                    x = arg_x.float_value ();
+
+                  if (! error_state)
+                    {
+                      float y;
+                      if (arg_y.is_complex_type ())
+                        y = abs (arg_y.float_complex_value ());
+                      else
+                        y = arg_y.float_value ();
+
+                      if (! error_state)
+                        retval = hypotf (x, y);
+                    }
+                }
+              else
+                {
+                  double x;
+                  if (arg_x.is_complex_type ())
+                    x = abs (arg_x.complex_value ());
+                  else
+                    x = arg_x.double_value ();
+
+                  if (! error_state)
+                    {
+                      double y;
+                      if (arg_y.is_complex_type ())
+                        y = abs (arg_y.complex_value ());
+                      else
+                        y = arg_y.double_value ();
+
+                      if (! error_state)
+                        retval = hypot (x, y);
+                    }
+                }
+            }
+          else if (y_is_scalar)
+            {
+              if (is_float)
+                {
+                  FloatNDArray x;
+                  if (arg_x.is_complex_type ())
+                    x = arg_x.float_complex_array_value ().abs ();
+                  else
+                    x = arg_x.float_array_value ();
+
+                  if (! error_state)
+                    {
+                      float y;
+                      if (arg_y.is_complex_type ())
+                        y = abs (arg_y.float_complex_value ());
+                      else
+                        y = arg_y.float_value ();
+
+                      if (! error_state)
+                        retval = map_fm_f (hypotf, x, y);
+                    }
+                }
+              else
+                {
+                  NDArray x;
+                  if (arg_x.is_complex_type ())
+                    x = arg_x.complex_array_value ().abs ();
+                  else
+                    x = arg_x.array_value ();
+
+                  if (! error_state)
+                    {
+                      double y;
+                      if (arg_y.is_complex_type ())
+                        y = abs (arg_y.complex_value ());
+                      else
+                        y = arg_y.double_value ();
+
+                      if (! error_state)
+                        retval = map_m_d (hypot, x, y);
+                    }
+                }
+            }
+          else if (x_is_scalar)
+            {
+              if (is_float)
+                {
+                  float x;
+                  if (arg_x.is_complex_type ())
+                    x = abs (arg_x.float_complex_value ());
+                  else
+                    x = arg_x.float_value ();
+
+                  if (! error_state)
+                    {
+                      FloatNDArray y;
+                      if (arg_y.is_complex_type ())
+                        y = arg_y.float_complex_array_value ().abs ();
+                      else
+                        y = arg_y.float_array_value ();
+
+                      if (! error_state)
+                        retval = map_f_fm (hypotf, x, y);
+                    }
+                }
+              else
+                {
+                  double x;
+                  if (arg_x.is_complex_type ())
+                    x = abs (arg_x.complex_value ());
+                  else
+                    x = arg_x.double_value ();
+
+                  if (! error_state)
+                    {
+                      NDArray y;
+                      if (arg_y.is_complex_type ())
+                        y = arg_y.complex_array_value ().abs ();
+                      else
+                        y = arg_y.array_value ();
+
+                      if (! error_state)
+                        retval = map_d_m (hypot, x, y);
+                    }
+                }
+            }
+          else if (y_dims == x_dims)
+            {
+              if (arg_x.is_sparse_type () && arg_y.is_sparse_type ())
+                {
+                  SparseMatrix x;
+                  if (arg_x.is_complex_type ())
+                    x = arg_x.sparse_complex_matrix_value ().abs ();
+                  else
+                    x = arg_x.sparse_matrix_value ();
+
+                  if (! error_state)
+                    {
+                      SparseMatrix y;
+                      if (arg_y.is_complex_type ())
+                        y = arg_y.sparse_complex_matrix_value ().abs ();
+                      else
+                        y = arg_y.sparse_matrix_value ();
+
+                      if (! error_state)
+                        retval = map_s_s (hypot, x, y);
+                    }
+                }
+              else if (is_float)
+                {
+                  FloatNDArray x;
+                  if (arg_x.is_complex_type ())
+                    x = arg_x.float_complex_array_value ().abs ();
+                  else
+                    x = arg_x.float_array_value ();
+
+                  if (! error_state)
+                    {
+                      FloatNDArray y;
+                      if (arg_y.is_complex_type ())
+                        y = arg_y.float_complex_array_value ().abs ();
+                      else
+                        y = arg_y.float_array_value ();
+
+                      if (! error_state)
+                        retval = map_fm_fm (hypotf, x, y);
+                    }
+                }
+              else
+                {
+                  NDArray x;
+                  if (arg_x.is_complex_type ())
+                    x = arg_x.complex_array_value ().abs ();
+                  else
+                    x = arg_x.array_value ();
+
+                  if (! error_state)
+                    {
+                      NDArray y;
+                      if (arg_y.is_complex_type ())
+                        y = arg_y.complex_array_value ().abs ();
+                      else
+                        y = arg_y.array_value ();
+
+                      if (! error_state)
+                        retval = map_m_m (hypot, x, y);
+                    }
+                }
+            }
+          else
+            error ("hypot: nonconformant matrices");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1025,38 +1025,38 @@ and @var{e} is an integer.  If\n\
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       if (nargout < 2)
         retval(0) = args(0).log2 ();
       else if (args(0).is_single_type ())
-	{
-	  if (args(0).is_real_type ())
-	    {
-	      FloatNDArray f;
-	      FloatNDArray x = args(0).float_array_value ();
-	      // FIXME -- should E be an int value?
-	      FloatMatrix e;
-	      map_2_xlog2 (x, f, e);
-	      retval (1) = e;
-	      retval (0) = f;
-	    }
-	  else if (args(0).is_complex_type ())
-	    {
-	      FloatComplexNDArray f;
-	      FloatComplexNDArray x = args(0).float_complex_array_value ();
-	      // FIXME -- should E be an int value?
-	      FloatNDArray e;
-	      map_2_xlog2 (x, f, e);
-	      retval (1) = e;
-	      retval (0) = f;
-	    }
-	}
+        {
+          if (args(0).is_real_type ())
+            {
+              FloatNDArray f;
+              FloatNDArray x = args(0).float_array_value ();
+              // FIXME -- should E be an int value?
+              FloatMatrix e;
+              map_2_xlog2 (x, f, e);
+              retval (1) = e;
+              retval (0) = f;
+            }
+          else if (args(0).is_complex_type ())
+            {
+              FloatComplexNDArray f;
+              FloatComplexNDArray x = args(0).float_complex_array_value ();
+              // FIXME -- should E be an int value?
+              FloatNDArray e;
+              map_2_xlog2 (x, f, e);
+              retval (1) = e;
+              retval (0) = f;
+            }
+        }
       else if (args(0).is_real_type ())
         {
           NDArray f;
           NDArray x = args(0).array_value ();
           // FIXME -- should E be an int value?
           Matrix e;
           map_2_xlog2 (x, f, e);
           retval (1) = e;
@@ -1121,159 +1121,159 @@ sign as @var{x}.  If @var{y} is zero, th
       dim_vector x_dims = arg_x.dims ();
 
       bool y_is_scalar = y_dims.all_ones ();
       bool x_is_scalar = x_dims.all_ones ();
 
       bool is_float = arg_y.is_single_type () || arg_x.is_single_type ();
 
       if (y_is_scalar && x_is_scalar)
-	{
-	  if (is_float)
-	    {
-	      float y = arg_y.float_value ();
-
-	      if (! error_state)
-		{
-		  float x = arg_x.float_value ();
-
-		  if (! error_state)
-		    retval = fmod (x, y);
-		}
-	    }
-	  else
-	    {
-	      double y = arg_y.double_value ();
-
-	      if (! error_state)
-		{
-		  double x = arg_x.double_value ();
-
-		  if (! error_state)
-		    retval = fmod (x, y);
-		}
-	    }
-	}
+        {
+          if (is_float)
+            {
+              float y = arg_y.float_value ();
+
+              if (! error_state)
+                {
+                  float x = arg_x.float_value ();
+
+                  if (! error_state)
+                    retval = fmod (x, y);
+                }
+            }
+          else
+            {
+              double y = arg_y.double_value ();
+
+              if (! error_state)
+                {
+                  double x = arg_x.double_value ();
+
+                  if (! error_state)
+                    retval = fmod (x, y);
+                }
+            }
+        }
       else if (y_is_scalar)
-	{
-	  if (is_float)
-	    {
-	      float y = arg_y.float_value ();
-
-	      if (! error_state)
-		{
-		  FloatNDArray x = arg_x.float_array_value ();
-
-		  if (! error_state)
-		    retval = map_fm_f (fmodf, x, y);
-		}
-	    }
-	  else
-	    {
-	      double y = arg_y.double_value ();
-
-	      if (! error_state)
-		{
-		  if (arg_x.is_sparse_type ())
-		    {
-		      SparseMatrix x = arg_x.sparse_matrix_value ();
-
-		      if (! error_state)
-			retval = map_s_d (fmod, x, y);
-		    }
-		  else
-		    {
-		      NDArray x = arg_x.array_value ();
-
-		      if (! error_state)
-			retval = map_m_d (fmod, x, y);
-		    }
-		}
-	    }
-	}
+        {
+          if (is_float)
+            {
+              float y = arg_y.float_value ();
+
+              if (! error_state)
+                {
+                  FloatNDArray x = arg_x.float_array_value ();
+
+                  if (! error_state)
+                    retval = map_fm_f (fmodf, x, y);
+                }
+            }
+          else
+            {
+              double y = arg_y.double_value ();
+
+              if (! error_state)
+                {
+                  if (arg_x.is_sparse_type ())
+                    {
+                      SparseMatrix x = arg_x.sparse_matrix_value ();
+
+                      if (! error_state)
+                        retval = map_s_d (fmod, x, y);
+                    }
+                  else
+                    {
+                      NDArray x = arg_x.array_value ();
+
+                      if (! error_state)
+                        retval = map_m_d (fmod, x, y);
+                    }
+                }
+            }
+        }
       else if (x_is_scalar)
-	{
-	  if (arg_y.is_sparse_type ())
-	    {
-	      SparseMatrix y = arg_y.sparse_matrix_value ();
-
-	      if (! error_state)
-		{
-		  double x = arg_x.double_value ();
-
-		  if (! error_state)
-		    retval = map_d_s (fmod, x, y);
-		}
-	    }
-	  else if (is_float)
-	    {
-	      FloatNDArray y = arg_y.float_array_value ();
-
-	      if (! error_state)
-		{
-		  float x = arg_x.float_value ();
-
-		  if (! error_state)
-		    retval = map_f_fm (fmodf, x, y);
-		}
-	    }
-	  else
-	    {
-	      NDArray y = arg_y.array_value ();
-
-	      if (! error_state)
-		{
-		  double x = arg_x.double_value ();
-
-		  if (! error_state)
-		    retval = map_d_m (fmod, x, y);
-		}
-	    }
-	}
+        {
+          if (arg_y.is_sparse_type ())
+            {
+              SparseMatrix y = arg_y.sparse_matrix_value ();
+
+              if (! error_state)
+                {
+                  double x = arg_x.double_value ();
+
+                  if (! error_state)
+                    retval = map_d_s (fmod, x, y);
+                }
+            }
+          else if (is_float)
+            {
+              FloatNDArray y = arg_y.float_array_value ();
+
+              if (! error_state)
+                {
+                  float x = arg_x.float_value ();
+
+                  if (! error_state)
+                    retval = map_f_fm (fmodf, x, y);
+                }
+            }
+          else
+            {
+              NDArray y = arg_y.array_value ();
+
+              if (! error_state)
+                {
+                  double x = arg_x.double_value ();
+
+                  if (! error_state)
+                    retval = map_d_m (fmod, x, y);
+                }
+            }
+        }
       else if (y_dims == x_dims)
-	{
-	  if (arg_y.is_sparse_type () || arg_x.is_sparse_type ())
-	    {
-	      SparseMatrix y = arg_y.sparse_matrix_value ();
-
-	      if (! error_state)
-		{
-		  SparseMatrix x = arg_x.sparse_matrix_value ();
-
-		  if (! error_state)
-		    retval = map_s_s (fmod, x, y);
-		}
-	    }
-	  else if (is_float)
-	    {
-	      FloatNDArray y = arg_y.float_array_value ();
-
-	      if (! error_state)
-		{
-		  FloatNDArray x = arg_x.float_array_value ();
-
-		  if (! error_state)
-		    retval = map_fm_fm (fmodf, x, y);
-		}
-	    }
-	  else
-	    {
-	      NDArray y = arg_y.array_value ();
-
-	      if (! error_state)
-		{
-		  NDArray x = arg_x.array_value ();
-
-		  if (! error_state)
-		    retval = map_m_m (fmod, x, y);
-		}
-	    }
-	}
+        {
+          if (arg_y.is_sparse_type () || arg_x.is_sparse_type ())
+            {
+              SparseMatrix y = arg_y.sparse_matrix_value ();
+
+              if (! error_state)
+                {
+                  SparseMatrix x = arg_x.sparse_matrix_value ();
+
+                  if (! error_state)
+                    retval = map_s_s (fmod, x, y);
+                }
+            }
+          else if (is_float)
+            {
+              FloatNDArray y = arg_y.float_array_value ();
+
+              if (! error_state)
+                {
+                  FloatNDArray x = arg_x.float_array_value ();
+
+                  if (! error_state)
+                    retval = map_fm_fm (fmodf, x, y);
+                }
+            }
+          else
+            {
+              NDArray y = arg_y.array_value ();
+
+              if (! error_state)
+                {
+                  NDArray x = arg_x.array_value ();
+
+                  if (! error_state)
+                    retval = map_m_m (fmod, x, y);
+                }
+            }
+        }
       else
-	error ("fmod: nonconformant matrices");
+        error ("fmod: nonconformant matrices");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1313,162 +1313,162 @@ sign as @var{x}.  If @var{y} is zero, th
   bool isnative = false; \
   bool isdouble = false; \
   \
   if (nargin > 1 && args(nargin - 1).is_string ()) \
     { \
       std::string str = args(nargin - 1).string_value (); \
       \
       if (! error_state) \
-	{ \
-	  if (str == "native") \
-	    isnative = true; \
-	  else if (str == "double") \
+        { \
+          if (str == "native") \
+            isnative = true; \
+          else if (str == "double") \
             isdouble = true; \
           else \
-	    error ("sum: unrecognized string argument"); \
+            error ("sum: unrecognized string argument"); \
           nargin --; \
-	} \
+        } \
     } \
   \
   if (nargin == 1 || nargin == 2) \
     { \
       octave_value arg = args(0); \
  \
       int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
       if (! error_state) \
-	{ \
-	  if (dim >= -1) \
-	    { \
-	      if (arg.is_sparse_type ()) \
-		{ \
-		  if (arg.is_real_type ()) \
-		    { \
-		      SparseMatrix tmp = arg.sparse_matrix_value (); \
-		      \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		  else \
-		    { \
-		      SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
+        { \
+          if (dim >= -1) \
+            { \
+              if (arg.is_sparse_type ()) \
+                { \
+                  if (arg.is_real_type ()) \
+                    { \
+                      SparseMatrix tmp = arg.sparse_matrix_value (); \
                       \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		} \
-	      else \
-		{ \
-		  if (isnative)	\
-		    { \
-		      if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
-		      else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                  else \
+                    { \
+                      SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
+                      \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                } \
+              else \
+                { \
+                  if (isnative) \
+                    { \
+                      if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
+                      else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, uint32, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, uint64, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, int8, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
                       else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
                       else if (arg.is_bool_type ()) \
                         { \
                           boolNDArray tmp = arg.bool_array_value (); \
                           if (! error_state) \
                             retval = boolNDArray (tmp.BOOL_FCN (dim)); \
                         } \
                       else if (arg.is_char_matrix ()) \
                         { \
-			  error (#FCN, ": invalid char type"); \
-			} \
-		      else if (!isdouble && arg.is_single_type ()) \
+                          error (#FCN, ": invalid char type"); \
+                        } \
+                      else if (!isdouble && arg.is_single_type ()) \
                         { \
-	                  if (arg.is_complex_type ()) \
-		            { \
-		              FloatComplexNDArray tmp = \
-				arg.float_complex_array_value (); \
+                          if (arg.is_complex_type ()) \
+                            { \
+                              FloatComplexNDArray tmp = \
+                                arg.float_complex_array_value (); \
                               \
-		              if (! error_state) \
-		                retval = tmp.FCN (dim); \
-		            } \
-	                  else if (arg.is_real_type ()) \
-		            { \
-		              FloatNDArray tmp = arg.float_array_value (); \
+                              if (! error_state) \
+                                retval = tmp.FCN (dim); \
+                            } \
+                          else if (arg.is_real_type ()) \
+                            { \
+                              FloatNDArray tmp = arg.float_array_value (); \
                               \
-		              if (! error_state) \
-		                retval = tmp.FCN (dim); \
-		            } \
-			} \
-	              else if (arg.is_complex_type ()) \
-		        { \
-		          ComplexNDArray tmp = arg.complex_array_value (); \
+                              if (! error_state) \
+                                retval = tmp.FCN (dim); \
+                            } \
+                        } \
+                      else if (arg.is_complex_type ()) \
+                        { \
+                          ComplexNDArray tmp = arg.complex_array_value (); \
                           \
-		          if (! error_state) \
-		            retval = tmp.FCN (dim); \
-		        } \
-	              else if (arg.is_real_type ()) \
-		        { \
-		          NDArray tmp = arg.array_value (); \
+                          if (! error_state) \
+                            retval = tmp.FCN (dim); \
+                        } \
+                      else if (arg.is_real_type ()) \
+                        { \
+                          NDArray tmp = arg.array_value (); \
                           \
-		          if (! error_state) \
-		            retval = tmp.FCN (dim); \
-		        } \
+                          if (! error_state) \
+                            retval = tmp.FCN (dim); \
+                        } \
                       else \
-		        { \
-		          gripe_wrong_type_arg (#FCN, arg); \
-		          return retval; \
-		        } \
+                        { \
+                          gripe_wrong_type_arg (#FCN, arg); \
+                          return retval; \
+                        } \
                     } \
                   else if (arg.is_bool_type ()) \
                     { \
                       boolNDArray tmp = arg.bool_array_value (); \
                       if (! error_state) \
                         retval = tmp.FCN (dim); \
                     } \
-		  else if (!isdouble && arg.is_single_type ()) \
-		    { \
-	              if (arg.is_real_type ()) \
-		        { \
-		          FloatNDArray tmp = arg.float_array_value (); \
+                  else if (!isdouble && arg.is_single_type ()) \
+                    { \
+                      if (arg.is_real_type ()) \
+                        { \
+                          FloatNDArray tmp = arg.float_array_value (); \
                           \
-		          if (! error_state) \
-		            retval = tmp.FCN (dim); \
-		        } \
-	              else if (arg.is_complex_type ()) \
-		        { \
-		          FloatComplexNDArray tmp = \
-			    arg.float_complex_array_value (); \
+                          if (! error_state) \
+                            retval = tmp.FCN (dim); \
+                        } \
+                      else if (arg.is_complex_type ()) \
+                        { \
+                          FloatComplexNDArray tmp = \
+                            arg.float_complex_array_value (); \
                           \
-		          if (! error_state) \
-		            retval = tmp.FCN (dim); \
-		        } \
-		    } \
-	          else if (arg.is_real_type ()) \
-		    { \
-		      NDArray tmp = arg.array_value (); \
+                          if (! error_state) \
+                            retval = tmp.FCN (dim); \
+                        } \
+                    } \
+                  else if (arg.is_real_type ()) \
+                    { \
+                      NDArray tmp = arg.array_value (); \
                       \
-		      if (! error_state) \
-		        retval = tmp.FCN (dim); \
-		    } \
-	          else if (arg.is_complex_type ()) \
-		    { \
-		      ComplexNDArray tmp = arg.complex_array_value (); \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                  else if (arg.is_complex_type ()) \
+                    { \
+                      ComplexNDArray tmp = arg.complex_array_value (); \
                       \
-		      if (! error_state) \
-		        retval = tmp.FCN (dim); \
-		    } \
-	          else \
-		    { \
-		      gripe_wrong_type_arg (#FCN, arg); \
-		      return retval; \
-		    } \
-		} \
-	    } \
-	  else \
-	    error (#FCN ": invalid dimension argument = %d", dim + 1); \
-	} \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                  else \
+                    { \
+                      gripe_wrong_type_arg (#FCN, arg); \
+                      return retval; \
+                    } \
+                } \
+            } \
+          else \
+            error (#FCN ": invalid dimension argument = %d", dim + 1); \
+        } \
       \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 #define DATA_REDUCTION(FCN) \
@@ -1479,76 +1479,76 @@ sign as @var{x}.  If @var{y} is zero, th
  \
   if (nargin == 1 || nargin == 2) \
     { \
       octave_value arg = args(0); \
  \
       int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
       if (! error_state) \
-	{ \
-	  if (dim >= -1) \
-	    { \
-	      if (arg.is_real_type ()) \
-		{ \
-		  if (arg.is_sparse_type ()) \
-		    { \
-		      SparseMatrix tmp = arg.sparse_matrix_value (); \
+        { \
+          if (dim >= -1) \
+            { \
+              if (arg.is_real_type ()) \
+                { \
+                  if (arg.is_sparse_type ()) \
+                    { \
+                      SparseMatrix tmp = arg.sparse_matrix_value (); \
  \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		  else if (arg.is_single_type ()) \
-		    { \
-		      FloatNDArray tmp = arg.float_array_value (); \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                  else if (arg.is_single_type ()) \
+                    { \
+                      FloatNDArray tmp = arg.float_array_value (); \
  \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		  else \
-		    { \
-		      NDArray tmp = arg.array_value (); \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                  else \
+                    { \
+                      NDArray tmp = arg.array_value (); \
  \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		} \
-	      else if (arg.is_complex_type ()) \
-		{ \
-		  if (arg.is_sparse_type ()) \
-		    { \
-		      SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                } \
+              else if (arg.is_complex_type ()) \
+                { \
+                  if (arg.is_sparse_type ()) \
+                    { \
+                      SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
  \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		  else if (arg.is_single_type ()) \
-		    { \
-		      FloatComplexNDArray tmp = arg.float_complex_array_value (); \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                  else if (arg.is_single_type ()) \
+                    { \
+                      FloatComplexNDArray tmp = arg.float_complex_array_value (); \
  \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		  else \
-		    { \
-		      ComplexNDArray tmp = arg.complex_array_value (); \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                  else \
+                    { \
+                      ComplexNDArray tmp = arg.complex_array_value (); \
  \
-		      if (! error_state) \
-			retval = tmp.FCN (dim); \
-		    } \
-		} \
-	      else \
-		{ \
-		  gripe_wrong_type_arg (#FCN, arg); \
-		  return retval; \
-		} \
-	    } \
-	  else \
-	    error (#FCN ": invalid dimension argument = %d", dim + 1); \
-	} \
+                      if (! error_state) \
+                        retval = tmp.FCN (dim); \
+                    } \
+                } \
+              else \
+                { \
+                  gripe_wrong_type_arg (#FCN, arg); \
+                  return retval; \
+                } \
+            } \
+          else \
+            error (#FCN ": invalid dimension argument = %d", dim + 1); \
+        } \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (cumprod, args, ,
   "-*- texinfo -*-\n\
@@ -1606,44 +1606,44 @@ The \"native\" argument implies the summ
   bool isnative = false;
   bool isdouble = false;
 
   if (nargin > 1 && args(nargin - 1).is_string ())
     {
       std::string str = args(nargin - 1).string_value ();
 
       if (! error_state)
-	{
-	  if (str == "native")
-	    isnative = true;
-	  else if (str == "double")
+        {
+          if (str == "native")
+            isnative = true;
+          else if (str == "double")
             isdouble = true;
           else
-	    error ("sum: unrecognized string argument");
+            error ("sum: unrecognized string argument");
           nargin --;
-	}
+        }
     }
 
   if (error_state)
     return retval;
 
   if (nargin == 1 || nargin == 2)
     {
       octave_value arg = args(0);
 
       int dim = -1;
       if (nargin == 2)
         {
           dim = args(1).int_value () - 1;
           if (dim < 0)
-	    error ("cumsum: invalid dimension argument = %d", dim + 1);
+            error ("cumsum: invalid dimension argument = %d", dim + 1);
         }
 
       if (! error_state)
-	{
+        {
           switch (arg.builtin_type ())
             {
             case btyp_double:
               if (arg.is_sparse_type ())
                 retval = arg.sparse_matrix_value ().cumsum (dim);
               else
                 retval = arg.array_value ().cumsum (dim);
               break;
@@ -1700,17 +1700,17 @@ The \"native\" argument implies the summ
                   else
                     retval = cs;
                 }
               break;
 
             default:
               gripe_wrong_type_arg ("cumsum", arg);
             }
-	}
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1765,19 +1765,19 @@ Given a matrix argument, instead of a ve
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).diag();
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       octave_idx_type k = args(1).int_value ();
 
       if (error_state)
-	error ("diag: invalid second argument");      
+        error ("diag: invalid second argument");      
       else
-	retval = args(0).diag(k);
+        retval = args(0).diag(k);
     }
   else if (nargin == 3)
     {
       octave_value arg0 = args(0);
       if (arg0.ndims () == 2 && (args(0).rows () == 1 || args(0).columns () == 1))
         {
           octave_idx_type m = args(1).int_value (), n = args(2).int_value ();
           if (! error_state)
@@ -1890,40 +1890,40 @@ omitted, it defaults to the first non-si
 
 #define SINGLE_TYPE_CONCAT(TYPE, EXTRACTOR) \
   do \
     { \
       int dv_len = dv.length (); \
       Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0); \
       \
       for (int j = 1; j < n_args; j++) \
-	{ \
-	  octave_quit (); \
-	  \
-	  TYPE ra = args(j).EXTRACTOR ();	\
-	  \
-	  if (! error_state) \
-	    { \
-	      result.insert (ra, ra_idx); \
-	      \
-	      if (error_state) \
-	        return retval; \
-	      \
-	      dim_vector dv_tmp = args (j).dims (); \
-	      \
-	      if (dim >= dv_len) \
-	        { \
-		  if (j > 1) \
-		    error ("%s: indexing error", fname.c_str ()); \
-		  break; \
-		} \
-	      else \
-		ra_idx (dim) += (dim < dv_tmp.length () ? dv_tmp (dim) : 1); \
-	    } \
-	} \
+        { \
+          octave_quit (); \
+          \
+          TYPE ra = args(j).EXTRACTOR ();       \
+          \
+          if (! error_state) \
+            { \
+              result.insert (ra, ra_idx); \
+              \
+              if (error_state) \
+                return retval; \
+              \
+              dim_vector dv_tmp = args (j).dims (); \
+              \
+              if (dim >= dv_len) \
+                { \
+                  if (j > 1) \
+                    error ("%s: indexing error", fname.c_str ()); \
+                  break; \
+                } \
+              else \
+                ra_idx (dim) += (dim < dv_tmp.length () ? dv_tmp (dim) : 1); \
+            } \
+        } \
     } \
  while (0)
 
 #define DO_SINGLE_TYPE_CONCAT(TYPE, EXTRACTOR) \
   do \
     { \
       TYPE result (dv); \
       \
@@ -1944,176 +1944,176 @@ do_cat (const octave_value_list& args, s
     retval = Matrix ();
   else if (n_args == 2)
     retval = args(1);
   else if (n_args > 2)
     {
       octave_idx_type dim = args(0).int_value () - 1;
 
       if (error_state)
-	{
-	  error ("cat: expecting first argument to be a integer");
-	  return retval;
-	}
+        {
+          error ("cat: expecting first argument to be a integer");
+          return retval;
+        }
   
       if (dim >= 0)
-	{
- 	  
- 	  dim_vector  dv = args(1).dims ();
-	  std::string result_type = args(1).class_name ();
-	  
-	  bool all_sq_strings_p = args(1).is_sq_string ();
-	  bool all_dq_strings_p = args(1).is_dq_string ();
-	  bool all_real_p = args(1).is_real_type ();
-	  bool any_sparse_p = args(1).is_sparse_type();
-
- 	  for (int i = 2; i < args.length (); i++)
-  	    {
- 	      // add_dims constructs a dimension vector which holds the
-	      // dimensions of the final array after concatenation.
-
-	      if (! dv.concat (args(i).dims (), dim))
-		{
-		  // Dimensions do not match. 
-		  error ("cat: dimension mismatch");
-		  return retval;
-		}
-	      
-	      result_type = 
-		get_concat_class (result_type, args(i).class_name ());
-
-	      if (all_sq_strings_p && ! args(i).is_sq_string ())
-		all_sq_strings_p = false;
-	      if (all_dq_strings_p && ! args(i).is_dq_string ())
-		all_dq_strings_p = false;
-	      if (all_real_p && ! args(i).is_real_type ())
-		all_real_p = false;
-	      if (!any_sparse_p && args(i).is_sparse_type ())
-		any_sparse_p = true;
-	    }
-
-	  if (result_type == "double")
-	    {
-	      if (any_sparse_p)
-		{	    
-		  if (all_real_p)
-		    DO_SINGLE_TYPE_CONCAT (SparseMatrix, sparse_matrix_value);
-		  else
-		    DO_SINGLE_TYPE_CONCAT (SparseComplexMatrix, sparse_complex_matrix_value);
-		}
-	      else
-		{
-		  if (all_real_p)
-		    DO_SINGLE_TYPE_CONCAT (NDArray, array_value);
-		  else
-		    DO_SINGLE_TYPE_CONCAT (ComplexNDArray, complex_array_value);
-		}
-	    }
-	  else if (result_type == "single")
-	    {
-	      if (all_real_p)
-		DO_SINGLE_TYPE_CONCAT (FloatNDArray, float_array_value);
-	      else
-		DO_SINGLE_TYPE_CONCAT (FloatComplexNDArray, 
-				       float_complex_array_value);
-	    }
-	  else if (result_type == "char")
-	    {
-	      char type = all_dq_strings_p ? '"' : '\'';
-
-	      maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
-
-	      charNDArray result (dv, Vstring_fill_char);
-
-	      SINGLE_TYPE_CONCAT (charNDArray, char_array_value);
-
-	      retval = octave_value (result, type);
-	    }
-	  else if (result_type == "logical")
-	    {
-	      if (any_sparse_p)
-		DO_SINGLE_TYPE_CONCAT (SparseBoolMatrix, sparse_bool_matrix_value);
-	      else
-		DO_SINGLE_TYPE_CONCAT (boolNDArray, bool_array_value);
-	    }
-	  else if (result_type == "int8")
-	    DO_SINGLE_TYPE_CONCAT (int8NDArray, int8_array_value);
-	  else if (result_type == "int16")
-	    DO_SINGLE_TYPE_CONCAT (int16NDArray, int16_array_value);
-	  else if (result_type == "int32")
-	    DO_SINGLE_TYPE_CONCAT (int32NDArray, int32_array_value);
-	  else if (result_type == "int64")
-	    DO_SINGLE_TYPE_CONCAT (int64NDArray, int64_array_value);
-	  else if (result_type == "uint8")
-	    DO_SINGLE_TYPE_CONCAT (uint8NDArray, uint8_array_value);
-	  else if (result_type == "uint16")
-	    DO_SINGLE_TYPE_CONCAT (uint16NDArray, uint16_array_value);
-	  else if (result_type == "uint32")
-	    DO_SINGLE_TYPE_CONCAT (uint32NDArray, uint32_array_value);
-	  else if (result_type == "uint64")
-	    DO_SINGLE_TYPE_CONCAT (uint64NDArray, uint64_array_value);
-	  else
-	    {
-	      // The lines below might seem crazy, since we take a copy
-	      // of the first argument, resize it to be empty and then resize
-	      // it to be full. This is done since it means that there is no
-	      // recopying of data, as would happen if we used a single resize.
-	      // It should be noted that resize operation is also significantly 
-	      // slower than the do_cat_op function, so it makes sense to have
-	      // an empty matrix and copy all data.
-	      //
-	      // We might also start with a empty octave_value using
-	      //   tmp = octave_value_typeinfo::lookup_type 
-	      //                                (args(1).type_name());
-	      // and then directly resize. However, for some types there might
-	      // be some additional setup needed, and so this should be avoided.
-
-	      octave_value tmp = args (1);
-	      tmp = tmp.resize (dim_vector (0,0)).resize (dv);
-
-	      if (error_state)
-		return retval;
-
-	      int dv_len = dv.length ();
-	      Array<octave_idx_type> ra_idx (dv_len, 0);
-
-	      for (int j = 1; j < n_args; j++)
-		{
-		  // Can't fast return here to skip empty matrices as something
-		  // like cat(1,[],single([])) must return an empty matrix of
-		  // the right type.
-		  tmp = do_cat_op (tmp, args (j), ra_idx);
-
-		  if (error_state)
-		    return retval;
-
-		  dim_vector dv_tmp = args (j).dims ();
-
-		  if (dim >= dv_len)
-		    {
-		      if (j > 1)
-			error ("%s: indexing error", fname.c_str ());
-		      break;
-		    }
-		  else
-		    ra_idx (dim) += (dim < dv_tmp.length () ? 
-				     dv_tmp (dim) : 1);
-		}
-	      retval = tmp;
-	    }
-
-	  if (! error_state)
-	    {
-	      // Reshape, chopping trailing singleton dimensions
-	      dv.chop_trailing_singletons ();
-	      retval = retval.reshape (dv);
-	    }
-	}
+        {
+          
+          dim_vector  dv = args(1).dims ();
+          std::string result_type = args(1).class_name ();
+          
+          bool all_sq_strings_p = args(1).is_sq_string ();
+          bool all_dq_strings_p = args(1).is_dq_string ();
+          bool all_real_p = args(1).is_real_type ();
+          bool any_sparse_p = args(1).is_sparse_type();
+
+          for (int i = 2; i < args.length (); i++)
+            {
+              // add_dims constructs a dimension vector which holds the
+              // dimensions of the final array after concatenation.
+
+              if (! dv.concat (args(i).dims (), dim))
+                {
+                  // Dimensions do not match. 
+                  error ("cat: dimension mismatch");
+                  return retval;
+                }
+              
+              result_type = 
+                get_concat_class (result_type, args(i).class_name ());
+
+              if (all_sq_strings_p && ! args(i).is_sq_string ())
+                all_sq_strings_p = false;
+              if (all_dq_strings_p && ! args(i).is_dq_string ())
+                all_dq_strings_p = false;
+              if (all_real_p && ! args(i).is_real_type ())
+                all_real_p = false;
+              if (!any_sparse_p && args(i).is_sparse_type ())
+                any_sparse_p = true;
+            }
+
+          if (result_type == "double")
+            {
+              if (any_sparse_p)
+                {           
+                  if (all_real_p)
+                    DO_SINGLE_TYPE_CONCAT (SparseMatrix, sparse_matrix_value);
+                  else
+                    DO_SINGLE_TYPE_CONCAT (SparseComplexMatrix, sparse_complex_matrix_value);
+                }
+              else
+                {
+                  if (all_real_p)
+                    DO_SINGLE_TYPE_CONCAT (NDArray, array_value);
+                  else
+                    DO_SINGLE_TYPE_CONCAT (ComplexNDArray, complex_array_value);
+                }
+            }
+          else if (result_type == "single")
+            {
+              if (all_real_p)
+                DO_SINGLE_TYPE_CONCAT (FloatNDArray, float_array_value);
+              else
+                DO_SINGLE_TYPE_CONCAT (FloatComplexNDArray, 
+                                       float_complex_array_value);
+            }
+          else if (result_type == "char")
+            {
+              char type = all_dq_strings_p ? '"' : '\'';
+
+              maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
+
+              charNDArray result (dv, Vstring_fill_char);
+
+              SINGLE_TYPE_CONCAT (charNDArray, char_array_value);
+
+              retval = octave_value (result, type);
+            }
+          else if (result_type == "logical")
+            {
+              if (any_sparse_p)
+                DO_SINGLE_TYPE_CONCAT (SparseBoolMatrix, sparse_bool_matrix_value);
+              else
+                DO_SINGLE_TYPE_CONCAT (boolNDArray, bool_array_value);
+            }
+          else if (result_type == "int8")
+            DO_SINGLE_TYPE_CONCAT (int8NDArray, int8_array_value);
+          else if (result_type == "int16")
+            DO_SINGLE_TYPE_CONCAT (int16NDArray, int16_array_value);
+          else if (result_type == "int32")
+            DO_SINGLE_TYPE_CONCAT (int32NDArray, int32_array_value);
+          else if (result_type == "int64")
+            DO_SINGLE_TYPE_CONCAT (int64NDArray, int64_array_value);
+          else if (result_type == "uint8")
+            DO_SINGLE_TYPE_CONCAT (uint8NDArray, uint8_array_value);
+          else if (result_type == "uint16")
+            DO_SINGLE_TYPE_CONCAT (uint16NDArray, uint16_array_value);
+          else if (result_type == "uint32")
+            DO_SINGLE_TYPE_CONCAT (uint32NDArray, uint32_array_value);
+          else if (result_type == "uint64")
+            DO_SINGLE_TYPE_CONCAT (uint64NDArray, uint64_array_value);
+          else
+            {
+              // The lines below might seem crazy, since we take a copy
+              // of the first argument, resize it to be empty and then resize
+              // it to be full. This is done since it means that there is no
+              // recopying of data, as would happen if we used a single resize.
+              // It should be noted that resize operation is also significantly 
+              // slower than the do_cat_op function, so it makes sense to have
+              // an empty matrix and copy all data.
+              //
+              // We might also start with a empty octave_value using
+              //   tmp = octave_value_typeinfo::lookup_type 
+              //                                (args(1).type_name());
+              // and then directly resize. However, for some types there might
+              // be some additional setup needed, and so this should be avoided.
+
+              octave_value tmp = args (1);
+              tmp = tmp.resize (dim_vector (0,0)).resize (dv);
+
+              if (error_state)
+                return retval;
+
+              int dv_len = dv.length ();
+              Array<octave_idx_type> ra_idx (dv_len, 0);
+
+              for (int j = 1; j < n_args; j++)
+                {
+                  // Can't fast return here to skip empty matrices as something
+                  // like cat(1,[],single([])) must return an empty matrix of
+                  // the right type.
+                  tmp = do_cat_op (tmp, args (j), ra_idx);
+
+                  if (error_state)
+                    return retval;
+
+                  dim_vector dv_tmp = args (j).dims ();
+
+                  if (dim >= dv_len)
+                    {
+                      if (j > 1)
+                        error ("%s: indexing error", fname.c_str ());
+                      break;
+                    }
+                  else
+                    ra_idx (dim) += (dim < dv_tmp.length () ? 
+                                     dv_tmp (dim) : 1);
+                }
+              retval = tmp;
+            }
+
+          if (! error_state)
+            {
+              // Reshape, chopping trailing singleton dimensions
+              dv.chop_trailing_singletons ();
+              retval = retval.reshape (dv);
+            }
+        }
       else
-	error ("%s: invalid dimension argument", fname.c_str ());
+        error ("%s: invalid dimension argument", fname.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (horzcat, args, ,
@@ -2344,22 +2344,22 @@ do_permute (const octave_value_list& arg
       Array<int> vec = args(1).int_vector_value ();
 
       // FIXME -- maybe we should create an idx_vector object
       // here and pass that to permute?
 
       int n = vec.length ();
 
       for (int i = 0; i < n; i++)
-	vec(i)--;
+        vec(i)--;
 
       octave_value ret = args(0).permute (vec, inv);
 
       if (! error_state)
-	retval = ret;
+        retval = ret;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (permute, args, ,
@@ -2497,54 +2497,54 @@ returns the number of columns in the giv
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       const dim_vector dimensions = args(0).dims ();
 
       if (nargout > 1)
-	{
+        {
           const dim_vector rdims = dimensions.redim (nargout);
           retval.resize (nargout);
           for (int i = 0; i < nargout; i++)
             retval(i) = rdims(i);
-	}
+        }
       else
-	{
+        {
           int ndims = dimensions.length ();
 
           NoAlias<Matrix> m (1, ndims);
 
-	  for (int i = 0; i < ndims; i++)
-	    m(i) = dimensions(i);
-
-	  retval(0) = m;
-	}
+          for (int i = 0; i < ndims; i++)
+            m(i) = dimensions(i);
+
+          retval(0) = m;
+        }
     }
   else if (nargin == 2 && nargout < 2)
     {
       octave_idx_type nd = args(1).int_value (true);
 
       if (error_state)
-	error ("size: expecting scalar as second argument");
+        error ("size: expecting scalar as second argument");
       else
-	{
-	  const dim_vector dv = args(0).dims ();
-
-	  if (nd > 0)
-	    {
-	      if (nd <= dv.length ())
-		retval(0) = dv(nd-1);
-	      else 
-		retval(0) = 1;
-	    }
-	  else
-	    error ("size: requested dimension (= %d) out of range", nd);
-	}
+        {
+          const dim_vector dv = args(0).dims ();
+
+          if (nd > 0)
+            {
+              if (nd <= dv.length ())
+                retval(0) = dv(nd-1);
+              else 
+                retval(0) = 1;
+            }
+          else
+            error ("size: requested dimension (= %d) out of range", nd);
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (size_equal, args, ,
@@ -2566,20 +2566,20 @@ Called with a single or no argument, siz
     {
       dim_vector a_dims = args(0).dims ();
 
       for (int i = 1; i < nargin; ++i)
         {
           dim_vector b_dims = args(i).dims ();
 
           if (a_dims != b_dims)
-	    {
-	      retval = false;
-	      break;
-	    }
+            {
+              retval = false;
+              break;
+            }
         }
     }
 
   return retval;
 }
 
 DEFUN (nnz, args, ,
    "-*- texinfo -*-\n\
@@ -2693,46 +2693,46 @@ the same as 'double'.  Otherwise, 'extra
   bool isdouble = false;
   bool isextra = false;
 
   if (nargin > 1 && args(nargin - 1).is_string ())
     {
       std::string str = args(nargin - 1).string_value ();
 
       if (! error_state)
-	{
-	  if (str == "native")
-	    isnative = true;
-	  else if (str == "double")
+        {
+          if (str == "native")
+            isnative = true;
+          else if (str == "double")
             isdouble = true;
           else if (str == "extra")
             isextra = true;
           else
-	    error ("sum: unrecognized string argument");
+            error ("sum: unrecognized string argument");
           nargin --;
-	}
+        }
     }
 
   if (error_state)
     return retval;
 
   if (nargin == 1 || nargin == 2)
     {
       octave_value arg = args(0);
 
       int dim = -1;
       if (nargin == 2)
         {
           dim = args(1).int_value () - 1;
           if (dim < 0)
-	    error ("sum: invalid dimension argument = %d", dim + 1);
+            error ("sum: invalid dimension argument = %d", dim + 1);
         }
 
       if (! error_state)
-	{
+        {
           switch (arg.builtin_type ())
             {
             case btyp_double:
               if (arg.is_sparse_type ())
                 {
                   if (isextra)
                     warning ("sum: 'extra' not yet implemented for sparse matrices");
                   retval = arg.sparse_matrix_value ().sum (dim);
@@ -2796,17 +2796,17 @@ the same as 'double'.  Otherwise, 'extra
                 retval = arg.bool_array_value ().any (dim);
               else
                 retval = arg.bool_array_value ().sum (dim);
               break;
 
             default:
               gripe_wrong_type_arg ("sum", arg);
             }
-	}
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -3018,270 +3018,270 @@ complex ([1, 2], [3, 4])\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_complex_type ())
-	retval = arg;
+        retval = arg;
       else
-	{
-	  if (arg.is_sparse_type ())
-	    {
-	      SparseComplexMatrix val = arg.sparse_complex_matrix_value ();
-
-	      if (! error_state)
-		retval = octave_value (new octave_sparse_complex_matrix (val));
-	    }
-	  else if (arg.is_single_type ())
-	    {
-	      if (arg.numel () == 1)
-		{
-		  FloatComplex val = arg.float_complex_value ();
-
-		  if (! error_state)
-		    retval = octave_value (new octave_float_complex (val));
-		}
-	      else
-		{
-		  FloatComplexNDArray val = arg.float_complex_array_value ();
-
-		  if (! error_state)
-		    retval = octave_value (new octave_float_complex_matrix (val));
-		}
-	    }
-	  else
-	    {
-	      if (arg.numel () == 1)
-		{
-		  Complex val = arg.complex_value ();
-
-		  if (! error_state)
-		    retval = octave_value (new octave_complex (val));
-		}
-	      else
-		{
-		  ComplexNDArray val = arg.complex_array_value ();
-
-		  if (! error_state)
-		    retval = octave_value (new octave_complex_matrix (val));
-		}
-	    }
-
-	  if (error_state)
-	    error ("complex: invalid conversion");
-	}
+        {
+          if (arg.is_sparse_type ())
+            {
+              SparseComplexMatrix val = arg.sparse_complex_matrix_value ();
+
+              if (! error_state)
+                retval = octave_value (new octave_sparse_complex_matrix (val));
+            }
+          else if (arg.is_single_type ())
+            {
+              if (arg.numel () == 1)
+                {
+                  FloatComplex val = arg.float_complex_value ();
+
+                  if (! error_state)
+                    retval = octave_value (new octave_float_complex (val));
+                }
+              else
+                {
+                  FloatComplexNDArray val = arg.float_complex_array_value ();
+
+                  if (! error_state)
+                    retval = octave_value (new octave_float_complex_matrix (val));
+                }
+            }
+          else
+            {
+              if (arg.numel () == 1)
+                {
+                  Complex val = arg.complex_value ();
+
+                  if (! error_state)
+                    retval = octave_value (new octave_complex (val));
+                }
+              else
+                {
+                  ComplexNDArray val = arg.complex_array_value ();
+
+                  if (! error_state)
+                    retval = octave_value (new octave_complex_matrix (val));
+                }
+            }
+
+          if (error_state)
+            error ("complex: invalid conversion");
+        }
     }
   else if (nargin == 2)
     {
       octave_value re = args(0);
       octave_value im = args(1);
 
       if (re.is_sparse_type () && im.is_sparse_type ())
-	{
-	  const SparseMatrix re_val = re.sparse_matrix_value ();
-	  const SparseMatrix im_val = im.sparse_matrix_value ();
-
-	  if (!error_state)
-	    {
-	      if (re.numel () == 1)
-		{
-		  SparseComplexMatrix result;
-		  if (re_val.nnz () == 0)
-		    result = Complex(0, 1) * SparseComplexMatrix (im_val);
-		  else
-		    {
-		      result = SparseComplexMatrix (im_val.dims (), re_val (0));
-		      octave_idx_type nr = im_val.rows ();
-		      octave_idx_type nc = im_val.cols ();
-
-		      for (octave_idx_type j = 0; j < nc; j++)
-			{
-			  octave_idx_type off = j * nr;
-			  for (octave_idx_type i = im_val.cidx(j); 
-			       i < im_val.cidx(j + 1); i++)
-			    result.data (im_val.ridx(i) + off) =  
-			      result.data (im_val.ridx(i) + off) + 
-			      Complex (0, im_val.data (i));
-			}
-		    }
-		  retval = octave_value (new octave_sparse_complex_matrix (result));
-		}
-	      else if (im.numel () == 1)
-		{
-		  SparseComplexMatrix result;
-		  if (im_val.nnz () == 0)
-		    result = SparseComplexMatrix (re_val);
-		  else
-		    {
-		      result = SparseComplexMatrix (re_val.rows(), re_val.cols(), Complex(0, im_val (0)));
-		      octave_idx_type nr = re_val.rows ();
-		      octave_idx_type nc = re_val.cols ();
-
-		      for (octave_idx_type j = 0; j < nc; j++)
-			{
-			  octave_idx_type off = j * nr;
-			  for (octave_idx_type i = re_val.cidx(j); 
-			       i < re_val.cidx(j + 1); i++)
-			    result.data (re_val.ridx(i) + off) =  
-			      result.data (re_val.ridx(i) + off) + 
-			      re_val.data (i);
-			}
-		    }
-		  retval = octave_value (new octave_sparse_complex_matrix (result));
-		}
-	      else
-		{
-		  if (re_val.dims () == im_val.dims ())
-		    {
-		      SparseComplexMatrix result = SparseComplexMatrix(re_val) 
-			+ Complex(0, 1) * SparseComplexMatrix (im_val);
-		      retval = octave_value (new octave_sparse_complex_matrix (result));
-		    }
-		  else
-		    error ("complex: dimension mismatch");
-		}
-	    }
-	}
+        {
+          const SparseMatrix re_val = re.sparse_matrix_value ();
+          const SparseMatrix im_val = im.sparse_matrix_value ();
+
+          if (!error_state)
+            {
+              if (re.numel () == 1)
+                {
+                  SparseComplexMatrix result;
+                  if (re_val.nnz () == 0)
+                    result = Complex(0, 1) * SparseComplexMatrix (im_val);
+                  else
+                    {
+                      result = SparseComplexMatrix (im_val.dims (), re_val (0));
+                      octave_idx_type nr = im_val.rows ();
+                      octave_idx_type nc = im_val.cols ();
+
+                      for (octave_idx_type j = 0; j < nc; j++)
+                        {
+                          octave_idx_type off = j * nr;
+                          for (octave_idx_type i = im_val.cidx(j); 
+                               i < im_val.cidx(j + 1); i++)
+                            result.data (im_val.ridx(i) + off) =  
+                              result.data (im_val.ridx(i) + off) + 
+                              Complex (0, im_val.data (i));
+                        }
+                    }
+                  retval = octave_value (new octave_sparse_complex_matrix (result));
+                }
+              else if (im.numel () == 1)
+                {
+                  SparseComplexMatrix result;
+                  if (im_val.nnz () == 0)
+                    result = SparseComplexMatrix (re_val);
+                  else
+                    {
+                      result = SparseComplexMatrix (re_val.rows(), re_val.cols(), Complex(0, im_val (0)));
+                      octave_idx_type nr = re_val.rows ();
+                      octave_idx_type nc = re_val.cols ();
+
+                      for (octave_idx_type j = 0; j < nc; j++)
+                        {
+                          octave_idx_type off = j * nr;
+                          for (octave_idx_type i = re_val.cidx(j); 
+                               i < re_val.cidx(j + 1); i++)
+                            result.data (re_val.ridx(i) + off) =  
+                              result.data (re_val.ridx(i) + off) + 
+                              re_val.data (i);
+                        }
+                    }
+                  retval = octave_value (new octave_sparse_complex_matrix (result));
+                }
+              else
+                {
+                  if (re_val.dims () == im_val.dims ())
+                    {
+                      SparseComplexMatrix result = SparseComplexMatrix(re_val) 
+                        + Complex(0, 1) * SparseComplexMatrix (im_val);
+                      retval = octave_value (new octave_sparse_complex_matrix (result));
+                    }
+                  else
+                    error ("complex: dimension mismatch");
+                }
+            }
+        }
       else if (re.is_single_type () || im.is_single_type ())
-	{
-	  if (re.numel () == 1)
-	    {
-	      float re_val = re.float_value ();
-
-	      if (im.numel () == 1)
-		{
-		  float im_val = im.double_value ();
-
-		  if (! error_state)
-		    retval = octave_value (new octave_float_complex (FloatComplex (re_val, im_val)));
-		}
-	      else
-		{
-		  const FloatNDArray im_val = im.float_array_value ();
-
-		  if (! error_state)
-		    {
-		      FloatComplexNDArray result (im_val.dims (), FloatComplex ());
-
-		      for (octave_idx_type i = 0; i < im_val.numel (); i++)
-			result.xelem (i) = FloatComplex (re_val, im_val(i));
-
-		      retval = octave_value (new octave_float_complex_matrix (result));
-		    }
-		}
-	    }
-	  else
-	    {
-	      const FloatNDArray re_val = re.float_array_value ();
-
-	      if (im.numel () == 1)
-		{
-		  float im_val = im.float_value ();
-
-		  if (! error_state)
-		    {
-		      FloatComplexNDArray result (re_val.dims (), FloatComplex ());
-
-		      for (octave_idx_type i = 0; i < re_val.numel (); i++)
-			result.xelem (i) = FloatComplex (re_val(i), im_val);
-
-		      retval = octave_value (new octave_float_complex_matrix (result));
-		    }
-		}
-	      else
-		{
-		  const FloatNDArray im_val = im.float_array_value ();
-
-		  if (! error_state)
-		    {
-		      if (re_val.dims () == im_val.dims ())
-			{
-			  FloatComplexNDArray result (re_val.dims (), FloatComplex ());
-
-			  for (octave_idx_type i = 0; i < re_val.numel (); i++)
-			    result.xelem (i) = FloatComplex (re_val(i), im_val(i));
-
-			  retval = octave_value (new octave_float_complex_matrix (result));
-			}
-		      else
-			error ("complex: dimension mismatch");
-		    }
-		}
-	    }
-	}
+        {
+          if (re.numel () == 1)
+            {
+              float re_val = re.float_value ();
+
+              if (im.numel () == 1)
+                {
+                  float im_val = im.double_value ();
+
+                  if (! error_state)
+                    retval = octave_value (new octave_float_complex (FloatComplex (re_val, im_val)));
+                }
+              else
+                {
+                  const FloatNDArray im_val = im.float_array_value ();
+
+                  if (! error_state)
+                    {
+                      FloatComplexNDArray result (im_val.dims (), FloatComplex ());
+
+                      for (octave_idx_type i = 0; i < im_val.numel (); i++)
+                        result.xelem (i) = FloatComplex (re_val, im_val(i));
+
+                      retval = octave_value (new octave_float_complex_matrix (result));
+                    }
+                }
+            }
+          else
+            {
+              const FloatNDArray re_val = re.float_array_value ();
+
+              if (im.numel () == 1)
+                {
+                  float im_val = im.float_value ();
+
+                  if (! error_state)
+                    {
+                      FloatComplexNDArray result (re_val.dims (), FloatComplex ());
+
+                      for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                        result.xelem (i) = FloatComplex (re_val(i), im_val);
+
+                      retval = octave_value (new octave_float_complex_matrix (result));
+                    }
+                }
+              else
+                {
+                  const FloatNDArray im_val = im.float_array_value ();
+
+                  if (! error_state)
+                    {
+                      if (re_val.dims () == im_val.dims ())
+                        {
+                          FloatComplexNDArray result (re_val.dims (), FloatComplex ());
+
+                          for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                            result.xelem (i) = FloatComplex (re_val(i), im_val(i));
+
+                          retval = octave_value (new octave_float_complex_matrix (result));
+                        }
+                      else
+                        error ("complex: dimension mismatch");
+                    }
+                }
+            }
+        }
       else if (re.numel () == 1)
-	{
-	  double re_val = re.double_value ();
-
-	  if (im.numel () == 1)
-	    {
-	      double im_val = im.double_value ();
-
-	      if (! error_state)
-		retval = octave_value (new octave_complex (Complex (re_val, im_val)));
-	    }
-	  else
-	    {
-	      const NDArray im_val = im.array_value ();
-
-	      if (! error_state)
-		{
-		  ComplexNDArray result (im_val.dims (), Complex ());
-
-		  for (octave_idx_type i = 0; i < im_val.numel (); i++)
-		    result.xelem (i) = Complex (re_val, im_val(i));
-
-		  retval = octave_value (new octave_complex_matrix (result));
-		}
-	    }
-	}
+        {
+          double re_val = re.double_value ();
+
+          if (im.numel () == 1)
+            {
+              double im_val = im.double_value ();
+
+              if (! error_state)
+                retval = octave_value (new octave_complex (Complex (re_val, im_val)));
+            }
+          else
+            {
+              const NDArray im_val = im.array_value ();
+
+              if (! error_state)
+                {
+                  ComplexNDArray result (im_val.dims (), Complex ());
+
+                  for (octave_idx_type i = 0; i < im_val.numel (); i++)
+                    result.xelem (i) = Complex (re_val, im_val(i));
+
+                  retval = octave_value (new octave_complex_matrix (result));
+                }
+            }
+        }
       else
-	{
-	  const NDArray re_val = re.array_value ();
-
-	  if (im.numel () == 1)
-	    {
-	      double im_val = im.double_value ();
-
-	      if (! error_state)
-		{
-		  ComplexNDArray result (re_val.dims (), Complex ());
-
-		  for (octave_idx_type i = 0; i < re_val.numel (); i++)
-		    result.xelem (i) = Complex (re_val(i), im_val);
-
-		  retval = octave_value (new octave_complex_matrix (result));
-		}
-	    }
-	  else
-	    {
-	      const NDArray im_val = im.array_value ();
-
-	      if (! error_state)
-		{
-		  if (re_val.dims () == im_val.dims ())
-		    {
-		      ComplexNDArray result (re_val.dims (), Complex ());
-
-		      for (octave_idx_type i = 0; i < re_val.numel (); i++)
-			result.xelem (i) = Complex (re_val(i), im_val(i));
-
-		      retval = octave_value (new octave_complex_matrix (result));
-		    }
-		  else
-		    error ("complex: dimension mismatch");
-		}
-	    }
-	}
+        {
+          const NDArray re_val = re.array_value ();
+
+          if (im.numel () == 1)
+            {
+              double im_val = im.double_value ();
+
+              if (! error_state)
+                {
+                  ComplexNDArray result (re_val.dims (), Complex ());
+
+                  for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                    result.xelem (i) = Complex (re_val(i), im_val);
+
+                  retval = octave_value (new octave_complex_matrix (result));
+                }
+            }
+          else
+            {
+              const NDArray im_val = im.array_value ();
+
+              if (! error_state)
+                {
+                  if (re_val.dims () == im_val.dims ())
+                    {
+                      ComplexNDArray result (re_val.dims (), Complex ());
+
+                      for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                        result.xelem (i) = Complex (re_val(i), im_val(i));
+
+                      retval = octave_value (new octave_complex_matrix (result));
+                    }
+                  else
+                    error ("complex: dimension mismatch");
+                }
+            }
+        }
 
       if (error_state)
-	error ("complex: invalid conversion");
+        error ("complex: invalid conversion");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isreal, args, ,
@@ -3398,42 +3398,42 @@ fill_matrix (const octave_value_list& ar
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
-	return retval;
+        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
-	dims.resize (nargin);
-
-	for (int i = 0; i < nargin; i++)
-	  {
-	    dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-	    if (error_state)
-	      {
-		error ("%s: expecting scalar integer arguments", fcn);
-		break;
-	      }
-	  }
+        dims.resize (nargin);
+
+        for (int i = 0; i < nargin; i++)
+          {
+            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
+
+            if (error_state)
+              {
+                error ("%s: expecting scalar integer arguments", fcn);
+                break;
+              }
+          }
       }
       break;
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
@@ -3442,81 +3442,81 @@ fill_matrix (const octave_value_list& ar
       // FIXME -- perhaps this should be made extensible by
       // using the class name to lookup a function to call to create
       // the new value.
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
-	{
-	  switch (dt)
-	    {
-	    case oct_data_conv::dt_int8:
-	      retval = int8NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_uint8:
-	      retval = uint8NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_int16:
-	      retval = int16NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_uint16:
-	      retval = uint16NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_int32:
-	      retval = int32NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_uint32:
-	      retval = uint32NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_int64:
-	      retval = int64NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_uint64:
-	      retval = uint64NDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_single:
-	      retval = FloatNDArray (dims, val);
-	      break;
-
-	    case oct_data_conv::dt_double:
+        {
+          switch (dt)
+            {
+            case oct_data_conv::dt_int8:
+              retval = int8NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_uint8:
+              retval = uint8NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_int16:
+              retval = int16NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_uint16:
+              retval = uint16NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_int32:
+              retval = int32NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_uint32:
+              retval = uint32NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_int64:
+              retval = int64NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_uint64:
+              retval = uint64NDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_single:
+              retval = FloatNDArray (dims, val);
+              break;
+
+            case oct_data_conv::dt_double:
               {
                 if (val == 1 && dims.length () == 2 && dims (0) == 1)
                   retval = Range (1.0, 0.0, dims (1)); // packed form
                 else
                   retval = NDArray (dims, val);
               }
-	      break;
-
-	    case oct_data_conv::dt_logical:
-	      retval = boolNDArray (dims, val);
-	      break;
-
-	    default:
-	      error ("%s: invalid class name", fcn);
-	      break;
-	    }
-	}
+              break;
+
+            case oct_data_conv::dt_logical:
+              retval = boolNDArray (dims, val);
+              break;
+
+            default:
+              error ("%s: invalid class name", fcn);
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, double val, float fval, 
-	     const char *fcn)
+             const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
   dim_vector dims (1, 1);
@@ -3524,72 +3524,72 @@ fill_matrix (const octave_value_list& ar
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
-	return retval;
+        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
-	dims.resize (nargin);
-
-	for (int i = 0; i < nargin; i++)
-	  {
-	    dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-	    if (error_state)
-	      {
-		error ("%s: expecting scalar integer arguments", fcn);
-		break;
-	      }
-	  }
+        dims.resize (nargin);
+
+        for (int i = 0; i < nargin; i++)
+          {
+            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
+
+            if (error_state)
+              {
+                error ("%s: expecting scalar integer arguments", fcn);
+                break;
+              }
+          }
       }
       break;
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
       check_dimensions (dims, fcn);
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
-	{
-	  switch (dt)
-	    {
-	    case oct_data_conv::dt_single:
-	      retval = FloatNDArray (dims, fval);
-	      break;
-
-	    case oct_data_conv::dt_double:
-	      retval = NDArray (dims, val);
-	      break;
-
-	    default:
-	      error ("%s: invalid class name", fcn);
-	      break;
-	    }
-	}
+        {
+          switch (dt)
+            {
+            case oct_data_conv::dt_single:
+              retval = FloatNDArray (dims, fval);
+              break;
+
+            case oct_data_conv::dt_double:
+              retval = NDArray (dims, val);
+              break;
+
+            default:
+              error ("%s: invalid class name", fcn);
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, double val, const char *fcn)
 {
@@ -3604,80 +3604,80 @@ fill_matrix (const octave_value_list& ar
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
-	return retval;
+        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
-	dims.resize (nargin);
-
-	for (int i = 0; i < nargin; i++)
-	  {
-	    dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-	    if (error_state)
-	      {
-		error ("%s: expecting scalar integer arguments", fcn);
-		break;
-	      }
-	  }
+        dims.resize (nargin);
+
+        for (int i = 0; i < nargin; i++)
+          {
+            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
+
+            if (error_state)
+              {
+                error ("%s: expecting scalar integer arguments", fcn);
+                break;
+              }
+          }
       }
       break;
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
       check_dimensions (dims, fcn);
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
-	{
-	  switch (dt)
-	    {
-	    case oct_data_conv::dt_single:
-	      retval = FloatNDArray (dims, static_cast <float> (val));
-	      break;
-
-	    case oct_data_conv::dt_double:
-	      retval = NDArray (dims, val);
-	      break;
-
-	    default:
-	      error ("%s: invalid class name", fcn);
-	      break;
-	    }
-	}
+        {
+          switch (dt)
+            {
+            case oct_data_conv::dt_single:
+              retval = FloatNDArray (dims, static_cast <float> (val));
+              break;
+
+            case oct_data_conv::dt_double:
+              retval = NDArray (dims, val);
+              break;
+
+            default:
+              error ("%s: invalid class name", fcn);
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, const Complex& val,
-	     const char *fcn)
+             const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
   dim_vector dims (1, 1);
@@ -3685,72 +3685,72 @@ fill_matrix (const octave_value_list& ar
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
-	return retval;
+        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
-	dims.resize (nargin);
-
-	for (int i = 0; i < nargin; i++)
-	  {
-	    dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-	    if (error_state)
-	      {
-		error ("%s: expecting scalar integer arguments", fcn);
-		break;
-	      }
-	  }
+        dims.resize (nargin);
+
+        for (int i = 0; i < nargin; i++)
+          {
+            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
+
+            if (error_state)
+              {
+                error ("%s: expecting scalar integer arguments", fcn);
+                break;
+              }
+          }
       }
       break;
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
       check_dimensions (dims, fcn);
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
-	{
-	  switch (dt)
-	    {
-	    case oct_data_conv::dt_single:
-	      retval = FloatComplexNDArray (dims, static_cast<FloatComplex> (val));
-	      break;
-
-	    case oct_data_conv::dt_double:
-	      retval = ComplexNDArray (dims, val);
-	      break;
-
-	    default:
-	      error ("%s: invalid class name", fcn);
-	      break;
-	    }
-	}
+        {
+          switch (dt)
+            {
+            case oct_data_conv::dt_single:
+              retval = FloatComplexNDArray (dims, static_cast<FloatComplex> (val));
+              break;
+
+            case oct_data_conv::dt_double:
+              retval = ComplexNDArray (dims, val);
+              break;
+
+            default:
+              error ("%s: invalid class name", fcn);
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 static octave_value
 fill_matrix (const octave_value_list& args, bool val, const char *fcn)
 {
@@ -3766,43 +3766,43 @@ fill_matrix (const octave_value_list& ar
       break;
 
     case 1:
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
-	dims.resize (nargin);
-
-	for (int i = 0; i < nargin; i++)
-	  {
-	    dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
-
-	    if (error_state)
-	      {
-		error ("%s: expecting scalar integer arguments", fcn);
-		break;
-	      }
-	  }
+        dims.resize (nargin);
+
+        for (int i = 0; i < nargin; i++)
+          {
+            dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
+
+            if (error_state)
+              {
+                error ("%s: expecting scalar integer arguments", fcn);
+                break;
+              }
+          }
       }
       break;
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
       check_dimensions (dims, fcn);
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
-	retval = boolNDArray (dims, val);
+        retval = boolNDArray (dims, val);
     }
 
   return retval;
 }
 
 DEFUN (ones, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ones (@var{x})\n\
@@ -3918,17 +3918,17 @@ specified.  When called with more than o
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{isinf}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_inf_value (), 
-		      lo_ieee_float_inf_value (), "Inf");
+                      lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
 
 /*
 
 %!assert(inf (3), [Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]);
 %!assert(inf (2, 3), [Inf, Inf, Inf; Inf, Inf, Inf]);
@@ -3976,17 +3976,17 @@ specified.  When called with more than o
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{isnan}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_nan_value (), 
-		      lo_ieee_float_nan_value (), "NaN");
+                      lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
 
 /* 
 %!assert(NaN (3), [NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]);
 %!assert(NaN (2, 3), [NaN, NaN, NaN; NaN, NaN, NaN]);
 %!assert(NaN (3, 2), [NaN, NaN; NaN, NaN; NaN, NaN]);
@@ -4070,65 +4070,65 @@ either \"double\" or \"single\".\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 1 && ! args(0).is_string ())
     {
       if (args(0).is_single_type ())
-	{
-	  float val = args(0).float_value ();
-
-	  if (! error_state)
-	    {
-	      val  = ::fabsf(val);
-	      if (xisnan (val) || xisinf (val))
-		retval = fill_matrix (octave_value ("single"), 
-				      lo_ieee_nan_value (), 
-				      lo_ieee_float_nan_value (), "eps");
-	      else if (val < FLT_MIN)
-		retval = fill_matrix (octave_value ("single"), 0e0, 
-				      powf (2.0, -149e0), "eps");
-	      else
-		{
-		  int expon;
-		  frexpf (val, &expon);
-		  val = std::pow (static_cast <float> (2.0), 
-				  static_cast <float> (expon - 24));
-		  retval = fill_matrix (octave_value ("single"), DBL_EPSILON, 
-					val, "eps");
-		}
-	    }
-	}
+        {
+          float val = args(0).float_value ();
+
+          if (! error_state)
+            {
+              val  = ::fabsf(val);
+              if (xisnan (val) || xisinf (val))
+                retval = fill_matrix (octave_value ("single"), 
+                                      lo_ieee_nan_value (), 
+                                      lo_ieee_float_nan_value (), "eps");
+              else if (val < FLT_MIN)
+                retval = fill_matrix (octave_value ("single"), 0e0, 
+                                      powf (2.0, -149e0), "eps");
+              else
+                {
+                  int expon;
+                  frexpf (val, &expon);
+                  val = std::pow (static_cast <float> (2.0), 
+                                  static_cast <float> (expon - 24));
+                  retval = fill_matrix (octave_value ("single"), DBL_EPSILON, 
+                                        val, "eps");
+                }
+            }
+        }
       else
-	{
-	  double val = args(0).double_value ();
-
-	  if (! error_state)
-	    {
-	      val  = ::fabs(val);
-	      if (xisnan (val) || xisinf (val))
-		retval = fill_matrix (octave_value_list (), 
-				      lo_ieee_nan_value (), 
-				      lo_ieee_float_nan_value (), "eps");
-	      else if (val < DBL_MIN)
-		retval = fill_matrix (octave_value_list (),
-				      pow (2.0, -1074e0), 0e0, "eps");
-	      else
-		{
-		  int expon;
-		  frexp (val, &expon);
-		  val = std::pow (static_cast <double> (2.0), 
-				  static_cast <double> (expon - 53));
-		  retval = fill_matrix (octave_value_list (), val, 
-					FLT_EPSILON, "eps");
-		}
-	    }
-	}
+        {
+          double val = args(0).double_value ();
+
+          if (! error_state)
+            {
+              val  = ::fabs(val);
+              if (xisnan (val) || xisinf (val))
+                retval = fill_matrix (octave_value_list (), 
+                                      lo_ieee_nan_value (), 
+                                      lo_ieee_float_nan_value (), "eps");
+              else if (val < DBL_MIN)
+                retval = fill_matrix (octave_value_list (),
+                                      pow (2.0, -1074e0), 0e0, "eps");
+              else
+                {
+                  int expon;
+                  frexp (val, &expon);
+                  val = std::pow (static_cast <double> (2.0), 
+                                  static_cast <double> (expon - 53));
+                  retval = fill_matrix (octave_value_list (), val, 
+                                        FLT_EPSILON, "eps");
+                }
+            }
+        }
     }
   else
     retval = fill_matrix (args, DBL_EPSILON, FLT_EPSILON, "eps");
 
   return retval;
 }
 
 /*
@@ -4315,17 +4315,17 @@ specified.  When called with more than o
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{isna}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_na_value (), 
-		      lo_ieee_float_na_value (), "NA");
+                      lo_ieee_float_na_value (), "NA");
 }
 
 /*
 
 %!assert(single(NA('double')),NA('single'))
 %!assert(double(NA('single')),NA('double'))
 
  */
@@ -4368,22 +4368,22 @@ identity_matrix (int nr, int nc)
     {
       dim_vector dims (nr, nc);
 
       typename MT::element_type zero (0);
 
       MT m (dims, zero);
 
       if (nr > 0 && nc > 0)
-	{
-	  int n = std::min (nr, nc);
-
-	  for (int i = 0; i < n; i++)
-	    m(i,i) = one;
-	}
+        {
+          int n = std::min (nr, nc);
+
+          for (int i = 0; i < n; i++)
+            m(i,i) = one;
+        }
 
       retval = m;
     }
 
   return retval;
 }
 
 #define INSTANTIATE_EYE(T) \
@@ -4408,65 +4408,65 @@ identity_matrix (int nr, int nc, oct_dat
 
   // FIXME -- perhaps this should be made extensible by using
   // the class name to lookup a function to call to create the new
   // value.
 
   if (! error_state)
     {
       switch (dt)
-	{
-	case oct_data_conv::dt_int8:
-	  retval = identity_matrix<int8NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_uint8:
-	  retval = identity_matrix<uint8NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_int16:
-	  retval = identity_matrix<int16NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_uint16:
-	  retval = identity_matrix<uint16NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_int32:
-	  retval = identity_matrix<int32NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_uint32:
-	  retval = identity_matrix<uint32NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_int64:
-	  retval = identity_matrix<int64NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_uint64:
-	  retval = identity_matrix<uint64NDArray> (nr, nc);
-	  break;
-
-	case oct_data_conv::dt_single:
-	  retval = FloatDiagMatrix (nr, nc, 1.0f);
-	  break;
-
-	case oct_data_conv::dt_double:
-	  retval = DiagMatrix (nr, nc, 1.0);
-	  break;
-
-	case oct_data_conv::dt_logical:
-	  retval = identity_matrix<boolNDArray> (nr, nc);
-	  break;
-
-	default:
-	  error ("eye: invalid class name");
-	  break;
-	}
+        {
+        case oct_data_conv::dt_int8:
+          retval = identity_matrix<int8NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_uint8:
+          retval = identity_matrix<uint8NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_int16:
+          retval = identity_matrix<int16NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_uint16:
+          retval = identity_matrix<uint16NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_int32:
+          retval = identity_matrix<int32NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_uint32:
+          retval = identity_matrix<uint32NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_int64:
+          retval = identity_matrix<int64NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_uint64:
+          retval = identity_matrix<uint64NDArray> (nr, nc);
+          break;
+
+        case oct_data_conv::dt_single:
+          retval = FloatDiagMatrix (nr, nc, 1.0f);
+          break;
+
+        case oct_data_conv::dt_double:
+          retval = DiagMatrix (nr, nc, 1.0);
+          break;
+
+        case oct_data_conv::dt_logical:
+          retval = identity_matrix<boolNDArray> (nr, nc);
+          break;
+
+        default:
+          error ("eye: invalid class name");
+          break;
+        }
     }
 
   return retval;
 }
 
 #undef INT_EYE_MATRIX
 
 DEFUN (eye, args, ,
@@ -4525,42 +4525,42 @@ with @sc{matlab}.\n\
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
-	return retval;
+        return retval;
     }
 
   switch (nargin)
     {
     case 0:
       retval = identity_matrix (1, 1, dt);
       break;
 
     case 1:
       {
-	octave_idx_type nr, nc;
-	get_dimensions (args(0), "eye", nr, nc);
-
-	if (! error_state)
-	  retval = identity_matrix (nr, nc, dt);
+        octave_idx_type nr, nc;
+        get_dimensions (args(0), "eye", nr, nc);
+
+        if (! error_state)
+          retval = identity_matrix (nr, nc, dt);
       }
       break;
 
     case 2:
       {
-	octave_idx_type nr, nc;
-	get_dimensions (args(0), args(1), "eye", nr, nc);
-
-	if (! error_state)
-	  retval = identity_matrix (nr, nc, dt);
+        octave_idx_type nr, nc;
+        get_dimensions (args(0), args(1), "eye", nr, nc);
+
+        if (! error_state)
+          retval = identity_matrix (nr, nc, dt);
       }
       break;
 
     default:
       print_usage ();
       break;
     }
 
@@ -4661,30 +4661,30 @@ fewer than two values are requested.\n\
     npoints = args(2).idx_type_value ();
 
   if (! error_state)
     {
       octave_value arg_1 = args(0);
       octave_value arg_2 = args(1);
 
       if (arg_1.is_single_type () || arg_2.is_single_type ())
-	{
-	  if (arg_1.is_complex_type () || arg_2.is_complex_type ())
+        {
+          if (arg_1.is_complex_type () || arg_2.is_complex_type ())
             retval = do_linspace<FloatComplexMatrix> (arg_1, arg_2, npoints);
-	  else
+          else
             retval = do_linspace<FloatMatrix> (arg_1, arg_2, npoints);
-	    
-	}
+            
+        }
       else
-	{
-	  if (arg_1.is_complex_type () || arg_2.is_complex_type ())
+        {
+          if (arg_1.is_complex_type () || arg_2.is_complex_type ())
             retval = do_linspace<ComplexMatrix> (arg_1, arg_2, npoints);
-	  else
+          else
             retval = do_linspace<Matrix> (arg_1, arg_2, npoints);
-	}
+        }
     }
   else
     error ("linspace: expecting third argument to be an integer");
 
   return retval;
 }
 
 
@@ -4759,42 +4759,42 @@ Resizing an object to fewer dimensions i
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       Array<double> vec = args(1).vector_value ();
       int ndim = vec.length ();
       if (ndim == 1)
-	{
-	  octave_idx_type m = static_cast<octave_idx_type> (vec(0));
-	  retval = args(0);
-	  retval = retval.resize (dim_vector (m, m), true);
-	}
+        {
+          octave_idx_type m = static_cast<octave_idx_type> (vec(0));
+          retval = args(0);
+          retval = retval.resize (dim_vector (m, m), true);
+        }
       else
-	{
-	  dim_vector dv;
-	  dv.resize (ndim);
-	  for (int i = 0; i < ndim; i++)
-	    dv(i) = static_cast<octave_idx_type> (vec(i));
-	  retval = args(0);
-	  retval = retval.resize (dv, true);
-	}
+        {
+          dim_vector dv;
+          dv.resize (ndim);
+          for (int i = 0; i < ndim; i++)
+            dv(i) = static_cast<octave_idx_type> (vec(i));
+          retval = args(0);
+          retval = retval.resize (dv, true);
+        }
     }
   else if (nargin > 2)
     {
       dim_vector dv;
       dv.resize (nargin - 1);
       for (octave_idx_type i = 1; i < nargin; i++)
         dv(i-1) = static_cast<octave_idx_type> (args(i).scalar_value ());
       if (!error_state)
-	{
-	  retval = args(0);
-	  retval = retval.resize (dv, true);
-	}
+        {
+          retval = args(0);
+          retval = retval.resize (dv, true);
+        }
 
     }
   else
     print_usage ();
   return retval;
 }
 
 // FIXME -- should use octave_idx_type for dimensions.
@@ -4834,55 +4834,55 @@ by an empty argument.\n\
   if (nargin == 2)
     new_size = args(1).int_vector_value ();
   else if (nargin > 2)
     {
       new_size.resize (nargin-1);
       int empty_dim = -1;
       
       for (int i = 1; i < nargin; i++)
-	{
-	  if (args(i).is_empty ())
-	    if (empty_dim > 0)
-	      {
-		error ("reshape: only a single dimension can be unknown");
-		break;
-	      }
-	    else
-	      {
-		empty_dim = i;
-		new_size(i-1) = 1;
-	      }
-	  else
-	    {
-	      new_size(i-1) = args(i).idx_type_value ();
-
-	      if (error_state)
-		break;
-	    }
-	}
+        {
+          if (args(i).is_empty ())
+            if (empty_dim > 0)
+              {
+                error ("reshape: only a single dimension can be unknown");
+                break;
+              }
+            else
+              {
+                empty_dim = i;
+                new_size(i-1) = 1;
+              }
+          else
+            {
+              new_size(i-1) = args(i).idx_type_value ();
+
+              if (error_state)
+                break;
+            }
+        }
 
       if (! error_state && (empty_dim > 0))
-	{
-	  int nel = 1;
-	  for (int i = 0; i < nargin - 1; i++)
-	    nel *= new_size(i);
-
-	  if (nel == 0)
-	    new_size(empty_dim-1) = 0;
-	  else
-	    {
-	      int size_empty_dim = args(0).numel () / nel;
-	      
-	      if (args(0).numel () != size_empty_dim * nel)
-		error ("reshape: size is not divisble by the product of known dimensions (= %d)", nel);
-	      else
-		new_size(empty_dim-1) = size_empty_dim;
-	    }
-	}
+        {
+          int nel = 1;
+          for (int i = 0; i < nargin - 1; i++)
+            nel *= new_size(i);
+
+          if (nel == 0)
+            new_size(empty_dim-1) = 0;
+          else
+            {
+              int size_empty_dim = args(0).numel () / nel;
+              
+              if (args(0).numel () != size_empty_dim * nel)
+                error ("reshape: size is not divisble by the product of known dimensions (= %d)", nel);
+              else
+                new_size(empty_dim-1) = size_empty_dim;
+            }
+        }
     }
   else
     {
       print_usage ();
       return retval;
     }
 
   if (error_state)
@@ -4894,19 +4894,19 @@ by an empty argument.\n\
   // Remove trailing singletons in new_size, but leave at least 2
   // elements.
 
   int n = new_size.length ();
 
   while (n > 2)
     {
       if (new_size(n-1) == 1)
-	n--;
+        n--;
       else
-	break;
+        break;
     }
 
   new_size.resize (n);
 
   if (n < 2)
     {
       error ("reshape: expecting size to be vector with at least 2 elements");
       return retval;
@@ -4926,17 +4926,17 @@ by an empty argument.\n\
   if (new_dims.numel () == dims.numel ())
     retval = (new_dims == dims) ? arg : arg.reshape (new_dims);
   else
     {
       std::string dims_str = dims.str ();
       std::string new_dims_str = new_dims.str ();
 
       error ("reshape: can't reshape %s array to %s array",
-	     dims_str.c_str (), new_dims_str.c_str ());
+             dims_str.c_str (), new_dims_str.c_str ());
     }
 
   return retval;
 }
 
 /*
 
 %!assert(size (reshape (ones (4, 4), 2, 8)), [2, 8])
@@ -5055,17 +5055,17 @@ column norms are computed.\n\
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
     {
       octave_value x_arg = args(0);
 
       if (x_arg.ndims () == 2)
-	{
+        {
           enum { sfmatrix, sfcols, sfrows, sffrob, sfinf } strflag = sfmatrix;
           if (nargin > 1 && args(nargin-1).is_string ())
             {
               std::string str = args(nargin-1).string_value ();
               if (str == "cols" || str == "columns")
                 strflag = sfcols;
               else if (str == "rows")
                 strflag = sfrows;
@@ -5098,19 +5098,19 @@ column norms are computed.\n\
                 case sffrob:
                   retval(0) = xfrobnorm (x_arg);
                   break;
                 case sfinf:
                   retval(0) = xnorm (x_arg, octave_Inf);
                   break;
                 }
             }
-	}
+        }
       else
-	error ("norm: only valid for 2-D objects");
+        error ("norm: only valid for 2-D objects");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -5609,28 +5609,28 @@ See tic.\n\
 
   if (nargin != 0)
     warning ("tic: ignoring extra arguments");
 
   if (tic_toc_timestamp < 0)
     {
       warning ("toc called before timer set");
       if (nargout > 0)
-	retval = Matrix ();
+        retval = Matrix ();
     }
   else
     {
       octave_time now;
 
       double tmp = now.double_value () - tic_toc_timestamp;
 
       if (nargout > 0)
-	retval = tmp;
+        retval = tmp;
       else
-	octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
+        octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
     }
     
   return retval;
 }
 
 DEFUN (cputime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{total}, @var{user}, @var{system}] =} cputime ();\n\
@@ -5763,70 +5763,70 @@ ordered lists.\n\
   bool return_idx = nargout > 1;
 
   octave_value arg = args(0);
 
   int dim = 0;
   if (nargin > 1)
     {
       if (args(1).is_string ())
-	{
-	  std::string mode = args(1).string_value();
-	  if (mode == "ascend")
-	    smode = ASCENDING;
-	  else if (mode == "descend")
-	    smode = DESCENDING;
-	  else
-	    {
-	      error ("sort: mode must be either \"ascend\" or \"descend\"");
-	      return retval;
-	    }
-	}
+        {
+          std::string mode = args(1).string_value();
+          if (mode == "ascend")
+            smode = ASCENDING;
+          else if (mode == "descend")
+            smode = DESCENDING;
+          else
+            {
+              error ("sort: mode must be either \"ascend\" or \"descend\"");
+              return retval;
+            }
+        }
       else
-	dim = args(1).nint_value () - 1;
+        dim = args(1).nint_value () - 1;
     }
 
   if (nargin > 2)
     {
       if (args(1).is_string ())
-	{
-	  print_usage ();
-	  return retval;
-	}
+        {
+          print_usage ();
+          return retval;
+        }
 
       if (! args(2).is_string ())
-	{
-	  error ("sort: mode must be a string");
-	  return retval;
-	}
+        {
+          error ("sort: mode must be a string");
+          return retval;
+        }
       std::string mode = args(2).string_value();
       if (mode == "ascend")
-	smode = ASCENDING;
+        smode = ASCENDING;
       else if (mode == "descend")
-	smode = DESCENDING;
+        smode = DESCENDING;
       else
-	{
-	  error ("sort: mode must be either \"ascend\" or \"descend\"");
-	  return retval;
-	}
+        {
+          error ("sort: mode must be either \"ascend\" or \"descend\"");
+          return retval;
+        }
     }
 
   const dim_vector dv = arg.dims ();
   if (nargin == 1 || args(1).is_string ())
     {
       // Find first non singleton dimension
       dim = dv.first_non_singleton ();
     }
   else
     {
       if (dim < 0 || dim > dv.length () - 1)
-	{
-	  error ("sort: dim must be a valid dimension");
-	  return retval;
-	}
+        {
+          error ("sort: dim must be a valid dimension");
+          return retval;
+        }
     }
 
   if (return_idx)
     {
       Array<octave_idx_type> sidx;
 
       retval (0) = arg.sort (sidx, dim, smode);
       retval (1) = idx_vector (sidx, dv(dim)); // No checking, the extent is known.
@@ -6120,49 +6120,49 @@ This function does not yet support spars
 
   sortmode smode = ASCENDING;
 
   if (nargin > 1)
     {
       octave_value mode_arg;
 
       if (nargin == 3)
-	smode = get_sort_mode_option (args(2), "third");
+        smode = get_sort_mode_option (args(2), "third");
 
       std::string tmp = args(1).string_value ();
 
       if (! error_state)
-	{
-	  if (tmp == "rows")
-	    by_rows = true;
-	  else
-	    smode = get_sort_mode_option (args(1), "second");
-	}
+        {
+          if (tmp == "rows")
+            by_rows = true;
+          else
+            smode = get_sort_mode_option (args(1), "second");
+        }
       else
-	error ("expecting second argument to be character string");
+        error ("expecting second argument to be character string");
 
       if (error_state)
-	return retval;
+        return retval;
     }
     
   octave_value arg = args(0);
 
   if (by_rows)
     {
       if (arg.is_sparse_type ())
-	error ("issorted: sparse matrices not yet supported");
+        error ("issorted: sparse matrices not yet supported");
       if (arg.ndims () == 2)
-	retval = arg.is_sorted_rows (smode) != UNSORTED;
+        retval = arg.is_sorted_rows (smode) != UNSORTED;
       else
-	error ("issorted: needs a 2-dimensional object");
+        error ("issorted: needs a 2-dimensional object");
     }
   else
     {
       if (arg.dims ().is_vector ())
-	retval = args(0).is_sorted (smode) != UNSORTED;
+        retval = args(0).is_sorted (smode) != UNSORTED;
       else
         error ("issorted: needs a vector");
     }
 
   return retval;
 }
 
 /*
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -68,30 +68,30 @@ snarf_file (const std::string& fname)
 
   if (fs)
     {
       size_t sz = fs.size ();
 
       std::ifstream file (fname.c_str (), std::ios::in|std::ios::binary);
 
       if (file)
-	{
-	  std::string buf (sz+1, 0);
+        {
+          std::string buf (sz+1, 0);
 
-	  file.read (&buf[0], sz+1);
+          file.read (&buf[0], sz+1);
 
-	  if (file.eof ())
-	    {
-	      // Expected to read the entire file.
+          if (file.eof ())
+            {
+              // Expected to read the entire file.
 
-	      retval = buf;
-	    }
-	  else
-	    error ("error reading file %s", fname.c_str ());
-	}
+              retval = buf;
+            }
+          else
+            error ("error reading file %s", fname.c_str ());
+        }
     }
 
   return retval;
 }
 
 static std::deque<size_t>
 get_line_offsets (const std::string& buf)
 {
@@ -104,26 +104,26 @@ get_line_offsets (const std::string& buf
 
   size_t len = buf.length ();
 
   for (size_t i = 0; i < len; i++)
     {
       char c = buf[i];
 
       if (c == '\r' && ++i < len)
-	{
-	  c = buf[i];
+        {
+          c = buf[i];
 
-	  if (c == '\n')
-	    offsets.push_back (i+1);
-	  else
-	    offsets.push_back (i);
-	}
+          if (c == '\n')
+            offsets.push_back (i+1);
+          else
+            offsets.push_back (i);
+        }
       else if (c == '\n')
-	offsets.push_back (i+1);
+        offsets.push_back (i+1);
     }
 
   offsets.push_back (len);
 
   return offsets;
 }
 
 std::string
@@ -148,17 +148,17 @@ get_file_line (const std::string& fname,
     line--;
 
   if (line < offsets.size () - 1)
     {
       size_t bol = offsets[line];
       size_t eol = offsets[line+1];
 
       while (eol > 0 && (buf[eol-1] == '\n' || buf[eol-1] == '\r'))
-	eol--;
+        eol--;
 
       retval = buf.substr (bol, eol - bol);
     }
 
   return retval;
 }
 
 // Return a pointer to the user-defined function FNAME.  If FNAME is
@@ -172,25 +172,25 @@ get_user_code (const std::string& fname 
 
   if (fname.empty ())
     dbg_fcn = octave_call_stack::caller_user_code ();
   else
     {
       octave_value fcn = symbol_table::find_function (fname);
 
       if (fcn.is_defined () && fcn.is_user_code ())
-	dbg_fcn = fcn.user_code_value ();
+        dbg_fcn = fcn.user_code_value ();
     }
 
   return dbg_fcn;
 }
 
 static void
 parse_dbfunction_params (const char *who, const octave_value_list& args, 
-			 std::string& symbol_name, bp_table::intmap& lines)
+                         std::string& symbol_name, bp_table::intmap& lines)
 {
   int nargin = args.length ();
   int idx = 0;
   int list_idx = 0;
   symbol_name = std::string ();
   lines = bp_table::intmap ();
 
   if (args.length () == 0)
@@ -206,185 +206,185 @@ parse_dbfunction_params (const char *who
     {
       // Problem because parse_dbfunction_params() can only pass out a
       // single function
     }
   else if (args(0).is_string())
     {
       symbol_name = args(0).string_value ();
       if (error_state)
-	return;
+        return;
       idx = 1;
     }
   else
     error ("%s: invalid parameter specified", who);
 
   for (int i = idx; i < nargin; i++ )
     {
       if (args(i).is_string ())
-	{
-	  int line = atoi (args(i).string_value().c_str ());
-	  if (error_state)
-	    break;
-	  lines[list_idx++] = line;
-	}
+        {
+          int line = atoi (args(i).string_value().c_str ());
+          if (error_state)
+            break;
+          lines[list_idx++] = line;
+        }
       else if (args(i).is_map ())
-	octave_stdout << who << ": accepting a struct" << std::endl;
+        octave_stdout << who << ": accepting a struct" << std::endl;
       else
-	{
-	  const NDArray arg = args(i).array_value ();
-	  
-	  if (error_state)
-	    break;
-	  
-	  for (octave_idx_type j = 0; j < arg.nelem (); j++)
-	    {
-	      int line = static_cast<int> (arg.elem (j));
-	      if (error_state)
-		break;
-	      lines[list_idx++] = line;
-	    }
-	  
-	  if (error_state)
-	    break;
-	}
+        {
+          const NDArray arg = args(i).array_value ();
+          
+          if (error_state)
+            break;
+          
+          for (octave_idx_type j = 0; j < arg.nelem (); j++)
+            {
+              int line = static_cast<int> (arg.elem (j));
+              if (error_state)
+                break;
+              lines[list_idx++] = line;
+            }
+          
+          if (error_state)
+            break;
+        }
     } 
 }
 
 bp_table::intmap
 bp_table::do_add_breakpoint (const std::string& fname, 
-			     const bp_table::intmap& line)
+                             const bp_table::intmap& line)
 {
   intmap retval;
 
   octave_idx_type len = line.size ();
 
   octave_user_code *dbg_fcn = get_user_code (fname);
 
   if (dbg_fcn)
     {
       tree_statement_list *cmds = dbg_fcn->body ();
 
       if (cmds)
-	{
-	  for (int i = 0; i < len; i++)
-	    {
-	      const_intmap_iterator p = line.find (i);
+        {
+          for (int i = 0; i < len; i++)
+            {
+              const_intmap_iterator p = line.find (i);
 
-	      if (p != line.end ())
-		{
-		  int lineno = p->second;
+              if (p != line.end ())
+                {
+                  int lineno = p->second;
 
-		  retval[i] = cmds->set_breakpoint (lineno);
+                  retval[i] = cmds->set_breakpoint (lineno);
 
-		  if (retval[i] != 0)
-		    {
-		      bp_set.insert (fname);
-		    }
-		}
-	    }
-	}
+                  if (retval[i] != 0)
+                    {
+                      bp_set.insert (fname);
+                    }
+                }
+            }
+        }
     }
   else
     error ("add_breakpoint: unable to find the function requested\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
 int 
 bp_table::do_remove_breakpoint (const std::string& fname, 
-				const bp_table::intmap& line)
+                                const bp_table::intmap& line)
 {
   int retval = 0;
 
   octave_idx_type len = line.size ();
 
   if (len == 0)
     {
       intmap results = remove_all_breakpoints_in_file (fname);
       retval = results.size ();
     }
   else
     {
       octave_user_code *dbg_fcn = get_user_code (fname);
 
       if (dbg_fcn)
-	{
-	  tree_statement_list *cmds = dbg_fcn->body ();
+        {
+          tree_statement_list *cmds = dbg_fcn->body ();
 
-	  if (cmds)
-	    {
-	      octave_value_list results = cmds->list_breakpoints ();
+          if (cmds)
+            {
+              octave_value_list results = cmds->list_breakpoints ();
 
-	      if (results.length () > 0)
-		{
-		  for (int i = 0; i < len; i++)
-		    {
-		      const_intmap_iterator p = line.find (i);
+              if (results.length () > 0)
+                {
+                  for (int i = 0; i < len; i++)
+                    {
+                      const_intmap_iterator p = line.find (i);
 
-		      if (p != line.end ())
-			cmds->delete_breakpoint (p->second);
-		    }
+                      if (p != line.end ())
+                        cmds->delete_breakpoint (p->second);
+                    }
 
-		  results = cmds->list_breakpoints ();
+                  results = cmds->list_breakpoints ();
 
-		  bp_set_iterator it = bp_set.find (fname);
-		  if (results.length () == 0 && it != bp_set.end ())
-		    bp_set.erase (it);
+                  bp_set_iterator it = bp_set.find (fname);
+                  if (results.length () == 0 && it != bp_set.end ())
+                    bp_set.erase (it);
 
-		}
+                }
 
-	      retval = results.length ();
-	    }
-	}
+              retval = results.length ();
+            }
+        }
       else
-	error ("remove_breakpoint: unable to find the function requested\n");
+        error ("remove_breakpoint: unable to find the function requested\n");
     }
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
 bp_table::intmap
 bp_table::do_remove_all_breakpoints_in_file (const std::string& fname, 
-					     bool silent)
+                                             bool silent)
 {
   intmap retval;
 
   octave_user_code *dbg_fcn = get_user_code (fname);
   
   if (dbg_fcn)
     {
       tree_statement_list *cmds = dbg_fcn->body ();
 
       if (cmds)
-	{
-	  octave_value_list bkpts = cmds->list_breakpoints ();
+        {
+          octave_value_list bkpts = cmds->list_breakpoints ();
 
-	  for (int i = 0; i < bkpts.length (); i++)
-	    {
-	      int lineno = static_cast<int> (bkpts(i).int_value ());
-	      cmds->delete_breakpoint (lineno);
-	      retval[i] = lineno;
-	    }
+          for (int i = 0; i < bkpts.length (); i++)
+            {
+              int lineno = static_cast<int> (bkpts(i).int_value ());
+              cmds->delete_breakpoint (lineno);
+              retval[i] = lineno;
+            }
 
-	  bp_set_iterator it = bp_set.find (fname);
-	  if (it != bp_set.end ())
-	    bp_set.erase (it);
+          bp_set_iterator it = bp_set.find (fname);
+          if (it != bp_set.end ())
+            bp_set.erase (it);
 
-	}
+        }
     }
   else if (! silent)
     error ("remove_all_breakpoint_in_file: "
-	   "unable to find the function requested\n");
+           "unable to find the function requested\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 void 
 bp_table::do_remove_all_breakpoints (void)
@@ -393,68 +393,68 @@ bp_table::do_remove_all_breakpoints (voi
     remove_all_breakpoints_in_file (*it);
 
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 }
 
 std::string 
 do_find_bkpt_list (octave_value_list slist, 
-		   std::string match)
+                   std::string match)
 {
   std::string retval;
 
   for (int i = 0; i < slist.length (); i++)
     {
       if (slist (i).string_value () == match)
-	{
-	  retval = slist(i).string_value ();
-	  break;
-	}
+        {
+          retval = slist(i).string_value ();
+          break;
+        }
     }
 
   return retval;
 }
 
 
 bp_table::fname_line_map
 bp_table::do_get_breakpoint_list (const octave_value_list& fname_list)
 {
   fname_line_map retval;
 
   for (bp_set_iterator it = bp_set.begin (); it != bp_set.end (); it++)
     {
       if (fname_list.length () == 0
-	  || do_find_bkpt_list (fname_list, *it) != "")
-	{
-	  octave_user_code *f = get_user_code (*it);
+          || do_find_bkpt_list (fname_list, *it) != "")
+        {
+          octave_user_code *f = get_user_code (*it);
 
-	  if (f)
-	    {
-	      tree_statement_list *cmds = f->body ();
+          if (f)
+            {
+              tree_statement_list *cmds = f->body ();
 
-	      if (cmds)
-		{
-		  octave_value_list bkpts = cmds->list_breakpoints ();
-		  octave_idx_type len = bkpts.length (); 
+              if (cmds)
+                {
+                  octave_value_list bkpts = cmds->list_breakpoints ();
+                  octave_idx_type len = bkpts.length (); 
 
-		  if (len > 0)
-		    {
-		      bp_table::intmap bkpts_vec;
-		      
-		      for (int i = 0; i < len; i++)
-			bkpts_vec[i] = bkpts (i).double_value ();
-		      
-		      std::string symbol_name = f->name ();
+                  if (len > 0)
+                    {
+                      bp_table::intmap bkpts_vec;
+                      
+                      for (int i = 0; i < len; i++)
+                        bkpts_vec[i] = bkpts (i).double_value ();
+                      
+                      std::string symbol_name = f->name ();
 
-		      retval[symbol_name] = bkpts_vec;
-		    }
-		}
-	    }
-	}
+                      retval[symbol_name] = bkpts_vec;
+                    }
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 static octave_value
 intmap_to_ov (const bp_table::intmap& line) 
 {
@@ -462,20 +462,20 @@ intmap_to_ov (const bp_table::intmap& li
 
   NDArray retval (dim_vector (1, line.size ()));
 
   for (size_t i = 0; i < line.size (); i++)
     {
       bp_table::const_intmap_iterator p = line.find (i);
 
       if (p != line.end ())
-	{
-	  int lineno = p->second;
-	  retval(idx++) = lineno;
-	}
+        {
+          int lineno = p->second;
+          retval(idx++) = lineno;
+        }
     }
 
   retval.resize (dim_vector (1, idx));
 
   return retval;
 }
 
 DEFUN (dbstop, args, ,
@@ -562,74 +562,74 @@ mode this should be left out.\n\
     {
       error ("dbstatus: only zero or one arguements accepted\n");
       return octave_value ();
     }
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
-	{
-	  symbol_name = args(0).string_value ();
-	  fcn_list(0) = symbol_name;
-	  bp_list = bp_table::get_breakpoint_list (fcn_list);
-	}
+        {
+          symbol_name = args(0).string_value ();
+          fcn_list(0) = symbol_name;
+          bp_list = bp_table::get_breakpoint_list (fcn_list);
+        }
       else
-	gripe_wrong_type_arg ("dbstatus", args(0));
+        gripe_wrong_type_arg ("dbstatus", args(0));
     }
   else
     {
        octave_user_code *dbg_fcn = get_user_code ();
        if (dbg_fcn)
-	 {
-	   symbol_name = dbg_fcn->name ();
-	   fcn_list(0) = symbol_name;
-	 }
+         {
+           symbol_name = dbg_fcn->name ();
+           fcn_list(0) = symbol_name;
+         }
 
        bp_list = bp_table::get_breakpoint_list (fcn_list);
     }
 
   if (nargout == 0)
     {
       // Print out the breakpoint information.
 
       for (bp_table::fname_line_map_iterator it = bp_list.begin ();
-	   it != bp_list.end (); it++)
-	{	  
-	  octave_stdout << "Breakpoint in " << it->first << " at line(s) ";
+           it != bp_list.end (); it++)
+        {         
+          octave_stdout << "Breakpoint in " << it->first << " at line(s) ";
 
-	  bp_table::intmap m = it->second;
+          bp_table::intmap m = it->second;
 
-	  size_t nel = m.size ();
+          size_t nel = m.size ();
 
-	  for (size_t j = 0; j < nel; j++)
-	    octave_stdout << m[j] << ((j < nel - 1) ? ", " : ".");
+          for (size_t j = 0; j < nel; j++)
+            octave_stdout << m[j] << ((j < nel - 1) ? ", " : ".");
 
-	  if (nel > 0)
-	    octave_stdout << std::endl;
-	}
+          if (nel > 0)
+            octave_stdout << std::endl;
+        }
       return octave_value ();
     }
   else
     {
       // Fill in an array for return.
 
       int i = 0;
       Cell names (dim_vector (bp_list.size (), 1));
       Cell file (dim_vector (bp_list.size (), 1));
       Cell line (dim_vector (bp_list.size (), 1));
 
       for (bp_table::const_fname_line_map_iterator it = bp_list.begin ();
-	   it != bp_list.end (); it++)
-	{
-	  names(i) = it->first;
-	  line(i) = intmap_to_ov (it->second);
-	  file(i) = do_which (it->first);
-	  i++;
-	}
+           it != bp_list.end (); it++)
+        {
+          names(i) = it->first;
+          line(i) = intmap_to_ov (it->second);
+          file(i) = do_which (it->first);
+          i++;
+        }
 
       retval.assign ("name", names);
       retval.assign ("file", file);
       retval.assign ("line", line);
 
       return octave_value (retval);
     }
 }
@@ -647,55 +647,55 @@ Show where we are in the code\n\
 
   if (dbg_fcn)
     {
       bool have_file = true;
 
       std::string name = dbg_fcn->fcn_file_name ();
 
       if (name.empty ())
-	{
-	  have_file = false;
+        {
+          have_file = false;
 
-	  name = dbg_fcn->name ();
-	}
+          name = dbg_fcn->name ();
+        }
 
       octave_stdout << name << ":";
 
       unwind_protect frame;
 
       frame.add_fcn (octave_call_stack::restore_frame, 
                      octave_call_stack::current_frame ());
 
       // Skip the frame assigned to the dbwhere function.
       octave_call_stack::goto_frame_relative (0);
 
       int l = octave_call_stack::current_line ();
 
       if (l > 0)
-	{
-	  octave_stdout << " line " << l;
+        {
+          octave_stdout << " line " << l;
 
-	  int c = octave_call_stack::current_column ();
+          int c = octave_call_stack::current_column ();
 
-	  if (c > 0)
-	    octave_stdout << ", column " << c;
+          if (c > 0)
+            octave_stdout << ", column " << c;
 
-	  octave_stdout << std::endl;
+          octave_stdout << std::endl;
 
-	  if (have_file)
-	    {
-	      std::string line = get_file_line (name, l);
+          if (have_file)
+            {
+              std::string line = get_file_line (name, l);
 
-	      if (! line.empty ())
-		octave_stdout << l << ": " << line << std::endl;
-	    }
-	}
+              if (! line.empty ())
+                octave_stdout << l << ": " << line << std::endl;
+            }
+        }
       else
-	octave_stdout << " (unknown line)\n";
+        octave_stdout << " (unknown line)\n";
     }
   else
     error ("dbwhere: must be inside of a user function to use dbwhere\n");
 
   return retval;
 }
 
 // Copied and modified from the do_type command in help.cc
@@ -705,40 +705,40 @@ do_dbtype (std::ostream& os, const std::
 {
   std::string ff = fcn_file_in_path (name);
 
   if (! ff.empty ())
     {
       std::ifstream fs (ff.c_str (), std::ios::in);
 
       if (fs)
-	{
-	  char ch;
-	  int line = 1;
-	
-	  if (line >= start && line <= end)
-	    os << line << "\t";
- 	
-	  while (fs.get (ch))
-	    {
-	      if (line >= start && line <= end)
-		{
-		  os << ch;
-		}
+        {
+          char ch;
+          int line = 1;
+        
+          if (line >= start && line <= end)
+            os << line << "\t";
+        
+          while (fs.get (ch))
+            {
+              if (line >= start && line <= end)
+                {
+                  os << ch;
+                }
 
-	      if (ch == '\n')
-		{
-		  line++;
-		  if (line >= start && line <= end)
-		    os << line << "\t";
-		}
-	    }
-	}
+              if (ch == '\n')
+                {
+                  line++;
+                  if (line >= start && line <= end)
+                    os << line << "\t";
+                }
+            }
+        }
       else
-	os << "dbtype: unable to open `" << ff << "' for reading!\n";
+        os << "dbtype: unable to open `" << ff << "' for reading!\n";
     }
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
@@ -752,101 +752,101 @@ List script file with line numbers.\n\
   octave_user_code *dbg_fcn;
 
   int nargin = args.length ();
   string_vector argv = args.make_argv ("dbtype");
 
   if (! error_state)
     {
       switch (nargin)
-	{
-	case 0: // dbtype
-	  dbg_fcn = get_user_code ();
+        {
+        case 0: // dbtype
+          dbg_fcn = get_user_code ();
 
-	  if (dbg_fcn)
-	    do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
-	  else
-	    error ("dbtype: must be in a user function to give no arguments to dbtype\n");
-	  break;
+          if (dbg_fcn)
+            do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
+          else
+            error ("dbtype: must be in a user function to give no arguments to dbtype\n");
+          break;
 
-	case 1: // (dbtype func) || (dbtype start:end)
-	  dbg_fcn = get_user_code (argv[1]);
+        case 1: // (dbtype func) || (dbtype start:end)
+          dbg_fcn = get_user_code (argv[1]);
 
-	  if (dbg_fcn)
-	    do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
-	  else
-	    {
-	      dbg_fcn = get_user_code ();
+          if (dbg_fcn)
+            do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
+          else
+            {
+              dbg_fcn = get_user_code ();
 
-	      if (dbg_fcn)
-		{
-		  std::string arg = argv[1];
+              if (dbg_fcn)
+                {
+                  std::string arg = argv[1];
 
-		  size_t ind = arg.find (':');
+                  size_t ind = arg.find (':');
 
-		  if (ind != std::string::npos)
-		    {
-		      std::string start_str = arg.substr (0, ind);
-		      std::string end_str = arg.substr (ind + 1);
+                  if (ind != std::string::npos)
+                    {
+                      std::string start_str = arg.substr (0, ind);
+                      std::string end_str = arg.substr (ind + 1);
 
-		      int start = atoi (start_str.c_str ());
-		      int end = atoi (end_str.c_str ());
-		
-		      if (std::min (start, end) <= 0)
- 			error ("dbtype: start and end lines must be >= 1\n");
+                      int start = atoi (start_str.c_str ());
+                      int end = atoi (end_str.c_str ());
+                
+                      if (std::min (start, end) <= 0)
+                        error ("dbtype: start and end lines must be >= 1\n");
 
-		      if (start <= end)
-			do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
-		      else
-			error ("dbtype: start line must be less than end line\n");
-		    }
-		  else
-		    error ("dbtype: line specification must be `start:end'");
-		}
-	    }
-	  break;
+                      if (start <= end)
+                        do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
+                      else
+                        error ("dbtype: start line must be less than end line\n");
+                    }
+                  else
+                    error ("dbtype: line specification must be `start:end'");
+                }
+            }
+          break;
 
-	case 2: // (dbtype func start:end) , (dbtype func start)
-	  dbg_fcn = get_user_code (argv[1]);
+        case 2: // (dbtype func start:end) , (dbtype func start)
+          dbg_fcn = get_user_code (argv[1]);
 
-	  if (dbg_fcn)
-	    {
-	      std::string arg = argv[2];
-	      int start = 0;
-	      int end = 0;
-	      size_t ind = arg.find (':');
+          if (dbg_fcn)
+            {
+              std::string arg = argv[2];
+              int start = 0;
+              int end = 0;
+              size_t ind = arg.find (':');
 
-	      if (ind != std::string::npos)
-		{
-		  std::string start_str = arg.substr (0, ind);
-		  std::string end_str = arg.substr (ind + 1);
+              if (ind != std::string::npos)
+                {
+                  std::string start_str = arg.substr (0, ind);
+                  std::string end_str = arg.substr (ind + 1);
 
-		  start = atoi (start_str.c_str ());
-		  end = atoi (end_str.c_str ());
-		  
-		}
-	      else
-		{
-		  start = atoi (arg.c_str ());
-		  end = start;
-		}
+                  start = atoi (start_str.c_str ());
+                  end = atoi (end_str.c_str ());
+                  
+                }
+              else
+                {
+                  start = atoi (arg.c_str ());
+                  end = start;
+                }
 
-	      if (std::min (start, end) <= 0)
-		error ("dbtype: start and end lines must be >= 1\n");
-	      
-	      if (start <= end)
-		do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
-	      else
-		error ("dbtype: start line must be less than end line\n");
-	    }
-	  break;
+              if (std::min (start, end) <= 0)
+                error ("dbtype: start and end lines must be >= 1\n");
+              
+              if (start <= end)
+                do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
+              else
+                error ("dbtype: start line must be less than end line\n");
+            }
+          break;
 
-	default:
-	  error ("dbtype: expecting zero, one, or two arguments\n");
-	}
+        default:
+          error ("dbtype: expecting zero, one, or two arguments\n");
+        }
     }
 
   return retval;
 }
 
 DEFUN (dbstack, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{stack}, @var{idx}]} dbstack (@var{n})\n\
@@ -865,96 +865,96 @@ Print or return current stack informatio
 
   if (args.length () == 1)
     {
       int n = 0;
 
       octave_value arg = args(0);
 
       if (arg.is_string ())
-	{
-	  std::string s_arg = arg.string_value ();
+        {
+          std::string s_arg = arg.string_value ();
 
-	  n = atoi (s_arg.c_str ());
-	}
+          n = atoi (s_arg.c_str ());
+        }
       else
-	n = args(0).int_value ();
+        n = args(0).int_value ();
 
       if (n > 0)
-	nskip = n;
+        nskip = n;
       else
-	error ("dbstack: expecting N to be a nonnegative integer");
+        error ("dbstack: expecting N to be a nonnegative integer");
     }
 
   if (! error_state)
     {
       Octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
 
       if (nargout == 0)
-	{
-	  octave_idx_type nframes_to_display = stk.numel ();
+        {
+          octave_idx_type nframes_to_display = stk.numel ();
 
-	  if (nframes_to_display > 0)
-	    {
-	      octave_stdout << "Stopped in:\n\n";
+          if (nframes_to_display > 0)
+            {
+              octave_stdout << "Stopped in:\n\n";
 
-	      Cell names = stk.contents ("name");
-	      Cell lines = stk.contents ("line");
-	      Cell columns = stk.contents ("column");
+              Cell names = stk.contents ("name");
+              Cell lines = stk.contents ("line");
+              Cell columns = stk.contents ("column");
 
-	      for (octave_idx_type i = 0; i < nframes_to_display; i++)
-		{
-		  octave_value name = names(i);
-		  octave_value line = lines(i);
-		  octave_value column = columns(i);
+              for (octave_idx_type i = 0; i < nframes_to_display; i++)
+                {
+                  octave_value name = names(i);
+                  octave_value line = lines(i);
+                  octave_value column = columns(i);
 
-		  octave_stdout << (i == curr_frame ? "--> " : "    ")
-				<< name.string_value ()
-				<< " at line " << line.int_value ()
-				<< " column " << column.int_value ()
-				<< std::endl;
-		}
-	    }
-	}
+                  octave_stdout << (i == curr_frame ? "--> " : "    ")
+                                << name.string_value ()
+                                << " at line " << line.int_value ()
+                                << " column " << column.int_value ()
+                                << std::endl;
+                }
+            }
+        }
       else
-	{
-	  retval(1) = curr_frame < 0 ? 1 : curr_frame + 1;
-	  retval(0) = stk;
-	}
+        {
+          retval(1) = curr_frame < 0 ? 1 : curr_frame + 1;
+          retval(0) = stk;
+        }
     }
 
   return retval;
 }
 
 static void
 do_dbupdown (const octave_value_list& args, const std::string& who)
 {
   int n = 1;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_string ())
-	{
-	  std::string s_arg = arg.string_value ();
+        {
+          std::string s_arg = arg.string_value ();
 
-	  n = atoi (s_arg.c_str ());
-	}
+          n = atoi (s_arg.c_str ());
+        }
       else
-	n = args(0).int_value ();
+        n = args(0).int_value ();
     }
 
   if (! error_state)
     {
       if (who == "dbup")
-	n = -n;
+        n = -n;
 
       if (! octave_call_stack::goto_frame_relative (n, true))
-	error ("%s: invalid stack frame", who.c_str ());
+        error ("%s: invalid stack frame", who.c_str ());
     }
 }
 
 DEFUN (dbup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} dbup\n\
 @deftypefnx {Loadable Function} {} dbup (@var{n})\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
@@ -1002,61 +1002,61 @@ execution to continue until the current 
 @seealso{dbcont, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       int nargin = args.length ();
       
       if (nargin > 1)
-	print_usage ();
+        print_usage ();
       else if (nargin == 1)
-	{
-	  if (args(0).is_string ())
-	    {
-	      std::string arg = args(0).string_value ();
+        {
+          if (args(0).is_string ())
+            {
+              std::string arg = args(0).string_value ();
 
-	      if (! error_state)
-		{
-		  if (arg == "in")
-		    {
-		      Vdebugging = false;
+              if (! error_state)
+                {
+                  if (arg == "in")
+                    {
+                      Vdebugging = false;
 
-		      tree_evaluator::dbstep_flag = -1;
-		    }
-		  else if (arg == "out")
-		    {
-		      Vdebugging = false;
+                      tree_evaluator::dbstep_flag = -1;
+                    }
+                  else if (arg == "out")
+                    {
+                      Vdebugging = false;
 
-		      tree_evaluator::dbstep_flag = -2;
-		    }
-		  else
-		    {
-		      int n = atoi (arg.c_str ());
+                      tree_evaluator::dbstep_flag = -2;
+                    }
+                  else
+                    {
+                      int n = atoi (arg.c_str ());
 
-		      if (n > 0)
-			{
-			  Vdebugging = false;
+                      if (n > 0)
+                        {
+                          Vdebugging = false;
 
-			  tree_evaluator::dbstep_flag = n;
-			}
-		      else
-			error ("dbstep: invalid argument");
-		    }
-		}
-	    }
-	  else
-	    error ("dbstep: expecting character string as argument");
-	}
+                          tree_evaluator::dbstep_flag = n;
+                        }
+                      else
+                        error ("dbstep: invalid argument");
+                    }
+                }
+            }
+          else
+            error ("dbstep: expecting character string as argument");
+        }
       else
-	{
-	  Vdebugging = false;
+        {
+          Vdebugging = false;
 
-	  tree_evaluator::dbstep_flag = 1;
-	}
+          tree_evaluator::dbstep_flag = 1;
+        }
     }
   else
     error ("dbstep: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
@@ -1066,23 +1066,23 @@ DEFUN (dbcont, args, ,
 @deftypefn {Command} {} dbcont\n\
 In debugging mode, quit debugging mode and continue execution.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () == 0)
-	{
-	  Vdebugging = false;
+        {
+          Vdebugging = false;
 
           tree_evaluator::reset_debug_state ();
-	}
+        }
       else
-	print_usage ();
+        print_usage ();
     }
   else
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (dbquit, args, ,
@@ -1090,25 +1090,25 @@ DEFUN (dbquit, args, ,
 @deftypefn {Command} {} dbquit\n\
 In debugging mode, quit debugging mode and return to the top level.\n\
 @seealso{dbstep, dbcont}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () == 0)
-	{
-	  Vdebugging = false;
+        {
+          Vdebugging = false;
 
           tree_evaluator::reset_debug_state ();
 
-	  octave_throw_interrupt_exception ();
-	}
+          octave_throw_interrupt_exception ();
+        }
       else
-	print_usage ();
+        print_usage ();
     }
   else
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -101,22 +101,22 @@ subst_octave_home (const std::string& s)
 
   retval = s;
 
   if (Voctave_home != prefix)
     {
       octave_idx_type len = prefix.length ();
 
       if (s.substr (0, len) == prefix)
-	retval.replace (0, len, Voctave_home);
+        retval.replace (0, len, Voctave_home);
     }
 
   if (file_ops::dir_sep_char () != '/')
     std::replace (retval.begin (), retval.end (), '/',
-		  file_ops::dir_sep_char ());
+                  file_ops::dir_sep_char ());
 
   return retval;
 }
 
 static void
 set_octave_home (void)
 {
   std::string oh = octave_env::getenv ("OCTAVE_HOME");
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -64,53 +64,53 @@ print_usage (const std::string& name)
 }
 
 void
 check_version (const std::string& version, const std::string& fcn)
 {
   if (version != OCTAVE_API_VERSION)
     {
       error ("API version %s found in .oct file function `%s'\n"
-	     "       does not match the running Octave (API version %s)\n"
-	     "       this can lead to incorrect results or other failures\n"
-	     "       you can fix this problem by recompiling this .oct file",
-	     version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
+             "       does not match the running Octave (API version %s)\n"
+             "       this can lead to incorrect results or other failures\n"
+             "       you can fix this problem by recompiling this .oct file",
+             version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
     }
 }
 
 // Install variables and functions in the symbol tables.
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
-			  const std::string& doc,
-			  bool /* can_hide_function -- not yet implemented */)
+                          const std::string& doc,
+                          bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (f, name, doc));
 
   symbol_table::install_built_in_function (name, fcn);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
-		      const octave_shlib& shl, const std::string& doc,
-		      bool relative)
+                      const octave_shlib& shl, const std::string& doc,
+                      bool relative)
 {
   octave_dld_function *fcn = new octave_dld_function (f, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
   symbol_table::install_built_in_function (name, fval);
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-		      const octave_shlib& shl, bool relative)
+                      const octave_shlib& shl, bool relative)
 {
   octave_mex_function *fcn = new octave_mex_function (fptr, fmex, shl, name);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -120,27 +120,27 @@ directory is not changed.\n\
   if (error_state)
     return retval;
 
   if (argc > 1)
     {
       std::string dirname = argv[1];
 
       if (dirname.length () > 0
-	  && ! octave_change_to_directory (dirname))
-	{
-	  return retval;
-	}
+          && ! octave_change_to_directory (dirname))
+        {
+          return retval;
+        }
     }
   else
     {
       std::string home_dir = octave_env::get_home_directory ();
 
       if (home_dir.empty () || ! octave_change_to_directory (home_dir))
-	return retval;
+        return retval;
     }
 
   return retval;
 }
 
 DEFALIAS (chdir, cd);
 
 DEFUN (pwd, , ,
@@ -171,32 +171,32 @@ system-dependent error message.\n\
   retval(1) = -1.0;
   retval(0) = Cell ();
 
   if (args.length () == 1)
     {
       std::string dirname = args(0).string_value ();
 
       if (error_state)
-	gripe_wrong_type_arg ("readdir", args(0));
+        gripe_wrong_type_arg ("readdir", args(0));
       else
-	{
-	  dir_entry dir (dirname);
+        {
+          dir_entry dir (dirname);
 
-	  if (dir)
-	    {
-	      string_vector dirlist = dir.read ();
-	      retval(0) = Cell (dirlist.sort ());
-	      retval(1) = 0.0;
-	    }
-	  else
-	    {
-	      retval(2) = dir.error ();
-	    }
-	}
+          if (dir)
+            {
+              string_vector dirlist = dir.read ();
+              retval(0) = Cell (dirlist.sort ());
+              retval(1) = 0.0;
+            }
+          else
+            {
+              retval(2) = dir.error ();
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // FIXME -- should maybe also allow second arg to specify
@@ -226,63 +226,63 @@ message identifier.\n\
   std::string dirname;
 
   if (nargin == 2)
     {
       std::string parent = args(0).string_value ();
       std::string dir = args(1).string_value ();
 
       if (error_state)
-	{
-	  gripe_wrong_type_arg ("mkdir", args(0));
-	  return retval;
-	}
+        {
+          gripe_wrong_type_arg ("mkdir", args(0));
+          return retval;
+        }
       else
-	dirname = file_ops::concat (parent, dir);
+        dirname = file_ops::concat (parent, dir);
     }
   else if (nargin == 1)
     {
       dirname = args(0).string_value ();
 
       if (error_state)
-	{
-	  gripe_wrong_type_arg ("mkdir", args(0));
-	  return retval;
-	}
+        {
+          gripe_wrong_type_arg ("mkdir", args(0));
+          return retval;
+        }
     }
 
   if (nargin == 1 || nargin == 2)
     {
       std::string msg;
 
       dirname = file_ops::tilde_expand (dirname);
 
       file_stat fs (dirname);
 
       if (fs && fs.is_dir ())
-	{
-	  // For compatibility with Matlab, we return true when the
-	  // directory already exists.
+        {
+          // For compatibility with Matlab, we return true when the
+          // directory already exists.
 
-	  retval(2) = "mkdir";
-	  retval(1) = "directory exists";
-	  retval(0) = true;
-	}
+          retval(2) = "mkdir";
+          retval(1) = "directory exists";
+          retval(0) = true;
+        }
       else
-	{
-	  int status = octave_mkdir (dirname, 0777, msg);
+        {
+          int status = octave_mkdir (dirname, 0777, msg);
 
-	  if (status < 0)
-	    {
-	      retval(2) = "mkdir";
-	      retval(1) = msg;
-	    }
-	  else
-	    retval(0) = true;
-	}
+          if (status < 0)
+            {
+              retval(2) = "mkdir";
+              retval(1) = msg;
+            }
+          else
+            retval(0) = true;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rmdir", Frmdir, args, ,
@@ -309,54 +309,54 @@ recursively remove all subdirectories as
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string dirname = args(0).string_value ();
 
       if (error_state)
-	gripe_wrong_type_arg ("rmdir", args(0));
+        gripe_wrong_type_arg ("rmdir", args(0));
       else
-	{
-	  std::string fulldir = file_ops::tilde_expand (dirname);
-	  int status = -1;
-	  std::string msg;
+        {
+          std::string fulldir = file_ops::tilde_expand (dirname);
+          int status = -1;
+          std::string msg;
 
-	  if (nargin == 2)
-	    {
-	      if (args(1).string_value () == "s")
-		{
-		  bool doit = true;
+          if (nargin == 2)
+            {
+              if (args(1).string_value () == "s")
+                {
+                  bool doit = true;
 
-		  if (interactive && Vconfirm_recursive_rmdir)
-		    {
-		      std::string prompt
-			= "remove entire contents of " + fulldir + "? ";
+                  if (interactive && Vconfirm_recursive_rmdir)
+                    {
+                      std::string prompt
+                        = "remove entire contents of " + fulldir + "? ";
 
-		      doit = octave_yes_or_no (prompt);
-		    }
+                      doit = octave_yes_or_no (prompt);
+                    }
 
-		  if (doit)
-		    status = octave_recursive_rmdir (fulldir, msg);
-		}
-	      else
-		error ("rmdir: expecting second argument to be \"s\"");
-	    }
-	  else
-	    status = octave_rmdir (fulldir, msg);
+                  if (doit)
+                    status = octave_recursive_rmdir (fulldir, msg);
+                }
+              else
+                error ("rmdir: expecting second argument to be \"s\"");
+            }
+          else
+            status = octave_rmdir (fulldir, msg);
 
-	  if (status < 0)
-	    {
-	      retval(2) = "rmdir";
-	      retval(1) = msg;
-	    }
-	  else
-	    retval(0) = true;
-	}
+          if (status < 0)
+            {
+              retval(2) = "rmdir";
+              retval(1) = msg;
+            }
+          else
+            retval(0) = true;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("link", Flink, args, ,
@@ -375,35 +375,35 @@ system-dependent error message.\n\
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
       std::string from = args(0).string_value ();
 
       if (error_state)
-	gripe_wrong_type_arg ("link", args(0));
+        gripe_wrong_type_arg ("link", args(0));
       else
-	{
-	  std::string to = args(1).string_value ();
+        {
+          std::string to = args(1).string_value ();
 
-	  if (error_state)
-	    gripe_wrong_type_arg ("link", args(1));
-	  else
-	    {
-	      std::string msg;
+          if (error_state)
+            gripe_wrong_type_arg ("link", args(1));
+          else
+            {
+              std::string msg;
 
-	      int status = octave_link (from, to, msg);
+              int status = octave_link (from, to, msg);
 
-	      retval(0) = status;
+              retval(0) = status;
 
-	      if (status < 0)
-		retval(1) = msg;
-	    }
-	}
+              if (status < 0)
+                retval(1) = msg;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
@@ -422,35 +422,35 @@ system-dependent error message.\n\
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
       std::string from = args(0).string_value ();
 
       if (error_state)
-	gripe_wrong_type_arg ("symlink", args(0));
+        gripe_wrong_type_arg ("symlink", args(0));
       else
-	{
-	  std::string to = args(1).string_value ();
+        {
+          std::string to = args(1).string_value ();
 
-	  if (error_state)
-	    gripe_wrong_type_arg ("symlink", args(1));
-	  else
-	    {
-	      std::string msg;
+          if (error_state)
+            gripe_wrong_type_arg ("symlink", args(1));
+          else
+            {
+              std::string msg;
 
-	      int status = octave_symlink (from, to, msg);
+              int status = octave_symlink (from, to, msg);
 
-	      retval(0) = status;
+              retval(0) = status;
 
-	      if (status < 0)
-		retval(1) = msg;
-	    }
-	}
+              if (status < 0)
+                retval(1) = msg;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
@@ -471,31 +471,31 @@ system-dependent error message.\n\
   retval(1) = -1.0;
   retval(0) = std::string ();
 
   if (args.length () == 1)
     {
       std::string symlink = args(0).string_value ();
 
       if (error_state)
-	gripe_wrong_type_arg ("readlink", args(0));
+        gripe_wrong_type_arg ("readlink", args(0));
       else
-	{
-	  std::string result;
-	  std::string msg;
+        {
+          std::string result;
+          std::string msg;
 
-	  int status = octave_readlink (symlink, result, msg);
+          int status = octave_readlink (symlink, result, msg);
 
-	  retval(0) = result;
+          retval(0) = result;
 
-	  retval(1) = status;
+          retval(1) = status;
 
-	  if (status < 0)
-	    retval(2) = msg;
-	}
+          if (status < 0)
+            retval(2) = msg;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rename", Frename, args, ,
@@ -514,35 +514,35 @@ system-dependent error message.\n\
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
       std::string from = args(0).string_value ();
 
       if (error_state)
-	gripe_wrong_type_arg ("rename", args(0));
+        gripe_wrong_type_arg ("rename", args(0));
       else
-	{
-	  std::string to = args(1).string_value ();
+        {
+          std::string to = args(1).string_value ();
 
-	  if (error_state)
-	    gripe_wrong_type_arg ("rename", args(1));
-	  else
-	    {
-	      std::string msg;
+          if (error_state)
+            gripe_wrong_type_arg ("rename", args(1));
+          else
+            {
+              std::string msg;
 
-	      int status = octave_rename (from, to, msg);
+              int status = octave_rename (from, to, msg);
 
-	      retval(0) = status;
+              retval(0) = status;
 
-	      if (status < 0)
-		retval(1) = msg;
-	    }
-	}
+              if (status < 0)
+                retval(1) = msg;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (glob, args, ,
@@ -565,23 +565,23 @@ glob (\"/vm*\")\n\
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       string_vector pat = args(0).all_strings ();
 
       if (error_state)
-	gripe_wrong_type_arg ("glob", args(0));
+        gripe_wrong_type_arg ("glob", args(0));
       else
-	{
-	  glob_match pattern (file_ops::tilde_expand (pat));
+        {
+          glob_match pattern (file_ops::tilde_expand (pat));
 
-	  retval = Cell (pattern.glob ());
-	}
+          retval = Cell (pattern.glob ());
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fnmatch, args, ,
@@ -602,23 +602,23 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
   octave_value retval;
 
   if (args.length () == 2)
     {
       string_vector pat = args(0).all_strings ();
       string_vector str = args(1).all_strings ();
 
       if (error_state)
-	gripe_wrong_type_arg ("fnmatch", args(0));
+        gripe_wrong_type_arg ("fnmatch", args(0));
       else
-	{
-	  glob_match pattern (file_ops::tilde_expand (pat));
+        {
+          glob_match pattern (file_ops::tilde_expand (pat));
 
-	  retval = pattern.match (str);
-	}
+          retval = pattern.match (str);
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (filesep, args, ,
@@ -638,24 +638,24 @@ backward slashes) under Windows.\n\
 
   if (args.length () == 0)
     retval = file_ops::dir_sep_str ();
   else if (args.length () == 1)
     {
       std::string s = args(0).string_value ();
 
       if (! error_state)
-	{
-	  if (s == "all")
-	    retval = file_ops::dir_sep_chars ();
-	  else
-	    gripe_wrong_type_arg ("filesep", args(0));
-	}
+        {
+          if (s == "all")
+            retval = file_ops::dir_sep_chars ();
+          else
+            gripe_wrong_type_arg ("filesep", args(0));
+        }
       else
-	gripe_wrong_type_arg ("filesep", args(0));
+        gripe_wrong_type_arg ("filesep", args(0));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
@@ -674,34 +674,34 @@ a path.\n\
   if (nargout > 0 || nargin == 0)
     retval = dir_path::path_sep_str ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).string_value ();
 
       if (! error_state)
-	{
-	  switch (sval.length ())
-	    {
-	    case 1:
-	      dir_path::path_sep_char (sval[0]);
-	      break;
+        {
+          switch (sval.length ())
+            {
+            case 1:
+              dir_path::path_sep_char (sval[0]);
+              break;
 
-	    case 0:
-	      dir_path::path_sep_char ('\0');
-	      break;
+            case 0:
+              dir_path::path_sep_char ('\0');
+              break;
 
-	    default:
-	      error ("pathsep: argument must be a single character");
-	      break;
-	    }
-	}
+            default:
+              error ("pathsep: argument must be a single character");
+              break;
+            }
+        }
       else
-	error ("pathsep: argument must be a single character");
+        error ("pathsep: argument must be a single character");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
diff --git a/src/display.cc b/src/display.cc
--- a/src/display.cc
+++ b/src/display.cc
@@ -44,91 +44,91 @@ display_info::init (bool query)
 {
   if (query)
     {
 #if defined (OCTAVE_USE_WINDOWS_API)
 
       HDC hdc = GetDC (0);
 
       if (hdc)
-	{
-	  dp = GetDeviceCaps (hdc, BITSPIXEL);
+        {
+          dp = GetDeviceCaps (hdc, BITSPIXEL);
 
-	  ht = GetDeviceCaps (hdc, VERTRES);
-	  wd = GetDeviceCaps (hdc, HORZRES);
+          ht = GetDeviceCaps (hdc, VERTRES);
+          wd = GetDeviceCaps (hdc, HORZRES);
 
-	  double ht_mm = GetDeviceCaps (hdc, VERTSIZE);
-	  double wd_mm = GetDeviceCaps (hdc, HORZSIZE);
+          double ht_mm = GetDeviceCaps (hdc, VERTSIZE);
+          double wd_mm = GetDeviceCaps (hdc, HORZSIZE);
 
-	  rx = wd * 25.4 / wd_mm;
-	  ry = ht * 25.4 / ht_mm;
-	}
+          rx = wd * 25.4 / wd_mm;
+          ry = ht * 25.4 / ht_mm;
+        }
       else
-	warning ("no graphical display found");
+        warning ("no graphical display found");
 
 #elif defined (HAVE_FRAMEWORK_CARBON)
 
       CGDirectDisplayID display = CGMainDisplayID ();
 
       if (display)
-	{
-	  dp = CGDisplayBitsPerPixel (display);
+        {
+          dp = CGDisplayBitsPerPixel (display);
 
-	  ht = CGDisplayPixelsHigh (display);
-	  wd = CGDisplayPixelsWide (display);
+          ht = CGDisplayPixelsHigh (display);
+          wd = CGDisplayPixelsWide (display);
 
-	  CGSize sz_mm = CGDisplayScreenSize (display);
+          CGSize sz_mm = CGDisplayScreenSize (display);
 
-	  // On modern Mac systems (>= 10.5) CGSize is a struct keeping 2
-	  // CGFloat values, but the CGFloat typedef is not present on
-	  // older systems, so use double instead.
-	  double ht_mm = sz_mm.height;
-	  double wd_mm = sz_mm.width;
+          // On modern Mac systems (>= 10.5) CGSize is a struct keeping 2
+          // CGFloat values, but the CGFloat typedef is not present on
+          // older systems, so use double instead.
+          double ht_mm = sz_mm.height;
+          double wd_mm = sz_mm.width;
 
-	  rx = wd * 25.4 / wd_mm;
-	  ry = ht * 25.4 / ht_mm;
-	}
+          rx = wd * 25.4 / wd_mm;
+          ry = ht * 25.4 / ht_mm;
+        }
       else
-	warning ("no graphical display found");
+        warning ("no graphical display found");
 
 #elif defined (HAVE_X_WINDOWS)
 
       const char *display_name = getenv ("DISPLAY");
 
       if (display_name && *display_name)
-	{
-	  Display *display = XOpenDisplay (display_name);
+        {
+          Display *display = XOpenDisplay (display_name);
 
-	  if (display)
-	    {
-	      Screen *screen = DefaultScreenOfDisplay (display);
+          if (display)
+            {
+              Screen *screen = DefaultScreenOfDisplay (display);
 
-	      if (screen)
-		{
-		  dp = DefaultDepthOfScreen (screen);
+              if (screen)
+                {
+                  dp = DefaultDepthOfScreen (screen);
 
-		  ht = HeightOfScreen (screen);
-		  wd = WidthOfScreen (screen);
+                  ht = HeightOfScreen (screen);
+                  wd = WidthOfScreen (screen);
 
-		  int screen_number = XScreenNumberOfScreen (screen);
+                  int screen_number = XScreenNumberOfScreen (screen);
 
-		  double ht_mm = DisplayHeightMM (display, screen_number);
-		  double wd_mm = DisplayWidthMM (display, screen_number);
+                  double ht_mm = DisplayHeightMM (display, screen_number);
+                  double wd_mm = DisplayWidthMM (display, screen_number);
 
-		  rx = wd * 25.4 / wd_mm;
-		  ry = ht * 25.4 / ht_mm;
-		}
-	      else
-		warning ("X11 display has no default screen");
-	    }
-	  else
-	    warning ("unable to open X11 DISPLAY");
-	}
+                  rx = wd * 25.4 / wd_mm;
+                  ry = ht * 25.4 / ht_mm;
+                }
+              else
+                warning ("X11 display has no default screen");
+            }
+          else
+            warning ("unable to open X11 DISPLAY");
+        }
       else
-	warning ("X11 DISPLAY environment variable not set");
+        warning ("X11 DISPLAY environment variable not set");
 #else
 
       warning ("no graphical display found");
 
 #endif
     }
 }
 
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -96,45 +96,45 @@ octave_shlib_list *octave_shlib_list::in
 void
 octave_shlib_list::do_append (const octave_shlib& shl)
 {
   lib_list.push_back (shl);
 }
 
 void
 octave_shlib_list::do_remove (octave_shlib& shl,
-			      octave_shlib::close_hook cl_hook)
+                              octave_shlib::close_hook cl_hook)
 {
   for (iterator p = lib_list.begin (); p != lib_list.end (); p++)
     {
       if (*p == shl)
-	{
+        {
           // Erase first to avoid potentially invalidating the pointer by the
           // following hooks.
-	  lib_list.erase (p);
+          lib_list.erase (p);
 
-	  shl.close (cl_hook);
+          shl.close (cl_hook);
 
-	  break;
-	}
+          break;
+        }
     }
 }
 
 octave_shlib
 octave_shlib_list::do_find_file (const std::string& file_name) const
 {
   octave_shlib retval;
 
   for (const_iterator p = lib_list.begin (); p != lib_list.end (); p++)
     {
       if (p->file_name () == file_name)
-	{
-	  retval = *p;
-	  break;
-	}
+        {
+          retval = *p;
+          break;
+        }
     }
 
   return retval;
 }
 
 void
 octave_shlib_list::do_display (void) const
 {
@@ -165,17 +165,17 @@ void
 octave_shlib_list::append (const octave_shlib& shl)
 {
   if (instance_ok ())
     instance->do_append (shl);
 }
 
 void
 octave_shlib_list::remove (octave_shlib& shl,
-			   octave_shlib::close_hook cl_hook)
+                           octave_shlib::close_hook cl_hook)
 {
   if (instance_ok ())
     instance->do_remove (shl, cl_hook);
 }
 
 octave_shlib
 octave_shlib_list::find_file (const std::string& file_name)
 {
@@ -231,30 +231,30 @@ octave_mex_file_list *octave_mex_file_li
 void
 octave_mex_file_list::do_append (const octave_shlib& shl)
 {
   file_list.push_back (shl);
 }
 
 void
 octave_mex_file_list::do_remove (octave_shlib& shl,
-				 octave_shlib::close_hook cl_hook)
+                                 octave_shlib::close_hook cl_hook)
 {
   for (iterator p = file_list.begin (); p != file_list.end (); p++)
     {
       if (*p == shl)
-	{
+        {
           // Erase first to avoid potentially invalidating the pointer by the
           // following hooks.
-	  file_list.erase (p);
+          file_list.erase (p);
 
-	  shl.close (cl_hook);
+          shl.close (cl_hook);
 
-	  break;
-	}
+          break;
+        }
     }
 }
 
 bool
 octave_mex_file_list::instance_ok (void)
 {
   bool retval = true;
 
@@ -275,17 +275,17 @@ void
 octave_mex_file_list::append (const octave_shlib& shl)
 {
   if (instance_ok ())
     instance->do_append (shl);
 }
 
 void
 octave_mex_file_list::remove (octave_shlib& shl,
-			      octave_shlib::close_hook cl_hook)
+                              octave_shlib::close_hook cl_hook)
 {
   if (instance_ok ())
     instance->do_remove (shl, cl_hook);
 }
 
 octave_dynamic_loader *octave_dynamic_loader::instance = 0;
 
 bool octave_dynamic_loader::doing_load = false;
@@ -328,18 +328,18 @@ clear (octave_shlib& oct_file)
       octave_shlib_list::remove (oct_file, do_clear_function);
     }
   else
     octave_shlib_list::remove (oct_file, symbol_table::clear_dld_function);
 }
 
 octave_function *
 octave_dynamic_loader::do_load_oct (const std::string& fcn_name,
-				    const std::string& file_name,
-				    bool relative)
+                                    const std::string& file_name,
+                                    bool relative)
 {
   octave_function *retval = 0;
 
   unwind_protect frame;
 
   frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
@@ -355,51 +355,51 @@ octave_dynamic_loader::do_load_oct (cons
 
       if (! error_state && oct_file)
         octave_shlib_list::append (oct_file);
     }
 
   if (! error_state)
     {
       if (oct_file)
-	{
-	  void *function = oct_file.search (fcn_name, name_mangler);
+        {
+          void *function = oct_file.search (fcn_name, name_mangler);
 
-	  if (! function)
-	    {
-	      // FIXME -- can we determine this C mangling scheme
-	      // automatically at run time or configure time?
+          if (! function)
+            {
+              // FIXME -- can we determine this C mangling scheme
+              // automatically at run time or configure time?
 
-	      function = oct_file.search (fcn_name, name_uscore_mangler);
-	    }
+              function = oct_file.search (fcn_name, name_uscore_mangler);
+            }
 
-	  if (function)
-	    {
-	      octave_dld_fcn_getter f
-		= FCN_PTR_CAST (octave_dld_fcn_getter, function);
+          if (function)
+            {
+              octave_dld_fcn_getter f
+                = FCN_PTR_CAST (octave_dld_fcn_getter, function);
 
-	      retval = f (oct_file, relative);
+              retval = f (oct_file, relative);
 
-	      if (! retval)
-		::error ("failed to install .oct file function `%s'",
-			 fcn_name.c_str ());
-	    }
-	}
+              if (! retval)
+                ::error ("failed to install .oct file function `%s'",
+                         fcn_name.c_str ());
+            }
+        }
       else
-	::error ("%s is not a valid shared library",
-		 file_name.c_str ());
+        ::error ("%s is not a valid shared library",
+                 file_name.c_str ());
     }
   
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
-				    const std::string& file_name,
-				    bool /*relative*/)
+                                    const std::string& file_name,
+                                    bool /*relative*/)
 {
   octave_function *retval = 0;
 
   unwind_protect frame;
 
   frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
@@ -415,124 +415,124 @@ octave_dynamic_loader::do_load_mex (cons
 
       if (! error_state && mex_file)
         octave_shlib_list::append (mex_file);
     }
 
   if (! error_state)
     {
       if (mex_file)
-	{
-	  void *function = 0;
+        {
+          void *function = 0;
 
-	  bool have_fmex = false;
+          bool have_fmex = false;
 
-	  octave_mex_file_list::append (mex_file);
+          octave_mex_file_list::append (mex_file);
 
-	  function = mex_file.search (fcn_name, mex_mangler);
+          function = mex_file.search (fcn_name, mex_mangler);
 
-	  if (! function)
-	    {
-	      // FIXME -- can we determine this C mangling scheme
-	      // automatically at run time or configure time?
+          if (! function)
+            {
+              // FIXME -- can we determine this C mangling scheme
+              // automatically at run time or configure time?
 
-	      function = mex_file.search (fcn_name, mex_uscore_mangler);
+              function = mex_file.search (fcn_name, mex_uscore_mangler);
 
-	      if (! function)
-		{
-		  function = mex_file.search (fcn_name, mex_f77_mangler);
+              if (! function)
+                {
+                  function = mex_file.search (fcn_name, mex_f77_mangler);
 
-		  if (function)
-		    have_fmex = true;
-		}
-	    }
+                  if (function)
+                    have_fmex = true;
+                }
+            }
 
-	  if (function)
-	    retval = new octave_mex_function (function, have_fmex,
-					      mex_file, fcn_name);
-	  else
-	    ::error ("failed to install .mex file function `%s'",
-		     fcn_name.c_str ());
-  	}
+          if (function)
+            retval = new octave_mex_function (function, have_fmex,
+                                              mex_file, fcn_name);
+          else
+            ::error ("failed to install .mex file function `%s'",
+                     fcn_name.c_str ());
+        }
       else
-	::error ("%s is not a valid shared library",
-		 file_name.c_str ());
+        ::error ("%s is not a valid shared library",
+                 file_name.c_str ());
     }
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_oct (const std::string& fcn_name,
-				      octave_shlib& shl)
+                                      octave_shlib& shl)
 {
   bool retval = false;
 
   // We don't need to do anything if this is called because we are in
   // the process of reloading a .oct file that has changed.
 
   if (! doing_load)
     {
       retval = shl.remove (fcn_name);
 
       if (shl.number_of_functions_loaded () == 0)
-	octave_shlib_list::remove (shl);
+        octave_shlib_list::remove (shl);
     }
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_mex (const std::string& fcn_name,
-				      octave_shlib& shl)
+                                      octave_shlib& shl)
 {
   bool retval = false;
 
   // We don't need to do anything if this is called because we are in
   // the process of reloading a .oct file that has changed.
 
   if (! doing_load)
     {
       retval = shl.remove (fcn_name);
 
       if (shl.number_of_functions_loaded () == 0)
-	octave_mex_file_list::remove (shl);
+        octave_mex_file_list::remove (shl);
     }
 
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::load_oct (const std::string& fcn_name,
-				  const std::string& file_name,
-				  bool relative)
+                                  const std::string& file_name,
+                                  bool relative)
 {
   return (instance_ok ())
     ? instance->do_load_oct (fcn_name, file_name, relative) : 0;
 }
 
 octave_function *
 octave_dynamic_loader::load_mex (const std::string& fcn_name,
-				  const std::string& file_name,
-				  bool relative)
+                                  const std::string& file_name,
+                                  bool relative)
 {
   return (instance_ok ())
     ? instance->do_load_mex (fcn_name, file_name, relative) : 0;
 }
 
 bool
 octave_dynamic_loader::remove_oct (const std::string& fcn_name,
-				   octave_shlib& shl)
+                                   octave_shlib& shl)
 {
   return (instance_ok ()) ? instance->do_remove_oct (fcn_name, shl) : false;
 }
 
 bool
 octave_dynamic_loader::remove_mex (const std::string& fcn_name,
-				   octave_shlib& shl)
+                                   octave_shlib& shl)
 {
   return (instance_ok ()) ? instance->do_remove_mex (fcn_name, shl) : false;
 }
 
 std::string
 octave_dynamic_loader::name_mangler (const std::string& name)
 {
   return "G" + name;
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -199,17 +199,17 @@ vwarning (const char *name, const char *
       octave_diary << msg_string;
 
       std::cerr << msg_string;
     }
 }
 
 static void
 verror (bool save_last_error, std::ostream& os,
-	const char *name, const char *id, const char *fmt, va_list args,
+        const char *name, const char *id, const char *fmt, va_list args,
         bool with_cfn = false)
 {
   if (discard_error_messages)
     return;
 
   if (! buffer_error_messages)
     flush_octave_stdout ();
 
@@ -262,83 +262,83 @@ verror (bool save_last_error, std::ostre
       // This is the first error in a possible series.
 
       Vlast_error_id = id;
       Vlast_error_message = base_msg;
 
       octave_user_code *fcn = octave_call_stack::caller_user_code ();
 
       if (fcn)
-	{
-	  octave_idx_type curr_frame = -1;
+        {
+          octave_idx_type curr_frame = -1;
 
-	  Vlast_error_stack = octave_call_stack::backtrace (0, curr_frame);
-	}
+          Vlast_error_stack = octave_call_stack::backtrace (0, curr_frame);
+        }
       else
-	Vlast_error_stack = initialize_last_error_stack ();
+        Vlast_error_stack = initialize_last_error_stack ();
     }
 
   if (buffer_error_messages)
     {
       if (error_message_buffer)
-	msg_string = "error: " + msg_string;
+        msg_string = "error: " + msg_string;
       else
-	error_message_buffer = new std::ostringstream ();
+        error_message_buffer = new std::ostringstream ();
 
       *error_message_buffer << msg_string;
     }
   else
     {
       octave_diary << msg_string;
       os << msg_string;
     }
 }
 
 // Note that we don't actually print any message if the error string
 // is just "" or "\n".  This allows error ("") and error ("\n") to
 // just set the error state.
 
 static void
 error_1 (std::ostream& os, const char *name, const char *id,
-	 const char *fmt, va_list args, bool with_cfn = false)
+         const char *fmt, va_list args, bool with_cfn = false)
 {
   if (error_state != -2)
     {
       if (fmt)
-	{
-	  if (*fmt)
-	    {
-	      size_t len = strlen (fmt);
+        {
+          if (*fmt)
+            {
+              size_t len = strlen (fmt);
 
-	      if (len > 0)
-		{
-		  if (fmt[len - 1] == '\n')
-		    {
-		      if (len > 1)
-			{
-			  char *tmp_fmt = strsave (fmt);
-			  tmp_fmt[len - 1] = '\0';
-			  verror (true, os, name, id, tmp_fmt, args, with_cfn);
-			  delete [] tmp_fmt;
-			}
+              if (len > 0)
+                {
+                  if (fmt[len - 1] == '\n')
+                    {
+                      if (len > 1)
+                        {
+                          char *tmp_fmt = strsave (fmt);
+                          tmp_fmt[len - 1] = '\0';
+                          verror (true, os, name, id, tmp_fmt, args, with_cfn);
+                          delete [] tmp_fmt;
+                        }
 
-		      error_state = -2;
-		    }
-		  else
-		    {
-		      verror (true, os, name, id, fmt, args, with_cfn);
+                      error_state = -2;
+                    }
+                  else
+                    {
+                      verror (true, os, name, id, fmt, args, with_cfn);
 
-		      if (! error_state)
-			error_state = 1;
-		    }
-		}
-	    }
-	}
+                      if (! error_state)
+                        error_state = 1;
+                    }
+                }
+            }
+        }
       else
-	panic ("error_1: invalid format");
+        panic ("error_1: invalid format");
     }
 }
 
 void
 vmessage (const char *name, const char *fmt, va_list args)
 {
   verror (false, std::cerr, name, "", fmt, args);
 }
@@ -349,17 +349,17 @@ message (const char *name, const char *f
   va_list args;
   va_start (args, fmt);
   vmessage (name, fmt, args);
   va_end (args);
 }
 
 void
 vmessage_with_id (const char *name, const char *id, const char *fmt,
-		  va_list args)
+                  va_list args)
 {
   verror (false, std::cerr, name, id, fmt, args);
 }
 
 void
 message_with_id (const char *name, const char *id, const char *fmt, ...)
 {
   va_list args;
@@ -406,35 +406,35 @@ usage_with_id (const char *id, const cha
 }
 
 static void
 pr_where_2 (const char *fmt, va_list args)
 {
   if (fmt)
     {
       if (*fmt)
-	{
-	  size_t len = strlen (fmt);
+        {
+          size_t len = strlen (fmt);
 
-	  if (len > 0)
-	    {
-	      if (fmt[len - 1] == '\n')
-		{
-		  if (len > 1)
-		    {
-		      char *tmp_fmt = strsave (fmt);
-		      tmp_fmt[len - 1] = '\0';
-		      verror (false, std::cerr, 0, "", tmp_fmt, args);
-		      delete [] tmp_fmt;
-		    }
-		}
-	      else
-		verror (false, std::cerr, 0, "", fmt, args);
-	    }
-	}
+          if (len > 0)
+            {
+              if (fmt[len - 1] == '\n')
+                {
+                  if (len > 1)
+                    {
+                      char *tmp_fmt = strsave (fmt);
+                      tmp_fmt[len - 1] = '\0';
+                      verror (false, std::cerr, 0, "", tmp_fmt, args);
+                      delete [] tmp_fmt;
+                    }
+                }
+              else
+                verror (false, std::cerr, 0, "", fmt, args);
+            }
+        }
     }
   else
     panic ("pr_where_2: invalid format");
 }
 
 static void
 pr_where_1 (const char *fmt, ...)
 {
@@ -457,26 +457,26 @@ pr_where (const char *who)
     {
       pr_where_1 ("%s: called from\n", who);
 
       Cell names = stk.contents ("name");
       Cell lines = stk.contents ("line");
       Cell columns = stk.contents ("column");
 
       for (octave_idx_type i = 0; i < nframes_to_display; i++)
-	{
-	  octave_value name = names(i);
-	  octave_value line = lines(i);
-	  octave_value column = columns(i);
+        {
+          octave_value name = names(i);
+          octave_value line = lines(i);
+          octave_value column = columns(i);
 
-	  std::string nm = name.string_value ();
+          std::string nm = name.string_value ();
 
-	  pr_where_1 ("    %s at line %d column %d\n", nm.c_str (),
-		      line.int_value (), column.int_value ());
-	}
+          pr_where_1 ("    %s at line %d column %d\n", nm.c_str (),
+                      line.int_value (), column.int_value ());
+        }
     }
 }
 
 static void
 error_2 (const char *id, const char *fmt, va_list args, bool with_cfn = false)
 {
   int init_state = error_state;
 
@@ -593,62 +593,62 @@ warning_enabled (const std::string& id)
     {
       Cell identifier = warning_options.contents ("identifier");
       Cell state = warning_options.contents ("state");
 
       bool all_found = false;
       bool id_found = false;
 
       for (octave_idx_type i = 0; i < nel; i++)
-	{
-	  octave_value ov = identifier(i);
-	  std::string ovs = ov.string_value ();
+        {
+          octave_value ov = identifier(i);
+          std::string ovs = ov.string_value ();
 
-	  if (! all_found && ovs == "all")
-	    {
-	      all_state = check_state (state(i).string_value ());
+          if (! all_found && ovs == "all")
+            {
+              all_state = check_state (state(i).string_value ());
 
-	      if (all_state >= 0)
-		all_found = true;
-	    }
+              if (all_state >= 0)
+                all_found = true;
+            }
 
-	  if (! id_found && ovs == id)
-	    {
-	      id_state = check_state (state(i).string_value ());
+          if (! id_found && ovs == id)
+            {
+              id_state = check_state (state(i).string_value ());
 
-	      if (id_state >= 0)
-		id_found = true;
-	    }
+              if (id_state >= 0)
+                id_found = true;
+            }
 
-	  if (all_found && id_found)
-	    break;
-	}
+          if (all_found && id_found)
+            break;
+        }
     }
 
   if (all_state == -1)
     panic_impossible ();
 
   if (all_state == 0)
     {
       if (id_state >= 0)
-	retval = id_state;
+        retval = id_state;
     }
   else if (all_state == 1)
     {
       if (id_state == 0 || id_state == 2)
-	retval = id_state;
+        retval = id_state;
       else
-	retval = all_state;
+        retval = all_state;
     }
   else if (all_state == 2)
     {
       if (id_state == 0)
-	retval= id_state;
+        retval= id_state;
       else
-	retval = all_state;
+        retval = all_state;
     }
 
   return retval;
 }
 
 static void
 warning_1 (const char *id, const char *fmt, va_list args)
 {
@@ -660,33 +660,33 @@ warning_1 (const char *id, const char *f
 
       error_2 (id, fmt, args);
     }
   else if (warn_opt == 1)
     {
       vwarning ("warning", id, fmt, args);
 
       if (! symbol_table::at_top_level ()
-	  && Vbacktrace_on_warning
-	  && ! warning_state
-	  && ! discard_warning_messages)
-	pr_where ("warning");
+          && Vbacktrace_on_warning
+          && ! warning_state
+          && ! discard_warning_messages)
+        pr_where ("warning");
 
       warning_state = 1;
 
       if ((interactive || forced_interactive)
-	  && Vdebug_on_warning
-	  && octave_call_stack::caller_user_code ())
-	{
+          && Vdebug_on_warning
+          && octave_call_stack::caller_user_code ())
+        {
           unwind_protect frame;
-	  frame.protect_var (Vdebug_on_warning);
-	  Vdebug_on_warning = false;
+          frame.protect_var (Vdebug_on_warning);
+          Vdebug_on_warning = false;
 
-	  do_keyboard (octave_value_list ());
-	}
+          do_keyboard (octave_value_list ());
+        }
     }
 }
 
 void
 vwarning (const char *fmt, va_list args)
 {
   warning_1 ("", fmt, args);
 }
@@ -782,73 +782,73 @@ defun_usage_message (const std::string& 
 }
 
 typedef void (*error_fun)(const char *, const char *, ...);
 
 extern octave_value_list Fsprintf (const octave_value_list&, int);
 
 static std::string
 handle_message (error_fun f, const char *id, const char *msg,
-		const octave_value_list& args)
+                const octave_value_list& args)
 {
   std::string retval;
 
   std::string tstr;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       octave_value arg;
 
       if (nargin > 1)
-	{
-	  octave_value_list tmp = Fsprintf (args, 1);
-	  arg = tmp(0);
-	}
+        {
+          octave_value_list tmp = Fsprintf (args, 1);
+          arg = tmp(0);
+        }
       else
-	arg = args(0);
+        arg = args(0);
 
       if (arg.is_defined ())
-	{
-	  if (arg.is_string ())
-	    {
-	      tstr = arg.string_value ();
-	      msg = tstr.c_str ();
-	      
-	      if (! msg)
-		return retval;
-	    }
-	  else if (arg.is_empty ())
-	    return retval;
-	}
+        {
+          if (arg.is_string ())
+            {
+              tstr = arg.string_value ();
+              msg = tstr.c_str ();
+              
+              if (! msg)
+                return retval;
+            }
+          else if (arg.is_empty ())
+            return retval;
+        }
     }
 
 // Ugh.
 
   size_t len = strlen (msg);
 
   if (len > 0)
     {
       if (msg[len - 1] == '\n')
-	{
-	  if (len > 1)
-	    {
-	      char *tmp_msg = strsave (msg);
-	      tmp_msg[len - 1] = '\0';
-	      f (id, "%s\n", tmp_msg);
-	      retval = tmp_msg;
-	      delete [] tmp_msg;
-	    }
-	}
+        {
+          if (len > 1)
+            {
+              char *tmp_msg = strsave (msg);
+              tmp_msg[len - 1] = '\0';
+              f (id, "%s\n", tmp_msg);
+              retval = tmp_msg;
+              delete [] tmp_msg;
+            }
+        }
       else
-	{
-	  f (id, "%s", msg);
-	  retval = msg;
-	}
+        {
+          f (id, "%s", msg);
+          retval = msg;
+        }
     }
 
   return retval;
 }
 
 DEFUN (rethrow, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rethrow (@var{err})\n\
@@ -865,127 +865,127 @@ location of the error.  Typically @var{e
 
   if (nargin != 1)
     print_usage ();
   else
     {
       Octave_map err = args(0).map_value ();
 
       if (! error_state)
-	{
-	  if (err.contains ("message") && err.contains ("identifier"))
-	    {
-	      std::string msg = err.contents("message")(0).string_value ();
-	      std::string id = err.contents("identifier")(0).string_value ();
-	      int len = msg.length();
+        {
+          if (err.contains ("message") && err.contains ("identifier"))
+            {
+              std::string msg = err.contents("message")(0).string_value ();
+              std::string id = err.contents("identifier")(0).string_value ();
+              int len = msg.length();
 
-	      std::string file;
-	      std::string nm;
-	      int l = -1;
-	      int c = -1;
+              std::string file;
+              std::string nm;
+              int l = -1;
+              int c = -1;
 
-	      Octave_map err_stack = initialize_last_error_stack ();
+              Octave_map err_stack = initialize_last_error_stack ();
 
-	      if (err.contains ("stack"))
-		{
-		  err_stack = err.contents("stack")(0).map_value ();
+              if (err.contains ("stack"))
+                {
+                  err_stack = err.contents("stack")(0).map_value ();
 
-		  if (err_stack.numel () > 0)
-		    {
-		      if (err_stack.contains ("file"))
-			file = err_stack.contents("file")(0).string_value ();
+                  if (err_stack.numel () > 0)
+                    {
+                      if (err_stack.contains ("file"))
+                        file = err_stack.contents("file")(0).string_value ();
 
-		      if (err_stack.contains ("name"))
-			nm = err_stack.contents("name")(0).string_value ();
+                      if (err_stack.contains ("name"))
+                        nm = err_stack.contents("name")(0).string_value ();
 
-		      if (err_stack.contains ("line"))
-			l = err_stack.contents("line")(0).nint_value ();
+                      if (err_stack.contains ("line"))
+                        l = err_stack.contents("line")(0).nint_value ();
 
-		      if (err_stack.contains ("column"))
-			c = err_stack.contents("column")(0).nint_value ();
-		    }
-		}
+                      if (err_stack.contains ("column"))
+                        c = err_stack.contents("column")(0).nint_value ();
+                    }
+                }
 
-	      // Ugh.
-	      char *tmp_msg = strsave (msg.c_str ());
-	      if (tmp_msg[len-1] == '\n')
-		{
-		  if (len > 1)
-		    {
-		      tmp_msg[len - 1] = '\0';
-		      rethrow_error (id.c_str (), "%s\n", tmp_msg);
-		    }
-		}
-	      else
-		rethrow_error (id.c_str (), "%s", tmp_msg);
-	      delete [] tmp_msg;
+              // Ugh.
+              char *tmp_msg = strsave (msg.c_str ());
+              if (tmp_msg[len-1] == '\n')
+                {
+                  if (len > 1)
+                    {
+                      tmp_msg[len - 1] = '\0';
+                      rethrow_error (id.c_str (), "%s\n", tmp_msg);
+                    }
+                }
+              else
+                rethrow_error (id.c_str (), "%s", tmp_msg);
+              delete [] tmp_msg;
 
-	      // FIXME -- is this the right thing to do for
-	      // Vlast_error_stack?  Should it be saved and restored
-	      // with unwind_protect?
+              // FIXME -- is this the right thing to do for
+              // Vlast_error_stack?  Should it be saved and restored
+              // with unwind_protect?
 
-	      Vlast_error_stack = err_stack;
+              Vlast_error_stack = err_stack;
 
-	      if (err.contains ("stack"))
-		{
-		  if (file.empty ())
-		    {
-		      if (nm.empty ())
-			{
-			  if (l > 0)
-			    {
-			      if (c > 0)
-				pr_where_1 ("error: near line %d, column %d", 
-					    l, c);
-			      else
-				pr_where_1 ("error: near line %d", l);
-			    }
-			}
-		      else
-			{
-			  if (l > 0)
-			    {
-			      if (c > 0)
-				pr_where_1 ("error: called from `%s' near line %d, column %d", 
-					    nm.c_str (), l, c);
-			      else
-				pr_where_1 ("error: called from `%d' near line %d", nm.c_str (), l);
-			    }
-			}
-		    }
-		  else
-		    {
-		      if (nm.empty ())
-			{
-			  if (l > 0)
-			    {
-			      if (c > 0)
-				pr_where_1 ("error: in file %s near line %d, column %d", 
-					    file.c_str (), l, c);
-			      else
-				pr_where_1 ("error: in file %s near line %d", file.c_str (), l);
-			    }
-			}
-		      else
-			{
-			  if (l > 0)
-			    {
-			      if (c > 0)
-				pr_where_1 ("error: called from `%s' in file %s near line %d, column %d", 
-					    nm.c_str (), file.c_str (), l, c);
-			      else
-				pr_where_1 ("error: called from `%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
-			    }
-			}
-		    }
-		}
-	    }
-	  else
-	    error ("rethrow: structure must contain the fields 'message and 'identifier'");
-	}
+              if (err.contains ("stack"))
+                {
+                  if (file.empty ())
+                    {
+                      if (nm.empty ())
+                        {
+                          if (l > 0)
+                            {
+                              if (c > 0)
+                                pr_where_1 ("error: near line %d, column %d", 
+                                            l, c);
+                              else
+                                pr_where_1 ("error: near line %d", l);
+                            }
+                        }
+                      else
+                        {
+                          if (l > 0)
+                            {
+                              if (c > 0)
+                                pr_where_1 ("error: called from `%s' near line %d, column %d", 
+                                            nm.c_str (), l, c);
+                              else
+                                pr_where_1 ("error: called from `%d' near line %d", nm.c_str (), l);
+                            }
+                        }
+                    }
+                  else
+                    {
+                      if (nm.empty ())
+                        {
+                          if (l > 0)
+                            {
+                              if (c > 0)
+                                pr_where_1 ("error: in file %s near line %d, column %d", 
+                                            file.c_str (), l, c);
+                              else
+                                pr_where_1 ("error: in file %s near line %d", file.c_str (), l);
+                            }
+                        }
+                      else
+                        {
+                          if (l > 0)
+                            {
+                              if (c > 0)
+                                pr_where_1 ("error: called from `%s' in file %s near line %d, column %d", 
+                                            nm.c_str (), file.c_str (), l, c);
+                              else
+                                pr_where_1 ("error: called from `%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
+                            }
+                        }
+                    }
+                }
+            }
+          else
+            error ("rethrow: structure must contain the fields 'message and 'identifier'");
+        }
     }
   return retval;
 }
 
 DEFUN (error, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} error (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} error (@var{id}, @var{template}, @dots{})\n\
@@ -1050,63 +1050,63 @@ error: nargin != 1\n\
 
   std::string id;
 
   if (nargin == 0)
     print_usage ();
   else
     {
       if (nargin > 1)
-	{
-	  std::string arg1 = args(0).string_value ();
+        {
+          std::string arg1 = args(0).string_value ();
 
-	  if (! error_state)
-	    {
-	      if (arg1.find ('%') == std::string::npos)
-		{
-		  id = arg1;
+          if (! error_state)
+            {
+              if (arg1.find ('%') == std::string::npos)
+                {
+                  id = arg1;
 
-		  nargs.resize (nargin-1);
+                  nargs.resize (nargin-1);
 
-		  for (int i = 1; i < nargin; i++)
-		    nargs(i-1) = args(i);
-		}
-	    }
-	  else
-	    return retval;
-	}
+                  for (int i = 1; i < nargin; i++)
+                    nargs(i-1) = args(i);
+                }
+            }
+          else
+            return retval;
+        }
       else if (nargin == 1 && args(0).is_map ())
-	{
-	  octave_value_list tmp;
+        {
+          octave_value_list tmp;
 
-	  Octave_map m = args(0).map_value ();
+          Octave_map m = args(0).map_value ();
 
-	  if (m.numel () == 1)
-	    {
-	      if (m.contains ("message"))
-		{
-		  Cell c = m.contents ("message");
+          if (m.numel () == 1)
+            {
+              if (m.contains ("message"))
+                {
+                  Cell c = m.contents ("message");
 
-		  if (! c.is_empty () && c(0).is_string ())
-		    nargs(0) = c(0).string_value ();
-		}
+                  if (! c.is_empty () && c(0).is_string ())
+                    nargs(0) = c(0).string_value ();
+                }
 
-	      if (m.contains ("identifier"))
-		{
-		  Cell c = m.contents ("identifier");
+              if (m.contains ("identifier"))
+                {
+                  Cell c = m.contents ("identifier");
 
-		  if (! c.is_empty () && c(0).is_string ())
-		    id = c(0).string_value ();
-		}
+                  if (! c.is_empty () && c(0).is_string ())
+                    id = c(0).string_value ();
+                }
 
-	      // FIXME -- also need to handle "stack" field in error
-	      // structure, but that will require some more significant
-	      // surgery on handle_message, error_with_id, etc.
-	    }
-	}
+              // FIXME -- also need to handle "stack" field in error
+              // structure, but that will require some more significant
+              // surgery on handle_message, error_with_id, etc.
+            }
+        }
 
       handle_message (error_with_id, id.c_str (), "unspecified error", nargs);
     }
 
   return retval;
 }
 
 DEFUN (warning, args, nargout,
@@ -1144,302 +1144,302 @@ warning named by @var{id} is handled as 
 
   bool done = false;
 
   if (argc > 1 && args.all_strings_p ())
     {
       string_vector argv = args.make_argv ("warning");
 
       if (! error_state)
-	{
-	  std::string arg1 = argv(1);
-	  std::string arg2 = "all";
+        {
+          std::string arg1 = argv(1);
+          std::string arg2 = "all";
 
-	  if (argc == 3)
-	    arg2 = argv(2);
+          if (argc == 3)
+            arg2 = argv(2);
 
-	  if (arg1 == "on" || arg1 == "off" || arg1 == "error")
-	    {
-	      Octave_map old_warning_options = warning_options;
+          if (arg1 == "on" || arg1 == "off" || arg1 == "error")
+            {
+              Octave_map old_warning_options = warning_options;
 
-	      if (arg2 == "all")
-		{
-		  Octave_map tmp;
+              if (arg2 == "all")
+                {
+                  Octave_map tmp;
 
-		  Cell id (1, 1);
-		  Cell st (1, 1);
+                  Cell id (1, 1);
+                  Cell st (1, 1);
 
-		  id(0) = arg2;
-		  st(0) = arg1;
+                  id(0) = arg2;
+                  st(0) = arg1;
 
-		  // Since internal Octave functions are not
-		  // compatible, turning all warnings into errors
-		  // should leave the state of
-		  // Octave:matlab-incompatible alone.
+                  // Since internal Octave functions are not
+                  // compatible, turning all warnings into errors
+                  // should leave the state of
+                  // Octave:matlab-incompatible alone.
 
-		  if (arg1 == "error"
-		      && warning_options.contains ("identifier"))
-		    {
-		      octave_idx_type n = 1;
+                  if (arg1 == "error"
+                      && warning_options.contains ("identifier"))
+                    {
+                      octave_idx_type n = 1;
 
-		      Cell tid = warning_options.contents ("identifier");
-		      Cell tst = warning_options.contents ("state");
+                      Cell tid = warning_options.contents ("identifier");
+                      Cell tst = warning_options.contents ("state");
 
-		      for (octave_idx_type i = 0; i < tid.numel (); i++)
-			{
-			  octave_value vid = tid(i);
+                      for (octave_idx_type i = 0; i < tid.numel (); i++)
+                        {
+                          octave_value vid = tid(i);
 
-			  if (vid.is_string ())
-			    {
-			      std::string key = vid.string_value ();
+                          if (vid.is_string ())
+                            {
+                              std::string key = vid.string_value ();
 
-			      if (key == "Octave:matlab-incompatible"
-				  || key == "Octave:single-quote-string")
-				{
-				  id.resize (dim_vector (1, n+1));
-				  st.resize (dim_vector (1, n+1));
+                              if (key == "Octave:matlab-incompatible"
+                                  || key == "Octave:single-quote-string")
+                                {
+                                  id.resize (dim_vector (1, n+1));
+                                  st.resize (dim_vector (1, n+1));
 
-				  id(n) = tid(i);
-				  st(n) = tst(i);
+                                  id(n) = tid(i);
+                                  st(n) = tst(i);
 
-				  n++;
-				}
-			    }
-			}
-		    }
+                                  n++;
+                                }
+                            }
+                        }
+                    }
 
-		  tmp.assign ("identifier", id);
-		  tmp.assign ("state", st);
+                  tmp.assign ("identifier", id);
+                  tmp.assign ("state", st);
 
-		  warning_options = tmp;
+                  warning_options = tmp;
 
-		  done = true;
-		}
-	      else if (arg2 == "backtrace")
-		{
-		  if (arg1 != "error")
-		    {
-		      Vbacktrace_on_warning = (arg1 == "on");
-		      done = true;
-		    }
-		}
-	      else if (arg2 == "debug")
-		{
-		  if (arg1 != "error")
-		    {
-		      Vdebug_on_warning = (arg1 == "on");
-		      done = true;
-		    }
-		}
-	      else if (arg2 == "verbose")
-		{
-		  if (arg1 != "error")
-		    {
-		      Vverbose_warning = (arg1 == "on");
-		      done = true;
-		    }
-		}
-	      else if (arg2 == "quiet")
-		{
-		  if (arg1 != "error")
-		    {
-		      Vquiet_warning = (arg1 == "on");
-		      done = true;
-		    }
-		}
-	      else
-		{
-		  if (arg2 == "last")
-		    arg2 = Vlast_warning_id;
+                  done = true;
+                }
+              else if (arg2 == "backtrace")
+                {
+                  if (arg1 != "error")
+                    {
+                      Vbacktrace_on_warning = (arg1 == "on");
+                      done = true;
+                    }
+                }
+              else if (arg2 == "debug")
+                {
+                  if (arg1 != "error")
+                    {
+                      Vdebug_on_warning = (arg1 == "on");
+                      done = true;
+                    }
+                }
+              else if (arg2 == "verbose")
+                {
+                  if (arg1 != "error")
+                    {
+                      Vverbose_warning = (arg1 == "on");
+                      done = true;
+                    }
+                }
+              else if (arg2 == "quiet")
+                {
+                  if (arg1 != "error")
+                    {
+                      Vquiet_warning = (arg1 == "on");
+                      done = true;
+                    }
+                }
+              else
+                {
+                  if (arg2 == "last")
+                    arg2 = Vlast_warning_id;
 
-		  if (arg2 == "all")
-		    initialize_warning_options (arg1);
-		  else
-		    {
-		      Cell ident = warning_options.contents ("identifier");
-		      Cell state = warning_options.contents ("state");
+                  if (arg2 == "all")
+                    initialize_warning_options (arg1);
+                  else
+                    {
+                      Cell ident = warning_options.contents ("identifier");
+                      Cell state = warning_options.contents ("state");
 
-		      octave_idx_type nel = ident.numel ();
+                      octave_idx_type nel = ident.numel ();
 
-		      bool found = false;
+                      bool found = false;
 
-		      for (octave_idx_type i = 0; i < nel; i++)
-			{
-			  if (ident(i).string_value () == arg2)
-			    {
-			      // FIXME -- if state for "all" is
-			      // same as arg1, we can simply remove the
-			      // item from the list.
+                      for (octave_idx_type i = 0; i < nel; i++)
+                        {
+                          if (ident(i).string_value () == arg2)
+                            {
+                              // FIXME -- if state for "all" is
+                              // same as arg1, we can simply remove the
+                              // item from the list.
 
-			      state(i) = arg1;
-			      warning_options.assign ("state", state);
-			      found = true;
-			      break;
-			    }
-			}
+                              state(i) = arg1;
+                              warning_options.assign ("state", state);
+                              found = true;
+                              break;
+                            }
+                        }
 
-		      if (! found)
-			{
-			  // FIXME -- if state for "all" is
-			  // same as arg1, we don't need to do anything.
+                      if (! found)
+                        {
+                          // FIXME -- if state for "all" is
+                          // same as arg1, we don't need to do anything.
 
-			  ident.resize (dim_vector (1, nel+1));
-			  state.resize (dim_vector (1, nel+1));
+                          ident.resize (dim_vector (1, nel+1));
+                          state.resize (dim_vector (1, nel+1));
 
-			  ident(nel) = arg2;
-			  state(nel) = arg1;
+                          ident(nel) = arg2;
+                          state(nel) = arg1;
 
-			  warning_options.clear ();
+                          warning_options.clear ();
 
-			  warning_options.assign ("identifier", ident);
-			  warning_options.assign ("state", state);
-			}
-		    }
+                          warning_options.assign ("identifier", ident);
+                          warning_options.assign ("state", state);
+                        }
+                    }
 
-		  done = true;
-		}
+                  done = true;
+                }
 
-	      if (done && nargout > 0)
-		retval = old_warning_options;
-	    }
-	  else if (arg1 == "query")
-	    {
-	      if (arg2 == "all")
-		retval = warning_options;
-	      else if (arg2 == "backtrace" || arg2 == "debug"
-		       || arg2 == "verbose" || arg2 == "quiet")
-		{
-		  Octave_map tmp;
-		  tmp.assign ("identifier", arg2);
-		  if (arg2 == "backtrace")
-		    tmp.assign ("state", Vbacktrace_on_warning ? "on" : "off");
-		  else if (arg2 == "debug")
-		    tmp.assign ("state", Vdebug_on_warning ? "on" : "off");
-		  else if (arg2 == "verbose")
-		    tmp.assign ("state", Vverbose_warning ? "on" : "off");
-		  else
-		    tmp.assign ("state", Vquiet_warning ? "on" : "off");
+              if (done && nargout > 0)
+                retval = old_warning_options;
+            }
+          else if (arg1 == "query")
+            {
+              if (arg2 == "all")
+                retval = warning_options;
+              else if (arg2 == "backtrace" || arg2 == "debug"
+                       || arg2 == "verbose" || arg2 == "quiet")
+                {
+                  Octave_map tmp;
+                  tmp.assign ("identifier", arg2);
+                  if (arg2 == "backtrace")
+                    tmp.assign ("state", Vbacktrace_on_warning ? "on" : "off");
+                  else if (arg2 == "debug")
+                    tmp.assign ("state", Vdebug_on_warning ? "on" : "off");
+                  else if (arg2 == "verbose")
+                    tmp.assign ("state", Vverbose_warning ? "on" : "off");
+                  else
+                    tmp.assign ("state", Vquiet_warning ? "on" : "off");
 
-		  retval = tmp;
-		}
-	      else
-		{
-		  if (arg2 == "last")
-		    arg2 = Vlast_warning_id;
+                  retval = tmp;
+                }
+              else
+                {
+                  if (arg2 == "last")
+                    arg2 = Vlast_warning_id;
 
-		  Cell ident = warning_options.contents ("identifier");
-		  Cell state = warning_options.contents ("state");
+                  Cell ident = warning_options.contents ("identifier");
+                  Cell state = warning_options.contents ("state");
 
-		  octave_idx_type nel = ident.numel ();
+                  octave_idx_type nel = ident.numel ();
 
-		  bool found = false;
-		  
-		  std::string val;
+                  bool found = false;
+                  
+                  std::string val;
 
-		  for (octave_idx_type i = 0; i < nel; i++)
-		    {
-		      if (ident(i).string_value () == arg2)
-			{
-			  val = state(i).string_value ();
-			  found = true;
-			  break;
-			}
-		    }
+                  for (octave_idx_type i = 0; i < nel; i++)
+                    {
+                      if (ident(i).string_value () == arg2)
+                        {
+                          val = state(i).string_value ();
+                          found = true;
+                          break;
+                        }
+                    }
 
-		  if (! found)
-		    {
-		      for (octave_idx_type i = 0; i < nel; i++)
-			{
-			  if (ident(i).string_value () == "all")
-			    {
-			      val = state(i).string_value ();
-			      found = true;
-			      break;
-			    }
-			}
-		    }
+                  if (! found)
+                    {
+                      for (octave_idx_type i = 0; i < nel; i++)
+                        {
+                          if (ident(i).string_value () == "all")
+                            {
+                              val = state(i).string_value ();
+                              found = true;
+                              break;
+                            }
+                        }
+                    }
 
-		  if (found)
-		    {
-		      Octave_map tmp;
+                  if (found)
+                    {
+                      Octave_map tmp;
 
-		      tmp.assign ("identifier", arg2);
-		      tmp.assign ("state", val);
+                      tmp.assign ("identifier", arg2);
+                      tmp.assign ("state", val);
 
-		      retval = tmp;
-		    }
-		  else
-		    error ("warning: unable to find default warning state!");
-		}
+                      retval = tmp;
+                    }
+                  else
+                    error ("warning: unable to find default warning state!");
+                }
 
-	      done = true;
-	    }
-	}
+              done = true;
+            }
+        }
     }
   else if (argc == 1)
     {
       retval = warning_options;
 
       done = true;
     }
   else if (argc == 2)
     {
       octave_value arg = args(0);
 
       Octave_map old_warning_options = warning_options;
 
       if (arg.is_map ())
-	{
-	  Octave_map m = arg.map_value ();
+        {
+          Octave_map m = arg.map_value ();
 
-	  if (m.contains ("identifier") && m.contains ("state"))
-	    warning_options = m;
-	  else
-	    error ("warning: expecting structure with fields `identifier' and `state'");
+          if (m.contains ("identifier") && m.contains ("state"))
+            warning_options = m;
+          else
+            error ("warning: expecting structure with fields `identifier' and `state'");
 
-	  done = true;
+          done = true;
 
-	  if (nargout > 0)
-	    retval = old_warning_options;
-	}
+          if (nargout > 0)
+            retval = old_warning_options;
+        }
     }
 
   if (! (error_state || done))
     {
       octave_value_list nargs = args;
 
       std::string id;
 
       if (nargin > 1)
-	{
-	  std::string arg1 = args(0).string_value ();
+        {
+          std::string arg1 = args(0).string_value ();
 
-	  if (! error_state)
-	    {
-	      if (arg1.find ('%') == std::string::npos)
-		{
-		  id = arg1;
+          if (! error_state)
+            {
+              if (arg1.find ('%') == std::string::npos)
+                {
+                  id = arg1;
 
-		  nargs.resize (nargin-1);
+                  nargs.resize (nargin-1);
 
-		  for (int i = 1; i < nargin; i++)
-		    nargs(i-1) = args(i);
-		}
-	    }
-	  else
-	    return retval;
-	}
+                  for (int i = 1; i < nargin; i++)
+                    nargs(i-1) = args(i);
+                }
+            }
+          else
+            return retval;
+        }
 
       std::string prev_msg = Vlast_warning_message;
 
       std::string curr_msg = handle_message (warning_with_id, id.c_str (),
-					     "unspecified warning", nargs);
+                                             "unspecified warning", nargs);
 
       if (nargout > 0)
-	retval = prev_msg;
+        retval = prev_msg;
     }
 
   return retval;
 }
 
 void
 disable_warning (const std::string& id)
 {
@@ -1532,104 +1532,104 @@ their default values.\n\
       Octave_map err;
 
       err.assign ("message", Vlast_error_message);
       err.assign ("identifier", Vlast_error_id);
 
       err.assign ("stack", octave_value (Vlast_error_stack));
 
       if (nargin == 1)
-	{
-	  if (args(0).is_string())
-	    {
-	      if (args(0).string_value () == "reset")
-		{
-		  Vlast_error_message = std::string();
-		  Vlast_error_id = std::string();
+        {
+          if (args(0).is_string())
+            {
+              if (args(0).string_value () == "reset")
+                {
+                  Vlast_error_message = std::string();
+                  Vlast_error_id = std::string();
 
-		  Vlast_error_stack = initialize_last_error_stack ();
-		}
-	      else
-		error("lasterror: unrecognized string argument");
-	    }
-	  else if (args(0).is_map ())
-	    {
-	      Octave_map new_err = args(0).map_value ();
-	      std::string new_error_message;
-	      std::string new_error_id;
-	      std::string new_error_file;
-	      std::string new_error_name;
-	      int new_error_line = -1;
-	      int new_error_column = -1;
+                  Vlast_error_stack = initialize_last_error_stack ();
+                }
+              else
+                error("lasterror: unrecognized string argument");
+            }
+          else if (args(0).is_map ())
+            {
+              Octave_map new_err = args(0).map_value ();
+              std::string new_error_message;
+              std::string new_error_id;
+              std::string new_error_file;
+              std::string new_error_name;
+              int new_error_line = -1;
+              int new_error_column = -1;
 
-	      if (! error_state && new_err.contains ("message"))
-		{
-		  const std::string tmp = 
-		    new_err.contents("message")(0).string_value ();
-		  new_error_message = tmp;
-		}
+              if (! error_state && new_err.contains ("message"))
+                {
+                  const std::string tmp = 
+                    new_err.contents("message")(0).string_value ();
+                  new_error_message = tmp;
+                }
 
-	      if (! error_state && new_err.contains ("identifier"))
-		{
-		  const std::string tmp = 
-		    new_err.contents("identifier")(0).string_value ();
-		  new_error_id = tmp;
-		}
+              if (! error_state && new_err.contains ("identifier"))
+                {
+                  const std::string tmp = 
+                    new_err.contents("identifier")(0).string_value ();
+                  new_error_id = tmp;
+                }
 
-	      if (! error_state && new_err.contains ("stack"))
-		{
-		  Octave_map new_err_stack = 
-		    new_err.contents("identifier")(0).map_value ();
+              if (! error_state && new_err.contains ("stack"))
+                {
+                  Octave_map new_err_stack = 
+                    new_err.contents("identifier")(0).map_value ();
 
-		  if (! error_state && new_err_stack.contains ("file"))
-		    {
-		      const std::string tmp = 
-			new_err_stack.contents("file")(0).string_value ();
-		      new_error_file = tmp;
-		    }
+                  if (! error_state && new_err_stack.contains ("file"))
+                    {
+                      const std::string tmp = 
+                        new_err_stack.contents("file")(0).string_value ();
+                      new_error_file = tmp;
+                    }
 
-		  if (! error_state && new_err_stack.contains ("name"))
-		    {
-		      const std::string tmp = 
-			new_err_stack.contents("name")(0).string_value ();
-		      new_error_name = tmp;
-		    }
+                  if (! error_state && new_err_stack.contains ("name"))
+                    {
+                      const std::string tmp = 
+                        new_err_stack.contents("name")(0).string_value ();
+                      new_error_name = tmp;
+                    }
 
-		  if (! error_state && new_err_stack.contains ("line"))
-		    {
-		      const int tmp = 
-			new_err_stack.contents("line")(0).nint_value ();
-		      new_error_line = tmp;
-		    }
-		  
-		  if (! error_state && new_err_stack.contains ("column"))
-		    {
-		      const int tmp = 
-			new_err_stack.contents("column")(0).nint_value ();
-		      new_error_column = tmp;
-		    }
-		}
+                  if (! error_state && new_err_stack.contains ("line"))
+                    {
+                      const int tmp = 
+                        new_err_stack.contents("line")(0).nint_value ();
+                      new_error_line = tmp;
+                    }
+                  
+                  if (! error_state && new_err_stack.contains ("column"))
+                    {
+                      const int tmp = 
+                        new_err_stack.contents("column")(0).nint_value ();
+                      new_error_column = tmp;
+                    }
+                }
 
-	      if (! error_state)
-		{
-		  Vlast_error_message = new_error_message;
-		  Vlast_error_id = new_error_id;
+              if (! error_state)
+                {
+                  Vlast_error_message = new_error_message;
+                  Vlast_error_id = new_error_id;
 
-		  octave_idx_type curr_frame = -1;
+                  octave_idx_type curr_frame = -1;
 
-		  Vlast_error_stack
-		    = octave_call_stack::backtrace (0, curr_frame);
-		}
-	    }
-	  else
-	    error ("lasterror: argument must be a structure or a string");
-	}
+                  Vlast_error_stack
+                    = octave_call_stack::backtrace (0, curr_frame);
+                }
+            }
+          else
+            error ("lasterror: argument must be a structure or a string");
+        }
 
       if (! error_state)
-	retval = err;
+        retval = err;
     }
   else
     print_usage ();
 
   return retval;  
 }
 
 DEFUN (lasterr, args, nargout,
@@ -1649,34 +1649,34 @@ also set the last message identifier.\n\
 
   int argc = args.length () + 1;
 
   if (argc < 4)
     {
       string_vector argv = args.make_argv ("lasterr");
 
       if (! error_state)
-	{
-	  std::string prev_error_id = Vlast_error_id;
-	  std::string prev_error_message = Vlast_error_message;
+        {
+          std::string prev_error_id = Vlast_error_id;
+          std::string prev_error_message = Vlast_error_message;
 
-	  if (argc > 2)
-	    Vlast_error_id = argv(2);
+          if (argc > 2)
+            Vlast_error_id = argv(2);
 
-	  if (argc > 1)
-	    Vlast_error_message = argv(1);
+          if (argc > 1)
+            Vlast_error_message = argv(1);
 
-	  if (argc == 1 || nargout > 0)
-	    {
-	      retval(1) = prev_error_id;
-	      retval(0) = prev_error_message;
-	    }
-	}
+          if (argc == 1 || nargout > 0)
+            {
+              retval(1) = prev_error_id;
+              retval(0) = prev_error_message;
+            }
+        }
       else
-	error ("lasterr: expecting arguments to be character strings");
+        error ("lasterr: expecting arguments to be character strings");
     }
   else
     print_usage ();
 
   return retval;  
 }
 
 // For backward compatibility.
@@ -1695,35 +1695,35 @@ also set the last message identifier.\n\
 
   int argc = args.length () + 1;
 
   if (argc < 4)
     {
       string_vector argv = args.make_argv ("lastwarn");
 
       if (! error_state)
-	{
-	  std::string prev_warning_id = Vlast_warning_id;
-	  std::string prev_warning_message = Vlast_warning_message;
+        {
+          std::string prev_warning_id = Vlast_warning_id;
+          std::string prev_warning_message = Vlast_warning_message;
 
-	  if (argc > 2)
-	    Vlast_warning_id = argv(2);
+          if (argc > 2)
+            Vlast_warning_id = argv(2);
 
-	  if (argc > 1)
-	    Vlast_warning_message = argv(1);
+          if (argc > 1)
+            Vlast_warning_message = argv(1);
 
-	  if (argc == 1 || nargout > 0)
-	    {
-	      warning_state = 0;
-	      retval(1) = prev_warning_id;
-	      retval(0) = prev_warning_message;
-	    }
-	}
+          if (argc == 1 || nargout > 0)
+            {
+              warning_state = 0;
+              retval(1) = prev_warning_id;
+              retval(0) = prev_warning_message;
+            }
+        }
       else
-	error ("lastwarn: expecting arguments to be character strings");
+        error ("lastwarn: expecting arguments to be character strings");
     }
   else
     print_usage ();
 
   return retval;  
 }
 
 DEFUN (usage, args, ,
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -143,71 +143,71 @@ fopen_mode_to_ios_mode (const std::strin
 
       // 'W' and 'R' are accepted as 'w' and 'r', but we warn about
       // them because Matlab says they perform "automatic flushing"
       // but we don't know precisely what action that implies.
 
       size_t pos = mode.find ('W');
 
       if (pos != std::string::npos)
-	{
-	  warning ("fopen: treating mode \"W\" as equivalent to \"w\"");
-	  mode[pos] = 'w';
-	}
+        {
+          warning ("fopen: treating mode \"W\" as equivalent to \"w\"");
+          mode[pos] = 'w';
+        }
 
       pos = mode.find ('R');
 
       if (pos != std::string::npos)
-	{
-	  warning ("fopen: treating mode \"R\" as equivalent to \"r\"");
-	  mode[pos] = 'r';
-	}
+        {
+          warning ("fopen: treating mode \"R\" as equivalent to \"r\"");
+          mode[pos] = 'r';
+        }
 
       pos = mode.find ('z');
 
       if (pos != std::string::npos)
-	{
+        {
 #if defined (HAVE_ZLIB)
-	  mode.erase (pos, 1);
+          mode.erase (pos, 1);
 #else
-	  error ("this version of Octave does not support gzipped files");
+          error ("this version of Octave does not support gzipped files");
 #endif
-	}
+        }
 
       if (! error_state)
-	{
-	  if (mode == "rt")
-	    retval = std::ios::in;
-	  else if (mode == "wt")
-	    retval = std::ios::out | std::ios::trunc;
-	  else if (mode == "at")
-	    retval = std::ios::out | std::ios::app;
-	  else if (mode == "r+t" || mode == "rt+")
-	    retval = std::ios::in | std::ios::out;
-	  else if (mode == "w+t" || mode == "wt+")
-	    retval = std::ios::in | std::ios::out | std::ios::trunc;
-	  else if (mode == "a+t" || mode == "at+")
-	    retval = std::ios::in | std::ios::out | std::ios::app;
-	  else if (mode == "rb" || mode == "r")
-	    retval = std::ios::in | std::ios::binary;
-	  else if (mode == "wb" || mode == "w")
-	    retval = std::ios::out | std::ios::trunc | std::ios::binary;
-	  else if (mode == "ab" || mode == "a")
-	    retval = std::ios::out | std::ios::app | std::ios::binary;
-	  else if (mode == "r+b" || mode == "rb+" || mode == "r+")
-	    retval = std::ios::in | std::ios::out | std::ios::binary;
-	  else if (mode == "w+b" || mode == "wb+" || mode == "w+")
-	    retval = (std::ios::in | std::ios::out | std::ios::trunc
-		      | std::ios::binary);
-	  else if (mode == "a+b" || mode == "ab+" || mode == "a+")
-	    retval = (std::ios::in | std::ios::out | std::ios::app
-		      | std::ios::binary);
-	  else
-	    ::error ("invalid mode specified");
-	}
+        {
+          if (mode == "rt")
+            retval = std::ios::in;
+          else if (mode == "wt")
+            retval = std::ios::out | std::ios::trunc;
+          else if (mode == "at")
+            retval = std::ios::out | std::ios::app;
+          else if (mode == "r+t" || mode == "rt+")
+            retval = std::ios::in | std::ios::out;
+          else if (mode == "w+t" || mode == "wt+")
+            retval = std::ios::in | std::ios::out | std::ios::trunc;
+          else if (mode == "a+t" || mode == "at+")
+            retval = std::ios::in | std::ios::out | std::ios::app;
+          else if (mode == "rb" || mode == "r")
+            retval = std::ios::in | std::ios::binary;
+          else if (mode == "wb" || mode == "w")
+            retval = std::ios::out | std::ios::trunc | std::ios::binary;
+          else if (mode == "ab" || mode == "a")
+            retval = std::ios::out | std::ios::app | std::ios::binary;
+          else if (mode == "r+b" || mode == "rb+" || mode == "r+")
+            retval = std::ios::in | std::ios::out | std::ios::binary;
+          else if (mode == "w+b" || mode == "wb+" || mode == "w+")
+            retval = (std::ios::in | std::ios::out | std::ios::trunc
+                      | std::ios::binary);
+          else if (mode == "a+b" || mode == "ab+" || mode == "a+")
+            retval = (std::ios::in | std::ios::out | std::ios::app
+                      | std::ios::binary);
+          else
+            ::error ("invalid mode specified");
+        }
     }
 
   return retval;
 }
 
 DEFUN (fclose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fclose (@var{fid})\n\
@@ -240,17 +240,17 @@ Clear the stream state for the specified
 
   if (nargin == 1)
     {
       int fid = octave_stream_list::get_file_number (args (0));
 
       octave_stream os = octave_stream_list::lookup (fid, "fclear");
 
       if (! error_state)
-	os.clearerr ();
+        os.clearerr ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fflush, args, ,
@@ -272,28 +272,28 @@ stream before calling @code{input}.\n\
 
   if (nargin == 1)
     {
       // FIXME -- any way to avoid special case for stdout?
 
       int fid = octave_stream_list::get_file_number (args (0));
 
       if (fid == 1)
-	{
-	  flush_octave_stdout ();
+        {
+          flush_octave_stdout ();
 
-	  retval = 0;
-	}
+          retval = 0;
+        }
       else
-	{
-	  octave_stream os = octave_stream_list::lookup (fid, "fflush");
+        {
+          octave_stream os = octave_stream_list::lookup (fid, "fflush");
 
-	  if (! error_state)
-	    retval = os.flush ();
-	}
+          if (! error_state)
+            retval = os.flush ();
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fgetl, args, ,
@@ -319,29 +319,29 @@ If there are no more characters to read,
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
-	{
-	  octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
+        {
+          octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
-	  bool err = false;
+          bool err = false;
 
-	  std::string tmp = os.getl (len_arg, err, who);
+          std::string tmp = os.getl (len_arg, err, who);
 
-	  if (! (error_state || err))
-	    {
-	      retval(1) = tmp.length ();
-	      retval(0) = tmp;
-	    }
-	}
+          if (! (error_state || err))
+            {
+              retval(1) = tmp.length ();
+              retval(0) = tmp;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
@@ -367,29 +367,29 @@ If there are no more characters to read,
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
-	{
-	  octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
+        {
+          octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
-	  bool err = false;
+          bool err = false;
 
-	  std::string tmp = os.gets (len_arg, err, who);
+          std::string tmp = os.gets (len_arg, err, who);
 
-	  if (! (error_state || err))
-	    {
-	      retval(1) = tmp.length ();
-	      retval(0) = tmp;
-	    }
-	}
+          if (! (error_state || err))
+            {
+              retval(1) = tmp.length ();
+              retval(0) = tmp;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fskipl, args, ,
@@ -410,149 +410,149 @@ This form is suitable for counting lines
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
-	{
-	  octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
+        {
+          octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
 
-	  bool err = false;
+          bool err = false;
 
-	  long tmp = os.skipl (count_arg, err, who);
+          long tmp = os.skipl (count_arg, err, who);
 
-	  if (! (error_state || err))
+          if (! (error_state || err))
             retval = tmp;
-	}
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 
 static octave_stream
 do_stream_open (const std::string& name, const std::string& mode,
-		const std::string& arch, int& fid)
+                const std::string& arch, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
   std::ios::openmode md = fopen_mode_to_ios_mode (mode);
 
   if (! error_state)
     {
       oct_mach_info::float_format flt_fmt =
-	oct_mach_info::string_to_float_format (arch);
+        oct_mach_info::string_to_float_format (arch);
 
       if (! error_state)
-	{
-	  std::string fname = file_ops::tilde_expand (name);
+        {
+          std::string fname = file_ops::tilde_expand (name);
 
-	  file_stat fs (fname);
+          file_stat fs (fname);
 
-	  if (! (md & std::ios::out
-		 || octave_env::absolute_pathname (fname)
-		 || octave_env::rooted_relative_pathname (fname)))
-	    {
-	      if (! fs.exists ())
-		{
-		  std::string tmp
+          if (! (md & std::ios::out
+                 || octave_env::absolute_pathname (fname)
+                 || octave_env::rooted_relative_pathname (fname)))
+            {
+              if (! fs.exists ())
+                {
+                  std::string tmp
                     = octave_env::make_absolute (load_path::find_file (fname));
 
-		  if (! tmp.empty ())
-		    {
-		      warning_with_id ("Octave:fopen-file-in-path",
-				       "fopen: file found in load path");
-		      fname = tmp;
-		    }
-		}
-	    }
-	  
-	  if (! fs.is_dir ())
-	    {
-	      std::string tmode = mode;
+                  if (! tmp.empty ())
+                    {
+                      warning_with_id ("Octave:fopen-file-in-path",
+                                       "fopen: file found in load path");
+                      fname = tmp;
+                    }
+                }
+            }
+          
+          if (! fs.is_dir ())
+            {
+              std::string tmode = mode;
 
-	      // Use binary mode if 't' is not specified, but don't add
-	      // 'b' if it is already present.
+              // Use binary mode if 't' is not specified, but don't add
+              // 'b' if it is already present.
 
-	      size_t bpos = tmode.find ('b');
-	      size_t tpos = tmode.find ('t');
+              size_t bpos = tmode.find ('b');
+              size_t tpos = tmode.find ('t');
 
-	      if (bpos == std::string::npos && tpos == std::string::npos)
-		tmode += 'b';
+              if (bpos == std::string::npos && tpos == std::string::npos)
+                tmode += 'b';
 
 #if defined (HAVE_ZLIB)
-	      size_t pos = tmode.find ('z');
+              size_t pos = tmode.find ('z');
 
-	      if (pos != std::string::npos)
-		{
-		  tmode.erase (pos, 1);
+              if (pos != std::string::npos)
+                {
+                  tmode.erase (pos, 1);
 
-		  gzFile fptr = ::gzopen (fname.c_str (), tmode.c_str ());
+                  gzFile fptr = ::gzopen (fname.c_str (), tmode.c_str ());
 
-		  if (fptr)
-		    retval = octave_zstdiostream::create (fname, fptr, md, flt_fmt);
-		  else
-		    {
-		      using namespace std;
-		      retval.error (::strerror (errno));
-		    }
-		}
-	      else
+                  if (fptr)
+                    retval = octave_zstdiostream::create (fname, fptr, md, flt_fmt);
+                  else
+                    {
+                      using namespace std;
+                      retval.error (::strerror (errno));
+                    }
+                }
+              else
 #endif
-		{
-		  FILE *fptr = ::fopen (fname.c_str (), tmode.c_str ());
+                {
+                  FILE *fptr = ::fopen (fname.c_str (), tmode.c_str ());
 
-		  retval = octave_stdiostream::create (fname, fptr, md, flt_fmt);
+                  retval = octave_stdiostream::create (fname, fptr, md, flt_fmt);
 
-		  if (! fptr)
-		    {
-		      using namespace std;
-		      retval.error (::strerror (errno));
-		    }
-		}
+                  if (! fptr)
+                    {
+                      using namespace std;
+                      retval.error (::strerror (errno));
+                    }
+                }
 
-	    }
-	}
+            }
+        }
     }
 
   return retval;
 }
 
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
-		const octave_value& tc_arch, const char *fcn, int& fid)
+                const octave_value& tc_arch, const char *fcn, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
   std::string name = tc_name.string_value ();
 
   if (! error_state)
     {
       std::string mode = tc_mode.string_value ();
 
       if (! error_state)
-	{
-	  std::string arch = tc_arch.string_value ();
+        {
+          std::string arch = tc_arch.string_value ();
 
-	  if (! error_state)
-	    retval = do_stream_open (name, mode, arch, fid);
-	  else
-	    ::error ("%s: architecture type must be a string", fcn);
-	}
+          if (! error_state)
+            retval = do_stream_open (name, mode, arch, fid);
+          else
+            ::error ("%s: architecture type must be a string", fcn);
+        }
       else
-	::error ("%s: file mode must be a string", fcn);
+        ::error ("%s: file mode must be a string", fcn);
     }
   else
     ::error ("%s: file name must be a string", fcn);
 
   return retval;
 }
 
 DEFUN (fopen, args, ,
@@ -661,64 +661,64 @@ however, conversions are currently only 
 
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
-	{
-	  // If there is only one argument and it is a string but it
-	  // is not the string "all", we assume it is a file to open
-	  // with MODE = "r".  To open a file called "all", you have
-	  // to supply more than one argument.
+        {
+          // If there is only one argument and it is a string but it
+          // is not the string "all", we assume it is a file to open
+          // with MODE = "r".  To open a file called "all", you have
+          // to supply more than one argument.
 
-	  if (args(0).string_value () == "all")
-	    return octave_stream_list::open_file_numbers ();
-	}
+          if (args(0).string_value () == "all")
+            return octave_stream_list::open_file_numbers ();
+        }
       else
-	{
-	  string_vector tmp = octave_stream_list::get_info (args(0));
+        {
+          string_vector tmp = octave_stream_list::get_info (args(0));
 
-	  if (! error_state)
-	    {
-	      retval(2) = tmp(2);
-	      retval(1) = tmp(1);
-	      retval(0) = tmp(0);
-	    }
+          if (! error_state)
+            {
+              retval(2) = tmp(2);
+              retval(1) = tmp(1);
+              retval(0) = tmp(0);
+            }
 
-	  return retval;
-	}
+          return retval;
+        }
     }
 
   if (nargin > 0 && nargin < 4)
     {
       octave_value mode = (nargin == 2 || nargin == 3)
-	? args(1) : octave_value ("r");
+        ? args(1) : octave_value ("r");
 
       octave_value arch = (nargin == 3)
-	? args(2) : octave_value ("native");
+        ? args(2) : octave_value ("native");
 
       int fid = -1;
 
       octave_stream os = do_stream_open (args(0), mode, arch, "fopen", fid);
 
       if (os && ! error_state)
-	{
-	  retval(1) = "";
-	  retval(0) = octave_stream_list::insert (os);
-	}
+        {
+          retval(1) = "";
+          retval(0) = octave_stream_list::insert (os);
+        }
       else
-	{
-	  int error_number = 0;
+        {
+          int error_number = 0;
 
-	  retval(1) = os.error (false, error_number);
-	  retval(0) = -1.0;
-	}
+          retval(1) = os.error (false, error_number);
+          retval(0) = -1.0;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (freport, args, ,
@@ -767,17 +767,17 @@ 0 for success, and -1 if an error was en
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "frewind");
 
       if (! error_state)
-	result = os.rewind ();
+        result = os.rewind ();
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
@@ -803,22 +803,22 @@ Return 0 on success and -1 on error.\n\
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fseek");
 
       if (! error_state)
-	{
-	  octave_value origin_arg = (nargin == 3)
-	    ? args(2) : octave_value (-1.0);
+        {
+          octave_value origin_arg = (nargin == 3)
+            ? args(2) : octave_value (-1.0);
 
-	  retval = os.seek (args(1), origin_arg);
-	}
+          retval = os.seek (args(1), origin_arg);
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (ftell, args, ,
@@ -833,17 +833,17 @@ from the beginning of the file @var{fid}
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "ftell");
 
       if (! error_state)
-	retval = os.tell ();
+        retval = os.tell ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fprintf, args, nargout,
@@ -864,44 +864,44 @@ If @var{fid} is omitted, the output is w
   int nargin = args.length ();
 
   if (nargin > 1 || (nargin > 0 && args(0).is_string ()))
     {
       octave_stream os;
       int fmt_n = 0;
 
       if (args(0).is_string ()) 
-	{
-	  os = octave_stream_list::lookup (1, who);
-	}
+        {
+          os = octave_stream_list::lookup (1, who);
+        }
       else
-	{
-	  fmt_n = 1;
-	  os = octave_stream_list::lookup (args(0), who);
-	}
+        {
+          fmt_n = 1;
+          os = octave_stream_list::lookup (args(0), who);
+        }
 
       if (! error_state)
-	{
-	  if (args(fmt_n).is_string ())
-	    {
-	      octave_value_list tmp_args;
+        {
+          if (args(fmt_n).is_string ())
+            {
+              octave_value_list tmp_args;
 
-	      if (nargin > 1 + fmt_n)
-		{
-		  tmp_args.resize (nargin-fmt_n-1, octave_value ());
+              if (nargin > 1 + fmt_n)
+                {
+                  tmp_args.resize (nargin-fmt_n-1, octave_value ());
 
-		  for (int i = fmt_n + 1; i < nargin; i++)
-		    tmp_args(i-fmt_n-1) = args(i);
-		}
+                  for (int i = fmt_n + 1; i < nargin; i++)
+                    tmp_args(i-fmt_n-1) = args(i);
+                }
 
-	      result = os.printf (args(fmt_n), tmp_args, who);
-	    }
-	  else
-	    ::error ("%s: format must be a string", who.c_str ());
-	}
+              result = os.printf (args(fmt_n), tmp_args, who);
+            }
+          else
+            ::error ("%s: format must be a string", who.c_str ());
+        }
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
@@ -927,31 +927,31 @@ complete description of the syntax of th
 
   int result = -1;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       if (args(0).is_string ())
-	{
-	  octave_value_list tmp_args;
+        {
+          octave_value_list tmp_args;
 
-	  if (nargin > 1)
-	    {
-	      tmp_args.resize (nargin-1, octave_value ());
+          if (nargin > 1)
+            {
+              tmp_args.resize (nargin-1, octave_value ());
 
-	      for (int i = 1; i < nargin; i++)
-		tmp_args(i-1) = args(i);
-	    }
+              for (int i = 1; i < nargin; i++)
+                tmp_args(i-1) = args(i);
+            }
 
-	  result = stdout_stream.printf (args(0), tmp_args, who);
-	}
+          result = stdout_stream.printf (args(0), tmp_args, who);
+        }
       else
-	::error ("%s: format must be a string", who.c_str ());
+        ::error ("%s: format must be a string", who.c_str ());
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
@@ -972,17 +972,17 @@ Return a non-negative number on success 
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
-	retval = os.puts (args(1), who);
+        retval = os.puts (args(1), who);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (puts, args, ,
@@ -1028,41 +1028,41 @@ converted.\n\
       retval(1) = "unknown error";
       retval(0) = "";
 
       octave_ostrstream *ostr = new octave_ostrstream ();
 
       octave_stream os (ostr);
 
       if (os.is_valid ())
-	{
-	  octave_value fmt_arg = args(0);
+        {
+          octave_value fmt_arg = args(0);
 
-	  if (fmt_arg.is_string ())
-	    {
-	      octave_value_list tmp_args;
+          if (fmt_arg.is_string ())
+            {
+              octave_value_list tmp_args;
 
-	      if (nargin > 1)
-		{
-		  tmp_args.resize (nargin-1, octave_value ());
+              if (nargin > 1)
+                {
+                  tmp_args.resize (nargin-1, octave_value ());
 
-		  for (int i = 1; i < nargin; i++)
-		    tmp_args(i-1) = args(i);
-		}
+                  for (int i = 1; i < nargin; i++)
+                    tmp_args(i-1) = args(i);
+                }
 
-	      retval(2) = os.printf (fmt_arg, tmp_args, who);
-	      retval(1) = os.error ();
-	      retval(0) = octave_value (ostr->str (),
-					fmt_arg.is_sq_string () ? '\'' : '"');
-	    }
-	  else
-	    ::error ("%s: format must be a string", who.c_str ());
-	}
+              retval(2) = os.printf (fmt_arg, tmp_args, who);
+              retval(1) = os.error ();
+              retval(0) = octave_value (ostr->str (),
+                                        fmt_arg.is_sq_string () ? '\'' : '"');
+            }
+          else
+            ::error ("%s: format must be a string", who.c_str ());
+        }
       else
-	::error ("%s: unable to create output buffer", who.c_str ());
+        ::error ("%s: unable to create output buffer", who.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
@@ -1120,59 +1120,59 @@ complete description of the syntax of th
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
-	{
-	  if (args(1).is_string ())
-	    retval = os.oscanf (args(1), who);
-	  else
-	    ::error ("%s: format must be a string", who.c_str ());
-	}
+        {
+          if (args(1).is_string ())
+            retval = os.oscanf (args(1), who);
+          else
+            ::error ("%s: format must be a string", who.c_str ());
+        }
     }
   else
     {
       retval (1) = 0.0;
       retval (0) = Matrix ();
 
       if (nargin == 2 || nargin == 3)
-	{
-	  octave_stream os = octave_stream_list::lookup (args(0), who);
+        {
+          octave_stream os = octave_stream_list::lookup (args(0), who);
 
-	  if (! error_state)
-	    {
-	      if (args(1).is_string ())
-		{
-		  octave_idx_type count = 0;
+          if (! error_state)
+            {
+              if (args(1).is_string ())
+                {
+                  octave_idx_type count = 0;
 
-		  Array<double> size = (nargin == 3)
-		    ? args(2).vector_value ()
-		    : Array<double> (1, lo_ieee_inf_value ());
+                  Array<double> size = (nargin == 3)
+                    ? args(2).vector_value ()
+                    : Array<double> (1, lo_ieee_inf_value ());
 
-		  if (! error_state)
-		    {
-		      octave_value tmp = os.scanf (args(1), size, count, who);
+                  if (! error_state)
+                    {
+                      octave_value tmp = os.scanf (args(1), size, count, who);
 
-		      if (! error_state)
-			{
-			  retval(1) = count;
-			  retval(0) = tmp;
-			}
-		    }
-		}
-	      else
-		::error ("%s: format must be a string", who.c_str ());
-	    }
-	}
+                      if (! error_state)
+                        {
+                          retval(1) = count;
+                          retval(0) = tmp;
+                        }
+                    }
+                }
+              else
+                ::error ("%s: format must be a string", who.c_str ());
+            }
+        }
       else
-	print_usage ();
+        print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
@@ -1187,87 +1187,87 @@ string is treated as an end-of-file cond
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
     {
       if (args(0).is_string ())
-	{
-	  std::string data = args(0).string_value ();
+        {
+          std::string data = args(0).string_value ();
 
-	  octave_stream os = octave_istrstream::create (data);
+          octave_stream os = octave_istrstream::create (data);
 
-	  if (os.is_valid ())
-	    {
-	      if (args(1).is_string ())
-		retval = os.oscanf (args(1), who);
-	      else
-		::error ("%s: format must be a string", who.c_str ());
-	    }
-	  else
-	    ::error ("%s: unable to create temporary input buffer",
-		     who.c_str ());
-	}
+          if (os.is_valid ())
+            {
+              if (args(1).is_string ())
+                retval = os.oscanf (args(1), who);
+              else
+                ::error ("%s: format must be a string", who.c_str ());
+            }
+          else
+            ::error ("%s: unable to create temporary input buffer",
+                     who.c_str ());
+        }
       else
-	::error ("%s: first argument must be a string", who.c_str ());
+        ::error ("%s: first argument must be a string", who.c_str ());
     }
   else
     {
       if (nargin == 2 || nargin == 3)
-	{
-	  retval(3) = -1.0;
-	  retval(2) = "unknown error";
-	  retval(1) = 0.0;
-	  retval(0) = Matrix ();
+        {
+          retval(3) = -1.0;
+          retval(2) = "unknown error";
+          retval(1) = 0.0;
+          retval(0) = Matrix ();
 
-	  if (args(0).is_string ())
-	    {
-	      std::string data = args(0).string_value ();
+          if (args(0).is_string ())
+            {
+              std::string data = args(0).string_value ();
 
-	      octave_stream os = octave_istrstream::create (data);
+              octave_stream os = octave_istrstream::create (data);
 
-	      if (os.is_valid ())
-		{
-		  if (args(1).is_string ())
-		    {
-		      octave_idx_type count = 0;
+              if (os.is_valid ())
+                {
+                  if (args(1).is_string ())
+                    {
+                      octave_idx_type count = 0;
 
-		      Array<double> size = (nargin == 3)
-			? args(2).vector_value ()
-			: Array<double> (1, lo_ieee_inf_value ());
+                      Array<double> size = (nargin == 3)
+                        ? args(2).vector_value ()
+                        : Array<double> (1, lo_ieee_inf_value ());
 
-		      octave_value tmp = os.scanf (args(1), size, count, who);
+                      octave_value tmp = os.scanf (args(1), size, count, who);
 
-		      if (! error_state)
-			{
-			  // FIXME -- is this the right thing to do?
-			  // Extract error message first, because getting
-			  // position will clear it.
-			  std::string errmsg = os.error ();
+                      if (! error_state)
+                        {
+                          // FIXME -- is this the right thing to do?
+                          // Extract error message first, because getting
+                          // position will clear it.
+                          std::string errmsg = os.error ();
 
-			  retval(3) = os.tell () + 1;
-			  retval(2) = errmsg;
-			  retval(1) = count;
-			  retval(0) = tmp;
-			}
-		    }
-		  else
-		    ::error ("%s: format must be a string", who.c_str ());
-		}
-	      else
-		::error ("%s: unable to create temporary input buffer",
-			 who.c_str  ());
-	    }
-	  else
-	    ::error ("%s: first argument must be a string", who.c_str ());
-	}
+                          retval(3) = os.tell () + 1;
+                          retval(2) = errmsg;
+                          retval(1) = count;
+                          retval(0) = tmp;
+                        }
+                    }
+                  else
+                    ::error ("%s: format must be a string", who.c_str ());
+                }
+              else
+                ::error ("%s: unable to create temporary input buffer",
+                         who.c_str  ());
+            }
+          else
+            ::error ("%s: first argument must be a string", who.c_str ());
+        }
       else
-	print_usage ();
+        print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} scanf (@var{template}, @var{size})\n\
@@ -1287,66 +1287,66 @@ programs.\n\
   for (int i = 0; i < nargin; i++)
     tmp_args (i+1) = args (i);
 
   return Ffscanf (tmp_args, nargout);
 }
 
 static octave_value
 do_fread (octave_stream& os, const octave_value& size_arg,
-	  const octave_value& prec_arg, const octave_value& skip_arg,
-	  const octave_value& arch_arg, octave_idx_type& count)
+          const octave_value& prec_arg, const octave_value& skip_arg,
+          const octave_value& arch_arg, octave_idx_type& count)
 {
   octave_value retval;
 
   count = -1;
 
   Array<double> size = size_arg.vector_value ();
 
   if (! error_state)
     {
       std::string prec = prec_arg.string_value ();
 
       if (! error_state)
-	{
-	  int block_size = 1;
-	  oct_data_conv::data_type input_type;
-	  oct_data_conv::data_type output_type;
+        {
+          int block_size = 1;
+          oct_data_conv::data_type input_type;
+          oct_data_conv::data_type output_type;
 
-	  oct_data_conv::string_to_data_type (prec, block_size,
-					      input_type, output_type);
+          oct_data_conv::string_to_data_type (prec, block_size,
+                                              input_type, output_type);
 
-	  if (! error_state)
-	    {
-	      int skip = skip_arg.int_value (true);
+          if (! error_state)
+            {
+              int skip = skip_arg.int_value (true);
 
-	      if (! error_state)
-		{
-		  std::string arch = arch_arg.string_value ();
+              if (! error_state)
+                {
+                  std::string arch = arch_arg.string_value ();
 
-		  if (! error_state)
-		    {
-		      oct_mach_info::float_format flt_fmt
-			= oct_mach_info::string_to_float_format (arch);
+                  if (! error_state)
+                    {
+                      oct_mach_info::float_format flt_fmt
+                        = oct_mach_info::string_to_float_format (arch);
 
-		      if (! error_state)
-			retval = os.read (size, block_size, input_type,
-					  output_type, skip, flt_fmt, count);
-		    }
-		  else
-		    ::error ("fread: architecture type must be a string");
-		}
-	      else
-		::error ("fread: skip must be an integer");
-	    }
-	  else
-	    ::error ("fread: invalid data type specified");
-	}
+                      if (! error_state)
+                        retval = os.read (size, block_size, input_type,
+                                          output_type, skip, flt_fmt, count);
+                    }
+                  else
+                    ::error ("fread: architecture type must be a string");
+                }
+              else
+                ::error ("fread: skip must be an integer");
+            }
+          else
+            ::error ("fread: invalid data type specified");
+        }
       else
-	::error ("fread: precision must be a string");
+        ::error ("fread: precision must be a string");
     }
   else
     ::error ("fread: invalid size specified");
 
   return retval;
 }
 
 DEFUN (fread, args, ,
@@ -1531,96 +1531,96 @@ values read is returned in @code{count}\
   if (nargin > 0 && nargin < 6)
     {
       retval(1) = -1.0;
       retval(0) = Matrix ();
 
       octave_stream os = octave_stream_list::lookup (args(0), "fread");
 
       if (! error_state)
-	{
-	  octave_value size = lo_ieee_inf_value ();
-	  octave_value prec = "uchar";
-	  octave_value skip = 0;
-	  octave_value arch = "unknown";
+        {
+          octave_value size = lo_ieee_inf_value ();
+          octave_value prec = "uchar";
+          octave_value skip = 0;
+          octave_value arch = "unknown";
 
-	  int idx = 1;
+          int idx = 1;
 
-	  if (nargin > idx && ! args(idx).is_string ())
-	    size = args(idx++);
+          if (nargin > idx && ! args(idx).is_string ())
+            size = args(idx++);
 
-	  if (nargin > idx)
-	    prec = args(idx++);
+          if (nargin > idx)
+            prec = args(idx++);
 
-	  if (nargin > idx)
-	    skip = args(idx++);
+          if (nargin > idx)
+            skip = args(idx++);
 
-	  if (nargin > idx)
-	    arch = args(idx++);
-	  else if (skip.is_string ())
-	    {
-	      arch = skip;
-	      skip = 0;
-	    }
+          if (nargin > idx)
+            arch = args(idx++);
+          else if (skip.is_string ())
+            {
+              arch = skip;
+              skip = 0;
+            }
 
-	  octave_idx_type count = -1;
+          octave_idx_type count = -1;
 
-	  octave_value tmp = do_fread (os, size, prec, skip, arch, count);
+          octave_value tmp = do_fread (os, size, prec, skip, arch, count);
 
-	  retval(1) = count;
-	  retval(0) = tmp;
-	}
+          retval(1) = count;
+          retval(0) = tmp;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
-	   const octave_value& prec_arg, const octave_value& skip_arg,
-	   const octave_value& arch_arg)
+           const octave_value& prec_arg, const octave_value& skip_arg,
+           const octave_value& arch_arg)
 {
   int retval = -1;
 
   std::string prec = prec_arg.string_value ();
 
   if (! error_state)
     {
       int block_size = 1;
       oct_data_conv::data_type output_type;
 
       oct_data_conv::string_to_data_type (prec, block_size, output_type);
 
       if (! error_state)
-	{
-	  int skip = skip_arg.int_value (true);
+        {
+          int skip = skip_arg.int_value (true);
 
-	  if (! error_state)
-	    {
-	      std::string arch = arch_arg.string_value ();
+          if (! error_state)
+            {
+              std::string arch = arch_arg.string_value ();
 
-	      if (! error_state)
-		{
-		  oct_mach_info::float_format flt_fmt
-		    = oct_mach_info::string_to_float_format (arch);
+              if (! error_state)
+                {
+                  oct_mach_info::float_format flt_fmt
+                    = oct_mach_info::string_to_float_format (arch);
 
-		  if (! error_state)
-		    retval = os.write (data, block_size, output_type,
-				       skip, flt_fmt);
-		}
-	      else
-		::error ("fwrite: architecture type must be a string");
-	    }
-	  else
-	    ::error ("fwrite: skip must be an integer");
-	}
+                  if (! error_state)
+                    retval = os.write (data, block_size, output_type,
+                                       skip, flt_fmt);
+                }
+              else
+                ::error ("fwrite: architecture type must be a string");
+            }
+          else
+            ::error ("fwrite: skip must be an integer");
+        }
       else
-	::error ("fwrite: invalid precision specified");
+        ::error ("fwrite: invalid precision specified");
     }
   else
     ::error ("fwrite: precision must be a string");
 
   return retval;
 }
 
 DEFUN (fwrite, args, ,
@@ -1645,43 +1645,43 @@ are too large to fit in the specified pr
 
   int nargin = args.length ();
 
   if (nargin > 1 && nargin < 6)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fwrite");
 
       if (! error_state)
-	{
-	  octave_value prec = "uchar";
-	  octave_value skip = 0;
-	  octave_value arch = "unknown";
+        {
+          octave_value prec = "uchar";
+          octave_value skip = 0;
+          octave_value arch = "unknown";
 
-	  int idx = 1;
+          int idx = 1;
 
-	  octave_value data = args(idx++);
+          octave_value data = args(idx++);
 
-	  if (nargin > idx)
-	    prec = args(idx++);
+          if (nargin > idx)
+            prec = args(idx++);
 
-	  if (nargin > idx)
-	    skip = args(idx++);
+          if (nargin > idx)
+            skip = args(idx++);
 
-	  if (nargin > idx)
-	    arch = args(idx++);
-	  else if (skip.is_string ())
-	    {
-	      arch = skip;
-	      skip = 0;
-	    }
+          if (nargin > idx)
+            arch = args(idx++);
+          else if (skip.is_string ())
+            {
+              arch = skip;
+              skip = 0;
+            }
 
-	  double status = do_fwrite (os, data, prec, skip, arch);
+          double status = do_fwrite (os, data, prec, skip, arch);
 
-	  retval = status;
-	}
+          retval = status;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("feof", Ffeof, args, ,
@@ -1698,17 +1698,17 @@ result in an end-of-file condition.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "feof");
 
       if (! error_state)
-	retval = os.eof () ? 1.0 : 0.0;
+        retval = os.eof () ? 1.0 : 0.0;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("ferror", Fferror, args, ,
@@ -1727,36 +1727,36 @@ error condition.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "ferror");
 
       if (! error_state)
-	{
-	  bool clear = false;
+        {
+          bool clear = false;
 
-	  if (nargin == 2)
-	    {
-	      std::string opt = args(1).string_value ();
+          if (nargin == 2)
+            {
+              std::string opt = args(1).string_value ();
 
-	      if (! error_state)
-		clear = (opt == "clear");
-	      else
-		return retval;
-	    }
+              if (! error_state)
+                clear = (opt == "clear");
+              else
+                return retval;
+            }
 
-	  int error_number = 0;
+          int error_number = 0;
 
-	  std::string error_message = os.error (clear, error_number);
+          std::string error_message = os.error (clear, error_number);
 
-	  retval(1) = error_number;
-	  retval(0) = error_message;
-	}
+          retval(1) = error_number;
+          retval(0) = error_message;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (popen, args, ,
@@ -1796,41 +1796,41 @@ endwhile\n\
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string mode = args(1).string_value ();
+        {
+          std::string mode = args(1).string_value ();
 
-	  if (! error_state)
-	    {
-	      if (mode == "r")
-		{
-		  octave_stream ips = octave_iprocstream::create (name);
+          if (! error_state)
+            {
+              if (mode == "r")
+                {
+                  octave_stream ips = octave_iprocstream::create (name);
 
-		  retval = octave_stream_list::insert (ips);
-		}
-	      else if (mode == "w")
-		{
-		  octave_stream ops = octave_oprocstream::create (name);
+                  retval = octave_stream_list::insert (ips);
+                }
+              else if (mode == "w")
+                {
+                  octave_stream ops = octave_oprocstream::create (name);
 
-		  retval = octave_stream_list::insert (ops);
-		}
-	      else
-		::error ("popen: invalid mode specified");
-	    }
-	  else
-	    ::error ("popen: mode must be a string");
-	}
+                  retval = octave_stream_list::insert (ops);
+                }
+              else
+                ::error ("popen: invalid mode specified");
+            }
+          else
+            ::error ("popen: mode must be a string");
+        }
       else
-	::error ("popen: name must be a string");
+        ::error ("popen: name must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (pclose, args, ,
@@ -1870,27 +1870,27 @@ that it will not be available by the tim
 
   int len = args.length ();
 
   if (len < 3)
     {
       std::string dir = len > 0 ? args(0).string_value () : std::string ();
 
       if (! error_state)
-	{
-	  std::string pfx
-	    = len > 1 ? args(1).string_value () : std::string ("oct-");
+        {
+          std::string pfx
+            = len > 1 ? args(1).string_value () : std::string ("oct-");
 
-	  if (! error_state)
-	    retval = octave_tempnam (dir, pfx);
-	  else
-	    ::error ("expecting second argument to be a string");
-	}
+          if (! error_state)
+            retval = octave_tempnam (dir, pfx);
+          else
+            ::error ("expecting second argument to be a string");
+        }
       else
-	::error ("expecting first argument to be a string");
+        ::error ("expecting first argument to be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (octave_tmp_file_name, tmpnam);
@@ -1916,35 +1916,35 @@ system-dependent error message.\n\
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       FILE *fid = tmpfile ();
 
       if (fid)
-	{
-	  std::string nm;
+        {
+          std::string nm;
 
-	  std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
+          std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
 
-	  octave_stream s = octave_stdiostream::create (nm, fid, md);
+          octave_stream s = octave_stdiostream::create (nm, fid, md);
 
-	  if (s)
-	    retval(0) = octave_stream_list::insert (s);
-	  else
-	    error ("tmpfile: failed to create octave_stdiostream object");
+          if (s)
+            retval(0) = octave_stream_list::insert (s);
+          else
+            error ("tmpfile: failed to create octave_stdiostream object");
 
-	}
+        }
       else
-	{
-	  using namespace std;
-	  retval(1) = ::strerror (errno);
-	  retval(0) = -1;
-	}
+        {
+          using namespace std;
+          retval(1) = ::strerror (errno);
+          retval(0) = -1;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #if defined (HAVE_MKSTEMPS)
@@ -1955,17 +1955,17 @@ extern "C" int mkstemps (char *pattern, 
 #if ! defined (HAVE_MKSTEMP) && ! defined (HAVE_MKSTEMPS) && defined (_MSC_VER)
 #include <fcntl.h>
 #include <sys/stat.h>
 int mkstemp (char *tmpl)
 {
   int ret=-1;
   mktemp (tmpl);
   ret = open (tmpl, O_RDWR | O_BINARY | O_CREAT | O_EXCL | _O_SHORT_LIVED,
-	      _S_IREAD | _S_IWRITE);
+              _S_IREAD | _S_IWRITE);
   return ret;
 }
 #define HAVE_MKSTEMP 1
 #endif
 
 DEFUN (mkstemp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (@var{template}, @var{delete})\n\
@@ -1998,67 +1998,67 @@ error message.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string tmpl8 = args(0).string_value ();
 
       if (! error_state)
-	{
-	  OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
-	  strcpy (tmp, tmpl8.c_str ());
+        {
+          OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
+          strcpy (tmp, tmpl8.c_str ());
 
 #if defined (HAVE_MKSTEMP)
-	  int fd = mkstemp (tmp);
+          int fd = mkstemp (tmp);
 #else
-	  int fd = mkstemps (tmp, 0);
+          int fd = mkstemps (tmp, 0);
 #endif
 
-	  if (fd < 0)
-	    {
-	      using namespace std;
-	      retval(2) = ::strerror (errno);
-	      retval(0) = fd;
-	    }
-	  else
-	    {
-	      const char *fopen_mode = "w+";
+          if (fd < 0)
+            {
+              using namespace std;
+              retval(2) = ::strerror (errno);
+              retval(0) = fd;
+            }
+          else
+            {
+              const char *fopen_mode = "w+";
 
-	      FILE *fid = fdopen (fd, fopen_mode);
+              FILE *fid = fdopen (fd, fopen_mode);
 
-	      if (fid)
-		{
-		  std::string nm = tmp;
+              if (fid)
+                {
+                  std::string nm = tmp;
 
-		  std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
+                  std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
 
-		  octave_stream s = octave_stdiostream::create (nm, fid, md);
+                  octave_stream s = octave_stdiostream::create (nm, fid, md);
 
-		  if (s)
-		    {
-		      retval(1) = nm;
-		      retval(0) = octave_stream_list::insert (s);
+                  if (s)
+                    {
+                      retval(1) = nm;
+                      retval(0) = octave_stream_list::insert (s);
 
-		      if (nargin == 2 && args(1).is_true ())
-			mark_for_deletion (nm);
-		    }
-		  else
-		    error ("mkstemp: failed to create octave_stdiostream object");
-		}
-	      else
-		{
-		  using namespace std;
-		  retval(2) = ::strerror (errno);
-		  retval(0) = -1;
-		}
-	    }
-	}
+                      if (nargin == 2 && args(1).is_true ())
+                        mark_for_deletion (nm);
+                    }
+                  else
+                    error ("mkstemp: failed to create octave_stdiostream object");
+                }
+              else
+                {
+                  using namespace std;
+                  retval(2) = ::strerror (errno);
+                  retval(0) = -1;
+                }
+            }
+        }
       else
-	error ("mkstemp: expecting string as first argument");
+        error ("mkstemp: expecting string as first argument");
     }
   else
     print_usage ();
 
 #else
   retval(2) = "mkstemp: not supported on this sytem";
 #endif
 
@@ -2074,26 +2074,26 @@ convert (int x, int ibase, int obase)
 
   if (tmp > ibase - 1)
     ::error ("umask: invalid digit");
   else
     {
       retval = tmp;
       int mult = ibase;
       while ((x = (x - tmp) / obase))
-	{
-	  tmp = x % obase;
-	  if (tmp > ibase - 1)
-	    {
-	      ::error ("umask: invalid digit");
-	      break;
-	    }
-	  retval += mult * tmp;
-	  mult *= ibase;
-	}
+        {
+          tmp = x % obase;
+          if (tmp > ibase - 1)
+            {
+              ::error ("umask: invalid digit");
+              break;
+            }
+          retval += mult * tmp;
+          mult *= ibase;
+        }
     }
 
   return retval;
 }
 
 DEFUNX ("umask", Fumask, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} umask (@var{mask})\n\
@@ -2107,35 +2107,35 @@ interpreted as an octal number); otherwi
 
   int status = 0;
 
   if (args.length () == 1)
     {
       int mask = args(0).int_value (true);
 
       if (! error_state)
-	{
-	  if (mask < 0)
-	    {
-	      status = -1;
-	      ::error ("umask: MASK must be a positive integer value");
-	    }
-	  else
-	    {
-	      int oct_mask = convert (mask, 8, 10);
+        {
+          if (mask < 0)
+            {
+              status = -1;
+              ::error ("umask: MASK must be a positive integer value");
+            }
+          else
+            {
+              int oct_mask = convert (mask, 8, 10);
 
-	      if (! error_state)
-		status = convert (octave_umask (oct_mask), 10, 8);
-	    }
-	}
+              if (! error_state)
+                status = convert (octave_umask (oct_mask), 10, 8);
+            }
+        }
       else
-	{
-	  status = -1;
-	  ::error ("umask: expecting integer argument");
-	}
+        {
+          status = -1;
+          ::error ("umask: expecting integer argument");
+        }
     }
   else
     print_usage ();
 
   if (status >= 0)
     retval(0) = status;
 
   return retval;
@@ -2219,17 +2219,17 @@ DEFUNX ("SEEK_END", FSEEK_END, args, ,
 See SEEK_SET.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_END", args, 1);
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args,
-	     const octave_value& val)
+             const octave_value& val)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = val;
   else
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -61,24 +61,24 @@ opengl_texture
 {
 protected:
   class texture_rep
   {
   public:
     texture_rep (void) : valid (false), count (1) { }
 
     texture_rep (GLuint id_arg, int w_arg, int h_arg, int tw_arg, int th_arg)
-	: id (id_arg), w (w_arg), h (h_arg), tw (tw_arg), th (th_arg),
-	  tx (double(w)/tw), ty (double(h)/th), valid (true),
-	  count (1) { }
+        : id (id_arg), w (w_arg), h (h_arg), tw (tw_arg), th (th_arg),
+          tx (double(w)/tw), ty (double(h)/th), valid (true),
+          count (1) { }
 
     ~texture_rep (void)
       {
-	if (valid)
-	  glDeleteTextures (1, &id);
+        if (valid)
+          glDeleteTextures (1, &id);
       }
 
     void bind (int mode) const
       { if (valid) glBindTexture (mode, id); }
 
     void tex_coord (double q, double r) const
       { if (valid) glTexCoord2d (q*tx, r*ty); }
 
@@ -102,23 +102,23 @@ public:
       : rep (tx.rep)
     {
       rep->count++;
     }
 
   ~opengl_texture (void)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
   opengl_texture& operator = (const opengl_texture& tx)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
 
       rep = tx.rep;
       rep->count++;
 
       return *this;
     }
 
   static opengl_texture create (const octave_value& data);
@@ -162,69 +162,69 @@ opengl_texture::create (const octave_val
 
       tw = next_power_of_2 (w);
       th = next_power_of_2 (w);
 
       glGenTextures (1, &id);
       glBindTexture (GL_TEXTURE_2D, id);
 
       if (data.is_double_type ())
-	{
-	  const NDArray xdata = data.array_value ();
-
-	  OCTAVE_LOCAL_BUFFER (float, a, (3*tw*th));
-
-	  for (int i = 0; i < h; i++)
-	    {
-	      for (int j = 0, idx = i*tw*3; j < w; j++, idx += 3)
-		{
-		  a[idx]   = xdata(i,j,0);
-		  a[idx+1] = xdata(i,j,1);
-		  a[idx+2] = xdata(i,j,2);
-		}
-	    }
-
-	  glTexImage2D (GL_TEXTURE_2D, 0, 3, tw, th, 0,
-			GL_RGB, GL_FLOAT, a);
-	}
+        {
+          const NDArray xdata = data.array_value ();
+
+          OCTAVE_LOCAL_BUFFER (float, a, (3*tw*th));
+
+          for (int i = 0; i < h; i++)
+            {
+              for (int j = 0, idx = i*tw*3; j < w; j++, idx += 3)
+                {
+                  a[idx]   = xdata(i,j,0);
+                  a[idx+1] = xdata(i,j,1);
+                  a[idx+2] = xdata(i,j,2);
+                }
+            }
+
+          glTexImage2D (GL_TEXTURE_2D, 0, 3, tw, th, 0,
+                        GL_RGB, GL_FLOAT, a);
+        }
       else if (data.is_uint8_type ())
-	{
-	  const uint8NDArray xdata = data.uint8_array_value ();
-
-	  OCTAVE_LOCAL_BUFFER (octave_uint8, a, (3*tw*th));
-
-	  for (int i = 0; i < h; i++)
-	    {
-	      for (int j = 0, idx = i*tw*3; j < w; j++, idx += 3)
-		{
-		  a[idx]   = xdata(i,j,0);
-		  a[idx+1] = xdata(i,j,1);
-		  a[idx+2] = xdata(i,j,2);
-		}
-	    }
-
-	  glTexImage2D (GL_TEXTURE_2D, 0, 3, tw, th, 0,
-			GL_RGB, GL_UNSIGNED_BYTE, a);
-	}
+        {
+          const uint8NDArray xdata = data.uint8_array_value ();
+
+          OCTAVE_LOCAL_BUFFER (octave_uint8, a, (3*tw*th));
+
+          for (int i = 0; i < h; i++)
+            {
+              for (int j = 0, idx = i*tw*3; j < w; j++, idx += 3)
+                {
+                  a[idx]   = xdata(i,j,0);
+                  a[idx+1] = xdata(i,j,1);
+                  a[idx+2] = xdata(i,j,2);
+                }
+            }
+
+          glTexImage2D (GL_TEXTURE_2D, 0, 3, tw, th, 0,
+                        GL_RGB, GL_UNSIGNED_BYTE, a);
+        }
       else
-	{
-	  ok = false;
-	  warning ("opengl_texture::create: invalid texture data type (expected double or uint8)");
-	}
+        {
+          ok = false;
+          warning ("opengl_texture::create: invalid texture data type (expected double or uint8)");
+        }
 
       if (ok)
-	{
-	  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-	  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-
-	  if (glGetError () != GL_NO_ERROR)
-	    warning ("opengl_texture::create: OpenGL error while generating texture data");
-	  else
-	    retval = opengl_texture (new texture_rep (id, w, h, tw, th));
-	}
+        {
+          glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+          glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+          if (glGetError () != GL_NO_ERROR)
+            warning ("opengl_texture::create: OpenGL error while generating texture data");
+          else
+            retval = opengl_texture (new texture_rep (id, w, h, tw, th));
+        }
     }
   else
     warning ("opengl_texture::create: invalid texture data size");
 
   return retval;
 }
 
 class
@@ -242,17 +242,17 @@ public:
   opengl_tesselator (void) : glu_tess (0) { init (); }
 
   virtual ~opengl_tesselator (void)
     { if (glu_tess) gluDeleteTess (glu_tess); }
 
   void begin_polygon (bool filled = true)
     {
       gluTessProperty (glu_tess, GLU_TESS_BOUNDARY_ONLY,
-		       (filled ? GL_FALSE : GL_TRUE));
+                       (filled ? GL_FALSE : GL_TRUE));
       fill = filled;
       gluTessBeginPolygon (glu_tess, this);
     }
 
   void end_polygon (void) const
     { gluTessEndPolygon (glu_tess); }
 
   void begin_contour (void) const
@@ -267,55 +267,55 @@ public:
 protected:
   virtual void begin (GLenum /*type*/) { }
 
   virtual void end (void) { }
 
   virtual void vertex (void */*data*/) { }
 
   virtual void combine (GLdouble /*c*/[3], void */*data*/[4],
-			GLfloat /*w*/[4], void **/*out_data*/) { }
+                        GLfloat /*w*/[4], void **/*out_data*/) { }
 
   virtual void edge_flag (GLboolean /*flag*/) { }
 
   virtual void error (GLenum err)
     { ::error ("OpenGL tesselation error (%d)", err); }
 
   virtual void init (void)
     {
       glu_tess = gluNewTess ();
 
       gluTessCallback (glu_tess, GLU_TESS_BEGIN_DATA,
-		       reinterpret_cast<fcn> (tess_begin));
+                       reinterpret_cast<fcn> (tess_begin));
       gluTessCallback (glu_tess, GLU_TESS_END_DATA,
-		       reinterpret_cast<fcn> (tess_end));
+                       reinterpret_cast<fcn> (tess_end));
       gluTessCallback (glu_tess, GLU_TESS_VERTEX_DATA,
-		       reinterpret_cast<fcn> (tess_vertex));
+                       reinterpret_cast<fcn> (tess_vertex));
       gluTessCallback (glu_tess, GLU_TESS_COMBINE_DATA,
-		       reinterpret_cast<fcn> (tess_combine));
+                       reinterpret_cast<fcn> (tess_combine));
       gluTessCallback (glu_tess, GLU_TESS_EDGE_FLAG_DATA,
-		       reinterpret_cast<fcn> (tess_edge_flag));
+                       reinterpret_cast<fcn> (tess_edge_flag));
       gluTessCallback (glu_tess, GLU_TESS_ERROR_DATA,
-		       reinterpret_cast<fcn> (tess_error));
+                       reinterpret_cast<fcn> (tess_error));
     }
 
   bool is_filled (void) const { return fill; }
 
 private:
   static void CALLBACK tess_begin (GLenum type, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->begin (type); }
   
   static void CALLBACK tess_end (void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->end (); }
   
   static void CALLBACK tess_vertex (void *v, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->vertex (v); }
   
   static void CALLBACK tess_combine (GLdouble c[3], void *v[4], GLfloat w[4],
-				     void **out,  void *t)
+                                     void **out,  void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->combine (c, v, w, out); }
   
   static void CALLBACK tess_edge_flag (GLboolean flag, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->edge_flag (flag); }
   
   static void CALLBACK tess_error (GLenum err, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->error (err); }
 
@@ -341,20 +341,20 @@ public:
     float specular_exp;
 
     // reference counter
     int count;
 
     vertex_data_rep (void) : count (1) { }
 
     vertex_data_rep (const Matrix& c, const Matrix& col, const Matrix& n,
-		     double a, float as, float ds, float ss, float se)
-	: coords (c), color (col), normal (n), alpha (a),
-	  ambient (as), diffuse (ds), specular (ss), specular_exp (se),
-	  count (1) { }
+                     double a, float as, float ds, float ss, float se)
+        : coords (c), color (col), normal (n), alpha (a),
+          ambient (as), diffuse (ds), specular (ss), specular_exp (se),
+          count (1) { }
   };
 
 private:
   vertex_data_rep *rep;
 
   vertex_data_rep *nil_rep (void) const
     {
       static vertex_data_rep *nr = new vertex_data_rep ();
@@ -365,33 +365,33 @@ private:
 public:
   vertex_data (void) : rep (nil_rep ())
     { rep->count++; }
 
   vertex_data (const vertex_data& v) : rep (v.rep)
     { rep->count++; }
 
   vertex_data (const Matrix& c, const Matrix& col, const Matrix& n,
-	       double a, float as, float ds, float ss, float se)
+               double a, float as, float ds, float ss, float se)
       : rep (new vertex_data_rep (c, col, n, a, as, ds, ss, se))
     { }
 
   vertex_data (vertex_data_rep *new_rep)
       : rep (new_rep) { }
 
   ~vertex_data (void)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
   vertex_data& operator = (const vertex_data& v)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
 
       rep = v.rep;
       rep->count++;
 
       return *this;
     }
 
   vertex_data_rep *get_rep (void) const { return rep; }
@@ -408,128 +408,128 @@ public:
 
 protected:
   void begin (GLenum type)
     {
       //printf("patch_tesselator::begin (%d)\n", type);
       first = true;
 
       if (color_mode == 2 || light_mode == 2)
-	glShadeModel (GL_SMOOTH);
+        glShadeModel (GL_SMOOTH);
       else
-	glShadeModel (GL_FLAT);
+        glShadeModel (GL_FLAT);
 
       if (is_filled ())
-	renderer->set_polygon_offset (true, 1+index);
+        renderer->set_polygon_offset (true, 1+index);
 
       glBegin (type);
     }
 
   void end (void)
     {
       //printf("patch_tesselator::end\n");
       glEnd ();
       renderer->set_polygon_offset (false);
     }
 
   void vertex (void *data)
     {
       vertex_data::vertex_data_rep *v
-	  = reinterpret_cast<vertex_data::vertex_data_rep *> (data);
+          = reinterpret_cast<vertex_data::vertex_data_rep *> (data);
       //printf("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
 
       // FIXME: why did I need to keep the first vertex of the face
       // in JHandles? I think it's related to the fact that the 
       // tessellation process might re-order the vertices, such that
       // the first one you get here might not be the first one of the face;
       // but I can't figure out the actual reason.
       if (color_mode > 0 && (first || color_mode == 2))
-	{
-	  Matrix col = v->color;
-
-	  if (col.numel () == 3)
-	    {
-	      glColor3dv (col.data ());
-	      if (light_mode > 0)
-		{
-		  float buf[4] = { 0, 0, 0, 1 };
-
-		  for (int k = 0; k < 3; k++)
-		    buf[k] = (v->ambient * col(k));
-		  glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
-
-		  for (int k = 0; k < 3; k++)
-		    buf[k] = (v->diffuse * col(k));
-		  glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
-		}
-	    }
-	}
+        {
+          Matrix col = v->color;
+
+          if (col.numel () == 3)
+            {
+              glColor3dv (col.data ());
+              if (light_mode > 0)
+                {
+                  float buf[4] = { 0, 0, 0, 1 };
+
+                  for (int k = 0; k < 3; k++)
+                    buf[k] = (v->ambient * col(k));
+                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
+
+                  for (int k = 0; k < 3; k++)
+                    buf[k] = (v->diffuse * col(k));
+                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
+                }
+            }
+        }
 
       if (light_mode > 0 && (first || light_mode == 2))
-	glNormal3dv (v->normal.data ());
+        glNormal3dv (v->normal.data ());
 
       glVertex3dv (v->coords.data ());
 
       first = false;
     }
 
   void combine (GLdouble xyz[3], void *data[4], GLfloat w[4],
-		void **out_data)
+                void **out_data)
     {
       //printf("patch_tesselator::combine\n");
 
       vertex_data::vertex_data_rep *v[4];
       int vmax = 4;
 
       for (int i = 0; i < 4; i++)
-	{
-	  v[i] = reinterpret_cast<vertex_data::vertex_data_rep *> (data[i]);
-
-	  if (vmax == 4 && ! v[i])
-	    vmax = i;
-	}
+        {
+          v[i] = reinterpret_cast<vertex_data::vertex_data_rep *> (data[i]);
+
+          if (vmax == 4 && ! v[i])
+            vmax = i;
+        }
 
       Matrix vv (1, 3, 0.0);
       Matrix cc;
       Matrix nn (1, 3, 0.0);
       double aa = 0.0;
 
       vv(0) = xyz[0];
       vv(1) = xyz[1];
       vv(2) = xyz[2];
 
       if (v[0]->color.numel ())
-	{
-	  cc.resize (1, 3, 0.0);
-	  for (int ic = 0; ic < 3; ic++)
-	    for (int iv = 0; iv < vmax; iv++)
-	      cc(ic) += (w[iv] * v[iv]->color(ic));
-	}
+        {
+          cc.resize (1, 3, 0.0);
+          for (int ic = 0; ic < 3; ic++)
+            for (int iv = 0; iv < vmax; iv++)
+              cc(ic) += (w[iv] * v[iv]->color(ic));
+        }
 
       if (v[0]->normal.numel () > 0)
-	{
-	  for (int in = 0; in < 3; in++)
-	    for (int iv = 0; iv < vmax; iv++)
-	      nn(in) += (w[iv] * v[iv]->normal(in));
-	}
+        {
+          for (int in = 0; in < 3; in++)
+            for (int iv = 0; iv < vmax; iv++)
+              nn(in) += (w[iv] * v[iv]->normal(in));
+        }
 
       for (int iv = 0; iv < vmax; iv++)
-	aa += (w[iv] * v[iv]->alpha);
+        aa += (w[iv] * v[iv]->alpha);
 
       vertex_data new_v (vv, cc, nn, aa, v[0]->ambient, v[0]->diffuse,
-			 v[0]->specular, v[0]->specular_exp);
+                         v[0]->specular, v[0]->specular_exp);
       tmp_vdata.push_back (new_v);
 
       *out_data = new_v.get_rep ();
     }
 
 private:
   opengl_renderer *renderer;
-  int color_mode;	// 0: uni,  1: flat, 2: interp
-  int light_mode;	// 0: none, 1: flat, 2: gouraud
+  int color_mode;       // 0: uni,  1: flat, 2: interp
+  int light_mode;       // 0: none, 1: flat, 2: gouraud
   int index;
   bool first;
   std::list<vertex_data> tmp_vdata;
 };
 
 void
 opengl_renderer::draw (const graphics_object& go)
 {
@@ -551,17 +551,17 @@ opengl_renderer::draw (const graphics_ob
   else if (go.isa ("hggroup"))
     draw_hggroup (dynamic_cast<const hggroup::properties&> (props));
   else if (go.isa ("text"))
     draw_text (dynamic_cast<const text::properties&> (props));
   else if (go.isa ("image"))
     draw_image (dynamic_cast<const image::properties&> (props));
   else
     warning ("opengl_renderer: cannot render object of type `%s'",
-	     props.graphics_object_name ().c_str ());
+             props.graphics_object_name ().c_str ());
 }
 
 void
 opengl_renderer::draw_figure (const figure::properties& props)
 {
   backend = props.get_backend ();
 
   // Initialize OpenGL context
@@ -743,18 +743,18 @@ opengl_renderer::draw_axes (const axes::
     //autoMode--;
   }
 
   // FIXME: use ticklength property
   double xticklen = 7, yticklen = 7, zticklen = 7;
 
   //double tickdir = (props.tickdir_is ("in") ? -1 : 1);
   double tickdir = (props.tickdirmode_is ("auto") ?
-		    (mode2d ? -1 : 1) :
-		    (props.tickdir_is ("in") ? -1 : 1));
+                    (mode2d ? -1 : 1) :
+                    (props.tickdir_is ("in") ? -1 : 1));
   double xtickoffset = (mode2d && tickdir < 0 ? 0 : xticklen) + 5;
   double ytickoffset = (mode2d && tickdir < 0 ? 0 : yticklen) + 5;
   double ztickoffset = (mode2d && tickdir < 0 ? 0 : zticklen) + 5;
 
   bool xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   bool x2Dtop = false;
   bool y2Dright = false;
   double zpTick = zPlane;
@@ -970,35 +970,35 @@ opengl_renderer::draw_axes (const axes::
               tickpos(i,1) = yPlaneN+signum(yPlaneN-yPlane)*fy*xtickoffset;
               tickpos(i,2) = zPlane;
             }
           glEnd ();
         }
 
       // tick texts
       if (xticklabels.numel () > 0)
-	{
-	  int n = std::min (xticklabels.numel (), xticks.numel ());
-	  int halign = (xstate == AXE_HORZ_DIR ? 1 : (xySym ? 0 : 2));
-	  int valign = (xstate == AXE_VERT_DIR
-			? 1
-		       : (zd*zv(2) <= 0 && !x2Dtop ? 2 : 0));
-
-	  for (int i = 0; i < n; i++)
-	    {
-	      // FIXME: as tick text is transparent, shouldn't be
-	      //        drawn after axes object, for correct rendering?
-	      Matrix b = render_text (xticklabels(i),
-				    tickpos(i,0), tickpos(i,1), tickpos(i,2),
-				    halign, valign); 
-
-	      wmax = std::max (wmax, static_cast<int> (b(2)));
-	      hmax = std::max (hmax, static_cast<int> (b(3)));
-	    }
-	}
+        {
+          int n = std::min (xticklabels.numel (), xticks.numel ());
+          int halign = (xstate == AXE_HORZ_DIR ? 1 : (xySym ? 0 : 2));
+          int valign = (xstate == AXE_VERT_DIR
+                        ? 1
+                       : (zd*zv(2) <= 0 && !x2Dtop ? 2 : 0));
+
+          for (int i = 0; i < n; i++)
+            {
+              // FIXME: as tick text is transparent, shouldn't be
+              //        drawn after axes object, for correct rendering?
+              Matrix b = render_text (xticklabels(i),
+                                    tickpos(i,0), tickpos(i,1), tickpos(i,2),
+                                    halign, valign); 
+
+              wmax = std::max (wmax, static_cast<int> (b(2)));
+              hmax = std::max (hmax, static_cast<int> (b(3)));
+            }
+        }
 
       // minor grid lines
       if (do_xminorgrid)
         {
           set_linestyle (minorgridstyle, true);
           glBegin (GL_LINES);
           for (int i = 0; i < xmticks.numel (); i++)
             {
@@ -1010,17 +1010,17 @@ opengl_renderer::draw_axes (const axes::
                 {
                   glVertex3d (xval, yPlane, zPlaneN);
                   glVertex3d (xval, yPlane, zPlane);
                 }
             }
           glEnd ();
           set_linestyle ("-", true);
         }
-			
+                        
       // minor tick marks
       if (do_xminortick)
         {
           if (tick_along_z)
             {
               glBegin (GL_LINES);
               for (int i = 0; i < xmticks.numel (); i++)
                 {
@@ -1064,17 +1064,17 @@ opengl_renderer::draw_axes (const axes::
 
       xlabel_props.set_visible ("on");
 
       // FIXME: auto-positioning should be disabled if the 
       //        label has been positioned manually
       if (! xlabel_props.get_string ().empty ())
         {
           xlabel_props.set_horizontalalignment (xstate > AXE_DEPTH_DIR ? "center" : (xySym ? "left" : "right"));
-	  xlabel_props.set_verticalalignment (xstate == AXE_VERT_DIR ? "bottom" : (zd*zv(2) <= 0 ? "top" : "bottom"));
+          xlabel_props.set_verticalalignment (xstate == AXE_VERT_DIR ? "bottom" : (zd*zv(2) <= 0 ? "top" : "bottom"));
 
           double angle = 0;
           ColumnVector p = graphics_xform::xform_vector ((x_min+x_max)/2, yPlaneN, zPlane);
 
           if (tick_along_z)
             p(2) += (signum(zPlane-zPlaneN)*fz*xtickoffset);
           else
             p(1) += (signum(yPlaneN-yPlane)*fy*xtickoffset);
@@ -1099,17 +1099,17 @@ opengl_renderer::draw_axes (const axes::
         }
     }
   else
     {
       gh_manager::get_object (props.get_xlabel ()).set ("visible", "off");
     }
 
   // Y grid
-		
+                
   if (ystate != AXE_DEPTH_DIR && visible)
     {
       bool do_ygrid = (props.is_ygrid () && (gridstyle != "none"));
       bool do_yminorgrid = (props.is_yminorgrid () && (minorgridstyle != "none"));
       bool do_yminortick = props.is_yminortick ();
       Matrix yticks = xform.yscale (props.get_ytick ().matrix_value ());
       // FIXME: use pre-computed minor ticks
       Matrix ymticks;
@@ -1182,33 +1182,33 @@ opengl_renderer::draw_axes (const axes::
               tickpos(i,1) = yval;
               tickpos(i,2) = zPlane;
             }
           glEnd ();
         }
 
       // tick texts
       if (yticklabels.numel () > 0)
-	{
-	  int n = std::min (yticklabels.numel (), yticks.numel ());
-	  int halign = (ystate == AXE_HORZ_DIR ? 1 : (!xySym || y2Dright ? 0 : 2));
-	  int valign = (ystate == AXE_VERT_DIR ? 1 : (zd*zv(2) <= 0 ? 2 : 0));
-
-	  for (int i = 0; i < n; i++)
-	    {
-	      // FIXME: as tick text is transparent, shouldn't be
-	      //        drawn after axes object, for correct rendering?
-	      Matrix b = render_text (yticklabels(i),
-				    tickpos(i,0), tickpos(i,1), tickpos(i,2),
-				    halign, valign); 
-
-	      wmax = std::max (wmax, static_cast<int> (b(2)));
-	      hmax = std::max (hmax, static_cast<int> (b(3)));
-	    }
-	}
+        {
+          int n = std::min (yticklabels.numel (), yticks.numel ());
+          int halign = (ystate == AXE_HORZ_DIR ? 1 : (!xySym || y2Dright ? 0 : 2));
+          int valign = (ystate == AXE_VERT_DIR ? 1 : (zd*zv(2) <= 0 ? 2 : 0));
+
+          for (int i = 0; i < n; i++)
+            {
+              // FIXME: as tick text is transparent, shouldn't be
+              //        drawn after axes object, for correct rendering?
+              Matrix b = render_text (yticklabels(i),
+                                    tickpos(i,0), tickpos(i,1), tickpos(i,2),
+                                    halign, valign); 
+
+              wmax = std::max (wmax, static_cast<int> (b(2)));
+              hmax = std::max (hmax, static_cast<int> (b(3)));
+            }
+        }
 
       // minor grid lines
       if (do_yminorgrid)
         {
           set_linestyle (minorgridstyle, true);
           glBegin (GL_LINES);
           for (int i = 0; i < ymticks.numel (); i++)
             {
@@ -1274,17 +1274,17 @@ opengl_renderer::draw_axes (const axes::
 
       ylabel_props.set_visible ("on");
 
       // FIXME: auto-positioning should be disabled if the 
       //        label has been positioned manually
       if (! ylabel_props.get_string ().empty ())
         {
           ylabel_props.set_horizontalalignment (ystate > AXE_DEPTH_DIR ? "center" : (!xySym ? "left" : "right"));
-	  ylabel_props.set_verticalalignment (ystate == AXE_VERT_DIR ? "bottom" : (zd*zv(2) <= 0 ? "top" : "bottom"));
+          ylabel_props.set_verticalalignment (ystate == AXE_VERT_DIR ? "bottom" : (zd*zv(2) <= 0 ? "top" : "bottom"));
 
           double angle = 0;
           ColumnVector p = graphics_xform::xform_vector (xPlaneN, (y_min+y_max)/2, zPlane);
 
           if (tick_along_z)
             p(2) += (signum(zPlane-zPlaneN)*fz*ytickoffset);
           else
             p(0) += (signum(xPlaneN-xPlane)*fx*ytickoffset);
@@ -1307,17 +1307,17 @@ opengl_renderer::draw_axes (const axes::
           ylabel_props.set_position (p.extract_n (0, 3).transpose ());
           ylabel_props.set_rotation (angle);
         }
     }
   else
     {
       gh_manager::get_object (props.get_ylabel ()).set ("visible", "off");
     }
-		
+                
   // Z Grid
 
   if (zstate != AXE_DEPTH_DIR && visible)
     {
       bool do_zgrid = (props.is_zgrid () && (gridstyle != "none"));
       bool do_zminorgrid = (props.is_zminorgrid () && (minorgridstyle != "none"));
       bool do_zminortick = props.is_zminortick ();
       Matrix zticks = xform.zscale (props.get_ztick ().matrix_value ());
@@ -1424,33 +1424,33 @@ opengl_renderer::draw_axes (const axes::
                 tickpos(i,2) = zval;
               }
             glEnd ();
           }
         }
 
       // FIXME: tick texts
       if (zticklabels.numel () > 0)
-	{
-	  int n = std::min (zticklabels.numel (), zticks.numel ());
-	  int halign = 2;
-	  int valign = (zstate == AXE_VERT_DIR ? 1 : (zd*zv(2) < 0 ? 3 : 2));
-
-	  for (int i = 0; i < n; i++)
-	    {
-	      // FIXME: as tick text is transparent, shouldn't be
-	      //        drawn after axes object, for correct rendering?
-	      Matrix b = render_text (zticklabels(i),
-				    tickpos(i,0), tickpos(i,1), tickpos(i,2),
-				    halign, valign); 
-
-	      wmax = std::max (wmax, static_cast<int> (b(2)));
-	      hmax = std::max (hmax, static_cast<int> (b(3)));
-	    }
-	}
+        {
+          int n = std::min (zticklabels.numel (), zticks.numel ());
+          int halign = 2;
+          int valign = (zstate == AXE_VERT_DIR ? 1 : (zd*zv(2) < 0 ? 3 : 2));
+
+          for (int i = 0; i < n; i++)
+            {
+              // FIXME: as tick text is transparent, shouldn't be
+              //        drawn after axes object, for correct rendering?
+              Matrix b = render_text (zticklabels(i),
+                                    tickpos(i,0), tickpos(i,1), tickpos(i,2),
+                                    halign, valign); 
+
+              wmax = std::max (wmax, static_cast<int> (b(2)));
+              hmax = std::max (hmax, static_cast<int> (b(3)));
+            }
+        }
 
       // minor grid lines
       if (do_zminorgrid)
         {
           set_linestyle (minorgridstyle, true);
           glBegin (GL_LINES);
           for (int i = 0; i < zmticks.numel (); i++)
             {
@@ -1543,17 +1543,17 @@ opengl_renderer::draw_axes (const axes::
 
       // FIXME: auto-positioning should be disabled if the 
       //        label has been positioned manually
       if (! zlabel_props.get_string ().empty ())
         {
           bool camAuto = props.cameraupvectormode_is ("auto");
 
           zlabel_props.set_horizontalalignment ((zstate > AXE_DEPTH_DIR || camAuto) ? "center" : "right");
-	  zlabel_props.set_verticalalignment(zstate == AXE_VERT_DIR ? "bottom" : ((zd*zv(2) < 0 || camAuto) ? "bottom" : "top"));
+          zlabel_props.set_verticalalignment(zstate == AXE_VERT_DIR ? "bottom" : ((zd*zv(2) < 0 || camAuto) ? "bottom" : "top"));
 
           double angle = 0;
           ColumnVector p;
 
           if (xySym)
             {
               p = graphics_xform::xform_vector (xPlaneN, yPlane, (z_min+z_max)/2);
               if (xisinf (fy))
@@ -1633,17 +1633,17 @@ opengl_renderer::draw_axes (const axes::
 
   for (int i = 0; i < children.numel (); i++)
     {
       graphics_object go = gh_manager::get_object (children (i));
 
       if (go.get_properties ().is_visible ())
         {
           if (go.isa ("light"))
-	    draw (go);
+            draw (go);
           else
             obj_list.push_back (go);
         }
     }
 
   // 2nd pass: draw other objects (with units set to "data")
 
   it = obj_list.begin ();
@@ -1653,19 +1653,19 @@ opengl_renderer::draw_axes (const axes::
 
       // FIXME: check whether object has "units" property and it is set to "data"
       if (! go.isa ("text") || go.get ("units").string_value () == "data")
         {
           set_clipping (go.get_properties ().is_clipping ());
           draw (go);
 
           it = obj_list.erase (it);
-	}
+        }
       else
-	it++;
+        it++;
     }
 
   // 3rd pass: draw remaining objects
 
   for (it = obj_list.begin (); it != obj_list.end (); it++)
     {
       graphics_object go = (*it);
 
@@ -1694,102 +1694,102 @@ opengl_renderer::draw_line (const line::
   if (has_z)
     for (int i = 0; i < n; i++)
       clip[i] = (clip_code (x(i), y(i), z(i)) & clip_mask);
   else
     {
       double z_mid = (zmin+zmax)/2;
 
       for (int i = 0; i < n; i++)
-	clip[i] = (clip_code (x(i), y(i), z_mid) & clip_mask);
+        clip[i] = (clip_code (x(i), y(i), z_mid) & clip_mask);
     }
 
   if (! props.linestyle_is ("none"))
     {
       set_color (props.get_color_rgb ());
       set_linestyle (props.get_linestyle (), false);
       set_linewidth (props.get_linewidth ());
 
       if (has_z)
-	{
-	  bool flag = false;
-
-	  for (int i = 1; i < n; i++)
-	    {
-	      if ((clip[i-1] & clip[i]) == clip_ok)
-		{
-		  if (! flag)
-		    {
-		      flag = true;
-		      glBegin (GL_LINE_STRIP);
-		      glVertex3d (x(i-1), y(i-1), z(i-1));
-		    }
-		  glVertex3d (x(i), y(i), z(i));
-		}
-	      else if (flag)
-		{
-		  flag = false;
-		  glEnd ();
-		}
-	    }
-
-	  if (flag)
-	    glEnd ();
-	}
+        {
+          bool flag = false;
+
+          for (int i = 1; i < n; i++)
+            {
+              if ((clip[i-1] & clip[i]) == clip_ok)
+                {
+                  if (! flag)
+                    {
+                      flag = true;
+                      glBegin (GL_LINE_STRIP);
+                      glVertex3d (x(i-1), y(i-1), z(i-1));
+                    }
+                  glVertex3d (x(i), y(i), z(i));
+                }
+              else if (flag)
+                {
+                  flag = false;
+                  glEnd ();
+                }
+            }
+
+          if (flag)
+            glEnd ();
+        }
       else
-	{
-	  bool flag = false;
-
-	  for (int i = 1; i < n; i++)
-	    {
-	      if ((clip[i-1] & clip[i]) == clip_ok)
-		{
-		  if (! flag)
-		    {
-		      flag = true;
-		      glBegin (GL_LINE_STRIP);
-		      glVertex2d (x(i-1), y(i-1));
-		    }
-		  glVertex2d (x(i), y(i));
-		}
-	      else if (flag)
-		{
-		  flag = false;
-		  glEnd ();
-		}
-	    }
-
-	  if (flag)
-	    glEnd ();
-	}
-	  
+        {
+          bool flag = false;
+
+          for (int i = 1; i < n; i++)
+            {
+              if ((clip[i-1] & clip[i]) == clip_ok)
+                {
+                  if (! flag)
+                    {
+                      flag = true;
+                      glBegin (GL_LINE_STRIP);
+                      glVertex2d (x(i-1), y(i-1));
+                    }
+                  glVertex2d (x(i), y(i));
+                }
+              else if (flag)
+                {
+                  flag = false;
+                  glEnd ();
+                }
+            }
+
+          if (flag)
+            glEnd ();
+        }
+          
       set_linewidth (0.5);
       set_linestyle ("-");
     }
 
   set_clipping (false);
 
   if (! props.marker_is ("none") &&
       ! (props.markeredgecolor_is ("none")
-	 && props.markerfacecolor_is ("none")))
+         && props.markerfacecolor_is ("none")))
     {
       Matrix lc, fc;
 
       if (props.markeredgecolor_is ("auto"))
-	lc = props.get_color_rgb ();
+        lc = props.get_color_rgb ();
       else if (! props.markeredgecolor_is ("none"))
-	lc = props.get_markeredgecolor_rgb ();
+        lc = props.get_markeredgecolor_rgb ();
 
       if (props.markerfacecolor_is ("auto"))
-	fc = props.get_color_rgb ();
+        fc = props.get_color_rgb ();
       else if (! props.markerfacecolor_is ("none"))
-	fc = props.get_markerfacecolor_rgb ();
+        fc = props.get_markerfacecolor_rgb ();
 
       init_marker (props.get_marker (), props.get_markersize (),
-		   props.get_linewidth ());
+                   props.get_linewidth ());
 
       for (int i = 0; i < n; i++)
         {
           if (clip[i] == clip_ok)
             draw_marker (x(i), y(i), (has_z ? z(i) : 0), lc, fc);
         }
 
       end_marker ();
@@ -1812,30 +1812,30 @@ opengl_renderer::draw_surface (const sur
 
   // FIXME: handle transparency
   Matrix a;
 
   if (props.facelighting_is ("phong") || props.edgelighting_is ("phong"))
     warning ("opengl_renderer::draw: phong light model not supported");
 
   int fc_mode = (props.facecolor_is_rgb () ? 0 :
-		 (props.facecolor_is ("flat") ? 1 :
-		  (props.facecolor_is ("interp") ? 2 :
-		   (props.facecolor_is ("texturemap") ? 3 : -1))));
+                 (props.facecolor_is ("flat") ? 1 :
+                  (props.facecolor_is ("interp") ? 2 :
+                   (props.facecolor_is ("texturemap") ? 3 : -1))));
   int fl_mode = (props.facelighting_is ("none") ? 0 :
-		 (props.facelighting_is ("flat") ? 1 : 2));
+                 (props.facelighting_is ("flat") ? 1 : 2));
   int fa_mode = (props.facealpha_is_double () ? 0 :
-		 (props.facealpha_is ("flat") ? 1 : 2));
+                 (props.facealpha_is ("flat") ? 1 : 2));
   int ec_mode = (props.edgecolor_is_rgb () ? 0 :
-		 (props.edgecolor_is ("flat") ? 1 :
-		  (props.edgecolor_is ("interp") ? 2 : -1)));
+                 (props.edgecolor_is ("flat") ? 1 :
+                  (props.edgecolor_is ("interp") ? 2 : -1)));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
-		 (props.edgelighting_is ("flat") ? 1 : 2));
+                 (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
-		 (props.edgealpha_is ("flat") ? 1 : 2));
+                 (props.edgealpha_is ("flat") ? 1 : 2));
 
   Matrix fcolor = (fc_mode == 3 ? Matrix (1, 3, 1.0) : props.get_facecolor_rgb ());
   Matrix ecolor = props.get_edgecolor_rgb ();
 
   float as = props.get_ambientstrength ();
   float ds = props.get_diffusestrength ();
   float ss = props.get_specularstrength ();
   float se = props.get_specularexponent ();
@@ -1850,25 +1850,25 @@ opengl_renderer::draw_surface (const sur
 
   i1 = i2 = j1 = j2 = 0;
 
   boolMatrix clip (z.dims (), false);
 
   for (int i = 0; i < zr; i++)
     {
       if (x_mat)
-	i1 = i;
+        i1 = i;
 
       for (int j = 0; j < zc; j++)
-	{
-	  if (y_mat)
-	    j1 = j;
-
-	  clip(i,j) = is_nan_or_inf (x(i1,j), y(i,j1), z(i,j));
-	}
+        {
+          if (y_mat)
+            j1 = j;
+
+          clip(i,j) = is_nan_or_inf (x(i1,j), y(i,j1), z(i,j));
+        }
     }
 
   if ((fc_mode > 0 && fc_mode < 3) || ec_mode > 0)
     c = props.get_color_data ().array_value ();
 
   if (fa_mode > 0 || ea_mode > 0)
     {
       // FIXME: implement alphadata conversion
@@ -1886,463 +1886,463 @@ opengl_renderer::draw_surface (const sur
   // FIXME: good candidate for caching, transfering pixel
   // data to OpenGL is time consuming.
   if (fc_mode == 3)
     tex = opengl_texture::create (props.get_color_data ());
 
   if (! props.facecolor_is ("none"))
     {
       if (props.get_facealpha_double () == 1)
-	{
-	  if (fc_mode == 0 || fc_mode == 3)
-	    {
-	      glColor3dv (fcolor.data ());
-	      if (fl_mode > 0)
-		{
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = as * fcolor(i);
-		  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = ds * fcolor(i);
-		  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-		}
-	    }
-
-	  if (fl_mode > 0)
-	    glEnable (GL_LIGHTING);
-	  glShadeModel ((fc_mode == 2 || fl_mode == 2) ? GL_SMOOTH : GL_FLAT);
-	  set_polygon_offset (true, 1);
-	  if (fc_mode == 3)
-	    glEnable (GL_TEXTURE_2D);
-
-	  for (int i = 1; i < zc; i++)
-	    {
-	      if (y_mat)
-		{
-		  i1 = i-1;
-		  i2 = i;
-		}
-
-	      for (int j = 1; j < zr; j++)
-		{
-		  if (clip(j-1, i-1) || clip (j, i-1)
-		      || clip (j-1, i) || clip (j, i))
-		    continue;
-
-		  if (x_mat)
-		    {
-		      j1 = j-1;
-		      j2 = j;
-		    }
-
-		  glBegin (GL_QUADS);
-
-		  // Vertex 1
-		  if (fc_mode == 3)
-		    tex.tex_coord (double (i-1) / (zc-1), double (j-1) / (zr-1));
-		  else if (fc_mode > 0)
-		    {
-		      // FIXME: is there a smarter way to do this?
-		      for (int k = 0; k < 3; k++)
-			cb[k] = c(j-1, i-1, k);
-		      glColor3fv (cb);
-
-		      if (fl_mode > 0)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] *= as;
-			  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-			  
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = ds * c(j-1, i-1, k);
-			  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			}
-		    }
+        {
+          if (fc_mode == 0 || fc_mode == 3)
+            {
+              glColor3dv (fcolor.data ());
+              if (fl_mode > 0)
+                {
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = as * fcolor(i);
+                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ds * fcolor(i);
+                  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                }
+            }
+
+          if (fl_mode > 0)
+            glEnable (GL_LIGHTING);
+          glShadeModel ((fc_mode == 2 || fl_mode == 2) ? GL_SMOOTH : GL_FLAT);
+          set_polygon_offset (true, 1);
+          if (fc_mode == 3)
+            glEnable (GL_TEXTURE_2D);
+
+          for (int i = 1; i < zc; i++)
+            {
+              if (y_mat)
+                {
+                  i1 = i-1;
+                  i2 = i;
+                }
+
+              for (int j = 1; j < zr; j++)
+                {
+                  if (clip(j-1, i-1) || clip (j, i-1)
+                      || clip (j-1, i) || clip (j, i))
+                    continue;
+
+                  if (x_mat)
+                    {
+                      j1 = j-1;
+                      j2 = j;
+                    }
+
+                  glBegin (GL_QUADS);
+
+                  // Vertex 1
+                  if (fc_mode == 3)
+                    tex.tex_coord (double (i-1) / (zc-1), double (j-1) / (zr-1));
+                  else if (fc_mode > 0)
+                    {
+                      // FIXME: is there a smarter way to do this?
+                      for (int k = 0; k < 3; k++)
+                        cb[k] = c(j-1, i-1, k);
+                      glColor3fv (cb);
+
+                      if (fl_mode > 0)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] *= as;
+                          glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+                          
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ds * c(j-1, i-1, k);
+                          glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                        }
+                    }
                   if (fl_mode > 0)
-		    {
-		      d = sqrt (n(j-1,i-1,0) * n(j-1,i-1,0)
-				+ n(j-1,i-1,1) * n(j-1,i-1,1)
-				+ n(j-1,i-1,2) * n(j-1,i-1,2));
-		      glNormal3d (n(j-1,i-1,0)/d, n(j-1,i-1,1)/d, n(j-1,i-1,2)/d);
-		    }
-		  glVertex3d (x(j1,i-1), y(j-1,i1), z(j-1,i-1));
-
-		  // Vertex 2
-		  if (fc_mode == 3)
-		    tex.tex_coord (double (i) / (zc-1), double (j-1) / (zr-1));
-		  else if (fc_mode == 2)
-		    {
-		      for (int k = 0; k < 3; k++)
-			cb[k] = c(j-1, i, k);
-		      glColor3fv (cb);
-
-		      if (fl_mode > 0)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] *= as;
-			  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-			  
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = ds * c(j-1, i, k);
-			  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			}
-		    }
+                    {
+                      d = sqrt (n(j-1,i-1,0) * n(j-1,i-1,0)
+                                + n(j-1,i-1,1) * n(j-1,i-1,1)
+                                + n(j-1,i-1,2) * n(j-1,i-1,2));
+                      glNormal3d (n(j-1,i-1,0)/d, n(j-1,i-1,1)/d, n(j-1,i-1,2)/d);
+                    }
+                  glVertex3d (x(j1,i-1), y(j-1,i1), z(j-1,i-1));
+
+                  // Vertex 2
+                  if (fc_mode == 3)
+                    tex.tex_coord (double (i) / (zc-1), double (j-1) / (zr-1));
+                  else if (fc_mode == 2)
+                    {
+                      for (int k = 0; k < 3; k++)
+                        cb[k] = c(j-1, i, k);
+                      glColor3fv (cb);
+
+                      if (fl_mode > 0)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] *= as;
+                          glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+                          
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ds * c(j-1, i, k);
+                          glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                        }
+                    }
 
                   if (fl_mode == 2)
-		    {
-		      d = sqrt (n(j-1,i,0) * n(j-1,i,0)
-				+ n(j-1,i,1) * n(j-1,i,1)
-				+ n(j-1,i,2) * n(j-1,i,2));
-		      glNormal3d (n(j-1,i,0)/d, n(j-1,i,1)/d, n(j-1,i,2)/d);
-		    }
-
-		  glVertex3d (x(j1,i), y(j-1,i2), z(j-1,i));
-		  
-		  // Vertex 3
-		  if (fc_mode == 3)
-		    tex.tex_coord (double (i) / (zc-1), double (j) / (zr-1));
-		  else if (fc_mode == 2)
-		    {
-		      for (int k = 0; k < 3; k++)
-			cb[k] = c(j, i, k);
-		      glColor3fv (cb);
-
-		      if (fl_mode > 0)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] *= as;
-			  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-			  
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = ds * c(j, i, k);
-			  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			}
-		    }
-		  if (fl_mode == 2)
-		    {
-		      d = sqrt (n(j,i,0) * n(j,i,0)
-				+ n(j,i,1) * n(j,i,1)
-				+ n(j,i,2) * n(j,i,2));
-		      glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
-		    }
-		  glVertex3d (x(j2,i), y(j,i2), z(j,i));
-
-		  // Vertex 4
-		  if (fc_mode == 3)
-		    tex.tex_coord (double (i-1) / (zc-1), double (j) / (zr-1));
-		  else if (fc_mode == 2)
-		    {
-		      for (int k = 0; k < 3; k++)
-			cb[k] = c(j, i-1, k);
-		      glColor3fv (cb);
-
-		      if (fl_mode > 0)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] *= as;
-			  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-			  
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = ds * c(j, i-1, k);
-			  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			}
-		    }
+                    {
+                      d = sqrt (n(j-1,i,0) * n(j-1,i,0)
+                                + n(j-1,i,1) * n(j-1,i,1)
+                                + n(j-1,i,2) * n(j-1,i,2));
+                      glNormal3d (n(j-1,i,0)/d, n(j-1,i,1)/d, n(j-1,i,2)/d);
+                    }
+
+                  glVertex3d (x(j1,i), y(j-1,i2), z(j-1,i));
+                  
+                  // Vertex 3
+                  if (fc_mode == 3)
+                    tex.tex_coord (double (i) / (zc-1), double (j) / (zr-1));
+                  else if (fc_mode == 2)
+                    {
+                      for (int k = 0; k < 3; k++)
+                        cb[k] = c(j, i, k);
+                      glColor3fv (cb);
+
+                      if (fl_mode > 0)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] *= as;
+                          glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+                          
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ds * c(j, i, k);
+                          glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                        }
+                    }
                   if (fl_mode == 2)
-		    {
-		      d = sqrt (n(j,i-1,0) * n(j,i-1,0)
-				+ n(j,i-1,1) * n(j,i-1,1)
-				+ n(j,i-1,2) * n(j,i-1,2));
-		      glNormal3d (n(j,i-1,0)/d, n(j,i-1,1)/d, n(j,i-1,2)/d);
-		    }
-		  glVertex3d (x(j2,i-1), y(j,i1), z(j,i-1));
-
-		  glEnd ();
-		}
-	    }
-
-	  set_polygon_offset (false);
-	  if (fc_mode == 3)
-	    glDisable (GL_TEXTURE_2D);
-
-	  if (fl_mode > 0)
-	    glDisable (GL_LIGHTING);
-	}
+                    {
+                      d = sqrt (n(j,i,0) * n(j,i,0)
+                                + n(j,i,1) * n(j,i,1)
+                                + n(j,i,2) * n(j,i,2));
+                      glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
+                    }
+                  glVertex3d (x(j2,i), y(j,i2), z(j,i));
+
+                  // Vertex 4
+                  if (fc_mode == 3)
+                    tex.tex_coord (double (i-1) / (zc-1), double (j) / (zr-1));
+                  else if (fc_mode == 2)
+                    {
+                      for (int k = 0; k < 3; k++)
+                        cb[k] = c(j, i-1, k);
+                      glColor3fv (cb);
+
+                      if (fl_mode > 0)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] *= as;
+                          glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+                          
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = ds * c(j, i-1, k);
+                          glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                        }
+                    }
+                  if (fl_mode == 2)
+                    {
+                      d = sqrt (n(j,i-1,0) * n(j,i-1,0)
+                                + n(j,i-1,1) * n(j,i-1,1)
+                                + n(j,i-1,2) * n(j,i-1,2));
+                      glNormal3d (n(j,i-1,0)/d, n(j,i-1,1)/d, n(j,i-1,2)/d);
+                    }
+                  glVertex3d (x(j2,i-1), y(j,i1), z(j,i-1));
+
+                  glEnd ();
+                }
+            }
+
+          set_polygon_offset (false);
+          if (fc_mode == 3)
+            glDisable (GL_TEXTURE_2D);
+
+          if (fl_mode > 0)
+            glDisable (GL_LIGHTING);
+        }
       else
-	{
-	  // FIXME: implement transparency
-	}
+        {
+          // FIXME: implement transparency
+        }
     }
 
   if (! props.edgecolor_is ("none"))
     {
       if (props.get_edgealpha_double () == 1)
-	{
-	  if (ec_mode == 0)
-	    {
-	      glColor3dv (ecolor.data ());
-	      if (fl_mode > 0)
-		{
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = as * ecolor(i);
-		  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = ds * ecolor(i);
-		  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-		}
-	    }
-
-	  if (el_mode > 0)
-	    glEnable (GL_LIGHTING);
-	  glShadeModel ((ec_mode == 2 || el_mode == 2) ? GL_SMOOTH : GL_FLAT);
-
-	  set_linestyle (props.get_linestyle (), false);
-	  set_linewidth (props.get_linewidth ());
-
-	  // Mesh along Y-axis
-
-	  if (props.meshstyle_is ("both") || props.meshstyle_is ("column"))
-	    {
-	      for (int i = 0; i < zc; i++)
-		{
-		  if (y_mat)
-		    {
-		      i1 = i-1;
-		      i2 = i;
-		    }
-
-		  for (int j = 1; j < zr; j++)
-		    {
-		      if (clip(j-1,i) || clip(j,i))
-			continue;
-
-		      if (x_mat)
-			{
-			  j1 = j-1;
-			  j2 = j;
-			}
-
-		      glBegin (GL_LINES);
-
-		      // Vertex 1
-		      if (ec_mode > 0)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = c(j-1, i, k);
-			  glColor3fv (cb);
-
-			  if (fl_mode > 0)
-			    {
-			      for (int k = 0; k < 3; k++)
-				cb[k] *= as;
-			      glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-			      for (int k = 0; k < 3; k++)
-				cb[k] = ds * c(j-1, i, k);
-			      glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			    }
-			}
-		      if (el_mode > 0)
-			{
-			  d = sqrt (n(j-1,i,0) * n(j-1,i,0)
-				    + n(j-1,i,1) * n(j-1,i,1)
-				    + n(j-1,i,2) * n(j-1,i,2));
-			  glNormal3d (n(j-1,i,0)/d, n(j-1,i,1)/d, n(j-1,i,2)/d);
-			}
-		      glVertex3d (x(j1,i), y(j-1,i2), z(j-1,i));
-
-		      // Vertex 2
-		      if (ec_mode == 2)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = c(j, i, k);
-			  glColor3fv (cb);
-
-			  if (fl_mode > 0)
-			    {
-			      for (int k = 0; k < 3; k++)
-				cb[k] *= as;
-			      glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-			      for (int k = 0; k < 3; k++)
-				cb[k] = ds * c(j, i, k);
-			      glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			    }
-			}
-		      if (el_mode == 2)
-		        {
-			  d = sqrt (n(j,i,0) * n(j,i,0)
-				    + n(j,i,1) * n(j,i,1)
-				    + n(j,i,2) * n(j,i,2));
-			  glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
-			}
-		      glVertex3d (x(j2,i), y(j,i2), z(j,i));
-
-		      glEnd ();
-		    }
-		}
-	    }
-
-	  // Mesh along X-axis
-
-	  if (props.meshstyle_is ("both") || props.meshstyle_is ("row"))
-	    {
-	      for (int j = 0; j < zr; j++)
-		{
-		  if (x_mat)
-		    {
-		      j1 = j-1;
-		      j2 = j;
-		    }
-
-		  for (int i = 1; i < zc; i++)
-		    {
-		      if (clip(j,i-1) || clip(j,i))
-			continue;
-
-		      if (y_mat)
-			{
-			  i1 = i-1;
-			  i2 = i;
-			}
-
-		      glBegin (GL_LINES);
-
-		      // Vertex 1
-		      if (ec_mode > 0)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = c(j, i-1, k);
-			  glColor3fv (cb);
-
-			  if (fl_mode > 0)
-			    {
-			      for (int k = 0; k < 3; k++)
-				cb[k] *= as;
-			      glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-			      for (int k = 0; k < 3; k++)
-				cb[k] = ds * c(j, i-1, k);
-			      glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			    }
-			}
-		      if (el_mode > 0)
+        {
+          if (ec_mode == 0)
+            {
+              glColor3dv (ecolor.data ());
+              if (fl_mode > 0)
+                {
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = as * ecolor(i);
+                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ds * ecolor(i);
+                  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                }
+            }
+
+          if (el_mode > 0)
+            glEnable (GL_LIGHTING);
+          glShadeModel ((ec_mode == 2 || el_mode == 2) ? GL_SMOOTH : GL_FLAT);
+
+          set_linestyle (props.get_linestyle (), false);
+          set_linewidth (props.get_linewidth ());
+
+          // Mesh along Y-axis
+
+          if (props.meshstyle_is ("both") || props.meshstyle_is ("column"))
+            {
+              for (int i = 0; i < zc; i++)
+                {
+                  if (y_mat)
+                    {
+                      i1 = i-1;
+                      i2 = i;
+                    }
+
+                  for (int j = 1; j < zr; j++)
+                    {
+                      if (clip(j-1,i) || clip(j,i))
+                        continue;
+
+                      if (x_mat)
+                        {
+                          j1 = j-1;
+                          j2 = j;
+                        }
+
+                      glBegin (GL_LINES);
+
+                      // Vertex 1
+                      if (ec_mode > 0)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = c(j-1, i, k);
+                          glColor3fv (cb);
+
+                          if (fl_mode > 0)
+                            {
+                              for (int k = 0; k < 3; k++)
+                                cb[k] *= as;
+                              glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ds * c(j-1, i, k);
+                              glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                            }
+                        }
+                      if (el_mode > 0)
+                        {
+                          d = sqrt (n(j-1,i,0) * n(j-1,i,0)
+                                    + n(j-1,i,1) * n(j-1,i,1)
+                                    + n(j-1,i,2) * n(j-1,i,2));
+                          glNormal3d (n(j-1,i,0)/d, n(j-1,i,1)/d, n(j-1,i,2)/d);
+                        }
+                      glVertex3d (x(j1,i), y(j-1,i2), z(j-1,i));
+
+                      // Vertex 2
+                      if (ec_mode == 2)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = c(j, i, k);
+                          glColor3fv (cb);
+
+                          if (fl_mode > 0)
+                            {
+                              for (int k = 0; k < 3; k++)
+                                cb[k] *= as;
+                              glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ds * c(j, i, k);
+                              glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                            }
+                        }
+                      if (el_mode == 2)
                         {
-			  d = sqrt (n(j,i-1,0) * n(j,i-1,0)
-				    + n(j,i-1,1) * n(j,i-1,1)
-				    + n(j,i-1,2) * n(j,i-1,2));
-			  glNormal3d (n(j,i-1,0)/d, n(j,i-1,1)/d, n(j,i-1,2)/d);
-			}
-		      glVertex3d (x(j2,i-1), y(j,i1), z(j,i-1));
-		      
-		      // Vertex 2
-		      if (ec_mode == 2)
-			{
-			  for (int k = 0; k < 3; k++)
-			    cb[k] = c(j, i, k);
-			  glColor3fv (cb);
-
-			  if (fl_mode > 0)
-			    {
-			      for (int k = 0; k < 3; k++)
-				cb[k] *= as;
-			      glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-			      for (int k = 0; k < 3; k++)
-				cb[k] = ds * c(j, i, k);
-			      glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-			    }
-			}
-		      if (el_mode == 2)
-		        {
-			  d = sqrt (n(j,i,0) * n(j,i,0)
-				    + n(j,i,1) * n(j,i,1)
-				    + n(j,i,2) * n(j,i,2));
-			  glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
-			}
-		      glVertex3d (x(j2,i), y(j,i2), z(j,i));
-		      
-		      glEnd ();
-		    }
-		}
-	    }
-
-	  set_linestyle ("-");
-	  set_linewidth (0.5);
-
-	  if (el_mode > 0)
-	    glDisable (GL_LIGHTING);
-	}
+                          d = sqrt (n(j,i,0) * n(j,i,0)
+                                    + n(j,i,1) * n(j,i,1)
+                                    + n(j,i,2) * n(j,i,2));
+                          glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
+                        }
+                      glVertex3d (x(j2,i), y(j,i2), z(j,i));
+
+                      glEnd ();
+                    }
+                }
+            }
+
+          // Mesh along X-axis
+
+          if (props.meshstyle_is ("both") || props.meshstyle_is ("row"))
+            {
+              for (int j = 0; j < zr; j++)
+                {
+                  if (x_mat)
+                    {
+                      j1 = j-1;
+                      j2 = j;
+                    }
+
+                  for (int i = 1; i < zc; i++)
+                    {
+                      if (clip(j,i-1) || clip(j,i))
+                        continue;
+
+                      if (y_mat)
+                        {
+                          i1 = i-1;
+                          i2 = i;
+                        }
+
+                      glBegin (GL_LINES);
+
+                      // Vertex 1
+                      if (ec_mode > 0)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = c(j, i-1, k);
+                          glColor3fv (cb);
+
+                          if (fl_mode > 0)
+                            {
+                              for (int k = 0; k < 3; k++)
+                                cb[k] *= as;
+                              glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ds * c(j, i-1, k);
+                              glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                            }
+                        }
+                      if (el_mode > 0)
+                        {
+                          d = sqrt (n(j,i-1,0) * n(j,i-1,0)
+                                    + n(j,i-1,1) * n(j,i-1,1)
+                                    + n(j,i-1,2) * n(j,i-1,2));
+                          glNormal3d (n(j,i-1,0)/d, n(j,i-1,1)/d, n(j,i-1,2)/d);
+                        }
+                      glVertex3d (x(j2,i-1), y(j,i1), z(j,i-1));
+                      
+                      // Vertex 2
+                      if (ec_mode == 2)
+                        {
+                          for (int k = 0; k < 3; k++)
+                            cb[k] = c(j, i, k);
+                          glColor3fv (cb);
+
+                          if (fl_mode > 0)
+                            {
+                              for (int k = 0; k < 3; k++)
+                                cb[k] *= as;
+                              glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                              for (int k = 0; k < 3; k++)
+                                cb[k] = ds * c(j, i, k);
+                              glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                            }
+                        }
+                      if (el_mode == 2)
+                        {
+                          d = sqrt (n(j,i,0) * n(j,i,0)
+                                    + n(j,i,1) * n(j,i,1)
+                                    + n(j,i,2) * n(j,i,2));
+                          glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
+                        }
+                      glVertex3d (x(j2,i), y(j,i2), z(j,i));
+                      
+                      glEnd ();
+                    }
+                }
+            }
+
+          set_linestyle ("-");
+          set_linewidth (0.5);
+
+          if (el_mode > 0)
+            glDisable (GL_LIGHTING);
+        }
       else
-	{
-	  // FIXME: implement transparency
-	}
+        {
+          // FIXME: implement transparency
+        }
     }
 
   if (! props.marker_is ("none") &&
       ! (props.markeredgecolor_is ("none")
-	 && props.markerfacecolor_is ("none")))
+         && props.markerfacecolor_is ("none")))
     {
       // FIXME: check how transparency should be handled in markers
       // FIXME: check what to do with marker facecolor set to auto
       //        and facecolor set to none.
 
       bool do_edge = ! props.markeredgecolor_is ("none");
       bool do_face = ! props.markerfacecolor_is ("none");
 
       Matrix mecolor = props.get_markeredgecolor_rgb ();
       Matrix mfcolor = props.get_markerfacecolor_rgb ();
       Matrix cc (1, 3, 0.0);
 
       if (mecolor.numel () == 0 && props.markeredgecolor_is ("auto"))
-	{
-	  mecolor = props.get_edgecolor_rgb ();
-	  do_edge = ! props.edgecolor_is ("none");
-	}
+        {
+          mecolor = props.get_edgecolor_rgb ();
+          do_edge = ! props.edgecolor_is ("none");
+        }
 
       if (mfcolor.numel () == 0 && props.markerfacecolor_is ("auto"))
-	{
-	  mfcolor = props.get_facecolor_rgb ();
-	  do_face = ! props.facecolor_is ("none");
-	}
+        {
+          mfcolor = props.get_facecolor_rgb ();
+          do_face = ! props.facecolor_is ("none");
+        }
 
       if ((mecolor.numel () == 0 || mfcolor.numel () == 0)
-	  && c.numel () == 0)
-	c = props.get_color_data ().array_value ();
+          && c.numel () == 0)
+        c = props.get_color_data ().array_value ();
 
       init_marker (props.get_marker (), props.get_markersize (),
-		   props.get_linewidth ());
+                   props.get_linewidth ());
 
       for (int i = 0; i < zc; i++)
-	{
-	  if (y_mat)
-	    i1 = i;
-	  
-	  for (int j = 0; j < zr; j++)
-	    {
-	      if (clip(j,i))
-		continue;
-
-	      if (x_mat)
-		j1 = j;
-
-	      if ((do_edge && mecolor.numel () == 0)
-		  || (do_face && mfcolor.numel () == 0))
-		{
-		  for (int k = 0; k < 3; k++)
-		    cc(k) = c(j,i,k);
-		}
-
-	      Matrix lc = (do_edge ? (mecolor.numel () == 0 ? cc : mecolor) : Matrix ());
-	      Matrix fc = (do_face ? (mfcolor.numel () == 0 ? cc : mfcolor) : Matrix ());
-
-	      draw_marker (x(j1,i), y(j,i1), z(j,i), lc, fc);
-	    }
-	}
+        {
+          if (y_mat)
+            i1 = i;
+          
+          for (int j = 0; j < zr; j++)
+            {
+              if (clip(j,i))
+                continue;
+
+              if (x_mat)
+                j1 = j;
+
+              if ((do_edge && mecolor.numel () == 0)
+                  || (do_face && mfcolor.numel () == 0))
+                {
+                  for (int k = 0; k < 3; k++)
+                    cc(k) = c(j,i,k);
+                }
+
+              Matrix lc = (do_edge ? (mecolor.numel () == 0 ? cc : mecolor) : Matrix ());
+              Matrix fc = (do_face ? (mfcolor.numel () == 0 ? cc : mfcolor) : Matrix ());
+
+              draw_marker (x(j1,i), y(j,i1), z(j,i), lc, fc);
+            }
+        }
 
       end_marker ();
     }
 }
 
 // FIXME: global optimization (rendering, data structures...), there
 // is probably a smarter/faster/less-memory-consuming way to do this.
 void
@@ -2359,27 +2359,27 @@ opengl_renderer::draw_patch (const patch
   int nf = f.rows ();
   int fcmax = f.columns ();
 
   bool has_z = (v.columns () > 2);
   bool has_facecolor = false;
   bool has_facealpha = false;
 
   int fc_mode = (props.facecolor_is_rgb () ? 0 :
-		 (props.facecolor_is("flat") ? 1 : 2));
+                 (props.facecolor_is("flat") ? 1 : 2));
   int fl_mode = (props.facelighting_is ("none") ? 0 :
-		 (props.facelighting_is ("flat") ? 1 : 2));
+                 (props.facelighting_is ("flat") ? 1 : 2));
   int fa_mode = (props.facealpha_is_double () ? 0 :
-		 (props.facealpha_is ("flat") ? 1 : 2));
+                 (props.facealpha_is ("flat") ? 1 : 2));
   int ec_mode = (props.edgecolor_is_rgb () ? 0 :
-		 (props.edgecolor_is("flat") ? 1 : 2));
+                 (props.edgecolor_is("flat") ? 1 : 2));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
-		 (props.edgelighting_is ("flat") ? 1 : 2));
+                 (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
-		 (props.edgealpha_is ("flat") ? 1 : 2));
+                 (props.edgealpha_is ("flat") ? 1 : 2));
 
   Matrix fcolor = props.get_facecolor_rgb ();
   Matrix ecolor = props.get_edgecolor_rgb ();
   
   float as = props.get_ambientstrength ();
   float ds = props.get_diffusestrength ();
   float ss = props.get_specularstrength ();
   float se = props.get_specularexponent ();
@@ -2397,262 +2397,262 @@ opengl_renderer::draw_patch (const patch
   Array<int> count_f (nf, 0);
 
   for (int i = 0; i < nf; i++)
     {
       bool fclip = false;
       int count = 0;
 
       for (int j = 0; j < fcmax && ! xisnan (f(i,j)); j++, count++)
-	fclip = (fclip || clip(int (f(i,j) - 1)));
+        fclip = (fclip || clip(int (f(i,j) - 1)));
 
       clip_f(i) = fclip;
       count_f(i) = count;
     }
 
   if (fc_mode > 0 || ec_mode > 0)
     {
       c = props.get_color_data ().matrix_value ();
 
       if (c.rows () == 1)
-	{
-	  // Single color specifications, we can simplify a little bit
-	  
-	  if (fc_mode > 0)
-	    {
-	      fcolor = c;
-	      fc_mode = 0;
-	    }
-
-	  if (ec_mode > 0)
-	    {
-	      ecolor = c;
-	      ec_mode = 0;
-	    }
-
-	  c = Matrix ();
-	}
+        {
+          // Single color specifications, we can simplify a little bit
+          
+          if (fc_mode > 0)
+            {
+              fcolor = c;
+              fc_mode = 0;
+            }
+
+          if (ec_mode > 0)
+            {
+              ecolor = c;
+              ec_mode = 0;
+            }
+
+          c = Matrix ();
+        }
       else
-	has_facecolor = ((c.numel () > 0) && (c.rows () == f.rows ()));
+        has_facecolor = ((c.numel () > 0) && (c.rows () == f.rows ()));
     }
 
   if (fa_mode > 0 || ea_mode > 0)
     {
       // FIXME: retrieve alpha data from patch object
       //a = props.get_alpha_data ();
       has_facealpha = ((a.numel () > 0) && (a.rows () == f.rows ()));
     }
 
   octave_idx_type fr = f.rows ();
   std::vector<vertex_data> vdata (f.numel ());
 
   for (int i = 0; i < nf; i++)
     for (int j = 0; j < count_f(i); j++)
       {
-	int idx = int (f(i,j) - 1);
-
-	Matrix vv (1, 3, 0.0);
-	Matrix cc;
-	Matrix nn(1, 3, 0.0);
-	double aa = 1.0;
-
-	vv(0) = v(idx,0); vv(1) = v(idx,1);
-	if (has_z)
-	  vv(2) = v(idx,2);
-	// FIXME: uncomment when patch object has normal computation
-	//nn(0) = n(idx,0); nn(1) = n(idx,1); nn(2) = n(idx,2);
-	if (c.numel () > 0)
-	  {
-	    cc.resize (1, 3);
-	    if (has_facecolor)
-	      cc(0) = c(i,0), cc(1) = c(i,1), cc(2) = c(i,2);
-	    else
-	      cc(0) = c(idx,0), cc(1) = c(idx,1), cc(2) = c(idx,2);
-	  }
-	if (a.numel () > 0)
-	  {
-	    if (has_facealpha)
-	      aa = a(i);
-	    else
-	      aa = a(idx);
-	  }
-
-	vdata[i+j*fr] =
-	    vertex_data (vv, cc, nn, aa, as, ds, ss, se);
+        int idx = int (f(i,j) - 1);
+
+        Matrix vv (1, 3, 0.0);
+        Matrix cc;
+        Matrix nn(1, 3, 0.0);
+        double aa = 1.0;
+
+        vv(0) = v(idx,0); vv(1) = v(idx,1);
+        if (has_z)
+          vv(2) = v(idx,2);
+        // FIXME: uncomment when patch object has normal computation
+        //nn(0) = n(idx,0); nn(1) = n(idx,1); nn(2) = n(idx,2);
+        if (c.numel () > 0)
+          {
+            cc.resize (1, 3);
+            if (has_facecolor)
+              cc(0) = c(i,0), cc(1) = c(i,1), cc(2) = c(i,2);
+            else
+              cc(0) = c(idx,0), cc(1) = c(idx,1), cc(2) = c(idx,2);
+          }
+        if (a.numel () > 0)
+          {
+            if (has_facealpha)
+              aa = a(i);
+            else
+              aa = a(idx);
+          }
+
+        vdata[i+j*fr] =
+            vertex_data (vv, cc, nn, aa, as, ds, ss, se);
       }
 
   if (fl_mode > 0 || el_mode > 0)
     {
       float buf[4] = { ss, ss, ss, 1 };
 
       glMaterialfv (LIGHT_MODE, GL_SPECULAR, buf);
       glMaterialf (LIGHT_MODE, GL_SHININESS, se);
     }
 
   if (! props.facecolor_is ("none"))
     {
       // FIXME: adapt to double-radio property
       if (props.get_facealpha_double () == 1)
-	{
-	  if (fc_mode == 0)
-	    {
-	      glColor3dv (fcolor.data ());
-	      if (fl_mode > 0)
-		{
-		  float cb[4] = { 0, 0, 0, 1 };
-
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = (as * fcolor(i));
-		  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = ds * fcolor(i);
-		  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-		}
-	    }
-
-	  if (fl_mode > 0)
-	    glEnable (GL_LIGHTING);
-
-	  // FIXME: use __index__ property from patch object
-	  patch_tesselator tess (this, fc_mode, fl_mode, 0);
-
-	  for (int i = 0; i < nf; i++)
-	    {
-	      if (clip_f(i))
-		continue;
-
-	      tess.begin_polygon (true);
-	      tess.begin_contour ();
-
-	      for (int j = 0; j < count_f(i); j++)
-		{
-		  vertex_data::vertex_data_rep *vv = vdata[i+j*fr].get_rep ();
-	
-		  tess.add_vertex (vv->coords.fortran_vec (), vv);
-		}
-
-	      tess.end_contour ();
-	      tess.end_polygon ();
-	    }
-
-	  if (fl_mode > 0)
-	    glDisable (GL_LIGHTING);
-	}
+        {
+          if (fc_mode == 0)
+            {
+              glColor3dv (fcolor.data ());
+              if (fl_mode > 0)
+                {
+                  float cb[4] = { 0, 0, 0, 1 };
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = (as * fcolor(i));
+                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ds * fcolor(i);
+                  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                }
+            }
+
+          if (fl_mode > 0)
+            glEnable (GL_LIGHTING);
+
+          // FIXME: use __index__ property from patch object
+          patch_tesselator tess (this, fc_mode, fl_mode, 0);
+
+          for (int i = 0; i < nf; i++)
+            {
+              if (clip_f(i))
+                continue;
+
+              tess.begin_polygon (true);
+              tess.begin_contour ();
+
+              for (int j = 0; j < count_f(i); j++)
+                {
+                  vertex_data::vertex_data_rep *vv = vdata[i+j*fr].get_rep ();
+        
+                  tess.add_vertex (vv->coords.fortran_vec (), vv);
+                }
+
+              tess.end_contour ();
+              tess.end_polygon ();
+            }
+
+          if (fl_mode > 0)
+            glDisable (GL_LIGHTING);
+        }
       else
-	{
-	  // FIXME: implement transparency
-	}
+        {
+          // FIXME: implement transparency
+        }
     }
 
   if (! props.edgecolor_is ("none"))
     {
       // FIXME: adapt to double-radio property
       if (props.get_edgealpha_double () == 1)
-	{
-	  if (ec_mode == 0)
-	    {
-	      glColor3dv (ecolor.data ());
-	      if (el_mode > 0)
-		{
-		  float cb[4] = { 0, 0, 0, 1 };
-
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = (as * ecolor(i));
-		  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-
-		  for (int i = 0; i < 3; i++)
-		    cb[i] = ds * ecolor(i);
-		  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
-		}
-	    }
-
-	  if (el_mode > 0)
-	    glEnable (GL_LIGHTING);
-
-	  set_linestyle (props.get_linestyle (), false);
-	  set_linewidth (props.get_linewidth ());
-
-	  // FIXME: use __index__ property from patch object; should we
-	  // offset patch contour as well?
-	  patch_tesselator tess (this, ec_mode, el_mode);
-
-	  for (int i = 0; i < nf; i++)
-	    {
-	      if (clip_f(i))
-		continue;
-
-	      tess.begin_polygon (false);
-	      tess.begin_contour ();
-
-	      for (int j = 0; j < count_f(i); j++)
-		{
-		  vertex_data::vertex_data_rep *vv = vdata[i+j*fr].get_rep ();
-	
-		  tess.add_vertex (vv->coords.fortran_vec (), vv);
-		}
-
-	      tess.end_contour ();
-	      tess.end_polygon ();
-	    }
-
-	  set_linestyle ("-");
-	  set_linewidth (0.5);
-
-	  if (el_mode > 0)
-	    glDisable (GL_LIGHTING);
-	}
+        {
+          if (ec_mode == 0)
+            {
+              glColor3dv (ecolor.data ());
+              if (el_mode > 0)
+                {
+                  float cb[4] = { 0, 0, 0, 1 };
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = (as * ecolor(i));
+                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
+
+                  for (int i = 0; i < 3; i++)
+                    cb[i] = ds * ecolor(i);
+                  glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
+                }
+            }
+
+          if (el_mode > 0)
+            glEnable (GL_LIGHTING);
+
+          set_linestyle (props.get_linestyle (), false);
+          set_linewidth (props.get_linewidth ());
+
+          // FIXME: use __index__ property from patch object; should we
+          // offset patch contour as well?
+          patch_tesselator tess (this, ec_mode, el_mode);
+
+          for (int i = 0; i < nf; i++)
+            {
+              if (clip_f(i))
+                continue;
+
+              tess.begin_polygon (false);
+              tess.begin_contour ();
+
+              for (int j = 0; j < count_f(i); j++)
+                {
+                  vertex_data::vertex_data_rep *vv = vdata[i+j*fr].get_rep ();
+        
+                  tess.add_vertex (vv->coords.fortran_vec (), vv);
+                }
+
+              tess.end_contour ();
+              tess.end_polygon ();
+            }
+
+          set_linestyle ("-");
+          set_linewidth (0.5);
+
+          if (el_mode > 0)
+            glDisable (GL_LIGHTING);
+        }
       else
-	{
-	  // FIXME: implement transparency
-	}
+        {
+          // FIXME: implement transparency
+        }
     }
 
   if (! props.marker_is ("none") &&
       ! (props.markeredgecolor_is ("none") && props.markerfacecolor_is ("none")))
     {
       bool do_edge = ! props.markeredgecolor_is ("none");
       bool do_face = ! props.markerfacecolor_is ("none");
 
       Matrix mecolor = props.get_markeredgecolor_rgb ();
       Matrix mfcolor = props.get_markerfacecolor_rgb ();
       Matrix cc (1, 3, 0.0);
 
       if (mecolor.numel () == 0 && props.markeredgecolor_is ("auto"))
-	{
-	  mecolor = props.get_edgecolor_rgb ();
-	  do_edge = ! props.edgecolor_is ("none");
-	}
+        {
+          mecolor = props.get_edgecolor_rgb ();
+          do_edge = ! props.edgecolor_is ("none");
+        }
 
       if (mfcolor.numel () == 0 && props.markerfacecolor_is ("auto"))
-	{
-	  mfcolor = props.get_facecolor_rgb ();
-	  do_face = ! props.facecolor_is ("none");
-	}
+        {
+          mfcolor = props.get_facecolor_rgb ();
+          do_face = ! props.facecolor_is ("none");
+        }
 
       init_marker (props.get_marker (), props.get_markersize (),
-		   props.get_linewidth ());
+                   props.get_linewidth ());
 
       for (int i = 0; i < nf; i++)
-	for (int j = 0; j < count_f(i); j++)
-	  {
-	    int idx = int (f(i,j) - 1);
-
-	    if (clip(idx))
-	      continue;
-
-	    Matrix lc = (do_edge ? (mecolor.numel () == 0 ?
-				    vdata[i+j*fr].get_rep ()->color : mecolor)
-			 : Matrix ());
-	    Matrix fc = (do_face ? (mfcolor.numel () == 0 ?
-				    vdata[i+j*fr].get_rep ()->color : mfcolor)
-			 : Matrix ());
-
-	    draw_marker (v(idx,0), v(idx,1), (has_z ? v(idx,2) : 0), lc, fc);
-	  }
+        for (int j = 0; j < count_f(i); j++)
+          {
+            int idx = int (f(i,j) - 1);
+
+            if (clip(idx))
+              continue;
+
+            Matrix lc = (do_edge ? (mecolor.numel () == 0 ?
+                                    vdata[i+j*fr].get_rep ()->color : mecolor)
+                         : Matrix ());
+            Matrix fc = (do_face ? (mfcolor.numel () == 0 ?
+                                    vdata[i+j*fr].get_rep ()->color : mfcolor)
+                         : Matrix ());
+
+            draw_marker (v(idx,0), v(idx,1), (has_z ? v(idx,2) : 0), lc, fc);
+          }
 
       end_marker ();
     }
 }
 
 void
 opengl_renderer::draw_hggroup (const hggroup::properties &props)
 {
@@ -2682,18 +2682,18 @@ opengl_renderer::draw_text (const text::
   else if (props.verticalalignment_is ("baseline"))
     valign = 3;
   else if (props.verticalalignment_is ("middle"))
     valign = 1;
 
   // FIXME: handle margin and surrounding box
 
   render_text (props.get_string (),
-	     pos(0), pos(1), pos(2),
-	     halign, valign, props.get_rotation ());
+             pos(0), pos(1), pos(2),
+             halign, valign, props.get_rotation ());
 }
 
 void
 opengl_renderer::draw_image (const image::properties& props)
 {
   octave_value cdata = props.get_color_data ();
   dim_vector dv (cdata.dims ());
   int h = dv(0), w = dv(1);
@@ -2743,24 +2743,24 @@ opengl_renderer::draw_image (const image
 
   float im_xmin = x(0) - nor_dx/2;
   float im_xmax = x(1) + nor_dx/2;
   float im_ymin = y(0) - nor_dy/2;
   float im_ymax = y(1) + nor_dy/2;
   if (props.is_clipping ()) // clip to axes
     {
       if (im_xmin < xmin)
-	j0 += (xmin - im_xmin)/nor_dx + 1;
+        j0 += (xmin - im_xmin)/nor_dx + 1;
       if (im_xmax > xmax)
-	j1 -= (im_xmax - xmax)/nor_dx ;
+        j1 -= (im_xmax - xmax)/nor_dx ;
 
       if (im_ymin < ymin)
-	i0 += (ymin - im_ymin)/nor_dy + 1;
+        i0 += (ymin - im_ymin)/nor_dy + 1;
       if (im_ymax > ymax)
-	i1 -= (im_ymax - ymax)/nor_dy;
+        i1 -= (im_ymax - ymax)/nor_dy;
     }
   else // clip to viewport
     {
       GLfloat vp[4];
       glGetFloatv(GL_VIEWPORT, vp);
       // FIXME -- actually add the code to do it!
       
     }
@@ -2773,76 +2773,76 @@ opengl_renderer::draw_image (const image
 
   // by default this is 4
   glPixelStorei (GL_UNPACK_ALIGNMENT,1);
 
   // Expect RGB data
   if (dv.length () == 3 && dv(2) == 3)
     {
       if (cdata.is_double_type ())
-	{
-	  const NDArray xcdata = cdata.array_value ();
-
-	  OCTAVE_LOCAL_BUFFER (GLfloat, a, 3*(j1-j0)*(i1-i0));
-
-	  for (int i = i0; i < i1; i++)
-	    {
-	      for (int j = j0, idx = (i-i0)*(j1-j0)*3; j < j1; j++, idx += 3)
-		{
-		  a[idx]   = xcdata(i,j,0);
-		  a[idx+1] = xcdata(i,j,1);
-		  a[idx+2] = xcdata(i,j,2);
-		}
-	    }
-
-	  draw_pixels (j1-j0, i1-i0, GL_RGB, GL_FLOAT, a);
-
-	}
+        {
+          const NDArray xcdata = cdata.array_value ();
+
+          OCTAVE_LOCAL_BUFFER (GLfloat, a, 3*(j1-j0)*(i1-i0));
+
+          for (int i = i0; i < i1; i++)
+            {
+              for (int j = j0, idx = (i-i0)*(j1-j0)*3; j < j1; j++, idx += 3)
+                {
+                  a[idx]   = xcdata(i,j,0);
+                  a[idx+1] = xcdata(i,j,1);
+                  a[idx+2] = xcdata(i,j,2);
+                }
+            }
+
+          draw_pixels (j1-j0, i1-i0, GL_RGB, GL_FLOAT, a);
+
+        }
       else if (cdata.is_uint16_type ())
-	{
-	  const uint16NDArray xcdata = cdata.uint16_array_value ();
-
-	  OCTAVE_LOCAL_BUFFER (GLushort, a, 3*(j1-j0)*(i1-i0));
-
-	  for (int i = i0; i < i1; i++)
-	    {
-	      for (int j = j0, idx = (i-i0)*(j1-j0)*3; j < j1; j++, idx += 3)
-		{
-		  a[idx]   = xcdata(i,j,0);
-		  a[idx+1] = xcdata(i,j,1);
-		  a[idx+2] = xcdata(i,j,2);
-		}
-	    }
-
-	  draw_pixels (j1-j0, i1-i0, GL_RGB, GL_UNSIGNED_SHORT, a);
-
-	}
+        {
+          const uint16NDArray xcdata = cdata.uint16_array_value ();
+
+          OCTAVE_LOCAL_BUFFER (GLushort, a, 3*(j1-j0)*(i1-i0));
+
+          for (int i = i0; i < i1; i++)
+            {
+              for (int j = j0, idx = (i-i0)*(j1-j0)*3; j < j1; j++, idx += 3)
+                {
+                  a[idx]   = xcdata(i,j,0);
+                  a[idx+1] = xcdata(i,j,1);
+                  a[idx+2] = xcdata(i,j,2);
+                }
+            }
+
+          draw_pixels (j1-j0, i1-i0, GL_RGB, GL_UNSIGNED_SHORT, a);
+
+        }
       else if (cdata.is_uint8_type ())
-	{
-	  const uint8NDArray xcdata = cdata.uint8_array_value ();
-
-	  OCTAVE_LOCAL_BUFFER (GLubyte, a, 3*(j1-j0)*(i1-i0));
-
-	  for (int i = i0; i < i1; i++)
-	    {
-	      for (int j = j0, idx = (i-i0)*(j1-j0)*3; j < j1; j++, idx += 3)
-		{
-		  a[idx]   = xcdata(i,j,0);
-		  a[idx+1] = xcdata(i,j,1);
-		  a[idx+2] = xcdata(i,j,2);
-		}
-	    }
-
-	  draw_pixels (j1-j0, i1-i0, GL_RGB, GL_UNSIGNED_BYTE, a);
-	}
+        {
+          const uint8NDArray xcdata = cdata.uint8_array_value ();
+
+          OCTAVE_LOCAL_BUFFER (GLubyte, a, 3*(j1-j0)*(i1-i0));
+
+          for (int i = i0; i < i1; i++)
+            {
+              for (int j = j0, idx = (i-i0)*(j1-j0)*3; j < j1; j++, idx += 3)
+                {
+                  a[idx]   = xcdata(i,j,0);
+                  a[idx+1] = xcdata(i,j,1);
+                  a[idx+2] = xcdata(i,j,2);
+                }
+            }
+
+          draw_pixels (j1-j0, i1-i0, GL_RGB, GL_UNSIGNED_BYTE, a);
+        }
       else
-	{
-	  ok = false;
-	  warning ("opengl_texture::draw: invalid image data type (expected double, uint16, or uint8)");
-	}
+        {
+          ok = false;
+          warning ("opengl_texture::draw: invalid image data type (expected double, uint16, or uint8)");
+        }
     }
   else 
     {
       ok = false;
       warning ("opengl_texture::draw: invalid image size (expected n*m*3 or n*m)");
     }
   glPixelZoom (1, 1);
 }
@@ -2921,17 +2921,17 @@ opengl_renderer::set_linestyle (const st
   if (solid && ! use_stipple)
     glDisable (GL_LINE_STIPPLE);
   else
     glEnable (GL_LINE_STIPPLE);
 }
 
 void
 opengl_renderer::set_clipbox (double x1, double x2, double y1, double y2,
-			      double z1, double z2)
+                              double z1, double z2)
 {
   double dx = (x2-x1);
   double dy = (y2-y1);
   double dz = (z2-z1);
 
   x1 -= 0.001*dx; x2 += 0.001*dx;
   y1 -= 0.001*dy; y2 += 0.001*dy;
   z1 -= 0.001*dz; z2 += 0.001*dz;
@@ -3007,49 +3007,49 @@ opengl_renderer::end_marker (void)
   glPopMatrix ();
   glMatrixMode (GL_PROJECTION);
   glPopMatrix ();
   set_linewidth (0.5f);
 }
 
 void
 opengl_renderer::draw_marker (double x, double y, double z,
-			      const Matrix& lc, const Matrix& fc)
+                              const Matrix& lc, const Matrix& fc)
 {
   ColumnVector tmp = xform.transform (x, y, z, false);
   
   glLoadIdentity ();
   glTranslated (tmp(0), tmp(1), -tmp(2));
 
   if (filled_marker_id > 0 && fc.numel () > 0)
     {
       glColor3dv (fc.data ());
       set_polygon_offset (true, -1.0);
       glCallList (filled_marker_id);
       if (lc.numel () > 0)
-	{
-	  glColor3dv (lc.data ());
-	  glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
-	  glEdgeFlag (GL_TRUE);
-	  set_polygon_offset (true, -2.0);
-	  glCallList (filled_marker_id);
-	  glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
-	}
+        {
+          glColor3dv (lc.data ());
+          glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
+          glEdgeFlag (GL_TRUE);
+          set_polygon_offset (true, -2.0);
+          glCallList (filled_marker_id);
+          glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
+        }
       set_polygon_offset (false);
     }
   else if (marker_id > 0 && lc.numel () > 0)
     {
       glColor3dv (lc.data ());
       glCallList (marker_id);
     }
 }
 
 unsigned int
 opengl_renderer::make_marker_list (const std::string& marker, double size,
-				   bool filled) const
+                                   bool filled) const
 {
   char c = marker[0];
 
   if (filled && (c == '+' || c == 'x' || c == '*' || c == '.'))
     return 0;
 
   unsigned int ID = glGenLists (1);
   double sz = size * backend.get_screen_resolution () / 72.0;
@@ -3103,22 +3103,22 @@ opengl_renderer::make_marker_list (const
       glVertex2d (-sz/2, -sz/2);
       glVertex2d (-sz/2, sz/2);
       glVertex2d (sz/2, sz/2);
       glVertex2d (sz/2, -sz/2);
       glEnd();
       break;
     case 'o':
       {
-	double ang_step = M_PI / 5;
-
-	glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
-	for (double ang = 0; ang < (2*M_PI); ang += ang_step)
-	  glVertex2d (sz*cos(ang)/2, sz*sin(ang)/2);
-	glEnd ();
+        double ang_step = M_PI / 5;
+
+        glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
+        for (double ang = 0; ang < (2*M_PI); ang += ang_step)
+          glVertex2d (sz*cos(ang)/2, sz*sin(ang)/2);
+        glEnd ();
       }
       break;
     case 'd':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2d (0, -sz/2);
       glVertex2d (sz/2, 0);
       glVertex2d (0, sz/2);
       glVertex2d (-sz/2, 0);
@@ -3149,31 +3149,31 @@ opengl_renderer::make_marker_list (const
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2f (-sz/2, 0);
       glVertex2f (sz/2, -sz/2);
       glVertex2f (sz/2, sz/2);
       glEnd ();
       break;
     default:
       warning ("opengl_renderer: unsupported marker `%s'",
-	       marker.c_str ());
+               marker.c_str ());
       break;
     }
 
   glEndList ();
 
   return ID;
 }
 
 void
 opengl_renderer::text_to_pixels (const std::string& txt,
-				 double rotation,
-				 uint8NDArray& pixels,
-				 Matrix& bbox,
-				 int& rot_mode)
+                                 double rotation,
+                                 uint8NDArray& pixels,
+                                 Matrix& bbox,
+                                 int& rot_mode)
 {
   // FIXME: clip "rotation" between 0 and 360
 
   rot_mode = ft_render::ROTATION_0;
 
   if (rotation == 90.0)
     rot_mode = ft_render::ROTATION_90;
   else if (rotation == 180.0)
@@ -3183,18 +3183,18 @@ opengl_renderer::text_to_pixels (const s
 
   text_element *elt = text_parser_none ().parse (txt);
   pixels = text_renderer.render (elt, bbox, rot_mode);
   delete elt;
 }
 
 Matrix
 opengl_renderer::render_text (const std::string& txt,
-			    double x, double y, double z,
-			    int halign, int valign, double rotation)
+                            double x, double y, double z,
+                            int halign, int valign, double rotation)
 {
 #if HAVE_FREETYPE
   if (txt.empty ())
     return Matrix (1, 4, 0.0);
 
   Matrix bbox;
   uint8NDArray pixels;
   int rot_mode;
@@ -3243,17 +3243,17 @@ opengl_renderer::render_text (const std:
 
   bool blend = glIsEnabled (GL_BLEND);
 
   glEnable (GL_BLEND);
   glEnable (GL_ALPHA_TEST);
   glRasterPos3d (x, y, z);
   glBitmap(0, 0, 0, 0, x0, y0, 0);
   glDrawPixels (w, h,
-		GL_RGBA, GL_UNSIGNED_BYTE, pixels.data ());
+                GL_RGBA, GL_UNSIGNED_BYTE, pixels.data ());
   glDisable (GL_ALPHA_TEST);
   if (! blend)
     glDisable (GL_BLEND);
 
   return bbox;
 #else
   ::warning ("render_text: cannot render text, Freetype library not available");
   return Matrix (1, 4, 0.0);
diff --git a/src/gl2ps-renderer.cc b/src/gl2ps-renderer.cc
--- a/src/gl2ps-renderer.cc
+++ b/src/gl2ps-renderer.cc
@@ -45,72 +45,72 @@ glps_renderer::draw (const graphics_obje
 
       FILE *fp = fopen (filename.c_str (), "wb");
       GLint buffsize = 0, state = GL2PS_OVERFLOW;
       GLint viewport[4];
 
       glGetIntegerv (GL_VIEWPORT, viewport);
 
       while (state == GL2PS_OVERFLOW)
-	{ 
-	  buffsize += 1024*1024;
-	  gl2psBeginPage ("glps_renderer figure", "Octave", viewport,
-			  GL2PS_EPS, GL2PS_BSP_SORT,
-			  (GL2PS_SILENT | GL2PS_SIMPLE_LINE_OFFSET
-			   | GL2PS_NO_BLENDING | GL2PS_OCCLUSION_CULL
-			   | GL2PS_BEST_ROOT), GL_RGBA, 0, NULL, 0, 0, 0,
-			  buffsize, fp, filename.c_str () );
+        { 
+          buffsize += 1024*1024;
+          gl2psBeginPage ("glps_renderer figure", "Octave", viewport,
+                          GL2PS_EPS, GL2PS_BSP_SORT,
+                          (GL2PS_SILENT | GL2PS_SIMPLE_LINE_OFFSET
+                           | GL2PS_NO_BLENDING | GL2PS_OCCLUSION_CULL
+                           | GL2PS_BEST_ROOT), GL_RGBA, 0, NULL, 0, 0, 0,
+                          buffsize, fp, filename.c_str () );
 
-	  opengl_renderer::draw (go);
-	  state = gl2psEndPage ();
-	}
+          opengl_renderer::draw (go);
+          state = gl2psEndPage ();
+        }
 
       fclose (fp);
 
       in_draw = 0;
     }
   else
     opengl_renderer::draw (go); 
 }
 
 Matrix 
 glps_renderer::render_text (const std::string& txt,
-			    double x, double y, double z,
-			    int ha, int va, double rotation)
+                            double x, double y, double z,
+                            int ha, int va, double rotation)
 {
   if (txt.empty ())
     return Matrix (1, 4, 0.0);
 
   int gl2psa=GL2PS_TEXT_BL;
   if (ha == 0)
     {
       if (va == 0 || va == 3)
-	gl2psa=GL2PS_TEXT_BL;
+        gl2psa=GL2PS_TEXT_BL;
       else if (va == 2)
-	gl2psa=GL2PS_TEXT_TL;
+        gl2psa=GL2PS_TEXT_TL;
       else if (va == 1)
-	gl2psa=GL2PS_TEXT_CL;
+        gl2psa=GL2PS_TEXT_CL;
     }
   else if (ha == 2)
     {
       if (va == 0 || va == 3)
-	gl2psa=GL2PS_TEXT_BR;
+        gl2psa=GL2PS_TEXT_BR;
       else if (va == 2)
-	gl2psa=GL2PS_TEXT_TR;
+        gl2psa=GL2PS_TEXT_TR;
       else if (va == 1)
-	gl2psa=GL2PS_TEXT_CR;
+        gl2psa=GL2PS_TEXT_CR;
     }
   else if (ha == 1)
     {
       if (va == 0 || va == 3)
-	gl2psa=GL2PS_TEXT_B;
+        gl2psa=GL2PS_TEXT_B;
       else if (va == 2)
-	gl2psa=GL2PS_TEXT_T;
+        gl2psa=GL2PS_TEXT_T;
       else if (va == 1)
-	gl2psa=GL2PS_TEXT_C;
+        gl2psa=GL2PS_TEXT_C;
     }
 
   glRasterPos3d (x, y, z);
 
   gl2psTextOpt (txt.c_str (), fontname.c_str (), fontsize, gl2psa, rotation);
 
   // FIXME? -- we have no way of getting a bounding box from gl2ps, so
   // we use freetype
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -62,67 +62,67 @@ gripe_set_invalid (const std::string& pn
 }
 
 // Check to see that PNAME matches just one of PNAMES uniquely.
 // Return the full name of the match, or an empty caseless_str object
 // if there is no match, or the match is ambiguous.
 
 static caseless_str
 validate_property_name (const std::string& who, const std::string& what,
-			const std::set<std::string>& pnames,
-			const caseless_str& pname)
+                        const std::set<std::string>& pnames,
+                        const caseless_str& pname)
 {
   size_t len = pname.length ();
   std::set<std::string> matches;
 
   for (std::set<std::string>::const_iterator p = pnames.begin ();
        p != pnames.end (); p++)
     {
       if (pname.compare (*p, len))
-	{
-	  if (len == p->length ())
-	    {
-	      // Exact match.
-	      return pname;
-	    }
-
-	  matches.insert (*p);
-	}
+        {
+          if (len == p->length ())
+            {
+              // Exact match.
+              return pname;
+            }
+
+          matches.insert (*p);
+        }
     }
 
   size_t num_matches = matches.size ();
 
   if (num_matches == 0)
     {
       error ("%s: unknown %s property %s",
-	     who.c_str (), what.c_str (), pname.c_str ());
+             who.c_str (), what.c_str (), pname.c_str ());
     }
   else if (num_matches > 1)
     {
       string_vector sv (matches);
 
       std::ostringstream os;
 
       sv.list_in_columns (os);
 
       std::string match_list = os.str ();
 
       error ("%s: ambiguous %s property name %s; possible matches:\n\n%s",
-	     who.c_str (), what.c_str (), pname.c_str (), match_list.c_str ());
+             who.c_str (), what.c_str (), pname.c_str (), match_list.c_str ());
     }
   else if (num_matches == 1)
     {
       // Exact match was handled above.
 
       std::string possible_match = *(matches.begin ());
 
       warning_with_id ("Octave:abbreviated-property-match",
-		       "%s: allowing %s to match %s property %s",
-		       who.c_str (), pname.c_str (), what.c_str (),
-		       possible_match.c_str ());
+                       "%s: allowing %s to match %s property %s",
+                       who.c_str (), pname.c_str (), what.c_str (),
+                       possible_match.c_str ());
 
       return possible_match;
     }
 
   return caseless_str ();
 }
 
 static Matrix
@@ -303,149 +303,149 @@ default_figure_paperposition (void)
   m(1) = 2.50;
   m(2) = 8.00;
   m(3) = 6.00;
   return m;
 }
 
 static Matrix
 convert_position (const Matrix& pos, const caseless_str& from_units,
-		  const caseless_str& to_units,
-		  const Matrix& parent_dim = Matrix (1, 2, 0.0))
+                  const caseless_str& to_units,
+                  const Matrix& parent_dim = Matrix (1, 2, 0.0))
 {
   Matrix retval (1, 4);
   double res = 0;
 
   if (from_units.compare ("pixels"))
     retval = pos;
   else if (from_units.compare ("normalized"))
     {
       retval(0) = pos(0) * parent_dim(0) + 1;
       retval(1) = pos(1) * parent_dim(1) + 1;
       retval(2) = pos(2) * parent_dim(0);
       retval(3) = pos(3) * parent_dim(1);
     }
   else if (from_units.compare ("characters"))
     {
       if (res <= 0)
-	res = xget (0, "screenpixelsperinch").double_value ();
+        res = xget (0, "screenpixelsperinch").double_value ();
 
       double f = 0.0;
 
       // FIXME -- this assumes the system font is Helvetica 10pt 
       //          (for which "x" requires 6x12 pixels at 74.951 pixels/inch)
       f = 12.0 * res / 74.951;
 
       if (f > 0)
-	{
-	  retval(0) = 0.5 * pos(0) * f;
-	  retval(1) = pos(1) * f;
-	  retval(2) = 0.5 * pos(2) * f;
-	  retval(3) = pos(3) * f;
-	}
+        {
+          retval(0) = 0.5 * pos(0) * f;
+          retval(1) = pos(1) * f;
+          retval(2) = 0.5 * pos(2) * f;
+          retval(3) = pos(3) * f;
+        }
     }
   else
     {
       if (res <= 0)
-	res = xget (0, "screenpixelsperinch").double_value ();
+        res = xget (0, "screenpixelsperinch").double_value ();
 
       double f = 0.0;
 
       if (from_units.compare ("points"))
-	f = res / 72.0;
+        f = res / 72.0;
       else if (from_units.compare ("inches"))
-	f = res;
+        f = res;
       else if (from_units.compare ("centimeters"))
-	f = res / 2.54;
+        f = res / 2.54;
 
       if (f > 0)
-	{
-	  retval(0) = pos(0) * f + 1;
-	  retval(1) = pos(1) * f + 1;
-	  retval(2) = pos(2) * f;
-	  retval(3) = pos(3) * f;
-	}
+        {
+          retval(0) = pos(0) * f + 1;
+          retval(1) = pos(1) * f + 1;
+          retval(2) = pos(2) * f;
+          retval(3) = pos(3) * f;
+        }
     }
 
   if (! to_units.compare ("pixels"))
     {
       if (to_units.compare ("normalized"))
-	{
-	  retval(0) = (retval(0) - 1) / parent_dim(0);
-	  retval(1) = (retval(1) - 1) / parent_dim(1);
-	  retval(2) /= parent_dim(0);
-	  retval(3) /= parent_dim(1);
-	}
+        {
+          retval(0) = (retval(0) - 1) / parent_dim(0);
+          retval(1) = (retval(1) - 1) / parent_dim(1);
+          retval(2) /= parent_dim(0);
+          retval(3) /= parent_dim(1);
+        }
       else if (to_units.compare ("characters"))
-	{
-	  if (res <= 0)
-	    res = xget (0, "screenpixelsperinch").double_value ();
-
-	  double f = 0.0;
-
-	  f = 12.0 * res / 74.951;
-
-	  if (f > 0)
-	    {
-	      retval(0) = 2 * retval(0) / f;
-	      retval(1) = retval(1) / f;
-	      retval(2) = 2 * retval(2) / f;
-	      retval(3) = retval(3) / f;
-	    }
-	}
+        {
+          if (res <= 0)
+            res = xget (0, "screenpixelsperinch").double_value ();
+
+          double f = 0.0;
+
+          f = 12.0 * res / 74.951;
+
+          if (f > 0)
+            {
+              retval(0) = 2 * retval(0) / f;
+              retval(1) = retval(1) / f;
+              retval(2) = 2 * retval(2) / f;
+              retval(3) = retval(3) / f;
+            }
+        }
       else
-	{
-	  if (res <= 0)
-	    res = xget (0, "screenpixelsperinch").double_value ();
-
-	  double f = 0.0;
-
-	  if (to_units.compare ("points"))
-	    f = res / 72.0;
-	  else if (to_units.compare ("inches"))
-	    f = res;
-	  else if (to_units.compare ("centimeters"))
-	    f = res / 2.54;
-
-	  if (f > 0)
-	    {
-	      retval(0) = (retval(0) - 1) / f;
-	      retval(1) = (retval(1) - 1) / f;
-	      retval(2) /= f;
-	      retval(3) /= f;
-	    }
-	}
+        {
+          if (res <= 0)
+            res = xget (0, "screenpixelsperinch").double_value ();
+
+          double f = 0.0;
+
+          if (to_units.compare ("points"))
+            f = res / 72.0;
+          else if (to_units.compare ("inches"))
+            f = res;
+          else if (to_units.compare ("centimeters"))
+            f = res / 2.54;
+
+          if (f > 0)
+            {
+              retval(0) = (retval(0) - 1) / f;
+              retval(1) = (retval(1) - 1) / f;
+              retval(2) /= f;
+              retval(3) /= f;
+            }
+        }
     }
 
   return retval;
 }
 
 static graphics_object
 xget_ancestor (const graphics_object& go_arg, const std::string& type)
 {
   graphics_object go = go_arg;
 
   do
     {
       if (go.valid_object ())
-	{
-	  if (go.isa (type))
-	    return go;
-	  else
-	    go = gh_manager::get_object (go.get_parent ());
-	}
+        {
+          if (go.isa (type))
+            return go;
+          else
+            go = gh_manager::get_object (go.get_parent ());
+        }
       else
-	return graphics_object ();
+        return graphics_object ();
     }
  while (true);
 }
 
 static octave_value
 convert_cdata (const base_properties& props, const octave_value& cdata,
-	       bool is_scaled, int cdim)
+               bool is_scaled, int cdim)
 {
   dim_vector dv (cdata.dims ());
 
   if (dv.length () == cdim && dv(cdim-1) == 3)
     return cdata;
 
   Matrix cmap (1, 3, 0.0);
   Matrix clim (1, 2, 0.0);
@@ -453,30 +453,30 @@ convert_cdata (const base_properties& pr
   graphics_object go = gh_manager::get_object (props.get___myhandle__ ());
   graphics_object fig = xget_ancestor (go, "figure");
 
   if (fig.valid_object ())
     {
       Matrix _cmap = fig.get (caseless_str ("colormap")).matrix_value ();
 
       if (! error_state)
-	cmap = _cmap;
+        cmap = _cmap;
     }
 
   if (is_scaled)
     {
       graphics_object ax = xget_ancestor (go, "axes");
 
       if (ax.valid_object ())
-	{
-	  Matrix _clim = ax.get (caseless_str ("clim")).matrix_value ();
-
-	  if (! error_state)
-	    clim = _clim;
-	}
+        {
+          Matrix _clim = ax.get (caseless_str ("clim")).matrix_value ();
+
+          if (! error_state)
+            clim = _clim;
+        }
     }
 
   dv.resize (cdim);
   dv(cdim-1) = 3;
 
   NDArray a (dv);
 
   octave_idx_type lda = a.numel () / static_cast<octave_idx_type> (3);
@@ -492,122 +492,122 @@ convert_cdata (const base_properties& pr
   else
     cv = cdata.array_value ().data ();
 
   for (octave_idx_type i = 0; i < lda; i++)
     {
       double x = (cv ? cv[i] : double (icv[i]));
 
       if (is_scaled)
-	x = xround ((nc - 1) * (x - clim(0)) / (clim(1) - clim(0)));
+        x = xround ((nc - 1) * (x - clim(0)) / (clim(1) - clim(0)));
       else
-	x = xround (x - 1);
+        x = xround (x - 1);
 
       if (xisnan (x))
-	{
-	  av[i]       = x;
-	  av[i+lda]   = x;
-	  av[i+2*lda] = x;
-	}
+        {
+          av[i]       = x;
+          av[i+lda]   = x;
+          av[i+2*lda] = x;
+        }
       else
-	{
-	  if (x < 0)
-	    x = 0;
-	  else if (x >= nc)
-	    x = (nc - 1);
-
-	  octave_idx_type idx = static_cast<octave_idx_type> (x);
-
-	  av[i]       = cmapv[idx];
-	  av[i+lda]   = cmapv[idx+nc];
-	  av[i+2*lda] = cmapv[idx+2*nc];
-	}
+        {
+          if (x < 0)
+            x = 0;
+          else if (x >= nc)
+            x = (nc - 1);
+
+          octave_idx_type idx = static_cast<octave_idx_type> (x);
+
+          av[i]       = cmapv[idx];
+          av[i+lda]   = cmapv[idx+nc];
+          av[i+2*lda] = cmapv[idx+2*nc];
+        }
     }
 
   return octave_value (a);
 }
 
 template<class T>
 static void
 get_array_limits (const Array<T>& m, double& emin, double& emax,
-		  double& eminp)
+                  double& eminp)
 {
   const T *data = m.data ();
   octave_idx_type n = m.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       double e = double (data[i]);
 
       if (! (xisinf (e) || xisnan (e)))
-	{
-	  if (e < emin)
-	    emin = e;
-
-	  if (e > emax)
-	    emax = e;
-
-	  if (e > 0 && e < eminp)
-	    eminp = e;
-	}
+        {
+          if (e < emin)
+            emin = e;
+
+          if (e > emax)
+            emax = e;
+
+          if (e > 0 && e < eminp)
+            eminp = e;
+        }
     }
 }
 
 static bool
 lookup_object_name (const caseless_str& name, caseless_str& go_name,
-		    caseless_str& rest)
+                    caseless_str& rest)
 {
   int len = name.length ();
   int offset = 0;
   bool result = false;
 
   if (len >= 4)
     {
       caseless_str pfx = name.substr (0, 4);
 
       if (pfx.compare ("axes") || pfx.compare ("line")
-	  || pfx.compare ("text"))
-	offset = 4;
+          || pfx.compare ("text"))
+        offset = 4;
       else if (len >= 5)
-	{
-	  pfx = name.substr (0, 5);
-
-	  if (pfx.compare ("image") || pfx.compare ("patch"))
-	    offset = 5;
-	  else if (len >= 6)
-	    {
-	      pfx = name.substr (0, 6);
-
-	      if (pfx.compare ("figure"))
-		offset = 6;
-	      else if (len >= 7)
-		{
-		  pfx = name.substr (0, 7);
-
-		  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
-		    offset = 7;
-		}
-	    }
-	}
+        {
+          pfx = name.substr (0, 5);
+
+          if (pfx.compare ("image") || pfx.compare ("patch"))
+            offset = 5;
+          else if (len >= 6)
+            {
+              pfx = name.substr (0, 6);
+
+              if (pfx.compare ("figure"))
+                offset = 6;
+              else if (len >= 7)
+                {
+                  pfx = name.substr (0, 7);
+
+                  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
+                    offset = 7;
+                }
+            }
+        }
 
       if (offset > 0)
-	{
-	  go_name = pfx;
-	  rest = name.substr (offset);
-	  result = true;
-	}
+        {
+          go_name = pfx;
+          rest = name.substr (offset);
+          result = true;
+        }
     }
 
   return result;
 }
 
 static base_graphics_object*
 make_graphics_object_from_type (const caseless_str& type,
-				const graphics_handle& h = graphics_handle (),
-				const graphics_handle& p = graphics_handle ())
+                                const graphics_handle& h = graphics_handle (),
+                                const graphics_handle& p = graphics_handle ())
 {
   base_graphics_object *go = 0;
 
   if (type.compare ("figure"))
     go = new figure (h, p);
   else if (type.compare ("axes"))
     go = new axes (h, p);
   else if (type.compare ("line"))
@@ -631,29 +631,29 @@ make_graphics_object_from_type (const ca
 bool
 base_property::set (const octave_value& v, bool do_run )
 {
   if (do_set (v))
     {
 
       // notify backend
       if (id >= 0)
-	{
-	  graphics_object go = gh_manager::get_object (parent);
-	  if (go)
-	    {
-	      graphics_backend backend = go.get_backend();
-	      if (backend)
-		backend.property_changed (go, id);
-	    }
-	}
+        {
+          graphics_object go = gh_manager::get_object (parent);
+          if (go)
+            {
+              graphics_backend backend = go.get_backend();
+              if (backend)
+                backend.property_changed (go, id);
+            }
+        }
 
       // run listeners
       if (do_run && ! error_state)
-	run_listeners (POSTSET);
+        run_listeners (POSTSET);
 
       return true;
     }
 
   return false;
 }
 
 
@@ -662,46 +662,46 @@ base_property::run_listeners (listener_m
 {
   const octave_value_list& l = listeners[mode];
 
   for (int i = 0; i < l.length (); i++)
     {
       gh_manager::execute_callback (parent, l(i), octave_value ());
 
       if (error_state)
-	break;
+        break;
     }
 }
 
 radio_values::radio_values (const std::string& opt_string)
 {
   size_t beg = 0;
   size_t len = opt_string.length ();
   bool done = len == 0;
 
   while (! done)
     {
       size_t end = opt_string.find ('|', beg);
 
       if (end == std::string::npos)
-	{
-	  end = len;
-	  done = true;
-	}
+        {
+          end = len;
+          done = true;
+        }
 
       std::string t = opt_string.substr (beg, end-beg);
 
       // Might want more error checking here...
       if (t[0] == '{')
-	{
-	  t = t.substr (1, t.length () - 2);
-	  default_val = t;
-	}
+        {
+          t = t.substr (1, t.length () - 2);
+          default_val = t;
+        }
       else if (beg == 0) // ensure default value
-	default_val = t;
+        default_val = t;
 
       possible_vals.insert (t);
 
       beg = end + 1;
     }
 }
 
 bool
@@ -711,101 +711,101 @@ color_values::str2rgb (std::string str)
   bool retval = true;
   unsigned int len = str.length();
 
   std::transform (str.begin (), str.end (), str.begin (), tolower);
 
   if (str.compare(0, len, "blue", 0, len) == 0)
     tmp_rgb[2] = 1;
   else if (str.compare(0, len, "black", 0, len) == 0
-	   || str.compare(0, len, "k", 0, len) == 0)
+           || str.compare(0, len, "k", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 0;
   else if (str.compare(0, len, "red", 0, len) == 0)
     tmp_rgb[0] = 1;
   else if (str.compare(0, len, "green", 0, len) == 0)
     tmp_rgb[1] = 1;
   else if (str.compare(0, len, "yellow", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = 1;
   else if (str.compare(0, len, "magenta", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[2] = 1;
   else if (str.compare(0, len, "cyan", 0, len) == 0)
     tmp_rgb[1] = tmp_rgb[2] = 1;
   else if (str.compare(0, len, "white", 0, len) == 0
-	   || str.compare(0, len, "w", 0, len) == 0)
+           || str.compare(0, len, "w", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 1;
-  else	
+  else  
     retval = false;
 
   if (retval)
     {
       for (int i = 0; i < 3; i++)
-	xrgb(i) = tmp_rgb[i];
+        xrgb(i) = tmp_rgb[i];
     }
 
   return retval;
 }
 
 bool
 color_property::do_set (const octave_value& val)
 {
   if (val.is_string ())
     {
       std::string s = val.string_value ();
 
       if (! s.empty ())
-	{
-	  if (radio_val.contains (s))
-	    {
-	      if (current_type != radio_t || current_val != s)
-		{
-		  current_val = s;
-		  current_type = radio_t;
-		  return true;
-		}
-	    }
+        {
+          if (radio_val.contains (s))
+            {
+              if (current_type != radio_t || current_val != s)
+                {
+                  current_val = s;
+                  current_type = radio_t;
+                  return true;
+                }
+            }
           else
-	    {
-	      color_values col (s);
-	      if (! error_state)
-		{
-		  if (current_type != color_t || col != color_val)
-		    {
-		      color_val = col;
-		      current_type = color_t;
-		      return true;
-		    }
-		}
-	      else
-		error ("invalid value for color property \"%s\" (value = %s)",
-		       get_name ().c_str (), s.c_str ());
-	    }	
-	}
+            {
+              color_values col (s);
+              if (! error_state)
+                {
+                  if (current_type != color_t || col != color_val)
+                    {
+                      color_val = col;
+                      current_type = color_t;
+                      return true;
+                    }
+                }
+              else
+                error ("invalid value for color property \"%s\" (value = %s)",
+                       get_name ().c_str (), s.c_str ());
+            }   
+        }
       else
-	error ("invalid value for color property \"%s\"",
+        error ("invalid value for color property \"%s\"",
            get_name ().c_str ());
     }
   else if (val.is_numeric_type ())
     {
       Matrix m = val.matrix_value ();
 
       if (m.numel () == 3)
-	{
-	  color_values col (m (0), m (1), m(2));
-	  if (! error_state)
-	    {
-	      if (current_type != color_t || col != color_val)
-		{
-		  color_val = col;
-		  current_type = color_t;
-		  return true;
-		}
-	    }
-	}
+        {
+          color_values col (m (0), m (1), m(2));
+          if (! error_state)
+            {
+              if (current_type != color_t || col != color_val)
+                {
+                  color_val = col;
+                  current_type = color_t;
+                  return true;
+                }
+            }
+        }
       else
-	error ("invalid value for color property \"%s\"",
+        error ("invalid value for color property \"%s\"",
            get_name ().c_str ());
     }
   else 
     error ("invalid value for color property \"%s\"",
            get_name ().c_str ());
 
   return false;
 }
@@ -813,42 +813,42 @@ color_property::do_set (const octave_val
 bool
 double_radio_property::do_set (const octave_value& val)
 {
   if (val.is_string ())
     {
       std::string s = val.string_value ();
 
       if (! s.empty () && radio_val.contains (s))
-	{
-	  if (current_type != radio_t || s != current_val)
-	    {
-	      current_val = s;
-	      current_type = radio_t;
-	      return true;
-	    }
-	}
+        {
+          if (current_type != radio_t || s != current_val)
+            {
+              current_val = s;
+              current_type = radio_t;
+              return true;
+            }
+        }
       else
-	error ("invalid value for double_radio property \"%s\"",
-	       get_name ().c_str ());
+        error ("invalid value for double_radio property \"%s\"",
+               get_name ().c_str ());
     }
   else if (val.is_scalar_type () && val.is_real_type ())
     {
       double new_dval = val.double_value ();
 
       if (current_type != double_t || new_dval != dval)
-	{
-	  dval = new_dval;
-	  current_type = double_t;
-	  return true;
-	}
+        {
+          dval = new_dval;
+          current_type = double_t;
+          return true;
+        }
     }
   else 
     error ("invalid value for double_radio property \"%s\"",
-	   get_name ().c_str ());
+           get_name ().c_str ());
 
   return false;
 }
 
 bool
 array_property::validate (const octave_value& v)
 {
   bool xok = false;
@@ -899,124 +899,124 @@ array_property::validate (const octave_v
 }
 
 bool
 array_property::is_equal (const octave_value& v) const
 {
   if (data.type_name () == v.type_name ())
     {
       if (data.dims () == v.dims ())
-	{
+        {
 
 #define CHECK_ARRAY_EQUAL(T,F,A) \
-	    { \
-	      if (data.numel () == 1) \
-		return data.F ## scalar_value () == \
-		  v.F ## scalar_value (); \
-	      else  \
-		{ \
+            { \
+              if (data.numel () == 1) \
+                return data.F ## scalar_value () == \
+                  v.F ## scalar_value (); \
+              else  \
+                { \
                   /* Keep copy of array_value to allow sparse/bool arrays */ \
-		  /* that are converted, to not be deallocated early */ \
-		  const A m1 = data.F ## array_value (); \
-		  const T* d1 = m1.data (); \
-		  const A m2 = v.F ## array_value (); \
-		  const T* d2 = m2.data ();\
-		  \
-		  bool flag = true; \
-		  \
-		  for (int i = 0; flag && i < data.numel (); i++) \
-		    if (d1[i] != d2[i]) \
-		      flag = false; \
-		  \
-		  return flag; \
-		} \
-	    }
-
-	  if (data.is_double_type() || data.is_bool_type ())
-	    CHECK_ARRAY_EQUAL (double, , NDArray)
-	  else if (data.is_single_type ())
-	    CHECK_ARRAY_EQUAL (float, float_, FloatNDArray)
-	  else if (data.is_int8_type ())
-	    CHECK_ARRAY_EQUAL (octave_int8, int8_, int8NDArray)
-	  else if (data.is_int16_type ())
-	    CHECK_ARRAY_EQUAL (octave_int16, int16_, int16NDArray)
-	  else if (data.is_int32_type ())
-	    CHECK_ARRAY_EQUAL (octave_int32, int32_, int32NDArray)
-	  else if (data.is_int64_type ())
-	    CHECK_ARRAY_EQUAL (octave_int64, int64_, int64NDArray)
-	  else if (data.is_uint8_type ())
-	    CHECK_ARRAY_EQUAL (octave_uint8, uint8_, uint8NDArray)
-	  else if (data.is_uint16_type ())
-	    CHECK_ARRAY_EQUAL (octave_uint16, uint16_, uint16NDArray)
-	  else if (data.is_uint32_type ())
-	    CHECK_ARRAY_EQUAL (octave_uint32, uint32_, uint32NDArray)
-	  else if (data.is_uint64_type ())
-	    CHECK_ARRAY_EQUAL (octave_uint64, uint64_, uint64NDArray)
-	}
+                  /* that are converted, to not be deallocated early */ \
+                  const A m1 = data.F ## array_value (); \
+                  const T* d1 = m1.data (); \
+                  const A m2 = v.F ## array_value (); \
+                  const T* d2 = m2.data ();\
+                  \
+                  bool flag = true; \
+                  \
+                  for (int i = 0; flag && i < data.numel (); i++) \
+                    if (d1[i] != d2[i]) \
+                      flag = false; \
+                  \
+                  return flag; \
+                } \
+            }
+
+          if (data.is_double_type() || data.is_bool_type ())
+            CHECK_ARRAY_EQUAL (double, , NDArray)
+          else if (data.is_single_type ())
+            CHECK_ARRAY_EQUAL (float, float_, FloatNDArray)
+          else if (data.is_int8_type ())
+            CHECK_ARRAY_EQUAL (octave_int8, int8_, int8NDArray)
+          else if (data.is_int16_type ())
+            CHECK_ARRAY_EQUAL (octave_int16, int16_, int16NDArray)
+          else if (data.is_int32_type ())
+            CHECK_ARRAY_EQUAL (octave_int32, int32_, int32NDArray)
+          else if (data.is_int64_type ())
+            CHECK_ARRAY_EQUAL (octave_int64, int64_, int64NDArray)
+          else if (data.is_uint8_type ())
+            CHECK_ARRAY_EQUAL (octave_uint8, uint8_, uint8NDArray)
+          else if (data.is_uint16_type ())
+            CHECK_ARRAY_EQUAL (octave_uint16, uint16_, uint16NDArray)
+          else if (data.is_uint32_type ())
+            CHECK_ARRAY_EQUAL (octave_uint32, uint32_, uint32NDArray)
+          else if (data.is_uint64_type ())
+            CHECK_ARRAY_EQUAL (octave_uint64, uint64_, uint64NDArray)
+        }
     }
 
   return false;
 }
 
 void
 array_property::get_data_limits (void)
 {
   xmin = xminp = octave_Inf;
   xmax = -octave_Inf;
 
   if (! data.is_empty ())
     {
       if (data.is_integer_type ())
-	{
-	  if (data.is_int8_type ())
-	    get_array_limits (data.int8_array_value (), xmin, xmax, xminp);
-	  else if (data.is_uint8_type ())
-	    get_array_limits (data.uint8_array_value (), xmin, xmax, xminp);
-	  else if (data.is_int16_type ())
-	    get_array_limits (data.int16_array_value (), xmin, xmax, xminp);
-	  else if (data.is_uint16_type ())
-	    get_array_limits (data.uint16_array_value (), xmin, xmax, xminp);
-	  else if (data.is_int32_type ())
-	    get_array_limits (data.int32_array_value (), xmin, xmax, xminp);
-	  else if (data.is_uint32_type ())
-	    get_array_limits (data.uint32_array_value (), xmin, xmax, xminp);
-	  else if (data.is_int64_type ())
-	    get_array_limits (data.int64_array_value (), xmin, xmax, xminp);
-	  else if (data.is_uint64_type ())
-	    get_array_limits (data.uint64_array_value (), xmin, xmax, xminp);
-	}
+        {
+          if (data.is_int8_type ())
+            get_array_limits (data.int8_array_value (), xmin, xmax, xminp);
+          else if (data.is_uint8_type ())
+            get_array_limits (data.uint8_array_value (), xmin, xmax, xminp);
+          else if (data.is_int16_type ())
+            get_array_limits (data.int16_array_value (), xmin, xmax, xminp);
+          else if (data.is_uint16_type ())
+            get_array_limits (data.uint16_array_value (), xmin, xmax, xminp);
+          else if (data.is_int32_type ())
+            get_array_limits (data.int32_array_value (), xmin, xmax, xminp);
+          else if (data.is_uint32_type ())
+            get_array_limits (data.uint32_array_value (), xmin, xmax, xminp);
+          else if (data.is_int64_type ())
+            get_array_limits (data.int64_array_value (), xmin, xmax, xminp);
+          else if (data.is_uint64_type ())
+            get_array_limits (data.uint64_array_value (), xmin, xmax, xminp);
+        }
       else
-	get_array_limits (data.array_value (), xmin, xmax, xminp);
+        get_array_limits (data.array_value (), xmin, xmax, xminp);
     }
 }
 
 bool
 handle_property::do_set (const octave_value& v)
 {
   double dv = v.double_value ();
 
   if (! error_state)
     {
       graphics_handle gh = gh_manager::lookup (dv);
 
       if (xisnan (gh.value ()) || gh.ok ())
-	{
-	  if (current_val != gh)
-	    {
-	      current_val = gh;
-	      return true;
-	    }
-	}
+        {
+          if (current_val != gh)
+            {
+              current_val = gh;
+              return true;
+            }
+        }
       else
         error ("set: invalid graphics handle (= %g) for property \"%s\"",
-	       dv, get_name ().c_str ());
+               dv, get_name ().c_str ());
     }
   else
     error ("set: invalid graphics handle for property \"%s\"",
-	   get_name ().c_str ());
+           get_name ().c_str ());
 
   return false;
 }
 
 bool
 callback_property::validate (const octave_value& v) const
 {
   // case 1: function handle
@@ -1048,159 +1048,159 @@ callback_property::execute (const octave
 }
 
 // Used to cache dummy graphics objects from which dynamic
 // properties can be cloned.
 static std::map<caseless_str, graphics_object> dprop_obj_map;
 
 property
 property::create (const std::string& name, const graphics_handle& h,
-		  const caseless_str& type, const octave_value_list& args)
+                  const caseless_str& type, const octave_value_list& args)
 {
   property retval;
 
   if (type.compare ("string"))
     {
       std::string val = (args.length () > 0 ? args(0).string_value () : "");
 
       if (! error_state)
-	retval = property (new string_property (name, h, val));
+        retval = property (new string_property (name, h, val));
     }
   else if (type.compare ("any"))
     {
       octave_value val =
-	  (args.length () > 0 ? args(0) : octave_value (Matrix ()));
+          (args.length () > 0 ? args(0) : octave_value (Matrix ()));
 
       retval = property (new any_property (name, h, val));
     }
   else if (type.compare ("radio"))
     {
       if (args.length () > 0)
-	{
-	  std::string vals = args(0).string_value ();
-
-	  if (! error_state)
-	    {
-	      retval = property (new radio_property (name, h, vals));
-
-	      if (args.length () > 1)
-		retval.set (args(1));
-	    }
-	  else
-	    error ("addproperty: invalid argument for radio property, expected a string value");
-	}
+        {
+          std::string vals = args(0).string_value ();
+
+          if (! error_state)
+            {
+              retval = property (new radio_property (name, h, vals));
+
+              if (args.length () > 1)
+                retval.set (args(1));
+            }
+          else
+            error ("addproperty: invalid argument for radio property, expected a string value");
+        }
       else
-	error ("addproperty: missing possible values for radio property");
+        error ("addproperty: missing possible values for radio property");
     }
   else if (type.compare ("double"))
     {
       double d = (args.length () > 0 ? args(0).double_value () : 0);
 
       if (! error_state)
-	retval = property (new double_property (name, h, d));
+        retval = property (new double_property (name, h, d));
     }
   else if (type.compare ("handle"))
     {
       double hh = (args.length () > 0 ? args(0).double_value () : octave_NaN);
 
       if (! error_state)
-	{
-	  graphics_handle gh (hh);
-
-	  retval = property (new handle_property (name, h, gh));
-	}
+        {
+          graphics_handle gh (hh);
+
+          retval = property (new handle_property (name, h, gh));
+        }
     }
   else if (type.compare ("boolean"))
     {
       retval = property (new bool_property (name, h, false));
 
       if (args.length () > 0)
-	retval.set (args(0));
+        retval.set (args(0));
     }
   else if (type.compare ("data"))
     {
       retval = property (new array_property (name, h, Matrix ()));
 
       if (args.length () > 0)
-	{
-	  retval.set (args(0));
-
-	  // FIXME -- additional argument could define constraints,
-	  // but is this really useful?
-	}
+        {
+          retval.set (args(0));
+
+          // FIXME -- additional argument could define constraints,
+          // but is this really useful?
+        }
     }
   else if (type.compare ("color"))
     {
       color_values cv (0, 0, 0);
       radio_values rv;
 
       if (args.length () > 1)
-	rv = radio_values (args(1).string_value ());
+        rv = radio_values (args(1).string_value ());
 
       if (! error_state)
-	{
-	  retval = property (new color_property (name, h, cv, rv));
-
-	  if (! error_state)
-	    {
-	      if (args.length () > 0 && ! args(0).is_empty ())
-		retval.set (args(0));
-	      else
-		retval.set (rv.default_value ());
-	    }
-	}
+        {
+          retval = property (new color_property (name, h, cv, rv));
+
+          if (! error_state)
+            {
+              if (args.length () > 0 && ! args(0).is_empty ())
+                retval.set (args(0));
+              else
+                retval.set (rv.default_value ());
+            }
+        }
     }
   else
     {
       caseless_str go_name, go_rest;
 
       if (lookup_object_name (type, go_name, go_rest))
-	{
-	  graphics_object go;
-
-	  std::map<caseless_str, graphics_object>::const_iterator it =
-	      dprop_obj_map.find (go_name);
-
-	  if (it == dprop_obj_map.end ())
-	    {
-	      base_graphics_object *bgo =
-		  make_graphics_object_from_type (go_name);
-
-	      if (bgo)
-		{
-		  go = graphics_object (bgo);
-
-		  dprop_obj_map[go_name] = go;
-		}
-	    }
-	  else
-	    go = it->second;
-
-	  if (go.valid_object ())
-	    {
-	      property prop = go.get_properties ().get_property (go_rest);
-
-	      if (! error_state)
-		{
-		  retval = prop.clone ();
-
-		  retval.set_parent (h);
-		  retval.set_name (name);
-
-		  if (args.length () > 0)
-		    retval.set (args(0));
-		}
-	    }
-	  else
-	    error ("addproperty: invalid object type (= %s)",
-		   go_name.c_str ());
-	}
+        {
+          graphics_object go;
+
+          std::map<caseless_str, graphics_object>::const_iterator it =
+              dprop_obj_map.find (go_name);
+
+          if (it == dprop_obj_map.end ())
+            {
+              base_graphics_object *bgo =
+                  make_graphics_object_from_type (go_name);
+
+              if (bgo)
+                {
+                  go = graphics_object (bgo);
+
+                  dprop_obj_map[go_name] = go;
+                }
+            }
+          else
+            go = it->second;
+
+          if (go.valid_object ())
+            {
+              property prop = go.get_properties ().get_property (go_rest);
+
+              if (! error_state)
+                {
+                  retval = prop.clone ();
+
+                  retval.set_parent (h);
+                  retval.set_name (name);
+
+                  if (args.length () > 0)
+                    retval.set (args(0));
+                }
+            }
+          else
+            error ("addproperty: invalid object type (= %s)",
+                   go_name.c_str ());
+        }
       else
-	error ("addproperty: unsupported type for dynamic property (= %s)",
-	       type.c_str ());
+        error ("addproperty: unsupported type for dynamic property (= %s)",
+               type.c_str ());
     }
   
   return retval;
 }
 
 // ---------------------------------------------------------------------
 
 void
@@ -1210,92 +1210,92 @@ property_list::set (const caseless_str& 
 
   size_t len = name.length ();
 
   if (len > 4)
     {
       caseless_str pfx = name.substr (0, 4);
 
       if (pfx.compare ("axes") || pfx.compare ("line")
-	  || pfx.compare ("text"))
-	offset = 4;
+          || pfx.compare ("text"))
+        offset = 4;
       else if (len > 5)
-	{
-	  pfx = name.substr (0, 5);
-
-	  if (pfx.compare ("image") || pfx.compare ("patch"))
-	    offset = 5;
-	  else if (len > 6)
-	    {
-	      pfx = name.substr (0, 6);
-
-	      if (pfx.compare ("figure"))
-		offset = 6;
-	      else if (len > 7)
-		{
-		  pfx = name.substr (0, 7);
-
-		  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
-		    offset = 7;
-		}
-	    }
-	}
+        {
+          pfx = name.substr (0, 5);
+
+          if (pfx.compare ("image") || pfx.compare ("patch"))
+            offset = 5;
+          else if (len > 6)
+            {
+              pfx = name.substr (0, 6);
+
+              if (pfx.compare ("figure"))
+                offset = 6;
+              else if (len > 7)
+                {
+                  pfx = name.substr (0, 7);
+
+                  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
+                    offset = 7;
+                }
+            }
+        }
 
       if (offset > 0)
-	{
-	  // FIXME -- should we validate property names and values here?
-
-	  std::string pname = name.substr (offset);
-
-	  std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
-	  std::transform (pname.begin (), pname.end (), pname.begin (), tolower);
-
-	  bool has_property = false;
-	  if (pfx == "axes")
-	    has_property = axes::properties::has_core_property (pname);
-	  else if (pfx == "line")
-	    has_property = line::properties::has_core_property (pname);
-	  else if (pfx == "text")
-	    has_property = text::properties::has_core_property (pname);
-	  else if (pfx == "image")
-	    has_property = image::properties::has_core_property (pname);
-	  else if (pfx == "patch")
-	    has_property = patch::properties::has_core_property (pname);
-	  else if (pfx == "figure")
-	    has_property = figure::properties::has_core_property (pname);
-	  else if (pfx == "surface")
-	    has_property = surface::properties::has_core_property (pname);
-	  else if (pfx == "hggroup")
-	    has_property = hggroup::properties::has_core_property (pname);
-
-	  if (has_property)
-	    {
-	      bool remove = false;
-	      if (val.is_string ())
-		{
-		  caseless_str tval = val.string_value ();
-
-		  remove = tval.compare ("remove");
-		}
-
-	      pval_map_type& pval_map = plist_map[pfx];
-
-	      if (remove)
-		{
-		  pval_map_iterator p = pval_map.find (pname);
-
-		  if (p != pval_map.end ())
-		    pval_map.erase (p);
-		}
-	      else
-		pval_map[pname] = val;
-	    }
-	  else
-	    error ("invalid %s property `%s'", pfx.c_str (), pname.c_str ());
-	}
+        {
+          // FIXME -- should we validate property names and values here?
+
+          std::string pname = name.substr (offset);
+
+          std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
+          std::transform (pname.begin (), pname.end (), pname.begin (), tolower);
+
+          bool has_property = false;
+          if (pfx == "axes")
+            has_property = axes::properties::has_core_property (pname);
+          else if (pfx == "line")
+            has_property = line::properties::has_core_property (pname);
+          else if (pfx == "text")
+            has_property = text::properties::has_core_property (pname);
+          else if (pfx == "image")
+            has_property = image::properties::has_core_property (pname);
+          else if (pfx == "patch")
+            has_property = patch::properties::has_core_property (pname);
+          else if (pfx == "figure")
+            has_property = figure::properties::has_core_property (pname);
+          else if (pfx == "surface")
+            has_property = surface::properties::has_core_property (pname);
+          else if (pfx == "hggroup")
+            has_property = hggroup::properties::has_core_property (pname);
+
+          if (has_property)
+            {
+              bool remove = false;
+              if (val.is_string ())
+                {
+                  caseless_str tval = val.string_value ();
+
+                  remove = tval.compare ("remove");
+                }
+
+              pval_map_type& pval_map = plist_map[pfx];
+
+              if (remove)
+                {
+                  pval_map_iterator p = pval_map.find (pname);
+
+                  if (p != pval_map.end ())
+                    pval_map.erase (p);
+                }
+              else
+                pval_map[pname] = val;
+            }
+          else
+            error ("invalid %s property `%s'", pfx.c_str (), pname.c_str ());
+        }
     }
 
   if (! error_state && offset == 0)
     error ("invalid default property specification");
 }
 
 octave_value
 property_list::lookup (const caseless_str& name) const
@@ -1306,59 +1306,59 @@ property_list::lookup (const caseless_st
 
   size_t len = name.length ();
 
   if (len > 4)
     {
       caseless_str pfx = name.substr (0, 4);
 
       if (pfx.compare ("axes") || pfx.compare ("line")
-	  || pfx.compare ("text"))
-	offset = 4;
+          || pfx.compare ("text"))
+        offset = 4;
       else if (len > 5)
-	{
-	  pfx = name.substr (0, 5);
-
-	  if (pfx.compare ("image") || pfx.compare ("patch"))
-	    offset = 5;
-	  else if (len > 6)
-	    {
-	      pfx = name.substr (0, 6);
-
-	      if (pfx.compare ("figure"))
-		offset = 6;
-	      else if (len > 7)
-		{
-		  pfx = name.substr (0, 7);
-
-		  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
-		    offset = 7;
-		}
-	    }
-	}
+        {
+          pfx = name.substr (0, 5);
+
+          if (pfx.compare ("image") || pfx.compare ("patch"))
+            offset = 5;
+          else if (len > 6)
+            {
+              pfx = name.substr (0, 6);
+
+              if (pfx.compare ("figure"))
+                offset = 6;
+              else if (len > 7)
+                {
+                  pfx = name.substr (0, 7);
+
+                  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
+                    offset = 7;
+                }
+            }
+        }
 
       if (offset > 0)
-	{
-	  std::string pname = name.substr (offset);
-
-	  std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
-	  std::transform (pname.begin (), pname.end (), pname.begin (), tolower);
-
-	  plist_map_const_iterator p = find (pfx);
-
-	  if (p != end ())
-	    {
-	      const pval_map_type& pval_map = p->second;
-
-	      pval_map_const_iterator q = pval_map.find (pname);
-
-	      if (q != pval_map.end ())
-		retval = q->second;
-	    }
-	}
+        {
+          std::string pname = name.substr (offset);
+
+          std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
+          std::transform (pname.begin (), pname.end (), pname.begin (), tolower);
+
+          plist_map_const_iterator p = find (pfx);
+
+          if (p != end ())
+            {
+              const pval_map_type& pval_map = p->second;
+
+              pval_map_const_iterator q = pval_map.find (pname);
+
+              if (q != pval_map.end ())
+                retval = q->second;
+            }
+        }
     }
 
   return retval;
 }
 
 Octave_map
 property_list::as_struct (const std::string& prefix_arg) const
 {
@@ -1366,67 +1366,67 @@ property_list::as_struct (const std::str
 
   for (plist_map_const_iterator p = begin (); p != end (); p++)
     {
       std::string prefix = prefix_arg + p->first;
 
       const pval_map_type pval_map = p->second;
 
       for (pval_map_const_iterator q = pval_map.begin ();
-	   q != pval_map.end ();
-	   q++)
-	m.assign (prefix + q->first, q->second);
+           q != pval_map.end ();
+           q++)
+        m.assign (prefix + q->first, q->second);
     }
 
   return m;    
 }
 
 graphics_handle::graphics_handle (const octave_value& a)
   : val (octave_NaN)
 {
   if (a.is_empty ())
     /* do nothing */;
   else
     {
       double tval = a.double_value ();
 
       if (! error_state)
-	val = tval;
+        val = tval;
       else
-	error ("invalid graphics handle");
+        error ("invalid graphics handle");
     }
 }
 
 // Set properties given as a cs-list of name, value pairs.
 
 void
 graphics_object::set (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   if (nargin == 0)
     rep->defaults ();
   else if (nargin % 2 == 0)
     {
       for (int i = 0; i < nargin; i += 2)
-	{
-	  caseless_str name = args(i).string_value ();
-
-	  if (! error_state)
-	    {
-	      octave_value val = args(i+1);
+        {
+          caseless_str name = args(i).string_value ();
+
+          if (! error_state)
+            {
+              octave_value val = args(i+1);
 
               set_value_or_default (name, val);
 
-	      if (error_state)
-		break;
-	    }
-	  else
-	    error ("set: expecting argument %d to be a property name", i);
-	}
+              if (error_state)
+                break;
+            }
+          else
+            error ("set: expecting argument %d to be a property name", i);
+        }
     }
   else
     error ("set: invalid number of arguments");
 }
 
 /*
 %!# test set with name, value pairs
 %!test
@@ -1591,88 +1591,88 @@ gh_manager::get_handle (const std::strin
       // Figure handles are positive integers corresponding to the
       // figure number.
 
       // We always want the lowest unused figure number.
 
       retval = 1;
 
       while (handle_map.find (retval) != handle_map.end ())
-	retval++;
+        retval++;
     }
   else
     {
       // Other graphics handles are negative integers plus some random
       // fractional part.  To avoid running out of integers, we
       // recycle the integer part but tack on a new random part each
       // time.
 
       free_list_iterator p = handle_free_list.begin ();
 
       if (p != handle_free_list.end ())
-	{
-	  retval = *p;
-	  handle_free_list.erase (p);
-	}
+        {
+          retval = *p;
+          handle_free_list.erase (p);
+        }
       else
-	{
-	  retval = graphics_handle (next_handle);
-
-	  next_handle = ceil (next_handle) - 1.0 - make_handle_fraction ();
-	}
+        {
+          retval = graphics_handle (next_handle);
+
+          next_handle = ceil (next_handle) - 1.0 - make_handle_fraction ();
+        }
     }
 
   return retval;
 }
 
 void
 gh_manager::do_free (const graphics_handle& h)
 {
   if (h.ok ())
     {
       if (h.value () != 0)
-	{
-	  iterator p = handle_map.find (h);
-
-	  if (p != handle_map.end ())
-	    {
-	      base_properties& bp = p->second.get_properties ();
-	      
-	      bp.set_beingdeleted (true);
-
-	      bp.delete_children ();
-
-	      octave_value val = bp.get_deletefcn ();
-
-	      bp.execute_deletefcn ();
-
-	      // notify backend
-	      graphics_backend backend = p->second.get_backend ();
-	      if (backend)
+        {
+          iterator p = handle_map.find (h);
+
+          if (p != handle_map.end ())
+            {
+              base_properties& bp = p->second.get_properties ();
+              
+              bp.set_beingdeleted (true);
+
+              bp.delete_children ();
+
+              octave_value val = bp.get_deletefcn ();
+
+              bp.execute_deletefcn ();
+
+              // notify backend
+              graphics_backend backend = p->second.get_backend ();
+              if (backend)
                 backend.object_destroyed (p->second);
 
-	      // Note: this will be valid only for first explicitly 
-	      // deleted object.  All its children will then have an
-	      // unknown backend.
-
-	      // Graphics handles for non-figure objects are negative
-	      // integers plus some random fractional part.  To avoid
-	      // running out of integers, we recycle the integer part
-	      // but tack on a new random part each time.
-
-	      handle_map.erase (p);
-
-	      if (h.value () < 0)
-		handle_free_list.insert (ceil (h.value ()) - make_handle_fraction ());
-	    }
-	  else
-	    error ("graphics_handle::free: invalid object %g", h.value ());
-	}
+              // Note: this will be valid only for first explicitly 
+              // deleted object.  All its children will then have an
+              // unknown backend.
+
+              // Graphics handles for non-figure objects are negative
+              // integers plus some random fractional part.  To avoid
+              // running out of integers, we recycle the integer part
+              // but tack on a new random part each time.
+
+              handle_map.erase (p);
+
+              if (h.value () < 0)
+                handle_free_list.insert (ceil (h.value ()) - make_handle_fraction ());
+            }
+          else
+            error ("graphics_handle::free: invalid object %g", h.value ());
+        }
       else
-	error ("graphics_handle::free: can't delete root figure");
+        error ("graphics_handle::free: can't delete root figure");
     }
 }
 
 gh_manager *gh_manager::instance = 0;
 
 static void
 xset (const graphics_handle& h, const caseless_str& name,
       const octave_value& val)
@@ -1696,49 +1696,49 @@ static octave_value
 xget (const graphics_handle& h, const caseless_str& name)
 {
   graphics_object obj = gh_manager::get_object (h);
   return obj.get (name);
 }
 
 static graphics_handle
 reparent (const octave_value& ov, const std::string& who,
-	  const std::string& property, const graphics_handle& new_parent,
-	  bool adopt = true)
+          const std::string& property, const graphics_handle& new_parent,
+          bool adopt = true)
 {
   graphics_handle h = octave_NaN;
 
   double val = ov.double_value ();
 
   if (! error_state)
     {
       h = gh_manager::lookup (val);
 
       if (h.ok ())
-	{
-	  graphics_object obj = gh_manager::get_object (h);
-	  
-	  graphics_handle parent_h = obj.get_parent ();
-
-	  graphics_object parent_obj = gh_manager::get_object (parent_h);
-
-	  parent_obj.remove_child (h);
-
-	  if (adopt)
-	    obj.set ("parent", new_parent.value ());
-	  else
-	    obj.reparent (new_parent);
-	}
+        {
+          graphics_object obj = gh_manager::get_object (h);
+          
+          graphics_handle parent_h = obj.get_parent ();
+
+          graphics_object parent_obj = gh_manager::get_object (parent_h);
+
+          parent_obj.remove_child (h);
+
+          if (adopt)
+            obj.set ("parent", new_parent.value ());
+          else
+            obj.reparent (new_parent);
+        }
       else
-	error ("%s: invalid graphics handle (= %g) for %s",
-	       who.c_str (), val, property.c_str ());
+        error ("%s: invalid graphics handle (= %g) for %s",
+               who.c_str (), val, property.c_str ());
     }
   else
     error ("%s: expecting %s to be a graphics handle",
-	   who.c_str (), property.c_str ());
+           who.c_str (), property.c_str ());
 
   return h;
 }
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
@@ -1783,31 +1783,31 @@ is_handle (const octave_value& val)
 {
   octave_value retval = false;
 
   if (val.is_real_scalar () && is_handle (val.double_value ()))
     retval = true;
   else if (val.is_real_matrix ())
     {
       if (val.is_string ())
-	retval = boolNDArray (val.dims (), false);
+        retval = boolNDArray (val.dims (), false);
       else
-	{
-	  const NDArray handles = val.array_value ();
-
-	  if (! error_state)
-	    {
-	      boolNDArray result (handles.dims ());
-
-	      for (octave_idx_type i = 0; i < handles.numel (); i++)
-		result.xelem (i) = is_handle (handles (i));
-
-	      retval = result;
-	    }
-	}
+        {
+          const NDArray handles = val.array_value ();
+
+          if (! error_state)
+            {
+              boolNDArray result (handles.dims ());
+
+              for (octave_idx_type i = 0; i < handles.numel (); i++)
+                result.xelem (i) = is_handle (handles (i));
+
+              retval = result;
+            }
+        }
     }
 
   return retval;
 }
 
 static bool
 is_figure (double val)
 {
@@ -1847,40 +1847,40 @@ base_graphics_backend::object_destroyed 
   graphics_object go = gh_manager::get_object (h);
 
   object_destroyed (go);
 }
 // ---------------------------------------------------------------------
 
 void
 base_properties::set_from_list (base_graphics_object& obj,
-				property_list& defaults)
+                                property_list& defaults)
 {
   std::string go_name = graphics_object_name ();
 
   property_list::plist_map_const_iterator p = defaults.find (go_name);
 
   if (p != defaults.end ())
     {
       const property_list::pval_map_type pval_map = p->second;
 
       for (property_list::pval_map_const_iterator q = pval_map.begin ();
-	   q != pval_map.end ();
-	   q++)
-	{
-	  std::string pname = q->first;
-
-	  obj.set (pname, q->second);
-
-	  if (error_state)
-	    {
-	      error ("error setting default property %s", pname.c_str ());
-	      break;
-	    }
-	}
+           q != pval_map.end ();
+           q++)
+        {
+          std::string pname = q->first;
+
+          obj.set (pname, q->second);
+
+          if (error_state)
+            {
+              error ("error setting default property %s", pname.c_str ());
+              break;
+            }
+        }
     }
 }
 
 octave_value
 base_properties::get_dynamic (const caseless_str& name) const
 {
   octave_value retval;
 
@@ -1918,17 +1918,17 @@ base_properties::has_dynamic_property (c
 {
   const std::set<std::string>& dynprops = dynamic_property_names ();
 
   return dynprops.find (pname) != dynprops.end ();
 }
 
 void
 base_properties::set_dynamic (const caseless_str& pname,
-			      const octave_value& val)
+                              const octave_value& val)
 {
   std::map<caseless_str, property, cmp_caseless_str>::iterator it = all_props.find (pname);
 
   if (it != all_props.end ())
     it->second.set (val);
   else
     error ("set: unknown property \"%s\"", pname.c_str ());
 
@@ -1957,31 +1957,31 @@ base_properties::get_property_dynamic (c
 void
 base_properties::remove_child (const graphics_handle& h)
 {
   octave_idx_type k = -1;
   octave_idx_type n = children.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (h.value () == children(i))
-	{
-	  k = i;
-	  break;
-	}
+        {
+          k = i;
+          break;
+        }
     }
 
   if (k >= 0)
     {
       Matrix new_kids (n-1, 1);
       octave_idx_type j = 0;
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  if (i != k)
-	    new_kids(j++) = children(i);
-	}
+        {
+          if (i != k)
+            new_kids(j++) = children(i);
+        }
       children = new_kids;
       mark_modified ();
     }
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
@@ -1989,27 +1989,27 @@ base_properties::set_parent (const octav
 
   graphics_handle new_parent = octave_NaN;
 
   if (! error_state)
     {
       new_parent = gh_manager::lookup (tmp);
 
       if (new_parent.ok ())
-	{
-	  graphics_object parent_obj = gh_manager::get_object (get_parent ());
-
-	  parent_obj.remove_child (__myhandle__);
-
-	  parent = new_parent.as_octave_value ();
-
-	  ::adopt (parent.handle_value (), __myhandle__);
-	}
+        {
+          graphics_object parent_obj = gh_manager::get_object (get_parent ());
+
+          parent_obj.remove_child (__myhandle__);
+
+          parent = new_parent.as_octave_value ();
+
+          ::adopt (parent.handle_value (), __myhandle__);
+        }
       else
-	error ("set: invalid graphics handle (= %g) for parent", tmp);
+        error ("set: invalid graphics handle (= %g) for parent", tmp);
     }
   else
     error ("set: expecting parent to be a graphics handle");
 }
 
 void
 base_properties::set_children (const octave_value& val)
 {
@@ -2021,28 +2021,28 @@ base_properties::set_children (const oct
 
   bool ok = true;
 
   if (! error_state)
     {
       const Matrix visible_kids = get_children ();
 
       if (visible_kids.numel () == new_kids.numel ())
-	{
-	  Matrix t1 = visible_kids.sort ();
-	  Matrix t2 = new_kids_column.sort ();
-
-	  if (t1 != t2)
-	    ok = false;
-	}
+        {
+          Matrix t1 = visible_kids.sort ();
+          Matrix t2 = new_kids_column.sort ();
+
+          if (t1 != t2)
+            ok = false;
+        }
       else
-	ok = false;
+        ok = false;
 
       if (! ok)
-	error ("set: new children must be a permutation of existing children");
+        error ("set: new children must be a permutation of existing children");
     }
   else
     {
       ok = false;
       error ("set: expecting children to be array of graphics handles");
     }
 
   if (ok)
@@ -2083,17 +2083,17 @@ base_properties::delete_children (void)
 
   // A callback function might have already deleted the child,
   // so check before deleting
   for (octave_idx_type i = 0; i < n; i++)
     {
       graphics_object go = gh_manager::get_object (children(i));
 
       if (go.valid_object ())
-	gh_manager::free (children(i));
+        gh_manager::free (children(i));
     }
 }
 
 graphics_backend
 base_properties::get_backend (void) const
 {
   graphics_object go = gh_manager::get_object (get_parent ());
 
@@ -2108,33 +2108,33 @@ base_properties::update_boundingbox (voi
 {
   Matrix kids = get_children ();
 
   for (int i = 0; i < kids.numel (); i++)
     {
       graphics_object go = gh_manager::get_object (kids(i));
 
       if (go.valid_object ())
-	go.get_properties ().update_boundingbox ();
+        go.get_properties ().update_boundingbox ();
     }
 }
 
 void
 base_properties::add_listener (const caseless_str& nm, const octave_value& v,
-			       listener_mode mode)
+                               listener_mode mode)
 {
   property p = get_property (nm);
 
   if (! error_state && p.ok ())
     p.add_listener (v, mode);
 }
 
 void
 base_properties::delete_listener (const caseless_str& nm, 
-				  const octave_value& v, listener_mode mode)
+                                  const octave_value& v, listener_mode mode)
 {
   property p = get_property (nm);
 
   if (! error_state && p.ok ())
     p.delete_listener (v, mode);
 }
 
 // ---------------------------------------------------------------------
@@ -2147,61 +2147,61 @@ public:
 
   ~gnuplot_backend (void) { }
 
   bool is_valid (void) const { return true; }
 
   void object_destroyed (const graphics_object& go)
     {
       if (go.isa ("figure"))
-	{
-	  const figure::properties& props =
-	      dynamic_cast<const figure::properties&> (go.get_properties ());
-
-	  send_quit (props.get___plot_stream__ ());
-	}
+        {
+          const figure::properties& props =
+              dynamic_cast<const figure::properties&> (go.get_properties ());
+
+          send_quit (props.get___plot_stream__ ());
+        }
     }
 
   void property_changed (const graphics_object& go, int id)
     {
       if (go.isa ("figure"))
-	{
-	  graphics_object obj (go);
-
-	  figure::properties& props =
-	      dynamic_cast<figure::properties&> (obj.get_properties ());
-
-	  switch (id)
-	    {
-	    case base_properties::VISIBLE:
-	      if (! props.is_visible ())
-		{
-		  send_quit (props.get___plot_stream__ ());
-		  props.set___plot_stream__ (Matrix ());
-		  props.set___enhanced__ (false);
-		}
-	      break;
-	    }
-	}
+        {
+          graphics_object obj (go);
+
+          figure::properties& props =
+              dynamic_cast<figure::properties&> (obj.get_properties ());
+
+          switch (id)
+            {
+            case base_properties::VISIBLE:
+              if (! props.is_visible ())
+                {
+                  send_quit (props.get___plot_stream__ ());
+                  props.set___plot_stream__ (Matrix ());
+                  props.set___enhanced__ (false);
+                }
+              break;
+            }
+        }
     }
 
   void redraw_figure (const graphics_object& go) const
     {
       octave_value_list args;
       args(0) = go.get_handle ().as_octave_value ();
       feval ("gnuplot_drawnow", args);
     }
 
   void print_figure (const graphics_object& go, const std::string& term,
-		     const std::string& file, bool mono,
-		     const std::string& debug_file) const
+                     const std::string& file, bool mono,
+                     const std::string& debug_file) const
     {
       octave_value_list args;
       if (! debug_file.empty ())
-	args(4) = debug_file;
+        args(4) = debug_file;
       args(3) = mono;
       args(2) = file;
       args(1) = term;
       args(0) = go.get_handle ().as_octave_value ();
       feval ("gnuplot_drawnow", args);
     }
 
   Matrix get_canvas_size (const graphics_handle&) const
@@ -2215,43 +2215,43 @@ public:
 
   Matrix get_screen_size (void) const
     { return Matrix (1, 2, 0.0); }
 
 private:
   void send_quit (const octave_value& pstream) const
     {
       if (! pstream.is_empty ())
-	{
-	  octave_value_list args;
-	  Matrix fids = pstream.matrix_value ();
-
-	  if (! error_state)
-	    {
-	      args(1) = "\nquit;\n";
-	      args(0) = fids(0);
-	      feval ("fputs", args);
-
-	      args.resize (1);
-	      feval ("fflush", args);
-	      feval ("pclose", args);
-
-	      if (fids.numel () > 1)
-		{
-		  args(0) = fids(1);
-		  feval ("pclose", args);
-
-		  if (fids.numel () > 2)
-		    {
-		      args(0) = fids(2);
-		      feval ("waitpid", args);
-		    }
-		}
-	    }
-	}
+        {
+          octave_value_list args;
+          Matrix fids = pstream.matrix_value ();
+
+          if (! error_state)
+            {
+              args(1) = "\nquit;\n";
+              args(0) = fids(0);
+              feval ("fputs", args);
+
+              args.resize (1);
+              feval ("fflush", args);
+              feval ("pclose", args);
+
+              if (fids.numel () > 1)
+                {
+                  args(0) = fids(1);
+                  feval ("pclose", args);
+
+                  if (fids.numel () > 2)
+                    {
+                      args(0) = fids(2);
+                      feval ("waitpid", args);
+                    }
+                }
+            }
+        }
     }
 };
 
 graphics_backend
 graphics_backend::default_backend (void)
 {
   if (available_backends.size () == 0)
     register_backend (new gnuplot_backend ());
@@ -2266,17 +2266,17 @@ std::map<std::string, graphics_backend> 
 void
 base_graphics_object::update_axis_limits (const std::string& axis_type)
 {
   if (valid_object ())
     {
       graphics_object parent_obj = gh_manager::get_object (get_parent ());
 
       if (parent_obj)
-	parent_obj.update_axis_limits (axis_type);
+        parent_obj.update_axis_limits (axis_type);
     }
   else
     error ("base_graphics_object::update_axis_limits: invalid graphics object");
 }
 
 void
 base_graphics_object::remove_all_listeners (void)
 {
@@ -2293,17 +2293,17 @@ base_graphics_object::remove_all_listene
       frame.protect_var (discard_error_messages);
       frame.protect_var (error_state);
 
       discard_error_messages = true;
 
       property p = get_properties ().get_property (pa->first);
 
       if (! error_state && p.ok ())
-	p.delete_listener ();
+        p.delete_listener ();
     }
 }
 
 // ---------------------------------------------------------------------
 
 #include "graphics-props.cc"
 
 // ---------------------------------------------------------------------
@@ -2332,28 +2332,28 @@ root_figure::properties::set_callbackobj
   graphics_handle val (v);
 
   if (error_state)
     return;
 
   if (xisnan (val.value ()))
     {
       if (! cbo_stack.empty ())
-	{
-	  val = cbo_stack.front ();
-
-	  cbo_stack.pop_front ();
-	}
+        {
+          val = cbo_stack.front ();
+
+          cbo_stack.pop_front ();
+        }
 
       callbackobject = val;
     }
   else if (is_handle (val))
     {
       if (get_callbackobject ().ok ())
-	cbo_stack.push_front (get_callbackobject ());
+        cbo_stack.push_front (get_callbackobject ());
 
       callbackobject = val;
     }
   else
     gripe_set_invalid ("callbackobject");
 }
 
 void
@@ -2430,54 +2430,54 @@ figure::properties::remove_child (const 
 {
   base_properties::remove_child (gh);
 
   if (gh == currentaxes.handle_value ())
     {
       graphics_handle new_currentaxes;
 
       for (octave_idx_type i = 0; i < children.numel (); i++)
-	{
-	  graphics_handle kid = children(i);
-
-	  graphics_object go = gh_manager::get_object (kid);
-
-	  if (go.isa ("axes"))
-	    {
-	      new_currentaxes = kid;
-	      break;
-	    }
-	}
+        {
+          graphics_handle kid = children(i);
+
+          graphics_object go = gh_manager::get_object (kid);
+
+          if (go.isa ("axes"))
+            {
+              new_currentaxes = kid;
+              break;
+            }
+        }
 
       currentaxes = new_currentaxes;
     }
 }
 
 void
 figure::properties::set_visible (const octave_value& val)
 {
   std::string s = val.string_value ();
 
   if (! error_state)
     {
       if (s == "on")
-	xset (0, "currentfigure", __myhandle__.value ());
+        xset (0, "currentfigure", __myhandle__.value ());
 
       visible = val;
     }
 }
 
 Matrix
 figure::properties::get_boundingbox (bool) const
 {
   Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
   Matrix pos;
 
   pos = convert_position (get_position ().matrix_value (), get_units (),
-			  "pixels", screen_size);
+                          "pixels", screen_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = screen_size(1) - pos(1) - pos(3);
 
   return pos;
 }
 
@@ -2502,39 +2502,39 @@ figure::properties::set_position (const 
     {
       Matrix old_bb, new_bb;
 
       old_bb = get_boundingbox ();
       position = v;
       new_bb = get_boundingbox ();
 
       if (old_bb != new_bb)
-	{
-	  if (old_bb(2) != new_bb(2) || old_bb(3) != new_bb(3))
-	    {
-	      execute_resizefcn ();
-	      update_boundingbox ();
-	    }
-	}
+        {
+          if (old_bb(2) != new_bb(2) || old_bb(3) != new_bb(3))
+            {
+              execute_resizefcn ();
+              update_boundingbox ();
+            }
+        }
 
       mark_modified ();
     }
 }
 
 std::string
 figure::properties::get_title (void) const
 {
   if (is_numbertitle ())
     {
       std::ostringstream os;
       std::string nm = get_name ();
 
       os << "Figure " << __myhandle__.value ();
       if (! nm.empty ())
-	os << ": " << get_name ();
+        os << ": " << get_name ();
 
       return os.str ();
     }
   else
     return get_name ();
 }
 
 octave_value
@@ -2654,18 +2654,18 @@ axes::properties::sync_positions (void)
     }
 #endif
 
   update_transform ();
 }
 
 void
 axes::properties::set_text_child (handle_property& hp,
-				  const std::string& who,
-				  const octave_value& v)
+                                  const std::string& who,
+                                  const octave_value& v)
 {
   graphics_handle val;
 
   if (v.is_string ())
     {
       val = gh_manager::make_graphics_handle ("text", __myhandle__, false);
 
       xset (val, "string", v);
@@ -2720,17 +2720,17 @@ axes::properties::set_zlabel (const octa
 void
 axes::properties::set_title (const octave_value& v)
 {
   set_text_child (title, "title", v);
 }
 
 void
 axes::properties::set_defaults (base_graphics_object& obj,
-				const std::string& mode)
+                                const std::string& mode)
 {
   box = "on";
   key = "off";
   keybox = "off";
   keyreverse = "off";
   keypos = 1.0;
   colororder = default_colororder ();
   dataaspectratio = Matrix (1, 3, 1.0);
@@ -2877,17 +2877,17 @@ axes::properties::delete_text_child (han
 {
   graphics_handle h = hp.handle_value ();
 
   if (h.ok ())
     {
       graphics_object go = gh_manager::get_object (h);
 
       if (go.valid_object ())
-	gh_manager::free (h);
+        gh_manager::free (h);
 
       base_properties::remove_child (h);
     }
 
   // FIXME -- is it necessary to check whether the axes object is
   // being deleted now?  I think this function is only called when an
   // individual child object is delete and not when the parent axes
   // object is deleted.
@@ -2927,30 +2927,30 @@ base_properties::get_children_internal (
   root_figure::properties& props =
       dynamic_cast<root_figure::properties&> (go.get_properties ());
 
   if (! props.is_showhiddenhandles ())
     {
       octave_idx_type k = 0;
 
       for (octave_idx_type i = 0; i < children.numel (); i++)
-	{
-	  graphics_handle kid = children (i);
-
-	  if (gh_manager::is_handle_visible (kid))
+        {
+          graphics_handle kid = children (i);
+
+          if (gh_manager::is_handle_visible (kid))
             {
               if (! return_hidden)
                 retval(k++) = children(i);
             }
           else
             {
               if (return_hidden)
                 retval(k++) = children(i);
             }
-	}
+        }
 
       retval.resize (k, 1);
     }
 
   return retval;
 }
 
 Matrix
@@ -3119,21 +3119,21 @@ axes::properties::update_camera (void)
 
   double xo = xlimits(xd > 0 ? 0 : 1);
   double yo = ylimits(yd > 0 ? 0 : 1);
   double zo = zlimits(zd > 0 ? 0 : 1);
   
   Matrix pb  = get_plotboxaspectratio ().matrix_value ();
   
   bool autocam = (camerapositionmode_is ("auto")
-		  && cameratargetmode_is ("auto")
-	    	  && cameraupvectormode_is ("auto")
-		  && cameraviewanglemode_is ("auto"));
+                  && cameratargetmode_is ("auto")
+                  && cameraupvectormode_is ("auto")
+                  && cameraviewanglemode_is ("auto"));
   bool dowarp = (autocam && dataaspectratiomode_is("auto")
-		 && plotboxaspectratiomode_is ("auto"));
+                 && plotboxaspectratiomode_is ("auto"));
 
   ColumnVector c_eye (xform_vector ());
   ColumnVector c_center (xform_vector ());
   ColumnVector c_upv (xform_vector ());
   
   if (cameratargetmode_is ("auto"))
     {
       c_center(0) = (xlimits(0)+xlimits(1))/2;
@@ -3147,46 +3147,46 @@ axes::properties::update_camera (void)
   
   if (camerapositionmode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0), el = tview(1);
       double d = 5*sqrt(pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
 
       if (el == 90 || el == -90)
-	c_eye(2) = d*signum(el);
+        c_eye(2) = d*signum(el);
       else
-	{
-	  az *= M_PI/180.0;
-	  el *= M_PI/180.0;
-	  c_eye(0) = d*cos(el)*sin(az);
-	  c_eye(1) = -d*cos(el)*cos(az);
-	  c_eye(2) = d*sin(el);
-	}
+        {
+          az *= M_PI/180.0;
+          el *= M_PI/180.0;
+          c_eye(0) = d*cos(el)*sin(az);
+          c_eye(1) = -d*cos(el)*cos(az);
+          c_eye(2) = d*sin(el);
+        }
       c_eye(0) = c_eye(0)*(xlimits(1)-xlimits(0))/(xd*pb(0))+c_center(0);
       c_eye(1) = c_eye(1)*(ylimits(1)-ylimits(0))/(yd*pb(1))+c_center(1);
       c_eye(2) = c_eye(2)*(zlimits(1)-zlimits(0))/(zd*pb(2))+c_center(2);
 
       cameraposition = xform2cam (c_eye);
     }
   else
     c_eye = cam2xform (get_cameraposition ().matrix_value ());
 
   if (cameraupvectormode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0), el = tview(1);
 
       if (el == 90 || el == -90)
-	{
-	  c_upv(0) = -sin(az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
-	  c_upv(1) = cos(az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
-	}
+        {
+          c_upv(0) = -sin(az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
+          c_upv(1) = cos(az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
+        }
       else
-	c_upv(2) = 1;
+        c_upv(2) = 1;
 
       cameraupvector = xform2cam (c_upv);
     }
   else
     c_upv = cam2xform (get_cameraupvector ().matrix_value ());
 
   Matrix x_view = xform_matrix ();
   Matrix x_projection = xform_matrix ();
@@ -3195,23 +3195,23 @@ axes::properties::update_camera (void)
   Matrix x_pre = xform_matrix ();
   
   x_render = xform_matrix ();
   x_render_inv = xform_matrix ();
 
   scale (x_pre, pb(0), pb(1), pb(2));
   translate (x_pre, -0.5, -0.5, -0.5);
   scale (x_pre, xd/(xlimits(1)-xlimits(0)), yd/(ylimits(1)-ylimits(0)),
-	 zd/(zlimits(1)-zlimits(0)));
+         zd/(zlimits(1)-zlimits(0)));
   translate (x_pre, -xo, -yo, -zo);
 
   xform (c_eye, x_pre);
   xform (c_center, x_pre);
   scale (c_upv, pb(0)/(xlimits(1)-xlimits(0)), pb(1)/(ylimits(1)-ylimits(0)), 
-	 pb(2)/(zlimits(1)-zlimits(0)));
+         pb(2)/(zlimits(1)-zlimits(0)));
   translate (c_center, -c_eye(0), -c_eye(1), -c_eye(2));
 
   ColumnVector F (c_center), f (F), UP (c_upv);
   normalize (f);
   normalize (UP);
 
   if (std::abs (dot (f, UP)) > 1e-15)
     {
@@ -3273,56 +3273,56 @@ axes::properties::update_camera (void)
       yM *= pf;
       translate (x_viewport, bb(0)+bb(2)/2, bb(1)+bb(3)/2, 0);
       scale (x_viewport, bb(2)/xM, -bb(3)/yM, 1);
     }
   else
     {
       double pix = 1;
       if (autocam)
-	{
-	  if ((bb(2)/bb(3)) > (xM/yM))
-	    pix = bb(3);
-	  else
-	    pix = bb(2);
-	}
+        {
+          if ((bb(2)/bb(3)) > (xM/yM))
+            pix = bb(3);
+          else
+            pix = bb(2);
+        }
       else
-	pix = (bb(2) < bb(3) ? bb(2) : bb(3));
+        pix = (bb(2) < bb(3) ? bb(2) : bb(3));
       translate (x_viewport, bb(0)+bb(2)/2, bb(1)+bb(3)/2, 0);
       scale (x_viewport, pix, -pix, 1);
     }
 
   x_normrender = x_viewport * x_projection * x_view;
 
   x_cube = x_normrender * unit_cube ();
   cmin = x_cube.row_min ();
   cmax = x_cube.row_max ();
   x_zlim.resize (1, 2);
   x_zlim(0) = cmin(2);
   x_zlim(1) = cmax(2);
 
   x_render = x_normrender;
   scale (x_render, xd/(xlimits(1)-xlimits(0)), yd/(ylimits(1)-ylimits(0)),
-	 zd/(zlimits(1)-zlimits(0)));
+         zd/(zlimits(1)-zlimits(0)));
   translate (x_render, -xo, -yo, -zo);
 
   x_viewtransform = x_view;
   x_projectiontransform = x_projection;
   x_viewporttransform = x_viewport;
   x_normrendertransform = x_normrender;
   x_rendertransform = x_render;
 
   x_render_inv = x_render.inverse ();
 
   // Note: these matrices are a slight modified version of the regular
   // matrices, more suited for OpenGL rendering (x_gl_mat1 => light
   // => x_gl_mat2)
   x_gl_mat1 = x_view;
   scale (x_gl_mat1, xd/(xlimits(1)-xlimits(0)), yd/(ylimits(1)-ylimits(0)),
-	 zd/(zlimits(1)-zlimits(0)));
+         zd/(zlimits(1)-zlimits(0)));
   translate (x_gl_mat1, -xo, -yo, -zo);
   x_gl_mat2 = x_viewport * x_projection;
 }
 
 void
 axes::properties::update_aspectratios (void)
 {
   Matrix xlimits = get_xlim ().matrix_value ();
@@ -3343,46 +3343,46 @@ axes::properties::update_aspectratios (v
       da(2) = dz/dmin;
 
       dataaspectratio = da;
     }
 
   if (plotboxaspectratiomode_is ("auto"))
     {
       if (dataaspectratiomode_is ("auto"))
-	plotboxaspectratio = Matrix (1, 3, 1.0);
+        plotboxaspectratio = Matrix (1, 3, 1.0);
       else
-	{
-	  Matrix da = get_dataaspectratio ().matrix_value ();
-	  Matrix pba (1, 3, 0.0);
-
-	  pba(0) = dx/da(0);
-	  pba(1) = dy/da(1);
-	  pba(2) = dz/da(2);
-	}
+        {
+          Matrix da = get_dataaspectratio ().matrix_value ();
+          Matrix pba (1, 3, 0.0);
+
+          pba(0) = dx/da(0);
+          pba(1) = dy/da(1);
+          pba(2) = dz/da(2);
+        }
     }
   
   // FIXME -- if plotboxaspectratiomode is "manual", limits
   // and/or dataaspectratio might be adapted.
 }
 
 // The INTERNAL flag defines whether position or outerposition is used.
 
 Matrix
 axes::properties::get_boundingbox (bool internal) const
 {
   graphics_object obj = gh_manager::get_object (get_parent ());
   Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
   Matrix pos = (internal ?
-		  get_position ().matrix_value ()
-		  : get_outerposition ().matrix_value ());
+                  get_position ().matrix_value ()
+                  : get_outerposition ().matrix_value ());
 
 
   pos = convert_position (pos, get_units (), "pixels",
-			  parent_bb.extract_n (0, 2, 1, 2));
+                          parent_bb.extract_n (0, 2, 1, 2));
   pos(0)--;
   pos(1)--;
   pos(1) = parent_bb(3) - pos(1) - pos(3);
 
   return pos;
 }
 
 ColumnVector
@@ -3394,31 +3394,31 @@ graphics_xform::xform_vector (double x, 
 Matrix
 graphics_xform::xform_eye (void)
 {
   return ::xform_matrix ();
 }
 
 ColumnVector
 graphics_xform::transform (double x, double y, double z,
-			   bool use_scale) const
+                           bool use_scale) const
 {
   if (use_scale)
     {
       x = sx.scale (x);
       y = sy.scale (y);
       z = sz.scale (z);
     }
 
   return ::transform (xform, x, y, z);
 }
 
 ColumnVector
 graphics_xform::untransform (double x, double y, double z,
-			     bool use_scale) const
+                             bool use_scale) const
 {
   ColumnVector v = ::transform (xform_inv, x, y, z);
 
   if (use_scale)
     {
       v(0) = sx.unscale (v(0));
       v(1) = sy.unscale (v(1));
       v(2) = sz.unscale (v(2));
@@ -3443,54 +3443,54 @@ axes::get_default (const caseless_str& n
   return retval;
 }
 
 // FIXME -- remove.
 // FIXME -- maybe this should go into array_property class?
 /*
 static void
 check_limit_vals (double& min_val, double& max_val, double& min_pos,
-		  const array_property& data)
+                  const array_property& data)
 {
   double val = data.min_val ();
   if (! (xisinf (val) || xisnan (val)) && val < min_val)
     min_val = val;
   val = data.max_val ();
   if (! (xisinf (val) || xisnan (val)) && val > max_val)
     max_val = val;
   val = data.min_pos ();
   if (! (xisinf (val) || xisnan (val)) && val > 0 && val < min_pos)
     min_pos = val;
 }
 */
 
 static void
 check_limit_vals (double& min_val, double& max_val, double& min_pos,
-		  const octave_value& data)
+                  const octave_value& data)
 {
   if (data.is_matrix_type ())
     {
       Matrix m = data.matrix_value ();
 
       if (! error_state && m.numel () == 3)
-	{
-	  double val;
-
-	  val = m(0);
-	  if (! (xisinf (val) || xisnan (val)) && val < min_val)
-	    min_val = val;
-
-	  val = m(1);
-	  if (! (xisinf (val) || xisnan (val)) && val > max_val)
-	    max_val = val;
-
-	  val = m(2);
-	  if (! (xisinf (val) || xisnan (val)) && val > 0 && val < min_pos)
-	    min_pos = val;
-	}
+        {
+          double val;
+
+          val = m(0);
+          if (! (xisinf (val) || xisnan (val)) && val < min_val)
+            min_val = val;
+
+          val = m(1);
+          if (! (xisinf (val) || xisnan (val)) && val > max_val)
+            max_val = val;
+
+          val = m(2);
+          if (! (xisinf (val) || xisnan (val)) && val > 0 && val < min_pos)
+            min_pos = val;
+        }
     }
 }
 
 // magform(x) Returns (a, b), where x = a * 10^b, a >= 1., and b is
 // integral.
 
 static void
 magform (double x, double& a, int& b)
@@ -3502,23 +3502,23 @@ magform (double x, double& a, int& b)
     }
   else
     {
       double l = std::log10 (std::abs (x));
       double r = std::fmod (l, 1.);
       a = std::pow (10.0, r);
       b = static_cast<int> (l-r);
       if (a < 1)
-	{
-	  a *= 10;
-	  b -= 1;
-	}
+        {
+          a *= 10;
+          b -= 1;
+        }
 
       if (x < 0)
-	a = -a;
+        a = -a;
     }
 }
 
 // A translation from Tom Holoryd's python code at
 // http://kurage.nimh.nih.gov/tomh/tics.py
 // FIXME -- add log ticks
 
 double
@@ -3554,79 +3554,79 @@ axes::properties::calc_tick_sep (double 
 }
 
 // Attempt to make "nice" limits from the actual max and min of the
 // data.  For log plots, we will also use the smallest strictly positive
 // value.
 
 Matrix
 axes::properties::get_axis_limits (double xmin, double xmax,
-				   double min_pos, bool logscale)
+                                   double min_pos, bool logscale)
 {
   Matrix retval;
 
   double min_val = xmin;
   double max_val = xmax;
 
   if (! (xisinf (min_val) || xisinf (max_val)))
     {
       if (logscale)
-	{
-	  if (xisinf (min_pos))
-	    {
-	      // warning ("axis: logscale with no positive values to plot");
-	      return retval;
-	    }
-
-	  if (min_val <= 0)
-	    {
-	      warning ("axis: omitting nonpositive data in log plot");
-	      min_val = min_pos;
-	    }
-	  // FIXME -- maybe this test should also be relative?
-	  if (std::abs (min_val - max_val) < sqrt (DBL_EPSILON))
-	    {
-	      min_val *= 0.9;
-	      max_val *= 1.1;
-	    }
-	  min_val = pow (10, floor (log10 (min_val)));
-	  max_val = pow (10, ceil (log10 (max_val)));
-	}
+        {
+          if (xisinf (min_pos))
+            {
+              // warning ("axis: logscale with no positive values to plot");
+              return retval;
+            }
+
+          if (min_val <= 0)
+            {
+              warning ("axis: omitting nonpositive data in log plot");
+              min_val = min_pos;
+            }
+          // FIXME -- maybe this test should also be relative?
+          if (std::abs (min_val - max_val) < sqrt (DBL_EPSILON))
+            {
+              min_val *= 0.9;
+              max_val *= 1.1;
+            }
+          min_val = pow (10, floor (log10 (min_val)));
+          max_val = pow (10, ceil (log10 (max_val)));
+        }
       else
-	{
-	  if (min_val == 0 && max_val == 0)
-	    {
-	      min_val = -1;
-	      max_val = 1;
-	    }
-	  // FIXME -- maybe this test should also be relative?
-	  else if (std::abs (min_val - max_val) < sqrt (DBL_EPSILON))
-	    {
-	      min_val -= 0.1 * std::abs (min_val);
-	      max_val += 0.1 * std::abs (max_val);
-	    }
-
-	  double tick_sep = calc_tick_sep (min_val , max_val);
-	  min_val = tick_sep * std::floor (min_val / tick_sep);
-	  max_val = tick_sep * ceil (max_val / tick_sep);
-	}
+        {
+          if (min_val == 0 && max_val == 0)
+            {
+              min_val = -1;
+              max_val = 1;
+            }
+          // FIXME -- maybe this test should also be relative?
+          else if (std::abs (min_val - max_val) < sqrt (DBL_EPSILON))
+            {
+              min_val -= 0.1 * std::abs (min_val);
+              max_val += 0.1 * std::abs (max_val);
+            }
+
+          double tick_sep = calc_tick_sep (min_val , max_val);
+          min_val = tick_sep * std::floor (min_val / tick_sep);
+          max_val = tick_sep * ceil (max_val / tick_sep);
+        }
     }
 
   retval.resize (1, 2);
 
   retval(0) = min_val;
   retval(1) = max_val;
 
   return retval;
 }
 
 void 
 axes::properties::calc_ticks_and_lims (array_property& lims,
-				       array_property& ticks,
-				       bool limmode_is_auto, bool is_logscale)
+                                       array_property& ticks,
+                                       bool limmode_is_auto, bool is_logscale)
 {
   // FIXME -- add log ticks and lims
 
   if (lims.get ().is_empty ())
     return;
 
   double lo = (lims.get ().matrix_value ()) (0);
   double hi = (lims.get ().matrix_value ()) (1);
@@ -3653,43 +3653,43 @@ axes::properties::calc_ticks_and_lims (a
   if (limmode_is_auto)
     {
       // adjust limits to include min and max tics
       Matrix tmp_lims (1,2);
       tmp_lims(0) = tick_sep * i1;
       tmp_lims(1) = tick_sep * i2;
 
       if (is_logscale) 
-	{
-	  tmp_lims(0) = std::pow (10.,tmp_lims(0));
-	  tmp_lims(1) = std::pow (10.,tmp_lims(1));
-	}
+        {
+          tmp_lims(0) = std::pow (10.,tmp_lims(0));
+          tmp_lims(1) = std::pow (10.,tmp_lims(1));
+        }
       lims = tmp_lims;
     }
   else
     {
       // adjust min and max tics if they are out of limits
       i1 = static_cast<int> (std::ceil (lo / tick_sep));
       i2 = static_cast<int> (std::floor (hi / tick_sep));
     }
       
   Matrix tmp_ticks (1, i2-i1+1);
   for (int i = 0; i <= i2-i1; i++) 
     {
       tmp_ticks (i) = tick_sep * (i+i1);
       if (is_logscale)
-	tmp_ticks (i) = std::pow (10., tmp_ticks (i));
+        tmp_ticks (i) = std::pow (10., tmp_ticks (i));
     }
 
   ticks = tmp_ticks;
 }
 
 void
 axes::properties::calc_ticklabels (const array_property& ticks,
-				   any_property& labels, bool /*logscale*/)
+                                   any_property& labels, bool /*logscale*/)
 {
   Matrix values = ticks.get ().matrix_value ();
   Cell c (values.dims ());
   std::ostringstream os;
 
   for (int i = 0; i < values.numel (); i++)
     {
       os.str (std::string ());
@@ -3697,90 +3697,90 @@ axes::properties::calc_ticklabels (const
       c(i) = os.str ();
     }
 
   labels = c;
 }
 
 void
 get_children_limits (double& min_val, double& max_val, double& min_pos,
-		     const Matrix& kids, char limit_type)
+                     const Matrix& kids, char limit_type)
 {
   octave_idx_type n = kids.numel ();
 
   switch (limit_type)
     {
     case 'x':
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  graphics_object obj = gh_manager::get_object (kids(i));
-
-	  if (obj.is_xliminclude ())
-	    {
-	      octave_value lim = obj.get_xlim ();
-
-	      check_limit_vals (min_val, max_val, min_pos, lim);
-	    }
-	}
+        {
+          graphics_object obj = gh_manager::get_object (kids(i));
+
+          if (obj.is_xliminclude ())
+            {
+              octave_value lim = obj.get_xlim ();
+
+              check_limit_vals (min_val, max_val, min_pos, lim);
+            }
+        }
       break;
 
     case 'y':
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  graphics_object obj = gh_manager::get_object (kids(i));
-
-	  if (obj.is_yliminclude ())
-	    {
-	      octave_value lim = obj.get_ylim ();
-
-	      check_limit_vals (min_val, max_val, min_pos, lim);
-	    }
-	}
+        {
+          graphics_object obj = gh_manager::get_object (kids(i));
+
+          if (obj.is_yliminclude ())
+            {
+              octave_value lim = obj.get_ylim ();
+
+              check_limit_vals (min_val, max_val, min_pos, lim);
+            }
+        }
       break;
     
     case 'z':
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  graphics_object obj = gh_manager::get_object (kids(i));
-
-	  if (obj.is_zliminclude ())
-	    {
-	      octave_value lim = obj.get_zlim ();
-
-	      check_limit_vals (min_val, max_val, min_pos, lim);
-	    }
-	}
+        {
+          graphics_object obj = gh_manager::get_object (kids(i));
+
+          if (obj.is_zliminclude ())
+            {
+              octave_value lim = obj.get_zlim ();
+
+              check_limit_vals (min_val, max_val, min_pos, lim);
+            }
+        }
       break;
     
     case 'c':
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  graphics_object obj = gh_manager::get_object (kids(i));
-
-	  if (obj.is_climinclude ())
-	    {
-	      octave_value lim = obj.get_clim ();
-
-	      check_limit_vals (min_val, max_val, min_pos, lim);
-	    }
-	}
+        {
+          graphics_object obj = gh_manager::get_object (kids(i));
+
+          if (obj.is_climinclude ())
+            {
+              octave_value lim = obj.get_clim ();
+
+              check_limit_vals (min_val, max_val, min_pos, lim);
+            }
+        }
       break;
     
     case 'a':
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  graphics_object obj = gh_manager::get_object (kids(i));
-
-	  if (obj.is_aliminclude ())
-	    {
-	      octave_value lim = obj.get_alim ();
-
-	      check_limit_vals (min_val, max_val, min_pos, lim);
-	    }
-	}
+        {
+          graphics_object obj = gh_manager::get_object (kids(i));
+
+          if (obj.is_aliminclude ())
+            {
+              octave_value lim = obj.get_alim ();
+
+              check_limit_vals (min_val, max_val, min_pos, lim);
+            }
+        }
       break;
 
     default:
       break;
     }
 }
 
 static bool updating_axis_limits = false;
@@ -3802,102 +3802,102 @@ axes::update_axis_limits (const std::str
   Matrix limits;
 
   if (axis_type == "xdata" || axis_type == "xscale"
       || axis_type == "xldata" || axis_type == "xudata"
       || axis_type == "xlimmode" || axis_type == "xliminclude"
       || axis_type == "xlim")
     {
       if (xproperties.xlimmode_is ("auto"))
-	{
-	  get_children_limits (min_val, max_val, min_pos, kids, 'x');
-	  
-	  limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
-						xproperties.xscale_is ("log"));
-
-	  update_type = 'x';
-	}
+        {
+          get_children_limits (min_val, max_val, min_pos, kids, 'x');
+          
+          limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
+                                                xproperties.xscale_is ("log"));
+
+          update_type = 'x';
+        }
     }
   else if (axis_type == "ydata" || axis_type == "yscale"
-	   || axis_type == "ldata" || axis_type == "udata"
-	   || axis_type == "ylimmode" || axis_type == "yliminclude"
-	   || axis_type == "ylim")
+           || axis_type == "ldata" || axis_type == "udata"
+           || axis_type == "ylimmode" || axis_type == "yliminclude"
+           || axis_type == "ylim")
     {
       if (xproperties.ylimmode_is ("auto"))
-	{
-	  get_children_limits (min_val, max_val, min_pos, kids, 'y');
-
-	  limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
-						xproperties.yscale_is ("log"));
-
-	  update_type = 'y';
-	}
+        {
+          get_children_limits (min_val, max_val, min_pos, kids, 'y');
+
+          limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
+                                                xproperties.yscale_is ("log"));
+
+          update_type = 'y';
+        }
     }
   else if (axis_type == "zdata" || axis_type == "zscale"
-	   || axis_type == "zlimmode" || axis_type == "zliminclude"
-	   || axis_type == "zlim")
+           || axis_type == "zlimmode" || axis_type == "zliminclude"
+           || axis_type == "zlim")
     {
       if (xproperties.zlimmode_is ("auto"))
-	{
-	  get_children_limits (min_val, max_val, min_pos, kids, 'z');
-
-	  limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
-						xproperties.zscale_is ("log"));
-
-	  update_type = 'z';
-	}
+        {
+          get_children_limits (min_val, max_val, min_pos, kids, 'z');
+
+          limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
+                                                xproperties.zscale_is ("log"));
+
+          update_type = 'z';
+        }
     }
   else if (axis_type == "cdata" || axis_type == "climmode"
-	   || axis_type == "cdatamapping" || axis_type == "climinclude"
-	   || axis_type == "clim")
+           || axis_type == "cdatamapping" || axis_type == "climinclude"
+           || axis_type == "clim")
     {
       if (xproperties.climmode_is ("auto"))
-	{
-	  get_children_limits (min_val, max_val, min_pos, kids, 'c');
-
-	  if (min_val > max_val)
-	    {
-	      min_val = min_pos = 0;
-	      max_val = 1;
-	    }
-	  else if (min_val == max_val)
-	    max_val = min_val + 1;
-
-	  limits.resize (1, 2);
-
-	  limits(0) = min_val;
-	  limits(1) = max_val;
-
-	  update_type = 'c';
-	}
+        {
+          get_children_limits (min_val, max_val, min_pos, kids, 'c');
+
+          if (min_val > max_val)
+            {
+              min_val = min_pos = 0;
+              max_val = 1;
+            }
+          else if (min_val == max_val)
+            max_val = min_val + 1;
+
+          limits.resize (1, 2);
+
+          limits(0) = min_val;
+          limits(1) = max_val;
+
+          update_type = 'c';
+        }
 
     }
   else if (axis_type == "alphadata" || axis_type == "alimmode"
-	   || axis_type == "alphadatamapping" || axis_type == "aliminclude"
-	   || axis_type == "alim")
+           || axis_type == "alphadatamapping" || axis_type == "aliminclude"
+           || axis_type == "alim")
     {
       if (xproperties.alimmode_is ("auto"))
-	{
-	  get_children_limits (min_val, max_val, min_pos, kids, 'a');
-
-	  if (min_val > max_val)
-	    {
-	      min_val = min_pos = 0;
-	      max_val = 1;
-	    }
-	  else if (min_val == max_val)
-	    max_val = min_val + 1;
-
-	  limits.resize (1, 2);
-
-	  limits(0) = min_val;
-	  limits(1) = max_val;
-
-	  update_type = 'a';
-	}
+        {
+          get_children_limits (min_val, max_val, min_pos, kids, 'a');
+
+          if (min_val > max_val)
+            {
+              min_val = min_pos = 0;
+              max_val = 1;
+            }
+          else if (min_val == max_val)
+            max_val = min_val + 1;
+
+          limits.resize (1, 2);
+
+          limits(0) = min_val;
+          limits(1) = max_val;
+
+          update_type = 'a';
+        }
 
     }
 
   unwind_protect frame;
   frame.protect_var (updating_axis_limits);
 
   updating_axis_limits = true;
 
@@ -4102,40 +4102,40 @@ line::properties::compute_ylim (void) co
 // Note: "text" code is entirely auto-generated
 
 // ---------------------------------------------------------------------
 
 octave_value
 image::properties::get_color_data (void) const
 {
   return convert_cdata (*this, get_cdata (),
-			cdatamapping_is ("scaled"), 3);
+                        cdatamapping_is ("scaled"), 3);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 patch::properties::get_color_data (void) const
 {
   return convert_cdata (*this, get_facevertexcdata (),
-			cdatamapping_is ("scaled"), 2);
+                        cdatamapping_is ("scaled"), 2);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 surface::properties::get_color_data (void) const
 {
   return convert_cdata (*this, get_cdata (), cdatamapping_is ("scaled"), 3);
 }
 
 inline void
 cross_product (double x1, double y1, double z1,
-	       double x2, double y2, double z2,
-	       double& x, double& y, double& z)
+               double x2, double y2, double z2,
+               double& x, double& y, double& z)
 {
   x += (y1 * z2 - z1 * y2);
   y += (z1 * x2 - x1 * z2);
   z += (x1 * y2 - y1 * x2);
 }
 
 void
 surface::properties::update_normals (void)
@@ -4152,68 +4152,68 @@ surface::properties::update_normals (voi
       int j1 = 0, j2 = 0, j3 = 0;
 
       bool x_mat = (x.rows () == q);
       bool y_mat = (y.columns () == p);
 
       NDArray n (dim_vector (q, p, 3), 0.0);
 
       for (int i = 0; i < p; i++)
-	{
-	  if (y_mat)
-	    {
-	      i1 = i - 1;
-	      i2 = i;
-	      i3 = i + 1;
-	    }
-
-	  for (int j = 0; j < q; j++)
-	    {
-	      if (x_mat)
-		{
-		  j1 = j - 1;
-		  j2 = j;
-		  j3 = j + 1;
-		}
-
-	      double& nx = n(j, i, 0);
-	      double& ny = n(j, i, 1);
-	      double& nz = n(j, i, 2);
+        {
+          if (y_mat)
+            {
+              i1 = i - 1;
+              i2 = i;
+              i3 = i + 1;
+            }
+
+          for (int j = 0; j < q; j++)
+            {
+              if (x_mat)
+                {
+                  j1 = j - 1;
+                  j2 = j;
+                  j3 = j + 1;
+                }
+
+              double& nx = n(j, i, 0);
+              double& ny = n(j, i, 1);
+              double& nz = n(j, i, 2);
 
               if ((j > 0) && (i > 0))
                   // upper left quadrangle
-	          cross_product (x(j1,i-1)-x(j2,i), y(j-1,i1)-y(j,i2), z(j-1,i-1)-z(j,i),
-		                 x(j2,i-1)-x(j1,i), y(j,i1)-y(j-1,i2), z(j,i-1)-z(j-1,i),
-			         nx, ny, nz);
+                  cross_product (x(j1,i-1)-x(j2,i), y(j-1,i1)-y(j,i2), z(j-1,i-1)-z(j,i),
+                                 x(j2,i-1)-x(j1,i), y(j,i1)-y(j-1,i2), z(j,i-1)-z(j-1,i),
+                                 nx, ny, nz);
 
               if ((j > 0) && (i < (p -1)))
                   // upper right quadrangle
                   cross_product (x(j1,i+1)-x(j2,i), y(j-1,i3)-y(j,i2), z(j-1,i+1)-z(j,i),
-		                 x(j1,i)-x(j2,i+1), y(j-1,i2)-y(j,i3), z(j-1,i)-z(j,i+1),
-			         nx, ny, nz);
+                                 x(j1,i)-x(j2,i+1), y(j-1,i2)-y(j,i3), z(j-1,i)-z(j,i+1),
+                                 nx, ny, nz);
 
               if ((j < (q - 1)) && (i > 0))
                   // lower left quadrangle
                   cross_product (x(j2,i-1)-x(j3,i), y(j,i1)-y(j+1,i2), z(j,i-1)-z(j+1,i),
-		                 x(j3,i-1)-x(j2,i), y(j+1,i1)-y(j,i2), z(j+1,i-1)-z(j,i),
-			         nx, ny, nz);
+                                 x(j3,i-1)-x(j2,i), y(j+1,i1)-y(j,i2), z(j+1,i-1)-z(j,i),
+                                 nx, ny, nz);
 
               if ((j < (q - 1)) && (i < (p -1)))
                   // lower right quadrangle
-	          cross_product (x(j3,i)-x(j2,i+1), y(j+1,i2)-y(j,i3), z(j+1,i)-z(j,i+1),
+                  cross_product (x(j3,i)-x(j2,i+1), y(j+1,i2)-y(j,i3), z(j+1,i)-z(j,i+1),
                                  x(j3,i+1)-x(j2,i), y(j+1,i3)-y(j,i2), z(j+1,i+1)-z(j,i),
-			         nx, ny, nz);
+                                 nx, ny, nz);
 
               double d = - std::max(std::max(fabs(nx), fabs(ny)), fabs(nz));
 
-	      nx /= d;
-	      ny /= d;
-	      nz /= d;
-	    }
-	}
+              nx /= d;
+              ny /= d;
+              nz /= d;
+            }
+        }
       vertexnormals = n;
     }
 }
 
 // ---------------------------------------------------------------------
 
 void
 hggroup::update_axis_limits (const std::string& axis_type)
@@ -4321,17 +4321,17 @@ gh_manager::gh_manager (void)
   handle_map[0] = graphics_object (new root_figure ());
 
   // Make sure the default backend is registered.
   graphics_backend::default_backend ();
 }
 
 graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
-				     const graphics_handle& p, bool do_createfcn)
+                                     const graphics_handle& p, bool do_createfcn)
 {
   graphics_handle h = get_handle (go_name);
 
   base_graphics_object *go = 0;
 
   go = make_graphics_object_from_type (go_name, h, p);
   
   if (go)
@@ -4344,17 +4344,17 @@ gh_manager::do_make_graphics_handle (con
 
       // notify backend
       graphics_backend backend = go->get_backend ();
       if (backend)
         backend.object_created (obj);
     }
   else
     error ("gh_manager::do_make_graphics_handle: invalid object type `%s'",
-	   go_name.c_str ());
+           go_name.c_str ());
 
   return h;
 }
 
 graphics_handle
 gh_manager::do_make_figure_handle (double val)
 {
   graphics_handle h = val;
@@ -4383,29 +4383,29 @@ gh_manager::do_push_figure (const graphi
 void
 gh_manager::do_pop_figure (const graphics_handle& h)
 {
   for (figure_list_iterator p = figure_list.begin ();
        p != figure_list.end ();
        p++)
     {
       if (*p == h)
-	{
-	  figure_list.erase (p);
-	  break;
-	}
+        {
+          figure_list.erase (p);
+          break;
+        }
     }
 }
 
 class
 callback_event : public base_graphics_event
 {
 public:
   callback_event (const graphics_handle& h, const std::string& name,
-		  const octave_value& data = Matrix ())
+                  const octave_value& data = Matrix ())
       : base_graphics_event (), handle (h), callback_name (name),
         callback_data (data) { }
 
   void execute (void)
     {
       gh_manager::execute_callback (handle, callback_name, callback_data);
     }
 
@@ -4441,17 +4441,17 @@ private:
   void* function_data;
 };
 
 class
 set_event : public base_graphics_event
 {
 public:
   set_event (const graphics_handle& h, const std::string& name,
-	     const octave_value& value)
+             const octave_value& value)
       : base_graphics_event (), handle (h), property_name (name),
         property_value (value) { }
 
   void execute (void)
     {
       gh_manager::autolock guard;
 
       xset (handle, property_name, property_value);
@@ -4464,41 +4464,41 @@ private:
 private:
   graphics_handle handle;
   std::string property_name;
   octave_value property_value;
 };
 
 graphics_event
 graphics_event::create_callback_event (const graphics_handle& h,
-				       const std::string& name,
-				       const octave_value& data)
+                                       const std::string& name,
+                                       const octave_value& data)
 {
   graphics_event e;
 
   e.rep = new callback_event (h, name, data);
 
   return e;
 }
 
 graphics_event
 graphics_event::create_function_event (graphics_event::event_fcn fcn,
-				       void *data)
+                                       void *data)
 {
   graphics_event e;
 
   e.rep = new function_event (fcn, data);
 
   return e;
 }
 
 graphics_event
 graphics_event::create_set_event (const graphics_handle& h,
-				  const std::string& name,
-				  const octave_value& data)
+                                  const std::string& name,
+                                  const octave_value& data)
 {
   graphics_event e;
 
   e.rep = new set_event (h, name, data);
 
   return e;
 }
 
@@ -4515,24 +4515,24 @@ xset_gcbo (const graphics_handle& h)
 void
 gh_manager::do_restore_gcbo (void)
 {
   gh_manager::autolock guard;
 
   callback_objects.pop_front ();
 
   xset_gcbo (callback_objects.empty ()
-	     ? graphics_handle ()
-	     : callback_objects.front ().get_handle ());
+             ? graphics_handle ()
+             : callback_objects.front ().get_handle ());
 }
 
 void
 gh_manager::do_execute_callback (const graphics_handle& h,
-				 const octave_value& cb_arg,
-				 const octave_value& data)
+                                 const octave_value& cb_arg,
+                                 const octave_value& data)
 {
   octave_value_list args;
   octave_function *fcn = 0;
 
   args(0) = h.as_octave_value ();
   if (data.is_defined ())
     args(1) = data;
   else
@@ -4576,17 +4576,17 @@ gh_manager::do_execute_callback (const g
           for (int i = 1; i < c.length () ; i++)
             args(1+i) = c(i);
         }
     }
   else
     {
       std::string nm = cb.class_name ();
       error ("trying to execute non-executable object (class = %s)",
-	     nm.c_str ());
+             nm.c_str ());
     }
 
   if (fcn && ! error_state)
     feval (fcn, args);
   
   END_INTERRUPT_WITH_EXCEPTIONS;
 }
 
@@ -4595,65 +4595,65 @@ gh_manager::do_post_event (const graphic
 {
   event_queue.push_back (e);
 
   command_editor::add_event_hook (gh_manager::process_events);
 }
 
 void
 gh_manager::do_post_callback (const graphics_handle& h, const std::string name,
-			      const octave_value& data)
+                              const octave_value& data)
 {
   gh_manager::autolock guard;
 
   graphics_object go = get_object (h);
 
   if (go.valid_object ())
     {
       if (callback_objects.empty ())
-	do_post_event (graphics_event::create_callback_event (h, name, data));
+        do_post_event (graphics_event::create_callback_event (h, name, data));
       else
-	{
-	  const graphics_object& current = callback_objects.front ();
-
-	  if (current.get_properties ().is_interruptible ())
-	    do_post_event (graphics_event::create_callback_event (h, name, data));
-	  else
-	    {
-	      caseless_str busy_action (go.get_properties ().get_busyaction ());
-
-	      if (busy_action.compare ("queue"))
-		do_post_event (graphics_event::create_callback_event (h, name, data));
-	      else
-		{
-		  caseless_str cname (name);
-
-		  if (cname.compare ("deletefcn")
-		      || cname.compare ("createfcn")
-		      || (go.isa ("figure")
-			  && (cname.compare ("closerequestfcn")
-			      || cname.compare ("resizefcn"))))
-		    do_post_event (graphics_event::create_callback_event (h, name, data));
-		}
-	    }
-	}
+        {
+          const graphics_object& current = callback_objects.front ();
+
+          if (current.get_properties ().is_interruptible ())
+            do_post_event (graphics_event::create_callback_event (h, name, data));
+          else
+            {
+              caseless_str busy_action (go.get_properties ().get_busyaction ());
+
+              if (busy_action.compare ("queue"))
+                do_post_event (graphics_event::create_callback_event (h, name, data));
+              else
+                {
+                  caseless_str cname (name);
+
+                  if (cname.compare ("deletefcn")
+                      || cname.compare ("createfcn")
+                      || (go.isa ("figure")
+                          && (cname.compare ("closerequestfcn")
+                              || cname.compare ("resizefcn"))))
+                    do_post_event (graphics_event::create_callback_event (h, name, data));
+                }
+            }
+        }
     }
 }
 
 void
 gh_manager::do_post_function (graphics_event::event_fcn fcn, void* fcn_data)
 {
   gh_manager::autolock guard;
 
   do_post_event (graphics_event::create_function_event (fcn, fcn_data));
 }
 
 void
 gh_manager::do_post_set (const graphics_handle& h, const std::string name,
-			 const octave_value& value)
+                         const octave_value& value)
 {
   gh_manager::autolock guard;
 
   do_post_event (graphics_event::create_set_event (h, name, value));
 }
 
 int
 gh_manager::do_process_events (bool force)
@@ -4662,40 +4662,40 @@ gh_manager::do_process_events (bool forc
 
   do
     {
       e = graphics_event ();
 
       gh_manager::lock ();
 
       if (! event_queue.empty ())
-	{
-	  if (callback_objects.empty () || force)
-	    {
-	      e = event_queue.front ();
-	      
-	      event_queue.pop_front ();
-	    }
-	  else
-	    {
-	      const graphics_object& go = callback_objects.front ();
-
-	      if (go.get_properties ().is_interruptible ())
-		{
-		  e = event_queue.front ();
-
-		  event_queue.pop_front ();
-		}
-	    }
-	}
+        {
+          if (callback_objects.empty () || force)
+            {
+              e = event_queue.front ();
+              
+              event_queue.pop_front ();
+            }
+          else
+            {
+              const graphics_object& go = callback_objects.front ();
+
+              if (go.get_properties ().is_interruptible ())
+                {
+                  e = event_queue.front ();
+
+                  event_queue.pop_front ();
+                }
+            }
+        }
 
       gh_manager::unlock ();
 
       if (e.ok ())
-	e.execute ();
+        e.execute ();
     }
   while (e.ok ());
 
   gh_manager::lock ();
 
   if (event_queue.empty ())
     command_editor::remove_event_hook (gh_manager::process_events);
 
@@ -4782,17 +4782,17 @@ the dimensions of @var{pv}.\n\
 
   if (nargin > 0)
     {
       // get vector of graphics handles
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
-	  bool request_drawnow = false;
+          bool request_drawnow = false;
 
           // loop over graphics objects
           for (octave_idx_type n = 0; n < hcv.length (); n++) 
             {
               graphics_object obj = gh_manager::get_object (hcv(n));
 
               if (obj)
                 {
@@ -4823,29 +4823,29 @@ the dimensions of @var{pv}.\n\
                     }
                   else
                     {
                       obj.set (args.splice (0, 1));
                       request_drawnow = true;
                     }
                 }
               else
-		{
-		  error ("set: invalid handle (= %g)", hcv(n));
-		  break;
-		}
+                {
+                  error ("set: invalid handle (= %g)", hcv(n));
+                  break;
+                }
 
               if (error_state)
                 break;
 
               request_drawnow = true;
            }
 
-	  if (! error_state && request_drawnow)
-	    Vdrawnow_requested = true;
+          if (! error_state && request_drawnow)
+            Vdrawnow_requested = true;
         }
       else
         error ("set: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
   return retval;
@@ -4869,62 +4869,62 @@ values or lists respectively.\n\
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
-	  octave_idx_type len = hcv.length ();
-
-	  vals.resize (dim_vector (len, 1));
+          octave_idx_type len = hcv.length ();
+
+          vals.resize (dim_vector (len, 1));
 
           for (octave_idx_type n = 0; n < len; n++)
             {
               graphics_object obj = gh_manager::get_object (hcv(n));
 
               if (obj)
                 {
                   if (nargin == 1)
                     vals(n) = obj.get ();
                   else
                     {
                       caseless_str property = args(1).string_value ();
 
                       if (! error_state)
                         vals(n) = obj.get (property);
                       else
-			{
-			  error ("get: expecting property name as second argument");
-			  break;
-			}
+                        {
+                          error ("get: expecting property name as second argument");
+                          break;
+                        }
                     }
                 }
               else
-		{
-		  error ("get: invalid handle (= %g)", hcv(n));
-		  break;
-		}
+                {
+                  error ("get: invalid handle (= %g)", hcv(n));
+                  break;
+                }
             }
         }
       else
         error ("get: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
   if (! error_state)
     {
       octave_idx_type len = vals.numel ();
 
       if (len > 1)
-	retval = vals;
+        retval = vals;
       else if (len == 1)
-	retval = vals(0);
+        retval = vals(0);
     }
 
   return retval;
 }
 
 // Return all properties from the graphics handle @var{h}.
 // If @var{h} is a vector, return a cell array including the
 // property values or lists respectively.
@@ -4982,75 +4982,75 @@ Undocumented internal function.\n\
         retval = vals(0);
     }
 
   return retval;
 }
 
 static octave_value
 make_graphics_object (const std::string& go_name,
-		      const octave_value_list& args)
+                      const octave_value_list& args)
 {
   octave_value retval;
 
   double val = octave_NaN;
 
   octave_value_list xargs = args.splice (0, 1);
 
   caseless_str p ("parent");
 
   for (int i = 0; i < xargs.length (); i++)
     if (xargs(i).is_string ()
-	&& p.compare (xargs(i).string_value ()))
+        && p.compare (xargs(i).string_value ()))
       {
-	if (i < (xargs.length () - 1))
-	  {
-	    val = xargs(i+1).double_value ();
-
-	    if (! error_state)
-	      {
-		xargs = xargs.splice (i, 2);
-		break;
-	      }
-	  }
-	else
-	  error ("__go_%s__: missing value for parent property",
-		 go_name.c_str ());
+        if (i < (xargs.length () - 1))
+          {
+            val = xargs(i+1).double_value ();
+
+            if (! error_state)
+              {
+                xargs = xargs.splice (i, 2);
+                break;
+              }
+          }
+        else
+          error ("__go_%s__: missing value for parent property",
+                 go_name.c_str ());
       }
 
   if (! error_state && xisnan (val))
     val = args(0).double_value ();
 
   if (! error_state)
     {
       graphics_handle parent = gh_manager::lookup (val);
 
       if (parent.ok ())
-	{
-	  graphics_handle h
-	    = gh_manager::make_graphics_handle (go_name, parent, false);
-
-	  if (! error_state)
-	    {
-	      adopt (parent, h);
-
-	      xset (h, xargs);
-	      xcreatefcn (h);
-
-	      retval = h.value ();
-
-	      if (! error_state)
-		Vdrawnow_requested = true;
-	    }
-	  else
-	    error ("__go%s__: unable to create graphics handle",
-		   go_name.c_str ());
-	}
+        {
+          graphics_handle h
+            = gh_manager::make_graphics_handle (go_name, parent, false);
+
+          if (! error_state)
+            {
+              adopt (parent, h);
+
+              xset (h, xargs);
+              xcreatefcn (h);
+
+              retval = h.value ();
+
+              if (! error_state)
+                Vdrawnow_requested = true;
+            }
+          else
+            error ("__go%s__: unable to create graphics handle",
+                   go_name.c_str ());
+        }
       else
-	error ("__go_%s__: invalid parent", go_name.c_str ());
+        error ("__go_%s__: invalid parent", go_name.c_str ());
     }
   else
     error ("__go_%s__: invalid parent", go_name.c_str ());
 
   return retval;
 }
 
 DEFUN (__go_figure__, args, ,
@@ -5063,51 +5063,51 @@ Undocumented internal function.\n\
 
   octave_value retval;
 
   if (args.length () > 0)
     {
       double val = args(0).double_value ();
 
       if (! error_state)
-	{
-	  if (is_figure (val))
-	    {
-	      graphics_handle h = gh_manager::lookup (val);
-
-	      xset (h, args.splice (0, 1));
-
-	      retval = h.value ();
-	    }
-	  else
-	    {
-	      graphics_handle h = octave_NaN;
-
-	      if (xisnan (val))
-		h = gh_manager::make_graphics_handle ("figure", 0, false);
-	      else if (val > 0 && D_NINT (val) == val)
-		h = gh_manager::make_figure_handle (val);
-	      else
-		error ("__go_figure__: invalid figure number");
-
-	      if (! error_state && h.ok ())
-		{
-		  adopt (0, h);
-
-		  xset (h, args.splice (0, 1));
-		  xcreatefcn (h);
-
-		  retval = h.value ();
-		}
-	      else
-		error ("__go_figure__: failed to create figure handle");
-	    }
-	}
+        {
+          if (is_figure (val))
+            {
+              graphics_handle h = gh_manager::lookup (val);
+
+              xset (h, args.splice (0, 1));
+
+              retval = h.value ();
+            }
+          else
+            {
+              graphics_handle h = octave_NaN;
+
+              if (xisnan (val))
+                h = gh_manager::make_graphics_handle ("figure", 0, false);
+              else if (val > 0 && D_NINT (val) == val)
+                h = gh_manager::make_figure_handle (val);
+              else
+                error ("__go_figure__: invalid figure number");
+
+              if (! error_state && h.ok ())
+                {
+                  adopt (0, h);
+
+                  xset (h, args.splice (0, 1));
+                  xcreatefcn (h);
+
+                  retval = h.value ();
+                }
+              else
+                error ("__go_figure__: failed to create figure handle");
+            }
+        }
       else
-	error ("__go_figure__: expecting figure number to be double value");
+        error ("__go_figure__: expecting figure number to be double value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #define GO_BODY(TYPE) \
@@ -5197,70 +5197,70 @@ Undocumented internal function.\n\
 
   if (args.length () == 1)
     {
       graphics_handle h = octave_NaN;
 
       const NDArray vals = args (0).array_value ();
 
       if (! error_state)
-	{
-	  // Check is all the handles to delete are valid first
-	  // as callbacks might delete one of the handles we
-	  // later want to delete
-	  for (octave_idx_type i = 0; i < vals.numel (); i++)
-	    {
-	      h = gh_manager::lookup (vals.elem (i));
-
-	      if (! h.ok ())
-		{
-		  error ("delete: invalid graphics object (= %g)", 
-			 vals.elem (i));
-		  break;
-		}
-	    }
-
-	  if (! error_state)
-	    {
-	      for (octave_idx_type i = 0; i < vals.numel (); i++)
-		{
-		  h = gh_manager::lookup (vals.elem (i));
-
-		  if (h.ok ())
-		    {
-		      graphics_object obj = gh_manager::get_object (h);
-
-		      // Don't do recursive deleting, due to callbacks
-		      if (! obj.get_properties ().is_beingdeleted ())
-			{
-			  graphics_handle parent_h = obj.get_parent ();
-
-			  graphics_object parent_obj = 
-			    gh_manager::get_object (parent_h);
-
-			  // NOTE: free the handle before removing it from its
-			  //       parent's children, such that the object's 
-			  //       state is correct when the deletefcn callback
-			  //       is executed
-
-			  gh_manager::free (h);
-
-			  // A callback function might have already deleted 
-			  // the parent
-			  if (parent_obj.valid_object ())
-			    parent_obj.remove_child (h);
-
-			  Vdrawnow_requested = true;
-			}
-		    }
-		}
-	    }
-	}
+        {
+          // Check is all the handles to delete are valid first
+          // as callbacks might delete one of the handles we
+          // later want to delete
+          for (octave_idx_type i = 0; i < vals.numel (); i++)
+            {
+              h = gh_manager::lookup (vals.elem (i));
+
+              if (! h.ok ())
+                {
+                  error ("delete: invalid graphics object (= %g)", 
+                         vals.elem (i));
+                  break;
+                }
+            }
+
+          if (! error_state)
+            {
+              for (octave_idx_type i = 0; i < vals.numel (); i++)
+                {
+                  h = gh_manager::lookup (vals.elem (i));
+
+                  if (h.ok ())
+                    {
+                      graphics_object obj = gh_manager::get_object (h);
+
+                      // Don't do recursive deleting, due to callbacks
+                      if (! obj.get_properties ().is_beingdeleted ())
+                        {
+                          graphics_handle parent_h = obj.get_parent ();
+
+                          graphics_object parent_obj = 
+                            gh_manager::get_object (parent_h);
+
+                          // NOTE: free the handle before removing it from its
+                          //       parent's children, such that the object's 
+                          //       state is correct when the deletefcn callback
+                          //       is executed
+
+                          gh_manager::free (h);
+
+                          // A callback function might have already deleted 
+                          // the parent
+                          if (parent_obj.valid_object ())
+                            parent_obj.remove_child (h);
+
+                          Vdrawnow_requested = true;
+                        }
+                    }
+                }
+            }
+        }
       else
-	error ("delete: invalid graphics object");
+        error ("delete: invalid graphics object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__go_axes_init__, args, ,
@@ -5277,44 +5277,44 @@ Undocumented internal function.\n\
 
   std::string mode = "";
 
   if (nargin == 2)
     {
       mode = args(1).string_value ();
 
       if (error_state)
-	return retval;
+        return retval;
     }
 
   if (nargin == 1 || nargin == 2)
     {
       graphics_handle h = octave_NaN;
 
       double val = args(0).double_value ();
 
       if (! error_state)
-	{
-	  h = gh_manager::lookup (val);
-
-	  if (h.ok ())
-	    {
-	      graphics_object obj = gh_manager::get_object (h);
-
-	      obj.set_defaults (mode);
-
-	      h = gh_manager::lookup (val);
-	      if (! h.ok ())
-		error ("__go_axes_init__: axis deleted during initialization (= %g)", val);
-	    }
-	  else
-	    error ("__go_axes_init__: invalid graphics object (= %g)", val);
-	}
+        {
+          h = gh_manager::lookup (val);
+
+          if (h.ok ())
+            {
+              graphics_object obj = gh_manager::get_object (h);
+
+              obj.set_defaults (mode);
+
+              h = gh_manager::lookup (val);
+              if (! h.ok ())
+                error ("__go_axes_init__: axis deleted during initialization (= %g)", val);
+            }
+          else
+            error ("__go_axes_init__: invalid graphics object (= %g)", val);
+        }
       else
-	error ("__go_axes_init__: invalid graphics object");
+        error ("__go_axes_init__: invalid graphics object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__go_handles__, , ,
@@ -5350,39 +5350,39 @@ Undocumented internal function.\n\
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       double val = args(0).double_value ();
 
       if (! error_state)
-	{
-	  graphics_handle h = gh_manager::lookup (val);
-
-	  if (h.ok ())
-	    {
-	      std::string name = args(1).string_value ();
-
-	      if (! error_state)
-		{
-		  if (nargin == 2)
-		    gh_manager::execute_callback (h, name);
-		  else
-		    gh_manager::execute_callback (h, name, args(2));
-		}
-	      else
-		error ("__go_execute_callback__: invalid callback name");
-	    }
-	  else
-	    error ("__go_execute_callback__: invalid graphics object (= %g)",
-		   val);
-	}
+        {
+          graphics_handle h = gh_manager::lookup (val);
+
+          if (h.ok ())
+            {
+              std::string name = args(1).string_value ();
+
+              if (! error_state)
+                {
+                  if (nargin == 2)
+                    gh_manager::execute_callback (h, name);
+                  else
+                    gh_manager::execute_callback (h, name, args(2));
+                }
+              else
+                error ("__go_execute_callback__: invalid callback name");
+            }
+          else
+            error ("__go_execute_callback__: invalid graphics object (= %g)",
+                   val);
+        }
       else
-	error ("__go_execute_callback__: invalid graphics object");
+        error ("__go_execute_callback__: invalid graphics object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (available_backends, , ,
@@ -5419,144 +5419,144 @@ undocumented.\n\
   unwind_protect frame;
   frame.protect_var (Vdrawnow_requested, false);
 
   frame.protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
       if (! __go_close_all_registered__)
-	{
-	  octave_add_atexit_function ("__go_close_all__");
-
-	  __go_close_all_registered__ = true;
-	}
+        {
+          octave_add_atexit_function ("__go_close_all__");
+
+          __go_close_all_registered__ = true;
+        }
 
       if (args.length () == 0 || args.length () == 1)
-	{
-	  Matrix hlist = gh_manager::figure_handle_list ();
-
-	  for (int i = 0; ! error_state && i < hlist.length (); i++)
-	    {
-	      graphics_handle h = gh_manager::lookup (hlist(i));
-
-	      if (h.ok () && h != 0)
-		{
-		  graphics_object go = gh_manager::get_object (h);
-		  figure::properties& fprops = dynamic_cast <figure::properties&> (go.get_properties ());
-
-		  if (fprops.is_modified ())
-		    {
-		      if (fprops.is_visible ())
-			{
-			  gh_manager::unlock ();
-
-			  fprops.get_backend ().redraw_figure (go);
-
-			  gh_manager::lock ();
-			}
-
-		      fprops.set_modified (false);
-		    }
-		}
-	    }
-
-	  bool do_events = true;
-
-	  if (args.length () == 1)
-	    {
-	      caseless_str val (args(0).string_value ());
-
-	      if (! error_state && val.compare ("expose"))
-		do_events = false;
-	      else
-		{
-		  error ("drawnow: invalid argument, expected `expose' as argument");
-		  return retval;
-		}
-	    }
-
-	  if (do_events)
-	    {
-	      gh_manager::unlock ();
-
-	      gh_manager::process_events ();
-
-	      gh_manager::lock ();
-	    }
-	}
+        {
+          Matrix hlist = gh_manager::figure_handle_list ();
+
+          for (int i = 0; ! error_state && i < hlist.length (); i++)
+            {
+              graphics_handle h = gh_manager::lookup (hlist(i));
+
+              if (h.ok () && h != 0)
+                {
+                  graphics_object go = gh_manager::get_object (h);
+                  figure::properties& fprops = dynamic_cast <figure::properties&> (go.get_properties ());
+
+                  if (fprops.is_modified ())
+                    {
+                      if (fprops.is_visible ())
+                        {
+                          gh_manager::unlock ();
+
+                          fprops.get_backend ().redraw_figure (go);
+
+                          gh_manager::lock ();
+                        }
+
+                      fprops.set_modified (false);
+                    }
+                }
+            }
+
+          bool do_events = true;
+
+          if (args.length () == 1)
+            {
+              caseless_str val (args(0).string_value ());
+
+              if (! error_state && val.compare ("expose"))
+                do_events = false;
+              else
+                {
+                  error ("drawnow: invalid argument, expected `expose' as argument");
+                  return retval;
+                }
+            }
+
+          if (do_events)
+            {
+              gh_manager::unlock ();
+
+              gh_manager::process_events ();
+
+              gh_manager::lock ();
+            }
+        }
       else if (args.length () >= 2 && args.length () <= 4)
-	{
-	  std::string term, file, debug_file;
-	  bool mono;
-
-	  term = args(0).string_value ();
-
-	  if (! error_state)
-	    {
-	      file = args(1).string_value ();
-
-	      if (! error_state)
-		{
-		  size_t pos = file.find_last_of (file_ops::dir_sep_chars ());
-
-		  if (pos != std::string::npos)
-		    {
-		      std::string dirname = file.substr (0, pos+1);
-
-		      file_stat fs (dirname);
-
-		      if (! (fs && fs.is_dir ()))
-			{
-			  error ("drawnow: nonexistent directory `%s'",
-				 dirname.c_str ());
-
-			  return retval;
-			}
-		    }
-
-		  mono = (args.length () >= 3 ? args(2).bool_value () : false);
-
-		  if (! error_state)
-		    {
-		      debug_file = (args.length () > 3 ? args(3).string_value ()
-				    : "");
-
-		      if (! error_state)
-			{
-			  graphics_handle h = gcf ();
-
-			  if (h.ok ())
-			    {
-			      graphics_object go = gh_manager::get_object (h);
-
-			      gh_manager::unlock ();
-
-			      go.get_backend ()
-				.print_figure (go, term, file, mono, debug_file);
-
-			      gh_manager::lock ();
-			    }
-			  else
-			    error ("drawnow: nothing to draw");
-			}
-		      else
-			error ("drawnow: invalid debug_file, expected a string value");
-		    }
-		  else
-		    error ("drawnow: invalid colormode, expected a boolean value");
-		}
-	      else
-		error ("drawnow: invalid file, expected a string value");
-	    }
-	  else
-	    error ("drawnow: invalid terminal, expected a string value");
-	}
+        {
+          std::string term, file, debug_file;
+          bool mono;
+
+          term = args(0).string_value ();
+
+          if (! error_state)
+            {
+              file = args(1).string_value ();
+
+              if (! error_state)
+                {
+                  size_t pos = file.find_last_of (file_ops::dir_sep_chars ());
+
+                  if (pos != std::string::npos)
+                    {
+                      std::string dirname = file.substr (0, pos+1);
+
+                      file_stat fs (dirname);
+
+                      if (! (fs && fs.is_dir ()))
+                        {
+                          error ("drawnow: nonexistent directory `%s'",
+                                 dirname.c_str ());
+
+                          return retval;
+                        }
+                    }
+
+                  mono = (args.length () >= 3 ? args(2).bool_value () : false);
+
+                  if (! error_state)
+                    {
+                      debug_file = (args.length () > 3 ? args(3).string_value ()
+                                    : "");
+
+                      if (! error_state)
+                        {
+                          graphics_handle h = gcf ();
+
+                          if (h.ok ())
+                            {
+                              graphics_object go = gh_manager::get_object (h);
+
+                              gh_manager::unlock ();
+
+                              go.get_backend ()
+                                .print_figure (go, term, file, mono, debug_file);
+
+                              gh_manager::lock ();
+                            }
+                          else
+                            error ("drawnow: nothing to draw");
+                        }
+                      else
+                        error ("drawnow: invalid debug_file, expected a string value");
+                    }
+                  else
+                    error ("drawnow: invalid colormode, expected a boolean value");
+                }
+              else
+                error ("drawnow: invalid file, expected a string value");
+            }
+          else
+            error ("drawnow: invalid terminal, expected a string value");
+        }
       else
-	print_usage ();
+        print_usage ();
     }
 
   gh_manager::unlock ();
 
   return retval;
 }
 
 DEFUN (addlistener, args, ,
@@ -5596,38 +5596,38 @@ addlistener (gcf, \"position\", @{@@my_l
 
   octave_value retval;
 
   if (args.length () == 3)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
-	{
-	  std::string pname = args(1).string_value ();
-
-	  if (! error_state)
-	    {
-	      graphics_handle gh = gh_manager::lookup (h);
-
-	      if (gh.ok ())
-		{
-		  graphics_object go = gh_manager::get_object (gh);
-
-		  go.add_property_listener (pname, args(2), POSTSET);
-		}
-	      else
-		error ("addlistener: invalid graphics object (= %g)",
-		       h);
-	    }
-	  else
-	    error ("addlistener: invalid property name, expected a string value");
-	}
+        {
+          std::string pname = args(1).string_value ();
+
+          if (! error_state)
+            {
+              graphics_handle gh = gh_manager::lookup (h);
+
+              if (gh.ok ())
+                {
+                  graphics_object go = gh_manager::get_object (gh);
+
+                  go.add_property_listener (pname, args(2), POSTSET);
+                }
+              else
+                error ("addlistener: invalid graphics object (= %g)",
+                       h);
+            }
+          else
+            error ("addlistener: invalid property name, expected a string value");
+        }
       else
-	error ("addlistener: invalid handle");
+        error ("addlistener: invalid handle");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (dellistener, args, ,
@@ -5661,41 +5661,41 @@ dellistener (gcf, \"position\", c);\n\
 
   octave_value retval;
 
   if (args.length () == 3 || args.length () == 2)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
-	{
-	  std::string pname = args(1).string_value ();
-
-	  if (! error_state)
-	    {
-	      graphics_handle gh = gh_manager::lookup (h);
-
-	      if (gh.ok ())
-		{
-		  graphics_object go = gh_manager::get_object (gh);
-
-		  if (args.length () == 2)
-		    go.delete_property_listener (pname, octave_value (), POSTSET);
-		  else
-		    go.delete_property_listener (pname, args(2), POSTSET);
-		}
-	      else
-		error ("dellistener: invalid graphics object (= %g)",
-		       h);
-	    }
-	  else
-	    error ("dellistener: invalid property name, expected a string value");
-	}
+        {
+          std::string pname = args(1).string_value ();
+
+          if (! error_state)
+            {
+              graphics_handle gh = gh_manager::lookup (h);
+
+              if (gh.ok ())
+                {
+                  graphics_object go = gh_manager::get_object (gh);
+
+                  if (args.length () == 2)
+                    go.delete_property_listener (pname, octave_value (), POSTSET);
+                  else
+                    go.delete_property_listener (pname, args(2), POSTSET);
+                }
+              else
+                error ("dellistener: invalid graphics object (= %g)",
+                       h);
+            }
+          else
+            error ("dellistener: invalid property name, expected a string value");
+        }
       else
-	error ("dellistener: invalid handle");
+        error ("dellistener: invalid handle");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (addproperty, args, ,
@@ -5764,91 +5764,91 @@ addproperty (\"my_style\", gcf, \"lineli
 
   octave_value retval;
 
   if (args.length () >= 3)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	{
-	  double h = args(1).double_value ();
-
-	  if (! error_state)
-	    {
-	      graphics_handle gh = gh_manager::lookup (h);
-
-	      if (gh.ok ())
-		{
-		  graphics_object go = gh_manager::get_object (gh);
-
-		  std::string type = args(2).string_value ();
-
-		  if (! error_state)
-		    {
-		      if (! go.get_properties ().has_property (name))
-			{
-			  property p = property::create (name, gh, type,
-							 args.splice (0, 3));
-
-			  if (! error_state)
-			    go.get_properties ().insert_property (name, p);
-			}
-		      else
-			error ("addproperty: a `%s' property already exists in the graphics object",
-			       name.c_str ());
-		    }
-		  else
-		    error ("addproperty: invalid property type, expected a string value");
-		}
-	      else
-		error ("addproperty: invalid graphics object (= %g)", h);
-	    }
-	  else
-	    error ("addproperty: invalid handle value");
-	}
+        {
+          double h = args(1).double_value ();
+
+          if (! error_state)
+            {
+              graphics_handle gh = gh_manager::lookup (h);
+
+              if (gh.ok ())
+                {
+                  graphics_object go = gh_manager::get_object (gh);
+
+                  std::string type = args(2).string_value ();
+
+                  if (! error_state)
+                    {
+                      if (! go.get_properties ().has_property (name))
+                        {
+                          property p = property::create (name, gh, type,
+                                                         args.splice (0, 3));
+
+                          if (! error_state)
+                            go.get_properties ().insert_property (name, p);
+                        }
+                      else
+                        error ("addproperty: a `%s' property already exists in the graphics object",
+                               name.c_str ());
+                    }
+                  else
+                    error ("addproperty: invalid property type, expected a string value");
+                }
+              else
+                error ("addproperty: invalid graphics object (= %g)", h);
+            }
+          else
+            error ("addproperty: invalid handle value");
+        }
       else
-	error ("addproperty: invalid property name, expected a string value");
+        error ("addproperty: invalid property name, expected a string value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 octave_value
 get_property_from_handle (double handle, const std::string& property,
-			  const std::string& func)
+                          const std::string& func)
 {
   gh_manager::autolock guard;
 
   graphics_object obj = gh_manager::get_object (handle);
   octave_value retval;
 
   if (obj)
     retval = obj.get (caseless_str (property));
   else
     error ("%s: invalid handle (= %g)", func.c_str(), handle);
 
   return retval;
 }
 
 bool
 set_property_in_handle (double handle, const std::string& property,
-			const octave_value& arg, const std::string& func)
+                        const octave_value& arg, const std::string& func)
 {
   gh_manager::autolock guard;
 
   graphics_object obj = gh_manager::get_object (handle);
   int ret = false;
 
   if (obj)
     {
       obj.set (caseless_str (property), arg);
 
       if (! error_state)
-	ret = true;
+        ret = true;
     }
   else
     error ("%s: invalid handle (= %g)", func.c_str(), handle);
 
   return ret;
 }
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -60,17 +60,17 @@ gripe_nonconformant (void)
 {
   error ("nonconformant matrices");
 }
 
 void
 gripe_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
 {
   error ("nonconformant matrices (op1 is %dx%d, op2 is %dx%d)",
-	 r1, c1, r2, c2);
+         r1, c1, r2, c2);
 }
 
 void
 gripe_empty_arg (const char *name, bool is_error)
 {
   if (is_error)
     error ("%s: empty matrix is invalid as an argument", name);
   else
@@ -143,26 +143,26 @@ gripe_wrong_type_arg (const char *name, 
 void
 gripe_wrong_type_arg (const char *name, const std::string& s, bool is_error)
 {
   gripe_wrong_type_arg (name, s.c_str (), is_error);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
-		      bool is_error)
+                      bool is_error)
 {
   std::string type = tc.type_name ();
 
   gripe_wrong_type_arg (name, type, is_error);
 }
 
 void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
-		      bool is_error)
+                      bool is_error)
 {
   gripe_wrong_type_arg (name.c_str (), tc, is_error);
 }
 
 void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
@@ -179,34 +179,34 @@ gripe_wrong_type_arg_for_binary_op (cons
 void
 gripe_implicit_conversion (const char *id, const char *from, const char *to)
 {
   warning_with_id (id, "implicit conversion from %s to %s", from, to);
 }
 
 void
 gripe_implicit_conversion (const std::string& id,
-			   const std::string& from, const std::string& to)
+                           const std::string& from, const std::string& to)
 {
   warning_with_id (id.c_str (),
-		   "implicit conversion from %s to %s",
-		   from.c_str (), to.c_str ());
+                   "implicit conversion from %s to %s",
+                   from.c_str (), to.c_str ());
 }
 
 void
 gripe_divide_by_zero (void)
 {
   warning_with_id ("Octave:divide-by-zero", "division by zero");
 }
 
 void
 gripe_logical_conversion (void)
 {
   warning_with_id ("Octave:logical-conversion",
-		   "value not equal to 1 or 0 converted to logical 1");
+                   "value not equal to 1 or 0 converted to logical 1");
 }
 
 void
 gripe_truncated_conversion (const char *srctype, const char *desttype)
 {
   warning_with_id ("Octave:int-convert-overflow", 
                    "data truncated converting from %s to %s",
                    srctype, desttype);
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -621,48 +621,48 @@ looks_like_texinfo (const std::string& m
 
   size_t p2 = t.find ("-*- texinfo -*-");
 
   return (p2 != std::string::npos);
 }
 
 static bool
 raw_help_from_symbol_table (const std::string& nm, std::string& h, 
-			    std::string& w, bool& symbol_found)
+                            std::string& w, bool& symbol_found)
 {
   bool retval = false;
 
   octave_value val = symbol_table::find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
-	{
-	  symbol_found = true;
+        {
+          symbol_found = true;
 
-	  h = fcn->doc_string ();
+          h = fcn->doc_string ();
 
           retval = true;
 
-	  w = fcn->fcn_file_name ();
+          w = fcn->fcn_file_name ();
 
-	  if (w.empty ())
+          if (w.empty ())
             w = fcn->is_user_function ()
               ? "command-line function" : "built-in function";
-	}
+        }
     }
 
   return retval;
 }
 
 static bool
 raw_help_from_file (const std::string& nm, std::string& h, 
-		    std::string& file, bool& symbol_found)
+                    std::string& file, bool& symbol_found)
 {
   bool retval = false;
 
   // FIXME -- this is a bit of a kluge...
   unwind_protect frame;
   frame.protect_var (reading_script_file);
   reading_script_file = true;
 
@@ -671,17 +671,17 @@ raw_help_from_file (const std::string& n
   if (h.length () > 0)
     retval = true;
 
   return retval;
 }
 
 static bool
 raw_help_from_map (const std::string& nm, std::string& h, 
-		   const map_type& map, bool& symbol_found)
+                   const map_type& map, bool& symbol_found)
 {
   map_iter idx = map.find (nm);
   symbol_found = (idx != map.end ());
   h = (symbol_found) ? idx->second : "";
   return symbol_found;
 }
 
 std::string
@@ -696,17 +696,17 @@ raw_help (const std::string& nm, bool& s
    || raw_help_from_map (nm, h, operators_map, symbol_found)
    || raw_help_from_map (nm, h, keywords_map, symbol_found));
 
   return h;
 }
 
 static void
 do_get_help_text (const std::string& name, std::string& text,
-		  std::string& format)
+                  std::string& format)
 {
   bool symbol_found = false;
   text = raw_help (name, symbol_found);
   
   format = "Not found";
   if (symbol_found)
     {
       size_t idx = -1;
@@ -746,37 +746,37 @@ To convert the help text to other format
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       const std::string name = args (0).string_value ();
 
       if (! error_state)
-	{
-	  std::string text;
-	  std::string format;
+        {
+          std::string text;
+          std::string format;
 
-	  do_get_help_text (name, text, format);
+          do_get_help_text (name, text, format);
   
-	  retval(1) = format;
-	  retval(0) = text;
-	}
+          retval(1) = format;
+          retval(0) = text;
+        }
       else
-	error ("get_help_text: invalid input");
+        error ("get_help_text: invalid input");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static void
 do_get_help_text_from_file (const std::string& fname, std::string& text,
-			    std::string& format)
+                            std::string& format)
 {
   bool symbol_found = false;
 
   std::string f;
 
   raw_help_from_file (fname, text, f, symbol_found);
 
   format = "Not found";
@@ -820,27 +820,27 @@ To convert the help text to other format
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       const std::string fname = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string text;
-	  std::string format;
+        {
+          std::string text;
+          std::string format;
 
-	  do_get_help_text_from_file (fname, text, format);
+          do_get_help_text_from_file (fname, text, format);
   
-	  retval(1) = format;
-	  retval(0) = text;
-	}
+          retval(1) = format;
+          retval(0) = text;
+        }
       else
-	error ("get_help_text_from_file: invalid input");
+        error ("get_help_text_from_file: invalid input");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // Return a cell array of strings containing the names of all
@@ -956,44 +956,44 @@ Undocumented internal function.\n\
 
   string_vector argv = args.make_argv ("which");
 
   if (! error_state)
     {
       int argc = argv.length ();
 
       if (argc > 1)
-	{
-	  Octave_map m (dim_vector (1, argc-1));
+        {
+          Octave_map m (dim_vector (1, argc-1));
 
-	  Cell names (1, argc-1);
-	  Cell files (1, argc-1);
-	  Cell types (1, argc-1);
+          Cell names (1, argc-1);
+          Cell files (1, argc-1);
+          Cell types (1, argc-1);
 
-	  for (int i = 1; i < argc; i++)
-	    {
-	      std::string name = argv[i];
+          for (int i = 1; i < argc; i++)
+            {
+              std::string name = argv[i];
 
-	      std::string type;
+              std::string type;
 
-	      std::string file = do_which (name, type);
+              std::string file = do_which (name, type);
 
-	      names(i-1) = name;
-	      files(i-1) = file;
-	      types(i-1) = type;
-	    }
+              names(i-1) = name;
+              files(i-1) = file;
+              types(i-1) = type;
+            }
 
-	  m.assign ("name", names);
-	  m.assign ("file", files);
-	  m.assign ("type", types);
+          m.assign ("name", names);
+          m.assign ("file", files);
+          m.assign ("type", types);
 
-	  retval = m;
-	}
+          retval = m;
+        }
       else
-	print_usage ();
+        print_usage ();
     }
 
   return retval;
 }
 
 // FIXME -- Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
@@ -1034,29 +1034,29 @@ Undocumented internal function.\n\
   
   if (args.length () == 0)
     retval = Cell (ffl.append (afl));
   else
     {
       std::string dir = args (0).string_value ();
 
       if (! error_state)
-	{
-	  string_vector fl = load_path::files (dir, true);
+        {
+          string_vector fl = load_path::files (dir, true);
 
-	  if (! error_state)
-	    {
-	      // Return a sorted list with unique entries (in case of
-	      // .m and .oct versions of the same function in a given
-	      // directory, for example).
-	      fl.sort (true);
+          if (! error_state)
+            {
+              // Return a sorted list with unique entries (in case of
+              // .m and .oct versions of the same function in a given
+              // directory, for example).
+              fl.sort (true);
 
-	      retval = Cell (fl);
-	    }
-	}
+              retval = Cell (fl);
+            }
+        }
       else
         error ("__list_functions__: input must be a string");
     }  
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -167,32 +167,32 @@ do_input_echo (const std::string& input_
 {
   int do_echo = reading_script_file ?
     (Vecho_executing_commands & ECHO_SCRIPTS)
       : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
 
   if (do_echo)
     {
       if (forced_interactive)
-	{
-	  if (promptflag > 0)
-	    octave_stdout << command_editor::decode_prompt_string (VPS1);
-	  else
-	    octave_stdout << command_editor::decode_prompt_string (VPS2);
-	}
+        {
+          if (promptflag > 0)
+            octave_stdout << command_editor::decode_prompt_string (VPS1);
+          else
+            octave_stdout << command_editor::decode_prompt_string (VPS2);
+        }
       else
-	octave_stdout << command_editor::decode_prompt_string (VPS4);
+        octave_stdout << command_editor::decode_prompt_string (VPS4);
 
       if (! input_string.empty ())
-	{
-	  octave_stdout << input_string;
+        {
+          octave_stdout << input_string;
 
-	  if (input_string[input_string.length () - 1] != '\n')
-	    octave_stdout << "\n";
-	}
+          if (input_string[input_string.length () - 1] != '\n')
+            octave_stdout << "\n";
+        }
     }
 }
 
 std::string
 gnu_readline (const std::string& s, bool force_readline)
 {
   octave_quit ();
 
@@ -200,32 +200,32 @@ gnu_readline (const std::string& s, bool
 
   if (line_editing || force_readline)
     {
       bool eof;
 
       retval = command_editor::readline (s, eof);
 
       if (! eof && retval.empty ())
-	retval = "\n";
+        retval = "\n";
     }
   else
     {
       if (! s.empty () && (interactive || forced_interactive))
-	{
-	  FILE *stream = command_editor::get_output_stream ();
+        {
+          FILE *stream = command_editor::get_output_stream ();
 
-	  fputs (s.c_str (), stream);
-	  fflush (stream);
-	}
+          fputs (s.c_str (), stream);
+          fflush (stream);
+        }
 
       FILE *curr_stream = command_editor::get_input_stream ();
 
       if (reading_fcn_file || reading_script_file || reading_classdef_file)
-	curr_stream = ff_instream;
+        curr_stream = ff_instream;
 
       retval = octave_fgets (curr_stream);
     }
 
   return retval;
 }
 
 static inline std::string
@@ -240,87 +240,87 @@ interactive_input (const std::string& s,
       flush_octave_stdout ();
 
       // We set Vdrawnow_requested to false even if there is an error
       // in drawnow so that the error doesn't reappear at every prompt.
 
       Vdrawnow_requested = false;
 
       if (error_state)
-	return "\n";
+        return "\n";
     }
 
   return gnu_readline (s, force_readline);
 }
 
 static std::string
 octave_gets (void)
 {
   octave_quit ();
 
   std::string retval;
 
   bool history_skip_auto_repeated_debugging_command = false;
 
   if ((interactive || forced_interactive)
       && (! (reading_fcn_file
-	     || reading_classdef_file
-	     || reading_script_file
-	     || get_input_from_eval_string
-	     || input_from_startup_file
-	     || input_from_command_line_file)))
+             || reading_classdef_file
+             || reading_script_file
+             || get_input_from_eval_string
+             || input_from_startup_file
+             || input_from_command_line_file)))
     {
       std::string ps = (promptflag > 0) ? VPS1 : VPS2;
 
       std::string prompt = command_editor::decode_prompt_string (ps);
 
       pipe_handler_error_count = 0;
 
       flush_octave_stdout ();
 
       octave_diary << prompt;
 
       retval = interactive_input (prompt);
 
       // There is no need to update the load_path cache if there is no
       // user input.
       if (! retval.empty ()
-	  && retval.find_first_not_of (" \t\n\r") != std::string::npos)
-	{
-	  load_path::update ();
+          && retval.find_first_not_of (" \t\n\r") != std::string::npos)
+        {
+          load_path::update ();
 
-	  if (Vdebugging)
-	    last_debugging_command = retval;
-	  else
-	    last_debugging_command = std::string ();
-	}
+          if (Vdebugging)
+            last_debugging_command = retval;
+          else
+            last_debugging_command = std::string ();
+        }
       else if (Vdebugging)
-	{
-	  retval = last_debugging_command;
-	  history_skip_auto_repeated_debugging_command = true;
-	}
+        {
+          retval = last_debugging_command;
+          history_skip_auto_repeated_debugging_command = true;
+        }
     }
   else
     retval = gnu_readline ("");
 
   current_input_line = retval;
 
   if (! current_input_line.empty ())
     {
       if (! (input_from_startup_file || input_from_command_line_file
-	     || history_skip_auto_repeated_debugging_command))
-	command_history::add (current_input_line);
+             || history_skip_auto_repeated_debugging_command))
+        command_history::add (current_input_line);
 
       if (! (reading_fcn_file || reading_script_file || reading_classdef_file))
-	{
-	  octave_diary << current_input_line;
+        {
+          octave_diary << current_input_line;
 
-	  if (current_input_line[current_input_line.length () - 1] != '\n')
-	    octave_diary << "\n";
-	}
+          if (current_input_line[current_input_line.length () - 1] != '\n')
+            octave_diary << "\n";
+        }
 
       do_input_echo (current_input_line);
     }
   else if (! (reading_fcn_file || reading_script_file || reading_classdef_file))
     octave_diary << "\n";
 
   return retval;
 }
@@ -332,26 +332,26 @@ get_user_input (void)
 {
   octave_quit ();
 
   std::string retval;
 
   if (get_input_from_eval_string)
     {
       if (input_from_eval_string_pending)
-	{
-	  input_from_eval_string_pending = false;
+        {
+          input_from_eval_string_pending = false;
 
-	  retval = current_eval_string;
+          retval = current_eval_string;
 
-	  size_t len = retval.length ();
+          size_t len = retval.length ();
 
-	  if (len > 0 && retval[len-1] != '\n')
-	    retval.append ("\n");
-	}
+          if (len > 0 && retval[len-1] != '\n')
+            retval.append ("\n");
+        }
     }
   else
     retval = octave_gets ();
 
   current_input_line = retval;
 
   return retval;
 }
@@ -385,32 +385,32 @@ octave_read (char *buf, unsigned max_siz
 
       memcpy (buf, pos, len);
 
       chars_left -= len;
       pos += len;
 
       // Make sure input ends with a new line character.
       if (chars_left == 0 && buf[len-1] != '\n')
-	{
-	  if (len < max_size)
-	    {
-	      // There is enough room to plug the newline character in
-	      // the buffer.
-	      buf[len++] = '\n';
-	    }
-	  else
-	    {
-	      // There isn't enough room to plug the newline character
-	      // in the buffer so make sure it is returned on the next
-	      // octave_read call.
-	      pos = eol;
-	      chars_left = 1;
-	    }
-	}
+        {
+          if (len < max_size)
+            {
+              // There is enough room to plug the newline character in
+              // the buffer.
+              buf[len++] = '\n';
+            }
+          else
+            {
+              // There isn't enough room to plug the newline character
+              // in the buffer so make sure it is returned on the next
+              // octave_read call.
+              pos = eol;
+              chars_left = 1;
+            }
+        }
 
       status = len;
 
     }
   else if (chars_left == 0)
     {
       status = 0;
     }
@@ -452,17 +452,17 @@ get_input_from_stdin (void)
   command_editor::set_input_stream (stdin);
   return command_editor::get_input_stream ();
 }
 
 // FIXME -- make this generate file names when appropriate.
 
 static string_vector
 generate_possible_completions (const std::string& text, std::string& prefix,
-			       std::string& hint)
+                               std::string& hint)
 {
   string_vector names;
 
   prefix = "";
 
   if (looks_like_struct (text))
     names = generate_struct_completions (text, prefix, hint);
   else
@@ -485,20 +485,20 @@ is_completing_dirfns (void)
 
   std::string line = command_editor::get_line_buffer ();
 
   for (size_t i = 0; i < dirfns_commands_length; i++)
     {
       int index = line.find (dirfns_commands[i] + " ");
 
       if (index == 0)
-	{
-	  retval = true;
-	  break;
-	}
+        {
+          retval = true;
+          break;
+        }
     }
 
   return retval;
 }
 
 static std::string
 generate_completion (const std::string& text, int state)
 {
@@ -524,69 +524,69 @@ generate_completion (const std::string& 
       prefix = "";
 
       hint = text;
 
       // No reason to display symbols while completing a
       // file/directory operation.
 
       if (is_completing_dirfns ())
-	name_list = string_vector ();
+        name_list = string_vector ();
       else
         name_list = generate_possible_completions (text, prefix, hint);
 
       name_list_len = name_list.length ();
 
       file_name_list = command_editor::generate_filename_completions (text);
 
       name_list.append (file_name_list);
 
       name_list_total_len = name_list.length ();
 
       hint_len = hint.length ();
 
       matches = 0;
 
       for (int i = 0; i < name_list_len; i++)
-	if (hint == name_list[i].substr (0, hint_len))
-	  matches++;
+        if (hint == name_list[i].substr (0, hint_len))
+          matches++;
     }
 
   if (name_list_total_len > 0 && matches > 0)
     {
       while (list_index < name_list_total_len)
-	{
-	  std::string name = name_list[list_index];
+        {
+          std::string name = name_list[list_index];
 
-	  list_index++;
+          list_index++;
 
-	  if (hint == name.substr (0, hint_len))
-	    {
-	      if (list_index <= name_list_len && ! prefix.empty ())
-		retval = prefix + "." + name;
-	      else
-		retval = name;
+          if (hint == name.substr (0, hint_len))
+            {
+              if (list_index <= name_list_len && ! prefix.empty ())
+                retval = prefix + "." + name;
+              else
+                retval = name;
 
-	      // FIXME -- looks_like_struct is broken for now,
-	      // so it always returns false.
+              // FIXME -- looks_like_struct is broken for now,
+              // so it always returns false.
 
-	      if (matches == 1 && looks_like_struct (retval))
- 		{
- 		  // Don't append anything, since we don't know
- 		  // whether it should be '(' or '.'.
+              if (matches == 1 && looks_like_struct (retval))
+                {
+                  // Don't append anything, since we don't know
+                  // whether it should be '(' or '.'.
 
- 		  command_editor::set_completion_append_character ('\0');
- 		}
- 	      else
- 		command_editor::set_completion_append_character
- 		  (Vcompletion_append_char);
+                  command_editor::set_completion_append_character ('\0');
+                }
+              else
+                command_editor::set_completion_append_character
+                  (Vcompletion_append_char);
 
-	      break;
-	    }
-	}
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 static std::string
 quoting_filename (const std::string &text, int, char quote)
 {
@@ -633,53 +633,53 @@ get_debug_input (const std::string& prom
 
   bool have_file = false;
 
   if (caller)
     {
       nm = caller->fcn_file_name ();
 
       if (nm.empty ())
-	nm = caller->name ();
+        nm = caller->name ();
       else
-	have_file = true;
+        have_file = true;
     }
   else
     curr_debug_line = -1;
 
   std::ostringstream buf;
 
   if (! nm.empty ())
     {
       if (Vgud_mode)
-	{
-	  static char ctrl_z = 'Z' & 0x1f;
+        {
+          static char ctrl_z = 'Z' & 0x1f;
 
-	  buf << ctrl_z << ctrl_z << nm << ":" << curr_debug_line;
-	}
+          buf << ctrl_z << ctrl_z << nm << ":" << curr_debug_line;
+        }
       else
-	{
-	  // FIXME -- we should come up with a clean way to detect
-	  // that we are stopped on the no-op command that marks the
-	  // end of a function or script.
+        {
+          // FIXME -- we should come up with a clean way to detect
+          // that we are stopped on the no-op command that marks the
+          // end of a function or script.
 
-	  buf << "stopped in " << nm;
+          buf << "stopped in " << nm;
 
-	  if (curr_debug_line > 0)
-	    buf << " at line " << curr_debug_line;
+          if (curr_debug_line > 0)
+            buf << " at line " << curr_debug_line;
 
-	  if (have_file)
-	    {
-	      std::string line_buf
-		= get_file_line (nm, curr_debug_line);
+          if (have_file)
+            {
+              std::string line_buf
+                = get_file_line (nm, curr_debug_line);
 
-	      if (! line_buf.empty ())
-		buf << "\n" << curr_debug_line << ": " << line_buf;
-	    }
-	}
+              if (! line_buf.empty ())
+                buf << "\n" << curr_debug_line << ": " << line_buf;
+            }
+        }
     }
 
   std::string msg = buf.str ();
 
   if (! msg.empty ())
     std::cerr << msg << std::endl;
 
   unwind_protect frame;
@@ -800,45 +800,45 @@ get_user_input (const octave_value_list&
 
   octave_diary << prompt;
 
   std::string input_buf = interactive_input (prompt.c_str (), true);
 
   if (! (error_state || input_buf.empty ()))
     {
       if (! input_from_startup_file)
-	command_history::add (input_buf);
+        command_history::add (input_buf);
 
       size_t len = input_buf.length ();
 
       octave_diary << input_buf;
 
       if (input_buf[len - 1] != '\n')
-	octave_diary << "\n";
+        octave_diary << "\n";
 
       if (len < 1)
-	return read_as_string ? octave_value ("") : octave_value (Matrix ());
+        return read_as_string ? octave_value ("") : octave_value (Matrix ());
 
       if (read_as_string)
-	{
-	  // FIXME -- fix gnu_readline and octave_gets instead!
-	  if (input_buf.length () == 1 && input_buf[0] == '\n')
-	    retval(0) = "";
-	  else
-	    retval(0) = input_buf;
-	}
+        {
+          // FIXME -- fix gnu_readline and octave_gets instead!
+          if (input_buf.length () == 1 && input_buf[0] == '\n')
+            retval(0) = "";
+          else
+            retval(0) = input_buf;
+        }
       else
-	{
-	  int parse_status = 0;
+        {
+          int parse_status = 0;
 
-	  retval = eval_string (input_buf, true, parse_status, nargout);
+          retval = eval_string (input_buf, true, parse_status, nargout);
 
-	  if (! Vdebugging && retval.length () == 0)
-	    retval(0) = Matrix ();
-	}
+          if (! Vdebugging && retval.length () == 0)
+            retval(0) = Matrix ();
+        }
     }
   else
     error ("input: reading user-input failed!");
 
   return retval;
 }
 
 DEFUN (input, args, nargout,
@@ -894,21 +894,21 @@ octave_yes_or_no (const std::string& pro
 {
   std::string prompt_string = prompt + "(yes or no) ";
 
   while (1)
     {
       std::string input_buf = interactive_input (prompt_string, true);
 
       if (input_buf == "yes")
-	return true;
+        return true;
       else if (input_buf == "no")
-	return false;
+        return false;
       else
-	message (0, "Please answer yes or no.");
+        message (0, "Please answer yes or no.");
     }
 }
 
 DEFUN (yes_or_no, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} yes_or_no (@var{prompt})\n\
 Ask the user a yes-or-no question.  Return 1 if the answer is yes.\n\
 Takes one argument, which is the string to display to ask the\n\
@@ -921,25 +921,25 @@ RET and can edit it until it has been co
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
       std::string prompt;
 
       if (nargin == 1)
-	{
-	  prompt = args(0).string_value ();
+        {
+          prompt = args(0).string_value ();
 
-	  if (error_state)
-	    {
-	      error ("yes_or_no: expecting argument to be character string");
-	      return retval;
-	    }
-	}
+          if (error_state)
+            {
+              error ("yes_or_no: expecting argument to be character string");
+              return retval;
+            }
+        }
 
       retval = octave_yes_or_no (prompt);
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -1064,50 +1064,50 @@ With no arguments, @code{echo} toggles t
 
   if (error_state)
     return retval;
 
   switch (argc)
     {
     case 1:
       {
-	if ((Vecho_executing_commands & ECHO_SCRIPTS)
-	    || (Vecho_executing_commands & ECHO_FUNCTIONS))
-	  Vecho_executing_commands = ECHO_OFF;
-	else
-	  Vecho_executing_commands = ECHO_SCRIPTS;
+        if ((Vecho_executing_commands & ECHO_SCRIPTS)
+            || (Vecho_executing_commands & ECHO_FUNCTIONS))
+          Vecho_executing_commands = ECHO_OFF;
+        else
+          Vecho_executing_commands = ECHO_SCRIPTS;
       }
       break;
 
     case 2:
       {
-	std::string arg = argv[1];
+        std::string arg = argv[1];
 
-	if (arg == "on")
-	  Vecho_executing_commands = ECHO_SCRIPTS;
-	else if (arg == "off")
-	  Vecho_executing_commands = ECHO_OFF;
-	else
-	  print_usage ();
+        if (arg == "on")
+          Vecho_executing_commands = ECHO_SCRIPTS;
+        else if (arg == "off")
+          Vecho_executing_commands = ECHO_OFF;
+        else
+          print_usage ();
       }
       break;
 
     case 3:
       {
-	std::string arg = argv[1];
+        std::string arg = argv[1];
 
-	if (arg == "on" && argv[2] == "all")
-	  {
-	    int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
-	    Vecho_executing_commands = tmp;
-	  }
-	else if (arg == "off" && argv[2] == "all")
-	  Vecho_executing_commands = ECHO_OFF;
-	else
-	  print_usage ();
+        if (arg == "on" && argv[2] == "all")
+          {
+            int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
+            Vecho_executing_commands = tmp;
+          }
+        else if (arg == "off" && argv[2] == "all")
+          Vecho_executing_commands = ECHO_OFF;
+        else
+          print_usage ();
       }
       break;
 
     default:
       print_usage ();
       break;
     }
 
@@ -1129,65 +1129,65 @@ a feature, not a bug.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string hint = args(0).string_value ();
 
       if (! error_state)
-	{
-	  int n = 32;
+        {
+          int n = 32;
 
-	  string_vector list (n);
+          string_vector list (n);
 
-	  int k = 0;
+          int k = 0;
 
-	  for (;;)
-	    {
-	      std::string cmd = generate_completion (hint, k);
+          for (;;)
+            {
+              std::string cmd = generate_completion (hint, k);
 
-	      if (! cmd.empty ())
-		{
-		  if (k == n)
-		    {
-		      n *= 2;
-		      list.resize (n);
-		    }
+              if (! cmd.empty ())
+                {
+                  if (k == n)
+                    {
+                      n *= 2;
+                      list.resize (n);
+                    }
 
-		  list[k++] = cmd;
-		}
-	      else
-		{
-		  list.resize (k);
-		  break;
-		}
-	    }
+                  list[k++] = cmd;
+                }
+              else
+                {
+                  list.resize (k);
+                  break;
+                }
+            }
 
-	  if (nargout > 0)
-	    {
-	      if (! list.empty ())
-		retval = list;
-	      else
-		retval = "";
-	    }
-	  else
-	    {
-	      // We don't use string_vector::list_in_columns here
-	      // because it will be easier for Emacs if the names
-	      // appear in a single column.
+          if (nargout > 0)
+            {
+              if (! list.empty ())
+                retval = list;
+              else
+                retval = "";
+            }
+          else
+            {
+              // We don't use string_vector::list_in_columns here
+              // because it will be easier for Emacs if the names
+              // appear in a single column.
 
-	      int len = list.length ();
+              int len = list.length ();
 
-	      for (int i = 0; i < len; i++)
-		octave_stdout << list[i] << "\n";
-	    }
+              for (int i = 0; i < len; i++)
+                octave_stdout << list[i] << "\n";
+            }
 
-	  octave_completion_matches_called = true;
-	}
+          octave_completion_matches_called = true;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (read_readline_init_file, args, ,
@@ -1207,17 +1207,17 @@ for details.\n\
 
   if (nargin == 0)
     command_editor::read_init_file ();
   else if (nargin == 1)
     {
       std::string file = args(0).string_value ();
 
       if (! error_state)
-	command_editor::read_init_file (file);
+        command_editor::read_init_file (file);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (re_read_readline_init_file, args, ,
@@ -1250,24 +1250,24 @@ input_event_hook (void)
   while (p != hook_fcn_map.end ())
     {
       std::string hook_fcn = p->first;
       octave_value user_data = p->second;
 
       p++;
 
       if (is_valid_function (hook_fcn))
-	{
-	  if (user_data.is_defined ())
-	    feval (hook_fcn, user_data, 0);
-	  else
-	    feval (hook_fcn, octave_value_list (), 0);
-	}
+        {
+          if (user_data.is_defined ())
+            feval (hook_fcn, user_data, 0);
+          else
+            feval (hook_fcn, octave_value_list (), 0);
+        }
       else
-	hook_fcn_map.erase (p);
+        hook_fcn_map.erase (p);
     }
 
   if (hook_fcn_map.empty ())
     command_editor::remove_event_hook (input_event_hook);
 
   return 0;
 }
 
@@ -1290,29 +1290,29 @@ arguments.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_value user_data;
 
       if (nargin == 2)
-	user_data = args(1);
+        user_data = args(1);
 
       std::string hook_fcn = args(0).string_value ();
 
       if (! error_state)
-	{
-	  if (hook_fcn_map.empty ())
-	    command_editor::add_event_hook (input_event_hook);
+        {
+          if (hook_fcn_map.empty ())
+            command_editor::add_event_hook (input_event_hook);
 
-	  hook_fcn_map[hook_fcn] = user_data;
-	}
+          hook_fcn_map[hook_fcn] = user_data;
+        }
       else
-	error ("add_input_event_hook: expecting string as first arg");
+        error ("add_input_event_hook: expecting string as first arg");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (remove_input_event_hook, args, ,
@@ -1327,30 +1327,30 @@ periodically when Octave is waiting for 
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string hook_fcn = args(0).string_value ();
 
       if (! error_state)
-	{
-	  hook_fcn_map_type::iterator p = hook_fcn_map.find (hook_fcn);
+        {
+          hook_fcn_map_type::iterator p = hook_fcn_map.find (hook_fcn);
 
-	  if (p != hook_fcn_map.end ())
-	    hook_fcn_map.erase (p);
-	  else
-	    error ("remove_input_event_hook: %s not found in list",
-		   hook_fcn.c_str ());
+          if (p != hook_fcn_map.end ())
+            hook_fcn_map.erase (p);
+          else
+            error ("remove_input_event_hook: %s not found in list",
+                   hook_fcn.c_str ());
 
-	  if (hook_fcn_map.empty ())
-	    command_editor::remove_event_hook (input_event_hook);
-	}
+          if (hook_fcn_map.empty ())
+            command_editor::remove_event_hook (input_event_hook);
+        }
       else
-	error ("remove_input_event_hook: expecting string as first arg");
+        error ("remove_input_event_hook: expecting string as first arg");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (PS1, args, nargout,
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -114,20 +114,20 @@ along with Octave; see the file COPYING.
 #define DISPLAY_TOK_AND_RETURN(tok) \
   do \
     { \
       int tok_val = tok; \
       if (Vdisplay_tokens) \
         display_token (tok_val); \
       if (lexer_debug_flag) \
         { \
-	  std::cerr << "R: "; \
+          std::cerr << "R: "; \
           display_token (tok_val); \
-	  std::cerr << std::endl;  \
-	} \
+          std::cerr << std::endl;  \
+        } \
       return tok_val; \
     } \
   while (0)
 
 #define COUNT_TOK_AND_RETURN(tok) \
   do \
     { \
       Vtoken_count++; \
@@ -144,17 +144,17 @@ along with Octave; see the file COPYING.
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_PUSH_AND_RETURN(name, tok) \
   do \
     { \
       yylval.tok_val = new token (name, input_line_number, \
-				  current_input_column); \
+                                  current_input_column); \
       token_stack.push (yylval.tok_val); \
       TOK_RETURN (tok); \
     } \
   while (0)
 
 #define BIN_OP_RETURN(tok, convert, bos) \
   do \
     { \
@@ -227,17 +227,17 @@ public:
     { return ! context.empty () && context.top () == BRACE; }
 
   void paren (void) {  context.push (PAREN); }
   bool is_paren (void)
     { return ! context.empty () && context.top () == PAREN; }
 
   bool is_bracket_or_brace (void)
     { return (! context.empty ()
-	      && (context.top () == BRACKET || context.top () == BRACE)); }
+              && (context.top () == BRACKET || context.top () == BRACE)); }
 
   bool none (void) { return context.empty (); }
 
   void remove (void) { if (! context.empty ()) context.pop (); }
 
   void clear (void) { while (! context.empty ()) context.pop (); }
 
 private:
@@ -302,33 +302,33 @@ static void gripe_matlab_incompatible (c
 static void maybe_gripe_matlab_incompatible_comment (char c);
 static void gripe_matlab_incompatible_continuation (void);
 static void gripe_matlab_incompatible_operator (const std::string& op);
 static void display_token (int tok);
 static void lexer_debug (const char *pattern, const char *text);
 
 %}
 
-D	[0-9]
-S	[ \t]
-NL	((\n)|(\r)|(\r\n))
-SNL	({S}|{NL})
-EL	(\.\.\.)
-BS	(\\)
-CONT	({EL}|{BS})
-Im	[iIjJ]
-CCHAR	[#%]
-COMMENT	({CCHAR}.*{NL})
-SNLCMT	({SNL}|{COMMENT})
-NOT	((\~)|(\!))
+D       [0-9]
+S       [ \t]
+NL      ((\n)|(\r)|(\r\n))
+SNL     ({S}|{NL})
+EL      (\.\.\.)
+BS      (\\)
+CONT    ({EL}|{BS})
+Im      [iIjJ]
+CCHAR   [#%]
+COMMENT ({CCHAR}.*{NL})
+SNLCMT  ({SNL}|{COMMENT})
+NOT     ((\~)|(\!))
 POW     ((\*\*)|(\^))
 EPOW    (\.{POW})
-IDENT	([_$a-zA-Z][_$a-zA-Z0-9]*)
-EXPON	([DdEe][+-]?{D}+)
-NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EXPON}?)|(0[xX][0-9a-fA-F]+))
+IDENT   ([_$a-zA-Z][_$a-zA-Z0-9]*)
+EXPON   ([DdEe][+-]?{D}+)
+NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{EXPON}?)|(0[xX][0-9a-fA-F]+))
 %%
 
 %{
 // Make script and function files start with a bogus token. This makes
 // the parser go down a special path.
 %}
 
 <SCRIPT_FILE_BEGIN>. {
@@ -479,22 +479,22 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     if (! lexer_flags.looking_at_object_index.front ())
       {
-	if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
-	  {
-	    maybe_warn_separator_insert (';');
-
-	    xunput (';', yytext);
-	  }
+        if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
+          {
+            maybe_warn_separator_insert (';');
+
+            xunput (';', yytext);
+          }
       }
 
     COUNT_TOK_AND_RETURN (',');
   }
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
 // If commas are required, spaces are not important in matrix
@@ -508,38 +508,38 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     current_input_column += yyleng;
 
     lexer_flags.at_beginning_of_statement = false;
 
     int tmp = eat_continuation ();
 
     if (! lexer_flags.looking_at_object_index.front ())
       {
-	bool bin_op = next_token_is_bin_op (true);
-	bool postfix_un_op = next_token_is_postfix_unary_op (true);
-	bool sep_op = next_token_is_sep_op ();
-
-	if (! (postfix_un_op || bin_op || sep_op)
-	    && nesting_level.is_bracket_or_brace ()
-	    && lexer_flags.convert_spaces_to_comma)
-	  {
-	    if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
-	      {
-		maybe_warn_separator_insert (';');
-
-		xunput (';', yytext);
-	      }
-
-	    lexer_flags.quote_is_transpose = false;
-	    lexer_flags.convert_spaces_to_comma = true;
-
-	    maybe_warn_separator_insert (',');
-
-	    COUNT_TOK_AND_RETURN (',');
-	  }
+        bool bin_op = next_token_is_bin_op (true);
+        bool postfix_un_op = next_token_is_postfix_unary_op (true);
+        bool sep_op = next_token_is_sep_op ();
+
+        if (! (postfix_un_op || bin_op || sep_op)
+            && nesting_level.is_bracket_or_brace ()
+            && lexer_flags.convert_spaces_to_comma)
+          {
+            if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
+              {
+                maybe_warn_separator_insert (';');
+
+                xunput (';', yytext);
+              }
+
+            lexer_flags.quote_is_transpose = false;
+            lexer_flags.convert_spaces_to_comma = true;
+
+            maybe_warn_separator_insert (',');
+
+            COUNT_TOK_AND_RETURN (',');
+          }
       }
   }
 
 %{
 // Semicolons are handled as row seprators in matrix constants.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 
@@ -580,21 +580,21 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.at_beginning_of_statement = false;
 
     if (nesting_level.none ())
       return LEXICAL_ERROR;
 
     if (! lexer_flags.looking_at_object_index.front ()
-	&& nesting_level.is_bracket_or_brace ())
+        && nesting_level.is_bracket_or_brace ())
       {
-	maybe_warn_separator_insert (';');
-
-	COUNT_TOK_AND_RETURN (';');
+        maybe_warn_separator_insert (';');
+
+        COUNT_TOK_AND_RETURN (';');
       }
   }
 
 \[{S}* {
     LEXER_DEBUG ("\\[{S}*");
 
     nesting_level.bracket ();
 
@@ -684,22 +684,22 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 // End of file.
 %}
 
 <<EOF>> {
     LEXER_DEBUG ("<<EOF>>");
 
     if (block_comment_nesting_level != 0)
       {
-	warning ("block comment open at end of input");
-
-	if ((reading_fcn_file || reading_script_file || reading_classdef_file)
-	    && ! curr_fcn_file_name.empty ())
-	  warning ("near line %d of file `%s.m'",
-		   input_line_number, curr_fcn_file_name.c_str ());
+        warning ("block comment open at end of input");
+
+        if ((reading_fcn_file || reading_script_file || reading_classdef_file)
+            && ! curr_fcn_file_name.empty ())
+          warning ("near line %d of file `%s.m'",
+                   input_line_number, curr_fcn_file_name.c_str ());
       }
 
     TOK_RETURN (END_OF_INPUT);
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
 // don't write directly on yytext.
@@ -781,23 +781,23 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     input_line_number++;
     current_input_column = 1;
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
 
     if (nesting_level.none ())
       {
-	lexer_flags.at_beginning_of_statement = true;
-	COUNT_TOK_AND_RETURN ('\n');
+        lexer_flags.at_beginning_of_statement = true;
+        COUNT_TOK_AND_RETURN ('\n');
       }
     else if (nesting_level.is_paren ())
       {
-	lexer_flags.at_beginning_of_statement = false;
-	gripe_matlab_incompatible ("bare newline inside parentheses");
+        lexer_flags.at_beginning_of_statement = false;
+        gripe_matlab_incompatible ("bare newline inside parentheses");
       }
     else if (nesting_level.is_bracket_or_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator. 
@@ -806,23 +806,23 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 "'" {
     LEXER_DEBUG ("'");
 
     current_input_column++;
     lexer_flags.convert_spaces_to_comma = true;
 
     if (lexer_flags.quote_is_transpose)
       {
-	do_comma_insert_check ();
-	COUNT_TOK_AND_RETURN (QUOTE);
+        do_comma_insert_check ();
+        COUNT_TOK_AND_RETURN (QUOTE);
       }
     else
       {
-	int tok = handle_string ('\'');
-	COUNT_TOK_AND_RETURN (tok);
+        int tok = handle_string ('\'');
+        COUNT_TOK_AND_RETURN (tok);
       }
   }
 
 %{
 // Double quotes always begin strings.
 %}
 
 \" {
@@ -873,49 +873,49 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
   }
 
 %{
 // Other operators.
 %}
 
 ":"     { LEXER_DEBUG (":"); BIN_OP_RETURN (':', false, false); }
 
-".+"	{ LEXER_DEBUG (".+"); XBIN_OP_RETURN (EPLUS, false, false); }
-".-"	{ LEXER_DEBUG (".-"); XBIN_OP_RETURN (EMINUS, false, false); }
-".*"	{ LEXER_DEBUG (".*"); BIN_OP_RETURN (EMUL, false, false); }
-"./"	{ LEXER_DEBUG ("./"); BIN_OP_RETURN (EDIV, false, false); }
-".\\"	{ LEXER_DEBUG (".\\"); BIN_OP_RETURN (ELEFTDIV, false, false); }
-".^"	{ LEXER_DEBUG (".^"); BIN_OP_RETURN (EPOW, false, false); }
-".**"	{ LEXER_DEBUG (".**"); XBIN_OP_RETURN (EPOW, false, false); }
-".'"	{ LEXER_DEBUG (".'"); do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
-"++"	{ LEXER_DEBUG ("++"); do_comma_insert_check (); XBIN_OP_RETURN (PLUS_PLUS, true, false); }
-"--"	{ LEXER_DEBUG ("--"); do_comma_insert_check (); XBIN_OP_RETURN (MINUS_MINUS, true, false); }
-"<="	{ LEXER_DEBUG ("<="); BIN_OP_RETURN (EXPR_LE, false, false); }
-"=="	{ LEXER_DEBUG ("=="); BIN_OP_RETURN (EXPR_EQ, false, false); }
-"~="	{ LEXER_DEBUG ("~="); BIN_OP_RETURN (EXPR_NE, false, false); }
-"!="	{ LEXER_DEBUG ("!="); XBIN_OP_RETURN (EXPR_NE, false, false); }
-">="	{ LEXER_DEBUG (">="); BIN_OP_RETURN (EXPR_GE, false, false); }
-"&"	{ LEXER_DEBUG ("&"); BIN_OP_RETURN (EXPR_AND, false, false); }
-"|"	{ LEXER_DEBUG ("|"); BIN_OP_RETURN (EXPR_OR, false, false); }
-"<"	{ LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false, false); }
-">"	{ LEXER_DEBUG (">"); BIN_OP_RETURN (EXPR_GT, false, false); }
+".+"    { LEXER_DEBUG (".+"); XBIN_OP_RETURN (EPLUS, false, false); }
+".-"    { LEXER_DEBUG (".-"); XBIN_OP_RETURN (EMINUS, false, false); }
+".*"    { LEXER_DEBUG (".*"); BIN_OP_RETURN (EMUL, false, false); }
+"./"    { LEXER_DEBUG ("./"); BIN_OP_RETURN (EDIV, false, false); }
+".\\"   { LEXER_DEBUG (".\\"); BIN_OP_RETURN (ELEFTDIV, false, false); }
+".^"    { LEXER_DEBUG (".^"); BIN_OP_RETURN (EPOW, false, false); }
+".**"   { LEXER_DEBUG (".**"); XBIN_OP_RETURN (EPOW, false, false); }
+".'"    { LEXER_DEBUG (".'"); do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
+"++"    { LEXER_DEBUG ("++"); do_comma_insert_check (); XBIN_OP_RETURN (PLUS_PLUS, true, false); }
+"--"    { LEXER_DEBUG ("--"); do_comma_insert_check (); XBIN_OP_RETURN (MINUS_MINUS, true, false); }
+"<="    { LEXER_DEBUG ("<="); BIN_OP_RETURN (EXPR_LE, false, false); }
+"=="    { LEXER_DEBUG ("=="); BIN_OP_RETURN (EXPR_EQ, false, false); }
+"~="    { LEXER_DEBUG ("~="); BIN_OP_RETURN (EXPR_NE, false, false); }
+"!="    { LEXER_DEBUG ("!="); XBIN_OP_RETURN (EXPR_NE, false, false); }
+">="    { LEXER_DEBUG (">="); BIN_OP_RETURN (EXPR_GE, false, false); }
+"&"     { LEXER_DEBUG ("&"); BIN_OP_RETURN (EXPR_AND, false, false); }
+"|"     { LEXER_DEBUG ("|"); BIN_OP_RETURN (EXPR_OR, false, false); }
+"<"     { LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false, false); }
+">"     { LEXER_DEBUG (">"); BIN_OP_RETURN (EXPR_GT, false, false); }
 "+"     { LEXER_DEBUG ("+"); BIN_OP_RETURN ('+', false, false); }
 "-"     { LEXER_DEBUG ("-"); BIN_OP_RETURN ('-', false, false); }
-"*"	{ LEXER_DEBUG ("*"); BIN_OP_RETURN ('*', false, false); }
-"/"	{ LEXER_DEBUG ("/"); BIN_OP_RETURN ('/', false, false); }
-"\\"	{ LEXER_DEBUG ("\\"); BIN_OP_RETURN (LEFTDIV, false, false); }
+"*"     { LEXER_DEBUG ("*"); BIN_OP_RETURN ('*', false, false); }
+"/"     { LEXER_DEBUG ("/"); BIN_OP_RETURN ('/', false, false); }
+"\\"    { LEXER_DEBUG ("\\"); BIN_OP_RETURN (LEFTDIV, false, false); }
 ";"     { LEXER_DEBUG (";"); BIN_OP_RETURN (';', true, true); }
 ","     { LEXER_DEBUG (","); BIN_OP_RETURN (',', true, ! lexer_flags.looking_at_object_index.front ()); }
-"^"	{ LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false, false); }
-"**"	{ LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false, false); }
-"="	{ LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true, false); }
-"&&"	{ LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false, false); }
-"||"	{ LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false, false); }
-"<<"	{ LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false, false); }
-">>"	{ LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false, false); }
+"^"     { LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false, false); }
+"**"    { LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false, false); }
+"="     { LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true, false); }
+"&&"    { LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false, false); }
+"||"    { LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false, false); }
+"<<"    { LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false, false); }
+">>"    { LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false, false); }
 
 {NOT} {
     LEXER_DEBUG ("{NOT}");
 
     if (yytext[0] == '~')
       BIN_OP_RETURN (EXPR_NOT, false, false);
     else
       XBIN_OP_RETURN (EXPR_NOT, false, false);
@@ -964,32 +964,32 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     LEXER_DEBUG (".");
 
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     TOK_RETURN ('.');
   }
 
-"+="	{ LEXER_DEBUG ("+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
-"-="	{ LEXER_DEBUG ("-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
-"*="	{ LEXER_DEBUG ("*="); XBIN_OP_RETURN (MUL_EQ, false, false); }
-"/="	{ LEXER_DEBUG ("/="); XBIN_OP_RETURN (DIV_EQ, false, false); }
-"\\="	{ LEXER_DEBUG ("\\="); XBIN_OP_RETURN (LEFTDIV_EQ, false, false); }
-".+="	{ LEXER_DEBUG (".+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
-".-="	{ LEXER_DEBUG (".-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
-".*="	{ LEXER_DEBUG (".*="); XBIN_OP_RETURN (EMUL_EQ, false, false); }
-"./="	{ LEXER_DEBUG ("./="); XBIN_OP_RETURN (EDIV_EQ, false, false); }
-".\\="	{ LEXER_DEBUG (".\\="); XBIN_OP_RETURN (ELEFTDIV_EQ, false, false); }
+"+="    { LEXER_DEBUG ("+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
+"-="    { LEXER_DEBUG ("-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
+"*="    { LEXER_DEBUG ("*="); XBIN_OP_RETURN (MUL_EQ, false, false); }
+"/="    { LEXER_DEBUG ("/="); XBIN_OP_RETURN (DIV_EQ, false, false); }
+"\\="   { LEXER_DEBUG ("\\="); XBIN_OP_RETURN (LEFTDIV_EQ, false, false); }
+".+="   { LEXER_DEBUG (".+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
+".-="   { LEXER_DEBUG (".-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
+".*="   { LEXER_DEBUG (".*="); XBIN_OP_RETURN (EMUL_EQ, false, false); }
+"./="   { LEXER_DEBUG ("./="); XBIN_OP_RETURN (EDIV_EQ, false, false); }
+".\\="  { LEXER_DEBUG (".\\="); XBIN_OP_RETURN (ELEFTDIV_EQ, false, false); }
 {POW}=  { LEXER_DEBUG ("{POW}="); XBIN_OP_RETURN (POW_EQ, false, false); }
 {EPOW}= { LEXER_DEBUG ("{EPOW}="); XBIN_OP_RETURN (EPOW_EQ, false, false); }
-"&="	{ LEXER_DEBUG ("&="); XBIN_OP_RETURN (AND_EQ, false, false); }
-"|="	{ LEXER_DEBUG ("|="); XBIN_OP_RETURN (OR_EQ, false, false); }
-"<<="	{ LEXER_DEBUG ("<<="); XBIN_OP_RETURN (LSHIFT_EQ, false, false); }
-">>="	{ LEXER_DEBUG (">>="); XBIN_OP_RETURN (RSHIFT_EQ, false, false); }
+"&="    { LEXER_DEBUG ("&="); XBIN_OP_RETURN (AND_EQ, false, false); }
+"|="    { LEXER_DEBUG ("|="); XBIN_OP_RETURN (OR_EQ, false, false); }
+"<<="   { LEXER_DEBUG ("<<="); XBIN_OP_RETURN (LSHIFT_EQ, false, false); }
+">>="   { LEXER_DEBUG (">>="); XBIN_OP_RETURN (RSHIFT_EQ, false, false); }
 
 \{{S}* {
     LEXER_DEBUG ("\\{{S}*");
 
     nesting_level.brace ();
 
     lexer_flags.looking_at_object_index.push_front
       (lexer_flags.looking_for_object_index);
@@ -1029,23 +1029,23 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     LEXER_DEBUG (".");
 
     xunput (yytext[0], yytext);
 
     int c = text_yyinput ();
 
     if (c != EOF)
       {
-	current_input_column++;
-
-	error ("invalid character `%s' (ASCII %d) near line %d, column %d",
-	       undo_string_escape (static_cast<char> (c)), c,
-	       input_line_number, current_input_column);
-
-	return LEXICAL_ERROR;
+        current_input_column++;
+
+        error ("invalid character `%s' (ASCII %d) near line %d, column %d",
+               undo_string_escape (static_cast<char> (c)), c,
+               input_line_number, current_input_column);
+
+        return LEXICAL_ERROR;
       }
     else
       TOK_RETURN (END_OF_INPUT);
   }
 
 %%
 
 // GAG.
@@ -1061,17 +1061,17 @@ do_comma_insert_check (void)
   int c = text_yyinput ();
 
   xunput (c, yytext);
 
   if (spc_gobbled)
     xunput (' ', yytext);
 
   lexer_flags.do_comma_insert = (! lexer_flags.looking_at_object_index.front ()
-				 && lexer_flags.bracketflag && c == '[');
+                                 && lexer_flags.bracketflag && c == '[');
 }
 
 // Fix things up for errors or interrupts.  The parser is never called
 // recursively, so it is always safe to reinitialize its state before
 // doing any parsing.
 
 void
 reset_parser (void)
@@ -1108,19 +1108,19 @@ reset_parser (void)
       input_line_number = command_editor::current_command_number ();
     }
 
   // Only ask for input from stdin if we are expecting interactive
   // input.
   if ((interactive || forced_interactive)
       && ! (reading_fcn_file
         || reading_classdef_file
-	    || reading_script_file
-	    || get_input_from_eval_string
-	    || input_from_startup_file))
+            || reading_script_file
+            || get_input_from_eval_string
+            || input_from_startup_file))
     yyrestart (stdin);
 
   // Clear the buffer for help text.
   while (! help_buf.empty ())
     help_buf.pop ();
 
   // Reset other flags.
   lexer_flags.init ();
@@ -1130,150 +1130,150 @@ static void
 display_character (char c)
 {
   if (isgraph (c))
     std::cerr << c;
   else
     switch (c)
       {
       case 0:
-	std::cerr << "NUL";
-	break;
+        std::cerr << "NUL";
+        break;
 
       case 1:
-	std::cerr << "SOH";
-	break;
+        std::cerr << "SOH";
+        break;
 
       case 2:
-	std::cerr << "STX";
-	break;
+        std::cerr << "STX";
+        break;
 
       case 3:
-	std::cerr << "ETX";
-	break;
+        std::cerr << "ETX";
+        break;
 
       case 4:
-	std::cerr << "EOT";
-	break;
+        std::cerr << "EOT";
+        break;
 
       case 5:
-	std::cerr << "ENQ";
-	break;
+        std::cerr << "ENQ";
+        break;
 
       case 6:
-	std::cerr << "ACK";
-	break;
+        std::cerr << "ACK";
+        break;
 
       case 7:
-	std::cerr << "\\a";
-	break;
+        std::cerr << "\\a";
+        break;
 
       case 8:
-	std::cerr << "\\b";
-	break;
+        std::cerr << "\\b";
+        break;
 
       case 9:
-	std::cerr << "\\t";
-	break;
+        std::cerr << "\\t";
+        break;
 
       case 10:
-	std::cerr << "\\n";
-	break;
+        std::cerr << "\\n";
+        break;
 
       case 11:
-	std::cerr << "\\v";
-	break;
+        std::cerr << "\\v";
+        break;
 
       case 12:
-	std::cerr << "\\f";
-	break;
+        std::cerr << "\\f";
+        break;
 
       case 13:
-	std::cerr << "\\r";
-	break;
+        std::cerr << "\\r";
+        break;
 
       case 14:
-	std::cerr << "SO";
-	break;
+        std::cerr << "SO";
+        break;
 
       case 15:
-	std::cerr << "SI";
-	break;
+        std::cerr << "SI";
+        break;
 
       case 16:
-	std::cerr << "DLE";
-	break;
+        std::cerr << "DLE";
+        break;
 
       case 17:
-	std::cerr << "DC1";
-	break;
+        std::cerr << "DC1";
+        break;
 
       case 18:
-	std::cerr << "DC2";
-	break;
+        std::cerr << "DC2";
+        break;
 
       case 19:
-	std::cerr << "DC3";
-	break;
+        std::cerr << "DC3";
+        break;
 
       case 20:
-	std::cerr << "DC4";
-	break;
+        std::cerr << "DC4";
+        break;
 
       case 21:
-	std::cerr << "NAK";
-	break;
+        std::cerr << "NAK";
+        break;
 
       case 22:
-	std::cerr << "SYN";
-	break;
+        std::cerr << "SYN";
+        break;
 
       case 23:
-	std::cerr << "ETB";
-	break;
+        std::cerr << "ETB";
+        break;
 
       case 24:
-	std::cerr << "CAN";
-	break;
+        std::cerr << "CAN";
+        break;
 
       case 25:
-	std::cerr << "EM";
-	break;
+        std::cerr << "EM";
+        break;
 
       case 26:
-	std::cerr << "SUB";
-	break;
+        std::cerr << "SUB";
+        break;
 
       case 27:
-	std::cerr << "ESC";
-	break;
+        std::cerr << "ESC";
+        break;
 
       case 28:
-	std::cerr << "FS";
-	break;
+        std::cerr << "FS";
+        break;
 
       case 29:
-	std::cerr << "GS";
-	break;
+        std::cerr << "GS";
+        break;
 
       case 30:
-	std::cerr << "RS";
-	break;
+        std::cerr << "RS";
+        break;
 
       case 31:
-	std::cerr << "US";
-	break;
+        std::cerr << "US";
+        break;
 
       case 32:
-	std::cerr << "SPACE";
-	break;
+        std::cerr << "SPACE";
+        break;
 
       case 127:
-	std::cerr << "DEL";
-	break;
+        std::cerr << "DEL";
+        break;
       }
 }
 
 static int
 text_yyinput (void)
 {
   int c = yyinput ();
 
@@ -1286,27 +1286,27 @@ text_yyinput (void)
 
   // Convert CRLF into just LF and single CR into LF.
 
   if (c == '\r')
     {
       c = yyinput ();
 
       if (lexer_debug_flag)
-	{
-	  std::cerr << "I: ";
-	  display_character (c);
-	  std::cerr << std::endl;
-	}
+        {
+          std::cerr << "I: ";
+          display_character (c);
+          std::cerr << std::endl;
+        }
 
       if (c != '\n')
-	{
-	  xunput (c, yytext);
-	  c = '\n';
-	}
+        {
+          xunput (c, yytext);
+          c = '\n';
+        }
     }
 
   if (c == '\n')
     input_line_number++;
 
   return c;
 }
 
@@ -1336,17 +1336,17 @@ fixup_column_count (char *s)
   while ((c = *s++) != '\0')
     {
       if (c == '\n')
         {
           input_line_number++;
           current_input_column = 1;
         }
       else
-	current_input_column++;
+        current_input_column++;
     }
 }
 
 // Include these so that we don't have to link to libfl.a.
 
 int
 yywrap (void)
 {
@@ -1405,20 +1405,20 @@ static bool
 inside_any_object_index (void)
 {
   bool retval = false;
 
   for (std::list<bool>::const_iterator i = lexer_flags.looking_at_object_index.begin ();
        i != lexer_flags.looking_at_object_index.end (); i++)
     {
       if (*i)
-	{
-	  retval = true;
-	  break;
-	}
+        {
+          retval = true;
+          break;
+        }
     }
 
   return retval;
 }
 
 // Handle keywords.  Return -1 if the keyword should be ignored.
 
 static int
@@ -1431,193 +1431,193 @@ is_keyword_token (const std::string& s)
 
   const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
   if (kw)
     {
       yylval.tok_val = 0;
 
       switch (kw->kw_id)
-	{
-	case break_kw:
-	case catch_kw:
-	case continue_kw:
-	case else_kw:
-	case otherwise_kw:
-	case return_kw:
-	case unwind_protect_cleanup_kw:
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case case_kw:
-	case elseif_kw:
-	case global_kw:
-	case static_kw:
-	case until_kw:
-	  break;
-
-	case end_kw:
-	  if (! reading_classdef_file
-	      && (inside_any_object_index ()
-		  || (lexer_flags.defining_func
-		      && ! (lexer_flags.looking_at_return_list
-			    || lexer_flags.parsed_function_name))))
-	    return 0;
-
-	  yylval.tok_val = new token (token::simple_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case end_try_catch_kw:
-	  yylval.tok_val = new token (token::try_catch_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case end_unwind_protect_kw:
-	  yylval.tok_val = new token (token::unwind_protect_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case endfor_kw:
-	  yylval.tok_val = new token (token::for_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case endfunction_kw:
-	  yylval.tok_val = new token (token::function_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case endif_kw:
-	  yylval.tok_val = new token (token::if_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case endswitch_kw:
-	  yylval.tok_val = new token (token::switch_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case endwhile_kw:
-	  yylval.tok_val = new token (token::while_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-	  
-	case endclassdef_kw:
-	  yylval.tok_val = new token (token::classdef_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-	  
-	case endevents_kw:
-	  yylval.tok_val = new token (token::events_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-	  
-	case endmethods_kw:
-	  yylval.tok_val = new token (token::methods_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-	  
-	case endproperties_kw:
-	  yylval.tok_val = new token (token::properties_end, l, c);
-	  lexer_flags.at_beginning_of_statement = true;
-	  break;
-
-	case for_kw:
-	case while_kw:
-	  promptflag--;
-	  lexer_flags.looping++;
-	  break;
-
-	case do_kw:
-	  lexer_flags.at_beginning_of_statement = true;
-	  promptflag--;
-	  lexer_flags.looping++;
-	  break;
-
-	case try_kw:
-	case unwind_protect_kw:
-	  lexer_flags.at_beginning_of_statement = true;
-	  promptflag--;
-	  break;
-
-	case if_kw:
-	case switch_kw:
-	  promptflag--;
-	  break;
-
-	case get_kw:
-	case set_kw:  
-	  // 'get' and 'set' are keywords in classdef method
-	  // declarations.
-	  if (! lexer_flags.maybe_classdef_get_set_method)
-	    return 0;
-	  break;
-
-	case properties_kw:
-	case methods_kw:
-	case events_kw:
-	  // 'properties', 'methods' and 'events' are keywords for
-	  // classdef blocks.
-	  if (! lexer_flags.parsing_classdef)
-	    return 0;
-	  // fall through ...
-
-	case classdef_kw:
-	  // 'classdef' is always a keyword.
-	  promptflag--;
-	  break;	  
-
-	case function_kw:
-	  promptflag--;
-
-	  lexer_flags.defining_func = true;
-	  lexer_flags.parsed_function_name = false;
-
-	  if (! (reading_fcn_file || reading_script_file
-		 || reading_classdef_file))
-	    input_line_number = 1;
-	  break;
+        {
+        case break_kw:
+        case catch_kw:
+        case continue_kw:
+        case else_kw:
+        case otherwise_kw:
+        case return_kw:
+        case unwind_protect_cleanup_kw:
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case case_kw:
+        case elseif_kw:
+        case global_kw:
+        case static_kw:
+        case until_kw:
+          break;
+
+        case end_kw:
+          if (! reading_classdef_file
+              && (inside_any_object_index ()
+                  || (lexer_flags.defining_func
+                      && ! (lexer_flags.looking_at_return_list
+                            || lexer_flags.parsed_function_name))))
+            return 0;
+
+          yylval.tok_val = new token (token::simple_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case end_try_catch_kw:
+          yylval.tok_val = new token (token::try_catch_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case end_unwind_protect_kw:
+          yylval.tok_val = new token (token::unwind_protect_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case endfor_kw:
+          yylval.tok_val = new token (token::for_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case endfunction_kw:
+          yylval.tok_val = new token (token::function_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case endif_kw:
+          yylval.tok_val = new token (token::if_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case endswitch_kw:
+          yylval.tok_val = new token (token::switch_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case endwhile_kw:
+          yylval.tok_val = new token (token::while_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+          
+        case endclassdef_kw:
+          yylval.tok_val = new token (token::classdef_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+          
+        case endevents_kw:
+          yylval.tok_val = new token (token::events_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+          
+        case endmethods_kw:
+          yylval.tok_val = new token (token::methods_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+          
+        case endproperties_kw:
+          yylval.tok_val = new token (token::properties_end, l, c);
+          lexer_flags.at_beginning_of_statement = true;
+          break;
+
+        case for_kw:
+        case while_kw:
+          promptflag--;
+          lexer_flags.looping++;
+          break;
+
+        case do_kw:
+          lexer_flags.at_beginning_of_statement = true;
+          promptflag--;
+          lexer_flags.looping++;
+          break;
+
+        case try_kw:
+        case unwind_protect_kw:
+          lexer_flags.at_beginning_of_statement = true;
+          promptflag--;
+          break;
+
+        case if_kw:
+        case switch_kw:
+          promptflag--;
+          break;
+
+        case get_kw:
+        case set_kw:  
+          // 'get' and 'set' are keywords in classdef method
+          // declarations.
+          if (! lexer_flags.maybe_classdef_get_set_method)
+            return 0;
+          break;
+
+        case properties_kw:
+        case methods_kw:
+        case events_kw:
+          // 'properties', 'methods' and 'events' are keywords for
+          // classdef blocks.
+          if (! lexer_flags.parsing_classdef)
+            return 0;
+          // fall through ...
+
+        case classdef_kw:
+          // 'classdef' is always a keyword.
+          promptflag--;
+          break;          
+
+        case function_kw:
+          promptflag--;
+
+          lexer_flags.defining_func = true;
+          lexer_flags.parsed_function_name = false;
+
+          if (! (reading_fcn_file || reading_script_file
+                 || reading_classdef_file))
+            input_line_number = 1;
+          break;
 
         case magic_file_kw:
-	  {
-	    if ((reading_fcn_file || reading_script_file
-		 || reading_classdef_file)
-		&& ! curr_fcn_file_full_name.empty ())
-	      yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
-	    else
-	      yylval.tok_val = new token ("stdin", l, c);
-	  }
-	  break;
+          {
+            if ((reading_fcn_file || reading_script_file
+                 || reading_classdef_file)
+                && ! curr_fcn_file_full_name.empty ())
+              yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
+            else
+              yylval.tok_val = new token ("stdin", l, c);
+          }
+          break;
 
         case magic_line_kw:
-	  yylval.tok_val = new token (static_cast<double> (l), "", l, c);
-	  break;
-
-	default:
-	  panic_impossible ();
-	}
+          yylval.tok_val = new token (static_cast<double> (l), "", l, c);
+          break;
+
+        default:
+          panic_impossible ();
+        }
 
       if (! yylval.tok_val)
-	yylval.tok_val = new token (l, c);
+        yylval.tok_val = new token (l, c);
 
       token_stack.push (yylval.tok_val);
 
       return kw->tok;
     }
 
   return 0;
 }
 
 static bool
 is_variable (const std::string& name)
 {
   return (symbol_table::is_variable (name)
-	  || (lexer_flags.pending_local_variables.find (name)
-	      != lexer_flags.pending_local_variables.end ()));
+          || (lexer_flags.pending_local_variables.find (name)
+              != lexer_flags.pending_local_variables.end ()));
 }
 
 static std::string
 grab_block_comment (stream_reader& reader, bool& eof)
 {
   std::string buf;
 
   bool at_bol = true;
@@ -1627,108 +1627,108 @@ grab_block_comment (stream_reader& reade
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
       current_input_column++;
 
       if (look_for_marker)
-	{
-	  at_bol = false;
-	  look_for_marker = false;
-
-	  if (c == '{' || c == '}')
-	    {
-	      std::string tmp_buf (1, static_cast<char> (c));
-
-	      int type = c;
-
-	      bool done = false;
-
-	      while ((c = reader.getc ()) != EOF && ! done)
-		{
-		  current_input_column++;
-
-		  switch (c)
-		    {
-		    case ' ':
-		    case '\t':
-		      tmp_buf += static_cast<char> (c);
-		      break;
-
-		    case '\n':
-		      {
-			current_input_column = 0;
-			at_bol = true;
-			done = true;
-
-			if (type == '{')
-			  {
-			    block_comment_nesting_level++;
-			    promptflag--;
-			  }
-			else
-			  {
-			    block_comment_nesting_level--;
-			    promptflag++;
-
-			    if (block_comment_nesting_level == 0)
-			      {
-				buf += grab_comment_block (reader, true, eof);
-
-				return buf;
-			      }
-			  }
-		      }
-		      break;
-
-		    default:
-		      at_bol = false;
-		      tmp_buf += static_cast<char> (c);
-		      buf += tmp_buf;
-		      done = true;
-		      break;
-		    }
-		}
-	    }
-	}
+        {
+          at_bol = false;
+          look_for_marker = false;
+
+          if (c == '{' || c == '}')
+            {
+              std::string tmp_buf (1, static_cast<char> (c));
+
+              int type = c;
+
+              bool done = false;
+
+              while ((c = reader.getc ()) != EOF && ! done)
+                {
+                  current_input_column++;
+
+                  switch (c)
+                    {
+                    case ' ':
+                    case '\t':
+                      tmp_buf += static_cast<char> (c);
+                      break;
+
+                    case '\n':
+                      {
+                        current_input_column = 0;
+                        at_bol = true;
+                        done = true;
+
+                        if (type == '{')
+                          {
+                            block_comment_nesting_level++;
+                            promptflag--;
+                          }
+                        else
+                          {
+                            block_comment_nesting_level--;
+                            promptflag++;
+
+                            if (block_comment_nesting_level == 0)
+                              {
+                                buf += grab_comment_block (reader, true, eof);
+
+                                return buf;
+                              }
+                          }
+                      }
+                      break;
+
+                    default:
+                      at_bol = false;
+                      tmp_buf += static_cast<char> (c);
+                      buf += tmp_buf;
+                      done = true;
+                      break;
+                    }
+                }
+            }
+        }
 
       if (at_bol && (c == '%' || c == '#'))
         {
           if (c == '#' && ! warned_incompatible)
-	    {
-	      warned_incompatible = true;
-	      maybe_gripe_matlab_incompatible_comment (c);
-	    }
-
-	  at_bol = false;
-	  look_for_marker = true;
-	}
+            {
+              warned_incompatible = true;
+              maybe_gripe_matlab_incompatible_comment (c);
+            }
+
+          at_bol = false;
+          look_for_marker = true;
+        }
       else
-	{
-	  buf += static_cast<char> (c);
-
-	  if (c == '\n')
-	    {
-	      current_input_column = 0;
-	      at_bol = true;
-	    }
-	}
+        {
+          buf += static_cast<char> (c);
+
+          if (c == '\n')
+            {
+              current_input_column = 0;
+              at_bol = true;
+            }
+        }
     }
 
   if (c == EOF)
     eof = true;
 
   return buf;
 }
 
 std::string
 grab_comment_block (stream_reader& reader, bool at_bol,
-		    bool& eof)
+                    bool& eof)
 {
   std::string buf;
 
   // TRUE means we are at the beginning of a comment block.
   bool begin_comment = false;
 
   // TRUE means we are currently reading a comment block.
   bool in_comment = false;
@@ -1737,125 +1737,125 @@ grab_comment_block (stream_reader& reade
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
       current_input_column++;
 
       if (begin_comment)
-	{
-	  if (c == '%' || c == '#')
-	    {
-	      at_bol = false;
-	      continue;
-	    }
-	  else if (at_bol && c == '{')
-	    {
-	      std::string tmp_buf (1, static_cast<char> (c));
-
-	      bool done = false;
-
-	      while ((c = reader.getc ()) != EOF && ! done)
-		{
-		  current_input_column++;
-
-		  switch (c)
-		    {
-		    case ' ':
-		    case '\t':
-		      tmp_buf += static_cast<char> (c);
-		      break;
-
-		    case '\n':
-		      {
-			current_input_column = 0;
-			at_bol = true;
-			done = true;
-
-			block_comment_nesting_level++;
-			promptflag--;
-
-			buf += grab_block_comment (reader, eof);
-
-			in_comment = false;
-
-			if (eof)
-			  goto done;
-		      }
-		      break;
-
-		    default:
-		      at_bol = false;
-		      tmp_buf += static_cast<char> (c);
-		      buf += tmp_buf;
-		      done = true;
-		      break;
-		    }
-		}
-	    }
-	  else
-	    {
-	      at_bol = false;
-	      begin_comment = false;
-	    }
-	}	
+        {
+          if (c == '%' || c == '#')
+            {
+              at_bol = false;
+              continue;
+            }
+          else if (at_bol && c == '{')
+            {
+              std::string tmp_buf (1, static_cast<char> (c));
+
+              bool done = false;
+
+              while ((c = reader.getc ()) != EOF && ! done)
+                {
+                  current_input_column++;
+
+                  switch (c)
+                    {
+                    case ' ':
+                    case '\t':
+                      tmp_buf += static_cast<char> (c);
+                      break;
+
+                    case '\n':
+                      {
+                        current_input_column = 0;
+                        at_bol = true;
+                        done = true;
+
+                        block_comment_nesting_level++;
+                        promptflag--;
+
+                        buf += grab_block_comment (reader, eof);
+
+                        in_comment = false;
+
+                        if (eof)
+                          goto done;
+                      }
+                      break;
+
+                    default:
+                      at_bol = false;
+                      tmp_buf += static_cast<char> (c);
+                      buf += tmp_buf;
+                      done = true;
+                      break;
+                    }
+                }
+            }
+          else
+            {
+              at_bol = false;
+              begin_comment = false;
+            }
+        }       
 
       if (in_comment)
-	{
-	  buf += static_cast<char> (c);
-
-	  if (c == '\n')
-	    {
-	      at_bol = true;
-	      current_input_column = 0;
-	      in_comment = false;
-
-	      // FIXME -- bailing out here prevents things like
-	      //
-	      //    octave> # comment
-	      //    octave> x = 1
-	      //
-	      // from failing at the command line, while still
-	      // allowing blocks of comments to be grabbed properly
-	      // for function doc strings.  But only the first line of
-	      // a mult-line doc string will be picked up for
-	      // functions defined on the command line.  We need a
-	      // better way of collecting these comments...
-	      if (! (reading_fcn_file || reading_script_file))
-		goto done;
-	    }
-	}
+        {
+          buf += static_cast<char> (c);
+
+          if (c == '\n')
+            {
+              at_bol = true;
+              current_input_column = 0;
+              in_comment = false;
+
+              // FIXME -- bailing out here prevents things like
+              //
+              //    octave> # comment
+              //    octave> x = 1
+              //
+              // from failing at the command line, while still
+              // allowing blocks of comments to be grabbed properly
+              // for function doc strings.  But only the first line of
+              // a mult-line doc string will be picked up for
+              // functions defined on the command line.  We need a
+              // better way of collecting these comments...
+              if (! (reading_fcn_file || reading_script_file))
+                goto done;
+            }
+        }
       else
-	{
-	  switch (c)
-	    {
-	    case ' ':
-	    case '\t':
-	      break;
-
-	    case '#':
-	      if (! warned_incompatible)
-		{
-		  warned_incompatible = true;
-		  maybe_gripe_matlab_incompatible_comment (c);
-		}
-	      // fall through...
-
-	    case '%':
-	      in_comment = true;
-	      begin_comment = true;
-	      break;
-
-	    default:
-	      current_input_column--;
-	      reader.ungetc (c);
-	      goto done;
-	    }
-	}
+        {
+          switch (c)
+            {
+            case ' ':
+            case '\t':
+              break;
+
+            case '#':
+              if (! warned_incompatible)
+                {
+                  warned_incompatible = true;
+                  maybe_gripe_matlab_incompatible_comment (c);
+                }
+              // fall through...
+
+            case '%':
+              in_comment = true;
+              begin_comment = true;
+              break;
+
+            default:
+              current_input_column--;
+              reader.ungetc (c);
+              goto done;
+            }
+        }
     }
 
  done:
 
   if (c == EOF)
     eof = true;
 
   return buf;
@@ -1894,17 +1894,17 @@ process_comment (bool start_in_block, bo
     : grab_comment_block (flex_reader, false, eof);
 
   if (lexer_debug_flag)
     std::cerr << "C: " << txt << std::endl;
 
   if (help_txt.empty () && nesting_level.none ())
     {
       if (! help_buf.empty ())
-	help_buf.pop ();
+        help_buf.pop ();
 
       help_buf.push (txt);
     }
 
   octave_comment_buffer::append (txt);
 
   current_input_column = 1;
   lexer_flags.quote_is_transpose = false;
@@ -1927,17 +1927,17 @@ process_comment (bool start_in_block, bo
 
 static bool
 match_any (char c, const char *s)
 {
   char tmp;
   while ((tmp = *s++) != '\0')
     {
       if (c == tmp)
-	return true;
+        return true;
     }
   return false;
 }
 
 // Given information about the spacing surrounding an operator,
 // return 1 if it looks like it should be treated as a binary
 // operator.  For example,
 //
@@ -2027,61 +2027,61 @@ next_token_is_bin_op (bool spc_prev)
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     case '+':
     case '-':
       {
-	int c1 = text_yyinput ();
-
-	switch (c1)
-	  {
-	  case '+':
-	  case '-':
-	    // Unary ops, spacing doesn't matter.
-	    break;
-
-	  case '=':
-	    // Binary ops, spacing doesn't matter.
-	    bin_op = true;
-	    break;
-
-	  default:
-	    // Could be either, spacing matters.
-	    bin_op = looks_like_bin_op (spc_prev, c1);
-	    break;
-	  }
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        switch (c1)
+          {
+          case '+':
+          case '-':
+            // Unary ops, spacing doesn't matter.
+            break;
+
+          case '=':
+            // Binary ops, spacing doesn't matter.
+            bin_op = true;
+            break;
+
+          default:
+            // Could be either, spacing matters.
+            bin_op = looks_like_bin_op (spc_prev, c1);
+            break;
+          }
+
+        xunput (c1, yytext);
       }
       break;
 
     case ':':
     case '/':
     case '\\':
     case '^':
       // Always a binary op (may also include /=, \=, and ^=).
       bin_op = true;
       break;
 
     // .+ .- ./ .\ .^ .* .**
     case '.':
       {
-	int c1 = text_yyinput ();
-
-	if (match_any (c1, "+-/\\^*"))
-	  // Always a binary op (may also include .+=, .-=, ./=, ...).
-	  bin_op = true;
-	else if (! isdigit (c1) && c1 != ' ' && c1 != '\t' && c1 != '.')
-	  // A structure element reference is a binary op.
-	  bin_op = true;
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        if (match_any (c1, "+-/\\^*"))
+          // Always a binary op (may also include .+=, .-=, ./=, ...).
+          bin_op = true;
+        else if (! isdigit (c1) && c1 != ' ' && c1 != '\t' && c1 != '.')
+          // A structure element reference is a binary op.
+          bin_op = true;
+
+        xunput (c1, yytext);
       }
       break;
 
     // = == & && | || * **
     case '=':
     case '&':
     case '|':
     case '*':
@@ -2095,23 +2095,23 @@ next_token_is_bin_op (bool spc_prev)
       // Always a binary op (may also include <=, <>, >=).
       bin_op = true;
       break;
 
     // ~= !=
     case '~':
     case '!':
       {
-	int c1 = text_yyinput ();
-
-	// ~ and ! can be unary ops, so require following =.
-	if (c1 == '=')
-	  bin_op = true;
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        // ~ and ! can be unary ops, so require following =.
+        if (c1 == '=')
+          bin_op = true;
+
+        xunput (c1, yytext);
       }
       break;
 
     default:
       break;
     }
 
   xunput (c0, yytext);
@@ -2147,51 +2147,51 @@ scan_for_comments (const char *text)
   int len = strlen (text);
   int i = 0;
 
   while (i < len)
     {
       char c = text[i++];
 
       switch (c)
-	{
-	case '%':
-	case '#':
-	  if (in_comment)
-	    {
-	      if (! beginning_of_comment)
-		comment_buf += static_cast<char> (c);
-	    }
-	  else
-	    {
-	      maybe_gripe_matlab_incompatible_comment (c);
-	      in_comment = true;
-	      beginning_of_comment = true;
-	    }
-	  break;
-
-	case '\n':
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      octave_comment_buffer::append (comment_buf);
-	      comment_buf.resize (0);
-	      in_comment = false;
-	      beginning_of_comment = false;
-	    }
-	  break;
-
-	default:
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      beginning_of_comment = false;
-	    }
-	  break;
-	}
+        {
+        case '%':
+        case '#':
+          if (in_comment)
+            {
+              if (! beginning_of_comment)
+                comment_buf += static_cast<char> (c);
+            }
+          else
+            {
+              maybe_gripe_matlab_incompatible_comment (c);
+              in_comment = true;
+              beginning_of_comment = true;
+            }
+          break;
+
+        case '\n':
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              octave_comment_buffer::append (comment_buf);
+              comment_buf.resize (0);
+              in_comment = false;
+              beginning_of_comment = false;
+            }
+          break;
+
+        default:
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              beginning_of_comment = false;
+            }
+          break;
+        }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 }
 
 // Discard whitespace, including comments and continuations.
 //
@@ -2215,95 +2215,95 @@ eat_whitespace (void)
 
   int c = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
       current_input_column++;
 
       switch (c)
-	{
-	case ' ':
-	case '\t':
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      beginning_of_comment = false;
-	    }
-	  retval |= ATE_SPACE_OR_TAB;
-	  break;
-
-	case '\n':
-	  retval |= ATE_NEWLINE;
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      octave_comment_buffer::append (comment_buf);
-	      comment_buf.resize (0);
-	      in_comment = false;
-	      beginning_of_comment = false;
-	    }
-	  current_input_column = 0;
-	  break;
-
-	case '#':
-	case '%':
-	  if (in_comment)
-	    {
-	      if (! beginning_of_comment)
-		comment_buf += static_cast<char> (c);
-	    }
-	  else
-	    {
-	      maybe_gripe_matlab_incompatible_comment (c);
-	      in_comment = true;
-	      beginning_of_comment = true;
-	    }
-	  break;
-
-	case '.':
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      beginning_of_comment = false;
-	      break;
-	    }
-	  else
-	    {
-	      if (have_ellipsis_continuation ())
-		break;
-	      else
-		goto done;
-	    }
-
-	case '\\':
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      beginning_of_comment = false;
-	      break;
-	    }
-	  else
-	    {
-	      if (have_continuation ())
-		break;
-	      else
-		goto done;
-	    }
-
-	default:
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      beginning_of_comment = false;
-	      break;
-	    }
-	  else
-	    goto done;
-	}
+        {
+        case ' ':
+        case '\t':
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              beginning_of_comment = false;
+            }
+          retval |= ATE_SPACE_OR_TAB;
+          break;
+
+        case '\n':
+          retval |= ATE_NEWLINE;
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              octave_comment_buffer::append (comment_buf);
+              comment_buf.resize (0);
+              in_comment = false;
+              beginning_of_comment = false;
+            }
+          current_input_column = 0;
+          break;
+
+        case '#':
+        case '%':
+          if (in_comment)
+            {
+              if (! beginning_of_comment)
+                comment_buf += static_cast<char> (c);
+            }
+          else
+            {
+              maybe_gripe_matlab_incompatible_comment (c);
+              in_comment = true;
+              beginning_of_comment = true;
+            }
+          break;
+
+        case '.':
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              beginning_of_comment = false;
+              break;
+            }
+          else
+            {
+              if (have_ellipsis_continuation ())
+                break;
+              else
+                goto done;
+            }
+
+        case '\\':
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              beginning_of_comment = false;
+              break;
+            }
+          else
+            {
+              if (have_continuation ())
+                break;
+              else
+                goto done;
+            }
+
+        default:
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              beginning_of_comment = false;
+              break;
+            }
+          else
+            goto done;
+        }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 
  done:
   xunput (c, yytext);
   current_input_column--;
@@ -2332,34 +2332,34 @@ handle_number (void)
     }
   else
     {
       char *tmp = strsave (yytext);
 
       char *idx = strpbrk (tmp, "Dd");
 
       if (idx)
-	*idx = 'e';
+        *idx = 'e';
 
       nread = sscanf (tmp, "%lf", &value);
 
       delete [] tmp;
     }
 
   // If yytext doesn't contain a valid number, we are in deep doo doo.
 
   assert (nread == 1);
 
   lexer_flags.quote_is_transpose = true;
   lexer_flags.convert_spaces_to_comma = true;
   lexer_flags.looking_for_object_index = true;
   lexer_flags.at_beginning_of_statement = false;
 
   yylval.tok_val = new token (value, yytext, input_line_number,
-			      current_input_column);
+                              current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   current_input_column += yyleng;
 
   do_comma_insert_check ();
 }
 
@@ -2386,67 +2386,67 @@ have_continuation (bool trailing_comment
 
   int c = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
       buf << static_cast<char> (c);
 
       switch (c)
-	{
-	case ' ':
-	case '\t':
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      beginning_of_comment = false;
-	    }
-	  break;
-
-	case '%':
-	case '#':
-	  if (trailing_comments_ok)
-	    {
-	      if (in_comment)
-		{
-		  if (! beginning_of_comment)
-		    comment_buf += static_cast<char> (c);
-		}
-	      else
-		{
-		  maybe_gripe_matlab_incompatible_comment (c);
-		  in_comment = true;
-		  beginning_of_comment = true;
-		}
-	    }
-	  else
-	    goto cleanup;
-	  break;
-
-	case '\n':
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      octave_comment_buffer::append (comment_buf);
-	    }
-	  current_input_column = 0;
-	  promptflag--;
-	  gripe_matlab_incompatible_continuation ();
-	  return true;
-
-	default:
-	  if (in_comment)
-	    {
-	      comment_buf += static_cast<char> (c);
-	      beginning_of_comment = false;
-	    }
-	  else
-	    goto cleanup;
-	  break;
-	}
+        {
+        case ' ':
+        case '\t':
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              beginning_of_comment = false;
+            }
+          break;
+
+        case '%':
+        case '#':
+          if (trailing_comments_ok)
+            {
+              if (in_comment)
+                {
+                  if (! beginning_of_comment)
+                    comment_buf += static_cast<char> (c);
+                }
+              else
+                {
+                  maybe_gripe_matlab_incompatible_comment (c);
+                  in_comment = true;
+                  beginning_of_comment = true;
+                }
+            }
+          else
+            goto cleanup;
+          break;
+
+        case '\n':
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              octave_comment_buffer::append (comment_buf);
+            }
+          current_input_column = 0;
+          promptflag--;
+          gripe_matlab_incompatible_continuation ();
+          return true;
+
+        default:
+          if (in_comment)
+            {
+              comment_buf += static_cast<char> (c);
+              beginning_of_comment = false;
+            }
+          else
+            goto cleanup;
+          break;
+        }
     }
 
   xunput (c, yytext);
   return false;
 
 cleanup:
 
   std::string s = buf.str ();
@@ -2465,22 +2465,22 @@ cleanup:
 static bool
 have_ellipsis_continuation (bool trailing_comments_ok)
 {
   char c1 = text_yyinput ();
   if (c1 == '.')
     {
       char c2 = text_yyinput ();
       if (c2 == '.' && have_continuation (trailing_comments_ok))
-	return true;
+        return true;
       else
-	{
-	  xunput (c2, yytext);
-	  xunput (c1, yytext);
-	}
+        {
+          xunput (c2, yytext);
+          xunput (c1, yytext);
+        }
     }
   else
     xunput (c1, yytext);
 
   return false;
 }
 
 // See if we have a continuation line.  If so, eat it and the leading
@@ -2515,87 +2515,87 @@ handle_string (char delim)
   int c;
   int escape_pending = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
       current_input_column++;
 
       if (c == '\\')
-	{
-	  if (delim == '\'' || escape_pending)
-	    {
-	      buf << static_cast<char> (c);
-	      escape_pending = 0;
-	    }
-	  else
-	    {
-	      if (have_continuation (false))
-		escape_pending = 0;
-	      else
-		{
-		  buf << static_cast<char> (c);
-		  escape_pending = 1;
-		}
-	    }
-	  continue;
-	}
+        {
+          if (delim == '\'' || escape_pending)
+            {
+              buf << static_cast<char> (c);
+              escape_pending = 0;
+            }
+          else
+            {
+              if (have_continuation (false))
+                escape_pending = 0;
+              else
+                {
+                  buf << static_cast<char> (c);
+                  escape_pending = 1;
+                }
+            }
+          continue;
+        }
       else if (c == '.')
-	{
-	  if (delim == '\'' || ! have_ellipsis_continuation (false))
-	    buf << static_cast<char> (c);
-	}
+        {
+          if (delim == '\'' || ! have_ellipsis_continuation (false))
+            buf << static_cast<char> (c);
+        }
       else if (c == '\n')
-	{
-	  error ("unterminated string constant");
-	  break;
-	}
+        {
+          error ("unterminated string constant");
+          break;
+        }
       else if (c == delim)
-	{
-	  if (escape_pending)
-	    buf << static_cast<char> (c);
-	  else
-	    {
-	      c = text_yyinput ();
-	      if (c == delim)
-		{
-		  buf << static_cast<char> (c);		    
-		}
-	      else
-		{
-		  std::string s;  
-		  xunput (c, yytext);
-
-		  if (delim == '\'')
-		    s = buf.str ();
-		  else
-		    s = do_string_escapes (buf.str ());
-
-		  lexer_flags.quote_is_transpose = true;
-		  lexer_flags.convert_spaces_to_comma = true;
-
-		  yylval.tok_val = new token (s, bos_line, bos_col);
-		  token_stack.push (yylval.tok_val);
-
-		  if (delim == '"')
-		    gripe_matlab_incompatible ("\" used as string delimiter");
-		  else if (delim == '\'')
-		    gripe_single_quote_string ();
+        {
+          if (escape_pending)
+            buf << static_cast<char> (c);
+          else
+            {
+              c = text_yyinput ();
+              if (c == delim)
+                {
+                  buf << static_cast<char> (c);             
+                }
+              else
+                {
+                  std::string s;  
+                  xunput (c, yytext);
+
+                  if (delim == '\'')
+                    s = buf.str ();
+                  else
+                    s = do_string_escapes (buf.str ());
+
+                  lexer_flags.quote_is_transpose = true;
+                  lexer_flags.convert_spaces_to_comma = true;
+
+                  yylval.tok_val = new token (s, bos_line, bos_col);
+                  token_stack.push (yylval.tok_val);
+
+                  if (delim == '"')
+                    gripe_matlab_incompatible ("\" used as string delimiter");
+                  else if (delim == '\'')
+                    gripe_single_quote_string ();
 
                   lexer_flags.looking_for_object_index = true;
-		  lexer_flags.at_beginning_of_statement = false;
-
-		  return delim == '"' ? DQ_STRING : SQ_STRING;
-		}
-	    }
-	}
+                  lexer_flags.at_beginning_of_statement = false;
+
+                  return delim == '"' ? DQ_STRING : SQ_STRING;
+                }
+            }
+        }
       else
-	{
-	  buf << static_cast<char> (c);
-	}
+        {
+          buf << static_cast<char> (c);
+        }
 
       escape_pending = 0;
     }
 
   return LEXICAL_ERROR;
 }
 
 static bool
@@ -2604,77 +2604,77 @@ next_token_is_assign_op (void)
   bool retval = false;
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     case '=':
       {
-	int c1 = text_yyinput ();
-	xunput (c1, yytext);
-	if (c1 != '=')
-	  retval = true;
+        int c1 = text_yyinput ();
+        xunput (c1, yytext);
+        if (c1 != '=')
+          retval = true;
       }
       break;
 
     case '+':
     case '-':
     case '*':
     case '/':
     case '\\':
     case '&':
     case '|':
       {
-	int c1 = text_yyinput ();
-	xunput (c1, yytext);
-	if (c1 == '=')
-	  retval = true;
+        int c1 = text_yyinput ();
+        xunput (c1, yytext);
+        if (c1 == '=')
+          retval = true;
       }
       break;
 
     case '.':
       {
-	int c1 = text_yyinput ();
-	if (match_any (c1, "+-*/\\"))
-	  {
-	    int c2 = text_yyinput ();
-	    xunput (c2, yytext);
-	    if (c2 == '=')
-	      retval = true;
-	  }
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+        if (match_any (c1, "+-*/\\"))
+          {
+            int c2 = text_yyinput ();
+            xunput (c2, yytext);
+            if (c2 == '=')
+              retval = true;
+          }
+        xunput (c1, yytext);
       }
       break;
 
     case '>':
       {
-	int c1 = text_yyinput ();
-	if (c1 == '>')
-	  {
-	    int c2 = text_yyinput ();
-	    xunput (c2, yytext);
-	    if (c2 == '=')
-	      retval = true;
-	  }
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+        if (c1 == '>')
+          {
+            int c2 = text_yyinput ();
+            xunput (c2, yytext);
+            if (c2 == '=')
+              retval = true;
+          }
+        xunput (c1, yytext);
       }
       break;
 
     case '<':
       {
-	int c1 = text_yyinput ();
-	if (c1 == '<')
-	  {
-	    int c2 = text_yyinput ();
-	    xunput (c2, yytext);
-	    if (c2 == '=')
-	      retval = true;
-	  }
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+        if (c1 == '<')
+          {
+            int c2 = text_yyinput ();
+            xunput (c2, yytext);
+            if (c2 == '=')
+              retval = true;
+          }
+        xunput (c1, yytext);
       }
       break;
 
     default:
       break;
     }
 
   xunput (c0, yytext);
@@ -2695,104 +2695,104 @@ handle_close_bracket (bool spc_gobbled, 
 {
   int retval = bracket_type;
 
   if (! nesting_level.none ())
     {
       nesting_level.remove ();
 
       if (bracket_type == ']')
-	lexer_flags.bracketflag--;
+        lexer_flags.bracketflag--;
       else if (bracket_type == '}')
-	lexer_flags.braceflag--;
+        lexer_flags.braceflag--;
       else
-	panic_impossible ();
+        panic_impossible ();
     }
 
   if (lexer_flags.bracketflag == 0 && lexer_flags.braceflag == 0)
     BEGIN (INITIAL);
 
   if (bracket_type == ']'
       && next_token_is_assign_op ()
       && ! lexer_flags.looking_at_return_list)
     {
       retval = CLOSE_BRACE;
     }
   else if ((lexer_flags.bracketflag || lexer_flags.braceflag)
-	   && lexer_flags.convert_spaces_to_comma
-	   && (nesting_level.is_bracket ()
-	       || (nesting_level.is_brace ()
-		   && ! lexer_flags.looking_at_object_index.front ())))
+           && lexer_flags.convert_spaces_to_comma
+           && (nesting_level.is_bracket ()
+               || (nesting_level.is_brace ()
+                   && ! lexer_flags.looking_at_object_index.front ())))
     {
       bool index_op = next_token_is_index_op ();
 
       // Don't insert comma if we are looking at something like
       //
       //   [x{i}{j}] or [x{i}(j)]
       //
       // but do if we are looking at
       //
       //   [x{i} {j}] or [x{i} (j)]
 
       if (spc_gobbled || ! (bracket_type == '}' && index_op))
-	{
-	  bool bin_op = next_token_is_bin_op (spc_gobbled);
-
-	  bool postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
-
-	  bool sep_op = next_token_is_sep_op ();
-
-	  if (! (postfix_un_op || bin_op || sep_op))
-	    {
-	      maybe_warn_separator_insert (',');
-
-	      xunput (',', yytext);
-	      return retval;
-	    }
-	}
+        {
+          bool bin_op = next_token_is_bin_op (spc_gobbled);
+
+          bool postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
+
+          bool sep_op = next_token_is_sep_op ();
+
+          if (! (postfix_un_op || bin_op || sep_op))
+            {
+              maybe_warn_separator_insert (',');
+
+              xunput (',', yytext);
+              return retval;
+            }
+        }
     }
 
   lexer_flags.quote_is_transpose = true;
   lexer_flags.convert_spaces_to_comma = true;
 
   return retval;
 }
 
 static void
 maybe_unput_comma (int spc_gobbled)
 {
   if (nesting_level.is_bracket ()
       || (nesting_level.is_brace ()
-	  && ! lexer_flags.looking_at_object_index.front ()))
+          && ! lexer_flags.looking_at_object_index.front ()))
     {
       int bin_op = next_token_is_bin_op (spc_gobbled);
 
       int postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
 
       int c1 = text_yyinput ();
       int c2 = text_yyinput ();
 
       xunput (c2, yytext);
       xunput (c1, yytext);
 
       int sep_op = next_token_is_sep_op ();
 
       int dot_op = (c1 == '.'
-		    && (isalpha (c2) || isspace (c2) || c2 == '_'));
+                    && (isalpha (c2) || isspace (c2) || c2 == '_'));
 
       if (postfix_un_op || bin_op || sep_op || dot_op)
-	return;
+        return;
 
       int index_op = (c1 == '(' || c1 == '{');
 
       // If there is no space before the indexing op, we don't insert
       // a comma.
 
       if (index_op && ! spc_gobbled)
-	return;
+        return;
 
       maybe_warn_separator_insert (',');
 
       xunput (',', yytext);
     }
 }
 
 static bool
@@ -2805,17 +2805,17 @@ next_token_can_follow_bin_op (void)
   // Skip whitespace in current statement on current line
   while (true)
     {
       c = text_yyinput ();
 
       buf.push (c);
 
       if (match_any (c, ",;\n") || (c != ' ' && c != '\t'))
-	break;
+        break;
     }
 
   // Restore input.
   while (! buf.empty ())
     {
       xunput (buf.top (), yytext);
 
       buf.pop ();
@@ -2844,32 +2844,32 @@ looks_like_command_arg (void)
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     // = ==
     case '=':
       {
-	int c1 = text_yyinput ();
-
-	if (c1 == '=')
-	  {
-	    int c2 = text_yyinput ();
-
-	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
-		&& next_token_can_follow_bin_op ())
-	      retval = false;
-
-	    xunput (c2, yytext);
-	  }
-	else
-	  retval = false;
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        if (c1 == '=')
+          {
+            int c2 = text_yyinput ();
+
+            if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+                && next_token_can_follow_bin_op ())
+              retval = false;
+
+            xunput (c2, yytext);
+          }
+        else
+          retval = false;
+
+        xunput (c1, yytext);
       }
       break;
 
     case '(':
     case '{':
       // Indexing.
       retval = false;
       break;
@@ -2882,176 +2882,176 @@ looks_like_command_arg (void)
     case '"':
       // Beginning of a character string.
       break;
 
     // + - ++ -- += -=
     case '+':
     case '-':
       {
-	int c1 = text_yyinput ();
-
-	switch (c1)
-	  {
-	  case '\n':
-	    // EOL.
-	  case '+':
-	  case '-':
-	    // Unary ops, spacing doesn't matter.
-	    break;
-
-	  case '\t':
-	  case ' ':
-	    {
-	      if (next_token_can_follow_bin_op ())
-		retval = false;
-	    }
-	    break;
-
-	  case '=':
-	    {
-	      int c2 = text_yyinput ();
-
-	      if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
-		  && next_token_can_follow_bin_op ())
-		retval = false;
-
-	      xunput (c2, yytext);
-	    }
-	    break;
-	  }
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        switch (c1)
+          {
+          case '\n':
+            // EOL.
+          case '+':
+          case '-':
+            // Unary ops, spacing doesn't matter.
+            break;
+
+          case '\t':
+          case ' ':
+            {
+              if (next_token_can_follow_bin_op ())
+                retval = false;
+            }
+            break;
+
+          case '=':
+            {
+              int c2 = text_yyinput ();
+
+              if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+                  && next_token_can_follow_bin_op ())
+                retval = false;
+
+              xunput (c2, yytext);
+            }
+            break;
+          }
+
+        xunput (c1, yytext);
       }
       break;
 
     case ':':
     case '/':
     case '\\':
     case '^':
       {
-	int c1 = text_yyinput ();
-
-	if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
-	    && next_token_can_follow_bin_op ())
-	  retval = false;
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+            && next_token_can_follow_bin_op ())
+          retval = false;
+
+        xunput (c1, yytext);
       }
       break;
 
     // .+ .- ./ .\ .^ .* .**
     case '.':
       {
-	int c1 = text_yyinput ();
-
-	if (match_any (c1, "+-/\\^*"))
-	  {
-	    int c2 = text_yyinput ();
-
-	    if (c2 == '=')
-	      {
-		int c3 = text_yyinput ();
-
-		if (! match_any (c3, ",;\n") && (c3 == ' ' || c3 == '\t')
-		    && next_token_can_follow_bin_op ())
-		  retval = false;
-
-		xunput (c3, yytext);
-	      }
-	    else if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
-		     && next_token_can_follow_bin_op ())
-	      retval = false;
-
-	    xunput (c2, yytext);
-	  }
-	else if (! match_any (c1, ",;\n")
-		 && (! isdigit (c1) && c1 != ' ' && c1 != '\t'
-		     && c1 != '.'))
-	  {
-	    // Structure reference.  FIXME -- is this a complete check?
-
-	    retval = false;
-	  }
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        if (match_any (c1, "+-/\\^*"))
+          {
+            int c2 = text_yyinput ();
+
+            if (c2 == '=')
+              {
+                int c3 = text_yyinput ();
+
+                if (! match_any (c3, ",;\n") && (c3 == ' ' || c3 == '\t')
+                    && next_token_can_follow_bin_op ())
+                  retval = false;
+
+                xunput (c3, yytext);
+              }
+            else if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+                     && next_token_can_follow_bin_op ())
+              retval = false;
+
+            xunput (c2, yytext);
+          }
+        else if (! match_any (c1, ",;\n")
+                 && (! isdigit (c1) && c1 != ' ' && c1 != '\t'
+                     && c1 != '.'))
+          {
+            // Structure reference.  FIXME -- is this a complete check?
+
+            retval = false;
+          }
+
+        xunput (c1, yytext);
       }
       break;
 
     // & && | || * **
     case '&':
     case '|':
     case '*':
       {
-	int c1 = text_yyinput ();
-
-	if (c1 == c0)
-	  {
-	    int c2 = text_yyinput ();
-
-	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
-		&& next_token_can_follow_bin_op ())
-	      retval = false;
-
-	    xunput (c2, yytext);
-	  }
-	else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
-		 && next_token_can_follow_bin_op ())
-	  retval = false;
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        if (c1 == c0)
+          {
+            int c2 = text_yyinput ();
+
+            if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+                && next_token_can_follow_bin_op ())
+              retval = false;
+
+            xunput (c2, yytext);
+          }
+        else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+                 && next_token_can_follow_bin_op ())
+          retval = false;
+
+        xunput (c1, yytext);
       }
       break;
 
     // < <= > >=
     case '<':
     case '>':
       {
-	int c1 = text_yyinput ();
-
-	if (c1 == '=')
-	  {
-	    int c2 = text_yyinput ();
-
-	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
-		&& next_token_can_follow_bin_op ())
-	      retval = false;
-
-	    xunput (c2, yytext);
-	  }
-	else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
-		 && next_token_can_follow_bin_op ())
-	  retval = false;
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        if (c1 == '=')
+          {
+            int c2 = text_yyinput ();
+
+            if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+                && next_token_can_follow_bin_op ())
+              retval = false;
+
+            xunput (c2, yytext);
+          }
+        else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+                 && next_token_can_follow_bin_op ())
+          retval = false;
+
+        xunput (c1, yytext);
       }
       break;
 
     // ~= !=
     case '~':
     case '!':
       {
-	int c1 = text_yyinput ();
-
-	// ~ and ! can be unary ops, so require following =.
-	if (c1 == '=')
-	  {
-	    int c2 = text_yyinput ();
-
-	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
-		&& next_token_can_follow_bin_op ())
-	      retval = false;
-
-	    xunput (c2, yytext);
-	  }
-	else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
-		 && next_token_can_follow_bin_op ())
-	  retval = false;
-
-	xunput (c1, yytext);
+        int c1 = text_yyinput ();
+
+        // ~ and ! can be unary ops, so require following =.
+        if (c1 == '=')
+          {
+            int c2 = text_yyinput ();
+
+            if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+                && next_token_can_follow_bin_op ())
+              retval = false;
+
+            xunput (c2, yytext);
+          }
+        else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+                 && next_token_can_follow_bin_op ())
+          retval = false;
+
+        xunput (c1, yytext);
       }
       break;
 
     default:
       break;
     }
 
   xunput (c0, yytext);
@@ -3067,34 +3067,34 @@ handle_superclass_identifier (void)
   std::string pkg;  
   std::string meth = strip_trailing_whitespace (yytext); 
   size_t pos = meth.find ("@");
   std::string cls = meth.substr (pos).substr (1);
   meth = meth.substr (0, pos - 1);  
   
   pos = cls.find (".");
   if (pos != std::string::npos)
-    {	 
+    {    
       pkg = cls.substr (pos).substr (1);
       cls = cls.substr (0, pos - 1);
     }
     
   int kw_token = (is_keyword_token (meth) || is_keyword_token (cls)
-		  || is_keyword_token (pkg));
+                  || is_keyword_token (pkg));
   if (kw_token)
     {
       error ("method, class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
  
   yylval.tok_val
     = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
                  cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-		 input_line_number, current_input_column);				   
+                 input_line_number, current_input_column);                                 
   token_stack.push (yylval.tok_val);
   
   lexer_flags.convert_spaces_to_comma = true;
   current_input_column += yyleng;
   
   return SUPERCLASSREF;
 }
 
@@ -3103,32 +3103,32 @@ handle_meta_identifier (void)
 {
   eat_continuation ();
 
   std::string pkg;
   std::string cls = strip_trailing_whitespace (yytext).substr (1);
   size_t pos = cls.find (".");
   
   if (pos != std::string::npos)
-    {	 
+    {    
       pkg = cls.substr (pos).substr (1);
       cls = cls.substr (0, pos - 1);
     }
   
   int kw_token = is_keyword_token (cls) || is_keyword_token (pkg);
   if (kw_token)
     {
        error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
   
   yylval.tok_val
     = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
-		 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-		 input_line_number, current_input_column);
+                 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
+                 input_line_number, current_input_column);
 
   token_stack.push (yylval.tok_val);
                    
   lexer_flags.convert_spaces_to_comma = true;
   current_input_column += yyleng;
   
   return METAQUERY;
 }
@@ -3157,17 +3157,17 @@ handle_identifier (void)
 
   if (lexer_flags.looking_at_indirect_ref)
     {
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
 
       yylval.tok_val = new token (tok, input_line_number,
-				  current_input_column);
+                                  current_input_column);
 
       token_stack.push (yylval.tok_val);
 
       lexer_flags.quote_is_transpose = true;
       lexer_flags.convert_spaces_to_comma = true;
       lexer_flags.looking_for_object_index = true;
 
       current_input_column += yyleng;
@@ -3186,65 +3186,65 @@ handle_identifier (void)
 
   // If we found a keyword token, then the beginning_of_statement flag
   // is already set.  Otherwise, we won't be at the beginning of a
   // statement.
 
   if (lexer_flags.looking_at_function_handle)
     {
       if (kw_token)
-	{
-	  error ("function handles may not refer to keywords");
-
-	  return LEXICAL_ERROR;
-	}
+        {
+          error ("function handles may not refer to keywords");
+
+          return LEXICAL_ERROR;
+        }
       else
-	{
-	  yylval.tok_val = new token (tok, input_line_number,
-				      current_input_column);
-
-	  token_stack.push (yylval.tok_val);
-
-	  current_input_column += yyleng;
-	  lexer_flags.quote_is_transpose = false;
-	  lexer_flags.convert_spaces_to_comma = true;
-	  lexer_flags.looking_for_object_index = true;
-
-	  return FCN_HANDLE;
-	}
+        {
+          yylval.tok_val = new token (tok, input_line_number,
+                                      current_input_column);
+
+          token_stack.push (yylval.tok_val);
+
+          current_input_column += yyleng;
+          lexer_flags.quote_is_transpose = false;
+          lexer_flags.convert_spaces_to_comma = true;
+          lexer_flags.looking_for_object_index = true;
+
+          return FCN_HANDLE;
+        }
     }
 
   // If we have a regular keyword, return it.
   // Keywords can be followed by identifiers.
 
   if (kw_token)
     {
       if (kw_token >= 0)
-	{
-	  current_input_column += yyleng;
-	  lexer_flags.quote_is_transpose = false;
-	  lexer_flags.convert_spaces_to_comma = true;
-	  lexer_flags.looking_for_object_index = false;
-	}
+        {
+          current_input_column += yyleng;
+          lexer_flags.quote_is_transpose = false;
+          lexer_flags.convert_spaces_to_comma = true;
+          lexer_flags.looking_for_object_index = false;
+        }
 
       return kw_token;
     }
 
   // See if we have a plot keyword (title, using, with, or clear).
 
   int c1 = text_yyinput ();
 
   bool next_tok_is_eq = false;
   if (c1 == '=')
     {
       int c2 = text_yyinput ();
       xunput (c2, yytext);
 
       if (c2 != '=')
-	next_tok_is_eq = true;
+        next_tok_is_eq = true;
     }
 
   xunput (c1, yytext);
 
   // Kluge alert.
   //
   // If we are looking at a text style function, set up to gobble its
   // arguments.
@@ -3253,41 +3253,41 @@ handle_identifier (void)
   // return list or function parameter list, or if we are looking at
   // something like [ab,cd] = foo (), force the symbol to be inserted
   // as a variable in the current symbol table.
 
   if (! is_variable (tok))
     {
       if (at_bos && spc_gobbled && can_be_command (tok)
           && looks_like_command_arg ())
-	{
-	  BEGIN (COMMAND_START);
-	}
+        {
+          BEGIN (COMMAND_START);
+        }
       else if (next_tok_is_eq
-	       || lexer_flags.looking_at_decl_list
-	       || lexer_flags.looking_at_return_list
-	       || (lexer_flags.looking_at_parameter_list
-		   && ! lexer_flags.looking_at_initializer_expression))
-	{
-	  symbol_table::force_variable (tok);
-	}
+               || lexer_flags.looking_at_decl_list
+               || lexer_flags.looking_at_return_list
+               || (lexer_flags.looking_at_parameter_list
+                   && ! lexer_flags.looking_at_initializer_expression))
+        {
+          symbol_table::force_variable (tok);
+        }
       else if (lexer_flags.looking_at_matrix_or_assign_lhs)
-	{
-	  lexer_flags.pending_local_variables.insert (tok);
-	}
+        {
+          lexer_flags.pending_local_variables.insert (tok);
+        }
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";    
 
   yylval.tok_val = new token (&(symbol_table::insert (tok)),
-			      input_line_number, current_input_column);
+                              input_line_number, current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
   lexer_flags.convert_spaces_to_comma = true;
 
@@ -3393,17 +3393,17 @@ is omitted, return a list of keywords.\n
   if (error_state)
     return retval;
 
   if (argc == 1)
     {
       string_vector lst (TOTAL_KEYWORDS);
 
       for (int i = 0; i < TOTAL_KEYWORDS; i++)
-	lst[i] = wordlist[i].name;
+        lst[i] = wordlist[i].name;
 
       retval = Cell (lst.sort ());
     }
   else if (argc == 2)
     {
       retval = is_keyword (argv[1]);
     }
   else
@@ -3426,52 +3426,52 @@ prep_lexer_for_function_file (void)
 
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
-		     "potential auto-insertion of `%c' near line %d",
-		     sep, input_line_number);
+                     "potential auto-insertion of `%c' near line %d",
+                     sep, input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
-		     "potential auto-insertion of `%c' near line %d of file %s",
-		     sep, input_line_number, nm.c_str ());
+                     "potential auto-insertion of `%c' near line %d of file %s",
+                     sep, input_line_number, nm.c_str ());
 }
 
 static void
 gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:single-quote-string",
-		     "single quote delimited string near line %d",
-		     input_line_number);
+                     "single quote delimited string near line %d",
+                     input_line_number);
   else
     warning_with_id ("Octave:single-quote-string",
-		     "single quote delimited string near line %d of file %s",
-		     input_line_number, nm.c_str ());
+                     "single quote delimited string near line %d of file %s",
+                     input_line_number, nm.c_str ());
 }
 
 static void
 gripe_matlab_incompatible (const std::string& msg)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:matlab-incompatible",
-		     "potential Matlab compatibility problem: %s",
-		     msg.c_str ());
+                     "potential Matlab compatibility problem: %s",
+                     msg.c_str ());
   else
     warning_with_id ("Octave:matlab-incompatible",
-		     "potential Matlab compatibility problem: %s near line %d offile %s",
-		     msg.c_str (), input_line_number, nm.c_str ());
+                     "potential Matlab compatibility problem: %s near line %d offile %s",
+                     msg.c_str (), input_line_number, nm.c_str ());
 }
 
 static void
 maybe_gripe_matlab_incompatible_comment (char c)
 {
   if (c == '#')
     gripe_matlab_incompatible ("# used as comment character");
 }
@@ -3584,19 +3584,19 @@ display_token (int tok)
     case EVENTS: std::cerr << "EVENTS\n"; break;
     case CLASSDEF: std::cerr << "CLASSDEF\n"; break;
     case '\n': std::cerr << "\\n\n"; break;
     case '\r': std::cerr << "\\r\n"; break;
     case '\t': std::cerr << "TAB\n"; break;
     default:
       {
         if (tok < 256)
-	  std::cerr << static_cast<char> (tok) << "\n";
-	else
-	  std::cerr << "UNKNOWN(" << tok << ")\n";
+          std::cerr << static_cast<char> (tok) << "\n";
+        else
+          std::cerr << "UNKNOWN(" << tok << ")\n";
       }
       break;
     }
 }
 
 static void
 display_state (void)
 {
@@ -3664,12 +3664,12 @@ DEFUN (__lexer_debug_flag__, args, nargo
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{old_val} =} __lexer_debug_flag__ (@var{new_val}))\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   retval = set_internal_variable (lexer_debug_flag, args, nargout,
-           			  "__lexer_debug_flag__");
+                                  "__lexer_debug_flag__");
 
   return retval;
 }
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -52,56 +52,56 @@ load_path::abs_dir_cache_type load_path:
 void
 load_path::dir_info::update (void)
 {
   file_stat fs (dir_name);
 
   if (fs)
     {
       if (is_relative)
-	{
-	  try
-	    {
-	      std::string abs_name = octave_env::make_absolute (dir_name);
-
-	      abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
-
-	      if (p != abs_dir_cache.end ())
-		{
-		  // The directory is in the cache of all directories
-		  // we have visited (indexed by its absolute name).
-		  // If it is out of date, initialize it.  Otherwise,
-		  // copy the info from the cache.  By doing that, we
-		  // avoid unnecessary calls to stat that can slow
-		  // things down tremendously for large directories.
-
-		  const dir_info& di = p->second;
-
-		  if (fs.mtime () + fs.time_resolution () > di.dir_time_last_checked)
-		    initialize ();
-		  else
-		    *this = di;
-		}
-	      else
-		{
-		  // We haven't seen this directory before.
-
-		  initialize ();
-		}
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      // Skip updating if we don't know where we are, but
-	      // don't treat it as an error.
-
-	      error_state = 0;
-	    }
-	}
+        {
+          try
+            {
+              std::string abs_name = octave_env::make_absolute (dir_name);
+
+              abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
+
+              if (p != abs_dir_cache.end ())
+                {
+                  // The directory is in the cache of all directories
+                  // we have visited (indexed by its absolute name).
+                  // If it is out of date, initialize it.  Otherwise,
+                  // copy the info from the cache.  By doing that, we
+                  // avoid unnecessary calls to stat that can slow
+                  // things down tremendously for large directories.
+
+                  const dir_info& di = p->second;
+
+                  if (fs.mtime () + fs.time_resolution () > di.dir_time_last_checked)
+                    initialize ();
+                  else
+                    *this = di;
+                }
+              else
+                {
+                  // We haven't seen this directory before.
+
+                  initialize ();
+                }
+            }
+          catch (octave_execution_exception)
+            {
+              // Skip updating if we don't know where we are, but
+              // don't treat it as an error.
+
+              error_state = 0;
+            }
+        }
       else if (fs.mtime () + fs.time_resolution () > dir_time_last_checked)
-	initialize ();
+        initialize ();
     }
   else
     {
       std::string msg = fs.error ();
       warning ("load_path: %s: %s", dir_name.c_str (), msg.c_str ());
     }
 }
 
@@ -117,29 +117,29 @@ load_path::dir_info::initialize (void)
   if (fs)
     {
       dir_mtime = fs.mtime ();
       dir_time_last_checked = octave_time ();
 
       get_file_list (dir_name);
 
       try
-	{
-	  std::string abs_name = octave_env::make_absolute (dir_name);
-
-	  // FIXME -- nothing is ever removed from this cache of
-	  // directory information, so there could be some resource
-	  // problems.  Perhaps it should be pruned from time to time.
-
-	  abs_dir_cache[abs_name] = *this;
-	}
+        {
+          std::string abs_name = octave_env::make_absolute (dir_name);
+
+          // FIXME -- nothing is ever removed from this cache of
+          // directory information, so there could be some resource
+          // problems.  Perhaps it should be pruned from time to time.
+
+          abs_dir_cache[abs_name] = *this;
+        }
       catch (octave_execution_exception)
-	{
-	  // Skip updating if we don't know where we are.
-	}
+        {
+          // Skip updating if we don't know where we are.
+        }
     }
   else
     {
       std::string msg = fs.error ();
       warning ("load_path: %s: %s", dir_name.c_str (), msg.c_str ());
     }
 }
 
@@ -156,53 +156,53 @@ load_path::dir_info::get_file_list (cons
 
       all_files.resize (len);
       fcn_files.resize (len);
 
       octave_idx_type all_files_count = 0;
       octave_idx_type fcn_files_count = 0;
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  std::string fname = flist[i];
-
-	  std::string full_name = file_ops::concat (d, fname);
-
-	  file_stat fs (full_name);
-
-	  if (fs)
-	    {
-	      if (fs.is_dir ())
-		{
-		  if (fname == "private")
-		    get_private_file_map (full_name);
-		  else if (fname[0] == '@')
-		    get_method_file_map (full_name, fname.substr (1));
-		}
-	      else
-		{
-		  all_files[all_files_count++] = fname;
-
-		  size_t pos = fname.rfind ('.');
-
-		  if (pos != std::string::npos)
-		    {
-		      std::string ext = fname.substr (pos);
-
-		      if (ext == ".m" || ext == ".oct" || ext == ".mex")
-			{
-			  std::string base = fname.substr (0, pos);
-
-			  if (valid_identifier (base))
-			    fcn_files[fcn_files_count++] = fname;
-			}
-		    }
-		}
-	    }
-	}
+        {
+          std::string fname = flist[i];
+
+          std::string full_name = file_ops::concat (d, fname);
+
+          file_stat fs (full_name);
+
+          if (fs)
+            {
+              if (fs.is_dir ())
+                {
+                  if (fname == "private")
+                    get_private_file_map (full_name);
+                  else if (fname[0] == '@')
+                    get_method_file_map (full_name, fname.substr (1));
+                }
+              else
+                {
+                  all_files[all_files_count++] = fname;
+
+                  size_t pos = fname.rfind ('.');
+
+                  if (pos != std::string::npos)
+                    {
+                      std::string ext = fname.substr (pos);
+
+                      if (ext == ".m" || ext == ".oct" || ext == ".mex")
+                        {
+                          std::string base = fname.substr (0, pos);
+
+                          if (valid_identifier (base))
+                            fcn_files[fcn_files_count++] = fname;
+                        }
+                    }
+                }
+            }
+        }
 
       all_files.resize (all_files_count);
       fcn_files.resize (fcn_files_count);
     }
   else
     {
       std::string msg = dir.error ();
       warning ("load_path: %s: %s", d.c_str (), msg.c_str ());
@@ -218,44 +218,44 @@ get_fcn_files (const std::string& d)
 
   if (dir)
     {
       string_vector flist = dir.read ();
 
       octave_idx_type len = flist.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  std::string fname = flist[i];
-
-	  std::string ext;
-	  std::string base = fname;
-
-	  size_t pos = fname.rfind ('.');
-
-	  if (pos != std::string::npos)
-	    {
-	      base = fname.substr (0, pos);
-	      ext = fname.substr (pos);
-
-	      if (valid_identifier (base))
-		{
-		  int t = 0;
-
-		  if (ext == ".m")
-		    t = load_path::M_FILE;
-		  else if (ext == ".oct")
-		    t = load_path::OCT_FILE;
-		  else if (ext == ".mex")
-		    t = load_path::MEX_FILE;
-
-		  retval[base] |= t;
-		}
-	    }
-	}
+        {
+          std::string fname = flist[i];
+
+          std::string ext;
+          std::string base = fname;
+
+          size_t pos = fname.rfind ('.');
+
+          if (pos != std::string::npos)
+            {
+              base = fname.substr (0, pos);
+              ext = fname.substr (pos);
+
+              if (valid_identifier (base))
+                {
+                  int t = 0;
+
+                  if (ext == ".m")
+                    t = load_path::M_FILE;
+                  else if (ext == ".oct")
+                    t = load_path::OCT_FILE;
+                  else if (ext == ".mex")
+                    t = load_path::MEX_FILE;
+
+                  retval[base] |= t;
+                }
+            }
+        }
     }
   else
     {
       std::string msg = dir.error ();
       warning ("load_path: %s: %s", d.c_str (), msg.c_str ());
     }
 
   return retval;
@@ -264,17 +264,17 @@ get_fcn_files (const std::string& d)
 void
 load_path::dir_info::get_private_file_map (const std::string& d)
 {
   private_file_map = get_fcn_files (d);
 }
 
 void
 load_path::dir_info::get_method_file_map (const std::string& d,
-					  const std::string& class_name)
+                                          const std::string& class_name)
 {
   method_file_map[class_name].method_file_map = get_fcn_files (d);
 
   std::string pd = file_ops::concat (d, "private");
 
   file_stat fs (pd);
 
   if (fs && fs.is_dir ())
@@ -307,17 +307,17 @@ load_path::find_dir_info (const std::str
 {
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   const_dir_info_list_iterator retval = dir_info_list.begin ();
 
   while (retval != dir_info_list.end ())
     {
       if (retval->dir_name == dir)
-	break;
+        break;
 
       retval++;
     }
 
   return retval;
 }
 
 load_path::dir_info_list_iterator
@@ -325,137 +325,137 @@ load_path::find_dir_info (const std::str
 {
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   dir_info_list_iterator retval = dir_info_list.begin ();
 
   while (retval != dir_info_list.end ())
     {
       if (retval->dir_name == dir)
-	break;
+        break;
 
       retval++;
     }
 
   return retval;
 }
 
 bool
 load_path::contains (const std::string& dir) const
 {
   return find_dir_info (dir) != dir_info_list.end ();
 }
 
 void
 load_path::move_fcn_map (const std::string& dir_name,
-			 const string_vector& fcn_files, bool at_end)
+                         const string_vector& fcn_files, bool at_end)
 {
   octave_idx_type len = fcn_files.length ();
 
   for (octave_idx_type k = 0; k < len; k++)
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
       std::string base = fname;
 
       size_t pos = fname.rfind ('.');
 
       if (pos != std::string::npos)
-	{
-	  base = fname.substr (0, pos);
-	  ext = fname.substr (pos);
-	}
+        {
+          base = fname.substr (0, pos);
+          ext = fname.substr (pos);
+        }
 
       file_info_list_type& file_info_list = fcn_map[base];
 
       if (file_info_list.size () == 1)
-	continue;
+        continue;
       else
-	{
-	  for (file_info_list_iterator p = file_info_list.begin ();
-	       p != file_info_list.end ();
-	       p++)
-	    {
-	      if (p->dir_name == dir_name)
-		{
-		  file_info fi = *p;
-
-		  file_info_list.erase (p);
-
-		  if (at_end)
-		    file_info_list.push_back (fi);
-		  else
-		    file_info_list.push_front (fi);
-
-		  break;
-		}
-	    }
-	}
+        {
+          for (file_info_list_iterator p = file_info_list.begin ();
+               p != file_info_list.end ();
+               p++)
+            {
+              if (p->dir_name == dir_name)
+                {
+                  file_info fi = *p;
+
+                  file_info_list.erase (p);
+
+                  if (at_end)
+                    file_info_list.push_back (fi);
+                  else
+                    file_info_list.push_front (fi);
+
+                  break;
+                }
+            }
+        }
     }
 }
 
 void
 load_path::move_method_map (const std::string& dir_name, bool at_end)
 {
   for (method_map_iterator i = method_map.begin ();
        i != method_map.end ();
        i++)
     {
       std::string class_name = i->first;
 
       fcn_map_type& fm = i->second;
 
       std::string full_dir_name
-	= file_ops::concat (dir_name, "@" + class_name);
+        = file_ops::concat (dir_name, "@" + class_name);
 
       for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
-	{
-	  file_info_list_type& file_info_list = q->second;
-
-	  if (file_info_list.size () == 1)
-	    continue;
-	  else
-	    {
-	      for (file_info_list_iterator p = file_info_list.begin ();
-	       p != file_info_list.end ();
-	       p++)
-		{
-		  if (p->dir_name == full_dir_name)
-		    {
-		      file_info fi = *p;
-
-		      file_info_list.erase (p);
-
-		      if (at_end)
-			file_info_list.push_back (fi);
-		      else
-			file_info_list.push_front (fi);
-
-		      break;
-		    }
-		}
-	    }
-	}
+        {
+          file_info_list_type& file_info_list = q->second;
+
+          if (file_info_list.size () == 1)
+            continue;
+          else
+            {
+              for (file_info_list_iterator p = file_info_list.begin ();
+               p != file_info_list.end ();
+               p++)
+                {
+                  if (p->dir_name == full_dir_name)
+                    {
+                      file_info fi = *p;
+
+                      file_info_list.erase (p);
+
+                      if (at_end)
+                        file_info_list.push_back (fi);
+                      else
+                        file_info_list.push_front (fi);
+
+                      break;
+                    }
+                }
+            }
+        }
     }
 }
 
 void
 load_path::move (dir_info_list_iterator i, bool at_end)
 {
   if (dir_info_list.size () > 1)
     {
       dir_info di = *i;
 
       dir_info_list.erase (i);
 
       if (at_end)
-	dir_info_list.push_back (di);
+        dir_info_list.push_back (di);
       else
-	dir_info_list.push_front (di);
+        dir_info_list.push_front (di);
 
       std::string dir_name = di.dir_name;
 
       move_fcn_map (dir_name, di.fcn_files, at_end);
 
       // No need to move elements of private function map.
 
       move_method_map (dir_name, at_end);
@@ -465,19 +465,19 @@ load_path::move (dir_info_list_iterator 
 static void
 maybe_add_path_elts (std::string& path, const std::string& dir)
 {
   std::string tpath = genpath (dir);
 
   if (! tpath.empty ())
     {
       if (path.empty ())
-	path = tpath;
+        path = tpath;
       else
-	path += dir_path::path_sep_str () + tpath;
+        path += dir_path::path_sep_str () + tpath;
     }
 }
 
 void
 load_path::do_initialize (bool set_initial_path)
 {
   sys_path = "";
 
@@ -532,22 +532,22 @@ split_path (const std::string& p)
 
   size_t len = p.length ();
 
   while (end != std::string::npos)
     {
       std::string elt = p.substr (beg, end-beg);
 
       if (! elt.empty ())
-	retval.push_back (elt);
+        retval.push_back (elt);
 
       beg = end + 1;
 
       if (beg == len)
-	break;
+        break;
 
       end = p.find (dir_path::path_sep_char (), beg);
     }
 
   std::string elt = p.substr (beg);
 
   if (! elt.empty ())
     retval.push_back (elt);
@@ -577,17 +577,17 @@ load_path::do_set (const std::string& p,
   // Restore add hook and execute for all newly added directories.
   frame.run_top ();
 
   for (dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        i++)
     {
       if (add_hook)
-	add_hook (i->dir_name);
+        add_hook (i->dir_name);
     }
 
   // Always prepend current directory.
   do_prepend (".", warn);
 }
 
 void
 load_path::do_append (const std::string& dir, bool warn)
@@ -605,106 +605,106 @@ load_path::do_prepend (const std::string
 
 void
 load_path::do_add (const std::string& dir_arg, bool at_end, bool warn)
 {
   size_t len = dir_arg.length ();
 
   if (len > 1 && dir_arg.substr (len-2) == "//")
     warning_with_id ("Octave:recursive-path-search",
-		     "trailing `//' is no longer special in search path elements");
+                     "trailing `//' is no longer special in search path elements");
 
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   dir_info_list_iterator i = find_dir_info (dir);
 
   if (i != dir_info_list.end ())
     move (i, at_end);
   else
     {
       file_stat fs (dir);
 
       if (fs)
-	{
-	  if (fs.is_dir ())
-	    {
-	      dir_info di (dir);
-
-	      if (! error_state)
-		{
-		  if (at_end)
-		    dir_info_list.push_back (di);
-		  else
-		    dir_info_list.push_front (di);
-
-		  add_to_fcn_map (di, at_end);
-
-		  add_to_private_fcn_map (di);
-
-		  add_to_method_map (di, at_end);
-
-		  if (add_hook)
-		    add_hook (dir);
-		}
-	    }
-	  else if (warn)
-	    warning ("addpath: %s: not a directory", dir_arg.c_str ());
-	}
+        {
+          if (fs.is_dir ())
+            {
+              dir_info di (dir);
+
+              if (! error_state)
+                {
+                  if (at_end)
+                    dir_info_list.push_back (di);
+                  else
+                    dir_info_list.push_front (di);
+
+                  add_to_fcn_map (di, at_end);
+
+                  add_to_private_fcn_map (di);
+
+                  add_to_method_map (di, at_end);
+
+                  if (add_hook)
+                    add_hook (dir);
+                }
+            }
+          else if (warn)
+            warning ("addpath: %s: not a directory", dir_arg.c_str ());
+        }
       else if (warn)
-	{
-	  std::string msg = fs.error ();
-	  warning ("addpath: %s: %s", dir_arg.c_str (), msg.c_str ());
-	}
+        {
+          std::string msg = fs.error ();
+          warning ("addpath: %s: %s", dir_arg.c_str (), msg.c_str ());
+        }
     }
 
   // FIXME -- is there a better way to do this?
 
   i = find_dir_info (".");
 
   if (i != dir_info_list.end ())
     move (i, false);
 }
 
 void
 load_path::remove_fcn_map (const std::string& dir,
-			   const string_vector& fcn_files)
+                           const string_vector& fcn_files)
 {
   octave_idx_type len = fcn_files.length ();
 
   for (octave_idx_type k = 0; k < len; k++)
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
       std::string base = fname;
 
       size_t pos = fname.rfind ('.');
 
       if (pos != std::string::npos)
-	{
-	  base = fname.substr (0, pos);
-	  ext = fname.substr (pos);
-	}
+        {
+          base = fname.substr (0, pos);
+          ext = fname.substr (pos);
+        }
 
       file_info_list_type& file_info_list = fcn_map[base];
 
       for (file_info_list_iterator p = file_info_list.begin ();
-	   p != file_info_list.end ();
-	   p++)
-	{
-	  if (p->dir_name == dir)
-	    {
-	      file_info_list.erase (p);
-
-	      if (file_info_list.empty ())
-		fcn_map.erase (fname);
-
-	      break;
-	    }
-	}
+           p != file_info_list.end ();
+           p++)
+        {
+          if (p->dir_name == dir)
+            {
+              file_info_list.erase (p);
+
+              if (file_info_list.empty ())
+                fcn_map.erase (fname);
+
+              break;
+            }
+        }
     }
 }
 
 void
 load_path::remove_private_fcn_map (const std::string& dir)
 {
   private_fcn_map_iterator p = private_fcn_map.find (dir);
 
@@ -721,81 +721,81 @@ load_path::remove_method_map (const std:
     {
       std::string class_name = i->first;
 
       fcn_map_type& fm = i->second;
 
       std::string full_dir_name = file_ops::concat (dir, "@" + class_name);
 
       for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
-	{
-	  file_info_list_type& file_info_list = q->second;
-
-	  if (file_info_list.size () == 1)
-	    continue;
-	  else
-	    {
-	      for (file_info_list_iterator p = file_info_list.begin ();
-	       p != file_info_list.end ();
-	       p++)
-		{
-		  if (p->dir_name == full_dir_name)
-		    {
-		      file_info_list.erase (p);
-
-		      // FIXME -- if there are no other elements, we
-		      // should remove this element of fm but calling
-		      // erase here would invalidate the iterator q.
-
-		      break;
-		    }
-		}
-	    }
-	}
+        {
+          file_info_list_type& file_info_list = q->second;
+
+          if (file_info_list.size () == 1)
+            continue;
+          else
+            {
+              for (file_info_list_iterator p = file_info_list.begin ();
+               p != file_info_list.end ();
+               p++)
+                {
+                  if (p->dir_name == full_dir_name)
+                    {
+                      file_info_list.erase (p);
+
+                      // FIXME -- if there are no other elements, we
+                      // should remove this element of fm but calling
+                      // erase here would invalidate the iterator q.
+
+                      break;
+                    }
+                }
+            }
+        }
     }
 }
 
 bool
 load_path::do_remove (const std::string& dir_arg)
 {
   bool retval = false;
 
   if (! dir_arg.empty ())
     {
       if (dir_arg == ".")
-	{
-	  warning ("rmpath: can't remove \".\" from path");
-
-	  // Avoid additional warnings.
-	  retval = true;
-	}
+        {
+          warning ("rmpath: can't remove \".\" from path");
+
+          // Avoid additional warnings.
+          retval = true;
+        }
       else
-	{
-	  std::string dir = file_ops::tilde_expand (dir_arg);
-
-	  dir_info_list_iterator i = find_dir_info (dir);
-
-	  if (i != dir_info_list.end ())
-	    {
-	      retval = true;
-
-	      if (remove_hook)
-		remove_hook (dir);
-
-	      string_vector fcn_files = i->fcn_files;
-
-	      dir_info_list.erase (i);
-
-	      remove_fcn_map (dir, fcn_files);
-
-	      remove_private_fcn_map (dir);
-
-	      remove_method_map (dir);
-	    }
-	}
+        {
+          std::string dir = file_ops::tilde_expand (dir_arg);
+
+          dir_info_list_iterator i = find_dir_info (dir);
+
+          if (i != dir_info_list.end ())
+            {
+              retval = true;
+
+              if (remove_hook)
+                remove_hook (dir);
+
+              string_vector fcn_files = i->fcn_files;
+
+              dir_info_list.erase (i);
+
+              remove_fcn_map (dir, fcn_files);
+
+              remove_private_fcn_map (dir);
+
+              remove_method_map (dir);
+            }
+        }
     }
 
   return retval;
 }
 
 void
 load_path::do_update (void) const
 {
@@ -822,236 +822,236 @@ load_path::do_update (void) const
       add_to_private_fcn_map (di);
 
       add_to_method_map (di, true);
     }
 }
 
 bool
 load_path::check_file_type (std::string& fname, int type, int possible_types,
-			    const std::string& fcn, const char *who)
+                            const std::string& fcn, const char *who)
 {
   bool retval = false;
 
   if (type == load_path::OCT_FILE)
     {
       if ((type & possible_types) == load_path::OCT_FILE)
-	{
-	  fname += ".oct";
-	  retval = true;
-	}
+        {
+          fname += ".oct";
+          retval = true;
+        }
     }
   else if (type == load_path::M_FILE)
     {
       if ((type & possible_types) == load_path::M_FILE)
-	{
-	  fname += ".m";
-	  retval = true;
-	}
+        {
+          fname += ".m";
+          retval = true;
+        }
     }
   else if (type == load_path::MEX_FILE)
     {
       if ((type & possible_types) == load_path::MEX_FILE)
-	{
-	  fname += ".mex";
-	  retval = true;
-	}
+        {
+          fname += ".mex";
+          retval = true;
+        }
     }
   else if (type == (load_path::M_FILE | load_path::OCT_FILE))
     {
       if (possible_types & load_path::OCT_FILE)
-	{
-	  fname += ".oct";
-	  retval = true;
-	}
+        {
+          fname += ".oct";
+          retval = true;
+        }
       else if (possible_types & load_path::M_FILE)
-	{
-	  fname += ".m";
-	  retval = true;
-	}
+        {
+          fname += ".m";
+          retval = true;
+        }
     }
   else if (type == (load_path::M_FILE | load_path::MEX_FILE))
     {
       if (possible_types & load_path::MEX_FILE)
-	{
-	  fname += ".mex";
-	  retval = true;
-	}
+        {
+          fname += ".mex";
+          retval = true;
+        }
       else if (possible_types & load_path::M_FILE)
-	{
-	  fname += ".m";
-	  retval = true;
-	}
+        {
+          fname += ".m";
+          retval = true;
+        }
     }
   else if (type == (load_path::OCT_FILE | load_path::MEX_FILE))
     {
       if (possible_types & load_path::OCT_FILE)
-	{
-	  fname += ".oct";
-	  retval = true;
-	}
+        {
+          fname += ".oct";
+          retval = true;
+        }
       else if (possible_types & load_path::MEX_FILE)
-	{
-	  fname += ".mex";
-	  retval = true;
-	}
+        {
+          fname += ".mex";
+          retval = true;
+        }
     }
   else if (type == (load_path::M_FILE | load_path::OCT_FILE
-		    | load_path::MEX_FILE))
+                    | load_path::MEX_FILE))
     {
       if (possible_types & load_path::OCT_FILE)
-	{
-	  fname += ".oct";
-	  retval = true;
-	}
+        {
+          fname += ".oct";
+          retval = true;
+        }
       else if (possible_types & load_path::MEX_FILE)
-	{
-	  fname += ".mex";
-	  retval = true;
-	}
+        {
+          fname += ".mex";
+          retval = true;
+        }
       else if (possible_types & load_path::M_FILE)
-	{
-	  fname += ".m";
-	  retval = true;
-	}
+        {
+          fname += ".m";
+          retval = true;
+        }
     }
   else
     error ("%s: %s: invalid type code = %d", who, fcn.c_str (), type);
 
   return retval;
 } 
 
 std::string
 load_path::do_find_fcn (const std::string& fcn, std::string& dir_name,
-			int type) const
+                        int type) const
 {
   std::string retval;
   
   //  update ();
 
   if (fcn.length () > 0 && fcn[0] == '@')
     {
       size_t pos = fcn.find ('/');
 
       if (pos != std::string::npos)
-	{
-	  std::string class_name = fcn.substr (1, pos-1);
-	  std::string meth = fcn.substr (pos+1);
-
-	  retval = do_find_method (class_name, meth, dir_name);
-	}
+        {
+          std::string class_name = fcn.substr (1, pos-1);
+          std::string meth = fcn.substr (pos+1);
+
+          retval = do_find_method (class_name, meth, dir_name);
+        }
       else
-	retval = std::string ();
+        retval = std::string ();
     }
   else
     {
       dir_name = std::string ();
 
       const_fcn_map_iterator p = fcn_map.find (fcn);
 
       if (p != fcn_map.end ())
-	{
-	  const file_info_list_type& file_info_list = p->second;
-
-	  for (const_file_info_list_iterator i = file_info_list.begin ();
-	       i != file_info_list.end ();
-	       i++)
-	    {
-	      const file_info& fi = *i;
-
-	      retval = file_ops::concat (fi.dir_name, fcn);
-
-	      if (check_file_type (retval, type, fi.types,
-				   fcn, "load_path::do_find_fcn"))
-		{
-		  dir_name = fi.dir_name;
-		  break;
-		}
-	      else
-		retval = std::string ();
-	    }
-	}
+        {
+          const file_info_list_type& file_info_list = p->second;
+
+          for (const_file_info_list_iterator i = file_info_list.begin ();
+               i != file_info_list.end ();
+               i++)
+            {
+              const file_info& fi = *i;
+
+              retval = file_ops::concat (fi.dir_name, fcn);
+
+              if (check_file_type (retval, type, fi.types,
+                                   fcn, "load_path::do_find_fcn"))
+                {
+                  dir_name = fi.dir_name;
+                  break;
+                }
+              else
+                retval = std::string ();
+            }
+        }
     }
 
   return retval;
 }
 
 std::string
 load_path::do_find_private_fcn (const std::string& dir,
-				const std::string& fcn, int type) const
+                                const std::string& fcn, int type) const
 {
   std::string retval;
 
   //  update ();
 
   const_private_fcn_map_iterator q = private_fcn_map.find (dir);
 
   if (q != private_fcn_map.end ())
     {
       const dir_info::fcn_file_map_type& m = q->second;
 
       dir_info::const_fcn_file_map_iterator p = m.find (fcn);
 
       if (p != m.end ())
-	{
-	  std::string fname
-	    = file_ops::concat (file_ops::concat (dir, "private"), fcn);
-
-	  if (check_file_type (fname, type, p->second, fcn,
-			       "load_path::find_private_fcn"))
-	    retval = fname;
-	}
+        {
+          std::string fname
+            = file_ops::concat (file_ops::concat (dir, "private"), fcn);
+
+          if (check_file_type (fname, type, p->second, fcn,
+                               "load_path::find_private_fcn"))
+            retval = fname;
+        }
     }
 
   return retval;
 }
 
 std::string
 load_path::do_find_method (const std::string& class_name,
-			   const std::string& meth,
-			   std::string& dir_name, int type) const
+                           const std::string& meth,
+                           std::string& dir_name, int type) const
 {
   std::string retval;
 
   //  update ();
 
   dir_name = std::string ();
 
   const_method_map_iterator q = method_map.find (class_name);
 
   if (q != method_map.end ())
     {
       const fcn_map_type& m = q->second;
 
       const_fcn_map_iterator p = m.find (meth);
 
       if (p != m.end ())
-	{
-	  const file_info_list_type& file_info_list = p->second;
-
-	  for (const_file_info_list_iterator i = file_info_list.begin ();
-	       i != file_info_list.end ();
-	       i++)
-	    {
-	      const file_info& fi = *i;
-
-	      retval = file_ops::concat (fi.dir_name, meth);
-
-	      bool found = check_file_type (retval, type, fi.types,
-					    meth, "load_path::do_find_method");
-
-	      if (found)
-		{
-		  dir_name = fi.dir_name;
-		  break;
-		}
-	      else
-		retval = std::string ();
-	    }
-	}
+        {
+          const file_info_list_type& file_info_list = p->second;
+
+          for (const_file_info_list_iterator i = file_info_list.begin ();
+               i != file_info_list.end ();
+               i++)
+            {
+              const file_info& fi = *i;
+
+              retval = file_ops::concat (fi.dir_name, meth);
+
+              bool found = check_file_type (retval, type, fi.types,
+                                            meth, "load_path::do_find_method");
+
+              if (found)
+                {
+                  dir_name = fi.dir_name;
+                  break;
+                }
+              else
+                retval = std::string ();
+            }
+        }
     }
 
   return retval;
 }
 
 std::list<std::string>
 load_path::do_methods (const std::string& class_name) const
 {
@@ -1061,17 +1061,17 @@ load_path::do_methods (const std::string
 
   const_method_map_iterator q = method_map.find (class_name);
 
   if (q != method_map.end ())
     {
       const fcn_map_type& m = q->second;
 
       for (const_fcn_map_iterator p = m.begin (); p != m.end (); p++)
-	retval.push_back (p->first);
+        retval.push_back (p->first);
     }
 
   if (! retval.empty ())
     retval.sort ();
 
   return retval;
 }
 
@@ -1100,148 +1100,148 @@ load_path::do_any_class_method (const st
 std::string
 load_path::do_find_file (const std::string& file) const
 {
   std::string retval;
 
   if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
     {
       if (octave_env::absolute_pathname (file)
-	  || octave_env::rooted_relative_pathname (file))
-	{
-	  file_stat fs (file);
-
-	  if (fs.exists ())
-	    return file;
-	}
+          || octave_env::rooted_relative_pathname (file))
+        {
+          file_stat fs (file);
+
+          if (fs.exists ())
+            return file;
+        }
       else
-	{
-	  for (const_dir_info_list_iterator p = dir_info_list.begin ();
-	       p != dir_info_list.end ();
-	       p++)
-	    {
-	      std::string tfile = file_ops::concat (p->dir_name, file);
-
-	      file_stat fs (tfile);
-
-	      if (fs.exists ())
-		return tfile;
-	    }
-	}
+        {
+          for (const_dir_info_list_iterator p = dir_info_list.begin ();
+               p != dir_info_list.end ();
+               p++)
+            {
+              std::string tfile = file_ops::concat (p->dir_name, file);
+
+              file_stat fs (tfile);
+
+              if (fs.exists ())
+                return tfile;
+            }
+        }
     }
   else
     {
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
-	   p != dir_info_list.end ();
-	   p++)
-	{
-	  string_vector all_files = p->all_files;
-
-	  octave_idx_type len = all_files.length ();
-
-	  for (octave_idx_type i = 0; i < len; i++)
-	    {
-	      if (all_files[i] == file)
-		return file_ops::concat (p->dir_name, file);
-	    }
-	}
+           p != dir_info_list.end ();
+           p++)
+        {
+          string_vector all_files = p->all_files;
+
+          octave_idx_type len = all_files.length ();
+
+          for (octave_idx_type i = 0; i < len; i++)
+            {
+              if (all_files[i] == file)
+                return file_ops::concat (p->dir_name, file);
+            }
+        }
     }
 
   return retval;
 }
 
 std::string
 load_path::do_find_dir (const std::string& dir) const
 {
   std::string retval;
 
   if (dir.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos
       && (octave_env::absolute_pathname (dir)
-	  || octave_env::rooted_relative_pathname (dir)))
+          || octave_env::rooted_relative_pathname (dir)))
     {
       file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
-	return dir;
+        return dir;
     }
   else
     {
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
-	   p != dir_info_list.end ();
-	   p++)
-	{
-	  std::string dname = octave_env::make_absolute (p->dir_name);
-
-	  size_t dname_len = dname.length ();
-
-	  if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
-	    {
-	      dname = dname.substr (0, dname_len - 1);
-	      dname_len--;
-	    }
-
-	  size_t dir_len = dir.length ();
-
-	  if (dname_len >= dir_len
-	      && file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
-	      && dir.compare (dname.substr (dname_len - dir_len)) == 0)
-	    {
-	      file_stat fs (p->dir_name);
-
-	      if (fs.exists () && fs.is_dir ())
-		return p->dir_name;
-	    }
-	}
+           p != dir_info_list.end ();
+           p++)
+        {
+          std::string dname = octave_env::make_absolute (p->dir_name);
+
+          size_t dname_len = dname.length ();
+
+          if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
+            {
+              dname = dname.substr (0, dname_len - 1);
+              dname_len--;
+            }
+
+          size_t dir_len = dir.length ();
+
+          if (dname_len >= dir_len
+              && file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+              && dir.compare (dname.substr (dname_len - dir_len)) == 0)
+            {
+              file_stat fs (p->dir_name);
+
+              if (fs.exists () && fs.is_dir ())
+                return p->dir_name;
+            }
+        }
     }
 
   return retval;
 }
 
 string_vector
 load_path::do_find_matching_dirs (const std::string& dir) const
 {
   std::list<std::string> retlist;
 
   if (dir.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos
       && (octave_env::absolute_pathname (dir)
-	  || octave_env::rooted_relative_pathname (dir)))
+          || octave_env::rooted_relative_pathname (dir)))
     {
       file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
-	retlist.push_back (dir);
+        retlist.push_back (dir);
     }
   else
     {
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
-	   p != dir_info_list.end ();
-	   p++)
-	{
-	  std::string dname = octave_env::make_absolute (p->dir_name);
-
-	  size_t dname_len = dname.length ();
-
-	  if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
-	    {
-	      dname = dname.substr (0, dname_len - 1);
-	      dname_len--;
-	    }
-
-	  size_t dir_len = dir.length ();
-
-	  if (dname_len >= dir_len
-	      && file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
-	      && dir.compare (dname.substr (dname_len - dir_len)) == 0)
-	    {
-	      file_stat fs (p->dir_name);
-
-	      if (fs.exists () && fs.is_dir ())
-		retlist.push_back (p->dir_name);
-	    }
-	}
+           p != dir_info_list.end ();
+           p++)
+        {
+          std::string dname = octave_env::make_absolute (p->dir_name);
+
+          size_t dname_len = dname.length ();
+
+          if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
+            {
+              dname = dname.substr (0, dname_len - 1);
+              dname_len--;
+            }
+
+          size_t dir_len = dir.length ();
+
+          if (dname_len >= dir_len
+              && file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+              && dir.compare (dname.substr (dname_len - dir_len)) == 0)
+            {
+              file_stat fs (p->dir_name);
+
+              if (fs.exists () && fs.is_dir ())
+                retlist.push_back (p->dir_name);
+            }
+        }
     }
 
   return retlist;
 }
 
 std::string
 load_path::do_find_first_of (const string_vector& flist) const
 {
@@ -1253,49 +1253,49 @@ load_path::do_find_first_of (const strin
   octave_idx_type flen = flist.length ();
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       if (octave_env::absolute_pathname (flist[i]))
-	{
-	  file_stat fs (flist[i]);
-
-	  if (fs.exists ())
-	    return flist[i];
-	}
+        {
+          file_stat fs (flist[i]);
+
+          if (fs.exists ())
+            return flist[i];
+        }
       else
-	rel_flist[rel_flen++] = flist[i];
+        rel_flist[rel_flen++] = flist[i];
     }
 
   rel_flist.resize (rel_flen);
 
   for (const_dir_info_list_iterator p = dir_info_list.begin ();
        p != dir_info_list.end ();
        p++)
     {
       string_vector all_files = p->all_files;
 
       octave_idx_type len = all_files.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  for (octave_idx_type j = 0; j < rel_flen; j++)
-	    {
-	      if (all_files[i] == rel_flist[j])
-		{
-		  dir_name = p->dir_name;
-		  file_name = rel_flist[j];
-
-		  goto done;
-		}
-	    }
-	}
+        {
+          for (octave_idx_type j = 0; j < rel_flen; j++)
+            {
+              if (all_files[i] == rel_flist[j])
+                {
+                  dir_name = p->dir_name;
+                  file_name = rel_flist[j];
+
+                  goto done;
+                }
+            }
+        }
     }
 
  done:
 
   if (! dir_name.empty ())
     retval = file_ops::concat (dir_name, file_name);
 
   return retval;
@@ -1312,45 +1312,45 @@ load_path::do_find_all_first_of (const s
   octave_idx_type flen = flist.length ();
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       if (octave_env::absolute_pathname (flist[i]))
-	{
-	  file_stat fs (flist[i]);
-
-	  if (fs.exists ())
-	    retlist.push_back (flist[i]);
-	}
+        {
+          file_stat fs (flist[i]);
+
+          if (fs.exists ())
+            retlist.push_back (flist[i]);
+        }
       else
-	rel_flist[rel_flen++] = flist[i];
+        rel_flist[rel_flen++] = flist[i];
     }
 
   rel_flist.resize (rel_flen);
 
   for (const_dir_info_list_iterator p = dir_info_list.begin ();
        p != dir_info_list.end ();
        p++)
     {
       string_vector all_files = p->all_files;
 
       octave_idx_type len = all_files.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  for (octave_idx_type j = 0; j < rel_flen; j++)
-	    {
-	      if (all_files[i] == rel_flist[j])
-		retlist.push_back
-		  (file_ops::concat (p->dir_name, rel_flist[j]));
-	    }
-	}
+        {
+          for (octave_idx_type j = 0; j < rel_flen; j++)
+            {
+              if (all_files[i] == rel_flist[j])
+                retlist.push_back
+                  (file_ops::concat (p->dir_name, rel_flist[j]));
+            }
+        }
     }
 
   return retlist;
 }
 
 string_vector
 load_path::do_dirs (void) const
 {
@@ -1391,24 +1391,24 @@ load_path::do_files (const std::string& 
   if (p != dir_info_list.end ())
     retval = p->fcn_files;
 
   if (omit_exts)
     {
       octave_idx_type len = retval.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  std::string fname = retval[i];
-
-	  size_t pos = fname.rfind ('.');
-
-	  if (pos != std::string::npos)
-	    retval[i] = fname.substr (0, pos);
-	}
+        {
+          std::string fname = retval[i];
+
+          size_t pos = fname.rfind ('.');
+
+          if (pos != std::string::npos)
+            retval[i] = fname.substr (0, pos);
+        }
     }
 
   return retval;
 }
 
 string_vector
 load_path::do_fcn_names (void) const
 {
@@ -1453,33 +1453,33 @@ print_types (std::ostream& os, int types
     {
       os << "oct";
       printed_type = true;
     }
 
   if (types & load_path::MEX_FILE)
     {
       if (printed_type)
-	os << "|";
+        os << "|";
       os << "mex";
       printed_type = true;
     }
 
   if (types & load_path::M_FILE)
     {
       if (printed_type)
-	os << "|";
+        os << "|";
       os << "m";
       printed_type = true;
     }
 }
 
 void
 print_fcn_list (std::ostream& os,
-		const load_path::dir_info::fcn_file_map_type& lst)
+                const load_path::dir_info::fcn_file_map_type& lst)
 {
   for (load_path::dir_info::const_fcn_file_map_iterator p = lst.begin ();
        p != lst.end ();
        p++)
     {
       os << "  " << p->first << " (";
 
       print_types (os, p->second);
@@ -1501,21 +1501,21 @@ get_file_list (const load_path::dir_info
        p != lst.end ();
        p++)
     {
       std::string nm = p->first;
 
       int types = p->second;
 
       if (types & load_path::OCT_FILE)
-	nm += ".oct";
+        nm += ".oct";
       else if (types & load_path::MEX_FILE)
-	nm += ".mex";
+        nm += ".mex";
       else
-	nm += ".m";
+        nm += ".m";
 
       retval[count++] = nm;
     }
 
   return retval;
 }
 
 void
@@ -1523,101 +1523,101 @@ load_path::do_display (std::ostream& os)
 {
   for (const_dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        i++)
     {
       string_vector fcn_files = i->fcn_files;
 
       if (! fcn_files.empty ())
-	{
-	  os << "\n*** function files in " << i->dir_name << ":\n\n";
-
-	  fcn_files.list_in_columns (os);
-	}
+        {
+          os << "\n*** function files in " << i->dir_name << ":\n\n";
+
+          fcn_files.list_in_columns (os);
+        }
 
       const dir_info::method_file_map_type& method_file_map
-	= i->method_file_map;
+        = i->method_file_map;
 
       if (! method_file_map.empty ())
-	{
-	  for (dir_info::const_method_file_map_iterator p = method_file_map.begin ();
-	       p != method_file_map.end ();
-	       p++)
-	    {
-	      os << "\n*** methods in " << i->dir_name
-		 << "/@" << p->first << ":\n\n";
-
-	      const dir_info::class_info& ci = p->second;
-
-	      string_vector method_files = get_file_list (ci.method_file_map);
-
-	      method_files.list_in_columns (os);
-	    }
-	}
+        {
+          for (dir_info::const_method_file_map_iterator p = method_file_map.begin ();
+               p != method_file_map.end ();
+               p++)
+            {
+              os << "\n*** methods in " << i->dir_name
+                 << "/@" << p->first << ":\n\n";
+
+              const dir_info::class_info& ci = p->second;
+
+              string_vector method_files = get_file_list (ci.method_file_map);
+
+              method_files.list_in_columns (os);
+            }
+        }
     }
 
   for (const_private_fcn_map_iterator i = private_fcn_map.begin ();
        i != private_fcn_map.end (); i++)
     {
       os << "\n*** private functions in "
-	 << file_ops::concat (i->first, "private") << ":\n\n";
+         << file_ops::concat (i->first, "private") << ":\n\n";
 
       print_fcn_list (os, i->second);
     }
 
 #if defined (DEBUG_LOAD_PATH)
 
   for (const_fcn_map_iterator i = fcn_map.begin ();
        i != fcn_map.end ();
        i++)
     {
       os << i->first << ":\n";
 
       const file_info_list_type& file_info_list = i->second;
 
       for (const_file_info_list_iterator p = file_info_list.begin ();
-	   p != file_info_list.end ();
-	   p++)
-	{
-	  os << "  " << p->dir_name << " (";
-
-	  print_types (os, p->types);
-
-	  os << ")\n";
-	}
+           p != file_info_list.end ();
+           p++)
+        {
+          os << "  " << p->dir_name << " (";
+
+          print_types (os, p->types);
+
+          os << ")\n";
+        }
     }
 
   for (const_method_map_iterator i = method_map.begin ();
        i != method_map.end ();
        i++)
     {
       os << "CLASS " << i->first << ":\n";
 
       const fcn_map_type& fm = i->second;
 
       for (const_fcn_map_iterator q = fm.begin ();
-	   q != fm.end ();
-	   q++)
-	{
-	  os << "  " << q->first << ":\n";
-
-	  const file_info_list_type& file_info_list = q->second;
-
-	  for (const_file_info_list_iterator p = file_info_list.begin ();
-	       p != file_info_list.end ();
-	       p++)
-	    {
-	      os << "  " << p->dir_name << " (";
-
-	      print_types (os, p->types);
-
-	      os << ")\n";
-	    }
-	}
+           q != fm.end ();
+           q++)
+        {
+          os << "  " << q->first << ":\n";
+
+          const file_info_list_type& file_info_list = q->second;
+
+          for (const_file_info_list_iterator p = file_info_list.begin ();
+               p != file_info_list.end ();
+               p++)
+            {
+              os << "  " << p->dir_name << " (";
+
+              print_types (os, p->types);
+
+              os << ")\n";
+            }
+        }
     }
 
   os << "\n";
 
 #endif
 }
 
 void
@@ -1634,48 +1634,48 @@ load_path::add_to_fcn_map (const dir_inf
       std::string fname = fcn_files[i];
 
       std::string ext;
       std::string base = fname;
 
       size_t pos = fname.rfind ('.');
 
       if (pos != std::string::npos)
-	{
-	  base = fname.substr (0, pos);
-	  ext = fname.substr (pos);
-	}
+        {
+          base = fname.substr (0, pos);
+          ext = fname.substr (pos);
+        }
 
       file_info_list_type& file_info_list = fcn_map[base];
 
       file_info_list_iterator p = file_info_list.begin ();
 
       while (p != file_info_list.end ())
-	{
-	  if (p->dir_name == dir_name)
-	    break;
-
-	  p++;
-	}
+        {
+          if (p->dir_name == dir_name)
+            break;
+
+          p++;
+        }
 
       int t = 0;
       if (ext == ".m")
-	t = load_path::M_FILE;
+        t = load_path::M_FILE;
       else if (ext == ".oct")
-	t = load_path::OCT_FILE;
+        t = load_path::OCT_FILE;
       else if (ext == ".mex")
-	t = load_path::MEX_FILE;
+        t = load_path::MEX_FILE;
 
       if (p == file_info_list.end ())
-	{
-	  file_info fi (dir_name, t);
-
-	  if (at_end)
-	    file_info_list.push_back (fi);
-	  else
+        {
+          file_info fi (dir_name, t);
+
+          if (at_end)
+            file_info_list.push_back (fi);
+          else
             {
               // Warn if a built-in or library function is being shadowed.
               if (! file_info_list.empty ())
                 {
                   file_info& old = file_info_list.front ();
                   if (sys_path.find (old.dir_name) != std::string::npos)
                     {
                       std::string fcn_path = file_ops::concat (dir_name, fname);
@@ -1689,23 +1689,23 @@ load_path::add_to_fcn_map (const dir_inf
                   std::string fcn_path = file_ops::concat (dir_name, fname);
                   warning_with_id ("Octave:shadowed-function",
                                    "function %s shadows a built-in function", 
                                    fcn_path.c_str ());
                 }
 
               file_info_list.push_front (fi);
             }
-	}
+        }
       else
-	{
-	  file_info& fi = *p;
-
-	  fi.types |= t;
-	}
+        {
+          file_info& fi = *p;
+
+          fi.types |= t;
+        }
     }
 }
 
 void
 load_path::add_to_private_fcn_map (const dir_info& di) const
 {
   dir_info::fcn_file_map_type private_file_map = di.private_file_map;
 
@@ -1725,67 +1725,67 @@ load_path::add_to_method_map (const dir_
        q != method_file_map.end ();
        q++)
     {
       std::string class_name = q->first;
 
       fcn_map_type& fm = method_map[class_name];
 
       std::string full_dir_name
-	= file_ops::concat (dir_name, "@" + class_name);
+        = file_ops::concat (dir_name, "@" + class_name);
 
       const dir_info::class_info& ci = q->second;
 
       // <FCN_NAME, TYPES>
       const dir_info::fcn_file_map_type& m = ci.method_file_map;
 
       for (dir_info::const_fcn_file_map_iterator p = m.begin ();
-	   p != m.end ();
-	   p++)
-	{
-	  std::string base = p->first;
-
-	  int types = p->second;
-
-	  file_info_list_type& file_info_list = fm[base];
-
-	  file_info_list_iterator p2 = file_info_list.begin ();
-
-	  while (p2 != file_info_list.end ())
-	    {
-	      if (p2->dir_name == full_dir_name)
-		break;
-
-	      p2++;
-	    }
-
-	  if (p2 == file_info_list.end ())
-	    {
-	      file_info fi (full_dir_name, types);
-
-	      if (at_end)
-		file_info_list.push_back (fi);
-	      else
-		file_info_list.push_front (fi);
-	    }
-	  else
-	    {
-	      // FIXME -- is this possible?
-
-	      file_info& fi = *p2;
-
-	      fi.types = types;
-	    }
-	}
+           p != m.end ();
+           p++)
+        {
+          std::string base = p->first;
+
+          int types = p->second;
+
+          file_info_list_type& file_info_list = fm[base];
+
+          file_info_list_iterator p2 = file_info_list.begin ();
+
+          while (p2 != file_info_list.end ())
+            {
+              if (p2->dir_name == full_dir_name)
+                break;
+
+              p2++;
+            }
+
+          if (p2 == file_info_list.end ())
+            {
+              file_info fi (full_dir_name, types);
+
+              if (at_end)
+                file_info_list.push_back (fi);
+              else
+                file_info_list.push_front (fi);
+            }
+          else
+            {
+              // FIXME -- is this possible?
+
+              file_info& fi = *p2;
+
+              fi.types = types;
+            }
+        }
 
       // <FCN_NAME, TYPES>
       dir_info::fcn_file_map_type private_file_map = ci.private_file_map;
 
       if (! private_file_map.empty ())
-	private_fcn_map[full_dir_name] = private_file_map;
+        private_fcn_map[full_dir_name] = private_file_map;
     }
 }
 
 std::string
 genpath (const std::string& dirname, const string_vector& skip)
 {
   std::string retval;
 
@@ -1795,53 +1795,53 @@ genpath (const std::string& dirname, con
     {
       retval = dirname;
 
       string_vector dirlist = dir.read ();
       
       octave_idx_type len = dirlist.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  std::string elt = dirlist[i];
-
-	  // FIXME -- the caller should be able to specify the list of
-	  // directories to skip in addition to ".", "..", and
-	  // directories beginning with "@".
-
-	  bool skip_p = (elt == "." || elt == ".." || elt[0] == '@');
-
-	  if (! skip_p)
-	    {
-	      for (octave_idx_type j = 0; j < skip.length (); j++)
-		{
-		  skip_p = (elt == skip[j]);
-		  if (skip_p)
-		    break;
-		}
-
-	      if (! skip_p)
-		{
-		  std::string nm = file_ops::concat (dirname, elt);
-
-		  file_stat fs (nm);
-
-		  if (fs && fs.is_dir ())
-		    retval += dir_path::path_sep_str () + genpath (nm);
-		}
-	    }
-	}
+        {
+          std::string elt = dirlist[i];
+
+          // FIXME -- the caller should be able to specify the list of
+          // directories to skip in addition to ".", "..", and
+          // directories beginning with "@".
+
+          bool skip_p = (elt == "." || elt == ".." || elt[0] == '@');
+
+          if (! skip_p)
+            {
+              for (octave_idx_type j = 0; j < skip.length (); j++)
+                {
+                  skip_p = (elt == skip[j]);
+                  if (skip_p)
+                    break;
+                }
+
+              if (! skip_p)
+                {
+                  std::string nm = file_ops::concat (dirname, elt);
+
+                  file_stat fs (nm);
+
+                  if (fs && fs.is_dir ())
+                    retval += dir_path::path_sep_str () + genpath (nm);
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 static void
 execute_pkg_add_or_del (const std::string& dir,
-			const std::string& script_file)
+                        const std::string& script_file)
 {
   if (! octave_interpreter_ready)
     return;
 
   unwind_protect frame;
 
   frame.protect_var (input_from_startup_file);
 
@@ -1875,19 +1875,19 @@ Return a path constructed from @var{dir}
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       std::string dirname = args(0).string_value ();
 
       if (! error_state)
-	retval = genpath (dirname);
+        retval = genpath (dirname);
       else
-	error ("genpath: expecting argument to be a character string");
+        error ("genpath: expecting argument to be a character string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static void
@@ -1976,39 +1976,39 @@ No checks are made for duplicate element
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("path");
 
   if (! error_state)
     {
       if (argc > 1)
-	{
-	  std::string path = argv[1];
-
-	  for (int i = 2; i < argc; i++)
-	    path += dir_path::path_sep_str () + argv[i];
-
-	  load_path::set (path, true);
-
-	  rehash_internal ();
-	}
+        {
+          std::string path = argv[1];
+
+          for (int i = 2; i < argc; i++)
+            path += dir_path::path_sep_str () + argv[i];
+
+          load_path::set (path, true);
+
+          rehash_internal ();
+        }
 
       if (nargout > 0)
-	retval = load_path::path ();
+        retval = load_path::path ();
       else if (argc == 1 && nargout == 0)
-	{
-	  octave_stdout << "\nOctave's search path contains the following directories:\n\n";
-
-	  string_vector dirs = load_path::dirs ();
-
-	  dirs.list_in_columns (octave_stdout);
-
-	  octave_stdout << "\n";
-	}
+        {
+          octave_stdout << "\nOctave's search path contains the following directories:\n\n";
+
+          string_vector dirs = load_path::dirs ();
+
+          dirs.list_in_columns (octave_stdout);
+
+          octave_stdout << "\n";
+        }
     }
 
   return retval;
 }
 
 DEFUN (addpath, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
@@ -2033,86 +2033,86 @@ Directories added to the path must exist
 
   if (nargin > 0)
     {
       bool append = false;
 
       octave_value option_arg = args(nargin-1);
 
       if (option_arg.is_string ())
-	{
-	  std::string option = option_arg.string_value ();
-
-	  if (option == "-end")
-	    {
-	      append = true;
-	      nargin--;
-	    }
-	  else if (option == "-begin")
-	    nargin--;
-	}
+        {
+          std::string option = option_arg.string_value ();
+
+          if (option == "-end")
+            {
+              append = true;
+              nargin--;
+            }
+          else if (option == "-begin")
+            nargin--;
+        }
       else if (option_arg.is_numeric_type ())
-	{
-	  int val = option_arg.int_value ();
-
-	  if (! error_state)
-	    {
-	      if (val == 0)
-		append = false;
-	      else if (val == 1)
-		append = true;
-	      else
-		{
-		  error ("addpath: expecting final argument to be 1 or 0");
-		  return retval;
-		}
-	    }
-	  else
-	    {
-	      error ("addpath: expecting final argument to be 1 or 0");
-	      return retval;
-	    }
-	}
+        {
+          int val = option_arg.int_value ();
+
+          if (! error_state)
+            {
+              if (val == 0)
+                append = false;
+              else if (val == 1)
+                append = true;
+              else
+                {
+                  error ("addpath: expecting final argument to be 1 or 0");
+                  return retval;
+                }
+            }
+          else
+            {
+              error ("addpath: expecting final argument to be 1 or 0");
+              return retval;
+            }
+        }
 
       bool need_to_update = false;
 
       for (int i = 0; i < nargin; i++)
-	{
-	  std::string arg = args(i).string_value ();
-
-	  if (! error_state)
-	    {
-	      std::list<std::string> dir_elts = split_path (arg);
-
-	      if (! append)
-		std::reverse (dir_elts.begin (), dir_elts.end ());
-
-	      for (std::list<std::string>::const_iterator p = dir_elts.begin ();
-		   p != dir_elts.end ();
-		   p++)
-		{
-		  std::string dir = *p;
-
-		  //dir = regexprep (dir_elts{j}, "//+", "/");
-		  //dir = regexprep (dir, "/$", "");
-
-		  if (append)
-		    load_path::append (dir, true);
-		  else
-		    load_path::prepend (dir, true);
-
-		  need_to_update = true;
-		}
-	    }
-	  else
-	    error ("addpath: expecting all args to be character strings");
-	}
+        {
+          std::string arg = args(i).string_value ();
+
+          if (! error_state)
+            {
+              std::list<std::string> dir_elts = split_path (arg);
+
+              if (! append)
+                std::reverse (dir_elts.begin (), dir_elts.end ());
+
+              for (std::list<std::string>::const_iterator p = dir_elts.begin ();
+                   p != dir_elts.end ();
+                   p++)
+                {
+                  std::string dir = *p;
+
+                  //dir = regexprep (dir_elts{j}, "//+", "/");
+                  //dir = regexprep (dir, "/$", "");
+
+                  if (append)
+                    load_path::append (dir, true);
+                  else
+                    load_path::prepend (dir, true);
+
+                  need_to_update = true;
+                }
+            }
+          else
+            error ("addpath: expecting all args to be character strings");
+        }
 
       if (need_to_update)
-	rehash_internal ();
+        rehash_internal ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (rmpath, args, nargout,
@@ -2133,42 +2133,42 @@ Remove @var{dir1}, @dots{} from the curr
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       bool need_to_update = false;
 
       for (int i = 0; i < nargin; i++)
-	{
-	  std::string arg = args(i).string_value ();
-
-	  if (! error_state)
-	    {
-	      std::list<std::string> dir_elts = split_path (arg);
-
-	      for (std::list<std::string>::const_iterator p = dir_elts.begin ();
-		   p != dir_elts.end ();
-		   p++)
-		{
-		  std::string dir = *p;
-
-		  //dir = regexprep (dir_elts{j}, "//+", "/");
-		  //dir = regexprep (dir, "/$", "");
-
-		  if (! load_path::remove (dir))
-		    warning ("rmpath: %s: not found", dir.c_str ());
-		  else
-		    need_to_update = true;
-		}
-	    }
-	  else
-	    error ("addpath: expecting all args to be character strings");
-	}
+        {
+          std::string arg = args(i).string_value ();
+
+          if (! error_state)
+            {
+              std::list<std::string> dir_elts = split_path (arg);
+
+              for (std::list<std::string>::const_iterator p = dir_elts.begin ();
+                   p != dir_elts.end ();
+                   p++)
+                {
+                  std::string dir = *p;
+
+                  //dir = regexprep (dir_elts{j}, "//+", "/");
+                  //dir = regexprep (dir, "/$", "");
+
+                  if (! load_path::remove (dir))
+                    warning ("rmpath: %s: not found", dir.c_str ());
+                  else
+                    need_to_update = true;
+                }
+            }
+          else
+            error ("addpath: expecting all args to be character strings");
+        }
 
       if (need_to_update)
-	rehash_internal ();
+        rehash_internal ();
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -109,17 +109,17 @@ static std::string Vdefault_save_options
 // The output format for Octave core files.
 static std::string Voctave_core_file_options = "-binary";
 
 static std::string
 default_save_header_format (void)
 {
   return
     std::string ("# Created by Octave " OCTAVE_VERSION
-		 ", %a %b %d %H:%M:%S %Y %Z <")
+                 ", %a %b %d %H:%M:%S %Y %Z <")
     + octave_env::get_user_name ()
     + std::string ("@")
     + octave_env::get_host_name ()
     + std::string (">");
 }
 
 // The format string for the comment line at the top of text-format
 // save files.  Passed to strftime.  Should begin with `#' and contain
@@ -137,66 +137,66 @@ gripe_file_open (const std::string& fcn,
     error ("%s: unable to open file `%s'", fcn.c_str (), file.c_str ());
 }
 
 // Install a variable with name NAME and the value VAL in the
 // symbol table.  If GLOBAL is TRUE, make the variable global.
 
 static void
 install_loaded_variable (const std::string& name,
-			 const octave_value& val,
-			 bool global, const std::string& /*doc*/)
+                         const octave_value& val,
+                         bool global, const std::string& /*doc*/)
 {
   if (global)
     {
       symbol_table::clear (name);
       symbol_table::mark_global (name);
       symbol_table::global_varref (name) = val;
     }
   else
     symbol_table::varref (name) = val;
 }
 
 // Return TRUE if NAME matches one of the given globbing PATTERNS.
 
 static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
-		  int num_pat, const std::string& name)
+                  int num_pat, const std::string& name)
 {
   for (int i = pat_idx; i < num_pat; i++)
     {
       glob_match pattern (patterns[i]);
 
       if (pattern.match (name))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 int
 read_binary_file_header (std::istream& is, bool& swap,
-			 oct_mach_info::float_format& flt_fmt, bool quiet)
+                         oct_mach_info::float_format& flt_fmt, bool quiet)
 {
   const int magic_len = 10;
   char magic[magic_len+1];
   is.read (magic, magic_len);
   magic[magic_len] = '\0';
 
   if (strncmp (magic, "Octave-1-L", magic_len) == 0)
     swap = oct_mach_info::words_big_endian ();
   else if (strncmp (magic, "Octave-1-B", magic_len) == 0)
     swap = ! oct_mach_info::words_big_endian ();
   else
     {
       if (! quiet)
-	error ("load: unable to read read binary file");
+        error ("load: unable to read read binary file");
       return -1;
     }
-	
+        
   char tmp = 0;
   is.read (&tmp, 1);
 
   flt_fmt = mopt_digit_to_float_format (tmp);
 
   if (flt_fmt == oct_mach_info::flt_fmt_unknown)
     {
       if (! quiet)
@@ -241,49 +241,49 @@ get_file_format (std::istream& file, con
       file.clear ();
       file.seekg (0, std::ios::beg);
 
       int32_t mopt, nr, nc, imag, len;
 
       int err = read_mat_file_header (file, swap, mopt, nr, nc, imag, len, 1);
 
       if (! err)
-	retval = LS_MAT_BINARY;
+        retval = LS_MAT_BINARY;
       else
-	{
-	  file.clear ();
-	  file.seekg (0, std::ios::beg);
+        {
+          file.clear ();
+          file.seekg (0, std::ios::beg);
 
-	  err = read_mat5_binary_file_header (file, swap, true, filename);
+          err = read_mat5_binary_file_header (file, swap, true, filename);
 
-	  if (! err)
-  	    {
-	      file.clear ();
-	      file.seekg (0, std::ios::beg);
-	      retval = LS_MAT5_BINARY;
-  	    }
-  	  else
-  	    {
-	      file.clear ();
-	      file.seekg (0, std::ios::beg);
+          if (! err)
+            {
+              file.clear ();
+              file.seekg (0, std::ios::beg);
+              retval = LS_MAT5_BINARY;
+            }
+          else
+            {
+              file.clear ();
+              file.seekg (0, std::ios::beg);
 
-	      std::string tmp = extract_keyword (file, "name");
+              std::string tmp = extract_keyword (file, "name");
 
-	      if (! tmp.empty ())
-		retval = LS_ASCII;
-	    }
-	}
+              if (! tmp.empty ())
+                retval = LS_ASCII;
+            }
+        }
     }
 
   return retval;
 }
 
 static load_save_format
 get_file_format (const std::string& fname, const std::string& orig_fname, 
-		 bool &use_zlib)
+                 bool &use_zlib)
 {
   load_save_format retval = LS_UNKNOWN;
 
 #ifdef HAVE_HDF5
   // check this before we open the file
   if (H5Fis_hdf5 (fname.c_str ()) > 0)
     return LS_HDF5;
 #endif /* HAVE_HDF5 */
@@ -292,52 +292,52 @@ get_file_format (const std::string& fnam
   use_zlib = false;
       
   if (file)
     {
       retval = get_file_format (file, orig_fname);
       file.close ();
 
 #ifdef HAVE_ZLIB
-      if (retval == LS_UNKNOWN && check_gzip_magic (fname))	
-	{
-	  gzifstream gzfile (fname.c_str ());
-	  use_zlib = true;
+      if (retval == LS_UNKNOWN && check_gzip_magic (fname))     
+        {
+          gzifstream gzfile (fname.c_str ());
+          use_zlib = true;
 
-	  if (gzfile)
-	    {
-	      retval = get_file_format (gzfile, orig_fname);
-	      gzfile.close ();
-	    }
-	}
+          if (gzfile)
+            {
+              retval = get_file_format (gzfile, orig_fname);
+              gzfile.close ();
+            }
+        }
 #endif
 
       if (retval == LS_UNKNOWN)
-	{
-	  // Try reading the file as numbers only, determining the
-	  // number of rows and columns from the data.  We don't
-	  // even bother to check to see if the first item in the
-	  // file is a number, so that get_complete_line() can
-	  // skip any comments that might appear at the top of the
-	  // file.
+        {
+          // Try reading the file as numbers only, determining the
+          // number of rows and columns from the data.  We don't
+          // even bother to check to see if the first item in the
+          // file is a number, so that get_complete_line() can
+          // skip any comments that might appear at the top of the
+          // file.
 
-	  retval = LS_MAT_ASCII;
-	}
+          retval = LS_MAT_ASCII;
+        }
     }
   else
     gripe_file_open ("load", orig_fname);
 
   return retval;
 }
 
 octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
-	 load_save_format format, oct_mach_info::float_format flt_fmt,
-	 bool list_only, bool swap, bool verbose,
-	 const string_vector& argv, int argv_idx, int argc, int nargout)
+         load_save_format format, oct_mach_info::float_format flt_fmt,
+         bool list_only, bool swap, bool verbose,
+         const string_vector& argv, int argv_idx, int argc, int nargout)
 {
   octave_value retval;
 
   Octave_map retstruct;
 
   std::ostringstream output_buf;
   std::list<std::string> symbol_names;
 
@@ -347,197 +347,197 @@ do_load (std::istream& stream, const std
     {
       bool global = false;
       octave_value tc;
 
       std::string name;
       std::string doc;
 
       switch (format.type)
-	{
-	case LS_ASCII:
-	  name = read_ascii_data (stream, orig_fname, global, tc, count);
-	  break;
+        {
+        case LS_ASCII:
+          name = read_ascii_data (stream, orig_fname, global, tc, count);
+          break;
 
-	case LS_BINARY:
-	  name = read_binary_data (stream, swap, flt_fmt, orig_fname,
-				   global, tc, doc);
-	  break;
+        case LS_BINARY:
+          name = read_binary_data (stream, swap, flt_fmt, orig_fname,
+                                   global, tc, doc);
+          break;
 
-	case LS_MAT_ASCII:
-	  name = read_mat_ascii_data (stream, orig_fname, tc);
-	  break;
+        case LS_MAT_ASCII:
+          name = read_mat_ascii_data (stream, orig_fname, tc);
+          break;
 
-	case LS_MAT_BINARY:
-	  name = read_mat_binary_data (stream, orig_fname, tc);
-	  break;
+        case LS_MAT_BINARY:
+          name = read_mat_binary_data (stream, orig_fname, tc);
+          break;
 
 #ifdef HAVE_HDF5
-	case LS_HDF5:
-	  name = read_hdf5_data (stream, orig_fname, global, tc, doc);
-	  break;
+        case LS_HDF5:
+          name = read_hdf5_data (stream, orig_fname, global, tc, doc);
+          break;
 #endif /* HAVE_HDF5 */
 
-	case LS_MAT5_BINARY:
-	case LS_MAT7_BINARY:
-	  name = read_mat5_binary_element (stream, orig_fname, swap,
-					   global, tc);
-	  break;
+        case LS_MAT5_BINARY:
+        case LS_MAT7_BINARY:
+          name = read_mat5_binary_element (stream, orig_fname, swap,
+                                           global, tc);
+          break;
 
-	default:
-	  gripe_unrecognized_data_fmt ("load");
-	  break;
-	}
+        default:
+          gripe_unrecognized_data_fmt ("load");
+          break;
+        }
 
       if (error_state || stream.eof () || name.empty ())
-	break;
+        break;
       else if (! error_state && ! name.empty ())
-	{
-	  if (tc.is_defined ())
-	    {
-	      if (format == LS_MAT_ASCII && argv_idx < argc)
-		warning ("load: loaded ASCII file `%s' -- ignoring extra args",
-			 orig_fname.c_str ());
+        {
+          if (tc.is_defined ())
+            {
+              if (format == LS_MAT_ASCII && argv_idx < argc)
+                warning ("load: loaded ASCII file `%s' -- ignoring extra args",
+                         orig_fname.c_str ());
 
-	      if (format == LS_MAT_ASCII
-		  || argv_idx == argc
-		  || matches_patterns (argv, argv_idx, argc, name))
-		{
-		  count++;
-		  if (list_only)
-		    {
-		      if (verbose)
-			{
-			  if (count == 1)
-			    output_buf
-			      << "type               rows   cols   name\n"
-			      << "====               ====   ====   ====\n";
+              if (format == LS_MAT_ASCII
+                  || argv_idx == argc
+                  || matches_patterns (argv, argv_idx, argc, name))
+                {
+                  count++;
+                  if (list_only)
+                    {
+                      if (verbose)
+                        {
+                          if (count == 1)
+                            output_buf
+                              << "type               rows   cols   name\n"
+                              << "====               ====   ====   ====\n";
 
-			  output_buf
-			    << std::setiosflags (std::ios::left)
-			    << std::setw (16) << tc.type_name () . c_str ()
-			    << std::setiosflags (std::ios::right)
-			    << std::setw (7) << tc.rows ()
-			    << std::setw (7) << tc.columns ()
-			    << "   " << name << "\n";
-			}
-		      else
-			symbol_names.push_back (name);
-		    }
-		  else
-		    {
-		      if (nargout == 1)
-			{
-			  if (format == LS_MAT_ASCII)
-			    retval = tc;
-			  else
-			    retstruct.assign (name, tc);
-			}
-		      else
-			install_loaded_variable (name, tc, global, doc);
-		    }
-		}
+                          output_buf
+                            << std::setiosflags (std::ios::left)
+                            << std::setw (16) << tc.type_name () . c_str ()
+                            << std::setiosflags (std::ios::right)
+                            << std::setw (7) << tc.rows ()
+                            << std::setw (7) << tc.columns ()
+                            << "   " << name << "\n";
+                        }
+                      else
+                        symbol_names.push_back (name);
+                    }
+                  else
+                    {
+                      if (nargout == 1)
+                        {
+                          if (format == LS_MAT_ASCII)
+                            retval = tc;
+                          else
+                            retstruct.assign (name, tc);
+                        }
+                      else
+                        install_loaded_variable (name, tc, global, doc);
+                    }
+                }
 
-	      // Only attempt to read one item from a headless text file.
+              // Only attempt to read one item from a headless text file.
 
-	      if (format == LS_MAT_ASCII)
-		break;
-	    }
-	  else
-	    error ("load: unable to load variable `%s'", name.c_str ());
-	}
+              if (format == LS_MAT_ASCII)
+                break;
+            }
+          else
+            error ("load: unable to load variable `%s'", name.c_str ());
+        }
       else
-	{
-	  if (count == 0)
-	    error ("load: are you sure `%s' is an Octave data file?",
-		   orig_fname.c_str ());
+        {
+          if (count == 0)
+            error ("load: are you sure `%s' is an Octave data file?",
+                   orig_fname.c_str ());
 
-	  break;
-	}
+          break;
+        }
     }
 
   if (list_only && count)
     {
       if (verbose)
-	{
-	  std::string msg = output_buf.str ();
+        {
+          std::string msg = output_buf.str ();
 
-	  if (nargout > 0)
-	    retval = msg;
-	  else
-	    octave_stdout << msg;
-	}
+          if (nargout > 0)
+            retval = msg;
+          else
+            octave_stdout << msg;
+        }
       else
-	{
-	  if (nargout  > 0)
-	    retval = Cell (string_vector (symbol_names));
-	  else
-	    {
-	      string_vector names (symbol_names);
+        {
+          if (nargout  > 0)
+            retval = Cell (string_vector (symbol_names));
+          else
+            {
+              string_vector names (symbol_names);
 
-	      names.list_in_columns (octave_stdout);
+              names.list_in_columns (octave_stdout);
 
-	      octave_stdout << "\n";
-	    }
-	}
+              octave_stdout << "\n";
+            }
+        }
     }
   else if (retstruct.nfields () != 0)
     retval = retstruct;
 
   return retval;
 }
 
 std::string
 find_file_to_load (const std::string& name, const std::string& orig_name)
 {
   std::string fname = name;
 
   if (! (octave_env::absolute_pathname (fname)
-	 || octave_env::rooted_relative_pathname (fname)))
+         || octave_env::rooted_relative_pathname (fname)))
     {
       file_stat fs (fname);
 
       if (! (fs.exists () && fs.is_reg ()))
-	{
-	  std::string tmp
+        {
+          std::string tmp
             = octave_env::make_absolute (load_path::find_file (fname));
 
-	  if (! tmp.empty ())
-	    {
-	      warning_with_id ("Octave:load-file-in-path",
-			       "load: file found in load path");
-	      fname = tmp;
-	    }
-	}
+          if (! tmp.empty ())
+            {
+              warning_with_id ("Octave:load-file-in-path",
+                               "load: file found in load path");
+              fname = tmp;
+            }
+        }
     }
 
   size_t dot_pos = fname.rfind (".");
   size_t sep_pos = fname.find_last_of (file_ops::dir_sep_chars ());
     
   if (dot_pos == std::string::npos
       || (sep_pos != std::string::npos && dot_pos < sep_pos))
     {
       // Either no '.' in name or no '.' appears after last directory
       // separator.
 
       file_stat fs (fname);
 
       if (! (fs.exists () && fs.is_reg ()))
-	fname = find_file_to_load (fname + ".mat", orig_name);
+        fname = find_file_to_load (fname + ".mat", orig_name);
     }
   else
     {
       file_stat fs (fname);
   
       if (! (fs.exists () && fs.is_reg ()))
-	{
-	  fname = "";
+        {
+          fname = "";
 
-	  error ("load: unable to find file %s", orig_name.c_str ());
-	}
+          error ("load: unable to find file %s", orig_name.c_str ());
+        }
     }
 
   return fname;
 }
 
 
 // HDF5 load/save documentation is included in the Octave manual
 // regardless, but if HDF5 is not linked in we also include a
@@ -665,69 +665,69 @@ Force Octave to assume the file is in Oc
 
   bool list_only = false;
   bool verbose = false;
 
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-force" || argv[i] == "-f")
-	{
-	  // Silently ignore this
-	  // warning ("load: -force ignored");
-	}
+        {
+          // Silently ignore this
+          // warning ("load: -force ignored");
+        }
       else if (argv[i] == "-list" || argv[i] == "-l")
-	{
-	  list_only = true;
-	}
+        {
+          list_only = true;
+        }
       else if (argv[i] == "-verbose" || argv[i] == "-v")
-	{
-	  verbose = true;
-	}
+        {
+          verbose = true;
+        }
       else if (argv[i] == "-ascii" || argv[i] == "-a")
-	{
-	  format = LS_MAT_ASCII;
-	}
+        {
+          format = LS_MAT_ASCII;
+        }
       else if (argv[i] == "-binary" || argv[i] == "-b")
-	{
-	  format = LS_BINARY;
-	}
+        {
+          format = LS_BINARY;
+        }
       else if (argv[i] == "-mat-binary" || argv[i] == "-mat" || argv[i] == "-m"
-	       || argv[i] == "-6" || argv[i] == "-v6")
-	{
-	  format = LS_MAT5_BINARY;
-	}
+               || argv[i] == "-6" || argv[i] == "-v6")
+        {
+          format = LS_MAT5_BINARY;
+        }
       else if (argv[i] == "-7" || argv[i] == "-v7")
-	{
-	  format = LS_MAT7_BINARY;
-	}
+        {
+          format = LS_MAT7_BINARY;
+        }
       else if (argv[i] == "-mat4-binary" || argv[i] == "-V4"
-	       || argv[i] == "-v4" || argv[i] == "-4")
-	{
-	  format = LS_MAT_BINARY;
-	}
+               || argv[i] == "-v4" || argv[i] == "-4")
+        {
+          format = LS_MAT_BINARY;
+        }
       else if (argv[i] == "-hdf5" || argv[i] == "-h")
-	{
+        {
 #ifdef HAVE_HDF5
-	  format = LS_HDF5;
+          format = LS_HDF5;
 #else /* ! HAVE_HDF5 */
-	  error ("load: octave executable was not linked with HDF5 library");
-	  return retval;
+          error ("load: octave executable was not linked with HDF5 library");
+          return retval;
 #endif /* ! HAVE_HDF5 */
-	}
+        }
       else if (argv[i] == "-import" || argv[i] == "-i")
-	{
-	  warning ("load: -import ignored");
-	}
+        {
+          warning ("load: -import ignored");
+        }
       else if (argv[i] == "-text" || argv[i] == "-t")
-	{
-	  format = LS_ASCII;
-	}
+        {
+          format = LS_ASCII;
+        }
       else
-	break;
+        break;
     }
 
   if (i == argc)
     {
       print_usage ();
       return retval;
     }
 
@@ -738,147 +738,147 @@ Force Octave to assume the file is in Oc
   bool swap = false;
 
   if (argv[i] == "-")
     {
       i++;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
-	error ("load: cannot read HDF5 format from stdin");
+        error ("load: cannot read HDF5 format from stdin");
       else
 #endif /* HAVE_HDF5 */
       if (format != LS_UNKNOWN)
-	{
-	  // FIXME -- if we have already seen EOF on a
-	  // previous call, how do we fix up the state of std::cin so
-	  // that we can get additional input?  I'm afraid that we
-	  // can't fix this using std::cin only.
+        {
+          // FIXME -- if we have already seen EOF on a
+          // previous call, how do we fix up the state of std::cin so
+          // that we can get additional input?  I'm afraid that we
+          // can't fix this using std::cin only.
 
-	  retval = do_load (std::cin, orig_fname, format, flt_fmt,
-			    list_only, swap, verbose, argv, i, argc,
-			    nargout);
-	}
+          retval = do_load (std::cin, orig_fname, format, flt_fmt,
+                            list_only, swap, verbose, argv, i, argc,
+                            nargout);
+        }
       else
-	error ("load: must specify file format if reading from stdin");
+        error ("load: must specify file format if reading from stdin");
     }
   else
     {
       std::string fname = file_ops::tilde_expand (argv[i]);
 
       fname = find_file_to_load (fname, orig_fname);
 
       if (error_state)
-	return retval;
+        return retval;
 
       bool use_zlib = false;
 
       if (format == LS_UNKNOWN)
-	format = get_file_format (fname, orig_fname, use_zlib);
+        format = get_file_format (fname, orig_fname, use_zlib);
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
-	{
-	  i++;
+        {
+          i++;
 
-	  hdf5_ifstream hdf5_file (fname.c_str ());
+          hdf5_ifstream hdf5_file (fname.c_str ());
 
-	  if (hdf5_file.file_id >= 0)
-	    {
-	      retval = do_load (hdf5_file, orig_fname, format,
-				flt_fmt, list_only, swap, verbose,
-				argv, i, argc, nargout);
+          if (hdf5_file.file_id >= 0)
+            {
+              retval = do_load (hdf5_file, orig_fname, format,
+                                flt_fmt, list_only, swap, verbose,
+                                argv, i, argc, nargout);
 
-	      hdf5_file.close ();
-	    }
-	  else
-	    gripe_file_open ("load", orig_fname);
-	}
+              hdf5_file.close ();
+            }
+          else
+            gripe_file_open ("load", orig_fname);
+        }
       else
 #endif /* HAVE_HDF5 */
-	// don't insert any statements here; the "else" above has to
-	// go with the "if" below!!!!!
+        // don't insert any statements here; the "else" above has to
+        // go with the "if" below!!!!!
       if (format != LS_UNKNOWN)
-	{
-	  i++;
+        {
+          i++;
 
-	  // Always open in binary mode and handle various
-	  // line-endings explicitly.
-	  std::ios::openmode mode = std::ios::in | std::ios::binary;
+          // Always open in binary mode and handle various
+          // line-endings explicitly.
+          std::ios::openmode mode = std::ios::in | std::ios::binary;
 
 #ifdef HAVE_ZLIB
-	  if (use_zlib)
-	    {
-	      gzifstream file (fname.c_str (), mode);
+          if (use_zlib)
+            {
+              gzifstream file (fname.c_str (), mode);
 
-	      if (file)
-		{
-		  if (format == LS_BINARY)
-		    {
-		      if (read_binary_file_header (file, swap, flt_fmt) < 0)
-			{
-			  if (file) file.close ();
-			  return retval;
-			}
-		    }
-		  else if (format == LS_MAT5_BINARY 
-			   || format == LS_MAT7_BINARY)
-		    {
-		      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
-			{
-			  if (file) file.close ();
-			  return retval;
-			}
-		    }
+              if (file)
+                {
+                  if (format == LS_BINARY)
+                    {
+                      if (read_binary_file_header (file, swap, flt_fmt) < 0)
+                        {
+                          if (file) file.close ();
+                          return retval;
+                        }
+                    }
+                  else if (format == LS_MAT5_BINARY 
+                           || format == LS_MAT7_BINARY)
+                    {
+                      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
+                        {
+                          if (file) file.close ();
+                          return retval;
+                        }
+                    }
 
-		  retval = do_load (file, orig_fname, format,
-				    flt_fmt, list_only, swap, verbose,
-				argv, i, argc, nargout);
+                  retval = do_load (file, orig_fname, format,
+                                    flt_fmt, list_only, swap, verbose,
+                                argv, i, argc, nargout);
 
-		  file.close ();
-		}
-	      else
-		gripe_file_open ("load", orig_fname);
-	    }
-	  else
+                  file.close ();
+                }
+              else
+                gripe_file_open ("load", orig_fname);
+            }
+          else
 #endif
-	    {
-	      std::ifstream file (fname.c_str (), mode);
+            {
+              std::ifstream file (fname.c_str (), mode);
 
-	      if (file)
-		{
-		  if (format == LS_BINARY)
-		    {
-		      if (read_binary_file_header (file, swap, flt_fmt) < 0)
-			{
-			  if (file) file.close ();
-			  return retval;
-			}
-		    }
-		  else if (format == LS_MAT5_BINARY 
-			   || format == LS_MAT7_BINARY)
-		    {
-		      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
-			{
-			  if (file) file.close ();
-			  return retval;
-			}
-		    }
+              if (file)
+                {
+                  if (format == LS_BINARY)
+                    {
+                      if (read_binary_file_header (file, swap, flt_fmt) < 0)
+                        {
+                          if (file) file.close ();
+                          return retval;
+                        }
+                    }
+                  else if (format == LS_MAT5_BINARY 
+                           || format == LS_MAT7_BINARY)
+                    {
+                      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
+                        {
+                          if (file) file.close ();
+                          return retval;
+                        }
+                    }
 
-		  retval = do_load (file, orig_fname, format,
-				    flt_fmt, list_only, swap, verbose,
-				    argv, i, argc, nargout);
+                  retval = do_load (file, orig_fname, format,
+                                    flt_fmt, list_only, swap, verbose,
+                                    argv, i, argc, nargout);
 
-		  file.close ();
-		}
-	      else
-		error ("load: unable open input file `%s'",
-		       orig_fname.c_str ());
-	    }
-	}
+                  file.close ();
+                }
+              else
+                error ("load: unable open input file `%s'",
+                       orig_fname.c_str ());
+            }
+        }
     }
     
   return retval;
 }
 
 // Return TRUE if PATTERN has any special globbing chars in it.
 
 static bool
@@ -888,61 +888,61 @@ glob_pattern_p (const std::string& patte
 
   int len = pattern.length ();
 
   for (int i = 0; i < len; i++)
     {
       char c = pattern[i];
 
       switch (c)
-	{
-	case '?':
-	case '*':
-	  return true;
+        {
+        case '?':
+        case '*':
+          return true;
 
-	case '[':	// Only accept an open brace if there is a close
-	  open++;	// brace to match it.  Bracket expressions must be
-	  continue;	// complete, according to Posix.2
+        case '[':       // Only accept an open brace if there is a close
+          open++;       // brace to match it.  Bracket expressions must be
+          continue;     // complete, according to Posix.2
 
-	case ']':
-	  if (open)
-	    return true;
-	  continue;
+        case ']':
+          if (open)
+            return true;
+          continue;
 
-	case '\\':
-	  if (i == len - 1)
-	    return false;
+        case '\\':
+          if (i == len - 1)
+            return false;
 
-	default:
-	  continue;
-	}
+        default:
+          continue;
+        }
     }
 
   return false;
 }
 
 static void
 do_save (std::ostream& os, const octave_value& tc,
-	 const std::string& name, const std::string& help,
-	 bool global, load_save_format fmt, bool save_as_floats)
+         const std::string& name, const std::string& help,
+         bool global, load_save_format fmt, bool save_as_floats)
 {
   switch (fmt.type)
     {
     case LS_ASCII:
       save_ascii_data (os, tc, name, global, 0);
       break;
 
     case LS_BINARY:
       save_binary_data (os, tc, name, help, global, save_as_floats);
       break;
 
     case LS_MAT_ASCII:
       if (! save_mat_ascii_data (os, tc, fmt.opts & LS_MAT_ASCII_LONG ? 16 : 8, 
                                  fmt.opts & LS_MAT_ASCII_TABS))
-	warning ("save: unable to save %s in ASCII format", name.c_str ());
+        warning ("save: unable to save %s in ASCII format", name.c_str ());
       break;
 
     case LS_MAT_BINARY:
       save_mat_binary_data (os, tc, name);
       break;
 
 #ifdef HAVE_HDF5
     case LS_HDF5:
@@ -963,17 +963,17 @@ do_save (std::ostream& os, const octave_
       break;
     }
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
-	 load_save_format fmt, bool save_as_floats)
+         load_save_format fmt, bool save_as_floats)
 {
   octave_value val = sr.varval ();
 
   if (val.is_defined ())
     {
       std::string name = sr.name ();
       std::string help;
       bool global = sr.is_global ();
@@ -982,275 +982,275 @@ do_save (std::ostream& os, const symbol_
     }
 }
 
 // save fields of a scalar structure STR matching PATTERN on stream OS
 // in the format specified by FMT.
 
 static size_t
 save_fields (std::ostream& os, const Octave_map& m,
-	     const std::string& pattern,
-	     load_save_format fmt, bool save_as_floats)
+             const std::string& pattern,
+             load_save_format fmt, bool save_as_floats)
 {
   glob_match pat (pattern);
   
   size_t saved = 0;
 
   for (Octave_map::const_iterator p = m.begin (); p != m.end (); p++)
     {
       std::string empty_str;
 
       if (pat.match(p->first))
         {
           do_save (os, p->second(0), p->first, empty_str,
-		   0, fmt, save_as_floats);
+                   0, fmt, save_as_floats);
 
           saved++;
         }
     }
 
   return saved;
 }
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.
 
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
-	   load_save_format fmt, bool save_as_floats)
+           load_save_format fmt, bool save_as_floats)
 {
   std::list<symbol_table::symbol_record> vars = symbol_table::glob (pattern);
 
   size_t saved = 0;
 
   typedef std::list<symbol_table::symbol_record>::const_iterator const_vars_iterator;
 
   for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
       do_save (os, *p, fmt, save_as_floats);
 
       if (error_state)
-	break;
+        break;
 
       saved++;
     }
 
   return saved;
 }
 
 static string_vector
 parse_save_options (const string_vector &argv,
-		    load_save_format &format, bool &append,
-		    bool &save_as_floats, bool &use_zlib)
+                    load_save_format &format, bool &append,
+                    bool &save_as_floats, bool &use_zlib)
 {
   string_vector retval;
   int argc = argv.length ();
 
   bool do_double = false, do_tabs = false;
 
   for (int i = 0; i < argc; i++)
     {
       if (argv[i] == "-append")
-	{
-	  append = true;
-	}
+        {
+          append = true;
+        }
       else if (argv[i] == "-ascii" || argv[i] == "-a")
-	{
-	  format = LS_MAT_ASCII;
-	}
+        {
+          format = LS_MAT_ASCII;
+        }
       else if (argv[i] == "-double")
-	{
-	  do_double = true;
-	}
+        {
+          do_double = true;
+        }
       else if (argv[i] == "-tabs")
-	{
-	  do_tabs = true;
-	}
+        {
+          do_tabs = true;
+        }
       else if (argv[i] == "-text" || argv[i] == "-t")
-	{
-	  format = LS_ASCII;
-	}
+        {
+          format = LS_ASCII;
+        }
       else if (argv[i] == "-binary" || argv[i] == "-b")
-	{
-	  format = LS_BINARY;
-	}
+        {
+          format = LS_BINARY;
+        }
       else if (argv[i] == "-hdf5" || argv[i] == "-h")
-	{
+        {
 #ifdef HAVE_HDF5
-	  format = LS_HDF5;
+          format = LS_HDF5;
 #else /* ! HAVE_HDF5 */
-	  error ("save: octave executable was not linked with HDF5 library");
+          error ("save: octave executable was not linked with HDF5 library");
 #endif /* ! HAVE_HDF5 */
-	}
+        }
       else if (argv[i] == "-mat-binary" || argv[i] == "-mat" 
-	       || argv[i] == "-m" || argv[i] == "-6" || argv[i] == "-v6"
-	       || argv[i] == "-V6")
-	{
-	  format = LS_MAT5_BINARY;
-	}
+               || argv[i] == "-m" || argv[i] == "-6" || argv[i] == "-v6"
+               || argv[i] == "-V6")
+        {
+          format = LS_MAT5_BINARY;
+        }
 #ifdef HAVE_ZLIB
       else if (argv[i] == "-mat7-binary" || argv[i] == "-7" 
-	       || argv[i] == "-v7" || argv[i] == "-V7")
-	{
-	  format = LS_MAT7_BINARY;
-	}
+               || argv[i] == "-v7" || argv[i] == "-V7")
+        {
+          format = LS_MAT7_BINARY;
+        }
 #endif
       else if (argv[i] == "-mat4-binary" || argv[i] == "-V4"
-	       || argv[i] == "-v4" || argv[i] == "-4")
-	{
-	  format = LS_MAT_BINARY;
-	}
+               || argv[i] == "-v4" || argv[i] == "-4")
+        {
+          format = LS_MAT_BINARY;
+        }
       else if (argv[i] == "-float-binary" || argv[i] == "-f")
-	{
-	  format = LS_BINARY;
-	  save_as_floats = true;
-	}
+        {
+          format = LS_BINARY;
+          save_as_floats = true;
+        }
       else if (argv[i] == "-float-hdf5")
-	{
+        {
 #ifdef HAVE_HDF5
-	  format = LS_HDF5;
-	  save_as_floats = true;
+          format = LS_HDF5;
+          save_as_floats = true;
 #else /* ! HAVE_HDF5 */
-	  error ("save: octave executable was not linked with HDF5 library");
+          error ("save: octave executable was not linked with HDF5 library");
 #endif /* ! HAVE_HDF5 */
-	}
+        }
 #ifdef HAVE_ZLIB
       else if (argv[i] == "-zip" || argv[i] == "-z")
-	{
-	  use_zlib  = true;
-	}
+        {
+          use_zlib  = true;
+        }
 #endif
       else
         retval.append (argv[i]);
     }
 
   if (do_double)
     {
       if (format == LS_MAT_ASCII)
-	format.opts |= LS_MAT_ASCII_LONG;
+        format.opts |= LS_MAT_ASCII_LONG;
       else
-	warning ("save: \"-double\" option only has an effect with \"-ascii\"");
+        warning ("save: \"-double\" option only has an effect with \"-ascii\"");
     }
 
   if (do_tabs)
     {
       if (format == LS_MAT_ASCII)
-	format.opts |= LS_MAT_ASCII_TABS;
+        format.opts |= LS_MAT_ASCII_TABS;
       else
-	warning ("save: \"-tabs\" option only has an effect with \"-ascii\"");
+        warning ("save: \"-tabs\" option only has an effect with \"-ascii\"");
     }
 
   return retval;
 }
 
 static string_vector
 parse_save_options (const std::string &arg, load_save_format &format, 
-		    bool &append, bool &save_as_floats, 
-		    bool &use_zlib)
+                    bool &append, bool &save_as_floats, 
+                    bool &use_zlib)
 {
   std::istringstream is (arg);
   std::string str;
   string_vector argv;
   
   while (! is.eof ())
     {
       is >> str;
       argv.append (str);
     }
 
   return parse_save_options (argv, format, append, save_as_floats, 
-			     use_zlib);
+                             use_zlib);
 }
 
 void
 write_header (std::ostream& os, load_save_format format)
 {
   switch (format.type)
     {
     case LS_BINARY:
       {
-	os << (oct_mach_info::words_big_endian ()
-	       ? "Octave-1-B" : "Octave-1-L");
+        os << (oct_mach_info::words_big_endian ()
+               ? "Octave-1-B" : "Octave-1-L");
 
-	oct_mach_info::float_format flt_fmt =
-	  oct_mach_info::native_float_format ();
+        oct_mach_info::float_format flt_fmt =
+          oct_mach_info::native_float_format ();
 
-	char tmp = static_cast<char> (float_format_to_mopt_digit (flt_fmt));
+        char tmp = static_cast<char> (float_format_to_mopt_digit (flt_fmt));
 
-	os.write (&tmp, 1);
+        os.write (&tmp, 1);
       }
       break;
 
     case LS_MAT5_BINARY:
     case LS_MAT7_BINARY:
       {
-	char const * versionmagic;
-	int16_t number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
-	struct tm bdt;
-	time_t now;
-	char headertext[128];
+        char const * versionmagic;
+        int16_t number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
+        struct tm bdt;
+        time_t now;
+        char headertext[128];
 
-	time (&now);
-	bdt = *gmtime (&now);
-	memset (headertext, ' ', 124);
-	// ISO 8601 format date
-	nstrftime (headertext, 124, "MATLAB 5.0 MAT-file, written by Octave "
+        time (&now);
+        bdt = *gmtime (&now);
+        memset (headertext, ' ', 124);
+        // ISO 8601 format date
+        nstrftime (headertext, 124, "MATLAB 5.0 MAT-file, written by Octave "
                    OCTAVE_VERSION ", %Y-%m-%d %T UTC", &bdt, 1, 0);
 
-	// The first pair of bytes give the version of the MAT file
-	// format.  The second pair of bytes form a magic number which
-	// signals a MAT file.  MAT file data are always written in
-	// native byte order.  The order of the bytes in the second
-	// pair indicates whether the file was written by a big- or
-	// little-endian machine.  However, the version number is
-	// written in the *opposite* byte order from everything else!
-	if (number == 1)
-	  versionmagic = "\x01\x00\x4d\x49"; // this machine is big endian
-	else
-	  versionmagic = "\x00\x01\x49\x4d"; // this machine is little endian
+        // The first pair of bytes give the version of the MAT file
+        // format.  The second pair of bytes form a magic number which
+        // signals a MAT file.  MAT file data are always written in
+        // native byte order.  The order of the bytes in the second
+        // pair indicates whether the file was written by a big- or
+        // little-endian machine.  However, the version number is
+        // written in the *opposite* byte order from everything else!
+        if (number == 1)
+          versionmagic = "\x01\x00\x4d\x49"; // this machine is big endian
+        else
+          versionmagic = "\x00\x01\x49\x4d"; // this machine is little endian
 
-	memcpy (headertext+124, versionmagic, 4);
-	os.write (headertext, 128);
+        memcpy (headertext+124, versionmagic, 4);
+        os.write (headertext, 128);
       }
 
       break;
 
 #ifdef HAVE_HDF5
     case LS_HDF5:
 #endif /* HAVE_HDF5 */
     case LS_ASCII:
       {
-	octave_localtime now;
+        octave_localtime now;
 
-	std::string comment_string = now.strftime (Vsave_header_format_string);
+        std::string comment_string = now.strftime (Vsave_header_format_string);
 
-	if (! comment_string.empty ())
-	  {
+        if (! comment_string.empty ())
+          {
 #ifdef HAVE_HDF5
-	    if (format == LS_HDF5)
-	      {
-		hdf5_ofstream& hs = dynamic_cast<hdf5_ofstream&> (os);
-		H5Gset_comment (hs.file_id, "/", comment_string.c_str ());
-	      }
-	    else
+            if (format == LS_HDF5)
+              {
+                hdf5_ofstream& hs = dynamic_cast<hdf5_ofstream&> (os);
+                H5Gset_comment (hs.file_id, "/", comment_string.c_str ());
+              }
+            else
 #endif /* HAVE_HDF5 */
-	      os << comment_string << "\n";
-	  }
+              os << comment_string << "\n";
+          }
       }
     break;
 
     default:
       break;
     }
 }
 
 static void
 save_vars (const string_vector& argv, int argv_idx, int argc,
-	   std::ostream& os, load_save_format fmt,
-	   bool save_as_floats, bool write_header_info)
+           std::ostream& os, load_save_format fmt,
+           bool save_as_floats, bool write_header_info)
 {
   if (write_header_info)
     write_header (os, fmt);
 
   if (argv_idx == argc)
     {
       save_vars (os, "*", fmt, save_as_floats);
     }
@@ -1270,86 +1270,86 @@ save_vars (const string_vector& argv, in
           return;
         }
 
       octave_value struct_var = symbol_table::varref (struct_name);
 
       if (! struct_var.is_map () || struct_var.numel () != 1) 
         {
           error ("save: `%s' is not a scalar structure",
-		 struct_name.c_str ());
+                 struct_name.c_str ());
           return;
         }
       Octave_map struct_var_map = struct_var.map_value ();
 
       ++argv_idx;
 
       if (argv_idx < argc) 
         {
           for (int i = argv_idx; i < argc; i++)
             {
               if (! save_fields (os, struct_var_map, argv[i], fmt,
-				 save_as_floats))
+                                 save_as_floats))
                 {
                   warning ("save: no such field `%s.%s'", 
-			   struct_name.c_str (), argv[i].c_str ());
+                           struct_name.c_str (), argv[i].c_str ());
                 }
             }
         }
       else
-	save_fields (os, struct_var_map, "*", fmt, save_as_floats);
+        save_fields (os, struct_var_map, "*", fmt, save_as_floats);
     }
   else
     {
       for (int i = argv_idx; i < argc; i++)
-	{
-	  if (! save_vars (os, argv[i], fmt, save_as_floats))
-	    warning ("save: no such variable `%s'", argv[i].c_str ());
-	}
+        {
+          if (! save_vars (os, argv[i], fmt, save_as_floats))
+            warning ("save: no such variable `%s'", argv[i].c_str ());
+        }
     }
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
-		  bool save_as_floats)
+                  bool save_as_floats)
 {
   write_header (os, fmt);
 
   std::list<symbol_table::symbol_record> vars
     = symbol_table::all_variables (symbol_table::top_scope (), 0);
 
   double save_mem_size = 0;
 
   typedef std::list<symbol_table::symbol_record>::const_iterator const_vars_iterator;
 
   for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
       octave_value val = p->varval ();
 
       if (val.is_defined ())
-	{
-	  std::string name = p->name ();
-	  std::string help;
-	  bool global = p->is_global ();
+        {
+          std::string name = p->name ();
+          std::string help;
+          bool global = p->is_global ();
 
-	  double val_size = val.byte_size () / 1024;
+          double val_size = val.byte_size () / 1024;
 
-	  // FIXME -- maybe we should try to throw out the largest first...
+          // FIXME -- maybe we should try to throw out the largest first...
 
-	  if (Voctave_core_file_limit < 0
-	      || save_mem_size + val_size < Voctave_core_file_limit)
-	    {
-	      save_mem_size += val_size;
+          if (Voctave_core_file_limit < 0
+              || save_mem_size + val_size < Voctave_core_file_limit)
+            {
+              save_mem_size += val_size;
 
-	      do_save (os, val, name, help, global, fmt, save_as_floats);
+              do_save (os, val, name, help, global, fmt, save_as_floats);
 
-	      if (error_state)
-		break;
-	    }
-	}
+              if (error_state)
+                break;
+            }
+        }
     }
 
   message (0, "save to `%s' complete", fname);
 }
 
 void
 dump_octave_core (void)
 {
@@ -1365,83 +1365,83 @@ dump_octave_core (void)
 
       bool save_as_floats = false;
 
       bool append = false;
 
       bool use_zlib = false;
 
       parse_save_options (Voctave_core_file_options, format, append, 
-			  save_as_floats, use_zlib);
+                          save_as_floats, use_zlib);
   
       std::ios::openmode mode = std::ios::out;
 
       // Matlab v7 files are always compressed
       if (format == LS_MAT7_BINARY)
-	use_zlib = false;
+        use_zlib = false;
 
       if (format == LS_BINARY
 #ifdef HAVE_HDF5
-	  || format == LS_HDF5
+          || format == LS_HDF5
 #endif
-	  || format == LS_MAT_BINARY
-	  || format == LS_MAT5_BINARY
-	  || format == LS_MAT7_BINARY)
-	mode |= std::ios::binary;
+          || format == LS_MAT_BINARY
+          || format == LS_MAT5_BINARY
+          || format == LS_MAT7_BINARY)
+        mode |= std::ios::binary;
 
       mode |= append ? std::ios::ate : std::ios::trunc;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
-	{
-	  hdf5_ofstream file (fname, mode);
+        {
+          hdf5_ofstream file (fname, mode);
 
-	  if (file.file_id >= 0)
-	    {
-	      dump_octave_core (file, fname, format, save_as_floats);
+          if (file.file_id >= 0)
+            {
+              dump_octave_core (file, fname, format, save_as_floats);
 
-	      file.close ();
-	    }
-	  else
-	    warning ("unable to open `%s' for writing...", fname);
-	}
+              file.close ();
+            }
+          else
+            warning ("unable to open `%s' for writing...", fname);
+        }
       else
 #endif /* HAVE_HDF5 */
-	// don't insert any commands here!  The open brace below must
-	// go with the else above!
-	{
+        // don't insert any commands here!  The open brace below must
+        // go with the else above!
+        {
 #ifdef HAVE_ZLIB
-	  if (use_zlib)
-	    {
-	      gzofstream file (fname, mode);
+          if (use_zlib)
+            {
+              gzofstream file (fname, mode);
 
-	      if (file)
-		{
-		  dump_octave_core (file, fname, format, save_as_floats);
+              if (file)
+                {
+                  dump_octave_core (file, fname, format, save_as_floats);
 
-		  file.close ();
-		}
-	      else
-		warning ("unable to open `%s' for writing...", fname);
-	    }
-	  else
+                  file.close ();
+                }
+              else
+                warning ("unable to open `%s' for writing...", fname);
+            }
+          else
 #endif
-	    {
-	      std::ofstream file (fname, mode);
-	  
-	      if (file)
-		{
-		  dump_octave_core (file, fname, format, save_as_floats);
+            {
+              std::ofstream file (fname, mode);
+          
+              if (file)
+                {
+                  dump_octave_core (file, fname, format, save_as_floats);
 
-		  file.close ();
-		}
-	      else
-		warning ("unable to open `%s' for writing...", fname);
-	    }
-	}
+                  file.close ();
+                }
+              else
+                warning ("unable to open `%s' for writing...", fname);
+            }
+        }
     }
 }
 
 #ifdef HAVE_ZLIB
 #define HAVE_ZLIB_HELP_STRING ""
 #else /* ! HAVE_ZLIB */
 #define HAVE_ZLIB_HELP_STRING "\n\
 This option is not available, as this Octave executable was not linked with\n\
@@ -1623,28 +1623,28 @@ the file @file{data} in Octave's binary 
     {
       i++;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
         error ("save: cannot write HDF5 format to stdout");
       else
 #endif /* HAVE_HDF5 */
-	// don't insert any commands here!  the brace below must go
-	// with the "else" above!
-	{
-	  if (append)
-	    warning ("save: ignoring -append option for output to stdout");
+        // don't insert any commands here!  the brace below must go
+        // with the "else" above!
+        {
+          if (append)
+            warning ("save: ignoring -append option for output to stdout");
 
-	  // FIXME -- should things intended for the screen end up
-	  // in a octave_value (string)?
-	  
-	  save_vars (argv, i, argc, octave_stdout, format,
-		     save_as_floats, true);
-	}
+          // FIXME -- should things intended for the screen end up
+          // in a octave_value (string)?
+          
+          save_vars (argv, i, argc, octave_stdout, format,
+                     save_as_floats, true);
+        }
     }
 
   // Guard against things like `save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
     {
       print_usage ();
       return retval;
@@ -1652,104 +1652,104 @@ the file @file{data} in Octave's binary 
   else
     {
       std::string fname = file_ops::tilde_expand (argv[i]);
 
       i++;
 
       // Matlab v7 files are always compressed
       if (format == LS_MAT7_BINARY)
-	use_zlib = false;
+        use_zlib = false;
 
       std::ios::openmode mode
-	= append ? (std::ios::app | std::ios::ate) : std::ios::out;
+        = append ? (std::ios::app | std::ios::ate) : std::ios::out;
 
       if (format == LS_BINARY
 #ifdef HAVE_HDF5
-	  || format == LS_HDF5
+          || format == LS_HDF5
 #endif
-	  || format == LS_MAT_BINARY
-	  || format == LS_MAT5_BINARY
-	  || format == LS_MAT7_BINARY)
-	mode |= std::ios::binary;
+          || format == LS_MAT_BINARY
+          || format == LS_MAT5_BINARY
+          || format == LS_MAT7_BINARY)
+        mode |= std::ios::binary;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
-	{
-	  // FIXME. It should be possible to append to HDF5 files.
-	  if (append)
-	    {
-	      error ("save: appending to HDF5 files is not implemented");
-	      return retval;
-	    }
+        {
+          // FIXME. It should be possible to append to HDF5 files.
+          if (append)
+            {
+              error ("save: appending to HDF5 files is not implemented");
+              return retval;
+            }
 
-	  bool write_header_info = ! (append && 
-				      H5Fis_hdf5 (fname.c_str ()) > 0);
+          bool write_header_info = ! (append && 
+                                      H5Fis_hdf5 (fname.c_str ()) > 0);
 
-	  hdf5_ofstream hdf5_file (fname.c_str (), mode);
+          hdf5_ofstream hdf5_file (fname.c_str (), mode);
 
-	  if (hdf5_file.file_id != -1)
-	    {
-	      save_vars (argv, i, argc, hdf5_file, format,
-			 save_as_floats, write_header_info);
+          if (hdf5_file.file_id != -1)
+            {
+              save_vars (argv, i, argc, hdf5_file, format,
+                         save_as_floats, write_header_info);
 
-	      hdf5_file.close ();
-	  }
-	else
-	  {
-	    gripe_file_open ("save", fname);
-	    return retval;
-	  }
-	}
+              hdf5_file.close ();
+          }
+        else
+          {
+            gripe_file_open ("save", fname);
+            return retval;
+          }
+        }
       else
 #endif /* HAVE_HDF5 */
-	// don't insert any statements here!  The brace below must go
-	// with the "else" above!
-	{
+        // don't insert any statements here!  The brace below must go
+        // with the "else" above!
+        {
 #ifdef HAVE_ZLIB
-	  if (use_zlib)
-	    {
-	      gzofstream file (fname.c_str (), mode);
+          if (use_zlib)
+            {
+              gzofstream file (fname.c_str (), mode);
 
-	      if (file)
-		{
-		  bool write_header_info = ! file.tellp ();
+              if (file)
+                {
+                  bool write_header_info = ! file.tellp ();
 
-		  save_vars (argv, i, argc, file, format,
-			     save_as_floats, write_header_info);
+                  save_vars (argv, i, argc, file, format,
+                             save_as_floats, write_header_info);
 
-		  file.close ();
-		}
-	      else
-		{
-		  gripe_file_open ("save", fname);
-		  return retval;
-		}
-	    }
-	  else
+                  file.close ();
+                }
+              else
+                {
+                  gripe_file_open ("save", fname);
+                  return retval;
+                }
+            }
+          else
 #endif
-	    {
-	      std::ofstream file (fname.c_str (), mode);
-	  
-	      if (file)
-		{
-		  bool write_header_info = ! file.tellp ();
+            {
+              std::ofstream file (fname.c_str (), mode);
+          
+              if (file)
+                {
+                  bool write_header_info = ! file.tellp ();
 
-		  save_vars (argv, i, argc, file, format,
-			     save_as_floats, write_header_info);
+                  save_vars (argv, i, argc, file, format,
+                             save_as_floats, write_header_info);
 
-		  file.close ();
-		}
-	      else
-		{
-		  gripe_file_open ("save", fname);
-		  return retval;
-		}
-	    }
-	}
+                  file.close ();
+                }
+              else
+                {
+                  gripe_file_open ("save", fname);
+                  return retval;
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
diff --git a/src/ls-ascii-helper.cc b/src/ls-ascii-helper.cc
--- a/src/ls-ascii-helper.cc
+++ b/src/ls-ascii-helper.cc
@@ -44,44 +44,44 @@ skip_until_newline (std::istream& is, bo
   if (! is)
     return;
   
   while (is)
     {
       char c = is.peek ();
 
       if (c == '\n' || c == '\r')
-	{
-	  // Reached newline.
-	  if (! keep_newline)
-	    {
-	      // Eat the CR or LF character.
-	      char d;
-	      is.get (d);
-	      
-	      // Make sure that for binary-mode opened ascii files
-	      // containing CRLF line endings we skip the LF after CR.
-	      if (c == '\r' && is.peek () == '\n')
-		{
-		  // Yes, LF following CR, eat it.
-		  is.get (d);
-		}
-	    }
-	  
-	  // Newline was found, and read from stream if
-	  // keep_newline == true, so exit loop.
-	  break;
-	}
+        {
+          // Reached newline.
+          if (! keep_newline)
+            {
+              // Eat the CR or LF character.
+              char d;
+              is.get (d);
+              
+              // Make sure that for binary-mode opened ascii files
+              // containing CRLF line endings we skip the LF after CR.
+              if (c == '\r' && is.peek () == '\n')
+                {
+                  // Yes, LF following CR, eat it.
+                  is.get (d);
+                }
+            }
+          
+          // Newline was found, and read from stream if
+          // keep_newline == true, so exit loop.
+          break;
+        }
       else
-	{
-	  // No newline charater peeked, so read it and proceed to next
-	  // character.
-	  char d;
-	  is.get (d);
-	}
+        {
+          // No newline charater peeked, so read it and proceed to next
+          // character.
+          char d;
+          is.get (d);
+        }
     }
 }
 
 
 // If stream IS currently points to a newline (a leftover from a
 // previous read) then eat newline(s) until a non-newline character is
 // found.
 
@@ -93,34 +93,34 @@ skip_preceeding_newline (std::istream& i
   
   // Check whether IS currently points to newline character.
   char c = is.peek ();
 
   if (c == '\n' || c == '\r')
     {
       // Yes, at newline.
       do
-	{
-	  // Eat the CR or LF character.
-	  char d;
-	  is.get (d);
-	  
-	  // Make sure that for binary-mode opened ascii files
-	  // containing CRLF line endings we skip the LF after CR.
-	  if (c == '\r' && is.peek () == '\n')
-	    {
-	      // Yes, LF following CR, eat it.
-	      is.get (d);
-	  }
-	  
-	  // Peek into next character.
-	  c = is.peek ();
+        {
+          // Eat the CR or LF character.
+          char d;
+          is.get (d);
+          
+          // Make sure that for binary-mode opened ascii files
+          // containing CRLF line endings we skip the LF after CR.
+          if (c == '\r' && is.peek () == '\n')
+            {
+              // Yes, LF following CR, eat it.
+              is.get (d);
+          }
+          
+          // Peek into next character.
+          c = is.peek ();
 
-	  // Loop while still a newline ahead.
-	}
+          // Loop while still a newline ahead.
+        }
       while (c == '\n' || c == '\r');
     }
 }
 
 // Read charaters from stream IS until a newline is reached.
 // Depending on KEEP_NEWLINE, either eat newline from stream or keep
 // it unread.  Characters read are stored and returned as
 // std::string.
@@ -133,43 +133,43 @@ read_until_newline (std::istream& is, bo
   
   std::ostringstream buf;
   
   while (is)
     {
       char c = is.peek ();
 
       if (c == '\n' || c == '\r')
-	{
-	  // Reached newline.
-	  if (! keep_newline)
-	    {
-	      // Eat the CR or LF character.
-	      char d;
-	      is.get (d);
-	      
-	      // Make sure that for binary-mode opened ascii files
-	      // containing CRLF line endings we skip the LF after
-	      // CR.
+        {
+          // Reached newline.
+          if (! keep_newline)
+            {
+              // Eat the CR or LF character.
+              char d;
+              is.get (d);
+              
+              // Make sure that for binary-mode opened ascii files
+              // containing CRLF line endings we skip the LF after
+              // CR.
 
-	      if (c == '\r' && is.peek () == '\n')
-		{
-		  // Yes, LF following CR, eat it.
-		  is.get (d);
-		}
-	    }
-	  
-	  // Newline was found, and read from stream if
-	  // keep_newline == true, so exit loop.
-	  break;
-	}
+              if (c == '\r' && is.peek () == '\n')
+                {
+                  // Yes, LF following CR, eat it.
+                  is.get (d);
+                }
+            }
+          
+          // Newline was found, and read from stream if
+          // keep_newline == true, so exit loop.
+          break;
+        }
       else
-	{
-	  // No newline charater peeked, so read it, store it, and
-	  // proceed to next.
-	  char d;
-	  is.get (d);
-	  buf << d;
-	}
+        {
+          // No newline charater peeked, so read it, store it, and
+          // proceed to next.
+          char d;
+          is.get (d);
+          buf << d;
+        }
     }
   
   return buf.str ();
 }
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -76,23 +76,23 @@ make_valid_identifier (const std::string
 {
   std::string retval;
 
   size_t nm_len = nm.length ();
 
   if (nm_len > 0)
     {
       if (! isalpha (nm[0]))
-	retval += '_';
+        retval += '_';
 
       for (size_t i = 0; i < nm_len; i++)
-	{
-	  char c = nm[i];
-	  retval += (isalnum (c) || c == '_') ? c : '_';
-	}
+        {
+          char c = nm[i];
+          retval += (isalnum (c) || c == '_') ? c : '_';
+        }
     }
 
   return retval;
 }
 
 // Define this to 1 if/when HDF5 supports automatic conversion between
 // integer and floating-point binary data:
 #define HAVE_HDF5_INT2FLOAT_CONVERSIONS 0
@@ -110,17 +110,17 @@ hdf5_types_compatible (hid_t t1, hid_t t
     return false;
 
   for (int i = 0; i < n; ++i)
     {
       hid_t mt1 = H5Tget_member_type (t1, i);
       hid_t mt2 = H5Tget_member_type (t2, i);
 
       if (H5Tget_class (mt1) != H5Tget_class (mt2))
-	return false;
+        return false;
 
       H5Tclose (mt2);
       H5Tclose (mt1);
     }
 
   return true;
 }
 
@@ -226,317 +226,317 @@ hdf5_read_next_data (hid_t group_id, con
     {
 #if HAVE_HDF5_18
       subgroup_id = H5Gopen (group_id, name, H5P_DEFAULT);
 #else
       subgroup_id = H5Gopen (group_id, name);
 #endif
 
       if (subgroup_id < 0)
-	{
-	  retval = subgroup_id;
-	  goto done;
-	}
+        {
+          retval = subgroup_id;
+          goto done;
+        }
 
       if (hdf5_check_attr (subgroup_id, "OCTAVE_NEW_FORMAT"))
-	{
+        {
 #if HAVE_HDF5_18
-	  data_id = H5Dopen (subgroup_id, "type", H5P_DEFAULT);
+          data_id = H5Dopen (subgroup_id, "type", H5P_DEFAULT);
 #else
-	  data_id = H5Dopen (subgroup_id, "type");
+          data_id = H5Dopen (subgroup_id, "type");
 #endif
 
-	  if (data_id < 0)
-	    {
-	      retval = data_id;
-	      goto done;
-	    }
+          if (data_id < 0)
+            {
+              retval = data_id;
+              goto done;
+            }
 
-	  type_id = H5Dget_type (data_id);
+          type_id = H5Dget_type (data_id);
 
-	  type_class_id = H5Tget_class (type_id);
+          type_class_id = H5Tget_class (type_id);
 
-	  if (type_class_id != H5T_STRING)
-	    goto done;
-	  
-	  space_id = H5Dget_space (data_id);
-	  hsize_t rank = H5Sget_simple_extent_ndims (space_id);
+          if (type_class_id != H5T_STRING)
+            goto done;
+          
+          space_id = H5Dget_space (data_id);
+          hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
-	  if (rank != 0)
-	    goto done;
+          if (rank != 0)
+            goto done;
 
-	  int slen = H5Tget_size (type_id);
-	  if (slen < 0)
-	    goto done;
+          int slen = H5Tget_size (type_id);
+          if (slen < 0)
+            goto done;
 
-	  OCTAVE_LOCAL_BUFFER (char, typ, slen);
+          OCTAVE_LOCAL_BUFFER (char, typ, slen);
 
-	  // create datatype for (null-terminated) string to read into:
-	  hid_t st_id = H5Tcopy (H5T_C_S1);
-	  H5Tset_size (st_id, slen);
+          // create datatype for (null-terminated) string to read into:
+          hid_t st_id = H5Tcopy (H5T_C_S1);
+          H5Tset_size (st_id, slen);
 
-	  if (H5Dread (data_id, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
-		       typ) < 0)
-	    goto done;
+          if (H5Dread (data_id, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
+                       typ) < 0)
+            goto done;
 
-	  H5Tclose (st_id);
-	  H5Dclose (data_id);
+          H5Tclose (st_id);
+          H5Dclose (data_id);
 
-	  d->tc = octave_value_typeinfo::lookup_type (typ);
+          d->tc = octave_value_typeinfo::lookup_type (typ);
 
-	  retval = (d->tc.load_hdf5 (subgroup_id, "value") ? 1 : -1);
+          retval = (d->tc.load_hdf5 (subgroup_id, "value") ? 1 : -1);
 
-	  // check for OCTAVE_GLOBAL attribute:
-	  d->global = hdf5_check_attr (subgroup_id, "OCTAVE_GLOBAL");
+          // check for OCTAVE_GLOBAL attribute:
+          d->global = hdf5_check_attr (subgroup_id, "OCTAVE_GLOBAL");
 
-	  H5Gclose (subgroup_id);
-	}
+          H5Gclose (subgroup_id);
+        }
       else
-	{
-	  // an HDF5 group is treated as an octave structure by
-	  // default (since that preserves name information), and an
-	  // octave list otherwise.
+        {
+          // an HDF5 group is treated as an octave structure by
+          // default (since that preserves name information), and an
+          // octave list otherwise.
 
-	  if (hdf5_check_attr (subgroup_id, "OCTAVE_LIST"))
-	    d->tc = octave_value_typeinfo::lookup_type ("list");
-	  else
-	    d->tc = octave_value_typeinfo::lookup_type ("struct");
-	  
-	  // check for OCTAVE_GLOBAL attribute:
-	  d->global = hdf5_check_attr (subgroup_id, "OCTAVE_GLOBAL");
+          if (hdf5_check_attr (subgroup_id, "OCTAVE_LIST"))
+            d->tc = octave_value_typeinfo::lookup_type ("list");
+          else
+            d->tc = octave_value_typeinfo::lookup_type ("struct");
+          
+          // check for OCTAVE_GLOBAL attribute:
+          d->global = hdf5_check_attr (subgroup_id, "OCTAVE_GLOBAL");
 
-	  H5Gclose (subgroup_id);
+          H5Gclose (subgroup_id);
 
-	  retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
-	}
+          retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
+        }
 
     }
   else if (info.type == H5G_DATASET && ident_valid)
     {
       // For backwards compatiability.
 #if HAVE_HDF5_18
       data_id = H5Dopen (group_id, name, H5P_DEFAULT);
 #else
       data_id = H5Dopen (group_id, name);
 #endif
 
       if (data_id < 0)
-	{
-	  retval = data_id;
-	  goto done;
-	}
+        {
+          retval = data_id;
+          goto done;
+        }
 
       type_id = H5Dget_type (data_id);
       
       type_class_id = H5Tget_class (type_id);
 
       if (type_class_id == H5T_FLOAT)
-	{
-	  space_id = H5Dget_space (data_id);
+        {
+          space_id = H5Dget_space (data_id);
 
-	  hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-	  
-	  if (rank == 0)
-	    d->tc = octave_value_typeinfo::lookup_type ("scalar");
-	  else
-	    d->tc = octave_value_typeinfo::lookup_type ("matrix");
+          hsize_t rank = H5Sget_simple_extent_ndims (space_id);
+          
+          if (rank == 0)
+            d->tc = octave_value_typeinfo::lookup_type ("scalar");
+          else
+            d->tc = octave_value_typeinfo::lookup_type ("matrix");
 
-	  H5Sclose (space_id);
-	}
+          H5Sclose (space_id);
+        }
       else if (type_class_id == H5T_INTEGER)
-	{
-	  // What integer type do we really have..
-	  std::string int_typ;
+        {
+          // What integer type do we really have..
+          std::string int_typ;
 #ifdef HAVE_H5T_GET_NATIVE_TYPE
-	  // FIXME test this code and activated with an autoconf 
-	  // test!! It is also incorrect for 64-bit indexing!!
-	  
-	  switch (H5Tget_native_type (type_id, H5T_DIR_ASCEND))
-	    {
-	    case H5T_NATIVE_CHAR:
-	      int_typ = "int8 ";
-	      break;
+          // FIXME test this code and activated with an autoconf 
+          // test!! It is also incorrect for 64-bit indexing!!
+          
+          switch (H5Tget_native_type (type_id, H5T_DIR_ASCEND))
+            {
+            case H5T_NATIVE_CHAR:
+              int_typ = "int8 ";
+              break;
  
-	    case H5T_NATIVE_SHORT:
-	      int_typ = "int16 ";
-	      break;
+            case H5T_NATIVE_SHORT:
+              int_typ = "int16 ";
+              break;
 
-	    case H5T_NATIVE_INT:
-	    case H5T_NATIVE_LONG:
-	      int_typ = "int32 ";
-	      break;
+            case H5T_NATIVE_INT:
+            case H5T_NATIVE_LONG:
+              int_typ = "int32 ";
+              break;
 
-	    case H5T_NATIVE_LLONG:
-	      int_typ = "int64 ";
-	      break;
+            case H5T_NATIVE_LLONG:
+              int_typ = "int64 ";
+              break;
 
-	    case H5T_NATIVE_UCHAR:
-	      int_typ = "uint8 ";
-	      break;
+            case H5T_NATIVE_UCHAR:
+              int_typ = "uint8 ";
+              break;
 
-	    case H5T_NATIVE_USHORT:
-	      int_typ = "uint16 ";
-	      break;
+            case H5T_NATIVE_USHORT:
+              int_typ = "uint16 ";
+              break;
 
-	    case H5T_NATIVE_UINT:
-	    case H5T_NATIVE_ULONG:
-	      int_typ = "uint32 ";
-	      break;
+            case H5T_NATIVE_UINT:
+            case H5T_NATIVE_ULONG:
+              int_typ = "uint32 ";
+              break;
 
-	    case H5T_NATIVE_ULLONG:
-	      int_typ = "uint64 ";
-	      break;
-	    }   
+            case H5T_NATIVE_ULLONG:
+              int_typ = "uint64 ";
+              break;
+            }   
 #else
-	  hid_t int_sign = H5Tget_sign (type_id);
+          hid_t int_sign = H5Tget_sign (type_id);
 
-	  if (int_sign == H5T_SGN_ERROR)
-	    warning ("load: can't read `%s' (unknown datatype)", name);
-	  else
-	    {
-	      if (int_sign == H5T_SGN_NONE)
-		int_typ.append ("u");
-	      int_typ.append ("int");
+          if (int_sign == H5T_SGN_ERROR)
+            warning ("load: can't read `%s' (unknown datatype)", name);
+          else
+            {
+              if (int_sign == H5T_SGN_NONE)
+                int_typ.append ("u");
+              int_typ.append ("int");
 
-	      int slen = H5Tget_size (type_id);
-	      if (slen < 0)
-		warning ("load: can't read `%s' (unknown datatype)", name);
-	      else
-		{
-		  switch (slen)
-		    {
-		    case 1:
-		      int_typ.append ("8 ");
-		      break;
+              int slen = H5Tget_size (type_id);
+              if (slen < 0)
+                warning ("load: can't read `%s' (unknown datatype)", name);
+              else
+                {
+                  switch (slen)
+                    {
+                    case 1:
+                      int_typ.append ("8 ");
+                      break;
 
-		    case 2:
-		      int_typ.append ("16 ");
-		      break;
+                    case 2:
+                      int_typ.append ("16 ");
+                      break;
 
-		    case 4:
-		      int_typ.append ("32 ");
-		      break;
+                    case 4:
+                      int_typ.append ("32 ");
+                      break;
 
-		    case 8:
-		      int_typ.append ("64 ");
-		      break;
+                    case 8:
+                      int_typ.append ("64 ");
+                      break;
 
-		    default:
-		      warning ("load: can't read `%s' (unknown datatype)", 
-			       name);
-		      int_typ = "";
-		      break;
-		    }
-		}
-	    }
+                    default:
+                      warning ("load: can't read `%s' (unknown datatype)", 
+                               name);
+                      int_typ = "";
+                      break;
+                    }
+                }
+            }
 #endif
-	  if (int_typ == "")
-	    warning ("load: can't read `%s' (unknown datatype)", name);
-	  else
-	    {
-	      // Matrix or scalar?
-	      space_id = H5Dget_space (data_id);
+          if (int_typ == "")
+            warning ("load: can't read `%s' (unknown datatype)", name);
+          else
+            {
+              // Matrix or scalar?
+              space_id = H5Dget_space (data_id);
 
-	      hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-	      
-	      if (rank == 0)
-		int_typ.append ("scalar");
-	      else
-		int_typ.append ("matrix");
+              hsize_t rank = H5Sget_simple_extent_ndims (space_id);
+              
+              if (rank == 0)
+                int_typ.append ("scalar");
+              else
+                int_typ.append ("matrix");
 
-	      d->tc = octave_value_typeinfo::lookup_type (int_typ);
-	      H5Sclose (space_id);
-	    }
-	}
+              d->tc = octave_value_typeinfo::lookup_type (int_typ);
+              H5Sclose (space_id);
+            }
+        }
       else if (type_class_id == H5T_STRING)
-	d->tc = octave_value_typeinfo::lookup_type ("string");
+        d->tc = octave_value_typeinfo::lookup_type ("string");
       else if (type_class_id == H5T_COMPOUND)
-	{
-	  hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
+        {
+          hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
-	  if (hdf5_types_compatible (type_id, complex_type))
-	    {
-	      // read complex matrix or scalar variable
-	      space_id = H5Dget_space (data_id);
-	      hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-		  
-	      if (rank == 0)
-		d->tc = octave_value_typeinfo::lookup_type ("complex scalar");
-	      else
-		d->tc = octave_value_typeinfo::lookup_type ("complex matrix");
+          if (hdf5_types_compatible (type_id, complex_type))
+            {
+              // read complex matrix or scalar variable
+              space_id = H5Dget_space (data_id);
+              hsize_t rank = H5Sget_simple_extent_ndims (space_id);
+                  
+              if (rank == 0)
+                d->tc = octave_value_typeinfo::lookup_type ("complex scalar");
+              else
+                d->tc = octave_value_typeinfo::lookup_type ("complex matrix");
 
-	      H5Sclose (space_id);
-	    }
-	  else
-	    // Assume that if its not complex its a range. If its not
-	    // it'll be rejected later in the range code
-	    d->tc = octave_value_typeinfo::lookup_type ("range");
+              H5Sclose (space_id);
+            }
+          else
+            // Assume that if its not complex its a range. If its not
+            // it'll be rejected later in the range code
+            d->tc = octave_value_typeinfo::lookup_type ("range");
 
-	  H5Tclose (complex_type);
-	}
+          H5Tclose (complex_type);
+        }
       else
-	{
-	  warning ("load: can't read `%s' (unknown datatype)", name);
-	  retval = 0; // unknown datatype; skip
-	}
+        {
+          warning ("load: can't read `%s' (unknown datatype)", name);
+          retval = 0; // unknown datatype; skip
+        }
       
       // check for OCTAVE_GLOBAL attribute:
       d->global = hdf5_check_attr (data_id, "OCTAVE_GLOBAL");
 
       H5Tclose (type_id);
       H5Dclose (data_id);
 
       retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
     }
 
   if (!ident_valid)
     {
       // should we attempt to handle invalid identifiers by converting
       // bad characters to '_', say?
       warning ("load: skipping invalid identifier `%s' in hdf5 file",
-	       name);
+               name);
     }
 
  done:
   if (retval < 0)
     error ("load: error while reading hdf5 item %s", name);
   
   if (retval > 0)
     {
       // get documentation string, if any:
       int comment_length = H5Gget_comment (group_id, name, 0, 0);
 
       if (comment_length > 1)
-	{
-	  OCTAVE_LOCAL_BUFFER (char, tdoc, comment_length);
-	  H5Gget_comment (group_id, name, comment_length, tdoc);
-	  d->doc = tdoc;
-	}
+        {
+          OCTAVE_LOCAL_BUFFER (char, tdoc, comment_length);
+          H5Gget_comment (group_id, name, comment_length, tdoc);
+          d->doc = tdoc;
+        }
       else if (vname != name)
-	{
-	  // the name was changed; store the original name
-	  // as the documentation string:
-	  d->doc = name;
-	}
+        {
+          // the name was changed; store the original name
+          // as the documentation string:
+          d->doc = name;
+        }
 
       // copy name (actually, vname):
       d->name = vname;
     }
 
   return retval;
 }
 
 // Read the next Octave variable from the stream IS, which must really be
 // an hdf5_ifstream.  Return the variable value in tc, its doc string
 // in doc, and whether it is global in global.  The return value is
 // the name of the variable, or NULL if none were found or there was
 // and error.
 std::string
 read_hdf5_data (std::istream& is, const std::string& /* filename */, 
-		bool& global, octave_value& tc, std::string& doc)
+                bool& global, octave_value& tc, std::string& doc)
 {
   std::string retval;
 
   doc.resize (0);
 
   hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
 
@@ -547,17 +547,17 @@ read_hdf5_data (std::istream& is, const 
   hid_t group_id = H5Gopen (hs.file_id, "/", H5P_DEFAULT); 
 #else
   hid_t group_id = H5Gopen (hs.file_id, "/"); 
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
   if (hs.current_item < static_cast<int> (num_obj))
     H5Giterate_retval = H5Giterate (hs.file_id, "/", &hs.current_item,
-				    hdf5_read_next_data, &d);
+                                    hdf5_read_next_data, &d);
 
   if (H5Giterate_retval > 0)
     {
       global = d.global;
       tc = d.tc;
       doc = d.doc;
     }
   else
@@ -581,31 +581,31 @@ hdf5_add_attr (hid_t loc_id, const char 
   herr_t retval = 0;
 
   hid_t as_id = H5Screate (H5S_SCALAR);
 
   if (as_id >= 0)
     {
 #if HAVE_HDF5_18
       hid_t a_id = H5Acreate (loc_id, attr_name, H5T_NATIVE_UCHAR, 
-      			      as_id, H5P_DEFAULT, H5P_DEFAULT);
+                              as_id, H5P_DEFAULT, H5P_DEFAULT);
 #else
       hid_t a_id = H5Acreate (loc_id, attr_name,
-			      H5T_NATIVE_UCHAR, as_id, H5P_DEFAULT);
+                              H5T_NATIVE_UCHAR, as_id, H5P_DEFAULT);
 #endif
       if (a_id >= 0)
-	{
-	  unsigned char attr_val = 1;
+        {
+          unsigned char attr_val = 1;
 
-	  retval = H5Awrite (a_id, H5T_NATIVE_UCHAR, &attr_val);
+          retval = H5Awrite (a_id, H5T_NATIVE_UCHAR, &attr_val);
 
-	  H5Aclose (a_id);
-	}
+          H5Aclose (a_id);
+        }
       else
-	retval = a_id;
+        retval = a_id;
 
       H5Sclose (as_id);
     }
   else
     retval = as_id;
 
   return retval;
 }
@@ -621,39 +621,39 @@ save_hdf5_empty (hid_t loc_id, const cha
   OCTAVE_LOCAL_BUFFER (octave_idx_type, dims, sz);
   bool empty = false;
   hid_t space_hid = -1, data_hid = -1;
   int retval;
   for (hsize_t i = 0; i < sz; i++)
     {
       dims[i] = d(i);
       if (dims[i] < 1)
-	empty = true;
+        empty = true;
     }
 
   if (!empty)
     return 0;
 
   space_hid = H5Screate_simple (1, &sz, 0);
   if (space_hid < 0) return space_hid;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return data_hid;
     }
   
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, dims) >= 0;
+                     H5P_DEFAULT, dims) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   if (retval >= 0)
     retval = hdf5_add_attr (loc_id, "OCTAVE_EMPTY_MATRIX");
   
   return (retval == 0 ? 1 : retval);
@@ -677,22 +677,22 @@ load_hdf5_empty (hid_t loc_id, const cha
 #endif
   hid_t space_id = H5Dget_space (data_hid);
   H5Sget_simple_extent_dims (space_id, &hdims, &maxdims);
   int retval;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, dims, hdims);
 
   retval = H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-		    H5P_DEFAULT, dims);
+                    H5P_DEFAULT, dims);
   if (retval >= 0)
     {
       d.resize (hdims);
       for (hsize_t i = 0; i < hdims; i++)
-	d(i) = dims[i];
+        d(i) = dims[i];
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
   return (retval == 0 ? hdims : retval);
 }
 
@@ -738,18 +738,18 @@ save_type_to_hdf5 (save_type st)
 
 // Add the data from TC to the HDF5 location loc_id, which could
 // be either a file or a group within a file.  Return true if
 // successful.  This function calls itself recursively for lists
 // (stored as HDF5 groups).
 
 bool
 add_hdf5_data (hid_t loc_id, const octave_value& tc,
-	       const std::string& name, const std::string& doc,
-	       bool mark_as_global, bool save_as_floats)
+               const std::string& name, const std::string& doc,
+               bool mark_as_global, bool save_as_floats)
 {
   hsize_t dims[3];
   hid_t type_id = -1, space_id = -1, data_id = -1, data_type_id = -1;
   bool retval = false;
   octave_value val = tc;
   // FIXME: diagonal & permutation matrices currently don't know how to save
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
@@ -771,22 +771,22 @@ add_hdf5_data (hid_t loc_id, const octav
     goto error_cleanup;
 
   dims[0] = 0;
   space_id = H5Screate_simple (0 , dims, 0);
   if (space_id < 0)
     goto error_cleanup;
 #if HAVE_HDF5_18
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
-  			    H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                            H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id, H5P_DEFAULT);
 #endif
   if (data_type_id < 0 || H5Dwrite (data_type_id, type_id, H5S_ALL, H5S_ALL, 
-				    H5P_DEFAULT, t.c_str ()) < 0)
+                                    H5P_DEFAULT, t.c_str ()) < 0)
     goto error_cleanup;
 
   // Now call the real function to save the variable
   retval = val.save_hdf5 (data_id, "value", save_as_floats);
 
   // attach doc string as comment:
   if (retval && doc.length () > 0
       && H5Gset_comment (loc_id, name.c_str (), doc.c_str ()) < 0)
@@ -820,18 +820,18 @@ add_hdf5_data (hid_t loc_id, const octav
   return retval;
 }
 
 // Write data from TC in HDF5 (binary) format to the stream OS,
 // which must be an hdf5_ofstream, returning true on success.
 
 bool
 save_hdf5_data (std::ostream& os, const octave_value& tc,
-		const std::string& name, const std::string& doc,
-		bool mark_as_global, bool save_as_floats)
+                const std::string& name, const std::string& doc,
+                bool mark_as_global, bool save_as_floats)
 {
   hdf5_ofstream& hs = dynamic_cast<hdf5_ofstream&> (os);
 
   return add_hdf5_data (hs.file_id, tc, name, doc,
-			mark_as_global, save_as_floats);
+                        mark_as_global, save_as_floats);
 }
 
 #endif
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -73,38 +73,38 @@ get_mat_data_input_line (std::istream& i
   bool have_data = false;
 
   do
     {
       retval = "";
 
       char c;
       while (is.get (c))
-	{
-	  if (c == '\n' || c == '\r')
-	    {
-	      is.putback (c);
-	      skip_preceeding_newline (is);
-	      break;
-	    }
+        {
+          if (c == '\n' || c == '\r')
+            {
+              is.putback (c);
+              skip_preceeding_newline (is);
+              break;
+            }
 
-	  if (c == '%' || c == '#')
-	    {
-	      skip_until_newline (is, false);
-	      break;
-	    }
+          if (c == '%' || c == '#')
+            {
+              skip_until_newline (is, false);
+              break;
+            }
 
-	  if (! is.eof ())
-	    {
-	      if (! have_data && c != ' ' && c != '\t')
-		have_data = true;
+          if (! is.eof ())
+            {
+              if (! have_data && c != ' ' && c != '\t')
+                have_data = true;
 
-	      retval += c;
-	    }
-	}
+              retval += c;
+            }
+        }
     }
   while (! (have_data || is.eof ()));
 
   return retval;
 }
 
 static void
 get_lines_and_columns (std::istream& is, const std::string& filename, octave_idx_type& nr, octave_idx_type& nc)
@@ -126,60 +126,60 @@ get_lines_and_columns (std::istream& is,
 
       size_t beg = buf.find_first_not_of (", \t");
 
       // If we see a CR as the last character in the buffer, we had a
       // CRLF pair as the line separator.  Any other CR in the text
       // will not be considered as whitespace.
 
       if (beg != std::string::npos && buf[beg] == '\r' && beg == buf.length () - 1)
-	{
-	  // We had a blank line ending with a CRLF.  Handle it the
-	  // same as an empty line.
-	  beg = std::string::npos;
-	}
+        {
+          // We had a blank line ending with a CRLF.  Handle it the
+          // same as an empty line.
+          beg = std::string::npos;
+        }
 
       octave_idx_type tmp_nc = 0;
 
       while (beg != std::string::npos)
-	{
-	  tmp_nc++;
+        {
+          tmp_nc++;
 
-	  size_t end = buf.find_first_of (", \t", beg);
+          size_t end = buf.find_first_of (", \t", beg);
 
-	  if (end != std::string::npos)
-	    {
-	      beg = buf.find_first_not_of (", \t", end);
+          if (end != std::string::npos)
+            {
+              beg = buf.find_first_not_of (", \t", end);
 
-	      if (beg == std::string::npos || (buf[beg] == '\r' && 
-				  beg == buf.length () - 1))
-		{
-		  // We had a line with trailing spaces and
-		  // ending with a CRLF, so this should look like EOL,
-		  // not a new colum.
-		  break;
-		}
-	    }
-	  else
-	    break;
-	}
+              if (beg == std::string::npos || (buf[beg] == '\r' && 
+                                  beg == buf.length () - 1))
+                {
+                  // We had a line with trailing spaces and
+                  // ending with a CRLF, so this should look like EOL,
+                  // not a new colum.
+                  break;
+                }
+            }
+          else
+            break;
+        }
 
       if (tmp_nc > 0)
-	{
-	  if (nc == 0)
-	    {
-	      nc = tmp_nc;
-	      nr++;
-	    }
-	  else if (nc == tmp_nc)
-	    nr++;
-	  else
-	    error ("load: %s: inconsistent number of columns near line %d",
-		   filename.c_str (), file_line_number);
-	}
+        {
+          if (nc == 0)
+            {
+              nc = tmp_nc;
+              nr++;
+            }
+          else if (nc == tmp_nc)
+            nr++;
+          else
+            error ("load: %s: inconsistent number of columns near line %d",
+                   filename.c_str (), file_line_number);
+        }
     }
 
   if (nr == 0 || nc == 0)
     error ("load: file `%s' seems to be empty!", filename.c_str ());
 
   is.clear ();
   is.seekg (pos);
 }
@@ -192,17 +192,17 @@ get_lines_and_columns (std::istream& is,
 // and once to extract the matrix.
 //
 // FILENAME is used for error messages.
 //
 // This format provides no way to tag the data as global.
 
 std::string
 read_mat_ascii_data (std::istream& is, const std::string& filename,
-		     octave_value& tc)
+                     octave_value& tc)
 {
   std::string retval;
 
   std::string varname;
 
   size_t pos = filename.rfind ('/');
 
   if (pos != std::string::npos)
@@ -215,17 +215,17 @@ read_mat_ascii_data (std::istream& is, c
   if (pos != std::string::npos)
     varname = varname.substr (0, pos);
 
   size_t len = varname.length ();
   for (size_t i = 0; i < len; i++)
     {
       char c = varname[i];
       if (! (isalnum (c) || c == '_'))
-	varname[i] = '_';
+        varname[i] = '_';
     }
 
   if (is_keyword (varname) || ! isalpha (varname[0]))
     varname.insert (0, "X");
 
   if (valid_identifier (varname))
     {
       octave_idx_type nr = 0;
@@ -233,108 +233,108 @@ read_mat_ascii_data (std::istream& is, c
 
       int total_count = 0;
 
       get_lines_and_columns (is, filename, nr, nc);
 
       octave_quit ();
 
       if (! error_state && nr > 0 && nc > 0)
-	{
-	  Matrix tmp (nr, nc);
+        {
+          Matrix tmp (nr, nc);
 
-	  if (nr < 1 || nc < 1)
-	    is.clear (std::ios::badbit);
-	  else
-	    {
-	      double d;
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  std::string buf = get_mat_data_input_line (is);
+          if (nr < 1 || nc < 1)
+            is.clear (std::ios::badbit);
+          else
+            {
+              double d;
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  std::string buf = get_mat_data_input_line (is);
 
-		  std::istringstream tmp_stream (buf);
+                  std::istringstream tmp_stream (buf);
 
-		  for (octave_idx_type j = 0; j < nc; j++)
-		    {
-		      octave_quit ();
+                  for (octave_idx_type j = 0; j < nc; j++)
+                    {
+                      octave_quit ();
 
-		      d = octave_read_value<double> (tmp_stream);
+                      d = octave_read_value<double> (tmp_stream);
 
-		      if (tmp_stream || tmp_stream.eof ())
-			{
-			  tmp.elem (i, j) = d;
-			  total_count++;
+                      if (tmp_stream || tmp_stream.eof ())
+                        {
+                          tmp.elem (i, j) = d;
+                          total_count++;
 
-			  // Skip whitespace and commas.
-			  char c;
-			  while (1)
-			    {
-			      tmp_stream >> c;
+                          // Skip whitespace and commas.
+                          char c;
+                          while (1)
+                            {
+                              tmp_stream >> c;
 
-			      if (! tmp_stream)
-				break;
+                              if (! tmp_stream)
+                                break;
 
-			      if (! (c == ' ' || c == '\t' || c == ','))
-				{
-				  tmp_stream.putback (c);
-				  break;
-				}
-			    }
+                              if (! (c == ' ' || c == '\t' || c == ','))
+                                {
+                                  tmp_stream.putback (c);
+                                  break;
+                                }
+                            }
 
-			  if (tmp_stream.eof ())
-			    break;
-			}
-		      else
-			{
-			  error ("load: failed to read matrix from file `%s'",
-				 filename.c_str ());
+                          if (tmp_stream.eof ())
+                            break;
+                        }
+                      else
+                        {
+                          error ("load: failed to read matrix from file `%s'",
+                                 filename.c_str ());
 
-			  return retval;
-			}
+                          return retval;
+                        }
 
-		    }
-		}
-	    }
+                    }
+                }
+            }
 
-	  if (is || is.eof ())
-	    {
-	      // FIXME -- not sure this is best, but it works.
+          if (is || is.eof ())
+            {
+              // FIXME -- not sure this is best, but it works.
 
-	      if (is.eof ())
-		is.clear ();
+              if (is.eof ())
+                is.clear ();
 
-	      octave_idx_type expected = nr * nc;
+              octave_idx_type expected = nr * nc;
 
-	      if (expected == total_count)
-		{
-		  tc = tmp;
-		  retval = varname;
-		}
-	      else
-		error ("load: expected %d elements, found %d",
-		       expected, total_count);
-	    }
-	  else
-	    error ("load: failed to read matrix from file `%s'",
-		   filename.c_str ());
-	}
+              if (expected == total_count)
+                {
+                  tc = tmp;
+                  retval = varname;
+                }
+              else
+                error ("load: expected %d elements, found %d",
+                       expected, total_count);
+            }
+          else
+            error ("load: failed to read matrix from file `%s'",
+                   filename.c_str ());
+        }
       else
-	error ("load: unable to extract matrix size from file `%s'",
-	       filename.c_str ());
+        error ("load: unable to extract matrix size from file `%s'",
+               filename.c_str ());
     }
   else
     error ("load: unable to convert filename `%s' to valid identifier",
-	   filename.c_str ());
+           filename.c_str ());
 
   return retval;
 }
 
 bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val,
-		     int precision, bool tabs)
+                     int precision, bool tabs)
 {
   bool success = true;
 
   if (val.is_complex_type ())
     warning ("save: omitting imaginary part for ASCII file");
 
   Matrix m = val.matrix_value (true);
 
@@ -346,17 +346,17 @@ save_mat_ascii_data (std::ostream& os, c
     }
   else
     {
       long old_precision = os.precision ();
 
       os.precision (precision);
 
       std::ios::fmtflags oflags
-	= os.flags (static_cast<std::ios::fmtflags> (std::ios::scientific));
+        = os.flags (static_cast<std::ios::fmtflags> (std::ios::scientific));
 
       if (tabs)
         {
           for (octave_idx_type i = 0; i < m.rows (); i++)
             {
               for (octave_idx_type j = 0; j < m.cols (); j++)
                 {
                   // Omit leading tabs.
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -69,18 +69,18 @@ along with Octave; see the file COPYING.
 // Read LEN elements of data from IS in the format specified by
 // PRECISION, placing the result in DATA.  If SWAP is TRUE, swap
 // the bytes of each element before copying to DATA.  FLT_FMT
 // specifies the format of the data if we are reading floating point
 // numbers.
 
 static void
 read_mat_binary_data (std::istream& is, double *data, int precision,
-		      int len, bool swap,
-		      oct_mach_info::float_format flt_fmt)
+                      int len, bool swap,
+                      oct_mach_info::float_format flt_fmt)
 {
   switch (precision)
     {
     case 0:
       read_doubles (is, data, LS_DOUBLE, len, swap, flt_fmt);
       break;
 
     case 1:
@@ -105,19 +105,19 @@ read_mat_binary_data (std::istream& is, 
 
     default:
       break;
     }
 }
 
 int
 read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt, 
-		      int32_t& nr, int32_t& nc,
-		      int32_t& imag, int32_t& len,
-		      int quiet)
+                      int32_t& nr, int32_t& nc,
+                      int32_t& imag, int32_t& len,
+                      int quiet)
 {
   swap = false;
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another mopt value should not result in an
   // error.
 
   is.read (reinterpret_cast<char *> (&mopt), 4);
@@ -160,17 +160,17 @@ read_mat_file_header (std::istream& is, 
       swap_bytes<4> (&nc);
       swap_bytes<4> (&imag);
       swap_bytes<4> (&len);
     }
 
   if (mopt > 9999 || mopt < 0 || imag > 1 || imag < 0)
     {
       if (! quiet)
-	error ("load: can't read binary file");
+        error ("load: can't read binary file");
       return -1;
     }
 
   return 0;
 
  data_read_error:
   return -1;
 }
@@ -254,17 +254,17 @@ float_format_to_mopt_digit (oct_mach_inf
 // not all the features of that format are supported.
 //
 // FILENAME is used for error messages.
 //
 // This format provides no way to tag the data as global.
 
 std::string
 read_mat_binary_data (std::istream& is, const std::string& filename,
-		      octave_value& tc)
+                      octave_value& tc)
 {
   std::string retval;
 
   // These are initialized here instead of closer to where they are
   // first used to avoid errors from gcc about goto crossing
   // initialization of variable.
 
   Matrix re;
@@ -277,19 +277,19 @@ read_mat_binary_data (std::istream& is, 
   int dlen = 0;
 
   int32_t mopt, nr, nc, imag, len;
 
   int err = read_mat_file_header (is, swap, mopt, nr, nc, imag, len);
   if (err)
     {
       if (err < 0)
-	goto data_read_error;
+        goto data_read_error;
       else
-	return retval;
+        return retval;
     }
 
   type = mopt % 10;  // Full, sparse, etc.
   mopt /= 10;        // Eliminate first digit.
   prec = mopt % 10;  // double, float, int, etc.
   mopt /= 10;        // Eliminate second digit.
   order = mopt % 10; // Row or column major ordering.
   mopt /= 10;        // Eliminate third digit.
@@ -321,131 +321,131 @@ read_mat_binary_data (std::istream& is, 
     retval = name;
 
     dlen = nr * nc;
     if (dlen < 0)
       goto data_read_error;
 
     if (order)
       {
-	octave_idx_type tmp = nr;
-	nr = nc;
-	nc = tmp;
+        octave_idx_type tmp = nr;
+        nr = nc;
+        nc = tmp;
       }
 
     if (type == 2)
       {
-	if (nc == 4)
-	  {
-	    octave_idx_type nr_new, nc_new;
-	    Array<Complex> data (dim_vector (1, nr - 1));
-	    Array<octave_idx_type> c (dim_vector (1, nr - 1));
-	    Array<octave_idx_type> r (dim_vector (1, nr - 1));
-	    OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
-	    OCTAVE_LOCAL_BUFFER (double, ctmp, nr);
+        if (nc == 4)
+          {
+            octave_idx_type nr_new, nc_new;
+            Array<Complex> data (dim_vector (1, nr - 1));
+            Array<octave_idx_type> c (dim_vector (1, nr - 1));
+            Array<octave_idx_type> r (dim_vector (1, nr - 1));
+            OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
+            OCTAVE_LOCAL_BUFFER (double, ctmp, nr);
 
-	    read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
-	    for (octave_idx_type i = 0; i < nr - 1; i++)
-	      r.xelem(i) = dtmp[i] - 1;
-	    nr_new = dtmp[nr - 1];
-	    read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
-	    for (octave_idx_type i = 0; i < nr - 1; i++)
-	      c.xelem(i) = dtmp[i] - 1;
-	    nc_new = dtmp[nr - 1];
-	    read_mat_binary_data (is, dtmp, prec, nr - 1, swap, flt_fmt);
-	    read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
-	    read_mat_binary_data (is, ctmp, prec, nr - 1, swap, flt_fmt);
+            read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
+            for (octave_idx_type i = 0; i < nr - 1; i++)
+              r.xelem(i) = dtmp[i] - 1;
+            nr_new = dtmp[nr - 1];
+            read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
+            for (octave_idx_type i = 0; i < nr - 1; i++)
+              c.xelem(i) = dtmp[i] - 1;
+            nc_new = dtmp[nr - 1];
+            read_mat_binary_data (is, dtmp, prec, nr - 1, swap, flt_fmt);
+            read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
+            read_mat_binary_data (is, ctmp, prec, nr - 1, swap, flt_fmt);
 
-	    for (octave_idx_type i = 0; i < nr - 1; i++)
-	      data.xelem(i) = Complex (dtmp[i], ctmp[i]);
-	    read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
+            for (octave_idx_type i = 0; i < nr - 1; i++)
+              data.xelem(i) = Complex (dtmp[i], ctmp[i]);
+            read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
 
-	    SparseComplexMatrix smc = SparseComplexMatrix (data, r, c, 
-							   nr_new, nc_new);
+            SparseComplexMatrix smc = SparseComplexMatrix (data, r, c, 
+                                                           nr_new, nc_new);
 
-	    tc = order ? smc.transpose () : smc;
-	  }
-	else
-	  {
-	    octave_idx_type nr_new, nc_new;
-	    Array<double> data (dim_vector (1, nr - 1));
-	    Array<octave_idx_type> c (dim_vector (1, nr - 1));
-	    Array<octave_idx_type> r (dim_vector (1, nr - 1));
-	    OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
+            tc = order ? smc.transpose () : smc;
+          }
+        else
+          {
+            octave_idx_type nr_new, nc_new;
+            Array<double> data (dim_vector (1, nr - 1));
+            Array<octave_idx_type> c (dim_vector (1, nr - 1));
+            Array<octave_idx_type> r (dim_vector (1, nr - 1));
+            OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
 
-	    read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
-	    for (octave_idx_type i = 0; i < nr - 1; i++)
-	      r.xelem(i) = dtmp[i] - 1;
-	    nr_new = dtmp[nr - 1];
-	    read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
-	    for (octave_idx_type i = 0; i < nr - 1; i++)
-	      c.xelem(i) = dtmp[i] - 1;
-	    nc_new = dtmp[nr - 1];
-	    read_mat_binary_data (is, data.fortran_vec (), prec, nr - 1, swap, flt_fmt);
-	    read_mat_binary_data (is, dtmp, prec, 1, swap, flt_fmt);
+            read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
+            for (octave_idx_type i = 0; i < nr - 1; i++)
+              r.xelem(i) = dtmp[i] - 1;
+            nr_new = dtmp[nr - 1];
+            read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
+            for (octave_idx_type i = 0; i < nr - 1; i++)
+              c.xelem(i) = dtmp[i] - 1;
+            nc_new = dtmp[nr - 1];
+            read_mat_binary_data (is, data.fortran_vec (), prec, nr - 1, swap, flt_fmt);
+            read_mat_binary_data (is, dtmp, prec, 1, swap, flt_fmt);
 
-	    SparseMatrix sm = SparseMatrix (data, r, c, nr_new, nc_new);
+            SparseMatrix sm = SparseMatrix (data, r, c, nr_new, nc_new);
 
-	    tc = order ? sm.transpose () : sm;
-	  }
+            tc = order ? sm.transpose () : sm;
+          }
       }
     else
       {
-	re.resize (nr, nc);
+        re.resize (nr, nc);
 
-	read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
+        read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
 
-	if (! is || error_state)
-	  {
-	    error ("load: reading matrix data for `%s'", name);
-	    goto data_read_error;
-	  }
+        if (! is || error_state)
+          {
+            error ("load: reading matrix data for `%s'", name);
+            goto data_read_error;
+          }
 
-	if (imag)
-	  {
-	    Matrix im (nr, nc);
+        if (imag)
+          {
+            Matrix im (nr, nc);
 
-	    read_mat_binary_data (is, im.fortran_vec (), prec, dlen, swap,
-				  flt_fmt);
+            read_mat_binary_data (is, im.fortran_vec (), prec, dlen, swap,
+                                  flt_fmt);
 
-	    if (! is || error_state)
-	      {
-		error ("load: reading imaginary matrix data for `%s'", name);
-		goto data_read_error;
-	      }
+            if (! is || error_state)
+              {
+                error ("load: reading imaginary matrix data for `%s'", name);
+                goto data_read_error;
+              }
 
-	    ComplexMatrix ctmp (nr, nc);
+            ComplexMatrix ctmp (nr, nc);
 
-	    for (octave_idx_type j = 0; j < nc; j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
-		ctmp (i, j) = Complex (re (i, j), im (i, j));
+            for (octave_idx_type j = 0; j < nc; j++)
+              for (octave_idx_type i = 0; i < nr; i++)
+                ctmp (i, j) = Complex (re (i, j), im (i, j));
 
-	    tc = order ? ctmp.transpose () : ctmp;
-	  }
-	else
-	  tc = order ? re.transpose () : re;
+            tc = order ? ctmp.transpose () : ctmp;
+          }
+        else
+          tc = order ? re.transpose () : re;
 
-	if (type == 1)
-	  tc = tc.convert_to_str (false, true, '\'');
+        if (type == 1)
+          tc = tc.convert_to_str (false, true, '\'');
       }
 
       return retval;
     }
 
  data_read_error:
   error ("load: trouble reading binary file `%s'", filename.c_str ());
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS 
 // in the MatLab version 4 binary format.
 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
-		      const std::string& name) 
+                      const std::string& name) 
 {
   int32_t mopt = 0;
 
   mopt += tc.is_sparse_type () ? 2 : tc.is_string () ? 1 : 0;
 
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();;
 
@@ -493,101 +493,101 @@ save_mat_binary_data (std::ostream& os, 
   if (tc.is_string ())
     {
       unwind_protect frame;
 
       charMatrix chm = tc.char_matrix_value ();
 
       octave_idx_type nrow = chm.rows ();
       octave_idx_type ncol = chm.cols ();
-	
+        
       OCTAVE_LOCAL_BUFFER (double, buf, ncol*nrow);
-	
+        
       for (octave_idx_type i = 0; i < nrow; i++)
-      	{
-	  std::string tstr = chm.row_as_string (i);
-	  const char *s = tstr.data ();
-	  
-	  for (octave_idx_type j = 0; j < ncol; j++)
-	    buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
-       	}
+        {
+          std::string tstr = chm.row_as_string (i);
+          const char *s = tstr.data ();
+          
+          for (octave_idx_type j = 0; j < ncol; j++)
+            buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
+        }
       os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof(double));
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
       octave_idx_type nel = r.nelem ();
       for (octave_idx_type i = 0; i < nel; i++)
-	{
-	  double x = base + i * inc;
-	  os.write (reinterpret_cast<char *> (&x), 8);
-	}
+        {
+          double x = base + i * inc;
+          os.write (reinterpret_cast<char *> (&x), 8);
+        }
     }
   else if (tc.is_real_scalar ())
     {
       double tmp = tc.double_value ();
       os.write (reinterpret_cast<char *> (&tmp), 8);
     }
   else if (tc.is_sparse_type ())
     {
       double ds;
       OCTAVE_LOCAL_BUFFER (double, dtmp, len);
       if (tc.is_complex_matrix ())
-	{
-	  SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
+        {
+          SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
 
-	  for (octave_idx_type i = 0; i < len; i++)
-	    dtmp [i] = m.ridx(i) + 1;
-	  os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
-	  ds = nr;
-	  os.write (reinterpret_cast<const char *> (&ds), 8);
+          for (octave_idx_type i = 0; i < len; i++)
+            dtmp [i] = m.ridx(i) + 1;
+          os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
+          ds = nr;
+          os.write (reinterpret_cast<const char *> (&ds), 8);
 
-	  octave_idx_type ii = 0;
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	      dtmp[ii++] = j + 1;
-	  os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
-	  ds = nc;
-	  os.write (reinterpret_cast<const char *> (&ds), 8);
+          octave_idx_type ii = 0;
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+              dtmp[ii++] = j + 1;
+          os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
+          ds = nc;
+          os.write (reinterpret_cast<const char *> (&ds), 8);
 
-	  for (octave_idx_type i = 0; i < len; i++)
-	    dtmp [i] = std::real (m.data(i));
-	  os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
-	  ds = 0.;
-	  os.write (reinterpret_cast<const char *> (&ds), 8);
+          for (octave_idx_type i = 0; i < len; i++)
+            dtmp [i] = std::real (m.data(i));
+          os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
+          ds = 0.;
+          os.write (reinterpret_cast<const char *> (&ds), 8);
 
-	  for (octave_idx_type i = 0; i < len; i++)
-	    dtmp [i] = std::imag (m.data(i));
-	  os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
-	  os.write (reinterpret_cast<const char *> (&ds), 8);
-	}
+          for (octave_idx_type i = 0; i < len; i++)
+            dtmp [i] = std::imag (m.data(i));
+          os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
+          os.write (reinterpret_cast<const char *> (&ds), 8);
+        }
       else
-	{
-	  SparseMatrix m = tc.sparse_matrix_value ();
+        {
+          SparseMatrix m = tc.sparse_matrix_value ();
 
-	  for (octave_idx_type i = 0; i < len; i++)
-	    dtmp [i] = m.ridx(i) + 1;
-	  os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
-	  ds = nr;
-	  os.write (reinterpret_cast<const char *> (&ds), 8);
+          for (octave_idx_type i = 0; i < len; i++)
+            dtmp [i] = m.ridx(i) + 1;
+          os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
+          ds = nr;
+          os.write (reinterpret_cast<const char *> (&ds), 8);
 
-	  octave_idx_type ii = 0;
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-	      dtmp[ii++] = j + 1;
-	  os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
-	  ds = nc;
-	  os.write (reinterpret_cast<const char *> (&ds), 8);
+          octave_idx_type ii = 0;
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+              dtmp[ii++] = j + 1;
+          os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
+          ds = nc;
+          os.write (reinterpret_cast<const char *> (&ds), 8);
 
-	  os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
-	  ds = 0.;
-	  os.write (reinterpret_cast<const char *> (&ds), 8);
-	}
+          os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
+          ds = 0.;
+          os.write (reinterpret_cast<const char *> (&ds), 8);
+        }
     }
   else if (tc.is_real_matrix ())
     {
       Matrix m = tc.matrix_value ();
       os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
     }
   else if (tc.is_complex_scalar ())
     {
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -92,44 +92,44 @@ static octave_value subsys_ov;
 // mxClassID values in mexproto.h, but it seems they have also changed
 // over time.  What is the correct way to handle this and maintain
 // backward compatibility with old MAT files?  For now, use
 // "MAT_FILE_" instead of "mx" as the prefix for these names to avoid
 // conflict with the mxClassID enum in mexproto.h.
 
 enum arrayclasstype
   {
-    MAT_FILE_CELL_CLASS=1,		// cell array
-    MAT_FILE_STRUCT_CLASS,		// structure
-    MAT_FILE_OBJECT_CLASS,		// object
-    MAT_FILE_CHAR_CLASS,		// character array
-    MAT_FILE_SPARSE_CLASS,		// sparse array
-    MAT_FILE_DOUBLE_CLASS,		// double precision array
-    MAT_FILE_SINGLE_CLASS,		// single precision floating point
-    MAT_FILE_INT8_CLASS,		// 8 bit signed integer
-    MAT_FILE_UINT8_CLASS,		// 8 bit unsigned integer
-    MAT_FILE_INT16_CLASS,		// 16 bit signed integer
-    MAT_FILE_UINT16_CLASS,		// 16 bit unsigned integer
-    MAT_FILE_INT32_CLASS,		// 32 bit signed integer
-    MAT_FILE_UINT32_CLASS,		// 32 bit unsigned integer
-    MAT_FILE_INT64_CLASS,		// 64 bit signed integer
-    MAT_FILE_UINT64_CLASS,		// 64 bit unsigned integer
+    MAT_FILE_CELL_CLASS=1,              // cell array
+    MAT_FILE_STRUCT_CLASS,              // structure
+    MAT_FILE_OBJECT_CLASS,              // object
+    MAT_FILE_CHAR_CLASS,                // character array
+    MAT_FILE_SPARSE_CLASS,              // sparse array
+    MAT_FILE_DOUBLE_CLASS,              // double precision array
+    MAT_FILE_SINGLE_CLASS,              // single precision floating point
+    MAT_FILE_INT8_CLASS,                // 8 bit signed integer
+    MAT_FILE_UINT8_CLASS,               // 8 bit unsigned integer
+    MAT_FILE_INT16_CLASS,               // 16 bit signed integer
+    MAT_FILE_UINT16_CLASS,              // 16 bit unsigned integer
+    MAT_FILE_INT32_CLASS,               // 32 bit signed integer
+    MAT_FILE_UINT32_CLASS,              // 32 bit unsigned integer
+    MAT_FILE_INT64_CLASS,               // 64 bit signed integer
+    MAT_FILE_UINT64_CLASS,              // 64 bit unsigned integer
     MAT_FILE_FUNCTION_CLASS,            // Function handle
-    MAT_FILE_WORKSPACE_CLASS		// Workspace (undocumented)
+    MAT_FILE_WORKSPACE_CLASS            // Workspace (undocumented)
   };
 
 // Read COUNT elements of data from IS in the format specified by TYPE,
 // placing the result in DATA.  If SWAP is TRUE, swap the bytes of
 // each element before copying to DATA.  FLT_FMT specifies the format
 // of the data if we are reading floating point numbers.
 
 static void
 read_mat5_binary_data (std::istream& is, double *data,
-		       int count, bool swap, mat5_data_type type,
-		       oct_mach_info::float_format flt_fmt)
+                       int count, bool swap, mat5_data_type type,
+                       oct_mach_info::float_format flt_fmt)
 {
   
   switch (type)
     {
     case miINT8:
       read_doubles (is, data, LS_CHAR, count, swap, flt_fmt);
       break;
 
@@ -184,31 +184,31 @@ read_mat5_binary_data (std::istream& is,
     default:
       break;
     }
 }
 
 template <class T>
 void
 read_mat5_integer_data (std::istream& is, T *m, int count, bool swap,
-			mat5_data_type type)
+                        mat5_data_type type)
 {
 
-#define READ_INTEGER_DATA(TYPE, swap, data, size, len, stream)	\
+#define READ_INTEGER_DATA(TYPE, swap, data, size, len, stream)  \
   do \
     { \
       if (len > 0) \
-	{ \
-	  OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
-	  stream.read (reinterpret_cast<char *> (ptr), size * len); \
-	  if (swap) \
-	    swap_bytes< size > (ptr, len); \
-	  for (int i = 0; i < len; i++) \
-	    data[i] = ptr[i]; \
-	} \
+        { \
+          OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
+          stream.read (reinterpret_cast<char *> (ptr), size * len); \
+          if (swap) \
+            swap_bytes< size > (ptr, len); \
+          for (int i = 0; i < len; i++) \
+            data[i] = ptr[i]; \
+        } \
     } \
   while (0)
 
   switch (type)
     {
     case miINT8:
       READ_INTEGER_DATA (int8_t, swap, m, 1, count, is);
       break;
@@ -253,101 +253,101 @@ read_mat5_integer_data (std::istream& is
       break;
     }
 
 #undef READ_INTEGER_DATA
 
 }
 
 template void read_mat5_integer_data (std::istream& is, octave_int8 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 template void read_mat5_integer_data (std::istream& is, octave_int16 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 template void read_mat5_integer_data (std::istream& is, octave_int32 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 template void read_mat5_integer_data (std::istream& is, octave_int64 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 template void read_mat5_integer_data (std::istream& is, octave_uint8 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 template void read_mat5_integer_data (std::istream& is, octave_uint16 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 template void read_mat5_integer_data (std::istream& is, octave_uint32 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 template void read_mat5_integer_data (std::istream& is, octave_uint64 *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 
 template void read_mat5_integer_data (std::istream& is, int *m,
-				      int count, bool swap,
-				      mat5_data_type type);
+                                      int count, bool swap,
+                                      mat5_data_type type);
 
 #define OCTAVE_MAT5_INTEGER_READ(TYP) \
   { \
-	TYP re (dims); \
+        TYP re (dims); \
   \
-	std::streampos tmp_pos; \
+        std::streampos tmp_pos; \
   \
-	if (read_mat5_tag (is, swap, type, len)) \
-	  { \
-	    error ("load: reading matrix data for `%s'", retval.c_str ()); \
-	    goto data_read_error; \
-	  } \
+        if (read_mat5_tag (is, swap, type, len)) \
+          { \
+            error ("load: reading matrix data for `%s'", retval.c_str ()); \
+            goto data_read_error; \
+          } \
   \
-	int n = re.length (); \
-	tmp_pos = is.tellg (); \
-	read_mat5_integer_data (is, re.fortran_vec (), n, swap,	\
-				static_cast<enum mat5_data_type> (type)); \
+        int n = re.length (); \
+        tmp_pos = is.tellg (); \
+        read_mat5_integer_data (is, re.fortran_vec (), n, swap, \
+                                static_cast<enum mat5_data_type> (type)); \
   \
-	if (! is || error_state) \
-	  { \
-	    error ("load: reading matrix data for `%s'", retval.c_str ()); \
-	    goto data_read_error; \
-	  } \
+        if (! is || error_state) \
+          { \
+            error ("load: reading matrix data for `%s'", retval.c_str ()); \
+            goto data_read_error; \
+          } \
   \
-	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len))); \
+        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len))); \
   \
-	if (imag) \
-	  { \
-	    /* We don't handle imag integer types, convert to an array */ \
-	    NDArray im (dims); \
+        if (imag) \
+          { \
+            /* We don't handle imag integer types, convert to an array */ \
+            NDArray im (dims); \
   \
-	    if (read_mat5_tag (is, swap, type, len)) \
-	      { \
-		error ("load: reading matrix data for `%s'", \
-		       retval.c_str ()); \
-		goto data_read_error; \
-	      } \
+            if (read_mat5_tag (is, swap, type, len)) \
+              { \
+                error ("load: reading matrix data for `%s'", \
+                       retval.c_str ()); \
+                goto data_read_error; \
+              } \
   \
-	    n = im.length (); \
-	    read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
-				   static_cast<enum mat5_data_type> (type), flt_fmt); \
+            n = im.length (); \
+            read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
+                                   static_cast<enum mat5_data_type> (type), flt_fmt); \
   \
-	    if (! is || error_state) \
-	      { \
-		error ("load: reading imaginary matrix data for `%s'", \
-		       retval.c_str ()); \
-		goto data_read_error; \
-	      } \
+            if (! is || error_state) \
+              { \
+                error ("load: reading imaginary matrix data for `%s'", \
+                       retval.c_str ()); \
+                goto data_read_error; \
+              } \
   \
-	    ComplexNDArray ctmp (dims); \
+            ComplexNDArray ctmp (dims); \
   \
-	    for (int i = 0; i < n; i++) \
-	      ctmp(i) = Complex (re(i).double_value (), im(i)); \
+            for (int i = 0; i < n; i++) \
+              ctmp(i) = Complex (re(i).double_value (), im(i)); \
   \
             tc = ctmp;  \
-	  } \
-	else \
-	  tc = re; \
+          } \
+        else \
+          tc = re; \
   }
   
 // Read one element tag from stream IS, 
 // place the type code in TYPE and the byte count in BYTES
 // return nonzero on error
 static int
 read_mat5_tag (std::istream& is, bool swap, int32_t& type, int32_t& bytes)
 {
@@ -366,19 +366,19 @@ read_mat5_tag (std::istream& is, bool sw
   if (upper)
     {
       // "compressed" format
       bytes = upper;
     }
   else
     {
       if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
-	goto data_read_error;
+        goto data_read_error;
       if (swap)
-	swap_bytes<4> (&temp);
+        swap_bytes<4> (&temp);
       bytes = temp;
     }
 
   return 0;
 
  data_read_error:
   return 1;
 }
@@ -397,17 +397,17 @@ read_int (std::istream& is, bool swap, i
 //
 // The data is expected to be in Matlab's "Version 5" .mat format,
 // though not all the features of that format are supported.
 //
 // FILENAME is used for error messages.
 
 std::string
 read_mat5_binary_element (std::istream& is, const std::string& filename,
-			  bool swap, bool& global, octave_value& tc)
+                          bool swap, bool& global, octave_value& tc)
 {
   std::string retval;
 
   // These are initialized here instead of closer to where they are
   // first used to avoid errors from gcc about goto crossing
   // initialization of variable.
 
   oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
@@ -431,59 +431,59 @@ read_mat5_binary_element (std::istream& 
   // MAT files always use IEEE floating point
   if ((number == 1) ^ swap)
     flt_fmt = oct_mach_info::flt_fmt_ieee_big_endian;
   else
     flt_fmt = oct_mach_info::flt_fmt_ieee_little_endian;
 
   // element type and length
   if (read_mat5_tag (is, swap, type, element_length))
-    return retval;			// EOF
+    return retval;                      // EOF
 
 #ifdef HAVE_ZLIB
   if (type == miCOMPRESSED)
     {
       // If C++ allowed us direct access to the file descriptor of an ifstream 
       // in a uniform way, the code below could be vastly simplified, and 
       // additional copies of the data in memory wouldn't be needed!!
 
       OCTAVE_LOCAL_BUFFER (char, inbuf, element_length);
       is.read (inbuf, element_length);
 
       // We uncompress the first 8 bytes of the header to get the buffer length
       // This will fail with an error Z_MEM_ERROR
       uLongf destLen = 8;
       OCTAVE_LOCAL_BUFFER (unsigned int, tmp, 2);
       if (uncompress (reinterpret_cast<Bytef *> (tmp), &destLen, 
-		      reinterpret_cast<Bytef *> (inbuf), element_length)
-	  !=  Z_MEM_ERROR)
-	{
-	  // Why should I have to initialize outbuf as I'll just overwrite!!
-	  if (swap)
-	    swap_bytes<4> (tmp, 2);
+                      reinterpret_cast<Bytef *> (inbuf), element_length)
+          !=  Z_MEM_ERROR)
+        {
+          // Why should I have to initialize outbuf as I'll just overwrite!!
+          if (swap)
+            swap_bytes<4> (tmp, 2);
 
-	  destLen = tmp[1] + 8;
-	  std::string outbuf (destLen, ' '); 
+          destLen = tmp[1] + 8;
+          std::string outbuf (destLen, ' '); 
 
-	  // FIXME -- find a way to avoid casting away const here!
+          // FIXME -- find a way to avoid casting away const here!
 
-	  int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())), &destLen, 
-				reinterpret_cast<Bytef *> (inbuf), element_length);
+          int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())), &destLen, 
+                                reinterpret_cast<Bytef *> (inbuf), element_length);
 
-	  if (err != Z_OK)
-	    error ("load: error uncompressing data element");
-	  else
-	    {
-	      std::istringstream gz_is (outbuf);
-	      retval = read_mat5_binary_element (gz_is, filename, 
-						 swap, global, tc);
-	    }
-	}
+          if (err != Z_OK)
+            error ("load: error uncompressing data element");
+          else
+            {
+              std::istringstream gz_is (outbuf);
+              retval = read_mat5_binary_element (gz_is, filename, 
+                                                 swap, global, tc);
+            }
+        }
       else
-	error ("load: error probing size of compressed data element");
+        error ("load: error probing size of compressed data element");
 
       return retval;
     }
 #endif
 
   if (type != miMATRIX)
     {
       pos = is.tellg ();
@@ -502,41 +502,41 @@ read_mat5_binary_element (std::istream& 
   // array flags subelement
   if (read_mat5_tag (is, swap, type, len) || type != miUINT32 || len != 8)
     {
       error ("load: invalid array flags subelement");
       goto early_read_error;
     }
 
   read_int (is, swap, flags);
-  imag = (flags & 0x0800) != 0;	// has an imaginary part?
+  imag = (flags & 0x0800) != 0; // has an imaginary part?
   global = (flags & 0x0400) != 0; // global variable?
   logicalvar = (flags & 0x0200) != 0; // boolean ?
   arrayclass = static_cast<arrayclasstype> (flags & 0xff);
-  read_int (is, swap, nzmax);	// max number of non-zero in sparse
+  read_int (is, swap, nzmax);   // max number of non-zero in sparse
   
   // dimensions array subelement
   if (arrayclass != MAT_FILE_WORKSPACE_CLASS)
     {
       int32_t dim_len;
 
       if (read_mat5_tag (is, swap, type, dim_len) || type != miINT32)
-	{
-	  error ("load: invalid dimensions array subelement");
-	  goto early_read_error;
-	}
+        {
+          error ("load: invalid dimensions array subelement");
+          goto early_read_error;
+        }
 
       int ndims = dim_len / 4;
       dims.resize (ndims);
       for (int i = 0; i < ndims; i++)
-	{
-	  int32_t n;
-	  read_int (is, swap, n);
-	  dims(i) = n;
-	}
+        {
+          int32_t n;
+          read_int (is, swap, n);
+          dims(i) = n;
+        }
 
       std::streampos tmp_pos = is.tellg ();
       is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (dim_len) - dim_len));
     }
   else
     {
       // Why did mathworks decide to not have dims for a workspace!!!
       dims.resize(2);
@@ -554,609 +554,609 @@ read_mat5_binary_element (std::istream& 
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
     // Structure field subelements have zero-length array name subelements.
 
     std::streampos tmp_pos = is.tellg ();
 
     if (len)
       {
-	if (! is.read (name, len ))
-	  goto data_read_error;
-	
-	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        if (! is.read (name, len ))
+          goto data_read_error;
+        
+        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
       }
 
     name[len] = '\0';
     retval = name;
   }
 
   switch (arrayclass)
     {
     case MAT_FILE_CELL_CLASS:
       {
-	Cell cell_array (dims);
+        Cell cell_array (dims);
 
-	int n = cell_array.length ();
+        int n = cell_array.length ();
 
-	for (int i = 0; i < n; i++)
-	  {
-	    octave_value tc2;
+        for (int i = 0; i < n; i++)
+          {
+            octave_value tc2;
 
-	    std::string nm
-	      = read_mat5_binary_element (is, filename, swap, global, tc2);
+            std::string nm
+              = read_mat5_binary_element (is, filename, swap, global, tc2);
 
-	    if (! is || error_state)
-	      {
-		error ("load: reading cell data for `%s'", nm.c_str ());
-		goto data_read_error;
-	      }
+            if (! is || error_state)
+              {
+                error ("load: reading cell data for `%s'", nm.c_str ());
+                goto data_read_error;
+              }
 
-	    cell_array(i) = tc2;
-	  }
+            cell_array(i) = tc2;
+          }
 
-	tc = cell_array;
+        tc = cell_array;
       }
       break;
 
     case MAT_FILE_SPARSE_CLASS:
 #if SIZEOF_INT != SIZEOF_OCTAVE_IDX_TYPE
       warning ("load: sparse objects are not implemented");
       goto skip_ahead;
 #else
       {
-	int nr = dims(0);
-	int nc = dims(1);
-	SparseMatrix sm;
-	SparseComplexMatrix scm;
-	int *ridx;
-	int *cidx;
-	double *data;
+        int nr = dims(0);
+        int nc = dims(1);
+        SparseMatrix sm;
+        SparseComplexMatrix scm;
+        int *ridx;
+        int *cidx;
+        double *data;
 
-	// Setup return value
-	if (imag)
-	  {
-	    scm = SparseComplexMatrix (static_cast<octave_idx_type> (nr),
-				       static_cast<octave_idx_type> (nc),
-				       static_cast<octave_idx_type> (nzmax));
-	    ridx = scm.ridx ();
-	    cidx = scm.cidx ();
-	    data = 0;
-	  }
-	else
-	  {
-	    sm = SparseMatrix (static_cast<octave_idx_type> (nr),
-			       static_cast<octave_idx_type> (nc),
-			       static_cast<octave_idx_type> (nzmax));
-	    ridx = sm.ridx ();
-	    cidx = sm.cidx ();
-	    data = sm.data ();
-	  }
+        // Setup return value
+        if (imag)
+          {
+            scm = SparseComplexMatrix (static_cast<octave_idx_type> (nr),
+                                       static_cast<octave_idx_type> (nc),
+                                       static_cast<octave_idx_type> (nzmax));
+            ridx = scm.ridx ();
+            cidx = scm.cidx ();
+            data = 0;
+          }
+        else
+          {
+            sm = SparseMatrix (static_cast<octave_idx_type> (nr),
+                               static_cast<octave_idx_type> (nc),
+                               static_cast<octave_idx_type> (nzmax));
+            ridx = sm.ridx ();
+            cidx = sm.cidx ();
+            data = sm.data ();
+          }
 
-	// row indices
-	std::streampos tmp_pos;
-	  
-	if (read_mat5_tag (is, swap, type, len))
-	  {
-	    error ("load: reading sparse row data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        // row indices
+        std::streampos tmp_pos;
+          
+        if (read_mat5_tag (is, swap, type, len))
+          {
+            error ("load: reading sparse row data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	tmp_pos = is.tellg ();
+        tmp_pos = is.tellg ();
 
-	read_mat5_integer_data (is, ridx, nzmax, swap,
-				static_cast<enum mat5_data_type> (type));
+        read_mat5_integer_data (is, ridx, nzmax, swap,
+                                static_cast<enum mat5_data_type> (type));
 
-	if (! is || error_state)
-	  {
-	    error ("load: reading sparse row data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        if (! is || error_state)
+          {
+            error ("load: reading sparse row data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
-	// col indices
-	if (read_mat5_tag (is, swap, type, len))
-	  {
-	    error ("load: reading sparse column data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        // col indices
+        if (read_mat5_tag (is, swap, type, len))
+          {
+            error ("load: reading sparse column data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	tmp_pos = is.tellg ();
+        tmp_pos = is.tellg ();
 
-	read_mat5_integer_data (is, cidx, nc + 1, swap,
-				static_cast<enum mat5_data_type> (type));
+        read_mat5_integer_data (is, cidx, nc + 1, swap,
+                                static_cast<enum mat5_data_type> (type));
 
-	if (! is || error_state)
-	  {
-	    error ("load: reading sparse column data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        if (! is || error_state)
+          {
+            error ("load: reading sparse column data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
-	// real data subelement
-	if (read_mat5_tag (is, swap, type, len))
-	  {
-	    error ("load: reading sparse matrix data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        // real data subelement
+        if (read_mat5_tag (is, swap, type, len))
+          {
+            error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	int32_t nnz = cidx[nc];
-	NDArray re;
-	if (imag)
-	  {
-	    re = NDArray (dim_vector (static_cast<int> (nnz)));
-	    data = re.fortran_vec ();
-	  }
+        int32_t nnz = cidx[nc];
+        NDArray re;
+        if (imag)
+          {
+            re = NDArray (dim_vector (static_cast<int> (nnz)));
+            data = re.fortran_vec ();
+          }
 
-	tmp_pos = is.tellg ();
-	read_mat5_binary_data (is, data, nnz, swap,
-			       static_cast<enum mat5_data_type> (type), flt_fmt);
+        tmp_pos = is.tellg ();
+        read_mat5_binary_data (is, data, nnz, swap,
+                               static_cast<enum mat5_data_type> (type), flt_fmt);
 
-	if (! is || error_state)
-	  {
-	    error ("load: reading sparse matrix data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        if (! is || error_state)
+          {
+            error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
-	// imaginary data subelement
-	if (imag)
-	  {
-	    NDArray im (dim_vector (static_cast<int> (nnz)));
-	  
-	    if (read_mat5_tag (is, swap, type, len))
-	      {
-		error ("load: reading sparse matrix data for `%s'", retval.c_str ());
-		goto data_read_error;
-	      }
+        // imaginary data subelement
+        if (imag)
+          {
+            NDArray im (dim_vector (static_cast<int> (nnz)));
+          
+            if (read_mat5_tag (is, swap, type, len))
+              {
+                error ("load: reading sparse matrix data for `%s'", retval.c_str ());
+                goto data_read_error;
+              }
 
-	    read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
-				   static_cast<enum mat5_data_type> (type), flt_fmt);
+            read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
+                                   static_cast<enum mat5_data_type> (type), flt_fmt);
 
-	    if (! is || error_state)
-	      {
-		error ("load: reading imaginary sparse matrix data for `%s'",
-		       retval.c_str ());
-		goto data_read_error;
-	      }
+            if (! is || error_state)
+              {
+                error ("load: reading imaginary sparse matrix data for `%s'",
+                       retval.c_str ());
+                goto data_read_error;
+              }
 
-	    for (int i = 0; i < nnz; i++)
-	      scm.xdata (i) = Complex (re (i), im (i));
+            for (int i = 0; i < nnz; i++)
+              scm.xdata (i) = Complex (re (i), im (i));
 
-	    tc = scm;
-	  }
-	else
-	  tc = sm;
+            tc = scm;
+          }
+        else
+          tc = sm;
       }
 #endif
       break;
 
     case MAT_FILE_FUNCTION_CLASS:
       {
-	octave_value tc2;
-	std::string nm
-	  = read_mat5_binary_element (is, filename, swap, global, tc2);
+        octave_value tc2;
+        std::string nm
+          = read_mat5_binary_element (is, filename, swap, global, tc2);
 
-	if (! is || error_state)
-	  goto data_read_error;
+        if (! is || error_state)
+          goto data_read_error;
 
-	// Octave can handle both "/" and "\" as a directry seperator
-	// and so can ignore the seperator field of m0. I think the
-	// sentinel field is also save to ignore.
-	Octave_map m0 = tc2.map_value();
-	Octave_map m1 = m0.contents("function_handle")(0).map_value();
-	std::string ftype = m1.contents("type")(0).string_value();
-	std::string fname = m1.contents("function")(0).string_value();
-	std::string fpath = m1.contents("file")(0).string_value();
+        // Octave can handle both "/" and "\" as a directry seperator
+        // and so can ignore the seperator field of m0. I think the
+        // sentinel field is also save to ignore.
+        Octave_map m0 = tc2.map_value();
+        Octave_map m1 = m0.contents("function_handle")(0).map_value();
+        std::string ftype = m1.contents("type")(0).string_value();
+        std::string fname = m1.contents("function")(0).string_value();
+        std::string fpath = m1.contents("file")(0).string_value();
 
-	if (ftype == "simple" || ftype == "scopedfunction")
-	  {
-	    if (fpath.length() == 0)
-	      // We have a builtin function
-	      tc = make_fcn_handle (fname);
-	    else
-	      {
-		std::string mroot = 
-		  m0.contents("matlabroot")(0).string_value();
+        if (ftype == "simple" || ftype == "scopedfunction")
+          {
+            if (fpath.length() == 0)
+              // We have a builtin function
+              tc = make_fcn_handle (fname);
+            else
+              {
+                std::string mroot = 
+                  m0.contents("matlabroot")(0).string_value();
 
-		if ((fpath.length () >= mroot.length ()) &&
-		    fpath.substr(0, mroot.length()) == mroot &&
-		    OCTAVE_EXEC_PREFIX != mroot)
-		  {
-		    // If fpath starts with matlabroot, and matlabroot
-		    // doesn't equal octave_config_info ("exec_prefix")
-		    // then the function points to a version of Octave
-		    // or Matlab other than the running version. In that
-		    // case we replace with the same function in the
-		    // running version of Octave?
-		    
-		    // First check if just replacing matlabroot is enough
-		    std::string str = OCTAVE_EXEC_PREFIX + 
-		      fpath.substr (mroot.length ());		    
-		    file_stat fs (str);
+                if ((fpath.length () >= mroot.length ()) &&
+                    fpath.substr(0, mroot.length()) == mroot &&
+                    OCTAVE_EXEC_PREFIX != mroot)
+                  {
+                    // If fpath starts with matlabroot, and matlabroot
+                    // doesn't equal octave_config_info ("exec_prefix")
+                    // then the function points to a version of Octave
+                    // or Matlab other than the running version. In that
+                    // case we replace with the same function in the
+                    // running version of Octave?
+                    
+                    // First check if just replacing matlabroot is enough
+                    std::string str = OCTAVE_EXEC_PREFIX + 
+                      fpath.substr (mroot.length ());               
+                    file_stat fs (str);
 
-		    if (fs.exists ())
-		      {
-			size_t xpos
-			  = str.find_last_of (file_ops::dir_sep_chars ());
+                    if (fs.exists ())
+                      {
+                        size_t xpos
+                          = str.find_last_of (file_ops::dir_sep_chars ());
 
-			std::string dir_name = str.substr (0, xpos);
+                        std::string dir_name = str.substr (0, xpos);
 
-			octave_function *fcn
-			  = load_fcn_from_file (str, dir_name, "", fname);
-		    
-			if (fcn)
-			  {
-			    octave_value tmp (fcn);
+                        octave_function *fcn
+                          = load_fcn_from_file (str, dir_name, "", fname);
+                    
+                        if (fcn)
+                          {
+                            octave_value tmp (fcn);
 
-			    tc = octave_value (new octave_fcn_handle (tmp, fname));
-			  }
-		      }
-		    else
-		      {
-			// Next just search for it anywhere in the
-			// system path
-			string_vector names(3);
-			names(0) = fname + ".oct";
-			names(1) = fname + ".mex";
-			names(2) = fname + ".m";
+                            tc = octave_value (new octave_fcn_handle (tmp, fname));
+                          }
+                      }
+                    else
+                      {
+                        // Next just search for it anywhere in the
+                        // system path
+                        string_vector names(3);
+                        names(0) = fname + ".oct";
+                        names(1) = fname + ".mex";
+                        names(2) = fname + ".m";
 
-			dir_path p (load_path::system_path ());
+                        dir_path p (load_path::system_path ());
 
-			str = octave_env::make_absolute (p.find_first_of (names));
+                        str = octave_env::make_absolute (p.find_first_of (names));
 
-			size_t xpos
-			  = str.find_last_of (file_ops::dir_sep_chars ());
+                        size_t xpos
+                          = str.find_last_of (file_ops::dir_sep_chars ());
 
-			std::string dir_name = str.substr (0, xpos);
+                        std::string dir_name = str.substr (0, xpos);
 
-			octave_function *fcn
-			  = load_fcn_from_file (str, dir_name, "", fname);
+                        octave_function *fcn
+                          = load_fcn_from_file (str, dir_name, "", fname);
 
-			if (fcn)
-			  {
-			    octave_value tmp (fcn);
+                        if (fcn)
+                          {
+                            octave_value tmp (fcn);
 
-			    tc = octave_value (new octave_fcn_handle (tmp, fname));
-			  }
-			else
-			  {
-			    warning ("load: can't find the file %s", 
-				     fpath.c_str());
-			    goto skip_ahead;
-			  }
-		      }
-		  }
-		else
-		  {
-		    size_t xpos
-		      = fpath.find_last_of (file_ops::dir_sep_chars ());
+                            tc = octave_value (new octave_fcn_handle (tmp, fname));
+                          }
+                        else
+                          {
+                            warning ("load: can't find the file %s", 
+                                     fpath.c_str());
+                            goto skip_ahead;
+                          }
+                      }
+                  }
+                else
+                  {
+                    size_t xpos
+                      = fpath.find_last_of (file_ops::dir_sep_chars ());
 
-		    std::string dir_name = fpath.substr (0, xpos);
+                    std::string dir_name = fpath.substr (0, xpos);
 
-		    octave_function *fcn
-		      = load_fcn_from_file (fpath, dir_name, "", fname);
+                    octave_function *fcn
+                      = load_fcn_from_file (fpath, dir_name, "", fname);
 
-		    if (fcn)
-		      {
-			octave_value tmp (fcn);
+                    if (fcn)
+                      {
+                        octave_value tmp (fcn);
 
-			tc = octave_value (new octave_fcn_handle (tmp, fname));
-		      }
-		    else
-		      {
-			warning ("load: can't find the file %s", 
-				 fpath.c_str());
-			goto skip_ahead;
-		      }
-		  }
-	      }
-	  }
-	else if (ftype == "nested")
-	  {
-	    warning ("load: can't load nested function");
-	    goto skip_ahead;
-	  }
-	else if (ftype == "anonymous")
-	  {
-	    Octave_map m2 = m1.contents("workspace")(0).map_value();
-	    uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value();
-	    octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
-	    m2 = subsys_ov.map_value();
-	    m2 = m2.contents("MCOS")(0).map_value();
-	    tc2 = m2.contents("MCOS")(0).cell_value()(1 + off).cell_value()(1);
-	    m2 = tc2.map_value();
+                        tc = octave_value (new octave_fcn_handle (tmp, fname));
+                      }
+                    else
+                      {
+                        warning ("load: can't find the file %s", 
+                                 fpath.c_str());
+                        goto skip_ahead;
+                      }
+                  }
+              }
+          }
+        else if (ftype == "nested")
+          {
+            warning ("load: can't load nested function");
+            goto skip_ahead;
+          }
+        else if (ftype == "anonymous")
+          {
+            Octave_map m2 = m1.contents("workspace")(0).map_value();
+            uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value();
+            octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
+            m2 = subsys_ov.map_value();
+            m2 = m2.contents("MCOS")(0).map_value();
+            tc2 = m2.contents("MCOS")(0).cell_value()(1 + off).cell_value()(1);
+            m2 = tc2.map_value();
 
-	    unwind_protect_safe frame;
+            unwind_protect_safe frame;
 
-	    // Set up temporary scope to use for evaluating the text
-	    // that defines the anonymous function.
+            // Set up temporary scope to use for evaluating the text
+            // that defines the anonymous function.
 
-	    symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-	    frame.add_fcn (symbol_table::erase_scope, local_scope);
+            symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
+            frame.add_fcn (symbol_table::erase_scope, local_scope);
 
-	    symbol_table::set_scope (local_scope);
+            symbol_table::set_scope (local_scope);
 
-	    octave_call_stack::push (local_scope, 0);
-	    frame.add_fcn (octave_call_stack::pop);
+            octave_call_stack::push (local_scope, 0);
+            frame.add_fcn (octave_call_stack::pop);
 
-	    if (m2.nfields() > 0)
-	      {
-		octave_value tmp;
+            if (m2.nfields() > 0)
+              {
+                octave_value tmp;
       
-		for (Octave_map::iterator p0 = m2.begin() ; 
-		     p0 != m2.end(); p0++)
-		  {
-		    std::string key = m2.key(p0);
-		    octave_value val = m2.contents(p0)(0);
+                for (Octave_map::iterator p0 = m2.begin() ; 
+                     p0 != m2.end(); p0++)
+                  {
+                    std::string key = m2.key(p0);
+                    octave_value val = m2.contents(p0)(0);
 
-		    symbol_table::varref (key, local_scope, 0) = val;
+                    symbol_table::varref (key, local_scope, 0) = val;
                   }
-	      }
-	    
-	    int parse_status;
-	    octave_value anon_fcn_handle = 
-	      eval_string (fname.substr (4), true, parse_status);
+              }
+            
+            int parse_status;
+            octave_value anon_fcn_handle = 
+              eval_string (fname.substr (4), true, parse_status);
 
-	    if (parse_status == 0)
-	      {
-		octave_fcn_handle *fh = 
-		  anon_fcn_handle.fcn_handle_value ();
+            if (parse_status == 0)
+              {
+                octave_fcn_handle *fh = 
+                  anon_fcn_handle.fcn_handle_value ();
 
-		if (fh)
-		  tc = new octave_fcn_handle (fh->fcn_val (), "@<anonymous>");
-		else
-		  {
-		    error ("load: failed to load anonymous function handle");
-		    goto skip_ahead;
-		  }
-	      }
-	    else
-	      {
-		error ("load: failed to load anonymous function handle");
-		goto skip_ahead;
-	      }
+                if (fh)
+                  tc = new octave_fcn_handle (fh->fcn_val (), "@<anonymous>");
+                else
+                  {
+                    error ("load: failed to load anonymous function handle");
+                    goto skip_ahead;
+                  }
+              }
+            else
+              {
+                error ("load: failed to load anonymous function handle");
+                goto skip_ahead;
+              }
 
-	    frame.run ();
-	  }
-	else
-	  {
-	    error ("load: invalid function handle type");
-	    goto skip_ahead;
-	  }
+            frame.run ();
+          }
+        else
+          {
+            error ("load: invalid function handle type");
+            goto skip_ahead;
+          }
       }
       break;
 
     case MAT_FILE_WORKSPACE_CLASS:
       {
-	Octave_map m (dim_vector (1, 1));
-	int n_fields = 2;
-	string_vector field (n_fields);
+        Octave_map m (dim_vector (1, 1));
+        int n_fields = 2;
+        string_vector field (n_fields);
 
-	for (int i = 0; i < n_fields; i++)
-	  {
-	    int32_t fn_type;
-	    int32_t fn_len;
-	    if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT8)
-	      {
-		error ("load: invalid field name subelement");
-		goto data_read_error;
-	      }
+        for (int i = 0; i < n_fields; i++)
+          {
+            int32_t fn_type;
+            int32_t fn_len;
+            if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT8)
+              {
+                error ("load: invalid field name subelement");
+                goto data_read_error;
+              }
 
-	    OCTAVE_LOCAL_BUFFER (char, elname, fn_len + 1);
+            OCTAVE_LOCAL_BUFFER (char, elname, fn_len + 1);
 
-	    std::streampos tmp_pos = is.tellg ();
+            std::streampos tmp_pos = is.tellg ();
 
-	    if (fn_len)
-	      {
-		if (! is.read (elname, fn_len))
-		  goto data_read_error;
+            if (fn_len)
+              {
+                if (! is.read (elname, fn_len))
+                  goto data_read_error;
 
-		is.seekg (tmp_pos + 
-			  static_cast<std::streamoff> (PAD (fn_len)));
-	      }
+                is.seekg (tmp_pos + 
+                          static_cast<std::streamoff> (PAD (fn_len)));
+              }
 
-	    elname[fn_len] = '\0';
+            elname[fn_len] = '\0';
 
-	    field(i) = elname;
-	  }
+            field(i) = elname;
+          }
 
-	std::vector<Cell> elt (n_fields);
+        std::vector<Cell> elt (n_fields);
 
-	for (octave_idx_type i = 0; i < n_fields; i++)
-	  elt[i] = Cell (dims);
+        for (octave_idx_type i = 0; i < n_fields; i++)
+          elt[i] = Cell (dims);
 
-	octave_idx_type n = dims.numel ();
+        octave_idx_type n = dims.numel ();
 
-	// fields subelements
-	for (octave_idx_type j = 0; j < n; j++)
-	  {
-	    for (octave_idx_type i = 0; i < n_fields; i++)
-	      {
-		if (field(i) == "MCOS")
-		  {
-		    octave_value fieldtc;
-		    read_mat5_binary_element (is, filename, swap, global,
-					      fieldtc); 
-		    if (! is || error_state)
-		      goto data_read_error;
+        // fields subelements
+        for (octave_idx_type j = 0; j < n; j++)
+          {
+            for (octave_idx_type i = 0; i < n_fields; i++)
+              {
+                if (field(i) == "MCOS")
+                  {
+                    octave_value fieldtc;
+                    read_mat5_binary_element (is, filename, swap, global,
+                                              fieldtc); 
+                    if (! is || error_state)
+                      goto data_read_error;
 
-		    elt[i](j) = fieldtc;
-		  }
-		else
-		  elt[i](j) = octave_value ();
-	      }
-	  }
+                    elt[i](j) = fieldtc;
+                  }
+                else
+                  elt[i](j) = octave_value ();
+              }
+          }
 
-	for (octave_idx_type i = 0; i < n_fields; i++)
-	  m.assign (field (i), elt[i]);
-	tc = m;
+        for (octave_idx_type i = 0; i < n_fields; i++)
+          m.assign (field (i), elt[i]);
+        tc = m;
       }
       break;
 
     case MAT_FILE_OBJECT_CLASS:
       {
-	isclass = true;
+        isclass = true;
 
-	if (read_mat5_tag (is, swap, type, len) || type != miINT8)
-	  {
-	    error ("load: invalid class name");
-	    goto skip_ahead;
-	  }
+        if (read_mat5_tag (is, swap, type, len) || type != miINT8)
+          {
+            error ("load: invalid class name");
+            goto skip_ahead;
+          }
 
-	{
-	  OCTAVE_LOCAL_BUFFER (char, name, len+1);
+        {
+          OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
-	  std::streampos tmp_pos = is.tellg ();
+          std::streampos tmp_pos = is.tellg ();
 
-	  if (len)
-	    {
-	      if (! is.read (name, len ))
-		goto data_read_error;
-	
-	      is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
-	    }
+          if (len)
+            {
+              if (! is.read (name, len ))
+                goto data_read_error;
+        
+              is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+            }
 
-	  name[len] = '\0';
-	  classname = name;
-	}
+          name[len] = '\0';
+          classname = name;
+        }
       }
       // Fall-through
     case MAT_FILE_STRUCT_CLASS:
       {
-	Octave_map m (dim_vector (1, 1));
-	int32_t fn_type;
-	int32_t fn_len;
-	int32_t field_name_length;
+        Octave_map m (dim_vector (1, 1));
+        int32_t fn_type;
+        int32_t fn_len;
+        int32_t field_name_length;
 
-	// field name length subelement -- actually the maximum length
-	// of a field name.  The Matlab docs promise this will always
-	// be 32.  We read and use the actual value, on the theory
-	// that eventually someone will recognize that's a waste of
-	// space.
-	if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT32)
-	  {
-	    error ("load: invalid field name length subelement");
-	    goto data_read_error;
-	  }
+        // field name length subelement -- actually the maximum length
+        // of a field name.  The Matlab docs promise this will always
+        // be 32.  We read and use the actual value, on the theory
+        // that eventually someone will recognize that's a waste of
+        // space.
+        if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT32)
+          {
+            error ("load: invalid field name length subelement");
+            goto data_read_error;
+          }
 
-	if (! is.read (reinterpret_cast<char *> (&field_name_length), fn_len ))
-	  goto data_read_error;
+        if (! is.read (reinterpret_cast<char *> (&field_name_length), fn_len ))
+          goto data_read_error;
 
-	if (swap)
-	  swap_bytes<4> (&field_name_length);
+        if (swap)
+          swap_bytes<4> (&field_name_length);
 
-	// field name subelement.  The length of this subelement tells
-	// us how many fields there are.
-	if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT8)
-	  {
-	    error ("load: invalid field name subelement");
-	    goto data_read_error;
-	  }
+        // field name subelement.  The length of this subelement tells
+        // us how many fields there are.
+        if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT8)
+          {
+            error ("load: invalid field name subelement");
+            goto data_read_error;
+          }
 
-	octave_idx_type n_fields = fn_len/field_name_length;
+        octave_idx_type n_fields = fn_len/field_name_length;
 
-	if (n_fields > 0)
-	  {
-	    fn_len = PAD (fn_len);
+        if (n_fields > 0)
+          {
+            fn_len = PAD (fn_len);
 
-	    OCTAVE_LOCAL_BUFFER (char, elname, fn_len);
+            OCTAVE_LOCAL_BUFFER (char, elname, fn_len);
 
-	    if (! is.read (elname, fn_len))
-	      goto data_read_error;
+            if (! is.read (elname, fn_len))
+              goto data_read_error;
 
-	    std::vector<Cell> elt (n_fields);
+            std::vector<Cell> elt (n_fields);
 
-	    for (octave_idx_type i = 0; i < n_fields; i++)
-	      elt[i] = Cell (dims);
+            for (octave_idx_type i = 0; i < n_fields; i++)
+              elt[i] = Cell (dims);
 
-	    octave_idx_type n = dims.numel ();
+            octave_idx_type n = dims.numel ();
 
-	    // fields subelements
-	    for (octave_idx_type j = 0; j < n; j++)
-	      {
-		for (octave_idx_type i = 0; i < n_fields; i++)
-		  {
-		    octave_value fieldtc;
-		    read_mat5_binary_element (is, filename, swap, global,
-					      fieldtc); 
-		    elt[i](j) = fieldtc;
-		  }
-	      }
+            // fields subelements
+            for (octave_idx_type j = 0; j < n; j++)
+              {
+                for (octave_idx_type i = 0; i < n_fields; i++)
+                  {
+                    octave_value fieldtc;
+                    read_mat5_binary_element (is, filename, swap, global,
+                                              fieldtc); 
+                    elt[i](j) = fieldtc;
+                  }
+              }
 
-	    for (octave_idx_type i = 0; i < n_fields; i++)
-	      {
-		const char *key = elname + i*field_name_length;
+            for (octave_idx_type i = 0; i < n_fields; i++)
+              {
+                const char *key = elname + i*field_name_length;
 
-		m.assign (key, elt[i]);
-	      }
-	  }
+                m.assign (key, elt[i]);
+              }
+          }
 
-	if (isclass)
-	  {
-	    if (classname == "inline")
-	      {
-		// inline is not an object in Octave but rather an
-		// overload of a function handle. Special case.
-		tc =  
-		  new octave_fcn_inline (m.contents("expr")(0).string_value(),
-					 m.contents("args")(0).string_value());
-	      }
-	    else
-	      {
-		octave_class* cls = new octave_class (m, classname);
-		cls->reconstruct_exemplar ();
+        if (isclass)
+          {
+            if (classname == "inline")
+              {
+                // inline is not an object in Octave but rather an
+                // overload of a function handle. Special case.
+                tc =  
+                  new octave_fcn_inline (m.contents("expr")(0).string_value(),
+                                         m.contents("args")(0).string_value());
+              }
+            else
+              {
+                octave_class* cls = new octave_class (m, classname);
+                cls->reconstruct_exemplar ();
 
-		if (! cls->reconstruct_parents ())
-		  warning ("load: unable to reconstruct object inheritance");
+                if (! cls->reconstruct_parents ())
+                  warning ("load: unable to reconstruct object inheritance");
 
-		tc = cls; 
-		if (load_path::find_method (classname, "loadobj") != 
-		    std::string())
-		  {
-		    octave_value_list tmp = feval ("loadobj", tc, 1);
+                tc = cls; 
+                if (load_path::find_method (classname, "loadobj") != 
+                    std::string())
+                  {
+                    octave_value_list tmp = feval ("loadobj", tc, 1);
 
-		    if (! error_state)
-		      tc = tmp(0);
-		    else
-		      goto data_read_error;
-		  }
-	      }
-	  }
-	else
-	  tc = m;
+                    if (! error_state)
+                      tc = tmp(0);
+                    else
+                      goto data_read_error;
+                  }
+              }
+          }
+        else
+          tc = m;
       }
       break;
 
     case MAT_FILE_INT8_CLASS:
       OCTAVE_MAT5_INTEGER_READ (int8NDArray);
       break;
 
     case MAT_FILE_UINT8_CLASS:
       {
-	OCTAVE_MAT5_INTEGER_READ (uint8NDArray);
+        OCTAVE_MAT5_INTEGER_READ (uint8NDArray);
 
-	// Logical variables can either be MAT_FILE_UINT8_CLASS or
-	// MAT_FILE_DOUBLE_CLASS, so check if we have a logical
-	// variable and convert it.
+        // Logical variables can either be MAT_FILE_UINT8_CLASS or
+        // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
+        // variable and convert it.
 
-	if (logicalvar)
-	  {
-	    uint8NDArray in = tc.uint8_array_value ();
-	    int nel = in.nelem ();
-	    boolNDArray out (dims);
-	    
-	    for (int i = 0; i < nel; i++)
-	      out (i) = in(i).bool_value ();
+        if (logicalvar)
+          {
+            uint8NDArray in = tc.uint8_array_value ();
+            int nel = in.nelem ();
+            boolNDArray out (dims);
+            
+            for (int i = 0; i < nel; i++)
+              out (i) = in(i).bool_value ();
 
-	    tc = out;
-	  }
+            tc = out;
+          }
       }
       break;
 
     case MAT_FILE_INT16_CLASS:
       OCTAVE_MAT5_INTEGER_READ (int16NDArray);
       break;
 
     case MAT_FILE_UINT16_CLASS:
@@ -1181,136 +1181,136 @@ read_mat5_binary_element (std::istream& 
 
     case MAT_FILE_CHAR_CLASS:
       // handle as a numerical array to start with
 
     case MAT_FILE_DOUBLE_CLASS:
     case MAT_FILE_SINGLE_CLASS:
     default:
       {
-	NDArray re (dims);
+        NDArray re (dims);
       
-	// real data subelement
+        // real data subelement
 
-	std::streampos tmp_pos;
-	  
-	if (read_mat5_tag (is, swap, type, len))
-	  {
-	    error ("load: reading matrix data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        std::streampos tmp_pos;
+          
+        if (read_mat5_tag (is, swap, type, len))
+          {
+            error ("load: reading matrix data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	int n = re.length ();
-	tmp_pos = is.tellg ();
-	read_mat5_binary_data (is, re.fortran_vec (), n, swap,
-			       static_cast<enum mat5_data_type> (type), flt_fmt);
+        int n = re.length ();
+        tmp_pos = is.tellg ();
+        read_mat5_binary_data (is, re.fortran_vec (), n, swap,
+                               static_cast<enum mat5_data_type> (type), flt_fmt);
 
-	if (! is || error_state)
-	  {
-	    error ("load: reading matrix data for `%s'", retval.c_str ());
-	    goto data_read_error;
-	  }
+        if (! is || error_state)
+          {
+            error ("load: reading matrix data for `%s'", retval.c_str ());
+            goto data_read_error;
+          }
 
-	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
+        is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
-	if (logicalvar)
-	  {
-	    // Logical variables can either be MAT_FILE_UINT8_CLASS or
-	    // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
-	    // variable and convert it.
+        if (logicalvar)
+          {
+            // Logical variables can either be MAT_FILE_UINT8_CLASS or
+            // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
+            // variable and convert it.
 
-	    boolNDArray out (dims);
-	    
-	    for (int i = 0; i < n; i++)
-	      out (i) = static_cast<bool> (re (i));
+            boolNDArray out (dims);
+            
+            for (int i = 0; i < n; i++)
+              out (i) = static_cast<bool> (re (i));
 
-	    tc = out;
-	  }
-	else if (imag)
-	  {
-	    // imaginary data subelement
+            tc = out;
+          }
+        else if (imag)
+          {
+            // imaginary data subelement
 
-	    NDArray im (dims);
-	  
-	    if (read_mat5_tag (is, swap, type, len))
-	      {
-		error ("load: reading matrix data for `%s'", retval.c_str ());
-		goto data_read_error;
-	      }
+            NDArray im (dims);
+          
+            if (read_mat5_tag (is, swap, type, len))
+              {
+                error ("load: reading matrix data for `%s'", retval.c_str ());
+                goto data_read_error;
+              }
 
-	    n = im.length ();
-	    read_mat5_binary_data (is, im.fortran_vec (), n, swap,
-				   static_cast<enum mat5_data_type> (type), flt_fmt);
+            n = im.length ();
+            read_mat5_binary_data (is, im.fortran_vec (), n, swap,
+                                   static_cast<enum mat5_data_type> (type), flt_fmt);
 
-	    if (! is || error_state)
-	      {
-		error ("load: reading imaginary matrix data for `%s'",
-		       retval.c_str ());
-		goto data_read_error;
-	      }
+            if (! is || error_state)
+              {
+                error ("load: reading imaginary matrix data for `%s'",
+                       retval.c_str ());
+                goto data_read_error;
+              }
 
-	    ComplexNDArray ctmp (dims);
+            ComplexNDArray ctmp (dims);
 
-	    for (int i = 0; i < n; i++)
-	      ctmp(i) = Complex (re(i), im(i));
+            for (int i = 0; i < n; i++)
+              ctmp(i) = Complex (re(i), im(i));
 
-	    tc = ctmp;
-	  }
-	else
-	  {
-	    if (arrayclass == MAT_FILE_CHAR_CLASS)
-	      {
-		if (type == miUTF16 || type == miUTF32)
-		  {
-		    bool found_big_char = false;
-		    for (int i = 0; i < n; i++)
-		      {
-			if (re(i) > 127) {
-			  re(i) = '?';
-			  found_big_char = true;
-			}
-		      }
+            tc = ctmp;
+          }
+        else
+          {
+            if (arrayclass == MAT_FILE_CHAR_CLASS)
+              {
+                if (type == miUTF16 || type == miUTF32)
+                  {
+                    bool found_big_char = false;
+                    for (int i = 0; i < n; i++)
+                      {
+                        if (re(i) > 127) {
+                          re(i) = '?';
+                          found_big_char = true;
+                        }
+                      }
 
-		    if (found_big_char)
-		      {
-			warning ("load: can not read non-ASCII portions of UTF characters.");
-			warning ("      Replacing unreadable characters with '?'.");
-		      }
-		  }
-		else if (type == miUTF8)
-		  {
-		    // Search for multi-byte encoded UTF8 characters and
-		    // replace with 0x3F for '?'... Give the user a warning
+                    if (found_big_char)
+                      {
+                        warning ("load: can not read non-ASCII portions of UTF characters.");
+                        warning ("      Replacing unreadable characters with '?'.");
+                      }
+                  }
+                else if (type == miUTF8)
+                  {
+                    // Search for multi-byte encoded UTF8 characters and
+                    // replace with 0x3F for '?'... Give the user a warning
 
-		    bool utf8_multi_byte = false;
-		    for (int i = 0; i < n; i++)
-		      {
-			unsigned char a = static_cast<unsigned char> (re(i));
-			if (a > 0x7f)
-			  utf8_multi_byte = true;
-		      }
-		    
-		    if (utf8_multi_byte)
-		      {
-			warning ("load: can not read multi-byte encoded UTF8 characters.");
-			warning ("      Replacing unreadable characters with '?'.");
-			for (int i = 0; i < n; i++)
-			  {
-			    unsigned char a = static_cast<unsigned char> (re(i));
-			    if (a > 0x7f)
-			      re(i) = '?';
-			  }
-		      }
-		  }
-		tc = re;
-		tc = tc.convert_to_str (false, true, '\'');
-	      }
-	    else
-	      tc = re;
-	  }
+                    bool utf8_multi_byte = false;
+                    for (int i = 0; i < n; i++)
+                      {
+                        unsigned char a = static_cast<unsigned char> (re(i));
+                        if (a > 0x7f)
+                          utf8_multi_byte = true;
+                      }
+                    
+                    if (utf8_multi_byte)
+                      {
+                        warning ("load: can not read multi-byte encoded UTF8 characters.");
+                        warning ("      Replacing unreadable characters with '?'.");
+                        for (int i = 0; i < n; i++)
+                          {
+                            unsigned char a = static_cast<unsigned char> (re(i));
+                            if (a > 0x7f)
+                              re(i) = '?';
+                          }
+                      }
+                  }
+                tc = re;
+                tc = tc.convert_to_str (false, true, '\'');
+              }
+            else
+              tc = re;
+          }
       }
     }
 
   is.seekg (pos + static_cast<std::streamoff> (element_length));
 
   if (is.eof ())
     is.clear ();
 
@@ -1324,17 +1324,17 @@ read_mat5_binary_element (std::istream& 
  skip_ahead:
   warning ("skipping over `%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
 read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet, 
-			      const std::string& filename)
+                              const std::string& filename)
 {
   int16_t version=0, magic=0;
   uint64_t subsys_offset;
 
   is.seekg (116, std::ios::beg);
   is.read (reinterpret_cast<char *> (&subsys_offset), 8);
 
   is.seekg (124, std::ios::beg);
@@ -1343,64 +1343,64 @@ read_mat5_binary_file_header (std::istre
 
   if (magic == 0x4d49)
     swap = 0;
   else if (magic == 0x494d)
     swap = 1;
   else
     {
       if (! quiet)
-	error ("load: can't read binary file");
+        error ("load: can't read binary file");
       return -1;
     }
 
-  if (! swap)			// version number is inverse swapped!
+  if (! swap)                   // version number is inverse swapped!
     version = ((version >> 8) & 0xff) + ((version & 0xff) << 8);
 
   if (version != 1 && !quiet)
     warning ("load: found version %d binary MAT file, "
-	     "but only prepared for version 1", version);
+             "but only prepared for version 1", version);
 
   if (swap)
     swap_bytes<8> (&subsys_offset, 1);
 
   if (subsys_offset != 0x2020202020202020ULL && subsys_offset != 0ULL)
     {
       // Read the subsystem data block
       is.seekg (subsys_offset, std::ios::beg);
 
       octave_value tc;
       bool global;
       read_mat5_binary_element (is, filename, swap, global, tc);
 
       if (!is || error_state)
-	return -1;
+        return -1;
 
       if (tc.is_uint8_type ())
-	{
-	  const uint8NDArray itmp = tc.uint8_array_value();
-	  octave_idx_type ilen = itmp.nelem ();
+        {
+          const uint8NDArray itmp = tc.uint8_array_value();
+          octave_idx_type ilen = itmp.nelem ();
 
-	  // Why should I have to initialize outbuf as just overwrite
-	  std::string outbuf (ilen - 7, ' ');
+          // Why should I have to initialize outbuf as just overwrite
+          std::string outbuf (ilen - 7, ' ');
 
-	  // FIXME -- find a way to avoid casting away const here
-	  char *ctmp = const_cast<char *> (outbuf.c_str ());
-	  for (octave_idx_type j = 8; j < ilen; j++)
-	    ctmp[j-8] = itmp(j).char_value ();
+          // FIXME -- find a way to avoid casting away const here
+          char *ctmp = const_cast<char *> (outbuf.c_str ());
+          for (octave_idx_type j = 8; j < ilen; j++)
+            ctmp[j-8] = itmp(j).char_value ();
 
-	  std::istringstream fh_ws (outbuf);
+          std::istringstream fh_ws (outbuf);
 
-	  read_mat5_binary_element (fh_ws, filename, swap, global, subsys_ov);
+          read_mat5_binary_element (fh_ws, filename, swap, global, subsys_ov);
 
-	  if (error_state)
-	    return -1;
-	}
+          if (error_state)
+            return -1;
+        }
       else
-	return -1;
+        return -1;
 
       // Reposition to just after the header
       is.seekg (128, std::ios::beg);
     }
 
   return 0;
 }
 
@@ -1410,17 +1410,17 @@ write_mat5_tag (std::ostream& is, int ty
   int32_t temp;
 
   if (bytes > 0 && bytes <= 4)
     temp = (bytes << 16) + type;
   else
     {
       temp = type;
       if (! is.write (reinterpret_cast<char *> (&temp), 4))
-	goto data_write_error;
+        goto data_write_error;
       temp = bytes;
     }
 
   if (! is.write (reinterpret_cast<char *> (&temp), 4))
     goto data_write_error;
 
   return 0;
 
@@ -1452,22 +1452,22 @@ write_mat5_array (std::ostream& os, cons
         ptr[i] = static_cast<TYPE> (data[i]); \
       stream.write (reinterpret_cast<char *> (ptr), count * sizeof (TYPE)); \
     } \
   while (0)
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	st = LS_FLOAT;
+        st = LS_FLOAT;
     }
 
   if (m.all_integers (max_val, min_val))
     st = get_save_type (max_val, min_val);
 
   switch (st)
     {
     default:
@@ -1483,59 +1483,59 @@ write_mat5_array (std::ostream& os, cons
 
   len = nel*size;
   write_mat5_tag (os, mst, len);
 
   {
     switch (st)
       {
       case LS_U_CHAR:
-	MAT5_DO_WRITE (uint8_t, data, nel, os);
-	break;
-	
+        MAT5_DO_WRITE (uint8_t, data, nel, os);
+        break;
+        
       case LS_U_SHORT:
-	MAT5_DO_WRITE (uint16_t, data, nel, os);
-	break;
-	
+        MAT5_DO_WRITE (uint16_t, data, nel, os);
+        break;
+        
       case LS_U_INT:
-	MAT5_DO_WRITE (uint32_t, data, nel, os);
-	break;
-	
+        MAT5_DO_WRITE (uint32_t, data, nel, os);
+        break;
+        
       case LS_U_LONG:
-	MAT5_DO_WRITE (uint64_t, data, nel, os);
-	break;
+        MAT5_DO_WRITE (uint64_t, data, nel, os);
+        break;
 
       case LS_CHAR:
-	MAT5_DO_WRITE (int8_t, data, nel, os);
-	break;
-	
+        MAT5_DO_WRITE (int8_t, data, nel, os);
+        break;
+        
       case LS_SHORT:
-	MAT5_DO_WRITE (int16_t, data, nel, os);
-	break;
+        MAT5_DO_WRITE (int16_t, data, nel, os);
+        break;
 
       case LS_INT:
-	MAT5_DO_WRITE (int32_t, data, nel, os);
-	break;
+        MAT5_DO_WRITE (int32_t, data, nel, os);
+        break;
 
       case LS_LONG:
-	MAT5_DO_WRITE (int64_t, data, nel, os);
-	break;
+        MAT5_DO_WRITE (int64_t, data, nel, os);
+        break;
 
       case LS_FLOAT:
-	MAT5_DO_WRITE (float, data, nel, os);
-	break;
+        MAT5_DO_WRITE (float, data, nel, os);
+        break;
 
       case LS_DOUBLE: // No conversion necessary.
-	os.write (reinterpret_cast<const char *> (data), len);
-	break;
+        os.write (reinterpret_cast<const char *> (data), len);
+        break;
 
       default:
-	(*current_liboctave_error_handler)
-	  ("unrecognized data format requested");
-	break;
+        (*current_liboctave_error_handler)
+          ("unrecognized data format requested");
+        break;
       }
   }
   if (PAD (len) > len)
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
@@ -1588,80 +1588,80 @@ write_mat5_integer_data (std::ostream& o
   if (PAD (len) > len)
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
 
 template void write_mat5_integer_data (std::ostream& os, const octave_int8 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const octave_int16 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const octave_int32 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const octave_int64 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const octave_uint8 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const octave_uint16 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const octave_uint32 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const octave_uint64 *m,
-				       int size, int nel);
+                                       int size, int nel);
 template void write_mat5_integer_data (std::ostream& os, const int *m, 
-				       int size, int nel);
+                                       int size, int nel);
 
 // Write out cell element values in the cell array to OS, preceded by
 // the appropriate tag.
 
 static bool 
 write_mat5_cell_array (std::ostream& os, const Cell& cell,
-		       bool mark_as_global, bool save_as_floats)
+                       bool mark_as_global, bool save_as_floats)
 {
   int nel = cell.nelem ();
 
   for (int i = 0; i < nel; i++)
     {
       octave_value ov = cell(i);
 
       if (! save_mat5_binary_element (os, ov, "", mark_as_global,
-				      false, save_as_floats))
-	return false;
+                                      false, save_as_floats))
+        return false;
     }
 
   return true;
 }
 
 int
 save_mat5_array_length (const double* val, int nel, bool save_as_floats)
 {
   if (nel > 0)
     {
       int size = 8;
 
       if (save_as_floats)
-	{
-	  bool too_large_for_float = false;
-	  for (int i = 0; i < nel; i++)
-	    {
-	      double tmp = val [i];
+        {
+          bool too_large_for_float = false;
+          for (int i = 0; i < nel; i++)
+            {
+              double tmp = val [i];
 
-	      if (! (xisnan (tmp) || xisinf (tmp))
-		  && fabs (tmp) > FLT_MAX)
-		{
-		  too_large_for_float = true;
-		  break;
-		}
-	    }
+              if (! (xisnan (tmp) || xisinf (tmp))
+                  && fabs (tmp) > FLT_MAX)
+                {
+                  too_large_for_float = true;
+                  break;
+                }
+            }
 
-	  if (!too_large_for_float)
-	    size = 4;
-	}
+          if (!too_large_for_float)
+            size = 4;
+        }
 
       // The code below is disabled since get_save_type currently doesn't
       // deal with integer types. This will need to be activated if get_save_type
       // is changed.
 
       // double max_val = val[0];
       // double min_val = val[0];
       // bool all_integers =  true;
@@ -1722,63 +1722,63 @@ save_mat5_array_length (const Complex* v
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
 save_mat5_element_length (const octave_value& tc, const std::string& name, 
-			  bool save_as_floats, bool mat7_format)
+                          bool save_as_floats, bool mat7_format)
 {
   int max_namelen = (mat7_format ? 63 : 31);
   int len = name.length ();
   std::string cname = tc.class_name ();
   int ret = 32;
 
   if (len > 4)
     ret += PAD (len > max_namelen ? max_namelen : len);
 
   ret += PAD (4 * tc.ndims ());
   
   if (tc.is_string ())
     {
       charNDArray chm = tc.char_array_value ();
       ret += 8;
       if (chm.nelem () > 2)
-	ret += PAD (2 * chm.nelem ());
+        ret += PAD (2 * chm.nelem ());
     }
   else if (tc.is_sparse_type ())
     {
       if (tc.is_complex_type ())
-	{
-	  SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
-	  int nc = m.cols ();
-	  int nnz = m.nzmax ();
+        {
+          SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
+          int nc = m.cols ();
+          int nnz = m.nzmax ();
 
-	  ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
-	    save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
-	}
+          ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
+            save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
+        }
       else
-	{
-	  SparseMatrix m = tc.sparse_matrix_value ();
-	  int nc = m.cols ();
-	  int nnz = m.nzmax ();
+        {
+          SparseMatrix m = tc.sparse_matrix_value ();
+          int nc = m.cols ();
+          int nnz = m.nzmax ();
 
-	  ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
-	    save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
-	}
+          ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
+            save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
+        }
     }
 
 #define INT_LEN(nel, size) \
   { \
     ret += 8; \
     int sz = nel * size; \
     if (sz > 4) \
-      ret += PAD (sz);	\
+      ret += PAD (sz);  \
   }
 
   else if (cname == "int8")
     INT_LEN (tc.int8_array_value ().nelem (), 1)
   else if (cname == "int16")
     INT_LEN (tc.int16_array_value ().nelem (), 2)
   else if (cname == "int32")
     INT_LEN (tc.int32_array_value ().nelem (), 4)
@@ -1793,81 +1793,81 @@ save_mat5_element_length (const octave_v
   else if (cname == "uint64")
     INT_LEN (tc.uint64_array_value ().nelem (), 8)
   else if (tc.is_bool_type ())
     INT_LEN (tc.bool_array_value ().nelem (), 1)
   else if (tc.is_real_scalar () || tc.is_real_matrix () || tc.is_range ())
     {
       NDArray m = tc.array_value ();
       ret += save_mat5_array_length (m.fortran_vec (), m.nelem (),
-				     save_as_floats);
+                                     save_as_floats);
     }
   else if (tc.is_cell ())
     {
       Cell cell = tc.cell_value ();
       int nel = cell.nelem ();
 
       for (int i = 0; i < nel; i++)
-	ret += 8 + 
-	  save_mat5_element_length (cell (i), "", save_as_floats, mat7_format);
+        ret += 8 + 
+          save_mat5_element_length (cell (i), "", save_as_floats, mat7_format);
     }
   else if (tc.is_complex_scalar () || tc.is_complex_matrix ()) 
     {
       ComplexNDArray m = tc.complex_array_value ();
       ret += save_mat5_array_length (m.fortran_vec (), m.nelem (),
-				     save_as_floats);
+                                     save_as_floats);
     }
   else if (tc.is_map () || tc.is_inline_function () || tc.is_object ()) 
     {
       int fieldcnt = 0;
       const Octave_map m = tc.map_value ();
       int nel = m.numel ();
 
       if (tc.is_inline_function ())
-	// length of "inline" is 6
-	ret += 8 + PAD (6 > max_namelen ? max_namelen : 6);
+        // length of "inline" is 6
+        ret += 8 + PAD (6 > max_namelen ? max_namelen : 6);
       else if (tc.is_object ())
-	{
-	  int classlen = tc.class_name (). length ();
+        {
+          int classlen = tc.class_name (). length ();
 
-	  ret += 8 + PAD (classlen > max_namelen ? max_namelen : classlen);
-	}
+          ret += 8 + PAD (classlen > max_namelen ? max_namelen : classlen);
+        }
 
       for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
-	fieldcnt++;
+        fieldcnt++;
 
       ret += 16 + fieldcnt * (max_namelen + 1);
 
 
       for (int j = 0; j < nel; j++)
-	{
+        {
 
-	  for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
-	    {
-	      const Cell elts = m.contents (i);
+          for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
+            {
+              const Cell elts = m.contents (i);
 
-	      ret += 8 + save_mat5_element_length (elts(j), "", 
-					       save_as_floats, mat7_format);
-	    }
-	}
+              ret += 8 + save_mat5_element_length (elts(j), "", 
+                                               save_as_floats, mat7_format);
+            }
+        }
     }
   else
     ret = -1;
 
   return ret;
 }
 
 // save the data from TC along with the corresponding NAME on stream
 // OS in the MatLab version 5 binary format.  Return true on success.
 
 bool
 save_mat5_binary_element (std::ostream& os,
-			  const octave_value& tc, const std::string& name,
-			  bool mark_as_global, bool mat7_format,
-			  bool save_as_floats, bool compressing) 
+                          const octave_value& tc, const std::string& name,
+                          bool mark_as_global, bool mat7_format,
+                          bool save_as_floats, bool compressing) 
 {
   int32_t flags=0;
   int32_t nnz=0;
   std::streampos fixup, contin;
   std::string cname = tc.class_name ();
   int max_namelen = (mat7_format ? 63 : 31);
 
 #ifdef HAVE_ZLIB
@@ -1875,48 +1875,48 @@ save_mat5_binary_element (std::ostream& 
     {
       bool ret = false;
 
       std::ostringstream buf;
 
       // The code seeks backwards in the stream to fix the header. Can't
       // do this with zlib, so use a stringstream.
       ret = save_mat5_binary_element (buf, tc, name, mark_as_global, true,
-				      save_as_floats, true);
+                                      save_as_floats, true);
 
       if (ret)
-	{
-	  // destLen must be at least 0.1% larger than source buffer 
-	  // + 12 bytes. Reality is it must be larger again than that.
-	  std::string buf_str = buf.str ();
-	  uLongf srcLen = buf_str.length ();
-	  uLongf destLen = srcLen * 101 / 100 + 12; 
-	  OCTAVE_LOCAL_BUFFER (char, out_buf, destLen);
+        {
+          // destLen must be at least 0.1% larger than source buffer 
+          // + 12 bytes. Reality is it must be larger again than that.
+          std::string buf_str = buf.str ();
+          uLongf srcLen = buf_str.length ();
+          uLongf destLen = srcLen * 101 / 100 + 12; 
+          OCTAVE_LOCAL_BUFFER (char, out_buf, destLen);
 
-	  if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen, 
-			reinterpret_cast<const Bytef *> (buf_str.c_str ()), srcLen) == Z_OK)
-	    {
-	      write_mat5_tag (os, miCOMPRESSED, static_cast<int> (destLen)); 
-	      os.write (out_buf, destLen);
-	    }
-	  else
-	    {
-	      error ("save: error compressing data element");
-	      ret = false;
-	    }
-	}
+          if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen, 
+                        reinterpret_cast<const Bytef *> (buf_str.c_str ()), srcLen) == Z_OK)
+            {
+              write_mat5_tag (os, miCOMPRESSED, static_cast<int> (destLen)); 
+              os.write (out_buf, destLen);
+            }
+          else
+            {
+              error ("save: error compressing data element");
+              ret = false;
+            }
+        }
 
       return ret;
     }
 #endif
 
   // element type and length
   fixup = os.tellp ();
   write_mat5_tag (os, miMATRIX, save_mat5_element_length 
-		  (tc, name, save_as_floats, mat7_format));
+                  (tc, name, save_as_floats, mat7_format));
   
   // array flags subelement
   write_mat5_tag (os, miUINT32, 8);
 
   if (tc.is_bool_type ())
     flags |= 0x0200;
 
   if (mark_as_global)
@@ -1942,25 +1942,25 @@ save_mat5_binary_element (std::ostream& 
   else if (cname == "uint32")
     flags |= MAT_FILE_UINT32_CLASS;
   else if (cname == "uint64")
     flags |= MAT_FILE_UINT64_CLASS;
   else if (tc.is_sparse_type ())
     {
       flags |= MAT_FILE_SPARSE_CLASS;
       if (tc.is_complex_type ())
-	{
-	  SparseComplexMatrix scm = tc.sparse_complex_matrix_value ();
-	  nnz = scm.nzmax ();
-	}
+        {
+          SparseComplexMatrix scm = tc.sparse_complex_matrix_value ();
+          nnz = scm.nzmax ();
+        }
       else
-	{
-	  SparseMatrix sm = tc.sparse_matrix_value ();
-	  nnz = sm.nzmax ();
-	}
+        {
+          SparseMatrix sm = tc.sparse_matrix_value ();
+          nnz = sm.nzmax ();
+        }
     }
   else if (tc.is_real_scalar ())
     flags |= MAT_FILE_DOUBLE_CLASS;
   else if (tc.is_real_matrix () || tc.is_range ())
     flags |= MAT_FILE_DOUBLE_CLASS;
   else if (tc.is_complex_scalar ())
     flags |= MAT_FILE_DOUBLE_CLASS;
   else if (tc.is_complex_matrix ())
@@ -1984,24 +1984,24 @@ save_mat5_binary_element (std::ostream& 
     dim_vector dv = tc.dims ();
     int nd = tc.ndims ();
     int dim_len = 4*nd;
 
     write_mat5_tag (os, miINT32, dim_len);
 
     for (int i = 0; i < nd; i++)
       {
-	int32_t n = dv(i);
-	os.write (reinterpret_cast<char *> (&n), 4);
+        int32_t n = dv(i);
+        os.write (reinterpret_cast<char *> (&n), 4);
       }
 
     if (PAD (dim_len) > dim_len)
       {
-	static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
-	os.write (buf, PAD (dim_len) - dim_len);
+        static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
+        os.write (buf, PAD (dim_len) - dim_len);
       }
   }
 
   // array name subelement
   {
     int namelen = name.length ();
 
     if (namelen > max_namelen)
@@ -2025,69 +2025,69 @@ save_mat5_binary_element (std::ostream& 
       int paddedlength = PAD (len);
 
       OCTAVE_LOCAL_BUFFER (int16_t, buf, nel+3);
       write_mat5_tag (os, miUINT16, len);
 
       const char *s = chm.data ();
 
       for (int i = 0; i < nel; i++)
-	buf[i] = *s++ & 0x00FF;
+        buf[i] = *s++ & 0x00FF;
 
       os.write (reinterpret_cast<char *> (buf), len);
       
       if (paddedlength > len)
-	{
-	  static char padbuf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
-	  os.write (padbuf, paddedlength - len);
-	}
+        {
+          static char padbuf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
+          os.write (padbuf, paddedlength - len);
+        }
     }
   else if (tc.is_sparse_type ())
     {
       if (tc.is_complex_type ())
-	{
-	  SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
-	  int nc = m.cols ();
+        {
+          SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
+          int nc = m.cols ();
 
-	  int tmp = sizeof (int);
+          int tmp = sizeof (int);
 
-	  write_mat5_integer_data (os, m.ridx (), -tmp, nnz);
-	  write_mat5_integer_data (os, m.cidx (), -tmp, nc + 1);
+          write_mat5_integer_data (os, m.ridx (), -tmp, nnz);
+          write_mat5_integer_data (os, m.cidx (), -tmp, nc + 1);
 
-	  NDArray buf (dim_vector (nnz, 1));
+          NDArray buf (dim_vector (nnz, 1));
 
-	  for (int i = 0; i < nnz; i++)
-	    buf (i) = std::real (m.data (i));
+          for (int i = 0; i < nnz; i++)
+            buf (i) = std::real (m.data (i));
 
-	  write_mat5_array (os, buf, save_as_floats);
+          write_mat5_array (os, buf, save_as_floats);
 
-	  for (int i = 0; i < nnz; i++)
-	    buf (i) = std::imag (m.data (i));
+          for (int i = 0; i < nnz; i++)
+            buf (i) = std::imag (m.data (i));
 
-	  write_mat5_array (os, buf, save_as_floats);
-	}
+          write_mat5_array (os, buf, save_as_floats);
+        }
       else
-	{
-	  SparseMatrix m = tc.sparse_matrix_value ();
-	  int nc = m.cols ();
+        {
+          SparseMatrix m = tc.sparse_matrix_value ();
+          int nc = m.cols ();
 
-	  int tmp = sizeof (int);
+          int tmp = sizeof (int);
 
-	  write_mat5_integer_data (os, m.ridx (), -tmp, nnz);
-	  write_mat5_integer_data (os, m.cidx (), -tmp, nc + 1);
+          write_mat5_integer_data (os, m.ridx (), -tmp, nnz);
+          write_mat5_integer_data (os, m.cidx (), -tmp, nc + 1);
 
-	  // FIXME
-	  // Is there a way to easily do without this buffer
-	  NDArray buf (dim_vector (nnz, 1));
+          // FIXME
+          // Is there a way to easily do without this buffer
+          NDArray buf (dim_vector (nnz, 1));
 
-	  for (int i = 0; i < nnz; i++)
-	    buf (i) = m.data (i);
+          for (int i = 0; i < nnz; i++)
+            buf (i) = m.data (i);
 
-	  write_mat5_array (os, buf, save_as_floats);
-	}
+          write_mat5_array (os, buf, save_as_floats);
+        }
     }
   else if (cname == "int8")
     {
       int8NDArray m = tc.int8_array_value ();
 
       write_mat5_integer_data (os, m.fortran_vec (), -1, m.nelem ());
     }
   else if (cname == "int16")
@@ -2144,111 +2144,111 @@ save_mat5_binary_element (std::ostream& 
 
       write_mat5_array (os, m, save_as_floats);
     }
   else if (tc.is_cell ())
     {
       Cell cell = tc.cell_value ();
 
       if (! write_mat5_cell_array (os, cell, mark_as_global, save_as_floats))
-	goto error_cleanup;
+        goto error_cleanup;
     }
   else if (tc.is_complex_scalar () || tc.is_complex_matrix ()) 
     {
       ComplexNDArray m_cmplx = tc.complex_array_value ();
 
       write_mat5_array (os, ::real (m_cmplx), save_as_floats);
       write_mat5_array (os, ::imag (m_cmplx), save_as_floats);
     }
   else if (tc.is_map () || tc.is_inline_function() || tc.is_object ()) 
     {
       if (tc.is_inline_function () || tc.is_object ())
-	{
-	  std::string classname = tc.is_object() ? tc.class_name () : "inline";
-	  int namelen = classname.length ();
+        {
+          std::string classname = tc.is_object() ? tc.class_name () : "inline";
+          int namelen = classname.length ();
 
-	  if (namelen > max_namelen)
-	    namelen = max_namelen; // only 31 or 63 char names permitted
+          if (namelen > max_namelen)
+            namelen = max_namelen; // only 31 or 63 char names permitted
 
-	  int paddedlength = PAD (namelen);
+          int paddedlength = PAD (namelen);
 
-	  write_mat5_tag (os, miINT8, namelen);
-	  OCTAVE_LOCAL_BUFFER (char, paddedname, paddedlength);
-	  memset (paddedname, 0, paddedlength);
-	  strncpy (paddedname, classname.c_str (), namelen);
-	  os.write (paddedname, paddedlength);
-	}
+          write_mat5_tag (os, miINT8, namelen);
+          OCTAVE_LOCAL_BUFFER (char, paddedname, paddedlength);
+          memset (paddedname, 0, paddedlength);
+          strncpy (paddedname, classname.c_str (), namelen);
+          os.write (paddedname, paddedlength);
+        }
 
       Octave_map m;
 
       if (tc.is_object () &&
-	  load_path::find_method (tc.class_name (), "saveobj") != std::string())
-	{
-	  octave_value_list tmp = feval ("saveobj", tc, 1);
-	  if (! error_state)
-	    m = tmp(0).map_value ();
-	  else
-	    goto error_cleanup;
-	}
+          load_path::find_method (tc.class_name (), "saveobj") != std::string())
+        {
+          octave_value_list tmp = feval ("saveobj", tc, 1);
+          if (! error_state)
+            m = tmp(0).map_value ();
+          else
+            goto error_cleanup;
+        }
       else
-	m = tc.map_value ();
+        m = tc.map_value ();
 
       // an Octave structure */
       // recursively write each element of the structure
       {
-	char buf[64];
-	int32_t maxfieldnamelength = max_namelen + 1;
+        char buf[64];
+        int32_t maxfieldnamelength = max_namelen + 1;
 
-	octave_idx_type nf = m.nfields ();
+        octave_idx_type nf = m.nfields ();
 
-	int fieldcnt = nf;
+        int fieldcnt = nf;
 
-	write_mat5_tag (os, miINT32, 4);
-	os.write (reinterpret_cast<char *> (&maxfieldnamelength), 4);
-	write_mat5_tag (os, miINT8, fieldcnt*maxfieldnamelength);
+        write_mat5_tag (os, miINT32, 4);
+        os.write (reinterpret_cast<char *> (&maxfieldnamelength), 4);
+        write_mat5_tag (os, miINT8, fieldcnt*maxfieldnamelength);
 
-	// Iterating over the list of keys will preserve the order of
-	// the fields.
-	string_vector keys = m.keys ();
+        // Iterating over the list of keys will preserve the order of
+        // the fields.
+        string_vector keys = m.keys ();
 
-	for (octave_idx_type i = 0; i < nf; i++)
-	  {
-	    std::string key = keys(i);
+        for (octave_idx_type i = 0; i < nf; i++)
+          {
+            std::string key = keys(i);
 
-	    // write the name of each element
-	    memset (buf, 0, max_namelen + 1);
-	    // only 31 or 63 char names permitted
-	    strncpy (buf, key.c_str (), max_namelen);
-	    os.write (buf, max_namelen + 1);
-	  }
+            // write the name of each element
+            memset (buf, 0, max_namelen + 1);
+            // only 31 or 63 char names permitted
+            strncpy (buf, key.c_str (), max_namelen);
+            os.write (buf, max_namelen + 1);
+          }
 
-	int len = m.numel ();
+        int len = m.numel ();
 
-	// Create temporary copy of structure contents to avoid
-	// multiple calls of the contents method.
-	std::vector<const octave_value *> elts (nf);
-	for (octave_idx_type i = 0; i < nf; i++)
-	  elts[i] = m.contents (keys(i)).data ();
+        // Create temporary copy of structure contents to avoid
+        // multiple calls of the contents method.
+        std::vector<const octave_value *> elts (nf);
+        for (octave_idx_type i = 0; i < nf; i++)
+          elts[i] = m.contents (keys(i)).data ();
 
-	for (int j = 0; j < len; j++)
-	  {
-	    // write the data of each element
+        for (int j = 0; j < len; j++)
+          {
+            // write the data of each element
 
-	    // Iterating over the list of keys will preserve the order
-	    // of the fields.
-	    for (octave_idx_type i = 0; i < nf; i++)
-	      {
-		bool retval2 = save_mat5_binary_element (os, elts[i][j], "",
-							 mark_as_global,
-							 false, 
-							 save_as_floats);
-		if (! retval2)
-		  goto error_cleanup;
-	      }
-	  }
+            // Iterating over the list of keys will preserve the order
+            // of the fields.
+            for (octave_idx_type i = 0; i < nf; i++)
+              {
+                bool retval2 = save_mat5_binary_element (os, elts[i][j], "",
+                                                         mark_as_global,
+                                                         false, 
+                                                         save_as_floats);
+                if (! retval2)
+                  goto error_cleanup;
+              }
+          }
       }
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
   contin = os.tellp ();
 
   return true;
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -84,64 +84,64 @@ extract_keyword (std::istream& is, const
   int ch = is.peek ();
   if (next_only && ch != '%' && ch != '#')
     return retval;
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
-	{
-	  std::ostringstream buf;
-	
-	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
-	    ; // Skip whitespace and comment characters.
+        {
+          std::ostringstream buf;
+        
+          while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
+            ; // Skip whitespace and comment characters.
 
-	  if (isalpha (c))
-	    buf << c;
+          if (isalpha (c))
+            buf << c;
 
-	  while (is.get (c) && isalpha (c))
-	    buf << c;
+          while (is.get (c) && isalpha (c))
+            buf << c;
 
-	  std::string tmp = buf.str ();
-	  bool match = (tmp.compare (0, strlen (keyword), keyword) == 0);
+          std::string tmp = buf.str ();
+          bool match = (tmp.compare (0, strlen (keyword), keyword) == 0);
 
-	  if (match)
-	    {
-	      std::ostringstream value;
-	      while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
-		; // Skip whitespace and the colon.
+          if (match)
+            {
+              std::ostringstream value;
+              while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
+                ; // Skip whitespace and the colon.
 
-	      is.putback(c);
-	      retval = read_until_newline (is, false);
-	      break;
-	    }
-	  else if (next_only)
-	    break;
-	  else
-	    skip_until_newline (is, false);
-	}
+              is.putback(c);
+              retval = read_until_newline (is, false);
+              break;
+            }
+          else if (next_only)
+            break;
+          else
+            skip_until_newline (is, false);
+        }
     }
 
   int len = retval.length ();
 
   if (len > 0)
     {
       while (len)
-	{
-	  c = retval[len-1];
+        {
+          c = retval[len-1];
 
-	  if (c == ' ' || c == '\t')
-	    len--;
-	  else
-	    {
-	      retval.resize (len);
-	      break;
-	    }
-	}
+          if (c == ' ' || c == '\t')
+            len--;
+          else
+            {
+              retval.resize (len);
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 // Extract one value (scalar, matrix, string, etc.) from stream IS and
 // place it in TC, returning the name of the variable.  If the value
 // is tagged as global in the file, return TRUE in GLOBAL.
@@ -230,65 +230,65 @@ extract_keyword (std::istream& is, const
 
 // Ugh.  The signature of the compare method is not standard in older
 // versions of the GNU libstdc++.  Do this instead:
 
 #define SUBSTRING_COMPARE_EQ(s, pos, n, t) (s.substr (pos, n) == t)
 
 std::string
 read_ascii_data (std::istream& is, const std::string& filename, bool& global,
-		 octave_value& tc, octave_idx_type count)
+                 octave_value& tc, octave_idx_type count)
 {
   // Read name for this entry or break on EOF.
 
   std::string name = extract_keyword (is, "name");
 
   if (name.empty ())
     {
       if (count == 0)
-	error ("load: empty name keyword or no data found in file `%s'",
-	       filename.c_str ());
+        error ("load: empty name keyword or no data found in file `%s'",
+               filename.c_str ());
 
       return std::string ();
     }
 
   if (! (name == ".nargin." || name == ".nargout."
-	 || name == CELL_ELT_TAG || valid_identifier (name)))
+         || name == CELL_ELT_TAG || valid_identifier (name)))
     {
       error ("load: bogus identifier `%s' found in file `%s'",
-	     name.c_str (), filename.c_str ());
+             name.c_str (), filename.c_str ());
       return std::string ();
     }
 
   // Look for type keyword.
 
   std::string tag = extract_keyword (is, "type");
 
   if (! tag.empty ())
     {
       std::string typ;
       size_t pos = tag.rfind (' ');
 
       if (pos != std::string::npos)
-	{
-	  global = SUBSTRING_COMPARE_EQ (tag, 0, 6, "global");
+        {
+          global = SUBSTRING_COMPARE_EQ (tag, 0, 6, "global");
 
-	  typ = global ? tag.substr (7) : tag;
-	}
+          typ = global ? tag.substr (7) : tag;
+        }
       else
-	typ = tag;
+        typ = tag;
 
       // Special case for backward compatiablity. A small bit of cruft
       if (SUBSTRING_COMPARE_EQ (typ, 0, 12, "string array"))
-	tc = charMatrix ();
+        tc = charMatrix ();
       else
-	tc = octave_value_typeinfo::lookup_type (typ);
+        tc = octave_value_typeinfo::lookup_type (typ);
 
       if (! tc.load_ascii (is))
-	error ("load: trouble reading ascii file `%s'", filename.c_str ());
+        error ("load: trouble reading ascii file `%s'", filename.c_str ());
     }
   else
     error ("load: failed to extract keyword specifying value type");
 
   if (error_state)
     {
       error ("load: reading file %s", filename.c_str ());
       return std::string ();
@@ -305,18 +305,18 @@ read_ascii_data (std::istream& is, const
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
 // FIXME -- should probably write the help string here too.
 
 bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
-		 const std::string& name, bool mark_as_global,
-		 int precision)
+                 const std::string& name, bool mark_as_global,
+                 int precision)
 {
   bool success = true;
 
   if (! name.empty ())
     os << "# name: " << name << "\n";
 
   octave_value val = val_arg;
 
@@ -335,17 +335,17 @@ save_ascii_data (std::ostream& os, const
 
   os.precision (old_precision);
 
   return (os && success);
 }
 
 bool
 save_ascii_data_for_plotting (std::ostream& os, const octave_value& t,
-			      const std::string& name)
+                              const std::string& name)
 {
   return save_ascii_data (os, t, name, false, 6);
 }
 
 // Maybe this should be a static function in tree-plot.cc?
 
 // If TC is matrix, save it on stream OS in a format useful for
 // making a 3-dimensional plot with gnuplot.  If PARAMETRIC is
@@ -357,51 +357,51 @@ save_three_d (std::ostream& os, const oc
   bool fail = false;
 
   octave_idx_type nr = tc.rows ();
   octave_idx_type nc = tc.columns ();
 
   if (tc.is_real_matrix ())
     {
       os << "# 3D data...\n"
-	 << "# type: matrix\n"
-	 << "# total rows: " << nr << "\n"
-	 << "# total columns: " << nc << "\n";
+         << "# type: matrix\n"
+         << "# total rows: " << nr << "\n"
+         << "# total columns: " << nc << "\n";
 
       long old_precision = os.precision ();
       os.precision (6);
 
       if (parametric)
-	{
-	  octave_idx_type extras = nc % 3;
-	  if (extras)
-	    warning ("ignoring last %d columns", extras);
+        {
+          octave_idx_type extras = nc % 3;
+          if (extras)
+            warning ("ignoring last %d columns", extras);
 
-	  Matrix tmp = tc.matrix_value ();
-	  nr = tmp.rows ();
+          Matrix tmp = tc.matrix_value ();
+          nr = tmp.rows ();
 
-	  for (octave_idx_type i = 0; i < nc-extras; i += 3)
-	    {
-	      os << tmp.extract (0, i, nr-1, i+2);
-	      if (i+3 < nc-extras)
-		os << "\n";
-	    }
-	}
+          for (octave_idx_type i = 0; i < nc-extras; i += 3)
+            {
+              os << tmp.extract (0, i, nr-1, i+2);
+              if (i+3 < nc-extras)
+                os << "\n";
+            }
+        }
       else
-	{
-	  Matrix tmp = tc.matrix_value ();
-	  nr = tmp.rows ();
+        {
+          Matrix tmp = tc.matrix_value ();
+          nr = tmp.rows ();
 
-	  for (octave_idx_type i = 0; i < nc; i++)
-	    {
-	      os << tmp.extract (0, i, nr-1, i);
-	      if (i+1 < nc)
-		os << "\n";
-	    }
-	}
+          for (octave_idx_type i = 0; i < nc; i++)
+            {
+              os << tmp.extract (0, i, nr-1, i);
+              if (i+1 < nc)
+                os << "\n";
+            }
+        }
 
       os.precision (old_precision);
     }
   else
     {
       ::error ("for now, I can only save real matrices in 3D format");
       fail = true;
     }
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -127,19 +127,19 @@ along with Octave; see the file COPYING.
 //   7                          string
 //
 // Except for "data type" equal 5 that requires special treatment, these
 // old style "data type" value also cause the specific load/save functions
 // to be called. FILENAME is used for error messages.
 
 std::string
 read_binary_data (std::istream& is, bool swap,
-		  oct_mach_info::float_format fmt,
-		  const std::string& filename, bool& global,
-		  octave_value& tc, std::string& doc)
+                  oct_mach_info::float_format fmt,
+                  const std::string& filename, bool& global,
+                  octave_value& tc, std::string& doc)
 {
   std::string retval;
 
   unsigned char tmp = 0;
 
   int32_t name_len = 0;
   int32_t doc_len = 0;
 
@@ -200,57 +200,57 @@ read_binary_data (std::istream& is, bool
       break;
 
     case 4:
       tc = octave_value_typeinfo::lookup_type ("complex matrix");
       break;
 
     case 5:
       {
-	// FIXMEX
-	// This is cruft, since its for a save type that is old. Maybe
-	// this is taking backward compatability too far!!
-	int32_t len;
-	if (! is.read (reinterpret_cast<char *> (&len), 4))
-	  goto data_read_error;
-	if (swap)
-	  swap_bytes<4> (&len);
-	OCTAVE_LOCAL_BUFFER (char, s, len+1);
-	if (! is.read (reinterpret_cast<char *> (s), len))
-	  goto data_read_error;
-	s[len] = '\0';
-	tc = s;
+        // FIXMEX
+        // This is cruft, since its for a save type that is old. Maybe
+        // this is taking backward compatability too far!!
+        int32_t len;
+        if (! is.read (reinterpret_cast<char *> (&len), 4))
+          goto data_read_error;
+        if (swap)
+          swap_bytes<4> (&len);
+        OCTAVE_LOCAL_BUFFER (char, s, len+1);
+        if (! is.read (reinterpret_cast<char *> (s), len))
+          goto data_read_error;
+        s[len] = '\0';
+        tc = s;
 
-	// Early return, since don't want rest of this function
-	return retval;
+        // Early return, since don't want rest of this function
+        return retval;
       }
       break;
 
     case 6:
       tc = octave_value_typeinfo::lookup_type ("range");
       break;
 
     case 7:
       tc = octave_value_typeinfo::lookup_type ("string");
       break;
 
     case 255:
       {
-	// Read the saved variable type
-	int32_t len;
-	if (! is.read (reinterpret_cast<char *> (&len), 4))
-	  goto data_read_error;
-	if (swap)
-	  swap_bytes<4> (&len);
-	OCTAVE_LOCAL_BUFFER (char, s, len+1);
-	if (! is.read (s, len))
-	  goto data_read_error;
-	s[len] = '\0';
-	std::string typ = s;
-	tc = octave_value_typeinfo::lookup_type (typ);
+        // Read the saved variable type
+        int32_t len;
+        if (! is.read (reinterpret_cast<char *> (&len), 4))
+          goto data_read_error;
+        if (swap)
+          swap_bytes<4> (&len);
+        OCTAVE_LOCAL_BUFFER (char, s, len+1);
+        if (! is.read (s, len))
+          goto data_read_error;
+        s[len] = '\0';
+        std::string typ = s;
+        tc = octave_value_typeinfo::lookup_type (typ);
       }
       break;
     default:
       goto data_read_error;
       break;
     }
   
   if (!tc.load_binary (is, swap, fmt))
@@ -263,18 +263,18 @@ read_binary_data (std::istream& is, bool
 }
 
 // Save the data from TC along with the corresponding NAME, help
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
 
 bool
 save_binary_data (std::ostream& os, const octave_value& tc,
-		  const std::string& name, const std::string& doc,
-		  bool mark_as_global, bool save_as_floats) 
+                  const std::string& name, const std::string& doc,
+                  bool mark_as_global, bool save_as_floats) 
 {
   int32_t name_len = name.length ();
 
   os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name;
 
   int32_t doc_len = doc.length ();
 
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -65,41 +65,41 @@ max_str_len (mwSize m, const char **str)
 {
   int max_len = 0;
 
   for (mwSize i = 0; i < m; i++)
     {
       mwSize tmp = strlen (str[i]);
 
       if (tmp > max_len)
-	max_len = tmp;
+        max_len = tmp;
     }
 
   return max_len;
 }
 
 static int
 valid_key (const char *key)
 {
   int retval = 0;
 
   int nel = strlen (key);
 
   if (nel > 0)
     {
       if (isalpha (key[0]))
-	{
-	  for (int i = 1; i < nel; i++)
-	    {
-	      if (! (isalnum (key[i]) || key[i] == '_'))
-		goto done;
-	    }
-
-	  retval = 1;
-	}
+        {
+          for (int i = 1; i < nel; i++)
+            {
+              if (! (isalnum (key[i]) || key[i] == '_'))
+                goto done;
+            }
+
+          retval = 1;
+        }
     }
 
  done:
 
   return retval;
 }
 
 // ------------------------------------------------------------------
@@ -269,39 +269,39 @@ protected:
   {
     // FIXME
     ::error ("%s", msg);
   }
 };
 
 static mwIndex
 calc_single_subscript_internal (mwSize ndims, const mwSize *dims,
-				mwSize nsubs, const mwIndex *subs)
+                                mwSize nsubs, const mwIndex *subs)
 {
   mwIndex retval = 0;
 
   switch (nsubs)
     {
     case 0:
       break;
 
     case 1:
       retval = subs[0];
       break;
 
     default:
       {
-	// Both nsubs and ndims should be at least 2 here.
-
-	mwSize n = nsubs <= ndims ? nsubs : ndims;
-
-	retval = subs[--n];
-
-	while (--n >= 0)
-	  retval = dims[n] * retval + subs[n];
+        // Both nsubs and ndims should be at least 2 here.
+
+        mwSize n = nsubs <= ndims ? nsubs : ndims;
+
+        retval = subs[--n];
+
+        while (--n >= 0)
+          retval = dims[n] * retval + subs[n];
       }
       break;
     }
 
   return retval;
 }
 
 // The object that handles values pass to MEX files from Octave.  Some
@@ -392,24 +392,24 @@ public:
 
     return n;
   }
 
   mwSize *get_dimensions (void) const
   {
     if (! dims)
       {
-	ndims = val.ndims ();
-
-	dims = static_cast<mwSize *> (malloc (ndims * sizeof (mwSize)));
-
-	dim_vector dv = val.dims ();
-
-	for (mwIndex i = 0; i < ndims; i++)
-	  dims[i] = dv(i);
+        ndims = val.ndims ();
+
+        dims = static_cast<mwSize *> (malloc (ndims * sizeof (mwSize)));
+
+        dim_vector dv = val.dims ();
+
+        for (mwIndex i = 0; i < ndims; i++)
+          dims[i] = dv(i);
       }
 
     return dims;
   }
 
   mwSize get_number_of_dimensions (void) const
   {
     // Force dims and ndims to be cached.
@@ -470,18 +470,18 @@ public:
 
     return id;
   }
 
   const char *get_class_name (void) const
   {
     if (! class_name)
       {
-	std::string s = val.class_name ();
-	class_name = strsave (s.c_str ());
+        std::string s = val.class_name ();
+        class_name = strsave (s.c_str ());
       }
 
     return class_name;
   }
 
   // Not allowed.
   void set_class_name (const char */*name_arg*/) { request_mutation (); }
 
@@ -586,55 +586,55 @@ public:
   int get_string (char *buf, mwSize buflen) const
   {
     int retval = 1;
 
     mwSize nel = get_number_of_elements ();
 
     if (val.is_string () && nel < buflen)
       {
-	charNDArray tmp = val.char_array_value ();
-
-	const char *p = tmp.data ();
-
-	for (mwIndex i = 0; i < nel; i++)
-	  buf[i] = p[i];
-
-	buf[nel] = 0;
-
-	retval = 0;
+        charNDArray tmp = val.char_array_value ();
+
+        const char *p = tmp.data ();
+
+        for (mwIndex i = 0; i < nel; i++)
+          buf[i] = p[i];
+
+        buf[nel] = 0;
+
+        retval = 0;
       }
 
     return retval;
   }
 
   char *array_to_string (void) const
   {
     // FIXME -- this is suposed to handle multi-byte character
     // strings.
 
     char *buf = 0;
 
     if (val.is_string ())
       {
-	mwSize nel = get_number_of_elements ();
-
-	buf = static_cast<char *> (malloc (nel + 1));
-
-	if (buf)
-	  {
-	    charNDArray tmp = val.char_array_value ();
-
-	    const char *p = tmp.data ();
-
-	    for (mwIndex i = 0; i < nel; i++)
-	      buf[i] = p[i];
-
-	    buf[nel] = '\0';
-	  }
+        mwSize nel = get_number_of_elements ();
+
+        buf = static_cast<char *> (malloc (nel + 1));
+
+        if (buf)
+          {
+            charNDArray tmp = val.char_array_value ();
+
+            const char *p = tmp.data ();
+
+            for (mwIndex i = 0; i < nel; i++)
+              buf[i] = p[i];
+
+            buf[nel] = '\0';
+          }
       }
 
     return buf;
   }
 
   mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const
   {
     // Force ndims, dims to be cached.
@@ -687,18 +687,18 @@ protected:
 
   mxArray_octave_value (const mxArray_octave_value& arg)
     : mxArray_base (arg), val (arg.val), mutate_flag (arg.mutate_flag),
       id (arg.id), class_name (strsave (arg.class_name)), ndims (arg.ndims),
       dims (ndims > 0 ? static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))) : 0)
   {
     if (dims)
       {
-	for (mwIndex i = 0; i < ndims; i++)
-	  dims[i] = arg.dims[i];
+        for (mwIndex i = 0; i < ndims; i++)
+          dims[i] = arg.dims[i];
       }
   }
 
 private:
 
   octave_value val;
 
   mutable bool mutate_flag;
@@ -725,46 +725,46 @@ protected:
 
   mxArray_matlab (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg)
     : mxArray_base (), class_name (0), id (id_arg),
       ndims (ndims_arg < 2 ? 2 : ndims_arg),
       dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
   {
     if (ndims_arg < 2)
       {
-	dims[0] = 1;
-	dims[1] = 1;
+        dims[0] = 1;
+        dims[1] = 1;
       }
 
     for (mwIndex i = 0; i < ndims_arg; i++)
       dims[i] = dims_arg[i];
 
     for (mwIndex i = ndims - 1; i > 1; i--)
       {
-	if (dims[i] == 1)
-	  ndims--;
-	else
-	  break;
+        if (dims[i] == 1)
+          ndims--;
+        else
+          break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, const dim_vector& dv)
     : mxArray_base (), class_name (0), id (id_arg),
       ndims (dv.length ()),
       dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
   {
     for (mwIndex i = 0; i < ndims; i++)
       dims[i] = dv(i);
 
     for (mwIndex i = ndims - 1; i > 1; i--)
       {
-	if (dims[i] == 1)
-	  ndims--;
-	else
-	  break;
+        if (dims[i] == 1)
+          ndims--;
+        else
+          break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, mwSize m, mwSize n)
     : mxArray_base (), class_name (0), id (id_arg), ndims (2),
       dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
   {
     dims[0] = m;
@@ -795,20 +795,20 @@ public:
 
   int is_int8 (void) const { return id == mxINT8_CLASS; }
 
   int is_logical (void) const { return id == mxLOGICAL_CLASS; }
 
   int is_numeric (void) const
   {
     return (id == mxDOUBLE_CLASS || id == mxSINGLE_CLASS
-	    || id == mxINT8_CLASS || id == mxUINT8_CLASS
-	    || id == mxINT16_CLASS || id == mxUINT16_CLASS
-	    || id == mxINT32_CLASS || id == mxUINT32_CLASS
-	    || id == mxINT64_CLASS || id == mxUINT64_CLASS);
+            || id == mxINT8_CLASS || id == mxUINT8_CLASS
+            || id == mxINT16_CLASS || id == mxUINT16_CLASS
+            || id == mxINT32_CLASS || id == mxUINT32_CLASS
+            || id == mxINT64_CLASS || id == mxUINT64_CLASS);
   }
 
   int is_single (void) const { return id == mxSINGLE_CLASS; }
 
   int is_sparse (void) const { return 0; }
 
   int is_struct (void) const { return id == mxSTRUCT_CLASS; }
 
@@ -818,17 +818,17 @@ public:
 
   int is_uint64 (void) const { return id == mxUINT64_CLASS; }
 
   int is_uint8 (void) const { return id == mxUINT8_CLASS; }
 
   int is_logical_scalar_true (void) const
   {
     return (is_logical_scalar ()
-	    && static_cast<mxLogical *> (get_data ())[0] != 0);
+            && static_cast<mxLogical *> (get_data ())[0] != 0);
   }
 
   mwSize get_m (void) const { return dims[0]; }
 
   mwSize get_n (void) const
   {
     mwSize n = 1;
 
@@ -1091,23 +1091,23 @@ private:
 
 // Matlab-style numeric, character, and logical data.
 
 class mxArray_number : public mxArray_matlab
 {
 public:
 
   mxArray_number (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg,
-		  mxComplexity flag = mxREAL)
+                  mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, ndims_arg, dims_arg),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
   mxArray_number (mxClassID id_arg, const dim_vector& dv,
-		  mxComplexity flag = mxREAL)
+                  mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, dv),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
   mxArray_number (mxClassID id_arg, mwSize m, mwSize n, mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
@@ -1150,26 +1150,26 @@ public:
     mxChar *cpr = static_cast<mxChar *> (pr);
     
     mwSize *dv = get_dimensions ();
 
     mwSize nc = dv[1];
 
     for (mwIndex j = 0; j < m; j++)
       {
-	const char *ptr = str[j];
-
-	size_t tmp_len = strlen (ptr);
-
-	for (size_t i = 0; i < tmp_len; i++)
-	  cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
-
-	for (size_t i = tmp_len; i < nc; i++)
-	  cpr[m*i+j] = static_cast<mxChar> (' ');
-      }	
+        const char *ptr = str[j];
+
+        size_t tmp_len = strlen (ptr);
+
+        for (size_t i = 0; i < tmp_len; i++)
+          cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
+
+        for (size_t i = tmp_len; i < nc; i++)
+          cpr[m*i+j] = static_cast<mxChar> (' ');
+      } 
   }
 
   mxArray_number *clone (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
     mxFree (pr);
     mxFree (pi);
@@ -1179,65 +1179,65 @@ public:
 
   double get_scalar (void) const
   {
     double retval = 0;
 
     switch (get_class_id ())
       {
       case mxLOGICAL_CLASS:
-	retval = *(static_cast<bool *> (pr));
-	break;
+        retval = *(static_cast<bool *> (pr));
+        break;
 
       case mxCHAR_CLASS:
-	retval = *(static_cast<mxChar *> (pr));
-	break;
+        retval = *(static_cast<mxChar *> (pr));
+        break;
 
       case mxSINGLE_CLASS:
-	retval = *(static_cast<float *> (pr));
-	break;
+        retval = *(static_cast<float *> (pr));
+        break;
 
       case mxDOUBLE_CLASS:
-	retval = *(static_cast<double *> (pr));
-	break;
+        retval = *(static_cast<double *> (pr));
+        break;
 
       case mxINT8_CLASS:
-	retval = *(static_cast<int8_t *> (pr));
-	break;
+        retval = *(static_cast<int8_t *> (pr));
+        break;
 
       case mxUINT8_CLASS:
-	retval = *(static_cast<uint8_t *> (pr));
-	break;
+        retval = *(static_cast<uint8_t *> (pr));
+        break;
 
       case mxINT16_CLASS:
-	retval = *(static_cast<int16_t *> (pr));
-	break;
+        retval = *(static_cast<int16_t *> (pr));
+        break;
 
       case mxUINT16_CLASS:
-	retval = *(static_cast<uint16_t *> (pr));
-	break;
+        retval = *(static_cast<uint16_t *> (pr));
+        break;
 
       case mxINT32_CLASS:
-	retval = *(static_cast<int32_t *> (pr));
-	break;
+        retval = *(static_cast<int32_t *> (pr));
+        break;
 
       case mxUINT32_CLASS:
-	retval = *(static_cast<uint32_t *> (pr));
-	break;
+        retval = *(static_cast<uint32_t *> (pr));
+        break;
 
       case mxINT64_CLASS:
-	retval = *(static_cast<int64_t *> (pr));
-	break;
+        retval = *(static_cast<int64_t *> (pr));
+        break;
 
       case mxUINT64_CLASS:
-	retval = *(static_cast<uint64_t *> (pr));
-	break;
+        retval = *(static_cast<uint64_t *> (pr));
+        break;
 
       default:
-	panic_impossible ();
+        panic_impossible ();
       }
 
     return retval;
   }
 
   void *get_data (void) const { return pr; }
 
   void *get_imag_data (void) const { return pi; }
@@ -1249,44 +1249,44 @@ public:
   int get_string (char *buf, mwSize buflen) const
   {
     int retval = 1;
 
     mwSize nel = get_number_of_elements ();
 
     if (nel < buflen)
       {
-	mxChar *ptr = static_cast<mxChar *> (pr);
-
-	for (mwIndex i = 0; i < nel; i++)
-	  buf[i] = static_cast<char> (ptr[i]);
-
-	buf[nel] = 0;
+        mxChar *ptr = static_cast<mxChar *> (pr);
+
+        for (mwIndex i = 0; i < nel; i++)
+          buf[i] = static_cast<char> (ptr[i]);
+
+        buf[nel] = 0;
       }
 
     return retval;
   }
 
   char *array_to_string (void) const
   {
     // FIXME -- this is suposed to handle multi-byte character
     // strings.
 
     mwSize nel = get_number_of_elements ();
 
     char *buf = static_cast<char *> (malloc (nel + 1));
 
     if (buf)
       {
-	mxChar *ptr = static_cast<mxChar *> (pr);
-
-	for (mwIndex i = 0; i < nel; i++)
-	  buf[i] = static_cast<char> (ptr[i]);
-
-	buf[nel] = '\0';
+        mxChar *ptr = static_cast<mxChar *> (pr);
+
+        for (mwIndex i = 0; i < nel; i++)
+          buf[i] = static_cast<char> (ptr[i]);
+
+        buf[nel] = '\0';
       }
 
     return buf;
   }
 
 protected:
 
   template <typename ELT_T, typename ARRAY_T, typename ARRAY_ELT_T>
@@ -1298,158 +1298,158 @@ protected:
     mwSize nel = get_number_of_elements ();
 
     ELT_T *ppr = static_cast<ELT_T *> (pr);
 
     if (pi)
       error ("complex integer types are not supported");
     else
       {
-	ARRAY_T val (dv);
-
-	ARRAY_ELT_T *ptr = val.fortran_vec ();
-
-	for (mwIndex i = 0; i < nel; i++)
-	  ptr[i] = ppr[i];
-
-	retval = val;
+        ARRAY_T val (dv);
+
+        ARRAY_ELT_T *ptr = val.fortran_vec ();
+
+        for (mwIndex i = 0; i < nel; i++)
+          ptr[i] = ppr[i];
+
+        retval = val;
       }
 
     return retval;
   }
 
   octave_value as_octave_value (void) const
   {
     octave_value retval;
 
     dim_vector dv = dims_to_dim_vector ();
 
     switch (get_class_id ())
       {
       case mxLOGICAL_CLASS:
-	retval = int_to_ov<bool, boolNDArray, bool> (dv);
-	break;
+        retval = int_to_ov<bool, boolNDArray, bool> (dv);
+        break;
 
       case mxCHAR_CLASS:
-	{
-	  mwSize nel = get_number_of_elements ();
-
-	  mxChar *ppr = static_cast<mxChar *> (pr);
-
-	  charNDArray val (dv);
-
-	  char *ptr = val.fortran_vec ();
-
-	  for (mwIndex i = 0; i < nel; i++)
-	    ptr[i] = static_cast<char> (ppr[i]);
-
-	  retval = val;
-	}
-	break;
+        {
+          mwSize nel = get_number_of_elements ();
+
+          mxChar *ppr = static_cast<mxChar *> (pr);
+
+          charNDArray val (dv);
+
+          char *ptr = val.fortran_vec ();
+
+          for (mwIndex i = 0; i < nel; i++)
+            ptr[i] = static_cast<char> (ppr[i]);
+
+          retval = val;
+        }
+        break;
 
       case mxSINGLE_CLASS:
-	{
-	  mwSize nel = get_number_of_elements ();
-
-	  float *ppr = static_cast<float *> (pr);
-
-	  if (pi)
-	    {
-	      ComplexNDArray val (dv);
-
-	      Complex *ptr = val.fortran_vec ();
-
-	      float *ppi = static_cast<float *> (pi);
-
-	      for (mwIndex i = 0; i < nel; i++)
-		ptr[i] = Complex (ppr[i], ppi[i]);
-
-	      retval = val;
-	    }
-	  else
-	    {
-	      NDArray val (dv);
-
-	      double *ptr = val.fortran_vec ();
-
-	      for (mwIndex i = 0; i < nel; i++)
-		ptr[i] = ppr[i];
-
-	      retval = val;
-	    }
-	}
-	break;
+        {
+          mwSize nel = get_number_of_elements ();
+
+          float *ppr = static_cast<float *> (pr);
+
+          if (pi)
+            {
+              ComplexNDArray val (dv);
+
+              Complex *ptr = val.fortran_vec ();
+
+              float *ppi = static_cast<float *> (pi);
+
+              for (mwIndex i = 0; i < nel; i++)
+                ptr[i] = Complex (ppr[i], ppi[i]);
+
+              retval = val;
+            }
+          else
+            {
+              NDArray val (dv);
+
+              double *ptr = val.fortran_vec ();
+
+              for (mwIndex i = 0; i < nel; i++)
+                ptr[i] = ppr[i];
+
+              retval = val;
+            }
+        }
+        break;
 
       case mxDOUBLE_CLASS:
-	{
-	  mwSize nel = get_number_of_elements ();
-
-	  double *ppr = static_cast<double *> (pr);
-
-	  if (pi)
-	    {
-	      ComplexNDArray val (dv);
-
-	      Complex *ptr = val.fortran_vec ();
-
-	      double *ppi = static_cast<double *> (pi);
-
-	      for (mwIndex i = 0; i < nel; i++)
-		ptr[i] = Complex (ppr[i], ppi[i]);
-
-	      retval = val;
-	    }
-	  else
-	    {
-	      NDArray val (dv);
-
-	      double *ptr = val.fortran_vec ();
-
-	      for (mwIndex i = 0; i < nel; i++)
-		ptr[i] = ppr[i];
-
-	      retval = val;
-	    }
-	}
-	break;
+        {
+          mwSize nel = get_number_of_elements ();
+
+          double *ppr = static_cast<double *> (pr);
+
+          if (pi)
+            {
+              ComplexNDArray val (dv);
+
+              Complex *ptr = val.fortran_vec ();
+
+              double *ppi = static_cast<double *> (pi);
+
+              for (mwIndex i = 0; i < nel; i++)
+                ptr[i] = Complex (ppr[i], ppi[i]);
+
+              retval = val;
+            }
+          else
+            {
+              NDArray val (dv);
+
+              double *ptr = val.fortran_vec ();
+
+              for (mwIndex i = 0; i < nel; i++)
+                ptr[i] = ppr[i];
+
+              retval = val;
+            }
+        }
+        break;
 
       case mxINT8_CLASS:
-	retval = int_to_ov<int8_t, int8NDArray, octave_int8> (dv);
-	break;
+        retval = int_to_ov<int8_t, int8NDArray, octave_int8> (dv);
+        break;
 
       case mxUINT8_CLASS:
-	retval = int_to_ov<uint8_t, uint8NDArray, octave_uint8> (dv);
-	break;
+        retval = int_to_ov<uint8_t, uint8NDArray, octave_uint8> (dv);
+        break;
 
       case mxINT16_CLASS:
-	retval = int_to_ov<int16_t, int16NDArray, octave_int16> (dv);
-	break;
+        retval = int_to_ov<int16_t, int16NDArray, octave_int16> (dv);
+        break;
 
       case mxUINT16_CLASS:
-	retval = int_to_ov<uint16_t, uint16NDArray, octave_uint16> (dv);
-	break;
+        retval = int_to_ov<uint16_t, uint16NDArray, octave_uint16> (dv);
+        break;
 
       case mxINT32_CLASS:
-	retval = int_to_ov<int32_t, int32NDArray, octave_int32> (dv);
-	break;
+        retval = int_to_ov<int32_t, int32NDArray, octave_int32> (dv);
+        break;
 
       case mxUINT32_CLASS:
-	retval = int_to_ov<uint32_t, uint32NDArray, octave_uint32> (dv);
-	break;
+        retval = int_to_ov<uint32_t, uint32NDArray, octave_uint32> (dv);
+        break;
 
       case mxINT64_CLASS:
-	retval = int_to_ov<int64_t, int64NDArray, octave_int64> (dv);
-	break;
+        retval = int_to_ov<int64_t, int64NDArray, octave_int64> (dv);
+        break;
 
       case mxUINT64_CLASS:
-	retval = int_to_ov<uint64_t, uint64NDArray, octave_uint64> (dv);
-	break;
+        retval = int_to_ov<uint64_t, uint64NDArray, octave_uint64> (dv);
+        break;
 
       default:
-	panic_impossible ();
+        panic_impossible ();
       }    
 
     return retval;
   }
 
   mxArray_number (const mxArray_number& val)
     : mxArray_matlab (val),
       pr (malloc (get_number_of_elements () * get_element_size ())),
@@ -1472,17 +1472,17 @@ private:
 
 // Matlab-style sparse arrays.
 
 class mxArray_sparse : public mxArray_matlab
 {
 public:
 
   mxArray_sparse (mxClassID id_arg, int m, int n, int nzmax_arg,
-		  mxComplexity flag = mxREAL)
+                  mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n), nzmax (nzmax_arg)
   {
     pr = (calloc (nzmax, get_element_size ()));
     pi = (flag == mxCOMPLEX ? calloc (nzmax, get_element_size ()) : 0);
     ir = static_cast<mwIndex *> (calloc (nzmax, sizeof (mwIndex)));
     jc = static_cast<mwIndex *> (calloc (n + 1, sizeof (mwIndex)));
   }
 
@@ -1526,83 +1526,83 @@ protected:
   {
     octave_value retval;
 
     dim_vector dv = dims_to_dim_vector ();
 
     switch (get_class_id ())
       {
       case mxLOGICAL_CLASS:
-	{
-	  bool *ppr = static_cast<bool *> (pr);
-
-	  SparseBoolMatrix val (get_m (), get_n (),
-				static_cast<octave_idx_type> (nzmax));
-
-	  for (mwIndex i = 0; i < nzmax; i++)
-	    {
-	      val.xdata(i) = ppr[i];
-	      val.xridx(i) = ir[i];
-	    }
-
-	  for (mwIndex i = 0; i < get_n () + 1; i++)
-	    val.xcidx(i) = jc[i];
-
-	  retval = val;
-	}
-	break;
+        {
+          bool *ppr = static_cast<bool *> (pr);
+
+          SparseBoolMatrix val (get_m (), get_n (),
+                                static_cast<octave_idx_type> (nzmax));
+
+          for (mwIndex i = 0; i < nzmax; i++)
+            {
+              val.xdata(i) = ppr[i];
+              val.xridx(i) = ir[i];
+            }
+
+          for (mwIndex i = 0; i < get_n () + 1; i++)
+            val.xcidx(i) = jc[i];
+
+          retval = val;
+        }
+        break;
 
       case mxSINGLE_CLASS:
-	error ("single precision sparse data type not supported");
-	break;
+        error ("single precision sparse data type not supported");
+        break;
 
       case mxDOUBLE_CLASS:
-	{
-	  if (pi)
-	    {
-	      double *ppr = static_cast<double *> (pr);
-	      double *ppi = static_cast<double *> (pi);
-
-	      SparseComplexMatrix val (get_m (), get_n (),
-				       static_cast<octave_idx_type> (nzmax));
-
-	      for (mwIndex i = 0; i < nzmax; i++)
-		{
-		  val.xdata(i) = Complex (ppr[i], ppi[i]);
-		  val.xridx(i) = ir[i];
-		}
-
-	      for (mwIndex i = 0; i < get_n () + 1; i++)
-		val.xcidx(i) = jc[i];
-
-	      retval = val;
-	    }
-	  else
-	    {
-	      double *ppr = static_cast<double *> (pr);
-
-	      SparseMatrix val (get_m (), get_n (),
-				static_cast<octave_idx_type> (nzmax));
-
-	      for (mwIndex i = 0; i < nzmax; i++)
-		{
-		  val.xdata(i) = ppr[i];
-		  val.xridx(i) = ir[i];
-		}
-
-	      for (mwIndex i = 0; i < get_n () + 1; i++)
-		val.xcidx(i) = jc[i];
-
-	      retval = val;
-	    }
-	}
-	break;
+        {
+          if (pi)
+            {
+              double *ppr = static_cast<double *> (pr);
+              double *ppi = static_cast<double *> (pi);
+
+              SparseComplexMatrix val (get_m (), get_n (),
+                                       static_cast<octave_idx_type> (nzmax));
+
+              for (mwIndex i = 0; i < nzmax; i++)
+                {
+                  val.xdata(i) = Complex (ppr[i], ppi[i]);
+                  val.xridx(i) = ir[i];
+                }
+
+              for (mwIndex i = 0; i < get_n () + 1; i++)
+                val.xcidx(i) = jc[i];
+
+              retval = val;
+            }
+          else
+            {
+              double *ppr = static_cast<double *> (pr);
+
+              SparseMatrix val (get_m (), get_n (),
+                                static_cast<octave_idx_type> (nzmax));
+
+              for (mwIndex i = 0; i < nzmax; i++)
+                {
+                  val.xdata(i) = ppr[i];
+                  val.xridx(i) = ir[i];
+                }
+
+              for (mwIndex i = 0; i < get_n () + 1; i++)
+                val.xcidx(i) = jc[i];
+
+              retval = val;
+            }
+        }
+        break;
 
       default:
-	panic_impossible ();
+        panic_impossible ();
       }
 
     return retval;
   }
 
 private:
 
   mwSize nzmax;
@@ -1637,17 +1637,17 @@ private:
 
 // Matlab-style struct arrays.
 
 class mxArray_struct : public mxArray_matlab
 {
 public:
 
   mxArray_struct (mwSize ndims_arg, const mwSize *dims_arg, int num_keys_arg,
-		  const char **keys)
+                  const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, ndims_arg, dims_arg), nfields (num_keys_arg),
       fields (static_cast<char **> (calloc (nfields, sizeof (char *)))),
       data (static_cast<mxArray **> (calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
   {
     init (keys);
   }
 
   mxArray_struct (const dim_vector& dv, int num_keys_arg, const char **keys)
@@ -1690,104 +1690,104 @@ public:
   }
 
   int add_field (const char *key)
   {
     int retval = -1;
 
     if (valid_key (key))
       {
-	nfields++;
-
-	fields = static_cast<char **> (mxRealloc (fields, nfields * sizeof (char *)));
-
-	if (fields)
-	  {
-	    fields[nfields-1] = strsave (key);
-
-	    mwSize nel = get_number_of_elements ();
-
-	    mwSize ntot = nfields * nel;
-
-	    mxArray **new_data = static_cast<mxArray **> (malloc (ntot * sizeof (mxArray *)));
-
-	    if (new_data)
-	      {
-		mwIndex j = 0;
-		mwIndex k = 0;
-		mwIndex n = 0;
-
-		for (mwIndex i = 0; i < ntot; i++)
-		  {
-		    if (++n == nfields)
-		      {
-			new_data[j++] = 0;
-			n = 0;
-		      }
-		    else
-		      new_data[j++] = data[k++];
-		  }
-
-		mxFree (data);
-
-		data = new_data;
-
-		retval = nfields - 1;
-	      }
-	  }
+        nfields++;
+
+        fields = static_cast<char **> (mxRealloc (fields, nfields * sizeof (char *)));
+
+        if (fields)
+          {
+            fields[nfields-1] = strsave (key);
+
+            mwSize nel = get_number_of_elements ();
+
+            mwSize ntot = nfields * nel;
+
+            mxArray **new_data = static_cast<mxArray **> (malloc (ntot * sizeof (mxArray *)));
+
+            if (new_data)
+              {
+                mwIndex j = 0;
+                mwIndex k = 0;
+                mwIndex n = 0;
+
+                for (mwIndex i = 0; i < ntot; i++)
+                  {
+                    if (++n == nfields)
+                      {
+                        new_data[j++] = 0;
+                        n = 0;
+                      }
+                    else
+                      new_data[j++] = data[k++];
+                  }
+
+                mxFree (data);
+
+                data = new_data;
+
+                retval = nfields - 1;
+              }
+          }
       }
 
     return retval;
   }
 
   void remove_field (int key_num)
   {
     if (key_num >= 0 && key_num < nfields)
       {
-	mwSize nel = get_number_of_elements ();
-
-	mwSize ntot = nfields * nel;
-
-	int new_nfields = nfields - 1;
-
-	char **new_fields = static_cast<char **> (malloc (new_nfields * sizeof (char *)));
-
-	mxArray **new_data = static_cast<mxArray **> (malloc (new_nfields * nel * sizeof (mxArray *)));
-
-	for (int i = 0; i < key_num; i++)
-	  new_fields[i] = fields[i];
-
-	for (int i = key_num + 1; i < nfields; i++)
-	  new_fields[i-1] = fields[i];
-
-	if (new_nfields > 0)
-	  {
-	    mwIndex j = 0;
-	    mwIndex k = 0;
-	    mwIndex n = 0;
-
-	    for (mwIndex i = 0; i < ntot; i++)
-	      {
-		if (n == key_num)
-		  k++;
-		else
-		  new_data[j++] = data[k++];
-
-		if (++n == nfields)
-		  n = 0;
-	      }
-	  }
-
-	nfields = new_nfields;
-
-	mxFree (fields);
-	mxFree (data);
-
-	fields = new_fields;
-	data = new_data;
+        mwSize nel = get_number_of_elements ();
+
+        mwSize ntot = nfields * nel;
+
+        int new_nfields = nfields - 1;
+
+        char **new_fields = static_cast<char **> (malloc (new_nfields * sizeof (char *)));
+
+        mxArray **new_data = static_cast<mxArray **> (malloc (new_nfields * nel * sizeof (mxArray *)));
+
+        for (int i = 0; i < key_num; i++)
+          new_fields[i] = fields[i];
+
+        for (int i = key_num + 1; i < nfields; i++)
+          new_fields[i-1] = fields[i];
+
+        if (new_nfields > 0)
+          {
+            mwIndex j = 0;
+            mwIndex k = 0;
+            mwIndex n = 0;
+
+            for (mwIndex i = 0; i < ntot; i++)
+              {
+                if (n == key_num)
+                  k++;
+                else
+                  new_data[j++] = data[k++];
+
+                if (++n == nfields)
+                  n = 0;
+              }
+          }
+
+        nfields = new_nfields;
+
+        mxFree (fields);
+        mxFree (data);
+
+        fields = new_fields;
+        data = new_data;
       }
   }
 
   mxArray *get_field_by_number (mwIndex index, int key_num) const
   {
     return key_num >= 0 && key_num < nfields
       ? data[nfields * index + key_num] : 0;
   }
@@ -1802,21 +1802,21 @@ public:
   }
 
   int get_field_number (const char *key) const
   {
     int retval = -1;
 
     for (int i = 0; i < nfields; i++)
       {
-	if (! strcmp (key, fields[i]))
-	  {
-	    retval = i;
-	    break;
-	  }
+        if (! strcmp (key, fields[i]))
+          {
+            retval = i;
+            break;
+          }
       }
 
     return retval;
   }
 
   void *get_data (void) const { return data; }
 
   void set_data (void *data_arg) { data = static_cast<mxArray **> (data_arg); }
@@ -1830,25 +1830,25 @@ protected:
     string_vector keys (fields, nfields);
 
     Octave_map m;
 
     mwSize ntot = nfields * get_number_of_elements ();
 
     for (int i = 0; i < nfields; i++)
       {
-	Cell c (dv);
-
-	octave_value *p = c.fortran_vec ();
-
-	mwIndex k = 0;
-	for (mwIndex j = i; j < ntot; j += nfields)
-	  p[k++] = mxArray::as_octave_value (data[j]);
-
-	m.assign (keys[i], c);
+        Cell c (dv);
+
+        octave_value *p = c.fortran_vec ();
+
+        mwIndex k = 0;
+        for (mwIndex j = i; j < ntot; j += nfields)
+          p[k++] = mxArray::as_octave_value (data[j]);
+
+        m.assign (keys[i], c);
       }
 
     return m;
   }
 
 private:
 
   int nfields;
@@ -1864,18 +1864,18 @@ private:
   {
     for (int i = 0; i < nfields; i++)
       fields[i] = strsave (val.fields[i]);
 
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel * nfields; i++)
       {
-	mxArray *ptr = val.data[i];
-	data[i] = ptr ? ptr->clone () : 0;
+        mxArray *ptr = val.data[i];
+        data[i] = ptr ? ptr->clone () : 0;
       }
   }
 };
 
 // Matlab-style cell arrays.
 
 class mxArray_cell : public mxArray_matlab
 {
@@ -1941,18 +1941,18 @@ private:
   mxArray_cell (const mxArray_cell& val)
     : mxArray_matlab (val),
       data (static_cast<mxArray **> (malloc (get_number_of_elements () * sizeof (mxArray *))))
   {
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel; i++)
       {
-	mxArray *ptr = val.data[i];
-	data[i] = ptr ? ptr->clone () : 0;
+        mxArray *ptr = val.data[i];
+        data[i] = ptr ? ptr->clone () : 0;
       }
   }
 };
 
 // ------------------------------------------------------------------
 
 mxArray::mxArray (const octave_value& ov)
   : rep (new mxArray_octave_value (ov)), name (0) { }
@@ -2032,22 +2032,22 @@ mxArray::maybe_mutate (void) const
     {
       // The mutate function returns a pointer to a complete new
       // mxArray object (or 0, if no mutation happened).  We just want
       // to replace the existing rep with the rep from the new object.
 
       mxArray *new_val = rep->mutate ();
 
       if (new_val)
-	{
-	  delete rep;
-	  rep = new_val->rep;
-	  new_val->rep = 0;
-	  delete new_val;
-	}
+        {
+          delete rep;
+          rep = new_val->rep;
+          new_val->rep = 0;
+          delete new_val;
+        }
     }
 }
 
 // ------------------------------------------------------------------
 
 // A class to manage calls to MEX functions.  Mostly deals with memory
 // management.
 
@@ -2065,63 +2065,63 @@ public:
 
     mxFree (fname);
   }
 
   const char *function_name (void) const
   {
     if (! fname)
       {
-	octave_function *fcn = octave_call_stack::current ();
-
-	if (fcn)
-	  {
-	    std::string nm = fcn->name ();
-	    fname = mxArray::strsave (nm.c_str ());
-	  }
-	else
-	  fname = mxArray::strsave ("unknown");
+        octave_function *fcn = octave_call_stack::current ();
+
+        if (fcn)
+          {
+            std::string nm = fcn->name ();
+            fname = mxArray::strsave (nm.c_str ());
+          }
+        else
+          fname = mxArray::strsave ("unknown");
       }
 
     return fname;
   }
 
   // Free all unmarked pointers obtained from malloc and calloc.
   static void cleanup (void *ptr)
   {
     mex *context = static_cast<mex *> (ptr);
 
     // We can't use mex::free here because it modifies memlist.
     for (std::set<void *>::iterator p = context->memlist.begin ();
-	 p != context->memlist.end (); p++)
+         p != context->memlist.end (); p++)
       xfree (*p);
 
     context->memlist.clear ();
 
     // We can't use mex::free_value here because it modifies arraylist.
     for (std::set<mxArray *>::iterator p = context->arraylist.begin ();
-	 p != context->arraylist.end (); p++)
+         p != context->arraylist.end (); p++)
       delete *p;
 
     context->arraylist.clear ();
   }
 
   // Allocate memory.
   void *malloc_unmarked (size_t n)
   {
     void *ptr = ::malloc (n);
 
     if (! ptr)
       {
-	// FIXME -- could use "octave_new_handler();" instead
-
-	error ("%s: failed to allocate %d bytes of memory",
-	       function_name (), n);
-
-	abort ();
+        // FIXME -- could use "octave_new_handler();" instead
+
+        error ("%s: failed to allocate %d bytes of memory",
+               function_name (), n);
+
+        abort ();
       }
 
     global_mark (ptr);
 
     return ptr;
   }
 
   // Allocate memory to be freed on exit.
@@ -2158,64 +2158,64 @@ public:
   // pointer is NULL, allocate using malloc.  We don't need an
   // "unmarked" version of this.
   void *realloc (void *ptr, size_t n)
   {
     void *v;
 
     if (ptr)
       {
-	v = ::realloc (ptr, n);
-	
-	std::set<void *>::iterator p = memlist.find (ptr);
-	
-	if (v && p != memlist.end ())
-	  {
-	    memlist.erase (p);
-	    memlist.insert (v);
-	  }
-	
-	p = global_memlist.find (ptr);
-	
-	if (v && p != global_memlist.end ())
-	  {
-	    global_memlist.erase (p);
-	    global_memlist.insert (v);
-	  }
+        v = ::realloc (ptr, n);
+        
+        std::set<void *>::iterator p = memlist.find (ptr);
+        
+        if (v && p != memlist.end ())
+          {
+            memlist.erase (p);
+            memlist.insert (v);
+          }
+        
+        p = global_memlist.find (ptr);
+        
+        if (v && p != global_memlist.end ())
+          {
+            global_memlist.erase (p);
+            global_memlist.insert (v);
+          }
       }
     else
       v = malloc (n);
 
     return v;
   }
 
   // Free a pointer obtained from malloc or calloc.
   void free (void *ptr)
   {
     if (ptr)
       {
-	unmark (ptr);
-
-	std::set<void *>::iterator p = global_memlist.find (ptr);
-
-	if (p != global_memlist.end ())
-	  {
-	    global_memlist.erase (p);
-
-	    xfree (ptr);
-	  }
-	else
-	  {
-	    p = foreign_memlist.find (ptr);
-
-	    if (p != foreign_memlist.end ())
-	      foreign_memlist.erase (p);
-	    else
-	      warning ("mxFree: skipping memory not allocated by mxMalloc, mxCalloc, or mxRealloc");
-	  }
+        unmark (ptr);
+
+        std::set<void *>::iterator p = global_memlist.find (ptr);
+
+        if (p != global_memlist.end ())
+          {
+            global_memlist.erase (p);
+
+            xfree (ptr);
+          }
+        else
+          {
+            p = foreign_memlist.find (ptr);
+
+            if (p != foreign_memlist.end ())
+              foreign_memlist.erase (p);
+            else
+              warning ("mxFree: skipping memory not allocated by mxMalloc, mxCalloc, or mxRealloc");
+          }
       }
   }
 
   // Mark a pointer to be freed on exit.
   void mark (void *ptr)
   {
 #ifdef DEBUG
     if (memlist.find (ptr) != memlist.end ())
@@ -2289,19 +2289,19 @@ public:
   bool free_value (mxArray *ptr)
   {
     bool inlist = false;
 
     std::set<mxArray *>::iterator p = arraylist.find (ptr);
 
     if (p != arraylist.end ())
       {
-	inlist = true;
-	arraylist.erase (p);
-	delete ptr;
+        inlist = true;
+        arraylist.erase (p);
+        delete ptr;
       }
 #ifdef DEBUG
     else
       warning ("mex::free_value: skipping memory not allocated by mex::make_value");
 #endif
 
     return inlist;
   }
@@ -2554,17 +2554,17 @@ mxCreateLogicalMatrix (mwSize m, mwSize 
 mxArray *
 mxCreateLogicalScalar (mxLogical val)
 {
   return maybe_mark_array (new mxArray (mxLOGICAL_CLASS, val));
 }
 
 mxArray *
 mxCreateNumericArray (mwSize ndims, const mwSize *dims, mxClassID class_id,
-		      mxComplexity flag)
+                      mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (class_id, ndims, dims, flag));
 }
 
 mxArray *
 mxCreateNumericMatrix (mwSize m, mwSize n, mxClassID class_id, mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (class_id, m, n, flag));
@@ -2797,18 +2797,18 @@ mxSetN (mxArray *ptr, mwSize n)
 {
   ptr->set_n (n);
 }
 
 void
 mxSetDimensions (mxArray *ptr, const mwSize *dims, mwSize ndims)
 {
   ptr->set_dimensions (static_cast<mwSize *> (
-			 maybe_unmark (const_cast<mwSize *> (dims))),
-		       ndims);
+                         maybe_unmark (const_cast<mwSize *> (dims))),
+                       ndims);
 }
   
 // Data extractors.
 double *
 mxGetPr (const mxArray *ptr)
 {
   return static_cast<double *> (ptr->get_data ());
 }
@@ -3026,17 +3026,17 @@ mxGetElementSize (const mxArray *ptr)
 
 // ------------------------------------------------------------------
 
 typedef void (*cmex_fptr) (int nlhs, mxArray **plhs, int nrhs, mxArray **prhs);
 typedef F77_RET_T (*fmex_fptr) (int& nlhs, mxArray **plhs, int& nrhs, mxArray **prhs);
 
 octave_value_list
 call_mex (bool have_fmex, void *f, const octave_value_list& args,
-	  int nargout_arg, octave_mex_function *curr_mex_fcn)
+          int nargout_arg, octave_mex_function *curr_mex_fcn)
 {
   // Use at least 1 for nargout since even for zero specified args,
   // still want to be able to return an ans.
 
   volatile int nargout = nargout_arg;
 
   int nargin = args.length ();
   OCTAVE_LOCAL_BUFFER (mxArray *, argin, nargin);
@@ -3060,48 +3060,48 @@ call_mex (bool have_fmex, void *f, const
   for (int i = 0; i < nargin; i++)
     argin[i] = context.make_value (args(i));
 
   if (setjmp (context.jump) == 0)
     {
       mex_context = &context;
 
       if (have_fmex)
-	{
-	  fmex_fptr fcn = FCN_PTR_CAST (fmex_fptr, f);
-
-	  int tmp_nargout = nargout;
-	  int tmp_nargin = nargin;
-
-	  fcn (tmp_nargout, argout, tmp_nargin, argin);
-	}
+        {
+          fmex_fptr fcn = FCN_PTR_CAST (fmex_fptr, f);
+
+          int tmp_nargout = nargout;
+          int tmp_nargin = nargin;
+
+          fcn (tmp_nargout, argout, tmp_nargin, argin);
+        }
       else
-	{
-	  cmex_fptr fcn = FCN_PTR_CAST (cmex_fptr, f);
-
-	  fcn (nargout, argout, nargin, argin);
-	}
+        {
+          cmex_fptr fcn = FCN_PTR_CAST (cmex_fptr, f);
+
+          fcn (nargout, argout, nargin, argin);
+        }
     }
 
   // Convert returned array entries back into octave values.
 
   octave_value_list retval;
 
   if (! error_state)
     {
       if (nargout == 0 && argout[0])
-	{
-	  // We have something for ans.
-	  nargout = 1;
-	}
+        {
+          // We have something for ans.
+          nargout = 1;
+        }
 
       retval.resize (nargout);
 
       for (int i = 0; i < nargout; i++)
-	retval(i) = mxArray::as_octave_value (argout[i]);
+        retval(i) = mxArray::as_octave_value (argout[i]);
     }
 
   // Clean up mex resources.
   frame.run ();
 
   return retval;
 }
 
@@ -3110,17 +3110,17 @@ call_mex (bool have_fmex, void *f, const
 const char *
 mexFunctionName (void)
 {
   return mex_context ? mex_context->function_name () : "unknown";
 }
 
 int
 mexCallMATLAB (int nargout, mxArray *argout[], int nargin, mxArray *argin[],
-	       const char *fname)
+               const char *fname)
 {
   octave_value_list args;
 
   // FIXME -- do we need unwind protect to clean up args?  Off hand, I
   // would say that this problem is endemic to Octave and we will
   // continue to have memory leaks after Ctrl-C until proper exception
   // handling is implemented.  longjmp() only clears the stack, so any
   // class which allocates data on the heap is going to leak.
@@ -3283,29 +3283,29 @@ mexGetVariable (const char *space, const
       // FIXME -- should this be in variables.cc?
 
       unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
-	{
-	  if (caller)
-	    octave_call_stack::goto_caller_frame ();
-	  else
-	    octave_call_stack::goto_base_frame ();
-
-	  if (! error_state)
-	    frame.add_fcn (octave_call_stack::pop);
-
-	  val = symbol_table::varval (name);
-	}
+        {
+          if (caller)
+            octave_call_stack::goto_caller_frame ();
+          else
+            octave_call_stack::goto_base_frame ();
+
+          if (! error_state)
+            frame.add_fcn (octave_call_stack::pop);
+
+          val = symbol_table::varval (name);
+        }
       else
-	mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
+        mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
 
   if (val.is_defined ())
     {
       retval = mex_context->make_value (val);
 
       retval->set_name (name);
     }
@@ -3341,29 +3341,29 @@ mexPutVariable (const char *space, const
       // FIXME -- should this be in variables.cc?
 
       unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
-	{
-	  if (caller)
-	    octave_call_stack::goto_caller_frame ();
-	  else
-	    octave_call_stack::goto_base_frame ();
-
-	  if (! error_state)
-	    frame.add_fcn (octave_call_stack::pop);
-
-	  symbol_table::varref (name) = mxArray::as_octave_value (ptr);
-	}
+        {
+          if (caller)
+            octave_call_stack::goto_caller_frame ();
+          else
+            octave_call_stack::goto_base_frame ();
+
+          if (! error_state)
+            frame.add_fcn (octave_call_stack::pop);
+
+          symbol_table::varref (name) = mxArray::as_octave_value (ptr);
+        }
       else
-	mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
+        mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
   return 0;
 }
 
 void
 mexMakeArrayPersistent (mxArray *ptr)
 {
@@ -3428,47 +3428,47 @@ std::map<std::string,int> mex_lock_count
 void
 mexLock (void)
 {
   if (mex_context)
     {
       const char *fname = mexFunctionName ();
 
       if (mex_lock_count.find (fname) == mex_lock_count.end ())
-	mex_lock_count[fname] = 1;
+        mex_lock_count[fname] = 1;
       else
-	mex_lock_count[fname]++;
+        mex_lock_count[fname]++;
 
       mlock ();
     }
 }
 
 int
 mexSet (double handle, const char *property, mxArray *val)
 {
   bool ret = 
     set_property_in_handle (handle, property, mxArray::as_octave_value (val),
-			    "mexSet");
+                            "mexSet");
   return (ret ? 0 : 1);
 }
 
 void
 mexUnlock (void)
 {
   if (mex_context)
     {
       const char *fname = mexFunctionName ();
 
       std::map<std::string,int>::iterator p = mex_lock_count.find (fname);
 
       if (p != mex_lock_count.end ())
-	{
-	  int count = --mex_lock_count[fname];
-
-	  if (count == 0)
-	    {
-	      munlock (fname);
-
-	      mex_lock_count.erase (p);
-	    }
-	}
+        {
+          int count = --mex_lock_count[fname];
+
+          if (count == 0)
+            {
+              munlock (fname);
+
+              mex_lock_count.erase (p);
+            }
+        }
     }
 }
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -28,24 +28,24 @@ along with Octave; see the file COPYING.
 #include <cerrno>
 #include <cstring>
 
 #include "error.h"
 #include "oct-fstrm.h"
 
 octave_stream
 octave_fstream::create (const std::string& nm_arg, std::ios::openmode arg_md,
-			oct_mach_info::float_format ff)
+                        oct_mach_info::float_format ff)
 {
   return octave_stream (new octave_fstream (nm_arg, arg_md, ff));
 }
 
 octave_fstream::octave_fstream (const std::string& nm_arg,
-				std::ios::openmode arg_md,
-				oct_mach_info::float_format ff)
+                                std::ios::openmode arg_md,
+                                oct_mach_info::float_format ff)
   : octave_base_stream (arg_md, ff), nm (nm_arg)
 {
 
 #if CXX_ISO_COMPLIANT_LIBRARY
 
   fs.open (nm.c_str (), arg_md);
 
 #else
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -79,17 +79,17 @@ default_history_file (void)
 
   std::string env_file = octave_env::getenv ("OCTAVE_HISTFILE");
 
   if (! env_file.empty ())
     file = env_file;
 
   if (file.empty ())
     file = file_ops::concat (octave_env::get_home_directory (),
-			     ".octave_hist");
+                             ".octave_hist");
 
   return file;
 }
 
 // Where history is saved.
 static std::string Vhistory_file = default_history_file ();
 
 static int
@@ -99,17 +99,17 @@ default_history_size (void)
 
   std::string env_size = octave_env::getenv ("OCTAVE_HISTSIZE");
 
   if (! env_size.empty ())
     {
       int val;
 
       if (sscanf (env_size.c_str (), "%d", &val) == 1)
-	size = val > 0 ? val : 0;
+        size = val > 0 ? val : 0;
     }
 
   return size;
 }
 
 // The number of lines to keep in the history file.
 static int Vhistory_size = default_history_size ();
 
@@ -144,69 +144,69 @@ do_history (int argc, const string_vecto
   int numbered_output = 1;
 
   int i;
   for (i = 1; i < argc; i++)
     {
       std::string option = argv[i];
 
       if (option == "-r" || option == "-w" || option == "-a"
-	  || option == "-n")
-	{
-	  if (i < argc - 1)
-	    command_history::set_file (argv[i+1]);
+          || option == "-n")
+        {
+          if (i < argc - 1)
+            command_history::set_file (argv[i+1]);
 
-	  if (option == "-a")
-	    // Append `new' lines to file.
-	    command_history::append ();
+          if (option == "-a")
+            // Append `new' lines to file.
+            command_history::append ();
 
-	  else if (option == "-w")
-	    // Write entire history.
-	    command_history::write ();
+          else if (option == "-w")
+            // Write entire history.
+            command_history::write ();
 
-	  else if (option == "-r")
-	    // Read entire file.
-	    command_history::read ();
+          else if (option == "-r")
+            // Read entire file.
+            command_history::read ();
 
-	  else if (option == "-n")
-	    // Read `new' history from file.
-	    command_history::read_range ();
+          else if (option == "-n")
+            // Read `new' history from file.
+            command_history::read_range ();
 
-	  else
-	    panic_impossible ();
+          else
+            panic_impossible ();
 
-	  return;
-	}
+          return;
+        }
       else if (argv[i] == "-q")
-	numbered_output = 0;
+        numbered_output = 0;
       else if (argv[i] == "--")
-	{
-	  i++;
-	  break;
-	}
+        {
+          i++;
+          break;
+        }
       else
-	break;
+        break;
     }
 
   int limit = -1;
 
   if (i < argc)
     {
       if (sscanf (argv[i].c_str (), "%d", &limit) != 1)
         {
-	  if (argv[i][0] == '-')
-	    error ("history: unrecognized option `%s'", argv[i].c_str ());
-	  else
-	    error ("history: bad non-numeric arg `%s'", argv[i].c_str ());
+          if (argv[i][0] == '-')
+            error ("history: unrecognized option `%s'", argv[i].c_str ());
+          else
+            error ("history: bad non-numeric arg `%s'", argv[i].c_str ());
 
-	  return;
+          return;
         }
 
       if (limit < 0)
-	limit = -limit;
+        limit = -limit;
     }
 
   string_vector hlist = command_history::list (limit, numbered_output);
 
   int len = hlist.length ();
 
   for (i = 0; i < len; i++)
     octave_stdout << hlist[i] << "\n";
@@ -223,31 +223,31 @@ edit_history_readline (std::fstream& str
   int line_len = 128;
   int lindex = 0;
   char *line = new char [line_len];
   line[0] = '\0';
 
   while (stream.get (c))
     {
       if (lindex + 2 >= line_len)
-	{
-	  char *tmp_line = new char [line_len += 128];
-	  strcpy (tmp_line, line);
-	  delete [] line;
-	  line = tmp_line;
-	}
+        {
+          char *tmp_line = new char [line_len += 128];
+          strcpy (tmp_line, line);
+          delete [] line;
+          line = tmp_line;
+        }
 
       if (c == '\n')
-	{
-	  line[lindex++] = '\n';
-	  line[lindex++] = '\0';
-	  return line;
-	}
+        {
+          line[lindex++] = '\n';
+          line[lindex++] = '\0';
+          return line;
+        }
       else
-	line[lindex++] = c;
+        line[lindex++] = c;
     }
 
   if (! lindex)
     {
       delete [] line;
       return 0;
     }
 
@@ -277,57 +277,57 @@ edit_history_repl_hist (const std::strin
 {
   if (! command.empty ())
     {
       string_vector hlist = command_history::list ();
 
       int len = hlist.length ();
 
       if (len > 0)
-	{
-	  int i = len - 1;
+        {
+          int i = len - 1;
 
-	  std::string histent = command_history::get_entry (i);
+          std::string histent = command_history::get_entry (i);
 
-	  if (! histent.empty ())
-	    {
-	      std::string cmd = command;
+          if (! histent.empty ())
+            {
+              std::string cmd = command;
 
-	      int cmd_len = cmd.length ();
+              int cmd_len = cmd.length ();
 
-	      if (cmd[cmd_len - 1] == '\n')
-		cmd.resize (cmd_len - 1);
+              if (cmd[cmd_len - 1] == '\n')
+                cmd.resize (cmd_len - 1);
 
-	      if (! cmd.empty ())
-		command_history::replace_entry (i, cmd);
-	    }
-	}
+              if (! cmd.empty ())
+                command_history::replace_entry (i, cmd);
+            }
+        }
     }
 }
 
 static void
 edit_history_add_hist (const std::string& line)
 {
   if (! line.empty ())
     {
       std::string tmp = line;
 
       int len = tmp.length ();
-	
+        
       if (len > 0 && tmp[len-1] == '\n')
-	tmp.resize (len - 1);
+        tmp.resize (len - 1);
 
       if (! tmp.empty ())
-	command_history::add (tmp);
+        command_history::add (tmp);
     }
 }
 
 static std::string
 mk_tmp_hist_file (int argc, const string_vector& argv,
-		  int insert_curr, const char *warn_for) 
+                  int insert_curr, const char *warn_for) 
 {
   std::string retval;
 
   string_vector hlist = command_history::list ();
 
   int hist_count = hlist.length ();
 
   // The current command line is already part of the history list by
@@ -348,33 +348,33 @@ mk_tmp_hist_file (int argc, const string
   int reverse = 0;
 
   // Process options.
 
   int usage_error = 0;
   if (argc == 3)
     {
       if (sscanf (argv[1].c_str (), "%d", &hist_beg) != 1
-	  || sscanf (argv[2].c_str (), "%d", &hist_end) != 1)
-	usage_error = 1;
+          || sscanf (argv[2].c_str (), "%d", &hist_end) != 1)
+        usage_error = 1;
       else
-	{
-	  hist_beg--;
-	  hist_end--;
-	}
+        {
+          hist_beg--;
+          hist_end--;
+        }
     }
   else if (argc == 2)
     {
       if (sscanf (argv[1].c_str (), "%d", &hist_beg) != 1)
-	usage_error = 1;
+        usage_error = 1;
       else
-	{
-	  hist_beg--;
-	  hist_end = hist_beg;
-	}
+        {
+          hist_beg--;
+          hist_end = hist_beg;
+        }
     }
 
   if (hist_beg < 0 || hist_end < 0 || hist_beg > hist_count
       || hist_end > hist_count)
     {
       error ("%s: history specification out of range", warn_for);
       return retval;
     }
@@ -395,29 +395,29 @@ mk_tmp_hist_file (int argc, const string
 
   std::string name = octave_tempnam ("", "oct-");
 
   std::fstream file (name.c_str (), std::ios::out);
 
   if (! file)
     {
       error ("%s: couldn't open temporary file `%s'", warn_for,
-	     name.c_str ());
+             name.c_str ());
       return retval;
     }
 
   if (reverse)
     {
       for (int i = hist_end; i >= hist_beg; i--)
-	file << hlist[i] << "\n";
+        file << hlist[i] << "\n";
     }
   else
     {
       for (int i = hist_beg; i <= hist_end; i++)
-	file << hlist[i] << "\n";
+        file << hlist[i] << "\n";
     }
 
   file.close ();
 
   return name;
 }
 
 static void unlink_cleanup (const char *file)
@@ -457,28 +457,28 @@ do_edit_history (int argc, const string_
 
   char *line;
   int first = 1;
   while ((line = edit_history_readline (file)) != 0)
     {
       // Skip blank lines.
 
       if (line[0] == '\n')
-	{
-	  delete [] line;
-	  continue;
-	}
+        {
+          delete [] line;
+          continue;
+        }
 
       if (first)
-	{
-	  first = 0;
-	  edit_history_repl_hist (line);
-	}
+        {
+          first = 0;
+          edit_history_repl_hist (line);
+        }
       else
-	edit_history_add_hist (line);
+        edit_history_add_hist (line);
     }
 
   file.close ();
 
   // Turn on command echo, so the output from this will make better
   // sense.
 
   unwind_protect frame;
diff --git a/src/oct-lvalue.cc b/src/oct-lvalue.cc
--- a/src/oct-lvalue.cc
+++ b/src/oct-lvalue.cc
@@ -41,17 +41,17 @@ octave_lvalue::assign (octave_value::ass
 
       if (! error_state)
         *val = tmp;
     }
 }
 
 void
 octave_lvalue::set_index (const std::string& t,
-			  const std::list<octave_value_list>& i)
+                          const std::list<octave_value_list>& i)
 {
   if (idx.empty ())
     {
       type = t;
       idx = i;
     }
   else
     error ("invalid index expression in assignment");
@@ -85,15 +85,15 @@ octave_lvalue::value (void)
       else
         {
           if (val->is_constant ())
             retval = val->subsref (type, idx);
           else
             {
               octave_value_list t = val->subsref (type, idx, 1);
               if (t.length () > 0)
-                retval = t(0);	      
+                retval = t(0);        
             }
         }
     }
 
   return retval;
 }
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -34,37 +34,37 @@ along with Octave; see the file COPYING.
 Octave_map::Octave_map (const dim_vector& dv, const Cell& key_vals)
   : map (), key_list (), dimensions (dv)
 {
   Cell c (dv);
 
   if (key_vals.is_cellstr ())
     {
       for (octave_idx_type i = 0; i < key_vals.numel (); i++)
-	{
-	  std::string k = key_vals(i).string_value ();
-	  map[k] = c;
-	  key_list.push_back (k);
-	}
+        {
+          std::string k = key_vals(i).string_value ();
+          map[k] = c;
+          key_list.push_back (k);
+        }
     }
   else
     error ("Octave_map: expecting keys to be cellstr");
 }
 
 Octave_map
 Octave_map::squeeze (void) const
 {
   Octave_map retval (dims ().squeeze ());
 
   for (const_iterator pa = begin (); pa != end (); pa++)
     {
       Cell tmp = contents (pa).squeeze ();
 
       if (error_state)
-	break;
+        break;
 
       retval.assign (key (pa), tmp);
     }
 
   // Preserve order of keys.
   retval.key_list = key_list;
 
   return retval;
@@ -82,17 +82,17 @@ Octave_map::permute (const Array<int>& v
 {
   Octave_map retval (dims ());
 
   for (const_iterator pa = begin (); pa != end (); pa++)
     {
       Cell tmp = contents (pa).permute (vec, inv);
 
       if (error_state)
-	break;
+        break;
 
       retval.assign (key (pa), tmp);
     }
 
   // Preserve order of keys.
   retval.key_list = key_list;
 
   return retval;
@@ -131,17 +131,17 @@ Octave_map::intfield (const std::string&
   if (! c.is_empty ())
     retval = c(0).int_value ();
 
   return retval;
 }
 
 std::string
 Octave_map::stringfield (const std::string& k,
-			 const std::string& def_val) const
+                         const std::string& def_val) const
 {
   std::string retval = def_val;
 
   Cell c = contents (k);
 
   if (! c.is_empty ())
     retval = c(0).string_value ();
 
@@ -191,17 +191,17 @@ Octave_map::transpose (void) const
 Octave_map
 Octave_map::reshape (const dim_vector& new_dims) const
 {
   Octave_map retval;
 
   if (new_dims != dims ())
     {
       for (const_iterator p = begin (); p != end (); p++)
-	retval.assign (key(p), contents(p).reshape (new_dims));
+        retval.assign (key(p), contents(p).reshape (new_dims));
 
       retval.dimensions = new_dims;
 
       // Preserve order of keys.
       retval.key_list = key_list;
     }
   else
     retval = *this;
@@ -217,75 +217,75 @@ Octave_map::reshape (const dim_vector& n
 */
 
 void
 Octave_map::resize (const dim_vector& dv, bool fill)
 {
   if (dv != dims ())
     {
       if (nfields () == 0)
-	dimensions = dv;
+        dimensions = dv;
       else
-	{
-	  for (const_iterator p = begin (); p != end (); p++)
-	    {
-	      Cell tmp = contents(p);
+        {
+          for (const_iterator p = begin (); p != end (); p++)
+            {
+              Cell tmp = contents(p);
 
-	      if (fill)
-		tmp.resize (dv, Cell::resize_fill_value ());
-	      else
-		tmp.resize (dv);
+              if (fill)
+                tmp.resize (dv, Cell::resize_fill_value ());
+              else
+                tmp.resize (dv);
 
-	      dimensions = dv;
+              dimensions = dv;
 
-	      assign (key(p), tmp);
-	    }
-	}
+              assign (key(p), tmp);
+            }
+        }
     }
 }
 
 Octave_map
 Octave_map::concat (const Octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   Octave_map retval;
 
   if (nfields () == rb.nfields ())
     {
       for (const_iterator pa = begin (); pa != end (); pa++)
-	{
-	  const_iterator pb = rb.seek (key(pa));
+        {
+          const_iterator pb = rb.seek (key(pa));
 
-	  if (pb == rb.end ())
-	    {
-	      error ("field name mismatch in structure concatenation");
-	      break;
-	    }
-	
-	  retval.assign (key(pa),
-			 contents(pa).insert (rb.contents(pb), ra_idx));
-	}
+          if (pb == rb.end ())
+            {
+              error ("field name mismatch in structure concatenation");
+              break;
+            }
+        
+          retval.assign (key(pa),
+                         contents(pa).insert (rb.contents(pb), ra_idx));
+        }
 
       // Preserve order of keys.
       retval.key_list = key_list;
     }
   else
     {
       dim_vector dv = dims ();
 
       if (dv.all_zero ())
-	retval = rb;
+        retval = rb;
       else
-	{
-	  dv = rb.dims ();
+        {
+          dv = rb.dims ();
 
-	  if (dv.all_zero ())
-	    retval = *this;
-	  else
-	    error ("invalid structure concatenation");
-	}
+          if (dv.all_zero ())
+            retval = *this;
+          else
+            error ("invalid structure concatenation");
+        }
     }
 
   return retval;
 }
 
 /*
 %!# test preservation of key order by concatenation
 %!test
@@ -310,123 +310,123 @@ keys_ok (const Octave_map& a, const Octa
     {
       string_vector a_keys = a.keys().sort ();
       string_vector b_keys = b.keys().sort ();
 
       octave_idx_type a_len = a_keys.length ();
       octave_idx_type b_len = b_keys.length ();
 
       if (a_len == b_len)
-	{
-	  for (octave_idx_type i = 0; i < a_len; i++)
-	    {
-	      if (a_keys[i] != b_keys[i])
-		goto done;
-	    }
+        {
+          for (octave_idx_type i = 0; i < a_len; i++)
+            {
+              if (a_keys[i] != b_keys[i])
+                goto done;
+            }
 
-	  keys = a_keys;
-	  retval = true;
-	}
+          keys = a_keys;
+          retval = true;
+        }
     }
 
  done:
   return retval;
 }
 
 Octave_map&
 Octave_map::maybe_delete_elements (const octave_value_list& idx)
 {
   string_vector t_keys = keys();
   octave_idx_type len = t_keys.length ();
 
   if (len > 0)
     {
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  std::string k = t_keys[i];
+        {
+          std::string k = t_keys[i];
 
-	  map[k] = contents(k).delete_elements (idx);
+          map[k] = contents(k).delete_elements (idx);
 
-	  if (error_state)
-	    break;
-	}
+          if (error_state)
+            break;
+        }
 
       if (!error_state)
-	dimensions = contents(t_keys[0]).dims();
+        dimensions = contents(t_keys[0]).dims();
     }
 
   return *this;
 }
 
 Octave_map&
 Octave_map::assign (const octave_value_list& idx, const Octave_map& rhs)
 {
   string_vector t_keys;
 
   if (keys_ok (*this, rhs, t_keys))
     {
       octave_idx_type len = t_keys.length ();
 
       if (len == 0)
-	{
-	  Cell tmp_lhs (dims ());
-	  Cell tmp_rhs (rhs.dims ());
+        {
+          Cell tmp_lhs (dims ());
+          Cell tmp_rhs (rhs.dims ());
 
-	  tmp_lhs.assign (idx, tmp_rhs, Matrix ());
+          tmp_lhs.assign (idx, tmp_rhs, Matrix ());
 
-	  if (! error_state)
-	    resize (tmp_lhs.dims ());
-	  else
-	    error ("size mismatch in structure assignment");
-	}
+          if (! error_state)
+            resize (tmp_lhs.dims ());
+          else
+            error ("size mismatch in structure assignment");
+        }
       else
-	{
-	  for (octave_idx_type i = 0; i < len; i++)
-	    {
-	      std::string k = t_keys[i];
+        {
+          for (octave_idx_type i = 0; i < len; i++)
+            {
+              std::string k = t_keys[i];
 
-	      Cell t_rhs = rhs.contents (k);
+              Cell t_rhs = rhs.contents (k);
 
-	      assign (idx, k, t_rhs);
+              assign (idx, k, t_rhs);
 
-	      if (error_state)
-		break;
-	    }
-	}
+              if (error_state)
+                break;
+            }
+        }
     }
   else
     error ("field name mismatch in structure assignment");
 
   return *this;
 }
 
 Octave_map&
 Octave_map::assign (const octave_value_list& idx, const std::string& k,
-		    const Cell& rhs)
+                    const Cell& rhs)
 {
   Cell tmp;
 
   if (contains (k))
     tmp = map[k];
   else
     tmp = Cell (dimensions);
 
   tmp.assign (idx, rhs);
 
   if (! error_state)
     {
       dim_vector tmp_dims = tmp.dims ();
 
       if (tmp_dims != dimensions)
-	{
-	  for (iterator p = begin (); p != end (); p++)
-	    contents(p).resize (tmp_dims, Cell::resize_fill_value ());
+        {
+          for (iterator p = begin (); p != end (); p++)
+            contents(p).resize (tmp_dims, Cell::resize_fill_value ());
 
           dimensions = tmp_dims;
-	}
+        }
 
       maybe_add_to_key_list (k);
 
       map[k] = tmp;
     }
 
   return *this;
 }
@@ -442,23 +442,23 @@ Octave_map::assign (const std::string& k
 
       dimensions = dim_vector (1, 1);
     }
   else
     {
       dim_vector dv = dims ();
 
       if (dv.all_ones ())
-	{
-	  maybe_add_to_key_list (k);
+        {
+          maybe_add_to_key_list (k);
 
-	  map[k] = Cell (rhs);
-	}
+          map[k] = Cell (rhs);
+        }
       else
-	error ("invalid structure assignment");
+        error ("invalid structure assignment");
     }
 
   return *this;
 }
 
 Octave_map&
 Octave_map::assign (const std::string& k, const Cell& rhs)
 {
@@ -468,23 +468,23 @@ Octave_map::assign (const std::string& k
 
       map[k] = rhs;
 
       dimensions = rhs.dims ();
     }
   else
     {
       if (dims () == rhs.dims ())
-	{
-	  maybe_add_to_key_list (k);
+        {
+          maybe_add_to_key_list (k);
 
-	  map[k] = rhs;
-	}
+          map[k] = rhs;
+        }
       else
-	error ("invalid structure assignment");
+        error ("invalid structure assignment");
     }
 
   return *this;
 }
 
 Octave_map
 Octave_map::index (const octave_value_list& idx, bool resize_ok) const
 {
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -119,29 +119,29 @@ octave_value_list::reverse (void)
       elem (n - i - 1) = tmp;
     }
 
   return *this;
 }
 
 octave_value_list
 octave_value_list::splice (octave_idx_type offset, octave_idx_type rep_length,
-			   const octave_value_list& lst) const
+                           const octave_value_list& lst) const
 { 
   octave_value_list retval;
 
   octave_idx_type len = length ();
 
   if (offset < 0 || offset >= len)
     {
       if (! (rep_length == 0 && offset == len))
-	{
-	  error ("octave_value_list::splice: invalid OFFSET");
-	  return retval;
-	}
+        {
+          error ("octave_value_list::splice: invalid OFFSET");
+          return retval;
+        }
     }
 
   if (rep_length < 0 || rep_length + offset > len)
     {
       error ("octave_value_list::splice: invalid LENGTH");
       return retval;
     }
 
@@ -218,49 +218,49 @@ octave_value_list::make_argv (const std:
 
   if (all_strings_p ())
     {
       octave_idx_type len = length ();
 
       octave_idx_type total_nr = 0;
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  // An empty std::string ("") has zero columns and zero rows (a
-	  // change that was made for Matlab contemptibility.
+        {
+          // An empty std::string ("") has zero columns and zero rows (a
+          // change that was made for Matlab contemptibility.
 
-	  octave_idx_type n = elem(i).rows ();
+          octave_idx_type n = elem(i).rows ();
 
-	  total_nr += n ? n : 1;
-	}
+          total_nr += n ? n : 1;
+        }
 
       octave_idx_type k = 0;
       if (! fcn_name.empty ())
         {
           argv.resize (total_nr+1);
           argv[0] = fcn_name;
           k = 1;
         }
       else
         argv.resize (total_nr);
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  octave_idx_type nr = elem(i).rows ();
+        {
+          octave_idx_type nr = elem(i).rows ();
 
-	  if (nr < 2)
-	    argv[k++] = elem(i).string_value ();
-	  else
-	    {
-	      string_vector tmp = elem(i).all_strings ();
+          if (nr < 2)
+            argv[k++] = elem(i).string_value ();
+          else
+            {
+              string_vector tmp = elem(i).all_strings ();
 
-	      for (octave_idx_type j = 0; j < nr; j++)
-		argv[k++] = tmp[j];
-	    }
-	}
+              for (octave_idx_type j = 0; j < nr; j++)
+                argv[k++] = tmp[j];
+            }
+        }
     }
   else
     error ("%s: expecting all arguments to be strings", fcn_name.c_str ());
 
   return argv;
 }
 
 void
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -181,59 +181,59 @@ make_fcn_handle (token *tok_val);
 
 // Build an anonymous function handle.
 static tree_anon_fcn_handle *
 make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt);
 
 // Build a binary expression.
 static tree_expression *
 make_binary_op (int op, tree_expression *op1, token *tok_val,
-		tree_expression *op2);
+                tree_expression *op2);
 
 // Build a boolean expression.
 static tree_expression *
 make_boolean_op (int op, tree_expression *op1, token *tok_val,
-		 tree_expression *op2);
+                 tree_expression *op2);
 
 // Build a prefix expression.
 static tree_expression *
 make_prefix_op (int op, tree_expression *op1, token *tok_val);
 
 // Build a postfix expression.
 static tree_expression *
 make_postfix_op (int op, tree_expression *op1, token *tok_val);
 
 // Build an unwind-protect command.
 static tree_command *
 make_unwind_command (token *unwind_tok, tree_statement_list *body,
-		     tree_statement_list *cleanup, token *end_tok,
-		     octave_comment_list *lc, octave_comment_list *mc);
+                     tree_statement_list *cleanup, token *end_tok,
+                     octave_comment_list *lc, octave_comment_list *mc);
 
 // Build a try-catch command.
 static tree_command *
 make_try_command (token *try_tok, tree_statement_list *body,
-		  tree_statement_list *cleanup, token *end_tok,
-		  octave_comment_list *lc, octave_comment_list *mc);
+                  tree_statement_list *cleanup, token *end_tok,
+                  octave_comment_list *lc, octave_comment_list *mc);
 
 // Build a while command.
 static tree_command *
 make_while_command (token *while_tok, tree_expression *expr,
-		    tree_statement_list *body, token *end_tok,
-		    octave_comment_list *lc);
+                    tree_statement_list *body, token *end_tok,
+                    octave_comment_list *lc);
 
 // Build a do-until command.
 static tree_command *
 make_do_until_command (token *until_tok, tree_statement_list *body,
-		       tree_expression *expr, octave_comment_list *lc);
+                       tree_expression *expr, octave_comment_list *lc);
 
 // Build a for command.
 static tree_command *
 make_for_command (token *for_tok, tree_argument_list *lhs,
-		  tree_expression *expr, tree_statement_list *body,
-		  token *end_tok, octave_comment_list *lc);
+                  tree_expression *expr, tree_statement_list *body,
+                  token *end_tok, octave_comment_list *lc);
 
 // Build a break command.
 static tree_command *
 make_break_command (token *break_tok);
 
 // Build a continue command.
 static tree_command *
 make_continue_command (token *continue_tok);
@@ -244,69 +244,69 @@ make_return_command (token *return_tok);
 
 // Start an if command.
 static tree_if_command_list *
 start_if_command (tree_expression *expr, tree_statement_list *list);
 
 // Finish an if command.
 static tree_if_command *
 finish_if_command (token *if_tok, tree_if_command_list *list,
-		   token *end_tok, octave_comment_list *lc);
+                   token *end_tok, octave_comment_list *lc);
 
 // Build an elseif clause.
 static tree_if_clause *
 make_elseif_clause (token *elseif_tok, tree_expression *expr,
-		    tree_statement_list *list, octave_comment_list *lc);
+                    tree_statement_list *list, octave_comment_list *lc);
 
 // Finish a switch command.
 static tree_switch_command *
 finish_switch_command (token *switch_tok, tree_expression *expr,
-		       tree_switch_case_list *list, token *end_tok,
-		       octave_comment_list *lc);
+                       tree_switch_case_list *list, token *end_tok,
+                       octave_comment_list *lc);
 
 // Build a switch case.
 static tree_switch_case *
 make_switch_case (token *case_tok, tree_expression *expr,
-		  tree_statement_list *list, octave_comment_list *lc);
+                  tree_statement_list *list, octave_comment_list *lc);
 
 // Build an assignment to a variable.
 static tree_expression *
 make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-		tree_expression *rhs);
+                tree_expression *rhs);
 
 // Define a script.
 static void
 make_script (tree_statement_list *cmds, tree_statement *end_script);
 
 // Begin defining a function.
 static octave_user_function *
 start_function (tree_parameter_list *param_list, tree_statement_list *body,
-		tree_statement *end_function);
+                tree_statement *end_function);
 
 // Create a no-op statement for end_function.
 static tree_statement *
 make_end (const std::string& type, int l, int c);
 
 // Do most of the work for defining a function.
 static octave_user_function *
 frob_function (const std::string& fname, octave_user_function *fcn);
 
 // Finish defining a function.
 static tree_function_def *
 finish_function (tree_parameter_list *ret_list,
-		 octave_user_function *fcn, octave_comment_list *lc);
+                 octave_user_function *fcn, octave_comment_list *lc);
 
 // Reset state after parsing function.
 static void
 recover_from_parsing_function (void);
 
 // Make an index expression.
 static tree_index_expression *
 make_index_expression (tree_expression *expr,
-		       tree_argument_list *args, char type);
+                       tree_argument_list *args, char type);
 
 // Make an indirect reference expression.
 static tree_index_expression *
 make_indirect_ref (tree_expression *expr, const std::string&);
 
 // Make an indirect reference expression with dynamic field name.
 static tree_index_expression *
 make_indirect_ref (tree_expression *expr, tree_expression *field);
@@ -336,17 +336,17 @@ static tree_statement_list *
 set_stmt_print_flag (tree_statement_list *, char, bool);
 
 // Create a statement list.
 static tree_statement_list *make_statement_list (tree_statement *stmt);
 
 // Append a statement to an existing statement list.
 static tree_statement_list *
 append_statement_list (tree_statement_list *list, char sep,
-		       tree_statement *stmt, bool warn_missing_semi);
+                       tree_statement *stmt, bool warn_missing_semi);
 
 // Finish building a statement.
 template <class T>
 static tree_statement *
 make_statement (T *arg)
 {
   octave_comment_list *comment = octave_comment_buffer::get_comment ();
 
@@ -355,23 +355,23 @@ make_statement (T *arg)
 
 #define ABORT_PARSE \
   do \
     { \
       global_command = 0; \
       yyerrok; \
       if (! symtab_context.empty ()) \
         { \
-	  symbol_table::set_scope (symtab_context.top ()); \
-	  symtab_context.pop (); \
+          symbol_table::set_scope (symtab_context.top ()); \
+          symtab_context.pop (); \
         } \
       if (interactive || forced_interactive) \
-	YYACCEPT; \
+        YYACCEPT; \
       else \
-	YYABORT; \
+        YYABORT; \
     } \
   while (0)
 
 %}
 
 // Bison declarations.
 
 // Don't add spaces around the = here; it causes some versions of
@@ -527,1120 +527,1120 @@ make_statement (T *arg)
 %start input
 
 %%
 
 // ==============================
 // Statements and statement lists
 // ==============================
 
-input		: input1
-		  {
-		    global_command = $1;
-		    promptflag = 1;
-		    YYACCEPT;
-		  }
-		| function_file
-		  {
-		    YYACCEPT;
-		  }
-		| simple_list parse_error
-		  { ABORT_PARSE; }
-		| parse_error
-		  { ABORT_PARSE; }
-		;
-
-input1		: '\n'
-		  { $$ = 0; }
-		| END_OF_INPUT
-		  {
-		    parser_end_of_input = 1;
-		    $$ = 0;
-		  }
-		| simple_list
-		  { $$ = $1; }
-		| simple_list '\n'
-		  { $$ = $1; }
-		| simple_list END_OF_INPUT
-		  { $$ = $1; }
-		;
-
-simple_list	: simple_list1 opt_sep_no_nl
-		  { $$ = set_stmt_print_flag ($1, $2, false); }
-		;
-
-simple_list1	: statement
-		  { $$ = make_statement_list ($1); }
-		| simple_list1 sep_no_nl statement
-		  { $$ = append_statement_list ($1, $2, $3, false); }
-		;
-
-opt_list	: // empty
-		  { $$ = new tree_statement_list (); }
-		| list
-		  { $$ = $1; }
-		;
-
-list		: list1 opt_sep
-		  { $$ = set_stmt_print_flag ($1, $2, true); }
-		;
-
-list1		: statement
-		  { $$ = make_statement_list ($1); }
-		| list1 sep statement
-		  { $$ = append_statement_list ($1, $2, $3, true); }
-		;
-
-statement	: expression
-		  { $$ = make_statement ($1); }
-		| command
-		  { $$ = make_statement ($1); }
-		| word_list_cmd
-		  { $$ = make_statement ($1); }
-		;
+input           : input1
+                  {
+                    global_command = $1;
+                    promptflag = 1;
+                    YYACCEPT;
+                  }
+                | function_file
+                  {
+                    YYACCEPT;
+                  }
+                | simple_list parse_error
+                  { ABORT_PARSE; }
+                | parse_error
+                  { ABORT_PARSE; }
+                ;
+
+input1          : '\n'
+                  { $$ = 0; }
+                | END_OF_INPUT
+                  {
+                    parser_end_of_input = 1;
+                    $$ = 0;
+                  }
+                | simple_list
+                  { $$ = $1; }
+                | simple_list '\n'
+                  { $$ = $1; }
+                | simple_list END_OF_INPUT
+                  { $$ = $1; }
+                ;
+
+simple_list     : simple_list1 opt_sep_no_nl
+                  { $$ = set_stmt_print_flag ($1, $2, false); }
+                ;
+
+simple_list1    : statement
+                  { $$ = make_statement_list ($1); }
+                | simple_list1 sep_no_nl statement
+                  { $$ = append_statement_list ($1, $2, $3, false); }
+                ;
+
+opt_list        : // empty
+                  { $$ = new tree_statement_list (); }
+                | list
+                  { $$ = $1; }
+                ;
+
+list            : list1 opt_sep
+                  { $$ = set_stmt_print_flag ($1, $2, true); }
+                ;
+
+list1           : statement
+                  { $$ = make_statement_list ($1); }
+                | list1 sep statement
+                  { $$ = append_statement_list ($1, $2, $3, true); }
+                ;
+
+statement       : expression
+                  { $$ = make_statement ($1); }
+                | command
+                  { $$ = make_statement ($1); }
+                | word_list_cmd
+                  { $$ = make_statement ($1); }
+                ;
 
 // =================
 // Word-list command
 // =================
 
 // These are not really like expressions since they can't appear on
 // the RHS of an assignment.  But they are also not like commands (IF,
 // WHILE, etc.
 
-word_list_cmd	: identifier word_list
-		  { $$ = make_index_expression ($1, $2, '('); }
-		;
-
-word_list	: string
-		  { $$ = new tree_argument_list ($1); }
-		| word_list string
-		  {
-		    $1->append ($2);
-		    $$ = $1;
-		  }
-		;
+word_list_cmd   : identifier word_list
+                  { $$ = make_index_expression ($1, $2, '('); }
+                ;
+
+word_list       : string
+                  { $$ = new tree_argument_list ($1); }
+                | word_list string
+                  {
+                    $1->append ($2);
+                    $$ = $1;
+                  }
+                ;
 
 // ===========
 // Expressions
 // ===========
 
-identifier	: NAME
-		  {
-		    symbol_table::symbol_record *sr = $1->sym_rec ();
-		    $$ = new tree_identifier (*sr, $1->line (), $1->column ());
-		  }
-		;
+identifier      : NAME
+                  {
+                    symbol_table::symbol_record *sr = $1->sym_rec ();
+                    $$ = new tree_identifier (*sr, $1->line (), $1->column ());
+                  }
+                ;
 
 superclass_identifier
-		: SUPERCLASSREF
-		  { $$ = new tree_identifier ($1->line (), $1->column ()); }
-		;
-	    
-meta_identifier	: METAQUERY
-		  { $$ = new tree_identifier ($1->line (), $1->column ()); }
-		;	    
-
-string		: DQ_STRING
-		  { $$ = make_constant (DQ_STRING, $1); }
-		| SQ_STRING
-		  { $$ = make_constant (SQ_STRING, $1); }
-		;
-
-constant	: NUM
-		  { $$ = make_constant (NUM, $1); }
-		| IMAG_NUM
-		  { $$ = make_constant (IMAG_NUM, $1); }
-		| string
-		  { $$ = $1; }
-		;
-
-matrix		: '[' ']'
-		  {
-		    $$ = new tree_constant (octave_null_matrix::instance);
-		    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-		    lexer_flags.pending_local_variables.clear ();
-		  }
-		| '[' ';' ']'
-		  {
-		    $$ = new tree_constant (octave_null_matrix::instance);
-		    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-		    lexer_flags.pending_local_variables.clear ();
-		  }
-		| '[' ',' ']'
-		  {
-		    $$ = new tree_constant (octave_null_matrix::instance);
-		    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-		    lexer_flags.pending_local_variables.clear ();
-		  }
-		| '[' matrix_rows ']'
-		  {
-		    $$ = finish_matrix ($2);
-		    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-		    lexer_flags.pending_local_variables.clear ();
-		  }
-		;
-
-matrix_rows	: matrix_rows1
-		  { $$ = $1; }
-		| matrix_rows1 ';'	// Ignore trailing semicolon.
-		  { $$ = $1; }
-		;
-
-matrix_rows1	: cell_or_matrix_row
-		  { $$ = new tree_matrix ($1); }
-		| matrix_rows1 ';' cell_or_matrix_row
-		  {
-		    $1->append ($3);
-		    $$ = $1;
-		  }
-		;
-
-cell		: '{' '}'
-		  { $$ = new tree_constant (octave_value (Cell ())); }
-		| '{' ';' '}'
-		  { $$ = new tree_constant (octave_value (Cell ())); }
-		| '{' cell_rows '}'
-		  { $$ = finish_cell ($2); }
-		;
-
-cell_rows	: cell_rows1
-		  { $$ = $1; }
-		| cell_rows1 ';'	// Ignore trailing semicolon.
-		  { $$ = $1; }
-		;
-
-cell_rows1	: cell_or_matrix_row
-		  { $$ = new tree_cell ($1); }
-		| cell_rows1 ';' cell_or_matrix_row
-		  {
-		    $1->append ($3);
-		    $$ = $1;
-		  }
-		;
+                : SUPERCLASSREF
+                  { $$ = new tree_identifier ($1->line (), $1->column ()); }
+                ;
+            
+meta_identifier : METAQUERY
+                  { $$ = new tree_identifier ($1->line (), $1->column ()); }
+                ;           
+
+string          : DQ_STRING
+                  { $$ = make_constant (DQ_STRING, $1); }
+                | SQ_STRING
+                  { $$ = make_constant (SQ_STRING, $1); }
+                ;
+
+constant        : NUM
+                  { $$ = make_constant (NUM, $1); }
+                | IMAG_NUM
+                  { $$ = make_constant (IMAG_NUM, $1); }
+                | string
+                  { $$ = $1; }
+                ;
+
+matrix          : '[' ']'
+                  {
+                    $$ = new tree_constant (octave_null_matrix::instance);
+                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
+                    lexer_flags.pending_local_variables.clear ();
+                  }
+                | '[' ';' ']'
+                  {
+                    $$ = new tree_constant (octave_null_matrix::instance);
+                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
+                    lexer_flags.pending_local_variables.clear ();
+                  }
+                | '[' ',' ']'
+                  {
+                    $$ = new tree_constant (octave_null_matrix::instance);
+                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
+                    lexer_flags.pending_local_variables.clear ();
+                  }
+                | '[' matrix_rows ']'
+                  {
+                    $$ = finish_matrix ($2);
+                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
+                    lexer_flags.pending_local_variables.clear ();
+                  }
+                ;
+
+matrix_rows     : matrix_rows1
+                  { $$ = $1; }
+                | matrix_rows1 ';'      // Ignore trailing semicolon.
+                  { $$ = $1; }
+                ;
+
+matrix_rows1    : cell_or_matrix_row
+                  { $$ = new tree_matrix ($1); }
+                | matrix_rows1 ';' cell_or_matrix_row
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
+                ;
+
+cell            : '{' '}'
+                  { $$ = new tree_constant (octave_value (Cell ())); }
+                | '{' ';' '}'
+                  { $$ = new tree_constant (octave_value (Cell ())); }
+                | '{' cell_rows '}'
+                  { $$ = finish_cell ($2); }
+                ;
+
+cell_rows       : cell_rows1
+                  { $$ = $1; }
+                | cell_rows1 ';'        // Ignore trailing semicolon.
+                  { $$ = $1; }
+                ;
+
+cell_rows1      : cell_or_matrix_row
+                  { $$ = new tree_cell ($1); }
+                | cell_rows1 ';' cell_or_matrix_row
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
+                ;
 
 cell_or_matrix_row
-		: arg_list
-		  { $$ = validate_matrix_row ($1); }
-		| arg_list ','	// Ignore trailing comma.
-		  { $$ = validate_matrix_row ($1); }
-		;
-
-fcn_handle	: '@' FCN_HANDLE
-		  {
-		    $$ = make_fcn_handle ($2);
-		    lexer_flags.looking_at_function_handle--;
-		  }
-		;
-
-anon_fcn_handle	: '@' param_list statement
-		  { $$ = make_anon_fcn_handle ($2, $3); }
-		;
-	
-primary_expr	: identifier
-		  { $$ = $1; }
-		| constant
-		  { $$ = $1; }
-		| fcn_handle
-		  { $$ = $1; }
-		| matrix
-		  { $$ = $1; }
-		| cell
-		  { $$ = $1; }
-		| meta_identifier
-		  { $$ = $1; }
-		| superclass_identifier
-		  { $$ = $1; }
-		| '(' expression ')'
-		  { $$ = $2->mark_in_parens (); }
-		;
-
-magic_colon	: ':'
-		  {
-		    octave_value tmp (octave_value::magic_colon_t);
-		    $$ = new tree_constant (tmp);
-		  }
-		;
-
-magic_tilde	: EXPR_NOT
-		  {
-		    $$ = new tree_black_hole ();
-		  }
-		;
-
-arg_list	: expression
-		  { $$ = new tree_argument_list ($1); }
-		| magic_colon
-		  { $$ = new tree_argument_list ($1); }
-		| magic_tilde
-		  { $$ = new tree_argument_list ($1); }
-		| arg_list ',' magic_colon
-		  {
-		    $1->append ($3);
-		    $$ = $1;
-		  }
-		| arg_list ',' magic_tilde
-		  {
-		    $1->append ($3);
-		    $$ = $1;
-		  }
-		| arg_list ',' expression
-		  {
-		    $1->append ($3);
-		    $$ = $1;
-		  }
-		;
-
-indirect_ref_op	: '.'
-		  { lexer_flags.looking_at_indirect_ref = true; }
-		;
-
-postfix_expr	: primary_expr
-		  { $$ = $1; }
-		| postfix_expr '(' ')'
-		  { $$ = make_index_expression ($1, 0, '('); }
-		| postfix_expr '(' arg_list ')'
-		  { $$ = make_index_expression ($1, $3, '('); }
-		| postfix_expr '{' '}'
-		  { $$ = make_index_expression ($1, 0, '{'); }
-		| postfix_expr '{' arg_list '}'
-		  { $$ = make_index_expression ($1, $3, '{'); }
-		| postfix_expr PLUS_PLUS
-		  { $$ = make_postfix_op (PLUS_PLUS, $1, $2); }
-		| postfix_expr MINUS_MINUS
-		  { $$ = make_postfix_op (MINUS_MINUS, $1, $2); }
-		| postfix_expr QUOTE
-		  { $$ = make_postfix_op (QUOTE, $1, $2); }
-		| postfix_expr TRANSPOSE
-		  { $$ = make_postfix_op (TRANSPOSE, $1, $2); }
-		| postfix_expr indirect_ref_op STRUCT_ELT
-		  { $$ = make_indirect_ref ($1, $3->text ()); }
-		| postfix_expr indirect_ref_op '(' expression ')'
-		  { $$ = make_indirect_ref ($1, $4); }
-		;
-
-prefix_expr	: postfix_expr
-		  { $$ = $1; }
-		| binary_expr
-		  { $$ = $1; }
-		| PLUS_PLUS prefix_expr %prec UNARY
-		  { $$ = make_prefix_op (PLUS_PLUS, $2, $1); }
-		| MINUS_MINUS prefix_expr %prec UNARY
-		  { $$ = make_prefix_op (MINUS_MINUS, $2, $1); }
-		| EXPR_NOT prefix_expr %prec UNARY
-		  { $$ = make_prefix_op (EXPR_NOT, $2, $1); }
-		| '+' prefix_expr %prec UNARY
-		  { $$ = make_prefix_op ('+', $2, $1); }
-		| '-' prefix_expr %prec UNARY
-		  { $$ = make_prefix_op ('-', $2, $1); }
-		;
-
-binary_expr	: prefix_expr POW prefix_expr
-		  { $$ = make_binary_op (POW, $1, $2, $3); }
-		| prefix_expr EPOW prefix_expr
-		  { $$ = make_binary_op (EPOW, $1, $2, $3); }
-		| prefix_expr '+' prefix_expr
-		  { $$ = make_binary_op ('+', $1, $2, $3); }
-		| prefix_expr '-' prefix_expr
-		  { $$ = make_binary_op ('-', $1, $2, $3); }
-		| prefix_expr '*' prefix_expr
-		  { $$ = make_binary_op ('*', $1, $2, $3); }
-		| prefix_expr '/' prefix_expr
-		  { $$ = make_binary_op ('/', $1, $2, $3); }
-		| prefix_expr EPLUS prefix_expr
-		  { $$ = make_binary_op ('+', $1, $2, $3); }
-		| prefix_expr EMINUS prefix_expr
-		  { $$ = make_binary_op ('-', $1, $2, $3); }
-		| prefix_expr EMUL prefix_expr
-		  { $$ = make_binary_op (EMUL, $1, $2, $3); }
-		| prefix_expr EDIV prefix_expr
-		  { $$ = make_binary_op (EDIV, $1, $2, $3); }
-		| prefix_expr LEFTDIV prefix_expr
-		  { $$ = make_binary_op (LEFTDIV, $1, $2, $3); }
-		| prefix_expr ELEFTDIV prefix_expr
-		  { $$ = make_binary_op (ELEFTDIV, $1, $2, $3); }
-		;
-
-colon_expr	: colon_expr1
-		  { $$ = finish_colon_expression ($1); }
-		;
-
-colon_expr1	: prefix_expr
-		  { $$ = new tree_colon_expression ($1); }
-		| colon_expr1 ':' prefix_expr
-		  {
-		    if (! ($$ = $1->append ($3)))
-		      ABORT_PARSE;
-		  }
-		;
-
-simple_expr	: colon_expr
-		  { $$ = $1; }
-		| simple_expr LSHIFT simple_expr
-		  { $$ = make_binary_op (LSHIFT, $1, $2, $3); }
-		| simple_expr RSHIFT simple_expr
-		  { $$ = make_binary_op (RSHIFT, $1, $2, $3); }
-		| simple_expr EXPR_LT simple_expr
-		  { $$ = make_binary_op (EXPR_LT, $1, $2, $3); }
-		| simple_expr EXPR_LE simple_expr
-		  { $$ = make_binary_op (EXPR_LE, $1, $2, $3); }
-		| simple_expr EXPR_EQ simple_expr
-		  { $$ = make_binary_op (EXPR_EQ, $1, $2, $3); }
-		| simple_expr EXPR_GE simple_expr
-		  { $$ = make_binary_op (EXPR_GE, $1, $2, $3); }
-		| simple_expr EXPR_GT simple_expr
-		  { $$ = make_binary_op (EXPR_GT, $1, $2, $3); }
-		| simple_expr EXPR_NE simple_expr
-		  { $$ = make_binary_op (EXPR_NE, $1, $2, $3); }
-		| simple_expr EXPR_AND simple_expr
-		  { $$ = make_binary_op (EXPR_AND, $1, $2, $3); }
-		| simple_expr EXPR_OR simple_expr
-		  { $$ = make_binary_op (EXPR_OR, $1, $2, $3); }
-		| simple_expr EXPR_AND_AND simple_expr
-		  { $$ = make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
-		| simple_expr EXPR_OR_OR simple_expr
-		  { $$ = make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
-		;
+                : arg_list
+                  { $$ = validate_matrix_row ($1); }
+                | arg_list ','  // Ignore trailing comma.
+                  { $$ = validate_matrix_row ($1); }
+                ;
+
+fcn_handle      : '@' FCN_HANDLE
+                  {
+                    $$ = make_fcn_handle ($2);
+                    lexer_flags.looking_at_function_handle--;
+                  }
+                ;
+
+anon_fcn_handle : '@' param_list statement
+                  { $$ = make_anon_fcn_handle ($2, $3); }
+                ;
+        
+primary_expr    : identifier
+                  { $$ = $1; }
+                | constant
+                  { $$ = $1; }
+                | fcn_handle
+                  { $$ = $1; }
+                | matrix
+                  { $$ = $1; }
+                | cell
+                  { $$ = $1; }
+                | meta_identifier
+                  { $$ = $1; }
+                | superclass_identifier
+                  { $$ = $1; }
+                | '(' expression ')'
+                  { $$ = $2->mark_in_parens (); }
+                ;
+
+magic_colon     : ':'
+                  {
+                    octave_value tmp (octave_value::magic_colon_t);
+                    $$ = new tree_constant (tmp);
+                  }
+                ;
+
+magic_tilde     : EXPR_NOT
+                  {
+                    $$ = new tree_black_hole ();
+                  }
+                ;
+
+arg_list        : expression
+                  { $$ = new tree_argument_list ($1); }
+                | magic_colon
+                  { $$ = new tree_argument_list ($1); }
+                | magic_tilde
+                  { $$ = new tree_argument_list ($1); }
+                | arg_list ',' magic_colon
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
+                | arg_list ',' magic_tilde
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
+                | arg_list ',' expression
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
+                ;
+
+indirect_ref_op : '.'
+                  { lexer_flags.looking_at_indirect_ref = true; }
+                ;
+
+postfix_expr    : primary_expr
+                  { $$ = $1; }
+                | postfix_expr '(' ')'
+                  { $$ = make_index_expression ($1, 0, '('); }
+                | postfix_expr '(' arg_list ')'
+                  { $$ = make_index_expression ($1, $3, '('); }
+                | postfix_expr '{' '}'
+                  { $$ = make_index_expression ($1, 0, '{'); }
+                | postfix_expr '{' arg_list '}'
+                  { $$ = make_index_expression ($1, $3, '{'); }
+                | postfix_expr PLUS_PLUS
+                  { $$ = make_postfix_op (PLUS_PLUS, $1, $2); }
+                | postfix_expr MINUS_MINUS
+                  { $$ = make_postfix_op (MINUS_MINUS, $1, $2); }
+                | postfix_expr QUOTE
+                  { $$ = make_postfix_op (QUOTE, $1, $2); }
+                | postfix_expr TRANSPOSE
+                  { $$ = make_postfix_op (TRANSPOSE, $1, $2); }
+                | postfix_expr indirect_ref_op STRUCT_ELT
+                  { $$ = make_indirect_ref ($1, $3->text ()); }
+                | postfix_expr indirect_ref_op '(' expression ')'
+                  { $$ = make_indirect_ref ($1, $4); }
+                ;
+
+prefix_expr     : postfix_expr
+                  { $$ = $1; }
+                | binary_expr
+                  { $$ = $1; }
+                | PLUS_PLUS prefix_expr %prec UNARY
+                  { $$ = make_prefix_op (PLUS_PLUS, $2, $1); }
+                | MINUS_MINUS prefix_expr %prec UNARY
+                  { $$ = make_prefix_op (MINUS_MINUS, $2, $1); }
+                | EXPR_NOT prefix_expr %prec UNARY
+                  { $$ = make_prefix_op (EXPR_NOT, $2, $1); }
+                | '+' prefix_expr %prec UNARY
+                  { $$ = make_prefix_op ('+', $2, $1); }
+                | '-' prefix_expr %prec UNARY
+                  { $$ = make_prefix_op ('-', $2, $1); }
+                ;
+
+binary_expr     : prefix_expr POW prefix_expr
+                  { $$ = make_binary_op (POW, $1, $2, $3); }
+                | prefix_expr EPOW prefix_expr
+                  { $$ = make_binary_op (EPOW, $1, $2, $3); }
+                | prefix_expr '+' prefix_expr
+                  { $$ = make_binary_op ('+', $1, $2, $3); }
+                | prefix_expr '-' prefix_expr
+                  { $$ = make_binary_op ('-', $1, $2, $3); }
+                | prefix_expr '*' prefix_expr
+                  { $$ = make_binary_op ('*', $1, $2, $3); }
+                | prefix_expr '/' prefix_expr
+                  { $$ = make_binary_op ('/', $1, $2, $3); }
+                | prefix_expr EPLUS prefix_expr
+                  { $$ = make_binary_op ('+', $1, $2, $3); }
+                | prefix_expr EMINUS prefix_expr
+                  { $$ = make_binary_op ('-', $1, $2, $3); }
+                | prefix_expr EMUL prefix_expr
+                  { $$ = make_binary_op (EMUL, $1, $2, $3); }
+                | prefix_expr EDIV prefix_expr
+                  { $$ = make_binary_op (EDIV, $1, $2, $3); }
+                | prefix_expr LEFTDIV prefix_expr
+                  { $$ = make_binary_op (LEFTDIV, $1, $2, $3); }
+                | prefix_expr ELEFTDIV prefix_expr
+                  { $$ = make_binary_op (ELEFTDIV, $1, $2, $3); }
+                ;
+
+colon_expr      : colon_expr1
+                  { $$ = finish_colon_expression ($1); }
+                ;
+
+colon_expr1     : prefix_expr
+                  { $$ = new tree_colon_expression ($1); }
+                | colon_expr1 ':' prefix_expr
+                  {
+                    if (! ($$ = $1->append ($3)))
+                      ABORT_PARSE;
+                  }
+                ;
+
+simple_expr     : colon_expr
+                  { $$ = $1; }
+                | simple_expr LSHIFT simple_expr
+                  { $$ = make_binary_op (LSHIFT, $1, $2, $3); }
+                | simple_expr RSHIFT simple_expr
+                  { $$ = make_binary_op (RSHIFT, $1, $2, $3); }
+                | simple_expr EXPR_LT simple_expr
+                  { $$ = make_binary_op (EXPR_LT, $1, $2, $3); }
+                | simple_expr EXPR_LE simple_expr
+                  { $$ = make_binary_op (EXPR_LE, $1, $2, $3); }
+                | simple_expr EXPR_EQ simple_expr
+                  { $$ = make_binary_op (EXPR_EQ, $1, $2, $3); }
+                | simple_expr EXPR_GE simple_expr
+                  { $$ = make_binary_op (EXPR_GE, $1, $2, $3); }
+                | simple_expr EXPR_GT simple_expr
+                  { $$ = make_binary_op (EXPR_GT, $1, $2, $3); }
+                | simple_expr EXPR_NE simple_expr
+                  { $$ = make_binary_op (EXPR_NE, $1, $2, $3); }
+                | simple_expr EXPR_AND simple_expr
+                  { $$ = make_binary_op (EXPR_AND, $1, $2, $3); }
+                | simple_expr EXPR_OR simple_expr
+                  { $$ = make_binary_op (EXPR_OR, $1, $2, $3); }
+                | simple_expr EXPR_AND_AND simple_expr
+                  { $$ = make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
+                | simple_expr EXPR_OR_OR simple_expr
+                  { $$ = make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
+                ;
 
 // Arrange for the lexer to return CLOSE_BRACE for `]' by looking ahead
 // one token for an assignment op.
 
-assign_lhs	: simple_expr
-		  {
-		    $$ = new tree_argument_list ($1);
-		    $$->mark_as_simple_assign_lhs ();
-		  }
-		| '[' arg_list CLOSE_BRACE
-		  {
-		    $$ = $2;
-		    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-		    for (std::set<std::string>::const_iterator p = lexer_flags.pending_local_variables.begin ();
-			 p != lexer_flags.pending_local_variables.end ();
-			 p++)
-		      {
-			symbol_table::force_variable (*p);
-		      }
-		    lexer_flags.pending_local_variables.clear ();
-		  }
-		;
-
-assign_expr	: assign_lhs '=' expression
-		  { $$ = make_assign_op ('=', $1, $2, $3); }
-		| assign_lhs ADD_EQ expression
-		  { $$ = make_assign_op (ADD_EQ, $1, $2, $3); }
-		| assign_lhs SUB_EQ expression
-		  { $$ = make_assign_op (SUB_EQ, $1, $2, $3); }
-		| assign_lhs MUL_EQ expression
-		  { $$ = make_assign_op (MUL_EQ, $1, $2, $3); }
-		| assign_lhs DIV_EQ expression
-		  { $$ = make_assign_op (DIV_EQ, $1, $2, $3); }
-		| assign_lhs LEFTDIV_EQ expression
-		  { $$ = make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
-		| assign_lhs POW_EQ expression
-		  { $$ = make_assign_op (POW_EQ, $1, $2, $3); }
-		| assign_lhs LSHIFT_EQ expression
-		  { $$ = make_assign_op (LSHIFT_EQ, $1, $2, $3); }
-		| assign_lhs RSHIFT_EQ expression
-		  { $$ = make_assign_op (RSHIFT_EQ, $1, $2, $3); }
-		| assign_lhs EMUL_EQ expression
-		  { $$ = make_assign_op (EMUL_EQ, $1, $2, $3); }
-		| assign_lhs EDIV_EQ expression
-		  { $$ = make_assign_op (EDIV_EQ, $1, $2, $3); }
-		| assign_lhs ELEFTDIV_EQ expression
-		  { $$ = make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
-		| assign_lhs EPOW_EQ expression
-		  { $$ = make_assign_op (EPOW_EQ, $1, $2, $3); }
-		| assign_lhs AND_EQ expression
-		  { $$ = make_assign_op (AND_EQ, $1, $2, $3); }
-		| assign_lhs OR_EQ expression
-		  { $$ = make_assign_op (OR_EQ, $1, $2, $3); }
-		;
-
-expression	: simple_expr
-		  { $$ = $1; }
-		| assign_expr
-		  { $$ = $1; }
-		| anon_fcn_handle
-		  { $$ = $1; }
-		;
+assign_lhs      : simple_expr
+                  {
+                    $$ = new tree_argument_list ($1);
+                    $$->mark_as_simple_assign_lhs ();
+                  }
+                | '[' arg_list CLOSE_BRACE
+                  {
+                    $$ = $2;
+                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
+                    for (std::set<std::string>::const_iterator p = lexer_flags.pending_local_variables.begin ();
+                         p != lexer_flags.pending_local_variables.end ();
+                         p++)
+                      {
+                        symbol_table::force_variable (*p);
+                      }
+                    lexer_flags.pending_local_variables.clear ();
+                  }
+                ;
+
+assign_expr     : assign_lhs '=' expression
+                  { $$ = make_assign_op ('=', $1, $2, $3); }
+                | assign_lhs ADD_EQ expression
+                  { $$ = make_assign_op (ADD_EQ, $1, $2, $3); }
+                | assign_lhs SUB_EQ expression
+                  { $$ = make_assign_op (SUB_EQ, $1, $2, $3); }
+                | assign_lhs MUL_EQ expression
+                  { $$ = make_assign_op (MUL_EQ, $1, $2, $3); }
+                | assign_lhs DIV_EQ expression
+                  { $$ = make_assign_op (DIV_EQ, $1, $2, $3); }
+                | assign_lhs LEFTDIV_EQ expression
+                  { $$ = make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
+                | assign_lhs POW_EQ expression
+                  { $$ = make_assign_op (POW_EQ, $1, $2, $3); }
+                | assign_lhs LSHIFT_EQ expression
+                  { $$ = make_assign_op (LSHIFT_EQ, $1, $2, $3); }
+                | assign_lhs RSHIFT_EQ expression
+                  { $$ = make_assign_op (RSHIFT_EQ, $1, $2, $3); }
+                | assign_lhs EMUL_EQ expression
+                  { $$ = make_assign_op (EMUL_EQ, $1, $2, $3); }
+                | assign_lhs EDIV_EQ expression
+                  { $$ = make_assign_op (EDIV_EQ, $1, $2, $3); }
+                | assign_lhs ELEFTDIV_EQ expression
+                  { $$ = make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
+                | assign_lhs EPOW_EQ expression
+                  { $$ = make_assign_op (EPOW_EQ, $1, $2, $3); }
+                | assign_lhs AND_EQ expression
+                  { $$ = make_assign_op (AND_EQ, $1, $2, $3); }
+                | assign_lhs OR_EQ expression
+                  { $$ = make_assign_op (OR_EQ, $1, $2, $3); }
+                ;
+
+expression      : simple_expr
+                  { $$ = $1; }
+                | assign_expr
+                  { $$ = $1; }
+                | anon_fcn_handle
+                  { $$ = $1; }
+                ;
 
 // ================================================
 // Commands, declarations, and function definitions
 // ================================================
 
-command		: declaration
-		  { $$ = $1; }
-		| select_command
-		  { $$ = $1; }
-		| loop_command
-		  { $$ = $1; }
-		| jump_command
-		  { $$ = $1; }
-		| except_command
-		  { $$ = $1; }
-		| function
-		  { $$ = $1; }
-		| script_file
-		  { $$ = $1; }
-		| classdef
-		  { $$ = $1; }
-		;
+command         : declaration
+                  { $$ = $1; }
+                | select_command
+                  { $$ = $1; }
+                | loop_command
+                  { $$ = $1; }
+                | jump_command
+                  { $$ = $1; }
+                | except_command
+                  { $$ = $1; }
+                | function
+                  { $$ = $1; }
+                | script_file
+                  { $$ = $1; }
+                | classdef
+                  { $$ = $1; }
+                ;
 
 // =====================
 // Declaration statemnts
 // =====================
 
 parsing_decl_list
-		: // empty
-		  { lexer_flags.looking_at_decl_list = true; }
-
-declaration	: GLOBAL parsing_decl_list decl1
-		  {
-		    $$ = make_decl_command (GLOBAL, $1, $3);
-		    lexer_flags.looking_at_decl_list = false;
-		  }
-		| STATIC parsing_decl_list decl1
-		  {
-		    $$ = make_decl_command (STATIC, $1, $3);
-		    lexer_flags.looking_at_decl_list = false;
-		  }
-		;
-
-decl1		: decl2
-		  { $$ = new tree_decl_init_list ($1); }
-		| decl1 decl2
-		  {
-		    $1->append ($2);
-		    $$ = $1;
-		  }
-		;
+                : // empty
+                  { lexer_flags.looking_at_decl_list = true; }
+
+declaration     : GLOBAL parsing_decl_list decl1
+                  {
+                    $$ = make_decl_command (GLOBAL, $1, $3);
+                    lexer_flags.looking_at_decl_list = false;
+                  }
+                | STATIC parsing_decl_list decl1
+                  {
+                    $$ = make_decl_command (STATIC, $1, $3);
+                    lexer_flags.looking_at_decl_list = false;
+                  }
+                ;
+
+decl1           : decl2
+                  { $$ = new tree_decl_init_list ($1); }
+                | decl1 decl2
+                  {
+                    $1->append ($2);
+                    $$ = $1;
+                  }
+                ;
 
 decl_param_init : // empty
-		{ lexer_flags.looking_at_initializer_expression = true; }
-
-decl2		: identifier
-		  { $$ = new tree_decl_elt ($1); }
-		| identifier '=' decl_param_init expression
-		  {
-		    lexer_flags.looking_at_initializer_expression = false;
-		    $$ = new tree_decl_elt ($1, $4);
-		  }
+                { lexer_flags.looking_at_initializer_expression = true; }
+
+decl2           : identifier
+                  { $$ = new tree_decl_elt ($1); }
+                | identifier '=' decl_param_init expression
+                  {
+                    lexer_flags.looking_at_initializer_expression = false;
+                    $$ = new tree_decl_elt ($1, $4);
+                  }
                 | magic_tilde
                   {
                     $$ = new tree_decl_elt ($1);
                   }
-		;
+                ;
 
 // ====================
 // Selection statements
 // ====================
 
-select_command	: if_command
-		  { $$ = $1; }
-		| switch_command
-		  { $$ = $1; }
-		;
+select_command  : if_command
+                  { $$ = $1; }
+                | switch_command
+                  { $$ = $1; }
+                ;
 
 // ============
 // If statement
 // ============
 
-if_command	: IF stash_comment if_cmd_list END
-		  {
-		    if (! ($$ = finish_if_command ($1, $3, $4, $2)))
-		      ABORT_PARSE;
-		  }
-		;
-
-if_cmd_list	: if_cmd_list1
-		  { $$ = $1; }
-		| if_cmd_list1 else_clause
-		  {
-		    $1->append ($2);
-		    $$ = $1;
-		  }
-		;
-
-if_cmd_list1	: expression opt_sep opt_list
-		  { $$ = start_if_command ($1, $3); }
-		| if_cmd_list1 elseif_clause
-		  {
-		    $1->append ($2);
-		    $$ = $1;
-		  }
-		;
-
-elseif_clause	: ELSEIF stash_comment opt_sep expression opt_sep opt_list
-		  { $$ = make_elseif_clause ($1, $4, $6, $2); }
-		;
-
-else_clause	: ELSE stash_comment opt_sep opt_list
-		  { $$ = new tree_if_clause ($4, $2); }
-		;
+if_command      : IF stash_comment if_cmd_list END
+                  {
+                    if (! ($$ = finish_if_command ($1, $3, $4, $2)))
+                      ABORT_PARSE;
+                  }
+                ;
+
+if_cmd_list     : if_cmd_list1
+                  { $$ = $1; }
+                | if_cmd_list1 else_clause
+                  {
+                    $1->append ($2);
+                    $$ = $1;
+                  }
+                ;
+
+if_cmd_list1    : expression opt_sep opt_list
+                  { $$ = start_if_command ($1, $3); }
+                | if_cmd_list1 elseif_clause
+                  {
+                    $1->append ($2);
+                    $$ = $1;
+                  }
+                ;
+
+elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
+                  { $$ = make_elseif_clause ($1, $4, $6, $2); }
+                ;
+
+else_clause     : ELSE stash_comment opt_sep opt_list
+                  { $$ = new tree_if_clause ($4, $2); }
+                ;
 
 // ================
 // Switch statement
 // ================
 
-switch_command	: SWITCH stash_comment expression opt_sep case_list END
-		  {
-		    if (! ($$ = finish_switch_command ($1, $3, $5, $6, $2)))
-		      ABORT_PARSE;
-		  }
-		;
-
-case_list	: // empty
-		  { $$ = new tree_switch_case_list (); }
-		| case_list1
-		  { $$ = $1; }
-		| case_list1 default_case
-		  {
-		    $1->append ($2);
-		    $$ = $1;
-		  }		
-		;
-
-case_list1	: switch_case
-		  { $$ = new tree_switch_case_list ($1); }
-		| case_list1 switch_case
-		  {
-		    $1->append ($2);
-		    $$ = $1;
-		  }
-		;
-
-switch_case	: CASE stash_comment opt_sep expression opt_sep opt_list
-		  { $$ = make_switch_case ($1, $4, $6, $2); }
-		;
-
-default_case	: OTHERWISE stash_comment opt_sep opt_list
-		  {
-		    $$ = new tree_switch_case ($4, $2);
-		  }
-		;
+switch_command  : SWITCH stash_comment expression opt_sep case_list END
+                  {
+                    if (! ($$ = finish_switch_command ($1, $3, $5, $6, $2)))
+                      ABORT_PARSE;
+                  }
+                ;
+
+case_list       : // empty
+                  { $$ = new tree_switch_case_list (); }
+                | case_list1
+                  { $$ = $1; }
+                | case_list1 default_case
+                  {
+                    $1->append ($2);
+                    $$ = $1;
+                  }             
+                ;
+
+case_list1      : switch_case
+                  { $$ = new tree_switch_case_list ($1); }
+                | case_list1 switch_case
+                  {
+                    $1->append ($2);
+                    $$ = $1;
+                  }
+                ;
+
+switch_case     : CASE stash_comment opt_sep expression opt_sep opt_list
+                  { $$ = make_switch_case ($1, $4, $6, $2); }
+                ;
+
+default_case    : OTHERWISE stash_comment opt_sep opt_list
+                  {
+                    $$ = new tree_switch_case ($4, $2);
+                  }
+                ;
 
 // =======
 // Looping
 // =======
 
-loop_command	: WHILE stash_comment expression opt_sep opt_list END
-		  {
-		    if (! ($$ = make_while_command ($1, $3, $5, $6, $2)))
-		      ABORT_PARSE;
-		  }
-		| DO stash_comment opt_sep opt_list UNTIL expression
-		  {
-		    if (! ($$ = make_do_until_command ($5, $4, $6, $2)))
-		      ABORT_PARSE;
-		  }
-		| FOR stash_comment assign_lhs '=' expression opt_sep opt_list END
-		  {
-		    if (! ($$ = make_for_command ($1, $3, $5, $7, $8, $2)))
-		      ABORT_PARSE;
-		  }
-		| FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
-		  {
-		    if (! ($$ = make_for_command ($1, $4, $6, $9, $10, $2)))
-		      ABORT_PARSE;
-		  }
-		;
+loop_command    : WHILE stash_comment expression opt_sep opt_list END
+                  {
+                    if (! ($$ = make_while_command ($1, $3, $5, $6, $2)))
+                      ABORT_PARSE;
+                  }
+                | DO stash_comment opt_sep opt_list UNTIL expression
+                  {
+                    if (! ($$ = make_do_until_command ($5, $4, $6, $2)))
+                      ABORT_PARSE;
+                  }
+                | FOR stash_comment assign_lhs '=' expression opt_sep opt_list END
+                  {
+                    if (! ($$ = make_for_command ($1, $3, $5, $7, $8, $2)))
+                      ABORT_PARSE;
+                  }
+                | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
+                  {
+                    if (! ($$ = make_for_command ($1, $4, $6, $9, $10, $2)))
+                      ABORT_PARSE;
+                  }
+                ;
 
 // =======
 // Jumping
 // =======
 
-jump_command	: BREAK
-		  {
-		    if (! ($$ = make_break_command ($1)))
-		      ABORT_PARSE;
-		  }
-		| CONTINUE
-		  {
-		    if (! ($$ = make_continue_command ($1)))
-		      ABORT_PARSE;
-		  }
-		| FUNC_RET
-		  {
-		    if (! ($$ = make_return_command ($1)))
-		      ABORT_PARSE;
-		  }
-		;
+jump_command    : BREAK
+                  {
+                    if (! ($$ = make_break_command ($1)))
+                      ABORT_PARSE;
+                  }
+                | CONTINUE
+                  {
+                    if (! ($$ = make_continue_command ($1)))
+                      ABORT_PARSE;
+                  }
+                | FUNC_RET
+                  {
+                    if (! ($$ = make_return_command ($1)))
+                      ABORT_PARSE;
+                  }
+                ;
 
 // ==========
 // Exceptions
 // ==========
 
-except_command	: UNWIND stash_comment opt_sep opt_list CLEANUP
-		  stash_comment opt_sep opt_list END
-		  {
-		    if (! ($$ = make_unwind_command ($1, $4, $8, $9, $2, $6)))
-		      ABORT_PARSE;
-		  }
-		| TRY stash_comment opt_sep opt_list CATCH
-		  stash_comment opt_sep opt_list END
-		  {
-		    if (! ($$ = make_try_command ($1, $4, $8, $9, $2, $6)))
-		      ABORT_PARSE;
-		  }
-		| TRY stash_comment opt_sep opt_list END
-		  {
-		    if (! ($$ = make_try_command ($1, $4, 0, $5, $2, 0)))
-		      ABORT_PARSE;
-		  }
-		;
+except_command  : UNWIND stash_comment opt_sep opt_list CLEANUP
+                  stash_comment opt_sep opt_list END
+                  {
+                    if (! ($$ = make_unwind_command ($1, $4, $8, $9, $2, $6)))
+                      ABORT_PARSE;
+                  }
+                | TRY stash_comment opt_sep opt_list CATCH
+                  stash_comment opt_sep opt_list END
+                  {
+                    if (! ($$ = make_try_command ($1, $4, $8, $9, $2, $6)))
+                      ABORT_PARSE;
+                  }
+                | TRY stash_comment opt_sep opt_list END
+                  {
+                    if (! ($$ = make_try_command ($1, $4, 0, $5, $2, 0)))
+                      ABORT_PARSE;
+                  }
+                ;
 
 // ===========================================
 // Some `subroutines' for function definitions
 // ===========================================
 
-push_fcn_symtab	: // empty
-		  {
-		    current_function_depth++;
-
-		    if (max_function_depth < current_function_depth)
-		      max_function_depth = current_function_depth;
-
-		    symtab_context.push (symbol_table::current_scope ());
-		    symbol_table::set_scope (symbol_table::alloc_scope ());
-
-		    if (! reading_script_file && current_function_depth == 1
-			&& ! parsing_subfunctions)
-		      primary_fcn_scope = symbol_table::current_scope ();
-
-		    if (reading_script_file && current_function_depth > 1)
-		      yyerror ("nested functions not implemented in this context");
-		  }
-		;
+push_fcn_symtab : // empty
+                  {
+                    current_function_depth++;
+
+                    if (max_function_depth < current_function_depth)
+                      max_function_depth = current_function_depth;
+
+                    symtab_context.push (symbol_table::current_scope ());
+                    symbol_table::set_scope (symbol_table::alloc_scope ());
+
+                    if (! reading_script_file && current_function_depth == 1
+                        && ! parsing_subfunctions)
+                      primary_fcn_scope = symbol_table::current_scope ();
+
+                    if (reading_script_file && current_function_depth > 1)
+                      yyerror ("nested functions not implemented in this context");
+                  }
+                ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
-param_list_beg	: '('
-		  {
-		    lexer_flags.looking_at_parameter_list = true;
-
-		    if (lexer_flags.looking_at_function_handle)
-		      {
-		        symtab_context.push (symbol_table::current_scope ());
-			symbol_table::set_scope (symbol_table::alloc_scope ());
-			lexer_flags.looking_at_function_handle--;
-		      }
-		  }
-		;
-
-param_list_end	: ')'
-		  {
-		    lexer_flags.looking_at_parameter_list = false;
-		    lexer_flags.looking_for_object_index = false;
-		  }
-		;
-
-param_list	: param_list_beg param_list1 param_list_end
-		  {
-		    lexer_flags.quote_is_transpose = false;
-		    $$ = $2;
-		  }
-		| param_list_beg error
-		  {
-		    yyerror ("invalid parameter list");
-		    $$ = 0;
-		    ABORT_PARSE;
-		  }
-		;
-
-param_list1	: // empty
-		  { $$ = 0; }
-		| param_list2
-		  {
-		    $1->mark_as_formal_parameters ();
-		    if ($1->validate (tree_parameter_list::in))
-		      $$ = $1;
-		    else
-		      ABORT_PARSE;
-		  }
-		;
-
-param_list2	: decl2
-		  { $$ = new tree_parameter_list ($1); }
-		| param_list2 ',' decl2
-		  {
-		    $1->append ($3);
-		    $$ = $1;
-		  }
-		;
+param_list_beg  : '('
+                  {
+                    lexer_flags.looking_at_parameter_list = true;
+
+                    if (lexer_flags.looking_at_function_handle)
+                      {
+                        symtab_context.push (symbol_table::current_scope ());
+                        symbol_table::set_scope (symbol_table::alloc_scope ());
+                        lexer_flags.looking_at_function_handle--;
+                      }
+                  }
+                ;
+
+param_list_end  : ')'
+                  {
+                    lexer_flags.looking_at_parameter_list = false;
+                    lexer_flags.looking_for_object_index = false;
+                  }
+                ;
+
+param_list      : param_list_beg param_list1 param_list_end
+                  {
+                    lexer_flags.quote_is_transpose = false;
+                    $$ = $2;
+                  }
+                | param_list_beg error
+                  {
+                    yyerror ("invalid parameter list");
+                    $$ = 0;
+                    ABORT_PARSE;
+                  }
+                ;
+
+param_list1     : // empty
+                  { $$ = 0; }
+                | param_list2
+                  {
+                    $1->mark_as_formal_parameters ();
+                    if ($1->validate (tree_parameter_list::in))
+                      $$ = $1;
+                    else
+                      ABORT_PARSE;
+                  }
+                ;
+
+param_list2     : decl2
+                  { $$ = new tree_parameter_list ($1); }
+                | param_list2 ',' decl2
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
+                ;
 
 // ===================================
 // List of function return value names
 // ===================================
 
-return_list	: '[' ']'
-		  {
-		    lexer_flags.looking_at_return_list = false;
-		    $$ = new tree_parameter_list ();
-		  }
-		| return_list1
-		  {
-		    lexer_flags.looking_at_return_list = false;
-		    if ($1->validate (tree_parameter_list::out))
-		      $$ = $1;
-		    else
-		      ABORT_PARSE;
-		  }
-		| '[' return_list1 ']'
-		  {
-		    lexer_flags.looking_at_return_list = false;
-		    if ($2->validate (tree_parameter_list::out))
-		      $$ = $2;
-		    else
-		      ABORT_PARSE;
-		  }
-		;
-
-return_list1	: identifier
-		  { $$ = new tree_parameter_list (new tree_decl_elt ($1)); }
-		| return_list1 ',' identifier
-		  {
-		    $1->append (new tree_decl_elt ($3));
-		    $$ = $1;
-		  }
-		;
+return_list     : '[' ']'
+                  {
+                    lexer_flags.looking_at_return_list = false;
+                    $$ = new tree_parameter_list ();
+                  }
+                | return_list1
+                  {
+                    lexer_flags.looking_at_return_list = false;
+                    if ($1->validate (tree_parameter_list::out))
+                      $$ = $1;
+                    else
+                      ABORT_PARSE;
+                  }
+                | '[' return_list1 ']'
+                  {
+                    lexer_flags.looking_at_return_list = false;
+                    if ($2->validate (tree_parameter_list::out))
+                      $$ = $2;
+                    else
+                      ABORT_PARSE;
+                  }
+                ;
+
+return_list1    : identifier
+                  { $$ = new tree_parameter_list (new tree_decl_elt ($1)); }
+                | return_list1 ',' identifier
+                  {
+                    $1->append (new tree_decl_elt ($3));
+                    $$ = $1;
+                  }
+                ;
 
 // ===========
 // Script file
 // ===========
 
-script_file	: SCRIPT_FILE opt_list END_OF_INPUT
-		  {
-		    tree_statement *end_of_script
-		      = make_end ("endscript", input_line_number,
-				  current_input_column);
-
-		    make_script ($2, end_of_script);
-
-		    $$ = 0;
-		  }
-		;
+script_file     : SCRIPT_FILE opt_list END_OF_INPUT
+                  {
+                    tree_statement *end_of_script
+                      = make_end ("endscript", input_line_number,
+                                  current_input_column);
+
+                    make_script ($2, end_of_script);
+
+                    $$ = 0;
+                  }
+                ;
 
 // =============
 // Function file
 // =============
 
 function_file   : FUNCTION_FILE function_list opt_sep END_OF_INPUT
-		  { $$ = 0; }
-		;
+                  { $$ = 0; }
+                ;
 
 function_list   : function
-		| function_list sep function
-		;
+                | function_list sep function
+                ;
 
 // ===================
 // Function definition
 // ===================
 
-function_beg	: push_fcn_symtab FCN stash_comment
-		  {
-		    $$ = $3;
-
-		    if (reading_classdef_file || lexer_flags.parsing_classdef) 
-		      lexer_flags.maybe_classdef_get_set_method = true; 
-		  }
-		;
-
-function	: function_beg function1
-		  {
-		    $$ = finish_function (0, $2, $1);
-		    recover_from_parsing_function ();
-		  }
-		| function_beg return_list '=' function1
-		  {
-		    $$ = finish_function ($2, $4, $1);
-		    recover_from_parsing_function ();
-		  }
-		;
-
-fcn_name	: identifier
-		  {
-		    std::string id_name = $1->name ();
-
-		    lexer_flags.parsed_function_name = true;
-		    lexer_flags.defining_func = false;
-		    lexer_flags.maybe_classdef_get_set_method = false;
+function_beg    : push_fcn_symtab FCN stash_comment
+                  {
+                    $$ = $3;
+
+                    if (reading_classdef_file || lexer_flags.parsing_classdef) 
+                      lexer_flags.maybe_classdef_get_set_method = true; 
+                  }
+                ;
+
+function        : function_beg function1
+                  {
+                    $$ = finish_function (0, $2, $1);
+                    recover_from_parsing_function ();
+                  }
+                | function_beg return_list '=' function1
+                  {
+                    $$ = finish_function ($2, $4, $1);
+                    recover_from_parsing_function ();
+                  }
+                ;
+
+fcn_name        : identifier
+                  {
+                    std::string id_name = $1->name ();
+
+                    lexer_flags.parsed_function_name = true;
+                    lexer_flags.defining_func = false;
+                    lexer_flags.maybe_classdef_get_set_method = false;
             
-		    $$ = $1;
-		  }
-		| GET '.' identifier
-		  {
-		    lexer_flags.maybe_classdef_get_set_method = false;
-		    $$ = $3;
-		  }
-		| SET '.' identifier
-		  {
-		    lexer_flags.maybe_classdef_get_set_method = false;
-		    $$ = $3;
-		  }
-		;
-
-function1	: fcn_name function2
-		  {
-		    std::string fname = $1->name ();
-
-		    delete $1;
-
-		    if (! ($$ = frob_function (fname, $2)))
-		      ABORT_PARSE;
-		  }
-		;
-
-function2	: param_list opt_sep opt_list function_end
-		  { $$ = start_function ($1, $3, $4); }
-		| opt_sep opt_list function_end
-		  { $$ = start_function (0, $2, $3); }
-		;
-
-function_end	: END
-		  {
-		    endfunction_found = true;
-		    if (end_token_ok ($1, token::function_end))
-		      $$ = make_end ("endfunction", $1->line (), $1->column ());
-		    else
-		      ABORT_PARSE;
-		  }
-		| END_OF_INPUT
-		  {
+                    $$ = $1;
+                  }
+                | GET '.' identifier
+                  {
+                    lexer_flags.maybe_classdef_get_set_method = false;
+                    $$ = $3;
+                  }
+                | SET '.' identifier
+                  {
+                    lexer_flags.maybe_classdef_get_set_method = false;
+                    $$ = $3;
+                  }
+                ;
+
+function1       : fcn_name function2
+                  {
+                    std::string fname = $1->name ();
+
+                    delete $1;
+
+                    if (! ($$ = frob_function (fname, $2)))
+                      ABORT_PARSE;
+                  }
+                ;
+
+function2       : param_list opt_sep opt_list function_end
+                  { $$ = start_function ($1, $3, $4); }
+                | opt_sep opt_list function_end
+                  { $$ = start_function (0, $2, $3); }
+                ;
+
+function_end    : END
+                  {
+                    endfunction_found = true;
+                    if (end_token_ok ($1, token::function_end))
+                      $$ = make_end ("endfunction", $1->line (), $1->column ());
+                    else
+                      ABORT_PARSE;
+                  }
+                | END_OF_INPUT
+                  {
 // A lot of tests are based on the assumption that this is OK
-// 		    if (reading_script_file)
-// 		      {
-// 			yyerror ("function body open at end of script");
-// 			YYABORT;
-// 		      }
-
-		    if (endfunction_found)
-		      {
-			yyerror ("inconsistent function endings -- "
-				 "if one function is explicitly ended, "
-				 "so must all the others");
-			YYABORT;
-		      }
-
-		    if (! (reading_fcn_file || reading_script_file
+//                  if (reading_script_file)
+//                    {
+//                      yyerror ("function body open at end of script");
+//                      YYABORT;
+//                    }
+
+                    if (endfunction_found)
+                      {
+                        yyerror ("inconsistent function endings -- "
+                                 "if one function is explicitly ended, "
+                                 "so must all the others");
+                        YYABORT;
+                      }
+
+                    if (! (reading_fcn_file || reading_script_file
                            || get_input_from_eval_string))
-		      {
-			yyerror ("function body open at end of input");
-			YYABORT;
-		      }
-
-		    if (reading_classdef_file)
-		      {
-		        yyerror ("classdef body open at end of input");
-		        YYABORT;
-		      }
-
-		    $$ = make_end ("endfunction", input_line_number,
-				   current_input_column);
-		  }
-		;
+                      {
+                        yyerror ("function body open at end of input");
+                        YYABORT;
+                      }
+
+                    if (reading_classdef_file)
+                      {
+                        yyerror ("classdef body open at end of input");
+                        YYABORT;
+                      }
+
+                    $$ = make_end ("endfunction", input_line_number,
+                                   current_input_column);
+                  }
+                ;
 
 // ========
 // Classdef
 // ========
 
-classdef_beg	: CLASSDEF stash_comment
-		  {
-		    $$ = 0;
-		    lexer_flags.parsing_classdef = true;
-		  }
-		;
-
-classdef_end	: END
-		  {
-		    lexer_flags.parsing_classdef = false;
-
-		    if (end_token_ok ($1, token::classdef_end))
-		      $$ = make_end ("endclassdef", $1->line (), $1->column ());
-		    else
-		      ABORT_PARSE;
-		  }
-		;
-
-classdef1	: classdef_beg opt_attr_list identifier opt_superclasses
-		  { $$ = 0; }
-		;
-
-classdef	: classdef1 '\n' class_body '\n' stash_comment classdef_end
-		  { $$ = 0; }
-		;
-
-opt_attr_list	: // empty
-		  { $$ = 0; }
-		| '(' attr_list ')'
-		  { $$ = 0; }
-		;
-
-attr_list	: attr
-		  { $$ = 0; }
-		| attr_list ',' attr
-		  { $$ = 0; }
-		;
-
-attr		: identifier
-		  { $$ = 0; }
-		| identifier '=' decl_param_init expression
-		  { $$ = 0; }
-		| EXPR_NOT identifier
-		  { $$ = 0; }
-		;
+classdef_beg    : CLASSDEF stash_comment
+                  {
+                    $$ = 0;
+                    lexer_flags.parsing_classdef = true;
+                  }
+                ;
+
+classdef_end    : END
+                  {
+                    lexer_flags.parsing_classdef = false;
+
+                    if (end_token_ok ($1, token::classdef_end))
+                      $$ = make_end ("endclassdef", $1->line (), $1->column ());
+                    else
+                      ABORT_PARSE;
+                  }
+                ;
+
+classdef1       : classdef_beg opt_attr_list identifier opt_superclasses
+                  { $$ = 0; }
+                ;
+
+classdef        : classdef1 '\n' class_body '\n' stash_comment classdef_end
+                  { $$ = 0; }
+                ;
+
+opt_attr_list   : // empty
+                  { $$ = 0; }
+                | '(' attr_list ')'
+                  { $$ = 0; }
+                ;
+
+attr_list       : attr
+                  { $$ = 0; }
+                | attr_list ',' attr
+                  { $$ = 0; }
+                ;
+
+attr            : identifier
+                  { $$ = 0; }
+                | identifier '=' decl_param_init expression
+                  { $$ = 0; }
+                | EXPR_NOT identifier
+                  { $$ = 0; }
+                ;
 
 opt_superclasses
-		: // empty
-		  { $$ = 0; }
-		| superclasses
-		  { $$ = 0; }
-		;
-
-superclasses	: EXPR_LT identifier '.' identifier
-		  { $$ = 0; }
-		| EXPR_LT identifier
-		  { $$ = 0; }
-		| superclasses EXPR_AND identifier '.' identifier
-		  { $$ = 0; }
-		| superclasses EXPR_AND identifier
-		  { $$ = 0; }
-		;
-
-class_body	: properties_block
-		  { $$ = 0; }
-		| methods_block
-		  { $$ = 0; }
-		| events_block
-		  { $$ = 0; }
-		| class_body '\n' properties_block
-		  { $$ = 0; }
-		| class_body '\n' methods_block
-		  { $$ = 0; }
-		| class_body '\n' events_block
-		  { $$ = 0; }
-		;
-
-properties_beg	: PROPERTIES stash_comment
-		  { $$ = 0; }
-		;
+                : // empty
+                  { $$ = 0; }
+                | superclasses
+                  { $$ = 0; }
+                ;
+
+superclasses    : EXPR_LT identifier '.' identifier
+                  { $$ = 0; }
+                | EXPR_LT identifier
+                  { $$ = 0; }
+                | superclasses EXPR_AND identifier '.' identifier
+                  { $$ = 0; }
+                | superclasses EXPR_AND identifier
+                  { $$ = 0; }
+                ;
+
+class_body      : properties_block
+                  { $$ = 0; }
+                | methods_block
+                  { $$ = 0; }
+                | events_block
+                  { $$ = 0; }
+                | class_body '\n' properties_block
+                  { $$ = 0; }
+                | class_body '\n' methods_block
+                  { $$ = 0; }
+                | class_body '\n' events_block
+                  { $$ = 0; }
+                ;
+
+properties_beg  : PROPERTIES stash_comment
+                  { $$ = 0; }
+                ;
 
 properties_block
-		: properties_beg opt_attr_list '\n' properties_list '\n' END
-		  { $$ = 0; }
-		;
+                : properties_beg opt_attr_list '\n' properties_list '\n' END
+                  { $$ = 0; }
+                ;
 
 properties_list
-		: class_property
-		  { $$ = 0; }
-		| properties_list '\n' class_property
-		  { $$ = 0; }
-		;
-
-class_property	: identifier
-		  { $$ = 0; }
-		| identifier '=' decl_param_init expression ';'
-		  { $$ = 0; }
-		;
-
-methods_beg	: METHODS stash_comment
-		  { $$ = 0; }
-		;
-
-methods_block	: methods_beg opt_attr_list '\n' methods_list '\n' END
-		  { $$ = 0; }
-		;
-
-methods_list	: function
-		  { $$ = 0; }
-		| methods_list '\n' function
-		  { $$ = 0; }
-		;
-
-events_beg	: EVENTS stash_comment
-		  { $$ = 0; }
-		;
-
-events_block	: events_beg opt_attr_list '\n' events_list '\n' END
-		  { $$ = 0; }
-		;
-
-events_list	: class_event
-		  { $$ = 0; }
-		| events_list '\n' class_event
-		  { $$ = 0; }
-		;
-
-class_event	: identifier
-		  { $$ = 0; }
-		;
+                : class_property
+                  { $$ = 0; }
+                | properties_list '\n' class_property
+                  { $$ = 0; }
+                ;
+
+class_property  : identifier
+                  { $$ = 0; }
+                | identifier '=' decl_param_init expression ';'
+                  { $$ = 0; }
+                ;
+
+methods_beg     : METHODS stash_comment
+                  { $$ = 0; }
+                ;
+
+methods_block   : methods_beg opt_attr_list '\n' methods_list '\n' END
+                  { $$ = 0; }
+                ;
+
+methods_list    : function
+                  { $$ = 0; }
+                | methods_list '\n' function
+                  { $$ = 0; }
+                ;
+
+events_beg      : EVENTS stash_comment
+                  { $$ = 0; }
+                ;
+
+events_block    : events_beg opt_attr_list '\n' events_list '\n' END
+                  { $$ = 0; }
+                ;
+
+events_list     : class_event
+                  { $$ = 0; }
+                | events_list '\n' class_event
+                  { $$ = 0; }
+                ;
+
+class_event     : identifier
+                  { $$ = 0; }
+                ;
  
 // =============
 // Miscellaneous
 // =============
 
-stash_comment	: // empty
-		  { $$ = octave_comment_buffer::get_comment (); }
-		;
-
-parse_error	: LEXICAL_ERROR
-		  { yyerror ("parse error"); }
-		| error
-		;
-
-sep_no_nl	: ','
-		  { $$ = ','; }
-		| ';'
-		  { $$ = ';'; }
-		| sep_no_nl ','
-		  { $$ = $1; }
-		| sep_no_nl ';'
-		  { $$ = $1; }
-		;
-
-opt_sep_no_nl	: // empty
-		  { $$ = 0; }
-		| sep_no_nl
-		  { $$ = $1; }
-		;
-
-sep		: ','
-		  { $$ = ','; }
-		| ';'
-		  { $$ = ';'; }
-		| '\n'
-		  { $$ = '\n'; }
-		| sep ','
-		  { $$ = $1; }
-		| sep ';'
-		  { $$ = $1; }
-		| sep '\n'
-		  { $$ = $1; }
-		;
-
-opt_sep		: // empty
-		  { $$ = 0; }
-		| sep
-		  { $$ = $1; }
-		;
+stash_comment   : // empty
+                  { $$ = octave_comment_buffer::get_comment (); }
+                ;
+
+parse_error     : LEXICAL_ERROR
+                  { yyerror ("parse error"); }
+                | error
+                ;
+
+sep_no_nl       : ','
+                  { $$ = ','; }
+                | ';'
+                  { $$ = ';'; }
+                | sep_no_nl ','
+                  { $$ = $1; }
+                | sep_no_nl ';'
+                  { $$ = $1; }
+                ;
+
+opt_sep_no_nl   : // empty
+                  { $$ = 0; }
+                | sep_no_nl
+                  { $$ = $1; }
+                ;
+
+sep             : ','
+                  { $$ = ','; }
+                | ';'
+                  { $$ = ';'; }
+                | '\n'
+                  { $$ = '\n'; }
+                | sep ','
+                  { $$ = $1; }
+                | sep ';'
+                  { $$ = $1; }
+                | sep '\n'
+                  { $$ = $1; }
+                ;
+
+opt_sep         : // empty
+                  { $$ = 0; }
+                | sep
+                  { $$ = $1; }
+                ;
 
 %%
 
 // Generic error messages.
 
 static void
 yyerror (const char *s)
 {
   int err_col = current_input_column - 1;
 
   std::ostringstream output_buf;
 
   if (reading_fcn_file || reading_script_file || reading_classdef_file)
     output_buf << "parse error near line " << input_line_number
-	       << " of file " << curr_fcn_file_full_name;
+               << " of file " << curr_fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
   output_buf << "\n\n";
 
@@ -1651,20 +1651,20 @@ yyerror (const char *s)
       if (current_input_line[len-1] == '\n')
         current_input_line.resize (len-1);
 
       // Print the line, maybe with a pointer near the error token.
 
       output_buf << ">>> " << current_input_line << "\n";
 
       if (err_col == 0)
-	err_col = len;
+        err_col = len;
 
       for (int i = 0; i < err_col + 3; i++)
-	output_buf << " ";
+        output_buf << " ";
 
       output_buf << "^";
     }
 
   output_buf << "\n";
 
   std::string msg = output_buf.str ();
 
@@ -1737,94 +1737,94 @@ end_token_ok (token *tok, token::end_tok
       retval = false;
 
       yyerror ("parse error");
 
       int l = tok->line ();
       int c = tok->column ();
 
       switch (expected)
-	{
-	case token::classdef_end:
-	  end_error ("classdef", ettype, l, c);
-	  break;
-
-	case token::for_end:
-	  end_error ("for", ettype, l, c);
-	  break;
-
-	case token::function_end:
-	  end_error ("function", ettype, l, c);
-	  break;
-
-	case token::if_end:
-	  end_error ("if", ettype, l, c);
-	  break;
-
-	case token::try_catch_end:
-	  end_error ("try", ettype, l, c);
-	  break;
-
-	case token::switch_end:
-	  end_error ("switch", ettype, l, c);
-	  break;
-
-	case token::unwind_protect_end:
-	  end_error ("unwind_protect", ettype, l, c);
-	  break;
-
-	case token::while_end:
-	  end_error ("while", ettype, l, c);
-	  break;
-
-	default:
-	  panic_impossible ();
-	  break;
-	}
+        {
+        case token::classdef_end:
+          end_error ("classdef", ettype, l, c);
+          break;
+
+        case token::for_end:
+          end_error ("for", ettype, l, c);
+          break;
+
+        case token::function_end:
+          end_error ("function", ettype, l, c);
+          break;
+
+        case token::if_end:
+          end_error ("if", ettype, l, c);
+          break;
+
+        case token::try_catch_end:
+          end_error ("try", ettype, l, c);
+          break;
+
+        case token::switch_end:
+          end_error ("switch", ettype, l, c);
+          break;
+
+        case token::unwind_protect_end:
+          end_error ("unwind_protect", ettype, l, c);
+          break;
+
+        case token::while_end:
+          end_error ("while", ettype, l, c);
+          break;
+
+        default:
+          panic_impossible ();
+          break;
+        }
     }
 
   return retval;
 }
 
 // Maybe print a warning if an assignment expression is used as the
 // test in a logical expression.
 
 static void
 maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
   if (expr->is_assignment_expression ()
       && expr->paren_count () < 2)
     {
       if (curr_fcn_file_full_name.empty ())
-	warning_with_id
-	  ("Octave:assign-as-truth-value",
-	   "suggest parenthesis around assignment used as truth value");
+        warning_with_id
+          ("Octave:assign-as-truth-value",
+           "suggest parenthesis around assignment used as truth value");
       else
-	warning_with_id
-	  ("Octave:assign-as-truth-value",
-	   "suggest parenthesis around assignment used as truth value near line %d, column %d in file `%s'",
-	   expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
+        warning_with_id
+          ("Octave:assign-as-truth-value",
+           "suggest parenthesis around assignment used as truth value near line %d, column %d in file `%s'",
+           expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
 static void
 maybe_warn_variable_switch_label (tree_expression *expr)
 {
   if (! expr->is_constant ())
     {
       if (curr_fcn_file_full_name.empty ())
-	warning_with_id ("Octave:variable-switch-label",
-			 "variable switch label");
+        warning_with_id ("Octave:variable-switch-label",
+                         "variable switch label");
       else
-	warning_with_id
-	  ("Octave:variable-switch-label",
-	   "variable switch label near line %d, column %d in file `%s'",
-	   expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
+        warning_with_id
+          ("Octave:variable-switch-label",
+           "variable switch label near line %d, column %d in file `%s'",
+           expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
 
@@ -1841,39 +1841,39 @@ fold (tree_binary_expression *e)
 
   tree_expression *op1 = e->lhs ();
   tree_expression *op2 = e->rhs ();
 
   octave_value::binary_op op_type = e->op_type ();
 
   if (op1->is_constant () && op2->is_constant ()
       && (! ((warning_enabled ("Octave:associativity-change")
-	      && (op_type == POW || op_type == EPOW))
-	     || (warning_enabled ("Octave:precedence-change")
-		 && (op_type == EXPR_OR || op_type == EXPR_OR_OR)))))
+              && (op_type == POW || op_type == EPOW))
+             || (warning_enabled ("Octave:precedence-change")
+                 && (op_type == EXPR_OR || op_type == EXPR_OR_OR)))))
     {
       octave_value tmp = e->rvalue1 ();
 
       if (! (error_state || warning_state))
-	{
-	  tree_constant *tc_retval
-	    = new tree_constant (tmp, op1->line (), op1->column ());
-
-	  std::ostringstream buf;
-
-	  tree_print_code tpc (buf);
-
-	  e->accept (tpc);
-
-	  tc_retval->stash_original_text (buf.str ());
-
-	  delete e;
-
-	  retval = tc_retval;
-	}
+        {
+          tree_constant *tc_retval
+            = new tree_constant (tmp, op1->line (), op1->column ());
+
+          std::ostringstream buf;
+
+          tree_print_code tpc (buf);
+
+          e->accept (tpc);
+
+          tc_retval->stash_original_text (buf.str ());
+
+          delete e;
+
+          retval = tc_retval;
+        }
     }
 
   return retval;
 }
 
 static tree_expression *
 fold (tree_unary_expression *e)
 {
@@ -1892,32 +1892,32 @@ fold (tree_unary_expression *e)
 
   tree_expression *op = e->operand ();
 
   if (op->is_constant ())
     {
       octave_value tmp = e->rvalue1 ();
 
       if (! (error_state || warning_state))
-	{
-	  tree_constant *tc_retval
-	    = new tree_constant (tmp, op->line (), op->column ());
-
-	  std::ostringstream buf;
-
-	  tree_print_code tpc (buf);
-
-	  e->accept (tpc);
-
-	  tc_retval->stash_original_text (buf.str ());
-
-	  delete e;
-
-	  retval = tc_retval;
-	}
+        {
+          tree_constant *tc_retval
+            = new tree_constant (tmp, op->line (), op->column ());
+
+          std::ostringstream buf;
+
+          tree_print_code tpc (buf);
+
+          e->accept (tpc);
+
+          tc_retval->stash_original_text (buf.str ());
+
+          delete e;
+
+          retval = tc_retval;
+        }
     }
 
   return retval;
 }
 
 // Finish building a range.
 
 static tree_expression *
@@ -1938,50 +1938,50 @@ finish_colon_expression (tree_colon_expr
 
   tree_expression *base = e->base ();
   tree_expression *limit = e->limit ();
   tree_expression *incr = e->increment ();
 
   if (base)
     {
       if (limit)
-	{
-	  if (base->is_constant () && limit->is_constant ()
-	      && (! incr || (incr && incr->is_constant ())))
-	    {
-	      octave_value tmp = e->rvalue1 ();
-
-	      if (! (error_state || warning_state))
-		{
-		  tree_constant *tc_retval
-		    = new tree_constant (tmp, base->line (), base->column ());
-
-		  std::ostringstream buf;
-
-		  tree_print_code tpc (buf);
-
-		  e->accept (tpc);
-
-		  tc_retval->stash_original_text (buf.str ());
-
-		  delete e;
-
-		  retval = tc_retval;
-		}
-	    }
-	}
+        {
+          if (base->is_constant () && limit->is_constant ()
+              && (! incr || (incr && incr->is_constant ())))
+            {
+              octave_value tmp = e->rvalue1 ();
+
+              if (! (error_state || warning_state))
+                {
+                  tree_constant *tc_retval
+                    = new tree_constant (tmp, base->line (), base->column ());
+
+                  std::ostringstream buf;
+
+                  tree_print_code tpc (buf);
+
+                  e->accept (tpc);
+
+                  tc_retval->stash_original_text (buf.str ());
+
+                  delete e;
+
+                  retval = tc_retval;
+                }
+            }
+        }
       else
-	{
-	  e->preserve_base ();
-	  delete e;
-
-	  // FIXME -- need to attempt constant folding here
-	  // too (we need a generic way to do that).
-	  retval = base;
-	}
+        {
+          e->preserve_base ();
+          delete e;
+
+          // FIXME -- need to attempt constant folding here
+          // too (we need a generic way to do that).
+          retval = base;
+        }
     }
 
   return retval;
 }
 
 // Make a constant.
 
 static tree_constant *
@@ -1991,54 +1991,54 @@ make_constant (int op, token *tok_val)
   int c = tok_val->column ();
 
   tree_constant *retval = 0;
 
   switch (op)
     {
     case NUM:
       {
-	octave_value tmp (tok_val->number ());
-	retval = new tree_constant (tmp, l, c);
-	retval->stash_original_text (tok_val->text_rep ());
+        octave_value tmp (tok_val->number ());
+        retval = new tree_constant (tmp, l, c);
+        retval->stash_original_text (tok_val->text_rep ());
       }
       break;
 
     case IMAG_NUM:
       {
-	octave_value tmp (Complex (0.0, tok_val->number ()));
-	retval = new tree_constant (tmp, l, c);
-	retval->stash_original_text (tok_val->text_rep ());
+        octave_value tmp (Complex (0.0, tok_val->number ()));
+        retval = new tree_constant (tmp, l, c);
+        retval->stash_original_text (tok_val->text_rep ());
       }
       break;
 
     case DQ_STRING:
     case SQ_STRING:
       {
-	std::string txt = tok_val->text ();
+        std::string txt = tok_val->text ();
 
         char delim = op == DQ_STRING ? '"' : '\'';
         octave_value tmp (txt, delim);
 
         if (txt.empty ())
           {
             if (op == DQ_STRING)
               tmp = octave_null_str::instance;
             else
               tmp = octave_null_sq_str::instance;
           }
 
-	retval = new tree_constant (tmp, l, c);
-
-	if (op == DQ_STRING)
-	  txt = undo_string_escapes (txt);
-
-	// FIXME -- maybe this should also be handled by
-	// tok_val->text_rep () for character strings?
-	retval->stash_original_text (delim + txt + delim);
+        retval = new tree_constant (tmp, l, c);
+
+        if (op == DQ_STRING)
+          txt = undo_string_escapes (txt);
+
+        // FIXME -- maybe this should also be handled by
+        // tok_val->text_rep () for character strings?
+        retval->stash_original_text (delim + txt + delim);
       }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
@@ -2092,45 +2092,45 @@ make_anon_fcn_handle (tree_parameter_lis
 }
 
 static void
 maybe_warn_associativity_change (tree_expression *op)
 {
   if (op->paren_count () == 0 && op->is_binary_expression ())
     {
       tree_binary_expression *e
-	= dynamic_cast<tree_binary_expression *> (op);
+        = dynamic_cast<tree_binary_expression *> (op);
 
       octave_value::binary_op op_type = e->op_type ();
 
       if (op_type == octave_value::op_pow
-	  || op_type == octave_value::op_el_pow)
-	{
-	  std::string op_str = octave_value::binary_op_as_string (op_type);
-
-	  if (curr_fcn_file_full_name.empty ())
-	    warning_with_id
-	      ("Octave:associativity-change",
-	       "meaning may have changed due to change in associativity for %s operator",
-	       op_str.c_str ());
-	  else
-	    warning_with_id
-	      ("Octave:associativity-change",
-	       "meaning may have changed due to change in associativity for %s operator near line %d, column %d in file `%s'",
-	       op_str.c_str (), op->line (), op->column (),
-	       curr_fcn_file_full_name.c_str ());
-	}
+          || op_type == octave_value::op_el_pow)
+        {
+          std::string op_str = octave_value::binary_op_as_string (op_type);
+
+          if (curr_fcn_file_full_name.empty ())
+            warning_with_id
+              ("Octave:associativity-change",
+               "meaning may have changed due to change in associativity for %s operator",
+               op_str.c_str ());
+          else
+            warning_with_id
+              ("Octave:associativity-change",
+               "meaning may have changed due to change in associativity for %s operator near line %d, column %d in file `%s'",
+               op_str.c_str (), op->line (), op->column (),
+               curr_fcn_file_full_name.c_str ());
+        }
     }
 }
 
 // Build a binary expression.
 
 static tree_expression *
 make_binary_op (int op, tree_expression *op1, token *tok_val,
-		tree_expression *op2)
+                tree_expression *op2)
 {
   octave_value::binary_op t = octave_value::unknown_binary_op;
 
   switch (op)
     {
     case POW:
       t = octave_value::op_pow;
       maybe_warn_associativity_change (op1);
@@ -2208,32 +2208,32 @@ make_binary_op (int op, tree_expression 
     case EXPR_AND:
       t = octave_value::op_el_and;
       break;
 
     case EXPR_OR:
       t = octave_value::op_el_or;
       if (op2->paren_count () == 0 && op2->is_binary_expression ())
         {
-	  tree_binary_expression *e
-	    = dynamic_cast<tree_binary_expression *> (op2);
-
-	  if (e->op_type () == octave_value::op_el_and)
-	    {
-	      if (curr_fcn_file_full_name.empty ())
-		warning_with_id
-		  ("Octave:precedence-change",
-		   "meaning may have changed due to change in precedence for & and | operators");
-	      else
-		warning_with_id
-		  ("Octave:precedence-change",
-		   "meaning may have changed due to change in precedence for & and | operators near line %d, column %d in file `%s'",
-		   op2->line (), op2->column (),
-		   curr_fcn_file_full_name.c_str ());
-	    }
+          tree_binary_expression *e
+            = dynamic_cast<tree_binary_expression *> (op2);
+
+          if (e->op_type () == octave_value::op_el_and)
+            {
+              if (curr_fcn_file_full_name.empty ())
+                warning_with_id
+                  ("Octave:precedence-change",
+                   "meaning may have changed due to change in precedence for & and | operators");
+              else
+                warning_with_id
+                  ("Octave:precedence-change",
+                   "meaning may have changed due to change in precedence for & and | operators near line %d, column %d in file `%s'",
+                   op2->line (), op2->column (),
+                   curr_fcn_file_full_name.c_str ());
+            }
         }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
@@ -2245,37 +2245,37 @@ make_binary_op (int op, tree_expression 
 
   return fold (e);
 }
 
 // Build a boolean expression.
 
 static tree_expression *
 make_boolean_op (int op, tree_expression *op1, token *tok_val,
-		 tree_expression *op2)
+                 tree_expression *op2)
 {
   tree_boolean_expression::type t;
 
   switch (op)
     {
     case EXPR_AND_AND:
       t = tree_boolean_expression::bool_and;
       break;
 
     case EXPR_OR_OR:
       t = tree_boolean_expression::bool_or;
       if (op2->paren_count () == 0 && op2->is_boolean_expression ())
         {
-	  tree_boolean_expression *e
-	    = dynamic_cast<tree_boolean_expression *> (op2);
-
-	  if (e->op_type () == tree_boolean_expression::bool_and)
-	    warning_with_id
-	      ("Octave:precedence-change",
-	       "meaning may have changed due to change in precedence for && and || operators");
+          tree_boolean_expression *e
+            = dynamic_cast<tree_boolean_expression *> (op2);
+
+          if (e->op_type () == tree_boolean_expression::bool_and)
+            warning_with_id
+              ("Octave:precedence-change",
+               "meaning may have changed due to change in precedence for && and || operators");
         }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
@@ -2369,64 +2369,64 @@ make_postfix_op (int op, tree_expression
 
   return fold (e);
 }
 
 // Build an unwind-protect command.
 
 static tree_command *
 make_unwind_command (token *unwind_tok, tree_statement_list *body,
-		     tree_statement_list *cleanup, token *end_tok,
-		     octave_comment_list *lc, octave_comment_list *mc)
+                     tree_statement_list *cleanup, token *end_tok,
+                     octave_comment_list *lc, octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::unwind_protect_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = unwind_tok->line ();
       int c = unwind_tok->column ();
 
       retval = new tree_unwind_protect_command (body, cleanup,
-						lc, mc, tc, l, c);
+                                                lc, mc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a try-catch command.
 
 static tree_command *
 make_try_command (token *try_tok, tree_statement_list *body,
-		  tree_statement_list *cleanup, token *end_tok,
-		  octave_comment_list *lc, octave_comment_list *mc)
+                  tree_statement_list *cleanup, token *end_tok,
+                  octave_comment_list *lc, octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::try_catch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = try_tok->line ();
       int c = try_tok->column ();
 
       retval = new tree_try_catch_command (body, cleanup,
-					   lc, mc, tc, l, c);
+                                           lc, mc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a while command.
 
 static tree_command *
 make_while_command (token *while_tok, tree_expression *expr,
-		    tree_statement_list *body, token *end_tok,
-		    octave_comment_list *lc)
+                    tree_statement_list *body, token *end_tok,
+                    octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   if (end_token_ok (end_tok, token::while_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
@@ -2441,17 +2441,17 @@ make_while_command (token *while_tok, tr
 
   return retval;
 }
 
 // Build a do-until command.
 
 static tree_command *
 make_do_until_command (token *until_tok, tree_statement_list *body,
-		       tree_expression *expr, octave_comment_list *lc)
+                       tree_expression *expr, octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
   lexer_flags.looping--;
@@ -2463,42 +2463,42 @@ make_do_until_command (token *until_tok,
 
   return retval;
 }
 
 // Build a for command.
 
 static tree_command *
 make_for_command (token *for_tok, tree_argument_list *lhs,
-		  tree_expression *expr, tree_statement_list *body,
-		  token *end_tok, octave_comment_list *lc)
+                  tree_expression *expr, tree_statement_list *body,
+                  token *end_tok, octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::for_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       lexer_flags.looping--;
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
       if (lhs->length () == 1)
-	{
-	  tree_expression *tmp = lhs->remove_front ();
-
-	  retval = new tree_simple_for_command (tmp, expr, body,
-						lc, tc, l, c);
-
-	  delete lhs;
-	}
+        {
+          tree_expression *tmp = lhs->remove_front ();
+
+          retval = new tree_simple_for_command (tmp, expr, body,
+                                                lc, tc, l, c);
+
+          delete lhs;
+        }
       else
-	retval = new tree_complex_for_command (lhs, expr, body,
-					       lc, tc, l, c);
+        retval = new tree_complex_for_command (lhs, expr, body,
+                                               lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a break command.
 
 static tree_command *
@@ -2555,110 +2555,110 @@ start_if_command (tree_expression *expr,
 
   return new tree_if_command_list (t);
 }
 
 // Finish an if command.
 
 static tree_if_command *
 finish_if_command (token *if_tok, tree_if_command_list *list,
-		   token *end_tok, octave_comment_list *lc)
+                   token *end_tok, octave_comment_list *lc)
 {
   tree_if_command *retval = 0;
 
   if (end_token_ok (end_tok, token::if_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = if_tok->line ();
       int c = if_tok->column ();
 
       if (list && ! list->empty ())
-	{
-	  tree_if_clause *elt = list->front ();
-
-	  if (elt)
-	    {
-	      elt->line (l);
-	      elt->column (c);
-	    }
-	}
+        {
+          tree_if_clause *elt = list->front ();
+
+          if (elt)
+            {
+              elt->line (l);
+              elt->column (c);
+            }
+        }
 
       retval = new tree_if_command (list, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build an elseif clause.
 
 static tree_if_clause *
 make_elseif_clause (token *elseif_tok, tree_expression *expr,
-		    tree_statement_list *list, octave_comment_list *lc)
+                    tree_statement_list *list, octave_comment_list *lc)
 {
   maybe_warn_assign_as_truth_value (expr);
 
   int l = elseif_tok->line ();
   int c = elseif_tok->column ();
 
   return new tree_if_clause (expr, list, lc, l, c);
 }
 
 // Finish a switch command.
 
 static tree_switch_command *
 finish_switch_command (token *switch_tok, tree_expression *expr,
-		       tree_switch_case_list *list, token *end_tok,
-		       octave_comment_list *lc)
+                       tree_switch_case_list *list, token *end_tok,
+                       octave_comment_list *lc)
 {
   tree_switch_command *retval = 0;
 
   if (end_token_ok (end_tok, token::switch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = switch_tok->line ();
       int c = switch_tok->column ();
 
       if (list && ! list->empty ())
-	{
-	  tree_switch_case *elt = list->front ();
-
-	  if (elt)
-	    {
-	      elt->line (l);
-	      elt->column (c);
-	    }
-	}
+        {
+          tree_switch_case *elt = list->front ();
+
+          if (elt)
+            {
+              elt->line (l);
+              elt->column (c);
+            }
+        }
 
       retval = new tree_switch_command (expr, list, lc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a switch case.
 
 static tree_switch_case *
 make_switch_case (token *case_tok, tree_expression *expr,
-		  tree_statement_list *list, octave_comment_list *lc)
+                  tree_statement_list *list, octave_comment_list *lc)
 {
   maybe_warn_variable_switch_label (expr);
 
   int l = case_tok->line ();
   int c = case_tok->column ();
 
   return new tree_switch_case (expr, list, lc, l, c);
 }
 
 // Build an assignment to a variable.
 
 static tree_expression *
 make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
-		tree_expression *rhs)
+                tree_expression *rhs)
 {
   tree_expression *retval = 0;
 
   octave_value::assign_op t = octave_value::unknown_assign_op;
 
   switch (op)
     {
     case '=':
@@ -2760,17 +2760,17 @@ make_script (tree_statement_list *cmds, 
 
   if (! cmds)
     cmds = new tree_statement_list ();
 
   cmds->append (end_script);
 
   octave_user_script *script
     = new octave_user_script (curr_fcn_file_full_name, curr_fcn_file_name,
-			      cmds, doc_string);
+                              cmds, doc_string);
 
   octave_time now;
 
   script->stash_fcn_file_time (now);
 
   primary_fcn_ptr = script;
 
   // Unmark any symbols that may have been tagged as local variables
@@ -2778,28 +2778,28 @@ make_script (tree_statement_list *cmds, 
 
   symbol_table::unmark_forced_variables ();
 }
 
 // Begin defining a function.
 
 static octave_user_function *
 start_function (tree_parameter_list *param_list, tree_statement_list *body,
-		tree_statement *end_fcn_stmt)
+                tree_statement *end_fcn_stmt)
 {
   // We'll fill in the return list later.
 
   if (! body)
     body = new tree_statement_list ();
 
   body->append (end_fcn_stmt);
 
   octave_user_function *fcn
     = new octave_user_function (symbol_table::current_scope (),
-				param_list, 0, body);
+                                param_list, 0, body);
 
   if (fcn)
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       fcn->stash_trailing_comment (tc);
     }
 
@@ -2820,81 +2820,81 @@ frob_function (const std::string& fname,
   std::string id_name = fname;
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
   if (! autoloading && reading_fcn_file
       && (current_function_depth == 1
-	  && ! (parsing_subfunctions || lexer_flags.parsing_class_method)))
+          && ! (parsing_subfunctions || lexer_flags.parsing_class_method)))
   {
     // FIXME -- should curr_fcn_file_name already be
     // preprocessed when we get here?  It seems to only be a
     // problem with relative file names.
 
     std::string nm = curr_fcn_file_name;
 
     size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
       nm = curr_fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
-	warning_with_id
-	  ("Octave:function-name-clash",
-	   "function name `%s' does not agree with function file name `%s'",
-	   id_name.c_str (), curr_fcn_file_full_name.c_str ());
-
-	id_name = nm;
+        warning_with_id
+          ("Octave:function-name-clash",
+           "function name `%s' does not agree with function file name `%s'",
+           id_name.c_str (), curr_fcn_file_full_name.c_str ());
+
+        id_name = nm;
       }
   }
 
   if (reading_fcn_file || reading_classdef_file || autoloading)
     {
       octave_time now;
 
       fcn->stash_fcn_file_name (curr_fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
-	fcn->mark_relative ();
+        fcn->mark_relative ();
 
       if (current_function_depth > 1 || parsing_subfunctions)
         {
-	  fcn->stash_parent_fcn_name (curr_fcn_file_name);
-	  fcn->stash_parent_fcn_scope (primary_fcn_scope);
+          fcn->stash_parent_fcn_name (curr_fcn_file_name);
+          fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
       if (lexer_flags.parsing_class_method)
-	{
-	  if (current_class_name == id_name)
-	    fcn->mark_as_class_constructor ();
-	  else
-	    fcn->mark_as_class_method ();
-
-	  fcn->stash_dispatch_class (current_class_name);
-	}
+        {
+          if (current_class_name == id_name)
+            fcn->mark_as_class_constructor ();
+          else
+            fcn->mark_as_class_method ();
+
+          fcn->stash_dispatch_class (current_class_name);
+        }
 
       std::string nm = fcn->fcn_file_name ();
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
-			 "time stamp for `%s' is in the future", nm.c_str ());
+                         "time stamp for `%s' is in the future", nm.c_str ());
     }
   else if (! (input_from_tmp_history_file || input_from_startup_file)
-	   && reading_script_file
-	   && curr_fcn_file_name == id_name)
+           && reading_script_file
+           && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
-	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
+               id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
 
   if (! help_buf.empty () && current_function_depth == 1
       && ! parsing_subfunctions)
     {
       fcn->document (help_buf.top ());
@@ -2906,62 +2906,62 @@ frob_function (const std::string& fname,
       && ! parsing_subfunctions)
     primary_fcn_ptr = fcn;
   
   return fcn;
 }
 
 static tree_function_def *
 finish_function (tree_parameter_list *ret_list,
-		 octave_user_function *fcn, octave_comment_list *lc)
+                 octave_user_function *fcn, octave_comment_list *lc)
 {
   tree_function_def *retval = 0;
 
   if (ret_list)
     ret_list->mark_as_formal_parameters ();
 
   if (fcn)
     {
       std::string nm = fcn->name ();
       std::string file = fcn->fcn_file_name ();
 
       std::string tmp = nm;
       if (! file.empty ())
-	tmp += ": " + file;
+        tmp += ": " + file;
 
       symbol_table::cache_name (fcn->scope (), tmp);
 
       if (lc)
-	fcn->stash_leading_comment (lc);
+        fcn->stash_leading_comment (lc);
 
       fcn->define_ret_list (ret_list);
 
       if (current_function_depth > 1 || parsing_subfunctions)
         {
           // FIXME -- is this flag used to determine if the function is a
           // _subfunction_ somewhere?
-	  fcn->mark_as_nested_function ();
-
-	  symbol_table::install_subfunction (nm, octave_value (fcn),
-					     primary_fcn_scope);
-	}
+          fcn->mark_as_nested_function ();
+
+          symbol_table::install_subfunction (nm, octave_value (fcn),
+                                             primary_fcn_scope);
+        }
 
       if (! reading_fcn_file)
-	{
-	  // We are either reading a script file or defining a function
-	  // at the command line, so this definition creates a
-	  // tree_function object that is placed in the parse tree.
-	  // Otherwise, it is just inserted in the symbol table,
-	  // either as a subfunction (see above), or as the primary
-	  // function for the file, via primary_fcn_ptr (see also
-	  // load_fcn_from_file,, parse_fcn_file, and
-	  // symbol_table::fcn_info::fcn_info_rep::find_user_function).
+        {
+          // We are either reading a script file or defining a function
+          // at the command line, so this definition creates a
+          // tree_function object that is placed in the parse tree.
+          // Otherwise, it is just inserted in the symbol table,
+          // either as a subfunction (see above), or as the primary
+          // function for the file, via primary_fcn_ptr (see also
+          // load_fcn_from_file,, parse_fcn_file, and
+          // symbol_table::fcn_info::fcn_info_rep::find_user_function).
 
           retval = new tree_function_def (fcn);
-	}
+        }
 
       // Unmark any symbols that may have been tagged as local
       // variables while parsing (for example, by force_local_variable
       // in lex.l).
 
       symbol_table::unmark_forced_variables (fcn->scope ());
     }
 
@@ -2987,17 +2987,17 @@ recover_from_parsing_function (void)
   lexer_flags.looking_at_return_list = false;
   lexer_flags.looking_at_parameter_list = false;
 }
 
 // Make an index expression.
 
 static tree_index_expression *
 make_index_expression (tree_expression *expr, tree_argument_list *args,
-		       char type)
+                       char type)
 {
   tree_index_expression *retval = 0;
   
   if (args && args->has_magic_tilde ())
     {
       yyerror ("invalid use of empty argument (~) in index expression");
       return retval;
     }
@@ -3086,25 +3086,25 @@ make_decl_command (int tok, token *tok_v
   switch (tok)
     {
     case GLOBAL:
       retval = new tree_global_command (lst, l, c);
       break;
 
     case STATIC:
       if (current_function_depth > 0)
-	retval = new tree_static_command (lst, l, c);
+        retval = new tree_static_command (lst, l, c);
       else
-	{
-	  if (reading_script_file)
-	    warning ("ignoring persistent declaration near line %d of file `%s'",
-		     l, curr_fcn_file_full_name.c_str ());
-	  else
-	    warning ("ignoring persistent declaration near line %d", l);
-	}
+        {
+          if (reading_script_file)
+            warning ("ignoring persistent declaration near line %d of file `%s'",
+                     l, curr_fcn_file_full_name.c_str ());
+          else
+            warning ("ignoring persistent declaration near line %d", l);
+        }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
@@ -3136,32 +3136,32 @@ finish_matrix (tree_matrix *m)
   discard_error_messages = true;
   discard_warning_messages = true;
 
   if (m->all_elements_are_constant ())
     {
       octave_value tmp = m->rvalue1 ();
 
       if (! (error_state || warning_state))
-	{
-	  tree_constant *tc_retval
-	    = new tree_constant (tmp, m->line (), m->column ());
-
-	  std::ostringstream buf;
-
-	  tree_print_code tpc (buf);
-
-	  m->accept (tpc);
-
-	  tc_retval->stash_original_text (buf.str ());
-
-	  delete m;
-
-	  retval = tc_retval;
-	}
+        {
+          tree_constant *tc_retval
+            = new tree_constant (tmp, m->line (), m->column ());
+
+          std::ostringstream buf;
+
+          tree_print_code tpc (buf);
+
+          m->accept (tpc);
+
+          tc_retval->stash_original_text (buf.str ());
+
+          delete m;
+
+          retval = tc_retval;
+        }
     }
 
   return retval;
 }
 
 // Finish building a cell list.
 
 static tree_expression *
@@ -3173,41 +3173,41 @@ finish_cell (tree_cell *c)
 static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (current_function_depth > 0)
     {
       tree_statement *tmp = t->back();
 
       if (tmp->is_expression ())
-	warning_with_id
-	  ("Octave:missing-semicolon",
-	   "missing semicolon near line %d, column %d in file `%s'",
-	    tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
+        warning_with_id
+          ("Octave:missing-semicolon",
+           "missing semicolon near line %d, column %d in file `%s'",
+            tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
 
 static tree_statement_list *
 set_stmt_print_flag (tree_statement_list *list, char sep,
-		     bool warn_missing_semi)
+                     bool warn_missing_semi)
 {
   tree_statement *tmp = list->back ();
 
   switch (sep)
     {
     case ';':
       tmp->set_print_flag (false);
       break;
 
     case 0:
     case ',':
     case '\n':
       tmp->set_print_flag (true);
       if (warn_missing_semi)
-	maybe_warn_missing_semi (list);
+        maybe_warn_missing_semi (list);
       break;
 
     default:
       warning ("unrecognized separator type!");
       break;
     }
 
   // Even if a statement is null, we add it to the list then remove it
@@ -3225,17 +3225,17 @@ set_stmt_print_flag (tree_statement_list
 static tree_statement_list *
 make_statement_list (tree_statement *stmt)
 {
   return new tree_statement_list (stmt);
 }
 
 static tree_statement_list *
 append_statement_list (tree_statement_list *list, char sep,
-		       tree_statement *stmt, bool warn_missing_semi)
+                       tree_statement *stmt, bool warn_missing_semi)
 {
   set_stmt_print_flag (list, sep, warn_missing_semi);
 
   list->append (stmt);
 
   return list;
 }
 
@@ -3277,20 +3277,20 @@ text_getc (FILE *f)
 
   // Convert CRLF into just LF and single CR into LF.
 
   if (c == '\r')
     {
       c = getc (f);
 
       if (c != '\n')
-	{
-	  ungetc (c, f);
-	  c = '\n';
-	}
+        {
+          ungetc (c, f);
+          c = '\n';
+        }
     }
 
   if (c == '\n')
     input_line_number++;
 
   return c;
 }
 
@@ -3316,31 +3316,31 @@ private:
 static bool
 skip_white_space (stream_reader& reader)
 {
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
       switch (c)
-	{
-	case ' ':
-	case '\t':
-	  current_input_column++;
-	  break;
-
-	case '\n':
-	  current_input_column = 0;
-	  break;
-
-	default:
-	  current_input_column--;
-	  reader.ungetc (c);
-	  goto done;
-	}
+        {
+        case ' ':
+        case '\t':
+          current_input_column++;
+          break;
+
+        case '\n':
+          current_input_column = 0;
+          break;
+
+        default:
+          current_input_column--;
+          reader.ungetc (c);
+          goto done;
+        }
     }
 
  done:
 
   return (c == EOF);
 }
 
 static bool
@@ -3376,33 +3376,33 @@ gobble_leading_white_space (FILE *ffile,
 
   stdio_stream_reader stdio_reader (ffile);
 
   while (true)
     {
       eof = skip_white_space (stdio_reader);
 
       if (eof)
-	break;
+        break;
 
       txt = grab_comment_block (stdio_reader, true, eof);
 
       if (txt.empty ())
-	break;
+        break;
 
       if (! (have_help_text || looks_like_copyright (txt)))
-	{
-	  help_txt = txt;
-	  have_help_text = true;
-	}
+        {
+          help_txt = txt;
+          have_help_text = true;
+        }
 
       octave_comment_buffer::append (txt);
 
       if (eof)
-	break;
+        break;
     }
 
   return help_txt;
 }
 
 static bool
 looking_at_function_keyword (FILE *ffile)
 {
@@ -3419,18 +3419,18 @@ looking_at_function_keyword (FILE *ffile
 
   fseek (ffile, pos, SEEK_SET);
 
   return status;
 }
 
 static octave_function *
 parse_fcn_file (const std::string& ff, const std::string& dispatch_type,
-		bool force_script = false, bool require_file = true,
-		const std::string& warn_for = std::string ())
+                bool force_script = false, bool require_file = true,
+                const std::string& warn_for = std::string ())
 {
   unwind_protect frame;
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
   FILE *in_stream = command_editor::get_input_stream ();
@@ -3477,146 +3477,146 @@ parse_fcn_file (const std::string& ff, c
 
   if (ffile)
     {
       bool eof;
 
       std::string help_txt = gobble_leading_white_space (ffile, eof);
 
       if (! eof)
-	{
-	  std::string file_type;
-
-	  frame.protect_var (get_input_from_eval_string);
-	  frame.protect_var (parser_end_of_input);
-	  frame.protect_var (reading_fcn_file);
-	  frame.protect_var (reading_script_file);
-	  frame.protect_var (reading_classdef_file);
-	  frame.protect_var (Vecho_executing_commands);
-
-
-	  get_input_from_eval_string = false;
-	  parser_end_of_input = false;
-
-	  if (! force_script && looking_at_function_keyword (ffile))
-	    {
-	      file_type = "function";
-
-	      Vecho_executing_commands = ECHO_OFF;
-
-	      reading_classdef_file = false;
-	      reading_fcn_file = true;
-	      reading_script_file = false;
-	    }
-	  else if (! force_script && looking_at_classdef_keyword (ffile))
-	    {
-	      file_type = "classdef";
-
-	      Vecho_executing_commands = ECHO_OFF;
-
-	      reading_classdef_file = true;
-	      reading_fcn_file = false;
-	      reading_script_file = false;
-	    }
-	  else
-	    {
-	      file_type = "script";
-
-	      Vecho_executing_commands = ECHO_OFF;
-
-	      reading_classdef_file = false;
-	      reading_fcn_file = false;
-	      reading_script_file = true;
-	    }
-
-	  YY_BUFFER_STATE old_buf = current_buffer ();
-	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
-
-	  frame.add_fcn (switch_to_buffer, old_buf);
-	  frame.add_fcn (delete_buffer, new_buf);
-
-	  switch_to_buffer (new_buf);
-
-	  frame.protect_var (primary_fcn_ptr);
-	  primary_fcn_ptr = 0;
-
-	  reset_parser ();
-
-	  // Do this with an unwind-protect cleanup function so that
-	  // the forced variables will be unmarked in the event of an
-	  // interrupt. 
-	  symbol_table::scope_id scope = symbol_table::top_scope ();
-	  frame.add_fcn (symbol_table::unmark_forced_variables, scope);
-
-	  if (! help_txt.empty ())
-	    help_buf.push (help_txt);
-
-	  if (reading_script_file)
-	    prep_lexer_for_script_file ();
-	  else
-	    prep_lexer_for_function_file ();
-
-	  lexer_flags.parsing_class_method = ! dispatch_type.empty ();
-
-	  int status = yyparse ();
-
-	  fcn_ptr = primary_fcn_ptr;
-
-	  if (reading_fcn_file && endfunction_found && max_function_depth > 1)
-	    warning_with_id ("Octave:nested-functions-coerced",
-			     "nested functions are coerced into subfunctions "
-			     "in file %s", ff.c_str ());
-
-	  if (status != 0)
-	    error ("parse error while reading %s file %s",
-		   file_type.c_str(), ff.c_str ());
-	}
+        {
+          std::string file_type;
+
+          frame.protect_var (get_input_from_eval_string);
+          frame.protect_var (parser_end_of_input);
+          frame.protect_var (reading_fcn_file);
+          frame.protect_var (reading_script_file);
+          frame.protect_var (reading_classdef_file);
+          frame.protect_var (Vecho_executing_commands);
+
+
+          get_input_from_eval_string = false;
+          parser_end_of_input = false;
+
+          if (! force_script && looking_at_function_keyword (ffile))
+            {
+              file_type = "function";
+
+              Vecho_executing_commands = ECHO_OFF;
+
+              reading_classdef_file = false;
+              reading_fcn_file = true;
+              reading_script_file = false;
+            }
+          else if (! force_script && looking_at_classdef_keyword (ffile))
+            {
+              file_type = "classdef";
+
+              Vecho_executing_commands = ECHO_OFF;
+
+              reading_classdef_file = true;
+              reading_fcn_file = false;
+              reading_script_file = false;
+            }
+          else
+            {
+              file_type = "script";
+
+              Vecho_executing_commands = ECHO_OFF;
+
+              reading_classdef_file = false;
+              reading_fcn_file = false;
+              reading_script_file = true;
+            }
+
+          YY_BUFFER_STATE old_buf = current_buffer ();
+          YY_BUFFER_STATE new_buf = create_buffer (ffile);
+
+          frame.add_fcn (switch_to_buffer, old_buf);
+          frame.add_fcn (delete_buffer, new_buf);
+
+          switch_to_buffer (new_buf);
+
+          frame.protect_var (primary_fcn_ptr);
+          primary_fcn_ptr = 0;
+
+          reset_parser ();
+
+          // Do this with an unwind-protect cleanup function so that
+          // the forced variables will be unmarked in the event of an
+          // interrupt. 
+          symbol_table::scope_id scope = symbol_table::top_scope ();
+          frame.add_fcn (symbol_table::unmark_forced_variables, scope);
+
+          if (! help_txt.empty ())
+            help_buf.push (help_txt);
+
+          if (reading_script_file)
+            prep_lexer_for_script_file ();
+          else
+            prep_lexer_for_function_file ();
+
+          lexer_flags.parsing_class_method = ! dispatch_type.empty ();
+
+          int status = yyparse ();
+
+          fcn_ptr = primary_fcn_ptr;
+
+          if (reading_fcn_file && endfunction_found && max_function_depth > 1)
+            warning_with_id ("Octave:nested-functions-coerced",
+                             "nested functions are coerced into subfunctions "
+                             "in file %s", ff.c_str ());
+
+          if (status != 0)
+            error ("parse error while reading %s file %s",
+                   file_type.c_str(), ff.c_str ());
+        }
     }
   else if (require_file)
     error ("no such file, `%s'", ff.c_str ());
   else if (! warn_for.empty ())
     error ("%s: unable to open file `%s'", warn_for.c_str (), ff.c_str ());    
 
   return fcn_ptr;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
-		    std::string& file)
+                    std::string& file)
 {
   std::string retval;
 
   file = fcn_file_in_path (nm);
 
   if (! file.empty ())
     {
       symbol_found = true;
 
       FILE *fptr = fopen (file.c_str (), "r");
 
       if (fptr)
-	{
-	  unwind_protect frame;
-	  frame.add_fcn (safe_fclose, fptr);
-
-	  bool eof;
-	  retval = gobble_leading_white_space (fptr, eof);
-
-	  if (retval.empty ())
-	    {
-	      octave_function *fcn = parse_fcn_file (file, "");
-
-	      if (fcn)
-		{
-		  retval = fcn->doc_string ();
-
-		  delete fcn;
-		}
-	    }
-	}
+        {
+          unwind_protect frame;
+          frame.add_fcn (safe_fclose, fptr);
+
+          bool eof;
+          retval = gobble_leading_white_space (fptr, eof);
+
+          if (retval.empty ())
+            {
+              octave_function *fcn = parse_fcn_file (file, "");
+
+              if (fcn)
+                {
+                  retval = fcn->doc_string ();
+
+                  delete fcn;
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found)
 {
@@ -3662,18 +3662,18 @@ reverse_lookup_autoload (const std::stri
     if (nm == p->second)
       names.append (p->first);
 
   return names;
 }
 
 octave_function *
 load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
-		    const std::string& dispatch_type,
-		    const std::string& fcn_name, bool autoload)
+                    const std::string& dispatch_type,
+                    const std::string& fcn_name, bool autoload)
 {
   octave_function *retval = 0;
 
   unwind_protect frame;
 
   std::string nm = file_name;
 
   size_t nm_len = nm.length ();
@@ -3704,17 +3704,17 @@ load_fcn_from_file (const std::string& f
 
   file = octave_env::make_absolute (file);
 
   int len = file.length ();
 
   if (len > 4 && file.substr (len-4, len-1) == ".oct")
     {
       if (autoload && ! fcn_name.empty ())
-	nm = fcn_name;
+        nm = fcn_name;
 
       retval = octave_dynamic_loader::load_oct (nm, file, fcn_file_from_relative_lookup);
     }
   else if (len > 4 && file.substr (len-4, len-1) == ".mex")
     retval = octave_dynamic_loader::load_mex (nm, file, fcn_file_from_relative_lookup);
   else if (len > 2)
     {
       // These are needed by yyparse.
@@ -3728,21 +3728,21 @@ load_fcn_from_file (const std::string& f
       retval = parse_fcn_file (file, dispatch_type, autoloading);
     }
 
   if (retval)
     {
       retval->stash_dir_name (dir_name);
 
       if (retval->is_user_function ())
-	{
-	  symbol_table::scope_id id = retval->scope ();
-
-	  symbol_table::stash_dir_name_for_subfunctions (id, dir_name);
-	}
+        {
+          symbol_table::scope_id id = retval->scope ();
+
+          symbol_table::stash_dir_name_for_subfunctions (id, dir_name);
+        }
     }
 
   return retval;
 }
 
 DEFUN (autoload, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} autoload (@var{function}, @var{file})\n\
@@ -3783,132 +3783,132 @@ With no arguments, return a structure co
   if (nargin == 0)
     {
       Cell func_names (dim_vector (autoload_map.size ()), 1);
       Cell file_names (dim_vector (autoload_map.size ()), 1);
 
       octave_idx_type i = 0;
       typedef std::map<std::string, std::string>::const_iterator am_iter;
       for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
-	{
-	  func_names(i) = p->first;
-	  file_names(i) = p->second;
-
-	  i++;
-	}
+        {
+          func_names(i) = p->first;
+          file_names(i) = p->second;
+
+          i++;
+        }
 
       Octave_map m;
 
       m.assign ("function", func_names);
       m.assign ("file", file_names);
 
       retval = m;
     }
   else if (nargin == 2)
     {
       string_vector argv = args.make_argv ("autoload");
 
       if (! error_state)
         {
-	  std::string nm = argv[2];
-
-	  if (! octave_env::absolute_pathname (nm))
-	    {
-	      octave_user_code *fcn = octave_call_stack::caller_user_code ();
-
-	      bool found = false;
-
-	      if (fcn)
-		{
-		  std::string fname = fcn->fcn_file_name ();
-
-		  if (! fname.empty ())
-		    {
-		      fname = octave_env::make_absolute (fname);
-		      fname = fname.substr (0, fname.find_last_of (file_ops::dir_sep_str ()) + 1);
-
-		      file_stat fs (fname + nm);
-
-		      if (fs.exists ())
-			{
-			  nm = fname + nm;
-			  found = true;
-			}
-		    }
-		}
-	      if (! found)
-		warning_with_id ("Octave:autoload-relative-file-name",
-				 "autoload: `%s' is not an absolute file name",
-				 nm.c_str ());
-	    }
-	  autoload_map[argv[1]] = nm;
-	}
+          std::string nm = argv[2];
+
+          if (! octave_env::absolute_pathname (nm))
+            {
+              octave_user_code *fcn = octave_call_stack::caller_user_code ();
+
+              bool found = false;
+
+              if (fcn)
+                {
+                  std::string fname = fcn->fcn_file_name ();
+
+                  if (! fname.empty ())
+                    {
+                      fname = octave_env::make_absolute (fname);
+                      fname = fname.substr (0, fname.find_last_of (file_ops::dir_sep_str ()) + 1);
+
+                      file_stat fs (fname + nm);
+
+                      if (fs.exists ())
+                        {
+                          nm = fname + nm;
+                          found = true;
+                        }
+                    }
+                }
+              if (! found)
+                warning_with_id ("Octave:autoload-relative-file-name",
+                                 "autoload: `%s' is not an absolute file name",
+                                 nm.c_str ());
+            }
+          autoload_map[argv[1]] = nm;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 void
 source_file (const std::string& file_name, const std::string& context,
-	     bool verbose, bool require_file, const std::string& warn_for)
+             bool verbose, bool require_file, const std::string& warn_for)
 {
   std::string file_full_name = file_ops::tilde_expand (file_name);
 
   unwind_protect frame;
 
   frame.protect_var (curr_fcn_file_name);
   frame.protect_var (curr_fcn_file_full_name);
 
   curr_fcn_file_name = file_name;
   curr_fcn_file_full_name = file_full_name;
 
   if (! context.empty ())
     {
       if (context == "caller")
-	octave_call_stack::goto_caller_frame ();
+        octave_call_stack::goto_caller_frame ();
       else if (context == "base")
-	octave_call_stack::goto_base_frame ();
+        octave_call_stack::goto_base_frame ();
       else
-	error ("source: context must be \"caller\" or \"base\"");
+        error ("source: context must be \"caller\" or \"base\"");
 
       if (! error_state)
-	frame.add_fcn (octave_call_stack::pop);
+        frame.add_fcn (octave_call_stack::pop);
     }      
 
   if (! error_state)
     {
       octave_function *fcn = parse_fcn_file (file_full_name, "", true,
-					     require_file, warn_for);
+                                             require_file, warn_for);
 
       if (! error_state)
-	{
-	  if (fcn && fcn->is_user_script ())
-	    {
-	      octave_value_list args;
-
-	      if (verbose)
-		{
-		  std::cout << "executing commands from " << file_full_name << " ... ";
-		  reading_startup_message_printed = true;
-		  std::cout.flush ();
-		}
-
-	      fcn->do_multi_index_op (0, args);
-
-	      if (verbose)
-		std::cout << "done." << std::endl;
-
-	      delete fcn;
-	    }
-	}
+        {
+          if (fcn && fcn->is_user_script ())
+            {
+              octave_value_list args;
+
+              if (verbose)
+                {
+                  std::cout << "executing commands from " << file_full_name << " ... ";
+                  reading_startup_message_printed = true;
+                  std::cout.flush ();
+                }
+
+              fcn->do_multi_index_op (0, args);
+
+              if (verbose)
+                std::cout << "done." << std::endl;
+
+              delete fcn;
+            }
+        }
       else
-	error ("source: error sourcing file `%s'",
-	       file_full_name.c_str ());
+        error ("source: error sourcing file `%s'",
+               file_full_name.c_str ());
     }
 }
 
 DEFUN (mfilename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (@code{\"fullpath\"})\n\
 @deftypefnx {Built-in Function} {} mfilename (@code{\"fullpathext\"})\n\
@@ -3931,20 +3931,20 @@ of the file name and the extension.\n\
 
   std::string arg;
 
   if (nargin == 1)
     {
       arg = args(0).string_value ();
 
       if (error_state)
-	{
-	  error ("mfilename: expecting argument to be a character string");
-	  return retval;
-	}
+        {
+          error ("mfilename: expecting argument to be a character string");
+          return retval;
+        }
     }
 
   std::string fname;
 
   octave_user_code *fcn = octave_call_stack::caller_user_code ();
 
   if (fcn)
     {
@@ -3962,17 +3962,17 @@ of the file name and the extension.\n\
       size_t epos = fname.rfind ('.');
 
       if (epos <= dpos)
         epos = std::string::npos;
 
       fname = (epos != std::string::npos) ? fname.substr (0, epos) : fname;
 
       if (arg == "fullpath")
-	retval = fname;
+        retval = fname;
       else
         retval = (dpos != std::string::npos) ? fname.substr (dpos+1) : fname;
     }
 
   return retval;
 }
 
 
@@ -3988,29 +3988,29 @@ be named @file{@var{file}.m}.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string file_name = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string context;
-
-	  if (nargin == 2)
-	    context = args(1).string_value ();
-
-	  if (! error_state)
-	    source_file (file_name, context);
-	  else
-	    error ("source: expecting context to be character string");
-	}
+        {
+          std::string context;
+
+          if (nargin == 2)
+            context = args(1).string_value ();
+
+          if (! error_state)
+            source_file (file_name, context);
+          else
+            error ("source: expecting context to be character string");
+        }
       else
-	error ("source: expecting file name as argument");
+        error ("source: expecting file name as argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // Evaluate an Octave function (built-in or interpreted) and return
@@ -4063,17 +4063,17 @@ get_feval_args (const octave_value_list&
 
       int n = arg_names.length () - 1;
 
       int len = n > tmp_nargin ? tmp_nargin : n;
 
       string_vector tmp_arg_names (len);
 
       for (int i = 0; i < len; i++)
-	tmp_arg_names(i) = arg_names(i+1);
+        tmp_arg_names(i) = arg_names(i+1);
 
       retval.stash_name_tags (tmp_arg_names);
     }
 
   return retval;
 }
 
 
@@ -4091,36 +4091,36 @@ feval (const octave_value_list& args, in
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       octave_value f_arg = args(0);
 
       if (f_arg.is_string ())
         {
-	  std::string name = f_arg.string_value ();
-
-	  if (! error_state)
-	    {
-	      octave_value_list tmp_args = get_feval_args (args);
-
-	      retval = feval (name, tmp_args, nargout);
-	    }
-	}
+          std::string name = f_arg.string_value ();
+
+          if (! error_state)
+            {
+              octave_value_list tmp_args = get_feval_args (args);
+
+              retval = feval (name, tmp_args, nargout);
+            }
+        }
       else
-	{
-	  octave_function *fcn = f_arg.function_value ();
-
-	  if (fcn)
-	    {
-	      octave_value_list tmp_args = get_feval_args (args);
-
-	      retval = feval (fcn, tmp_args, nargout);
-	    }
-	}
+        {
+          octave_function *fcn = f_arg.function_value ();
+
+          if (fcn)
+            {
+              octave_value_list tmp_args = get_feval_args (args);
+
+              retval = feval (fcn, tmp_args, nargout);
+            }
+        }
     }
 
   return retval;
 }
 
 DEFUN (feval, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} feval (@var{name}, @dots{})\n\
@@ -4218,66 +4218,66 @@ eval_string (const std::string& s, bool 
       tree_statement_list *command_list = global_command;
 
       // Unmark forced variables.
       // Restore previous value of global_command.
       frame.run_top (2);
 
       if (parse_status == 0)
         {
-	  if (command_list)
-	    {
-	      tree_statement *stmt = 0;
-
-	      if (command_list->length () == 1
-		  && (stmt = command_list->front ())
-		  && stmt->is_expression ())
-		{
-		  tree_expression *expr = stmt->expression ();
-
-		  if (silent)
-		    expr->set_print_flag (false);
-
-		  bool do_bind_ans = false;
-
-		  if (expr->is_identifier ())
-		    {
-		      tree_identifier *id
-			= dynamic_cast<tree_identifier *> (expr);
-
-		      do_bind_ans = (! id->is_variable ());
-		    }
-		  else
-		    do_bind_ans = (! expr->is_assignment_expression ());
-
-		  retval = expr->rvalue (nargout);
-
-		  if (do_bind_ans && ! (error_state || retval.empty ()))
-		    bind_ans (retval(0), expr->print_result ());
-
-		  if (nargout == 0)
-		    retval = octave_value_list ();
-		}
-	      else if (nargout == 0)
-		command_list->accept (*current_evaluator);
-	      else
-		error ("eval: invalid use of statement list");
-
-	      delete command_list;
-
-	      command_list = 0;
-
-	      if (error_state
-		  || tree_return_command::returning
-		  || tree_break_command::breaking
-		  || tree_continue_command::continuing)
-		break;
-	    }
-	  else if (parser_end_of_input)
-	    break;
+          if (command_list)
+            {
+              tree_statement *stmt = 0;
+
+              if (command_list->length () == 1
+                  && (stmt = command_list->front ())
+                  && stmt->is_expression ())
+                {
+                  tree_expression *expr = stmt->expression ();
+
+                  if (silent)
+                    expr->set_print_flag (false);
+
+                  bool do_bind_ans = false;
+
+                  if (expr->is_identifier ())
+                    {
+                      tree_identifier *id
+                        = dynamic_cast<tree_identifier *> (expr);
+
+                      do_bind_ans = (! id->is_variable ());
+                    }
+                  else
+                    do_bind_ans = (! expr->is_assignment_expression ());
+
+                  retval = expr->rvalue (nargout);
+
+                  if (do_bind_ans && ! (error_state || retval.empty ()))
+                    bind_ans (retval(0), expr->print_result ());
+
+                  if (nargout == 0)
+                    retval = octave_value_list ();
+                }
+              else if (nargout == 0)
+                command_list->accept (*current_evaluator);
+              else
+                error ("eval: invalid use of statement list");
+
+              delete command_list;
+
+              command_list = 0;
+
+              if (error_state
+                  || tree_return_command::returning
+                  || tree_break_command::breaking
+                  || tree_continue_command::continuing)
+                break;
+            }
+          else if (parser_end_of_input)
+            break;
         }
     }
   while (parse_status == 0);
 
   return retval;
 }
 
 octave_value
@@ -4290,17 +4290,17 @@ eval_string (const std::string& s, bool 
   if (! tmp.empty ())
     retval = tmp(0);
 
   return retval;
 }
 
 static octave_value_list
 eval_string (const octave_value& arg, bool silent, int& parse_status,
-	     int nargout)
+             int nargout)
 {
   std::string s = arg.string_value ();
 
   if (error_state)
     {
       error ("eval: expecting std::string argument");
       return octave_value (-1);
     }
@@ -4338,42 +4338,42 @@ eval ('error (\"This is a bad example\")
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       unwind_protect frame;
 
       if (nargin > 1)
-	{
-	  frame.protect_var (buffer_error_messages);
-	  buffer_error_messages++;
-	}
+        {
+          frame.protect_var (buffer_error_messages);
+          buffer_error_messages++;
+        }
 
       int parse_status = 0;
 
       octave_value_list tmp = eval_string (args(0), nargout > 0,
-					   parse_status, nargout);
+                                           parse_status, nargout);
 
       if (nargin > 1 && (parse_status != 0 || error_state))
-	{
-	  error_state = 0;
-
-	  // Set up for letting the user print any messages from
-	  // errors that occurred in the first part of this eval().
-
-	  buffer_error_messages--;
-
-	  tmp = eval_string (args(1), nargout > 0, parse_status, nargout);
-
-	  if (nargout > 0)
-	    retval = tmp;
-	}
+        {
+          error_state = 0;
+
+          // Set up for letting the user print any messages from
+          // errors that occurred in the first part of this eval().
+
+          buffer_error_messages--;
+
+          tmp = eval_string (args(1), nargout > 0, parse_status, nargout);
+
+          if (nargout > 0)
+            retval = tmp;
+        }
       else if (nargout > 0)
-	retval = tmp;
+        retval = tmp;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -4471,42 +4471,42 @@ may be either @code{\"base\"} or @code{\
   int nargin = args.length ();
 
   if (nargin == 3)
     {
       std::string context = args(0).string_value ();
 
       if (! error_state)
         {
-	  unwind_protect frame;
-
-	  if (context == "caller")
-	    octave_call_stack::goto_caller_frame ();
-	  else if (context == "base")
-	    octave_call_stack::goto_base_frame ();
-	  else
-	    error ("assignin: context must be \"caller\" or \"base\"");
-
-	  if (! error_state)
-	    {
-	      frame.add_fcn (octave_call_stack::pop);
-
-	      std::string nm = args(1).string_value ();
-
-	      if (! error_state)
-		{
-		  if (valid_identifier (nm))
-		    symbol_table::varref (nm) = args(2);
-		  else
-		    error ("assignin: invalid variable name");
-		}
-	      else
-		error ("assignin: expecting variable name as second argument");
-	    }
-	}
+          unwind_protect frame;
+
+          if (context == "caller")
+            octave_call_stack::goto_caller_frame ();
+          else if (context == "base")
+            octave_call_stack::goto_base_frame ();
+          else
+            error ("assignin: context must be \"caller\" or \"base\"");
+
+          if (! error_state)
+            {
+              frame.add_fcn (octave_call_stack::pop);
+
+              std::string nm = args(1).string_value ();
+
+              if (! error_state)
+                {
+                  if (valid_identifier (nm))
+                    symbol_table::varref (nm) = args(2);
+                  else
+                    error ("assignin: invalid variable name");
+                }
+              else
+                error ("assignin: expecting variable name as second argument");
+            }
+        }
       else
         error ("assignin: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -4524,59 +4524,59 @@ context @var{context}, which may be eith
   int nargin = args.length ();
 
   if (nargin > 1)
     {
       std::string context = args(0).string_value ();
 
       if (! error_state)
         {
-	  unwind_protect frame;
-
-	  if (context == "caller")
-	    octave_call_stack::goto_caller_frame ();
-	  else if (context == "base")
-	    octave_call_stack::goto_base_frame ();
-	  else
-	    error ("evalin: context must be \"caller\" or \"base\"");
-
-	  if (! error_state)
-	    {
-	      frame.add_fcn (octave_call_stack::pop);
-
-	      if (nargin > 2)
-	        {
-		  frame.protect_var (buffer_error_messages);
-		  buffer_error_messages++;
-		}
-
-	      int parse_status = 0;
-
-	      octave_value_list tmp = eval_string (args(1), nargout > 0,
-						   parse_status, nargout);
-
-	      if (nargout > 0)
-		retval = tmp;
-
-	      if (nargin > 2 && (parse_status != 0 || error_state))
-		{
-		  error_state = 0;
-
-		  // Set up for letting the user print any messages from
-		  // errors that occurred in the first part of this eval().
-
-		  buffer_error_messages--;
-
-		  tmp = eval_string (args(2), nargout > 0,
-				     parse_status, nargout);
-
-		  retval = (nargout > 0) ? tmp : octave_value_list ();
-		}
-	    }
-	}
+          unwind_protect frame;
+
+          if (context == "caller")
+            octave_call_stack::goto_caller_frame ();
+          else if (context == "base")
+            octave_call_stack::goto_base_frame ();
+          else
+            error ("evalin: context must be \"caller\" or \"base\"");
+
+          if (! error_state)
+            {
+              frame.add_fcn (octave_call_stack::pop);
+
+              if (nargin > 2)
+                {
+                  frame.protect_var (buffer_error_messages);
+                  buffer_error_messages++;
+                }
+
+              int parse_status = 0;
+
+              octave_value_list tmp = eval_string (args(1), nargout > 0,
+                                                   parse_status, nargout);
+
+              if (nargout > 0)
+                retval = tmp;
+
+              if (nargin > 2 && (parse_status != 0 || error_state))
+                {
+                  error_state = 0;
+
+                  // Set up for letting the user print any messages from
+                  // errors that occurred in the first part of this eval().
+
+                  buffer_error_messages--;
+
+                  tmp = eval_string (args(2), nargout > 0,
+                                     parse_status, nargout);
+
+                  retval = (nargout > 0) ? tmp : octave_value_list ();
+                }
+            }
+        }
       else
         error ("evalin: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -4587,14 +4587,14 @@ DEFUN (__parser_debug_flag__, args, narg
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   bool debug_flag = octave_debug;
 
   retval = set_internal_variable (debug_flag, args, nargout,
-           			  "__parser_debug_flag__");
+                                  "__parser_debug_flag__");
 
   octave_debug = debug_flag;
 
   return retval;
 }
diff --git a/src/oct-prcstrm.cc b/src/oct-prcstrm.cc
--- a/src/oct-prcstrm.cc
+++ b/src/oct-prcstrm.cc
@@ -27,45 +27,45 @@ along with Octave; see the file COPYING.
 
 #include <cstdio>
 
 #include "oct-prcstrm.h"
 #include "sysdep.h"
 
 octave_stream
 octave_iprocstream::create (const std::string& n, std::ios::openmode arg_md,
-			    oct_mach_info::float_format ff)
+                            oct_mach_info::float_format ff)
 {
   return octave_stream (new octave_iprocstream (n, arg_md, ff));
 }
 
 octave_iprocstream::octave_iprocstream (const std::string& n,
-					std::ios::openmode arg_md,
-					oct_mach_info::float_format ff)
+                                        std::ios::openmode arg_md,
+                                        oct_mach_info::float_format ff)
   : octave_stdiostream (n, octave_popen (n.c_str (), "r"),
-			arg_md, ff, octave_pclose)
+                        arg_md, ff, octave_pclose)
 {
 }
 
 octave_iprocstream::~octave_iprocstream (void)
 {
   do_close ();
 }
 
 octave_stream
 octave_oprocstream::create (const std::string& n, std::ios::openmode arg_md,
-			    oct_mach_info::float_format ff)
+                            oct_mach_info::float_format ff)
 {
   return octave_stream (new octave_oprocstream (n, arg_md, ff));
 }
 
 octave_oprocstream::octave_oprocstream (const std::string& n,
-					std::ios::openmode arg_md,
-					oct_mach_info::float_format ff)
+                                        std::ios::openmode arg_md,
+                                        oct_mach_info::float_format ff)
   : octave_stdiostream (n, octave_popen (n.c_str (), "w"),
-			arg_md, ff, octave_pclose)
+                        arg_md, ff, octave_pclose)
 {
 }
 
 octave_oprocstream::~octave_oprocstream (void)
 {
   do_close ();
 }
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -103,33 +103,33 @@ octave_procbuf::open (const char *comman
 
   proc_pid = ::fork ();
 
   if (proc_pid == 0)
     {
       ::close (parent_end);
 
       if (child_end != child_std_end)
-	{
-	  ::dup2 (child_end, child_std_end);
-	  ::close (child_end);
-	}
+        {
+          ::dup2 (child_end, child_std_end);
+          ::close (child_end);
+        }
 
       while (octave_procbuf_list)
-	{
-	  FILE *fp = octave_procbuf_list->f;
+        {
+          FILE *fp = octave_procbuf_list->f;
 
-	  if (fp)
-	    {
-	      ::fclose (fp);
-	      fp = 0;
-	    }
+          if (fp)
+            {
+              ::fclose (fp);
+              fp = 0;
+            }
 
-	  octave_procbuf_list = octave_procbuf_list->next;
-	}
+          octave_procbuf_list = octave_procbuf_list->next;
+        }
 
       execl ("/bin/sh", "sh", "-c", command, static_cast<void *> (0));
 
       exit (127);
     }
 
   ::close (child_end);
 
@@ -177,37 +177,37 @@ octave_procbuf::close (void)
 
   if (f)
     {
       pid_t wait_pid;
 
       int status = -1;
 
       for (octave_procbuf **ptr = &octave_procbuf_list;
-	   *ptr != 0;
-	   ptr = &(*ptr)->next)
-	{
-	  if (*ptr == this)
-	    {
-	      *ptr = (*ptr)->next;
-	      status = 0;
-	      break;
-	    }
-	}
+           *ptr != 0;
+           ptr = &(*ptr)->next)
+        {
+          if (*ptr == this)
+            {
+              *ptr = (*ptr)->next;
+              status = 0;
+              break;
+            }
+        }
 
       if (status == 0 && ::fclose (f) == 0)
-	{
-	  using namespace std;
+        {
+          using namespace std;
 
-	  do
-	    {
-	      wait_pid = octave_syscalls::waitpid (proc_pid, &wstatus, 0);
-	    }
-	  while (wait_pid == -1 && errno == EINTR);
-	}
+          do
+            {
+              wait_pid = octave_syscalls::waitpid (proc_pid, &wstatus, 0);
+            }
+          while (wait_pid == -1 && errno == EINTR);
+        }
 
       f = 0;
     }
 
   open_p = false;
 
   return this;
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -65,60 +65,60 @@ convert_to_valid_int (const octave_value
 
   conv_err = 0;
 
   double dval = tc.double_value ();
 
   if (! error_state)
     {
       if (! lo_ieee_isnan (dval))
-	{
-	  int ival = NINT (dval);
-
-	  if (ival == dval)
-	    retval = ival;
-	  else
-	    conv_err = 3;
-	}
+        {
+          int ival = NINT (dval);
+
+          if (ival == dval)
+            retval = ival;
+          else
+            conv_err = 3;
+        }
       else
-	conv_err = 2;
+        conv_err = 2;
     }
   else
     conv_err = 1;
 
   return retval;
 }
 
 static int
 get_size (double d, const std::string& who)
 {
   int retval = -1;
 
   if (! lo_ieee_isnan (d))
     {
       if (! xisinf (d))
-	{
-	  if (d >= 0.0)
-	    retval = NINT (d);
-	  else
-	    ::error ("%s: negative value invalid as size specification",
-		     who.c_str ());
-	}
+        {
+          if (d >= 0.0)
+            retval = NINT (d);
+          else
+            ::error ("%s: negative value invalid as size specification",
+                     who.c_str ());
+        }
       else
-	retval = -1;
+        retval = -1;
     }
   else
     ::error ("%s: NaN is invalid as size specification", who.c_str ());
 
   return retval;
 }
 
 static void
 get_size (const Array<double>& size, octave_idx_type& nr, octave_idx_type& nc, bool& one_elt_size_spec,
-	  const std::string& who)
+          const std::string& who)
 {
   nr = -1;
   nc = -1;
 
   one_elt_size_spec = false;
 
   double dnr = -1.0;
   double dnc = -1.0;
@@ -133,29 +133,29 @@ get_size (const Array<double>& size, oct
 
       dnc = (dnr == 0.0) ? 0.0 : 1.0;
     }
   else if (sz_len == 2)
     {
       dnr = size (0);
 
       if (! xisinf (dnr))
-	dnc = size (1);
+        dnc = size (1);
       else
-	::error ("%s: invalid size specification", who.c_str ());
+        ::error ("%s: invalid size specification", who.c_str ());
     }
   else
     ::error ("%s: invalid size specification", who.c_str ());
 
   if (! error_state)
     {
       nr = get_size (dnr, who);
 
       if (! error_state && dnc >= 0.0)
-	nc = get_size (dnc, who);
+        nc = get_size (dnc, who);
     }
 }
 
 scanf_format_list::scanf_format_list (const std::string& s)
   : nconv (0), curr_idx (0), list (16), buf (0)
 {
   octave_idx_type num_elts = 0;
 
@@ -170,64 +170,64 @@ scanf_format_list::scanf_format_list (co
 
   bool have_more = true;
 
   while (i < n)
     {
       have_more = true;
 
       if (! buf)
-	buf = new std::ostringstream ();
+        buf = new std::ostringstream ();
 
       if (s[i] == '%')
-	{
-	  // Process percent-escape conversion type.
-
-	  process_conversion (s, i, n, width, discard, type, modifier,
-			      num_elts);
-
-	  have_more = (buf != 0);
-	}
+        {
+          // Process percent-escape conversion type.
+
+          process_conversion (s, i, n, width, discard, type, modifier,
+                              num_elts);
+
+          have_more = (buf != 0);
+        }
       else if (isspace (s[i]))
-	{
-	  type = scanf_format_elt::whitespace_conversion;
-
-	  width = 0;
-	  discard = false;
-	  modifier = '\0';
-	  *buf << " ";
-
-	  while (++i < n && isspace (s[i]))
-	    /* skip whitespace */;
-
-	  add_elt_to_list (width, discard, type, modifier, num_elts);
-
-	  have_more = false;
-	}
+        {
+          type = scanf_format_elt::whitespace_conversion;
+
+          width = 0;
+          discard = false;
+          modifier = '\0';
+          *buf << " ";
+
+          while (++i < n && isspace (s[i]))
+            /* skip whitespace */;
+
+          add_elt_to_list (width, discard, type, modifier, num_elts);
+
+          have_more = false;
+        }
       else
-	{
-	  type = scanf_format_elt::literal_conversion;
-
-	  width = 0;
-	  discard = false;
-	  modifier = '\0';
-
-	  while (i < n && ! isspace (s[i]) && s[i] != '%')
-	    *buf << s[i++];
-
-	  add_elt_to_list (width, discard, type, modifier, num_elts);
-
-	  have_more = false;
-	}
+        {
+          type = scanf_format_elt::literal_conversion;
+
+          width = 0;
+          discard = false;
+          modifier = '\0';
+
+          while (i < n && ! isspace (s[i]) && s[i] != '%')
+            *buf << s[i++];
+
+          add_elt_to_list (width, discard, type, modifier, num_elts);
+
+          have_more = false;
+        }
 
       if (nconv < 0)
-	{
-	  have_more = false;
-	  break;
-	}
+        {
+          have_more = false;
+          break;
+        }
     }
 
   if (have_more)
     add_elt_to_list (width, discard, type, modifier, num_elts);
 
   list.resize (num_elts);
 
   delete buf;
@@ -236,39 +236,39 @@ scanf_format_list::scanf_format_list (co
 scanf_format_list::~scanf_format_list (void)
 {
   octave_idx_type n = list.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       scanf_format_elt *elt = list(i);
       delete elt;
-    }	
+    }   
 }
 
 void
 scanf_format_list::add_elt_to_list (int width, bool discard, char type,
-				    char modifier, octave_idx_type& num_elts,
-				    const std::string& char_class)
+                                    char modifier, octave_idx_type& num_elts,
+                                    const std::string& char_class)
 {
   if (buf)
     {
       std::string text = buf->str ();
 
       if (! text.empty ())
-	{
-	  scanf_format_elt *elt
-	    = new scanf_format_elt (text.c_str (), width, discard, type,
-				    modifier, char_class);
-
-	  if (num_elts == list.length ())
-	    list.resize (2 * num_elts);
-
-	  list(num_elts++) = elt;
-	}
+        {
+          scanf_format_elt *elt
+            = new scanf_format_elt (text.c_str (), width, discard, type,
+                                    modifier, char_class);
+
+          if (num_elts == list.length ())
+            list.resize (2 * num_elts);
+
+          list(num_elts++) = elt;
+        }
 
       delete buf;
       buf = 0;
     }
 }
 
 static std::string
 expand_char_class (const std::string& s)
@@ -279,32 +279,32 @@ expand_char_class (const std::string& s)
 
   size_t i = 0;
 
   while (i < len)
     {
       unsigned char c = s[i++];
 
       if (c == '-' && i > 1 && i < len
-	  && static_cast<unsigned char> (s[i-2]) <= static_cast<unsigned char> (s[i]))
-	{
-	  // Add all characters from the range except the first (we
-	  // already added it below).
-
-	  for (c = s[i-2]+1; c < s[i]; c++)
-	    retval += c;
-	}
+          && static_cast<unsigned char> (s[i-2]) <= static_cast<unsigned char> (s[i]))
+        {
+          // Add all characters from the range except the first (we
+          // already added it below).
+
+          for (c = s[i-2]+1; c < s[i]; c++)
+            retval += c;
+        }
       else
-	{
-	  // Add the character to the class.  Only add '-' if it is
-	  // the last character in the class.
-
-	  if (c != '-' || i == len)
-	    retval += c;
-	}
+        {
+          // Add the character to the class.  Only add '-' if it is
+          // the last character in the class.
+
+          if (c != '-' || i == len)
+            retval += c;
+        }
     }
 
   return retval;
 }
 
 void
 scanf_format_list::process_conversion (const std::string& s, size_t& i,
                                        size_t n, int& width, bool& discard,
@@ -318,96 +318,96 @@ scanf_format_list::process_conversion (c
 
   *buf << s[i++];
 
   bool have_width = false;
 
   while (i < n)
     {
       switch (s[i])
-	{
-	case '*':
-	  if (discard)
-	    nconv = -1;
-	  else
-	    {
-	      discard = true;
-	      *buf << s[i++];
-	    }
-	  break;
-
-	case '0': case '1': case '2': case '3': case '4':
-	case '5': case '6': case '7': case '8': case '9':
-	  if (have_width)
-	    nconv = -1;
-	  else
-	    {
-	      char c = s[i++];
-	      width = width * 10 + c - '0';
-	      have_width = true;
-	      *buf << c;
-	      while (i < n && isdigit (s[i]))
-		{
-		  c = s[i++];
-		  width = width * 10 + c - '0';
-		  *buf << c;
-		}
-	    }
-	  break;
-
-	case 'h': case 'l': case 'L':
-	  if (modifier != '\0')
-	    nconv = -1;
-	  else
-	    modifier = s[i++];
-	  break;
-
-	case 'd': case 'i': case 'o': case 'u': case 'x':
-	  if (modifier == 'L')
-	    {
-	      nconv = -1;
-	      break;
-	    }
-	  goto fini;
-
-	case 'e': case 'f': case 'g':
-	  if (modifier == 'h')
-	    {
-	      nconv = -1;
-	      break;
-	    }
-
-	  // No float or long double conversions, thanks.
-	  *buf << 'l';
-
-	  goto fini;
-
-	case 'c': case 's': case 'p': case '%': case '[':
-	  if (modifier != '\0')
-	    {
-	      nconv = -1;
-	      break;
-	    }
-	  goto fini;
-
-	fini:
-	  {
-	    if (finish_conversion (s, i, n, width, discard, type,
-				   modifier, num_elts) == 0)
-	      return;
-	  }
-	  break;
-
-	default:
-	  nconv = -1;
-	  break;
-	}
+        {
+        case '*':
+          if (discard)
+            nconv = -1;
+          else
+            {
+              discard = true;
+              *buf << s[i++];
+            }
+          break;
+
+        case '0': case '1': case '2': case '3': case '4':
+        case '5': case '6': case '7': case '8': case '9':
+          if (have_width)
+            nconv = -1;
+          else
+            {
+              char c = s[i++];
+              width = width * 10 + c - '0';
+              have_width = true;
+              *buf << c;
+              while (i < n && isdigit (s[i]))
+                {
+                  c = s[i++];
+                  width = width * 10 + c - '0';
+                  *buf << c;
+                }
+            }
+          break;
+
+        case 'h': case 'l': case 'L':
+          if (modifier != '\0')
+            nconv = -1;
+          else
+            modifier = s[i++];
+          break;
+
+        case 'd': case 'i': case 'o': case 'u': case 'x':
+          if (modifier == 'L')
+            {
+              nconv = -1;
+              break;
+            }
+          goto fini;
+
+        case 'e': case 'f': case 'g':
+          if (modifier == 'h')
+            {
+              nconv = -1;
+              break;
+            }
+
+          // No float or long double conversions, thanks.
+          *buf << 'l';
+
+          goto fini;
+
+        case 'c': case 's': case 'p': case '%': case '[':
+          if (modifier != '\0')
+            {
+              nconv = -1;
+              break;
+            }
+          goto fini;
+
+        fini:
+          {
+            if (finish_conversion (s, i, n, width, discard, type,
+                                   modifier, num_elts) == 0)
+              return;
+          }
+          break;
+
+        default:
+          nconv = -1;
+          break;
+        }
 
       if (nconv < 0)
-	break;
+        break;
     }
 
   nconv = -1;
 }
 
 int
 scanf_format_list::finish_conversion (const std::string& s, size_t& i,
                                       size_t n, int& width, bool discard,
@@ -426,63 +426,63 @@ scanf_format_list::finish_conversion (co
       type = '%';
       *buf << s[i++];
     }
   else
     {
       type = s[i];
 
       if (s[i] == '[')
-	{
-	  *buf << s[i++];
-
-	  if (i < n)
-	    {
-	      beg_idx = i;
-
-	      if (s[i] == '^')
-		{
-		  type = '^';
-		  *buf << s[i++];
-
-		  if (i < n)
-		    {
-		      beg_idx = i;
-
-		      if (s[i] == ']')
-			*buf << s[i++];
-		    }
-		}
-	      else if (s[i] == ']')
-		*buf << s[i++];
-	    }
-
-	  while (i < n && s[i] != ']')
-	    *buf << s[i++];
-
-	  if (i < n && s[i] == ']')
-	    {
-	      end_idx = i-1;
-	      *buf << s[i++];
-	    }
-
-	  if (s[i-1] != ']')
-	    retval = nconv = -1;
-	}
+        {
+          *buf << s[i++];
+
+          if (i < n)
+            {
+              beg_idx = i;
+
+              if (s[i] == '^')
+                {
+                  type = '^';
+                  *buf << s[i++];
+
+                  if (i < n)
+                    {
+                      beg_idx = i;
+
+                      if (s[i] == ']')
+                        *buf << s[i++];
+                    }
+                }
+              else if (s[i] == ']')
+                *buf << s[i++];
+            }
+
+          while (i < n && s[i] != ']')
+            *buf << s[i++];
+
+          if (i < n && s[i] == ']')
+            {
+              end_idx = i-1;
+              *buf << s[i++];
+            }
+
+          if (s[i-1] != ']')
+            retval = nconv = -1;
+        }
       else
-	*buf << s[i++];
+        *buf << s[i++];
 
       nconv++;
     }
 
   if (nconv >= 0)
     {
       if (beg_idx != std::string::npos && end_idx != std::string::npos)
-	char_class = expand_char_class (s.substr (beg_idx,
-						  end_idx - beg_idx + 1));
+        char_class = expand_char_class (s.substr (beg_idx,
+                                                  end_idx - beg_idx + 1));
 
       add_elt_to_list (width, discard, type, modifier, num_elts, char_class);
     }
 
   return retval;
 }
 
 void
@@ -490,86 +490,86 @@ scanf_format_list::printme (void) const
 {
   octave_idx_type n = list.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       scanf_format_elt *elt = list(i);
 
       std::cerr
-	<< "width:      " << elt->width << "\n"
-	<< "discard:    " << elt->discard << "\n"
-	<< "type:       ";
+        << "width:      " << elt->width << "\n"
+        << "discard:    " << elt->discard << "\n"
+        << "type:       ";
 
       if (elt->type == scanf_format_elt::literal_conversion)
-	std::cerr << "literal text\n";
+        std::cerr << "literal text\n";
       else if (elt->type == scanf_format_elt::whitespace_conversion)
-	std::cerr << "whitespace\n";
+        std::cerr << "whitespace\n";
       else
-	std::cerr << elt->type << "\n";
+        std::cerr << elt->type << "\n";
 
       std::cerr
-	<< "modifier:   " << elt->modifier << "\n"
-	<< "char_class: `" << undo_string_escapes (elt->char_class) << "'\n"
-	<< "text:       `" << undo_string_escapes (elt->text) << "'\n\n";
+        << "modifier:   " << elt->modifier << "\n"
+        << "char_class: `" << undo_string_escapes (elt->char_class) << "'\n"
+        << "text:       `" << undo_string_escapes (elt->text) << "'\n\n";
     }
 }
 
 bool
 scanf_format_list::all_character_conversions (void)
 {
   octave_idx_type n = list.length ();
 
   if (n > 0)
     {
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  scanf_format_elt *elt = list(i);
-
-	  switch (elt->type)
-	    {
-	    case 'c': case 's': case '%': case '[': case '^':
-	    case scanf_format_elt::literal_conversion:
-	    case scanf_format_elt::whitespace_conversion:
-	      break;
-
-	    default:
-	      return false;
-	      break;
-	    }
-	}
+        {
+          scanf_format_elt *elt = list(i);
+
+          switch (elt->type)
+            {
+            case 'c': case 's': case '%': case '[': case '^':
+            case scanf_format_elt::literal_conversion:
+            case scanf_format_elt::whitespace_conversion:
+              break;
+
+            default:
+              return false;
+              break;
+            }
+        }
 
       return true;
     }
   else
     return false;
 }
 
 bool
 scanf_format_list::all_numeric_conversions (void)
 {
   octave_idx_type n = list.length ();
 
   if (n > 0)
     {
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  scanf_format_elt *elt = list(i);
-
-	  switch (elt->type)
-	    {
-	    case 'd': case 'i': case 'o': case 'u': case 'x':
-	    case 'e': case 'f': case 'g':
-	      break;
-
-	    default:
-	      return false;
-	      break;
-	    }
-	}
+        {
+          scanf_format_elt *elt = list(i);
+
+          switch (elt->type)
+            {
+            case 'd': case 'i': case 'o': case 'u': case 'x':
+            case 'e': case 'f': case 'g':
+              break;
+
+            default:
+              return false;
+              break;
+            }
+        }
 
       return true;
     }
   else
     return false;
 }
 
 // Ugh again.
@@ -591,112 +591,112 @@ printf_format_list::printf_format_list (
   char type = '\0';
 
   bool have_more = true;
   bool empty_buf = true;
 
   if (n == 0)
     {
       printf_format_elt *elt
-	= new printf_format_elt ("", args, fw, prec, flags, type, modifier);
+        = new printf_format_elt ("", args, fw, prec, flags, type, modifier);
 
       list(num_elts++) = elt;
 
       list.resize (num_elts);
     }
   else
     {
       while (i < n)
-	{
-	  have_more = true;
-
-	  if (! buf)
-	    {
-	      buf = new std::ostringstream ();
-	      empty_buf = true;
-	    }
-
-	  switch (s[i])
-	    {
-	    case '%':
-	      {
-		if (empty_buf)
-		  {
-		    process_conversion (s, i, n, args, flags, fw, prec,
-					type, modifier, num_elts);
-
-		    have_more = (buf != 0);
-		  }
-		else
-		  add_elt_to_list (args, flags, fw, prec, type, modifier,
-				   num_elts);
-	      }
-	      break;
-
-	    default:
-	      {
-		args = 0;
-		flags = "";
-		fw = 0;
-		prec = 0;
-		modifier = '\0';
-		type = '\0';
-		*buf << s[i++];
-		empty_buf = false;
-	      }
-	      break;
-	    }
-
-	  if (nconv < 0)
-	    {
-	      have_more = false;
-	      break;
-	    }
-	}
+        {
+          have_more = true;
+
+          if (! buf)
+            {
+              buf = new std::ostringstream ();
+              empty_buf = true;
+            }
+
+          switch (s[i])
+            {
+            case '%':
+              {
+                if (empty_buf)
+                  {
+                    process_conversion (s, i, n, args, flags, fw, prec,
+                                        type, modifier, num_elts);
+
+                    have_more = (buf != 0);
+                  }
+                else
+                  add_elt_to_list (args, flags, fw, prec, type, modifier,
+                                   num_elts);
+              }
+              break;
+
+            default:
+              {
+                args = 0;
+                flags = "";
+                fw = 0;
+                prec = 0;
+                modifier = '\0';
+                type = '\0';
+                *buf << s[i++];
+                empty_buf = false;
+              }
+              break;
+            }
+
+          if (nconv < 0)
+            {
+              have_more = false;
+              break;
+            }
+        }
 
       if (have_more)
-	add_elt_to_list (args, flags, fw, prec, type, modifier, num_elts);
+        add_elt_to_list (args, flags, fw, prec, type, modifier, num_elts);
 
       list.resize (num_elts);
 
       delete buf;
     }
 }
 
 printf_format_list::~printf_format_list (void)
 {
   octave_idx_type n = list.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       printf_format_elt *elt = list(i);
       delete elt;
-    }	
+    }   
 }
 
 void
 printf_format_list::add_elt_to_list (int args, const std::string& flags,
-				     int fw, int prec, char type,
-				     char modifier, octave_idx_type& num_elts)
+                                     int fw, int prec, char type,
+                                     char modifier, octave_idx_type& num_elts)
 {
   if (buf)
     {
       std::string text = buf->str ();
 
       if (! text.empty ())
-	{
-	  printf_format_elt *elt
-	    = new printf_format_elt (text.c_str (), args, fw, prec, flags,
-				     type, modifier);
-
-	  if (num_elts == list.length ())
-	    list.resize (2 * num_elts);
-
-	  list(num_elts++) = elt;
-	}
+        {
+          printf_format_elt *elt
+            = new printf_format_elt (text.c_str (), args, fw, prec, flags,
+                                     type, modifier);
+
+          if (num_elts == list.length ())
+            list.resize (2 * num_elts);
+
+          list(num_elts++) = elt;
+        }
 
       delete buf;
       buf = 0;
     }
 }
 
 void
 printf_format_list::process_conversion
@@ -712,92 +712,92 @@ printf_format_list::process_conversion
 
   *buf << s[i++];
 
   bool nxt = false;
 
   while (i < n)
     {
       switch (s[i])
-	{
-	case '-': case '+': case ' ': case '0': case '#':
-	  flags += s[i];
-	  *buf << s[i++];
-	  break;
-
-	default:
-	  nxt = true;
-	  break;
-	}
+        {
+        case '-': case '+': case ' ': case '0': case '#':
+          flags += s[i];
+          *buf << s[i++];
+          break;
+
+        default:
+          nxt = true;
+          break;
+        }
 
       if (nxt)
-	break;
+        break;
     }
 
   if (i < n)
     {
       if (s[i] == '*')
-	{
-	  fw = -1;
-	  args++;
-	  *buf << s[i++];
-	}
+        {
+          fw = -1;
+          args++;
+          *buf << s[i++];
+        }
       else
-	{
-	  if (isdigit (s[i]))
-	    {
-	      int nn = 0;
-	      std::string tmp = s.substr (i);
-	      sscanf (tmp.c_str (), "%d%n", &fw, &nn);
-	    }
-
-	  while (i < n && isdigit (s[i]))
-	    *buf << s[i++];
-	}
+        {
+          if (isdigit (s[i]))
+            {
+              int nn = 0;
+              std::string tmp = s.substr (i);
+              sscanf (tmp.c_str (), "%d%n", &fw, &nn);
+            }
+
+          while (i < n && isdigit (s[i]))
+            *buf << s[i++];
+        }
     }
 
   if (i < n && s[i] == '.')
     {
       *buf << s[i++];
 
       if (i < n)
-	{
-	  if (s[i] == '*')
-	    {
-	      prec = -1;
-	      args++;
-	      *buf << s[i++];
-	    }
-	  else
-	    {
-	      if (isdigit (s[i]))
-		{
-		  int nn = 0;
-		  std::string tmp = s.substr (i);
-		  sscanf (tmp.c_str (), "%d%n", &prec, &nn);
-		}
-
-	      while (i < n && isdigit (s[i]))
-		*buf << s[i++];
-	    }
-	}
+        {
+          if (s[i] == '*')
+            {
+              prec = -1;
+              args++;
+              *buf << s[i++];
+            }
+          else
+            {
+              if (isdigit (s[i]))
+                {
+                  int nn = 0;
+                  std::string tmp = s.substr (i);
+                  sscanf (tmp.c_str (), "%d%n", &prec, &nn);
+                }
+
+              while (i < n && isdigit (s[i]))
+                *buf << s[i++];
+            }
+        }
     }
 
   if (i < n)
     {
       switch (s[i])
-	{
-	case 'h': case 'l': case 'L':
-	  modifier = s[i];
-	  *buf << s[i++];
-	  break;
-
-	default:
-	  break;
-	}
+        {
+        case 'h': case 'l': case 'L':
+          modifier = s[i];
+          *buf << s[i++];
+          break;
+
+        default:
+          break;
+        }
     }
 
   if (i < n)
     finish_conversion (s, i, args, flags, fw, prec, modifier, type, num_elts);
   else
     nconv = -1;
 }
 
@@ -807,49 +807,49 @@ printf_format_list::finish_conversion
    int fw, int prec, char modifier, char& type, octave_idx_type& num_elts)
 
 {
   switch (s[i])
     {
     case 'd': case 'i': case 'o': case 'x': case 'X':
     case 'u': case 'c':
       if (modifier == 'L')
-	{
-	  nconv = -1;
-	  break;
-	}
+        {
+          nconv = -1;
+          break;
+        }
       goto fini;
 
     case 'f': case 'e': case 'E': case 'g': case 'G':
       if (modifier == 'h' || modifier == 'l')
-	{
-	  nconv = -1;
-	  break;
-	}
+        {
+          nconv = -1;
+          break;
+        }
       goto fini;
 
     case 's': case 'p': case '%':
       if (modifier != '\0')
-	{
-	  nconv = -1;
-	  break;
-	}
+        {
+          nconv = -1;
+          break;
+        }
       goto fini;
 
     fini:
 
       type = s[i];
 
       *buf << s[i++];
 
       if (type != '%' || args != 0)
-	nconv++;
+        nconv++;
 
       if (type != '%')
-	args++;
+        args++;
 
       add_elt_to_list (args, flags, fw, prec, type, modifier, num_elts);
 
       break;
 
     default:
       nconv = -1;
       break;
@@ -861,23 +861,23 @@ printf_format_list::printme (void) const
 {
   int n = list.length ();
 
   for (int i = 0; i < n; i++)
     {
       printf_format_elt *elt = list(i);
 
       std::cerr
-	<< "args:     " << elt->args << "\n"
-	<< "flags:    `" << elt->flags << "'\n"
-	<< "width:    " << elt->fw << "\n"
-	<< "prec:     " << elt->prec << "\n"
-	<< "type:     `" << elt->type << "'\n"
-	<< "modifier: `" << elt->modifier << "'\n"
-	<< "text:     `" << undo_string_escapes (elt->text) << "'\n\n";
+        << "args:     " << elt->args << "\n"
+        << "flags:    `" << elt->flags << "'\n"
+        << "width:    " << elt->fw << "\n"
+        << "prec:     " << elt->prec << "\n"
+        << "type:     `" << elt->type << "'\n"
+        << "modifier: `" << elt->modifier << "'\n"
+        << "text:     `" << undo_string_escapes (elt->text) << "'\n\n";
     }
 }
 
 int
 octave_base_stream::file_number (void)
 {
   // Kluge alert!
 
@@ -906,19 +906,19 @@ octave_base_stream::file_number (void)
     = os ? dynamic_cast<c_file_ptr_buf *> (os->rdbuf ()) : 0;
 
   int i_fid = ibuf ? ibuf->file_number () : -1;
   int o_fid = obuf ? obuf->file_number () : -1;
 
   if (i_fid >= 0)
     {
       if (o_fid >= 0)
-	retval = (i_fid == o_fid) ? i_fid : -1;
+        retval = (i_fid == o_fid) ? i_fid : -1;
       else
-	retval = i_fid;
+        retval = i_fid;
     }
   else if (o_fid >= 0)
     retval = o_fid;
 
   return retval;
 }
 
 void
@@ -955,25 +955,25 @@ octave_base_stream::clearerr (void)
     os->clear ();
 }
 
 // Functions that are defined for all input streams (input streams
 // are those that define is).
 
 std::string
 octave_base_stream::do_gets (octave_idx_type max_len, bool& err,
-			     bool strip_newline, const std::string& who)
+                             bool strip_newline, const std::string& who)
 {
   std::string retval;
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
-	       who.c_str ());
-	     
+               who.c_str ());
+             
       return retval;
     }
 
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
@@ -981,81 +981,81 @@ octave_base_stream::do_gets (octave_idx_
       std::istream& is = *isp;
 
       std::ostringstream buf;
 
       int c = 0;
       int char_count = 0;
 
       if (max_len != 0)
-	{
-	  while (is && (c = is.get ()) != EOF)
-	    {
-	      char_count++;
-
-	      // Handle CRLF, CR, or LF as line ending.
-
-	      if (c == '\r')
-		{
-		  if (! strip_newline)
-		    buf << static_cast<char> (c);
-
-		  c = is.get ();
-
-		  if (c != EOF)
-		    {
-		      if (c == '\n')
-			{
-			  char_count++;
-
-			  if (! strip_newline)
-			    buf << static_cast<char> (c);
-			}
-		      else
-			is.putback (c);
-		    }
-
-		  break;
-		}
-	      else if (c == '\n')
-		{
-		  if (! strip_newline)
-		    buf << static_cast<char> (c);
-
-		  break;
-		}
-	      else
-		buf << static_cast<char> (c);
-
-	      if (max_len > 0 && char_count == max_len)
-		break;
-	    }
-	}
+        {
+          while (is && (c = is.get ()) != EOF)
+            {
+              char_count++;
+
+              // Handle CRLF, CR, or LF as line ending.
+
+              if (c == '\r')
+                {
+                  if (! strip_newline)
+                    buf << static_cast<char> (c);
+
+                  c = is.get ();
+
+                  if (c != EOF)
+                    {
+                      if (c == '\n')
+                        {
+                          char_count++;
+
+                          if (! strip_newline)
+                            buf << static_cast<char> (c);
+                        }
+                      else
+                        is.putback (c);
+                    }
+
+                  break;
+                }
+              else if (c == '\n')
+                {
+                  if (! strip_newline)
+                    buf << static_cast<char> (c);
+
+                  break;
+                }
+              else
+                buf << static_cast<char> (c);
+
+              if (max_len > 0 && char_count == max_len)
+                break;
+            }
+        }
 
       if (! is.eof () && char_count > 0)
-	{
-	  // GAGME.  Matlab seems to check for EOF even if the last
-	  // character in a file is a newline character.  This is NOT
-	  // what the corresponding C-library functions do.
-	  int disgusting_compatibility_hack = is.get ();
-	  if (! is.eof ())
-	    is.putback (disgusting_compatibility_hack);
-	}
+        {
+          // GAGME.  Matlab seems to check for EOF even if the last
+          // character in a file is a newline character.  This is NOT
+          // what the corresponding C-library functions do.
+          int disgusting_compatibility_hack = is.get ();
+          if (! is.eof ())
+            is.putback (disgusting_compatibility_hack);
+        }
 
       if (is.good () || (is.eof () && char_count > 0))
-	retval = buf.str ();
+        retval = buf.str ();
       else
-	{
-	  err = true;
-
-	  if (is.eof () && char_count == 0)
-	    error (who, "at end of file");
-	  else
-	    error (who, "read error");
-	}
+        {
+          err = true;
+
+          if (is.eof () && char_count == 0)
+            error (who, "at end of file");
+          else
+            error (who, "read error");
+        }
     }
   else
     {
       err = true;
       invalid_operation (who, "reading");
     }
 
   return retval;
@@ -1076,18 +1076,18 @@ octave_base_stream::gets (octave_idx_typ
 long
 octave_base_stream::skipl (long num, bool& err, const std::string& who)
 {
   long cnt = -1;
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
-	       who.c_str ());
-	     
+               who.c_str ());
+             
       return count;
     }
 
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
@@ -1147,49 +1147,49 @@ octave_scan_1 (std::istream& is, const s
       break;
 
     case 'x':
       is >> std::hex >> ref >> std::dec;
       break;
 
     case 'i':
       {
-	int c1 = is.get ();
-
-	if (! is.eof ())
-	  {
-	    if (c1 == '0')
-	      {
-		int c2 = is.peek ();
-
-		if (c2 == 'x' || c2 == 'X')
+        int c1 = is.get ();
+
+        if (! is.eof ())
+          {
+            if (c1 == '0')
+              {
+                int c2 = is.peek ();
+
+                if (c2 == 'x' || c2 == 'X')
                   {
                     is.ignore ();
                     if (std::isxdigit (is.peek ()))
                       is >> std::hex >> ref >> std::dec;
                     else
                       ref = 0;
                   }
-		else
-		  {
-		    if (c2 == '0' || c2 == '1' || c2 == '2'
-			|| c2 == '3' || c2 == '4' || c2 == '5'
-			|| c2 == '6' || c2 == '7')
-		      is >> std::oct >> ref >> std::dec;
-		    else
-		      ref = 0;
-		  }
-	      }
-	    else
-	      {
-		is.putback (c1);
-
-		is >> ref;
-	      }
-	  }
+                else
+                  {
+                    if (c2 == '0' || c2 == '1' || c2 == '2'
+                        || c2 == '3' || c2 == '4' || c2 == '5'
+                        || c2 == '6' || c2 == '7')
+                      is >> std::oct >> ref >> std::dec;
+                    else
+                      ref = 0;
+                  }
+              }
+            else
+              {
+                is.putback (c1);
+
+                is >> ref;
+              }
+          }
       }
       break;
 
     default:
       is >> ref;
       break;
     }
 
@@ -1221,17 +1221,17 @@ octave_scan (std::istream& is, const sca
 }
 
 // Note that this specialization is only used for reading characters, not 
 // character strings. See BEGIN_S_CONVERSION for details.
 
 template<>
 std::istream&
 octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
-	       char* valptr)
+               char* valptr)
 {
   return is >> valptr;
 }
 
 template std::istream&
 octave_scan (std::istream&, const scanf_format_elt&, int*);
 
 template std::istream&
@@ -1261,300 +1261,300 @@ octave_scan<> (std::istream& is, const s
   double& ref = *valptr;
 
   switch (fmt.type)
     {
     case 'e':
     case 'f':
     case 'g':
       {
-	int c1 = EOF;
-
-	while (is && (c1 = is.get ()) != EOF && isspace (c1))
-	  /* skip whitespace */;
-
-	if (c1 != EOF)
-	  {
-	    if (c1 == 'N')
-	      {
-		int c2 = is.get ();
-
-		if (c2 != EOF)
-		  {
-		    if (c2 == 'A')
-		      {
-			int c3 = is.get ();
-
-			if (c3 != EOF)
-			  {
-			    is.putback (c3);
-
-			    if (isspace (c3) || ispunct (c3))
-			      ref = octave_NA;
-			    else
-			      {
-				is.putback (c2);
-				is.putback (c1);
-
-				is >> ref;
-			      }
-			  }
-			else
-			  {
-			    is.clear ();
-
-			    ref = octave_NA;
-			  }
-		      }
-		    else if (c2 == 'a')
-		      {
-			int c3 = is.get ();
-
-			if (c3 != EOF)
-			  {
-			    if (c3 == 'N')
-			      {
-				int c4 = is.get ();
-
-				if (c4 != EOF)
-				  {
-				    is.putback (c4);
-
-				    if (isspace (c4) || ispunct (c4))
-				      ref = octave_NaN;
-				    else
-				      {
-					is.putback (c3);
-					is.putback (c2);
-					is.putback (c1);
-
-					is >> ref;
-				      }
-				  }
-				else
-				  {
-				    is.clear ();
-
-				    ref = octave_NaN;
-				  }
-			      }
-			    else
-			      {
-				is.putback (c3);
-				is.putback (c2);
-				is.putback (c1);
-
-				is >> ref;
-			      }
-			  }
-		      }
-		    else
-		      {
-			is.putback (c2);
-			is.putback (c1);
-
-			is >> ref;
-		      }
-		  }
-	      }
-	    else if (c1 == 'I')
-	      {
-		int c2 = is.get ();
-
-		if (c2 != EOF)
-		  {
-		    if (c2 == 'n')
-		      {
-			int c3 = is.get ();
-
-			if (c3 != EOF)
-			  {
-			    if (c3 == 'f')
-			      {
-				int c4 = is.get ();
-
-				if (c4 != EOF)
-				  {
-				    is.putback (c4);
-
-				    if (isspace (c4) || ispunct (c4))
-				      ref = octave_Inf;
-				    else
-				      {
-					is.putback (c3);
-					is.putback (c2);
-					is.putback (c1);
-
-					is >> ref;
-				      }
-				  }
-				else
-				  {
-				    is.clear ();
-
-				    ref = octave_Inf;
-				  }
-			      }
-			    else
-			      {
-				is.putback (c3);
-				is.putback (c2);
-				is.putback (c1);
-
-				is >> ref;
-			      }
-			}
-		      else
-			{
-			  is.putback (c2);
-			  is.putback (c1);
-
-			  is >> ref;
-			}
-		      }
-		  }
-	      }
-	    else
-	      {
-		is.putback (c1);
-
-		is >> ref;
-	      }
-	  }
+        int c1 = EOF;
+
+        while (is && (c1 = is.get ()) != EOF && isspace (c1))
+          /* skip whitespace */;
+
+        if (c1 != EOF)
+          {
+            if (c1 == 'N')
+              {
+                int c2 = is.get ();
+
+                if (c2 != EOF)
+                  {
+                    if (c2 == 'A')
+                      {
+                        int c3 = is.get ();
+
+                        if (c3 != EOF)
+                          {
+                            is.putback (c3);
+
+                            if (isspace (c3) || ispunct (c3))
+                              ref = octave_NA;
+                            else
+                              {
+                                is.putback (c2);
+                                is.putback (c1);
+
+                                is >> ref;
+                              }
+                          }
+                        else
+                          {
+                            is.clear ();
+
+                            ref = octave_NA;
+                          }
+                      }
+                    else if (c2 == 'a')
+                      {
+                        int c3 = is.get ();
+
+                        if (c3 != EOF)
+                          {
+                            if (c3 == 'N')
+                              {
+                                int c4 = is.get ();
+
+                                if (c4 != EOF)
+                                  {
+                                    is.putback (c4);
+
+                                    if (isspace (c4) || ispunct (c4))
+                                      ref = octave_NaN;
+                                    else
+                                      {
+                                        is.putback (c3);
+                                        is.putback (c2);
+                                        is.putback (c1);
+
+                                        is >> ref;
+                                      }
+                                  }
+                                else
+                                  {
+                                    is.clear ();
+
+                                    ref = octave_NaN;
+                                  }
+                              }
+                            else
+                              {
+                                is.putback (c3);
+                                is.putback (c2);
+                                is.putback (c1);
+
+                                is >> ref;
+                              }
+                          }
+                      }
+                    else
+                      {
+                        is.putback (c2);
+                        is.putback (c1);
+
+                        is >> ref;
+                      }
+                  }
+              }
+            else if (c1 == 'I')
+              {
+                int c2 = is.get ();
+
+                if (c2 != EOF)
+                  {
+                    if (c2 == 'n')
+                      {
+                        int c3 = is.get ();
+
+                        if (c3 != EOF)
+                          {
+                            if (c3 == 'f')
+                              {
+                                int c4 = is.get ();
+
+                                if (c4 != EOF)
+                                  {
+                                    is.putback (c4);
+
+                                    if (isspace (c4) || ispunct (c4))
+                                      ref = octave_Inf;
+                                    else
+                                      {
+                                        is.putback (c3);
+                                        is.putback (c2);
+                                        is.putback (c1);
+
+                                        is >> ref;
+                                      }
+                                  }
+                                else
+                                  {
+                                    is.clear ();
+
+                                    ref = octave_Inf;
+                                  }
+                              }
+                            else
+                              {
+                                is.putback (c3);
+                                is.putback (c2);
+                                is.putback (c1);
+
+                                is >> ref;
+                              }
+                        }
+                      else
+                        {
+                          is.putback (c2);
+                          is.putback (c1);
+
+                          is >> ref;
+                        }
+                      }
+                  }
+              }
+            else
+              {
+                is.putback (c1);
+
+                is >> ref;
+              }
+          }
       }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   return is;
 }
 
 template <class T>
 void
 do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
-	       T valptr, Matrix& mval, double *data, octave_idx_type& idx,
-	       octave_idx_type& conversion_count, octave_idx_type nr, octave_idx_type max_size,
-	       bool discard) 
+               T valptr, Matrix& mval, double *data, octave_idx_type& idx,
+               octave_idx_type& conversion_count, octave_idx_type nr, octave_idx_type max_size,
+               bool discard) 
 {
   OCTAVE_SCAN (is, fmt, valptr);
 
   if (is)
     {
       if (idx == max_size && ! discard)
-	{
-	  max_size *= 2;
-
-	  if (nr > 0)
-	    mval.resize (nr, max_size / nr, 0.0);
-	  else
-	    mval.resize (max_size, 1, 0.0);
-
-	  data = mval.fortran_vec ();
-	}
+        {
+          max_size *= 2;
+
+          if (nr > 0)
+            mval.resize (nr, max_size / nr, 0.0);
+          else
+            mval.resize (max_size, 1, 0.0);
+
+          data = mval.fortran_vec ();
+        }
 
       if (! discard)
-	{
-	  conversion_count++;
-	  data[idx++] = *(valptr);
-	}
+        {
+          conversion_count++;
+          data[idx++] = *(valptr);
+        }
     }
 }
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, int*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, long int*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, short int*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned int*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned long int*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned short int*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 #if 0
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, float*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 #endif
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, double*,
-	       Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 #define DO_WHITESPACE_CONVERSION() \
   do \
     { \
       int c = EOF; \
  \
       while (is && (c = is.get ()) != EOF && isspace (c)) \
-	/* skip whitespace */; \
+        /* skip whitespace */; \
  \
       if (c != EOF) \
-	is.putback (c); \
+        is.putback (c); \
     } \
   while (0)
 
 #define DO_LITERAL_CONVERSION() \
   do \
     { \
       int c = EOF; \
  \
       int n = strlen (fmt); \
       int i = 0; \
  \
       while (i < n && is && (c = is.get ()) != EOF) \
-	{ \
-	  if (c == static_cast<unsigned char> (fmt[i])) \
-	    { \
-	      i++; \
-	      continue; \
-	    } \
-	  else \
-	    { \
-	      is.putback (c); \
-	      break; \
-	    } \
-	} \
+        { \
+          if (c == static_cast<unsigned char> (fmt[i])) \
+            { \
+              i++; \
+              continue; \
+            } \
+          else \
+            { \
+              is.putback (c); \
+              break; \
+            } \
+        } \
  \
       if (i != n) \
-	is.setstate (std::ios::failbit); \
+        is.setstate (std::ios::failbit); \
     } \
   while (0)
 
 #define DO_PCT_CONVERSION() \
   do \
     { \
       int c = is.get (); \
  \
       if (c != EOF) \
-	{ \
-	  if (c != '%') \
-	    { \
-	      is.putback (c); \
-	      is.setstate (std::ios::failbit); \
-	    } \
-	} \
+        { \
+          if (c != '%') \
+            { \
+              is.putback (c); \
+              is.setstate (std::ios::failbit); \
+            } \
+        } \
       else \
-	is.setstate (std::ios::failbit); \
+        is.setstate (std::ios::failbit); \
     } \
   while (0)
 
 #define BEGIN_C_CONVERSION() \
   is.unsetf (std::ios::skipws); \
  \
   int width = elt->width ? elt->width : 1; \
  \
@@ -1622,117 +1622,117 @@ do_scanf_conv (std::istream&, const scan
 #define BEGIN_CHAR_CLASS_CONVERSION() \
   int width = elt->width; \
  \
   std::string tmp; \
  \
   do \
     { \
       if (! width) \
-	width = INT_MAX; \
+        width = INT_MAX; \
  \
       std::ostringstream buf; \
  \
       std::string char_class = elt->char_class; \
  \
       int c = EOF; \
  \
       if (elt->type == '[') \
         { \
-	  int chars_read = 0; \
-	  while (is && chars_read++ < width && (c = is.get ()) != EOF \
-	         && char_class.find (c) != std::string::npos) \
-	    buf << static_cast<char> (c); \
-	} \
+          int chars_read = 0; \
+          while (is && chars_read++ < width && (c = is.get ()) != EOF \
+                 && char_class.find (c) != std::string::npos) \
+            buf << static_cast<char> (c); \
+        } \
       else \
-	{ \
-	  int chars_read = 0; \
-	  while (is && chars_read++ < width && (c = is.get ()) != EOF \
-	         && char_class.find (c) == std::string::npos) \
-	    buf << static_cast<char> (c); \
-	} \
+        { \
+          int chars_read = 0; \
+          while (is && chars_read++ < width && (c = is.get ()) != EOF \
+                 && char_class.find (c) == std::string::npos) \
+            buf << static_cast<char> (c); \
+        } \
  \
       if (width == INT_MAX && c != EOF) \
-	is.putback (c); \
+        is.putback (c); \
  \
       tmp = buf.str (); \
  \
       if (tmp.empty ()) \
         is.setstate (std::ios::failbit); \
     } \
   while (0)
 
 #define FINISH_CHARACTER_CONVERSION() \
   do \
     { \
       width = tmp.length (); \
  \
       if (is) \
-	{ \
-	  int i = 0; \
+        { \
+          int i = 0; \
  \
-	  if (! discard) \
-	    { \
-	      conversion_count++; \
+          if (! discard) \
+            { \
+              conversion_count++; \
  \
-	      while (i < width) \
-		{ \
-		  if (data_index == max_size) \
-		    { \
-		      max_size *= 2; \
+              while (i < width) \
+                { \
+                  if (data_index == max_size) \
+                    { \
+                      max_size *= 2; \
  \
-		      if (all_char_conv) \
-			{ \
-			  if (one_elt_size_spec) \
-			    mval.resize (1, max_size, 0.0); \
-			  else if (nr > 0) \
-			    mval.resize (nr, max_size / nr, 0.0); \
-			  else \
-			    panic_impossible (); \
-			} \
-		      else if (nr > 0) \
-			mval.resize (nr, max_size / nr, 0.0); \
-		      else \
-			mval.resize (max_size, 1, 0.0); \
+                      if (all_char_conv) \
+                        { \
+                          if (one_elt_size_spec) \
+                            mval.resize (1, max_size, 0.0); \
+                          else if (nr > 0) \
+                            mval.resize (nr, max_size / nr, 0.0); \
+                          else \
+                            panic_impossible (); \
+                        } \
+                      else if (nr > 0) \
+                        mval.resize (nr, max_size / nr, 0.0); \
+                      else \
+                        mval.resize (max_size, 1, 0.0); \
  \
-		      data = mval.fortran_vec (); \
-		    } \
+                      data = mval.fortran_vec (); \
+                    } \
  \
-		  data[data_index++] = tmp[i++]; \
-		} \
-	    } \
-	} \
+                  data[data_index++] = tmp[i++]; \
+                } \
+            } \
+        } \
     } \
   while (0)
 
 octave_value
 octave_base_stream::do_scanf (scanf_format_list& fmt_list,
-			      octave_idx_type nr, octave_idx_type nc, bool one_elt_size_spec,
-			      octave_idx_type& conversion_count, const std::string& who)
+                              octave_idx_type nr, octave_idx_type nc, bool one_elt_size_spec,
+                              octave_idx_type& conversion_count, const std::string& who)
 {
   octave_value retval = Matrix ();
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
-	       who.c_str ());
-	     
+               who.c_str ());
+             
       return retval;
     }
 
   conversion_count = 0;
 
   octave_idx_type nconv = fmt_list.num_conversions ();
 
   octave_idx_type data_index = 0;
 
   if (nr == 0 || nc == 0)
     {
       if (one_elt_size_spec)
-	nc = 0;
+        nc = 0;
 
       return Matrix (nr, nc, 0.0);
     }
 
   std::istream *isp = input_stream ();
 
   bool all_char_conv = fmt_list.all_character_conversions ();
 
@@ -1746,54 +1746,54 @@ octave_base_stream::do_scanf (scanf_form
 
   if (all_char_conv)
     {
       // Any of these could be resized later (if we have %s
       // conversions, we may read more than one element for each
       // conversion).
 
       if (one_elt_size_spec)
-	{
-	  max_size = 512;
-	  mval.resize (1, max_size, 0.0);
-
-	  if (nr > 0)
-	    max_conv = nr;
-	}
+        {
+          max_size = 512;
+          mval.resize (1, max_size, 0.0);
+
+          if (nr > 0)
+            max_conv = nr;
+        }
       else if (nr > 0)
-	{
-	  if (nc > 0)
-	    {
-	      mval.resize (nr, nc, 0.0);
-	      max_size = max_conv = nr * nc;
-	    }
-	  else
-	    {
-	      mval.resize (nr, 32, 0.0);
-	      max_size = nr * 32;
-	    }
-	}
+        {
+          if (nc > 0)
+            {
+              mval.resize (nr, nc, 0.0);
+              max_size = max_conv = nr * nc;
+            }
+          else
+            {
+              mval.resize (nr, 32, 0.0);
+              max_size = nr * 32;
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else if (nr > 0)
     {
       if (nc > 0)
-	{
-	  // Will not resize later.
-	  mval.resize (nr, nc, 0.0);
-	  max_size = nr * nc;
-	  max_conv = max_size;
-	}
+        {
+          // Will not resize later.
+          mval.resize (nr, nc, 0.0);
+          max_size = nr * nc;
+          max_conv = max_size;
+        }
       else
-	{
-	  // Maybe resize later.
-	  mval.resize (nr, 32, 0.0);
-	  max_size = nr * 32;
-	}
+        {
+          // Maybe resize later.
+          mval.resize (nr, 32, 0.0);
+          max_size = nr * 32;
+        }
     }
   else
     {
       // Maybe resize later.
       mval.resize (32, 1, 0.0);
       max_size = 32;
     }
 
@@ -1807,260 +1807,260 @@ octave_base_stream::do_scanf (scanf_form
 
       std::ios::fmtflags flags = is.flags ();
 
       octave_idx_type trips = 0;
 
       octave_idx_type num_fmt_elts = fmt_list.length ();
 
       for (;;)
-	{
-	  octave_quit ();
-
-	  if (elt)
-	    {
-	      if (! (elt->type == scanf_format_elt::whitespace_conversion
+        {
+          octave_quit ();
+
+          if (elt)
+            {
+              if (! (elt->type == scanf_format_elt::whitespace_conversion
                      || elt->type == scanf_format_elt::literal_conversion
                      || elt->type == '%')
                   && max_conv > 0 && conversion_count == max_conv)
-		{
-		  if (all_char_conv && one_elt_size_spec)
-		    {
-		      final_nr = 1;
-		      final_nc = data_index;
-		    }
-		  else
-		    {
-		      final_nr = nr;
-		      final_nc = (data_index - 1) / nr + 1;
-		    }
-
-		  break;
-		}
-	      else if (data_index == max_size)
-		{
-		  max_size *= 2;
-
-		  if (all_char_conv)
-		    {
-		      if (one_elt_size_spec)
-			mval.resize (1, max_size, 0.0);
-		      else if (nr > 0)
-			mval.resize (nr, max_size / nr, 0.0);
-		      else
-			panic_impossible ();
-		    }
-		  else if (nr > 0)
-		    mval.resize (nr, max_size / nr, 0.0);
-		  else
-		    mval.resize (max_size, 1, 0.0);
-
-		  data = mval.fortran_vec ();
-		}
-
-	      const char *fmt = elt->text;
-
-	      bool discard = elt->discard;
-
-	      switch (elt->type)
-		{
-		case scanf_format_elt::whitespace_conversion:
-		  DO_WHITESPACE_CONVERSION ();
-		  break;
-
-		case scanf_format_elt::literal_conversion:
-		  DO_LITERAL_CONVERSION ();
-		  break;
-
-		case '%':
-		  DO_PCT_CONVERSION ();
-		  break;
-
-		case 'd': case 'i':
-		  {
-		    switch (elt->modifier)
-		      {
-		      case 'h':
-			{
-			  short int tmp;
-			  do_scanf_conv (is, *elt, &tmp, mval, data,
-					 data_index, conversion_count,
-					 nr, max_size, discard);
-			}
-			break;
-
-		      case 'l':
-			{
-			  long int tmp;
-			  do_scanf_conv (is, *elt, &tmp, mval, data,
-					 data_index, conversion_count,
-					 nr, max_size, discard);
-			}
-			break;
-
-		      default:
-			{
-			  int tmp;
-			  do_scanf_conv (is, *elt, &tmp, mval, data,
-					 data_index, conversion_count,
-					 nr, max_size, discard);
-			}
-			break;
-		      }
-		  }
-		  break;
-
-		case 'o': case 'u': case 'x':
-		  {
-		    switch (elt->modifier)
-		      {
-		      case 'h':
-			{
-			  unsigned short int tmp;
-			  do_scanf_conv (is, *elt, &tmp, mval, data,
-					 data_index, conversion_count,
-					 nr, max_size, discard);
-			}
-			break;
-
-		      case 'l':
-			{
-			  unsigned long int tmp;
-			  do_scanf_conv (is, *elt, &tmp, mval, data,
-					 data_index, conversion_count,
-					 nr, max_size, discard);
-			}
-			break;
-
-		      default:
-			{
-			  unsigned int tmp;
-			  do_scanf_conv (is, *elt, &tmp, mval, data,
-					 data_index, conversion_count,
-					 nr, max_size, discard);
-			}
-			break;
-		      }
-		  }
-		  break;
-
-		case 'e': case 'f': case 'g':
-		  {
-		    double tmp;
-
-		    do_scanf_conv (is, *elt, &tmp, mval, data,
-				   data_index, conversion_count,
-				   nr, max_size, discard);
-		  }
-		  break;
-
-		case 'c':
-		  {
-		    BEGIN_C_CONVERSION ();
-
-		    FINISH_CHARACTER_CONVERSION ();
-
-		    is.setf (flags);
-		  }
-		  break;
-
-		case 's':
-		  {
-		    BEGIN_S_CONVERSION ();
-
-		    FINISH_CHARACTER_CONVERSION ();
-		  }
-		  break;
-
-		case '[': case '^':
-		  {
-		    BEGIN_CHAR_CLASS_CONVERSION ();
-
-		    FINISH_CHARACTER_CONVERSION ();
-		  }
-		  break;
-
-		case 'p':
-		  error ("%s: unsupported format specifier", who.c_str ());
-		  break;
-
-		default:
-		  error ("%s: internal format error", who.c_str ());
-		  break;
-		}
-
-	      if (! ok ())
-		{
-		  break;
-		}
-	      else if (! is)
-		{
-		  if (all_char_conv)
-		    {
-		      if (one_elt_size_spec)
-			{
-			  final_nr = 1;
-			  final_nc = data_index;
-			}
-		      else if (data_index > nr)
-			{
-			  final_nr = nr;
-			  final_nc = (data_index - 1) / nr + 1;
-			}
-		      else
-			{
-			  final_nr = data_index;
-			  final_nc = 1;
-			}
-		    }
-		  else if (nr > 0)
-		    {
-		      if (data_index > nr)
-			{
-			  final_nr = nr;
-			  final_nc = (data_index - 1) / nr + 1;
-			}
-		      else
-			{
-			  final_nr = data_index;
-			  final_nc = 1;
-			}
-		    }
-		  else
-		    {
-		      final_nr = data_index;
-		      final_nc = 1;
-		    }
-
-		  // If it looks like we have a matching failure, then
-		  // reset the failbit in the stream state.
-
-		  if (is.rdstate () & std::ios::failbit)
-		    is.clear (is.rdstate () & (~std::ios::failbit));
-
-		  // FIXME -- is this the right thing to do?
-
-		  if (interactive && name () == "stdin")
-		    {
-		      is.clear ();
-
-		      // Skip to end of line.
-
-		      bool err;
-		      do_gets (-1, err, false, who);
-		    }
-
-		  break;
-		}
-	    }
-	  else
-	    {
-	      error ("%s: internal format error", who.c_str ());
-	      break;
-	    }
+                {
+                  if (all_char_conv && one_elt_size_spec)
+                    {
+                      final_nr = 1;
+                      final_nc = data_index;
+                    }
+                  else
+                    {
+                      final_nr = nr;
+                      final_nc = (data_index - 1) / nr + 1;
+                    }
+
+                  break;
+                }
+              else if (data_index == max_size)
+                {
+                  max_size *= 2;
+
+                  if (all_char_conv)
+                    {
+                      if (one_elt_size_spec)
+                        mval.resize (1, max_size, 0.0);
+                      else if (nr > 0)
+                        mval.resize (nr, max_size / nr, 0.0);
+                      else
+                        panic_impossible ();
+                    }
+                  else if (nr > 0)
+                    mval.resize (nr, max_size / nr, 0.0);
+                  else
+                    mval.resize (max_size, 1, 0.0);
+
+                  data = mval.fortran_vec ();
+                }
+
+              const char *fmt = elt->text;
+
+              bool discard = elt->discard;
+
+              switch (elt->type)
+                {
+                case scanf_format_elt::whitespace_conversion:
+                  DO_WHITESPACE_CONVERSION ();
+                  break;
+
+                case scanf_format_elt::literal_conversion:
+                  DO_LITERAL_CONVERSION ();
+                  break;
+
+                case '%':
+                  DO_PCT_CONVERSION ();
+                  break;
+
+                case 'd': case 'i':
+                  {
+                    switch (elt->modifier)
+                      {
+                      case 'h':
+                        {
+                          short int tmp;
+                          do_scanf_conv (is, *elt, &tmp, mval, data,
+                                         data_index, conversion_count,
+                                         nr, max_size, discard);
+                        }
+                        break;
+
+                      case 'l':
+                        {
+                          long int tmp;
+                          do_scanf_conv (is, *elt, &tmp, mval, data,
+                                         data_index, conversion_count,
+                                         nr, max_size, discard);
+                        }
+                        break;
+
+                      default:
+                        {
+                          int tmp;
+                          do_scanf_conv (is, *elt, &tmp, mval, data,
+                                         data_index, conversion_count,
+                                         nr, max_size, discard);
+                        }
+                        break;
+                      }
+                  }
+                  break;
+
+                case 'o': case 'u': case 'x':
+                  {
+                    switch (elt->modifier)
+                      {
+                      case 'h':
+                        {
+                          unsigned short int tmp;
+                          do_scanf_conv (is, *elt, &tmp, mval, data,
+                                         data_index, conversion_count,
+                                         nr, max_size, discard);
+                        }
+                        break;
+
+                      case 'l':
+                        {
+                          unsigned long int tmp;
+                          do_scanf_conv (is, *elt, &tmp, mval, data,
+                                         data_index, conversion_count,
+                                         nr, max_size, discard);
+                        }
+                        break;
+
+                      default:
+                        {
+                          unsigned int tmp;
+                          do_scanf_conv (is, *elt, &tmp, mval, data,
+                                         data_index, conversion_count,
+                                         nr, max_size, discard);
+                        }
+                        break;
+                      }
+                  }
+                  break;
+
+                case 'e': case 'f': case 'g':
+                  {
+                    double tmp;
+
+                    do_scanf_conv (is, *elt, &tmp, mval, data,
+                                   data_index, conversion_count,
+                                   nr, max_size, discard);
+                  }
+                  break;
+
+                case 'c':
+                  {
+                    BEGIN_C_CONVERSION ();
+
+                    FINISH_CHARACTER_CONVERSION ();
+
+                    is.setf (flags);
+                  }
+                  break;
+
+                case 's':
+                  {
+                    BEGIN_S_CONVERSION ();
+
+                    FINISH_CHARACTER_CONVERSION ();
+                  }
+                  break;
+
+                case '[': case '^':
+                  {
+                    BEGIN_CHAR_CLASS_CONVERSION ();
+
+                    FINISH_CHARACTER_CONVERSION ();
+                  }
+                  break;
+
+                case 'p':
+                  error ("%s: unsupported format specifier", who.c_str ());
+                  break;
+
+                default:
+                  error ("%s: internal format error", who.c_str ());
+                  break;
+                }
+
+              if (! ok ())
+                {
+                  break;
+                }
+              else if (! is)
+                {
+                  if (all_char_conv)
+                    {
+                      if (one_elt_size_spec)
+                        {
+                          final_nr = 1;
+                          final_nc = data_index;
+                        }
+                      else if (data_index > nr)
+                        {
+                          final_nr = nr;
+                          final_nc = (data_index - 1) / nr + 1;
+                        }
+                      else
+                        {
+                          final_nr = data_index;
+                          final_nc = 1;
+                        }
+                    }
+                  else if (nr > 0)
+                    {
+                      if (data_index > nr)
+                        {
+                          final_nr = nr;
+                          final_nc = (data_index - 1) / nr + 1;
+                        }
+                      else
+                        {
+                          final_nr = data_index;
+                          final_nc = 1;
+                        }
+                    }
+                  else
+                    {
+                      final_nr = data_index;
+                      final_nc = 1;
+                    }
+
+                  // If it looks like we have a matching failure, then
+                  // reset the failbit in the stream state.
+
+                  if (is.rdstate () & std::ios::failbit)
+                    is.clear (is.rdstate () & (~std::ios::failbit));
+
+                  // FIXME -- is this the right thing to do?
+
+                  if (interactive && name () == "stdin")
+                    {
+                      is.clear ();
+
+                      // Skip to end of line.
+
+                      bool err;
+                      do_gets (-1, err, false, who);
+                    }
+
+                  break;
+                }
+            }
+          else
+            {
+              error ("%s: internal format error", who.c_str ());
+              break;
+            }
 
           if (nconv == 0 && ++trips == num_fmt_elts)
             {
               if (all_char_conv && one_elt_size_spec)
                 {
                   final_nr = 1;
                   final_nc = data_index;
                 }
@@ -2069,212 +2069,212 @@ octave_base_stream::do_scanf (scanf_form
                   final_nr = nr;
                   final_nc = (data_index - 1) / nr + 1;
                 }
 
               break;
             }
           else
             elt = fmt_list.next (nconv > 0);
-	}
+        }
     }
 
   if (ok ())
     {
       mval.resize (final_nr, final_nc, 0.0);
 
       retval = mval;
 
       if (all_char_conv)
-	retval = retval.convert_to_str (false, true);
+        retval = retval.convert_to_str (false, true);
     }
 
   return retval;
 }
 
 octave_value
 octave_base_stream::scanf (const std::string& fmt, const Array<double>& size,
-			   octave_idx_type& conversion_count, const std::string& who)
+                           octave_idx_type& conversion_count, const std::string& who)
 {
   octave_value retval = Matrix ();
 
   conversion_count = 0;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       scanf_format_list fmt_list (fmt);
 
       if (fmt_list.num_conversions () == -1)
-	::error ("%s: invalid format specified", who.c_str ());
+        ::error ("%s: invalid format specified", who.c_str ());
       else
-	{
-	octave_idx_type nr = -1;
-	octave_idx_type nc = -1;
-
-	bool one_elt_size_spec;
-
-	get_size (size, nr, nc, one_elt_size_spec, who);
-
-	if (! error_state)
-	  retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
-			     conversion_count, who);
-	}
+        {
+        octave_idx_type nr = -1;
+        octave_idx_type nc = -1;
+
+        bool one_elt_size_spec;
+
+        get_size (size, nr, nc, one_elt_size_spec, who);
+
+        if (! error_state)
+          retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
+                             conversion_count, who);
+        }
     }
   else
     invalid_operation (who, "reading");
 
   return retval;
 }
 
 bool
 octave_base_stream::do_oscanf (const scanf_format_elt *elt,
-			       octave_value& retval, const std::string& who)
+                               octave_value& retval, const std::string& who)
 {
   bool quit = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       std::istream& is = *isp;
 
       std::ios::fmtflags flags = is.flags ();
 
       if (elt)
-	{
-	  const char *fmt = elt->text;
-
-	  bool discard = elt->discard;
-
-	  switch (elt->type)
-	    {
-	    case scanf_format_elt::whitespace_conversion:
-	      DO_WHITESPACE_CONVERSION ();
-	      break;
-
-	    case scanf_format_elt::literal_conversion:
-	      DO_LITERAL_CONVERSION ();
-	      break;
-
-	    case '%':
-	      {
-		DO_PCT_CONVERSION ();
-
-		if (! is)
-		  quit = true;
-
-	      }
-	      break;
-
-	    case 'd': case 'i':
-	      {
-		int tmp;
-
-		if (OCTAVE_SCAN (is, *elt, &tmp))
-		  {
-		    if (! discard)
-		      retval = tmp;
-		  }
-		else
-		  quit = true;
-	      }
-	      break;
-
-	    case 'o': case 'u': case 'x':
-	      {
-		long int tmp;
-
-		if (OCTAVE_SCAN (is, *elt, &tmp))
-		  {
-		    if (! discard)
-		      retval = tmp;
-		  }
-		else
-		  quit = true;
-	      }
-	      break;
-
-	    case 'e': case 'f': case 'g':
-	      {
-		double tmp;
-
-		if (OCTAVE_SCAN (is, *elt, &tmp))
-		  {
-		    if (! discard)
-		      retval = tmp;
-		  }
-		else
-		  quit = true;
-	      }
-	      break;
-
-	    case 'c':
-	      {
-		BEGIN_C_CONVERSION ();
-
-		if (! discard)
-		  retval = tmp;
-
-		if (! is)
-		  quit = true;
-
-		is.setf (flags);
-	      }
-	      break;
-
-	    case 's':
-	      {
-		BEGIN_S_CONVERSION ();
-
-		if (! discard)
-		  retval = tmp;
-
-		if (! is)
-		  quit = true;
-	      }
-	      break;
-
-	    case '[': case '^':
-	      {
-		BEGIN_CHAR_CLASS_CONVERSION ();
-
-		if (! discard)
-		  retval = tmp;
-
-		if (! is)
-		  quit = true;
-	      }
-	      break;
-
-	    case 'p':
-	      error ("%s: unsupported format specifier", who.c_str ());
-	      break;
-
-	    default:
-	      error ("%s: internal format error", who.c_str ());
-	      break;
-	    }
-	}
+        {
+          const char *fmt = elt->text;
+
+          bool discard = elt->discard;
+
+          switch (elt->type)
+            {
+            case scanf_format_elt::whitespace_conversion:
+              DO_WHITESPACE_CONVERSION ();
+              break;
+
+            case scanf_format_elt::literal_conversion:
+              DO_LITERAL_CONVERSION ();
+              break;
+
+            case '%':
+              {
+                DO_PCT_CONVERSION ();
+
+                if (! is)
+                  quit = true;
+
+              }
+              break;
+
+            case 'd': case 'i':
+              {
+                int tmp;
+
+                if (OCTAVE_SCAN (is, *elt, &tmp))
+                  {
+                    if (! discard)
+                      retval = tmp;
+                  }
+                else
+                  quit = true;
+              }
+              break;
+
+            case 'o': case 'u': case 'x':
+              {
+                long int tmp;
+
+                if (OCTAVE_SCAN (is, *elt, &tmp))
+                  {
+                    if (! discard)
+                      retval = tmp;
+                  }
+                else
+                  quit = true;
+              }
+              break;
+
+            case 'e': case 'f': case 'g':
+              {
+                double tmp;
+
+                if (OCTAVE_SCAN (is, *elt, &tmp))
+                  {
+                    if (! discard)
+                      retval = tmp;
+                  }
+                else
+                  quit = true;
+              }
+              break;
+
+            case 'c':
+              {
+                BEGIN_C_CONVERSION ();
+
+                if (! discard)
+                  retval = tmp;
+
+                if (! is)
+                  quit = true;
+
+                is.setf (flags);
+              }
+              break;
+
+            case 's':
+              {
+                BEGIN_S_CONVERSION ();
+
+                if (! discard)
+                  retval = tmp;
+
+                if (! is)
+                  quit = true;
+              }
+              break;
+
+            case '[': case '^':
+              {
+                BEGIN_CHAR_CLASS_CONVERSION ();
+
+                if (! discard)
+                  retval = tmp;
+
+                if (! is)
+                  quit = true;
+              }
+              break;
+
+            case 'p':
+              error ("%s: unsupported format specifier", who.c_str ());
+              break;
+
+            default:
+              error ("%s: internal format error", who.c_str ());
+              break;
+            }
+        }
 
       if (ok () && is.fail ())
-	{
-	  error ("%s: read error", who.c_str ());
-
-	  // FIXME -- is this the right thing to do?
-
-	  if (interactive && name () == "stdin")
-	    {
-	      // Skip to end of line.
-
-	      bool err;
-	      do_gets (-1, err, false, who);
-	    }
-	}
+        {
+          error ("%s: read error", who.c_str ());
+
+          // FIXME -- is this the right thing to do?
+
+          if (interactive && name () == "stdin")
+            {
+              // Skip to end of line.
+
+              bool err;
+              do_gets (-1, err, false, who);
+            }
+        }
     }
 
   return quit;
 }
 
 octave_value_list
 octave_base_stream::oscanf (const std::string& fmt, const std::string& who)
 {
@@ -2286,66 +2286,66 @@ octave_base_stream::oscanf (const std::s
     {
       std::istream& is = *isp;
 
       scanf_format_list fmt_list (fmt);
 
       octave_idx_type nconv = fmt_list.num_conversions ();
 
       if (nconv == -1)
-	::error ("%s: invalid format specified", who.c_str ());
+        ::error ("%s: invalid format specified", who.c_str ());
       else
-	{
-	  is.clear ();
-
-	  octave_idx_type len = fmt_list.length ();
-
-	  retval.resize (nconv+1, Matrix ());
-
-	  const scanf_format_elt *elt = fmt_list.first ();
-
-	  int num_values = 0;
-
-	  bool quit = false;
-
-	  for (octave_idx_type i = 0; i < len; i++)
-	    {
-	      octave_value tmp;
-
-	      quit = do_oscanf (elt, tmp, who);
-
-	      if (quit)
-		break;
-	      else
-		{
-		  if (tmp.is_defined ())
-		    retval (num_values++) = tmp;
-
-		  if (! ok ())
-		    break;
-
-		  elt = fmt_list.next (nconv > 0);
-		}
-	    }
-
-	  retval(nconv) = num_values;
-
-	  if (! quit)
-	    {
-	      // Pick up any trailing stuff.
-	      if (ok () && len > nconv)
-		{
-		  octave_value tmp;
-
-		  elt = fmt_list.next ();
-
-		  do_oscanf (elt, tmp, who);
-		}
-	    }
-	}
+        {
+          is.clear ();
+
+          octave_idx_type len = fmt_list.length ();
+
+          retval.resize (nconv+1, Matrix ());
+
+          const scanf_format_elt *elt = fmt_list.first ();
+
+          int num_values = 0;
+
+          bool quit = false;
+
+          for (octave_idx_type i = 0; i < len; i++)
+            {
+              octave_value tmp;
+
+              quit = do_oscanf (elt, tmp, who);
+
+              if (quit)
+                break;
+              else
+                {
+                  if (tmp.is_defined ())
+                    retval (num_values++) = tmp;
+
+                  if (! ok ())
+                    break;
+
+                  elt = fmt_list.next (nconv > 0);
+                }
+            }
+
+          retval(nconv) = num_values;
+
+          if (! quit)
+            {
+              // Pick up any trailing stuff.
+              if (ok () && len > nconv)
+                {
+                  octave_value tmp;
+
+                  elt = fmt_list.next ();
+
+                  do_oscanf (elt, tmp, who);
+                }
+            }
+        }
     }
   else
     invalid_operation (who, "reading");
 
   return retval;
 }
 
 // Functions that are defined for all output streams (output streams
@@ -2358,17 +2358,17 @@ octave_base_stream::flush (void)
 
   std::ostream *os = output_stream ();
 
   if (os)
     {
       os->flush ();
 
       if (os->good ())
-	retval = 0;
+        retval = 0;
     }
   else
     invalid_operation ("fflush", "writing");
 
   return retval;
 }
 
 class
@@ -2380,23 +2380,23 @@ public:
 
   printf_value_cache (const octave_value_list& args, const std::string& who)
     : values (args), val_idx (0), elt_idx (0),
       n_vals (values.length ()), n_elts (0), data (0),
       curr_state (ok)
   {
     for (octave_idx_type i = 0; i < values.length (); i++)
       {
-	octave_value val = values(i);
-
-	if (val.is_map () || val.is_cell () || val.is_object ())
-	  {
-	    gripe_wrong_type_arg (who, val);
-	    break;
-	  }
+        octave_value val = values(i);
+
+        if (val.is_map () || val.is_cell () || val.is_object ())
+          {
+            gripe_wrong_type_arg (who, val);
+            break;
+          }
       }
   }
 
   ~printf_value_cache (void) { }
 
   // Get the current value as a double and advance the internal pointer.
   double double_value (void);
 
@@ -2438,77 +2438,77 @@ printf_value_cache::double_value (void)
   double retval = 0.0;
 
   if (exhausted ())
     curr_state = conversion_error;
 
   while (! exhausted ())
     {
       if (! data)
-	{
-	  octave_value tmp_val = values (val_idx);
-
-	  // Force string conversion here for compatibility.
-
-	  curr_val = tmp_val.array_value (true);
-
-	  if (! error_state)
-	    {
-	      elt_idx = 0;
-	      n_elts = curr_val.length ();
-	      data = curr_val.data ();
-	    }
-	  else
-	    {
-	      curr_state = conversion_error;
-	      break;
-	    }
-	}
+        {
+          octave_value tmp_val = values (val_idx);
+
+          // Force string conversion here for compatibility.
+
+          curr_val = tmp_val.array_value (true);
+
+          if (! error_state)
+            {
+              elt_idx = 0;
+              n_elts = curr_val.length ();
+              data = curr_val.data ();
+            }
+          else
+            {
+              curr_state = conversion_error;
+              break;
+            }
+        }
 
       if (elt_idx < n_elts)
-	{
-	  retval = data[elt_idx++];
-
-	  if (elt_idx >= n_elts)
-	    {
-	      elt_idx = 0;
-	      val_idx++;
-	      data = 0;
-	    }
-
-	  break;
-	}
+        {
+          retval = data[elt_idx++];
+
+          if (elt_idx >= n_elts)
+            {
+              elt_idx = 0;
+              val_idx++;
+              data = 0;
+            }
+
+          break;
+        }
       else
-	{
-	  val_idx++;
-	  data = 0;
-
-	  if (n_elts == 0 && exhausted ())
-	    curr_state = conversion_error;
-
-	  continue;
-	}
+        {
+          val_idx++;
+          data = 0;
+
+          if (n_elts == 0 && exhausted ())
+            curr_state = conversion_error;
+
+          continue;
+        }
     }
 
   return retval;
 }
 
 int
 printf_value_cache::int_value (void)
 {
   int retval = 0;
 
   double dval = double_value ();
 
   if (! error_state)
     {
       if (D_NINT (dval) == dval)
-	retval = NINT (dval);
+        retval = NINT (dval);
       else
-	curr_state = conversion_error;
+        curr_state = conversion_error;
     }
 
   return retval;
 }
 
 std::string
 printf_value_cache::string_value (void)
 {
@@ -2516,48 +2516,48 @@ printf_value_cache::string_value (void)
 
   if (exhausted ())
     curr_state = conversion_error;
   else
     {
       octave_value tval = values (val_idx++);
 
       if (tval.rows () == 1)
-	retval = tval.string_value ();
+        retval = tval.string_value ();
       else
-	{
-	  // In the name of Matlab compatibility.
-
-	  charMatrix chm = tval.char_matrix_value ();
-
-	  octave_idx_type nr = chm.rows ();
-	  octave_idx_type nc = chm.columns ();
-
-	  int k = 0;
-
-	  retval.resize (nr * nc, '\0');
-
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = 0; i < nr; i++)
-	      retval[k++] = chm(i,j);
-	}
+        {
+          // In the name of Matlab compatibility.
+
+          charMatrix chm = tval.char_matrix_value ();
+
+          octave_idx_type nr = chm.rows ();
+          octave_idx_type nc = chm.columns ();
+
+          int k = 0;
+
+          retval.resize (nr * nc, '\0');
+
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = 0; i < nr; i++)
+              retval[k++] = chm(i,j);
+        }
 
       if (error_state)
-	curr_state = conversion_error;
+        curr_state = conversion_error;
     }
 
   return retval;
 }
 
 // Ugh again and again.
 
 template <class T>
 int
 do_printf_conv (std::ostream& os, const char *fmt, int nsa, int sa_1,
-		int sa_2, T arg, const std::string& who)
+                int sa_2, T arg, const std::string& who)
 {
   int retval = 0;
 
   switch (nsa)
     {
     case 2:
       retval = octave_format (os, fmt, sa_1, sa_2, arg);
       break;
@@ -2575,226 +2575,226 @@ do_printf_conv (std::ostream& os, const 
       break;
     }
 
   return retval;
 }
 
 template int
 do_printf_conv (std::ostream&, const char*, int, int, int, int,
-		const std::string&);
+                const std::string&);
 
 template int
 do_printf_conv (std::ostream&, const char*, int, int, int, long,
-		const std::string&);
+                const std::string&);
 
 template int
 do_printf_conv (std::ostream&, const char*, int, int, int, unsigned int,
-		const std::string&);
+                const std::string&);
 
 template int
 do_printf_conv (std::ostream&, const char*, int, int, int, unsigned long,
-		const std::string&);
+                const std::string&);
 
 template int
 do_printf_conv (std::ostream&, const char*, int, int, int, double,
-		const std::string&);
+                const std::string&);
 
 template int
 do_printf_conv (std::ostream&, const char*, int, int, int, const char*,
-		const std::string&);
+                const std::string&);
 
 #define DO_DOUBLE_CONV(TQUAL) \
   do \
     { \
       if (val > std::numeric_limits<TQUAL long>::max () \
-	  || val < std::numeric_limits<TQUAL long>::min ()) \
-	{ \
-	  std::string tfmt = fmt; \
+          || val < std::numeric_limits<TQUAL long>::min ()) \
+        { \
+          std::string tfmt = fmt; \
  \
-	  tfmt.replace (tfmt.rfind (elt->type), 1, ".f"); \
+          tfmt.replace (tfmt.rfind (elt->type), 1, ".f"); \
  \
-	  if (elt->modifier == 'l') \
-	    tfmt.replace (tfmt.rfind (elt->modifier), 1, ""); \
+          if (elt->modifier == 'l') \
+            tfmt.replace (tfmt.rfind (elt->modifier), 1, ""); \
  \
-	  retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2, \
-				    val, who); \
-	} \
+          retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2, \
+                                    val, who); \
+        } \
       else \
-	retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, \
-				  static_cast<TQUAL long> (val), who); \
+        retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, \
+                                  static_cast<TQUAL long> (val), who); \
     } \
   while (0)
 
 int
 octave_base_stream::do_printf (printf_format_list& fmt_list,
-			       const octave_value_list& args,
-			       const std::string& who)
+                               const octave_value_list& args,
+                               const std::string& who)
 {
   int retval = 0;
 
   octave_idx_type nconv = fmt_list.num_conversions ();
 
   std::ostream *osp = output_stream ();
 
   if (osp)
     {
       std::ostream& os = *osp;
 
       const printf_format_elt *elt = fmt_list.first ();
 
       printf_value_cache val_cache (args, who);
 
       if (error_state)
-	return retval;
+        return retval;
 
       for (;;)
-	{
-	  octave_quit ();
-
-	  if (elt)
-	    {
-	      // NSA is the number of `star' args to convert.
-
-	      int nsa = (elt->fw < 0) + (elt->prec < 0);
-
-	      int sa_1 = 0;
-	      int sa_2 = 0; 
-
-	      if (nsa > 0)
-		{
-		  sa_1 = val_cache.int_value ();
-
-		  if (! val_cache)
-		    break;
-		  else
-		    {
-		      if (nsa > 1)
-			{
-			  sa_2 = val_cache.int_value ();
-
-			  if (! val_cache)
-			    break;
-			}
-		    }
-		}
-
-	      const char *fmt = elt->text;
-
-	      if (elt->type == '%')
-		{
-		  os << "%";
-		  retval++;
-		}
-	      else if (elt->args == 0 && elt->text)
-		{
-		  os << elt->text;
-		  retval += strlen (elt->text);
-		}	      
-	      else if (elt->type == 's')
-		{
-		  std::string val = val_cache.string_value ();
-
-		  if (val_cache)
-		    retval += do_printf_conv (os, fmt, nsa, sa_1,
-					      sa_2, val.c_str (), who);
-		  else
-		    break;
-		}
-	      else
-		{
-		  double val = val_cache.double_value ();
-
-		  if (val_cache)
-		    {
-		      if (lo_ieee_isnan (val) || xisinf (val))
-			{
-			  std::string tfmt = fmt;
-			  std::string::size_type i1, i2;
-
-			  tfmt.replace ((i1 = tfmt.rfind (elt->type)),
-					1, 1, 's');
-
-			  if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
-			    {
-			      tfmt.erase (i2, i1-i2);
-			      if (elt->prec < 0)
-				nsa--;
-			    }
-
-			  const char *tval = xisinf (val)
-			    ? (val < 0 ? "-Inf" : "Inf")
-			    : (lo_ieee_is_NA (val) ? "NA" : "NaN");
-
-			  retval += do_printf_conv (os, tfmt.c_str (),
-						    nsa, sa_1, sa_2,
-						    tval, who);
-			}
-		      else
-			{
-			  char type = elt->type;
-
-			  switch (type)
-			    {
-			    case 'd': case 'i': case 'c':
-			      DO_DOUBLE_CONV (OCTAVE_EMPTY_CPP_ARG);
-			      break;
-
-			    case 'o': case 'x': case 'X': case 'u':
-			      DO_DOUBLE_CONV (unsigned);
-			      break;
-
-			    case 'f': case 'e': case 'E':
-			    case 'g': case 'G':
-			      retval
-				+= do_printf_conv (os, fmt, nsa, sa_1, sa_2,
-						   val, who);
-			      break;
-
-			    default:
-			      error ("%s: invalid format specifier",
-				     who.c_str ());
-			      return -1;
-			      break;
-			    }
-			}
-		    }
-		  else
-		    break;
-		}
-
-	      if (! os)
-		{
-		  error ("%s: write error", who.c_str ());
-		  break;
-		}
-	    }
-	  else
-	    {
-	      ::error ("%s: internal error handling format", who.c_str ());
-	      retval = -1;
-	      break;
-	    }
-
-	  elt = fmt_list.next (nconv > 0 && ! val_cache.exhausted ());
-
-	  if (! elt || (val_cache.exhausted () && elt->args > 0))
-	    break;
-	}	      
+        {
+          octave_quit ();
+
+          if (elt)
+            {
+              // NSA is the number of `star' args to convert.
+
+              int nsa = (elt->fw < 0) + (elt->prec < 0);
+
+              int sa_1 = 0;
+              int sa_2 = 0; 
+
+              if (nsa > 0)
+                {
+                  sa_1 = val_cache.int_value ();
+
+                  if (! val_cache)
+                    break;
+                  else
+                    {
+                      if (nsa > 1)
+                        {
+                          sa_2 = val_cache.int_value ();
+
+                          if (! val_cache)
+                            break;
+                        }
+                    }
+                }
+
+              const char *fmt = elt->text;
+
+              if (elt->type == '%')
+                {
+                  os << "%";
+                  retval++;
+                }
+              else if (elt->args == 0 && elt->text)
+                {
+                  os << elt->text;
+                  retval += strlen (elt->text);
+                }             
+              else if (elt->type == 's')
+                {
+                  std::string val = val_cache.string_value ();
+
+                  if (val_cache)
+                    retval += do_printf_conv (os, fmt, nsa, sa_1,
+                                              sa_2, val.c_str (), who);
+                  else
+                    break;
+                }
+              else
+                {
+                  double val = val_cache.double_value ();
+
+                  if (val_cache)
+                    {
+                      if (lo_ieee_isnan (val) || xisinf (val))
+                        {
+                          std::string tfmt = fmt;
+                          std::string::size_type i1, i2;
+
+                          tfmt.replace ((i1 = tfmt.rfind (elt->type)),
+                                        1, 1, 's');
+
+                          if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
+                            {
+                              tfmt.erase (i2, i1-i2);
+                              if (elt->prec < 0)
+                                nsa--;
+                            }
+
+                          const char *tval = xisinf (val)
+                            ? (val < 0 ? "-Inf" : "Inf")
+                            : (lo_ieee_is_NA (val) ? "NA" : "NaN");
+
+                          retval += do_printf_conv (os, tfmt.c_str (),
+                                                    nsa, sa_1, sa_2,
+                                                    tval, who);
+                        }
+                      else
+                        {
+                          char type = elt->type;
+
+                          switch (type)
+                            {
+                            case 'd': case 'i': case 'c':
+                              DO_DOUBLE_CONV (OCTAVE_EMPTY_CPP_ARG);
+                              break;
+
+                            case 'o': case 'x': case 'X': case 'u':
+                              DO_DOUBLE_CONV (unsigned);
+                              break;
+
+                            case 'f': case 'e': case 'E':
+                            case 'g': case 'G':
+                              retval
+                                += do_printf_conv (os, fmt, nsa, sa_1, sa_2,
+                                                   val, who);
+                              break;
+
+                            default:
+                              error ("%s: invalid format specifier",
+                                     who.c_str ());
+                              return -1;
+                              break;
+                            }
+                        }
+                    }
+                  else
+                    break;
+                }
+
+              if (! os)
+                {
+                  error ("%s: write error", who.c_str ());
+                  break;
+                }
+            }
+          else
+            {
+              ::error ("%s: internal error handling format", who.c_str ());
+              retval = -1;
+              break;
+            }
+
+          elt = fmt_list.next (nconv > 0 && ! val_cache.exhausted ());
+
+          if (! elt || (val_cache.exhausted () && elt->args > 0))
+            break;
+        }             
     }
   else
     invalid_operation (who, "writing");
 
   return retval;
 }
 
 int
 octave_base_stream::printf (const std::string& fmt,
-			    const octave_value_list& args,
-			    const std::string& who)
+                            const octave_value_list& args,
+                            const std::string& who)
 {
   int retval = 0;
 
   printf_format_list fmt_list (fmt);
 
   if (fmt_list.num_conversions () == -1)
     ::error ("%s: invalid format specified", who.c_str ());
   else
@@ -2812,33 +2812,33 @@ octave_base_stream::puts (const std::str
 
   if (osp)
     {
       std::ostream& os = *osp;
 
       os << s;
 
       if (os)
-	{
-	  // FIXME -- why does this seem to be necessary?
-	  // Without it, output from a loop like
-	  //
-	  //   for i = 1:100, fputs (stdout, "foo\n"); endfor
-	  //
-	  // doesn't seem to go to the pager immediately.
-
-	  os.flush ();
-
-	  if (os)
-	    retval = 0;
-	  else
-	    error ("%s: write error", who.c_str ());
-	}
+        {
+          // FIXME -- why does this seem to be necessary?
+          // Without it, output from a loop like
+          //
+          //   for i = 1:100, fputs (stdout, "foo\n"); endfor
+          //
+          // doesn't seem to go to the pager immediately.
+
+          os.flush ();
+
+          if (os)
+            retval = 0;
+          else
+            error ("%s: write error", who.c_str ());
+        }
       else
-	error ("%s: write error", who.c_str ());
+        error ("%s: write error", who.c_str ());
     }
   else
     invalid_operation (who, "writing");
 
   return retval;
 }
 
 // Return current error message for this stream.
@@ -2885,22 +2885,22 @@ octave_stream::octave_stream (const octa
 }
 
 octave_stream&
 octave_stream::operator = (const octave_stream& s)
 {
   if (rep != s.rep)
     {
       if (rep && --rep->count == 0)
-	delete rep;
+        delete rep;
 
       rep = s.rep;
 
       if (rep)
-	rep->count++;
+        rep->count++;
     }
 
   return *this;
 }
 
 int
 octave_stream::flush (void)
 {
@@ -2920,35 +2920,35 @@ octave_stream::getl (octave_idx_type max
   if (stream_ok ())
     retval = rep->getl (max_len, err, who);
 
   return retval;
 }
 
 std::string
 octave_stream::getl (const octave_value& tc_max_len, bool& err,
-		     const std::string& who)
+                     const std::string& who)
 {
   std::string retval;
 
   err = false;
 
   int conv_err = 0;
 
   int max_len = -1;
 
   if (tc_max_len.is_defined ())
     {
       max_len = convert_to_valid_int (tc_max_len, conv_err);
 
       if (conv_err || max_len < 0)
-	{
-	  err = true;
-	  ::error ("%s: invalid maximum length specified", who.c_str ());
-	}
+        {
+          err = true;
+          ::error ("%s: invalid maximum length specified", who.c_str ());
+        }
     }
 
   if (! error_state)
     retval = getl (max_len, err, who);
 
   return retval;
 }
 
@@ -2960,35 +2960,35 @@ octave_stream::gets (octave_idx_type max
   if (stream_ok ())
     retval = rep->gets (max_len, err, who);
 
   return retval;
 }
 
 std::string
 octave_stream::gets (const octave_value& tc_max_len, bool& err,
-		     const std::string& who)
+                     const std::string& who)
 {
   std::string retval;
 
   err = false;
 
   int conv_err = 0;
 
   int max_len = -1;
 
   if (tc_max_len.is_defined ())
     {
       max_len = convert_to_valid_int (tc_max_len, conv_err);
 
       if (conv_err || max_len < 0)
-	{
-	  err = true;
-	  ::error ("%s: invalid maximum length specified", who.c_str ());
-	}
+        {
+          err = true;
+          ::error ("%s: invalid maximum length specified", who.c_str ());
+        }
     }
 
   if (! error_state)
     retval = gets (max_len, err, who);
 
   return retval;
 }
 
@@ -3045,102 +3045,102 @@ octave_stream::seek (long offset, int or
     {
       clearerr ();
 
       long orig_pos = rep->tell ();
 
       status = rep->seek (offset, origin);
 
       if (status == 0)
-	{
-	  long save_pos = rep->tell ();
-
-	  rep->seek (0, SEEK_END);
-
-	  long pos_eof = rep->tell ();
-
-	  // I don't think save_pos can be less than zero, but we'll
-	  // check anyway...
-
-	  if (save_pos > pos_eof || save_pos < 0)
-	    {
-	      // Seek outside bounds of file.  Failure should leave
-	      // position unchanged.
-
-	      rep->seek (orig_pos, SEEK_SET);
-
-	      status = -1;
-	    }
-	  else
-	    {
-	      // Is it possible for this to fail?  We are just
-	      // returning to a position after the first successful
-	      // seek.
-
-	      rep->seek (save_pos, SEEK_SET);
-	    }
-	}
+        {
+          long save_pos = rep->tell ();
+
+          rep->seek (0, SEEK_END);
+
+          long pos_eof = rep->tell ();
+
+          // I don't think save_pos can be less than zero, but we'll
+          // check anyway...
+
+          if (save_pos > pos_eof || save_pos < 0)
+            {
+              // Seek outside bounds of file.  Failure should leave
+              // position unchanged.
+
+              rep->seek (orig_pos, SEEK_SET);
+
+              status = -1;
+            }
+          else
+            {
+              // Is it possible for this to fail?  We are just
+              // returning to a position after the first successful
+              // seek.
+
+              rep->seek (save_pos, SEEK_SET);
+            }
+        }
     }
 
   return status;
 }
 
 int
 octave_stream::seek (const octave_value& tc_offset,
-		     const octave_value& tc_origin)
+                     const octave_value& tc_origin)
 {
   int retval = -1;
 
   long xoffset = tc_offset.long_value (true);
 
   if (! error_state)
     {
       int conv_err = 0;
 
       int origin = SEEK_SET;
 
       if (tc_origin.is_string ())
-	{
-	  std::string xorigin = tc_origin.string_value ();
-
-	  if (xorigin == "bof")
-	    origin = SEEK_SET;
-	  else if (xorigin == "cof")
-	    origin = SEEK_CUR;
-	  else if (xorigin == "eof")
-	    origin = SEEK_END;
-	  else
-	    conv_err = -1;
-	}
+        {
+          std::string xorigin = tc_origin.string_value ();
+
+          if (xorigin == "bof")
+            origin = SEEK_SET;
+          else if (xorigin == "cof")
+            origin = SEEK_CUR;
+          else if (xorigin == "eof")
+            origin = SEEK_END;
+          else
+            conv_err = -1;
+        }
       else
-	{
-	  int xorigin = convert_to_valid_int (tc_origin, conv_err);
-
-	  if (! conv_err)
-	    {
-	      if (xorigin == -1)
-		origin = SEEK_SET;
-	      else if (xorigin == 0)
-		origin = SEEK_CUR;
-	      else if (xorigin == 1)
-		origin = SEEK_END;
-	      else
-		conv_err = -1;
-	    }
-	}
+        {
+          int xorigin = convert_to_valid_int (tc_origin, conv_err);
+
+          if (! conv_err)
+            {
+              if (xorigin == -1)
+                origin = SEEK_SET;
+              else if (xorigin == 0)
+                origin = SEEK_CUR;
+              else if (xorigin == 1)
+                origin = SEEK_END;
+              else
+                conv_err = -1;
+            }
+        }
 
       if (! conv_err)
-	{
-	  retval = seek (xoffset, origin);
-
-	  if (retval != 0)
-	    error ("fseek: failed to seek to requested position");
-	}
+        {
+          retval = seek (xoffset, origin);
+
+          if (retval != 0)
+            error ("fseek: failed to seek to requested position");
+        }
       else
-	error ("fseek: invalid value for origin");
+        error ("fseek: invalid value for origin");
     }
   else
     error ("fseek: invalid value for offset");
 
   return retval;
 }
 
 long
@@ -3176,18 +3176,18 @@ octave_stream::close (void)
 {
   if (stream_ok ())
     rep->close ();
 }
 
 template <class RET_T, class READ_T>
 octave_value
 do_read (octave_stream& strm, octave_idx_type nr, octave_idx_type nc, octave_idx_type block_size,
-	 octave_idx_type skip, bool do_float_fmt_conv, bool do_NA_conv,
-	 oct_mach_info::float_format from_flt_fmt, octave_idx_type& count)
+         octave_idx_type skip, bool do_float_fmt_conv, bool do_NA_conv,
+         oct_mach_info::float_format from_flt_fmt, octave_idx_type& count)
 {
   octave_value retval;
 
   RET_T nda;
 
   count = 0;
 
   typedef typename RET_T::element_type ELMT;
@@ -3198,43 +3198,43 @@ do_read (octave_stream& strm, octave_idx
   octave_idx_type max_size = 0;
 
   octave_idx_type final_nr = 0;
   octave_idx_type final_nc = 1;
 
   if (nr > 0)
     {
       if (nc > 0)
-	{
-	  nda.resize (dim_vector (nr, nc), elt_zero);
-	  dat = nda.fortran_vec ();
-	  max_size = nr * nc;
-	}
+        {
+          nda.resize (dim_vector (nr, nc), elt_zero);
+          dat = nda.fortran_vec ();
+          max_size = nr * nc;
+        }
       else
-	{
-	  nda.resize (dim_vector (nr, 32), elt_zero);
-	  dat = nda.fortran_vec ();
-	  max_size = nr * 32;
-	}
+        {
+          nda.resize (dim_vector (nr, 32), elt_zero);
+          dat = nda.fortran_vec ();
+          max_size = nr * 32;
+        }
     }
   else
     {
       nda.resize (dim_vector (32, 1), elt_zero);
       dat = nda.fortran_vec ();
       max_size = 32;
     }
 
   // FIXME -- byte order for Cray?
 
   bool swap = false;
 
   if (oct_mach_info::words_big_endian ())
     swap = (from_flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
-	    || from_flt_fmt == oct_mach_info::flt_fmt_vax_g
-	    || from_flt_fmt == oct_mach_info::flt_fmt_vax_g);
+            || from_flt_fmt == oct_mach_info::flt_fmt_vax_g
+            || from_flt_fmt == oct_mach_info::flt_fmt_vax_g);
   else
     swap = (from_flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 
   union
   {
     char buf[sizeof (typename strip_template_param<octave_int, READ_T>::type)];
     typename strip_template_param<octave_int, READ_T>::type val;
   } u;
@@ -3243,118 +3243,118 @@ do_read (octave_stream& strm, octave_idx
 
   if (isp)
     {
       std::istream& is = *isp;
 
       octave_idx_type elts_read = 0;
 
       for (;;)
-	{
-	  // FIXME -- maybe there should be a special case for
-	  // skip == 0.
-
-	  if (is)
-	    {
-	      if (nr > 0 && nc > 0 && count == max_size)
-		{
-		  final_nr = nr;
-		  final_nc = nc;
-
-		  break;
-		}
-
-	      is.read (u.buf, sizeof (typename strip_template_param<octave_int, READ_T>::type));
-
-	      // We only swap bytes for integer types.  For float
-	      // types, the format conversion will also handle byte
-	      // swapping.
-
-	      if (swap)
-		swap_bytes<sizeof (typename strip_template_param<octave_int, READ_T>::type)> (u.buf);
-	      else if (do_float_fmt_conv)
-		do_float_format_conversion
-		  (u.buf,
-		   sizeof (typename strip_template_param<octave_int, READ_T>::type),
-		   1, from_flt_fmt, oct_mach_info::float_format ());
-
-	      typename RET_T::element_type tmp
-		= static_cast <typename RET_T::element_type> (u.val);
-
-	      if (is)
-		{
-		  if (count == max_size)
-		    {
-		      max_size *= 2;
-
-		      if (nr > 0)
-			nda.resize (dim_vector (nr, max_size / nr),
-				    elt_zero);
-		      else
-			nda.resize (dim_vector (max_size, 1), elt_zero);
-
-		      dat = nda.fortran_vec ();
-		    }
-
-		  if (do_NA_conv && __lo_ieee_is_old_NA (tmp))
-		    tmp = __lo_ieee_replace_old_NA (tmp);
-
-		  dat[count++] = tmp;
-
-		  elts_read++;
-		}
-
-	      int seek_status = 0;
-
-	      if (skip != 0 && elts_read == block_size)
-		{
-		  seek_status = strm.seek (skip, SEEK_CUR);
-		  elts_read = 0;
-		}
-
-	      if (is.eof () || seek_status < 0)
-		{
-		  if (nr > 0)
-		    {
-		      if (count > nr)
-			{
-			  final_nr = nr;
-			  final_nc = (count - 1) / nr + 1;
-			}
-		      else
-			{
-			  final_nr = count;
-			  final_nc = 1;
-			}
-		    }
-		  else
-		    {
-		      final_nr = count;
-		      final_nc = 1;
-		    }
-
-		  break;
-		}
-	    }
-	  else if (is.eof ())
-	    break;
-	}
+        {
+          // FIXME -- maybe there should be a special case for
+          // skip == 0.
+
+          if (is)
+            {
+              if (nr > 0 && nc > 0 && count == max_size)
+                {
+                  final_nr = nr;
+                  final_nc = nc;
+
+                  break;
+                }
+
+              is.read (u.buf, sizeof (typename strip_template_param<octave_int, READ_T>::type));
+
+              // We only swap bytes for integer types.  For float
+              // types, the format conversion will also handle byte
+              // swapping.
+
+              if (swap)
+                swap_bytes<sizeof (typename strip_template_param<octave_int, READ_T>::type)> (u.buf);
+              else if (do_float_fmt_conv)
+                do_float_format_conversion
+                  (u.buf,
+                   sizeof (typename strip_template_param<octave_int, READ_T>::type),
+                   1, from_flt_fmt, oct_mach_info::float_format ());
+
+              typename RET_T::element_type tmp
+                = static_cast <typename RET_T::element_type> (u.val);
+
+              if (is)
+                {
+                  if (count == max_size)
+                    {
+                      max_size *= 2;
+
+                      if (nr > 0)
+                        nda.resize (dim_vector (nr, max_size / nr),
+                                    elt_zero);
+                      else
+                        nda.resize (dim_vector (max_size, 1), elt_zero);
+
+                      dat = nda.fortran_vec ();
+                    }
+
+                  if (do_NA_conv && __lo_ieee_is_old_NA (tmp))
+                    tmp = __lo_ieee_replace_old_NA (tmp);
+
+                  dat[count++] = tmp;
+
+                  elts_read++;
+                }
+
+              int seek_status = 0;
+
+              if (skip != 0 && elts_read == block_size)
+                {
+                  seek_status = strm.seek (skip, SEEK_CUR);
+                  elts_read = 0;
+                }
+
+              if (is.eof () || seek_status < 0)
+                {
+                  if (nr > 0)
+                    {
+                      if (count > nr)
+                        {
+                          final_nr = nr;
+                          final_nc = (count - 1) / nr + 1;
+                        }
+                      else
+                        {
+                          final_nr = count;
+                          final_nc = 1;
+                        }
+                    }
+                  else
+                    {
+                      final_nr = count;
+                      final_nc = 1;
+                    }
+
+                  break;
+                }
+            }
+          else if (is.eof ())
+            break;
+        }
     }
 
   nda.resize (dim_vector (final_nr, final_nc), elt_zero);
 
   retval = nda;
 
   return retval;
 }
 
 #define DO_READ_VAL_TEMPLATE(RET_T, READ_T) \
   template octave_value \
   do_read<RET_T, READ_T> (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool, bool, \
-			  oct_mach_info::float_format, octave_idx_type&)
+                          oct_mach_info::float_format, octave_idx_type&)
 
 // FIXME -- should we only have float if it is a different
 // size from double?
 
 #define INSTANTIATE_DO_READ(VAL_T) \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_int8); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_uint8); \
   DO_READ_VAL_TEMPLATE (VAL_T, octave_int16); \
@@ -3378,17 +3378,17 @@ INSTANTIATE_DO_READ (uint32NDArray);
 INSTANTIATE_DO_READ (int64NDArray);
 INSTANTIATE_DO_READ (uint64NDArray);
 INSTANTIATE_DO_READ (FloatNDArray);
 INSTANTIATE_DO_READ (NDArray);
 INSTANTIATE_DO_READ (charNDArray);
 INSTANTIATE_DO_READ (boolNDArray);
 
 typedef octave_value (*read_fptr) (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool, bool,
-				   oct_mach_info::float_format ffmt, octave_idx_type&);
+                                   oct_mach_info::float_format ffmt, octave_idx_type&);
 
 #define FILL_TABLE_ROW(R, VAL_T) \
   read_fptr_table[R][oct_data_conv::dt_int8] = do_read<VAL_T, octave_int8>; \
   read_fptr_table[R][oct_data_conv::dt_uint8] = do_read<VAL_T, octave_uint8>; \
   read_fptr_table[R][oct_data_conv::dt_int16] = do_read<VAL_T, octave_int16>; \
   read_fptr_table[R][oct_data_conv::dt_uint16] = do_read<VAL_T, octave_uint16>; \
   read_fptr_table[R][oct_data_conv::dt_int32] = do_read<VAL_T, octave_int32>; \
   read_fptr_table[R][oct_data_conv::dt_uint32] = do_read<VAL_T, octave_uint32>; \
@@ -3398,20 +3398,20 @@ typedef octave_value (*read_fptr) (octav
   read_fptr_table[R][oct_data_conv::dt_double] = do_read<VAL_T, double>; \
   read_fptr_table[R][oct_data_conv::dt_char] = do_read<VAL_T, char>; \
   read_fptr_table[R][oct_data_conv::dt_schar] = do_read<VAL_T, signed char>; \
   read_fptr_table[R][oct_data_conv::dt_uchar] = do_read<VAL_T, unsigned char>; \
   read_fptr_table[R][oct_data_conv::dt_logical] = do_read<VAL_T, unsigned char>
 
 octave_value
 octave_stream::read (const Array<double>& size, octave_idx_type block_size,
-		     oct_data_conv::data_type input_type,
-		     oct_data_conv::data_type output_type,
-		     octave_idx_type skip, oct_mach_info::float_format ffmt,
-		     octave_idx_type& char_count)
+                     oct_data_conv::data_type input_type,
+                     oct_data_conv::data_type output_type,
+                     octave_idx_type skip, oct_mach_info::float_format ffmt,
+                     octave_idx_type& char_count)
 {
   static bool initialized = false;
 
   // Table function pointers for return types x read types.
 
   static read_fptr read_fptr_table[oct_data_conv::dt_unknown][14];
 
   if (! initialized)
@@ -3453,113 +3453,113 @@ octave_stream::read (const Array<double>
       octave_idx_type nr = -1;
       octave_idx_type nc = -1;
 
       bool ignore;
 
       get_size (size, nr, nc, ignore, "fread");
 
       if (! error_state)
-	{
-	  if (nr == 0 || nc == 0)
-	    retval = Matrix (nr, nc);
-	  else
-	    {
-	      if (ffmt == oct_mach_info::flt_fmt_unknown)
-		ffmt = float_format ();
-
-	      read_fptr fcn = read_fptr_table[output_type][input_type];
-
-	      bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
-					 || input_type == oct_data_conv::dt_single)
-					&& ffmt != float_format ());
-
-	      bool do_NA_conv = (output_type == oct_data_conv::dt_double);
-
-	      if (fcn)
-		{
-		  retval = (*fcn) (*this, nr, nc, block_size, skip,
-				   do_float_fmt_conv, do_NA_conv,
-				   ffmt, char_count);
-
-		  // FIXME -- kluge!
-
-		  if (! error_state
-		      && (output_type == oct_data_conv::dt_char
-			  || output_type == oct_data_conv::dt_schar
-			  || output_type == oct_data_conv::dt_uchar))
-		    retval = retval.char_matrix_value ();
-		}
-	      else
-		error ("fread: unable to read and convert requested types");
-	    }
-	}
+        {
+          if (nr == 0 || nc == 0)
+            retval = Matrix (nr, nc);
+          else
+            {
+              if (ffmt == oct_mach_info::flt_fmt_unknown)
+                ffmt = float_format ();
+
+              read_fptr fcn = read_fptr_table[output_type][input_type];
+
+              bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
+                                         || input_type == oct_data_conv::dt_single)
+                                        && ffmt != float_format ());
+
+              bool do_NA_conv = (output_type == oct_data_conv::dt_double);
+
+              if (fcn)
+                {
+                  retval = (*fcn) (*this, nr, nc, block_size, skip,
+                                   do_float_fmt_conv, do_NA_conv,
+                                   ffmt, char_count);
+
+                  // FIXME -- kluge!
+
+                  if (! error_state
+                      && (output_type == oct_data_conv::dt_char
+                          || output_type == oct_data_conv::dt_schar
+                          || output_type == oct_data_conv::dt_uchar))
+                    retval = retval.char_matrix_value ();
+                }
+              else
+                error ("fread: unable to read and convert requested types");
+            }
+        }
       else
-	invalid_operation ("fread", "reading");
+        invalid_operation ("fread", "reading");
     }
 
   return retval;
 }
 
 octave_idx_type
 octave_stream::write (const octave_value& data, octave_idx_type block_size,
-		      oct_data_conv::data_type output_type, octave_idx_type skip,
-		      oct_mach_info::float_format flt_fmt)
+                      oct_data_conv::data_type output_type, octave_idx_type skip,
+                      oct_mach_info::float_format flt_fmt)
 {
   octave_idx_type retval = -1;
 
   if (stream_ok ())
     {
       if (! error_state)
-	{
-	  if (flt_fmt == oct_mach_info::flt_fmt_unknown)
-	    flt_fmt = float_format ();
-
-	  octave_idx_type status = data.write (*this, block_size, output_type,
-				   skip, flt_fmt);
-
-	  if (status < 0)
-	    error ("fwrite: write error");
-	  else
-	    retval = status;
-	}
+        {
+          if (flt_fmt == oct_mach_info::flt_fmt_unknown)
+            flt_fmt = float_format ();
+
+          octave_idx_type status = data.write (*this, block_size, output_type,
+                                   skip, flt_fmt);
+
+          if (status < 0)
+            error ("fwrite: write error");
+          else
+            retval = status;
+        }
       else
-	invalid_operation ("fwrite", "writing");
+        invalid_operation ("fwrite", "writing");
     }
 
   return retval;
 }
 
 template <class T>
 void
 write_int (std::ostream& os, bool swap, const T& val)
 {
   typename T::val_type tmp = val.value ();
 
   if (swap)
     swap_bytes<sizeof (typename T::val_type)> (&tmp);
 
   os.write (reinterpret_cast<const char *> (&tmp),
-	    sizeof (typename T::val_type));
+            sizeof (typename T::val_type));
 }
 
 template void write_int (std::ostream&, bool, const octave_int8&);
 template void write_int (std::ostream&, bool, const octave_uint8&);
 template void write_int (std::ostream&, bool, const octave_int16&);
 template void write_int (std::ostream&, bool, const octave_uint16&);
 template void write_int (std::ostream&, bool, const octave_int32&);
 template void write_int (std::ostream&, bool, const octave_uint32&);
 template void write_int (std::ostream&, bool, const octave_int64&);
 template void write_int (std::ostream&, bool, const octave_uint64&);
 
 template <class T>
 static inline bool
 do_write (std::ostream& os, const T& val, oct_data_conv::data_type output_type,
-	  oct_mach_info::float_format flt_fmt, bool swap,
-	  bool do_float_conversion)
+          oct_mach_info::float_format flt_fmt, bool swap,
+          bool do_float_conversion)
 {
   bool retval = true;
 
   // For compatibility, Octave converts to the output type, then
   // writes.  This means that truncation happens on the conversion.
   // For example, the following program prints 0:
   //
   //   x = int8 (-1)
@@ -3604,82 +3604,82 @@ do_write (std::ostream& os, const T& val
       break;
 
     case oct_data_conv::dt_uint64:
       write_int (os, swap, octave_uint64 (val));
       break;
 
     case oct_data_conv::dt_single:
       {
-	float f = static_cast<float> (val);
-
-	if (do_float_conversion)
-	  do_float_format_conversion (&f, 1, flt_fmt);
-
-	os.write (reinterpret_cast<const char *> (&f), sizeof (float));
+        float f = static_cast<float> (val);
+
+        if (do_float_conversion)
+          do_float_format_conversion (&f, 1, flt_fmt);
+
+        os.write (reinterpret_cast<const char *> (&f), sizeof (float));
       }
       break;
 
     case oct_data_conv::dt_double:
       {
-	double d = static_cast<double> (val);
-	if (do_float_conversion)
-	  do_double_format_conversion (&d, 1, flt_fmt);
-
-	os.write (reinterpret_cast<const char *> (&d), sizeof (double));
+        double d = static_cast<double> (val);
+        if (do_float_conversion)
+          do_double_format_conversion (&d, 1, flt_fmt);
+
+        os.write (reinterpret_cast<const char *> (&d), sizeof (double));
       }
       break;
 
     default:
       retval = false;
       (*current_liboctave_error_handler)
-	("write: invalid type specification");
+        ("write: invalid type specification");
       break;
     }
 
   return retval;
 }
 
 template bool
 do_write (std::ostream&, const octave_int8&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template bool
 do_write (std::ostream&, const octave_uint8&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template bool
 do_write (std::ostream&, const octave_int16&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template bool
 do_write (std::ostream&, const octave_uint16&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template bool
 do_write (std::ostream&, const octave_int32&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template bool
 do_write (std::ostream&, const octave_uint32&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template bool
 do_write (std::ostream&, const octave_int64&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template bool
 do_write (std::ostream&, const octave_uint64&, oct_data_conv::data_type,
-	  oct_mach_info::float_format, bool, bool);
+          oct_mach_info::float_format, bool, bool);
 
 template <class T>
 octave_idx_type
 octave_stream::write (const Array<T>& data, octave_idx_type block_size,
-		      oct_data_conv::data_type output_type,
-		      octave_idx_type skip, oct_mach_info::float_format flt_fmt)
+                      oct_data_conv::data_type output_type,
+                      octave_idx_type skip, oct_mach_info::float_format flt_fmt)
 {
   octave_idx_type retval = -1;
 
   bool status = true;
 
   octave_idx_type count = 0;
 
   const T *d = data.data ();
@@ -3692,174 +3692,174 @@ octave_stream::write (const Array<T>& da
   bool do_float_conversion = (flt_fmt != native_flt_fmt);
 
   // FIXME -- byte order for Cray?
 
   bool swap = false;
 
   if (oct_mach_info::words_big_endian ())
     swap = (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
-	    || flt_fmt == oct_mach_info::flt_fmt_vax_g
-	    || flt_fmt == oct_mach_info::flt_fmt_vax_g);
+            || flt_fmt == oct_mach_info::flt_fmt_vax_g
+            || flt_fmt == oct_mach_info::flt_fmt_vax_g);
   else
     swap = (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       std::ostream *osp = output_stream ();
 
       if (osp)
-	{
-	  std::ostream& os = *osp;
-
-	  if (skip != 0 && (i % block_size) == 0)
-	    {
-	      // Seek to skip when inside bounds of existing file.
-	      // Otherwise, write NUL to skip.
-
-	      long orig_pos = tell ();
-
-	      seek (0, SEEK_END);
-
-	      long eof_pos = tell ();
-
-	      // Is it possible for this to fail to return us to the
-	      // original position?
-	      seek (orig_pos, SEEK_SET);
-
-	      long remaining = eof_pos - orig_pos;
-
-	      if (remaining < skip)
-		{
-		  seek (0, SEEK_END);
-
-		  // FIXME -- probably should try to write larger
-		  // blocks...
-
-		  unsigned char zero = 0;
-		  for (octave_idx_type j = 0; j < skip - remaining; j++)
-		    os.write (reinterpret_cast<const char *> (&zero), 1);
-		}
-	      else
-		seek (skip, SEEK_CUR);
-	    }
-
-	  if (os)
-	    {
-	      status = do_write (os, d[i], output_type, flt_fmt, swap,
-				 do_float_conversion);
-
-	      if (os && status)
-		count++;
-	      else
-		break;
-	    }
-	  else
-	    {
-	      status = false;
-	      break;
-	    }
-	}
+        {
+          std::ostream& os = *osp;
+
+          if (skip != 0 && (i % block_size) == 0)
+            {
+              // Seek to skip when inside bounds of existing file.
+              // Otherwise, write NUL to skip.
+
+              long orig_pos = tell ();
+
+              seek (0, SEEK_END);
+
+              long eof_pos = tell ();
+
+              // Is it possible for this to fail to return us to the
+              // original position?
+              seek (orig_pos, SEEK_SET);
+
+              long remaining = eof_pos - orig_pos;
+
+              if (remaining < skip)
+                {
+                  seek (0, SEEK_END);
+
+                  // FIXME -- probably should try to write larger
+                  // blocks...
+
+                  unsigned char zero = 0;
+                  for (octave_idx_type j = 0; j < skip - remaining; j++)
+                    os.write (reinterpret_cast<const char *> (&zero), 1);
+                }
+              else
+                seek (skip, SEEK_CUR);
+            }
+
+          if (os)
+            {
+              status = do_write (os, d[i], output_type, flt_fmt, swap,
+                                 do_float_conversion);
+
+              if (os && status)
+                count++;
+              else
+                break;
+            }
+          else
+            {
+              status = false;
+              break;
+            }
+        }
       else
-	{
-	  status = false;
-	  break;
-	}
+        {
+          status = false;
+          break;
+        }
     }
 
   if (status)
     retval = count;
 
   return retval;
 }
 
 template octave_idx_type
 octave_stream::write (const Array<char>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<bool>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<double>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<float>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_int8>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_uint8>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_int16>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_uint16>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_int32>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_uint32>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_int64>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 template octave_idx_type
 octave_stream::write (const Array<octave_uint64>&, octave_idx_type,
-		      oct_data_conv::data_type,
-		      octave_idx_type, oct_mach_info::float_format);
+                      oct_data_conv::data_type,
+                      octave_idx_type, oct_mach_info::float_format);
 
 octave_value
 octave_stream::scanf (const std::string& fmt, const Array<double>& size,
-		      octave_idx_type& count, const std::string& who)
+                      octave_idx_type& count, const std::string& who)
 {
   octave_value retval;
 
   if (stream_ok ())
     retval = rep->scanf (fmt, size, count, who);
 
   return retval;
 }
 
 octave_value
 octave_stream::scanf (const octave_value& fmt, const Array<double>& size,
-		      octave_idx_type& count, const std::string& who)
+                      octave_idx_type& count, const std::string& who)
 {
   octave_value retval = Matrix ();
 
   if (fmt.is_string ())
     {
       std::string sfmt = fmt.string_value ();
 
       if (fmt.is_sq_string ())
-	sfmt = do_string_escapes (sfmt);
+        sfmt = do_string_escapes (sfmt);
 
       retval = scanf (sfmt, size, count, who);
     }
   else
     {
       // Note that this is not ::error () !
 
       error (who + ": format must be a string");
@@ -3884,54 +3884,54 @@ octave_stream::oscanf (const octave_valu
 {
   octave_value_list retval;
 
   if (fmt.is_string ())
     {
       std::string sfmt = fmt.string_value ();
 
       if (fmt.is_sq_string ())
-	sfmt = do_string_escapes (sfmt);
+        sfmt = do_string_escapes (sfmt);
 
       retval = oscanf (sfmt, who);
     }
   else
     {
       // Note that this is not ::error () !
 
       error (who + ": format must be a string");
     }
 
   return retval;
 }
 
 int
 octave_stream::printf (const std::string& fmt, const octave_value_list& args,
-		       const std::string& who)
+                       const std::string& who)
 {
   int retval = -1;
 
   if (stream_ok ())
     retval = rep->printf (fmt, args, who);
 
   return retval;
 }
 
 int
 octave_stream::printf (const octave_value& fmt, const octave_value_list& args,
-		       const std::string& who)
+                       const std::string& who)
 {
   int retval = 0;
 
   if (fmt.is_string ())
     {
       std::string sfmt = fmt.string_value ();
 
       if (fmt.is_sq_string ())
-	sfmt = do_string_escapes (sfmt);
+        sfmt = do_string_escapes (sfmt);
 
       retval = printf (sfmt, args, who);
     }
   else
     {
       // Note that this is not ::error () !
 
       error (who + ": format must be a string");
@@ -4045,27 +4045,27 @@ octave_stream::mode_as_string (int mode)
     retval = "r+";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc))
     retval = "w+";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate))
     retval = "a+";
   else if (in_mode == (std::ios::in | std::ios::binary))
     retval = "rb";
   else if (in_mode == (std::ios::out | std::ios::binary)
-	   || in_mode == (std::ios::out | std::ios::trunc | std::ios::binary))
+           || in_mode == (std::ios::out | std::ios::trunc | std::ios::binary))
     retval = "wb";
   else if (in_mode == (std::ios::out | std::ios::app | std::ios::binary))
     retval = "ab";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::binary))
     retval = "r+b";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc 
-		       | std::ios::binary))
+                       | std::ios::binary))
     retval = "w+b";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate
-		       | std::ios::binary))
+                       | std::ios::binary))
     retval = "a+b";
 
   return retval;
 }
 
 octave_stream_list *octave_stream_list::instance = 0;
 
 bool
@@ -4220,17 +4220,17 @@ octave_stream_list::do_lookup (int fid, 
   else
     gripe_invalid_file_id (fid, who);
 
   return retval;
 }
 
 octave_stream
 octave_stream_list::do_lookup (const octave_value& fid,
-			       const std::string& who) const
+                               const std::string& who) const
 {
   octave_stream retval;
 
   int i = get_file_number (fid);
 
   if (! error_state)
     retval = do_lookup (i, who);
 
@@ -4245,32 +4245,32 @@ octave_stream_list::do_remove (int fid, 
   // Can't remove stdin (std::cin), stdout (std::cout), or stderr
   // (std::cerr).
 
   if (fid > 2)
     {
       ostrl_map::iterator iter = list.find (fid);
 
       if (iter != list.end ())
-	{
-	  octave_stream os = iter->second;
+        {
+          octave_stream os = iter->second;
           list.erase (iter);
           lookup_cache = list.end ();
 
           // FIXME: is this check redundant?
-	  if (os.is_valid ())
-	    {
-	      os.close ();
-	      retval = 0;
-	    }
-	  else
-	    gripe_invalid_file_id (fid, who);
-	}
+          if (os.is_valid ())
+            {
+              os.close ();
+              retval = 0;
+            }
+          else
+            gripe_invalid_file_id (fid, who);
+        }
       else
-	gripe_invalid_file_id (fid, who);
+        gripe_invalid_file_id (fid, who);
     }
   else
     gripe_invalid_file_id (fid, who);
 
   return retval;
 }
 
 int
@@ -4284,17 +4284,17 @@ octave_stream_list::do_remove (const oct
 
       retval = 0;
     }
   else
     {
       int i = get_file_number (fid);
 
       if (! error_state)
-	retval = do_remove (i, who);
+        retval = do_remove (i, who);
     }
 
   return retval;
 }
 
 void
 octave_stream_list::do_clear (bool flush)
 {
@@ -4371,26 +4371,26 @@ octave_stream_list::do_list_open_files (
       << "  number  mode  arch       name\n"
       << "  ------  ----  ----       ----\n";
 
   for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
     {
       octave_stream os = p->second;
 
       buf << "  "
-	  << std::setiosflags (std::ios::right)
-	  << std::setw (4) << p->first << "     "
-	  << std::setiosflags (std::ios::left)
-	  << std::setw (3)
-	  << octave_stream::mode_as_string (os.mode ())
-	  << "  "
-	  << std::setw (9)
-	  << oct_mach_info::float_format_as_string (os.float_format ())
-	  << "  "
-	  << os.name () << "\n";
+          << std::setiosflags (std::ios::right)
+          << std::setw (4) << p->first << "     "
+          << std::setiosflags (std::ios::left)
+          << std::setw (3)
+          << octave_stream::mode_as_string (os.mode ())
+          << "  "
+          << std::setw (9)
+          << oct_mach_info::float_format_as_string (os.float_format ())
+          << "  "
+          << os.name () << "\n";
     }
 
   buf << "\n";
 
   retval = buf.str ();
 
   return retval;
 }
@@ -4402,17 +4402,17 @@ octave_stream_list::do_open_file_numbers
 
   int num_open = 0;
 
   for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
     {
       // Skip stdin, stdout, and stderr.
 
       if (p->first > 2 && p->second)
-	retval(0,num_open++) = p->first;
+        retval(0,num_open++) = p->first;
     }
 
   retval.resize ((num_open > 0), num_open);
 
   return retval;
 }
 
 int
@@ -4420,38 +4420,38 @@ octave_stream_list::do_get_file_number (
 {
   int retval = -1;
 
   if (fid.is_string ())
     {
       std::string nm = fid.string_value ();
 
       for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
-	{
-	  // stdin (std::cin), stdout (std::cout), and stderr (std::cerr)
-	  // are unnamed.
-
-	  if (p->first > 2)
-	    {
-	      octave_stream os = p->second;
-
-	      if (os && os.name () == nm)
-		{
-		  retval = p->first;
-		  break;
-		}
-	    }
-	}
+        {
+          // stdin (std::cin), stdout (std::cout), and stderr (std::cerr)
+          // are unnamed.
+
+          if (p->first > 2)
+            {
+              octave_stream os = p->second;
+
+              if (os && os.name () == nm)
+                {
+                  retval = p->first;
+                  break;
+                }
+            }
+        }
     }
   else
     {
       int conv_err = 0;
 
       int int_fid = convert_to_valid_int (fid, conv_err);
 
       if (conv_err)
-	::error ("file id must be a file object, std::string, or integer value");
+        ::error ("file id must be a file object, std::string, or integer value");
       else
-	retval = int_fid;
+        retval = int_fid;
     }
 
   return retval;
 }
diff --git a/src/oct-strstrm.cc b/src/oct-strstrm.cc
--- a/src/oct-strstrm.cc
+++ b/src/oct-strstrm.cc
@@ -42,26 +42,26 @@ long
 octave_base_strstream::tell (void)
 {
   error ("ftell: invalid operation");
   return -1;
 }
 
 octave_stream
 octave_istrstream::create (const char *data, std::ios::openmode arg_md,
-			   oct_mach_info::float_format flt_fmt)
+                           oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
 octave_stream
 octave_istrstream::create (const std::string& data, std::ios::openmode arg_md,
-			   oct_mach_info::float_format flt_fmt)
+                           oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
 octave_stream
 octave_ostrstream::create (std::ios::openmode arg_md,
-			   oct_mach_info::float_format flt_fmt)
+                           oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_ostrstream (arg_md, flt_fmt));
 }
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -68,17 +68,17 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include <version.h>
 
 // Kluge.
 extern "C" F77_RET_T
 F77_FUNC (xerbla, XERBLA) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&
-			   F77_CHAR_ARG_LEN_DECL);
+                           F77_CHAR_ARG_LEN_DECL);
 
 extern void install_builtins (void);
 
 // The command-line options.
 static string_vector octave_argv;
 
 // The name used to invoke Octave.
 static std::string
@@ -191,17 +191,17 @@ intern_argv (int argc, char **argv)
 
   if (argc > 1)
     {
       octave_argv.resize (argc - 1);
 
       // Skip program name in argv.
       int i = argc;
       while (--i > 0)
-	octave_argv[i-1] = *(argv+i);
+        octave_argv[i-1] = *(argv+i);
     }
 }
 
 static void
 initialize_pathsearch (void)
 {
   // This may seem odd, but doing it this way means that we don't have
   // to modify the kpathsea library...
@@ -228,35 +228,35 @@ Undocumented internal function.\n\
 
   static Octave_map vinfo;
 
   int nargin = args.length ();
 
   if (nargin == 4)
     {
       if (vinfo.nfields () == 0)
-	{
-	  vinfo.assign ("Name", args (0));
-	  vinfo.assign ("Version", args (1));
-	  vinfo.assign ("Release", args (2));
-	  vinfo.assign ("Date", args (3));
-	}
+        {
+          vinfo.assign ("Name", args (0));
+          vinfo.assign ("Version", args (1));
+          vinfo.assign ("Release", args (2));
+          vinfo.assign ("Date", args (3));
+        }
       else
-	{
-	  octave_idx_type n = vinfo.numel () + 1;
+        {
+          octave_idx_type n = vinfo.numel () + 1;
 
-	  vinfo.resize (dim_vector (n, 1));
+          vinfo.resize (dim_vector (n, 1));
 
-	  octave_value idx (n);
+          octave_value idx (n);
 
-	  vinfo.assign (idx, "Name", Cell (octave_value (args (0))));
-	  vinfo.assign (idx, "Version", Cell (octave_value (args (1))));
-	  vinfo.assign (idx, "Release", Cell (octave_value (args (2))));
-	  vinfo.assign (idx, "Date", Cell (octave_value (args (3))));
-	}
+          vinfo.assign (idx, "Name", Cell (octave_value (args (0))));
+          vinfo.assign (idx, "Version", Cell (octave_value (args (1))));
+          vinfo.assign (idx, "Release", Cell (octave_value (args (2))));
+          vinfo.assign (idx, "Date", Cell (octave_value (args (3))));
+        }
     }
   else if (nargin == 0)
     retval = vinfo;
   else
     print_usage ();
 
   return retval;
 }
@@ -309,50 +309,50 @@ execute_startup_files (void)
       // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set, .octaverc
       // is assumed.
 
       bool home_rc_already_executed = false;
 
       std::string initfile = octave_env::getenv ("OCTAVE_INITFILE");
 
       if (initfile.empty ())
-	initfile = ".octaverc";
+        initfile = ".octaverc";
 
       std::string home_dir = octave_env::get_home_directory ();
 
       std::string home_rc = octave_env::make_absolute (initfile, home_dir);
 
       std::string local_rc;
 
       if (! home_rc.empty ())
-	{
-	  source_file (home_rc, context, verbose, require_file);
+        {
+          source_file (home_rc, context, verbose, require_file);
 
-	  // Names alone are not enough.
+          // Names alone are not enough.
 
-	  file_stat fs_home_rc (home_rc);
+          file_stat fs_home_rc (home_rc);
 
-	  if (fs_home_rc)
-	    {
-	      // We want to check for curr_dir after executing home_rc
-	      // because doing that may change the working directory.
+          if (fs_home_rc)
+            {
+              // We want to check for curr_dir after executing home_rc
+              // because doing that may change the working directory.
 
-	      local_rc = octave_env::make_absolute (initfile);
+              local_rc = octave_env::make_absolute (initfile);
 
-	      home_rc_already_executed = same_file (home_rc, local_rc);
-	    }
-	}
+              home_rc_already_executed = same_file (home_rc, local_rc);
+            }
+        }
 
       if (! home_rc_already_executed)
-	{
-	  if (local_rc.empty ())
+        {
+          if (local_rc.empty ())
             local_rc = octave_env::make_absolute (initfile);
 
-	  source_file (local_rc, context, verbose, require_file);
-	}
+          source_file (local_rc, context, verbose, require_file);
+        }
     }
 }
 
 static int
 execute_eval_option_code (const std::string& code)
 {
   unwind_protect frame;
 
@@ -383,17 +383,17 @@ execute_eval_option_code (const std::str
       recover_from_exception ();
       octave_stdout << "\n";
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
   catch (std::bad_alloc)
     {
       std::cerr << "error: memory exhausted or requested size too large for range of Octave's index type -- eval failed"
-		<< std::endl;
+                << std::endl;
     }
 
   return parse_status;
 }
 
 static void
 execute_command_line_file (const std::string& fname)
 {
@@ -450,17 +450,17 @@ execute_command_line_file (const std::st
       recover_from_exception ();
       octave_stdout << "\n";
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
   catch (std::bad_alloc)
     {
       std::cerr << "error: memory exhausted or requested size too large for range of Octave's index type -- execution of "
-		<< fname << " failed" << std::endl;
+                << fname << " failed" << std::endl;
     }
 }
 
 // Usage message with extra help.
 
 static void
 verbose_usage (void)
 {
@@ -552,17 +552,17 @@ maximum_braindamage (void)
   bind_internal_variable ("PS1", ">> ");
   bind_internal_variable ("PS2", "");
   bind_internal_variable ("beep_on_error", true);
   bind_internal_variable ("confirm_recursive_rmdir", false);
   bind_internal_variable ("crash_dumps_octave_core", false);
   bind_internal_variable ("default_save_options", "-mat-binary");
   bind_internal_variable ("fixed_point_format", true);
   bind_internal_variable ("history_timestamp_format_string",
-			 "%%-- %D %I:%M %p --%%");
+                         "%%-- %D %I:%M %p --%%");
   bind_internal_variable ("page_screen_output", false);
   bind_internal_variable ("print_empty_dimensions", false);
 
   disable_warning ("Octave:abbreviated-property-match");
   disable_warning ("Octave:fopen-file-in-path");
   disable_warning ("Octave:function-name-clash");
   disable_warning ("Octave:load-file-in-path");
 }
@@ -626,136 +626,136 @@ octave_main (int argc, char **argv, int 
       int long_idx;
 
       int optc = getopt_long (argc, argv, short_opts, long_opts, &long_idx);
 
       if (optc < 0)
         break;
 
       switch (optc)
-	{
-	case 'H':
-	  read_history_file = false;
-	  bind_internal_variable ("saving_history", false);
-	  break;
+        {
+        case 'H':
+          read_history_file = false;
+          bind_internal_variable ("saving_history", false);
+          break;
 
-	case 'V':
-	  verbose_flag = true;
-	  break;
+        case 'V':
+          verbose_flag = true;
+          break;
 
-	case 'd':
-	  // This is the same as yydebug in parse.y.
-	  octave_debug++;
-	  break;
+        case 'd':
+          // This is the same as yydebug in parse.y.
+          octave_debug++;
+          break;
 
-	case 'f':
-	  read_init_files = false;
-	  read_site_files = false;
-	  break;
+        case 'f':
+          read_init_files = false;
+          read_site_files = false;
+          break;
 
-	case 'h':
-	case '?':
-	  verbose_usage ();
-	  break;
+        case 'h':
+        case '?':
+          verbose_usage ();
+          break;
 
-	case 'i':
-	  forced_interactive = true;
-	  break;
+        case 'i':
+          forced_interactive = true;
+          break;
 
-	case 'p':
-	  if (optarg)
-	    load_path::set_command_line_path (optarg);
-	  break;
+        case 'p':
+          if (optarg)
+            load_path::set_command_line_path (optarg);
+          break;
 
-	case 'q':
-	  inhibit_startup_message = true;
-	  break;
+        case 'q':
+          inhibit_startup_message = true;
+          break;
 
-	case 'x':
-	  {
-	    double tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE);
-	    bind_internal_variable ("echo_executing_commands", tmp);
-	  }
-	  break;
+        case 'x':
+          {
+            double tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE);
+            bind_internal_variable ("echo_executing_commands", tmp);
+          }
+          break;
 
-	case 'v':
-	  print_version_and_exit ();
-	  break;
+        case 'v':
+          print_version_and_exit ();
+          break;
 
-	case DOC_CACHE_FILE_OPTION:
-	  if (optarg)
-	    bind_internal_variable ("doc_cache_file", optarg);
-	  break;
+        case DOC_CACHE_FILE_OPTION:
+          if (optarg)
+            bind_internal_variable ("doc_cache_file", optarg);
+          break;
 
-	case EVAL_OPTION:
-	  if (optarg)
-	    {
-	      if (code_to_eval.empty ())
-		code_to_eval = optarg;
-	      else
-		code_to_eval += std::string (" ") + optarg;
-	    }
-	  break;
+        case EVAL_OPTION:
+          if (optarg)
+            {
+              if (code_to_eval.empty ())
+                code_to_eval = optarg;
+              else
+                code_to_eval += std::string (" ") + optarg;
+            }
+          break;
 
-	case EXEC_PATH_OPTION:
-	  if (optarg)
-	    set_exec_path (optarg);
-	  break;
+        case EXEC_PATH_OPTION:
+          if (optarg)
+            set_exec_path (optarg);
+          break;
 
-	case IMAGE_PATH_OPTION:
-	  if (optarg)
-	    set_image_path (optarg);
-	  break;
+        case IMAGE_PATH_OPTION:
+          if (optarg)
+            set_image_path (optarg);
+          break;
 
-	case INFO_FILE_OPTION:
-	  if (optarg)
-	    bind_internal_variable ("info_file", optarg);
-	  break;
+        case INFO_FILE_OPTION:
+          if (optarg)
+            bind_internal_variable ("info_file", optarg);
+          break;
 
-	case INFO_PROG_OPTION:
-	  if (optarg)
-	    bind_internal_variable ("info_program", optarg);
-	  break;
+        case INFO_PROG_OPTION:
+          if (optarg)
+            bind_internal_variable ("info_program", optarg);
+          break;
 
-	case LINE_EDITING_OPTION:
-	  forced_line_editing = true;
-	  break;
+        case LINE_EDITING_OPTION:
+          forced_line_editing = true;
+          break;
 
-	case NO_INIT_FILE_OPTION:
-	  read_init_files = false;
-	  break;
+        case NO_INIT_FILE_OPTION:
+          read_init_files = false;
+          break;
 
-	case NO_INIT_PATH_OPTION:
-	  set_initial_path = false;
-	  break;
+        case NO_INIT_PATH_OPTION:
+          set_initial_path = false;
+          break;
 
-	case NO_LINE_EDITING_OPTION:
-	  line_editing = false;
-	  break;
+        case NO_LINE_EDITING_OPTION:
+          line_editing = false;
+          break;
 
-	case NO_SITE_FILE_OPTION:
-	  read_site_files = 0;
-	  break;
+        case NO_SITE_FILE_OPTION:
+          read_site_files = 0;
+          break;
 
-	case NO_WINDOW_SYSTEM_OPTION:
-	  display_info::no_window_system ();
-	  break;
+        case NO_WINDOW_SYSTEM_OPTION:
+          display_info::no_window_system ();
+          break;
 
-	case PERSIST_OPTION:
-	  persist = true;
-	  break;
+        case PERSIST_OPTION:
+          persist = true;
+          break;
 
-	case TRADITIONAL_OPTION:
-	  traditional = true;
-	  break;
+        case TRADITIONAL_OPTION:
+          traditional = true;
+          break;
 
-	default:
-	  usage ();
-	  break;
-	}
+        default:
+          usage ();
+          break;
+        }
     }
 
   // Make sure we clean up when we exit.  Also allow users to register
   // functions.  If we don't have atexit or on_exit, we're going to
   // leave some junk files around if we exit abnormally.
 
   atexit (do_octave_atexit);
 
@@ -813,30 +813,30 @@ octave_main (int argc, char **argv, int 
 
   int remaining_args = argc - last_arg_idx;
 
   if (! code_to_eval.empty ())
     {
       int parse_status = execute_eval_option_code (code_to_eval);
 
       if (! (persist || remaining_args > 0))
-	clean_up_and_exit (parse_status || error_state ? 1 : 0);
+        clean_up_and_exit (parse_status || error_state ? 1 : 0);
     }
 
   if (remaining_args > 0)
     {
       // If we are running an executable script (#! /bin/octave) then
       // we should only see the args passed to the script.
 
       intern_argv (remaining_args, argv+last_arg_idx);
 
       execute_command_line_file (argv[last_arg_idx]);
 
       if (! persist)
-	clean_up_and_exit (error_state ? 1 : 0);
+        clean_up_and_exit (error_state ? 1 : 0);
     }
 
   // Avoid counting commands executed from startup files.
 
   command_editor::reset_current_command_number (1);
 
   // Now argv should have the full set of args.
   intern_argv (argc, argv);
diff --git a/src/ov-base-diag.cc b/src/ov-base-diag.cc
--- a/src/ov-base-diag.cc
+++ b/src/ov-base-diag.cc
@@ -50,18 +50,18 @@ octave_base_diag<DMT, MT>::subsref (cons
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
@@ -113,17 +113,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
                                      const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
-	if (type.length () == 1)
+        if (type.length () == 1)
           {
             octave_value_list jdx = idx.front ();
             // Check for a simple element assignment. That means, if D is a diagonal matrix,
             // `D(i,i) = x' will not destroy its diagonality (provided i is a valid index).
             if (jdx.length () == 2 && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
               {
                 typename DMT::element_type val;
                 idx_vector i0 = jdx(0).index_vector (), i1 = jdx(1).index_vector ();
@@ -137,39 +137,39 @@ octave_base_diag<DMT, MT>::subsasgn (con
                     // invalidate cache
                     dense_cache = octave_value ();
                   }
               }
 
             if (! error_state && ! retval.is_defined ())
               retval = numeric_assign (type, idx, rhs);
           }
-	else
-	  {
-	    std::string nm = type_name ();
-	    error ("in indexed assignment of %s, last lhs index must be ()",
-		   nm.c_str ());
-	  }
+        else
+          {
+            std::string nm = type_name ();
+            error ("in indexed assignment of %s, last lhs index must be ()",
+                   nm.c_str ());
+          }
       }
       break;
 
     case '{':
     case '.':
       {
-	if (is_empty ())
-	  {
-	    octave_value tmp = octave_value::empty_conv (type, rhs);
+        if (is_empty ())
+          {
+            octave_value tmp = octave_value::empty_conv (type, rhs);
 
-	    retval = tmp.subsasgn (type, idx, rhs);
-	  }
-	else
-	  {
-	    std::string nm = type_name ();
-	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-	  }
+            retval = tmp.subsasgn (type, idx, rhs);
+          }
+        else
+          {
+            std::string nm = type_name ();
+            error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+          }
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval;
@@ -209,22 +209,22 @@ template <class DMT, class MT>
 double
 octave_base_diag<DMT, MT>::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real scalar");
+                               "complex matrix", "real scalar");
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "real scalar");
+                                 type_name (), "real scalar");
 
       retval = helper_getreal (el_type (matrix (0, 0)));
     }
   else
     gripe_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
@@ -233,22 +233,22 @@ template <class DMT, class MT>
 float
 octave_base_diag<DMT, MT>::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real scalar");
+                               "complex matrix", "real scalar");
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "real scalar");
+                                 type_name (), "real scalar");
 
       retval = helper_getreal (el_type (matrix (0, 0)));
     }
   else
     gripe_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
@@ -259,17 +259,17 @@ octave_base_diag<DMT, MT>::complex_value
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "complex scalar");
+                                 type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
@@ -280,17 +280,17 @@ octave_base_diag<DMT, MT>::float_complex
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "complex scalar");
+                                 type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
@@ -415,20 +415,20 @@ octave_base_diag<DMT, MT>::load_ascii (s
   if (extract_keyword (is, "rows", r, true)
       && extract_keyword (is, "columns", c, true))
     {
       octave_idx_type l = r < c ? r : c;
       MT tmp (l, 1);
       is >> tmp;
 
       if (!is) 
-	{
-	  error ("load: failed to load diagonal matrix constant");
-	  success = false;
-	}
+        {
+          error ("load: failed to load diagonal matrix constant");
+          success = false;
+        }
       else
         {
           // This is a little tricky, as we have the Matrix type, but
           // not ColumnVector type. We need to help the compiler get
           // through the inheritance tree.
           typedef typename DMT::element_type el_type;
           matrix = DMT (MDiagArray2<el_type> (MArray<el_type> (tmp)));
           matrix.resize (r, c);
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -148,33 +148,33 @@ octave_base_int_matrix<T>::convert_to_st
       typename T::element_type tmp = this->matrix(i);
 
       typedef typename T::element_type::val_type val_type;
 
       val_type ival = tmp.value ();
 
       static const bool is_signed = std::numeric_limits<val_type>::is_signed;
       static const bool can_be_larger_than_uchar_max
-	= octave_base_int_helper_traits<val_type>::can_be_larger_than_uchar_max;
+        = octave_base_int_helper_traits<val_type>::can_be_larger_than_uchar_max;
 
       if (octave_base_int_helper<val_type, is_signed,
-	  can_be_larger_than_uchar_max>::char_value_out_of_range (ival))
-	{
-	  // FIXME -- is there something better we could do?
+          can_be_larger_than_uchar_max>::char_value_out_of_range (ival))
+        {
+          // FIXME -- is there something better we could do?
 
-	  ival = 0;
+          ival = 0;
 
-	  if (! warned)
-	    {
-	      ::warning ("range error for conversion to character value");
-	      warned = true;
-	    }
-	}
+          if (! warned)
+            {
+              ::warning ("range error for conversion to character value");
+              warned = true;
+            }
+        }
       else
-	chm (i) = static_cast<char> (ival);
+        chm (i) = static_cast<char> (ival);
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
 template <class T>
@@ -198,40 +198,40 @@ bool
 octave_base_int_matrix<T>::load_ascii (std::istream& is)
 {
   int mdims = 0;
   bool success = true;
 
   if (extract_keyword (is, "ndims", mdims, true))
     {
       if (mdims >= 0)
-	{
-	  dim_vector dv;
-	  dv.resize (mdims);
+        {
+          dim_vector dv;
+          dv.resize (mdims);
 
-	  for (int i = 0; i < mdims; i++)
-	    is >> dv(i);
+          for (int i = 0; i < mdims; i++)
+            is >> dv(i);
 
-	  T tmp(dv);
+          T tmp(dv);
 
-	  is >> tmp;
+          is >> tmp;
 
-	  if (!is) 
-	    {
-	      error ("load: failed to load matrix constant");
-	      success = false;
-	    }
+          if (!is) 
+            {
+              error ("load: failed to load matrix constant");
+              success = false;
+            }
 
-	  this->matrix = tmp;
-	}
+          this->matrix = tmp;
+        }
       else
-	{
-	  error ("load: failed to extract number of rows and columns");
-	  success = false;
-	}
+        {
+          error ("load: failed to extract number of rows and columns");
+          success = false;
+        }
     }
   else
     error ("load: failed to extract number of dimensions");
 
   return success;
 }
 
 template <class T>
@@ -254,17 +254,17 @@ octave_base_int_matrix<T>::save_binary (
   os.write (reinterpret_cast<const char *> (this->matrix.data()), this->byte_size());
 
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
-					oct_mach_info::float_format )
+                                        oct_mach_info::float_format )
 {
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
@@ -272,19 +272,19 @@ octave_base_int_matrix<T>::load_binary (
   mdims = - mdims;
   int32_t di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&di);
+        swap_bytes<4> (&di);
       dv(i) = di;
     }
 
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
   // might.
 
   if (mdims == 1)
@@ -300,31 +300,31 @@ octave_base_int_matrix<T>::load_binary (
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = dv.numel ();
       int bytes = nel / m.byte_size();
       for (int i = 0; i < nel; i++) 
-	switch (bytes)
-	  {
-	  case 8:
-	    swap_bytes<8> (&m(i));
-	    break;
-	  case 4:
-	    swap_bytes<4> (&m(i));
-	    break;
-	  case 2:
-	    swap_bytes<2> (&m(i));
-	    break;
-	  case 1:
-	  default:
-	    break;
-	  }
+        switch (bytes)
+          {
+          case 8:
+            swap_bytes<8> (&m(i));
+            break;
+          case 4:
+            swap_bytes<4> (&m(i));
+            break;
+          case 2:
+            swap_bytes<2> (&m(i));
+            break;
+          case 1:
+          default:
+            break;
+          }
     }
 
   this->matrix = m;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
@@ -347,29 +347,29 @@ octave_base_int_matrix<T>::save_hdf5 (hi
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
  
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, this->matrix.data()) >= 0;
+                     H5P_DEFAULT, this->matrix.data()) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 template <class T>
@@ -412,42 +412,42 @@ octave_base_int_matrix<T>::load_hdf5 (hi
       dv.resize (2);
       dv(0) = 1;
       dv(1) = hdims[0];
     }
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
-	dv(j) = hdims[i];
+        dv(j) = hdims[i];
     }
 
   T m (dv);
   if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, m.fortran_vec()) >= 0) 
+               H5P_DEFAULT, m.fortran_vec()) >= 0) 
     {
       retval = true;
       this->matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
   return retval;
 }
 
 #endif
 
 template <class T>
 void
 octave_base_int_matrix<T>::print_raw (std::ostream& os,
-				      bool pr_as_read_syntax) const
+                                      bool pr_as_read_syntax) const
 {
   octave_print_internal (os, this->matrix, pr_as_read_syntax,
-   			 this->current_print_indent_level ());
+                         this->current_print_indent_level ());
 }
 
 template <class T>
 octave_value
 octave_base_int_scalar<T>::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
@@ -503,37 +503,37 @@ octave_base_int_scalar<T>::save_binary (
 {
   os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size());
   return true;
 }
 
 template <class T>
 bool 
 octave_base_int_scalar<T>::load_binary (std::istream& is, bool swap,
-					oct_mach_info::float_format)
+                                        oct_mach_info::float_format)
 {
   T tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size()))
     return false;
 
   if (swap)
     switch (this->byte_size())
       {
       case 8:
-	swap_bytes<8> (&tmp);
-	break;
+        swap_bytes<8> (&tmp);
+        break;
       case 4:
-	swap_bytes<4> (&tmp);
-	break;
+        swap_bytes<4> (&tmp);
+        break;
       case 2:
-	swap_bytes<2> (&tmp);
-	break;
+        swap_bytes<2> (&tmp);
+        break;
       case 1:
       default:
-	break;
+        break;
       }
   this->scalar = tmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 template <class T>
@@ -545,29 +545,29 @@ octave_base_int_scalar<T>::save_hdf5 (hi
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &(this->scalar)) >= 0;
+                     H5P_DEFAULT, &(this->scalar)) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 template <class T>
@@ -587,17 +587,17 @@ octave_base_int_scalar<T>::load_hdf5 (hi
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   T tmp;
   if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, &tmp) < 0)
+               H5P_DEFAULT, &tmp) < 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   this->scalar = tmp;
 
   H5Dclose (data_hid);
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -33,126 +33,126 @@ along with Octave; see the file COPYING.
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "pr-output.h"
 
 template <class MT>
 octave_value
 octave_base_matrix<MT>::subsref (const std::string& type,
-				 const std::list<octave_value_list>& idx)
+                                 const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
 template <class MT>
 octave_value
 octave_base_matrix<MT>::subsasgn (const std::string& type,
-				  const std::list<octave_value_list>& idx,
-				  const octave_value& rhs)
+                                  const std::list<octave_value_list>& idx,
+                                  const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
-	if (type.length () == 1)
-	  retval = numeric_assign (type, idx, rhs);
-	else if (is_empty ())
-	  {
-	    // Allow conversion of empty matrix to some other type in
-	    // cases like
-	    //
-	    //  x = []; x(i).f = rhs
+        if (type.length () == 1)
+          retval = numeric_assign (type, idx, rhs);
+        else if (is_empty ())
+          {
+            // Allow conversion of empty matrix to some other type in
+            // cases like
+            //
+            //  x = []; x(i).f = rhs
 
-	    if (type[1] == '.')
-	      {
-		octave_value tmp = octave_value::empty_conv (type, rhs);
+            if (type[1] == '.')
+              {
+                octave_value tmp = octave_value::empty_conv (type, rhs);
 
-		retval = tmp.subsasgn (type, idx, rhs);
-	      }
-	    else
-	      error ("invalid assignment expression");
-	  }
-	else
-	  {
-	    std::string nm = type_name ();
-	    error ("in indexed assignment of %s, last lhs index must be ()",
-		   nm.c_str ());
-	  }
+                retval = tmp.subsasgn (type, idx, rhs);
+              }
+            else
+              error ("invalid assignment expression");
+          }
+        else
+          {
+            std::string nm = type_name ();
+            error ("in indexed assignment of %s, last lhs index must be ()",
+                   nm.c_str ());
+          }
       }
       break;
 
     case '{':
     case '.':
       {
-	if (is_empty ())
-	  {
-	    octave_value tmp = octave_value::empty_conv (type, rhs);
+        if (is_empty ())
+          {
+            octave_value tmp = octave_value::empty_conv (type, rhs);
 
-	    retval = tmp.subsasgn (type, idx, rhs);
-	  }
-	else
-	  {
-	    std::string nm = type_name ();
-	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-	  }
+            retval = tmp.subsasgn (type, idx, rhs);
+          }
+        else
+          {
+            std::string nm = type_name ();
+            error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+          }
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval;
 }
 
 template <class MT>
 octave_value
 octave_base_matrix<MT>::do_index_op (const octave_value_list& idx,
-				     bool resize_ok)
+                                     bool resize_ok)
 {
   octave_value retval;
 
   octave_idx_type n_idx = idx.length ();
 
   int nd = matrix.ndims ();
 
   switch (n_idx)
     {
     case 0:
       retval = matrix;
       break;
 
     case 1:
       {
-	idx_vector i = idx (0).index_vector ();
+        idx_vector i = idx (0).index_vector ();
 
-	if (! error_state)
+        if (! error_state)
           {
             // optimize single scalar index.
             if (i.is_scalar () && i(0) < matrix.numel ())
               retval = const_cast<const MT&> (matrix)(i(0));
             else
               retval = MT (matrix.index (i, resize_ok));
           }
       }
@@ -229,19 +229,19 @@ octave_base_matrix<MT>::assign (const oc
   switch (n_idx)
     {
     case 0:
       panic_impossible ();
       break;
 
     case 1:
       {
-	idx_vector i = idx (0).index_vector ();
+        idx_vector i = idx (0).index_vector ();
 
-	if (! error_state)
+        if (! error_state)
           matrix.assign (i, rhs);
       }
       break;
 
     case 2:
       {
         idx_vector i = idx (0).index_vector ();
 
@@ -300,19 +300,19 @@ octave_base_matrix<MT>::assign (const oc
   switch (n_idx)
     {
     case 0:
       panic_impossible ();
       break;
 
     case 1:
       {
-	idx_vector i = idx (0).index_vector ();
+        idx_vector i = idx (0).index_vector ();
 
-	if (! error_state)
+        if (! error_state)
           {
             // optimize single scalar index.
             if (i.is_scalar () && i(0) < matrix.numel ())
               matrix(i(0)) = rhs;
             else
               matrix.assign (i, mrhs);
           }
       }
@@ -418,23 +418,23 @@ octave_base_matrix<MT>::is_true (void) c
   dim_vector dv = matrix.dims ();
   int nel = dv.numel ();
 
   if (nel > 0)
     {
       MT t1 (matrix.reshape (dim_vector (nel, 1)));
 
       if (t1.any_element_is_nan ())
-	error ("invalid conversion from NaN to logical");
+        error ("invalid conversion from NaN to logical");
       else
-	{
-	  boolNDArray t2 = t1.all ();
+        {
+          boolNDArray t2 = t1.all ();
 
-	  retval = t2(0);
-	}
+          retval = t2(0);
+        }
     }
 
   return retval;
 }
 
 template <class MT>
 bool
 octave_base_matrix<MT>::print_as_scalar (void) const
@@ -450,12 +450,12 @@ octave_base_matrix<MT>::print (std::ostr
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class MT>
 void
 octave_base_matrix<MT>::print_info (std::ostream& os,
-				    const std::string& prefix) const
+                                    const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -32,69 +32,69 @@ along with Octave; see the file COPYING.
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-base-scalar.h"
 #include "pr-output.h"
 
 template <class ST>
 octave_value
 octave_base_scalar<ST>::subsref (const std::string& type,
-				 const std::list<octave_value_list>& idx)
+                                 const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
 template <class ST>
 octave_value
 octave_base_scalar<ST>::subsasgn (const std::string& type,
-				  const std::list<octave_value_list>& idx,
-				  const octave_value& rhs)
+                                  const std::list<octave_value_list>& idx,
+                                  const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
-	if (type.length () == 1)
+        if (type.length () == 1)
           retval = numeric_assign (type, idx, rhs);
-	else
-	  {
-	    std::string nm = type_name ();
-	    error ("in indexed assignment of %s, last rhs index must be ()",
-		   nm.c_str ());
-	  }
+        else
+          {
+            std::string nm = type_name ();
+            error ("in indexed assignment of %s, last rhs index must be ()",
+                   nm.c_str ());
+          }
       }
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval;
@@ -120,23 +120,23 @@ octave_base_scalar<ST>::print (std::ostr
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class ST>
 void
 octave_base_scalar<ST>::print_raw (std::ostream& os,
-				   bool pr_as_read_syntax) const
+                                   bool pr_as_read_syntax) const
 {
   indent (os);
   octave_print_internal (os, scalar, pr_as_read_syntax);
 }
 
 template <class ST>
 bool
 octave_base_scalar<ST>::print_name_tag (std::ostream& os,
-					const std::string& name) const
+                                        const std::string& name) const
 {
   indent (os);
   os << name << " = ";
   return false;    
 }
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -40,140 +40,140 @@ along with Octave; see the file COPYING.
 
 #include "boolSparse.h"
 #include "ov-base-sparse.h"
 #include "pager.h"
 
 template <class T>
 octave_value
 octave_base_sparse<T>::do_index_op (const octave_value_list& idx, 
-				    bool resize_ok)
+                                    bool resize_ok)
 {
   octave_value retval;
 
   octave_idx_type n_idx = idx.length ();
 
   int nd = matrix.ndims ();
 
   switch (n_idx)
     {
     case 0:
       retval = matrix;
       break;
 
     case 1:
       {
-	idx_vector i = idx (0).index_vector ();
+        idx_vector i = idx (0).index_vector ();
 
-	if (! error_state)
-	  retval = octave_value (matrix.index (i, resize_ok));
+        if (! error_state)
+          retval = octave_value (matrix.index (i, resize_ok));
       }
       break;
 
     default:
       {
-	if (n_idx == 2 && nd == 2)
-	  {
-	    idx_vector i = idx (0).index_vector ();
+        if (n_idx == 2 && nd == 2)
+          {
+            idx_vector i = idx (0).index_vector ();
 
-	    if (! error_state)
-	      {
-		idx_vector j = idx (1).index_vector ();
+            if (! error_state)
+              {
+                idx_vector j = idx (1).index_vector ();
 
-		if (! error_state)
-		  retval = octave_value (matrix.index (i, j, resize_ok));
-	      }
-	  }
-	else
-	  {
-	    Array<idx_vector> idx_vec (n_idx);
+                if (! error_state)
+                  retval = octave_value (matrix.index (i, j, resize_ok));
+              }
+          }
+        else
+          {
+            Array<idx_vector> idx_vec (n_idx);
 
-	    for (octave_idx_type i = 0; i < n_idx; i++)
-	      {
-		idx_vec(i) = idx(i).index_vector ();
+            for (octave_idx_type i = 0; i < n_idx; i++)
+              {
+                idx_vec(i) = idx(i).index_vector ();
 
-		if (error_state)
-		  break;
-	      }
+                if (error_state)
+                  break;
+              }
 
-	    if (! error_state)
-	      retval = octave_value (matrix.index (idx_vec, resize_ok));
-	  }
+            if (! error_state)
+              retval = octave_value (matrix.index (idx_vec, resize_ok));
+          }
       }
       break;
     }
 
   return retval;
 }
 
 template <class T>
 octave_value
 octave_base_sparse<T>::subsref (const std::string& type,
-				const std::list<octave_value_list>& idx)
+                                const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
 template <class T>
 octave_value 
 octave_base_sparse<T>::subsasgn (const std::string& type,
-				 const std::list<octave_value_list>& idx,
-				 const octave_value& rhs)
+                                 const std::list<octave_value_list>& idx,
+                                 const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
-	if (type.length () == 1)
-	  retval = numeric_assign (type, idx, rhs);
-	else
-	  {
-	    std::string nm = type_name ();
-	    error ("in indexed assignment of %s, last lhs index must be ()",
-		   nm.c_str ());
-	  }
+        if (type.length () == 1)
+          retval = numeric_assign (type, idx, rhs);
+        else
+          {
+            std::string nm = type_name ();
+            error ("in indexed assignment of %s, last lhs index must be ()",
+                   nm.c_str ());
+          }
       }
       break;
 
     case '{':
     case '.':
       {
-	if (is_empty ())
-	  {
-	    octave_value tmp = octave_value::empty_conv (type, rhs);
+        if (is_empty ())
+          {
+            octave_value tmp = octave_value::empty_conv (type, rhs);
 
-	    retval = tmp.subsasgn (type, idx, rhs);
-	  }
-	else
-	  {
-	    std::string nm = type_name ();
-	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-	  }
+            retval = tmp.subsasgn (type, idx, rhs);
+          }
+        else
+          {
+            std::string nm = type_name ();
+            error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+          }
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval;
@@ -256,25 +256,25 @@ octave_base_sparse<T>::print (std::ostre
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class T>
 void 
 octave_base_sparse<T>::print_info (std::ostream& os, 
-				   const std::string& prefix) const
+                                   const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
 template <class T>
 void
 octave_base_sparse<T>::print_raw (std::ostream& os,
-				  bool pr_as_read_syntax) const
+                                  bool pr_as_read_syntax) const
 {
   octave_idx_type nr = matrix.rows ();
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nz = nnz ();
 
   // FIXME -- this should probably all be handled by a
   // separate octave_print_internal function that can handle format
   // compact, loose, etc.
@@ -291,34 +291,34 @@ octave_base_sparse<T>::print_raw (std::o
   os << ")\n";
 
   // add one to the printed indices to go from
   //  zero-based to one-based arrays
 
   if (nz != 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  // FIXME -- is there an easy way to get the max row
-	  // and column indices so we can set the width appropriately
-	  // and line up the columns here?  Similarly, we should look
-	  // at all the nonzero values and display them with the same
-	  // formatting rules that apply to columns of a matrix.
+          // FIXME -- is there an easy way to get the max row
+          // and column indices so we can set the width appropriately
+          // and line up the columns here?  Similarly, we should look
+          // at all the nonzero values and display them with the same
+          // formatting rules that apply to columns of a matrix.
 
-	  for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-	    {
-	      os << "\n";
-	      os << "  (" << matrix.ridx(i)+1 <<
-		", "  << j+1 << ") -> ";
+          for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+            {
+              os << "\n";
+              os << "  (" << matrix.ridx(i)+1 <<
+                ", "  << j+1 << ") -> ";
 
-	      octave_print_internal (os, matrix.data(i), pr_as_read_syntax);
-	    }
-	}
+              octave_print_internal (os, matrix.data(i), pr_as_read_syntax);
+            }
+        }
     }
 }
 
 template <class T>
 bool
 octave_base_sparse<T>::save_ascii (std::ostream& os)
 {
   dim_vector dv = this->dims ();
@@ -348,20 +348,20 @@ octave_base_sparse<T>::load_ascii (std::
       extract_keyword (is, "rows", nr, true) &&
       extract_keyword (is, "columns", nc, true))
     {
       T tmp (nr, nc, nz);
 
       is >> tmp;
 
       if (!is) 
-	{
-	  error ("load: failed to load matrix constant");
-	  success = false;
-	}
+        {
+          error ("load: failed to load matrix constant");
+          success = false;
+        }
 
       matrix = tmp;
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -103,17 +103,17 @@ get_builtin_classes (void)
             retval(j++) = btyp_class_name[i];
         }
     }
 
   return retval;
 }
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value,
-				     "<unknown type>", "unknown");
+                                     "<unknown type>", "unknown");
 
 // TRUE means to perform automatic sparse to real mutation if there
 // is memory to be saved
 bool Vsparse_auto_mutate = false;
 
 octave_value
 octave_base_value::squeeze (void) const
 {
@@ -142,35 +142,35 @@ octave_base_value::size (void)
 octave_idx_type
 octave_base_value::numel (const octave_value_list& idx)
 {
   return dims_to_numel (dims (), idx);
 }
 
 octave_value
 octave_base_value::subsref (const std::string&,
-			    const std::list<octave_value_list>&)
+                            const std::list<octave_value_list>&)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 octave_value_list
 octave_base_value::subsref (const std::string&,
-			    const std::list<octave_value_list>&, int)
+                            const std::list<octave_value_list>&, int)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 octave_value
 octave_base_value::subsref (const std::string& type,
-			    const std::list<octave_value_list>& idx,
+                            const std::list<octave_value_list>& idx,
                             bool /* auto_add */)
 {
   // This way we may get a more meaningful error message.
   return subsref (type, idx);
 }
 
 octave_value
 octave_base_value::do_index_op (const octave_value_list&, bool)
@@ -203,83 +203,83 @@ octave_base_value::ndims (void) const
 
   int n_dims = dv.length ();
      
    // Remove trailing singleton dimensions.
 
    for (int i = n_dims; i > 2; i--)
      {
        if (dv(i-1) == 1)
-	 n_dims--;
+         n_dims--;
        else
-	 break;
+         break;
      }
    
    // The result is always >= 2.
 
    if (n_dims < 2)
      n_dims = 2;
 
    return n_dims;
 }
 
 octave_value
 octave_base_value::subsasgn (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     const octave_value& rhs)
+                             const std::list<octave_value_list>& idx,
+                             const octave_value& rhs)
 {
   octave_value retval;
 
   if (is_defined ())
     {
       if (is_numeric_type ())
-	{
-	  switch (type[0])
-	    {
-	    case '(':
-	      {
-		if (type.length () == 1)
-		  retval = numeric_assign (type, idx, rhs);
-		else if (is_empty ())
-		  {
-		    // Allow conversion of empty matrix to some other
-		    // type in cases like
-		    //
-		    //  x = []; x(i).f = rhs
+        {
+          switch (type[0])
+            {
+            case '(':
+              {
+                if (type.length () == 1)
+                  retval = numeric_assign (type, idx, rhs);
+                else if (is_empty ())
+                  {
+                    // Allow conversion of empty matrix to some other
+                    // type in cases like
+                    //
+                    //  x = []; x(i).f = rhs
 
-		    octave_value tmp = octave_value::empty_conv (type, rhs);
+                    octave_value tmp = octave_value::empty_conv (type, rhs);
 
-		    retval = tmp.subsasgn (type, idx, rhs);
-		  }
-		else
-		  {
-		    std::string nm = type_name ();
-		    error ("in indexed assignment of %s, last rhs index must be ()",
-			   nm.c_str ());
-		  }
-	      }
-	      break;
+                    retval = tmp.subsasgn (type, idx, rhs);
+                  }
+                else
+                  {
+                    std::string nm = type_name ();
+                    error ("in indexed assignment of %s, last rhs index must be ()",
+                           nm.c_str ());
+                  }
+              }
+              break;
 
-	    case '{':
-	    case '.':
-	      {
-		std::string nm = type_name ();
-		error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-	      }
-	      break;
+            case '{':
+            case '.':
+              {
+                std::string nm = type_name ();
+                error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+              }
+              break;
 
-	    default:
-	      panic_impossible ();
-	    }
-	}
+            default:
+              panic_impossible ();
+            }
+        }
       else
-	{
-	  std::string nm = type_name ();
-	  error ("can't perform indexed assignment for %s type", nm.c_str ());
-	}
+        {
+          std::string nm = type_name ();
+          error ("can't perform indexed assignment for %s type", nm.c_str ());
+        }
     }
   else
     {
       // Create new object of appropriate type for given index and rhs
       // types and then call subsasgn again for that object.
 
       octave_value tmp = octave_value::empty_conv (type, rhs);
 
@@ -359,26 +359,26 @@ octave_base_value::any (int) const
 
 octave_value
 octave_base_value::convert_to_str (bool pad, bool force, char type) const
 {
   octave_value retval = convert_to_str_internal (pad, force, type);
 
   if (! force && is_numeric_type ())
     gripe_implicit_conversion ("Octave:num-to-str",
-			       type_name (), retval.type_name ());
+                               type_name (), retval.type_name ());
 
   return retval;
 }
 
 octave_value
 octave_base_value::convert_to_str_internal (bool, bool, char) const
 {
   gripe_wrong_type_arg ("octave_base_value::convert_to_str_internal ()",
-			type_name ());
+                        type_name ());
   return octave_value ();
 }
 
 void
 octave_base_value::convert_to_row_or_column_vector (void)
 {
   gripe_wrong_type_arg
     ("octave_base_value::convert_to_row_or_column_vector ()",
@@ -414,56 +414,56 @@ octave_base_value::print_name_tag (std::
       retval = true;
     }
 
   return retval;
 }
 
 void
 octave_base_value::print_with_name (std::ostream& output_buf,
-				    const std::string& name, 
-				    bool print_padding)
+                                    const std::string& name, 
+                                    bool print_padding)
 {
   bool pad_after = print_name_tag (output_buf, name);
 
   print (output_buf);
 
   if (print_padding && pad_after)
     newline (output_buf);
 }
 
 void
 octave_base_value::print_info (std::ostream& os,
-			       const std::string& /* prefix */) const
+                               const std::string& /* prefix */) const
 {
   os << "no info for type: " << type_name () << "\n";
 }
 
 #define INT_CONV_METHOD(T, F, MIN_LIMIT, MAX_LIMIT) \
   T \
   octave_base_value::F ## _value (bool require_int, bool frc_str_conv) const \
   { \
     T retval = 0; \
  \
     double d = double_value (frc_str_conv); \
  \
     if (! error_state) \
       { \
-	if (require_int && D_NINT (d) != d) \
-	  error_with_cfn ("conversion of %g to " #T " value failed", d); \
-	else if (d < MIN_LIMIT) \
-	  retval = MIN_LIMIT; \
-	else if (d > MAX_LIMIT) \
-	  retval = MAX_LIMIT; \
-	else \
-	  retval = static_cast<T> (::fix (d));	\
+        if (require_int && D_NINT (d) != d) \
+          error_with_cfn ("conversion of %g to " #T " value failed", d); \
+        else if (d < MIN_LIMIT) \
+          retval = MIN_LIMIT; \
+        else if (d > MAX_LIMIT) \
+          retval = MAX_LIMIT; \
+        else \
+          retval = static_cast<T> (::fix (d));  \
       } \
     else \
       gripe_wrong_type_arg ("octave_base_value::" #F "_value ()", \
-			    type_name ()); \
+                            type_name ()); \
  \
     return retval; \
   }
 
 INT_CONV_METHOD (short int, short, SHRT_MIN, SHRT_MAX)
 INT_CONV_METHOD (unsigned short int, ushort, 0, USHRT_MAX)
 
 INT_CONV_METHOD (int, int, INT_MIN, INT_MAX)
@@ -477,20 +477,20 @@ octave_base_value::nint_value (bool frc_
 {
   int retval = 0;
 
   double d = double_value (frc_str_conv);
 
   if (! error_state)
     {
       if (xisnan (d))
-	{
-	  error ("conversion of NaN to integer value failed");
-	  return retval;
-	}
+        {
+          error ("conversion of NaN to integer value failed");
+          return retval;
+        }
 
       retval = static_cast<int> (::fix (d));
     }
   else
     gripe_wrong_type_arg ("octave_base_value::nint_value ()", type_name ());
 
   return retval;
 }
@@ -569,70 +569,70 @@ octave_base_value::float_complex_value (
   return retval;
 }
 
 ComplexMatrix
 octave_base_value::complex_matrix_value (bool) const
 {
   ComplexMatrix retval;
   gripe_wrong_type_arg ("octave_base_value::complex_matrix_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 FloatComplexMatrix
 octave_base_value::float_complex_matrix_value (bool) const
 {
   FloatComplexMatrix retval;
   gripe_wrong_type_arg ("octave_base_value::float_complex_matrix_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 ComplexNDArray
 octave_base_value::complex_array_value (bool) const
 {
   ComplexNDArray retval;
   gripe_wrong_type_arg ("octave_base_value::complex_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 FloatComplexNDArray
 octave_base_value::float_complex_array_value (bool) const
 {
   FloatComplexNDArray retval;
   gripe_wrong_type_arg ("octave_base_value::float_complex_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 bool
 octave_base_value::bool_value (bool) const
 {
   bool retval = false;
   gripe_wrong_type_arg ("octave_base_value::bool_value()", type_name ());
   return retval;
 }
 
 boolMatrix
 octave_base_value::bool_matrix_value (bool) const
 {
   boolMatrix retval;
   gripe_wrong_type_arg ("octave_base_value::bool_matrix_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 boolNDArray
 octave_base_value::bool_array_value (bool) const
 {
   boolNDArray retval;
   gripe_wrong_type_arg ("octave_base_value::bool_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 charMatrix
 octave_base_value::char_matrix_value (bool force) const
 {
   charMatrix retval;
 
@@ -644,17 +644,17 @@ octave_base_value::char_matrix_value (bo
   return retval;
 }
 
 charNDArray
 octave_base_value::char_array_value (bool) const
 {
   charNDArray retval;
   gripe_wrong_type_arg ("octave_base_value::char_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 SparseMatrix
 octave_base_value::sparse_matrix_value (bool) const
 {
   SparseMatrix retval;
   gripe_wrong_type_arg ("octave_base_value::sparse_matrix_value()", type_name ());
@@ -717,152 +717,152 @@ octave_base_value::perm_matrix_value (vo
   return retval;
 }
 
 octave_int8
 octave_base_value::int8_scalar_value (void) const
 {
   octave_int8 retval;
   gripe_wrong_type_arg ("octave_base_value::int8_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_int16
 octave_base_value::int16_scalar_value (void) const
 {
   octave_int16 retval;
   gripe_wrong_type_arg ("octave_base_value::int16_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_int32
 octave_base_value::int32_scalar_value (void) const
 {
   octave_int32 retval;
   gripe_wrong_type_arg ("octave_base_value::int32_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_int64
 octave_base_value::int64_scalar_value (void) const
 {
   octave_int64 retval;
   gripe_wrong_type_arg ("octave_base_value::int64_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_uint8
 octave_base_value::uint8_scalar_value (void) const
 {
   octave_uint8 retval;
   gripe_wrong_type_arg ("octave_base_value::uint8_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_uint16
 octave_base_value::uint16_scalar_value (void) const
 {
   octave_uint16 retval;
   gripe_wrong_type_arg ("octave_base_value::uint16_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_uint32
 octave_base_value::uint32_scalar_value (void) const
 {
   octave_uint32 retval;
   gripe_wrong_type_arg ("octave_base_value::uint32_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_uint64
 octave_base_value::uint64_scalar_value (void) const
 {
   octave_uint64 retval;
   gripe_wrong_type_arg ("octave_base_value::uint64_scalar_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 int8NDArray
 octave_base_value::int8_array_value (void) const
 {
   int8NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::int8_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 int16NDArray
 octave_base_value::int16_array_value (void) const
 {
   int16NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::int16_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 int32NDArray
 octave_base_value::int32_array_value (void) const
 {
   int32NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::int32_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 int64NDArray
 octave_base_value::int64_array_value (void) const
 {
   int64NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::int64_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 uint8NDArray
 octave_base_value::uint8_array_value (void) const
 {
   uint8NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::uint8_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 uint16NDArray
 octave_base_value::uint16_array_value (void) const
 {
   uint16NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::uint16_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 uint32NDArray
 octave_base_value::uint32_array_value (void) const
 {
   uint32NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::uint32_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 uint64NDArray
 octave_base_value::uint64_array_value (void) const
 {
   uint64NDArray retval;
   gripe_wrong_type_arg ("octave_base_value::uint64_array_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 string_vector
 octave_base_value::all_strings (bool pad) const
 {
   string_vector retval;
 
@@ -887,17 +887,17 @@ octave_base_value::string_value (bool fo
   return retval;
 }
 
 Array<std::string>
 octave_base_value::cellstr_value (void) const
 {
   Array<std::string> retval;
   gripe_wrong_type_arg ("octave_base_value::cellstry_value()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 Range
 octave_base_value::range_value (void) const
 {
   Range retval;
   gripe_wrong_type_arg ("octave_base_value::range_value()", type_name ());
@@ -928,92 +928,92 @@ octave_base_value::nparents (void) const
   return retval;
 }
 
 std::list<std::string>
 octave_base_value::parent_class_name_list (void) const
 {
   std::list<std::string> retval;
   gripe_wrong_type_arg ("octave_base_value::parent_class_name_list()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 string_vector
 octave_base_value::parent_class_names (void) const
 {
   string_vector retval;
   gripe_wrong_type_arg ("octave_base_value::parent_class_names()",
-			type_name ());
+                        type_name ());
   return retval;
 }
 
 octave_function *
 octave_base_value::function_value (bool silent)
 {
   octave_function *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::function_value()",
-			  type_name ());
+                          type_name ());
   return retval;
 }
 
 octave_user_function *
 octave_base_value::user_function_value (bool silent)
 {
   octave_user_function *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::user_function_value()",
-			  type_name ());
+                          type_name ());
   return retval;
 }
 
 octave_user_script *
 octave_base_value::user_script_value (bool silent)
 {
   octave_user_script *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::user_script_value()",
-			  type_name ());
+                          type_name ());
   return retval;
 }
 
 octave_user_code *
 octave_base_value::user_code_value (bool silent)
 {
   octave_user_code *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::user_code_value()",
-			  type_name ());
+                          type_name ());
   return retval;
 }
 
 octave_fcn_handle *
 octave_base_value::fcn_handle_value (bool silent)
 {
   octave_fcn_handle *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::fcn_handle_value()",
-			  type_name ());
+                          type_name ());
   return retval;
 }
 
 octave_fcn_inline *
 octave_base_value::fcn_inline_value (bool silent)
 {
   octave_fcn_inline *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::fcn_inline_value()",
-			  type_name ());
+                          type_name ());
   return retval;
 }
 
 octave_value_list
 octave_base_value::list_value (void) const
 {
   octave_value_list retval;
   gripe_wrong_type_arg ("octave_base_value::list_value()", type_name ());
@@ -1038,17 +1038,17 @@ bool
 octave_base_value::save_binary (std::ostream&, bool&)
 {
   gripe_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
   return false;
 }
 
 bool 
 octave_base_value::load_binary (std::istream&, bool,
-				oct_mach_info::float_format)
+                                oct_mach_info::float_format)
 {
   gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
   return false;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
@@ -1066,17 +1066,17 @@ octave_base_value::load_hdf5 (hid_t, con
 
   return false;
 }
 
 #endif
 
 int
 octave_base_value::write (octave_stream&, int, oct_data_conv::data_type,
-			  int, oct_mach_info::float_format) const
+                          int, oct_mach_info::float_format) const
 {
   gripe_wrong_type_arg ("octave_base_value::write()", type_name ());
 
   return false;
 }
 
 mxArray *
 octave_base_value::as_mxArray (void) const
@@ -1099,17 +1099,17 @@ octave_base_value::sort (octave_idx_type
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value();
 }
 
 octave_value
 octave_base_value::sort (Array<octave_idx_type> &, 
-			 octave_idx_type, sortmode) const
+                         octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value();
 }
 
 sortmode
 octave_base_value::is_sorted (sortmode) const
@@ -1232,54 +1232,54 @@ octave_base_value::dump (std::ostream& o
      << " type: " << this->type_name ()
      << " dims: " << dv.str ();
 }
 
 static void
 gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
   error ("assignment of `%s' to indexed `%s' not implemented",
-	 tn2.c_str (), tn1.c_str ());
+         tn2.c_str (), tn1.c_str ());
 }
 
 static void
 gripe_assign_conversion_failed (const std::string& tn1,
-				const std::string& tn2)
+                                const std::string& tn2)
 {
   error ("type conversion for assignment of `%s' to indexed `%s' failed",
-	 tn2.c_str (), tn1.c_str ());
+         tn2.c_str (), tn1.c_str ());
 }
 
 static void
 gripe_no_conversion (const std::string& on, const std::string& tn1,
-		     const std::string& tn2)
+                     const std::string& tn2)
 {
   error ("operator %s: no conversion for assignment of `%s' to indexed `%s'",
-	 on.c_str (), tn2.c_str (), tn1.c_str ());
+         on.c_str (), tn2.c_str (), tn1.c_str ());
 }
 
 octave_value
 octave_base_value::numeric_assign (const std::string& type,
-				   const std::list<octave_value_list>& idx,
-				   const octave_value& rhs)
+                                   const std::list<octave_value_list>& idx,
+                                   const octave_value& rhs)
 {
   octave_value retval;
 
   if (idx.front ().empty ())
     {
       error ("missing index in indexed assignment");
       return retval;
     }
 
   int t_lhs = type_id ();
   int t_rhs = rhs.type_id ();
 
   octave_value_typeinfo::assign_op_fcn f
     = octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
-					       t_lhs, t_rhs);
+                                               t_lhs, t_rhs);
 
   bool done = false;
 
   if (f)
     {
       f (*this, idx.front (), rhs.get_rep ());
 
       done = (! error_state);
@@ -1288,110 +1288,110 @@ octave_base_value::numeric_assign (const
   if (done)
     {
       count++;
       retval = octave_value (this);
     }
   else
     {
       int t_result
-	= octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, t_rhs);
+        = octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, t_rhs);
 
       if (t_result >= 0)
-	{
-	  octave_base_value::type_conv_fcn cf
-	    = octave_value_typeinfo::lookup_widening_op (t_lhs, t_result);
+        {
+          octave_base_value::type_conv_fcn cf
+            = octave_value_typeinfo::lookup_widening_op (t_lhs, t_result);
 
-	  if (cf)
-	    {
-	      octave_base_value *tmp = cf (*this);
+          if (cf)
+            {
+              octave_base_value *tmp = cf (*this);
 
-	      if (tmp)
-		{
-		  octave_value val (tmp);
+              if (tmp)
+                {
+                  octave_value val (tmp);
 
-		  retval = val.subsasgn (type, idx, rhs);
+                  retval = val.subsasgn (type, idx, rhs);
 
-		  done = (! error_state);
-		}
-	      else
-		gripe_assign_conversion_failed (type_name (),
-						rhs.type_name ());
-	    }
-	  else
-	    gripe_indexed_assignment (type_name (), rhs.type_name ());
-	}
+                  done = (! error_state);
+                }
+              else
+                gripe_assign_conversion_failed (type_name (),
+                                                rhs.type_name ());
+            }
+          else
+            gripe_indexed_assignment (type_name (), rhs.type_name ());
+        }
 
       if (! (done || error_state))
-	{
-	  octave_value tmp_rhs;
+        {
+          octave_value tmp_rhs;
 
-	  octave_base_value::type_conv_info cf_rhs
-	    = rhs.numeric_conversion_function ();
+          octave_base_value::type_conv_info cf_rhs
+            = rhs.numeric_conversion_function ();
 
-	  octave_base_value::type_conv_info cf_this
-	    = numeric_conversion_function ();
+          octave_base_value::type_conv_info cf_this
+            = numeric_conversion_function ();
 
           // Try biased (one-sided) conversions first.
           if (cf_rhs.type_id () >= 0
               && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
                                                            t_lhs, cf_rhs.type_id ())
                   || octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, 
                                                                      cf_rhs.type_id ()) >= 0))
             cf_this = 0;
           else if (cf_this.type_id () >= 0
                    && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
                                                                 cf_this.type_id (), t_rhs)
                        || octave_value_typeinfo::lookup_pref_assign_conv (cf_this.type_id (),
                                                                           t_rhs) >= 0))
             cf_rhs = 0;
 
-	  if (cf_rhs)
-	    {
-	      octave_base_value *tmp = cf_rhs (rhs.get_rep ());
+          if (cf_rhs)
+            {
+              octave_base_value *tmp = cf_rhs (rhs.get_rep ());
 
-	      if (tmp)
-		tmp_rhs = octave_value (tmp);
-	      else
-		{
-		  gripe_assign_conversion_failed (type_name (),
-						  rhs.type_name ());
-		  return octave_value ();
-		}
-	    }
-	  else
-	    tmp_rhs = rhs;
+              if (tmp)
+                tmp_rhs = octave_value (tmp);
+              else
+                {
+                  gripe_assign_conversion_failed (type_name (),
+                                                  rhs.type_name ());
+                  return octave_value ();
+                }
+            }
+          else
+            tmp_rhs = rhs;
 
-	  count++;
-	  octave_value tmp_lhs = octave_value (this);
+          count++;
+          octave_value tmp_lhs = octave_value (this);
 
-	  if (cf_this)
-	    {
-	      octave_base_value *tmp = cf_this (*this);
+          if (cf_this)
+            {
+              octave_base_value *tmp = cf_this (*this);
 
-	      if (tmp)
-		tmp_lhs = octave_value (tmp);
-	      else
-		{
-		  gripe_assign_conversion_failed (type_name (),
-						  rhs.type_name ());
-		  return octave_value ();
-		}
-	    }
+              if (tmp)
+                tmp_lhs = octave_value (tmp);
+              else
+                {
+                  gripe_assign_conversion_failed (type_name (),
+                                                  rhs.type_name ());
+                  return octave_value ();
+                }
+            }
 
-	  if (cf_this || cf_rhs)
-	    {
-	      retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
+          if (cf_this || cf_rhs)
+            {
+              retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
 
-	      done = (! error_state);
-	    }
-	  else
-	    gripe_no_conversion (octave_value::assign_op_as_string (octave_value::op_asn_eq),
-				 type_name (), rhs.type_name ());
-	}
+              done = (! error_state);
+            }
+          else
+            gripe_no_conversion (octave_value::assign_op_as_string (octave_value::op_asn_eq),
+                                 type_name (), rhs.type_name ());
+        }
     }
 
   // The assignment may have converted to a type that is wider than
   // necessary.
 
   retval.maybe_mutate ();
 
   return retval;
@@ -1413,17 +1413,17 @@ octave_base_value::indent (std::ostream&
   assert (curr_print_indent_level >= 0);
  
   if (beginning_of_line)
     {
       // FIXME -- do we need this?
       // os << prefix;
 
       for (int i = 0; i < curr_print_indent_level; i++)
-	os << " ";
+        os << " ";
 
       beginning_of_line = false;
     }
 }
 
 // All print() functions should use this to print new lines.
 
 void
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -49,17 +49,17 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 template class octave_base_matrix<boolNDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_bool_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool_matrix,
-				     "bool matrix", "logical");
+                                     "bool matrix", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_bool_matrix&);
 
   return new octave_matrix (NDArray (v.bool_array_value ()));
 }
@@ -79,31 +79,31 @@ octave_bool_matrix::try_narrowing_conver
   if (matrix.ndims () == 2)
     {
       boolMatrix bm = matrix.matrix_value ();
 
       octave_idx_type nr = bm.rows ();
       octave_idx_type nc = bm.cols ();
 
       if (nr == 1 && nc == 1)
-	retval = new octave_bool (bm (0, 0));
+        retval = new octave_bool (bm (0, 0));
     }
 
   return retval;
 }
 
 double
 octave_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "bool matrix", "real scalar");
+                                 "bool matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "real scalar");
 
   return retval;
 }
@@ -111,17 +111,17 @@ octave_bool_matrix::double_value (bool) 
 float
 octave_bool_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "bool matrix", "real scalar");
+                                 "bool matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "real scalar");
 
   return retval;
 }
@@ -131,17 +131,17 @@ octave_bool_matrix::complex_value (bool)
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "bool matrix", "complex scalar");
+                                 "bool matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
@@ -151,62 +151,62 @@ octave_bool_matrix::float_complex_value 
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "bool matrix", "complex scalar");
+                                 "bool matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
 
 octave_value
 octave_bool_matrix::convert_to_str_internal (bool pad, bool force,
-					     char type) const
+                                             char type) const
 {
   octave_value tmp = octave_value (array_value ());
   return tmp.convert_to_str (pad, force, type);
 }
 
 void
 octave_bool_matrix::print_raw (std::ostream& os,
-			       bool pr_as_read_syntax) const
+                               bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 bool 
 octave_bool_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
-	os << " " << d (i);
+        os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
-	 << "# columns: " << columns () << "\n";
+         << "# columns: " << columns () << "\n";
 
       Matrix tmp = matrix_value ();
 
       os << tmp;
     }
 
   return true;
 }
@@ -222,103 +222,103 @@ octave_bool_matrix::load_ascii (std::ist
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
-	{
-	  int mdims = static_cast<int> (val);
+        {
+          int mdims = static_cast<int> (val);
 
-	  if (mdims >= 0)
-	    {
-	      dim_vector dv;
-	      dv.resize (mdims);
+          if (mdims >= 0)
+            {
+              dim_vector dv;
+              dv.resize (mdims);
 
-	      for (int i = 0; i < mdims; i++)
-		is >> dv(i);
+              for (int i = 0; i < mdims; i++)
+                is >> dv(i);
 
-	      if (is)
-		{
-		  boolNDArray btmp (dv);
+              if (is)
+                {
+                  boolNDArray btmp (dv);
 
-		  if (btmp.is_empty ())
-		    matrix = btmp;
-		  else
-		    {
-		      NDArray tmp(dv);
-		      is >> tmp;
+                  if (btmp.is_empty ())
+                    matrix = btmp;
+                  else
+                    {
+                      NDArray tmp(dv);
+                      is >> tmp;
 
-		      if (is)
-			{
-			  for (octave_idx_type i = 0; i < btmp.nelem (); i++)
-			    btmp.elem (i) = (tmp.elem (i) != 0.);
+                      if (is)
+                        {
+                          for (octave_idx_type i = 0; i < btmp.nelem (); i++)
+                            btmp.elem (i) = (tmp.elem (i) != 0.);
 
-			  matrix = btmp;
-			}
-		      else
-			{
-			  error ("load: failed to load matrix constant");
-			  success = false;
-			}
-		    }
-		}
-	      else
-		{
-		  error ("load: failed to extract dimensions");
-		  success = false;
-		}
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of dimensions");
-	      success = false;
-	    }
-	}
+                          matrix = btmp;
+                        }
+                      else
+                        {
+                          error ("load: failed to load matrix constant");
+                          success = false;
+                        }
+                    }
+                }
+              else
+                {
+                  error ("load: failed to extract dimensions");
+                  success = false;
+                }
+            }
+          else
+            {
+              error ("load: failed to extract number of dimensions");
+              success = false;
+            }
+        }
       else if (kw == "rows")
-	{
-	  octave_idx_type nr = val;
-	  octave_idx_type nc = 0;
+        {
+          octave_idx_type nr = val;
+          octave_idx_type nc = 0;
 
-	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-	    {
-	      if (nr > 0 && nc > 0)
-		{
-		  Matrix tmp (nr, nc);
-		  is >> tmp;
-		  if (is) 
-		    {
-		      boolMatrix btmp (nr, nc);
-		      for (octave_idx_type j = 0; j < nc; j++)
-			for (octave_idx_type i = 0; i < nr; i++)
-			  btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
+          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+            {
+              if (nr > 0 && nc > 0)
+                {
+                  Matrix tmp (nr, nc);
+                  is >> tmp;
+                  if (is) 
+                    {
+                      boolMatrix btmp (nr, nc);
+                      for (octave_idx_type j = 0; j < nc; j++)
+                        for (octave_idx_type i = 0; i < nr; i++)
+                          btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
 
-		      matrix = btmp;
-		    }
-		  else
-		    {
-		      error ("load: failed to load matrix constant");
-		      success = false;
-		    }
-		}
-	      else if (nr == 0 || nc == 0)
-		matrix = boolMatrix (nr, nc);
-	      else
-		panic_impossible ();
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of rows and columns");
-	      success = false;
-	    }
-	}
+                      matrix = btmp;
+                    }
+                  else
+                    {
+                      error ("load: failed to load matrix constant");
+                      success = false;
+                    }
+                }
+              else if (nr == 0 || nc == 0)
+                matrix = boolMatrix (nr, nc);
+              else
+                panic_impossible ();
+            }
+          else
+            {
+              error ("load: failed to extract number of rows and columns");
+              success = false;
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
@@ -351,17 +351,17 @@ octave_bool_matrix::save_binary (std::os
 
   os.write (htmp, nel);
 
   return true;
 }
 
 bool 
 octave_bool_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format /* fmt */)
+                                 oct_mach_info::float_format /* fmt */)
 {
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
@@ -372,19 +372,19 @@ octave_bool_matrix::load_binary (std::is
   mdims = - mdims;
   int32_t di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&di);
+        swap_bytes<4> (&di);
       dv(i) = di;
     }
   
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
   // might.
 
   if (mdims == 1)
@@ -407,17 +407,17 @@ octave_bool_matrix::load_binary (std::is
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_bool_matrix::save_hdf5 (hid_t loc_id, const char *name,
-			       bool /* save_as_floats */)
+                               bool /* save_as_floats */)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid = -1, data_hid = -1;
@@ -429,36 +429,36 @@ octave_bool_matrix::save_hdf5 (hid_t loc
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   octave_idx_type nel = m.nelem ();
   bool *mtmp = m.fortran_vec ();
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nel);
   
   for (octave_idx_type i = 0; i < nel; i++)
     htmp[i] = mtmp[i];
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, htmp) >= 0;
+                     H5P_DEFAULT, htmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
@@ -499,28 +499,28 @@ octave_bool_matrix::load_hdf5 (hid_t loc
       dv.resize (2);
       dv(0) = 1;
       dv(1) = hdims[0];
     }
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
-	dv(j) = hdims[i];
+        dv(j) = hdims[i];
     }
 
   octave_idx_type nel = dv.numel ();
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nel);
   if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, H5P_DEFAULT, htmp) >= 0) 
     {
       retval = true;
 
       boolNDArray btmp (dv);
       for (octave_idx_type i = 0; i < nel; i++)
-	  btmp.elem (i) = htmp[i];
+          btmp.elem (i) = htmp[i];
 
       matrix = btmp;
     }
 
   H5Dclose (data_hid);
 
   return retval;
 }
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -72,41 +72,41 @@ octave_sparse_bool_matrix::try_narrowing
   octave_base_value *retval = 0;
 
   if (Vsparse_auto_mutate)
     {
       // Don't use numel, since it can overflow for very large matrices
       // Note that for the second test, this means it becomes approximative
       // since it involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
-	{
-	  // Const copy of the matrix, so the right version of () operator used
-	  const SparseBoolMatrix tmp (matrix);
+        {
+          // Const copy of the matrix, so the right version of () operator used
+          const SparseBoolMatrix tmp (matrix);
 
-	  retval = new octave_bool (tmp (0));
-	}
+          retval = new octave_bool (tmp (0));
+        }
       else if (matrix.cols () > 0 && matrix.rows () > 0
-	       && (double (matrix.byte_size ()) > double (matrix.rows ())
-		   * double (matrix.cols ()) * sizeof (bool)))
-	retval = new octave_bool_matrix (matrix.matrix_value ());
+               && (double (matrix.byte_size ()) > double (matrix.rows ())
+                   * double (matrix.cols ()) * sizeof (bool)))
+        retval = new octave_bool_matrix (matrix.matrix_value ());
     }
 
   return retval;
 }
 
 double
 octave_sparse_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
       if (numel () > 1)
-	gripe_implicit_conversion ("Octave:array-as-scalar",
-				   "bool sparse matrix", "real scalar");
+        gripe_implicit_conversion ("Octave:array-as-scalar",
+                                   "bool sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "real scalar");
 
   return retval;
 }
@@ -116,30 +116,30 @@ octave_sparse_bool_matrix::complex_value
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       if (numel () > 1)
-	gripe_implicit_conversion ("Octave:array-as-scalar",
-				   "bool sparse matrix", "complex scalar");
+        gripe_implicit_conversion ("Octave:array-as-scalar",
+                                   "bool sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "complex scalar");
 
   return retval;
 }
 
 octave_value
 octave_sparse_bool_matrix::convert_to_str_internal (bool pad, bool force,
-						    char type) const
+                                                    char type) const
 {
   octave_value tmp = octave_value (array_value ());
   return tmp.convert_to_str (pad, force, type);
 }
 
 // FIXME These are inefficient ways of creating full matrices
 
 Matrix
@@ -256,17 +256,17 @@ octave_sparse_bool_matrix::save_binary (
    
   os.write (htmp, nz);
 
   return true;
 }
 
 bool
 octave_sparse_bool_matrix::load_binary (std::istream& is, bool swap,
-					oct_mach_info::float_format /* fmt */)
+                                        oct_mach_info::float_format /* fmt */)
 {
   int32_t nz, nc, nr, tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
@@ -285,36 +285,36 @@ octave_sparse_bool_matrix::load_binary (
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
-		      static_cast<octave_idx_type> (nc),
-		      static_cast<octave_idx_type> (nz));
+                      static_cast<octave_idx_type> (nc),
+                      static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
 
   if (error_state || ! is)
     return false;
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
@@ -361,20 +361,20 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
@@ -385,56 +385,56 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -448,31 +448,31 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, itmp) >= 0;
+                     H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -486,59 +486,59 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, itmp) >= 0;
+                     H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, m.nzmax ());  
   for (int i = 0; i < m.nzmax (); i++)
     htmp[i] = m.xdata(i);
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, htmp) >= 0;
+                     H5P_DEFAULT, htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
@@ -630,18 +630,18 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
-		      static_cast<octave_idx_type> (nc),
-		      static_cast<octave_idx_type> (nz));
+                      static_cast<octave_idx_type> (nc),
+                      static_cast<octave_idx_type> (nz));
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "cidx", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "cidx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
@@ -704,17 +704,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-	       H5P_DEFAULT, itmp) < 0) 
+               H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -745,23 +745,23 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nz);
   bool retval = false;
   if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
-	       H5P_DEFAULT, htmp) >= 0
+               H5P_DEFAULT, htmp) >= 0
       && m.indices_ok ())
     {
       retval = true;
 
       for (int i = 0; i < nz; i++)
-	m.xdata(i) = htmp[i];
+        m.xdata(i) = htmp[i];
 
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
@@ -770,17 +770,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 
 #endif
 
 mxArray *
 octave_sparse_bool_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax ();
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, rows (), columns (), 
-				 nz, mxREAL);
+                                 nz, mxREAL);
   bool *pr = static_cast<bool *> (retval->get_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
       pr[i] = matrix.data(i);
       ir[i] = matrix.ridx(i);
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -86,24 +86,24 @@ octave_bool::do_index_op (const octave_v
 
 octave_value 
 octave_bool::resize (const dim_vector& dv, bool fill) const
 { 
   if (fill)
     {
       boolNDArray retval (dv, false); 
       if (dv.numel()) 
-	retval(0) = scalar; 
+        retval(0) = scalar; 
       return retval; 
     }
   else
     {
       boolNDArray retval (dv); 
       if (dv.numel()) 
-	retval(0) = scalar; 
+        retval(0) = scalar; 
       return retval; 
     }
 }
 
 octave_value
 octave_bool::convert_to_str_internal (bool, bool, char type) const
 {
   char s[2];
@@ -144,53 +144,53 @@ octave_bool::save_binary (std::ostream& 
   char tmp = (scalar ? 1 : 0);
   os.write (reinterpret_cast<char *> (&tmp), 1);
 
   return true;
 }
 
 bool 
 octave_bool::load_binary (std::istream& is, bool /* swap */,
-			  oct_mach_info::float_format /* fmt */)
+                          oct_mach_info::float_format /* fmt */)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   scalar = (tmp ? 1 : 0);
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_bool::save_hdf5 (hid_t loc_id, const char *name,
-			bool /* save_as_floats */)
+                        bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
@@ -208,17 +208,17 @@ octave_bool::load_hdf5 (hid_t loc_id, co
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   double dtmp;
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, &dtmp) < 0)
+               H5P_DEFAULT, &dtmp) < 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   scalar = (dtmp != 0.);
 
   H5Dclose (data_hid);
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -31,41 +31,41 @@ along with Octave; see the file COPYING.
 #include "ov-builtin.h"
 #include "ov.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_builtin);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_builtin,
-				     "built-in function",
-				     "built-in function");
+                                     "built-in function",
+                                     "built-in function");
 
 octave_value_list
 octave_builtin::subsref (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 int nargout)
+                         const std::list<octave_value_list>& idx,
+                         int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
-	int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
+        int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
 
-	retval = do_multi_index_op (tmp_nargout, idx.front ());
+        retval = do_multi_index_op (tmp_nargout, idx.front ());
       }
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME -- perhaps there should be an
@@ -98,30 +98,30 @@ octave_builtin::do_multi_index_op (int n
     {
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
       frame.add_fcn (octave_call_stack::pop);
 
       try
-	{
-	  retval = (*f) (args, nargout);
+        {
+          retval = (*f) (args, nargout);
           // Do not allow null values to be returned from functions.
           // FIXME -- perhaps true builtins should be allowed?
           retval.make_storable_values ();
           // Fix the case of a single undefined value.
           // This happens when a compiled function uses
           //   octave_value retval;
           // instead of
           //   octave_value_list retval;
           // the idiom is very common, so we solve that here.
           if (retval.length () == 1 && retval.xelem (0).is_undefined ())
             retval.clear ();
-	}
+        }
       catch (octave_execution_exception)
-	{
-	  gripe_library_execution_error ();
-	}
+        {
+          gripe_library_execution_error ();
+        }
     }
 
   return retval;
 }
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -101,47 +101,47 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 static void
 gripe_failed_assignment (void)
 {
   error ("assignment to cell array failed");
 }
 
 octave_value_list
 octave_cell::subsref (const std::string& type,
-		      const std::list<octave_value_list>& idx,
-		      int nargout)
+                      const std::list<octave_value_list>& idx,
+                      int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       retval(0) = do_index_op (idx.front ());
       break;
 
     case '{':
       {
-	octave_value tmp = do_index_op (idx.front ());
+        octave_value tmp = do_index_op (idx.front ());
 
-	if (! error_state)
-	  {
-	    Cell tcell = tmp.cell_value ();
+        if (! error_state)
+          {
+            Cell tcell = tmp.cell_value ();
 
-	    if (tcell.length () == 1)
-	      retval(0) = tcell(0,0);
-	    else
+            if (tcell.length () == 1)
+              retval(0) = tcell(0,0);
+            else
               retval = octave_value (octave_value_list (tcell), true);
-	  }
+          }
       }
       break;
 
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME -- perhaps there should be an
@@ -151,47 +151,47 @@ octave_cell::subsref (const std::string&
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 octave_value
 octave_cell::subsref (const std::string& type,
-		      const std::list<octave_value_list>& idx,
-		      bool auto_add)
+                      const std::list<octave_value_list>& idx,
+                      bool auto_add)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front (), auto_add);
       break;
 
     case '{':
       {
-	octave_value tmp = do_index_op (idx.front (), auto_add);
+        octave_value tmp = do_index_op (idx.front (), auto_add);
 
-	if (! error_state)
-	  {
-	    const Cell tcell = tmp.cell_value ();
+        if (! error_state)
+          {
+            const Cell tcell = tmp.cell_value ();
 
-	    if (tcell.length () == 1)
-	      retval = tcell(0,0);
-	    else
+            if (tcell.length () == 1)
+              retval = tcell(0,0);
+            else
               retval = octave_value (octave_value_list (tcell), true);
-	  }
+          }
       }
       break;
 
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME -- perhaps there should be an
@@ -201,18 +201,18 @@ octave_cell::subsref (const std::string&
   if (idx.size () > 1)
     retval = retval.next_subsref (auto_add, type, idx);
 
   return retval;
 }
 
 octave_value
 octave_cell::subsasgn (const std::string& type,
-		       const std::list<octave_value_list>& idx,
-		       const octave_value& rhs)
+                       const std::list<octave_value_list>& idx,
+                       const octave_value& rhs)
 {
   octave_value retval;
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
   clear_cellstr_cache ();
@@ -221,171 +221,171 @@ octave_cell::subsasgn (const std::string
     {
       error ("missing index in indexed assignment");
       return retval;
     }
 
   if (n > 1)
     {
       switch (type[0])
-	{
-	case '(':
-	  {
-	    if (is_empty () && type[1] == '.')
-	      {
-		// Allow conversion of empty cell array to some other
-		// type in cases like
-		//
-		//  x = []; x(i).f = rhs
+        {
+        case '(':
+          {
+            if (is_empty () && type[1] == '.')
+              {
+                // Allow conversion of empty cell array to some other
+                // type in cases like
+                //
+                //  x = []; x(i).f = rhs
 
-		octave_value tmp = octave_value::empty_conv (type, rhs);
+                octave_value tmp = octave_value::empty_conv (type, rhs);
 
-		return tmp.subsasgn (type, idx, rhs);
-	      }
-	    else
-	      {
-		octave_value tmp = do_index_op (idx.front (), true);
+                return tmp.subsasgn (type, idx, rhs);
+              }
+            else
+              {
+                octave_value tmp = do_index_op (idx.front (), true);
 
-		if (! tmp.is_defined ())
-		  tmp = octave_value::empty_conv (type.substr (1), rhs);
+                if (! tmp.is_defined ())
+                  tmp = octave_value::empty_conv (type.substr (1), rhs);
 
-		if (! error_state)
-		  {
-		    std::list<octave_value_list> next_idx (idx);
+                if (! error_state)
+                  {
+                    std::list<octave_value_list> next_idx (idx);
 
-		    next_idx.erase (next_idx.begin ());
+                    next_idx.erase (next_idx.begin ());
 
-		    tmp.make_unique ();
+                    tmp.make_unique ();
 
-		    t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
-		  }
-	      }
-	  }
-	  break;
+                    t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
+                  }
+              }
+          }
+          break;
 
-	case '{':
-	  {
+        case '{':
+          {
             matrix.make_unique ();
-	    Cell tmpc = matrix.index (idx.front (), true);
+            Cell tmpc = matrix.index (idx.front (), true);
 
-	    if (! error_state)
-	      {
+            if (! error_state)
+              {
                 std::list<octave_value_list> next_idx (idx);
 
                 next_idx.erase (next_idx.begin ());
 
                 std::string next_type = type.substr (1);
 
                 if (tmpc.numel () == 1)
-		  {
-		    octave_value tmp = tmpc(0);
+                  {
+                    octave_value tmp = tmpc(0);
                     tmpc = Cell ();
 
-		    if (! tmp.is_defined () || tmp.is_zero_by_zero ())
+                    if (! tmp.is_defined () || tmp.is_zero_by_zero ())
                       {
                         tmp = octave_value::empty_conv (type.substr (1), rhs);
                         tmp.make_unique (); // probably a no-op.
                       }
                     else
                       // optimization: ignore the copy still stored inside our array. 
                       tmp.make_unique (1);
 
-		    if (! error_state)
-		      t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
-		  }
+                    if (! error_state)
+                      t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
+                  }
                 else
                   gripe_indexed_cs_list ();
-	      }
-	  }
-	  break;
+              }
+          }
+          break;
 
-	case '.':
-	  {
-	    std::string nm = type_name ();
-	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-	  }
-	  break;
+        case '.':
+          {
+            std::string nm = type_name ();
+            error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+          }
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
     }
 
   if (! error_state)
     {
       switch (type[0])
-	{
-	case '(':
-	  {
-	    octave_value_list i = idx.front ();
+        {
+        case '(':
+          {
+            octave_value_list i = idx.front ();
 
-	    if (t_rhs.is_cell ())
-	      octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
-	    else
-	      if (t_rhs.is_null_value ())
-		octave_base_matrix<Cell>::delete_elements (i);
-	      else
-		octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
+            if (t_rhs.is_cell ())
+              octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
+            else
+              if (t_rhs.is_null_value ())
+                octave_base_matrix<Cell>::delete_elements (i);
+              else
+                octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
 
-	    if (! error_state)
-	      {
-		count++;
-		retval = octave_value (this);
-	      }
-	    else
-	      gripe_failed_assignment ();
-	  }
-	  break;
+            if (! error_state)
+              {
+                count++;
+                retval = octave_value (this);
+              }
+            else
+              gripe_failed_assignment ();
+          }
+          break;
 
-	case '{':
-	  {
-	    octave_value_list idxf = idx.front ();
+        case '{':
+          {
+            octave_value_list idxf = idx.front ();
 
-	    if (t_rhs.is_cs_list ())
-	      {
-		Cell tmp_cell = Cell (t_rhs.list_value ());
+            if (t_rhs.is_cs_list ())
+              {
+                Cell tmp_cell = Cell (t_rhs.list_value ());
 
                 // Inquire the proper shape of the RHS.
 
                 dim_vector didx = dims ().redim (idxf.length ());
                 for (octave_idx_type k = 0; k < idxf.length (); k++)
                   if (! idxf(k).is_magic_colon ()) didx(k) = idxf(k).numel ();
 
                 if (didx.numel () == tmp_cell.numel ())
                   tmp_cell = tmp_cell.reshape (didx);
 
 
-		octave_base_matrix<Cell>::assign (idxf, tmp_cell);
-	      }
-	    else if (idxf.all_scalars () || do_index_op (idxf, true).numel () == 1)
+                octave_base_matrix<Cell>::assign (idxf, tmp_cell);
+              }
+            else if (idxf.all_scalars () || do_index_op (idxf, true).numel () == 1)
               // Regularize a null matrix if stored into a cell.
               octave_base_matrix<Cell>::assign (idxf, Cell (t_rhs.storable_value ()));
             else if (! error_state)
               gripe_nonbraced_cs_list_assignment ();
 
-	    if (! error_state)
-	      {
-		count++;
-		retval = octave_value (this);
-	      }
-	    else
-	      gripe_failed_assignment ();
-	  }
-	  break;
+            if (! error_state)
+              {
+                count++;
+                retval = octave_value (this);
+              }
+            else
+              gripe_failed_assignment ();
+          }
+          break;
 
-	case '.':
-	  {
-	    std::string nm = type_name ();
-	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-	  }
-	  break;
+        case '.':
+          {
+            std::string nm = type_name ();
+            error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+          }
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
     }
 
   return retval;
 }
 
 bool 
 octave_cell::is_cellstr (void) const
 {
@@ -453,17 +453,17 @@ octave_cell::sort (octave_idx_type dim, 
   else
     error ("sort: only cell arrays of character strings may be sorted");
   
   return retval;
 }
 
 octave_value
 octave_cell::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
-		   sortmode mode) const
+                   sortmode mode) const
 {
   octave_value retval;
 
   if (is_cellstr ())
     {
       Array<std::string> tmp = cellstr_value ();
 
       tmp = tmp.sort (sidx, dim, mode);
@@ -555,58 +555,58 @@ octave_cell::all_strings (bool pad) cons
 
   std::queue<string_vector> strvec_queue;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       string_vector s = matrix(i).all_strings ();
 
       if (error_state)
-	return retval;
+        return retval;
 
       octave_idx_type s_len = s.length ();
 
       n_elts += s_len ? s_len : 1;
 
       octave_idx_type s_max_len = s.max_length ();
 
       if (s_max_len > max_len)
-	max_len = s_max_len;
+        max_len = s_max_len;
 
       strvec_queue.push (s);
     }
 
   retval = string_vector (n_elts);
 
   octave_idx_type k = 0;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       const string_vector s = strvec_queue.front ();
       strvec_queue.pop ();
 
       octave_idx_type s_len = s.length ();
 
       if (s_len)
-	{
-	  for (octave_idx_type j = 0; j < s_len; j++)
-	    {
-	      std::string t = s[j];
-	      int t_len = t.length ();
+        {
+          for (octave_idx_type j = 0; j < s_len; j++)
+            {
+              std::string t = s[j];
+              int t_len = t.length ();
 
-	      if (pad && max_len > t_len)
-		t += std::string (max_len - t_len, ' ');
+              if (pad && max_len > t_len)
+                t += std::string (max_len - t_len, ' ');
 
-	      retval[k++] = t;
-	    }
-	}
+              retval[k++] = t;
+            }
+        }
       else if (pad)
-	retval[k++] = std::string (max_len, ' ');
+        retval[k++] = std::string (max_len, ' ');
       else
-	retval[k++] = std::string ();
+        retval[k++] = std::string ();
     }
 
   return retval;
 }
 
 Array<std::string>
 octave_cell::cellstr_value (void) const
 {
@@ -643,52 +643,52 @@ octave_cell::print_raw (std::ostream& os
   int nd = matrix.ndims ();
 
   if (nd == 2)
     {
       octave_idx_type nr = rows ();
       octave_idx_type nc = columns ();
 
       if (nr > 0 && nc > 0)
-	{
-	  indent (os);
-	  os << "{";
-	  newline (os);
+        {
+          indent (os);
+          os << "{";
+          newline (os);
 
-	  increment_indent_level ();
+          increment_indent_level ();
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  octave_quit ();
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  octave_quit ();
 
-		  std::ostringstream buf;
-		  buf << "[" << i+1 << "," << j+1 << "]";
+                  std::ostringstream buf;
+                  buf << "[" << i+1 << "," << j+1 << "]";
 
-		  octave_value val = matrix(i,j);
+                  octave_value val = matrix(i,j);
 
-		  val.print_with_name (os, buf.str ());
-		}
-	    }
+                  val.print_with_name (os, buf.str ());
+                }
+            }
 
-	  decrement_indent_level ();
+          decrement_indent_level ();
 
-	  indent (os);
-	  os << "}";
-	  newline (os);
-	}
+          indent (os);
+          os << "}";
+          newline (os);
+        }
       else
-	{
+        {
           indent (os);
-	  os << "{}";
-	  if (Vprint_empty_dimensions)
-	    os << "(" << nr << "x" << nc << ")";
+          os << "{}";
+          if (Vprint_empty_dimensions)
+            os << "(" << nr << "x" << nc << ")";
           newline (os);
-	}
+        }
     }
   else
     {
       indent (os);
       dim_vector dv = matrix.dims ();
       os << "{" << dv.str () << " Cell Array}";
       newline (os);
     }
@@ -700,56 +700,56 @@ bool
 octave_cell::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       os << "# ndims: " << d.length () << "\n";
       
       for (int i = 0; i < d.length (); i++)
-	os << " " << d (i);
+        os << " " << d (i);
       os << "\n";
 
       Cell tmp = cell_value ();
       
       for (octave_idx_type i = 0; i < d.numel (); i++)
-	{
-	  octave_value o_val = tmp.elem (i);
+        {
+          octave_value o_val = tmp.elem (i);
 
-	  // Recurse to print sub-value.
-	  bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, false, 0);
-	      
-	  if (! b)
-	    return os;
-	}
+          // Recurse to print sub-value.
+          bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, false, 0);
+              
+          if (! b)
+            return os;
+        }
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
-	 << "# columns: " << columns () << "\n";
+         << "# columns: " << columns () << "\n";
 
       Cell tmp = cell_value ();
       
       for (octave_idx_type j = 0; j < tmp.cols (); j++)
-	{
-	  for (octave_idx_type i = 0; i < tmp.rows (); i++)
-	    {
-	      octave_value o_val = tmp.elem (i, j);
+        {
+          for (octave_idx_type i = 0; i < tmp.rows (); i++)
+            {
+              octave_value o_val = tmp.elem (i, j);
 
-	      // Recurse to print sub-value.
-	      bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, false, 0);
-	      
-	      if (! b)
-		return os;
-	    }
-	  
-	  os << "\n";
-	}
+              // Recurse to print sub-value.
+              bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, false, 0);
+              
+              if (! b)
+                return os;
+            }
+          
+          os << "\n";
+        }
     }
 
   return true;
 }
 
 bool 
 octave_cell::load_ascii (std::istream& is)
 {
@@ -763,124 +763,124 @@ octave_cell::load_ascii (std::istream& i
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
-	{
-	  int mdims = static_cast<int> (val);
+        {
+          int mdims = static_cast<int> (val);
 
-	  if (mdims >= 0)
-	    {
-	      dim_vector dv;
-	      dv.resize (mdims);
+          if (mdims >= 0)
+            {
+              dim_vector dv;
+              dv.resize (mdims);
 
-	      for (int i = 0; i < mdims; i++)
-		is >> dv(i);
+              for (int i = 0; i < mdims; i++)
+                is >> dv(i);
 
-	      Cell tmp(dv);
+              Cell tmp(dv);
 
-	      for (octave_idx_type i = 0; i < dv.numel (); i++)
-		{
-		  octave_value t2;
-		  bool dummy;
+              for (octave_idx_type i = 0; i < dv.numel (); i++)
+                {
+                  octave_value t2;
+                  bool dummy;
 
-		  // recurse to read cell elements
-		  std::string nm = read_ascii_data (is, std::string (), 
-						    dummy, t2, i);
+                  // recurse to read cell elements
+                  std::string nm = read_ascii_data (is, std::string (), 
+                                                    dummy, t2, i);
 
-		  if (nm == CELL_ELT_TAG)
-		    {
-		      if (is)
-			tmp.elem (i) = t2;
-		    }
-		  else
-		    {
-		      error ("load: cell array element had unexpected name");
-		      success = false;
-		      break;
-		    }
-		}
+                  if (nm == CELL_ELT_TAG)
+                    {
+                      if (is)
+                        tmp.elem (i) = t2;
+                    }
+                  else
+                    {
+                      error ("load: cell array element had unexpected name");
+                      success = false;
+                      break;
+                    }
+                }
 
-	      if (is)
-		matrix = tmp;
-	      else
-		{
-		  error ("load: failed to load matrix constant");
-		  success = false;
-		}
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of rows and columns");
-	      success = false;
-	    }
-	}
+              if (is)
+                matrix = tmp;
+              else
+                {
+                  error ("load: failed to load matrix constant");
+                  success = false;
+                }
+            }
+          else
+            {
+              error ("load: failed to extract number of rows and columns");
+              success = false;
+            }
+        }
       else if (kw == "rows")
-	{
-	  octave_idx_type nr = val;
-	  octave_idx_type nc = 0;
+        {
+          octave_idx_type nr = val;
+          octave_idx_type nc = 0;
 
-	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-	    {
-	      if (nr > 0 && nc > 0)
-		{
-		  Cell tmp (nr, nc);
+          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+            {
+              if (nr > 0 && nc > 0)
+                {
+                  Cell tmp (nr, nc);
 
-		  for (octave_idx_type j = 0; j < nc; j++)
-		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			{
-			  octave_value t2;
-			  bool dummy;
+                  for (octave_idx_type j = 0; j < nc; j++)
+                    {
+                      for (octave_idx_type i = 0; i < nr; i++)
+                        {
+                          octave_value t2;
+                          bool dummy;
 
-			  // recurse to read cell elements
-			  std::string nm = read_ascii_data (is, std::string (),
-							    dummy, t2, i);
+                          // recurse to read cell elements
+                          std::string nm = read_ascii_data (is, std::string (),
+                                                            dummy, t2, i);
 
-			  if (nm == CELL_ELT_TAG)
-			    {
-			      if (is)
-				tmp.elem (i, j) = t2;
-			    }
-			  else
-			    {
-			      error ("load: cell array element had unexpected name");
-			      success = false;
-			      goto cell_read_error;
-			    }
-			}
-		    }
-	      
-		cell_read_error:
+                          if (nm == CELL_ELT_TAG)
+                            {
+                              if (is)
+                                tmp.elem (i, j) = t2;
+                            }
+                          else
+                            {
+                              error ("load: cell array element had unexpected name");
+                              success = false;
+                              goto cell_read_error;
+                            }
+                        }
+                    }
+              
+                cell_read_error:
 
-		  if (is)
-		    matrix = tmp;
-		  else
-		    {
-		      error ("load: failed to load cell element");
-		      success = false;
-		    }
-		}
-	      else if (nr == 0 || nc == 0)
-		matrix = Cell (nr, nc);
-	      else
-		panic_impossible ();
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of rows and columns for cell array");
-	      success = false;
-	    }
-	}
+                  if (is)
+                    matrix = tmp;
+                  else
+                    {
+                      error ("load: failed to load cell element");
+                      success = false;
+                    }
+                }
+              else if (nr == 0 || nc == 0)
+                matrix = Cell (nr, nc);
+              else
+                panic_impossible ();
+            }
+          else
+            {
+              error ("load: failed to extract number of rows and columns for cell array");
+              success = false;
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
@@ -905,20 +905,20 @@ octave_cell::save_binary (std::ostream& 
   Cell tmp = cell_value ();
       
   for (octave_idx_type i = 0; i < d.numel (); i++)
     {
       octave_value o_val = tmp.elem (i);
 
       // Recurse to print sub-value.
       bool b = save_binary_data (os, o_val, CELL_ELT_TAG, "", 0, 
-				 save_as_floats);
-	      
+                                 save_as_floats);
+              
       if (! b)
-	return false;
+        return false;
     }
   
   return true;
 }
 
 bool 
 octave_cell::load_binary (std::istream& is, bool swap,
                           oct_mach_info::float_format fmt)
@@ -937,19 +937,19 @@ octave_cell::load_binary (std::istream& 
   mdims = -mdims;
   int32_t di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&di);
+        swap_bytes<4> (&di);
       dv(i) = di;
     }
   
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
   // might.
 
   if (mdims == 1)
@@ -966,29 +966,29 @@ octave_cell::load_binary (std::istream& 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_value t2;
       bool dummy;
       std::string doc;
 
       // recurse to read cell elements
       std::string nm = read_binary_data (is, swap, fmt, std::string (), 
-					 dummy, t2, doc);
+                                         dummy, t2, doc);
 
       if (nm == CELL_ELT_TAG)
-	{
-	  if (is)
-	    tmp.elem (i) = t2;
-	}
+        {
+          if (is)
+            tmp.elem (i) = t2;
+        }
       else
-	{
-	  error ("load: cell array element had unexpected name");
-	  success = false;
-	  break;
-	}
+        {
+          error ("load: cell array element had unexpected name");
+          success = false;
+          break;
+        }
     }
 
   if (is)
     matrix = tmp;
   else
     {
       error ("load: failed to load matrix constant");
       success = false;
@@ -1040,30 +1040,30 @@ octave_cell::save_hdf5 (hid_t loc_id, co
   OCTAVE_LOCAL_BUFFER (octave_idx_type, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (hsize_t i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
 #if HAVE_HDF5_18
   size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (size_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (data_hid);
       return false;
     }
 
   if (H5Dwrite (size_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		H5P_DEFAULT, hdims) < 0)
+                H5P_DEFAULT, hdims) < 0)
     {
       H5Dclose (size_hid);
       H5Sclose (space_hid);
       H5Gclose (data_hid);
       return false;
     }
 
   H5Dclose (size_hid);
@@ -1078,21 +1078,21 @@ octave_cell::save_hdf5 (hid_t loc_id, co
   for (octave_idx_type i = 0; i < nel; i++)
     {
       std::ostringstream buf;
       int digits = static_cast<int> (::floor (::log10 (static_cast<double> (nel)) + 1.0));
       buf << "_" << std::setw (digits) << std::setfill ('0') << i;
       std::string s = buf.str ();
 
       if (! add_hdf5_data (data_hid, tmp.elem (i), s.c_str (), "", false,
-			   save_as_floats))
-	{
-	  H5Gclose (data_hid);
-	  return false;
-	}
+                           save_as_floats))
+        {
+          H5Gclose (data_hid);
+          return false;
+        }
     }
 
   H5Gclose (data_hid);
 
   return true;
 }
 
 bool
@@ -1139,17 +1139,17 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 
   // Octave uses column-major, while HDF5 uses row-major ordering.
 
   dv.resize (hdims[0]);
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, hdims[0]);
   
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, tmp) < 0)
+               H5P_DEFAULT, tmp) < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_id);
       return false;
     }
 
   H5Dclose (data_hid);
   H5Gclose (group_id);
@@ -1173,23 +1173,23 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   for (octave_idx_type i = 0; i < dv.numel (); i++)
     {
 
       if (current_item >= static_cast<int> (num_obj))
-	retval2 = -1;
+        retval2 = -1;
       else
-	retval2 = H5Giterate (loc_id, name, &current_item,
-			      hdf5_read_next_data, &dsub);
+        retval2 = H5Giterate (loc_id, name, &current_item,
+                              hdf5_read_next_data, &dsub);
       
       if (retval2 <= 0)
-	break;
+        break;
 
       octave_value ov = dsub.tc;
       m.elem (i) = ov;
 
     }
 
   if (retval2 >= 0)
     {
@@ -1244,28 +1244,28 @@ rows and columns, respectively.\n\
       break;
 
     case 1:
       get_dimensions (args(0), "cell", dims);
       break;
 
     default:
       {
-	dims.resize (nargin);
+        dims.resize (nargin);
 
-	for (int i = 0; i < nargin; i++)
-	  {
-	    dims(i) = args(i).is_empty () ? 0 : args(i).nint_value ();
+        for (int i = 0; i < nargin; i++)
+          {
+            dims(i) = args(i).is_empty () ? 0 : args(i).nint_value ();
 
-	    if (error_state)
-	      {
-		error ("cell: expecting scalar arguments");
-		break;
-	      }
-	  }
+            if (error_state)
+              {
+                error ("cell: expecting scalar arguments");
+                break;
+              }
+          }
       }
       break;
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
@@ -1309,28 +1309,28 @@ array @var{string}.\n\
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_value_list tmp = Fiscellstr (args, 1);
 
       if (tmp(0).is_true ())
-	retval = args(0);
+        retval = args(0);
       else
-	{
-	  string_vector s = args(0).all_strings ();
+        {
+          string_vector s = args(0).all_strings ();
 
-	  if (! error_state)
-	    retval = (s.is_empty ()
+          if (! error_state)
+            retval = (s.is_empty ()
                       ? Cell (octave_value (std::string ()))
                       : Cell (s, true));
-	  else
-	    error ("cellstr: expecting argument to be a 2-d character array");
-	}
+          else
+            error ("cellstr: expecting argument to be a 2-d character array");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (struct2cell, args, ,
@@ -1370,59 +1370,59 @@ cell array will have a dimension vector 
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       Octave_map m = args(0).map_value ();
 
       if (! error_state)
-	{
-	  dim_vector m_dv = m.dims ();
+        {
+          dim_vector m_dv = m.dims ();
 
-	  string_vector keys = m.keys ();
+          string_vector keys = m.keys ();
 
-	  octave_idx_type num_fields = keys.length ();
+          octave_idx_type num_fields = keys.length ();
 
-	  // The resulting dim_vector should have dimensions:
-	  // [numel(fields) size(struct)]
-	  // except if the struct is a column vector.
+          // The resulting dim_vector should have dimensions:
+          // [numel(fields) size(struct)]
+          // except if the struct is a column vector.
 
-	  dim_vector result_dv;
-	  if (m_dv (m_dv.length () - 1) == 1)
-	      result_dv.resize (m_dv.length ());
-	  else
-	      result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
+          dim_vector result_dv;
+          if (m_dv (m_dv.length () - 1) == 1)
+              result_dv.resize (m_dv.length ());
+          else
+              result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
 
-	  result_dv(0) = num_fields;
+          result_dv(0) = num_fields;
 
-	  for (int i = 1; i < result_dv.length (); i++)
-	    result_dv(i) = m_dv(i-1);
+          for (int i = 1; i < result_dv.length (); i++)
+            result_dv(i) = m_dv(i-1);
 
-	  Cell c (result_dv);
+          Cell c (result_dv);
 
-	  octave_idx_type n_elts = m.numel ();
+          octave_idx_type n_elts = m.numel ();
 
-	  for (octave_idx_type j = 0; j < num_fields; j++)
-	    {
-	      octave_idx_type k = j;
+          for (octave_idx_type j = 0; j < num_fields; j++)
+            {
+              octave_idx_type k = j;
 
-	      const Cell vals = m.contents (keys(j));
+              const Cell vals = m.contents (keys(j));
 
-	      for (octave_idx_type i = 0; i < n_elts; i++)
-		{
-		  c(k) = vals(i);
-		  k += num_fields;
-		}
-	    }
+              for (octave_idx_type i = 0; i < n_elts; i++)
+                {
+                  c(k) = vals(i);
+                  k += num_fields;
+                }
+            }
 
-	  retval = c;
-	}
+          retval = c;
+        }
       else
-	error ("struct2cell: expecting argument to be a cell array");
+        error ("struct2cell: expecting argument to be a cell array");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -53,17 +53,17 @@ octave_char_matrix::index_vector (void) 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "character matrix", "real scalar");
+                                 "character matrix", "real scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("character matrix", "real scalar");
 
   return retval;
 }
@@ -71,17 +71,17 @@ octave_char_matrix::double_value (bool) 
 float
 octave_char_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "character matrix", "real scalar");
+                                 "character matrix", "real scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("character matrix", "real scalar");
 
   return retval;
 }
@@ -91,17 +91,17 @@ octave_char_matrix::complex_value (bool)
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "character matrix", "complex scalar");
+                                 "character matrix", "complex scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("character matrix", "complex scalar");
 
   return retval;
 }
@@ -111,32 +111,32 @@ octave_char_matrix::float_complex_value 
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "character matrix", "complex scalar");
+                                 "character matrix", "complex scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("character matrix", "complex scalar");
 
   return retval;
 }
 
 void
 octave_char_matrix::print_raw (std::ostream& os,
-			       bool pr_as_read_syntax) const
+                               bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 mxArray *
 octave_char_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxCHAR_CLASS, dims (), mxREAL);
 
   mxChar *pr = static_cast<mxChar *> (retval->get_data ());
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -62,40 +62,40 @@ const std::string octave_class::t_name (
 void
 octave_class::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
     (octave_class::t_name, "<unknown>", octave_value (new octave_class ()));
 }
 
 octave_class::octave_class (const Octave_map& m, const std::string& id, 
-			    const octave_value_list& parents)
+                            const octave_value_list& parents)
   : octave_base_value (), map (m), c_name (id), obsolete_copies (0)
 {
   octave_idx_type n = parents.length ();
 
   for (octave_idx_type idx = 0; idx < n; idx++)
     {
       octave_value parent = parents(idx);
 
       if (! parent.is_object ())
-	error ("parents must be objects");
+        error ("parents must be objects");
       else
-	{
-	  std::string cnm = parent.class_name ();
+        {
+          std::string cnm = parent.class_name ();
 
-	  if (find_parent_class (cnm))
-	    error ("duplicate class in parent tree");
-	  else
-	    {
-	      parent_list.push_back (cnm);
+          if (find_parent_class (cnm))
+            error ("duplicate class in parent tree");
+          else
+            {
+              parent_list.push_back (cnm);
 
-	      map.assign (cnm, parent);
-	    }
-	}
+              map.assign (cnm, parent);
+            }
+        }
     }
 
   if (! error_state)
     symbol_table::add_to_parent_map (id, parent_list);
 }
 
 octave_base_value *
 octave_class::unique_clone (void)
@@ -156,85 +156,85 @@ gripe_failed_assignment (void)
 static inline octave_value_list
 sanitize (const octave_value_list& ovl)
 {
   octave_value_list retval = ovl;
 
   for (octave_idx_type i = 0; i < ovl.length (); i++)
     {
       if (retval(i).is_magic_colon ())
-	retval(i) = ":";
+        retval(i) = ":";
     }
 
   return retval;
 }
 
 static inline octave_value
 make_idx_args (const std::string& type,
-	       const std::list<octave_value_list>& idx,
-	       const std::string& who)
+               const std::list<octave_value_list>& idx,
+               const std::string& who)
 {
   octave_value retval;
 
   size_t len = type.length ();
 
   if (len == idx.size ())
     {
       Cell type_field (1, len);
       Cell subs_field (1, len);
 
       std::list<octave_value_list>::const_iterator p = idx.begin ();
 
       for (size_t i = 0; i < len; i++)
-	{
-	  char t = type[i];
+        {
+          char t = type[i];
 
-	  switch (t)
-	    {
-	    case '(':
-	      type_field(i) = "()";
-	      subs_field(i) = Cell (sanitize (*p++));
-	      break;
+          switch (t)
+            {
+            case '(':
+              type_field(i) = "()";
+              subs_field(i) = Cell (sanitize (*p++));
+              break;
 
-	    case '{':
-	      type_field(i) = "{}";
-	      subs_field(i) = Cell (sanitize (*p++));
-	      break;
+            case '{':
+              type_field(i) = "{}";
+              subs_field(i) = Cell (sanitize (*p++));
+              break;
 
-	    case '.':
-	      {
-		type_field(i) = ".";
+            case '.':
+              {
+                type_field(i) = ".";
 
-		octave_value_list vlist = *p++;
+                octave_value_list vlist = *p++;
 
-		if (vlist.length () == 1)
-		  {
-		    octave_value val = vlist(0);
+                if (vlist.length () == 1)
+                  {
+                    octave_value val = vlist(0);
 
-		    if (val.is_string ())
-		      subs_field(i) = val;
-		    else
-		      {
-			error ("expecting character string argument for `.' index");
-			return retval;
-		      }
-		  }
-		else
-		  {
-		    error ("expecting single argument for `.' index");
-		    return retval;
-		  }
-	      }
-	      break;
+                    if (val.is_string ())
+                      subs_field(i) = val;
+                    else
+                      {
+                        error ("expecting character string argument for `.' index");
+                        return retval;
+                      }
+                  }
+                else
+                  {
+                    error ("expecting single argument for `.' index");
+                    return retval;
+                  }
+              }
+              break;
 
-	    default:
-	      panic_impossible ();
-	      break;
-	    }
-	}
+            default:
+              panic_impossible ();
+              break;
+            }
+        }
 
       Octave_map m;
 
       m.assign ("type", type_field);
       m.assign ("subs", subs_field);
 
       retval = m;
     }
@@ -265,19 +265,19 @@ octave_class::dotref (const octave_value
 
   std::string nm = idx(0).string_value ();
 
   if (! error_state)
     {
       Octave_map::const_iterator p = my_map.seek (nm);
 
       if (p != my_map.end ())
-	retval = my_map.contents (p);
+        retval = my_map.contents (p);
       else
-	error ("class has no member `%s'", nm.c_str ());
+        error ("class has no member `%s'", nm.c_str ());
     }
   else
     gripe_invalid_index ();
 
   return retval;
 }
 
 static bool
@@ -348,99 +348,99 @@ octave_class::numel (const octave_value_
   else
     retval = octave_base_value::numel (idx);
 
   return retval;
 }
 
 octave_value_list
 octave_class::subsref (const std::string& type,
-		       const std::list<octave_value_list>& idx,
-		       int nargout)
+                       const std::list<octave_value_list>& idx,
+                       int nargout)
 {
   octave_value_list retval;
 
   if (in_class_method () || called_from_builtin ())
     {
       // FIXME -- this block of code is the same as the body of
       // octave_struct::subsref.  Maybe it could be shared instead of
       // duplicated.
 
       int skip = 1;
 
       switch (type[0])
-	{
-	case '(':
-	  {
-	    if (type.length () > 1 && type[1] == '.')
-	      {
-		std::list<octave_value_list>::const_iterator p = idx.begin ();
-		octave_value_list key_idx = *++p;
+        {
+        case '(':
+          {
+            if (type.length () > 1 && type[1] == '.')
+              {
+                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                octave_value_list key_idx = *++p;
 
-		Cell tmp = dotref (key_idx);
+                Cell tmp = dotref (key_idx);
 
-		if (! error_state)
-		  {
-		    Cell t = tmp.index (idx.front ());
+                if (! error_state)
+                  {
+                    Cell t = tmp.index (idx.front ());
 
-		    retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+                    retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
 
-		    // We handled two index elements, so tell
-		    // next_subsref to skip both of them.
+                    // We handled two index elements, so tell
+                    // next_subsref to skip both of them.
 
-		    skip++;
-		  }
-	      }
-	    else
-	      retval(0) = octave_value (map.index (idx.front ()),
-					class_name ());
-	  }
-	  break;
+                    skip++;
+                  }
+              }
+            else
+              retval(0) = octave_value (map.index (idx.front ()),
+                                        class_name ());
+          }
+          break;
 
-	case '.':
-	  {
-	    if (map.numel() > 0)
-	      {
-		Cell t = dotref (idx.front ());
+        case '.':
+          {
+            if (map.numel() > 0)
+              {
+                Cell t = dotref (idx.front ());
 
-		retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
-	      }
-	  }
-	  break;
+                retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+              }
+          }
+          break;
 
-	case '{':
-	  gripe_invalid_index_type (type_name (), type[0]);
-	  break;
+        case '{':
+          gripe_invalid_index_type (type_name (), type[0]);
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
 
       // FIXME -- perhaps there should be an
       // octave_value_list::next_subsref member function?  See also
       // octave_user_function::subsref.
 
       if (idx.size () > 1)
-	retval = retval(0).next_subsref (nargout, type, idx, skip);
+        retval = retval(0).next_subsref (nargout, type, idx, skip);
     }
   else
     {
       octave_value meth = symbol_table::find_method ("subsref", class_name ());
 
       if (meth.is_defined ())
-	{
-	  octave_value_list args;
+        {
+          octave_value_list args;
 
-	  args(1) = make_idx_args (type, idx, "subsref");
+          args(1) = make_idx_args (type, idx, "subsref");
 
-	  if (error_state)
-	    return octave_value_list ();
+          if (error_state)
+            return octave_value_list ();
 
-	  count++;
-	  args(0) = octave_value (this);
+          count++;
+          args(0) = octave_value (this);
 
           // FIXME: for Matlab compatibility, let us attempt to set up a proper
           // value for nargout at least in the simple case where the
           // cs-list-type expression - i.e., {} or ().x, is the leading one.
           // Note that Octave does not actually need this, since it will
           // be able to properly react to varargout a posteriori.
           bool maybe_cs_list_query = (type[0] == '.' || type[0] == '{'
                                       || (type.length () > 1 && type[0] == '('
@@ -458,79 +458,79 @@ octave_class::subsref (const std::string
 
           retval = feval (meth.function_value (), args, true_nargout);
 
           // Since we're handling subsref, return the list in the first value
           // if it has more than one element, to be able to pass through
           // rvalue1 calls. 
           if (retval.length () > 1)
             retval = octave_value (retval, true);
-	}
+        }
       else
-	{
-	  if (type.length () == 1 && type[0] == '(')
-	    retval(0) = octave_value (map.index (idx.front ()), class_name ());
-	  else
-	    gripe_invalid_index ();
-	}
+        {
+          if (type.length () == 1 && type[0] == '(')
+            retval(0) = octave_value (map.index (idx.front ()), class_name ());
+          else
+            gripe_invalid_index ();
+        }
     }
 
   return retval;
 }
 
 octave_value
 octave_class::numeric_conv (const Cell& val, const std::string& type)
 {
   octave_value retval;
 
   if (val.length () == 1)
     {
       retval = val(0);
 
       if (type.length () > 0 && type[0] == '.' && ! retval.is_map ())
-	retval = Octave_map ();
+        retval = Octave_map ();
     }
   else
     gripe_invalid_index_for_assignment ();
 
   return retval;
 }
 
 octave_value
 octave_class::subsasgn (const std::string& type,
-			const std::list<octave_value_list>& idx,
-			const octave_value& rhs)
+                        const std::list<octave_value_list>& idx,
+                        const octave_value& rhs)
 {
   octave_value retval;
 
   if (! (in_class_method () || called_from_builtin ()))
     {
       octave_value meth = symbol_table::find_method ("subsasgn", class_name ());
 
       if (meth.is_defined ())
-	{
-	  octave_value_list args;
+        {
+          octave_value_list args;
 
           if (rhs.is_cs_list ())
             {
               octave_value_list lrhs = rhs.list_value ();
               args.resize (2 + lrhs.length ());
               for (octave_idx_type i = 0; i < lrhs.length (); i++)
                 args(2+i) = lrhs(i);
             }
           else
             args(2) = rhs;
 
-	  args(1) = make_idx_args (type, idx, "subsasgn");
+          args(1) = make_idx_args (type, idx, "subsasgn");
 
-	  if (error_state)
-	    return octave_value_list ();
+          if (error_state)
+            return octave_value_list ();
 
-	  count++;
-	  args(0) = octave_value (this);
+          count++;
+          args(0) = octave_value (this);
 
           // Now comes the magic. Count copies with me:
           // 1. myself (obsolete)
           // 2. the copy inside args (obsolete)
           // 3. the copy in method's symbol table (working)
           // ... possibly more (not obsolete).
           //
           // So we mark 2 copies as obsolete and hold our fingers crossed.
@@ -549,100 +549,100 @@ octave_class::subsasgn (const std::strin
               frame.protect_var (obsolete_copies);
               obsolete_copies = 2;
 
               tmp = feval (meth.function_value (), args);
             }
           else
             tmp = feval (meth.function_value (), args);
 
-	  // FIXME -- should the subsasgn method be able to return
-	  // more than one value?
+          // FIXME -- should the subsasgn method be able to return
+          // more than one value?
 
-	  if (tmp.length () > 1)
-	    error ("expecting single return value from @%s/subsasgn",
-		   class_name().c_str ());
+          if (tmp.length () > 1)
+            error ("expecting single return value from @%s/subsasgn",
+                   class_name().c_str ());
 
-	  else
-	    retval = tmp(0);
+          else
+            retval = tmp(0);
 
-	  return retval;
-	}
+          return retval;
+        }
     }
 
   // FIXME -- this block of code is the same as the body of
   // octave_struct::subsasgn.  Maybe it could be shared instead of
   // duplicated.
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
   if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
     {
       switch (type[0])
-	{
-	case '(':
-	  {
-	    if (type.length () > 1 && type[1] == '.')
-	      {
-		std::list<octave_value_list>::const_iterator p = idx.begin ();
-		octave_value_list t_idx = *p;
+        {
+        case '(':
+          {
+            if (type.length () > 1 && type[1] == '.')
+              {
+                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                octave_value_list t_idx = *p;
 
-		octave_value_list key_idx = *++p;
+                octave_value_list key_idx = *++p;
 
-		assert (key_idx.length () == 1);
+                assert (key_idx.length () == 1);
 
-		std::string key = key_idx(0).string_value ();
+                std::string key = key_idx(0).string_value ();
 
-		if (! error_state)
-		  {
-		    octave_value u;
+                if (! error_state)
+                  {
+                    octave_value u;
 
-		    if (! map.contains (key))
-		      u = octave_value::empty_conv (type.substr (2), rhs);
-		    else
-		      {
-			Cell map_val = map.contents (key);
+                    if (! map.contains (key))
+                      u = octave_value::empty_conv (type.substr (2), rhs);
+                    else
+                      {
+                        Cell map_val = map.contents (key);
 
-			Cell map_elt = map_val.index (idx.front (), true);
+                        Cell map_elt = map_val.index (idx.front (), true);
 
-			u = numeric_conv (map_elt, type.substr (2));
-		      }
+                        u = numeric_conv (map_elt, type.substr (2));
+                      }
 
-		    if (! error_state)
-		      {
-			std::list<octave_value_list> next_idx (idx);
+                    if (! error_state)
+                      {
+                        std::list<octave_value_list> next_idx (idx);
 
-			// We handled two index elements, so subsasgn to
-			// needs to skip both of them.
+                        // We handled two index elements, so subsasgn to
+                        // needs to skip both of them.
 
-			next_idx.erase (next_idx.begin ());
-			next_idx.erase (next_idx.begin ());
+                        next_idx.erase (next_idx.begin ());
+                        next_idx.erase (next_idx.begin ());
 
-			u.make_unique ();
+                        u.make_unique ();
 
-			t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
-		      }
-		  }
-		else
-		  gripe_invalid_index_for_assignment ();
-	      }
-	    else
-	      gripe_invalid_index_for_assignment ();
-	  }
-	  break;
+                        t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
+                      }
+                  }
+                else
+                  gripe_invalid_index_for_assignment ();
+              }
+            else
+              gripe_invalid_index_for_assignment ();
+          }
+          break;
 
-	case '.':
-	  {
-	    octave_value_list key_idx = idx.front ();
+        case '.':
+          {
+            octave_value_list key_idx = idx.front ();
 
-	    assert (key_idx.length () == 1);
+            assert (key_idx.length () == 1);
 
-	    std::string key = key_idx(0).string_value ();
+            std::string key = key_idx(0).string_value ();
 
             std::list<octave_value_list> next_idx (idx);
 
             next_idx.erase (next_idx.begin ());
 
             std::string next_type = type.substr (1);
 
             Cell tmpc (1, 1);
@@ -670,144 +670,144 @@ octave_class::subsasgn (const std::strin
                       tmp.make_unique (1);
 
                     if (! error_state)
                       t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
                   }
                 else
                   gripe_indexed_cs_list ();
               }
-	  }
-	  break;
+          }
+          break;
 
-	case '{':
-	  gripe_invalid_index_type (type_name (), type[0]);
-	  break;
+        case '{':
+          gripe_invalid_index_type (type_name (), type[0]);
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
     }
 
   if (! error_state)
     {
       switch (type[0])
-	{
-	case '(':
-	  {
-	    if (n > 1 && type[1] == '.')
-	      {
-		std::list<octave_value_list>::const_iterator p = idx.begin ();
-		octave_value_list key_idx = *++p;
+        {
+        case '(':
+          {
+            if (n > 1 && type[1] == '.')
+              {
+                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                octave_value_list key_idx = *++p;
 
-		assert (key_idx.length () == 1);
+                assert (key_idx.length () == 1);
 
-		std::string key = key_idx(0).string_value ();
+                std::string key = key_idx(0).string_value ();
 
-		if (! error_state)
-		  {
-		    map.assign (idx.front (), key, t_rhs);
+                if (! error_state)
+                  {
+                    map.assign (idx.front (), key, t_rhs);
 
-		    if (! error_state)
-		      {
-			count++;
-			retval = octave_value (this);
-		      }
-		    else
-		      gripe_failed_assignment ();
-		  }
-		else
-		  gripe_failed_assignment ();
-	      }
-	    else
-	      {
-		if (t_rhs.is_object () || t_rhs.is_map ())
-		  {
-		    Octave_map rhs_map = t_rhs.map_value ();
+                    if (! error_state)
+                      {
+                        count++;
+                        retval = octave_value (this);
+                      }
+                    else
+                      gripe_failed_assignment ();
+                  }
+                else
+                  gripe_failed_assignment ();
+              }
+            else
+              {
+                if (t_rhs.is_object () || t_rhs.is_map ())
+                  {
+                    Octave_map rhs_map = t_rhs.map_value ();
 
-		    if (! error_state)
-		      {
-			map.assign (idx.front (), rhs_map);
+                    if (! error_state)
+                      {
+                        map.assign (idx.front (), rhs_map);
 
-			if (! error_state)
-			  {
-			    count++;
-			    retval = octave_value (this);
-			  }
-			else
-			  gripe_failed_assignment ();
-		      }
-		    else
-		      error ("invalid class assignment");
-		  }
-		else
-		  {
-		    if (t_rhs.is_empty ())
-		      {
-			map.maybe_delete_elements (idx.front());
+                        if (! error_state)
+                          {
+                            count++;
+                            retval = octave_value (this);
+                          }
+                        else
+                          gripe_failed_assignment ();
+                      }
+                    else
+                      error ("invalid class assignment");
+                  }
+                else
+                  {
+                    if (t_rhs.is_empty ())
+                      {
+                        map.maybe_delete_elements (idx.front());
 
-			if (! error_state)
-			  {
-			    count++;
-			    retval = octave_value (this);
-			  }
-			else
-			  gripe_failed_assignment ();
-		      }
-		    else
-		      error ("invalid class assignment");
-		  }
-	      }
-	  }
-	  break;
+                        if (! error_state)
+                          {
+                            count++;
+                            retval = octave_value (this);
+                          }
+                        else
+                          gripe_failed_assignment ();
+                      }
+                    else
+                      error ("invalid class assignment");
+                  }
+              }
+          }
+          break;
 
-	case '.':
-	  {
-	    // Find the class in which this method resides before 
-	    // attempting to access the requested field.
+        case '.':
+          {
+            // Find the class in which this method resides before 
+            // attempting to access the requested field.
 
-	    std::string method_class = get_current_method_class ();
+            std::string method_class = get_current_method_class ();
 
-	    octave_base_value *obvp = unique_parent_class (method_class);
+            octave_base_value *obvp = unique_parent_class (method_class);
 
-	    if (obvp)
-	      {
-		octave_value_list key_idx = idx.front ();
+            if (obvp)
+              {
+                octave_value_list key_idx = idx.front ();
 
-		assert (key_idx.length () == 1);
+                assert (key_idx.length () == 1);
 
-		std::string key = key_idx(0).string_value ();
+                std::string key = key_idx(0).string_value ();
 
-		if (! error_state)
-		  {
-		    obvp->assign (key, t_rhs);
+                if (! error_state)
+                  {
+                    obvp->assign (key, t_rhs);
 
-		    if (! error_state)
-		      {
-			count++;
-			retval = octave_value (this);
-		      }
-		    else
-		      gripe_failed_assignment ();
-		  }
-		else
-		  gripe_failed_assignment ();
-	      }
-	    else
-	      error ("malformed class");
-	  }
-	  break;
+                    if (! error_state)
+                      {
+                        count++;
+                        retval = octave_value (this);
+                      }
+                    else
+                      gripe_failed_assignment ();
+                  }
+                else
+                  gripe_failed_assignment ();
+              }
+            else
+              error ("malformed class");
+          }
+          break;
 
-	case '{':
-	  gripe_invalid_index_type (type_name (), type[0]);
-	  break;
+        case '{':
+          gripe_invalid_index_type (type_name (), type[0]);
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
     }
   else
     gripe_failed_assignment ();
 
   return retval;
 }
 
 idx_vector
@@ -820,31 +820,31 @@ octave_class::index_vector (void) const
   if (meth.is_defined ())
     {
       octave_value_list args;
       args(0) = octave_value (new octave_class (map, c_name));
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
       if (!error_state && tmp.length () >= 1)
-	{
-	  if (tmp(0).is_object())
-	    error ("subsindex function must return a valid index vector");
-	  else
-	    // Index vector returned by subsindex is zero based 
-	    // (why this inconsistency Mathworks?), and so we must
-	    // add one to the value returned as the index_vector method
-	    // expects it to be one based.
-	    retval = do_binary_op (octave_value::op_add, tmp (0), 
-				   octave_value (1.0)).index_vector ();
-	}
+        {
+          if (tmp(0).is_object())
+            error ("subsindex function must return a valid index vector");
+          else
+            // Index vector returned by subsindex is zero based 
+            // (why this inconsistency Mathworks?), and so we must
+            // add one to the value returned as the index_vector method
+            // expects it to be one based.
+            retval = do_binary_op (octave_value::op_add, tmp (0), 
+                                   octave_value (1.0)).index_vector ();
+        }
     }
   else
     error ("no subsindex method defined for class %s",
-	   class_name().c_str ());
+           class_name().c_str ());
 
   return retval;
 }
 
 size_t
 octave_class::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
@@ -876,70 +876,70 @@ octave_class::find_parent_class (const s
 {
   octave_base_value* retval = 0;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (std::list<std::string>::iterator pit = parent_list.begin ();
-	   pit != parent_list.end ();
-	   pit++)
-	{
-	  Octave_map::const_iterator smap = map.seek (*pit);
+           pit != parent_list.end ();
+           pit++)
+        {
+          Octave_map::const_iterator smap = map.seek (*pit);
 
-	  const Cell& tmp = smap->second;
+          const Cell& tmp = smap->second;
 
-	  octave_value vtmp = tmp(0);
+          octave_value vtmp = tmp(0);
 
-	  octave_base_value *obvp = vtmp.internal_rep ();
+          octave_base_value *obvp = vtmp.internal_rep ();
 
-	  retval = obvp->find_parent_class (parent_class_name);
+          retval = obvp->find_parent_class (parent_class_name);
 
-	  if (retval)
-	    break;
-	}
+          if (retval)
+            break;
+        }
     }
 
   return retval;
 }
 
 octave_base_value *
 octave_class::unique_parent_class (const std::string& parent_class_name)
 {
   octave_base_value* retval = 0;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (std::list<std::string>::iterator pit = parent_list.begin ();
-	   pit != parent_list.end ();
-	   pit++)
-	{
-	  Octave_map::iterator smap = map.seek (*pit);
+           pit != parent_list.end ();
+           pit++)
+        {
+          Octave_map::iterator smap = map.seek (*pit);
 
-	  Cell& tmp = smap->second;
+          Cell& tmp = smap->second;
 
-	  octave_value& vtmp = tmp(0);
+          octave_value& vtmp = tmp(0);
 
-	  octave_base_value *obvp = vtmp.internal_rep ();
+          octave_base_value *obvp = vtmp.internal_rep ();
 
           // Use find_parent_class first to avoid uniquifying if not necessary.
-	  retval = obvp->find_parent_class (parent_class_name);
+          retval = obvp->find_parent_class (parent_class_name);
 
-	  if (retval)
+          if (retval)
             {
               vtmp.make_unique ();
               obvp = vtmp.internal_rep ();
               retval = obvp->unique_parent_class (parent_class_name);
 
               break;
             }
-	}
+        }
     }
 
   return retval;
 }
 
 void
 octave_class::print (std::ostream& os, bool) const
 {
@@ -968,17 +968,17 @@ octave_class::print_name_tag (std::ostre
   newline (os);
   newline (os);
 
   return retval;
 }
 
 void
 octave_class::print_with_name (std::ostream& os, const std::string& name, 
-			       bool)
+                               bool)
 {
   octave_value fcn = symbol_table::find_method ("display", class_name ());
 
   if (fcn.is_defined ())
     {
       octave_value_list args;
 
       count++;
@@ -1013,26 +1013,26 @@ octave_class::reconstruct_exemplar (void
 
   if (it != octave_class::exemplar_map.end ())
     retval = true;
   else
     {
       octave_value ctor = symbol_table::find_method (c_name, c_name);
 
       if (ctor.is_defined ())
-	{
-	  octave_value_list result = feval (ctor, 1);
+        {
+          octave_value_list result = feval (ctor, 1);
 
-	  if (result.length () == 1)
-	    retval = true;
-	  else
-	    warning ("call to constructor for class %s failed", c_name.c_str ());
-	}
+          if (result.length () == 1)
+            retval = true;
+          else
+            warning ("call to constructor for class %s failed", c_name.c_str ());
+        }
       else
-	warning ("no constructor for class %s", c_name.c_str ());
+        warning ("no constructor for class %s", c_name.c_str ());
     }
 
   return retval;
 }
 
 void
 octave_class::clear_exemplar_map (void)
 {
@@ -1053,84 +1053,84 @@ octave_class::reconstruct_parents (void)
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
   for (Octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string  key = map.key (p);
       Cell         val = map.contents (p);
       if ( val(0).is_object() )
-	{
-	  dbgstr = "blork";
-	  if( key == val(0).class_name() )
-	    {
-	      might_have_inheritance = true;
-	      dbgstr = "cork";
-	      break;
-	    }
-	}
+        {
+          dbgstr = "blork";
+          if( key == val(0).class_name() )
+            {
+              might_have_inheritance = true;
+              dbgstr = "cork";
+              break;
+            }
+        }
     }
   
   if (might_have_inheritance)
     {
       octave_class::exemplar_const_iterator it
-	= octave_class::exemplar_map.find (c_name);
+        = octave_class::exemplar_map.find (c_name);
 
       if (it == octave_class::exemplar_map.end ())
-	retval = false;
+        retval = false;
       else
-	{
-	  octave_class::exemplar_info exmplr = it->second;
-	  parent_list = exmplr.parents ();
-	  for (std::list<std::string>::iterator pit = parent_list.begin ();
-	       pit != parent_list.end ();
-	       pit++)
-	    {
-	      dbgstr = *pit;
-	      bool dbgbool = map.contains (*pit);
-	      if (!dbgbool)
-		{
-		  retval = false;
-		  break;
-		}
-	    }
-	}
+        {
+          octave_class::exemplar_info exmplr = it->second;
+          parent_list = exmplr.parents ();
+          for (std::list<std::string>::iterator pit = parent_list.begin ();
+               pit != parent_list.end ();
+               pit++)
+            {
+              dbgstr = *pit;
+              bool dbgbool = map.contains (*pit);
+              if (!dbgbool)
+                {
+                  retval = false;
+                  break;
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 bool
 octave_class::save_ascii (std::ostream& os)
 {
   os << "# classname: " << class_name () << "\n";
   Octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
       if (! error_state)
-	m = tmp(0).map_value ();
+        m = tmp(0).map_value ();
       else
-	return false;
+        return false;
     }
   else
     m = map_value ();
 
   os << "# length: " << m.nfields () << "\n";
 
   Octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_ascii_data (os, val, m.key (i), false, 0);
       
       if (! b)
-	return os;
+        return os;
 
       i++;
     }
 
   return true;
 }
 
 bool 
@@ -1138,87 +1138,87 @@ octave_class::load_ascii (std::istream& 
 {
   octave_idx_type len = 0;
   std::string classname;
   bool success = true;
 
   if (extract_keyword (is, "classname", classname) && classname != "")
     {
       if (extract_keyword (is, "length", len) && len >= 0)
-	{
-	  if (len > 0)
-	    {
-	      Octave_map m (map);
+        {
+          if (len > 0)
+            {
+              Octave_map m (map);
 
-	      for (octave_idx_type j = 0; j < len; j++)
-		{
-		  octave_value t2;
-		  bool dummy;
+              for (octave_idx_type j = 0; j < len; j++)
+                {
+                  octave_value t2;
+                  bool dummy;
 
-		  // recurse to read cell elements
-		  std::string nm
-		    = read_ascii_data (is, std::string (), dummy, t2, j);
+                  // recurse to read cell elements
+                  std::string nm
+                    = read_ascii_data (is, std::string (), dummy, t2, j);
 
-		  if (! is)
-		    break;
+                  if (! is)
+                    break;
 
-		  Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
+                  Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
 
-		  if (error_state)
-		    {
-		      error ("load: internal error loading class elements");
-		      return false;
-		    }
+                  if (error_state)
+                    {
+                      error ("load: internal error loading class elements");
+                      return false;
+                    }
 
-		  m.assign (nm, tcell);
-		}
+                  m.assign (nm, tcell);
+                }
 
-	      if (is) 
-		{
-		  c_name = classname;
-		  reconstruct_exemplar ();
+              if (is) 
+                {
+                  c_name = classname;
+                  reconstruct_exemplar ();
 
-		  map = m;
-		  
-		  if (! reconstruct_parents ())
-		    warning ("load: unable to reconstruct object inheritance");
-		  else
-		    {
-		      if (load_path::find_method (classname, "loadobj")
-			  != std::string ())
-			{
-			  octave_value in = new octave_class (*this);
-			  octave_value_list tmp = feval ("loadobj", in, 1);
+                  map = m;
+                  
+                  if (! reconstruct_parents ())
+                    warning ("load: unable to reconstruct object inheritance");
+                  else
+                    {
+                      if (load_path::find_method (classname, "loadobj")
+                          != std::string ())
+                        {
+                          octave_value in = new octave_class (*this);
+                          octave_value_list tmp = feval ("loadobj", in, 1);
 
-			  if (! error_state)
-			    map = tmp(0).map_value ();
-			  else
-			    success = false;
-			}
-		    }
-		}
-	      else
-		{
-		  error ("load: failed to load class");
-		  success = false;
-		}
-	    }
-	  else if (len == 0 )
-	    {
-	      map = Octave_map (dim_vector (1, 1));
-	      c_name = classname;
-	    }
-	  else
-	    panic_impossible ();
-	}
+                          if (! error_state)
+                            map = tmp(0).map_value ();
+                          else
+                            success = false;
+                        }
+                    }
+                }
+              else
+                {
+                  error ("load: failed to load class");
+                  success = false;
+                }
+            }
+          else if (len == 0 )
+            {
+              map = Octave_map (dim_vector (1, 1));
+              c_name = classname;
+            }
+          else
+            panic_impossible ();
+        }
       else 
-	{
-	  error ("load: failed to extract number of elements in class");
-	  success = false;
-	}
+        {
+          error ("load: failed to extract number of elements in class");
+          success = false;
+        }
     }
   else
     {
       error ("load: failed to extract name of class");
       success = false;
     }
 
   return success;
@@ -1233,45 +1233,45 @@ octave_class::save_binary (std::ostream&
   os << class_name ();
 
   Octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
       if (! error_state)
-	m = tmp(0).map_value ();
+        m = tmp(0).map_value ();
       else
-	return false;
+        return false;
     }
   else
     m = map_value ();
 
   int32_t len = m.nfields();
   os.write (reinterpret_cast<char *> (&len), 4);
   
   Octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_binary_data (os, val, m.key (i), "", 0, save_as_floats);
       
       if (! b)
-	return os;
+        return os;
 
       i++;
     }
 
   return true;
 }
 
 bool 
 octave_class::load_binary (std::istream& is, bool swap,
-			    oct_mach_info::float_format fmt)
+                            oct_mach_info::float_format fmt)
 {
   bool success = true;
 
   int32_t classname_len;
 
   is.read (reinterpret_cast<char *> (&classname_len), 4);
   if (! is)
     return false;
@@ -1293,64 +1293,64 @@ octave_class::load_binary (std::istream&
   if (swap)
     swap_bytes<4> (&len);
 
   if (len > 0)
     {
       Octave_map m (map);
 
       for (octave_idx_type j = 0; j < len; j++)
-	{
-	  octave_value t2;
-	  bool dummy;
-	  std::string doc;
+        {
+          octave_value t2;
+          bool dummy;
+          std::string doc;
 
-	  // recurse to read cell elements
-	  std::string nm = read_binary_data (is, swap, fmt, std::string (), 
-					     dummy, t2, doc);
+          // recurse to read cell elements
+          std::string nm = read_binary_data (is, swap, fmt, std::string (), 
+                                             dummy, t2, doc);
 
-	  if (! is)
-	    break;
+          if (! is)
+            break;
 
-	  Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
+          Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
  
-	  if (error_state)
-	    {
-	      error ("load: internal error loading class elements");
-	      return false;
-	    }
+          if (error_state)
+            {
+              error ("load: internal error loading class elements");
+              return false;
+            }
 
-	  m.assign (nm, tcell);
-	}
+          m.assign (nm, tcell);
+        }
 
       if (is) 
-	{
-	  map = m;
+        {
+          map = m;
 
-	  if (! reconstruct_parents ())
-	    warning ("load: unable to reconstruct object inheritance");
-	  else
-	    {
-	      if (load_path::find_method (c_name, "loadobj") != std::string ())
-		{
-		  octave_value in = new octave_class (*this);
-		  octave_value_list tmp = feval ("loadobj", in, 1);
+          if (! reconstruct_parents ())
+            warning ("load: unable to reconstruct object inheritance");
+          else
+            {
+              if (load_path::find_method (c_name, "loadobj") != std::string ())
+                {
+                  octave_value in = new octave_class (*this);
+                  octave_value_list tmp = feval ("loadobj", in, 1);
 
-		  if (! error_state)
-		    map = tmp(0).map_value ();
-		  else
-		    success = false;
-		}
-	    }
-	}
+                  if (! error_state)
+                    map = tmp(0).map_value ();
+                  else
+                    success = false;
+                }
+            }
+        }
       else
-	{
-	  warning ("load: failed to load class");
-	  success = false;
-	}
+        {
+          warning ("load: failed to load class");
+          success = false;
+        }
     }
   else if (len == 0 )
     map = Octave_map (dim_vector (1, 1));
   else
     panic_impossible ();
 
   return success;
 }
@@ -1383,56 +1383,56 @@ octave_class::save_hdf5 (hid_t loc_id, c
     goto error_cleanup;
 
   hdims[0] = 0;
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     goto error_cleanup;
 #if HAVE_HDF5_18
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
-			 H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
-			 H5P_DEFAULT);
+                         H5P_DEFAULT);
 #endif
   if (class_hid < 0 || H5Dwrite (class_hid, type_hid, H5S_ALL, H5S_ALL, 
-				    H5P_DEFAULT, c_name.c_str ()) < 0)
+                                    H5P_DEFAULT, c_name.c_str ()) < 0)
     goto error_cleanup;
 
 #if HAVE_HDF5_18
   data_hid = H5Gcreate (group_hid, "value", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
       if (! error_state)
-	m = tmp(0).map_value ();
+        m = tmp(0).map_value ();
       else
-	goto error_cleanup;
+        goto error_cleanup;
     }
   else
     m = map_value ();
 
   // recursively add each element of the class to this group
   i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool retval2 = add_hdf5_data (data_hid, val, m.key (i), "", false, 
-				    save_as_floats);
+                                    save_as_floats);
 
       if (! retval2)
-	break;
+        break;
 
       i++;
     }
 
  error_cleanup:
 
   if (data_hid > 0)
     H5Gclose (data_hid);
@@ -1492,17 +1492,17 @@ octave_class::load_hdf5 (hid_t loc_id, c
     goto error_cleanup;
 
   type_hid = H5Dget_type (data_hid);
 
   type_class_hid = H5Tget_class (type_hid);
 
   if (type_class_hid != H5T_STRING)
     goto error_cleanup;
-	  
+          
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     goto error_cleanup;
 
   slen = H5Tget_size (type_hid);
   if (slen < 0)
@@ -1513,23 +1513,23 @@ octave_class::load_hdf5 (hid_t loc_id, c
     {
       OCTAVE_LOCAL_BUFFER (char, classname, slen);
 
       // create datatype for (null-terminated) string to read into:
       st_id = H5Tcopy (H5T_C_S1);
       H5Tset_size (st_id, slen);
 
       if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
-		   classname) < 0)
-	{
-	  H5Tclose (st_id);
-	  H5Dclose (data_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+                   classname) < 0)
+        {
+          H5Tclose (st_id);
+          H5Dclose (data_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
      
       H5Tclose (st_id);
       H5Dclose (data_hid);
       data_hid = -1;
 
       c_name = classname;
     }
   while (0);
@@ -1539,57 +1539,57 @@ octave_class::load_hdf5 (hid_t loc_id, c
   subgroup_hid = H5Gopen (group_hid, name, H5P_DEFAULT); 
 #else
   subgroup_hid = H5Gopen (group_hid, name); 
 #endif
   H5Gget_num_objs (subgroup_hid, &num_obj);
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
-	 && (retval2 = H5Giterate (group_hid, name, &current_item,
-				   hdf5_read_next_data, &dsub)) > 0)
+         && (retval2 = H5Giterate (group_hid, name, &current_item,
+                                   hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
       Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
  
       if (error_state)
-	{
-	  error ("load: internal error loading class elements");
-	  return false;
-	}
+        {
+          error ("load: internal error loading class elements");
+          return false;
+        }
 
       m.assign (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
 
       if (!reconstruct_parents ())
-	warning ("load: unable to reconstruct object inheritance");
+        warning ("load: unable to reconstruct object inheritance");
       else
-	{
-	  if (load_path::find_method (c_name, "loadobj") != std::string ())
-	    {
-	      octave_value in = new octave_class (*this);
-	      octave_value_list tmp = feval ("loadobj", in, 1);
+        {
+          if (load_path::find_method (c_name, "loadobj") != std::string ())
+            {
+              octave_value in = new octave_class (*this);
+              octave_value_list tmp = feval ("loadobj", in, 1);
 
-	      if (! error_state)
-		{
-		  map = tmp(0).map_value ();
-		  retval = true;
-		}
-	      else
-		retval = false;
-	    }
-	  else
-	    retval = true;
-	}
+              if (! error_state)
+                {
+                  map = tmp(0).map_value ();
+                  retval = true;
+                }
+              else
+                retval = false;
+            }
+          else
+            retval = true;
+        }
     }
   
  error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
     H5Gclose (group_hid);
@@ -1608,20 +1608,20 @@ octave_class::as_mxArray (void) const
 }
 
 bool
 octave_class::in_class_method (void)
 {
   octave_function *fcn = octave_call_stack::current ();
 
   return (fcn
-	  && (fcn->is_class_method ()
-	      || fcn->is_class_constructor ()
-	      || fcn->is_private_function_of_class (class_name ()))
-	  && find_parent_class (fcn->dispatch_class ()));
+          && (fcn->is_class_method ()
+              || fcn->is_class_constructor ()
+              || fcn->is_private_function_of_class (class_name ()))
+          && find_parent_class (fcn->dispatch_class ()));
 }
 
 octave_class::exemplar_info::exemplar_info (const octave_value& obj)
   : field_names (), parent_class_names ()
 {
   if (obj.is_object ())
     {
       Octave_map m = obj.map_value ();
@@ -1640,61 +1640,61 @@ std::map<std::string, octave_class::exem
 bool
 octave_class::exemplar_info::compare (const octave_value& obj) const
 {
   bool retval = true;
 
   if (obj.is_object ())
     {
       if (nfields () == obj.nfields ())
-	{
-	  Octave_map obj_map = obj.map_value ();
-	  string_vector obj_fnames = obj_map.keys ();
-	  string_vector fnames = fields ();
+        {
+          Octave_map obj_map = obj.map_value ();
+          string_vector obj_fnames = obj_map.keys ();
+          string_vector fnames = fields ();
 
-	  for (octave_idx_type i = 0; i < nfields (); i++)
-	    {
-	      if (obj_fnames[i] != fnames[i])
-		{
-		  retval = false;
-		  error ("mismatch in field names");
-		  break;
-		}
-	    }
+          for (octave_idx_type i = 0; i < nfields (); i++)
+            {
+              if (obj_fnames[i] != fnames[i])
+                {
+                  retval = false;
+                  error ("mismatch in field names");
+                  break;
+                }
+            }
 
-	  if (nparents () == obj.nparents ())
-	    {
-	      std::list<std::string> obj_parents
-		= obj.parent_class_name_list ();
-	      std::list<std::string> pnames = parents ();
+          if (nparents () == obj.nparents ())
+            {
+              std::list<std::string> obj_parents
+                = obj.parent_class_name_list ();
+              std::list<std::string> pnames = parents ();
 
-	      std::list<std::string>::const_iterator p = obj_parents.begin ();
-	      std::list<std::string>::const_iterator q = pnames.begin ();
+              std::list<std::string>::const_iterator p = obj_parents.begin ();
+              std::list<std::string>::const_iterator q = pnames.begin ();
 
-	      while (p != obj_parents.end ())
-		{
-		  if (*p++ != *q++)
-		    {
-		      retval = false;
-		      error ("mismatch in parent classes");
-		      break;
-		    }
-		}
-	    }
-	  else
-	    {
-	      retval = false;
-	      error ("mismatch in number of parent classes");
-	    }
-	}
+              while (p != obj_parents.end ())
+                {
+                  if (*p++ != *q++)
+                    {
+                      retval = false;
+                      error ("mismatch in parent classes");
+                      break;
+                    }
+                }
+            }
+          else
+            {
+              retval = false;
+              error ("mismatch in number of parent classes");
+            }
+        }
       else
-	{
-	  retval = false;
-	  error ("mismatch in number of fields");
-	}
+        {
+          retval = false;
+          error ("mismatch in number of fields");
+        }
     }
   else
     {
       retval = false;
       error ("invalid comparison of class exemplar to non-class object");
     }
 
   return retval;
@@ -1728,43 +1728,43 @@ derived.\n\
           Octave_map m = args(0).map_value ();
 
           if (! error_state)
             {
               std::string id = args(1).string_value ();
 
               if (! error_state)
                 {
-		  if (nargin == 2)
-		    retval = octave_value (new octave_class (m, id));
-		  else
-		    {
-		      octave_value_list parents = args.slice (2, nargin-2);
+                  if (nargin == 2)
+                    retval = octave_value (new octave_class (m, id));
+                  else
+                    {
+                      octave_value_list parents = args.slice (2, nargin-2);
 
-		      retval = octave_value (new octave_class (m, id, parents));
-		    }
+                      retval = octave_value (new octave_class (m, id, parents));
+                    }
 
-		  if (! error_state)
-		    {
-		      octave_class::exemplar_const_iterator it
-			= octave_class::exemplar_map.find (id);
+                  if (! error_state)
+                    {
+                      octave_class::exemplar_const_iterator it
+                        = octave_class::exemplar_map.find (id);
 
-		      if (it == octave_class::exemplar_map.end ())
-			octave_class::exemplar_map[id]
-			  = octave_class::exemplar_info (retval);
-		      else if (! it->second.compare (retval))
-			error ("class: object of class `%s' does not match previously constructed objects", id.c_str ());
-		    }
+                      if (it == octave_class::exemplar_map.end ())
+                        octave_class::exemplar_map[id]
+                          = octave_class::exemplar_info (retval);
+                      else if (! it->second.compare (retval))
+                        error ("class: object of class `%s' does not match previously constructed objects", id.c_str ());
+                    }
                 }
-	      else
+              else
                 error ("class: expecting character string as second argument");
-	    }
-	  else
+            }
+          else
             error ("class: expecting structure as first argument");
-	}
+        }
       else
         error ("class: invalid call from outside class constructor");
     }
 
   return retval;
 }
 
 DEFUN (__isa_parent__, args, ,
@@ -1776,22 +1776,22 @@ Undocumented internal function.\n\
   octave_value retval = false;
 
   if (args.length () == 2)
     {
       octave_value cls = args(0);
       octave_value nm = args(1);
 
       if (! error_state)
-	{
-	  if (cls.find_parent_class (nm.string_value ()))
-	    retval = true;
-	}
+        {
+          if (cls.find_parent_class (nm.string_value ()))
+            retval = true;
+        }
       else
-	error ("__isa_parent__: expecting arguments to be character strings");
+        error ("__isa_parent__: expecting arguments to be character strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__parent_classes__, args, ,
@@ -1802,17 +1802,17 @@ Undocumented internal function.\n\
 {
   octave_value retval = Cell ();
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_object ())
-	retval = Cell (arg.parent_class_names ());
+        retval = Cell (arg.parent_class_names ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isobject, args, ,
@@ -1842,34 +1842,34 @@ is a method of this class.\n\
 
   if (args.length () == 2)
     {
       octave_value arg = args(0);
 
       std::string class_name;
 
       if (arg.is_object ())
-	class_name = arg.class_name ();
+        class_name = arg.class_name ();
       else if (arg.is_string ())
-	class_name = arg.string_value ();
+        class_name = arg.string_value ();
       else
-	error ("ismethod: expecting object or class name as first argument");
+        error ("ismethod: expecting object or class name as first argument");
 
       if (! error_state)
-	{
-	  std::string method = args(1).string_value ();
+        {
+          std::string method = args(1).string_value ();
 
-	  if (! error_state)
-	    {
-	      if (load_path::find_method (class_name, method) != std::string ())
-		retval = true;
-	      else
-		retval = false;
-	    }
-	}
+          if (! error_state)
+            {
+              if (load_path::find_method (class_name, method) != std::string ())
+                retval = true;
+              else
+                retval = false;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (methods, args, nargout,
@@ -1884,37 +1884,37 @@ object @var{x} or the named class.\n\
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
       std::string class_name;
 
       if (arg.is_object ())
-	class_name = arg.class_name ();
+        class_name = arg.class_name ();
       else if (arg.is_string ())
-	class_name = arg.string_value ();
+        class_name = arg.string_value ();
       else
-	error ("methods: expecting object or class name as argument");
+        error ("methods: expecting object or class name as argument");
 
       if (! error_state)
-	{
-	  string_vector sv = load_path::methods (class_name);
+        {
+          string_vector sv = load_path::methods (class_name);
 
-	  if (nargout == 0)
-	    {
-	      octave_stdout << "Methods for class " << class_name << ":\n\n";
+          if (nargout == 0)
+            {
+              octave_stdout << "Methods for class " << class_name << ":\n\n";
 
-	      sv.list_in_columns (octave_stdout);
+              sv.list_in_columns (octave_stdout);
 
-	      octave_stdout << std::endl;
-	    }
-	  else
-	    retval = Cell (sv);
-	}	  
+              octave_stdout << std::endl;
+            }
+          else
+            retval = Cell (sv);
+        }         
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static bool
@@ -1955,45 +1955,45 @@ This function may only be called from a 
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
 
   if (fcn && fcn->is_class_constructor ())
     {
       for (int i = 0; i < args.length(); i++)
-	{
-	  std::string class_name = args(i).string_value ();
+        {
+          std::string class_name = args(i).string_value ();
 
-	  if (! error_state)
-	    {
-	      if (! is_built_in_class (class_name))
-		{
-		  std::string this_class_name = fcn->name ();
+          if (! error_state)
+            {
+              if (! is_built_in_class (class_name))
+                {
+                  std::string this_class_name = fcn->name ();
 
-		  if (! symbol_table::set_class_relationship (this_class_name,
-							      class_name))
-		    {
-		      error ("superiorto: precedence already set for %s and %s",
-			     this_class_name.c_str (), class_name.c_str ());
-		      break;
-		    }
-		}
-	      else
-		{
-		  // User defined classes always have higher precedence
-		  // than built-in classes.
-		}
-	    }
-	  else
-	    {
-	      error ("superiorto: expecting argument to be class name");
-	      break;
-	    }
-	}
+                  if (! symbol_table::set_class_relationship (this_class_name,
+                                                              class_name))
+                    {
+                      error ("superiorto: precedence already set for %s and %s",
+                             this_class_name.c_str (), class_name.c_str ());
+                      break;
+                    }
+                }
+              else
+                {
+                  // User defined classes always have higher precedence
+                  // than built-in classes.
+                }
+            }
+          else
+            {
+              error ("superiorto: expecting argument to be class name");
+              break;
+            }
+        }
     }
   else
     error ("superiorto: invalid call from outside class constructor");
 
   return retval;
 }
 
 DEFUN (inferiorto, args, ,
@@ -2007,46 +2007,46 @@ This function may only be called from a 
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
 
   if (fcn && fcn->is_class_constructor ())
     {
       for (int i = 0; i < args.length(); i++)
-	{
-	  std::string class_name = args(i).string_value ();
+        {
+          std::string class_name = args(i).string_value ();
 
-	  if (! error_state)
-	    {
-	      if (! is_built_in_class (class_name))
-		{
-		  std::string this_class_name = fcn->name ();
+          if (! error_state)
+            {
+              if (! is_built_in_class (class_name))
+                {
+                  std::string this_class_name = fcn->name ();
 
-		  symbol_table::set_class_relationship (class_name,
-							this_class_name);
+                  symbol_table::set_class_relationship (class_name,
+                                                        this_class_name);
 
-		  if (! symbol_table::set_class_relationship (this_class_name,
-							      class_name))
-		    {
-		      error ("inferiorto: precedence already set for %s and %s",
-			     this_class_name.c_str (), class_name.c_str ());
-		      break;
-		    }
-		}
-	      else
-		{
-		  error ("inferiorto: cannot give user-defined class lower precedence than built-in class");
-		  break;
-		}
-	    }
-	  else
-	    {
-	      error ("inferiorto: expecting argument to be class name");
-	      break;
-	    }
-	}
+                  if (! symbol_table::set_class_relationship (this_class_name,
+                                                              class_name))
+                    {
+                      error ("inferiorto: precedence already set for %s and %s",
+                             this_class_name.c_str (), class_name.c_str ());
+                      break;
+                    }
+                }
+              else
+                {
+                  error ("inferiorto: cannot give user-defined class lower precedence than built-in class");
+                  break;
+                }
+            }
+          else
+            {
+              error ("inferiorto: expecting argument to be class name");
+              break;
+            }
+        }
     }
   else
     error ("inferiorto: invalid call from outside class constructor");
 
   return retval;
 }
diff --git a/src/ov-colon.cc b/src/ov-colon.cc
--- a/src/ov-colon.cc
+++ b/src/ov-colon.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "error.h"
 #include "pr-output.h"
 #include "oct-obj.h"
 #include "ov-colon.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_magic_colon,
-				     "magic-colon", "magic-colon");
+                                     "magic-colon", "magic-colon");
 
 void
 octave_magic_colon::print (std::ostream& os, bool) const
 {
   indent (os);
   print_raw (os);
 }
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -48,17 +48,17 @@ along with Octave; see the file COPYING.
 #include "ls-oct-ascii.h"
 #include "ls-hdf5.h"
 
 template class octave_base_scalar<Complex>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_complex);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex,
-				     "complex scalar", "double");
+                                     "complex scalar", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_float_complex (v.float_complex_value ());
 }
@@ -103,87 +103,87 @@ octave_complex::do_index_op (const octav
 
 double
 octave_complex::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real scalar");
+                               "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 float
 octave_complex::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real scalar");
+                               "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 Matrix
 octave_complex::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = Matrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 FloatMatrix
 octave_complex::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = FloatMatrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 NDArray
 octave_complex::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = NDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 FloatNDArray
 octave_complex::float_array_value (bool force_conversion) const
 {
   FloatNDArray retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = FloatNDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 Complex
 octave_complex::complex_value (bool) const
@@ -224,26 +224,26 @@ octave_complex::float_complex_array_valu
 octave_value 
 octave_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       ComplexNDArray retval (dv, ComplexNDArray::resize_fill_value ());
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
   else
     {
       ComplexNDArray retval (dv);
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
 }
 
 bool 
 octave_complex::save_ascii (std::ostream& os)
 {
@@ -279,37 +279,37 @@ octave_complex::save_binary (std::ostrea
   Complex ctmp = complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 16);
 
   return true;
 }
 
 bool 
 octave_complex::load_binary (std::istream& is, bool swap,
-			     oct_mach_info::float_format fmt)
+                             oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   Complex ctmp;
   read_doubles (is, reinterpret_cast<double *> (&ctmp),
-		static_cast<save_type> (tmp), 2, swap, fmt);
+                static_cast<save_type> (tmp), 2, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_complex::save_hdf5 (hid_t loc_id, const char *name,
-			   bool /* save_as_floats */)
+                           bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, type_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
@@ -317,30 +317,30 @@ octave_complex::save_hdf5 (hid_t loc_id,
   type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   Complex tmp = complex_value ();
   retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
-		     &tmp) >= 0;
+                     &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
@@ -373,17 +373,17 @@ octave_complex::load_hdf5 (hid_t loc_id,
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   // complex scalar:
   Complex ctmp;
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       &ctmp) >= 0)
+               &ctmp) >= 0)
     {
       retval = true;
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
diff --git a/src/ov-cx-diag.cc b/src/ov-cx-diag.cc
--- a/src/ov-cx-diag.cc
+++ b/src/ov-cx-diag.cc
@@ -97,31 +97,31 @@ octave_complex_diag_matrix::try_narrowin
 
 DiagMatrix
 octave_complex_diag_matrix::diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       type_name (), "real matrix");
+                               type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 FloatDiagMatrix
 octave_complex_diag_matrix::float_diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       type_name (), "real matrix");
+                               type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 ComplexDiagMatrix
 octave_complex_diag_matrix::complex_diag_matrix_value (bool) const
@@ -168,39 +168,39 @@ octave_complex_diag_matrix::save_binary 
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   ComplexMatrix m = ComplexMatrix (matrix.diag ());
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	st = LS_FLOAT;
+        st = LS_FLOAT;
     }
   else if (matrix.length () > 4096) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   const Complex *mtmp = m.data ();
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st, 2 * m.numel ());
 
   return true;
 }
 
 bool 
 octave_complex_diag_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -55,17 +55,17 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 template class octave_base_matrix<ComplexNDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_complex_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_matrix,
-				     "complex matrix", "double");
+                                     "complex matrix", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_complex_matrix&);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
@@ -99,92 +99,92 @@ octave_complex_matrix::try_narrowing_con
 
 double
 octave_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real scalar");
+                               "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "real scalar");
+                                 "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real scalar");
+                               "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "real scalar");
+                                 "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real matrix");
+                               "complex matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 FloatMatrix
 octave_complex_matrix::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real matrix");
+                               "complex matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 Complex
 octave_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "complex scalar");
+                                 "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
@@ -194,17 +194,17 @@ octave_complex_matrix::float_complex_val
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "complex scalar");
+                                 "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
@@ -235,24 +235,24 @@ octave_complex_matrix::bool_array_value 
   
 charNDArray
 octave_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
     gripe_implicit_conversion ("Octave:num-to-str",
-			       "complex matrix", "string");
+                               "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
   
       for (octave_idx_type i = 0; i < nel; i++)
-	retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
     }
 
   return retval;
 }  
 
 FloatComplexNDArray 
 octave_complex_matrix::float_complex_array_value (bool) const 
 { 
@@ -261,17 +261,17 @@ octave_complex_matrix::float_complex_arr
 
 SparseMatrix
 octave_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real matrix");
+                               "complex matrix", "real matrix");
 
   retval = SparseMatrix (::real (matrix.matrix_value ()));
 
   return retval;
 }
 
 SparseComplexMatrix
 octave_complex_matrix::sparse_complex_matrix_value (bool) const
@@ -298,26 +298,26 @@ octave_complex_matrix::save_ascii (std::
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       ComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
-	os << " " << d (i);
+        os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
-	 << "# columns: " << columns () << "\n";
+         << "# columns: " << columns () << "\n";
 
       os << complex_matrix_value ();
     }
 
   return true;
 }
 
 bool 
@@ -331,85 +331,85 @@ octave_complex_matrix::load_ascii (std::
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
-	{
-	  int mdims = static_cast<int> (val);
+        {
+          int mdims = static_cast<int> (val);
 
-	  if (mdims >= 0)
-	    {
-	      dim_vector dv;
-	      dv.resize (mdims);
+          if (mdims >= 0)
+            {
+              dim_vector dv;
+              dv.resize (mdims);
 
-	      for (int i = 0; i < mdims; i++)
-		is >> dv(i);
+              for (int i = 0; i < mdims; i++)
+                is >> dv(i);
 
-	      if (is)
-		{
-		  ComplexNDArray tmp(dv);
+              if (is)
+                {
+                  ComplexNDArray tmp(dv);
 
                   is >> tmp;
 
                   if (is)
                     matrix = tmp;
                   else
                     {
                       error ("load: failed to load matrix constant");
                       success = false;
                     }
-		}
-	      else
-		{
-		  error ("load: failed to read dimensions");
-		  success = false;
-		}
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of dimensions");
-	      success = false;
-	    }
-	}
+                }
+              else
+                {
+                  error ("load: failed to read dimensions");
+                  success = false;
+                }
+            }
+          else
+            {
+              error ("load: failed to extract number of dimensions");
+              success = false;
+            }
+        }
       else if (kw == "rows")
-	{
-	  octave_idx_type nr = val;
-	  octave_idx_type nc = 0;
+        {
+          octave_idx_type nr = val;
+          octave_idx_type nc = 0;
 
-	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-	    {
-	      if (nr > 0 && nc > 0)
-		{
-		  ComplexMatrix tmp (nr, nc);
-		  is >> tmp;
-		  if (is)
-		    matrix = tmp;
-		  else
-		    {
-		      error ("load: failed to load matrix constant");
-		      success = false;
-		    }
-		}
-	      else if (nr == 0 || nc == 0)
-		matrix = ComplexMatrix (nr, nc);
-	      else
-		panic_impossible ();
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of rows and columns");
-	      success = false;
-	    }
-	}
+          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+            {
+              if (nr > 0 && nc > 0)
+                {
+                  ComplexMatrix tmp (nr, nc);
+                  is >> tmp;
+                  if (is)
+                    matrix = tmp;
+                  else
+                    {
+                      error ("load: failed to load matrix constant");
+                      success = false;
+                    }
+                }
+              else if (nr == 0 || nc == 0)
+                matrix = ComplexMatrix (nr, nc);
+              else
+                panic_impossible ();
+            }
+          else
+            {
+              error ("load: failed to extract number of rows and columns");
+              success = false;
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
@@ -431,113 +431,113 @@ octave_complex_matrix::save_binary (std:
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   ComplexNDArray m = complex_array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	st = LS_FLOAT;
+        st = LS_FLOAT;
     }
   else if (d.numel () > 4096) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
 
   const Complex *mtmp = m.data ();
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st, 2 * d.numel ());
 
   return true;
 }
 
 bool 
 octave_complex_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
       int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
-	{
-	  if (! is.read (reinterpret_cast<char *> (&di), 4))
-	    return false;
-	  if (swap)
-	    swap_bytes<4> (&di);
-	  dv(i) = di;
-	}
+        {
+          if (! is.read (reinterpret_cast<char *> (&di), 4))
+            return false;
+          if (swap)
+            swap_bytes<4> (&di);
+          dv(i) = di;
+        }
 
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
       // might.
 
       if (mdims == 1)
-	{
-	  mdims = 2;
-	  dv.resize (mdims);
-	  dv(1) = dv(0);
-	  dv(0) = 1;
-	}
+        {
+          mdims = 2;
+          dv.resize (mdims);
+          dv(1) = dv(0);
+          dv(0) = 1;
+        }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
 
       ComplexNDArray m(dv);
       Complex *im = m.fortran_vec ();
       read_doubles (is, reinterpret_cast<double *> (im),
-		    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
+                    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&nc);
+        swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
       ComplexMatrix m (nr, nc);
       Complex *im = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_doubles (is, reinterpret_cast<double *> (im),
-		    static_cast<save_type> (tmp), 2*len, swap, fmt);
+                    static_cast<save_type> (tmp), 2*len, swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_complex_matrix::save_hdf5 (hid_t loc_id, const char *name,
-				  bool save_as_floats)
+                                  bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid = -1, data_hid = -1, type_hid = -1;
@@ -553,44 +553,44 @@ octave_complex_matrix::save_hdf5 (hid_t 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	save_type_hid = H5T_NATIVE_FLOAT;
+        save_type_hid = H5T_NATIVE_FLOAT;
     }
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
       
       if (m.all_integers (max_val, min_val))
-	save_type_hid
-	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
+        save_type_hid
+          = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
@@ -598,21 +598,21 @@ octave_complex_matrix::save_hdf5 (hid_t 
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (complex_type_hid < 0) retval = false;
 
   if (retval)
     {
       Complex *mtmp = m.fortran_vec ();
       if (H5Dwrite (data_hid, complex_type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		    mtmp) < 0)
-	{
-	  H5Tclose (complex_type_hid);
-	  retval = false;
-	}
+                    mtmp) < 0)
+        {
+          H5Tclose (complex_type_hid);
+          retval = false;
+        }
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
@@ -669,43 +669,43 @@ octave_complex_matrix::load_hdf5 (hid_t 
       dv.resize (2);
       dv(0) = 1;
       dv(1) = hdims[0];
     }
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
-	dv(j) = hdims[i];
+        dv(j) = hdims[i];
     }
 
   ComplexNDArray m (dv);
   Complex *reim = m.fortran_vec ();
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       reim) >= 0) 
+               reim) >= 0) 
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
   return retval;
 }
 
 #endif
 
 void
 octave_complex_matrix::print_raw (std::ostream& os,
-				  bool pr_as_read_syntax) const
+                                  bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 mxArray *
 octave_complex_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, dims (), mxCOMPLEX);
 
   double *pr = static_cast<double *> (retval->get_data ());
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -62,101 +62,101 @@ octave_sparse_complex_matrix::try_narrow
     {
       int nr = matrix.rows ();
       int nc = matrix.cols ();
 
       // Don't use numel, since it can overflow for very large matrices
       // Note that for the tests on matrix size, they become approximative
       // since they involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
-	{
-	  // Const copy of the matrix, so the right version of () operator used
-	  const SparseComplexMatrix tmp (matrix);
+        {
+          // Const copy of the matrix, so the right version of () operator used
+          const SparseComplexMatrix tmp (matrix);
 
-	  Complex c = tmp (0, 0);
+          Complex c = tmp (0, 0);
 
-	  if (std::imag (c) == 0.0)
-	    retval = new octave_scalar (std::real (c));
-	  else
-	    retval = new octave_complex (c);
-	}
+          if (std::imag (c) == 0.0)
+            retval = new octave_scalar (std::real (c));
+          else
+            retval = new octave_complex (c);
+        }
       else if (nr == 0 || nc == 0)
-	retval = new octave_matrix (Matrix (nr, nc));
+        retval = new octave_matrix (Matrix (nr, nc));
       else if (matrix.all_elements_are_real ())
-	if (matrix.cols () > 0 && matrix.rows () > 0
-	    && (double (matrix.byte_size ()) > double (matrix.rows ())
-		* double (matrix.cols ()) * sizeof (double)))
-	  retval = new octave_matrix (::real (matrix.matrix_value ()));
-	else
-	  retval = new octave_sparse_matrix (::real (matrix));
+        if (matrix.cols () > 0 && matrix.rows () > 0
+            && (double (matrix.byte_size ()) > double (matrix.rows ())
+                * double (matrix.cols ()) * sizeof (double)))
+          retval = new octave_matrix (::real (matrix.matrix_value ()));
+        else
+          retval = new octave_sparse_matrix (::real (matrix));
       else if (matrix.cols () > 0 && matrix.rows () > 0
-	       && (double (matrix.byte_size ()) > double (matrix.rows ())
-		   * double (matrix.cols ()) * sizeof (Complex)))
-	retval = new octave_complex_matrix (matrix.matrix_value ());
+               && (double (matrix.byte_size ()) > double (matrix.rows ())
+                   * double (matrix.cols ()) * sizeof (Complex)))
+        retval = new octave_complex_matrix (matrix.matrix_value ());
     }
   else
     {
       if (matrix.all_elements_are_real ())
-	retval = new octave_sparse_matrix (::real (matrix));
+        retval = new octave_sparse_matrix (::real (matrix));
     }
     
   return retval;
 }
 
 void
 octave_sparse_complex_matrix::assign (const octave_value_list& idx,
-				      const SparseComplexMatrix& rhs)
+                                      const SparseComplexMatrix& rhs)
 {
   octave_base_sparse<SparseComplexMatrix>::assign (idx, rhs);
 }
 
 void
 octave_sparse_complex_matrix::assign (const octave_value_list& idx,
-				      const SparseMatrix& rhs)
+                                      const SparseMatrix& rhs)
 {
   int len = idx.length ();
 
   for (int i = 0; i < len; i++)
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, rhs);
 }
 
 double
 octave_sparse_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex sparse matrix", "real scalar");
+                               "complex sparse matrix", "real scalar");
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
       if (numel () > 1)
-	gripe_implicit_conversion ("Octave:array-as-scalar",
-				   "complex sparse matrix", "real scalar");
+        gripe_implicit_conversion ("Octave:array-as-scalar",
+                                   "complex sparse matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_sparse_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex sparse matrix", "real matrix");
+                               "complex sparse matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 Complex
 octave_sparse_complex_matrix::complex_value (bool) const
@@ -164,18 +164,18 @@ octave_sparse_complex_matrix::complex_va
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
       if (numel () > 1)
-	gripe_implicit_conversion ("Octave:array-as-scalar",
-				   "complex sparse matrix", "real scalar");
+        gripe_implicit_conversion ("Octave:array-as-scalar",
+                                   "complex sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
@@ -194,41 +194,41 @@ octave_sparse_complex_matrix::complex_ar
 
 charNDArray
 octave_sparse_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
     gripe_implicit_conversion ("Octave:num-to-str",
-			       "sparse complex matrix", "string");
+                               "sparse complex matrix", "string");
   else
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-	  retval(matrix.ridx(i) + nr * j) = 
-	    static_cast<char>(std::real (matrix.data (i)));
+        for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+          retval(matrix.ridx(i) + nr * j) = 
+            static_cast<char>(std::real (matrix.data (i)));
     }
 
   return retval;
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex sparse matrix", 
-			       "real sparse matrix");
+                               "complex sparse matrix", 
+                               "real sparse matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 SparseBoolMatrix 
 octave_sparse_complex_matrix::sparse_bool_matrix_value (bool warn) const
@@ -239,17 +239,17 @@ octave_sparse_complex_matrix::sparse_boo
                     || real (matrix).any_element_not_one_or_zero ()))
     gripe_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 bool 
 octave_sparse_complex_matrix::save_binary (std::ostream& os, 
-					   bool&save_as_floats)
+                                           bool&save_as_floats)
 {
   dim_vector d = this->dims ();
   if (d.length() < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
@@ -270,28 +270,28 @@ octave_sparse_complex_matrix::save_binar
   
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (matrix.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	st = LS_FLOAT;
+        st = LS_FLOAT;
     }
   else if (matrix.nzmax () > 8192) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)  
      {
        octave_quit ();
        itmp = matrix.cidx(i);
@@ -307,17 +307,17 @@ octave_sparse_complex_matrix::save_binar
 
    write_doubles (os, reinterpret_cast<const double *> (matrix.data()), st, 2 * nz);
 
   return true;
 }
 
 bool
 octave_sparse_complex_matrix::load_binary (std::istream& is, bool swap,
-				   oct_mach_info::float_format fmt)
+                                   oct_mach_info::float_format fmt)
 {
   int32_t nz, nc, nr, tmp;
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
@@ -338,61 +338,61 @@ octave_sparse_complex_matrix::load_binar
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
-			 static_cast<octave_idx_type> (nc),
-			 static_cast<octave_idx_type> (nz));
+                         static_cast<octave_idx_type> (nc),
+                         static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
   
   read_doubles (is, reinterpret_cast<double *> (m.data ()),
-		static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
+                static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
 
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_sparse_complex_matrix::save_hdf5 (hid_t loc_id, const char *name, 
-					 bool save_as_floats)
+                                         bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
@@ -415,81 +415,81 @@ octave_sparse_complex_matrix::save_hdf5 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -503,31 +503,31 @@ octave_sparse_complex_matrix::save_hdf5 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, itmp) >= 0;
+                     H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -541,20 +541,20 @@ octave_sparse_complex_matrix::save_hdf5 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
@@ -568,45 +568,45 @@ octave_sparse_complex_matrix::save_hdf5 
       return false;
     }
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	save_type_hid = H5T_NATIVE_FLOAT;
+        save_type_hid = H5T_NATIVE_FLOAT;
     }
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
-	save_type_hid
-	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
+        save_type_hid
+          = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
   hid_t type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, H5P_DEFAULT);
 #endif  
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
@@ -615,17 +615,17 @@ octave_sparse_complex_matrix::save_hdf5 
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   retval = false;
   if (complex_type_hid >= 0) 
     {
       Complex * ctmp = m.xdata ();
 
       retval = H5Dwrite (data_hid, complex_type_hid, H5S_ALL, H5S_ALL,
-			 H5P_DEFAULT, ctmp) >= 0;
+                         H5P_DEFAULT, ctmp) >= 0;
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
@@ -720,18 +720,18 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
-			 static_cast<octave_idx_type> (nc),
-			 static_cast<octave_idx_type> (nz));
+                         static_cast<octave_idx_type> (nc),
+                         static_cast<octave_idx_type> (nz));
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "cidx", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "cidx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
@@ -846,17 +846,17 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   Complex *ctmp = m.xdata ();
   bool retval = false;
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL,
-	       H5P_DEFAULT, ctmp) >= 0
+               H5P_DEFAULT, ctmp) >= 0
       && m.indices_ok ())
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_hid);
@@ -868,17 +868,17 @@ octave_sparse_complex_matrix::load_hdf5 
 
 #endif
 
 mxArray *
 octave_sparse_complex_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax ();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, rows (), columns (),
-				 nz, mxCOMPLEX);
+                                 nz, mxCOMPLEX);
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
       Complex val = matrix.data(i);
diff --git a/src/ov-dld-fcn.cc b/src/ov-dld-fcn.cc
--- a/src/ov-dld-fcn.cc
+++ b/src/ov-dld-fcn.cc
@@ -32,18 +32,18 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-dld-fcn.h"
 #include "ov.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_dld_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_dld_function,
-				     "dynamically-linked function",
-				     "dynamically-linked function");
+                                     "dynamically-linked function",
+                                     "dynamically-linked function");
 
 
 octave_dld_function::octave_dld_function
   (octave_builtin::fcn ff, const octave_shlib& shl,
    const std::string& nm, const std::string& ds)
   : octave_builtin (ff, nm, ds), sh_lib (shl)
 {
   mark_fcn_file_up_to_date (time_parsed ());
@@ -80,12 +80,12 @@ octave_dld_function::time_parsed (void) 
 //       (scalar deleting destructor) to objects created in a dynamic
 //       module, and this code will be executed in the dynamic module
 //       context at object deletion; unloading the dynamic module
 //       before objects have been deleted will make the "delete" code
 //       of objects to point to an invalid code segment.
 
 octave_dld_function*
 octave_dld_function::create (octave_builtin::fcn ff, const octave_shlib& shl,
-			     const std::string& nm, const std::string& ds)
+                             const std::string& nm, const std::string& ds)
 {
   return new octave_dld_function (ff, shl, nm, ds);
 }
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -60,53 +60,53 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 #include "ls-oct-ascii.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_fcn_handle);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_fcn_handle,
-				     "function handle",
-				     "function_handle");
+                                     "function handle",
+                                     "function_handle");
 
 const std::string octave_fcn_handle::anonymous ("@<anonymous>");
 
 octave_fcn_handle::octave_fcn_handle (const octave_value& f,
-				      const std::string& n)
+                                      const std::string& n)
   : fcn (f), nm (n)
 {
   octave_user_function *uf = fcn.user_function_value (true);
 
   if (uf && nm != anonymous)
     symbol_table::cache_name (uf->scope (), nm);
 }
 
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
-			    const std::list<octave_value_list>& idx,
-			    int nargout)
+                            const std::list<octave_value_list>& idx,
+                            int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
-	int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
+        int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
 
-	retval = do_multi_index_op (tmp_nargout, idx.front ());
+        retval = do_multi_index_op (tmp_nargout, idx.front ());
       }
       break;
 
     case '{':
     case '.':
       {
-	std::string tnm = type_name ();
-	error ("%s cannot be indexed with %c", tnm.c_str (), type[0]);
+        std::string tnm = type_name ();
+        error ("%s cannot be indexed with %c", tnm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME -- perhaps there should be an
@@ -175,159 +175,159 @@ octave_fcn_handle::do_multi_index_op (in
         error ("invalid function handle");
     }
 
   return retval;
 }
 
 bool
 octave_fcn_handle::set_fcn (const std::string &octaveroot, 
-			    const std::string& fpath)
+                            const std::string& fpath)
 {
   bool success = true;
 
   if (octaveroot.length () != 0
       && fpath.length () >= octaveroot.length ()
       && fpath.substr (0, octaveroot.length ()) == octaveroot
       && OCTAVE_EXEC_PREFIX != octaveroot)
     {
       // First check if just replacing matlabroot is enough
       std::string str = OCTAVE_EXEC_PREFIX + 
-	fpath.substr (octaveroot.length ());		    
+        fpath.substr (octaveroot.length ());                
       file_stat fs (str);
 
       if (fs.exists ())
-	{
-	  size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
+        {
+          size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
-	  std::string dir_name = str.substr (0, xpos);
+          std::string dir_name = str.substr (0, xpos);
 
-	  octave_function *xfcn
-	    = load_fcn_from_file (str, dir_name, "", nm);
+          octave_function *xfcn
+            = load_fcn_from_file (str, dir_name, "", nm);
 
-	  if (xfcn)
-	    {
-	      octave_value tmp (xfcn);
+          if (xfcn)
+            {
+              octave_value tmp (xfcn);
 
-	      fcn = octave_value (new octave_fcn_handle (tmp, nm));
-	    }
-	  else
-	    {
-	      error ("function handle points to non-existent function");
-	      success = false;
-	    }
-	}
+              fcn = octave_value (new octave_fcn_handle (tmp, nm));
+            }
+          else
+            {
+              error ("function handle points to non-existent function");
+              success = false;
+            }
+        }
       else
-	{
-	  // Next just search for it anywhere in the system path
-	  string_vector names(3);
-	  names(0) = nm + ".oct";
-	  names(1) = nm + ".mex";
-	  names(2) = nm + ".m";
+        {
+          // Next just search for it anywhere in the system path
+          string_vector names(3);
+          names(0) = nm + ".oct";
+          names(1) = nm + ".mex";
+          names(2) = nm + ".m";
 
-	  dir_path p (load_path::system_path ());
+          dir_path p (load_path::system_path ());
 
-	  str = octave_env::make_absolute (p.find_first_of (names));
+          str = octave_env::make_absolute (p.find_first_of (names));
 
-	  size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
+          size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
-	  std::string dir_name = str.substr (0, xpos);
+          std::string dir_name = str.substr (0, xpos);
 
-	  octave_function *xfcn = load_fcn_from_file (str, dir_name, "", nm);
+          octave_function *xfcn = load_fcn_from_file (str, dir_name, "", nm);
 
-	  if (xfcn)
-	    {
-	      octave_value tmp (xfcn);
+          if (xfcn)
+            {
+              octave_value tmp (xfcn);
 
-	      fcn = octave_value (new octave_fcn_handle (tmp, nm));
-	    }
-	  else
-	    {
-	      error ("function handle points to non-existent function");
-	      success = false;
-	    }
-	}
+              fcn = octave_value (new octave_fcn_handle (tmp, nm));
+            }
+          else
+            {
+              error ("function handle points to non-existent function");
+              success = false;
+            }
+        }
     }
   else
     {
       if (fpath.length () > 0)
-	{
-	  size_t xpos = fpath.find_last_of (file_ops::dir_sep_chars ());
+        {
+          size_t xpos = fpath.find_last_of (file_ops::dir_sep_chars ());
 
-	  std::string dir_name = fpath.substr (0, xpos);
+          std::string dir_name = fpath.substr (0, xpos);
 
-	  octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", nm);
+          octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", nm);
 
-	  if (xfcn)
-	    {
-	      octave_value tmp (xfcn);
+          if (xfcn)
+            {
+              octave_value tmp (xfcn);
 
-	      fcn = octave_value (new octave_fcn_handle (tmp, nm));
-	    }
-	  else
-	    {
-	      error ("function handle points to non-existent function");
-	      success = false;
-	    }
-	}
+              fcn = octave_value (new octave_fcn_handle (tmp, nm));
+            }
+          else
+            {
+              error ("function handle points to non-existent function");
+              success = false;
+            }
+        }
       else
-	{
-	  fcn = symbol_table::find_function (nm);
+        {
+          fcn = symbol_table::find_function (nm);
 
-	  if (! fcn.is_function ())
-	    {
-	      error ("function handle points to non-existent function");
-	      success = false;
-	    }
-	}
+          if (! fcn.is_function ())
+            {
+              error ("function handle points to non-existent function");
+              success = false;
+            }
+        }
     }
 
   return success;
 }
 
 bool
 octave_fcn_handle::save_ascii (std::ostream& os)
 {
   if (nm == anonymous)
     {
       os << nm << "\n";
 
       print_raw (os, true);
       os << "\n";
 
       if (fcn.is_undefined ())
-	return false;
+        return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
       std::list<symbol_table::symbol_record> vars
-	= symbol_table::all_variables (f->scope (), 0);
+        = symbol_table::all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
-	{
-	  os << "# length: " << varlen << "\n";
+        {
+          os << "# length: " << varlen << "\n";
 
-	  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-	       p != vars.end (); p++)
-	    {
-	      if (! save_ascii_data (os, p->varval (), p->name (), false, 0))
-		return os;
-	    }
-	}
+          for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+               p != vars.end (); p++)
+            {
+              if (! save_ascii_data (os, p->varval (), p->name (), false, 0))
+                return os;
+            }
+        }
     }
   else
     {
       octave_function *f = function_value ();
       std::string fnm = f ? f->fcn_file_name () : std::string ();
 
       os << "# octaveroot: " << OCTAVE_EXEC_PREFIX << "\n";
       if (! fnm.empty ())
-	os << "# path: " << fnm << "\n";
+        os << "# path: " << fnm << "\n";
       os << nm << "\n";
     }
 
   return true;
 }
 
 bool
 octave_fcn_handle::load_ascii (std::istream& is)
@@ -353,23 +353,23 @@ octave_fcn_handle::load_ascii (std::istr
 
   if (nm == anonymous)
     {
       skip_preceeding_newline (is);
 
       std::string buf;
 
       if (is)
-	{
+        {
 
-	  // Get a line of text whitespace characters included, leaving
-	  // newline in the stream.
-	  buf = read_until_newline (is, true);
+          // Get a line of text whitespace characters included, leaving
+          // newline in the stream.
+          buf = read_until_newline (is, true);
 
-	}
+        }
 
       pos = is.tellg ();
 
       unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
@@ -379,122 +379,122 @@ octave_fcn_handle::load_ascii (std::istr
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
       frame.add_fcn (octave_call_stack::pop);
 
       octave_idx_type len = 0;
 
       if (extract_keyword (is, "length", len, true) && len >= 0)
-	{
-	  if (len > 0)
-	    {
-	      for (octave_idx_type i = 0; i < len; i++)
-		{
-		  octave_value t2;
-		  bool dummy;
+        {
+          if (len > 0)
+            {
+              for (octave_idx_type i = 0; i < len; i++)
+                {
+                  octave_value t2;
+                  bool dummy;
 
-		  std::string name
-		    = read_ascii_data (is, std::string (), dummy, t2, i);
+                  std::string name
+                    = read_ascii_data (is, std::string (), dummy, t2, i);
 
-		  if (!is)
-		    {
-		      error ("load: failed to load anonymous function handle");
-		      break;
-		    }
+                  if (!is)
+                    {
+                      error ("load: failed to load anonymous function handle");
+                      break;
+                    }
 
-		  symbol_table::varref (name, local_scope, 0) = t2;
-		}
-	    }
-	}
+                  symbol_table::varref (name, local_scope, 0) = t2;
+                }
+            }
+        }
       else
-	{
-	  is.seekg (pos);
-	  is.clear ();
-	}
+        {
+          is.seekg (pos);
+          is.clear ();
+        }
 
       if (is && success)
-	{
-	  int parse_status;
-	  octave_value anon_fcn_handle = 
-	    eval_string (buf, true, parse_status);
+        {
+          int parse_status;
+          octave_value anon_fcn_handle = 
+            eval_string (buf, true, parse_status);
 
-	  if (parse_status == 0)
-	    {
-	      octave_fcn_handle *fh = 
-		anon_fcn_handle.fcn_handle_value ();
+          if (parse_status == 0)
+            {
+              octave_fcn_handle *fh = 
+                anon_fcn_handle.fcn_handle_value ();
 
-	      if (fh)
-		{
-		  fcn = fh->fcn;
+              if (fh)
+                {
+                  fcn = fh->fcn;
 
-		  octave_user_function *uf = fcn.user_function_value (true);
+                  octave_user_function *uf = fcn.user_function_value (true);
 
-		  if (uf)
-		    symbol_table::cache_name (uf->scope (), nm);
-		}
-	      else
-		success = false;
-	    }
-	  else
-	    success = false;
-	}
+                  if (uf)
+                    symbol_table::cache_name (uf->scope (), nm);
+                }
+              else
+                success = false;
+            }
+          else
+            success = false;
+        }
       else
-	success = false;
+        success = false;
     }
   else
     success = set_fcn (octaveroot, fpath);
 
   return success;
 }
 
 bool
 octave_fcn_handle::save_binary (std::ostream& os, bool& save_as_floats)
 {
   if (nm == anonymous)
     {
       std::ostringstream nmbuf;
 
       if (fcn.is_undefined ())
-	return false;
+        return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
       std::list<symbol_table::symbol_record> vars
-	= symbol_table::all_variables (f->scope (), 0);
+        = symbol_table::all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
-	nmbuf << nm << " " << varlen;
+        nmbuf << nm << " " << varlen;
       else
-	nmbuf << nm;
+        nmbuf << nm;
 
       std::string buf_str = nmbuf.str();
       int32_t tmp = buf_str.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (buf_str.c_str (), buf_str.length ());
 
       std::ostringstream buf;
       print_raw (buf, true);
       std::string stmp = buf.str ();
       tmp = stmp.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (stmp.c_str (), stmp.length ());
 
       if (varlen > 0)
-	{
-	  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-	       p != vars.end (); p++)
-	    {
-	      if (! save_binary_data (os, p->varval (), p->name (),
-				      "", 0, save_as_floats))
-		return os;
-	    }
-	}
+        {
+          for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+               p != vars.end (); p++)
+            {
+              if (! save_binary_data (os, p->varval (), p->name (),
+                                      "", 0, save_as_floats))
+                return os;
+            }
+        }
     }
   else
     {
       std::ostringstream nmbuf;
 
       octave_function *f = function_value ();
       std::string fnm = f ? f->fcn_file_name () : std::string ();
 
@@ -506,17 +506,17 @@ octave_fcn_handle::save_binary (std::ost
       os.write (buf_str.c_str (), buf_str.length ());
     }
 
   return true;
 }
 
 bool
 octave_fcn_handle::load_binary (std::istream& is, bool swap,
-				oct_mach_info::float_format fmt)
+                                oct_mach_info::float_format fmt)
 {
   bool success = true;
 
   int32_t tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
   if (swap)
     swap_bytes<4> (&tmp);
@@ -530,115 +530,115 @@ octave_fcn_handle::load_binary (std::ist
 
   size_t anl = anonymous.length ();
 
   if (nm.length() >= anl && nm.substr (0, anl) == anonymous)
     {
       octave_idx_type len = 0;
 
       if (nm.length() > anl)
-	{
-	  std::istringstream nm_is (nm.substr (anl));
-	  nm_is >> len;
-	  nm = nm.substr (0, anl);
-	}
+        {
+          std::istringstream nm_is (nm.substr (anl));
+          nm_is >> len;
+          nm = nm.substr (0, anl);
+        }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       is.get (ctmp2, tmp+1, 0);
 
       unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      frame.add_fcn (symbol_table::erase_scope, local_scope);	      
+      frame.add_fcn (symbol_table::erase_scope, local_scope);         
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
       frame.add_fcn (octave_call_stack::pop);
 
       if (len > 0)
-	{
-	  for (octave_idx_type i = 0; i < len; i++)
-	    {
-	      octave_value t2;
-	      bool dummy;
-	      std::string doc;
+        {
+          for (octave_idx_type i = 0; i < len; i++)
+            {
+              octave_value t2;
+              bool dummy;
+              std::string doc;
 
-	      std::string name = 
-		read_binary_data (is, swap, fmt, std::string (), 
-				  dummy, t2, doc);
+              std::string name = 
+                read_binary_data (is, swap, fmt, std::string (), 
+                                  dummy, t2, doc);
 
-	      if (!is)
-		{
-		  error ("load: failed to load anonymous function handle");
-		  break;
-		}
+              if (!is)
+                {
+                  error ("load: failed to load anonymous function handle");
+                  break;
+                }
 
-	      symbol_table::varref (name, local_scope) = t2;
-	    }
-	}
+              symbol_table::varref (name, local_scope) = t2;
+            }
+        }
 
       if (is && success)
-	{
-	  int parse_status;
-	  octave_value anon_fcn_handle = 
-	    eval_string (ctmp2, true, parse_status);
+        {
+          int parse_status;
+          octave_value anon_fcn_handle = 
+            eval_string (ctmp2, true, parse_status);
 
-	  if (parse_status == 0)
-	    {
-	      octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
+          if (parse_status == 0)
+            {
+              octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
-	      if (fh)
-		{
-		  fcn = fh->fcn;
+              if (fh)
+                {
+                  fcn = fh->fcn;
 
-		  octave_user_function *uf = fcn.user_function_value (true);
+                  octave_user_function *uf = fcn.user_function_value (true);
 
-		  if (uf)
-		    symbol_table::cache_name (uf->scope (), nm);
-		}
-	      else
-		success = false;
-	    }
-	  else
-	    success = false;
-	}
+                  if (uf)
+                    symbol_table::cache_name (uf->scope (), nm);
+                }
+              else
+                success = false;
+            }
+          else
+            success = false;
+        }
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
       if (nm.find_first_of ("\n") != std::string::npos)
-	{
-	  size_t pos1 = nm.find_first_of ("\n");
-	  size_t pos2 = nm.find_first_of ("\n", pos1 + 1);
-	  octaveroot = nm.substr (pos1 + 1, pos2 - pos1 - 1);
-	  fpath = nm.substr (pos2 + 1);
-	  nm = nm.substr (0, pos1);
-	}
+        {
+          size_t pos1 = nm.find_first_of ("\n");
+          size_t pos2 = nm.find_first_of ("\n", pos1 + 1);
+          octaveroot = nm.substr (pos1 + 1, pos2 - pos1 - 1);
+          fpath = nm.substr (pos2 + 1);
+          nm = nm.substr (0, pos1);
+        }
 
       success = set_fcn (octaveroot, fpath);
      }
  
  return success;
 }
 
 #if defined (HAVE_HDF5)
 bool
 octave_fcn_handle::save_hdf5 (hid_t loc_id, const char *name,
-			      bool save_as_floats)
+                              bool save_as_floats)
 {
   bool retval = true;
 
   hid_t group_hid = -1;
 #if HAVE_HDF5_18
   group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
@@ -664,22 +664,22 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				H5P_DEFAULT, nm.c_str ()) < 0)
+                                H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Dclose (data_hid);
 
@@ -687,172 +687,172 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
     {
       std::ostringstream buf;
       print_raw (buf, true);
       std::string stmp = buf.str ();
 
       // attach the type of the variable
       H5Tset_size (type_hid, stmp.length () + 1);
       if (type_hid < 0)
-	{
-	  H5Sclose (space_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Sclose (space_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
 #if HAVE_HDF5_18
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
-			    H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                            H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
-			    H5P_DEFAULT);
+                            H5P_DEFAULT);
 #endif
       if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				    H5P_DEFAULT, stmp.c_str ()) < 0)
-	{
-	  H5Sclose (space_hid);
-	  H5Tclose (type_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+                                    H5P_DEFAULT, stmp.c_str ()) < 0)
+        {
+          H5Sclose (space_hid);
+          H5Tclose (type_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       H5Dclose (data_hid);
 
       octave_user_function *f = fcn.user_function_value ();
 
       std::list<symbol_table::symbol_record> vars
-	= symbol_table::all_variables (f->scope (), 0);
+        = symbol_table::all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
-	{
-	  hid_t as_id = H5Screate (H5S_SCALAR);
+        {
+          hid_t as_id = H5Screate (H5S_SCALAR);
 
-	  if (as_id >= 0)
-	    {
+          if (as_id >= 0)
+            {
 #if HAVE_HDF5_18
-	      hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
-				      H5T_NATIVE_IDX, as_id, 
-				      H5P_DEFAULT, H5P_DEFAULT);
+              hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
+                                      H5T_NATIVE_IDX, as_id, 
+                                      H5P_DEFAULT, H5P_DEFAULT);
 
 #else
-	      hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
-				      H5T_NATIVE_IDX, as_id, H5P_DEFAULT);
+              hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
+                                      H5T_NATIVE_IDX, as_id, H5P_DEFAULT);
 #endif
 
-	      if (a_id >= 0)
-		{
-		  retval = (H5Awrite (a_id, H5T_NATIVE_IDX, &varlen) >= 0);
+              if (a_id >= 0)
+                {
+                  retval = (H5Awrite (a_id, H5T_NATIVE_IDX, &varlen) >= 0);
 
-		  H5Aclose (a_id);
-		}
-	      else
-		retval = false;
+                  H5Aclose (a_id);
+                }
+              else
+                retval = false;
 
-	      H5Sclose (as_id);
-	    }
-	  else
-	    retval = false;
+              H5Sclose (as_id);
+            }
+          else
+            retval = false;
 #if HAVE_HDF5_18
-	  data_hid = H5Gcreate (group_hid, "symbol table", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+          data_hid = H5Gcreate (group_hid, "symbol table", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-	  data_hid = H5Gcreate (group_hid, "symbol table", 0);
+          data_hid = H5Gcreate (group_hid, "symbol table", 0);
 #endif
-	  if (data_hid < 0) 
-	    {
-	      H5Sclose (space_hid);
-	      H5Tclose (type_hid);
-	      H5Gclose (group_hid);
-	      return false;
-	    }
+          if (data_hid < 0) 
+            {
+              H5Sclose (space_hid);
+              H5Tclose (type_hid);
+              H5Gclose (group_hid);
+              return false;
+            }
 
-	  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-	       p != vars.end (); p++)
-	    {
-	      if (! add_hdf5_data (data_hid, p->varval (), p->name (),
-				   "", false, save_as_floats))
-		break;
-	    }
-	  H5Gclose (data_hid);
-	}
+          for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+               p != vars.end (); p++)
+            {
+              if (! add_hdf5_data (data_hid, p->varval (), p->name (),
+                                   "", false, save_as_floats))
+                break;
+            }
+          H5Gclose (data_hid);
+        }
     }
   else
     {
       std::string octaveroot = OCTAVE_EXEC_PREFIX;
 
       octave_function *f = function_value ();
       std::string fpath = f ? f->fcn_file_name () : std::string ();
 
       H5Sclose (space_hid);
       hdims[0] = 1;
       hdims[1] = octaveroot.length ();
       space_hid = H5Screate_simple (0 , hdims, 0);
       if (space_hid < 0)
-	{
-	  H5Tclose (type_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Tclose (type_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       H5Tclose (type_hid);
       type_hid = H5Tcopy (H5T_C_S1);
       H5Tset_size (type_hid, octaveroot.length () + 1);
 #if HAVE_HDF5_18
       hid_t a_id = H5Acreate (group_hid, "OCTAVEROOT",
-			      type_hid, space_hid, H5P_DEFAULT, H5P_DEFAULT);
+                              type_hid, space_hid, H5P_DEFAULT, H5P_DEFAULT);
 #else
       hid_t a_id = H5Acreate (group_hid, "OCTAVEROOT",
-			      type_hid, space_hid, H5P_DEFAULT);
+                              type_hid, space_hid, H5P_DEFAULT);
 #endif
 
       if (a_id >= 0)
-	{
-	  retval = (H5Awrite (a_id, type_hid, octaveroot.c_str ()) >= 0);
+        {
+          retval = (H5Awrite (a_id, type_hid, octaveroot.c_str ()) >= 0);
 
-	  H5Aclose (a_id);
-	}
+          H5Aclose (a_id);
+        }
       else
-	{
-	  H5Sclose (space_hid);
-	  H5Tclose (type_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Sclose (space_hid);
+          H5Tclose (type_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       H5Sclose (space_hid);
       hdims[0] = 1;
       hdims[1] = fpath.length ();
       space_hid = H5Screate_simple (0 , hdims, 0);
       if (space_hid < 0)
-	{
-	  H5Tclose (type_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Tclose (type_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       H5Tclose (type_hid);
       type_hid = H5Tcopy (H5T_C_S1);
       H5Tset_size (type_hid, fpath.length () + 1);
 
 #if HAVE_HDF5_18
       a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid, 
-      			H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT);
 #else
       a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid, H5P_DEFAULT);
 #endif
 
       if (a_id >= 0)
-	{
-	  retval = (H5Awrite (a_id, type_hid, fpath.c_str ()) >= 0);
+        {
+          retval = (H5Awrite (a_id, type_hid, fpath.c_str ()) >= 0);
 
-	  H5Aclose (a_id);
-	}
+          H5Aclose (a_id);
+        }
       else
-	retval = false;
+        retval = false;
     }
 
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
@@ -942,74 +942,74 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
     {
 #if HAVE_HDF5_18
       data_hid = H5Dopen (group_hid, "fcn", H5P_DEFAULT);
 #else
       data_hid = H5Dopen (group_hid, "fcn");
 #endif
 
       if (data_hid < 0)
-	{
-	  H5Sclose (space_hid);
-	  H5Tclose (type_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Sclose (space_hid);
+          H5Tclose (type_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       H5Tclose (type_hid);
       type_hid = H5Dget_type (data_hid);
       type_class_hid = H5Tget_class (type_hid);
 
       if (type_class_hid != H5T_STRING)
-	{
-	  H5Sclose (space_hid);
-	  H5Tclose (type_hid);
-	  H5Dclose (data_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Sclose (space_hid);
+          H5Tclose (type_hid);
+          H5Dclose (data_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       H5Sclose (space_hid);
       space_hid = H5Dget_space (data_hid);
       rank = H5Sget_simple_extent_ndims (space_hid);
 
       if (rank != 0)
-	{
-	  H5Sclose (space_hid);
-	  H5Tclose (type_hid);
-	  H5Dclose (data_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Sclose (space_hid);
+          H5Tclose (type_hid);
+          H5Dclose (data_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       slen = H5Tget_size (type_hid);
       if (slen < 0)
-	{
-	  H5Sclose (space_hid);
-	  H5Tclose (type_hid);
-	  H5Dclose (data_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Sclose (space_hid);
+          H5Tclose (type_hid);
+          H5Dclose (data_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
 
       OCTAVE_LOCAL_BUFFER (char, fcn_tmp, slen);
 
       // create datatype for (null-terminated) string to read into:
       st_id = H5Tcopy (H5T_C_S1);
       H5Tset_size (st_id, slen);
 
       if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, fcn_tmp) < 0)
-	{
-	  H5Tclose (st_id);
-	  H5Sclose (space_hid);
-	  H5Tclose (type_hid);
-	  H5Dclose (data_hid);
-	  H5Gclose (group_hid);
-	  return false;
-	}
+        {
+          H5Tclose (st_id);
+          H5Sclose (space_hid);
+          H5Tclose (type_hid);
+          H5Dclose (data_hid);
+          H5Gclose (group_hid);
+          return false;
+        }
       H5Tclose (st_id);
       H5Dclose (data_hid);
 
       octave_idx_type len = 0;
 
       // we have to pull some shenanigans here to make sure
       // HDF5 doesn't print out all sorts of error messages if we
       // call H5Aopen for a non-existing attribute
@@ -1025,22 +1025,22 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 #else
       H5Eget_auto (&err_func, &err_func_data);
       H5Eset_auto (0, 0);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "SYMBOL_TABLE");
 
       if (attr_id >= 0)
-	{
-	  if (H5Aread (attr_id, H5T_NATIVE_IDX, &len) < 0)
-	    success = false;
+        {
+          if (H5Aread (attr_id, H5T_NATIVE_IDX, &len) < 0)
+            success = false;
 
-	  H5Aclose (attr_id);
-	}
+          H5Aclose (attr_id);
+        }
 
       // restore error reporting:
 #if HAVE_HDF5_18
       H5Eset_auto (H5E_DEFAULT, err_func, err_func_data);
 #else
       H5Eset_auto (err_func, err_func_data);
 #endif
 
@@ -1053,76 +1053,76 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
       frame.add_fcn (octave_call_stack::pop);
 
       if (len > 0 && success)
-	{
-	  hsize_t num_obj = 0;
+        {
+          hsize_t num_obj = 0;
 #if HAVE_HDF5_18
-	  data_hid = H5Gopen (group_hid, "symbol table", H5P_DEFAULT); 
+          data_hid = H5Gopen (group_hid, "symbol table", H5P_DEFAULT); 
 #else
-	  data_hid = H5Gopen (group_hid, "symbol table"); 
+          data_hid = H5Gopen (group_hid, "symbol table"); 
 #endif
-	  H5Gget_num_objs (data_hid, &num_obj);
-	  H5Gclose (data_hid);
+          H5Gget_num_objs (data_hid, &num_obj);
+          H5Gclose (data_hid);
 
-	  if (num_obj != static_cast<hsize_t>(len))
-	    {
-	      error ("load: failed to load anonymous function handle");
-	      success = false;
-	    }
+          if (num_obj != static_cast<hsize_t>(len))
+            {
+              error ("load: failed to load anonymous function handle");
+              success = false;
+            }
 
-	  if (! error_state)
-	    {
-	      hdf5_callback_data dsub;
-	      int current_item = 0;
-	      for (octave_idx_type i = 0; i < len; i++)
-		{
-		  if (H5Giterate (group_hid, "symbol table", &current_item,
-				  hdf5_read_next_data, &dsub) <= 0)
-		    {
-		      error ("load: failed to load anonymous function handle");
-		      success = false;
-		      break;
-		    }
+          if (! error_state)
+            {
+              hdf5_callback_data dsub;
+              int current_item = 0;
+              for (octave_idx_type i = 0; i < len; i++)
+                {
+                  if (H5Giterate (group_hid, "symbol table", &current_item,
+                                  hdf5_read_next_data, &dsub) <= 0)
+                    {
+                      error ("load: failed to load anonymous function handle");
+                      success = false;
+                      break;
+                    }
 
-		  symbol_table::varref (dsub.name, local_scope) = dsub.tc;
-		}
-	    }
-	}
+                  symbol_table::varref (dsub.name, local_scope) = dsub.tc;
+                }
+            }
+        }
 
       if (success)
-	{
-	  int parse_status;
-	  octave_value anon_fcn_handle = 
-	    eval_string (fcn_tmp, true, parse_status);
+        {
+          int parse_status;
+          octave_value anon_fcn_handle = 
+            eval_string (fcn_tmp, true, parse_status);
 
-	  if (parse_status == 0)
-	    {
-	      octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
+          if (parse_status == 0)
+            {
+              octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
-	      if (fh)
-		{
-		  fcn = fh->fcn;
+              if (fh)
+                {
+                  fcn = fh->fcn;
 
-		  octave_user_function *uf = fcn.user_function_value (true);
+                  octave_user_function *uf = fcn.user_function_value (true);
 
-		  if (uf)
-		    symbol_table::cache_name (uf->scope (), nm);
-		}
-	      else
-		success = false;
-	    }
-	  else
-	    success = false;
-	}
+                  if (uf)
+                    symbol_table::cache_name (uf->scope (), nm);
+                }
+              else
+                success = false;
+            }
+          else
+            success = false;
+        }
 
       frame.run ();
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
@@ -1140,70 +1140,70 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       H5Eset_auto (H5E_DEFAULT, 0, 0);
 #else
       H5Eget_auto (&err_func, &err_func_data);
       H5Eset_auto (0, 0);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "OCTAVEROOT");
       if (attr_id >= 0)
-	{
-	  H5Tclose (type_hid);
-	  type_hid = H5Aget_type (attr_id);
-	  type_class_hid = H5Tget_class (type_hid);
+        {
+          H5Tclose (type_hid);
+          type_hid = H5Aget_type (attr_id);
+          type_class_hid = H5Tget_class (type_hid);
 
-	  if (type_class_hid != H5T_STRING)
-	    success = false;
-	  else
-	    {
-	      slen = H5Tget_size (type_hid);
-	      st_id = H5Tcopy (H5T_C_S1);
-	      H5Tset_size (st_id, slen);
-	      OCTAVE_LOCAL_BUFFER (char, root_tmp, slen);
+          if (type_class_hid != H5T_STRING)
+            success = false;
+          else
+            {
+              slen = H5Tget_size (type_hid);
+              st_id = H5Tcopy (H5T_C_S1);
+              H5Tset_size (st_id, slen);
+              OCTAVE_LOCAL_BUFFER (char, root_tmp, slen);
 
-	      if (H5Aread (attr_id, st_id, root_tmp) < 0)
-		success = false;
-	      else
-		octaveroot = root_tmp;
+              if (H5Aread (attr_id, st_id, root_tmp) < 0)
+                success = false;
+              else
+                octaveroot = root_tmp;
 
-	      H5Tclose (st_id);
-	    }
+              H5Tclose (st_id);
+            }
 
-	  H5Aclose (attr_id);
-	}
+          H5Aclose (attr_id);
+        }
 
       if (success)
-	{
-	  attr_id = H5Aopen_name (group_hid, "FILE");
-	  if (attr_id >= 0)
-	    {
-	      H5Tclose (type_hid);
-	      type_hid = H5Aget_type (attr_id);
-	      type_class_hid = H5Tget_class (type_hid);
+        {
+          attr_id = H5Aopen_name (group_hid, "FILE");
+          if (attr_id >= 0)
+            {
+              H5Tclose (type_hid);
+              type_hid = H5Aget_type (attr_id);
+              type_class_hid = H5Tget_class (type_hid);
 
-	      if (type_class_hid != H5T_STRING)
-		success = false;
-	      else
-		{
-		  slen = H5Tget_size (type_hid);
-		  st_id = H5Tcopy (H5T_C_S1);
-		  H5Tset_size (st_id, slen);
-		  OCTAVE_LOCAL_BUFFER (char, path_tmp, slen);
+              if (type_class_hid != H5T_STRING)
+                success = false;
+              else
+                {
+                  slen = H5Tget_size (type_hid);
+                  st_id = H5Tcopy (H5T_C_S1);
+                  H5Tset_size (st_id, slen);
+                  OCTAVE_LOCAL_BUFFER (char, path_tmp, slen);
 
-		  if (H5Aread (attr_id, st_id, path_tmp) < 0)
-		    success = false;
-		  else
-		    fpath = path_tmp;
+                  if (H5Aread (attr_id, st_id, path_tmp) < 0)
+                    success = false;
+                  else
+                    fpath = path_tmp;
 
-		  H5Tclose (st_id);
-		}
+                  H5Tclose (st_id);
+                }
 
-	      H5Aclose (attr_id);
-	    }
-	}
+              H5Aclose (attr_id);
+            }
+        }
 
       // restore error reporting:
 #if HAVE_HDF5_18
       H5Eset_auto (H5E_DEFAULT, err_func, err_func_data);
 #else
       H5Eset_auto (err_func, err_func_data);
 #endif
 
@@ -1275,61 +1275,61 @@ octave_fcn_handle::print_raw (std::ostre
       // FCN is const because this member function is, so we can't
       // use it to call user_function_value, so we make a copy first.
 
       octave_value ftmp = fcn;
 
       octave_user_function *f = ftmp.user_function_value ();
 
       if (f)
-	{
-	  tree_parameter_list *p = f->parameter_list ();
+        {
+          tree_parameter_list *p = f->parameter_list ();
 
-	  os << "@(";
+          os << "@(";
 
-	  if (p)
-	    p->accept (tpc);
+          if (p)
+            p->accept (tpc);
 
-	  os << ") ";
+          os << ") ";
 
-	  tree_statement_list *b = f->body ();
+          tree_statement_list *b = f->body ();
 
-	  if (b)
-	    {
-	      assert (b->length () == 1);
+          if (b)
+            {
+              assert (b->length () == 1);
 
-	      tree_statement *s = b->front ();
+              tree_statement *s = b->front ();
 
-	      if (s)
-		{
-		  if (s->is_expression ())
-		    {
-		      tree_expression *e = s->expression ();
+              if (s)
+                {
+                  if (s->is_expression ())
+                    {
+                      tree_expression *e = s->expression ();
 
-		      if (e)
-			e->accept (tpc);
-		    }
-		  else
-		    {
-		      tree_command *c = s->command ();
+                      if (e)
+                        e->accept (tpc);
+                    }
+                  else
+                    {
+                      tree_command *c = s->command ();
 
-		      tpc.suspend_newline ();
-		      c->accept (tpc);
-		      tpc.resume_newline ();
-		    }
-		}
-	    }
+                      tpc.suspend_newline ();
+                      c->accept (tpc);
+                      tpc.resume_newline ();
+                    }
+                }
+            }
 
-	  printed = true;
-	}
+          printed = true;
+        }
     }
 
   if (! printed)
     octave_print_internal (os, "@" + nm, pr_as_read_syntax,
-			   current_print_indent_level ());
+                           current_print_indent_level ());
 }
 
 octave_value
 make_fcn_handle (const std::string& nm, bool local_funcs)
 {
   octave_value retval;
 
   // Bow to the god of compatibility.
@@ -1343,126 +1343,126 @@ make_fcn_handle (const std::string& nm, 
 
   size_t len = nm.length ();
 
   if (len == 3 && nm == ".**")
     tnm = "power";
   else if (len == 2)
     {
       if (nm[0] == '.')
-	{
-	  switch (nm[1])
-	    {
-	    case '\'':
-	      tnm = "transpose";
-	      break;
+        {
+          switch (nm[1])
+            {
+            case '\'':
+              tnm = "transpose";
+              break;
 
-	    case '+':
-	      tnm = "plus";
-	      break;
+            case '+':
+              tnm = "plus";
+              break;
 
-	    case '-':
-	      tnm = "minus";
-	      break;
+            case '-':
+              tnm = "minus";
+              break;
 
-	    case '*':
-	      tnm = "times";
-	      break;
+            case '*':
+              tnm = "times";
+              break;
 
-	    case '/':
-	      tnm = "rdivide";
-	      break;
+            case '/':
+              tnm = "rdivide";
+              break;
 
-	    case '^':
-	      tnm = "power";
-	      break;
+            case '^':
+              tnm = "power";
+              break;
 
-	    case '\\':
-	      tnm = "ldivide";
-	      break;
-	    }
-	}
+            case '\\':
+              tnm = "ldivide";
+              break;
+            }
+        }
       else if (nm[1] == '=')
-	{
-	  switch (nm[0])
-	    {
-	    case '<':
-	      tnm = "le";
-	      break;
+        {
+          switch (nm[0])
+            {
+            case '<':
+              tnm = "le";
+              break;
 
-	    case '=':
-	      tnm = "eq";
-	      break;
+            case '=':
+              tnm = "eq";
+              break;
 
-	    case '>':
-	      tnm = "ge";
-	      break;
+            case '>':
+              tnm = "ge";
+              break;
 
-	    case '~':
-	    case '!':
-	      tnm = "ne";
-	      break;
-	    }
-	}
+            case '~':
+            case '!':
+              tnm = "ne";
+              break;
+            }
+        }
       else if (nm == "**")
-	tnm = "mpower";
+        tnm = "mpower";
     }
   else if (len == 1)
     {
       switch (nm[0])
-	{
-	case '~':
-	case '!':
-	  tnm = "not";
-	  break;
+        {
+        case '~':
+        case '!':
+          tnm = "not";
+          break;
 
-	case '\'':
-	  tnm = "ctranspose";
-	  break;
+        case '\'':
+          tnm = "ctranspose";
+          break;
 
-	case '+':
-	  tnm = "plus";
-	  break;
+        case '+':
+          tnm = "plus";
+          break;
 
-	case '-':
-	  tnm = "minus";
-	  break;
+        case '-':
+          tnm = "minus";
+          break;
 
-	case '*':
-	  tnm = "mtimes";
-	  break;
+        case '*':
+          tnm = "mtimes";
+          break;
 
-	case '/':
-	  tnm = "mrdivide";
-	  break;
+        case '/':
+          tnm = "mrdivide";
+          break;
 
-	case '^':
-	  tnm = "mpower";
-	  break;
+        case '^':
+          tnm = "mpower";
+          break;
 
-	case '\\':
-	  tnm = "mldivide";
-	  break;
+        case '\\':
+          tnm = "mldivide";
+          break;
 
-	case '<':
-	  tnm = "lt";
-	  break;
+        case '<':
+          tnm = "lt";
+          break;
 
-	case '>':
-	  tnm = "gt";
-	  break;
+        case '>':
+          tnm = "gt";
+          break;
 
-	case '&':
-	  tnm = "and";
-	  break;
+        case '&':
+          tnm = "and";
+          break;
 
-	case '|':
-	  tnm = "or";
-	  break;
-	}
+        case '|':
+          tnm = "or";
+          break;
+        }
     }
 
   bool handle_ok = false;
   octave_value f = symbol_table::find_function (tnm, octave_value_list (),
                                                 local_funcs);
 
   if (f.is_undefined ())
     {
@@ -1553,93 +1553,93 @@ Return a struct containing information a
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_fcn_handle *fh = args(0).fcn_handle_value ();
 
       if (! error_state)
-	{
-	  octave_function *fcn = fh ? fh->function_value () : 0;
+        {
+          octave_function *fcn = fh ? fh->function_value () : 0;
 
-	  if (fcn)
-	    {
-	      Octave_map m;
+          if (fcn)
+            {
+              Octave_map m;
 
-	      std::string fh_nm = fh->fcn_name ();
+              std::string fh_nm = fh->fcn_name ();
 
-	      if (fh_nm == octave_fcn_handle::anonymous)
-		{
-		  std::ostringstream buf;
-		  fh->print_raw (buf);
-		  m.assign ("function", buf.str ());
+              if (fh_nm == octave_fcn_handle::anonymous)
+                {
+                  std::ostringstream buf;
+                  fh->print_raw (buf);
+                  m.assign ("function", buf.str ());
 
-		  m.assign ("type", "anonymous");
-		}
-	      else
-		{
-		  m.assign ("function", fh_nm);
+                  m.assign ("type", "anonymous");
+                }
+              else
+                {
+                  m.assign ("function", fh_nm);
 
-		  if (fcn->is_nested_function ())
-		    {
-		      m.assign ("type", "subfunction");
-		      Cell parentage (dim_vector (1, 2));
-		      parentage.elem(0) = fh_nm;
-		      parentage.elem(1) = fcn->parent_fcn_name ();
-		      m.assign ("parentage", octave_value (parentage)); 
-		    }
+                  if (fcn->is_nested_function ())
+                    {
+                      m.assign ("type", "subfunction");
+                      Cell parentage (dim_vector (1, 2));
+                      parentage.elem(0) = fh_nm;
+                      parentage.elem(1) = fcn->parent_fcn_name ();
+                      m.assign ("parentage", octave_value (parentage)); 
+                    }
                   else if (fcn->is_private_function ())
-		    m.assign ("type", "private");
+                    m.assign ("type", "private");
                   else if (fh->is_overloaded ())
-		    m.assign ("type", "overloaded");
-		  else
-		    m.assign ("type", "simple");
-		}
+                    m.assign ("type", "overloaded");
+                  else
+                    m.assign ("type", "simple");
+                }
 
-	      std::string nm = fcn->fcn_file_name ();
+              std::string nm = fcn->fcn_file_name ();
 
-	      if (fh_nm == octave_fcn_handle::anonymous)
-		{
-		  m.assign ("file", nm);
+              if (fh_nm == octave_fcn_handle::anonymous)
+                {
+                  m.assign ("file", nm);
 
-		  octave_user_function *fu = fh->user_function_value ();
+                  octave_user_function *fu = fh->user_function_value ();
 
-		  std::list<symbol_table::symbol_record> vars
-		    = symbol_table::all_variables (fu->scope (), 0);
+                  std::list<symbol_table::symbol_record> vars
+                    = symbol_table::all_variables (fu->scope (), 0);
 
-		  size_t varlen = vars.size ();
+                  size_t varlen = vars.size ();
 
-		  if (varlen > 0)
-		    {
-		      Octave_map ws;
-		      for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-			   p != vars.end (); p++)
-			{
-			  ws.assign (p->name (), p->varval (0));
-			}
+                  if (varlen > 0)
+                    {
+                      Octave_map ws;
+                      for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+                           p != vars.end (); p++)
+                        {
+                          ws.assign (p->name (), p->varval (0));
+                        }
 
-		      m.assign ("workspace", ws);
-		    }
-		}
-	      else if (fcn->is_user_function () || fcn->is_user_script ())
-		{
-		  octave_function *fu = fh->function_value ();
-		  m.assign ("file", fu->fcn_file_name ());
-		}
-	      else
-		m.assign ("file", "");
+                      m.assign ("workspace", ws);
+                    }
+                }
+              else if (fcn->is_user_function () || fcn->is_user_script ())
+                {
+                  octave_function *fu = fh->function_value ();
+                  m.assign ("file", fu->fcn_file_name ());
+                }
+              else
+                m.assign ("file", "");
 
-	      retval = m;
-	    }
-	  else
-	    error ("functions: invalid function handle object");
-	}
+              retval = m;
+            }
+          else
+            error ("functions: invalid function handle object");
+        }
       else
-	error ("functions: argument must be a function handle object");
+        error ("functions: argument must be a function handle object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
@@ -1651,32 +1651,32 @@ the function handle @var{fcn_handle}.\n\
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_fcn_handle *fh = args(0).fcn_handle_value ();
 
       if (! error_state && fh)
-	{
-	  std::string fh_nm = fh->fcn_name ();
+        {
+          std::string fh_nm = fh->fcn_name ();
 
-	  if (fh_nm == octave_fcn_handle::anonymous)
-	    {
-	      std::ostringstream buf;
+          if (fh_nm == octave_fcn_handle::anonymous)
+            {
+              std::ostringstream buf;
 
-	      fh->print_raw (buf);
+              fh->print_raw (buf);
 
-	      retval = buf.str ();
-	    }
-	  else
-	    retval = fh_nm;
-	}
+              retval = buf.str ();
+            }
+          else
+            retval = fh_nm;
+        }
       else
-	error ("func2str: expecting valid function handle as first argument");
+        error ("func2str: expecting valid function handle as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
@@ -1691,19 +1691,19 @@ are ignored in the lookup.\n\
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string nm = args(0).string_value ();
 
       if (! error_state)
-	retval = make_fcn_handle (nm, nargin != 2);
+        retval = make_fcn_handle (nm, nargin != 2);
       else
-	error ("str2func: expecting string as first argument");
+        error ("str2func: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -51,69 +51,69 @@ Open Source Initiative (www.opensource.o
 #include "ls-ascii-helper.h"
 #include "ls-oct-ascii.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_fcn_inline);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_fcn_inline,
-				     "inline function",
-				     "function_handle");
+                                     "inline function",
+                                     "function_handle");
 
 octave_fcn_inline::octave_fcn_inline (const std::string& f,
-				      const string_vector& a,
-				      const std::string& n)
+                                      const string_vector& a,
+                                      const std::string& n)
   : octave_fcn_handle (n), iftext (f), ifargs (a)
 {
   // Form a string representing the function.
 
   std::ostringstream buf;
 
   buf << "@(";
 
   for (int i = 0; i < ifargs.length (); i++)
     {
       if (i > 0)
-	buf << ", ";
+        buf << ", ";
 
       buf << ifargs(i);
     }
 
   buf << ") " << iftext;
 
   int parse_status;
   octave_value anon_fcn_handle = eval_string (buf.str (), true, parse_status);
 
   if (parse_status == 0)
     {
       octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
       if (fh)
-	{
-	  fcn = fh->fcn_val ();
+        {
+          fcn = fh->fcn_val ();
 
-	  octave_user_function *uf = fcn.user_function_value ();
+          octave_user_function *uf = fcn.user_function_value ();
 
-	  if (uf)
-	    {
-	      octave_function *curr_fcn = octave_call_stack::current ();
+          if (uf)
+            {
+              octave_function *curr_fcn = octave_call_stack::current ();
 
-	      if (curr_fcn)
-		{
-		  symbol_table::scope_id parent_scope
-		    = curr_fcn->parent_fcn_scope ();
+              if (curr_fcn)
+                {
+                  symbol_table::scope_id parent_scope
+                    = curr_fcn->parent_fcn_scope ();
 
-		  if (parent_scope < 0)
-		    parent_scope = curr_fcn->scope ();
-	
-		  uf->stash_parent_fcn_scope (parent_scope);
-		}
-	    }
-	}
+                  if (parent_scope < 0)
+                    parent_scope = curr_fcn->scope ();
+        
+                  uf->stash_parent_fcn_scope (parent_scope);
+                }
+            }
+        }
     }
 
   if (fcn.is_undefined ())
     error ("inline: unable to define function");
 }
 
 // This function is supplied to allow a Matlab style class structure
 // to be returned..
@@ -153,32 +153,32 @@ octave_fcn_inline::save_ascii (std::ostr
 bool
 octave_fcn_inline::load_ascii (std::istream& is)
 {
   int nargs;
   if (extract_keyword (is, "nargs", nargs, true))
     {
       ifargs.resize (nargs);
       for (int i = 0; i < nargs; i++)
-	is >> ifargs(i);
+        is >> ifargs(i);
       is >> nm;
       if (nm == "0")
-	nm = "";
+        nm = "";
 
       skip_preceeding_newline (is);
 
       std::string buf;
 
       if (is)
-	{
+        {
 
-	  // Get a line of text whitespace characters included,
-	  // leaving newline in the stream.
-	  buf = read_until_newline (is, true);
-	}
+          // Get a line of text whitespace characters included,
+          // leaving newline in the stream.
+          buf = read_until_newline (is, true);
+        }
 
       iftext = buf;
 
       octave_fcn_inline tmp (iftext, ifargs, nm);
       fcn = tmp.fcn;
 
       return true;
     }
@@ -203,79 +203,79 @@ octave_fcn_inline::save_binary (std::ost
   tmp = iftext.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   os.write (iftext.c_str (), iftext.length ());
   return true;
 }
 
 bool
 octave_fcn_inline::load_binary (std::istream& is, bool swap,
-				oct_mach_info::float_format)
+                                oct_mach_info::float_format)
 {
   int32_t nargs;
   if (! is.read (reinterpret_cast<char *> (&nargs), 4))
     return false;
   if (swap)
     swap_bytes<4> (&nargs);
 
   if (nargs < 1)
     return false;
   else
     {
       int32_t tmp;
       ifargs.resize (nargs);
       for (int i = 0; i < nargs; i++)
-	{
-	  if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	    return false;
-	  if (swap)
-	    swap_bytes<4> (&tmp);
+        {
+          if (! is.read (reinterpret_cast<char *> (&tmp), 4))
+            return false;
+          if (swap)
+            swap_bytes<4> (&tmp);
 
-	  OCTAVE_LOCAL_BUFFER (char, ctmp, tmp+1);
-	  is.read (ctmp, tmp);
-	  ifargs(i) = std::string (ctmp);
+          OCTAVE_LOCAL_BUFFER (char, ctmp, tmp+1);
+          is.read (ctmp, tmp);
+          ifargs(i) = std::string (ctmp);
 
-	  if (! is)
-	    return false;
-	}
+          if (! is)
+            return false;
+        }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp1, tmp+1);
       is.read (ctmp1, tmp);
       nm = std::string (ctmp1);
 
       if (! is)
-	return false;
+        return false;
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       is.read (ctmp2, tmp);
       iftext = std::string (ctmp2);
 
       if (! is)
-	return false;
+        return false;
 
       octave_fcn_inline ftmp (iftext, ifargs, nm);
       fcn = ftmp.fcn;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
 bool
 octave_fcn_inline::save_hdf5 (hid_t loc_id, const char *name,
-			      bool /* save_as_floats */)
+                              bool /* save_as_floats */)
 {
   hid_t group_hid = -1;
 #if HAVE_HDF5_18
   group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0 ) return false;
@@ -300,41 +300,41 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   space_hid = H5Screate_simple (2, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "args", H5T_NATIVE_CHAR, space_hid,
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "args", H5T_NATIVE_CHAR, space_hid,
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (char, s, ifargs.length () * (len + 1));
 
   // Save the args as a null teminated list
   for (int i = 0; i < ifargs.length (); i++)
     {
       const char * cptr = ifargs(i).c_str ();
       for (size_t j = 0; j < ifargs(i).length (); j++)
-	s[i*(len+1)+j] = *cptr++;
+        s[i*(len+1)+j] = *cptr++;
       s[ifargs(i).length ()] = '\0';
     }
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, s) >= 0;
+                     H5P_DEFAULT, s) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   if (!retval)
     {
       H5Gclose (group_hid);
       return false;
@@ -354,22 +354,22 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				H5P_DEFAULT, nm.c_str ()) < 0)
+                                H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Dclose (data_hid);
 
@@ -378,23 +378,23 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   if (type_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				H5P_DEFAULT, iftext.c_str ()) < 0)
+                                H5P_DEFAULT, iftext.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -440,17 +440,17 @@ octave_fcn_inline::load_hdf5 (hid_t loc_
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
   ifargs.resize (hdims[1]);
 
   OCTAVE_LOCAL_BUFFER (char, s1, hdims[0] * hdims[1]);
 
   if (H5Dread (data_hid, H5T_NATIVE_UCHAR, H5S_ALL, H5S_ALL,
-	       H5P_DEFAULT, s1) < 0)
+               H5P_DEFAULT, s1) < 0)
     {
       H5Dclose (data_hid);
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -605,25 +605,25 @@ octave_fcn_inline::print_raw (std::ostre
   if (nm.empty ())
     buf << "f(";
   else
     buf << nm << "(";
 
   for (int i = 0; i < ifargs.length (); i++)
     {
       if (i)
-	buf << ", ";
+        buf << ", ";
 
       buf << ifargs(i);
     }
 
   buf << ") = " << iftext;
 
   octave_print_internal (os, buf.str (), pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 octave_value
 octave_fcn_inline::convert_to_str_internal (bool, bool, char type) const
 {
   return octave_value (fcn_text (), type);
 }
 
@@ -653,147 +653,147 @@ If the second argument is an integer @va
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       std::string fun = args(0).string_value ();
 
       if (! error_state)
-	{
-	  string_vector fargs;
+        {
+          string_vector fargs;
 
-	  if (nargin == 1)
-	    {
-	      bool is_arg = false;
-	      bool in_string = false;
-	      std::string tmp_arg;
-	      size_t i = 0;
-	      
-	      while (i < fun.length ())
-		{
-		  bool terminate_arg = false;
-		  char c = fun[i++];
+          if (nargin == 1)
+            {
+              bool is_arg = false;
+              bool in_string = false;
+              std::string tmp_arg;
+              size_t i = 0;
+              
+              while (i < fun.length ())
+                {
+                  bool terminate_arg = false;
+                  char c = fun[i++];
 
-		  if (in_string)
-		    {
-		      if (c == '\'' || c == '\"')
-			in_string = false;
-		    }
-		  else if (c == '\'' || c == '\"')
-		    {
-		      in_string = true;
-		      if (is_arg)
-			terminate_arg = true;
-		    }
-		  else if (! isalpha (c) && c != '_')
-		    if (! is_arg)
-		      continue;
-		    else if (isdigit (c))
-		      tmp_arg.append (1, c);
-		    else
-		      {
-			// Before we do anything remove trailing whitespaces.
-			while (i < fun.length () && isspace (c))
-			  c = fun[i++];
-			
-			// Do we have a variable or a function?
-			if (c != '(')
-			  terminate_arg = true;
-			else
-			  {
-			    tmp_arg = std::string ();
-			    is_arg = false;
-			  }
-		      }
-		  else
-		    {
-		      tmp_arg.append (1, c);
-		      is_arg = true;
-		    }
+                  if (in_string)
+                    {
+                      if (c == '\'' || c == '\"')
+                        in_string = false;
+                    }
+                  else if (c == '\'' || c == '\"')
+                    {
+                      in_string = true;
+                      if (is_arg)
+                        terminate_arg = true;
+                    }
+                  else if (! isalpha (c) && c != '_')
+                    if (! is_arg)
+                      continue;
+                    else if (isdigit (c))
+                      tmp_arg.append (1, c);
+                    else
+                      {
+                        // Before we do anything remove trailing whitespaces.
+                        while (i < fun.length () && isspace (c))
+                          c = fun[i++];
+                        
+                        // Do we have a variable or a function?
+                        if (c != '(')
+                          terminate_arg = true;
+                        else
+                          {
+                            tmp_arg = std::string ();
+                            is_arg = false;
+                          }
+                      }
+                  else
+                    {
+                      tmp_arg.append (1, c);
+                      is_arg = true;
+                    }
 
-		  if (terminate_arg || (i == fun.length () && is_arg))
-		    {
-		      bool have_arg = false;
-		      
-		      for (int j = 0; j < fargs.length (); j++)
-			if (tmp_arg == fargs (j))
-			  {
-			    have_arg = true;
-			    break;
-			  }
-			  
-		      if (! have_arg && tmp_arg != "i" && tmp_arg != "j" &&
-			  tmp_arg != "NaN" && tmp_arg != "nan" && 
-			  tmp_arg != "Inf" && tmp_arg != "inf" && 
-			  tmp_arg != "NA" && tmp_arg != "pi" &&
-			  tmp_arg != "eps")
-			fargs.append (tmp_arg);
+                  if (terminate_arg || (i == fun.length () && is_arg))
+                    {
+                      bool have_arg = false;
+                      
+                      for (int j = 0; j < fargs.length (); j++)
+                        if (tmp_arg == fargs (j))
+                          {
+                            have_arg = true;
+                            break;
+                          }
+                          
+                      if (! have_arg && tmp_arg != "i" && tmp_arg != "j" &&
+                          tmp_arg != "NaN" && tmp_arg != "nan" && 
+                          tmp_arg != "Inf" && tmp_arg != "inf" && 
+                          tmp_arg != "NA" && tmp_arg != "pi" &&
+                          tmp_arg != "eps")
+                        fargs.append (tmp_arg);
 
-		      tmp_arg = std::string ();
-		      is_arg = false;
-		    }
-		}
+                      tmp_arg = std::string ();
+                      is_arg = false;
+                    }
+                }
 
-	      // Sort the arguments into ascii order.
-	      fargs.sort ();
-	    }
-	  else if (nargin == 2 && args(1).is_numeric_type ())
-	    {
-	      int n = args(1).int_value ();
+              // Sort the arguments into ascii order.
+              fargs.sort ();
+            }
+          else if (nargin == 2 && args(1).is_numeric_type ())
+            {
+              int n = args(1).int_value ();
 
-	      if (! error_state)
-		{
-		  if (n >= 0)
-		    {
-		      fargs.resize (n+1);
+              if (! error_state)
+                {
+                  if (n >= 0)
+                    {
+                      fargs.resize (n+1);
 
-		      fargs(0) = "x";
+                      fargs(0) = "x";
 
-		      for (int i = 1; i < n+1; i++)
-			{
-			  std::ostringstream buf;
-			  buf << "P" << i;
-			  fargs(i) = buf.str ();
-			}
-		    }
-		  else
-		    {
-		      error ("inline: numeric argument must be nonnegative");
-		      return retval;
-		    }
-		}
-	      else
-		{
-		  error ("inline: expecting second argument to be an integer");
-		  return retval;
-		}
-	    }
-	  else
-	    {
-	      fargs.resize (nargin - 1);
+                      for (int i = 1; i < n+1; i++)
+                        {
+                          std::ostringstream buf;
+                          buf << "P" << i;
+                          fargs(i) = buf.str ();
+                        }
+                    }
+                  else
+                    {
+                      error ("inline: numeric argument must be nonnegative");
+                      return retval;
+                    }
+                }
+              else
+                {
+                  error ("inline: expecting second argument to be an integer");
+                  return retval;
+                }
+            }
+          else
+            {
+              fargs.resize (nargin - 1);
 
-	      for (int i = 1; i < nargin; i++)
-		{
-		  std::string s = args(i).string_value ();
+              for (int i = 1; i < nargin; i++)
+                {
+                  std::string s = args(i).string_value ();
 
-		  if (! error_state)
-		    fargs(i-1) = s;
-		  else
-		    {
-		      error ("inline: expecting string arguments");
-		      return retval;
-		    }
-		}
-	    }
+                  if (! error_state)
+                    fargs(i-1) = s;
+                  else
+                    {
+                      error ("inline: expecting string arguments");
+                      return retval;
+                    }
+                }
+            }
 
-	  retval = octave_value (new octave_fcn_inline (fun, fargs));
-	}
+          retval = octave_value (new octave_fcn_inline (fun, fargs));
+        }
       else
-	error ("inline: first argument must be a string");
+        error ("inline: first argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -816,19 +816,19 @@ Note that @code{char (@var{fun})} is equ
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_fcn_inline* fn = args(0).fcn_inline_value (true);
 
       if (fn)
-	retval = octave_value (fn->fcn_text ());
+        retval = octave_value (fn->fcn_text ());
       else
-	error ("formula: must be an inline function");
+        error ("formula: must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (argnames, args, ,
@@ -843,28 +843,28 @@ the arguments of the inline function @va
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_fcn_inline *fn = args(0).fcn_inline_value (true);
 
       if (fn)
-	{
-	  string_vector t1 = fn->fcn_arg_names ();
+        {
+          string_vector t1 = fn->fcn_arg_names ();
 
-	  Cell t2 (dim_vector (t1.length (), 1));
+          Cell t2 (dim_vector (t1.length (), 1));
 
-	  for (int i = 0; i < t1.length (); i++)
-	    t2(i) = t1(i);
+          for (int i = 0; i < t1.length (); i++)
+            t2(i) = t1(i);
 
-	  retval = t2;
-	}
+          retval = t2;
+        }
       else
-	error ("argnames: argument must be an inline function");
+        error ("argnames: argument must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (vectorize, args, ,
@@ -881,58 +881,58 @@ by replacing all occurrences of @code{*}
 
   if (nargin == 1)
     {
       std::string old_func;
       octave_fcn_inline* old = 0;
       bool func_is_string = true;
 
       if (args(0).is_string ())
-	old_func = args(0).string_value ();
+        old_func = args(0).string_value ();
       else
-	{
-	  old = args(0).fcn_inline_value (true);
-	  func_is_string = false;
+        {
+          old = args(0).fcn_inline_value (true);
+          func_is_string = false;
 
-	  if (old)
-	    old_func = old->fcn_text ();
-	  else
-	    error ("vectorize: must be a string or inline function");
-	}
+          if (old)
+            old_func = old->fcn_text ();
+          else
+            error ("vectorize: must be a string or inline function");
+        }
 
       if (! error_state)
-	{
-	  std::string new_func;
-	  size_t i = 0;
+        {
+          std::string new_func;
+          size_t i = 0;
 
-	  while (i < old_func.length ())
-	    {
-	      std::string t1 = old_func.substr (i, 1);
+          while (i < old_func.length ())
+            {
+              std::string t1 = old_func.substr (i, 1);
 
-	      if (t1 == "*" || t1 == "/" || t1 == "\\" || t1 == "^")
-		{
-		  if (i && old_func.substr (i-1, 1) != ".")
-		    new_func.append (".");
+              if (t1 == "*" || t1 == "/" || t1 == "\\" || t1 == "^")
+                {
+                  if (i && old_func.substr (i-1, 1) != ".")
+                    new_func.append (".");
 
-		  // Special case for ** operator.
-		  if (t1 == "*" && i < (old_func.length () - 1)
-		      && old_func.substr (i+1, 1) == "*")
-		    {
-		      new_func.append ("*");
-		      i++;
-		    }
-		}
-	      new_func.append (t1);
-	      i++;
-	    }
+                  // Special case for ** operator.
+                  if (t1 == "*" && i < (old_func.length () - 1)
+                      && old_func.substr (i+1, 1) == "*")
+                    {
+                      new_func.append ("*");
+                      i++;
+                    }
+                }
+              new_func.append (t1);
+              i++;
+            }
 
-	  if (func_is_string)
-	    retval = octave_value (new_func);
-	  else
-	    retval = octave_value (new octave_fcn_inline 
-				   (new_func, old->fcn_arg_names ()));
-	}
+          if (func_is_string)
+            retval = octave_value (new_func);
+          else
+            retval = octave_value (new octave_fcn_inline 
+                                   (new_func, old->fcn_arg_names ()));
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -78,26 +78,26 @@ octave_float_scalar::do_index_op (const 
 octave_value 
 octave_float_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       FloatNDArray retval (dv, NDArray::resize_fill_value());
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
   else
     {
       FloatNDArray retval (dv);
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
 }
 
 octave_value
 octave_float_scalar::convert_to_str_internal (bool, bool, char type) const
 {
@@ -105,23 +105,23 @@ octave_float_scalar::convert_to_str_inte
 
   if (xisnan (scalar))
     ::error ("invalid conversion from NaN to character");
   else
     {
       int ival = NINT (scalar);
 
       if (ival < 0 || ival > UCHAR_MAX)
-	{
-	  // FIXME -- is there something better we could do?
+        {
+          // FIXME -- is there something better we could do?
 
-	  ival = 0;
+          ival = 0;
 
-	  ::warning ("range error for conversion to character value");
-	}
+          ::warning ("range error for conversion to character value");
+        }
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
 
   return retval;
 }
 
 bool 
@@ -157,17 +157,17 @@ octave_float_scalar::save_binary (std::o
   float dtmp = float_value ();
   os.write (reinterpret_cast<char *> (&dtmp), 4);
 
   return true;
 }
 
 bool 
 octave_float_scalar::load_binary (std::istream& is, bool swap,
-			    oct_mach_info::float_format fmt)
+                            oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   float dtmp;
   read_floats (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
   if (error_state || ! is)
@@ -176,40 +176,40 @@ octave_float_scalar::load_binary (std::i
   scalar = dtmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_float_scalar::save_hdf5 (hid_t loc_id, const char *name,
-			  bool /* save_as_floats */)
+                          bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   float tmp = float_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
@@ -227,17 +227,17 @@ octave_float_scalar::load_hdf5 (hid_t lo
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   float dtmp;
   if (H5Dread (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, &dtmp) < 0)
+               H5P_DEFAULT, &dtmp) < 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -48,17 +48,17 @@ along with Octave; see the file COPYING.
 #include "ls-oct-ascii.h"
 #include "ls-hdf5.h"
 
 template class octave_base_scalar<FloatComplex>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_float_complex);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex,
-				     "float complex scalar", "single");
+                                     "float complex scalar", "single");
 
 octave_base_value *
 octave_float_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   float im = std::imag (scalar);
 
@@ -88,87 +88,87 @@ octave_float_complex::do_index_op (const
 
 double
 octave_float_complex::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real scalar");
+                               "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 float
 octave_float_complex::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real scalar");
+                               "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 Matrix
 octave_float_complex::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = Matrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 FloatMatrix
 octave_float_complex::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = FloatMatrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 NDArray
 octave_float_complex::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = NDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 FloatNDArray
 octave_float_complex::float_array_value (bool force_conversion) const
 {
   FloatNDArray retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex scalar", "real matrix");
+                               "complex scalar", "real matrix");
 
   retval = FloatNDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 Complex
 octave_float_complex::complex_value (bool) const
@@ -209,26 +209,26 @@ octave_float_complex::float_complex_arra
 octave_value 
 octave_float_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       FloatComplexNDArray retval (dv, FloatComplexNDArray::resize_fill_value ());
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
   else
     {
       FloatComplexNDArray retval (dv);
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
 }
 
 bool 
 octave_float_complex::save_ascii (std::ostream& os)
 {
@@ -264,37 +264,37 @@ octave_float_complex::save_binary (std::
   FloatComplex ctmp = float_complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 8);
 
   return true;
 }
 
 bool 
 octave_float_complex::load_binary (std::istream& is, bool swap,
-			     oct_mach_info::float_format fmt)
+                             oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   FloatComplex ctmp;
   read_floats (is, reinterpret_cast<float *> (&ctmp),
-		static_cast<save_type> (tmp), 2, swap, fmt);
+                static_cast<save_type> (tmp), 2, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_float_complex::save_hdf5 (hid_t loc_id, const char *name,
-			   bool /* save_as_floats */)
+                           bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, type_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
@@ -302,30 +302,30 @@ octave_float_complex::save_hdf5 (hid_t l
   type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (type_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
-#else			
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+#else                   
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   FloatComplex tmp = float_complex_value ();
   retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
-		     &tmp) >= 0;
+                     &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
@@ -358,17 +358,17 @@ octave_float_complex::load_hdf5 (hid_t l
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   // complex scalar:
   FloatComplex ctmp;
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       &ctmp) >= 0)
+               &ctmp) >= 0)
     {
       retval = true;
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
diff --git a/src/ov-flt-cx-diag.cc b/src/ov-flt-cx-diag.cc
--- a/src/ov-flt-cx-diag.cc
+++ b/src/ov-flt-cx-diag.cc
@@ -81,31 +81,31 @@ octave_float_complex_diag_matrix::try_na
 
 DiagMatrix
 octave_float_complex_diag_matrix::diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       type_name (), "real matrix");
+                               type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 FloatDiagMatrix
 octave_float_complex_diag_matrix::float_diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       type_name (), "real matrix");
+                               type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 ComplexDiagMatrix
 octave_float_complex_diag_matrix::complex_diag_matrix_value (bool) const
@@ -155,28 +155,28 @@ octave_float_complex_diag_matrix::save_b
   os.write (reinterpret_cast<char *> (&c), 4);
 
   FloatComplexMatrix m = FloatComplexMatrix (matrix.diag ());
   save_type st = LS_FLOAT;
   if (matrix.length () > 4096) // FIXME -- make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   const FloatComplex *mtmp = m.data ();
   write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * m.numel ());
 
   return true;
 }
 
 bool 
 octave_float_complex_diag_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -59,17 +59,17 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 template class octave_base_matrix<FloatComplexNDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_float_complex_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_matrix,
-				     "float complex matrix", "single");
+                                     "float complex matrix", "single");
 
 octave_base_value *
 octave_float_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.numel () == 1)
     {
@@ -88,92 +88,92 @@ octave_float_complex_matrix::try_narrowi
 
 double
 octave_float_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real scalar");
+                               "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "real scalar");
+                                 "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_float_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real scalar");
+                               "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "real scalar");
+                                 "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_float_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real matrix");
+                               "complex matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 FloatMatrix
 octave_float_complex_matrix::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real matrix");
+                               "complex matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 Complex
 octave_float_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "complex scalar");
+                                 "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
@@ -183,17 +183,17 @@ octave_float_complex_matrix::float_compl
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex matrix", "complex scalar");
+                                 "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
@@ -224,24 +224,24 @@ octave_float_complex_matrix::bool_array_
   
 charNDArray
 octave_float_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
     gripe_implicit_conversion ("Octave:num-to-str",
-			       "complex matrix", "string");
+                               "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
   
       for (octave_idx_type i = 0; i < nel; i++)
-	retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
     }
 
   return retval;
 }  
 
 FloatComplexNDArray 
 octave_float_complex_matrix::float_complex_array_value (bool) const 
 { 
@@ -250,17 +250,17 @@ octave_float_complex_matrix::float_compl
 
 SparseMatrix
 octave_float_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-			       "complex matrix", "real matrix");
+                               "complex matrix", "real matrix");
 
   retval = SparseMatrix (::real (complex_matrix_value ()));
 
   return retval;
 }
 
 SparseComplexMatrix
 octave_float_complex_matrix::sparse_complex_matrix_value (bool) const
@@ -287,26 +287,26 @@ octave_float_complex_matrix::save_ascii 
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       FloatComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
-	os << " " << d (i);
+        os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
-	 << "# columns: " << columns () << "\n";
+         << "# columns: " << columns () << "\n";
 
       os << complex_matrix_value ();
     }
 
   return true;
 }
 
 bool 
@@ -320,85 +320,85 @@ octave_float_complex_matrix::load_ascii 
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
-	{
-	  int mdims = static_cast<int> (val);
+        {
+          int mdims = static_cast<int> (val);
 
-	  if (mdims >= 0)
-	    {
-	      dim_vector dv;
-	      dv.resize (mdims);
+          if (mdims >= 0)
+            {
+              dim_vector dv;
+              dv.resize (mdims);
 
-	      for (int i = 0; i < mdims; i++)
-		is >> dv(i);
+              for (int i = 0; i < mdims; i++)
+                is >> dv(i);
 
-	      if (is)
-		{
-		  FloatComplexNDArray tmp(dv);
+              if (is)
+                {
+                  FloatComplexNDArray tmp(dv);
 
                   is >> tmp;
 
                   if (is)
                     matrix = tmp;
                   else
                     {
                       error ("load: failed to load matrix constant");
                       success = false;
                     }
-		}
-	      else
-		{
-		  error ("load: failed to read dimensions");
-		  success = false;
-		}
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of dimensions");
-	      success = false;
-	    }
-	}
+                }
+              else
+                {
+                  error ("load: failed to read dimensions");
+                  success = false;
+                }
+            }
+          else
+            {
+              error ("load: failed to extract number of dimensions");
+              success = false;
+            }
+        }
       else if (kw == "rows")
-	{
-	  octave_idx_type nr = val;
-	  octave_idx_type nc = 0;
+        {
+          octave_idx_type nr = val;
+          octave_idx_type nc = 0;
 
-	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-	    {
-	      if (nr > 0 && nc > 0)
-		{
-		  FloatComplexMatrix tmp (nr, nc);
-		  is >> tmp;
-		  if (is)
-		    matrix = tmp;
-		  else
-		    {
-		      error ("load: failed to load matrix constant");
-		      success = false;
-		    }
-		}
-	      else if (nr == 0 || nc == 0)
-		matrix = FloatComplexMatrix (nr, nc);
-	      else
-		panic_impossible ();
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of rows and columns");
-	      success = false;
-	    }
-	}
+          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+            {
+              if (nr > 0 && nc > 0)
+                {
+                  FloatComplexMatrix tmp (nr, nc);
+                  is >> tmp;
+                  if (is)
+                    matrix = tmp;
+                  else
+                    {
+                      error ("load: failed to load matrix constant");
+                      success = false;
+                    }
+                }
+              else if (nr == 0 || nc == 0)
+                matrix = FloatComplexMatrix (nr, nc);
+              else
+                panic_impossible ();
+            }
+          else
+            {
+              error ("load: failed to extract number of rows and columns");
+              success = false;
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
@@ -421,91 +421,91 @@ octave_float_complex_matrix::save_binary
     }
 
   FloatComplexNDArray m = complex_array_value ();
   save_type st = LS_FLOAT;
   if (d.numel () > 4096) // FIXME -- make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   const FloatComplex *mtmp = m.data ();
   write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * d.numel ());
 
   return true;
 }
 
 bool 
 octave_float_complex_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
       int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
-	{
-	  if (! is.read (reinterpret_cast<char *> (&di), 4))
-	    return false;
-	  if (swap)
-	    swap_bytes<4> (&di);
-	  dv(i) = di;
-	}
+        {
+          if (! is.read (reinterpret_cast<char *> (&di), 4))
+            return false;
+          if (swap)
+            swap_bytes<4> (&di);
+          dv(i) = di;
+        }
 
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
       // might.
 
       if (mdims == 1)
-	{
-	  mdims = 2;
-	  dv.resize (mdims);
-	  dv(1) = dv(0);
-	  dv(0) = 1;
-	}
+        {
+          mdims = 2;
+          dv.resize (mdims);
+          dv(1) = dv(0);
+          dv(0) = 1;
+        }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
 
       FloatComplexNDArray m(dv);
       FloatComplex *im = m.fortran_vec ();
       read_floats (is, reinterpret_cast<float *> (im),
-		    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
+                    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&nc);
+        swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
       FloatComplexMatrix m (nr, nc);
       FloatComplex *im = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_floats (is, reinterpret_cast<float *> (im),
-		    static_cast<save_type> (tmp), 2*len, swap, fmt);
+                    static_cast<save_type> (tmp), 2*len, swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
@@ -534,30 +534,30 @@ octave_float_complex_matrix::save_hdf5 (
 
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       float max_val, min_val;
       
       if (m.all_integers (max_val, min_val))
-	save_type_hid
-	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
+        save_type_hid
+          = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
@@ -565,21 +565,21 @@ octave_float_complex_matrix::save_hdf5 (
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (complex_type_hid < 0) retval = false;
 
   if (retval)
     {
       FloatComplex *mtmp = m.fortran_vec ();
       if (H5Dwrite (data_hid, complex_type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		    mtmp) < 0)
-	{
-	  H5Tclose (complex_type_hid);
-	  retval = false;
-	}
+                    mtmp) < 0)
+        {
+          H5Tclose (complex_type_hid);
+          retval = false;
+        }
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
@@ -636,43 +636,43 @@ octave_float_complex_matrix::load_hdf5 (
       dv.resize (2);
       dv(0) = 1;
       dv(1) = hdims[0];
     }
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
-	dv(j) = hdims[i];
+        dv(j) = hdims[i];
     }
 
   FloatComplexNDArray m (dv);
   FloatComplex *reim = m.fortran_vec ();
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       reim) >= 0) 
+               reim) >= 0) 
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
   return retval;
 }
 
 #endif
 
 void
 octave_float_complex_matrix::print_raw (std::ostream& os,
-				  bool pr_as_read_syntax) const
+                                  bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 mxArray *
 octave_float_complex_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxSINGLE_CLASS, dims (), mxCOMPLEX);
 
   float *pr = static_cast<float *> (retval->get_data ());
diff --git a/src/ov-flt-re-diag.cc b/src/ov-flt-re-diag.cc
--- a/src/ov-flt-re-diag.cc
+++ b/src/ov-flt-re-diag.cc
@@ -111,41 +111,41 @@ octave_float_diag_matrix::map (unary_map
       }
     default:
       return to_dense ().map (umap);
     }
 }
 
 bool 
 octave_float_diag_matrix::save_binary (std::ostream& os,
-				       bool& /* save_as_floats*/)
+                                       bool& /* save_as_floats*/)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   FloatMatrix m = FloatMatrix (matrix.diag ());
   save_type st = LS_FLOAT;
   if (matrix.length () > 8192) // FIXME -- make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, m.numel ());
 
   return true;
 }
 
 bool 
 octave_float_diag_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -92,17 +92,17 @@ octave_float_matrix::try_narrowing_conve
 double
 octave_float_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "real scalar");
+                                 "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
@@ -110,17 +110,17 @@ octave_float_matrix::double_value (bool)
 float
 octave_float_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "real scalar");
+                                 "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
@@ -144,17 +144,17 @@ octave_float_matrix::complex_value (bool
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "complex scalar");
+                                 "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
@@ -164,17 +164,17 @@ octave_float_matrix::float_complex_value
 {
   double tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "complex scalar");
+                                 "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
@@ -276,40 +276,40 @@ octave_float_matrix::convert_to_str_inte
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       float d = matrix (i);
 
       if (xisnan (d))
-	{
-	  ::error ("invalid conversion from NaN to character");
-	  return retval;
-	}
+        {
+          ::error ("invalid conversion from NaN to character");
+          return retval;
+        }
       else
-	{
-	  int ival = NINT (d);
+        {
+          int ival = NINT (d);
 
-	  if (ival < 0 || ival > UCHAR_MAX)
-	    {
-	      // FIXME -- is there something
-	      // better we could do?
+          if (ival < 0 || ival > UCHAR_MAX)
+            {
+              // FIXME -- is there something
+              // better we could do?
 
-	      ival = 0;
+              ival = 0;
 
-	      if (! warned)
-		{
-		  ::warning ("range error for conversion to character value");
-		  warned = true;
-		}
-	    }
+              if (! warned)
+                {
+                  ::warning ("range error for conversion to character value");
+                  warned = true;
+                }
+            }
 
-	  chm (i) = static_cast<char> (ival);
-	}
+          chm (i) = static_cast<char> (ival);
+        }
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
 bool 
@@ -319,26 +319,26 @@ octave_float_matrix::save_ascii (std::os
 
   if (d.length () > 2)
     {
       FloatNDArray tmp = float_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i=0; i < d.length (); i++)
-	os << " " << d (i);
+        os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
-	 << "# columns: " << columns () << "\n";
+         << "# columns: " << columns () << "\n";
 
       os << float_matrix_value ();
     }
 
   return true;
 }
 
 bool 
@@ -352,85 +352,85 @@ octave_float_matrix::load_ascii (std::is
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
-	{
-	  int mdims = static_cast<int> (val);
+        {
+          int mdims = static_cast<int> (val);
 
-	  if (mdims >= 0)
-	    {
-	      dim_vector dv;
-	      dv.resize (mdims);
+          if (mdims >= 0)
+            {
+              dim_vector dv;
+              dv.resize (mdims);
 
-	      for (int i = 0; i < mdims; i++)
-		is >> dv(i);
+              for (int i = 0; i < mdims; i++)
+                is >> dv(i);
 
-	      if (is)
-		{
-		  FloatNDArray tmp(dv);
+              if (is)
+                {
+                  FloatNDArray tmp(dv);
 
                   is >> tmp;
 
                   if (is)
                     matrix = tmp;
                   else
                     {
                       error ("load: failed to load matrix constant");
                       success = false;
                     }
-		}
-	      else
-		{
-		  error ("load: failed to read dimensions");
-		  success = false;
-		}
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of dimensions");
-	      success = false;
-	    }
-	}
+                }
+              else
+                {
+                  error ("load: failed to read dimensions");
+                  success = false;
+                }
+            }
+          else
+            {
+              error ("load: failed to extract number of dimensions");
+              success = false;
+            }
+        }
       else if (kw == "rows")
-	{
-	  octave_idx_type nr = val;
-	  octave_idx_type nc = 0;
+        {
+          octave_idx_type nr = val;
+          octave_idx_type nc = 0;
 
-	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-	    {
-	      if (nr > 0 && nc > 0)
-		{
-		  FloatMatrix tmp (nr, nc);
-		  is >> tmp;
-		  if (is)
-		    matrix = tmp;
-		  else
-		    {
-		      error ("load: failed to load matrix constant");
-		      success = false;
-		    }
-		}
-	      else if (nr == 0 || nc == 0)
-		matrix = FloatMatrix (nr, nc);
-	      else
-		panic_impossible ();
-	    }
-	  else 
-	    {
-	      error ("load: failed to extract number of rows and columns");
-	      success = false;
-	    }
-	}
+          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+            {
+              if (nr > 0 && nc > 0)
+                {
+                  FloatMatrix tmp (nr, nc);
+                  is >> tmp;
+                  if (is)
+                    matrix = tmp;
+                  else
+                    {
+                      error ("load: failed to load matrix constant");
+                      success = false;
+                    }
+                }
+              else if (nr == 0 || nc == 0)
+                matrix = FloatMatrix (nr, nc);
+              else
+                panic_impossible ();
+            }
+          else 
+            {
+              error ("load: failed to extract number of rows and columns");
+              success = false;
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
@@ -454,89 +454,89 @@ octave_float_matrix::save_binary (std::o
     }
 
   FloatNDArray m = float_array_value ();
   save_type st = LS_FLOAT;
   if (d.numel () > 8192) // FIXME -- make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, d.numel ());
 
   return true;
 }
 
 bool 
 octave_float_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
       int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
-	{
-	  if (! is.read (reinterpret_cast<char *> (&di), 4))
-	    return false;
-	  if (swap)
-	    swap_bytes<4> (&di);
-	  dv(i) = di;
-	}
+        {
+          if (! is.read (reinterpret_cast<char *> (&di), 4))
+            return false;
+          if (swap)
+            swap_bytes<4> (&di);
+          dv(i) = di;
+        }
 
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
       // might.
 
       if (mdims == 1)
-	{
-	  mdims = 2;
-	  dv.resize (mdims);
-	  dv(1) = dv(0);
-	  dv(0) = 1;
-	}
+        {
+          mdims = 2;
+          dv.resize (mdims);
+          dv(1) = dv(0);
+          dv(0) = 1;
+        }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
 
       FloatNDArray m(dv);
       float *re = m.fortran_vec ();
       read_floats (is, re, static_cast<save_type> (tmp), dv.numel (), swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&nc);
+        swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
       FloatMatrix m (nr, nc);
       float *re = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_floats (is, re, static_cast<save_type> (tmp), len, swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
@@ -566,36 +566,36 @@ octave_float_matrix::save_hdf5 (hid_t lo
 
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       float max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
-	save_type_hid
-	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
+        save_type_hid
+          = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   float *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, mtmp) >= 0;
+                     H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
@@ -637,42 +637,42 @@ octave_float_matrix::load_hdf5 (hid_t lo
       dv.resize (2);
       dv(0) = 1;
       dv(1) = hdims[0];
     }
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
-	dv(j) = hdims[i];
+        dv(j) = hdims[i];
     }
 
   FloatNDArray m (dv);
   float *re = m.fortran_vec ();
   if (H5Dread (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, re) >= 0) 
+               H5P_DEFAULT, re) >= 0) 
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
   return retval;
 }
 
 #endif
 
 void
 octave_float_matrix::print_raw (std::ostream& os,
-			  bool pr_as_read_syntax) const
+                          bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 mxArray *
 octave_float_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxSINGLE_CLASS, dims (), mxREAL);
 
   float *pr = static_cast<float *> (retval->get_data ());
@@ -805,35 +805,35 @@ Convert @var{x} to single precision type
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
   // avoid a shadowed declaration warning.
 
   if (args.length () == 1)
     {
       if (args(0).is_diag_matrix ())
         {
-	  if (args(0).is_complex_type ())
-	    {
-	      OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_diag_matrix, octave_float_complex);
-	    }
-	  else
-	    {
-	      OCTAVE_TYPE_CONV_BODY3 (single, octave_float_diag_matrix, octave_float_scalar);
-	    }
+          if (args(0).is_complex_type ())
+            {
+              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_diag_matrix, octave_float_complex);
+            }
+          else
+            {
+              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_diag_matrix, octave_float_scalar);
+            }
         }
       else if (args(0).is_sparse_type ())
-	{
-	  error ("single: sparse type do not support single precision");
-	}
+        {
+          error ("single: sparse type do not support single precision");
+        }
       else if (args(0).is_complex_type ())
-	{
-	  OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_matrix, octave_float_complex);
-	}
+        {
+          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_matrix, octave_float_complex);
+        }
       else
-	{
-	  OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix, octave_float_scalar);
-	}
+        {
+          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix, octave_float_scalar);
+        }
     }
   else
     print_usage ();
 
   return octave_value ();
 }
diff --git a/src/ov-int16.cc b/src/ov-int16.cc
--- a/src/ov-int16.cc
+++ b/src/ov-int16.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<int16NDArray>;
 
 template class octave_base_int_matrix<int16NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int16_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_matrix,
-				     "int16 matrix", "int16");
+                                     "int16 matrix", "int16");
 
 template class octave_base_scalar<octave_int16>;
 
 template class octave_base_int_scalar<octave_int16>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int16_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_scalar,
-				     "int16 scalar", "int16");
+                                     "int16 scalar", "int16");
 
 DEFUN (int16, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int16 (@var{x})\n\
 Convert @var{x} to 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int16);
diff --git a/src/ov-int32.cc b/src/ov-int32.cc
--- a/src/ov-int32.cc
+++ b/src/ov-int32.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<int32NDArray>;
 
 template class octave_base_int_matrix<int32NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int32_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_matrix,
-				     "int32 matrix", "int32");
+                                     "int32 matrix", "int32");
 
 template class octave_base_scalar<octave_int32>;
 
 template class octave_base_int_scalar<octave_int32>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int32_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_scalar,
-				     "int32 scalar", "int32");
+                                     "int32 scalar", "int32");
 
 DEFUN (int32, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int32 (@var{x})\n\
 Convert @var{x} to 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int32);
diff --git a/src/ov-int64.cc b/src/ov-int64.cc
--- a/src/ov-int64.cc
+++ b/src/ov-int64.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<int64NDArray>;
 
 template class octave_base_int_matrix<int64NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int64_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_matrix,
-				     "int64 matrix", "int64");
+                                     "int64 matrix", "int64");
 
 template class octave_base_scalar<octave_int64>;
 
 template class octave_base_int_scalar<octave_int64>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int64_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_scalar,
-				     "int64 scalar", "int64");
+                                     "int64 scalar", "int64");
 
 DEFUN (int64, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int64 (@var{x})\n\
 Convert @var{x} to 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int64);
diff --git a/src/ov-int8.cc b/src/ov-int8.cc
--- a/src/ov-int8.cc
+++ b/src/ov-int8.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<int8NDArray>;
 
 template class octave_base_int_matrix<int8NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int8_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_matrix,
-				     "int8 matrix", "int8");
+                                     "int8 matrix", "int8");
 
 template class octave_base_scalar<octave_int8>;
 
 template class octave_base_int_scalar<octave_int8>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int8_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_scalar,
-				     "int8 scalar", "int8");
+                                     "int8 scalar", "int8");
 
 DEFUN (int8, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int8 (@var{x})\n\
 Convert @var{x} to 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int8);
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "ov-mex-fcn.h"
 #include "ov.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_mex_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mex_function,
-				     "mex function", "mex function");
+                                     "mex function", "mex function");
 
 octave_mex_function::octave_mex_function
   (void *fptr, bool fmex, const octave_shlib& shl,
    const std::string& nm)
   : octave_function (nm), mex_fcn_ptr (fptr), exit_fcn_ptr (0),
     have_fmex (fmex), sh_lib (shl)
 {
   mark_fcn_file_up_to_date (time_parsed ());
@@ -73,36 +73,36 @@ octave_mex_function::fcn_file_name (void
 octave_time
 octave_mex_function::time_parsed (void) const
 {
   return sh_lib.time_loaded ();
 }
 
 octave_value_list
 octave_mex_function::subsref (const std::string& type,
-			      const std::list<octave_value_list>& idx,
-			      int nargout)
+                              const std::list<octave_value_list>& idx,
+                              int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
-	int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
+        int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
 
-	retval = do_multi_index_op (tmp_nargout, idx.front ());
+        retval = do_multi_index_op (tmp_nargout, idx.front ());
       }
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME -- perhaps there should be an
@@ -119,21 +119,21 @@ octave_mex_function::subsref (const std:
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 // FIXME -- shouldn't this declaration be a header file somewhere?
 extern octave_value_list
 call_mex (bool have_fmex, void *f, const octave_value_list& args,
-	  int nargout, octave_mex_function *curr_mex_fcn);
+          int nargout, octave_mex_function *curr_mex_fcn);
 
 octave_value_list
 octave_mex_function::do_multi_index_op (int nargout,
-					const octave_value_list& args)
+                                        const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (args.has_magic_colon ())
     ::error ("invalid use of colon in function argument list");
@@ -141,19 +141,19 @@ octave_mex_function::do_multi_index_op (
     {
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
       frame.add_fcn (octave_call_stack::pop);
 
       try
-	{
-	  retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
-	}
+        {
+          retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
+        }
       catch (octave_execution_exception)
-	{
-	  gripe_library_execution_error ();
-	}
+        {
+          gripe_library_execution_error ();
+        }
     }
 
   return retval;
 }
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -46,18 +46,18 @@ octave_perm_matrix::subsref (const std::
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
@@ -131,17 +131,17 @@ octave_perm_matrix::is_true (void) const
 double
 octave_perm_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "real scalar");
+                                 type_name (), "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
@@ -149,17 +149,17 @@ octave_perm_matrix::double_value (bool) 
 float
 octave_perm_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "real scalar");
+                                 type_name (), "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
@@ -169,17 +169,17 @@ octave_perm_matrix::complex_value (bool)
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "complex scalar");
+                                 type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
@@ -189,17 +189,17 @@ octave_perm_matrix::float_complex_value 
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 type_name (), "complex scalar");
+                                 type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
@@ -276,20 +276,20 @@ octave_perm_matrix::load_ascii (std::ist
   if (extract_keyword (is, "size", n, true)
       && extract_keyword (is, "orient", orient, true))
     {
       bool colp = orient == 'c';
       dim_vector dv (n);
       ColumnVector tmp (n);
       is >> tmp;
       if (!is) 
-	{
-	  error ("load: failed to load permutation matrix constant");
-	  success = false;
-	}
+        {
+          error ("load: failed to load permutation matrix constant");
+          success = false;
+        }
       else
         {
           Array<octave_idx_type> pvec (n);
           for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
           matrix = PermMatrix (pvec, colp);
 
           // Invalidate cache. Probably not necessary, but safe.
           dense_cache = octave_value ();
@@ -331,31 +331,31 @@ octave_perm_matrix::load_binary (std::is
 
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = m.numel ();
       for (int i = 0; i < nel; i++) 
-	switch (sizeof (octave_idx_type))
-	  {
-	  case 8:
-	    swap_bytes<8> (&m(i));
-	    break;
-	  case 4:
-	    swap_bytes<4> (&m(i));
-	    break;
-	  case 2:
-	    swap_bytes<2> (&m(i));
-	    break;
-	  case 1:
-	  default:
-	    break;
-	  }
+        switch (sizeof (octave_idx_type))
+          {
+          case 8:
+            swap_bytes<8> (&m(i));
+            break;
+          case 4:
+            swap_bytes<4> (&m(i));
+            break;
+          case 2:
+            swap_bytes<2> (&m(i));
+            break;
+          case 1:
+          default:
+            break;
+          }
     }
 
   matrix = PermMatrix (m, colp);
   return true;
 }
 
 void
 octave_perm_matrix::print_raw (std::ostream& os,
@@ -391,17 +391,17 @@ octave_perm_matrix::write (octave_stream
                                 oct_data_conv::data_type output_type, int skip,
                                 oct_mach_info::float_format flt_fmt) const
 { 
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt); 
 }
 
 void
 octave_perm_matrix::print_info (std::ostream& os,
-				    const std::string& prefix) const
+                                    const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
 
 octave_value
 octave_perm_matrix::to_dense (void) const
 {
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -85,31 +85,31 @@ octave_range::try_narrowing_conversion (
       break;
     }
 
   return retval;
 }
 
 octave_value
 octave_range::subsref (const std::string& type,
-		       const std::list<octave_value_list>& idx)
+                       const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
@@ -147,17 +147,17 @@ octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "range", "real scalar");
+                                 "range", "real scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "real scalar");
 
   return retval;
 }
@@ -167,17 +167,17 @@ octave_range::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "range", "real scalar");
+                                 "range", "real scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "real scalar");
 
   return retval;
 }
@@ -249,17 +249,17 @@ octave_range::complex_value (bool) const
 
   Complex retval (tmp, tmp);
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "range", "complex scalar");
+                                 "range", "complex scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "complex scalar");
 
   return retval;
 }
@@ -271,17 +271,17 @@ octave_range::float_complex_value (bool)
 
   FloatComplex retval (tmp, tmp);
 
   octave_idx_type nel = range.nelem ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "range", "complex scalar");
+                                 "range", "complex scalar");
 
       retval = range.base ();
     }
   else
     gripe_invalid_conversion ("range", "complex scalar");
 
   return retval;
 }
@@ -310,17 +310,17 @@ octave_range::print (std::ostream& os, b
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 void
 octave_range::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   octave_print_internal (os, range, pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 bool
 octave_range::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   octave_idx_type n = range.nelem ();
@@ -344,19 +344,19 @@ octave_range::print_name_tag (std::ostre
 
 static void
 skip_comments (std::istream& is)
 {
   char c = '\0';
   while (is.get (c))
     {
       if (c == ' ' || c == '\t' || c == '\n')
-	; // Skip whitespace on way to beginning of next line.
+        ; // Skip whitespace on way to beginning of next line.
       else
-	break;
+        break;
     }
 
   skip_until_newline (is, false);
 }
 
 bool 
 octave_range::save_ascii (std::ostream& os)
 {
@@ -406,17 +406,17 @@ octave_range::save_binary (std::ostream&
   os.write (reinterpret_cast<char *> (&lim), 8);
   os.write (reinterpret_cast<char *> (&inc), 8);
 
   return true;
 }
 
 bool 
 octave_range::load_binary (std::istream& is, bool swap,
-			   oct_mach_info::float_format /* fmt */)
+                           oct_mach_info::float_format /* fmt */)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   double bas, lim, inc;
   if (! is.read (reinterpret_cast<char *> (&bas), 8))
     return false;
   if (swap)
@@ -451,34 +451,34 @@ hdf5_make_range_type (hid_t num_type)
   H5Tinsert (type_id, "limit", 1 * sizeof (double), num_type);
   H5Tinsert (type_id, "increment", 2 * sizeof (double), num_type);
 
   return type_id;
 }
 
 bool
 octave_range::save_hdf5 (hid_t loc_id, const char *name,
-			 bool /* save_as_floats */)
+                         bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, type_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
   type_hid = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
-  			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
@@ -486,17 +486,17 @@ octave_range::save_hdf5 (hid_t loc_id, c
   
   Range r = range_value ();
   double range_vals[3];
   range_vals[0] = r.base ();
   range_vals[1] = r.limit ();
   range_vals[2] = r.inc ();
 
   retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     range_vals) >= 0;
+                     range_vals) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
@@ -529,17 +529,17 @@ octave_range::load_hdf5 (hid_t loc_id, c
       H5Tclose (range_type);
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       return false;
     }
 
   double rangevals[3];
   if (H5Dread (data_hid, range_type, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
-	       rangevals) >= 0)
+               rangevals) >= 0)
     {
       retval = true;
       Range r (rangevals[0], rangevals[1], rangevals[2]);
       range = r;
     }
 
   H5Tclose (range_type);
   H5Sclose (space_hid);
diff --git a/src/ov-re-diag.cc b/src/ov-re-diag.cc
--- a/src/ov-re-diag.cc
+++ b/src/ov-re-diag.cc
@@ -182,39 +182,39 @@ octave_diag_matrix::save_binary (std::os
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   Matrix m = Matrix (matrix.diag ());
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	st = LS_FLOAT;
+        st = LS_FLOAT;
     }
   else if (matrix.length () > 8192) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, m.numel ());
 
   return true;
 }
 
 bool 
 octave_diag_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -106,17 +106,17 @@ octave_matrix::try_narrowing_conversion 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "real scalar");
+                                 "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
@@ -124,17 +124,17 @@ octave_matrix::double_value (bool) const
 float
 octave_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (numel () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "real scalar");
+                                 "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
@@ -158,17 +158,17 @@ octave_matrix::complex_value (bool) cons
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "complex scalar");
+                                 "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
@@ -178,17 +178,17 @@ octave_matrix::float_complex_value (bool
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real matrix", "complex scalar");
+                                 "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
@@ -312,40 +312,40 @@ octave_matrix::convert_to_str_internal (
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       double d = matrix (i);
 
       if (xisnan (d))
-	{
-	  ::error ("invalid conversion from NaN to character");
-	  return retval;
-	}
+        {
+          ::error ("invalid conversion from NaN to character");
+          return retval;
+        }
       else
-	{
-	  int ival = NINT (d);
+        {
+          int ival = NINT (d);
 
-	  if (ival < 0 || ival > UCHAR_MAX)
-	    {
-	      // FIXME -- is there something
-	      // better we could do?
+          if (ival < 0 || ival > UCHAR_MAX)
+            {
+              // FIXME -- is there something
+              // better we could do?
 
-	      ival = 0;
+              ival = 0;
 
-	      if (! warned)
-		{
-		  ::warning ("range error for conversion to character value");
-		  warned = true;
-		}
-	    }
+              if (! warned)
+                {
+                  ::warning ("range error for conversion to character value");
+                  warned = true;
+                }
+            }
 
-	  chm (i) = static_cast<char> (ival);
-	}
+          chm (i) = static_cast<char> (ival);
+        }
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
 bool 
@@ -355,26 +355,26 @@ octave_matrix::save_ascii (std::ostream&
 
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i=0; i < d.length (); i++)
-	os << " " << d (i);
+        os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward 
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
-	 << "# columns: " << columns () << "\n";
+         << "# columns: " << columns () << "\n";
 
       os << matrix_value ();
     }
 
   return true;
 }
 
 bool 
@@ -388,85 +388,85 @@ octave_matrix::load_ascii (std::istream&
   keywords[1] = "rows";
 
   std::string kw;
   octave_idx_type val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
-	{
-	  int mdims = static_cast<int> (val);
+        {
+          int mdims = static_cast<int> (val);
 
-	  if (mdims >= 0)
-	    {
-	      dim_vector dv;
-	      dv.resize (mdims);
+          if (mdims >= 0)
+            {
+              dim_vector dv;
+              dv.resize (mdims);
 
-	      for (int i = 0; i < mdims; i++)
-		is >> dv(i);
+              for (int i = 0; i < mdims; i++)
+                is >> dv(i);
 
-	      if (is)
-		{
-		  NDArray tmp(dv);
+              if (is)
+                {
+                  NDArray tmp(dv);
 
                   is >> tmp;
 
                   if (is)
                     matrix = tmp;
                   else
                     {
                       error ("load: failed to load matrix constant");
                       success = false;
                     }
-		}
-	      else
-		{
-		  error ("load: failed to read dimensions");
-		  success = false;
-		}
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of dimensions");
-	      success = false;
-	    }
-	}
+                }
+              else
+                {
+                  error ("load: failed to read dimensions");
+                  success = false;
+                }
+            }
+          else
+            {
+              error ("load: failed to extract number of dimensions");
+              success = false;
+            }
+        }
       else if (kw == "rows")
-	{
-	  octave_idx_type nr = val;
-	  octave_idx_type nc = 0;
+        {
+          octave_idx_type nr = val;
+          octave_idx_type nc = 0;
 
-	  if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
-	    {
-	      if (nr > 0 && nc > 0)
-		{
-		  Matrix tmp (nr, nc);
-		  is >> tmp;
-		  if (is)
-		    matrix = tmp;
-		  else
-		    {
-		      error ("load: failed to load matrix constant");
-		      success = false;
-		    }
-		}
-	      else if (nr == 0 || nc == 0)
-		matrix = Matrix (nr, nc);
-	      else
-		panic_impossible ();
-	    }
-	  else 
-	    {
-	      error ("load: failed to extract number of rows and columns");
-	      success = false;
-	    }
-	}
+          if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+            {
+              if (nr > 0 && nc > 0)
+                {
+                  Matrix tmp (nr, nc);
+                  is >> tmp;
+                  if (is)
+                    matrix = tmp;
+                  else
+                    {
+                      error ("load: failed to load matrix constant");
+                      success = false;
+                    }
+                }
+              else if (nr == 0 || nc == 0)
+                matrix = Matrix (nr, nc);
+              else
+                panic_impossible ();
+            }
+          else 
+            {
+              error ("load: failed to extract number of rows and columns");
+              success = false;
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
@@ -489,100 +489,100 @@ octave_matrix::save_binary (std::ostream
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   NDArray m = array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	st = LS_FLOAT;
+        st = LS_FLOAT;
     }
   else if (d.numel () > 8192) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, d.numel ());
 
   return true;
 }
 
 bool 
 octave_matrix::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+                                 oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
       int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
-	{
-	  if (! is.read (reinterpret_cast<char *> (&di), 4))
-	    return false;
-	  if (swap)
-	    swap_bytes<4> (&di);
-	  dv(i) = di;
-	}
+        {
+          if (! is.read (reinterpret_cast<char *> (&di), 4))
+            return false;
+          if (swap)
+            swap_bytes<4> (&di);
+          dv(i) = di;
+        }
 
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
       // might.
 
       if (mdims == 1)
-	{
-	  mdims = 2;
-	  dv.resize (mdims);
-	  dv(1) = dv(0);
-	  dv(0) = 1;
-	}
+        {
+          mdims = 2;
+          dv.resize (mdims);
+          dv(1) = dv(0);
+          dv(0) = 1;
+        }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
 
       NDArray m(dv);
       double *re = m.fortran_vec ();
       read_doubles (is, re, static_cast<save_type> (tmp), dv.numel (), swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&nc);
+        swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
-	return false;
+        return false;
       Matrix m (nr, nc);
       double *re = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
@@ -608,51 +608,51 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	save_type_hid = H5T_NATIVE_FLOAT;
+        save_type_hid = H5T_NATIVE_FLOAT;
     }
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
-	save_type_hid
-	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
+        save_type_hid
+          = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
  
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, mtmp) >= 0;
+                     H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
@@ -694,42 +694,42 @@ octave_matrix::load_hdf5 (hid_t loc_id, 
       dv.resize (2);
       dv(0) = 1;
       dv(1) = hdims[0];
     }
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
-	dv(j) = hdims[i];
+        dv(j) = hdims[i];
     }
 
   NDArray m (dv);
   double *re = m.fortran_vec ();
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, re) >= 0) 
+               H5P_DEFAULT, re) >= 0) 
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
   return retval;
 }
 
 #endif
 
 void
 octave_matrix::print_raw (std::ostream& os,
-			  bool pr_as_read_syntax) const
+                          bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
+                         current_print_indent_level ());
 }
 
 mxArray *
 octave_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, dims (), mxREAL);
 
   double *pr = static_cast<double *> (retval->get_data ());
@@ -872,42 +872,42 @@ Convert @var{x} to double precision type
   if (args.length () == 1)
     {
       if (args(0).is_perm_matrix ())
         {
           OCTAVE_TYPE_CONV_BODY3 (double, octave_perm_matrix, octave_scalar);
         }
       else if (args(0).is_diag_matrix ())
         {
-	  if (args(0).is_complex_type ())
-	    {
-	      OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_diag_matrix, octave_complex);
-	    }
-	  else
-	    {
-	      OCTAVE_TYPE_CONV_BODY3 (double, octave_diag_matrix, octave_scalar);
-	    }
+          if (args(0).is_complex_type ())
+            {
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_diag_matrix, octave_complex);
+            }
+          else
+            {
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_diag_matrix, octave_scalar);
+            }
         }
       else if (args(0).is_sparse_type ())
-	{
-	  if (args(0).is_complex_type ())
-	    {
-	      OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_complex_matrix, octave_complex);
-	    }
-	  else
-	    {
-	      OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_matrix, octave_scalar);
-	    }
-	}
+        {
+          if (args(0).is_complex_type ())
+            {
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_complex_matrix, octave_complex);
+            }
+          else
+            {
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_matrix, octave_scalar);
+            }
+        }
       else if (args(0).is_complex_type ())
-	{
-	  OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_matrix, octave_complex);
-	}
+        {
+          OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_matrix, octave_complex);
+        }
       else
-	{
-	  OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
-	}
+        {
+          OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
+        }
     }
   else
     print_usage ();
 
   return octave_value ();
 }
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -72,41 +72,41 @@ octave_sparse_matrix::try_narrowing_conv
   octave_base_value *retval = 0;
 
   if (Vsparse_auto_mutate)
     {
       // Don't use numel, since it can overflow for very large matrices
       // Note that for the second test, this means it becomes approximative
       // since it involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
-	{
-	  // Const copy of the matrix, so the right version of () operator used
-	  const SparseMatrix tmp (matrix);
+        {
+          // Const copy of the matrix, so the right version of () operator used
+          const SparseMatrix tmp (matrix);
 
-	  retval = new octave_scalar (tmp (0));
-	}
+          retval = new octave_scalar (tmp (0));
+        }
       else if (matrix.cols () > 0 && matrix.rows () > 0
-	       && (double (matrix.byte_size ()) > double (matrix.rows ())
-		   * double (matrix.cols ()) * sizeof (double)))
-	retval = new octave_matrix (matrix.matrix_value ());
+               && (double (matrix.byte_size ()) > double (matrix.rows ())
+                   * double (matrix.cols ()) * sizeof (double)))
+        retval = new octave_matrix (matrix.matrix_value ());
     }
 
   return retval;
 }
 
 double
 octave_sparse_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
       if (numel () > 1)
-	gripe_implicit_conversion ("Octave:array-as-scalar",
-				   "real sparse matrix", "real scalar");
+        gripe_implicit_conversion ("Octave:array-as-scalar",
+                                   "real sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "real scalar");
 
   return retval;
 }
@@ -117,18 +117,18 @@ octave_sparse_matrix::complex_value (boo
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
       if (numel () > 1)
-	gripe_implicit_conversion ("Octave:array-as-scalar",
-				   "real sparse matrix", "complex scalar");
+        gripe_implicit_conversion ("Octave:array-as-scalar",
+                                   "real sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "complex scalar");
 
   return retval;
 }
@@ -207,54 +207,54 @@ octave_sparse_matrix::convert_to_str_int
       char s = '\0';
       retval = octave_value (&s, type);
     }
   else
     {
       octave_idx_type nr = matrix.rows ();
       octave_idx_type nc = matrix.cols ();
       charNDArray chm (dv, static_cast<char> (0));
-	  
+          
       bool warned = false;
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = matrix.cidx(j); 
-	     i < matrix.cidx(j+1); i++)
-	  {
-	    octave_quit ();
+        for (octave_idx_type i = matrix.cidx(j); 
+             i < matrix.cidx(j+1); i++)
+          {
+            octave_quit ();
 
-	    double d = matrix.data (i);
+            double d = matrix.data (i);
 
-	      if (xisnan (d))
-		{
-		  ::error ("invalid conversion from NaN to character");
-		  return retval;
-		}
-	      else
-		{
-		  int ival = NINT (d);
+              if (xisnan (d))
+                {
+                  ::error ("invalid conversion from NaN to character");
+                  return retval;
+                }
+              else
+                {
+                  int ival = NINT (d);
 
-		  if (ival < 0 || ival > UCHAR_MAX)
-		    {
-		      // FIXME -- is there something
-		      // better we could do?
+                  if (ival < 0 || ival > UCHAR_MAX)
+                    {
+                      // FIXME -- is there something
+                      // better we could do?
 
-		      ival = 0;
+                      ival = 0;
 
-		      if (! warned)
-			{
-			  ::warning ("range error for conversion to character value");
-			  warned = true;
-			}
-		    }
+                      if (! warned)
+                        {
+                          ::warning ("range error for conversion to character value");
+                          warned = true;
+                        }
+                    }
 
-		  chm (matrix.ridx(i) + j * nr) = 
-		    static_cast<char> (ival);
-		}
-	  }
+                  chm (matrix.ridx(i) + j * nr) = 
+                    static_cast<char> (ival);
+                }
+          }
 
       retval = octave_value (chm, type);
     }
 
   return retval;
 }
 
 bool 
@@ -284,28 +284,28 @@ octave_sparse_matrix::save_binary (std::
   
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (matrix.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	st = LS_FLOAT;
+        st = LS_FLOAT;
     }
   else if (matrix.nzmax () > 8192) // FIXME -- make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
-	st = get_save_type (max_val, min_val);
+        st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)  
      {
        octave_quit ();
        itmp = matrix.cidx(i);
@@ -321,17 +321,17 @@ octave_sparse_matrix::save_binary (std::
 
    write_doubles (os, matrix.data(), st, nz);
 
   return true;
 }
 
 bool
 octave_sparse_matrix::load_binary (std::istream& is, bool swap,
-				   oct_mach_info::float_format fmt)
+                                   oct_mach_info::float_format fmt)
 {
   int32_t nz, nc, nr, tmp;
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
@@ -352,36 +352,36 @@ octave_sparse_matrix::load_binary (std::
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
-		  static_cast<octave_idx_type> (nc),
-		  static_cast<octave_idx_type> (nz));
+                  static_cast<octave_idx_type> (nc),
+                  static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
       m.xcidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
-	return false;
+        return false;
       if (swap)
-	swap_bytes<4> (&tmp);
+        swap_bytes<4> (&tmp);
       m.xridx(i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
   
   read_doubles (is, m.xdata (), static_cast<save_type> (ctmp), nz, swap, fmt);
 
@@ -395,17 +395,17 @@ octave_sparse_matrix::load_binary (std::
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_sparse_matrix::save_hdf5 (hid_t loc_id, const char *name, 
-				 bool save_as_floats)
+                                 bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
@@ -427,80 +427,80 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     &tmp) >= 0;
+                     &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     &tmp) >= 0;
+                     &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else                   
   data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     &tmp) >= 0;
+                     &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -514,31 +514,31 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     itmp) >= 0;
+                     itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -551,80 +551,80 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     itmp) >= 0;
+                     itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
-	{
-	  warning ("save: some values too large to save as floats --");
-	  warning ("save: saving as doubles instead");
-	}
+        {
+          warning ("save: some values too large to save as floats --");
+          warning ("save: saving as doubles instead");
+        }
       else
-	save_type_hid = H5T_NATIVE_FLOAT;
+        save_type_hid = H5T_NATIVE_FLOAT;
     }
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
-	save_type_hid
-	  = save_type_to_hdf5 (get_save_type (max_val, min_val));
+        save_type_hid
+          = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   double * dtmp = m.xdata ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, dtmp) >= 0;
+                     H5P_DEFAULT, dtmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
@@ -659,17 +659,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, &nr) < 0)
+               H5P_DEFAULT, &nr) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -684,17 +684,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, &nc) < 0)
+               H5P_DEFAULT, &nc) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
   
@@ -709,28 +709,28 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, &nz) < 0)
+               H5P_DEFAULT, &nz) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
-		  static_cast<octave_idx_type> (nc),
-		  static_cast<octave_idx_type> (nz));
+                  static_cast<octave_idx_type> (nc),
+                  static_cast<octave_idx_type> (nz));
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "cidx", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "cidx");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
@@ -754,17 +754,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, itmp) < 0) 
+               H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -793,17 +793,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, itmp) < 0) 
+               H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -833,17 +833,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   double *dtmp = m.xdata ();
   bool retval = false;
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, dtmp) >= 0
+               H5P_DEFAULT, dtmp) >= 0
       && m.indices_ok ())
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -93,26 +93,26 @@ octave_scalar::do_index_op (const octave
 octave_value 
 octave_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       NDArray retval (dv, NDArray::resize_fill_value());
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
   else
     {
       NDArray retval (dv);
 
       if (dv.numel ())
-	retval(0) = scalar;
+        retval(0) = scalar;
 
       return retval;
     }
 }
 
 octave_value
 octave_scalar::convert_to_str_internal (bool, bool, char type) const
 {
@@ -120,23 +120,23 @@ octave_scalar::convert_to_str_internal (
 
   if (xisnan (scalar))
     ::error ("invalid conversion from NaN to character");
   else
     {
       int ival = NINT (scalar);
 
       if (ival < 0 || ival > UCHAR_MAX)
-	{
-	  // FIXME -- is there something better we could do?
+        {
+          // FIXME -- is there something better we could do?
 
-	  ival = 0;
+          ival = 0;
 
-	  ::warning ("range error for conversion to character value");
-	}
+          ::warning ("range error for conversion to character value");
+        }
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
 
   return retval;
 }
 
 bool 
@@ -172,17 +172,17 @@ octave_scalar::save_binary (std::ostream
   double dtmp = double_value ();
   os.write (reinterpret_cast<char *> (&dtmp), 8);
 
   return true;
 }
 
 bool 
 octave_scalar::load_binary (std::istream& is, bool swap,
-			    oct_mach_info::float_format fmt)
+                            oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   double dtmp;
   read_doubles (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
   if (error_state || ! is)
@@ -191,41 +191,41 @@ octave_scalar::load_binary (std::istream
   scalar = dtmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_scalar::save_hdf5 (hid_t loc_id, const char *name,
-			  bool /* save_as_floats */)
+                          bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, &tmp) >= 0;
+                     H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
@@ -243,17 +243,17 @@ octave_scalar::load_hdf5 (hid_t loc_id, 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   double dtmp;
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, &dtmp) < 0)
+               H5P_DEFAULT, &dtmp) < 0)
     { 
       H5Dclose (data_hid);
       return false;
     }
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -83,59 +83,59 @@ octave_base_value::type_conv_info
 octave_char_matrix_str::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_matrix::static_type_id ());
 }
 
 octave_value
 octave_char_matrix_str::do_index_op_internal (const octave_value_list& idx,
-					      bool resize_ok, char type)
+                                              bool resize_ok, char type)
 {
   octave_value retval;
 
   octave_idx_type len = idx.length ();
 
   switch (len)
     {
     case 0:
       retval = octave_value (matrix, type);
       break;
 
     case 1:
       {
-	idx_vector i = idx (0).index_vector ();
+        idx_vector i = idx (0).index_vector ();
 
-	if (! error_state)
-	  retval = octave_value (charNDArray (matrix.index (i, resize_ok)),
-				 type);
+        if (! error_state)
+          retval = octave_value (charNDArray (matrix.index (i, resize_ok)),
+                                 type);
       }
       break;
 
     case 2:
       {
-	idx_vector i = idx (0).index_vector ();
-	idx_vector j = idx (1).index_vector ();
+        idx_vector i = idx (0).index_vector ();
+        idx_vector j = idx (1).index_vector ();
 
-	if (! error_state)
-	  retval = octave_value (charNDArray (matrix.index (i, j, resize_ok)),
-				 type);
+        if (! error_state)
+          retval = octave_value (charNDArray (matrix.index (i, j, resize_ok)),
+                                 type);
       }
       break;
 
     default:
       {
-	Array<idx_vector> idx_vec (len);
+        Array<idx_vector> idx_vec (len);
 
-	for (octave_idx_type i = 0; i < len; i++)
-	  idx_vec(i) = idx(i).index_vector ();
+        for (octave_idx_type i = 0; i < len; i++)
+          idx_vec(i) = idx(i).index_vector ();
 
-	if (! error_state)
-	  retval = octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
-				 type);
+        if (! error_state)
+          retval = octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
+                                 type);
       }
       break;
     }
 
   return retval;
 }
 
 octave_value 
@@ -152,18 +152,18 @@ octave_char_matrix_str::resize (const di
 #define CHAR_MATRIX_CONV(T, INIT, TNAME, FCN) \
   T retval INIT; \
  \
   if (! force_string_conv) \
     gripe_invalid_conversion ("string", TNAME); \
   else \
     { \
       warning_with_id ("Octave:str-to-num", \
-		       "implicit conversion from %s to %s", \
-		       "string", TNAME); \
+                       "implicit conversion from %s to %s", \
+                       "string", TNAME); \
  \
       retval = octave_char_matrix::FCN (); \
     } \
  \
   return retval
 
 double
 octave_char_matrix_str::double_value (bool force_string_conv) const
@@ -194,34 +194,34 @@ octave_char_matrix_str::array_value (boo
 {
   CHAR_MATRIX_CONV (NDArray, , "real N-d array", array_value);
 }
 
 ComplexNDArray
 octave_char_matrix_str::complex_array_value (bool force_string_conv) const
 {
   CHAR_MATRIX_CONV (ComplexNDArray, , "complex N-d array",
-		    complex_array_value);
+                    complex_array_value);
 }
 
 string_vector
 octave_char_matrix_str::all_strings (bool) const
 {
   string_vector retval;
 
   if (matrix.ndims () == 2)
     {
       charMatrix chm = matrix.matrix_value ();
 
       octave_idx_type n = chm.rows ();
 
       retval.resize (n);
 
       for (octave_idx_type i = 0; i < n; i++)
-	retval[i] = chm.row_as_string (i);
+        retval[i] = chm.row_as_string (i);
     }
   else
     error ("invalid conversion of charNDArray to string_vector");
 
   return retval;
 }
 
 std::string
@@ -240,51 +240,51 @@ octave_char_matrix_str::string_value (bo
 
   return retval;
 }
 
 void
 octave_char_matrix_str::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level (), true);
+                         current_print_indent_level (), true);
 }
 
 bool 
 octave_char_matrix_str::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       charNDArray tmp = char_array_value ();
       os << "# ndims: " << d.length () << "\n";
       for (int i=0; i < d.length (); i++)
-	os << " " << d (i);
+        os << " " << d (i);
       os << "\n";
       os.write (tmp.fortran_vec (), d.numel ());
       os << "\n";
     }
   else
     {
       // Keep this case, rather than use generic code above for
       // backward compatiability. Makes load_ascii much more complex!!
       charMatrix chm = char_matrix_value ();
       octave_idx_type elements = chm.rows ();
       os << "# elements: " << elements << "\n";
       for (octave_idx_type i = 0; i < elements; i++)
-	{
-	  unsigned len = chm.cols ();
-	  os << "# length: " << len << "\n";
-	  std::string tstr = chm.row_as_string (i, false, true);
-	  const char *tmp = tstr.data ();
-	  if (tstr.length () > len)
-	    panic_impossible ();
-	  os.write (tmp, len);
-	  os << "\n";
-	}
+        {
+          unsigned len = chm.cols ();
+          os << "# length: " << len << "\n";
+          std::string tstr = chm.row_as_string (i, false, true);
+          const char *tmp = tstr.data ();
+          if (tstr.length () > len)
+            panic_impossible ();
+          os.write (tmp, len);
+          os << "\n";
+        }
     }
 
   return true;
 }
 
 bool 
 octave_char_matrix_str::load_ascii (std::istream& is)
 {
@@ -297,158 +297,158 @@ octave_char_matrix_str::load_ascii (std:
   keywords[2] = "length";
 
   std::string kw;
   int val = 0;
 
   if (extract_keyword (is, keywords, kw, val, true))
     {
       if (kw == "ndims")
-	{
-	  int mdims = val;
+        {
+          int mdims = val;
 
-	  if (mdims >= 0)
-	    {
-	      dim_vector dv;
-	      dv.resize (mdims);
+          if (mdims >= 0)
+            {
+              dim_vector dv;
+              dv.resize (mdims);
 
-	      for (int i = 0; i < mdims; i++)
-		is >> dv(i);
+              for (int i = 0; i < mdims; i++)
+                is >> dv(i);
 
-	      if (is)
-		{
-		  charNDArray tmp(dv);
+              if (is)
+                {
+                  charNDArray tmp(dv);
 
-		  if (tmp.is_empty ())
-		    matrix = tmp;
-		  else
-		    {
-		      char *ftmp = tmp.fortran_vec ();
+                  if (tmp.is_empty ())
+                    matrix = tmp;
+                  else
+                    {
+                      char *ftmp = tmp.fortran_vec ();
 
-		      skip_preceeding_newline (is);
+                      skip_preceeding_newline (is);
 
-		      if (! is.read (ftmp, dv.numel ()) || !is)
-			{
-			  error ("load: failed to load string constant");
-			  success = false;
-			}
-		      else
-			matrix = tmp;
-		    }
-		}
-	      else
-		{
-		  error ("load: failed to read dimensions");
-		  success = false;
-		}
-	    }
-	  else
-	    {
-	      error ("load: failed to extract matrix size");
-	      success = false;
-	    }
-	}
+                      if (! is.read (ftmp, dv.numel ()) || !is)
+                        {
+                          error ("load: failed to load string constant");
+                          success = false;
+                        }
+                      else
+                        matrix = tmp;
+                    }
+                }
+              else
+                {
+                  error ("load: failed to read dimensions");
+                  success = false;
+                }
+            }
+          else
+            {
+              error ("load: failed to extract matrix size");
+              success = false;
+            }
+        }
       else if (kw == "elements")
-	{
-	  int elements = val;
+        {
+          int elements = val;
 
-	  if (elements >= 0)
-	    {
-	      // FIXME -- need to be able to get max length
-	      // before doing anything.
+          if (elements >= 0)
+            {
+              // FIXME -- need to be able to get max length
+              // before doing anything.
 
-	      charMatrix chm (elements, 0);
-	      int max_len = 0;
-	      for (int i = 0; i < elements; i++)
-		{
-		  int len;
-		  if (extract_keyword (is, "length", len) && len >= 0)
-		    {
-		      // Use this instead of a C-style character
-		      // buffer so that we can properly handle
-		      // embedded NUL characters.
-		      charMatrix tmp (1, len);
-		      char *ptmp = tmp.fortran_vec ();
+              charMatrix chm (elements, 0);
+              int max_len = 0;
+              for (int i = 0; i < elements; i++)
+                {
+                  int len;
+                  if (extract_keyword (is, "length", len) && len >= 0)
+                    {
+                      // Use this instead of a C-style character
+                      // buffer so that we can properly handle
+                      // embedded NUL characters.
+                      charMatrix tmp (1, len);
+                      char *ptmp = tmp.fortran_vec ();
 
-		      if (len > 0 && ! is.read (ptmp, len))
-			{
-			  error ("load: failed to load string constant");
-			  success = false;
-			  break;
-			}
-		      else
-			{
-			  if (len > max_len)
-			    {
-			      max_len = len;
-			      chm.resize (elements, max_len, 0);
-			    }
+                      if (len > 0 && ! is.read (ptmp, len))
+                        {
+                          error ("load: failed to load string constant");
+                          success = false;
+                          break;
+                        }
+                      else
+                        {
+                          if (len > max_len)
+                            {
+                              max_len = len;
+                              chm.resize (elements, max_len, 0);
+                            }
 
-			  chm.insert (tmp, i, 0);
-			}
-		    }
-		  else
-		    {
-		      error ("load: failed to extract string length for element %d", 
-			     i+1);
-		      success = false;
-		    }
-		}
-	  
-	      if (! error_state)
-		matrix = chm;
-	    }
-	  else
-	    {
-	      error ("load: failed to extract number of string elements");
-	      success = false;
-	    }
-	}
+                          chm.insert (tmp, i, 0);
+                        }
+                    }
+                  else
+                    {
+                      error ("load: failed to extract string length for element %d", 
+                             i+1);
+                      success = false;
+                    }
+                }
+          
+              if (! error_state)
+                matrix = chm;
+            }
+          else
+            {
+              error ("load: failed to extract number of string elements");
+              success = false;
+            }
+        }
       else if (kw == "length")
-	{
-	  int len = val;
+        {
+          int len = val;
       
-	  if (len >= 0)
-	    {
-	      // This is cruft for backward compatiability, 
-	      // but relatively harmless.
+          if (len >= 0)
+            {
+              // This is cruft for backward compatiability, 
+              // but relatively harmless.
 
-	      // Use this instead of a C-style character buffer so
-	      // that we can properly handle embedded NUL characters.
-	      charMatrix tmp (1, len);
-	      char *ptmp = tmp.fortran_vec ();
+              // Use this instead of a C-style character buffer so
+              // that we can properly handle embedded NUL characters.
+              charMatrix tmp (1, len);
+              char *ptmp = tmp.fortran_vec ();
 
-	      if (len > 0 && ! is.read (ptmp, len))
-		{
-		  error ("load: failed to load string constant");
-		}
-	      else
-		{
-		  if (is)
-		    matrix = tmp;
-		  else
-		    error ("load: failed to load string constant");
-		}
-	    }
-	}
+              if (len > 0 && ! is.read (ptmp, len))
+                {
+                  error ("load: failed to load string constant");
+                }
+              else
+                {
+                  if (is)
+                    matrix = tmp;
+                  else
+                    error ("load: failed to load string constant");
+                }
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
 bool 
 octave_char_matrix_str::save_binary (std::ostream& os,
-				     bool& /* save_as_floats */)
+                                     bool& /* save_as_floats */)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   int32_t tmp = - d.length();
   os.write (reinterpret_cast<char *> (&tmp), 4);
@@ -460,92 +460,92 @@ octave_char_matrix_str::save_binary (std
 
   charNDArray m = char_array_value ();
   os.write (m.fortran_vec (), d.numel ());
   return true;
 }
 
 bool 
 octave_char_matrix_str::load_binary (std::istream& is, bool swap,
-				     oct_mach_info::float_format /* fmt */)
+                                     oct_mach_info::float_format /* fmt */)
 {
   int32_t elements;
   if (! is.read (reinterpret_cast<char *> (&elements), 4))
     return false;
   if (swap)
     swap_bytes<4> (&elements);
 
   if (elements < 0)
     {
       int32_t mdims = - elements;
       int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
-	{
-	  if (! is.read (reinterpret_cast<char *> (&di), 4))
-	    return false;
-	  if (swap)
-	    swap_bytes<4> (&di);
-	  dv(i) = di;
-	}
+        {
+          if (! is.read (reinterpret_cast<char *> (&di), 4))
+            return false;
+          if (swap)
+            swap_bytes<4> (&di);
+          dv(i) = di;
+        }
       
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
       // might.
 
       if (mdims == 1)
-	{
-	  mdims = 2;
-	  dv.resize (mdims);
-	  dv(1) = dv(0);
-	  dv(0) = 1;
-	}
+        {
+          mdims = 2;
+          dv.resize (mdims);
+          dv(1) = dv(0);
+          dv(0) = 1;
+        }
 
       charNDArray m(dv);
       char *tmp = m.fortran_vec ();
       is.read (tmp, dv.numel ());
       
       if (error_state || ! is)
-	return false;
+        return false;
       matrix = m;
     }
   else
     {
       charMatrix chm (elements, 0);
       int max_len = 0;
       for (int i = 0; i < elements; i++)
-	{
-	  int32_t len;
-	  if (! is.read (reinterpret_cast<char *> (&len), 4))
-	    return false;
-	  if (swap)
-	    swap_bytes<4> (&len);
-	  charMatrix btmp (1, len);
-	  char *pbtmp = btmp.fortran_vec ();
-	  if (! is.read (pbtmp, len))
-	    return false;
-	  if (len > max_len)
-	    {
-	      max_len = len;
-	      chm.resize (elements, max_len, 0);
-	    }
-	  chm.insert (btmp, i, 0);
-	}
+        {
+          int32_t len;
+          if (! is.read (reinterpret_cast<char *> (&len), 4))
+            return false;
+          if (swap)
+            swap_bytes<4> (&len);
+          charMatrix btmp (1, len);
+          char *pbtmp = btmp.fortran_vec ();
+          if (! is.read (pbtmp, len))
+            return false;
+          if (len > max_len)
+            {
+              max_len = len;
+              chm.resize (elements, max_len, 0);
+            }
+          chm.insert (btmp, i, 0);
+        }
       matrix = chm;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_char_matrix_str::save_hdf5 (hid_t loc_id, const char *name,
-				   bool /* save_as_floats */)
+                                   bool /* save_as_floats */)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid = -1, data_hid = -1;
@@ -558,34 +558,34 @@ octave_char_matrix_str::save_hdf5 (hid_t
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
  
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0)
     return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid, 
-			H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+                        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid, 
-			H5P_DEFAULT);
+                        H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (char, s, dv.numel ());
 
   for (int i = 0; i < dv.numel (); ++i)
     s[i] = m(i);
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL, 
-		     H5P_DEFAULT, s) >= 0;
+                     H5P_DEFAULT, s) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool 
@@ -608,151 +608,151 @@ octave_char_matrix_str::load_hdf5 (hid_t
   hid_t space_hid = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_hid);
   hid_t type_hid = H5Dget_type (data_hid);
   hid_t type_class_hid = H5Tget_class (type_hid);
 
   if (type_class_hid == H5T_INTEGER)
     {
       if (rank < 1)
-	{
-	  H5Tclose (type_hid);
-	  H5Sclose (space_hid);
-	  H5Dclose (data_hid);
-	  return false;
-	}
+        {
+          H5Tclose (type_hid);
+          H5Sclose (space_hid);
+          H5Dclose (data_hid);
+          return false;
+        }
 
       OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
       OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
       H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
       // Octave uses column-major, while HDF5 uses row-major ordering
       if (rank == 1)
-	{
-	  dv.resize (2);
-	  dv(0) = 1;
-	  dv(1) = hdims[0];
-	}
+        {
+          dv.resize (2);
+          dv(0) = 1;
+          dv(1) = hdims[0];
+        }
       else
-	{
-	  dv.resize (rank);
-	  for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
-	    dv(j) = hdims[i];
-	}
+        {
+          dv.resize (rank);
+          for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
+            dv(j) = hdims[i];
+        }
 
       charNDArray m (dv);
       char *str = m.fortran_vec ();
       if (H5Dread (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL, 
-		   H5P_DEFAULT, str) >= 0) 
-	{
-	  retval = true;
-	  matrix = m;
-	}
+                   H5P_DEFAULT, str) >= 0) 
+        {
+          retval = true;
+          matrix = m;
+        }
 
       H5Tclose (type_hid);
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       return true;
     }
   else
     {
       // This is cruft for backward compatiability and easy data
       // importation
       if (rank == 0)
-	{
-	  // a single string:
-	  int slen = H5Tget_size (type_hid);
-	  if (slen < 0)
-	    {
-	      H5Tclose (type_hid);
-	      H5Sclose (space_hid);
-	      H5Dclose (data_hid);
-	      return false;
-	    }
-	  else
-	    {
-	      OCTAVE_LOCAL_BUFFER (char, s, slen);
-	      // create datatype for (null-terminated) string
-	      // to read into:
-	      hid_t st_id = H5Tcopy (H5T_C_S1);
-	      H5Tset_size (st_id, slen);
-	      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
-		{
-		  H5Tclose (st_id);
-		  H5Tclose (type_hid);
-		  H5Sclose (space_hid);
-		  H5Dclose (data_hid);
-		  return false;
-		}
+        {
+          // a single string:
+          int slen = H5Tget_size (type_hid);
+          if (slen < 0)
+            {
+              H5Tclose (type_hid);
+              H5Sclose (space_hid);
+              H5Dclose (data_hid);
+              return false;
+            }
+          else
+            {
+              OCTAVE_LOCAL_BUFFER (char, s, slen);
+              // create datatype for (null-terminated) string
+              // to read into:
+              hid_t st_id = H5Tcopy (H5T_C_S1);
+              H5Tset_size (st_id, slen);
+              if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
+                {
+                  H5Tclose (st_id);
+                  H5Tclose (type_hid);
+                  H5Sclose (space_hid);
+                  H5Dclose (data_hid);
+                  return false;
+                }
 
-	      matrix = charMatrix (s);
-	  
-	      H5Tclose (st_id);
-	      H5Tclose (type_hid);
-	      H5Sclose (space_hid);
-	      H5Dclose (data_hid);
-	      return true;
-	    }
-	}
+              matrix = charMatrix (s);
+          
+              H5Tclose (st_id);
+              H5Tclose (type_hid);
+              H5Sclose (space_hid);
+              H5Dclose (data_hid);
+              return true;
+            }
+        }
       else if (rank == 1)
-	{
-	  // string vector
-	  hsize_t elements, maxdim;
-	  H5Sget_simple_extent_dims (space_hid, &elements, &maxdim);
-	  int slen = H5Tget_size (type_hid);
-	  if (slen < 0)
-	    {
-	      H5Tclose (type_hid);
-	      H5Sclose (space_hid);
-	      H5Dclose (data_hid);
-	      return false;
-	    }
-	  else
-	    {
-	      // hdf5 string arrays store strings of all the
-	      // same physical length (I think), which is
-	      // slightly wasteful, but oh well.
-	  
-	      OCTAVE_LOCAL_BUFFER (char, s, elements * slen);
+        {
+          // string vector
+          hsize_t elements, maxdim;
+          H5Sget_simple_extent_dims (space_hid, &elements, &maxdim);
+          int slen = H5Tget_size (type_hid);
+          if (slen < 0)
+            {
+              H5Tclose (type_hid);
+              H5Sclose (space_hid);
+              H5Dclose (data_hid);
+              return false;
+            }
+          else
+            {
+              // hdf5 string arrays store strings of all the
+              // same physical length (I think), which is
+              // slightly wasteful, but oh well.
+          
+              OCTAVE_LOCAL_BUFFER (char, s, elements * slen);
 
-	      // create datatype for (null-terminated) string
-	      // to read into:
-	      hid_t st_id = H5Tcopy (H5T_C_S1);
-	      H5Tset_size (st_id, slen);
+              // create datatype for (null-terminated) string
+              // to read into:
+              hid_t st_id = H5Tcopy (H5T_C_S1);
+              H5Tset_size (st_id, slen);
 
-	      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
-		{
-		  H5Tclose (st_id);
-		  H5Tclose (type_hid);
-		  H5Sclose (space_hid);
-		  H5Dclose (data_hid);
-		  return false;
-		}
+              if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
+                {
+                  H5Tclose (st_id);
+                  H5Tclose (type_hid);
+                  H5Sclose (space_hid);
+                  H5Dclose (data_hid);
+                  return false;
+                }
 
-	      charMatrix chm (elements, slen - 1);
-	      for (hsize_t i = 0; i < elements; ++i)
-		{
-		  chm.insert (s + i*slen, i, 0);
-		}
+              charMatrix chm (elements, slen - 1);
+              for (hsize_t i = 0; i < elements; ++i)
+                {
+                  chm.insert (s + i*slen, i, 0);
+                }
 
-	      matrix = chm;
+              matrix = chm;
 
-	      H5Tclose (st_id);
-	      H5Tclose (type_hid);
-	      H5Sclose (space_hid);
-	      H5Dclose (data_hid);
-	      return true;
-	    }
-	}
+              H5Tclose (st_id);
+              H5Tclose (type_hid);
+              H5Sclose (space_hid);
+              H5Dclose (data_hid);
+              return true;
+            }
+        }
       else
-	{
-	  H5Tclose (type_hid);
-	  H5Sclose (space_hid);
-	  H5Dclose (data_hid);
-	  return false;
-	}
+        {
+          H5Tclose (type_hid);
+          H5Sclose (space_hid);
+          H5Dclose (data_hid);
+          return false;
+        }
     }
 
   return retval;
 }
 
 #endif
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -95,59 +95,59 @@ gripe_invalid_index_type (const std::str
 static void
 gripe_failed_assignment (void)
 {
   error ("assignment to structure element failed");
 }
 
 octave_value_list
 octave_struct::subsref (const std::string& type,
-			const std::list<octave_value_list>& idx,
-			int nargout)
+                        const std::list<octave_value_list>& idx,
+                        int nargout)
 {
   octave_value_list retval;
 
   int skip = 1;
 
   switch (type[0])
     {
     case '(':
       {
-	if (type.length () > 1 && type[1] == '.')
-	  {
-	    std::list<octave_value_list>::const_iterator p = idx.begin ();
-	    octave_value_list key_idx = *++p;
+        if (type.length () > 1 && type[1] == '.')
+          {
+            std::list<octave_value_list>::const_iterator p = idx.begin ();
+            octave_value_list key_idx = *++p;
 
-	    const Cell tmp = dotref (key_idx);
+            const Cell tmp = dotref (key_idx);
 
-	    if (! error_state)
-	      {
-		const Cell t = tmp.index (idx.front ());
+            if (! error_state)
+              {
+                const Cell t = tmp.index (idx.front ());
 
-		retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+                retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
 
-		// We handled two index elements, so tell
-		// next_subsref to skip both of them.
+                // We handled two index elements, so tell
+                // next_subsref to skip both of them.
 
-		skip++;
-	      }
-	  }
-	else
-	  retval(0) = map.index (idx.front ());
+                skip++;
+              }
+          }
+        else
+          retval(0) = map.index (idx.front ());
       }
       break;
 
     case '.':
       {
-	if (map.numel() > 0)
-	  {
-	    const Cell t = dotref (idx.front ());
+        if (map.numel() > 0)
+          {
+            const Cell t = dotref (idx.front ());
 
-	    retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
-	  }
+            retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+          }
       }
       break;
 
     case '{':
       gripe_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
@@ -161,59 +161,59 @@ octave_struct::subsref (const std::strin
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
 }
 
 octave_value
 octave_struct::subsref (const std::string& type,
-			const std::list<octave_value_list>& idx,
-			bool auto_add)
+                        const std::list<octave_value_list>& idx,
+                        bool auto_add)
 {
   octave_value retval;
 
   int skip = 1;
 
   switch (type[0])
     {
     case '(':
       {
-	if (type.length () > 1 && type[1] == '.')
-	  {
-	    std::list<octave_value_list>::const_iterator p = idx.begin ();
-	    octave_value_list key_idx = *++p;
+        if (type.length () > 1 && type[1] == '.')
+          {
+            std::list<octave_value_list>::const_iterator p = idx.begin ();
+            octave_value_list key_idx = *++p;
 
-	    const Cell tmp = dotref (key_idx, auto_add);
+            const Cell tmp = dotref (key_idx, auto_add);
 
-	    if (! error_state)
-	      {
-		const Cell t = tmp.index (idx.front (), auto_add);
+            if (! error_state)
+              {
+                const Cell t = tmp.index (idx.front (), auto_add);
 
-		retval = (t.length () == 1) ? t(0) : octave_value (t, true);
+                retval = (t.length () == 1) ? t(0) : octave_value (t, true);
 
-		// We handled two index elements, so tell
-		// next_subsref to skip both of them.
+                // We handled two index elements, so tell
+                // next_subsref to skip both of them.
 
-		skip++;
-	      }
-	  }
-	else
-	  retval = map.index (idx.front (), auto_add);
+                skip++;
+              }
+          }
+        else
+          retval = map.index (idx.front (), auto_add);
       }
       break;
 
     case '.':
       {
-	if (map.numel() > 0)
-	  {
-	    const Cell t = dotref (idx.front (), auto_add);
+        if (map.numel() > 0)
+          {
+            const Cell t = dotref (idx.front (), auto_add);
 
-	    retval = (t.length () == 1) ? t(0) : octave_value (t, true);
-	  }
+            retval = (t.length () == 1) ? t(0) : octave_value (t, true);
+          }
       }
       break;
 
     case '{':
       gripe_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
@@ -235,61 +235,61 @@ octave_struct::subsref (const std::strin
 %! x(1).a.a = 1; x(2).a.a = 2;
 %! assert (size (x), [1, 2]);
 %! assert (x(1).a.a, 1);
 %! assert (x(2).a.a, 2);
 */
 
 octave_value
 octave_struct::numeric_conv (const octave_value& val,
-			     const std::string& type)
+                             const std::string& type)
 {
   octave_value retval;
 
   if (type.length () > 0 && type[0] == '.' && ! val.is_map ())
     retval = Octave_map ();
   else
     retval = val;
 
   return retval;
 }
 
 octave_value
 octave_struct::subsasgn (const std::string& type,
-			 const std::list<octave_value_list>& idx,
-			 const octave_value& rhs)
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs)
 {
   octave_value retval;
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
   if (idx.front ().empty ())
     {
       error ("missing index in indexed assignment");
       return retval;
     }
 
   if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
     {
       switch (type[0])
-	{
-	case '(':
-	  {
-	    if (type.length () > 1 && type[1] == '.')
-	      {
-		std::list<octave_value_list>::const_iterator p = idx.begin ();
-		octave_value_list t_idx = *p;
+        {
+        case '(':
+          {
+            if (type.length () > 1 && type[1] == '.')
+              {
+                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                octave_value_list t_idx = *p;
 
-		octave_value_list key_idx = *++p;
+                octave_value_list key_idx = *++p;
 
-		assert (key_idx.length () == 1);
+                assert (key_idx.length () == 1);
 
-		std::string key = key_idx(0).string_value ();
+                std::string key = key_idx(0).string_value ();
 
                 std::list<octave_value_list> next_idx (idx);
 
                 // We handled two index elements, so subsasgn to
                 // needs to skip both of them.
 
                 next_idx.erase (next_idx.begin ());
                 next_idx.erase (next_idx.begin ());
@@ -300,18 +300,18 @@ octave_struct::subsasgn (const std::stri
                 Octave_map::iterator pkey = map.seek (key);
                 if (pkey != map.end ())
                   {
                     pkey->second.make_unique ();
                     tmpc = pkey->second.index (idx.front (), true);
                   }
 
                 // FIXME: better code reuse? cf. octave_cell::subsasgn and the case below.
-		if (! error_state)
-		  {
+                if (! error_state)
+                  {
                     if (tmpc.numel () == 1)
                       {
                         octave_value& tmp = tmpc(0);
 
                         if (! tmp.is_defined () || tmp.is_zero_by_zero ())
                           {
                             tmp = octave_value::empty_conv (next_type, rhs);
                             tmp.make_unique (); // probably a no-op.
@@ -320,30 +320,30 @@ octave_struct::subsasgn (const std::stri
                           // optimization: ignore the copy still stored inside our map.
                           tmp.make_unique (1);
 
                         if (! error_state)
                           t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
                       }
                     else
                       gripe_indexed_cs_list ();
-		  }
-	      }
-	    else
-	      gripe_invalid_index_for_assignment ();
-	  }
-	  break;
+                  }
+              }
+            else
+              gripe_invalid_index_for_assignment ();
+          }
+          break;
 
-	case '.':
-	  {
-	    octave_value_list key_idx = idx.front ();
+        case '.':
+          {
+            octave_value_list key_idx = idx.front ();
 
-	    assert (key_idx.length () == 1);
+            assert (key_idx.length () == 1);
 
-	    std::string key = key_idx(0).string_value ();
+            std::string key = key_idx(0).string_value ();
 
             std::list<octave_value_list> next_idx (idx);
 
             next_idx.erase (next_idx.begin ());
 
             std::string next_type = type.substr (1);
 
             Cell tmpc (1, 1);
@@ -371,46 +371,46 @@ octave_struct::subsasgn (const std::stri
                       tmp.make_unique (1);
 
                     if (! error_state)
                       t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
                   }
                 else
                   gripe_indexed_cs_list ();
               }
-	  }
-	  break;
+          }
+          break;
 
-	case '{':
-	  gripe_invalid_index_type (type_name (), type[0]);
-	  break;
+        case '{':
+          gripe_invalid_index_type (type_name (), type[0]);
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
     }
 
   if (! error_state)
     {
       switch (type[0])
-	{
-	case '(':
-	  {
-	    if (n > 1 && type[1] == '.')
-	      {
-		std::list<octave_value_list>::const_iterator p = idx.begin ();
-		octave_value_list key_idx = *++p;
+        {
+        case '(':
+          {
+            if (n > 1 && type[1] == '.')
+              {
+                std::list<octave_value_list>::const_iterator p = idx.begin ();
+                octave_value_list key_idx = *++p;
                 octave_value_list idxf = idx.front ();
 
-		assert (key_idx.length () == 1);
+                assert (key_idx.length () == 1);
 
-		std::string key = key_idx(0).string_value ();
+                std::string key = key_idx(0).string_value ();
 
-		if (! error_state)
-		  {
+                if (! error_state)
+                  {
                     if (t_rhs.is_cs_list ())
                       {
                         Cell tmp_cell = Cell (t_rhs.list_value ());
 
                         // Inquire the proper shape of the RHS.
 
                         dim_vector didx = dims ().redim (idxf.length ());
                         for (octave_idx_type k = 0; k < idxf.length (); k++)
@@ -444,104 +444,104 @@ octave_struct::subsasgn (const std::stri
                                 retval = octave_value (this);
                               }
                             else
                               gripe_failed_assignment ();
                           }
                         else if (! error_state)
                           gripe_nonbraced_cs_list_assignment ();
                       }
-		  }
-		else
-		  gripe_failed_assignment ();
-	      }
-	    else
-	      {
-		if (t_rhs.is_map())
-		  {
-		    Octave_map rhs_map = t_rhs.map_value ();
+                  }
+                else
+                  gripe_failed_assignment ();
+              }
+            else
+              {
+                if (t_rhs.is_map())
+                  {
+                    Octave_map rhs_map = t_rhs.map_value ();
 
-		    if (! error_state)
-		      {
-			map.assign (idx.front (), rhs_map);
+                    if (! error_state)
+                      {
+                        map.assign (idx.front (), rhs_map);
 
-			if (! error_state)
-			  {
-			    count++;
-			    retval = octave_value (this);
-			  }
-			else
-			  gripe_failed_assignment ();
-		      }
-		    else
-		      error ("invalid structure assignment");
-		  }
-		else
-		  {
-		    if (t_rhs.is_null_value()) 
-		      {
-			map.maybe_delete_elements (idx.front());
+                        if (! error_state)
+                          {
+                            count++;
+                            retval = octave_value (this);
+                          }
+                        else
+                          gripe_failed_assignment ();
+                      }
+                    else
+                      error ("invalid structure assignment");
+                  }
+                else
+                  {
+                    if (t_rhs.is_null_value()) 
+                      {
+                        map.maybe_delete_elements (idx.front());
 
-			if (! error_state)
-			  {
-			    count++;
-			    retval = octave_value (this);
-			  }
-			else
-			  gripe_failed_assignment ();
-		      }
-		    else
-		      error ("invalid structure assignment");
-		  }
-	      }
-	  }
-	  break;
+                        if (! error_state)
+                          {
+                            count++;
+                            retval = octave_value (this);
+                          }
+                        else
+                          gripe_failed_assignment ();
+                      }
+                    else
+                      error ("invalid structure assignment");
+                  }
+              }
+          }
+          break;
 
-	case '.':
-	  {
-	    octave_value_list key_idx = idx.front ();
+        case '.':
+          {
+            octave_value_list key_idx = idx.front ();
 
-	    assert (key_idx.length () == 1);
+            assert (key_idx.length () == 1);
 
-	    std::string key = key_idx(0).string_value ();
+            std::string key = key_idx(0).string_value ();
 
-	    if (t_rhs.is_cs_list ())
-	      {
-		Cell tmp_cell = Cell (t_rhs.list_value ());
+            if (t_rhs.is_cs_list ())
+              {
+                Cell tmp_cell = Cell (t_rhs.list_value ());
 
-		// The shape of the RHS is irrelevant, we just want
-		// the number of elements to agree and to preserve the
-		// shape of the left hand side of the assignment.
+                // The shape of the RHS is irrelevant, we just want
+                // the number of elements to agree and to preserve the
+                // shape of the left hand side of the assignment.
 
-		if (numel () == tmp_cell.numel ())
-		  tmp_cell = tmp_cell.reshape (dims ());
+                if (numel () == tmp_cell.numel ())
+                  tmp_cell = tmp_cell.reshape (dims ());
 
-		map.assign (key, tmp_cell);
-	      }
-	    else
+                map.assign (key, tmp_cell);
+              }
+            else
               // Regularize a null matrix if stored into a struct component.
-	      map.assign (key, t_rhs.storable_value ());
+              map.assign (key, t_rhs.storable_value ());
 
-	    if (! error_state)
-	      {
-		count++;
-		retval = octave_value (this);
-	      }
-	    else
-	      gripe_failed_assignment ();
-	  }
-	  break;
+            if (! error_state)
+              {
+                count++;
+                retval = octave_value (this);
+              }
+            else
+              gripe_failed_assignment ();
+          }
+          break;
 
-	case '{':
-	  gripe_invalid_index_type (type_name (), type[0]);
-	  break;
+        case '{':
+          gripe_invalid_index_type (type_name (), type[0]);
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
     }
   else
     gripe_failed_assignment ();
 
   return retval;
 }
 
 octave_value
@@ -591,53 +591,53 @@ octave_struct::print_raw (std::ostream& 
       os << "{";
       newline (os);
 
       increment_indent_level ();
 
       octave_idx_type n = map.numel ();
 
       if (n != 1 || print_keys_only)
-	{
-	  indent (os);
-	  dim_vector dv = dims ();
-	  os << dv.str () << " struct array containing the fields:";
-	  newline (os);
-	  newline (os);
+        {
+          indent (os);
+          dim_vector dv = dims ();
+          os << dv.str () << " struct array containing the fields:";
+          newline (os);
+          newline (os);
 
-	  increment_indent_level ();
-	}
+          increment_indent_level ();
+        }
 
       string_vector key_list = map.keys ();
 
       for (octave_idx_type i = 0; i < key_list.length (); i++)
-	{
-	  std::string key = key_list[i];
+        {
+          std::string key = key_list[i];
 
-	  Cell val = map.contents (key);
+          Cell val = map.contents (key);
 
-	  octave_value tmp = (n == 1) ? val(0) : octave_value (val, true);
+          octave_value tmp = (n == 1) ? val(0) : octave_value (val, true);
 
-	  if (n != 1 || print_keys_only)
-	    {
-	      indent (os);
-	      os << key;
-	      if (n == 1)
-		{
-		  dim_vector dv = tmp.dims ();
-		  os << ": " << dv.str () << " " << tmp.type_name ();
-		}
-	      newline (os);
-	    }
-	  else
-	    tmp.print_with_name (os, key);
-	}
+          if (n != 1 || print_keys_only)
+            {
+              indent (os);
+              os << key;
+              if (n == 1)
+                {
+                  dim_vector dv = tmp.dims ();
+                  os << ": " << dv.str () << " " << tmp.type_name ();
+                }
+              newline (os);
+            }
+          else
+            tmp.print_with_name (os, key);
+        }
 
       if (n != 1 || print_keys_only)
-	decrement_indent_level ();
+        decrement_indent_level ();
 
       decrement_indent_level ();
 
       indent (os);
       os << "}";
       newline (os);
     }
   else
@@ -729,110 +729,110 @@ If the argument is an object, return the
     }
 
   if ((nargin == 1 || nargin == 2)
       && args(0).is_empty () && args(0).is_real_matrix ())
     {
       Cell fields;
 
       if (nargin == 2)
-	{
-	  if (args(1).is_cellstr ())
-	    retval = Octave_map (args(0).dims (), args(1).cell_value ());
-	  else
-	    error ("struct: expecting cell array of field names as second argument");
-	}
+        {
+          if (args(1).is_cellstr ())
+            retval = Octave_map (args(0).dims (), args(1).cell_value ());
+          else
+            error ("struct: expecting cell array of field names as second argument");
+        }
       else
-	retval = Octave_map (args(0).dims ());
+        retval = Octave_map (args(0).dims ());
 
       return retval;
     }
     
   // Check for "field", VALUE pairs.
 
   for (int i = 0; i < nargin; i += 2) 
     {
       if (! args(i).is_string () || i + 1 >= nargin)
-	{
-	  error ("struct expects alternating \"field\", VALUE pairs");
-	  return retval;
-	}
+        {
+          error ("struct expects alternating \"field\", VALUE pairs");
+          return retval;
+        }
     }
 
   // Check that the dimensions of the values correspond.
 
   dim_vector dims (1, 1);
 
   int first_dimensioned_value = 0;
 
   for (int i = 1; i < nargin; i += 2) 
     {
       if (args(i).is_cell ()) 
-	{
-	  dim_vector argdims (args(i).dims ());
+        {
+          dim_vector argdims (args(i).dims ());
 
-	  if (! scalar (argdims))
-	    {
-	      if (! first_dimensioned_value)
-		{
-		  dims = argdims;
-		  first_dimensioned_value = i + 1;
-		}
-	      else if (dims != argdims)
-		{
-		  error ("struct: dimensions of parameter %d do not match those of parameter %d",
-			 first_dimensioned_value, i+1);
-		  return retval;
-		}
-	    }
-	}
+          if (! scalar (argdims))
+            {
+              if (! first_dimensioned_value)
+                {
+                  dims = argdims;
+                  first_dimensioned_value = i + 1;
+                }
+              else if (dims != argdims)
+                {
+                  error ("struct: dimensions of parameter %d do not match those of parameter %d",
+                         first_dimensioned_value, i+1);
+                  return retval;
+                }
+            }
+        }
     }
 
   // Create the return value.
 
   Octave_map map (dims);
 
   for (int i = 0; i < nargin; i+= 2) 
     {
       // Get key.
 
       std::string key (args(i).string_value ());
 
       if (error_state)
-	return retval;
+        return retval;
 
       if (! valid_identifier (key))
-	{
-	  error ("struct: invalid structure field name `%s'", key.c_str ());
-	  return retval;
-	}
+        {
+          error ("struct: invalid structure field name `%s'", key.c_str ());
+          return retval;
+        }
 
       // Value may be v, { v }, or { v1, v2, ... }
       // In the first two cases, we need to create a cell array of
       // the appropriate dimensions filled with v.  In the last case, 
       // the cell array has already been determined to be of the
       // correct dimensions.
 
       if (args(i+1).is_cell ()) 
-	{
-	  const Cell c (args(i+1).cell_value ());
+        {
+          const Cell c (args(i+1).cell_value ());
 
-	  if (error_state)
-	    return retval;
+          if (error_state)
+            return retval;
 
-	  if (scalar (c.dims ())) 
-	    map.assign (key, Cell (dims, c(0)));
-	  else 
-	    map.assign (key, c);
-	}
+          if (scalar (c.dims ())) 
+            map.assign (key, Cell (dims, c(0)));
+          else 
+            map.assign (key, c);
+        }
       else 
-	map.assign (key, Cell (dims, args(i+1)));
+        map.assign (key, Cell (dims, args(i+1)));
 
       if (error_state)
-	return retval;
+        return retval;
     }
 
   return octave_value (map);
 }
 
 DEFUN (isstruct, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isstruct (@var{expr})\n\
@@ -862,28 +862,28 @@ argument that is not a structure.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_map () || arg.is_object ())
-	{
-	  Octave_map m = arg.map_value ();
+        {
+          Octave_map m = arg.map_value ();
 
-	  string_vector keys = m.keys ();
+          string_vector keys = m.keys ();
 
-	  if (keys.length () == 0)
-	    retval = Cell (0, 1);
-	  else
-	    retval = Cell (m.keys ());
-	}
+          if (keys.length () == 0)
+            retval = Cell (0, 1);
+          else
+            retval = Cell (m.keys ());
+        }
       else
-	gripe_wrong_type_arg ("fieldnames", args(0));
+        gripe_wrong_type_arg ("fieldnames", args(0));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -908,23 +908,23 @@ the second must be a string.\n\
   if (nargin == 2)
     {
       retval = false;
 
       // FIXME -- should this work for all types that can do
       // structure reference operations?
 
       if (args(0).is_map () && args(1).is_string ())
-	{
-	  std::string key = args(1).string_value ();
+        {
+          std::string key = args(1).string_value ();
 
-	  Octave_map m = args(0).map_value ();
+          Octave_map m = args(0).map_value ();
 
-	  retval = m.contains (key) != 0;
-	}
+          retval = m.contains (key) != 0;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nfields, args, ,
@@ -958,70 +958,70 @@ Return the number of fields of the struc
 %!assert( isfield( struct("a", "b"), "a "), logical (0));
 
 */
 
 // Check that the dimensions of the input arguments are correct.
 
 static bool
 cell2struct_check_args (const dim_vector& c_dv, const dim_vector& f_dv,
-			bool is_cell, int dim)
+                        bool is_cell, int dim)
 {
   bool retval = true;
 
   if (dim >= 0 && dim < c_dv.length ())
     {
       if (is_cell)
-	{
-	  if (f_dv.numel () != c_dv(dim))
-	    {
-	      error ("cell2struct: numel (FIELD) != size (CELL, DIM)");
+        {
+          if (f_dv.numel () != c_dv(dim))
+            {
+              error ("cell2struct: numel (FIELD) != size (CELL, DIM)");
 
-	      retval = false;
-	    }
-	}
+              retval = false;
+            }
+        }
       else
-	{
-	  if (f_dv.length () > 2)
-	    {
-	      error ("cell2struct: field array must be a 2-d matrix");
+        {
+          if (f_dv.length () > 2)
+            {
+              error ("cell2struct: field array must be a 2-d matrix");
 
-	      retval = false;
-	    }
-	  else if (f_dv(0) != c_dv(dim))
-	    {
-	      error ("cell2struct: size (FIELD, 1) != length (C, DIM)");
+              retval = false;
+            }
+          else if (f_dv(0) != c_dv(dim))
+            {
+              error ("cell2struct: size (FIELD, 1) != length (C, DIM)");
 
-	      retval = false;
-	    }
-	}
+              retval = false;
+            }
+        }
     }
   else
     {
       error ("cell2struct: DIM out of range");
 
       retval = false;
     }
 
   return retval;
 }
 
 static void
 cell2struct_construct_idx (Array<octave_idx_type>& ra_idx1,
-			   const Array<octave_idx_type>& ra_idx2,
-			   octave_idx_type dim, octave_idx_type fill_value)
+                           const Array<octave_idx_type>& ra_idx2,
+                           octave_idx_type dim, octave_idx_type fill_value)
 {
   octave_idx_type iidx = 0;
 
   for (octave_idx_type idx = 0; idx < ra_idx1.length (); idx++)
     {
       if (idx == dim)
-	ra_idx1.elem (idx) = fill_value;
+        ra_idx1.elem (idx) = fill_value;
       else
-	ra_idx1.elem (idx) = ra_idx2(iidx++);
+        ra_idx1.elem (idx) = ra_idx2(iidx++);
     }
 }
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
@@ -1045,165 +1045,165 @@ A(1)\n\
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
       Cell c = args(0).cell_value ();
 
       if (! error_state)
-	{
-	  octave_value field = args(1);
+        {
+          octave_value field = args(1);
 
-	  // Field is either cell or character matrix.
+          // Field is either cell or character matrix.
 
-	  // FIXME -- this could be simplified if we had
-	  // cellstr and iscellstr functions available.
+          // FIXME -- this could be simplified if we had
+          // cellstr and iscellstr functions available.
 
-	  bool field_is_cell = field.is_cell ();
+          bool field_is_cell = field.is_cell ();
 
-	  Cell field_cell;
-	  charMatrix field_char;
+          Cell field_cell;
+          charMatrix field_char;
 
-	  if (field_is_cell)
-	    field_cell = field.cell_value ();
-	  else
-	    field_char = field.char_matrix_value ();
+          if (field_is_cell)
+            field_cell = field.cell_value ();
+          else
+            field_char = field.char_matrix_value ();
 
-	  if (! error_state)
-	    {
-	      // Retrieve the dimension value.
+          if (! error_state)
+            {
+              // Retrieve the dimension value.
 
-	      // FIXME --  int_value () should print out the
-	      // conversions it does to be Matlab compatible.
+              // FIXME --  int_value () should print out the
+              // conversions it does to be Matlab compatible.
 
-	      octave_idx_type dim = args(2).int_value () - 1;
+              octave_idx_type dim = args(2).int_value () - 1;
 
-	      if (! error_state)
-		{
-		  dim_vector c_dv = c.dims ();
-		  dim_vector field_dv = field.dims ();
+              if (! error_state)
+                {
+                  dim_vector c_dv = c.dims ();
+                  dim_vector field_dv = field.dims ();
 
-		  if (cell2struct_check_args (c_dv, field_dv, field_is_cell,
-					      dim))
-		    {
-		      octave_idx_type c_dv_length = c_dv.length ();
+                  if (cell2struct_check_args (c_dv, field_dv, field_is_cell,
+                                              dim))
+                    {
+                      octave_idx_type c_dv_length = c_dv.length ();
 
-		      // Dimension vector for the Cell arrays to be
-		      // put into the structure.
+                      // Dimension vector for the Cell arrays to be
+                      // put into the structure.
 
-		      dim_vector value_dv;
+                      dim_vector value_dv;
 
-		      // Initialize c_value_dv.
+                      // Initialize c_value_dv.
 
-		      if (c_dv_length == 2)
-			value_dv = dim_vector (1, 1);
-		      else
-			value_dv.resize (c_dv_length - 1);
+                      if (c_dv_length == 2)
+                        value_dv = dim_vector (1, 1);
+                      else
+                        value_dv.resize (c_dv_length - 1);
 
-		      octave_idx_type idx_tmp = 0;
+                      octave_idx_type idx_tmp = 0;
 
-		      for (octave_idx_type i = 0; i < c_dv_length; i++)
-			{
-			  if (i != dim)
-			    value_dv.elem (idx_tmp++) = c_dv.elem (i);
-			}
+                      for (octave_idx_type i = 0; i < c_dv_length; i++)
+                        {
+                          if (i != dim)
+                            value_dv.elem (idx_tmp++) = c_dv.elem (i);
+                        }
 
-		      // All initializing is done, we can start moving
-		      // values.
+                      // All initializing is done, we can start moving
+                      // values.
 
-		      Octave_map map;
+                      Octave_map map;
 
-		      // If field is a cell array then we use all
-		      // elements in array, on the other hand when
-		      // field is a character array the number of
-		      // elements is equals the number of rows.
+                      // If field is a cell array then we use all
+                      // elements in array, on the other hand when
+                      // field is a character array the number of
+                      // elements is equals the number of rows.
 
-		      octave_idx_type field_numel
-			= field_is_cell ? field_dv.numel (): field_dv(0);
+                      octave_idx_type field_numel
+                        = field_is_cell ? field_dv.numel (): field_dv(0);
 
-		      // For matlab compatibility.
+                      // For matlab compatibility.
 
-		      if (field_numel == 0)
-			map.reshape (dim_vector (0, 1));
+                      if (field_numel == 0)
+                        map.reshape (dim_vector (0, 1));
 
-		      for (octave_idx_type i = 0; i < field_numel; i++)
-			{
-			  // Construct cell array which goes into the
-			  // structure together with the appropriate
-			  // field name.
+                      for (octave_idx_type i = 0; i < field_numel; i++)
+                        {
+                          // Construct cell array which goes into the
+                          // structure together with the appropriate
+                          // field name.
 
-			  Cell c_value (value_dv);
+                          Cell c_value (value_dv);
 
-			  Array<octave_idx_type> value_idx (value_dv.length (), 0);
-			  Array<octave_idx_type> c_idx (c_dv_length, 0);
+                          Array<octave_idx_type> value_idx (value_dv.length (), 0);
+                          Array<octave_idx_type> c_idx (c_dv_length, 0);
 
-			  for (octave_idx_type j = 0; j < value_dv.numel (); j++)
-			    {
-			      // Need to do this to construct the
-			      // appropriate idx for getting elements
-			      // from the original cell array.
+                          for (octave_idx_type j = 0; j < value_dv.numel (); j++)
+                            {
+                              // Need to do this to construct the
+                              // appropriate idx for getting elements
+                              // from the original cell array.
 
-			      cell2struct_construct_idx (c_idx, value_idx,
-							 dim, i);
+                              cell2struct_construct_idx (c_idx, value_idx,
+                                                         dim, i);
 
-			      c_value.elem (value_idx) = c.elem (c_idx);
+                              c_value.elem (value_idx) = c.elem (c_idx);
 
-			      increment_index (value_idx, value_dv);
-			    }
+                              increment_index (value_idx, value_dv);
+                            }
 
-			  std::string field_str;
+                          std::string field_str;
 
-			  if (field_is_cell)
-			    {
-			      // Matlab retrieves the field values
-			      // column by column.
+                          if (field_is_cell)
+                            {
+                              // Matlab retrieves the field values
+                              // column by column.
 
-			      octave_value field_tmp = field_cell.elem (i);
+                              octave_value field_tmp = field_cell.elem (i);
 
-			      field_str = field_tmp.string_value ();
+                              field_str = field_tmp.string_value ();
 
-			      if (error_state)
-				{
-				  error ("cell2struct: fields have to be of type string");
-				  break;
-				}
-			    }
-			  else
-			    {
-			      field_str = field_char.row_as_string (i);
+                              if (error_state)
+                                {
+                                  error ("cell2struct: fields have to be of type string");
+                                  break;
+                                }
+                            }
+                          else
+                            {
+                              field_str = field_char.row_as_string (i);
 
-			      if (error_state)
-				return retval;
-			    }
+                              if (error_state)
+                                return retval;
+                            }
 
-			  if (! valid_identifier (field_str))
-			    {
-			      error ("cell2struct: invalid field name `%s'",
-				     field_str.c_str ());
-			      break;
-			    }
+                          if (! valid_identifier (field_str))
+                            {
+                              error ("cell2struct: invalid field name `%s'",
+                                     field_str.c_str ());
+                              break;
+                            }
 
-			  map.reshape (value_dv);
+                          map.reshape (value_dv);
 
-			  map.assign (field_str, c_value);
-			}
+                          map.assign (field_str, c_value);
+                        }
 
-		      if (! error_state)
-			retval = map;
-		    }
-		}
-	      else
-		error ("cell2struct: expecting third argument to be an integer");
-	    }
-	  else
-	    error ("cell2struct: expecting second argument to be a cell or character array");
-	}
+                      if (! error_state)
+                        retval = map;
+                    }
+                }
+              else
+                error ("cell2struct: expecting third argument to be an integer");
+            }
+          else
+            error ("cell2struct: expecting second argument to be a cell or character array");
+        }
       else
-	error ("cell2struct: expecting first argument to be a cell array");
+        error ("cell2struct: expecting first argument to be a cell array");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1237,37 +1237,37 @@ named fields.\n\
 
   if (nargin == 2)
     {
       Octave_map m = args(0).map_value ();
 
       octave_value_list fval = Fcellstr (args(1), 1);
 
       if (! error_state)
-	{
-	  Cell fcell = fval(0).cell_value ();
+        {
+          Cell fcell = fval(0).cell_value ();
 
-	  for (int i = 0; i < fcell.numel (); i++)
-	    {
-	      std::string key = fcell(i).string_value ();
+          for (int i = 0; i < fcell.numel (); i++)
+            {
+              std::string key = fcell(i).string_value ();
 
-	      if (m.contains (key))
-		m.del (key);
-	      else
-		{
-		  error ("rmfield: structure does not contain field %s",
-			 key.c_str ());
+              if (m.contains (key))
+                m.del (key);
+              else
+                {
+                  error ("rmfield: structure does not contain field %s",
+                         key.c_str ());
 
-		  break;
-		}
-	    }
+                  break;
+                }
+            }
 
-	  if (! error_state)
-	    retval = m;
-	}
+          if (! error_state)
+            retval = m;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1304,17 +1304,17 @@ octave_struct::save_ascii (std::ostream&
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
       bool b = save_ascii_data (os, val, key, false, 0);
       
       if (! b)
-	return os;
+        return os;
     }
 
   return true;
 }
 
 bool 
 octave_struct::load_ascii (std::istream& is)
 {
@@ -1345,54 +1345,54 @@ octave_struct::load_ascii (std::istream&
         }
     }
   else
     success = false;
 
   if (success && len >= 0)
     {
       if (len > 0)
-	{
-	  Octave_map m (dv);
+        {
+          Octave_map m (dv);
 
-	  for (octave_idx_type j = 0; j < len; j++)
-	    {
-	      octave_value t2;
-	      bool dummy;
+          for (octave_idx_type j = 0; j < len; j++)
+            {
+              octave_value t2;
+              bool dummy;
 
-	      // recurse to read cell elements
-	      std::string nm
-		= read_ascii_data (is, std::string (), dummy, t2, j);
+              // recurse to read cell elements
+              std::string nm
+                = read_ascii_data (is, std::string (), dummy, t2, j);
 
-	      if (!is)
-		break;
+              if (!is)
+                break;
 
-	      Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
+              Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
 
-	      if (error_state)
-		{
-		  error ("load: internal error loading struct elements");
-		  return false;
-		}
+              if (error_state)
+                {
+                  error ("load: internal error loading struct elements");
+                  return false;
+                }
 
-	      m.assign (nm, tcell);
-	    }
+              m.assign (nm, tcell);
+            }
 
-	  if (is) 
-	    map = m;
-	  else
-	    {
-	      error ("load: failed to load structure");
-	      success = false;
-	    }
-	}
+          if (is) 
+            map = m;
+          else
+            {
+              error ("load: failed to load structure");
+              success = false;
+            }
+        }
       else if (len == 0 )
-	map = Octave_map (dv);
+        map = Octave_map (dv);
       else
-	panic_impossible ();
+        panic_impossible ();
     }
   else {
     error ("load: failed to extract number of elements in structure");
     success = false;
   }
 
   return success;
 }
@@ -1428,25 +1428,25 @@ octave_struct::save_binary (std::ostream
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
       bool b = save_binary_data (os, val, key, "", 0, save_as_floats);
       
       if (! b)
-	return os;
+        return os;
     }
 
   return true;
 }
 
 bool 
 octave_struct::load_binary (std::istream& is, bool swap,
-			    oct_mach_info::float_format fmt)
+                            oct_mach_info::float_format fmt)
 {
   bool success = true;
   int32_t len;
   if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
@@ -1475,46 +1475,46 @@ octave_struct::load_binary (std::istream
         swap_bytes<4> (&len);
     }
 
   if (len > 0)
     {
       Octave_map m (dv);
 
       for (octave_idx_type j = 0; j < len; j++)
-	{
-	  octave_value t2;
-	  bool dummy;
-	  std::string doc;
+        {
+          octave_value t2;
+          bool dummy;
+          std::string doc;
 
-	  // recurse to read cell elements
-	  std::string nm = read_binary_data (is, swap, fmt, std::string (), 
-					     dummy, t2, doc);
+          // recurse to read cell elements
+          std::string nm = read_binary_data (is, swap, fmt, std::string (), 
+                                             dummy, t2, doc);
 
-	  if (!is)
-	    break;
+          if (!is)
+            break;
 
-	  Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
+          Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
  
-	  if (error_state)
-	    {
-	      error ("load: internal error loading struct elements");
-	      return false;
-	    }
+          if (error_state)
+            {
+              error ("load: internal error loading struct elements");
+              return false;
+            }
 
-	  m.assign (nm, tcell);
-	}
+          m.assign (nm, tcell);
+        }
 
       if (is) 
-	map = m;
+        map = m;
       else
-	{
-	  error ("load: failed to load structure");
-	  success = false;
-	}
+        {
+          error ("load: failed to load structure");
+          success = false;
+        }
     }
   else if (len == 0)
     map = Octave_map (dv);
   else
     success = false;
 
   return success;
 }
@@ -1544,20 +1544,20 @@ octave_struct::save_hdf5 (hid_t loc_id, 
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
       bool retval2 = add_hdf5_data (data_hid, val, key, "", false, 
-				    save_as_floats);
+                                    save_as_floats);
 
       if (! retval2)
-	break;
+        break;
     }
 
   H5Gclose (data_hid);
 
   return true;
 }
 
 bool 
@@ -1578,28 +1578,28 @@ octave_struct::load_hdf5 (hid_t loc_id, 
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   // FIXME -- fields appear to be sorted alphabetically on loading.
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
-	 && (retval2 = H5Giterate (loc_id, name, &current_item,
-				   hdf5_read_next_data, &dsub)) > 0)
+         && (retval2 = H5Giterate (loc_id, name, &current_item,
+                                   hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
       Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
  
       if (error_state)
-	{
-	  error ("load: internal error loading struct elements");
-	  return false;
-	}
+        {
+          error ("load: internal error loading struct elements");
+          return false;
+        }
 
       m.assign (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
@@ -1633,13 +1633,13 @@ octave_struct::as_mxArray (void) const
   for (int i = 0; i < nf; i++)
     {
       Cell c = map.contents (kv[i]);
 
       const octave_value *p = c.data ();
 
       mwIndex k = 0;
       for (mwIndex j = i; j < ntot; j += nf)
-	elts[j] = new mxArray (p[k++]);
+        elts[j] = new mxArray (p[k++]);
     }
 
   return retval;
 }
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -54,137 +54,137 @@ octave_value_typeinfo::instance_ok (void
       retval = false;
     }
 
   return retval;
 }
 
 int
 octave_value_typeinfo::register_type (const std::string& t_name,
-				      const std::string& c_name,
-				      const octave_value& val)
+                                      const std::string& c_name,
+                                      const octave_value& val)
 {
   return (instance_ok ())
     ? instance->do_register_type (t_name, c_name, val) : -1;
 }
 
 bool
 octave_value_typeinfo::register_unary_class_op (octave_value::unary_op op,
-					        octave_value_typeinfo::unary_class_op_fcn f)
+                                                octave_value_typeinfo::unary_class_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_unary_class_op (op, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_unary_op (octave_value::unary_op op,
-					   int t, octave_value_typeinfo::unary_op_fcn f)
+                                           int t, octave_value_typeinfo::unary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_unary_op (op, t, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_non_const_unary_op (octave_value::unary_op op,
-						    int t,
-						    octave_value_typeinfo::non_const_unary_op_fcn f)
+                                                    int t,
+                                                    octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_non_const_unary_op (op, t, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_class_op (octave_value::binary_op op,
-						 octave_value_typeinfo::binary_class_op_fcn f)
+                                                 octave_value_typeinfo::binary_class_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_binary_class_op (op, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_op (octave_value::binary_op op,
-					   int t1, int t2,
-					   octave_value_typeinfo::binary_op_fcn f)
+                                           int t1, int t2,
+                                           octave_value_typeinfo::binary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_binary_op (op, t1, t2, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_class_op (octave_value::compound_binary_op op,
-						 octave_value_typeinfo::binary_class_op_fcn f)
+                                                 octave_value_typeinfo::binary_class_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_binary_class_op (op, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_op (octave_value::compound_binary_op op,
-					   int t1, int t2,
-					   octave_value_typeinfo::binary_op_fcn f)
+                                           int t1, int t2,
+                                           octave_value_typeinfo::binary_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_binary_op (op, t1, t2, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_cat_op (t1, t2, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_assign_op (octave_value::assign_op op,
-					   int t_lhs, int t_rhs,
-					   octave_value_typeinfo::assign_op_fcn f)
+                                           int t_lhs, int t_rhs,
+                                           octave_value_typeinfo::assign_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_assign_op (op, t_lhs, t_rhs, f) : -1;
 }
 
 bool
 octave_value_typeinfo::register_assignany_op (octave_value::assign_op op,
-					      int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
+                                              int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_assignany_op (op, t_lhs, f) : -1;
 }
 
 bool
 octave_value_typeinfo::register_pref_assign_conv (int t_lhs, int t_rhs,
-						  int t_result) 
+                                                  int t_result) 
 {
   return (instance_ok ())
     ? instance->do_register_pref_assign_conv (t_lhs, t_rhs, t_result) : false;
 }
 
 bool
 octave_value_typeinfo::register_type_conv_op (int t, int t_result,
-					      octave_base_value::type_conv_fcn f)
+                                              octave_base_value::type_conv_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_type_conv_op (t, t_result, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_widening_op (int t, int t_result,
-					     octave_base_value::type_conv_fcn f)
+                                             octave_base_value::type_conv_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_widening_op (t, t_result, f) : false;
 }
 
 // FIXME -- we should also store all class names and provide a
 // way to list them (calling class with nargin == 0?).
 
 int
 octave_value_typeinfo::do_register_type (const std::string& t_name,
-					 const std::string& /* c_name */,
-					 const octave_value& val)
+                                         const std::string& /* c_name */,
+                                         const octave_value& val)
 {
   int i = 0;
 
   for (i = 0; i < num_types; i++)
     if (t_name == types (i))
       return i;
 
   int len = types.length ();
@@ -195,20 +195,20 @@ octave_value_typeinfo::do_register_type 
 
       types.resize (len, std::string ());
 
       vals.resize (len, octave_value ());
 
       unary_ops.resize (static_cast<int> (octave_value::num_unary_ops), len, 0);
 
       non_const_unary_ops.resize
-	(static_cast<int> (octave_value::num_unary_ops), len, 0);
+        (static_cast<int> (octave_value::num_unary_ops), len, 0);
 
       binary_ops.resize (static_cast<int> (octave_value::num_binary_ops),
-			 len, len, 0);
+                         len, len, 0);
 
       compound_binary_ops.resize (static_cast<int> (octave_value::num_compound_binary_ops),
                                   len, len, 0);
 
       cat_ops.resize (len, len, 0);
 
       assign_ops.resize (static_cast<int> (octave_value::num_assign_ops), len, len, 0);
 
@@ -227,42 +227,42 @@ octave_value_typeinfo::do_register_type 
 
   num_types++;
 
   return i;
 }
 
 bool
 octave_value_typeinfo::do_register_unary_class_op (octave_value::unary_op op,
-					           octave_value_typeinfo::unary_class_op_fcn f)
+                                                   octave_value_typeinfo::unary_class_op_fcn f)
 {
   if (lookup_unary_class_op (op))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
 
       warning ("duplicate unary operator `%s' for class dispatch",
-	       op_name.c_str ());
+               op_name.c_str ());
     }
 
   unary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_unary_op (octave_value::unary_op op,
-					     int t, octave_value_typeinfo::unary_op_fcn f)
+                                             int t, octave_value_typeinfo::unary_op_fcn f)
 {
   if (lookup_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
       warning ("duplicate unary operator `%s' for type `%s'",
-	       op_name.c_str (), type_name.c_str ());
+               op_name.c_str (), type_name.c_str ());
     }
 
   unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
@@ -270,164 +270,164 @@ octave_value_typeinfo::do_register_non_c
   (octave_value::unary_op op, int t, octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   if (lookup_non_const_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
       warning ("duplicate unary operator `%s' for type `%s'",
-	       op_name.c_str (), type_name.c_str ());
+               op_name.c_str (), type_name.c_str ());
     }
 
   non_const_unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::binary_op op,
-						    octave_value_typeinfo::binary_class_op_fcn f)
+                                                    octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
 
       warning ("duplicate binary operator `%s' for class dispatch",
-	       op_name.c_str ());
+               op_name.c_str ());
     }
 
   binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_op (octave_value::binary_op op,
-					      int t1, int t2,
-					      octave_value_typeinfo::binary_op_fcn f)
+                                              int t1, int t2,
+                                              octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate binary operator `%s' for types `%s' and `%s'",
-	       op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
+               op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
   binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::compound_binary_op op,
-						    octave_value_typeinfo::binary_class_op_fcn f)
+                                                    octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_fcn_name (op);
 
       warning ("duplicate compound binary operator `%s' for class dispatch",
-	       op_name.c_str ());
+               op_name.c_str ());
     }
 
   compound_binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_op (octave_value::compound_binary_op op,
-					      int t1, int t2,
-					      octave_value_typeinfo::binary_op_fcn f)
+                                              int t1, int t2,
+                                              octave_value_typeinfo::binary_op_fcn f)
 {
   if (lookup_binary_op (op, t1, t2))
     {
       std::string op_name = octave_value::binary_op_fcn_name (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate compound binary operator `%s' for types `%s' and `%s'",
-	       op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
+               op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
   compound_binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
 {
   if (lookup_cat_op (t1, t2))
     {
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate concatenation operator for types `%s' and `%s'",
-	       t1_name.c_str (), t1_name.c_str ());
+               t1_name.c_str (), t1_name.c_str ());
     }
 
   cat_ops.checkelem (t1, t2) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_assign_op (octave_value::assign_op op,
-					      int t_lhs, int t_rhs,
-					      octave_value_typeinfo::assign_op_fcn f)
+                                              int t_lhs, int t_rhs,
+                                              octave_value_typeinfo::assign_op_fcn f)
 {
   if (lookup_assign_op (op, t_lhs, t_rhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
       warning ("duplicate assignment operator `%s' for types `%s' and `%s'",
-	       op_name.c_str (), t_lhs_name.c_str (), t_rhs_name.c_str ());
+               op_name.c_str (), t_lhs_name.c_str (), t_rhs_name.c_str ());
     }
 
   assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_assignany_op (octave_value::assign_op op,
-						 int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
+                                                 int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   if (lookup_assignany_op (op, t_lhs))
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
 
       warning ("duplicate assignment operator `%s' for types `%s'",
-	       op_name.c_str (), t_lhs_name.c_str ());
+               op_name.c_str (), t_lhs_name.c_str ());
     }
 
   assignany_ops.checkelem (static_cast<int> (op), t_lhs) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_pref_assign_conv (int t_lhs, int t_rhs,
-						     int t_result) 
+                                                     int t_result) 
 {
   if (lookup_pref_assign_conv (t_lhs, t_rhs) >= 0)
     {
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
       warning ("overriding assignment conversion for types `%s' and `%s'",
-	       t_lhs_name.c_str (), t_rhs_name.c_str ());
+               t_lhs_name.c_str (), t_rhs_name.c_str ());
     }
 
   pref_assign_conv.checkelem (t_lhs, t_rhs) = t_result;
 
   return false;
 }
 
 bool
@@ -435,17 +435,17 @@ octave_value_typeinfo::do_register_type_
   (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_type_conv_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
       warning ("overriding type conversion op for `%s' to `%s'",
-	       t_name.c_str (), t_result_name.c_str ());
+               t_name.c_str (), t_result_name.c_str ());
     }
 
   type_conv_ops.checkelem (t, t_result) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
@@ -453,37 +453,37 @@ octave_value_typeinfo::do_register_widen
   (int t, int t_result, octave_base_value::type_conv_fcn f)
 {
   if (lookup_widening_op (t, t_result))
     {
       std::string t_name = types(t);
       std::string t_result_name = types(t_result);
 
       warning ("overriding widening op for `%s' to `%s'",
-	       t_name.c_str (), t_result_name.c_str ());
+               t_name.c_str (), t_result_name.c_str ());
     }
 
   widening_ops.checkelem (t, t_result) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 octave_value
 octave_value_typeinfo::do_lookup_type (const std::string& nm)
 {
   octave_value retval;
 
   for (int i = 0; i < num_types; i++)
     {
       if (nm == types(i))
-	{
-	  retval = vals(i);
-	  retval.make_unique ();
-	  break;
-	}
+        {
+          retval = vals(i);
+          retval.make_unique ();
+          break;
+        }
     }
 
   return retval;
 }
 
 octave_value_typeinfo::unary_class_op_fcn
 octave_value_typeinfo::do_lookup_unary_class_op (octave_value::unary_op op)
 {
@@ -510,55 +510,55 @@ octave_value_typeinfo::binary_class_op_f
 octave_value_typeinfo::do_lookup_binary_class_op (octave_value::binary_op op)
 {
   void *f = binary_class_ops.checkelem (static_cast<int> (op));
   return reinterpret_cast<octave_value_typeinfo::binary_class_op_fcn> (f);
 }
 
 octave_value_typeinfo::binary_op_fcn
 octave_value_typeinfo::do_lookup_binary_op (octave_value::binary_op op,
-					    int t1, int t2)
+                                            int t1, int t2)
 {
   void *f = binary_ops.checkelem (static_cast<int> (op), t1, t2);
   return reinterpret_cast<octave_value_typeinfo::binary_op_fcn> (f);
 }
 
 octave_value_typeinfo::binary_class_op_fcn
 octave_value_typeinfo::do_lookup_binary_class_op (octave_value::compound_binary_op op)
 {
   void *f = compound_binary_class_ops.checkelem (static_cast<int> (op));
   return reinterpret_cast<octave_value_typeinfo::binary_class_op_fcn> (f);
 }
 
 octave_value_typeinfo::binary_op_fcn
 octave_value_typeinfo::do_lookup_binary_op (octave_value::compound_binary_op op,
-					    int t1, int t2)
+                                            int t1, int t2)
 {
   void *f = compound_binary_ops.checkelem (static_cast<int> (op), t1, t2);
   return reinterpret_cast<octave_value_typeinfo::binary_op_fcn> (f);
 }
 
 octave_value_typeinfo::cat_op_fcn
 octave_value_typeinfo::do_lookup_cat_op (int t1, int t2)
 {
   void *f = cat_ops.checkelem (t1, t2);
   return reinterpret_cast<octave_value_typeinfo::cat_op_fcn> (f);
 }
 
 octave_value_typeinfo::assign_op_fcn
 octave_value_typeinfo::do_lookup_assign_op (octave_value::assign_op op,
-					    int t_lhs, int t_rhs)
+                                            int t_lhs, int t_rhs)
 {
   void *f = assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs);
   return reinterpret_cast<octave_value_typeinfo::assign_op_fcn> (f);
 }
 
 octave_value_typeinfo::assignany_op_fcn
 octave_value_typeinfo::do_lookup_assignany_op (octave_value::assign_op op,
-					       int t_lhs)
+                                               int t_lhs)
 {
   void *f = assignany_ops.checkelem (static_cast<int> (op), t_lhs);
   return reinterpret_cast<octave_value_typeinfo::assignany_op_fcn> (f);
 }
 
 int
 octave_value_typeinfo::do_lookup_pref_assign_conv (int t_lhs, int t_rhs)
 {
diff --git a/src/ov-uint16.cc b/src/ov-uint16.cc
--- a/src/ov-uint16.cc
+++ b/src/ov-uint16.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<uint16NDArray>;
 
 template class octave_base_int_matrix<uint16NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint16_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_matrix,
-				     "uint16 matrix", "uint16");
+                                     "uint16 matrix", "uint16");
 
 template class octave_base_scalar<octave_uint16>;
 
 template class octave_base_int_scalar<octave_uint16>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint16_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_scalar,
-				     "uint16 scalar", "uint16");
+                                     "uint16 scalar", "uint16");
 
 DEFUN (uint16, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint16 (@var{x})\n\
 Convert @var{x} to unsigned 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint16);
diff --git a/src/ov-uint32.cc b/src/ov-uint32.cc
--- a/src/ov-uint32.cc
+++ b/src/ov-uint32.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<uint32NDArray>;
 
 template class octave_base_int_matrix<uint32NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint32_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_matrix,
-				     "uint32 matrix", "uint32");
+                                     "uint32 matrix", "uint32");
 
 template class octave_base_scalar<octave_uint32>;
 
 template class octave_base_int_scalar<octave_uint32>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint32_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_scalar,
-				     "uint32 scalar", "uint32");
+                                     "uint32 scalar", "uint32");
 
 DEFUN (uint32, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint32 (@var{x})\n\
 Convert @var{x} to unsigned 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint32);
diff --git a/src/ov-uint64.cc b/src/ov-uint64.cc
--- a/src/ov-uint64.cc
+++ b/src/ov-uint64.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<uint64NDArray>;
 
 template class octave_base_int_matrix<uint64NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint64_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_matrix,
-				     "uint64 matrix", "uint64");
+                                     "uint64 matrix", "uint64");
 
 template class octave_base_scalar<octave_uint64>;
 
 template class octave_base_int_scalar<octave_uint64>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint64_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_scalar,
-				     "uint64 scalar", "uint64");
+                                     "uint64 scalar", "uint64");
 
 DEFUN (uint64, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint64 (@var{x})\n\
 Convert @var{x} to unsigned 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint64);
diff --git a/src/ov-uint8.cc b/src/ov-uint8.cc
--- a/src/ov-uint8.cc
+++ b/src/ov-uint8.cc
@@ -58,26 +58,26 @@ along with Octave; see the file COPYING.
 
 template class octave_base_matrix<uint8NDArray>;
 
 template class octave_base_int_matrix<uint8NDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint8_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_matrix,
-				     "uint8 matrix", "uint8");
+                                     "uint8 matrix", "uint8");
 
 template class octave_base_scalar<octave_uint8>;
 
 template class octave_base_int_scalar<octave_uint8>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint8_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_scalar,
-				     "uint8 scalar", "uint8");
+                                     "uint8 scalar", "uint8");
 
 DEFUN (uint8, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint8 (@var{x})\n\
 Convert @var{x} to unsigned 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint8);
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -55,125 +55,125 @@ static int Vmax_recursion_depth = 256;
 // Whether to optimize subsasgn method calls.
 static bool Voptimize_subsasgn_calls = true;
 
 // User defined scripts.
 
 DEFINE_OCTAVE_ALLOCATOR (octave_user_script);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_script,
-				     "user-defined script",
-				     "user-defined script");
+                                     "user-defined script",
+                                     "user-defined script");
 
 octave_user_script::octave_user_script (void)
   : octave_user_code (), cmd_list (0), file_name (),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::octave_user_script (const std::string& fnm,
-					const std::string& nm,
-					tree_statement_list *cmds,
-					const std::string& ds)
+                                        const std::string& nm,
+                                        tree_statement_list *cmds,
+                                        const std::string& ds)
   : octave_user_code (nm, ds), cmd_list (cmds), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 {
   if (cmd_list)
     cmd_list->mark_as_script_body ();
 }
 
 octave_user_script::octave_user_script (const std::string& fnm,
-					const std::string& nm,
-					const std::string& ds)
+                                        const std::string& nm,
+                                        const std::string& ds)
   : octave_user_code (nm, ds), cmd_list (0), file_name (fnm), 
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::~octave_user_script (void)
 {
   delete cmd_list;
 }
 
 octave_value_list
 octave_user_script::subsref (const std::string&,
-			     const std::list<octave_value_list>&, int)
+                             const std::list<octave_value_list>&, int)
 {
   octave_value_list retval;
 
   ::error ("invalid use of script %s in index expression", file_name.c_str ());
 
   return retval;
 }
 
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
-				       const octave_value_list& args)
+                                       const octave_value_list& args)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
   if (! error_state)
     {
       if (args.length () == 0 && nargout == 0)
-	{
-	  if (cmd_list)
-	    {
-	      frame.protect_var (call_depth);
-	      call_depth++;
+        {
+          if (cmd_list)
+            {
+              frame.protect_var (call_depth);
+              call_depth++;
 
-	      if (call_depth < Vmax_recursion_depth)
-		{
-		  octave_call_stack::push (this);
+              if (call_depth < Vmax_recursion_depth)
+                {
+                  octave_call_stack::push (this);
 
                   frame.add_fcn (octave_call_stack::pop);
 
-		  frame.protect_var (tree_evaluator::in_fcn_or_script_body);
-		  tree_evaluator::in_fcn_or_script_body = true;
+                  frame.protect_var (tree_evaluator::in_fcn_or_script_body);
+                  tree_evaluator::in_fcn_or_script_body = true;
 
-		  cmd_list->accept (*current_evaluator);
+                  cmd_list->accept (*current_evaluator);
 
-		  if (tree_return_command::returning)
-		    tree_return_command::returning = 0;
+                  if (tree_return_command::returning)
+                    tree_return_command::returning = 0;
 
-		  if (tree_break_command::breaking)
-		    tree_break_command::breaking--;
+                  if (tree_break_command::breaking)
+                    tree_break_command::breaking--;
 
-		  if (error_state)
-		    octave_call_stack::backtrace_error_message ();
-		}
-	      else
-		::error ("max_recursion_limit exceeded");
-    	    }
-	}
+                  if (error_state)
+                    octave_call_stack::backtrace_error_message ();
+                }
+              else
+                ::error ("max_recursion_limit exceeded");
+            }
+        }
       else
-	error ("invalid call to script %s", file_name.c_str ());
+        error ("invalid call to script %s", file_name.c_str ());
     }
 
   return retval;
 }
 
 void
 octave_user_script::accept (tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
 }
 
 // User defined functions.
 
 DEFINE_OCTAVE_ALLOCATOR (octave_user_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
-				     "user-defined function",
-				     "user-defined function");
+                                     "user-defined function",
+                                     "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
   (symbol_table::scope_id sid, tree_parameter_list *pl,
    tree_parameter_list *rl, tree_statement_list *cl)
   : octave_user_code (std::string (), std::string ()),
@@ -231,17 +231,17 @@ octave_user_function::mark_as_system_fcn
       // We probably also don't need to get the library directory
       // every time, but since this function is only called when the
       // function file is parsed, it probably doesn't matter that
       // much.
 
       std::string ff_name = fcn_file_in_path (file_name);
 
       if (Vfcn_file_dir == ff_name.substr (0, Vfcn_file_dir.length ()))
-	system_fcn_file = 1;
+        system_fcn_file = 1;
     }
   else
     system_fcn_file = 0;
 }
 
 bool
 octave_user_function::takes_varargs (void) const
 {
@@ -276,36 +276,36 @@ octave_user_function::all_va_args (const
   if (n > 0)
     retval = args.slice (num_named_args, n);
 
   return retval;
 }
 
 octave_value_list
 octave_user_function::subsref (const std::string& type,
-			       const std::list<octave_value_list>& idx,
-			       int nargout)
+                               const std::list<octave_value_list>& idx,
+                               int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
-	int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
+        int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
 
-	retval = do_multi_index_op (tmp_nargout, idx.front ());
+        retval = do_multi_index_op (tmp_nargout, idx.front ());
       }
       break;
 
     case '{':
     case '.':
       {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+        std::string nm = type_name ();
+        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME -- perhaps there should be an
@@ -315,17 +315,17 @@ octave_user_function::subsref (const std
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 octave_value_list
 octave_user_function::do_multi_index_op (int nargout,
-					 const octave_value_list& args)
+                                         const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
@@ -549,44 +549,44 @@ function accepts a variable number of ar
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string fname = args(0).string_value ();
 
       if (! error_state)
-	{
-	  octave_value fcn_val = symbol_table::find_user_function (fname);
+        {
+          octave_value fcn_val = symbol_table::find_user_function (fname);
 
-	  octave_user_function *fcn = fcn_val.user_function_value (true);
+          octave_user_function *fcn = fcn_val.user_function_value (true);
 
-	  if (fcn)
-	    {
-	      if (fcn->takes_varargs ())
-		retval = -1;
-	      else
-		{
-		  tree_parameter_list *param_list = fcn->parameter_list ();
+          if (fcn)
+            {
+              if (fcn->takes_varargs ())
+                retval = -1;
+              else
+                {
+                  tree_parameter_list *param_list = fcn->parameter_list ();
 
-		  retval = param_list ? param_list->length () : 0;
-		}
-	    }
-	  else
-	    error ("nargin: invalid function");
-	}
+                  retval = param_list ? param_list->length () : 0;
+                }
+            }
+          else
+            error ("nargin: invalid function");
+        }
       else
-	error ("nargin: expecting string as first argument");
+        error ("nargin: expecting string as first argument");
     }
   else if (nargin == 0)
     {
       retval = symbol_table::varval (".nargin.");
 
       if (retval.is_undefined ())
-	retval = 0;
+        retval = 0;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
@@ -623,49 +623,49 @@ At the top level, @code{nargout} is unde
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string fname = args(0).string_value ();
 
       if (! error_state)
-	{
-	  octave_value fcn_val = symbol_table::find_user_function (fname);
+        {
+          octave_value fcn_val = symbol_table::find_user_function (fname);
 
-	  octave_user_function *fcn = fcn_val.user_function_value (true);
+          octave_user_function *fcn = fcn_val.user_function_value (true);
 
-	  if (fcn)
-	    {
-	      if (fcn->takes_var_return ())
-		retval = -1;
-	      else
-		{
-		  tree_parameter_list *ret_list = fcn->return_list ();
+          if (fcn)
+            {
+              if (fcn->takes_var_return ())
+                retval = -1;
+              else
+                {
+                  tree_parameter_list *ret_list = fcn->return_list ();
 
-		  retval = ret_list ? ret_list->length () : 0;
-		}
-	    }
-	  else
-	    error ("nargout: invalid function");
-	}
+                  retval = ret_list ? ret_list->length () : 0;
+                }
+            }
+          else
+            error ("nargout: invalid function");
+        }
       else
-	error ("nargout: expecting string as first argument");
+        error ("nargout: expecting string as first argument");
     }
   else if (nargin == 0)
     {
       if (! symbol_table::at_top_level ())
-	{
-	  retval = symbol_table::varval (".nargout.");
+        {
+          retval = symbol_table::varval (".nargout.");
 
-	  if (retval.is_undefined ())
-	    retval = 0;
-	}
+          if (retval.is_undefined ())
+            retval = 0;
+        }
       else
-	error ("nargout: invalid call at top level");
+        error ("nargout: invalid call at top level");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (max_recursion_depth, args, nargout,
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -575,25 +575,25 @@ octave_value::octave_value (double d)
 
 octave_value::octave_value (float d)
   : rep (new octave_float_scalar (d))
 {
 }
 
 octave_value::octave_value (const Cell& c, bool is_csl)
   : rep (is_csl
-	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (c))
-	 : dynamic_cast<octave_base_value *> (new octave_cell (c)))
+         ? dynamic_cast<octave_base_value *> (new octave_cs_list (c))
+         : dynamic_cast<octave_base_value *> (new octave_cell (c)))
 {
 }
 
 octave_value::octave_value (const Array<octave_value>& a, bool is_csl)
   : rep (is_csl
-	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (Cell (a)))
-	 : dynamic_cast<octave_base_value *> (new octave_cell (Cell (a))))
+         ? dynamic_cast<octave_base_value *> (new octave_cs_list (Cell (a)))
+         : dynamic_cast<octave_base_value *> (new octave_cell (Cell (a))))
 {
 }
 
 octave_value::octave_value (const Matrix& m, const MatrixType& t)
   : rep (new octave_matrix (m, t))
 {
   maybe_mutate ();
 }
@@ -774,90 +774,90 @@ octave_value::octave_value (const boolND
 octave_value::octave_value (const Array<bool>& bnda)
   : rep (new octave_bool_matrix (bnda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (char c, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (c)
-	 : new octave_char_matrix_sq_str (c))
+         ? new octave_char_matrix_dq_str (c)
+         : new octave_char_matrix_sq_str (c))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const char *s, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (s)
-	 : new octave_char_matrix_sq_str (s))
+         ? new octave_char_matrix_dq_str (s)
+         : new octave_char_matrix_sq_str (s))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const std::string& s, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (s)
-	 : new octave_char_matrix_sq_str (s))
+         ? new octave_char_matrix_dq_str (s)
+         : new octave_char_matrix_sq_str (s))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const string_vector& s, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (s)
-	 : new octave_char_matrix_sq_str (s))
+         ? new octave_char_matrix_dq_str (s)
+         : new octave_char_matrix_sq_str (s))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const charMatrix& chm, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (chm)
-	 : new octave_char_matrix_sq_str (chm))
+         ? new octave_char_matrix_dq_str (chm)
+         : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const charNDArray& chm, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (chm)
-	 : new octave_char_matrix_sq_str (chm))
+         ? new octave_char_matrix_dq_str (chm)
+         : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Array<char>& chm, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (chm)
-	 : new octave_char_matrix_sq_str (chm))
+         ? new octave_char_matrix_dq_str (chm)
+         : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const charMatrix& chm, bool, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (chm)
-	 : new octave_char_matrix_sq_str (chm))
+         ? new octave_char_matrix_dq_str (chm)
+         : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const charNDArray& chm, bool, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (chm)
-	 : new octave_char_matrix_sq_str (chm))
+         ? new octave_char_matrix_dq_str (chm)
+         : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Array<char>& chm, bool, char type)
   : rep (type == '"'
-	 ? new octave_char_matrix_dq_str (chm)
-	 : new octave_char_matrix_sq_str (chm))
+         ? new octave_char_matrix_dq_str (chm)
+         : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const SparseMatrix& m, const MatrixType &t)
   : rep (new octave_sparse_matrix (m, t))
 {
   maybe_mutate ();
@@ -1142,157 +1142,157 @@ octave_value::clone (void) const
 void
 octave_value::maybe_mutate (void)
 {
   octave_base_value *tmp = rep->try_narrowing_conversion ();
 
   if (tmp && tmp != rep)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
 
       rep = tmp;
     }    
 }
 
 octave_value
 octave_value::single_subsref (const std::string& type,
-			      const octave_value_list& idx)
+                              const octave_value_list& idx)
 {
   std::list<octave_value_list> i;
 
   i.push_back (idx);
 
   return rep->subsref (type, i);
 }
 
 octave_value_list
 octave_value::subsref (const std::string& type,
-		       const std::list<octave_value_list>& idx, int nargout)
+                       const std::list<octave_value_list>& idx, int nargout)
 {
   if (nargout == 1)
     return rep->subsref (type, idx);
   else
     return rep->subsref (type, idx, nargout);
 }
 
 octave_value
 octave_value::next_subsref (const std::string& type,
-			    const std::list<octave_value_list>& idx,
-			    size_t skip) 
+                            const std::list<octave_value_list>& idx,
+                            size_t skip) 
 {
   if (! error_state && idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
-	new_idx.erase (new_idx.begin ());
+        new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx);
     }
   else
     return *this;
 }
 
 octave_value_list
 octave_value::next_subsref (int nargout, const std::string& type,
-			    const std::list<octave_value_list>& idx,
-			    size_t skip) 
+                            const std::list<octave_value_list>& idx,
+                            size_t skip) 
 {
   if (! error_state && idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
-	new_idx.erase (new_idx.begin ());
+        new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, nargout);
     }
   else
     return *this;
 }
 
 octave_value
 octave_value::next_subsref (bool auto_add, const std::string& type,
-			    const std::list<octave_value_list>& idx,
-			    size_t skip) 
+                            const std::list<octave_value_list>& idx,
+                            size_t skip) 
 {
   if (! error_state && idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
-	new_idx.erase (new_idx.begin ());
+        new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, auto_add);
     }
   else
     return *this;
 }
 
 octave_value_list
 octave_value::do_multi_index_op (int nargout, const octave_value_list& idx)
 {
   return rep->do_multi_index_op (nargout, idx);
 }
 
 #if 0
 static void
 gripe_assign_failed (const std::string& on, const std::string& tn1,
-		     const std::string& tn2)
+                     const std::string& tn2)
 {
   error ("assignment failed for `%s %s %s'",
-	 tn1.c_str (), on.c_str (), tn2.c_str ());
+         tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 #endif
 
 static void
 gripe_assign_failed_or_no_method (const std::string& on,
-				  const std::string& tn1,
-				  const std::string& tn2)
+                                  const std::string& tn1,
+                                  const std::string& tn2)
 {
   error ("assignment failed, or no method for `%s %s %s'",
-	 tn1.c_str (), on.c_str (), tn2.c_str ());
+         tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 
 octave_value
 octave_value::subsasgn (const std::string& type,
-			const std::list<octave_value_list>& idx,
-			const octave_value& rhs)
+                        const std::list<octave_value_list>& idx,
+                        const octave_value& rhs)
 {
   return rep->subsasgn (type, idx, rhs);
 }
 
 octave_value
 octave_value::assign (assign_op op, const std::string& type,
-		      const std::list<octave_value_list>& idx,
-		      const octave_value& rhs)
+                      const std::list<octave_value_list>& idx,
+                      const octave_value& rhs)
 {
   octave_value retval;
 
   make_unique ();
 
   octave_value t_rhs = rhs;
 
   if (op != op_asn_eq)
     {
       octave_value t = subsref (type, idx);
 
       if (! error_state)
-	{
-	  binary_op binop = op_eq_to_binary_op (op);
-
-	  if (! error_state)
-	    t_rhs = do_binary_op (binop, t, rhs);
-	}
+        {
+          binary_op binop = op_eq_to_binary_op (op);
+
+          if (! error_state)
+            t_rhs = do_binary_op (binop, t, rhs);
+        }
     }
 
   if (! error_state)
     {
       if (type[0] == '.' && ! (is_map () || is_object ()))
-	{
-	  octave_value tmp = Octave_map ();
-	  retval = tmp.subsasgn (type, idx, t_rhs);
-	}
+        {
+          octave_value tmp = Octave_map ();
+          retval = tmp.subsasgn (type, idx, t_rhs);
+        }
       else
-	retval = subsasgn (type, idx, t_rhs);
+        retval = subsasgn (type, idx, t_rhs);
 
       if (error_state)
         gripe_assign_failed_or_no_method (assign_op_as_string (op_asn_eq),
                                           type_name (), rhs.type_name ());
     }
 
   return retval;
 }
@@ -1308,31 +1308,31 @@ octave_value::assign (assign_op op, cons
       octave_value_typeinfo::assign_op_fcn f = 0;
       
       // Only attempt to operate in-place if this variable is unshared.
       if (rep->count == 1)
         {
           int tthis = this->type_id ();
           int trhs = rhs.type_id ();
 
-	  f = octave_value_typeinfo::lookup_assign_op (op, tthis, trhs);
+          f = octave_value_typeinfo::lookup_assign_op (op, tthis, trhs);
         }
 
       if (f)
-	{
-	  try
-	    {
-	      f (*rep, octave_value_list (), *rhs.rep);
+        {
+          try
+            {
+              f (*rep, octave_value_list (), *rhs.rep);
               maybe_mutate (); // Usually unnecessary, but may be needed (complex arrays).
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      gripe_library_execution_error ();
-	    }
-	}
+            }
+          catch (octave_execution_exception)
+            {
+              gripe_library_execution_error ();
+            }
+        }
       else
         {
 
           binary_op binop = op_eq_to_binary_op (op);
 
           if (! error_state)
             {
               octave_value t = do_binary_op (binop, *this, rhs);
@@ -1351,29 +1351,29 @@ octave_value::length (void) const
 {
   int retval = 0;
 
   dim_vector dv = dims ();
 
   for (int i = 0; i < dv.length (); i++)
     {
       if (dv(i) < 0)
-	{
-	  retval = -1;
-	  break;
-	}
+        {
+          retval = -1;
+          break;
+        }
 
       if (dv(i) == 0)
-	{
-	  retval = 0;
-	  break;
-	}
+        {
+          retval = 0;
+          break;
+        }
 
       if (dv(i) > retval)
-	retval = dv(i);
+        retval = dv(i);
     }
 
   return retval;
 }
 
 bool
 octave_value::is_equal (const octave_value& test) const
 {
@@ -1382,17 +1382,17 @@ octave_value::is_equal (const octave_val
   // If there is no op_eq for these types, we can't compare values.
 
   if (rows () == test.rows () && columns () == test.columns ())
     {
       octave_value tmp = do_binary_op (octave_value::op_eq, *this, test);
 
       // Empty array also means a match.
       if (! error_state && tmp.is_defined ())
-	retval = tmp.is_true () || tmp.is_empty ();
+        retval = tmp.is_true () || tmp.is_empty ();
     }
 
   return retval;
 }
 
 Cell
 octave_value::cell_value (void) const
 {
@@ -1510,17 +1510,17 @@ octave_value::complex_row_vector_value (
                                         bool frc_vec_conv) const
 {
   return ComplexRowVector (complex_vector_value (force_string_conv, 
                                                  frc_vec_conv));
 }
 
 Array<double>
 octave_value::vector_value (bool force_string_conv,
-			    bool force_vector_conversion) const
+                            bool force_vector_conversion) const
 {
   Array<double> retval = array_value (force_string_conv);
 
   if (error_state)
     return retval;
   else
     return retval.reshape (make_vector_dims (retval.dims (),
                                              force_vector_conversion,
@@ -1543,17 +1543,17 @@ convert_to_int_array (const Array<octave
 
   octave_int<int>::clear_conv_flag ();
 
   return retval;
 }
 
 Array<int>
 octave_value::int_vector_value (bool force_string_conv, bool require_int,
-				bool force_vector_conversion) const
+                                bool force_vector_conversion) const
 {
   Array<int> retval;
 
   if (is_integer_type ())
     {
       if (is_int32_type ())
         retval = convert_to_int_array (int32_array_value ());
       else if (is_int64_type ())
@@ -1625,17 +1625,17 @@ convert_to_octave_idx_type_array (const 
   octave_int<int>::clear_conv_flag ();
 
   return retval;
 }
 
 Array<octave_idx_type>
 octave_value::octave_idx_type_vector_value (bool require_int,
                                             bool force_string_conv,
-					    bool force_vector_conversion) const
+                                            bool force_vector_conversion) const
 {
   Array<octave_idx_type> retval;
 
   if (is_integer_type ())
     {
       if (is_int32_type ())
         retval = convert_to_octave_idx_type_array (int32_array_value ());
       else if (is_int64_type ())
@@ -1787,212 +1787,212 @@ octave_value::make_storable_value (void)
       rep = rc;
     }
   else
     maybe_economize ();
 }
 
 int
 octave_value::write (octave_stream& os, int block_size,
-		     oct_data_conv::data_type output_type, int skip,
-		     oct_mach_info::float_format flt_fmt) const
+                     oct_data_conv::data_type output_type, int skip,
+                     oct_mach_info::float_format flt_fmt) const
 {
   return rep->write (os, block_size, output_type, skip, flt_fmt);
 }
 
 static void
 gripe_binary_op (const std::string& on, const std::string& tn1,
-		 const std::string& tn2)
+                 const std::string& tn2)
 {
   error ("binary operator `%s' not implemented for `%s' by `%s' operations",
-	 on.c_str (), tn1.c_str (), tn2.c_str ());
+         on.c_str (), tn1.c_str (), tn2.c_str ());
 }
 
 static void
 gripe_binary_op_conv (const std::string& on)
 {
   error ("type conversion failed for binary operator `%s'", on.c_str ());
 }
 
 octave_value
 do_binary_op (octave_value::binary_op op,
-	      const octave_value& v1, const octave_value& v2)
+              const octave_value& v1, const octave_value& v2)
 {
   octave_value retval;
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
   if (t1 == octave_class::static_type_id ()
       || t2 == octave_class::static_type_id ())
     {
       octave_value_typeinfo::binary_class_op_fcn f
-	= octave_value_typeinfo::lookup_binary_class_op (op);
+        = octave_value_typeinfo::lookup_binary_class_op (op);
 
       if (f)
-	{
-	  try
-	    {
-	      retval = f (v1, v2);
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      gripe_library_execution_error ();
-	    }
-	}	    
+        {
+          try
+            {
+              retval = f (v1, v2);
+            }
+          catch (octave_execution_exception)
+            {
+              gripe_library_execution_error ();
+            }
+        }           
       else
-	gripe_binary_op (octave_value::binary_op_as_string (op),
-			 v1.class_name (), v2.class_name ());
+        gripe_binary_op (octave_value::binary_op_as_string (op),
+                         v1.class_name (), v2.class_name ());
     }
   else
     {
       // FIXME -- we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::binary_op_fcn f
-	= octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+        = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
       if (f)
-	{
-	  try
-	    {
-	      retval = f (*v1.rep, *v2.rep);
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      gripe_library_execution_error ();
-	    }
-	}
+        {
+          try
+            {
+              retval = f (*v1.rep, *v2.rep);
+            }
+          catch (octave_execution_exception)
+            {
+              gripe_library_execution_error ();
+            }
+        }
       else
-	{
-	  octave_value tv1;
-	  octave_base_value::type_conv_info cf1 = v1.numeric_conversion_function ();
-
-	  octave_value tv2;
-	  octave_base_value::type_conv_info cf2 = v2.numeric_conversion_function ();
+        {
+          octave_value tv1;
+          octave_base_value::type_conv_info cf1 = v1.numeric_conversion_function ();
+
+          octave_value tv2;
+          octave_base_value::type_conv_info cf2 = v2.numeric_conversion_function ();
 
           // Try biased (one-sided) conversions first.
           if (cf2.type_id () >= 0 &&
               octave_value_typeinfo::lookup_binary_op (op, t1, cf2.type_id ()))
             cf1 = 0;
           else if (cf1.type_id () >= 0 &&
                    octave_value_typeinfo::lookup_binary_op (op, cf1.type_id (), t2))
             cf2 = 0;
 
-	  if (cf1)
-	    {
-	      octave_base_value *tmp = cf1 (*v1.rep);
-
-	      if (tmp)
-		{
-		  tv1 = octave_value (tmp);
-		  t1 = tv1.type_id ();
-		}
-	      else
-		{
-		  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-		  return retval;
-		}
-	    }
-	  else
-	    tv1 = v1;
-
-	  if (cf2)
-	    {
-	      octave_base_value *tmp = cf2 (*v2.rep);
-
-	      if (tmp)
-		{
-		  tv2 = octave_value (tmp);
-		  t2 = tv2.type_id ();
-		}
-	      else
-		{
-		  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-		  return retval;
-		}
-	    }
-	  else
-	    tv2 = v2;
-
-	  if (cf1 || cf2)
-	    {
+          if (cf1)
+            {
+              octave_base_value *tmp = cf1 (*v1.rep);
+
+              if (tmp)
+                {
+                  tv1 = octave_value (tmp);
+                  t1 = tv1.type_id ();
+                }
+              else
+                {
+                  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                  return retval;
+                }
+            }
+          else
+            tv1 = v1;
+
+          if (cf2)
+            {
+              octave_base_value *tmp = cf2 (*v2.rep);
+
+              if (tmp)
+                {
+                  tv2 = octave_value (tmp);
+                  t2 = tv2.type_id ();
+                }
+              else
+                {
+                  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                  return retval;
+                }
+            }
+          else
+            tv2 = v2;
+
+          if (cf1 || cf2)
+            {
               retval = do_binary_op (op, tv1, tv2);
-	    }
-	  else
-	    {
-	      //demote double -> single and try again
-	      cf1 = tv1.numeric_demotion_function ();
-
-	      cf2 = tv2.numeric_demotion_function ();
+            }
+          else
+            {
+              //demote double -> single and try again
+              cf1 = tv1.numeric_demotion_function ();
+
+              cf2 = tv2.numeric_demotion_function ();
 
               // Try biased (one-sided) conversions first.
               if (cf2.type_id () >= 0
                   && octave_value_typeinfo::lookup_binary_op (op, t1, cf2.type_id ()))
                 cf1 = 0;
               else if (cf1.type_id () >= 0
                        && octave_value_typeinfo::lookup_binary_op (op, cf1.type_id (), t2))
                 cf2 = 0;
 
-	      if (cf1)
-		{
-		  octave_base_value *tmp = cf1 (*tv1.rep);
-
-		  if (tmp)
-		    {
-		      tv1 = octave_value (tmp);
-		      t1 = tv1.type_id ();
-		    }
-		  else
-		    {
-		      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-		      return retval;
-		    }
-		}
-
-	      if (cf2)
-		{
-		  octave_base_value *tmp = cf2 (*tv2.rep);
-
-		  if (tmp)
-		    {
-		      tv2 = octave_value (tmp);
-		      t2 = tv2.type_id ();
-		    }
-		  else
-		    {
-		      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-		      return retval;
-		    }
-		}
-
-	      if (cf1 || cf2)
-		{
-		  f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
-
-		  if (f)
-		    {
-		      try
-			{
-			  retval = f (*tv1.rep, *tv2.rep);
-			}
-		      catch (octave_execution_exception)
-			{
-			  gripe_library_execution_error ();
-			}
-		    }
-		  else
-		    gripe_binary_op (octave_value::binary_op_as_string (op),
-				     v1.type_name (), v2.type_name ());
-		}
-	      else
-		gripe_binary_op (octave_value::binary_op_as_string (op),
-				 v1.type_name (), v2.type_name ());
-	    }
-	}
+              if (cf1)
+                {
+                  octave_base_value *tmp = cf1 (*tv1.rep);
+
+                  if (tmp)
+                    {
+                      tv1 = octave_value (tmp);
+                      t1 = tv1.type_id ();
+                    }
+                  else
+                    {
+                      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                      return retval;
+                    }
+                }
+
+              if (cf2)
+                {
+                  octave_base_value *tmp = cf2 (*tv2.rep);
+
+                  if (tmp)
+                    {
+                      tv2 = octave_value (tmp);
+                      t2 = tv2.type_id ();
+                    }
+                  else
+                    {
+                      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                      return retval;
+                    }
+                }
+
+              if (cf1 || cf2)
+                {
+                  f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+
+                  if (f)
+                    {
+                      try
+                        {
+                          retval = f (*tv1.rep, *tv2.rep);
+                        }
+                      catch (octave_execution_exception)
+                        {
+                          gripe_library_execution_error ();
+                        }
+                    }
+                  else
+                    gripe_binary_op (octave_value::binary_op_as_string (op),
+                                     v1.type_name (), v2.type_name ());
+                }
+              else
+                gripe_binary_op (octave_value::binary_op_as_string (op),
+                                 v1.type_name (), v2.type_name ());
+            }
+        }
     }
 
   return retval;
 }
 
 static octave_value
 decompose_binary_op (octave_value::compound_binary_op op,
                      const octave_value& v1, const octave_value& v2)
@@ -2067,93 +2067,93 @@ do_binary_op (octave_value::compound_bin
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
   if (t1 == octave_class::static_type_id ()
       || t2 == octave_class::static_type_id ())
     {
       octave_value_typeinfo::binary_class_op_fcn f
-	= octave_value_typeinfo::lookup_binary_class_op (op);
+        = octave_value_typeinfo::lookup_binary_class_op (op);
 
       if (f)
-	{
-	  try
-	    {
-	      retval = f (v1, v2);
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      gripe_library_execution_error ();
-	    }
-	}	    
+        {
+          try
+            {
+              retval = f (v1, v2);
+            }
+          catch (octave_execution_exception)
+            {
+              gripe_library_execution_error ();
+            }
+        }           
       else
         retval = decompose_binary_op (op, v1, v2);
     }
   else
     {
       octave_value_typeinfo::binary_op_fcn f
-	= octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+        = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
       if (f)
-	{
-	  try
-	    {
-	      retval = f (*v1.rep, *v2.rep);
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      gripe_library_execution_error ();
-	    }
-	}
+        {
+          try
+            {
+              retval = f (*v1.rep, *v2.rep);
+            }
+          catch (octave_execution_exception)
+            {
+              gripe_library_execution_error ();
+            }
+        }
       else
         retval = decompose_binary_op (op, v1, v2);
     }
 
   return retval;
 }
 
 static void
 gripe_cat_op (const std::string& tn1, const std::string& tn2)
 {
   error ("concatenation operator not implemented for `%s' by `%s' operations",
-	 tn1.c_str (), tn2.c_str ());
+         tn1.c_str (), tn2.c_str ());
 }
 
 static void
 gripe_cat_op_conv (void)
 {
   error ("type conversion failed for concatenation operator");
 }
 
 octave_value
 do_cat_op (const octave_value& v1, const octave_value& v2, 
-	   const Array<octave_idx_type>& ra_idx)
+           const Array<octave_idx_type>& ra_idx)
 {
   octave_value retval;
 
   // Can't rapid return for concatenation with an empty object here as
   // something like cat(1,[],single([]) must return the correct type.
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
   octave_value_typeinfo::cat_op_fcn f
     = octave_value_typeinfo::lookup_cat_op (t1, t2);
 
   if (f)
     {
       try
-	{
-	  retval = f (*v1.rep, *v2.rep, ra_idx);
-	}
+        {
+          retval = f (*v1.rep, *v2.rep, ra_idx);
+        }
       catch (octave_execution_exception)
-	{
-	  gripe_library_execution_error ();
-	}
+        {
+          gripe_library_execution_error ();
+        }
     }
   else
     {
       octave_value tv1;
       octave_base_value::type_conv_info cf1 = v1.numeric_conversion_function ();
 
       octave_value tv2;
       octave_base_value::type_conv_info cf2 = v2.numeric_conversion_function ();
@@ -2162,57 +2162,57 @@ do_cat_op (const octave_value& v1, const
       if (cf2.type_id () >= 0
           && octave_value_typeinfo::lookup_cat_op (t1, cf2.type_id ()))
         cf1 = 0;
       else if (cf1.type_id () >= 0
                && octave_value_typeinfo::lookup_cat_op (cf1.type_id (), t2))
         cf2 = 0;
 
       if (cf1)
-	{
-	  octave_base_value *tmp = cf1 (*v1.rep);
-
-	  if (tmp)
-	    {
-	      tv1 = octave_value (tmp);
-	      t1 = tv1.type_id ();
-	    }
-	  else
-	    {
-	      gripe_cat_op_conv ();
-	      return retval;
-	    }
-	}
+        {
+          octave_base_value *tmp = cf1 (*v1.rep);
+
+          if (tmp)
+            {
+              tv1 = octave_value (tmp);
+              t1 = tv1.type_id ();
+            }
+          else
+            {
+              gripe_cat_op_conv ();
+              return retval;
+            }
+        }
       else
-	tv1 = v1;
+        tv1 = v1;
 
       if (cf2)
-	{
-	  octave_base_value *tmp = cf2 (*v2.rep);
-
-	  if (tmp)
-	    {
-	      tv2 = octave_value (tmp);
-	      t2 = tv2.type_id ();
-	    }
-	  else
-	    {
-	      gripe_cat_op_conv ();
-	      return retval;
-	    }
-	}
+        {
+          octave_base_value *tmp = cf2 (*v2.rep);
+
+          if (tmp)
+            {
+              tv2 = octave_value (tmp);
+              t2 = tv2.type_id ();
+            }
+          else
+            {
+              gripe_cat_op_conv ();
+              return retval;
+            }
+        }
       else
-	tv2 = v2;
+        tv2 = v2;
 
       if (cf1 || cf2)
-	{
+        {
           retval = do_cat_op (tv1, tv2, ra_idx);
-	}
+        }
       else
-	gripe_cat_op (v1.type_name (), v2.type_name ());
+        gripe_cat_op (v1.type_name (), v2.type_name ());
     }
 
   return retval;
 }
 
 void
 octave_value::print_info (std::ostream& os, const std::string& prefix) const
 {
@@ -2222,17 +2222,17 @@ octave_value::print_info (std::ostream& 
 
   rep->print_info (os, prefix + " ");
 }
 
 static void
 gripe_unary_op (const std::string& on, const std::string& tn)
 {
   error ("unary operator `%s' not implemented for `%s' operands",
-	 on.c_str (), tn.c_str ());
+         on.c_str (), tn.c_str ());
 }
 
 static void
 gripe_unary_op_conv (const std::string& on)
 {
   error ("type conversion failed for unary operator `%s'", on.c_str ());
 }
 
@@ -2241,85 +2241,85 @@ do_unary_op (octave_value::unary_op op, 
 {
   octave_value retval;
 
   int t = v.type_id ();
 
   if (t == octave_class::static_type_id ())
     {
       octave_value_typeinfo::unary_class_op_fcn f
-	= octave_value_typeinfo::lookup_unary_class_op (op);
+        = octave_value_typeinfo::lookup_unary_class_op (op);
 
       if (f)
-	{
-	  try
-	    {
-	      retval = f (v);
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      gripe_library_execution_error ();
-	    }
-	}
+        {
+          try
+            {
+              retval = f (v);
+            }
+          catch (octave_execution_exception)
+            {
+              gripe_library_execution_error ();
+            }
+        }
       else
-	gripe_unary_op (octave_value::unary_op_as_string (op),
-			v.class_name ());
+        gripe_unary_op (octave_value::unary_op_as_string (op),
+                        v.class_name ());
     }
   else
     {
       // FIXME -- we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::unary_op_fcn f
-	= octave_value_typeinfo::lookup_unary_op (op, t);
+        = octave_value_typeinfo::lookup_unary_op (op, t);
 
       if (f)
-	{
-	  try
-	    {
-	      retval = f (*v.rep);
-	    }
-	  catch (octave_execution_exception)
-	    {
-	      gripe_library_execution_error ();
-	    }
-	}
+        {
+          try
+            {
+              retval = f (*v.rep);
+            }
+          catch (octave_execution_exception)
+            {
+              gripe_library_execution_error ();
+            }
+        }
       else
-	{
-	  octave_value tv;
-	  octave_base_value::type_conv_fcn cf
-	    = v.numeric_conversion_function ();
-
-	  if (cf)
-	    {
-	      octave_base_value *tmp = cf (*v.rep);
-
-	      if (tmp)
-		{
-		  tv = octave_value (tmp);
+        {
+          octave_value tv;
+          octave_base_value::type_conv_fcn cf
+            = v.numeric_conversion_function ();
+
+          if (cf)
+            {
+              octave_base_value *tmp = cf (*v.rep);
+
+              if (tmp)
+                {
+                  tv = octave_value (tmp);
                   retval = do_unary_op (op, tv);
-		}
-	      else
-		gripe_unary_op_conv (octave_value::unary_op_as_string (op));
-	    }
-	  else
-	    gripe_unary_op (octave_value::unary_op_as_string (op),
-			    v.type_name ());
-	}
+                }
+              else
+                gripe_unary_op_conv (octave_value::unary_op_as_string (op));
+            }
+          else
+            gripe_unary_op (octave_value::unary_op_as_string (op),
+                            v.type_name ());
+        }
     }
 
   return retval;
 }
 
 static void
 gripe_unary_op_conversion_failed (const std::string& op,
-				  const std::string& tn)
+                                  const std::string& tn)
 {
   error ("operator %s: type conversion for `%s' failed",
-	 op.c_str (), tn.c_str ());
+         op.c_str (), tn.c_str ());
 }
 
 const octave_value&
 octave_value::do_non_const_unary_op (unary_op op)
 {
   if (op == op_incr || op == op_decr)
     {
       // Genuine.
@@ -2421,32 +2421,32 @@ octave_value::do_non_const_unary_op (una
     }
 
   return *this;
 }
 
 #if 0
 static void
 gripe_unary_op_failed_or_no_method (const std::string& on,
-				    const std::string& tn) 
+                                    const std::string& tn) 
 {
   error ("operator %s: no method, or unable to evaluate for %s operand",
-	 on.c_str (), tn.c_str ());
+         on.c_str (), tn.c_str ());
 }
 #endif
 
 void
 octave_value::do_non_const_unary_op (unary_op, const octave_value_list&)
 {
   abort ();
 }
 
 octave_value
 octave_value::do_non_const_unary_op (unary_op op, const std::string& type,
-				     const std::list<octave_value_list>& idx)
+                                     const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   if (idx.empty ())
     {
       do_non_const_unary_op (op);
 
       retval = *this;
@@ -2477,18 +2477,18 @@ octave_value::unary_op_to_assign_op (una
       break;
 
     case op_decr:
       binop = op_sub_eq;
       break;
 
     default:
       {
-	std::string on = unary_op_as_string (op);
-	error ("operator %s: no assign operator found", on.c_str ());
+        std::string on = unary_op_as_string (op);
+        error ("operator %s: no assign operator found", on.c_str ());
       }
     }
 
   return binop;
 }
 
 octave_value::binary_op 
 octave_value::op_eq_to_binary_op (assign_op op)
@@ -2550,53 +2550,53 @@ octave_value::op_eq_to_binary_op (assign
       break;
 
     case op_el_or_eq:
       binop = op_el_or;
       break;
 
     default:
       {
-	std::string on = assign_op_as_string (op);
-	error ("operator %s: no binary operator found", on.c_str ());
+        std::string on = assign_op_as_string (op);
+        error ("operator %s: no binary operator found", on.c_str ());
       }
     }
 
   return binop;
 }
 
 octave_value
 octave_value::empty_conv (const std::string& type, const octave_value& rhs)
 {
   octave_value retval;
 
   if (type.length () > 0)
     {
       switch (type[0])
-	{
-	case '(':
-	  {
-	    if (type.length () > 1 && type[1] == '.')
-	      retval = Octave_map ();
-	    else
-	      retval = octave_value (rhs.empty_clone ());
-	  }
-	  break;
-
-	case '{':
-	  retval = Cell ();
-	  break;
-
-	case '.':
-	  retval = Octave_map ();
-	  break;
-
-	default:
-	  panic_impossible ();
-	}
+        {
+        case '(':
+          {
+            if (type.length () > 1 && type[1] == '.')
+              retval = Octave_map ();
+            else
+              retval = octave_value (rhs.empty_clone ());
+          }
+          break;
+
+        case '{':
+          retval = Cell ();
+          break;
+
+        case '.':
+          retval = Octave_map ();
+          break;
+
+        default:
+          panic_impossible ();
+        }
     }
   else
     retval = octave_value (rhs.empty_clone ());
 
   return retval;
 }
 
 void
@@ -2786,15 +2786,15 @@ Note that this is the same as writing @c
 
       decode_subscripts ("subsasgn", args(1), type, idx);
 
       octave_value arg0 = args(0);
 
       arg0.make_unique ();
 
       if (! error_state)
-	retval = arg0.subsasgn (type, idx, args(2));
+        retval = arg0.subsasgn (type, idx, args(2));
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -105,30 +105,30 @@ clear_external_pager (void)
 static bool
 pager_event_handler (pid_t pid, int status)
 {
   bool retval = false;
 
   if (pid > 0)
     {
       if (WIFEXITED (status) || WIFSIGNALLED (status))
-	{
-	  // Avoid warning() since that will put us back in the pager,
-	  // which would be bad news.
+        {
+          // Avoid warning() since that will put us back in the pager,
+          // which would be bad news.
 
-	  std::cerr << "warning: connection to external pager lost (pid = "
-		    << pid << ")" << std::endl;
-	  std::cerr << "warning: flushing pending output (please wait)"
-		    << std::endl;
+          std::cerr << "warning: connection to external pager lost (pid = "
+                    << pid << ")" << std::endl;
+          std::cerr << "warning: flushing pending output (please wait)"
+                    << std::endl;
 
-	  // Request removal of this PID from the list of child
-	  // processes.
+          // Request removal of this PID from the list of child
+          // processes.
 
-	  retval = true;
-	}
+          retval = true;
+        }
     }
 
   return retval;
 }
 
 static std::string
 pager_command (void)
 {
@@ -141,63 +141,63 @@ pager_command (void)
 }
 
 static void
 do_sync (const char *msg, int len, bool bypass_pager)
 {
   if (msg && len > 0)
     {
       if (bypass_pager)
-	{
-	  std::cout.write (msg, len);
-	  std::cout.flush ();
-	}
+        {
+          std::cout.write (msg, len);
+          std::cout.flush ();
+        }
       else
-	{
-	  if (! external_pager)
-	    {
-	      std::string pgr = pager_command ();
+        {
+          if (! external_pager)
+            {
+              std::string pgr = pager_command ();
 
-	      if (! pgr.empty ())
-		{
-		  external_pager = new oprocstream (pgr.c_str ());
+              if (! pgr.empty ())
+                {
+                  external_pager = new oprocstream (pgr.c_str ());
 
-		  if (external_pager)
-		    octave_child_list::insert (external_pager->pid (),
-					       pager_event_handler);
-		}
-	    }
+                  if (external_pager)
+                    octave_child_list::insert (external_pager->pid (),
+                                               pager_event_handler);
+                }
+            }
 
-	  if (external_pager)
-	    {
-	      if (external_pager->good ())
-		{
-		  external_pager->write (msg, len);
+          if (external_pager)
+            {
+              if (external_pager->good ())
+                {
+                  external_pager->write (msg, len);
 
-		  external_pager->flush ();
+                  external_pager->flush ();
 
 #if defined (EPIPE)
-		  if (errno == EPIPE)
-		    external_pager->setstate (std::ios::failbit);
+                  if (errno == EPIPE)
+                    external_pager->setstate (std::ios::failbit);
 #endif
-		}
-	      else
-		{
-		  // FIXME -- omething is not right with the
-		  // pager.  If it died then we should receive a
-		  // signal for that.  If there is some other problem,
-		  // then what?
-		}
-	    }
-	  else
-	    {
-	      std::cout.write (msg, len);
-	      std::cout.flush ();
-	    }
-	}
+                }
+              else
+                {
+                  // FIXME -- omething is not right with the
+                  // pager.  If it died then we should receive a
+                  // signal for that.  If there is some other problem,
+                  // then what?
+                }
+            }
+          else
+            {
+              std::cout.write (msg, len);
+              std::cout.flush ();
+            }
+        }
     }
 }
 
 // Assume our terminal wraps long lines.
 
 static bool
 more_than_a_screenful (const char *s, int len)
 {
@@ -207,28 +207,28 @@ more_than_a_screenful (const char *s, in
 
       int cols = command_editor::terminal_cols ();
 
       int count = 0;
 
       int chars_this_line = 0;
 
       for (int i = 0; i < len; i++)
-	{
-	  if (*s++ == '\n')
-	    {
-	      count += chars_this_line / cols + 1;
-	      chars_this_line = 0;
-	    }
-	  else
-	    chars_this_line++;
-	}
+        {
+          if (*s++ == '\n')
+            {
+              count += chars_this_line / cols + 1;
+              chars_this_line = 0;
+            }
+          else
+            chars_this_line++;
+        }
 
       if (count > available_rows)
- 	return true;
+        return true;
     }
 
   return false;
 }
 
 int
 octave_pager_buf::sync (void)
 {
@@ -237,30 +237,30 @@ octave_pager_buf::sync (void)
       || (Vpage_screen_output && Vpage_output_immediately)
       || ! Vpage_screen_output)
     {
       char *buf = eback ();
 
       int len = pptr () - buf;
 
       bool bypass_pager = (! interactive
-			   || ! Vpage_screen_output
-			   || (really_flush_to_pager
-			       && Vpage_screen_output
-			       && ! Vpage_output_immediately
-			       && ! more_than_a_screenful (buf, len)));
+                           || ! Vpage_screen_output
+                           || (really_flush_to_pager
+                               && Vpage_screen_output
+                               && ! Vpage_output_immediately
+                               && ! more_than_a_screenful (buf, len)));
 
       if (len > 0)
-	{
-	  do_sync (buf, len, bypass_pager);
+        {
+          do_sync (buf, len, bypass_pager);
 
-	  flush_current_contents_to_diary ();
+          flush_current_contents_to_diary ();
 
-	  seekoff (0, std::ios::beg);
-	}
+          seekoff (0, std::ios::beg);
+        }
     }
 
   return 0;
 }
 
 void
 octave_pager_buf::flush_current_contents_to_diary (void)
 {
@@ -284,17 +284,17 @@ octave_diary_buf::sync (void)
 {
   if (write_to_diary_file && external_diary_file)
     {
       char *buf = eback ();
 
       int len = pptr () - buf;
 
       if (len > 0)
-	external_diary_file.write (buf, len);
+        external_diary_file.write (buf, len);
     }
 
   seekoff (0, std::ios::beg);
 
   return 0;
 }
 
 octave_pager_stream *octave_pager_stream::instance = 0;
@@ -454,34 +454,34 @@ With no arguments, @code{diary} toggles 
     {
     case 1:
       write_to_diary_file = ! write_to_diary_file;
       open_diary_file ();
       break;
 
     case 2:
       {
-	std::string arg = argv[1];
+        std::string arg = argv[1];
 
-	if (arg == "on")
-	  {
-	    write_to_diary_file = true;
-	    open_diary_file ();
-	  }	
-	else if (arg == "off")
-	  {
-	    close_diary_file ();
-	    write_to_diary_file = false;
-	  }
-	else
-	  {
-	    diary_file = arg;
-	    write_to_diary_file = true;
-	    open_diary_file ();
-	  }
+        if (arg == "on")
+          {
+            write_to_diary_file = true;
+            open_diary_file ();
+          }     
+        else if (arg == "off")
+          {
+            close_diary_file ();
+            write_to_diary_file = false;
+          }
+        else
+          {
+            diary_file = arg;
+            write_to_diary_file = true;
+            open_diary_file ();
+          }
       }
       break;
 
     default:
       print_usage ();
       break;
     }
 
@@ -507,21 +507,21 @@ The current state can be determined via 
   if (error_state)
     return retval;
 
   if (argc == 2)
     {
       std::string arg = argv[1];
 
       if (arg == "on")
-	Vpage_screen_output = true;
+        Vpage_screen_output = true;
       else if (arg == "off")
-	Vpage_screen_output = false;
+        Vpage_screen_output = false;
       else
-	error ("more: unrecognized argument `%s'", arg.c_str ());
+        error ("more: unrecognized argument `%s'", arg.c_str ());
     }
   else if (argc == 1)
     Vpage_screen_output = ! Vpage_screen_output;
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -134,32 +134,32 @@ current_output_precision (void)
 }
 
 class
 float_format
 {
 public:
 
   float_format (int w = current_output_max_field_width (),
-		int p = current_output_precision (), int f = 0)
+                int p = current_output_precision (), int f = 0)
     : fw (w), prec (p), fmt (f), up (0), sp (0) { }
 
   float_format (const float_format& ff)
     : fw (ff.fw), prec (ff.prec), fmt (ff.fmt), up (ff.up), sp (ff.sp) { }
 
   float_format& operator = (const float_format& ff)
     {
       if (&ff != this)
-	{
-	  fw = ff.fw;
-	  prec = ff.prec;
-	  fmt = ff.fmt;
-	  up = ff.up;
-	  sp = ff.sp;
-	}
+        {
+          fw = ff.fw;
+          prec = ff.prec;
+          fmt = ff.fmt;
+          up = ff.up;
+          sp = ff.sp;
+        }
 
       return *this;
     }
 
   ~float_format (void) { }
 
   float_format& scientific (void) { fmt = std::ios::scientific; return *this; }
   float_format& fixed (void) { fmt = std::ios::fixed; return *this; }
@@ -171,20 +171,20 @@ public:
   float_format& precision (int p) { prec = p; return *this; }
 
   float_format& width (int w) { fw = w; return *this; }
 
   float_format& trailing_zeros (bool tz = true)
     { sp = tz ? std::ios::showpoint : 0; return *this; }
 
   friend std::ostream& operator << (std::ostream& os,
-				    const pr_formatted_float& pff);
+                                    const pr_formatted_float& pff);
 
   friend std::ostream& operator << (std::ostream& os,
-				    const pr_rational_float& pff);
+                                    const pr_rational_float& pff);
 
 private:
 
   // Field width.  Zero means as wide as necessary.
   int fw;
 
   // Precision.
   int prec;
@@ -261,67 +261,67 @@ rational_approx (double val, int len)
       int m = 0;
 
       std::ostringstream buf2;
       buf2.flags (std::ios::fixed);
       buf2 << std::setprecision (0) << static_cast<int>(n); 
       s = buf2.str();
 
       while (1)
-	{
-	  double flip = 1. / frac;
-	  double step = xround (flip);
-	  double nextn = n;
-	  double nextd = d;
-
-	  // Have we converged to 1/intmax ?
-	  if (m > 100 || fabs (frac) < 1 / static_cast<double>(INT_MAX))
-	    {
-	      lastn = n;
-	      lastd = d;
-	      break;
-	    }
-
-	  frac = flip - step;
-	  n = n * step + lastn;
-	  d = d * step + lastd;
-	  lastn = nextn;
-	  lastd = nextd;
-
-	  std::ostringstream buf;
-	  buf.flags (std::ios::fixed);
-	  buf << std::setprecision (0) << static_cast<int>(n) 
-	      << "/" << static_cast<int>(d);
-	  m++;
-
-	  if (n < 0 && d < 0)
-	    {
-	      // Double negative, string can be two characters longer..
-	      if (buf.str().length() > static_cast<unsigned int>(len + 2) && 
-		  m > 1) 
-		break;
-	    }
-	  else if (buf.str().length() > static_cast<unsigned int>(len) && 
-		   m > 1) 
-	    break;
-
-	  s = buf.str();
-	}
+        {
+          double flip = 1. / frac;
+          double step = xround (flip);
+          double nextn = n;
+          double nextd = d;
+
+          // Have we converged to 1/intmax ?
+          if (m > 100 || fabs (frac) < 1 / static_cast<double>(INT_MAX))
+            {
+              lastn = n;
+              lastd = d;
+              break;
+            }
+
+          frac = flip - step;
+          n = n * step + lastn;
+          d = d * step + lastd;
+          lastn = nextn;
+          lastd = nextd;
+
+          std::ostringstream buf;
+          buf.flags (std::ios::fixed);
+          buf << std::setprecision (0) << static_cast<int>(n) 
+              << "/" << static_cast<int>(d);
+          m++;
+
+          if (n < 0 && d < 0)
+            {
+              // Double negative, string can be two characters longer..
+              if (buf.str().length() > static_cast<unsigned int>(len + 2) && 
+                  m > 1) 
+                break;
+            }
+          else if (buf.str().length() > static_cast<unsigned int>(len) && 
+                   m > 1) 
+            break;
+
+          s = buf.str();
+        }
 
       if (lastd < 0.)
-	{
-	  // Move sign to the top
-	  lastd = - lastd;
-	  lastn = - lastn;
-	  std::ostringstream buf;
-	  buf.flags (std::ios::fixed);
-	  buf << std::setprecision (0) << static_cast<int>(lastn) 
-	       << "/" << static_cast<int>(lastd);
-	  s = buf.str();
-	}
+        {
+          // Move sign to the top
+          lastd = - lastd;
+          lastn = - lastn;
+          std::ostringstream buf;
+          buf.flags (std::ios::fixed);
+          buf << std::setprecision (0) << static_cast<int>(lastn) 
+               << "/" << static_cast<int>(lastd);
+          s = buf.str();
+        }
     }
 
   return s;
 }
 
 class
 pr_rational_float
 {
@@ -373,24 +373,24 @@ pr_max_internal (const Matrix& m)
 
   double result = -DBL_MAX;
 
   bool all_inf_or_nan = true;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	double val = m(i,j);
-	if (xisinf (val) || xisnan (val))
-	  continue;
-
-	all_inf_or_nan = false;
-
-	if (val > result)
-	  result = val;
+        double val = m(i,j);
+        if (xisinf (val) || xisnan (val))
+          continue;
+
+        all_inf_or_nan = false;
+
+        if (val > result)
+          result = val;
       }
 
   if (all_inf_or_nan)
     result = 0.0;
 
   return result;
 }
 
@@ -402,24 +402,24 @@ pr_min_internal (const Matrix& m)
 
   double result = DBL_MAX;
 
   bool all_inf_or_nan = true;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	double val = m(i,j);
-	if (xisinf (val) || xisnan (val))
-	  continue;
-
-	all_inf_or_nan = false;
-
-	if (val < result)
-	  result = val;
+        double val = m(i,j);
+        if (xisinf (val) || xisnan (val))
+          continue;
+
+        all_inf_or_nan = false;
+
+        if (val < result)
+          result = val;
       }
 
   if (all_inf_or_nan)
     result = 0.0;
 
   return result;
 }
 
@@ -439,76 +439,76 @@ set_real_format (int digits, bool inf_or
     {
       fw = 0;
       rd = 0;
     }
   else if (bank_format)
     {
       fw = digits < 0 ? 4 : digits + 3;
       if (inf_or_nan && fw < 4)
-	fw = 4;
+        fw = 4;
       rd = 2;
     }
   else if (hex_format)
     {
       fw = 2 * sizeof (double);
       rd = 0;
     }
   else if (bit_format)
     {
       fw = 8 * sizeof (double);
       rd = 0;
     }
   else if (inf_or_nan || int_only)
     {
       fw = 1 + digits;
       if (inf_or_nan && fw < 4)
-	fw = 4;
+        fw = 4;
       rd = fw;
     }
   else
     {
       if (digits > 0)
-	{
-	  ld = digits;
-	  rd = prec > digits ? prec - digits : prec;
-	  digits++;
-	}
+        {
+          ld = digits;
+          rd = prec > digits ? prec - digits : prec;
+          digits++;
+        }
       else
-	{
-	  ld = 1;
-	  rd = prec > digits ? prec - digits : prec;
-	  digits = -digits + 1;
-	}
+        {
+          ld = 1;
+          rd = prec > digits ? prec - digits : prec;
+          digits = -digits + 1;
+        }
 
       fw = 1 + ld + 1 + rd;
       if (inf_or_nan && fw < 4)
-	fw = 4;
+        fw = 4;
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
       && (fw > Voutput_max_field_width || print_e || print_g))
     {
       if (print_g)
-	fmt = float_format ();
+        fmt = float_format ();
       else
-	{
-	  int exp_field = 4;
-	  if (digits > 100)
-	    exp_field++;
-
-	  fw = 2 + prec + exp_field;
-	  if (inf_or_nan && fw < 4)
-	    fw = 4;
-
-	  fmt = float_format (fw, prec - 1, std::ios::scientific);
-	}
+        {
+          int exp_field = 4;
+          if (digits > 100)
+            exp_field++;
+
+          fw = 2 + prec + exp_field;
+          if (inf_or_nan && fw < 4)
+            fw = 4;
+
+          fmt = float_format (fw, prec - 1, std::ios::scientific);
+        }
 
       if (print_big_e)
-	fmt.uppercase ();
+        fmt.uppercase ();
     }
   else if (! bank_format && (inf_or_nan || int_only))
     fmt = float_format (fw, rd);
   else
     fmt = float_format (fw, rd, std::ios::fixed);
 
   curr_real_fmt = &fmt;
 }
@@ -538,17 +538,17 @@ static inline void
 set_format (double d)
 {
   int fw;
   set_format (d, fw);
 }
 
 static void
 set_real_matrix_format (int x_max, int x_min, bool inf_or_nan,
-			int int_or_inf_or_nan, int& fw)
+                        int int_or_inf_or_nan, int& fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
   if (rat_format)
@@ -556,17 +556,17 @@ set_real_matrix_format (int x_max, int x
       fw = 9;
       rd = 0;
     }
   else if (bank_format)
     {
       int digits = x_max > x_min ? x_max : x_min;
       fw = digits <= 0 ? 4 : digits + 3;
       if (inf_or_nan && fw < 4)
-	fw = 4;
+        fw = 4;
       rd = 2;
     }
   else if (hex_format)
     {
       fw = 2 * sizeof (double);
       rd = 0;
     }
   else if (bit_format)
@@ -574,86 +574,86 @@ set_real_matrix_format (int x_max, int x
       fw = 8 * sizeof (double);
       rd = 0;
     }
   else if (Vfixed_point_format && ! print_g)
     {
       rd = prec;
       fw = rd + 2;
       if (inf_or_nan && fw < 4)
-	fw = 4;
+        fw = 4;
     }
   else if (int_or_inf_or_nan)
     {
       int digits = x_max > x_min ? x_max : x_min;
       fw = digits <= 0 ? 2 : digits + 1;
       if (inf_or_nan && fw < 4)
-	fw = 4;
+        fw = 4;
       rd = fw;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
-	{
-	  ld_max = x_max;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max++;
-	}
+        {
+          ld_max = x_max;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max++;
+        }
       else
-	{
-	  ld_max = 1;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max = -x_max + 1;
-	}
+        {
+          ld_max = 1;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max = -x_max + 1;
+        }
 
       int ld_min, rd_min;
       if (x_min > 0)
-	{
-	  ld_min = x_min;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min++;
-	}
+        {
+          ld_min = x_min;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min++;
+        }
       else
-	{
-	  ld_min = 1;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min = -x_min + 1;
-	}
+        {
+          ld_min = 1;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min = -x_min + 1;
+        }
 
       ld = ld_max > ld_min ? ld_max : ld_min;
       rd = rd_max > rd_min ? rd_max : rd_min;
 
       fw = 1 + ld + 1 + rd;
       if (inf_or_nan && fw < 4)
-	fw = 4;
+        fw = 4;
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
-	  || print_g
-	  || (! Vfixed_point_format && fw > Voutput_max_field_width)))
+          || print_g
+          || (! Vfixed_point_format && fw > Voutput_max_field_width)))
     {
       if (print_g)
-	fmt = float_format ();
+        fmt = float_format ();
       else
-	{
-	  int exp_field = 4;
-	  if (x_max > 100 || x_min > 100)
-	    exp_field++;
-
-	  fw = 2 + prec + exp_field;
-	  if (inf_or_nan && fw < 4)
-	    fw = 4;
-
-	  fmt = float_format (fw, prec - 1, std::ios::scientific);
-	}
+        {
+          int exp_field = 4;
+          if (x_max > 100 || x_min > 100)
+            exp_field++;
+
+          fw = 2 + prec + exp_field;
+          if (inf_or_nan && fw < 4)
+            fw = 4;
+
+          fmt = float_format (fw, prec - 1, std::ios::scientific);
+        }
 
       if (print_big_e)
-	fmt.uppercase ();
+        fmt.uppercase ();
     }
   else if (! bank_format && int_or_inf_or_nan)
     fmt = float_format (fw, rd);
   else
     fmt = float_format (fw, rd, std::ios::fixed);
 
   curr_real_fmt = &fmt;
 }
@@ -691,17 +691,17 @@ set_format (const Matrix& m)
 {
   int fw;
   double scale;
   set_format (m, fw, scale);
 }
 
 static void
 set_complex_format (int x_max, int x_min, int r_x, bool inf_or_nan,
-		    int int_only, int& r_fw, int& i_fw)
+                    int int_only, int& r_fw, int& i_fw)
 {
   static float_format r_fmt;
   static float_format i_fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
@@ -712,17 +712,17 @@ set_complex_format (int x_max, int x_min
       rd = 0;
     }
   else if (bank_format)
     {
       int digits = r_x;
       i_fw = 0;
       r_fw = digits <= 0 ? 4 : digits + 3;
       if (inf_or_nan && r_fw < 4)
-	r_fw = 4;
+        r_fw = 4;
       rd = 2;
     }
   else if (hex_format)
     {
       r_fw = 2 * sizeof (double);
       i_fw = 2 * sizeof (double);
       rd = 0;
     }
@@ -733,95 +733,95 @@ set_complex_format (int x_max, int x_min
       rd = 0;
     }
   else if (inf_or_nan || int_only)
     {
       int digits = x_max > x_min ? x_max : x_min;
       i_fw = digits <= 0 ? 1 : digits;
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
-	{
-	  i_fw = 3;
-	  r_fw = 4;
-	}
+        {
+          i_fw = 3;
+          r_fw = 4;
+        }
       rd = r_fw;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
-	{
-	  ld_max = x_max;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max++;
-	}
+        {
+          ld_max = x_max;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max++;
+        }
       else
-	{
-	  ld_max = 1;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max = -x_max + 1;
-	}
+        {
+          ld_max = 1;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max = -x_max + 1;
+        }
 
       int ld_min, rd_min;
       if (x_min > 0)
-	{
-	  ld_min = x_min;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min++;
-	}
+        {
+          ld_min = x_min;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min++;
+        }
       else
-	{
-	  ld_min = 1;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min = -x_min + 1;
-	}
+        {
+          ld_min = 1;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min = -x_min + 1;
+        }
 
       ld = ld_max > ld_min ? ld_max : ld_min;
       rd = rd_max > rd_min ? rd_max : rd_min;
 
       i_fw = ld + 1 + rd;
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
-	{
-	  i_fw = 3;
-	  r_fw = 4;
-	}
+        {
+          i_fw = 3;
+          r_fw = 4;
+        }
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
       && (r_fw > Voutput_max_field_width || print_e || print_g))
     {
       if (print_g)
-	{
-	  r_fmt = float_format ();
-	  i_fmt = float_format ();
-	}
+        {
+          r_fmt = float_format ();
+          i_fmt = float_format ();
+        }
       else
-	{
-	  int exp_field = 4;
-	  if (x_max > 100 || x_min > 100)
-	    exp_field++;
-
-	  i_fw = prec + exp_field;
-	  r_fw = i_fw + 1;
-	  if (inf_or_nan && i_fw < 3)
-	    {
-	      i_fw = 3;
-	      r_fw = 4;
-	    }
-
-	  r_fmt = float_format (r_fw, prec - 1, std::ios::scientific);
-	  i_fmt = float_format (i_fw, prec - 1, std::ios::scientific);
-	}
+        {
+          int exp_field = 4;
+          if (x_max > 100 || x_min > 100)
+            exp_field++;
+
+          i_fw = prec + exp_field;
+          r_fw = i_fw + 1;
+          if (inf_or_nan && i_fw < 3)
+            {
+              i_fw = 3;
+              r_fw = 4;
+            }
+
+          r_fmt = float_format (r_fw, prec - 1, std::ios::scientific);
+          i_fmt = float_format (i_fw, prec - 1, std::ios::scientific);
+        }
 
       if (print_big_e)
-	{
-	  r_fmt.uppercase ();
-	  i_fmt.uppercase ();
-	}
+        {
+          r_fmt.uppercase ();
+          i_fmt.uppercase ();
+        }
     }
   else if (! bank_format && (inf_or_nan || int_only))
     {
       r_fmt = float_format (r_fw, rd);
       i_fmt = float_format (i_fw, rd);
     }
   else
     {
@@ -878,18 +878,18 @@ static inline void
 set_format (const Complex& c)
 {
   int r_fw, i_fw;
   set_format (c, r_fw, i_fw);
 }
 
 static void
 set_complex_matrix_format (int x_max, int x_min, int r_x_max,
-			   int r_x_min, bool inf_or_nan,
-			   int int_or_inf_or_nan, int& r_fw, int& i_fw)
+                           int r_x_min, bool inf_or_nan,
+                           int int_or_inf_or_nan, int& r_fw, int& i_fw)
 {
   static float_format r_fmt;
   static float_format i_fmt;
 
   int prec = Voutput_precision;
 
   int ld, rd;
 
@@ -900,17 +900,17 @@ set_complex_matrix_format (int x_max, in
       rd = 0;
     }
   else if (bank_format)
     {
       int digits = r_x_max > r_x_min ? r_x_max : r_x_min;
       i_fw = 0;
       r_fw = digits <= 0 ? 4 : digits + 3;
       if (inf_or_nan && r_fw < 4)
-	r_fw = 4;
+        r_fw = 4;
       rd = 2;
     }
   else if (hex_format)
     {
       r_fw = 2 * sizeof (double);
       i_fw = 2 * sizeof (double);
       rd = 0;
     }
@@ -921,108 +921,108 @@ set_complex_matrix_format (int x_max, in
       rd = 0;
     }
   else if (Vfixed_point_format && ! print_g)
     {
       rd = prec;
       i_fw = rd + 1;
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
-	{
-	  i_fw = 3;
-	  r_fw = 4;
-	}
+        {
+          i_fw = 3;
+          r_fw = 4;
+        }
     }
   else if (int_or_inf_or_nan)
     {
       int digits = x_max > x_min ? x_max : x_min;
       i_fw = digits <= 0 ? 1 : digits;
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
-	{
-	  i_fw = 3;
-	  r_fw = 4;
-	}
+        {
+          i_fw = 3;
+          r_fw = 4;
+        }
       rd = r_fw;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
-	{
-	  ld_max = x_max;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max++;
-	}
+        {
+          ld_max = x_max;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max++;
+        }
       else
-	{
-	  ld_max = 1;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max = -x_max + 1;
-	}
+        {
+          ld_max = 1;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max = -x_max + 1;
+        }
 
       int ld_min, rd_min;
       if (x_min > 0)
-	{
-	  ld_min = x_min;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min++;
-	}
+        {
+          ld_min = x_min;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min++;
+        }
       else
-	{
-	  ld_min = 1;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min = -x_min + 1;
-	}
+        {
+          ld_min = 1;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min = -x_min + 1;
+        }
 
       ld = ld_max > ld_min ? ld_max : ld_min;
       rd = rd_max > rd_min ? rd_max : rd_min;
 
       i_fw = ld + 1 + rd;
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
-	{
-	  i_fw = 3;
-	  r_fw = 4;
-	}
+        {
+          i_fw = 3;
+          r_fw = 4;
+        }
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
-	  || print_g
-	  || (! Vfixed_point_format && r_fw > Voutput_max_field_width)))
+          || print_g
+          || (! Vfixed_point_format && r_fw > Voutput_max_field_width)))
     {
       if (print_g)
-	{
-	  r_fmt = float_format ();
-	  i_fmt = float_format ();
-	}
+        {
+          r_fmt = float_format ();
+          i_fmt = float_format ();
+        }
       else
-	{
-	  int exp_field = 4;
-	  if (x_max > 100 || x_min > 100)
-	    exp_field++;
-
-	  i_fw = prec + exp_field;
-	  r_fw = i_fw + 1;
-	  if (inf_or_nan && i_fw < 3)
-	    {
-	      i_fw = 3;
-	      r_fw = 4;
-	    }
-
-	  r_fmt = float_format (r_fw, prec - 1, std::ios::scientific);
-	  i_fmt = float_format (i_fw, prec - 1, std::ios::scientific);
-	}
+        {
+          int exp_field = 4;
+          if (x_max > 100 || x_min > 100)
+            exp_field++;
+
+          i_fw = prec + exp_field;
+          r_fw = i_fw + 1;
+          if (inf_or_nan && i_fw < 3)
+            {
+              i_fw = 3;
+              r_fw = 4;
+            }
+
+          r_fmt = float_format (r_fw, prec - 1, std::ios::scientific);
+          i_fmt = float_format (i_fw, prec - 1, std::ios::scientific);
+        }
 
       if (print_big_e)
-	{
-	  r_fmt.uppercase ();
-	  i_fmt.uppercase ();
-	}
+        {
+          r_fmt.uppercase ();
+          i_fmt.uppercase ();
+        }
     }
   else if (! bank_format && int_or_inf_or_nan)
     {
       r_fmt = float_format (r_fw, rd);
       i_fmt = float_format (i_fw, rd);
     }
   else
     {
@@ -1044,17 +1044,17 @@ set_format (const ComplexMatrix& cm, int
     return;
 
   Matrix rp = real (cm);
   Matrix ip = imag (cm);
 
   bool inf_or_nan = cm.any_element_is_inf_or_nan ();
 
   bool int_or_inf_or_nan = (rp.all_elements_are_int_or_inf_or_nan ()
-			    && ip.all_elements_are_int_or_inf_or_nan ());
+                            && ip.all_elements_are_int_or_inf_or_nan ());
 
   Matrix r_m_abs = rp.abs ();
   double r_max_abs = pr_max_internal (r_m_abs);
   double r_min_abs = pr_min_internal (r_m_abs);
 
   Matrix i_m_abs = ip.abs ();
   double i_max_abs = pr_max_internal (i_m_abs);
   double i_min_abs = pr_min_internal (i_m_abs);
@@ -1072,17 +1072,17 @@ set_format (const ComplexMatrix& cm, int
     ? 0 : static_cast<int> (floor (log10 (i_min_abs) + 1.0));
 
   int x_max = r_x_max > i_x_max ? r_x_max : i_x_max;
   int x_min = r_x_min > i_x_min ? r_x_min : i_x_min;
 
   scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0 : std::pow (10.0, x_max - 1);
 
   set_complex_matrix_format (x_max, x_min, r_x_max, r_x_min, inf_or_nan,
-			     int_or_inf_or_nan, r_fw, i_fw);
+                             int_or_inf_or_nan, r_fw, i_fw);
 }
 
 static inline void
 set_format (const ComplexMatrix& cm)
 {
   int r_fw, i_fw;
   double scale;
   set_format (cm, r_fw, i_fw, scale);
@@ -1128,68 +1128,68 @@ set_range_format (int x_max, int x_min, 
     {
       rd = prec;
       fw = rd + 3;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
-	{
-	  ld_max = x_max;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max++;
-	}
+        {
+          ld_max = x_max;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max++;
+        }
       else
-	{
-	  ld_max = 1;
-	  rd_max = prec > x_max ? prec - x_max : prec;
-	  x_max = -x_max + 1;
-	}
+        {
+          ld_max = 1;
+          rd_max = prec > x_max ? prec - x_max : prec;
+          x_max = -x_max + 1;
+        }
 
       int ld_min, rd_min;
       if (x_min > 0)
-	{
-	  ld_min = x_min;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min++;
-	}
+        {
+          ld_min = x_min;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min++;
+        }
       else
-	{
-	  ld_min = 1;
-	  rd_min = prec > x_min ? prec - x_min : prec;
-	  x_min = -x_min + 1;
-	}
+        {
+          ld_min = 1;
+          rd_min = prec > x_min ? prec - x_min : prec;
+          x_min = -x_min + 1;
+        }
 
       ld = ld_max > ld_min ? ld_max : ld_min;
       rd = rd_max > rd_min ? rd_max : rd_min;
 
       fw = ld + rd + 3;
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
-	  || print_g
-	  || (! Vfixed_point_format && fw > Voutput_max_field_width)))
+          || print_g
+          || (! Vfixed_point_format && fw > Voutput_max_field_width)))
     {
       if (print_g)
-	fmt = float_format ();
+        fmt = float_format ();
       else
-	{
-	  int exp_field = 4;
-	  if (x_max > 100 || x_min > 100)
-	    exp_field++;
-
-	  fw = 3 + prec + exp_field;
-
-	  fmt = float_format (fw, prec - 1, std::ios::scientific);
-	}
+        {
+          int exp_field = 4;
+          if (x_max > 100 || x_min > 100)
+            exp_field++;
+
+          fw = 3 + prec + exp_field;
+
+          fmt = float_format (fw, prec - 1, std::ios::scientific);
+        }
 
       if (print_big_e)
-	fmt.uppercase ();
+        fmt.uppercase ();
     }
   else if (! bank_format && all_ints)
     fmt = float_format (fw, rd);
   else
     fmt = float_format (fw, rd, std::ios::fixed);
 
   curr_real_fmt = &fmt;
 }
@@ -1286,118 +1286,118 @@ pr_any_float (const float_format *fmt, s
     {
       // Unless explicitly asked for, always print in big-endian
       // format for hex and bit formats.
       //
       //   {bit,hex}_format == 1: print big-endian
       //   {bit,hex}_format == 2: print native
 
       if (hex_format)
-	{
-	  equiv tmp;
-	  tmp.d = d;
-
-	  // Unless explicitly asked for, always print in big-endian
-	  // format.
-
-	  // FIXME -- is it correct to swap bytes for VAX
-	  // formats and not for Cray?
-
-	  // FIXME -- will bad things happen if we are
-	  // interrupted before resetting the format flags and fill
-	  // character?
-
-	  oct_mach_info::float_format flt_fmt =
-	    oct_mach_info::native_float_format ();
-
-	  char ofill = os.fill ('0');
-
-	  std::ios::fmtflags oflags
-	    = os.flags (std::ios::right | std::ios::hex);
-
-	  if (hex_format > 1
-	      || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian
-	      || flt_fmt == oct_mach_info::flt_fmt_cray
-	      || flt_fmt == oct_mach_info::flt_fmt_unknown)
-	    {
-	      for (size_t i = 0; i < sizeof (double); i++)
-		os << std::setw (2) << static_cast<int> (tmp.i[i]);
-	    }
-	  else
-	    {
-	      for (int i = sizeof (double) - 1; i >= 0; i--)
-		os << std::setw (2) << static_cast<int> (tmp.i[i]);
-	    }
-
-	  os.fill (ofill);
-	  os.setf (oflags);	  
-	}
+        {
+          equiv tmp;
+          tmp.d = d;
+
+          // Unless explicitly asked for, always print in big-endian
+          // format.
+
+          // FIXME -- is it correct to swap bytes for VAX
+          // formats and not for Cray?
+
+          // FIXME -- will bad things happen if we are
+          // interrupted before resetting the format flags and fill
+          // character?
+
+          oct_mach_info::float_format flt_fmt =
+            oct_mach_info::native_float_format ();
+
+          char ofill = os.fill ('0');
+
+          std::ios::fmtflags oflags
+            = os.flags (std::ios::right | std::ios::hex);
+
+          if (hex_format > 1
+              || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian
+              || flt_fmt == oct_mach_info::flt_fmt_cray
+              || flt_fmt == oct_mach_info::flt_fmt_unknown)
+            {
+              for (size_t i = 0; i < sizeof (double); i++)
+                os << std::setw (2) << static_cast<int> (tmp.i[i]);
+            }
+          else
+            {
+              for (int i = sizeof (double) - 1; i >= 0; i--)
+                os << std::setw (2) << static_cast<int> (tmp.i[i]);
+            }
+
+          os.fill (ofill);
+          os.setf (oflags);       
+        }
       else if (bit_format)
-	{
-	  equiv tmp;
-	  tmp.d = d;
-
-	  // FIXME -- is it correct to swap bytes for VAX
-	  // formats and not for Cray?
-
-	  oct_mach_info::float_format flt_fmt =
-	    oct_mach_info::native_float_format ();
-
-	  if (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian
-	      || flt_fmt == oct_mach_info::flt_fmt_cray
-	      || flt_fmt == oct_mach_info::flt_fmt_unknown)
-	    {
-	      for (size_t i = 0; i < sizeof (double); i++)
-		PRINT_CHAR_BITS (os, tmp.i[i]);
-	    }
-	  else
-	    {
-	      if (bit_format > 1)
-		{
-		  for (size_t i = 0; i < sizeof (double); i++)
-		    PRINT_CHAR_BITS_SWAPPED (os, tmp.i[i]);
-		}
-	      else
-		{
-		  for (int i = sizeof (double) - 1; i >= 0; i--)
-		    PRINT_CHAR_BITS (os, tmp.i[i]);
-		}
-	    }
-	}
+        {
+          equiv tmp;
+          tmp.d = d;
+
+          // FIXME -- is it correct to swap bytes for VAX
+          // formats and not for Cray?
+
+          oct_mach_info::float_format flt_fmt =
+            oct_mach_info::native_float_format ();
+
+          if (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian
+              || flt_fmt == oct_mach_info::flt_fmt_cray
+              || flt_fmt == oct_mach_info::flt_fmt_unknown)
+            {
+              for (size_t i = 0; i < sizeof (double); i++)
+                PRINT_CHAR_BITS (os, tmp.i[i]);
+            }
+          else
+            {
+              if (bit_format > 1)
+                {
+                  for (size_t i = 0; i < sizeof (double); i++)
+                    PRINT_CHAR_BITS_SWAPPED (os, tmp.i[i]);
+                }
+              else
+                {
+                  for (int i = sizeof (double) - 1; i >= 0; i--)
+                    PRINT_CHAR_BITS (os, tmp.i[i]);
+                }
+            }
+        }
       else if (octave_is_NA (d))
-	{
-	  if (fw > 0)
-	    os << std::setw (fw) << "NA";
-	  else
-	    os << "NA";
-	}
+        {
+          if (fw > 0)
+            os << std::setw (fw) << "NA";
+          else
+            os << "NA";
+        }
       else if (rat_format)
-	os << pr_rational_float (*fmt, d);
+        os << pr_rational_float (*fmt, d);
       else if (xisinf (d))
-	{
-	  const char *s;
-	  if (d < 0.0)
-	    s = "-Inf";
-	  else
-	    s = "Inf";
-
-	  if (fw > 0)
-	    os << std::setw (fw) << s;
-	  else
-	    os << s;
-	}
+        {
+          const char *s;
+          if (d < 0.0)
+            s = "-Inf";
+          else
+            s = "Inf";
+
+          if (fw > 0)
+            os << std::setw (fw) << s;
+          else
+            os << s;
+        }
       else if (xisnan (d))
-	{
-	  if (fw > 0)
-	    os << std::setw (fw) << "NaN";
-	  else
-	    os << "NaN";
-	}
+        {
+          if (fw > 0)
+            os << std::setw (fw) << "NaN";
+          else
+            os << "NaN";
+        }
       else
-	os << pr_formatted_float (*fmt, d);
+        os << pr_formatted_float (*fmt, d);
     }
   else
     os << d;
 }
 
 static inline void
 pr_float (std::ostream& os, double d, int fw = 0, double scale = 1.0)
 {
@@ -1410,129 +1410,129 @@ pr_float (std::ostream& os, double d, in
 static inline void
 pr_imag_float (std::ostream& os, double d, int fw = 0)
 {
   pr_any_float (curr_imag_fmt, os, d, fw);
 }
 
 static void
 pr_complex (std::ostream& os, const Complex& c, int r_fw = 0,
-	    int i_fw = 0, double scale = 1.0)
+            int i_fw = 0, double scale = 1.0)
 {
   Complex tmp
     = (Vfixed_point_format && ! print_g && scale != 1.0) ? c / scale : c;
 
   double r = tmp.real ();
 
   pr_float (os, r, r_fw);
 
   if (! bank_format)
     {
       double i = tmp.imag ();
       if (! (hex_format || bit_format) && lo_ieee_signbit (i))
-	{
-	  os << " - ";
-	  i = -i;
-	  pr_imag_float (os, i, i_fw);
-	}
+        {
+          os << " - ";
+          i = -i;
+          pr_imag_float (os, i, i_fw);
+        }
       else
-	{
-	  if (hex_format || bit_format)
-	    os << "  ";
-	  else
-	    os << " + ";
-
-	  pr_imag_float (os, i, i_fw);
-	}
+        {
+          if (hex_format || bit_format)
+            os << "  ";
+          else
+            os << " + ";
+
+          pr_imag_float (os, i, i_fw);
+        }
       os << "i";
     }
 }
 
 static void
 print_empty_matrix (std::ostream& os, octave_idx_type nr, octave_idx_type nc, bool pr_as_read_syntax)
 {
   assert (nr == 0 || nc == 0);
 
   if (pr_as_read_syntax)
     {
       if (nr == 0 && nc == 0)
-	os << "[]";
+        os << "[]";
       else
-	os << "zeros (" << nr << ", " << nc << ")";
+        os << "zeros (" << nr << ", " << nc << ")";
     }
   else
     {
       os << "[]";
 
       if (Vprint_empty_dimensions)
-	os << "(" << nr << "x" << nc << ")";
+        os << "(" << nr << "x" << nc << ")";
     }
 }
 
 static void
 print_empty_nd_array (std::ostream& os, const dim_vector& dims,
-		      bool pr_as_read_syntax)
+                      bool pr_as_read_syntax)
 {
   assert (dims.any_zero ());
 
   if (pr_as_read_syntax)
     os << "zeros (" << dims.str (',') << ")";
   else
     {
       os << "[]";
 
       if (Vprint_empty_dimensions)
-	os << "(" << dims.str () << ")";
+        os << "(" << dims.str () << ")";
     }
 }
 
 static void
 pr_scale_header (std::ostream& os, double scale)
 {
   if (Vfixed_point_format && ! print_g && scale != 1.0)
     {
       os << "  "
-	 << std::setw (8) << std::setprecision (1)
-	 << std::setiosflags (std::ios::scientific|std::ios::left)
-	 << scale
-	 << std::resetiosflags (std::ios::scientific|std::ios::left)
-	 << " *\n";
+         << std::setw (8) << std::setprecision (1)
+         << std::setiosflags (std::ios::scientific|std::ios::left)
+         << scale
+         << std::resetiosflags (std::ios::scientific|std::ios::left)
+         << " *\n";
 
       if (! compact_format)
-	os << "\n";
+        os << "\n";
     }
 }
 
 static void
 pr_col_num_header (std::ostream& os, octave_idx_type total_width, int max_width,
-		   octave_idx_type lim, octave_idx_type col, int extra_indent)
+                   octave_idx_type lim, octave_idx_type col, int extra_indent)
 {
   if (total_width > max_width && Vsplit_long_rows)
     {
       if (col != 0)
-	{
-	  if (compact_format)
-	    os << "\n";
-	  else
-	    os << "\n\n";
-	}
+        {
+          if (compact_format)
+            os << "\n";
+          else
+            os << "\n\n";
+        }
 
       octave_idx_type num_cols = lim - col;
 
       os << std::setw (extra_indent) << "";
 
       if (num_cols == 1)
-	os << " Column " << col + 1 << ":\n";
+        os << " Column " << col + 1 << ":\n";
       else if (num_cols == 2)
-	os << " Columns " << col + 1 << " and " << lim << ":\n";
+        os << " Columns " << col + 1 << " and " << lim << ":\n";
       else
-	os << " Columns " << col + 1 << " through " << lim << ":\n";
+        os << " Columns " << col + 1 << " through " << lim << ":\n";
 
       if (! compact_format)
-	os << "\n";
+        os << "\n";
     }
 }
 
 template <class T>
 /* static */ inline void
 pr_plus_format (std::ostream& os, const T& val)
 {
   if (val > T (0))
@@ -1540,230 +1540,230 @@ pr_plus_format (std::ostream& os, const 
   else if (val < T (0))
     os << plus_format_chars[1];
   else
     os << plus_format_chars[2];
 }
 
 void
 octave_print_internal (std::ostream& os, double d,
-		       bool /* pr_as_read_syntax */)
+                       bool /* pr_as_read_syntax */)
 {
   if (plus_format)
     {
       pr_plus_format (os, d);
     }
   else
     {
       set_format (d);
       if (free_format)
-	os << d;
+        os << d;
       else
-	pr_float (os, d);
+        pr_float (os, d);
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const Matrix& m,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-
-	      pr_plus_format (os, m(i,j));
-	    }
-
-	  if (i < nr - 1)
-	    os << "\n";
-	}
+        {
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+
+              pr_plus_format (os, m(i,j));
+            }
+
+          if (i < nr - 1)
+            os << "\n";
+        }
     }
   else
     {
       int fw;
       double scale = 1.0;
       set_format (m, fw, scale);
       int column_width = fw + 2;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
-	max_width -= 4;
+        max_width -= 4;
       else
-	max_width -= extra_indent;
+        max_width -= extra_indent;
 
       if (max_width < 0)
-	max_width = 0;
+        max_width = 0;
 
       if (free_format)
-	{
-	  if (pr_as_read_syntax)
-	    os << "[\n";
-
-	  os << m;
-
-	  if (pr_as_read_syntax)
-	    os << "]";
-
-	  return;
-	}
+        {
+          if (pr_as_read_syntax)
+            os << "[\n";
+
+          os << m;
+
+          if (pr_as_read_syntax)
+            os << "]";
+
+          return;
+        }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
-	{
-	  inc = max_width / column_width;
-	  if (inc == 0)
-	    inc++;
-	}
+        {
+          inc = max_width / column_width;
+          if (inc == 0)
+            inc++;
+        }
 
       if (pr_as_read_syntax)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_idx_type col = 0;
-	      while (col < nc)
-		{
-		  octave_idx_type lim = col + inc < nc ? col + inc : nc;
-
-		  for (octave_idx_type j = col; j < lim; j++)
-		    {
-		      octave_quit ();
-
-		      if (i == 0 && j == 0)
-			os << "[ ";
-		      else
-			{
-			  if (j > col && j < lim)
-			    os << ", ";
-			  else
-			    os << "  ";
-			}
-
-		      pr_float (os, m(i,j));
-		    }
-
-		  col += inc;
-
-		  if (col >= nc)
-		    {
-		      if (i == nr - 1)
-			os << " ]";
-		      else
-			os << ";\n";
-		    }
-		  else
-		    os << " ...\n";
-		}
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_idx_type col = 0;
+              while (col < nc)
+                {
+                  octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+                  for (octave_idx_type j = col; j < lim; j++)
+                    {
+                      octave_quit ();
+
+                      if (i == 0 && j == 0)
+                        os << "[ ";
+                      else
+                        {
+                          if (j > col && j < lim)
+                            os << ", ";
+                          else
+                            os << "  ";
+                        }
+
+                      pr_float (os, m(i,j));
+                    }
+
+                  col += inc;
+
+                  if (col >= nc)
+                    {
+                      if (i == nr - 1)
+                        os << " ]";
+                      else
+                        os << ";\n";
+                    }
+                  else
+                    os << " ...\n";
+                }
+            }
+        }
       else
-	{
-	  pr_scale_header (os, scale);
-
-	  for (octave_idx_type col = 0; col < nc; col += inc)
-	    {
-	      octave_idx_type lim = col + inc < nc ? col + inc : nc;
-
-	      pr_col_num_header (os, total_width, max_width, lim, col,
-				 extra_indent);
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  os << std::setw (extra_indent) << "";
-
-		  for (octave_idx_type j = col; j < lim; j++)
-		    {
-		      octave_quit ();
-
-		      os << "  ";
-
-		      pr_float (os, m(i,j), fw, scale);
-		    }
-
-		  if (i < nr - 1)
-		    os << "\n";
-		}
-	    }
-	}
+        {
+          pr_scale_header (os, scale);
+
+          for (octave_idx_type col = 0; col < nc; col += inc)
+            {
+              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+              pr_col_num_header (os, total_width, max_width, lim, col,
+                                 extra_indent);
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  os << std::setw (extra_indent) << "";
+
+                  for (octave_idx_type j = col; j < lim; j++)
+                    {
+                      octave_quit ();
+
+                      os << "  ";
+
+                      pr_float (os, m(i,j), fw, scale);
+                    }
+
+                  if (i < nr - 1)
+                    os << "\n";
+                }
+            }
+        }
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const DiagMatrix& m,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-
-	      pr_plus_format (os, m(i,j));
-	    }
-
-	  if (i < nr - 1)
-	    os << "\n";
-	}
+        {
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+
+              pr_plus_format (os, m(i,j));
+            }
+
+          if (i < nr - 1)
+            os << "\n";
+        }
     }
   else
     {
       int fw;
       double scale = 1.0;
       set_format (Matrix (m.diag ()), fw, scale);
       int column_width = fw + 2;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
-	max_width -= 4;
+        max_width -= 4;
       else
-	max_width -= extra_indent;
+        max_width -= extra_indent;
 
       if (max_width < 0)
-	max_width = 0;
+        max_width = 0;
 
       if (free_format)
-	{
-	  if (pr_as_read_syntax)
-	    os << "[\n";
-
-	  os << Matrix (m);
-
-	  if (pr_as_read_syntax)
-	    os << "]";
-
-	  return;
-	}
+        {
+          if (pr_as_read_syntax)
+            os << "[\n";
+
+          os << Matrix (m);
+
+          if (pr_as_read_syntax)
+            os << "]";
+
+          return;
+        }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
-	{
-	  inc = max_width / column_width;
-	  if (inc == 0)
-	    inc++;
-	}
+        {
+          inc = max_width / column_width;
+          if (inc == 0)
+            inc++;
+        }
 
       if (pr_as_read_syntax)
-	{
+        {
           os << "diag (";
 
           octave_idx_type col = 0;
           while (col < nc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               for (octave_idx_type j = col; j < lim; j++)
@@ -1786,60 +1786,60 @@ octave_print_internal (std::ostream& os,
               col += inc;
 
               if (col >= nc)
                   os << " ]";
               else
                 os << " ...\n";
             }
           os << ")";
-	}
+        }
       else
-	{
+        {
           os << "Diagonal Matrix\n\n";
-	  pr_scale_header (os, scale);
+          pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
             { 
               std::ostringstream tmp_oss;
               pr_float (tmp_oss, 0.0, fw, scale);
               zero_fw = tmp_oss.str ().length ();
             }
 
-	  for (octave_idx_type col = 0; col < nc; col += inc)
-	    {
-	      octave_idx_type lim = col + inc < nc ? col + inc : nc;
-
-	      pr_col_num_header (os, total_width, max_width, lim, col,
-				 extra_indent);
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  os << std::setw (extra_indent) << "";
-
-		  for (octave_idx_type j = col; j < lim; j++)
-		    {
-		      octave_quit ();
-
-		      os << "  ";
+          for (octave_idx_type col = 0; col < nc; col += inc)
+            {
+              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+              pr_col_num_header (os, total_width, max_width, lim, col,
+                                 extra_indent);
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  os << std::setw (extra_indent) << "";
+
+                  for (octave_idx_type j = col; j < lim; j++)
+                    {
+                      octave_quit ();
+
+                      os << "  ";
 
                       if (i == j)
                         pr_float (os, m(i,j), fw, scale);
                       else
                         os << std::setw (zero_fw) << '0';
 
-		    }
-
-		  if (i < nr - 1)
-		    os << "\n";
-		}
-	    }
-	}
+                    }
+
+                  if (i < nr - 1)
+                    os << "\n";
+                }
+            }
+        }
     }
 }
 #define PRINT_ND_ARRAY(os, nda, NDA_T, ELT_T, MAT_T) \
   do \
     { \
       if (nda.is_empty ()) \
         print_empty_nd_array (os, nda.dims (), pr_as_read_syntax); \
       else \
@@ -1856,25 +1856,25 @@ octave_print_internal (std::ostream& os,
           for (int i = 2; i < ndims; i++) \
             m *= dims(i); \
  \
           octave_idx_type nr = dims(0); \
           octave_idx_type nc = dims(1); \
  \
           for (octave_idx_type i = 0; i < m; i++) \
             { \
-	      octave_quit (); \
+              octave_quit (); \
  \
               std::string nm = "ans"; \
  \
               if (m > 1) \
                 { \
                   nm += "(:,:,"; \
  \
-		  std::ostringstream buf; \
+                  std::ostringstream buf; \
  \
                   for (int k = 2; k < ndims; k++) \
                     { \
                       buf << ra_idx(k) + 1; \
  \
                       if (k < ndims - 1) \
                         buf << ","; \
                       else \
@@ -1901,24 +1901,24 @@ octave_print_internal (std::ostream& os,
                 NDA_T::increment_index (ra_idx, dims, 2); \
             } \
         } \
     } \
   while (0)
 
 void
 octave_print_internal (std::ostream& os, const NDArray& nda,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   switch (nda.ndims ())
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
-			     pr_as_read_syntax, extra_indent);
+                             pr_as_read_syntax, extra_indent);
       break;
 
     default:
       PRINT_ND_ARRAY (os, nda, NDArray, double, Matrix);
       break;
     }
 }
 
@@ -1927,246 +1927,246 @@ template <>
 pr_plus_format<> (std::ostream& os, const Complex& c)
 {
   double rp = c.real ();
   double ip = c.imag ();
 
   if (rp == 0.0)
     {
       if (ip == 0.0)
-	os << " ";
+        os << " ";
       else
-	os << "i";
+        os << "i";
     }
   else if (ip == 0.0)
     pr_plus_format (os, rp);
   else
     os << "c";
 }
 
 void
 octave_print_internal (std::ostream& os, const Complex& c,
-		       bool /* pr_as_read_syntax */)
+                       bool /* pr_as_read_syntax */)
 {
   if (plus_format)
     {
       pr_plus_format (os, c);
     }
   else
     {
       set_format (c);
       if (free_format)
-	os << c;
+        os << c;
       else
-	pr_complex (os, c);
+        pr_complex (os, c);
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const ComplexMatrix& cm,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_idx_type nr = cm.rows ();
   octave_idx_type nc = cm.columns ();
 
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-
-	      pr_plus_format (os, cm(i,j));
-	    }
-
-	  if (i < nr - 1)
-	    os << "\n";
-	}
+        {
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+
+              pr_plus_format (os, cm(i,j));
+            }
+
+          if (i < nr - 1)
+            os << "\n";
+        }
     }
   else
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (cm, r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
       column_width += (rat_format || bank_format || hex_format 
-		       || bit_format) ? 2 : 7;
+                       || bit_format) ? 2 : 7;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
-	max_width -= 4;
+        max_width -= 4;
       else
-	max_width -= extra_indent;
+        max_width -= extra_indent;
 
       if (max_width < 0)
-	max_width = 0;
+        max_width = 0;
 
       if (free_format)
-	{
-	  if (pr_as_read_syntax)
-	    os << "[\n";
-
-	  os << cm;
-
-	  if (pr_as_read_syntax)
-	    os << "]";
-
-	  return;
-	}
+        {
+          if (pr_as_read_syntax)
+            os << "[\n";
+
+          os << cm;
+
+          if (pr_as_read_syntax)
+            os << "]";
+
+          return;
+        }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
-	{
-	  inc = max_width / column_width;
-	  if (inc == 0)
-	    inc++;
-	}
+        {
+          inc = max_width / column_width;
+          if (inc == 0)
+            inc++;
+        }
 
       if (pr_as_read_syntax)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_idx_type col = 0;
-	      while (col < nc)
-		{
-		  octave_idx_type lim = col + inc < nc ? col + inc : nc;
-
-		  for (octave_idx_type j = col; j < lim; j++)
-		    {
-		      octave_quit ();
-
-		      if (i == 0 && j == 0)
-			os << "[ ";
-		      else
-			{
-			  if (j > col && j < lim)
-			    os << ", ";
-			  else
-			    os << "  ";
-			}
-
-		      pr_complex (os, cm(i,j));
-		    }
-
-		  col += inc;
-
-		  if (col >= nc)
-		    {
-		      if (i == nr - 1)
-			os << " ]";
-		      else
-			os << ";\n";
-		    }
-		  else
-		    os << " ...\n";
-		}
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_idx_type col = 0;
+              while (col < nc)
+                {
+                  octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+                  for (octave_idx_type j = col; j < lim; j++)
+                    {
+                      octave_quit ();
+
+                      if (i == 0 && j == 0)
+                        os << "[ ";
+                      else
+                        {
+                          if (j > col && j < lim)
+                            os << ", ";
+                          else
+                            os << "  ";
+                        }
+
+                      pr_complex (os, cm(i,j));
+                    }
+
+                  col += inc;
+
+                  if (col >= nc)
+                    {
+                      if (i == nr - 1)
+                        os << " ]";
+                      else
+                        os << ";\n";
+                    }
+                  else
+                    os << " ...\n";
+                }
+            }
+        }
       else
-	{
-	  pr_scale_header (os, scale);
-
-	  for (octave_idx_type col = 0; col < nc; col += inc)
-	    {
-	      octave_idx_type lim = col + inc < nc ? col + inc : nc;
-
-	      pr_col_num_header (os, total_width, max_width, lim, col,
-				 extra_indent);
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  os << std::setw (extra_indent) << "";
-
-		  for (octave_idx_type j = col; j < lim; j++)
-		    {
-		      octave_quit ();
-
-		      os << "  ";
-
-		      pr_complex (os, cm(i,j), r_fw, i_fw, scale);
-		    }
-
-		  if (i < nr - 1) 
-		    os << "\n";
-		}
-	    }
-	}
+        {
+          pr_scale_header (os, scale);
+
+          for (octave_idx_type col = 0; col < nc; col += inc)
+            {
+              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+              pr_col_num_header (os, total_width, max_width, lim, col,
+                                 extra_indent);
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  os << std::setw (extra_indent) << "";
+
+                  for (octave_idx_type j = col; j < lim; j++)
+                    {
+                      octave_quit ();
+
+                      os << "  ";
+
+                      pr_complex (os, cm(i,j), r_fw, i_fw, scale);
+                    }
+
+                  if (i < nr - 1) 
+                    os << "\n";
+                }
+            }
+        }
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const ComplexDiagMatrix& cm,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_idx_type nr = cm.rows ();
   octave_idx_type nc = cm.columns ();
 
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-
-	      pr_plus_format (os, cm(i,j));
-	    }
-
-	  if (i < nr - 1)
-	    os << "\n";
-	}
+        {
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+
+              pr_plus_format (os, cm(i,j));
+            }
+
+          if (i < nr - 1)
+            os << "\n";
+        }
     }
   else
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (ComplexMatrix (cm.diag ()), r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
       column_width += (rat_format || bank_format || hex_format 
-		       || bit_format) ? 2 : 7;
+                       || bit_format) ? 2 : 7;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
-	max_width -= 4;
+        max_width -= 4;
       else
-	max_width -= extra_indent;
+        max_width -= extra_indent;
 
       if (max_width < 0)
-	max_width = 0;
+        max_width = 0;
 
       if (free_format)
-	{
-	  if (pr_as_read_syntax)
-	    os << "[\n";
-
-	  os << ComplexMatrix (cm);
-
-	  if (pr_as_read_syntax)
-	    os << "]";
-
-	  return;
-	}
+        {
+          if (pr_as_read_syntax)
+            os << "[\n";
+
+          os << ComplexMatrix (cm);
+
+          if (pr_as_read_syntax)
+            os << "]";
+
+          return;
+        }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
-	{
-	  inc = max_width / column_width;
-	  if (inc == 0)
-	    inc++;
-	}
+        {
+          inc = max_width / column_width;
+          if (inc == 0)
+            inc++;
+        }
 
       if (pr_as_read_syntax)
-	{
+        {
           os << "diag (";
 
           octave_idx_type col = 0;
           while (col < nc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               for (octave_idx_type j = col; j < lim; j++)
@@ -2189,121 +2189,121 @@ octave_print_internal (std::ostream& os,
               col += inc;
 
               if (col >= nc)
                   os << " ]";
               else
                 os << " ...\n";
             }
           os << ")";
-	}
+        }
       else
-	{
+        {
           os << "Diagonal Matrix\n\n";
-	  pr_scale_header (os, scale);
+          pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
             { 
               std::ostringstream tmp_oss;
               pr_complex (tmp_oss, Complex (0.0), r_fw, i_fw, scale);
               zero_fw = tmp_oss.str ().length ();
             }
 
-	  for (octave_idx_type col = 0; col < nc; col += inc)
-	    {
-	      octave_idx_type lim = col + inc < nc ? col + inc : nc;
-
-	      pr_col_num_header (os, total_width, max_width, lim, col,
-				 extra_indent);
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  os << std::setw (extra_indent) << "";
-
-		  for (octave_idx_type j = col; j < lim; j++)
-		    {
-		      octave_quit ();
-
-		      os << "  ";
+          for (octave_idx_type col = 0; col < nc; col += inc)
+            {
+              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+              pr_col_num_header (os, total_width, max_width, lim, col,
+                                 extra_indent);
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  os << std::setw (extra_indent) << "";
+
+                  for (octave_idx_type j = col; j < lim; j++)
+                    {
+                      octave_quit ();
+
+                      os << "  ";
 
                       if (i == j)
                         pr_complex (os, cm(i,j), r_fw, i_fw, scale);
                       else
                         os << std::setw (zero_fw) << '0';
-		    }
-
-		  if (i < nr - 1) 
-		    os << "\n";
-		}
-	    }
-	}
+                    }
+
+                  if (i < nr - 1) 
+                    os << "\n";
+                }
+            }
+        }
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const PermMatrix& m,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      octave_quit ();
-
-	      pr_plus_format (os, m(i,j));
-	    }
-
-	  if (i < nr - 1)
-	    os << "\n";
-	}
+        {
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              octave_quit ();
+
+              pr_plus_format (os, m(i,j));
+            }
+
+          if (i < nr - 1)
+            os << "\n";
+        }
     }
   else
     {
       int fw = 2;
       int column_width = fw + 2;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
-	max_width -= 4;
+        max_width -= 4;
       else
-	max_width -= extra_indent;
+        max_width -= extra_indent;
 
       if (max_width < 0)
-	max_width = 0;
+        max_width = 0;
 
       if (free_format)
-	{
-	  if (pr_as_read_syntax)
-	    os << "[\n";
-
-	  os << Matrix (m);
-
-	  if (pr_as_read_syntax)
-	    os << "]";
-
-	  return;
-	}
+        {
+          if (pr_as_read_syntax)
+            os << "[\n";
+
+          os << Matrix (m);
+
+          if (pr_as_read_syntax)
+            os << "]";
+
+          return;
+        }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
-	{
-	  inc = max_width / column_width;
-	  if (inc == 0)
-	    inc++;
-	}
+        {
+          inc = max_width / column_width;
+          if (inc == 0)
+            inc++;
+        }
 
       if (pr_as_read_syntax)
         {
           Array<octave_idx_type> pvec = m.pvec ();
           bool colp = m.is_col_perm ();
 
           os << "eye (";
           if (colp) os << ":, ";
@@ -2334,59 +2334,59 @@ octave_print_internal (std::ostream& os,
 
               if (col >= nc)
                   os << " ]";
               else
                 os << " ...\n";
             }
           if (! colp) os << ", :";
           os << ")";
-	}
+        }
       else
-	{
+        {
           os << "Permutation Matrix\n\n";
 
-	  for (octave_idx_type col = 0; col < nc; col += inc)
-	    {
-	      octave_idx_type lim = col + inc < nc ? col + inc : nc;
-
-	      pr_col_num_header (os, total_width, max_width, lim, col,
-				 extra_indent);
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  os << std::setw (extra_indent) << "";
-
-		  for (octave_idx_type j = col; j < lim; j++)
-		    {
-		      octave_quit ();
-
-		      os << "  ";
+          for (octave_idx_type col = 0; col < nc; col += inc)
+            {
+              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+
+              pr_col_num_header (os, total_width, max_width, lim, col,
+                                 extra_indent);
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  os << std::setw (extra_indent) << "";
+
+                  for (octave_idx_type j = col; j < lim; j++)
+                    {
+                      octave_quit ();
+
+                      os << "  ";
 
                       os << std::setw (fw) << m(i,j);
-		    }
-
-		  if (i < nr - 1)
-		    os << "\n";
-		}
-	    }
-	}
+                    }
+
+                  if (i < nr - 1)
+                    os << "\n";
+                }
+            }
+        }
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const ComplexNDArray& nda,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   switch (nda.ndims ())
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
-			     pr_as_read_syntax, extra_indent);
+                             pr_as_read_syntax, extra_indent);
       break;
 
     default:
       PRINT_ND_ARRAY (os, nda, ComplexNDArray, Complex, ComplexMatrix);
       break;
     }
 }
 
@@ -2401,279 +2401,279 @@ octave_print_internal (std::ostream& os,
 void
 octave_print_internal (std::ostream& os, float d, bool pr_as_read_syntax)
 { 
   octave_print_internal (os, double (d), pr_as_read_syntax); 
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatMatrix& m,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 { 
   octave_print_internal (os, Matrix (m), pr_as_read_syntax, extra_indent); 
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatDiagMatrix& m,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 { 
   octave_print_internal (os, DiagMatrix (m), pr_as_read_syntax, extra_indent); 
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatNDArray& nda,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_print_internal (os, NDArray (nda), pr_as_read_syntax, extra_indent); 
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplex& c,
-		       bool pr_as_read_syntax)
+                       bool pr_as_read_syntax)
 {
   octave_print_internal (os, Complex (c), pr_as_read_syntax); 
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplexMatrix& cm,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_print_internal (os, ComplexMatrix (cm), pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplexDiagMatrix& cm,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_print_internal (os, ComplexDiagMatrix (cm), pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplexNDArray& nda,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   octave_print_internal (os, ComplexNDArray (nda), pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const Range& r,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   double base = r.base ();
   double increment = r.inc ();
   double limit = r.limit ();
   octave_idx_type num_elem = r.nelem ();
 
   if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < num_elem; i++)
-	{
-	  octave_quit ();
-
-	  double val = base + i * increment;
-
-	  pr_plus_format (os, val);
-	}
+        {
+          octave_quit ();
+
+          double val = base + i * increment;
+
+          pr_plus_format (os, val);
+        }
     }
   else
     {
       int fw;
       double scale = 1.0;
       set_format (r, fw, scale);
 
       if (pr_as_read_syntax)
-	{
-	  if (free_format)
-	    {
-	      os << base << " : ";
-	      if (increment != 1.0)
-		os << increment << " : ";
-	      os << limit;
-	    }
-	  else
-	    {
-	      pr_float (os, base, fw);
-	      os << " : ";
-	      if (increment != 1.0)
-		{
-		  pr_float (os, increment, fw);
-		  os << " : ";
-		}
-	      pr_float (os, limit, fw);
-	    }
-	}
+        {
+          if (free_format)
+            {
+              os << base << " : ";
+              if (increment != 1.0)
+                os << increment << " : ";
+              os << limit;
+            }
+          else
+            {
+              pr_float (os, base, fw);
+              os << " : ";
+              if (increment != 1.0)
+                {
+                  pr_float (os, increment, fw);
+                  os << " : ";
+                }
+              pr_float (os, limit, fw);
+            }
+        }
       else
-	{
-	  int column_width = fw + 2;
-	  octave_idx_type total_width = num_elem * column_width;
-	  octave_idx_type max_width = command_editor::terminal_cols ();
-
-	  if (free_format)
-	    {
-	      os << r;
-	      return;
-	    }
-
-	  octave_idx_type inc = num_elem;
-	  if (total_width > max_width && Vsplit_long_rows)
-	    {
-	      inc = max_width / column_width;
-	      if (inc == 0)
-		inc++;
-	    }
-
-	  max_width -= extra_indent;
-
-	  if (max_width < 0)
-	    max_width = 0;
-
-	  pr_scale_header (os, scale);
-
-	  octave_idx_type col = 0;
-	  while (col < num_elem)
-	    {
-	      octave_idx_type lim = col + inc < num_elem ? col + inc : num_elem;
-
-	      pr_col_num_header (os, total_width, max_width, lim, col,
-				 extra_indent);
-
-	      os << std::setw (extra_indent) << "";
-
-	      for (octave_idx_type i = col; i < lim; i++)
-		{
-		  octave_quit ();
-
-		  double val = base + i * increment;
-
-		  if (i == num_elem - 1)
-		    {
-		      // See the comments in Range::matrix_value.
-
-		      if ((increment > 0 && val > limit)
-			  || (increment < 0 && val < limit))
-			val = limit;
-		    }
-
-		  os << "  ";
-
-		  pr_float (os, val, fw, scale);
-		}
-
-	      col += inc;
-	    }
-	}
+        {
+          int column_width = fw + 2;
+          octave_idx_type total_width = num_elem * column_width;
+          octave_idx_type max_width = command_editor::terminal_cols ();
+
+          if (free_format)
+            {
+              os << r;
+              return;
+            }
+
+          octave_idx_type inc = num_elem;
+          if (total_width > max_width && Vsplit_long_rows)
+            {
+              inc = max_width / column_width;
+              if (inc == 0)
+                inc++;
+            }
+
+          max_width -= extra_indent;
+
+          if (max_width < 0)
+            max_width = 0;
+
+          pr_scale_header (os, scale);
+
+          octave_idx_type col = 0;
+          while (col < num_elem)
+            {
+              octave_idx_type lim = col + inc < num_elem ? col + inc : num_elem;
+
+              pr_col_num_header (os, total_width, max_width, lim, col,
+                                 extra_indent);
+
+              os << std::setw (extra_indent) << "";
+
+              for (octave_idx_type i = col; i < lim; i++)
+                {
+                  octave_quit ();
+
+                  double val = base + i * increment;
+
+                  if (i == num_elem - 1)
+                    {
+                      // See the comments in Range::matrix_value.
+
+                      if ((increment > 0 && val > limit)
+                          || (increment < 0 && val < limit))
+                        val = limit;
+                    }
+
+                  os << "  ";
+
+                  pr_float (os, val, fw, scale);
+                }
+
+              col += inc;
+            }
+        }
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const boolMatrix& bm,
-		       bool pr_as_read_syntax,
-		       int extra_indent)
+                       bool pr_as_read_syntax,
+                       int extra_indent)
 {
   Matrix tmp (bm);
   octave_print_internal (os, tmp, pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const boolNDArray& nda,
-		       bool pr_as_read_syntax,
-		       int extra_indent)
+                       bool pr_as_read_syntax,
+                       int extra_indent)
 {
   switch (nda.ndims ())
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
-			     pr_as_read_syntax, extra_indent);
+                             pr_as_read_syntax, extra_indent);
       break;
 
     default:
       PRINT_ND_ARRAY (os, nda, boolNDArray, bool, boolMatrix);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const charMatrix& chm,
-		       bool pr_as_read_syntax,
-		       int /* extra_indent FIXME */,
-		       bool pr_as_string)
+                       bool pr_as_read_syntax,
+                       int /* extra_indent FIXME */,
+                       bool pr_as_string)
 {
   if (pr_as_string)
     {
       octave_idx_type nstr = chm.rows ();
 
       if (pr_as_read_syntax && nstr > 1)
-	os << "[ ";
+        os << "[ ";
 
       if (nstr != 0)
-	{
-	  for (octave_idx_type i = 0; i < nstr; i++)
-	    {
-	      octave_quit ();
-
-	      std::string row = chm.row_as_string (i);
-
-	      if (pr_as_read_syntax)
-		{
-		  os << "\"" << undo_string_escapes (row) << "\"";
-
-		  if (i < nstr - 1)
-		    os << "; ";
-		}
-	      else
-		{
-		  os << row;
-
-		  if (i < nstr - 1)
-		    os << "\n";
-		}
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nstr; i++)
+            {
+              octave_quit ();
+
+              std::string row = chm.row_as_string (i);
+
+              if (pr_as_read_syntax)
+                {
+                  os << "\"" << undo_string_escapes (row) << "\"";
+
+                  if (i < nstr - 1)
+                    os << "; ";
+                }
+              else
+                {
+                  os << row;
+
+                  if (i < nstr - 1)
+                    os << "\n";
+                }
+            }
+        }
 
       if (pr_as_read_syntax && nstr > 1)
-	os << " ]";
+        os << " ]";
     }
   else
     {
       os << "sorry, printing char matrices not implemented yet\n";
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const charNDArray& nda,
-		       bool pr_as_read_syntax, int extra_indent,
-		       bool pr_as_string)
+                       bool pr_as_read_syntax, int extra_indent,
+                       bool pr_as_string)
 {
   switch (nda.ndims ())
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
-			     pr_as_read_syntax, extra_indent, pr_as_string);
+                             pr_as_read_syntax, extra_indent, pr_as_string);
       break;
 
     default:
       PRINT_ND_ARRAY (os, nda, charNDArray, char, charMatrix);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const std::string& s,
-		       bool pr_as_read_syntax, int extra_indent)
+                       bool pr_as_read_syntax, int extra_indent)
 {
   Array<std::string> nda (dim_vector (1, 1), s);
 
   octave_print_internal (os, nda, pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const Array<std::string>& nda,
-		       bool pr_as_read_syntax, int /* extra_indent */)
+                       bool pr_as_read_syntax, int /* extra_indent */)
 {
   // FIXME -- this mostly duplicates the code in the
   // PRINT_ND_ARRAY macro.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     {
@@ -2685,76 +2685,76 @@ octave_print_internal (std::ostream& os,
 
       dim_vector dims = nda.dims ();
 
       Array<octave_idx_type> ra_idx (ndims, 0);
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
-	m *= dims(i);
+        m *= dims(i);
 
       octave_idx_type nr = dims(0);
       octave_idx_type nc = dims(1);
 
       for (octave_idx_type i = 0; i < m; i++)
-	{
-	  std::string nm = "ans";
-
-	  if (m > 1)
-	    {
-	      nm += "(:,:,";
-
-	      std::ostringstream buf;
-
-	      for (int k = 2; k < ndims; k++)
-		{
-		  buf << ra_idx(k) + 1;
-
-		  if (k < ndims - 1)
-		    buf << ",";
-		  else
-		    buf << ")";
-		}
-
-	      nm += buf.str ();
-	    }
-
-	  Array<idx_vector> idx (ndims);
-
-	  idx(0) = idx_vector (':');
-	  idx(1) = idx_vector (':');
-
-	  for (int k = 2; k < ndims; k++)
-	    idx(k) = idx_vector (ra_idx(k));
-
-	  Array2<std::string> page (nda.index (idx), nr, nc);
-
-	  // FIXME -- need to do some more work to put these
-	  // in neatly aligned columns...
-
-	  octave_idx_type n_rows = page.rows ();
-	  octave_idx_type n_cols = page.cols ();
-
-	  os << nm << " =\n\n";
-
-	  for (octave_idx_type ii = 0; ii < n_rows; ii++)
-	    {
-	      for (octave_idx_type jj = 0; jj < n_cols; jj++)
-		os << "  " << page(ii,jj);
-
-	      os << "\n";
-	    }
-
-	  if (i < m - 1)
-	    os << "\n";
-
-	  if (i < m)
-	    increment_index (ra_idx, dims, 2);
-	}
+        {
+          std::string nm = "ans";
+
+          if (m > 1)
+            {
+              nm += "(:,:,";
+
+              std::ostringstream buf;
+
+              for (int k = 2; k < ndims; k++)
+                {
+                  buf << ra_idx(k) + 1;
+
+                  if (k < ndims - 1)
+                    buf << ",";
+                  else
+                    buf << ")";
+                }
+
+              nm += buf.str ();
+            }
+
+          Array<idx_vector> idx (ndims);
+
+          idx(0) = idx_vector (':');
+          idx(1) = idx_vector (':');
+
+          for (int k = 2; k < ndims; k++)
+            idx(k) = idx_vector (ra_idx(k));
+
+          Array2<std::string> page (nda.index (idx), nr, nc);
+
+          // FIXME -- need to do some more work to put these
+          // in neatly aligned columns...
+
+          octave_idx_type n_rows = page.rows ();
+          octave_idx_type n_cols = page.cols ();
+
+          os << nm << " =\n\n";
+
+          for (octave_idx_type ii = 0; ii < n_rows; ii++)
+            {
+              for (octave_idx_type jj = 0; jj < n_cols; jj++)
+                os << "  " << page(ii,jj);
+
+              os << "\n";
+            }
+
+          if (i < m - 1)
+            os << "\n";
+
+          if (i < m)
+            increment_index (ra_idx, dims, 2);
+        }
     }
 }
 
 template <class T>
 class
 octave_print_conv
 {
 public:
@@ -2788,60 +2788,60 @@ pr_int (std::ostream& os, const T& d, in
   //   {bit,hex}_format == 1: print big-endian
   //   {bit,hex}_format == 2: print native
 
   if (hex_format)
     {
       char ofill = os.fill ('0');
 
       std::ios::fmtflags oflags
-	= os.flags (std::ios::right | std::ios::hex);
+        = os.flags (std::ios::right | std::ios::hex);
 
       if (hex_format > 1 || oct_mach_info::words_big_endian ())
-	{
-	  for (size_t i = 0; i < sz; i++)
-	    os << std::setw (2) << static_cast<int> (tmpi[i]);
-	}
+        {
+          for (size_t i = 0; i < sz; i++)
+            os << std::setw (2) << static_cast<int> (tmpi[i]);
+        }
       else
-	{
-	  for (int i = sz - 1; i >= 0; i--)
-	    os << std::setw (2) << static_cast<int> (tmpi[i]);
-	}
+        {
+          for (int i = sz - 1; i >= 0; i--)
+            os << std::setw (2) << static_cast<int> (tmpi[i]);
+        }
 
       os.fill (ofill);
-      os.setf (oflags);	  
+      os.setf (oflags);   
     }
   else if (bit_format)
     {
       if (oct_mach_info::words_big_endian ())
-	{
-	  for (size_t i = 0; i < sz; i++)
-	    PRINT_CHAR_BITS (os, tmpi[i]);
-	}
+        {
+          for (size_t i = 0; i < sz; i++)
+            PRINT_CHAR_BITS (os, tmpi[i]);
+        }
       else
-	{
-	  if (bit_format > 1)
-	    {
-	      for (size_t i = 0; i < sz; i++)
-		PRINT_CHAR_BITS_SWAPPED (os, tmpi[i]);
-	    }
-	  else
-	    {
-	      for (int i = sz - 1; i >= 0; i--)
-		PRINT_CHAR_BITS (os, tmpi[i]);
-	    }
-	}
+        {
+          if (bit_format > 1)
+            {
+              for (size_t i = 0; i < sz; i++)
+                PRINT_CHAR_BITS_SWAPPED (os, tmpi[i]);
+            }
+          else
+            {
+              for (int i = sz - 1; i >= 0; i--)
+                PRINT_CHAR_BITS (os, tmpi[i]);
+            }
+        }
     }
   else
     {
       os << std::setw (fw)
-	 << typename octave_print_conv<T>::print_conv_type (d);
+         << typename octave_print_conv<T>::print_conv_type (d);
 
       if (bank_format)
-	os << ".00";
+        os << ".00";
     }
 }
 
 // FIXME -- all this mess with abs is an attempt to avoid seeing
 //
 //   warning: comparison of unsigned expression < 0 is always false
 //
 // from GCC.  Isn't there a better way
@@ -2898,28 +2898,28 @@ template void
 pr_int (std::ostream&, const octave_uint32&, int);
 
 template void
 pr_int (std::ostream&, const octave_uint64&, int);
 
 template <class T>
 void
 octave_print_internal_template (std::ostream& os, const octave_int<T>& val,
-				bool)
+                                bool)
 {
   if (plus_format)
     {
       pr_plus_format (os, val);
     }
   else
     {
       if (free_format)
-	os << typename octave_print_conv<octave_int<T> >::print_conv_type (val);
+        os << typename octave_print_conv<octave_int<T> >::print_conv_type (val);
       else
-	pr_int (os, val);
+        pr_int (os, val);
     }
 }
 
 #define PRINT_INT_SCALAR_INTERNAL(TYPE) \
   OCTINTERP_API void \
   octave_print_internal (std::ostream& os, const octave_int<TYPE>& val, bool dummy) \
   { \
     octave_print_internal_template (os, val, dummy); \
@@ -2932,17 +2932,17 @@ PRINT_INT_SCALAR_INTERNAL (uint16_t)
 PRINT_INT_SCALAR_INTERNAL (int32_t)
 PRINT_INT_SCALAR_INTERNAL (uint32_t)
 PRINT_INT_SCALAR_INTERNAL (int64_t)
 PRINT_INT_SCALAR_INTERNAL (uint64_t)
 
 template <class T>
 /* static */ inline void
 octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
-				bool pr_as_read_syntax, int extra_indent)
+                                bool pr_as_read_syntax, int extra_indent)
 {
   // FIXME -- this mostly duplicates the code in the
   // PRINT_ND_ARRAY macro.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
@@ -2952,219 +2952,219 @@ octave_print_internal_template (std::ost
 
       Array<octave_idx_type> ra_idx (ndims, 0);
 
       dim_vector dims = nda.dims ();
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
-	m *= dims(i);
+        m *= dims(i);
 
       octave_idx_type nr = dims(0);
       octave_idx_type nc = dims(1);
 
       for (octave_idx_type i = 0; i < m; i++)
-	{
-	  if (m > 1)
-	    {
-	      std::string nm = "ans(:,:,";
-
-	      std::ostringstream buf;
-
-	      for (int k = 2; k < ndims; k++)
-		{
-		  buf << ra_idx(k) + 1;
-
-		  if (k < ndims - 1)
-		    buf << ",";
-		  else
-		    buf << ")";
-		}
-
-	      nm += buf.str ();
-
-	      os << nm << " =\n\n";
-	    }
-
-	  Array<idx_vector> idx (ndims);
-
-	  idx(0) = idx_vector (':');
-	  idx(1) = idx_vector (':');
-
-	  for (int k = 2; k < ndims; k++)
-	    idx(k) = idx_vector (ra_idx(k));
-
-	  Array2<T> page (nda.index (idx), nr, nc);
-
-	  for (octave_idx_type ii = 0; ii < nr; ii++)
-	    {
-	      for (octave_idx_type jj = 0; jj < nc; jj++)
-		{
-		  octave_quit ();
-
-		  pr_plus_format (os, page(ii,jj));
-		}
-
-	      if ((ii < nr - 1) || (i < m -1))
-		os << "\n";
-	    }
-
-	  if (i < m - 1)
-	    {
-	      os << "\n";
-	      increment_index (ra_idx, dims, 2);
-	    }
-	}
+        {
+          if (m > 1)
+            {
+              std::string nm = "ans(:,:,";
+
+              std::ostringstream buf;
+
+              for (int k = 2; k < ndims; k++)
+                {
+                  buf << ra_idx(k) + 1;
+
+                  if (k < ndims - 1)
+                    buf << ",";
+                  else
+                    buf << ")";
+                }
+
+              nm += buf.str ();
+
+              os << nm << " =\n\n";
+            }
+
+          Array<idx_vector> idx (ndims);
+
+          idx(0) = idx_vector (':');
+          idx(1) = idx_vector (':');
+
+          for (int k = 2; k < ndims; k++)
+            idx(k) = idx_vector (ra_idx(k));
+
+          Array2<T> page (nda.index (idx), nr, nc);
+
+          for (octave_idx_type ii = 0; ii < nr; ii++)
+            {
+              for (octave_idx_type jj = 0; jj < nc; jj++)
+                {
+                  octave_quit ();
+
+                  pr_plus_format (os, page(ii,jj));
+                }
+
+              if ((ii < nr - 1) || (i < m -1))
+                os << "\n";
+            }
+
+          if (i < m - 1)
+            {
+              os << "\n";
+              increment_index (ra_idx, dims, 2);
+            }
+        }
     }
   else
     {
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
       Array<octave_idx_type> ra_idx (ndims, 0);
 
       octave_idx_type m = 1;
 
       for (int i = 2; i < ndims; i++)
-	m *= dims(i);
+        m *= dims(i);
 
       octave_idx_type nr = dims(0);
       octave_idx_type nc = dims(1);
 
       int fw = 0;
       if (hex_format)
-	fw = 2 * nda(0).byte_size ();
+        fw = 2 * nda(0).byte_size ();
       else if (bit_format)
-	fw = nda(0).nbits ();
+        fw = nda(0).nbits ();
       else
-	{
-	  bool isneg = false;
-	  int digits = 0;
-
-	  for (octave_idx_type i = 0; i < dims.numel (); i++)
-	    {
-	      int new_digits = static_cast<int> 
-		(floor (log10 (double (abs (nda(i).value ()))) + 1.0));
-
-	      if (new_digits > digits)
-		digits = new_digits;
-
-	      if (! isneg)
-	      isneg = (abs (nda(i).value ()) != nda(i).value ());
-	    }
-
-	  fw = digits + isneg;
-	}
+        {
+          bool isneg = false;
+          int digits = 0;
+
+          for (octave_idx_type i = 0; i < dims.numel (); i++)
+            {
+              int new_digits = static_cast<int> 
+                (floor (log10 (double (abs (nda(i).value ()))) + 1.0));
+
+              if (new_digits > digits)
+                digits = new_digits;
+
+              if (! isneg)
+              isneg = (abs (nda(i).value ()) != nda(i).value ());
+            }
+
+          fw = digits + isneg;
+        }
 
       int column_width = fw + (rat_format ?  0 : (bank_format ? 5 : 2));
       octave_idx_type total_width = nc * column_width;
       int max_width = command_editor::terminal_cols () - extra_indent;
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
-	{
-	  inc = max_width / column_width;
-	  if (inc == 0)
-	    inc++;
-	}
+        {
+          inc = max_width / column_width;
+          if (inc == 0)
+            inc++;
+        }
 
       for (octave_idx_type i = 0; i < m; i++)
-	{
-	  if (m > 1)
-	    {
-	      std::string nm = "ans(:,:,";
-
-	      std::ostringstream buf;
-
-	      for (int k = 2; k < ndims; k++)
-		{
-		  buf << ra_idx(k) + 1;
-
-		  if (k < ndims - 1)
-		    buf << ",";
-		  else
-		    buf << ")";
-		}
-
-	      nm += buf.str ();
-
-	      os << nm << " =\n\n";
-	    }
-
-	  Array<idx_vector> idx (ndims);
-
-	  idx(0) = idx_vector (':');
-	  idx(1) = idx_vector (':');
-
-	  for (int k = 2; k < ndims; k++)
-	    idx(k) = idx_vector (ra_idx(k));
-
-	  Array2<T> page (nda.index (idx), nr, nc);
-
-	  if (free_format)
-	    {
-	      if (pr_as_read_syntax)
-		os << "[\n";
-
-	      for (octave_idx_type ii = 0; ii < nr; ii++)
-		{
-		  for (octave_idx_type jj = 0; jj < nc; jj++)
-		    {
-		      octave_quit ();
-		      os << "  ";
-		      os << typename octave_print_conv<T>::print_conv_type (page(ii,jj));
-		    }
-		  os << "\n";
-		}
-
-	      if (pr_as_read_syntax)
-		os << "]";
-	    }
-	  else
-	    {
-	      octave_idx_type n_rows = page.rows ();
-	      octave_idx_type n_cols = page.cols ();
-
-	      for (octave_idx_type col = 0; col < n_cols; col += inc)
-		{
-		  octave_idx_type lim = col + inc < n_cols ? col + inc : n_cols;
-
-		  pr_col_num_header (os, total_width, max_width, lim, col,
-				     extra_indent);
-
-		  for (octave_idx_type ii = 0; ii < n_rows; ii++)
-		    {
-		      os << std::setw (extra_indent) << "";
-		      
-		      for (octave_idx_type jj = col; jj < lim; jj++)
-			{
-			  octave_quit ();
-			  os << "  ";
-			  pr_int (os, page(ii,jj), fw);
-			}
-		      if ((ii < n_rows - 1) || (i < m -1))
-			os << "\n";
-		    }
-		}
-	    }
-
-	  if (i < m - 1)
-	    {
-	      os << "\n";
-	      increment_index (ra_idx, dims, 2);
-	    }
-	}
+        {
+          if (m > 1)
+            {
+              std::string nm = "ans(:,:,";
+
+              std::ostringstream buf;
+
+              for (int k = 2; k < ndims; k++)
+                {
+                  buf << ra_idx(k) + 1;
+
+                  if (k < ndims - 1)
+                    buf << ",";
+                  else
+                    buf << ")";
+                }
+
+              nm += buf.str ();
+
+              os << nm << " =\n\n";
+            }
+
+          Array<idx_vector> idx (ndims);
+
+          idx(0) = idx_vector (':');
+          idx(1) = idx_vector (':');
+
+          for (int k = 2; k < ndims; k++)
+            idx(k) = idx_vector (ra_idx(k));
+
+          Array2<T> page (nda.index (idx), nr, nc);
+
+          if (free_format)
+            {
+              if (pr_as_read_syntax)
+                os << "[\n";
+
+              for (octave_idx_type ii = 0; ii < nr; ii++)
+                {
+                  for (octave_idx_type jj = 0; jj < nc; jj++)
+                    {
+                      octave_quit ();
+                      os << "  ";
+                      os << typename octave_print_conv<T>::print_conv_type (page(ii,jj));
+                    }
+                  os << "\n";
+                }
+
+              if (pr_as_read_syntax)
+                os << "]";
+            }
+          else
+            {
+              octave_idx_type n_rows = page.rows ();
+              octave_idx_type n_cols = page.cols ();
+
+              for (octave_idx_type col = 0; col < n_cols; col += inc)
+                {
+                  octave_idx_type lim = col + inc < n_cols ? col + inc : n_cols;
+
+                  pr_col_num_header (os, total_width, max_width, lim, col,
+                                     extra_indent);
+
+                  for (octave_idx_type ii = 0; ii < n_rows; ii++)
+                    {
+                      os << std::setw (extra_indent) << "";
+                      
+                      for (octave_idx_type jj = col; jj < lim; jj++)
+                        {
+                          octave_quit ();
+                          os << "  ";
+                          pr_int (os, page(ii,jj), fw);
+                        }
+                      if ((ii < n_rows - 1) || (i < m -1))
+                        os << "\n";
+                    }
+                }
+            }
+
+          if (i < m - 1)
+            {
+              os << "\n";
+              increment_index (ra_idx, dims, 2);
+            }
+        }
     }
 }
 
 #define PRINT_INT_ARRAY_INTERNAL(TYPE) \
   OCTINTERP_API void \
   octave_print_internal (std::ostream& os, const intNDArray<TYPE>& nda, \
-			 bool pr_as_read_syntax, int extra_indent) \
+                         bool pr_as_read_syntax, int extra_indent) \
   { \
     octave_print_internal_template (os, nda, pr_as_read_syntax, extra_indent); \
   }
 
 PRINT_INT_ARRAY_INTERNAL (octave_int8)
 PRINT_INT_ARRAY_INTERNAL (octave_uint8)
 PRINT_INT_ARRAY_INTERNAL (octave_int16)
 PRINT_INT_ARRAY_INTERNAL (octave_uint16)
@@ -3207,58 +3207,58 @@ representing the elements of @var{x}.  B
     {
       unwind_protect frame;
 
       frame.protect_var (rat_string_len);
 
       rat_string_len = 9;
 
       if (nargin == 2)
-	rat_string_len = args(1).nint_value ();
+        rat_string_len = args(1).nint_value ();
 
       if (! error_state)
-	{
-	  octave_value arg = args(0);
-
-	  if (arg.is_numeric_type ())
-	    {
-	      frame.protect_var (rat_format);
-
-	      rat_format = true;
-
-	      std::ostringstream buf;
-	      args(0).print (buf);
-	      std::string s = buf.str ();
-
-	      std::list<std::string> lst;
-
-	      size_t n = 0;
-	      size_t s_len = s.length ();
-
-	      while (n < s_len)
-		{
-		  size_t m = s.find ('\n',  n);
-
-		  if (m == std::string::npos)
-		    {
-		      lst.push_back (s.substr (n));
-		      break;
-		    }
-		  else
-		    {
-		      lst.push_back (s.substr (n, m - n));
-		      n = m + 1;
-		    }
-		}
-
-	      retval = string_vector (lst);
-	    }
-	  else
-	    error ("rats: expecting numeric input");
-	}
+        {
+          octave_value arg = args(0);
+
+          if (arg.is_numeric_type ())
+            {
+              frame.protect_var (rat_format);
+
+              rat_format = true;
+
+              std::ostringstream buf;
+              args(0).print (buf);
+              std::string s = buf.str ();
+
+              std::list<std::string> lst;
+
+              size_t n = 0;
+              size_t s_len = s.length ();
+
+              while (n < s_len)
+                {
+                  size_t m = s.find ('\n',  n);
+
+                  if (m == std::string::npos)
+                    {
+                      lst.push_back (s.substr (n));
+                      break;
+                    }
+                  else
+                    {
+                      lst.push_back (s.substr (n, m - n));
+                      n = m + 1;
+                    }
+                }
+
+              retval = string_vector (lst);
+            }
+          else
+            error ("rats: expecting numeric input");
+        }
     }
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
@@ -3283,24 +3283,24 @@ returns the formatted output in a string
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && nargout < 2)
     {
       if (nargout == 0)
-	args(0).print (octave_stdout);
+        args(0).print (octave_stdout);
       else
-	{
-	  octave_value arg = args(0);
-	  std::ostringstream buf;
-	  arg.print (buf);
-	  retval = octave_value (buf.str (), arg.is_dq_string () ? '"' : '\'');
-	}
+        {
+          octave_value arg = args(0);
+          std::ostringstream buf;
+          arg.print (buf);
+          retval = octave_value (buf.str (), arg.is_dq_string () ? '"' : '\'');
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fdisp, args, ,
@@ -3328,24 +3328,24 @@ Note that the output from @code{fdisp} a
 
   if (nargin == 2)
     {
       int fid = octave_stream_list::get_file_number (args (0));
 
       octave_stream os = octave_stream_list::lookup (fid, "fdisp");
 
       if (! error_state)
-	{
-	  std::ostream *osp = os.output_stream ();
-
-	  if (osp)
-	    args(1).print (*osp);
-	  else
-	    error ("fdisp: stream not open for writing");
-	}
+        {
+          std::ostream *osp = os.output_stream ();
+
+          if (osp)
+            args(1).print (*osp);
+          else
+            error ("fdisp: stream not open for writing");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /* 
@@ -3387,165 +3387,165 @@ set_format_style (int argc, const string
 {
   int idx = 1;
 
   if (--argc > 0)
     {
       std::string arg = argv[idx++];
 
       if (arg == "short")
-	{
-	  if (--argc > 0)
-	    {
-	      arg = argv[idx++];
-
-	      if (arg == "e")
-		{
-		  init_format_state ();
-		  print_e = true;
-		}
-	      else if (arg == "E")
-		{
-		  init_format_state ();
-		  print_e = true;
-		  print_big_e = true;
-		}
-	      else if (arg == "g")
-		{
-		  init_format_state ();
-		  print_g = true;
-		}
-	      else if (arg == "G")
-		{
-		  init_format_state ();
-		  print_g = true;
-		  print_big_e = true;
-		}
-	      else
-		{
-		  error ("format: unrecognized option `short %s'",
-			 arg.c_str ());
-		  return;
-		}
-	    }
-	  else
-	    init_format_state ();
-
-	  set_output_prec_and_fw (5, 10);
-	}
+        {
+          if (--argc > 0)
+            {
+              arg = argv[idx++];
+
+              if (arg == "e")
+                {
+                  init_format_state ();
+                  print_e = true;
+                }
+              else if (arg == "E")
+                {
+                  init_format_state ();
+                  print_e = true;
+                  print_big_e = true;
+                }
+              else if (arg == "g")
+                {
+                  init_format_state ();
+                  print_g = true;
+                }
+              else if (arg == "G")
+                {
+                  init_format_state ();
+                  print_g = true;
+                  print_big_e = true;
+                }
+              else
+                {
+                  error ("format: unrecognized option `short %s'",
+                         arg.c_str ());
+                  return;
+                }
+            }
+          else
+            init_format_state ();
+
+          set_output_prec_and_fw (5, 10);
+        }
       else if (arg == "long")
-	{
-	  if (--argc > 0)
-	    {
-	      arg = argv[idx++];
-
-	      if (arg == "e")
-		{
-		  init_format_state ();
-		  print_e = true;
-		}
-	      else if (arg == "E")
-		{
-		  init_format_state ();
-		  print_e = true;
-		  print_big_e = true;
-		}
-	      else if (arg == "g")
-		{
-		  init_format_state ();
-		  print_g = true;
-		}
-	      else if (arg == "G")
-		{
-		  init_format_state ();
-		  print_g = true;
-		  print_big_e = true;
-		}
-	      else
-		{
-		  error ("format: unrecognized option `long %s'",
-			 arg.c_str ());
-		  return;
-		}
-	    }
-	  else
-	    init_format_state ();
-
-	  set_output_prec_and_fw (15, 20);
-	}
+        {
+          if (--argc > 0)
+            {
+              arg = argv[idx++];
+
+              if (arg == "e")
+                {
+                  init_format_state ();
+                  print_e = true;
+                }
+              else if (arg == "E")
+                {
+                  init_format_state ();
+                  print_e = true;
+                  print_big_e = true;
+                }
+              else if (arg == "g")
+                {
+                  init_format_state ();
+                  print_g = true;
+                }
+              else if (arg == "G")
+                {
+                  init_format_state ();
+                  print_g = true;
+                  print_big_e = true;
+                }
+              else
+                {
+                  error ("format: unrecognized option `long %s'",
+                         arg.c_str ());
+                  return;
+                }
+            }
+          else
+            init_format_state ();
+
+          set_output_prec_and_fw (15, 20);
+        }
       else if (arg == "hex")
-	{
-	  init_format_state ();
-	  hex_format = 1;
-	}
+        {
+          init_format_state ();
+          hex_format = 1;
+        }
       else if (arg == "native-hex")
-	{
-	  init_format_state ();
-	  hex_format = 2;
-	}
+        {
+          init_format_state ();
+          hex_format = 2;
+        }
       else if (arg == "bit")
-	{
-	  init_format_state ();
-	  bit_format = 1;
-	}
+        {
+          init_format_state ();
+          bit_format = 1;
+        }
       else if (arg == "native-bit")
-	{
-	  init_format_state ();
-	  bit_format = 2;
-	}
+        {
+          init_format_state ();
+          bit_format = 2;
+        }
       else if (arg == "+" || arg == "plus")
-	{
-	  if (--argc > 0)
-	    {
-	      arg = argv[idx++];
-
-	      if (arg.length () == 3)
-		plus_format_chars = arg;
-	      else
-		{
-		  error ("format: invalid option for plus format");
-		  return;
-		}
-	    }
-	  else
-	    plus_format_chars = "+  ";
-
-	  init_format_state ();
-	  plus_format = true;
-	}
+        {
+          if (--argc > 0)
+            {
+              arg = argv[idx++];
+
+              if (arg.length () == 3)
+                plus_format_chars = arg;
+              else
+                {
+                  error ("format: invalid option for plus format");
+                  return;
+                }
+            }
+          else
+            plus_format_chars = "+  ";
+
+          init_format_state ();
+          plus_format = true;
+        }
       else if (arg == "rat")
-	{
-	  init_format_state ();
-	  rat_format = true;
-	}
+        {
+          init_format_state ();
+          rat_format = true;
+        }
       else if (arg == "bank")
-	{
-	  init_format_state ();
-	  bank_format = true;
-	}
+        {
+          init_format_state ();
+          bank_format = true;
+        }
       else if (arg == "free")
-	{
-	  init_format_state ();
-	  free_format = true;
-	}
+        {
+          init_format_state ();
+          free_format = true;
+        }
       else if (arg == "none")
-	{
-	  init_format_state ();
-	  free_format = true;
-	}
+        {
+          init_format_state ();
+          free_format = true;
+        }
       else if (arg == "compact")
-	{
-	  compact_format = true;
-	}
+        {
+          compact_format = true;
+        }
       else if (arg == "loose")
-	{
-	  compact_format = false;
-	}
+        {
+          compact_format = false;
+        }
       else
-	error ("format: unrecognized format state `%s'", arg.c_str ());
+        error ("format: unrecognized format state `%s'", arg.c_str ());
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
@@ -3837,10 +3837,10 @@ DEFUN (struct_levels_to_print, args, nar
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print,
-					    -1, INT_MAX);
+                                            -1, INT_MAX);
 }
diff --git a/src/procstream.cc b/src/procstream.cc
--- a/src/procstream.cc
+++ b/src/procstream.cc
@@ -57,15 +57,15 @@ procstreambase::open (const char *comman
 int
 procstreambase::close (void)
 {
   int status = 0;
 
   if (is_open ())
     {
       if (! pb.close ())
-	std::ios::setstate (std::ios::failbit);
+        std::ios::setstate (std::ios::failbit);
 
       status = pb.wait_status ();
     }
 
   return status;
 }
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -60,17 +60,17 @@ tree_argument_list::~tree_argument_list 
 bool
 tree_argument_list::has_magic_end (void) const
 {
   for (const_iterator p = begin (); p != end (); p++)
     {
       tree_expression *elt = *p;
 
       if (elt && elt->has_magic_end ())
-	return true;
+        return true;
     }
 
   return false;
 }
 
 void
 tree_argument_list::append (const element_type& s)
 {
@@ -89,17 +89,17 @@ tree_argument_list::append (const elemen
 bool
 tree_argument_list::all_elements_are_constant (void) const
 {
   for (const_iterator p = begin (); p != end (); p++)
     {
       tree_expression *elt = *p;
 
       if (! elt->is_constant ())
-	return false;
+        return false;
     }
 
   return true;
 }
 
 static const octave_value *indexed_object = 0;
 static int index_position = 0;
 static int num_indices = 0;
@@ -107,73 +107,73 @@ static int num_indices = 0;
 DEFCONSTFUN (__end__, , ,
   "internal function")
 {
   octave_value retval;
 
   if (indexed_object)
     {
       if (indexed_object->is_object ())
-	{
-	  octave_value_list args;
+        {
+          octave_value_list args;
 
-	  args(2) = num_indices;
-	  args(1) = index_position + 1;
-	  args(0) = *indexed_object;
+          args(2) = num_indices;
+          args(1) = index_position + 1;
+          args(0) = *indexed_object;
 
-	  std::string class_name = indexed_object->class_name ();
+          std::string class_name = indexed_object->class_name ();
 
-	  octave_value meth = symbol_table::find_method ("end", class_name);
+          octave_value meth = symbol_table::find_method ("end", class_name);
 
-	  if (meth.is_defined ())
-	    return feval (meth.function_value (), args, 1);
-	}
+          if (meth.is_defined ())
+            return feval (meth.function_value (), args, 1);
+        }
 
       dim_vector dv = indexed_object->dims ();
       int ndims = dv.length ();
 
       if (num_indices < ndims)
-	{
-	  for (int i = num_indices; i < ndims; i++)
-	    dv(num_indices-1) *= dv(i);
+        {
+          for (int i = num_indices; i < ndims; i++)
+            dv(num_indices-1) *= dv(i);
 
-	  if (num_indices == 1)
-	    {
-	      ndims = 2;
-	      dv.resize (ndims);
-	      dv(1) = 1;
-	    }
-	  else
-	    {
-	      ndims = num_indices;
-	      dv.resize (ndims);
-	    }
-	}
+          if (num_indices == 1)
+            {
+              ndims = 2;
+              dv.resize (ndims);
+              dv(1) = 1;
+            }
+          else
+            {
+              ndims = num_indices;
+              dv.resize (ndims);
+            }
+        }
 
       if (index_position < ndims)
-	retval = dv(index_position);
+        retval = dv(index_position);
       else
-	retval = 1;
+        retval = 1;
     }
   else
     ::error ("invalid use of end");
 
   return retval;
 }
 
 octave_value_list
 tree_argument_list::convert_to_const_vector (const octave_value *object)
 {
   // END doesn't make sense for functions.  Maybe we need a different
   // way of asking an octave_value object this question?
 
   bool stash_object = (list_includes_magic_end
-		       && object
-		       && ! (object->is_function ()
-			     || object->is_function_handle ()));
+                       && object
+                       && ! (object->is_function ()
+                             || object->is_function_handle ()));
   
   unwind_protect frame;
 
   if (stash_object)
     {
       frame.protect_var (indexed_object);
 
       indexed_object = object;
@@ -182,49 +182,49 @@ tree_argument_list::convert_to_const_vec
   int len = length ();
 
   std::list<octave_value_list> args;
 
   iterator p = begin ();
   for (int k = 0; k < len; k++)
     {
       if (stash_object)
-	{
-	  frame.protect_var (index_position);
-	  frame.protect_var (num_indices);
+        {
+          frame.protect_var (index_position);
+          frame.protect_var (num_indices);
 
-	  index_position = k;
-	  num_indices = len;
-	}
+          index_position = k;
+          num_indices = len;
+        }
 
       tree_expression *elt = *p++;
 
       if (elt)
-	{
-	  octave_value tmp = elt->rvalue1 ();
+        {
+          octave_value tmp = elt->rvalue1 ();
 
-	  if (error_state)
-	    {
-	      ::error ("evaluating argument list element number %d", k+1);
-	      args.clear ();
-	      break;
-	    }
-	  else
-	    {
-	      if (tmp.is_cs_list ())
+          if (error_state)
+            {
+              ::error ("evaluating argument list element number %d", k+1);
+              args.clear ();
+              break;
+            }
+          else
+            {
+              if (tmp.is_cs_list ())
                 args.push_back (tmp.list_value ());
-	      else if (tmp.is_defined ())
+              else if (tmp.is_defined ())
                 args.push_back (tmp);
-	    }
-	}
+            }
+        }
       else
-	{
-	  args.push_back (octave_value ());
-	  break;
-	}
+        {
+          args.push_back (octave_value ());
+          break;
+        }
     }
 
   return args;
 }
 
 std::list<octave_lvalue>
 tree_argument_list::lvalue_list (void)
 {
@@ -258,17 +258,17 @@ tree_argument_list::get_arg_names (void)
       retval(k++) = elt->str_print_code ();
     }
 
   return retval;
 }
 
 tree_argument_list *
 tree_argument_list::dup (symbol_table::scope_id scope,
-			 symbol_table::context_id context) const
+                         symbol_table::context_id context) const
 {
   tree_argument_list *new_list = new tree_argument_list ();
 
   new_list->list_includes_magic_end = list_includes_magic_end;
   new_list->simple_assign_lhs = simple_assign_lhs;
 
   for (const_iterator p = begin (); p != end (); p++)
     {
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -143,28 +143,28 @@ maybe_warn_former_built_in_variable (con
 
   static std::set<std::string> vars;
 
   if (! initialized)
     {
       const char **p = former_built_in_variables;
 
       while (*p)
-	vars.insert (*p++);
+        vars.insert (*p++);
 
       initialized = true;
     }
 
   if (vars.find (nm) != vars.end ())
     {
       const char *nm_c_str = nm.c_str ();
 
       warning_with_id ("Octave:built-in-variable-assignment",
-		       "%s is now a function instead of a built-in variable.  By assigning to %s, you have created a variable that hides the function %s.  To remove the variable and restore the function, type \"clear %s\"",
-		       nm_c_str, nm_c_str, nm_c_str, nm_c_str);
+                       "%s is now a function instead of a built-in variable.  By assigning to %s, you have created a variable that hides the function %s.  To remove the variable and restore the function, type \"clear %s\"",
+                       nm_c_str, nm_c_str, nm_c_str, nm_c_str);
     }
 }
 
 tree_simple_assignment::tree_simple_assignment
   (tree_expression *le, tree_expression *re,
    bool plhs, int l, int c, octave_value::assign_op t)
     : tree_expression (l, c), lhs (le), rhs (re), preserve (plhs), etype (t),
       first_execution (true) { }
@@ -201,94 +201,94 @@ tree_simple_assignment::rvalue1 (int)
   if (error_state)
     return retval;
 
   if (rhs)
     {
       octave_value rhs_val = rhs->rvalue1 ();
 
       if (! error_state)
-	{
-	  if (rhs_val.is_undefined ())
-	    {
-	      error ("value on right hand side of assignment is undefined");
-	      return retval;
-	    }
-	  else
-	    {
-	      if (rhs_val.is_cs_list ())
-		{
-		  const octave_value_list lst = rhs_val.list_value ();
+        {
+          if (rhs_val.is_undefined ())
+            {
+              error ("value on right hand side of assignment is undefined");
+              return retval;
+            }
+          else
+            {
+              if (rhs_val.is_cs_list ())
+                {
+                  const octave_value_list lst = rhs_val.list_value ();
 
-		  if (! lst.empty ())
-		    rhs_val = lst(0);
-		  else
-		    {
-		      error ("invalid number of elements on RHS of assignment");
-		      return retval;
-		    }
-		}
+                  if (! lst.empty ())
+                    rhs_val = lst(0);
+                  else
+                    {
+                      error ("invalid number of elements on RHS of assignment");
+                      return retval;
+                    }
+                }
 
-	      octave_lvalue ult = lhs->lvalue ();
+              octave_lvalue ult = lhs->lvalue ();
 
               if (ult.numel () != 1)
                 gripe_nonbraced_cs_list_assignment ();
 
-	      if (! error_state)
-		{
-		  ult.assign (etype, rhs_val);
+              if (! error_state)
+                {
+                  ult.assign (etype, rhs_val);
 
-		  if (! error_state)
-		    {
-		      if (etype == octave_value::op_asn_eq)
-			retval = rhs_val;
-		      else
-			retval = ult.value ();
+                  if (! error_state)
+                    {
+                      if (etype == octave_value::op_asn_eq)
+                        retval = rhs_val;
+                      else
+                        retval = ult.value ();
 
-		      if (print_result ())
-			{
-			  // We clear any index here so that we can
-			  // get the new value of the referenced
-			  // object below, instead of the indexed
-			  // value (which should be the same as the
-			  // right hand side value).
+                      if (print_result ())
+                        {
+                          // We clear any index here so that we can
+                          // get the new value of the referenced
+                          // object below, instead of the indexed
+                          // value (which should be the same as the
+                          // right hand side value).
 
-			  ult.clear_index ();
+                          ult.clear_index ();
 
-			  octave_value lhs_val = ult.value ();
+                          octave_value lhs_val = ult.value ();
 
-			  if (! error_state)
-			    lhs_val.print_with_name (octave_stdout,
-						     lhs->name ());
-			}
-		    }
-		}
-	    }
-	}
+                          if (! error_state)
+                            lhs_val.print_with_name (octave_stdout,
+                                                     lhs->name ());
+                        }
+                    }
+                }
+            }
+        }
     }
 
   first_execution = false;
 
   return retval;
 }
 
 std::string
 tree_simple_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
 tree_expression *
 tree_simple_assignment::dup (symbol_table::scope_id scope,
-			     symbol_table::context_id context) const
+                             symbol_table::context_id context) const
 {
   tree_simple_assignment *new_sa
     = new tree_simple_assignment (lhs ? lhs->dup (scope, context) : 0,
-				  rhs ? rhs->dup (scope, context) : 0,
-				  preserve, etype);
+                                  rhs ? rhs->dup (scope, context) : 0,
+                                  preserve, etype);
 
   new_sa->copy_base (*this);
 
   return new_sa;
 }
 
 void
 tree_simple_assignment::accept (tree_walker& tw)
@@ -347,32 +347,32 @@ tree_multi_assignment::rvalue (int)
         }
     }
 
   if (rhs)
     {
       std::list<octave_lvalue> lvalue_list = lhs->lvalue_list ();
 
       if (error_state)
-	return retval;
+        return retval;
 
       int n_out = 0;
 
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list.begin ();
-	   p != lvalue_list.end ();
-	   p++)
-	n_out += p->numel ();
+           p != lvalue_list.end ();
+           p++)
+        n_out += p->numel ();
 
       // The following trick is used to keep rhs_val constant.
       const octave_value_list rhs_val1 = rhs->rvalue (n_out);
       const octave_value_list rhs_val = (rhs_val1.length () == 1 && rhs_val1(0).is_cs_list ()
                                          ? rhs_val1(0).list_value () : rhs_val1);
 
       if (error_state)
-	return retval;
+        return retval;
 
       octave_idx_type k = 0;
 
       octave_idx_type n = rhs_val.length ();
 
       // To avoid copying per elements and possible optimizations, we
       // postpone joining the final values.
       std::list<octave_value_list> retval_list;
@@ -466,22 +466,22 @@ tree_multi_assignment::rvalue (int)
 std::string
 tree_multi_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (op_type ());
 }
 
 tree_expression *
 tree_multi_assignment::dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const
+                            symbol_table::context_id context) const
 {
   tree_multi_assignment *new_ma
     = new tree_multi_assignment (lhs ? lhs->dup (scope, context) : 0,
-				 rhs ? rhs->dup (scope, context) : 0,
-				 preserve);
+                                 rhs ? rhs->dup (scope, context) : 0,
+                                 preserve);
 
   new_ma->copy_base (*this);
 
   return new_ma;
 }
 
 void
 tree_multi_assignment::accept (tree_walker& tw)
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
  
 octave_value_list
 tree_binary_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("binary operator `%s': invalid number of output arguments",
-	   oper () . c_str ());
+           oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_binary_expression::rvalue1 (int)
@@ -56,46 +56,46 @@ tree_binary_expression::rvalue1 (int)
   if (error_state)
     return retval;
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue1 ();
 
       if (! error_state && a.is_defined () && op_rhs)
-	{
-	  octave_value b = op_rhs->rvalue1 ();
+        {
+          octave_value b = op_rhs->rvalue1 ();
 
-	  if (! error_state && b.is_defined ())
-	    {
-	      retval = ::do_binary_op (etype, a, b);
+          if (! error_state && b.is_defined ())
+            {
+              retval = ::do_binary_op (etype, a, b);
 
-	      if (error_state)
-		retval = octave_value ();
-	    }
-	}
+              if (error_state)
+                retval = octave_value ();
+            }
+        }
     }
 
   return retval;
 }
 
 std::string
 tree_binary_expression::oper (void) const
 {
   return octave_value::binary_op_as_string (etype);
 }
 
 tree_expression *
 tree_binary_expression::dup (symbol_table::scope_id scope,
-			     symbol_table::context_id context) const
+                             symbol_table::context_id context) const
 {
   tree_binary_expression *new_be
     = new tree_binary_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
-				  op_rhs ? op_rhs->dup (scope, context) : 0,
-				  line (), column (), etype);
+                                  op_rhs ? op_rhs->dup (scope, context) : 0,
+                                  line (), column (), etype);
 
   new_be->copy_base (*this);
 
   return new_be;
 }
 
 void
 tree_binary_expression::accept (tree_walker& tw)
@@ -107,17 +107,17 @@ tree_binary_expression::accept (tree_wal
  
 octave_value_list
 tree_boolean_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("binary operator `%s': invalid number of output arguments",
-	   oper () . c_str ());
+           oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_boolean_expression::rvalue1 (int)
@@ -129,49 +129,49 @@ tree_boolean_expression::rvalue1 (int)
 
   bool result = false;
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue1 ();
 
       if (! error_state)
-	{
-	  bool a_true = a.is_true ();
+        {
+          bool a_true = a.is_true ();
 
-	  if (! error_state)
-	    {
-	      if (a_true)
-		{
-		  if (etype == bool_or)
-		    {
-		      result = true;
-		      goto done;
-		    }
-		}
-	      else
-		{
-		  if (etype == bool_and)
-		    goto done;
-		}
+          if (! error_state)
+            {
+              if (a_true)
+                {
+                  if (etype == bool_or)
+                    {
+                      result = true;
+                      goto done;
+                    }
+                }
+              else
+                {
+                  if (etype == bool_and)
+                    goto done;
+                }
 
-	      if (op_rhs)
-		{
-		  octave_value b = op_rhs->rvalue1 ();
+              if (op_rhs)
+                {
+                  octave_value b = op_rhs->rvalue1 ();
 
-		  if (! error_state)
-		    result = b.is_true ();
-		}
+                  if (! error_state)
+                    result = b.is_true ();
+                }
 
-	    done:
+            done:
 
-	      if (! error_state)
-		retval = octave_value (result);
-	    }
-	}
+              if (! error_state)
+                retval = octave_value (result);
+            }
+        }
     }
 
   return retval;
 }
 
 std::string
 tree_boolean_expression::oper (void) const
 {
@@ -191,19 +191,19 @@ tree_boolean_expression::oper (void) con
       break;
     }
 
   return retval;
 }
 
 tree_expression *
 tree_boolean_expression::dup (symbol_table::scope_id scope,
-			      symbol_table::context_id context) const
+                              symbol_table::context_id context) const
 {
   tree_boolean_expression *new_be
     = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
-				   op_rhs ? op_rhs->dup (scope, context) : 0,
-				   line (), column (), etype);
+                                   op_rhs ? op_rhs->dup (scope, context) : 0,
+                                   line (), column (), etype);
 
   new_be->copy_base (*this);
 
   return new_be;
 }
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -38,35 +38,35 @@ tree_breakpoint::visit_while_command (tr
   if (cmd.line () >= line)
     take_action (cmd);
 
   if (! found)
     {
       tree_statement_list *lst = cmd.body ();
 
       if (lst)
-	lst->accept (*this);
+        lst->accept (*this);
     }
 }
 
 void
 tree_breakpoint::visit_do_until_command (tree_do_until_command& cmd)
 {
   if (! found)
     {
       tree_statement_list *lst = cmd.body ();
 
       if (lst)
-	lst->accept (*this);
+        lst->accept (*this);
 
       if (! found)
-	{
-	  if (cmd.line () >= line)
-	    take_action (cmd);
-	}
+        {
+          if (cmd.line () >= line)
+            take_action (cmd);
+        }
     }
 }
 
 void
 tree_breakpoint::visit_argument_list (tree_argument_list&)
 {
   panic_impossible ();
 }
@@ -134,32 +134,32 @@ tree_breakpoint::visit_simple_for_comman
   if (cmd.line () >= line)
     take_action (cmd);
 
   if (! found)
     {
       tree_statement_list *lst = cmd.body ();
 
       if (lst)
-	lst->accept (*this);
+        lst->accept (*this);
     }
 }
 
 void
 tree_breakpoint::visit_complex_for_command (tree_complex_for_command& cmd)
 {
   if (cmd.line () >= line)
     take_action (cmd);
 
   if (! found)
     {
       tree_statement_list *lst = cmd.body ();
 
       if (lst)
-	lst->accept (*this);
+        lst->accept (*this);
     }
 }
 
 void
 tree_breakpoint::visit_octave_user_script (octave_user_script& fcn)
 {
   tree_statement_list *cmd_list = fcn.body ();
 
@@ -223,28 +223,28 @@ tree_breakpoint::visit_if_command (tree_
 void
 tree_breakpoint::visit_if_command_list (tree_if_command_list& lst)
 {
   for (tree_if_command_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
       tree_if_clause *t = *p;
 
       if (t->line () >= line)
-	take_action (*t);
+        take_action (*t);
 
       if (! found)
-	{      
-	  tree_statement_list *stmt_lst = t->commands ();
+        {      
+          tree_statement_list *stmt_lst = t->commands ();
 
-	  if (stmt_lst)
-	    stmt_lst->accept (*this);
-	}
+          if (stmt_lst)
+            stmt_lst->accept (*this);
+        }
 
       if (found)
-	break;
+        break;
     }
 }
 
 void
 tree_breakpoint::visit_index_expression (tree_index_expression&)
 {
   panic_impossible ();
 }
@@ -348,22 +348,22 @@ tree_breakpoint::visit_statement (tree_s
 void
 tree_breakpoint::visit_statement_list (tree_statement_list& lst)
 {
   for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
       tree_statement *elt = *p;
 
       if (elt)
-	{
-	  elt->accept (*this);
+        {
+          elt->accept (*this);
 
-	  if (found)
-	    break;
-	}
+          if (found)
+            break;
+        }
     }
 }
 
 void
 tree_breakpoint::visit_switch_case (tree_switch_case&)
 {
   panic_impossible ();
 }
@@ -371,77 +371,77 @@ tree_breakpoint::visit_switch_case (tree
 void
 tree_breakpoint::visit_switch_case_list (tree_switch_case_list& lst)
 {
   for (tree_switch_case_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
       tree_switch_case *t = *p;
 
       if (t->line () >= line)
-	take_action (*t);
+        take_action (*t);
 
       if (! found)
-	{
-	  tree_statement_list *stmt_lst = t->commands ();
+        {
+          tree_statement_list *stmt_lst = t->commands ();
 
-	  if (stmt_lst)
-	    stmt_lst->accept (*this);
-	}
+          if (stmt_lst)
+            stmt_lst->accept (*this);
+        }
 
       if (found)
-	break;
+        break;
     }
 }
 
 void
 tree_breakpoint::visit_switch_command (tree_switch_command& cmd)
 {
   if (cmd.line () >= line)
     take_action (cmd);
 
   if (! found)
     {
       tree_switch_case_list *lst = cmd.case_list ();
 
       if (lst)
-	lst->accept (*this);
+        lst->accept (*this);
     }
 }
 
 void
 tree_breakpoint::visit_try_catch_command (tree_try_catch_command& cmd)
 {
   tree_statement_list *try_code = cmd.body ();
 
   if (try_code)
     try_code->accept (*this);
 
   if (! found)
     {
       tree_statement_list *catch_code = cmd.cleanup ();
 
       if (catch_code)
-	catch_code->accept (*this);
+        catch_code->accept (*this);
     }
 }
 
 void
 tree_breakpoint::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
 {
   tree_statement_list *body = cmd.body ();
 
   if (body)
     body->accept (*this);
 
   if (! found)
     {
       tree_statement_list *cleanup = cmd.cleanup ();
 
       if (cleanup)
-	cleanup->accept (*this);
+        cleanup->accept (*this);
     }
 }
 
 void
 tree_breakpoint::take_action (tree& tr)
 {
   if (act == set)
     {
@@ -452,20 +452,20 @@ tree_breakpoint::take_action (tree& tr)
   else if (act == clear)
     {
       tr.delete_breakpoint ();
       found = true;
     }
   else if (act == list)
     {
       if (tr.is_breakpoint ())
-	{
-	  bp_list.append (octave_value (tr.line ()));
-	  line = tr.line () + 1;
-	}
+        {
+          bp_list.append (octave_value (tr.line ()));
+          line = tr.line () + 1;
+        }
     }
   else
     panic_impossible ();
 }
 
 void
 tree_breakpoint::take_action (tree_statement& stmt)
 {
@@ -480,16 +480,16 @@ tree_breakpoint::take_action (tree_state
   else if (act == clear)
     {
       stmt.delete_breakpoint ();
       found = true;
     }
   else if (act == list)
     {
       if (stmt.is_breakpoint ())
-	{
-	  bp_list.append (octave_value (lineno));
-	  line = lineno + 1;
-	}
+        {
+          bp_list.append (octave_value (lineno));
+          line = lineno + 1;
+        }
     }
   else
     panic_impossible ();
 }
diff --git a/src/pt-cbinop.cc b/src/pt-cbinop.cc
--- a/src/pt-cbinop.cc
+++ b/src/pt-cbinop.cc
@@ -42,19 +42,19 @@ strip_trans_herm (tree_expression *&exp)
     {
       tree_unary_expression *uexp = 
         dynamic_cast<tree_unary_expression *> (exp);
 
       octave_value::unary_op op = uexp->op_type ();
 
       if (op == octave_value::op_transpose
           || op == octave_value::op_hermitian)
-	exp = uexp->operand ();
+        exp = uexp->operand ();
       else
-	op = octave_value::unknown_unary_op;
+        op = octave_value::unknown_unary_op;
 
       return op;
     }
   else
     return octave_value::unknown_unary_op;
 }
 
 static octave_value::unary_op 
@@ -63,19 +63,19 @@ strip_not (tree_expression *&exp)
   if (exp->is_unary_expression ())
     {
       tree_unary_expression *uexp = 
         dynamic_cast<tree_unary_expression *> (exp);
 
       octave_value::unary_op op = uexp->op_type ();
 
       if (op == octave_value::op_not)
-	exp = uexp->operand ();
+        exp = uexp->operand ();
       else
-	op = octave_value::unknown_unary_op;
+        op = octave_value::unknown_unary_op;
 
       return op;
     }
   else
     return octave_value::unknown_unary_op;
 }
 
 // Possibly convert multiplication to trans_mul, mul_trans, herm_mul,
@@ -199,25 +199,25 @@ tree_compound_binary_expression::rvalue1
   if (error_state)
     return retval;
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue1 ();
 
       if (! error_state && a.is_defined () && op_rhs)
-	{
-	  octave_value b = op_rhs->rvalue1 ();
+        {
+          octave_value b = op_rhs->rvalue1 ();
 
-	  if (! error_state && b.is_defined ())
-	    {
-	      retval = ::do_binary_op (etype, a, b);
+          if (! error_state && b.is_defined ())
+            {
+              retval = ::do_binary_op (etype, a, b);
 
-	      if (error_state)
-		retval = octave_value ();
-	    }
-	}
+              if (error_state)
+                retval = octave_value ();
+            }
+        }
     }
 
   return retval;
 }
 
 
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -57,34 +57,34 @@ tree_cell::rvalue1 (int)
       tree_argument_list *elt = *p;
 
       octave_value_list row = elt->convert_to_const_vector ();
       
       if (nr == 1)
         // Optimize the single row case.
         val = row.cell_value ();
       else if (nc < 0)
-	{
-	  nc = row.length ();
+        {
+          nc = row.length ();
 
-	  val = Cell (nr, nc);
-	}
+          val = Cell (nr, nc);
+        }
       else
-	{
-	  octave_idx_type this_nc = row.length ();
+        {
+          octave_idx_type this_nc = row.length ();
 
-	  if (nc != this_nc)
-	    {
-	      ::error ("number of columns must match");
-	      return retval;
-	    }
-	}
+          if (nc != this_nc)
+            {
+              ::error ("number of columns must match");
+              return retval;
+            }
+        }
 
       for (octave_idx_type j = 0; j < nc; j++)
-	val(i,j) = row(j);
+        val(i,j) = row(j);
 
       i++;
     }
 
   retval = val;
 
   return retval;
 }
@@ -99,17 +99,17 @@ tree_cell::rvalue (int nargout)
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 tree_expression *
 tree_cell::dup (symbol_table::scope_id scope,
-		symbol_table::context_id context) const
+                symbol_table::context_id context) const
 {
   tree_cell *new_cell = new tree_cell (0, line (), column ());
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_argument_list *elt = *p;
 
       new_cell->append (elt ? elt->dup (scope, context) : 0);
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -35,20 +35,20 @@ tree_checker::visit_argument_list (tree_
 {
   tree_argument_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_expression *elt = *p++;
 
       if (elt)
-	{
-	  if (do_lvalue_check && ! elt->lvalue_ok ())
-	    gripe ("invalid lvalue in multiple assignment", elt->line ());
-	}
+        {
+          if (do_lvalue_check && ! elt->lvalue_ok ())
+            gripe ("invalid lvalue in multiple assignment", elt->line ());
+        }
     }
 }
 
 void
 tree_checker::visit_binary_expression (tree_binary_expression& expr)
 {
   tree_expression *op1 = expr.lhs ();
 
@@ -130,29 +130,29 @@ tree_checker::visit_decl_init_list (tree
 {
   tree_decl_init_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_decl_elt *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   tree_expression *lhs = cmd.left_hand_side ();
 
   if (lhs)
     {
       if (! lhs->lvalue_ok ())
-	gripe ("invalid lvalue in for command", cmd.line ());
+        gripe ("invalid lvalue in for command", cmd.line ());
     }
 
   tree_expression *expr = cmd.control_expr ();
 
   if (expr)
     expr->accept (*this);
 
   tree_statement_list *list = cmd.body ();
@@ -166,18 +166,18 @@ tree_checker::visit_complex_for_command 
 {
   tree_argument_list *lhs = cmd.left_hand_side ();
 
   if (lhs)
     {
       int len = lhs->length ();
 
       if (len == 0 || len > 2)
-	gripe ("invalid number of output arguments in for command",
-	       cmd.line ());
+        gripe ("invalid number of output arguments in for command",
+               cmd.line ());
 
       do_lvalue_check = true;
 
       lhs->accept (*this);
 
       do_lvalue_check = false;
     }
 
@@ -254,17 +254,17 @@ tree_checker::visit_if_command_list (tre
 {
   tree_if_command_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_if_clause *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_index_expression (tree_index_expression& expr)
 {
   tree_expression *e = expr.expression ();
 
@@ -275,45 +275,45 @@ tree_checker::visit_index_expression (tr
 
   std::list<tree_argument_list *>::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_argument_list *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_matrix (tree_matrix& lst)
 {
   tree_matrix::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_argument_list *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_cell (tree_cell& lst)
 {
   tree_matrix::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_argument_list *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_multi_assignment (tree_multi_assignment& expr)
 {
   tree_argument_list *lhs = expr.left_hand_side ();
 
@@ -357,17 +357,17 @@ tree_checker::visit_parameter_list (tree
 {
   tree_parameter_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_decl_elt *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_postfix_expression (tree_postfix_expression& expr)
 {
   tree_expression *e = expr.operand ();
 
@@ -394,29 +394,29 @@ tree_checker::visit_return_list (tree_re
 {
   tree_return_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_index_expression *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_simple_assignment (tree_simple_assignment& expr)
 {
   tree_expression *lhs = expr.left_hand_side ();
 
   if (lhs)
     {
       if (! lhs->lvalue_ok ())
-	gripe ("invalid lvalue in assignment", expr.line ());
+        gripe ("invalid lvalue in assignment", expr.line ());
     }
 
   tree_expression *rhs = expr.right_hand_side ();
 
   if (rhs)
     rhs->accept (*this);
 }
 
@@ -427,29 +427,29 @@ tree_checker::visit_statement (tree_stat
 
   if (cmd)
     cmd->accept (*this);
   else
     {
       tree_expression *expr = stmt.expression ();
 
       if (expr)
-	expr->accept (*this);
+        expr->accept (*this);
     }
 }
 
 void
 tree_checker::visit_statement_list (tree_statement_list& lst)
 {
   for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
       tree_statement *elt = *p;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_switch_case (tree_switch_case& cs)
 {
   tree_expression *label = cs.case_label ();
 
@@ -467,17 +467,17 @@ tree_checker::visit_switch_case_list (tr
 {
   tree_switch_case_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_switch_case *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_switch_command (tree_switch_command& cmd)
 {
   tree_expression *expr = cmd.switch_value ();
 
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -27,32 +27,32 @@ along with Octave; see the file COPYING.
 
 #include "pt-cmd.h"
 #include "pt-walk.h"
 
 // No-op.
 
 tree_command *
 tree_no_op_command::dup (symbol_table::scope_id,
-			 symbol_table::context_id) const
+                         symbol_table::context_id) const
 {
   return new tree_no_op_command (orig_cmd, line (), column ());
 }
 
 void
 tree_no_op_command::accept (tree_walker& tw)
 {
   tw.visit_no_op_command (*this);
 }
 
 // Function definition.
 
 tree_command *
 tree_function_def::dup (symbol_table::scope_id,
-			symbol_table::context_id) const
+                        symbol_table::context_id) const
 {
   return new tree_function_def (fcn, line (), column ());
 }
 
 void
 tree_function_def::accept (tree_walker& tw)
 {
   tw.visit_function_def (*this);
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -38,32 +38,32 @@ along with Octave; see the file COPYING.
 tree_colon_expression *
 tree_colon_expression::append (tree_expression *t)
 {
   tree_colon_expression *retval = 0;
 
   if (op_base)
     {
       if (op_limit)
-	{
-	  if (op_increment)
-	    ::error ("invalid colon expression");
-	  else
-	    {
-	      // Stupid syntax:
-	      //
-	      // base : limit
-	      // base : increment : limit
+        {
+          if (op_increment)
+            ::error ("invalid colon expression");
+          else
+            {
+              // Stupid syntax:
+              //
+              // base : limit
+              // base : increment : limit
 
-	      op_increment = op_limit;
-	      op_limit = t;
-	    }
-	}
+              op_increment = op_limit;
+              op_limit = t;
+            }
+        }
       else
-	op_limit = t;
+        op_limit = t;
 
       retval = this;
     }
   else
     ::error ("invalid colon expression");
 
   return retval;
 }
@@ -78,92 +78,92 @@ tree_colon_expression::rvalue (int nargo
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_colon_expression::make_range (const Matrix& m_base,
-				   const Matrix& m_limit,
-				   const Matrix& m_increment,
-				   bool result_is_str, bool dq_str) const
+                                   const Matrix& m_limit,
+                                   const Matrix& m_increment,
+                                   bool result_is_str, bool dq_str) const
 {
   octave_value retval;
 
   bool base_empty = m_base.is_empty ();
   bool limit_empty = m_limit.is_empty ();
   bool increment_empty = m_increment.is_empty ();
 
   if (base_empty || limit_empty || increment_empty)
     retval = Range ();
   else
     {
       retval = Range (m_base(0), m_limit(0), m_increment(0));
 
       if (result_is_str)
-	retval = retval.convert_to_str (false, true, dq_str ? '"' : '\'');
+        retval = retval.convert_to_str (false, true, dq_str ? '"' : '\'');
     }
 
   return retval;
 }
 
 octave_value
 tree_colon_expression::make_range (const octave_value& ov_base,
-				   const octave_value& ov_limit,
-				   const octave_value& ov_increment) const
+                                   const octave_value& ov_limit,
+                                   const octave_value& ov_increment) const
 {
   octave_value retval;
 
   if (ov_base.is_object () || ov_limit.is_object () || 
       ov_increment.is_object ())
     {
       octave_value_list tmp1;
       tmp1(2) = ov_limit;
       tmp1(1) = ov_increment;
       tmp1(0) = ov_base;
 
       octave_value fcn = symbol_table::find_function ("colon", tmp1);
 
       if (fcn.is_defined ())
-	{
-	  octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
-		      
-	  if (! error_state)
-	    retval = tmp2 (0);
-	}
+        {
+          octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
+                      
+          if (! error_state)
+            retval = tmp2 (0);
+        }
       else
-	::error ("can not find overloaded colon function");
+        ::error ("can not find overloaded colon function");
     }
   else
     {
       bool result_is_str = (ov_base.is_string () && ov_limit.is_string ());
       bool dq_str = (ov_base.is_dq_string () || ov_limit.is_dq_string ());
 
       Matrix m_base = ov_base.matrix_value (true);
 
       if (error_state)
-	eval_error ("invalid base value in colon expression");
+        eval_error ("invalid base value in colon expression");
       else
-	{
-	  Matrix m_limit = ov_limit.matrix_value (true);
+        {
+          Matrix m_limit = ov_limit.matrix_value (true);
 
-	  if (error_state)
-	    eval_error ("invalid limit value in colon expression");
-	  else
-	    {
-	      Matrix m_increment = ov_increment.matrix_value (true);
+          if (error_state)
+            eval_error ("invalid limit value in colon expression");
+          else
+            {
+              Matrix m_increment = ov_increment.matrix_value (true);
 
-	      if (error_state)
-		eval_error ("invalid increment value in colon expression");
-	      else
-		retval = make_range (m_base, m_limit, m_increment,
-				     result_is_str, dq_str);
-	    }
-	}
+              if (error_state)
+                eval_error ("invalid increment value in colon expression");
+              else
+                retval = make_range (m_base, m_limit, m_increment,
+                                     result_is_str, dq_str);
+            }
+        }
     }
 
   return retval;
 }
 
 octave_value
 tree_colon_expression::rvalue1 (int)
 {
@@ -176,108 +176,108 @@ tree_colon_expression::rvalue1 (int)
 
   if (error_state || ov_base.is_undefined ())
     eval_error ("invalid base value in colon expression");
   else
     {
       octave_value ov_limit = op_limit->rvalue1 ();
 
       if (error_state || ov_limit.is_undefined ())
-	eval_error ("invalid limit value in colon expression");
+        eval_error ("invalid limit value in colon expression");
       else if (ov_base.is_object () || ov_limit.is_object ())
-	{
-	  octave_value_list tmp1;
+        {
+          octave_value_list tmp1;
 
-	  if (op_increment)
-	    {
-	      octave_value ov_increment = op_increment->rvalue1 ();
+          if (op_increment)
+            {
+              octave_value ov_increment = op_increment->rvalue1 ();
 
-	      if (error_state || ov_increment.is_undefined ())
-		eval_error ("invalid increment value in colon expression");
-	      else
-		{
-		  tmp1(2) = ov_limit;
-		  tmp1(1) = ov_increment;
-		  tmp1(0) = ov_base;
-		}
-	    }
-	  else
-	    {
-	      tmp1(1) = ov_limit;
-	      tmp1(0) = ov_base;
-	    }
+              if (error_state || ov_increment.is_undefined ())
+                eval_error ("invalid increment value in colon expression");
+              else
+                {
+                  tmp1(2) = ov_limit;
+                  tmp1(1) = ov_increment;
+                  tmp1(0) = ov_base;
+                }
+            }
+          else
+            {
+              tmp1(1) = ov_limit;
+              tmp1(0) = ov_base;
+            }
 
-	  if (!error_state)
-	    {
-	      octave_value fcn = symbol_table::find_function ("colon", tmp1);
+          if (!error_state)
+            {
+              octave_value fcn = symbol_table::find_function ("colon", tmp1);
 
-	      if (fcn.is_defined ())
-		{
-		  octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
-		      
-		  if (! error_state)
-		    retval = tmp2 (0);
-		}
-	      else
-		::error ("can not find overloaded colon function");
-	    }
-	}
+              if (fcn.is_defined ())
+                {
+                  octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
+                      
+                  if (! error_state)
+                    retval = tmp2 (0);
+                }
+              else
+                ::error ("can not find overloaded colon function");
+            }
+        }
       else
-	{
-	  octave_value ov_increment = 1.0;
+        {
+          octave_value ov_increment = 1.0;
 
-	  if (op_increment)
-	    {
-	      ov_increment = op_increment->rvalue1 ();
+          if (op_increment)
+            {
+              ov_increment = op_increment->rvalue1 ();
 
-	      if (error_state || ov_increment.is_undefined ())
-		eval_error ("invalid increment value in colon expression");
-	    }
+              if (error_state || ov_increment.is_undefined ())
+                eval_error ("invalid increment value in colon expression");
+            }
 
-	  if (! error_state)
-	    retval = make_range (ov_base, ov_limit, ov_increment);
-	}
+          if (! error_state)
+            retval = make_range (ov_base, ov_limit, ov_increment);
+        }
     }
 
   return retval;
 }
 
 void
 tree_colon_expression::eval_error (const std::string& s) const
 {
   ::error ("%s", s.c_str ());
 }
 
 int
 tree_colon_expression::line (void) const
 {
   return (op_base ? op_base->line ()
-	  : (op_increment ? op_increment->line ()
-	     : (op_limit ? op_limit->line ()
-		: -1)));
+          : (op_increment ? op_increment->line ()
+             : (op_limit ? op_limit->line ()
+                : -1)));
 }
 
 int
 tree_colon_expression::column (void) const
 {
   return (op_base ? op_base->column ()
-	  : (op_increment ? op_increment->column ()
-	     : (op_limit ? op_limit->column ()
-		: -1)));
+          : (op_increment ? op_increment->column ()
+             : (op_limit ? op_limit->column ()
+                : -1)));
 }
 
 tree_expression *
 tree_colon_expression::dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const
+                            symbol_table::context_id context) const
 {
   tree_colon_expression *new_ce = new
     tree_colon_expression (op_base ? op_base->dup (scope, context) : 0,
-			   op_limit ? op_limit->dup (scope, context) : 0,
-			   op_increment ? op_increment->dup (scope, context) : 0,
-			   line (), column ());
+                           op_limit ? op_limit->dup (scope, context) : 0,
+                           op_increment ? op_increment->dup (scope, context) : 0,
+                           line (), column ());
 
   new_ce->copy_base (*new_ce);
 
   return new_ce;
 }
 
 void
 tree_colon_expression::accept (tree_walker& tw)
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -44,17 +44,17 @@ tree_constant::print (std::ostream& os, 
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print (os, pr_as_read_syntax);
 }
 
 void
 tree_constant::print_raw (std::ostream& os, bool pr_as_read_syntax,
-			  bool pr_orig_text) 
+                          bool pr_orig_text) 
 {
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print_raw (os, pr_as_read_syntax);
 }
 
 octave_value_list
@@ -67,17 +67,17 @@ tree_constant::rvalue (int nargout)
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 tree_expression *
 tree_constant::dup (symbol_table::scope_id,
-		    symbol_table::context_id) const
+                    symbol_table::context_id) const
 {
   tree_constant *new_tc
     = new tree_constant (val, orig_text, line (), column ());
 
   new_tc->copy_base (*this);
 
   return new_tc;
 }
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -53,45 +53,45 @@ tree_decl_elt::eval (void)
 
   if (id && expr)
     {
       octave_lvalue ult = id->lvalue ();
 
       octave_value init_val = expr->rvalue1 ();
 
       if (! error_state)
-	{
-	  ult.assign (octave_value::op_asn_eq, init_val);
+        {
+          ult.assign (octave_value::op_asn_eq, init_val);
 
-	  retval = true;
-	}
+          retval = true;
+        }
     }
 
   return retval;
 }
 
 tree_decl_elt *
 tree_decl_elt::dup (symbol_table::scope_id scope,
-		    symbol_table::context_id context) const
+                    symbol_table::context_id context) const
 {
   return new tree_decl_elt (id ? id->dup (scope, context) : 0,
-			    expr ? expr->dup (scope, context) : 0);
+                            expr ? expr->dup (scope, context) : 0);
 }
 
 void
 tree_decl_elt::accept (tree_walker& tw)
 {
   tw.visit_decl_elt (*this);
 }
 
 // Initializer lists for declaration statements.
 
 tree_decl_init_list *
 tree_decl_init_list::dup (symbol_table::scope_id scope,
-			  symbol_table::context_id context) const
+                          symbol_table::context_id context) const
 {
   tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_decl_elt *elt = *p;
 
       new_dil->append (elt ? elt->dup (scope, context) : 0);
@@ -112,37 +112,37 @@ tree_decl_command::~tree_decl_command (v
 {
   delete init_list;
 }
 
 // Global.
 
 tree_command *
 tree_global_command::dup (symbol_table::scope_id scope,
-			  symbol_table::context_id context) const
+                          symbol_table::context_id context) const
 {
   return
     new tree_global_command (init_list ? init_list->dup (scope, context) : 0,
-			     line (), column ());
+                             line (), column ());
 }
 
 void
 tree_global_command::accept (tree_walker& tw)
 {
   tw.visit_global_command (*this);
 }
 
 // Static.
 
 tree_command *
 tree_static_command::dup (symbol_table::scope_id scope,
-			  symbol_table::context_id context) const
+                          symbol_table::context_id context) const
 {
   return
     new tree_static_command (init_list ? init_list->dup (scope, context) : 0,
-			     line (), column ());
+                             line (), column ());
 }
 
 void
 tree_static_command::accept (tree_walker& tw)
 {
   tw.visit_static_command (*this);
 }
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -83,17 +83,17 @@ tree_evaluator::visit_binary_expression 
 }
 
 void
 tree_evaluator::visit_break_command (tree_break_command& cmd)
 {
   if (! error_state)
     {
       if (debug_mode)
-	do_breakpoint (cmd.is_breakpoint ());
+        do_breakpoint (cmd.is_breakpoint ());
 
       if (tree_evaluator::in_fcn_or_script_body
           || tree_evaluator::in_loop_command)
         tree_break_command::breaking = 1;
     }
 }
 
 void
@@ -103,17 +103,17 @@ tree_evaluator::visit_colon_expression (
 }
 
 void
 tree_evaluator::visit_continue_command (tree_continue_command& cmd)
 {
   if (! error_state)
     {
       if (debug_mode)
-	do_breakpoint (cmd.is_breakpoint ());
+        do_breakpoint (cmd.is_breakpoint ());
 
       if (tree_evaluator::in_fcn_or_script_body
           || tree_evaluator::in_loop_command)
         tree_continue_command::continuing = 1;
     }
 }
 
 void
@@ -129,79 +129,79 @@ do_global_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
 
   if (id)
     {
       id->mark_global ();
 
       if (! error_state)
-	{
-	  octave_lvalue ult = id->lvalue ();
+        {
+          octave_lvalue ult = id->lvalue ();
 
-	  if (ult.is_undefined ())
-	    {
-	      tree_expression *expr = elt.expression ();
+          if (ult.is_undefined ())
+            {
+              tree_expression *expr = elt.expression ();
 
-	      octave_value init_val;
+              octave_value init_val;
 
-	      if (expr)
-		init_val = expr->rvalue1 ();
-	      else
-		init_val = Matrix ();
+              if (expr)
+                init_val = expr->rvalue1 ();
+              else
+                init_val = Matrix ();
 
-	      ult.assign (octave_value::op_asn_eq, init_val);
-	    }
-	}
+              ult.assign (octave_value::op_asn_eq, init_val);
+            }
+        }
     }
 }
 
 static inline void
 do_static_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
 
   if (id)
     {
       id->mark_as_static ();
 
       octave_lvalue ult = id->lvalue ();
 
       if (ult.is_undefined ())
-	{
-	  tree_expression *expr = elt.expression ();
+        {
+          tree_expression *expr = elt.expression ();
 
-	  octave_value init_val;
+          octave_value init_val;
 
-	  if (expr)
-	    init_val = expr->rvalue1 ();
-	  else
-	    init_val = Matrix ();
+          if (expr)
+            init_val = expr->rvalue1 ();
+          else
+            init_val = Matrix ();
 
-	  ult.assign (octave_value::op_asn_eq, init_val);
-	}
+          ult.assign (octave_value::op_asn_eq, init_val);
+        }
     }
 }
 
 void
 tree_evaluator::do_decl_init_list (decl_elt_init_fcn fcn,
-				   tree_decl_init_list *init_list)
+                                   tree_decl_init_list *init_list)
 {
   if (init_list)
     {
       for (tree_decl_init_list::iterator p = init_list->begin ();
-	   p != init_list->end (); p++)
-	{
-	  tree_decl_elt *elt = *p;
+           p != init_list->end (); p++)
+        {
+          tree_decl_elt *elt = *p;
 
-	  fcn (*elt);
+          fcn (*elt);
 
-	  if (error_state)
-	    break;
-	}
+          if (error_state)
+            break;
+        }
     }
 }
 
 void
 tree_evaluator::visit_global_command (tree_global_command& cmd)
 {
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
@@ -261,33 +261,33 @@ quit_loop_now (void)
   octave_quit ();
 
   // Maybe handle `continue N' someday...
 
   if (tree_continue_command::continuing)
     tree_continue_command::continuing--;
 
   bool quit = (error_state
-	       || tree_return_command::returning
-	       || tree_break_command::breaking
-	       || tree_continue_command::continuing);
+               || tree_return_command::returning
+               || tree_break_command::breaking
+               || tree_continue_command::continuing);
 
   if (tree_break_command::breaking)
     tree_break_command::breaking--;
 
   return quit;
 }
 
 #define DO_SIMPLE_FOR_LOOP_ONCE(VAL) \
   do \
     { \
       ult.assign (octave_value::op_asn_eq, VAL); \
  \
       if (! error_state && loop_body) \
-	loop_body->accept (*this); \
+        loop_body->accept (*this); \
  \
       quit = quit_loop_now (); \
     } \
   while (0)
 
 void
 tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
 {
@@ -317,47 +317,47 @@ tree_evaluator::visit_simple_for_command
 
     if (error_state)
       return;
 
     tree_statement_list *loop_body = cmd.body ();
 
     if (rhs.is_range ())
       {
-	Range rng = rhs.range_value ();
+        Range rng = rhs.range_value ();
 
-	octave_idx_type steps = rng.nelem ();
-	double b = rng.base ();
-	double increment = rng.inc ();
-	bool quit = false;
+        octave_idx_type steps = rng.nelem ();
+        double b = rng.base ();
+        double increment = rng.inc ();
+        bool quit = false;
 
-	for (octave_idx_type i = 0; i < steps; i++)
-	  {
-	    // Use multiplication here rather than declaring a
-	    // temporary variable outside the loop and using
-	    //
-	    //   tmp_val += increment
-	    //
-	    // to avoid problems with limited precision.  Also, this
-	    // is consistent with the way Range::matrix_value is
-	    // implemented.
+        for (octave_idx_type i = 0; i < steps; i++)
+          {
+            // Use multiplication here rather than declaring a
+            // temporary variable outside the loop and using
+            //
+            //   tmp_val += increment
+            //
+            // to avoid problems with limited precision.  Also, this
+            // is consistent with the way Range::matrix_value is
+            // implemented.
 
-	    octave_value val (b + i * increment);
+            octave_value val (b + i * increment);
 
-	    DO_SIMPLE_FOR_LOOP_ONCE (val);
+            DO_SIMPLE_FOR_LOOP_ONCE (val);
 
-	    if (quit)
-	      break;
-	  }
+            if (quit)
+              break;
+          }
       }
     else if (rhs.is_scalar_type ())
       {
-	bool quit = false;
+        bool quit = false;
 
-	DO_SIMPLE_FOR_LOOP_ONCE (rhs);
+        DO_SIMPLE_FOR_LOOP_ONCE (rhs);
       }
     else if (rhs.is_matrix_type () || rhs.is_cell () || rhs.is_string ()
              || rhs.is_map ())
       {
         // A matrix or cell is reshaped to 2 dimensions and iterated by
         // columns.
 
         bool quit = false;
@@ -396,18 +396,18 @@ tree_evaluator::visit_simple_for_command
 
                 if (quit)
                   break;
               }
           }
       }
     else
       {
-	::error ("invalid type in for loop expression near line %d, column %d",
-		 cmd.line (), cmd.column ());
+        ::error ("invalid type in for loop expression near line %d, column %d",
+                 cmd.line (), cmd.column ());
       }
   }
 }
 
 void
 tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
 {
   if (error_state)
@@ -451,34 +451,34 @@ tree_evaluator::visit_complex_for_comman
 
       tree_statement_list *loop_body = cmd.body ();
 
       string_vector keys = tmp_val.keys ();
 
       octave_idx_type nel = keys.numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-	{
-	  std::string key = keys[i];
+        {
+          std::string key = keys[i];
 
-	  const Cell val_lst = tmp_val.contents (key);
+          const Cell val_lst = tmp_val.contents (key);
 
-	  octave_idx_type n = val_lst.numel ();
+          octave_idx_type n = val_lst.numel ();
 
-	  octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
+          octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
 
-	  val_ref.assign (octave_value::op_asn_eq, val);
-	  key_ref.assign (octave_value::op_asn_eq, key);
+          val_ref.assign (octave_value::op_asn_eq, val);
+          key_ref.assign (octave_value::op_asn_eq, key);
 
-	  if (! error_state && loop_body)
-	    loop_body->accept (*this);
+          if (! error_state && loop_body)
+            loop_body->accept (*this);
 
-	  if (quit_loop_now ())
-	    break;
-	}
+          if (quit_loop_now ())
+            break;
+        }
     }
   else
     error ("in statement `for [X, Y] = VAL', VAL must be a structure");
 }
 
 void
 tree_evaluator::visit_octave_user_script (octave_user_script&)
 {
@@ -549,30 +549,30 @@ tree_evaluator::visit_if_command_list (t
 {
   for (tree_if_command_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
       tree_if_clause *tic = *p;
 
       tree_expression *expr = tic->condition ();
 
       if (debug_mode && ! tic->is_else_clause ())
-	do_breakpoint (tic->is_breakpoint ());
+        do_breakpoint (tic->is_breakpoint ());
 
       if (tic->is_else_clause () || expr->is_logically_true ("if"))
-	{
-	  if (! error_state)
-	    {
-	      tree_statement_list *stmt_lst = tic->commands ();
+        {
+          if (! error_state)
+            {
+              tree_statement_list *stmt_lst = tic->commands ();
 
-	      if (stmt_lst)
-		stmt_lst->accept (*this);
-	    }
+              if (stmt_lst)
+                stmt_lst->accept (*this);
+            }
 
-	  break;
-	}
+          break;
+        }
     }
 }
 
 void
 tree_evaluator::visit_index_expression (tree_index_expression&)
 {
   panic_impossible ();
 }
@@ -633,17 +633,17 @@ tree_evaluator::visit_prefix_expression 
 }
 
 void
 tree_evaluator::visit_return_command (tree_return_command& cmd)
 {
   if (! error_state)
     {
       if (debug_mode)
-	do_breakpoint (cmd.is_breakpoint ());
+        do_breakpoint (cmd.is_breakpoint ());
 
       // Act like dbcont.
 
       if (Vdebugging
           && octave_call_stack::current_frame () == current_frame)
         {
           Vdebugging = false;
 
@@ -671,126 +671,126 @@ void
 tree_evaluator::visit_statement (tree_statement& stmt)
 {
   tree_command *cmd = stmt.command ();
   tree_expression *expr = stmt.expression ();
 
   if (cmd || expr)
     {
       if (in_fcn_or_script_body)
-	{
-	  octave_call_stack::set_statement (&stmt);
+        {
+          octave_call_stack::set_statement (&stmt);
 
-	  if (Vecho_executing_commands & ECHO_FUNCTIONS)
-	    stmt.echo_code ();
-	}
+          if (Vecho_executing_commands & ECHO_FUNCTIONS)
+            stmt.echo_code ();
+        }
 
       try
-	{
-	  if (cmd)
-	    cmd->accept (*this);
-	  else
-	    {
-	      if (debug_mode)
-		do_breakpoint (expr->is_breakpoint ());
+        {
+          if (cmd)
+            cmd->accept (*this);
+          else
+            {
+              if (debug_mode)
+                do_breakpoint (expr->is_breakpoint ());
 
-	      if (in_fcn_or_script_body && Vsilent_functions)
-		expr->set_print_flag (false);
+              if (in_fcn_or_script_body && Vsilent_functions)
+                expr->set_print_flag (false);
 
-	      // FIXME -- maybe all of this should be packaged in
-	      // one virtual function that returns a flag saying whether
-	      // or not the expression will take care of binding ans and
-	      // printing the result.
+              // FIXME -- maybe all of this should be packaged in
+              // one virtual function that returns a flag saying whether
+              // or not the expression will take care of binding ans and
+              // printing the result.
 
-	      // FIXME -- it seems that we should just have to
-	      // call expr->rvalue1 () and that should take care of
-	      // everything, binding ans as necessary?
+              // FIXME -- it seems that we should just have to
+              // call expr->rvalue1 () and that should take care of
+              // everything, binding ans as necessary?
 
-	      bool do_bind_ans = false;
+              bool do_bind_ans = false;
 
-	      if (expr->is_identifier ())
-		{
-		  tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
+              if (expr->is_identifier ())
+                {
+                  tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-		  do_bind_ans = (! id->is_variable ());
-		}
-	      else
-		do_bind_ans = (! expr->is_assignment_expression ());
+                  do_bind_ans = (! id->is_variable ());
+                }
+              else
+                do_bind_ans = (! expr->is_assignment_expression ());
 
-	      octave_value tmp_result = expr->rvalue1 (0);
+              octave_value tmp_result = expr->rvalue1 (0);
 
-	      if (do_bind_ans && ! (error_state || tmp_result.is_undefined ()))
-		bind_ans (tmp_result, expr->print_result ());
+              if (do_bind_ans && ! (error_state || tmp_result.is_undefined ()))
+                bind_ans (tmp_result, expr->print_result ());
 
-	      //	      if (tmp_result.is_defined ())
-	      //		result_values(0) = tmp_result;
-	    }
-	}
+              //              if (tmp_result.is_defined ())
+              //                result_values(0) = tmp_result;
+            }
+        }
       catch (octave_execution_exception)
-	{
-	  gripe_library_execution_error ();
-	}
+        {
+          gripe_library_execution_error ();
+        }
     }
 }
 
 void
 tree_evaluator::visit_statement_list (tree_statement_list& lst)
 {
   static octave_value_list empty_list;
 
   if (error_state)
     return;
 
   tree_statement_list::iterator p = lst.begin ();
 
   if (p != lst.end ())
     {
       while (true)
-	{
-	  tree_statement *elt = *p++;
+        {
+          tree_statement *elt = *p++;
 
-	  if (elt)
-	    {
-	      octave_quit ();
+          if (elt)
+            {
+              octave_quit ();
 
-	      elt->accept (*this);
+              elt->accept (*this);
 
-	      if (error_state)
-		break;
+              if (error_state)
+                break;
 
-	      if (tree_break_command::breaking
-		  || tree_continue_command::continuing)
-		break;
+              if (tree_break_command::breaking
+                  || tree_continue_command::continuing)
+                break;
 
-	      if (tree_return_command::returning)
-		break;
+              if (tree_return_command::returning)
+                break;
 
-	      if (p == lst.end ())
-		break;
-	      else
-		{
-		  // Clear preivous values before next statement is
-		  // evaluated so that we aren't holding an extra
-		  // reference to a value that may be used next.  For
-		  // example, in code like this:
-		  //
-		  //   X = rand (N);  ## refcount for X should be 1
-		  //                  ## after this statement
-		  //
-		  //   X(idx) = val;  ## no extra copy of X should be
-		  //                  ## needed, but we will be faked
-		  //                  ## out if retval is not cleared
-		  //                  ## between statements here
+              if (p == lst.end ())
+                break;
+              else
+                {
+                  // Clear preivous values before next statement is
+                  // evaluated so that we aren't holding an extra
+                  // reference to a value that may be used next.  For
+                  // example, in code like this:
+                  //
+                  //   X = rand (N);  ## refcount for X should be 1
+                  //                  ## after this statement
+                  //
+                  //   X(idx) = val;  ## no extra copy of X should be
+                  //                  ## needed, but we will be faked
+                  //                  ## out if retval is not cleared
+                  //                  ## between statements here
 
-		  //		  result_values = empty_list;
-		}
-	    }
-	  else
-	    error ("invalid statement found in statement list!");
-	}
+                  //              result_values = empty_list;
+                }
+            }
+          else
+            error ("invalid statement found in statement list!");
+        }
     }
 }
 
 void
 tree_evaluator::visit_switch_case (tree_switch_case&)
 {
   panic_impossible ();
 }
@@ -808,43 +808,43 @@ tree_evaluator::visit_switch_command (tr
 
   if (expr)
     {
       octave_value val = expr->rvalue1 ();
 
       tree_switch_case_list *lst = cmd.case_list ();
 
       if (! error_state && lst)
-	{
-	  for (tree_switch_case_list::iterator p = lst->begin ();
-	       p != lst->end (); p++)
-	    {
-	      tree_switch_case *t = *p;
+        {
+          for (tree_switch_case_list::iterator p = lst->begin ();
+               p != lst->end (); p++)
+            {
+              tree_switch_case *t = *p;
 
-	      if (debug_mode && ! t->is_default_case ())
-		do_breakpoint (t->is_breakpoint ());
+              if (debug_mode && ! t->is_default_case ())
+                do_breakpoint (t->is_breakpoint ());
 
-	      if (t->is_default_case () || t->label_matches (val))
-		{
-		  if (error_state)
-		    break;
+              if (t->is_default_case () || t->label_matches (val))
+                {
+                  if (error_state)
+                    break;
 
-		  tree_statement_list *stmt_lst = t->commands ();
+                  tree_statement_list *stmt_lst = t->commands ();
 
-		  if (stmt_lst)
-		    stmt_lst->accept (*this);
+                  if (stmt_lst)
+                    stmt_lst->accept (*this);
 
-		  break;
-		}
-	    }
-	}
+                  break;
+                }
+            }
+        }
     }
   else
     ::error ("missing value in switch command near line %d, column %d",
-	     cmd.line (), cmd.column ());
+             cmd.line (), cmd.column ());
 }
 
 void
 tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
 {
   unwind_protect frame;
   
   frame.protect_var (buffer_error_messages);
@@ -1011,35 +1011,35 @@ tree_evaluator::visit_while_command (tre
   tree_expression *expr = cmd.condition ();
 
   if (! expr)
     panic_impossible ();
 
   for (;;)
     {
       if (debug_mode)
-	do_breakpoint (cmd.is_breakpoint ());
+        do_breakpoint (cmd.is_breakpoint ());
 
       if (expr->is_logically_true ("while"))
-	{
-	  tree_statement_list *loop_body = cmd.body ();
+        {
+          tree_statement_list *loop_body = cmd.body ();
 
-	  if (loop_body)
-	    {
-	      loop_body->accept (*this);
+          if (loop_body)
+            {
+              loop_body->accept (*this);
 
-	      if (error_state)
+              if (error_state)
                 return;
-	    }
+            }
 
-	  if (quit_loop_now ())
-	    break;
-	}
+          if (quit_loop_now ())
+            break;
+        }
       else
-	break;
+        break;
     }
 }
 
 void
 tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
 {
   if (error_state)
     return;
@@ -1055,60 +1055,60 @@ tree_evaluator::visit_do_until_command (
   if (! expr)
     panic_impossible ();
 
   for (;;)
     {
       tree_statement_list *loop_body = cmd.body ();
 
       if (loop_body)
-	{
-	  loop_body->accept (*this);
+        {
+          loop_body->accept (*this);
 
-	  if (error_state)
+          if (error_state)
             return;
-	}
+        }
 
       if (quit_loop_now ())
-	break;
+        break;
 
       if (debug_mode)
-	do_breakpoint (cmd.is_breakpoint ());
+        do_breakpoint (cmd.is_breakpoint ());
 
       if (expr->is_logically_true ("do-until"))
-	break;
+        break;
     }
 }
 
 void
 tree_evaluator::do_breakpoint (tree_statement& stmt) const
 {
   do_breakpoint (stmt.is_breakpoint (), stmt.is_end_of_fcn_or_script ());
 }
 
 void
 tree_evaluator::do_breakpoint (bool is_breakpoint,
-			       bool is_end_of_fcn_or_script) const
+                               bool is_end_of_fcn_or_script) const
 {
   bool break_on_this_statement = false;
 
   // Don't decrement break flag unless we are in the same frame as we
   // were when we saw the "dbstep N" command.
 
   if (dbstep_flag > 1)
     {
       if (octave_call_stack::current_frame () == current_frame)
-	{
-	  // Don't allow dbstep N to step past end of current frame.
+        {
+          // Don't allow dbstep N to step past end of current frame.
 
-	  if (is_end_of_fcn_or_script)
-	    dbstep_flag = 1;
-	  else
-	    dbstep_flag--;
-	}
+          if (is_end_of_fcn_or_script)
+            dbstep_flag = 1;
+          else
+            dbstep_flag--;
+        }
     }
 
   if (octave_debug_on_interrupt_state)
     {
       break_on_this_statement = true;
 
       octave_debug_on_interrupt_state = false;
 
@@ -1120,42 +1120,42 @@ tree_evaluator::do_breakpoint (bool is_b
 
       dbstep_flag = 0;
 
       current_frame = octave_call_stack::current_frame ();
     }
   else if (dbstep_flag == 1)
     {
       if (octave_call_stack::current_frame () == current_frame)
-	{
-	  // We get here if we are doing a "dbstep" or a "dbstep N"
-	  // and the count has reached 1 and we are in the current
-	  // debugging frame.
+        {
+          // We get here if we are doing a "dbstep" or a "dbstep N"
+          // and the count has reached 1 and we are in the current
+          // debugging frame.
 
-	  break_on_this_statement = true;
+          break_on_this_statement = true;
 
-	  dbstep_flag = 0;
-	}
+          dbstep_flag = 0;
+        }
     }
   else if (dbstep_flag == -1)
     {
       // We get here if we are doing a "dbstep in".
 
       break_on_this_statement = true;
 
       dbstep_flag = 0;
 
       current_frame = octave_call_stack::current_frame ();
     }
   else if (dbstep_flag == -2)
     {
       // We get here if we are doing a "dbstep out".
 
       if (is_end_of_fcn_or_script)
-	dbstep_flag = -1;
+        dbstep_flag = -1;
     }
 
   if (break_on_this_statement)
     do_keyboard ();
 
 }
 
 // ARGS is currently unused, but since the do_keyboard function in
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -48,25 +48,25 @@ tree_try_catch_command::~tree_try_catch_
   delete catch_code;
   delete lead_comm;
   delete mid_comm;
   delete trail_comm;
 }
 
 tree_command *
 tree_try_catch_command::dup (symbol_table::scope_id scope,
-			     symbol_table::context_id context) const
+                             symbol_table::context_id context) const
 {
   return new
     tree_try_catch_command (try_code ? try_code->dup (scope, context) : 0,
-			    catch_code ? catch_code->dup (scope, context) : 0,
-			    lead_comm ? lead_comm->dup () : 0,
-			    mid_comm ? mid_comm->dup () : 0,
-			    trail_comm ? trail_comm->dup () : 0,
-			    line (), column ());
+                            catch_code ? catch_code->dup (scope, context) : 0,
+                            lead_comm ? lead_comm->dup () : 0,
+                            mid_comm ? mid_comm->dup () : 0,
+                            trail_comm ? trail_comm->dup () : 0,
+                            line (), column ());
 }
 
 void
 tree_try_catch_command::accept (tree_walker& tw)
 {
   tw.visit_try_catch_command (*this);
 }
 
@@ -78,17 +78,17 @@ tree_unwind_protect_command::~tree_unwin
   delete cleanup_code;
   delete lead_comm;
   delete mid_comm;
   delete trail_comm;
 }
 
 tree_command *
 tree_unwind_protect_command::dup (symbol_table::scope_id scope,
-				  symbol_table::context_id context) const
+                                  symbol_table::context_id context) const
 {
   return new tree_unwind_protect_command
     (unwind_protect_code ? unwind_protect_code->dup (scope, context) : 0,
      cleanup_code ? cleanup_code->dup (scope, context) : 0,
      lead_comm ? lead_comm->dup () : 0,
      mid_comm ? mid_comm->dup () : 0,
      trail_comm ? trail_comm->dup () : 0,
      line (), column ());
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -41,20 +41,20 @@ tree_expression::is_logically_true (cons
 {
   bool expr_value = false;
 
   octave_value t1 = rvalue1 ();
 
   if (! error_state)
     {
       if (t1.is_defined ())
-	return t1.is_true ();
+        return t1.is_true ();
       else
-	::error ("%s: undefined value used in conditional expression",
-		 warn_for);
+        ::error ("%s: undefined value used in conditional expression",
+                 warn_for);
     }
 
   return expr_value;
 }
 
 octave_value
 tree_expression::rvalue1 (int)
 {
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -32,24 +32,24 @@ along with Octave; see the file COPYING.
 #include "pt-fcn-handle.h"
 #include "pager.h"
 #include "pt-const.h"
 #include "pt-walk.h"
 #include "variables.h"
 
 void
 tree_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax,
-			bool pr_orig_text)
+                        bool pr_orig_text)
 {
   print_raw (os, pr_as_read_syntax, pr_orig_text);
 }
 
 void
 tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
-			    bool pr_orig_text) 
+                            bool pr_orig_text) 
 {
   os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
 }
 
 octave_value
 tree_fcn_handle::rvalue1 (int)
 {
   return make_fcn_handle (nm);
@@ -65,17 +65,17 @@ tree_fcn_handle::rvalue (int nargout)
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 tree_expression *
 tree_fcn_handle::dup (symbol_table::scope_id,
-		      symbol_table::context_id) const
+                      symbol_table::context_id) const
 {
   tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
 
   new_fh->copy_base (*this);
 
   return new_fh;
 }
 
@@ -95,35 +95,35 @@ tree_anon_fcn_handle::rvalue1 (int)
   tree_parameter_list *ret_list = return_list ();
   tree_statement_list *cmd_list = body ();
   symbol_table::scope_id this_scope = scope ();
 
   symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
 
   if (new_scope > 0)
     symbol_table::inherit (new_scope, symbol_table::current_scope (),
-			   symbol_table::current_context ());
+                           symbol_table::current_context ());
 
   octave_user_function *uf
     = new octave_user_function (new_scope,
-				param_list ? param_list->dup (new_scope, 0) : 0,
-				ret_list ? ret_list->dup (new_scope, 0) : 0,
-				cmd_list ? cmd_list->dup (new_scope, 0) : 0);
+                                param_list ? param_list->dup (new_scope, 0) : 0,
+                                ret_list ? ret_list->dup (new_scope, 0) : 0,
+                                cmd_list ? cmd_list->dup (new_scope, 0) : 0);
 
   octave_function *curr_fcn = octave_call_stack::current ();
 
   if (curr_fcn)
     {
       uf->stash_parent_fcn_name (curr_fcn->name ());
 
       symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
 
       if (parent_scope < 0)
-	parent_scope = curr_fcn->scope ();
-	
+        parent_scope = curr_fcn->scope ();
+        
       uf->stash_parent_fcn_scope (parent_scope);
     }
 
   uf->mark_as_inline_function ();
 
   octave_value ov_fcn (uf);
 
   octave_value fh (new octave_fcn_handle (ov_fcn, octave_fcn_handle::anonymous));
@@ -160,34 +160,34 @@ tree_anon_fcn_handle::rvalue (int nargou
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 tree_expression *
 tree_anon_fcn_handle::dup (symbol_table::scope_id,
-			   symbol_table::context_id) const
+                           symbol_table::context_id) const
 {
   tree_parameter_list *param_list = parameter_list ();
   tree_parameter_list *ret_list = return_list ();
   tree_statement_list *cmd_list = body ();
   symbol_table::scope_id this_scope = scope ();
 
   symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
 
   if (new_scope > 0)
     symbol_table::inherit (new_scope, symbol_table::current_scope (),
-			   symbol_table::current_context ());
+                           symbol_table::current_context ());
 
   tree_anon_fcn_handle *new_afh = new
     tree_anon_fcn_handle (param_list ? param_list->dup (new_scope, 0) : 0,
-			  ret_list ? ret_list->dup (new_scope, 0) : 0,
-			  cmd_list ? cmd_list->dup (new_scope, 0) : 0,
-			  new_scope, line (), column ());
+                          ret_list ? ret_list->dup (new_scope, 0) : 0,
+                          cmd_list ? cmd_list->dup (new_scope, 0) : 0,
+                          new_scope, line (), column ());
 
   new_afh->copy_base (*this);
 
   return new_afh;
 }
 
 void
 tree_anon_fcn_handle::accept (tree_walker& tw)
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -44,17 +44,17 @@ tree_identifier::eval_undefined_error (v
 {
   int l = line ();
   int c = column ();
 
   if (l == -1 && c == -1)
     ::error ("`%s' undefined", name ().c_str ());
   else
     ::error ("`%s' undefined near line %d column %d",
-	     name ().c_str (), l, c);
+             name ().c_str (), l, c);
 }
 
 octave_value_list
 tree_identifier::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (error_state)
@@ -71,28 +71,28 @@ tree_identifier::rvalue (int nargout)
       // whether it is indexed so that we can do the same thing
       // for `f' and `f()'.  If the index is present, return the
       // function object and let tree_index_expression::rvalue
       // handle indexing.  Otherwise, arrange to call the function
       // here, so that we don't return the function definition as
       // a value.
 
       if (val.is_function () && ! is_postfix_indexed ())
-	{
-	  octave_value_list tmp_args;
+        {
+          octave_value_list tmp_args;
 
-	  retval = val.do_multi_index_op (nargout, tmp_args);
-	}
+          retval = val.do_multi_index_op (nargout, tmp_args);
+        }
       else
-	{
-	  if (print_result () && nargout == 0)
-	    val.print_with_name (octave_stdout, name ());
+        {
+          if (print_result () && nargout == 0)
+            val.print_with_name (octave_stdout, name ());
 
-	  retval = val;
-	}
+          retval = val;
+        }
     }
   else
     eval_undefined_error ();
 
   return retval;
 }
 
 octave_value
@@ -111,17 +111,17 @@ tree_identifier::rvalue1 (int nargout)
 octave_lvalue
 tree_identifier::lvalue (void)
 {
   return octave_lvalue (&(xsym().varref ()));
 }
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
-		      symbol_table::context_id) const
+                      symbol_table::context_id) const
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
 
   // FIXME -- is this the best way?
   symbol_table::symbol_record new_sym
     = symbol_table::find_symbol (name (), sc);
 
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -43,36 +43,36 @@ along with Octave; see the file COPYING.
 
 // Index expressions.
 
 tree_index_expression::tree_index_expression (int l, int c)
   : tree_expression (l, c), expr (0), args (0), type (),
     arg_nm (), dyn_field () { }
 
 tree_index_expression::tree_index_expression (tree_expression *e,
-					      tree_argument_list *lst,
-					      int l, int c, char t)
+                                              tree_argument_list *lst,
+                                              int l, int c, char t)
   : tree_expression (l, c), expr (e), args (0), type (),
     arg_nm (), dyn_field ()
 {
   append (lst, t);
 }
 
 tree_index_expression::tree_index_expression (tree_expression *e,
-					      const std::string& n,
-					      int l, int c)
+                                              const std::string& n,
+                                              int l, int c)
   : tree_expression (l, c), expr (e), args (0), type (),
     arg_nm (), dyn_field ()
 {
   append (n);
 }
 
 tree_index_expression::tree_index_expression (tree_expression *e,
-					      tree_expression *df,
-					      int l, int c)
+                                              tree_expression *df,
+                                              int l, int c)
   : tree_expression (l, c), expr (e), args (0), type (),
     arg_nm (), dyn_field ()
 {
   append (df);
 }
 
 void
 tree_index_expression::append (tree_argument_list *lst, char t)
@@ -121,17 +121,17 @@ tree_index_expression::has_magic_end (vo
 {
   for (std::list<tree_argument_list *>::const_iterator p = args.begin ();
        p != args.end ();
        p++)
     {
       tree_argument_list *elt = *p;
 
       if (elt && elt->has_magic_end ())
-	return true;
+        return true;
     }
   
   return false;
 }
 
 // This is useful for printing the name of the variable in an indexed
 // assignment.
 
@@ -151,49 +151,49 @@ make_subs_cell (tree_argument_list *args
   if (args)
     arg_values = args->convert_to_const_vector ();
 
   if (! error_state)
     {
       int n = arg_values.length ();
 
       if (n > 0)
-	{
-	  arg_values.stash_name_tags (arg_nm);
+        {
+          arg_values.stash_name_tags (arg_nm);
 
-	  retval.resize (dim_vector (1, n));
+          retval.resize (dim_vector (1, n));
 
-	  for (int i = 0; i < n; i++)
-	    retval(0,i) = arg_values(i);
-	}
+          for (int i = 0; i < n; i++)
+            retval(0,i) = arg_values(i);
+        }
     }
 
   return retval;
 }
 
 static inline octave_value_list
 make_value_list (tree_argument_list *args, const string_vector& arg_nm,
-		 const octave_value *object)
+                 const octave_value *object)
 {
   octave_value_list retval;
 
   if (args)
     {
       if (object && args->has_magic_end () && object->is_undefined ())
         gripe_invalid_inquiry_subscript ();
       else
         retval = args->convert_to_const_vector (object);
     }
 
   if (! error_state)
     {
       int n = retval.length ();
 
       if (n > 0)
-	retval.stash_name_tags (arg_nm);
+        retval.stash_name_tags (arg_nm);
     }
 
   return retval;
 }
 
 std::string
 tree_index_expression::get_struct_index
   (std::list<string_vector>::const_iterator p_arg_nm,
@@ -201,29 +201,29 @@ tree_index_expression::get_struct_index
 {
   std::string fn = (*p_arg_nm)(0);
 
   if (fn.empty ())
     {
       tree_expression *df = *p_dyn_field;
 
       if (df)
-	{
-	  octave_value t = df->rvalue1 ();
+        {
+          octave_value t = df->rvalue1 ();
 
-	  if (! error_state)
-	    {
-	      fn = t.string_value ();
+          if (! error_state)
+            {
+              fn = t.string_value ();
 
-	      if (! valid_identifier (fn))
-		::error ("invalid structure field name `%s'", fn.c_str ());
-	    }
-	}
+              if (! valid_identifier (fn))
+                ::error ("invalid structure field name `%s'", fn.c_str ());
+            }
+        }
       else
-	panic_impossible ();
+        panic_impossible ();
     }
 
   return fn;
 }
 
 Octave_map
 tree_index_expression::make_arg_struct (void) const
 {
@@ -236,35 +236,35 @@ tree_index_expression::make_arg_struct (
   std::list<string_vector>::const_iterator p_arg_nm = arg_nm.begin ();
   std::list<tree_expression *>::const_iterator p_dyn_field = dyn_field.begin ();
 
   Octave_map m;
 
   for (int i = 0; i < n; i++)
     {
       switch (type[i])
-	{
-	case '(':
-	  subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
-	  break;
+        {
+        case '(':
+          subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
+          break;
 
-	case '{':
-	  subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
-	  break;
+        case '{':
+          subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
+          break;
 
-	case '.':
-	  subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
-	  break;
+        case '.':
+          subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
 
       if (error_state)
-	return m;
+        return m;
 
       p_args++;
       p_arg_nm++;
       p_dyn_field++;
     }
 
   m.assign ("type", type_field);
   m.assign ("subs", subs_field);
@@ -286,124 +286,124 @@ tree_index_expression::rvalue (int nargo
 
   bool have_args = false;
 
   if (expr->is_identifier () && type[0] == '(')
     {
       tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
       if (! (id->is_variable () || args.empty ()))
-	{
-	  tree_argument_list *al = *(args.begin ());
+        {
+          tree_argument_list *al = *(args.begin ());
 
-	  size_t n = al ? al->length () : 0;
+          size_t n = al ? al->length () : 0;
 
-	  if (n > 0)
-	    {
-	      string_vector anm = *(arg_nm.begin ());
+          if (n > 0)
+            {
+              string_vector anm = *(arg_nm.begin ());
               have_args = true;
               first_args = al -> convert_to_const_vector ();
               first_args.stash_name_tags (anm);
 
               if (! error_state)
                 first_expr_val = id->do_lookup  (first_args);
-	    }
-	}
+            }
+        }
     }
 
   if (! error_state)
     {
       if (first_expr_val.is_undefined ())
-	first_expr_val = expr->rvalue1 ();
+        first_expr_val = expr->rvalue1 ();
 
       octave_value tmp = first_expr_val;
       octave_idx_type tmpi = 0;
 
       std::list<octave_value_list> idx;
 
       int n = args.size ();
 
       std::list<tree_argument_list *>::iterator p_args = args.begin ();
       std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
       std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
       for (int i = 0; i < n; i++)
-	{
-	  if (i > 0)
-	    {
-	      tree_argument_list *al = *p_args;
+        {
+          if (i > 0)
+            {
+              tree_argument_list *al = *p_args;
 
               // In Matlab, () can only be followed by . In Octave, we do not
               // enforce this for rvalue expressions, but we'll split the
               // evaluation at this point. This will, hopefully, allow Octave's
               // looser rules apply smoothly for Matlab overloaded subsref
               // codes.
               bool force_split = type[i-1] == '(' && type[i] != '.';
 
-	      if (force_split || (al && al->has_magic_end ()))
-		{
-		  // We have an expression like
-		  //
-		  //   x{end}.a(end)
-		  //
-		  // and we are looking at the argument list that
-		  // contains the second (or third, etc.) "end" token,
-		  // so we must evaluate everything up to the point of
-		  // that argument list so we can pass the appropriate
-		  // value to the built-in __end__ function.
+              if (force_split || (al && al->has_magic_end ()))
+                {
+                  // We have an expression like
+                  //
+                  //   x{end}.a(end)
+                  //
+                  // and we are looking at the argument list that
+                  // contains the second (or third, etc.) "end" token,
+                  // so we must evaluate everything up to the point of
+                  // that argument list so we can pass the appropriate
+                  // value to the built-in __end__ function.
 
-		  const octave_value_list tmp_list
-		    = tmp.subsref (type.substr (tmpi, i - tmpi), idx, nargout);
+                  const octave_value_list tmp_list
+                    = tmp.subsref (type.substr (tmpi, i - tmpi), idx, nargout);
 
-		  tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
+                  tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
                   tmpi = i;
                   idx.clear ();
                   
                   if (tmp.is_cs_list ())
                     gripe_indexed_cs_list ();
 
-		  if (error_state)
-		    break;
-		}
-	    }
+                  if (error_state)
+                    break;
+                }
+            }
 
-	  switch (type[i])
-	    {
-	    case '(':
-	      if (have_args)
-		{
-		  idx.push_back (first_args);
-		  have_args = false;
-		}
-	      else
-		idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-	      break;
+          switch (type[i])
+            {
+            case '(':
+              if (have_args)
+                {
+                  idx.push_back (first_args);
+                  have_args = false;
+                }
+              else
+                idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
+              break;
 
-	    case '{':
-	      idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
-	      break;
+            case '{':
+              idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
+              break;
 
-	    case '.':
-	      idx.push_back (octave_value (get_struct_index (p_arg_nm, p_dyn_field)));
-	      break;
+            case '.':
+              idx.push_back (octave_value (get_struct_index (p_arg_nm, p_dyn_field)));
+              break;
 
-	    default:
-	      panic_impossible ();
-	    }
+            default:
+              panic_impossible ();
+            }
 
-	  if (error_state)
-	    break;
+          if (error_state)
+            break;
 
-	  p_args++;
-	  p_arg_nm++;
-	  p_dyn_field++;
-	}
+          p_args++;
+          p_arg_nm++;
+          p_dyn_field++;
+        }
 
       if (! error_state)
-	retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout);
+        retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout);
     }
 
   return retval;
 }
 
 octave_value
 tree_index_expression::rvalue1 (int nargout)
 {
@@ -435,37 +435,37 @@ tree_index_expression::lvalue (void)
 
   if (! error_state)
     {
       const octave_value *tro = retval.object ();
 
       octave_value tmp;
 
       if (tro)
-	tmp = *tro;
+        tmp = *tro;
 
       octave_idx_type tmpi = 0;
       std::list<octave_value_list> tmpidx;
 
       for (int i = 0; i < n; i++)
-	{
+        {
           if (retval.numel () != 1)
             gripe_indexed_cs_list ();
           else if (tmpi < i)
             {
               tmp = tmp.subsref (type.substr (tmpi, i - tmpi), tmpidx, true);
               tmpidx.clear ();
             }
 
           if (error_state)
             break;
 
-	  switch (type[i])
-	    {
-	    case '(':
+          switch (type[i])
+            {
+            case '(':
               {
                 octave_value_list tidx
                   = make_value_list (*p_args, *p_arg_nm, &tmp);
 
                 idx.push_back (tidx);
 
                 if (i < n - 1)
                   {
@@ -475,20 +475,20 @@ tree_index_expression::lvalue (void)
                         tmpi = i+1;
                       }
                     else
                       error ("() must be followed by . or close the index chain");
                   }
               }
               break;
 
-	    case '{':
-	      {
-		octave_value_list tidx
-		  = make_value_list (*p_args, *p_arg_nm, &tmp);
+            case '{':
+              {
+                octave_value_list tidx
+                  = make_value_list (*p_args, *p_arg_nm, &tmp);
 
                 if (tmp.is_undefined ())
                   {
                     if (tidx.has_magic_colon ())
                       gripe_invalid_inquiry_subscript ();
                     else
                       tmp = Cell ();
                   }
@@ -498,25 +498,25 @@ tree_index_expression::lvalue (void)
                     tmp = Cell ();
                   }
 
                 retval.numel (tmp.numel (tidx));
 
                 if (error_state)
                   break;
 
-		idx.push_back (tidx);
+                idx.push_back (tidx);
                 tmpidx.push_back (tidx);
                 tmpi = i;
-	      }
-	      break;
+              }
+              break;
 
-	    case '.':
-	      {
-		octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
+            case '.':
+              {
+                octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
                 if (error_state)
                   break;
 
                 bool autoconv = (tmp.is_zero_by_zero () 
                                  && (tmp.is_matrix_type () || tmp.is_string ()
                                      || tmp.is_cell ()));
 
                 if (i > 0 && type [i-1] == '(')
@@ -553,36 +553,36 @@ tree_index_expression::lvalue (void)
                         tmpidx.push_back (tidx);
                       }
                   }
 
                 if (error_state)
                   break;
 
                 idx.push_back (tidx);
-	      }
-	      break;
+              }
+              break;
 
-	    default:
-	      panic_impossible ();
-	    }
+            default:
+              panic_impossible ();
+            }
 
           if (idx.back ().empty ())
             error ("invalid empty index list");
 
-	  if (error_state)
-	    break;
+          if (error_state)
+            break;
 
-	  p_args++;
-	  p_arg_nm++;
-	  p_dyn_field++;
-	}
+          p_args++;
+          p_arg_nm++;
+          p_dyn_field++;
+        }
 
       if (! error_state)
-	retval.set_index (type, idx);
+        retval.set_index (type, idx);
 
     }
 
   return retval;
 }
 
 /*
 %!test
@@ -606,17 +606,17 @@ tree_index_expression::lvalue (void)
 %!test
 %! x = struct (zeros (0, 1), {"a", "b"});
 %! x(2).b = 1;
 %! assert (x(2).b == 1);
 */
 
 tree_index_expression *
 tree_index_expression::dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const
+                            symbol_table::context_id context) const
 {
   tree_index_expression *new_idx_expr
     = new tree_index_expression (line (), column ());
 
   new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
 
   std::list<tree_argument_list *> new_args;
 
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -35,17 +35,17 @@ class octave_value_list;
 
 // Break.
 
 // Nonzero means we're breaking out of a loop or function body.
 int tree_break_command::breaking = 0;
 
 tree_command *
 tree_break_command::dup (symbol_table::scope_id,
-			 symbol_table::context_id) const
+                         symbol_table::context_id) const
 {
   return new tree_break_command (line (), column ());
 }
 
 void
 tree_break_command::accept (tree_walker& tw)
 {
   tw.visit_break_command (*this);
@@ -53,17 +53,17 @@ tree_break_command::accept (tree_walker&
 
 // Continue.
 
 // Nonzero means we're jumping to the end of a loop.
 int tree_continue_command::continuing = 0;
 
 tree_command *
 tree_continue_command::dup (symbol_table::scope_id,
-			    symbol_table::context_id) const
+                            symbol_table::context_id) const
 {
   return new tree_continue_command (line (), column ());
 }
 
 void
 tree_continue_command::accept (tree_walker& tw)
 {
   tw.visit_continue_command (*this);
@@ -71,17 +71,17 @@ tree_continue_command::accept (tree_walk
 
 // Return.
 
 // Nonzero means we're returning from a function.
 int tree_return_command::returning = 0;
 
 tree_command *
 tree_return_command::dup (symbol_table::scope_id,
-			  symbol_table::context_id) const
+                          symbol_table::context_id) const
 {
   return new tree_return_command (line (), column ());
 }
 
 void
 tree_return_command::accept (tree_walker& tw)
 {
   tw.visit_return_command (*this);
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -49,42 +49,42 @@ tree_while_command::~tree_while_command 
   delete expr;
   delete list;
   delete lead_comm;
   delete trail_comm;
 }
 
 tree_command *
 tree_while_command::dup (symbol_table::scope_id scope,
-			 symbol_table::context_id context) const
+                         symbol_table::context_id context) const
 {
   return new tree_while_command (expr ? expr->dup (scope, context) : 0,
-				 list ? list->dup (scope, context) : 0,
-				 lead_comm ? lead_comm->dup () : 0,
-				 trail_comm ? trail_comm->dup (): 0,
-				 line (), column ());
+                                 list ? list->dup (scope, context) : 0,
+                                 lead_comm ? lead_comm->dup () : 0,
+                                 trail_comm ? trail_comm->dup (): 0,
+                                 line (), column ());
 }
 
 void
 tree_while_command::accept (tree_walker& tw)
 {
   tw.visit_while_command (*this);
 }
 
 // Do-Until
 
 tree_command *
 tree_do_until_command::dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const
+                            symbol_table::context_id context) const
 {
   return new tree_do_until_command (expr ? expr->dup (scope, context) : 0,
-				    list ? list->dup (scope, context) : 0,
-				    lead_comm ? lead_comm->dup () : 0,
-				    trail_comm ? trail_comm->dup (): 0,
-				    line (), column ());
+                                    list ? list->dup (scope, context) : 0,
+                                    lead_comm ? lead_comm->dup () : 0,
+                                    trail_comm ? trail_comm->dup (): 0,
+                                    line (), column ());
 }
 
 void
 tree_do_until_command::accept (tree_walker& tw)
 {
   tw.visit_do_until_command (*this);
 }
 
@@ -95,24 +95,24 @@ tree_simple_for_command::~tree_simple_fo
   delete expr;
   delete list;
   delete lead_comm;
   delete trail_comm;
 }
 
 tree_command *
 tree_simple_for_command::dup (symbol_table::scope_id scope,
-			      symbol_table::context_id context) const
+                              symbol_table::context_id context) const
 {
   return new tree_simple_for_command (lhs ? lhs->dup (scope, context) : 0,
-				      expr ? expr->dup (scope, context) : 0,
-				      list ? list->dup (scope, context) : 0,
-				      lead_comm ? lead_comm->dup () : 0,
-				      trail_comm ? trail_comm->dup () : 0,
-				      line (), column ());
+                                      expr ? expr->dup (scope, context) : 0,
+                                      list ? list->dup (scope, context) : 0,
+                                      lead_comm ? lead_comm->dup () : 0,
+                                      trail_comm ? trail_comm->dup () : 0,
+                                      line (), column ());
 }
 
 void
 tree_simple_for_command::accept (tree_walker& tw)
 {
   tw.visit_simple_for_command (*this);
 }
 
@@ -121,23 +121,23 @@ tree_complex_for_command::~tree_complex_
   delete expr;
   delete list;
   delete lead_comm;
   delete trail_comm;
 }
 
 tree_command *
 tree_complex_for_command::dup (symbol_table::scope_id scope,
-			       symbol_table::context_id context) const
+                               symbol_table::context_id context) const
 {
   return new tree_complex_for_command (lhs ? lhs->dup (scope, context) : 0,
-				       expr ? expr->dup (scope, context) : 0,
-				       list ? list->dup (scope, context) : 0,
-				       lead_comm ? lead_comm->dup () : 0,
-				       trail_comm ? trail_comm->dup () : 0,
-				       line (), column ());
+                                       expr ? expr->dup (scope, context) : 0,
+                                       list ? list->dup (scope, context) : 0,
+                                       lead_comm ? lead_comm->dup () : 0,
+                                       trail_comm ? trail_comm->dup () : 0,
+                                       line (), column ());
 }
 
 void
 tree_complex_for_command::accept (tree_walker& tw)
 {
   tw.visit_complex_for_command (*this);
 }
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -62,27 +62,27 @@ private:
 
   class
   tm_row_const_rep : public octave_base_list<octave_value>
   {
   public:
 
     tm_row_const_rep (void)
       : count (1), dv (0, 0), all_str (false),
-	all_sq_str (false), all_dq_str (false),
-	some_str (false), all_real (false), all_cmplx (false),
-	all_mt (true), any_sparse (false), any_class (false),
-	class_nm (), ok (false)
+        all_sq_str (false), all_dq_str (false),
+        some_str (false), all_real (false), all_cmplx (false),
+        all_mt (true), any_sparse (false), any_class (false),
+        class_nm (), ok (false)
     { }
 
     tm_row_const_rep (const tree_argument_list& row)
       : count (1), dv (0, 0), all_str (false), all_sq_str (false),
-	some_str (false), all_real (false), all_cmplx (false),
-	all_mt (true), any_sparse (false), any_class (false),
-	class_nm (), ok (false)
+        some_str (false), all_real (false), all_cmplx (false),
+        all_mt (true), any_sparse (false), any_class (false),
+        class_nm (), ok (false)
     { init (row); }
 
     ~tm_row_const_rep (void) { }
 
     int count;
 
     dim_vector dv;
 
@@ -106,17 +106,17 @@ private:
 
   private:
 
     tm_row_const_rep (const tm_row_const_rep&);
 
     tm_row_const_rep& operator = (const tm_row_const_rep&);
 
     void eval_error (const char *msg, int l, int c,
-		     int x = -1, int y = -1) const;
+                     int x = -1, int y = -1) const;
 
     void eval_warning (const char *msg, int l, int c) const;
   };
 
 public:
 
   typedef tm_row_const_rep::iterator iterator;
   typedef tm_row_const_rep::const_iterator const_iterator;
@@ -133,23 +133,23 @@ public:
     if (rep)
       rep->count++;
   }
 
   tm_row_const& operator = (const tm_row_const& x)
   {
     if (this != &x && rep != x.rep)
       {
-	if (rep && --rep->count == 0)
-	  delete rep;
+        if (rep && --rep->count == 0)
+          delete rep;
 
-	rep = x.rep;
+        rep = x.rep;
 
-	if (rep)
-	  rep->count++;
+        if (rep)
+          rep->count++;
       }
 
     return *this;
   }
 
   ~tm_row_const (void)
   {
     if (rep && --rep->count == 0)
@@ -199,142 +199,142 @@ get_concat_class (const std::string& c1,
     retval = c1;
   else if (c1.empty ())
     retval = c2;
   else if (c2.empty ())
     retval = c1;
   else
     {
       bool c1_is_int = (c1 == "int8" || c1 == "uint8"
-			|| c1 == "int16" || c1 == "uint16"
-			|| c1 == "int32" || c1 == "uint32"
-			|| c1 == "int64" || c1 == "uint64");
+                        || c1 == "int16" || c1 == "uint16"
+                        || c1 == "int32" || c1 == "uint32"
+                        || c1 == "int64" || c1 == "uint64");
       bool c2_is_int = (c2 == "int8" || c2 == "uint8"
-			|| c2 == "int16" || c2 == "uint16"
-			|| c2 == "int32" || c2 == "uint32"
-			|| c2 == "int64" || c2 == "uint64");
+                        || c2 == "int16" || c2 == "uint16"
+                        || c2 == "int32" || c2 == "uint32"
+                        || c2 == "int64" || c2 == "uint64");
 
       bool c1_is_char = (c1 == "char");
       bool c2_is_char = (c2 == "char");
 
       bool c1_is_double = (c1 == "double");
       bool c2_is_double = (c2 == "double");
 
       bool c1_is_single = (c1 == "single");
       bool c2_is_single = (c2 == "single");
 
       bool c1_is_logical = (c1 == "logical");
       bool c2_is_logical = (c2 == "logical");
 
       bool c1_is_built_in_type
-	= (c1_is_int || c1_is_char || c1_is_double || c1_is_single
-	   || c1_is_logical);
+        = (c1_is_int || c1_is_char || c1_is_double || c1_is_single
+           || c1_is_logical);
 
       bool c2_is_built_in_type
-	= (c2_is_int || c2_is_char ||  c2_is_double || c2_is_single
-	   || c2_is_logical);
+        = (c2_is_int || c2_is_char ||  c2_is_double || c2_is_single
+           || c2_is_logical);
 
       // Order is important here...
 
       if (c1_is_char && c2_is_built_in_type)
-	retval = c1;
+        retval = c1;
       else if (c2_is_char && c1_is_built_in_type)
-	retval = c2;
+        retval = c2;
       else if (c1_is_int && c2_is_built_in_type)
-	retval = c1;
+        retval = c1;
       else if (c2_is_int && c1_is_built_in_type)
-	retval = c2;
+        retval = c2;
       else if (c1_is_single && c2_is_built_in_type)
-	retval = c1;
+        retval = c1;
       else if (c2_is_single && c1_is_built_in_type)
-	retval = c2;
+        retval = c2;
       else if (c1_is_double && c2_is_built_in_type)
-	retval = c1;
+        retval = c1;
       else if (c2_is_double && c1_is_built_in_type)
-	retval = c2;
+        retval = c2;
       else if (c1_is_logical && c2_is_logical)
-	retval = c1;
+        retval = c1;
     }
 
   return retval;    
 }
 
 bool
 tm_row_const::tm_row_const_rep::do_init_element (tree_expression *elt,
-						 const octave_value& val,
-						 bool& first_elem)
+                                                 const octave_value& val,
+                                                 bool& first_elem)
 {
   octave_idx_type this_elt_nr = val.rows ();
   octave_idx_type this_elt_nc = val.columns ();
 
   std::string this_elt_class_nm = val.class_name ();
 
   dim_vector this_elt_dv = val.dims ();
 
   class_nm = get_concat_class (class_nm, this_elt_class_nm);
 
 
   if (! this_elt_dv.all_zero ())
     {
       all_mt = false;
 
       if (first_elem)
-	{
-	  first_elem = false;
+        {
+          first_elem = false;
 
-	  dv.resize (this_elt_dv.length ());
-	  for (int i = 2; i < dv.length (); i++)
-	    dv.elem (i) = this_elt_dv.elem (i);
+          dv.resize (this_elt_dv.length ());
+          for (int i = 2; i < dv.length (); i++)
+            dv.elem (i) = this_elt_dv.elem (i);
 
-	  dv.elem (0) = this_elt_nr;
+          dv.elem (0) = this_elt_nr;
 
-	  dv.elem (1) = 0;
-	}
+          dv.elem (1) = 0;
+        }
       else
-	{
-	  int len = (this_elt_dv.length () < dv.length ()
-		     ? this_elt_dv.length () : dv.length ());
+        {
+          int len = (this_elt_dv.length () < dv.length ()
+                     ? this_elt_dv.length () : dv.length ());
 
-	  if (this_elt_nr != dv (0))
-	    {
-	      eval_error ("number of rows must match",
-			  elt->line (), elt->column (), this_elt_nr, dv (0));
-	      return false;
-	    }
-	  for (int i = 2; i < len; i++)
-	    {
-	      if (this_elt_dv (i) != dv (i))
-		{
-		  eval_error ("dimensions mismatch", elt->line (), elt->column (), this_elt_dv (i), dv (i));
-		  return false;
-		}
-	    }
+          if (this_elt_nr != dv (0))
+            {
+              eval_error ("number of rows must match",
+                          elt->line (), elt->column (), this_elt_nr, dv (0));
+              return false;
+            }
+          for (int i = 2; i < len; i++)
+            {
+              if (this_elt_dv (i) != dv (i))
+                {
+                  eval_error ("dimensions mismatch", elt->line (), elt->column (), this_elt_dv (i), dv (i));
+                  return false;
+                }
+            }
 
-	  if (this_elt_dv.length () > len)
-	    for (int i = len; i < this_elt_dv.length (); i++)
-	      if (this_elt_dv (i) != 1)
-		{
-		  eval_error ("dimensions mismatch", elt->line (), elt->column (), this_elt_dv (i), 1);
-		  return false;
-		}
+          if (this_elt_dv.length () > len)
+            for (int i = len; i < this_elt_dv.length (); i++)
+              if (this_elt_dv (i) != 1)
+                {
+                  eval_error ("dimensions mismatch", elt->line (), elt->column (), this_elt_dv (i), 1);
+                  return false;
+                }
 
-	  if (dv.length () > len)
-	    for (int i = len; i < dv.length (); i++)
-	      if (dv (i) != 1)
-		{
-		  eval_error ("dimensions mismatch", elt->line (), elt->column (), 1, dv (i));
-		  return false;
-		}
-	}
+          if (dv.length () > len)
+            for (int i = len; i < dv.length (); i++)
+              if (dv (i) != 1)
+                {
+                  eval_error ("dimensions mismatch", elt->line (), elt->column (), 1, dv (i));
+                  return false;
+                }
+        }
       dv.elem (1) = dv.elem (1) + this_elt_nc;
 
     }
   else
     eval_warning ("empty matrix found in matrix list",
-		  elt->line (), elt->column ());
+                  elt->line (), elt->column ());
 
   append (val);
 
   if (all_str && ! val.is_string ())
     all_str = false;
 
   if (all_sq_str && ! val.is_sq_string ())
     all_sq_str = false;
@@ -379,73 +379,73 @@ tm_row_const::tm_row_const_rep::init (co
     {
       octave_quit ();
 
       tree_expression *elt = *p;
 
       octave_value tmp = elt->rvalue1 ();
 
       if (error_state || tmp.is_undefined ())
-	break;
+        break;
       else
-	{
-	  if (tmp.is_cs_list ())
-	    {
-	      octave_value_list tlst = tmp.list_value ();
+        {
+          if (tmp.is_cs_list ())
+            {
+              octave_value_list tlst = tmp.list_value ();
 
-	      for (octave_idx_type i = 0; i < tlst.length (); i++)
-		{
-		  octave_quit ();
+              for (octave_idx_type i = 0; i < tlst.length (); i++)
+                {
+                  octave_quit ();
 
-		  if (! do_init_element (elt, tlst(i), first_elem))
-		    goto done;
-		}
-	    }
-	  else
-	    {
-	      if (! do_init_element (elt, tmp, first_elem))
-		goto done;
-	    }
-	}
+                  if (! do_init_element (elt, tlst(i), first_elem))
+                    goto done;
+                }
+            }
+          else
+            {
+              if (! do_init_element (elt, tmp, first_elem))
+                goto done;
+            }
+        }
     }
 
  done:
 
   ok = ! error_state;
 }
 
 void
 tm_row_const::tm_row_const_rep::eval_error (const char *msg, int l,
-					    int c, int x, int y) const
+                                            int c, int x, int y) const
 {
   if (l == -1 && c == -1)
     {
       if (x == -1 || y == -1)
-	::error ("%s", msg);
+        ::error ("%s", msg);
       else
-	::error ("%s (%d != %d)", msg, x, y);
+        ::error ("%s (%d != %d)", msg, x, y);
     }
   else
     {
       if (x == -1 || y == -1)
-	::error ("%s near line %d, column %d", msg, l, c);
+        ::error ("%s near line %d, column %d", msg, l, c);
       else
-	::error ("%s (%d != %d) near line %d, column %d", msg, x, y, l, c);
+        ::error ("%s (%d != %d) near line %d, column %d", msg, x, y, l, c);
     }
 }
 
 void
 tm_row_const::tm_row_const_rep::eval_warning (const char *msg, int l,
-					      int c) const
+                                              int c) const
 {
   if (l == -1 && c == -1)
     warning_with_id ("Octave:empty-list-elements", "%s", msg);
   else
     warning_with_id ("Octave:empty-list-elements",
-		     "%s near line %d, column %d", msg, l, c);
+                     "%s near line %d, column %d", msg, l, c);
 }
 
 class
 tm_const : public octave_base_list<tm_row_const>
 {
 public:
 
   tm_const (const tree_matrix& tm)
@@ -525,142 +525,142 @@ tm_const::init (const tree_matrix& tm)
     {
       octave_quit ();
 
       tree_argument_list *elt = *p;
 
       tm_row_const tmp (*elt);
 
       if (tmp && ! tmp.empty ())
-	{
-	  if (all_str && ! tmp.all_strings_p ())
-	    all_str = false;
+        {
+          if (all_str && ! tmp.all_strings_p ())
+            all_str = false;
 
-	  if (all_sq_str && ! tmp.all_sq_strings_p ())
-	    all_sq_str = false;
+          if (all_sq_str && ! tmp.all_sq_strings_p ())
+            all_sq_str = false;
 
-	  if (all_dq_str && ! tmp.all_dq_strings_p ())
-	    all_dq_str = false;
+          if (all_dq_str && ! tmp.all_dq_strings_p ())
+            all_dq_str = false;
 
-	  if (! some_str && tmp.some_strings_p ())
-	    some_str = true;
+          if (! some_str && tmp.some_strings_p ())
+            some_str = true;
 
-	  if (all_real && ! tmp.all_real_p ())
-	    all_real = false;
+          if (all_real && ! tmp.all_real_p ())
+            all_real = false;
 
-	  if (all_cmplx && ! tmp.all_complex_p ())
-	    all_cmplx = false;
+          if (all_cmplx && ! tmp.all_complex_p ())
+            all_cmplx = false;
 
-	  if (all_mt && ! tmp.all_empty_p ())
-	    all_mt = false;
+          if (all_mt && ! tmp.all_empty_p ())
+            all_mt = false;
 
-	  if (!any_sparse && tmp.any_sparse_p ())
-	    any_sparse = true;
+          if (!any_sparse && tmp.any_sparse_p ())
+            any_sparse = true;
 
-	  if (!any_class && tmp.any_class_p ())
-	    any_class = true;
+          if (!any_class && tmp.any_class_p ())
+            any_class = true;
 
-	  append (tmp);
-	}
+          append (tmp);
+        }
       else
-	break;
+        break;
     }
 
   if (! error_state)
     {
       for (iterator p = begin (); p != end (); p++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  tm_row_const elt = *p;
+          tm_row_const elt = *p;
 
-	  octave_idx_type this_elt_nr = elt.rows ();
-	  octave_idx_type this_elt_nc = elt.cols ();
+          octave_idx_type this_elt_nr = elt.rows ();
+          octave_idx_type this_elt_nc = elt.cols ();
 
-	  std::string this_elt_class_nm = elt.class_name ();
+          std::string this_elt_class_nm = elt.class_name ();
 
-	  dim_vector this_elt_dv = elt.dims ();
+          dim_vector this_elt_dv = elt.dims ();
 
-	  if (!this_elt_dv.all_zero ())
-	    {
-	      all_mt = false;
+          if (!this_elt_dv.all_zero ())
+            {
+              all_mt = false;
 
-	      if (first_elem)
-		{
-		  first_elem = false;
+              if (first_elem)
+                {
+                  first_elem = false;
 
-		  class_nm = this_elt_class_nm;
+                  class_nm = this_elt_class_nm;
 
-		  dv.resize (this_elt_dv.length ());
-		  for (int i = 2; i < dv.length (); i++)
-		    dv.elem (i) = this_elt_dv.elem (i);
+                  dv.resize (this_elt_dv.length ());
+                  for (int i = 2; i < dv.length (); i++)
+                    dv.elem (i) = this_elt_dv.elem (i);
 
-		  dv.elem (0) = 0;
+                  dv.elem (0) = 0;
 
-		  dv.elem (1) = this_elt_nc;
-		}
-	      else if (all_str)
-		{
-		  class_nm = get_concat_class (class_nm, this_elt_class_nm);
+                  dv.elem (1) = this_elt_nc;
+                }
+              else if (all_str)
+                {
+                  class_nm = get_concat_class (class_nm, this_elt_class_nm);
 
-		  if (this_elt_nc > cols ())
-		    dv.elem (1) = this_elt_nc;
-		}
-	      else
-		{
-		  class_nm = get_concat_class (class_nm, this_elt_class_nm);
+                  if (this_elt_nc > cols ())
+                    dv.elem (1) = this_elt_nc;
+                }
+              else
+                {
+                  class_nm = get_concat_class (class_nm, this_elt_class_nm);
 
-		  bool get_out = false;
-		  int len = (this_elt_dv.length () < dv.length ()
-			     ? this_elt_dv.length () : dv.length ());
+                  bool get_out = false;
+                  int len = (this_elt_dv.length () < dv.length ()
+                             ? this_elt_dv.length () : dv.length ());
 
-		  for (int i = 1; i < len; i++)
-		    {
-		      if (i == 1 && this_elt_nc != dv (1))
-			{
-			  ::error ("number of columns must match (%d != %d)",
-				   this_elt_nc, dv (1));
-			  get_out = true;
-			  break;
-			}
-		      else if (this_elt_dv (i) != dv (i))
-			{
-			  ::error ("dimensions mismatch (dim = %i, %d != %d)", i+1, this_elt_dv (i), dv (i));
-			  get_out = true;
-			  break;
-			}
-		    }
+                  for (int i = 1; i < len; i++)
+                    {
+                      if (i == 1 && this_elt_nc != dv (1))
+                        {
+                          ::error ("number of columns must match (%d != %d)",
+                                   this_elt_nc, dv (1));
+                          get_out = true;
+                          break;
+                        }
+                      else if (this_elt_dv (i) != dv (i))
+                        {
+                          ::error ("dimensions mismatch (dim = %i, %d != %d)", i+1, this_elt_dv (i), dv (i));
+                          get_out = true;
+                          break;
+                        }
+                    }
 
-		  if (this_elt_dv.length () > len)
-		    for (int i = len; i < this_elt_dv.length (); i++)
-		      if (this_elt_dv (i) != 1)
-			{
-			  ::error ("dimensions mismatch (dim = %i, %d != %d)", i+1, this_elt_dv (i), 1);
-			  get_out = true;
-			  break;
-			}
+                  if (this_elt_dv.length () > len)
+                    for (int i = len; i < this_elt_dv.length (); i++)
+                      if (this_elt_dv (i) != 1)
+                        {
+                          ::error ("dimensions mismatch (dim = %i, %d != %d)", i+1, this_elt_dv (i), 1);
+                          get_out = true;
+                          break;
+                        }
 
-		  if (dv.length () > len)
-		    for (int i = len; i < dv.length (); i++)
-		      if (dv (i) != 1)
-			{
-			  ::error ("dimensions mismatch (dim = %i, %d != %d)", i+1, 1, dv(i));
-			  get_out = true;
-			  break;
-			}
+                  if (dv.length () > len)
+                    for (int i = len; i < dv.length (); i++)
+                      if (dv (i) != 1)
+                        {
+                          ::error ("dimensions mismatch (dim = %i, %d != %d)", i+1, 1, dv(i));
+                          get_out = true;
+                          break;
+                        }
 
-		  if (get_out)
-		    break;
-		}
-	      dv.elem (0) = dv.elem (0) + this_elt_nr;
-	    }
-	  else
-	    warning_with_id ("Octave:empty-list-elements",
-			     "empty matrix found in matrix list");
-	}
+                  if (get_out)
+                    break;
+                }
+              dv.elem (0) = dv.elem (0) + this_elt_nr;
+            }
+          else
+            warning_with_id ("Octave:empty-list-elements",
+                             "empty matrix found in matrix list");
+        }
     }
 
   ok = ! error_state;
 }
 
 tree_matrix::~tree_matrix (void)
 {
   while (! empty ())
@@ -676,33 +676,33 @@ tree_matrix::has_magic_end (void) const
 {
   for (const_iterator p = begin (); p != end (); p++)
     {
       octave_quit ();
 
       tree_argument_list *elt = *p;
 
       if (elt && elt->has_magic_end ())
-	return true;
+        return true;
     }
 
   return false;
 }
 
 bool
 tree_matrix::all_elements_are_constant (void) const
 {
   for (const_iterator p = begin (); p != end (); p++)
     {
       octave_quit ();
 
       tree_argument_list *elt = *p;
 
       if (! elt->all_elements_are_constant ())
-	return false;
+        return false;
     }
 
   return true;
 }
 
 octave_value_list
 tree_matrix::rvalue (int nargout)
 {
@@ -716,17 +716,17 @@ tree_matrix::rvalue (int nargout)
   return retval;
 }
 
 void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
 {
   if (! (all_dq_strings_p || all_sq_strings_p))
     warning_with_id ("Octave:string-concat",
-		     "concatenation of different character string types may have unintended consequences");
+                     "concatenation of different character string types may have unintended consequences");
 }
 
 template<class TYPE>
 static void 
 single_type_concat (TYPE& result,
                     tm_const& tmp)
 {
   octave_idx_type r = 0, c = 0;
@@ -815,247 +815,247 @@ tree_matrix::rvalue1 (int)
       any_class_p = tmp.any_class_p ();
       frc_str_conv = tmp.some_strings_p ();
 
       // Try to speed up the common cases.
 
       std::string result_type = tmp.class_name ();
 
       if (any_class_p)
-	{
-	  octave_value_list tmp3 (tmp.length (), octave_value ());
+        {
+          octave_value_list tmp3 (tmp.length (), octave_value ());
 
-	  int j = 0;
-	  for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
-	    {
-	      octave_quit ();
+          int j = 0;
+          for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+            {
+              octave_quit ();
 
-	      tm_row_const row = *p;
+              tm_row_const row = *p;
 
-	      if (row.length () == 1)
-		tmp3 (j++) = *(row.begin ());
-	      else
-		{
-		  octave_value_list tmp1 (row.length (), octave_value ());
+              if (row.length () == 1)
+                tmp3 (j++) = *(row.begin ());
+              else
+                {
+                  octave_value_list tmp1 (row.length (), octave_value ());
 
-		  int i = 0;
-		  for (tm_row_const::iterator q = row.begin (); 
-		       q != row.end (); q++)
-		    tmp1 (i++) = *q;
+                  int i = 0;
+                  for (tm_row_const::iterator q = row.begin (); 
+                       q != row.end (); q++)
+                    tmp1 (i++) = *q;
 
-		  octave_value_list tmp2;
-		  octave_value fcn = 
-		    symbol_table::find_function ("horzcat", tmp1);
+                  octave_value_list tmp2;
+                  octave_value fcn = 
+                    symbol_table::find_function ("horzcat", tmp1);
 
-		  if (fcn.is_defined ())
-		    {
-		      tmp2 = fcn.do_multi_index_op (1, tmp1);
-		      
-		      if (error_state)
-			goto done;
+                  if (fcn.is_defined ())
+                    {
+                      tmp2 = fcn.do_multi_index_op (1, tmp1);
+                      
+                      if (error_state)
+                        goto done;
 
-		      tmp3 (j++) = tmp2 (0);
-		    }
-		  else
-		    {
-		      ::error ("cat not find overloaded horzcat function");
-		      goto done;
-		    }
-		}
-	    }
+                      tmp3 (j++) = tmp2 (0);
+                    }
+                  else
+                    {
+                      ::error ("cat not find overloaded horzcat function");
+                      goto done;
+                    }
+                }
+            }
 
-	  if (tmp.length () == 1)
-	    retval = tmp3 (0);
-	  else
-	    {
-	      octave_value_list tmp2;
-	      octave_value fcn = symbol_table::find_function ("vertcat", tmp3);
+          if (tmp.length () == 1)
+            retval = tmp3 (0);
+          else
+            {
+              octave_value_list tmp2;
+              octave_value fcn = symbol_table::find_function ("vertcat", tmp3);
 
-	      if (fcn.is_defined ())
-		{
-		  tmp2 = fcn.do_multi_index_op (1, tmp3);
-		      
-		  if (! error_state)
-		    retval = tmp2 (0);
-		}
-	      else
-		::error ("cat not find overloaded vertcat function");
-	    }
-	}
+              if (fcn.is_defined ())
+                {
+                  tmp2 = fcn.do_multi_index_op (1, tmp3);
+                      
+                  if (! error_state)
+                    retval = tmp2 (0);
+                }
+              else
+                ::error ("cat not find overloaded vertcat function");
+            }
+        }
       else if (result_type == "double")
-	{
-	  if (any_sparse_p)
-	    {	    
-	      if (all_real_p)
-		retval = do_single_type_concat<SparseMatrix> (dv, tmp);
-	      else
+        {
+          if (any_sparse_p)
+            {       
+              if (all_real_p)
+                retval = do_single_type_concat<SparseMatrix> (dv, tmp);
+              else
                 retval = do_single_type_concat_no_mutate<SparseComplexMatrix,
                                 octave_sparse_complex_matrix> (dv, tmp);
-	    }
-	  else
-	    {
-	      if (all_real_p)
-		retval = do_single_type_concat<NDArray> (dv, tmp);
-	      else
+            }
+          else
+            {
+              if (all_real_p)
+                retval = do_single_type_concat<NDArray> (dv, tmp);
+              else
                 retval = do_single_type_concat_no_mutate<ComplexNDArray,
                                 octave_complex_matrix> (dv, tmp);
-	    }
-	}
+            }
+        }
       else if (result_type == "single")
-	{
-	  if (all_real_p)
-	    retval = do_single_type_concat<FloatNDArray> (dv, tmp);
-	  else
+        {
+          if (all_real_p)
+            retval = do_single_type_concat<FloatNDArray> (dv, tmp);
+          else
             retval = do_single_type_concat_no_mutate<FloatComplexNDArray,
                         octave_float_complex_matrix> (dv, tmp);
-	}
+        }
       else if (result_type == "char")
-	{
-	  char type = all_dq_strings_p ? '"' : '\'';
+        {
+          char type = all_dq_strings_p ? '"' : '\'';
 
-	  maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
+          maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
-	  charNDArray result (dv, Vstring_fill_char);
+          charNDArray result (dv, Vstring_fill_char);
 
           single_type_concat (result, tmp);
 
-	  retval = octave_value (result, type);
-	}
+          retval = octave_value (result, type);
+        }
       else if (result_type == "logical")
-	{
-	  if (any_sparse_p)
-	    retval = do_single_type_concat<SparseBoolMatrix> (dv, tmp);
-	  else
-	    retval = do_single_type_concat<boolNDArray> (dv, tmp);
-	}
+        {
+          if (any_sparse_p)
+            retval = do_single_type_concat<SparseBoolMatrix> (dv, tmp);
+          else
+            retval = do_single_type_concat<boolNDArray> (dv, tmp);
+        }
       else if (result_type == "int8")
-	retval = do_single_type_concat<int8NDArray> (dv, tmp);
+        retval = do_single_type_concat<int8NDArray> (dv, tmp);
       else if (result_type == "int16")
-	retval = do_single_type_concat<int16NDArray> (dv, tmp);
+        retval = do_single_type_concat<int16NDArray> (dv, tmp);
       else if (result_type == "int32")
-	retval = do_single_type_concat<int32NDArray> (dv, tmp);
+        retval = do_single_type_concat<int32NDArray> (dv, tmp);
       else if (result_type == "int64")
-	retval = do_single_type_concat<int64NDArray> (dv, tmp);
+        retval = do_single_type_concat<int64NDArray> (dv, tmp);
       else if (result_type == "uint8")
-	retval = do_single_type_concat<uint8NDArray> (dv, tmp);
+        retval = do_single_type_concat<uint8NDArray> (dv, tmp);
       else if (result_type == "uint16")
-	retval = do_single_type_concat<uint16NDArray> (dv, tmp);
+        retval = do_single_type_concat<uint16NDArray> (dv, tmp);
       else if (result_type == "uint32")
-	retval = do_single_type_concat<uint32NDArray> (dv, tmp);
+        retval = do_single_type_concat<uint32NDArray> (dv, tmp);
       else if (result_type == "uint64")
-	retval = do_single_type_concat<uint64NDArray> (dv, tmp);
+        retval = do_single_type_concat<uint64NDArray> (dv, tmp);
       else
-	{
-	  // The line below might seem crazy, since we take a copy of
-	  // the first argument, resize it to be empty and then resize
-	  // it to be full. This is done since it means that there is
-	  // no recopying of data, as would happen if we used a single
-	  // resize.  It should be noted that resize operation is also
-	  // significantly slower than the do_cat_op function, so it
-	  // makes sense to have an empty matrix and copy all data.
-	  //
-	  // We might also start with a empty octave_value using
-	  //
-	  //    ctmp = octave_value_typeinfo::lookup_type
-	  //          (tmp.begin() -> begin() -> type_name());
-	  //
-	  // and then directly resize. However, for some types there
-	  // might be some additional setup needed, and so this should
-	  // be avoided.
+        {
+          // The line below might seem crazy, since we take a copy of
+          // the first argument, resize it to be empty and then resize
+          // it to be full. This is done since it means that there is
+          // no recopying of data, as would happen if we used a single
+          // resize.  It should be noted that resize operation is also
+          // significantly slower than the do_cat_op function, so it
+          // makes sense to have an empty matrix and copy all data.
+          //
+          // We might also start with a empty octave_value using
+          //
+          //    ctmp = octave_value_typeinfo::lookup_type
+          //          (tmp.begin() -> begin() -> type_name());
+          //
+          // and then directly resize. However, for some types there
+          // might be some additional setup needed, and so this should
+          // be avoided.
 
-	  octave_value ctmp;
+          octave_value ctmp;
 
-	  // Find the first non-empty object
+          // Find the first non-empty object
 
-	  if (any_sparse_p)
-	    {
-	      // Start with sparse matrix to avoid issues memory issues
-	      // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
-	      if (all_real_p)
-		ctmp = octave_sparse_matrix ().resize (dv); 
-	      else
-		ctmp = octave_sparse_complex_matrix ().resize (dv); 
-	    }
-	  else
-	    {
-	      for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
-		{
-		  octave_quit ();
+          if (any_sparse_p)
+            {
+              // Start with sparse matrix to avoid issues memory issues
+              // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
+              if (all_real_p)
+                ctmp = octave_sparse_matrix ().resize (dv); 
+              else
+                ctmp = octave_sparse_complex_matrix ().resize (dv); 
+            }
+          else
+            {
+              for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+                {
+                  octave_quit ();
 
-		  tm_row_const row = *p;
+                  tm_row_const row = *p;
 
-		  for (tm_row_const::iterator q = row.begin (); 
-		       q != row.end (); q++)
-		    {
-		      octave_quit ();
+                  for (tm_row_const::iterator q = row.begin (); 
+                       q != row.end (); q++)
+                    {
+                      octave_quit ();
 
-		      ctmp = *q;
+                      ctmp = *q;
 
-		      if (! ctmp.all_zero_dims ())
-			goto found_non_empty;
-		    }
-		}
+                      if (! ctmp.all_zero_dims ())
+                        goto found_non_empty;
+                    }
+                }
 
-	      ctmp = (*(tmp.begin() -> begin()));
+              ctmp = (*(tmp.begin() -> begin()));
 
-	    found_non_empty:
+            found_non_empty:
 
-	      if (! all_empty_p)
-		ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
-	    }
+              if (! all_empty_p)
+                ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
+            }
 
-	  if (! error_state)
-	    {
-	      // Now, extract the values from the individual elements and
-	      // insert them in the result matrix.
+          if (! error_state)
+            {
+              // Now, extract the values from the individual elements and
+              // insert them in the result matrix.
 
-	      int dv_len = dv.length ();
-	      Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0);
+              int dv_len = dv.length ();
+              Array<octave_idx_type> ra_idx (dv_len > 1 ? dv_len : 2, 0);
 
-	      for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
-		{
-		  octave_quit ();
+              for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+                {
+                  octave_quit ();
 
-		  tm_row_const row = *p;
+                  tm_row_const row = *p;
 
-		  for (tm_row_const::iterator q = row.begin ();
-		       q != row.end ();
-		       q++)
-		    {
-		      octave_quit ();
+                  for (tm_row_const::iterator q = row.begin ();
+                       q != row.end ();
+                       q++)
+                    {
+                      octave_quit ();
 
-		      octave_value elt = *q;
+                      octave_value elt = *q;
 
-		      ctmp = do_cat_op (ctmp, elt, ra_idx);
+                      ctmp = do_cat_op (ctmp, elt, ra_idx);
 
-		      if (error_state)
-			goto done;
+                      if (error_state)
+                        goto done;
 
-		      ra_idx (1) += elt.columns ();
-		    }
+                      ra_idx (1) += elt.columns ();
+                    }
 
-		  ra_idx (0) += row.rows ();
-		  ra_idx (1) = 0;
-		}
+                  ra_idx (0) += row.rows ();
+                  ra_idx (1) = 0;
+                }
 
-	      retval = ctmp;
+              retval = ctmp;
 
-	      if (frc_str_conv && ! retval.is_string ())
-		retval = retval.convert_to_str ();
-	    }
-	}
+              if (frc_str_conv && ! retval.is_string ())
+                retval = retval.convert_to_str ();
+            }
+        }
     }
 
 done:
   return retval;
 }
 
 tree_expression *
 tree_matrix::dup (symbol_table::scope_id scope,
-		  symbol_table::context_id context) const
+                  symbol_table::context_id context) const
 {
   tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_argument_list *elt = *p;
 
       new_matrix->append (elt ? elt->dup (scope, context) : 0);
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -68,98 +68,98 @@ tree_parameter_list::validate (in_or_out
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
 
       tree_identifier *id = elt->ident ();
 
       if (id)
-	{
-	  std::string name = id->name ();
+        {
+          std::string name = id->name ();
 
           if (id->is_black_hole ())
             {
               if (type != in)
                 error ("invalid use of ~ in output list");
             }
           else if (dict.find (name) != dict.end ())
-	    {
-	      retval = false;
-	      error ("`%s' appears more than once in parameter list",
-		     name.c_str ());
-	      break;
-	    }
-	  else
-	    dict.insert (name);
-	}
+            {
+              retval = false;
+              error ("`%s' appears more than once in parameter list",
+                     name.c_str ());
+              break;
+            }
+          else
+            dict.insert (name);
+        }
     }
 
   if (! error_state)
     {
       std::string va_type = (type == in ? "varargin" : "varargout");
 
       size_t len = length ();
 
       if (len > 0)
-	{
-	  tree_decl_elt *elt = back ();
+        {
+          tree_decl_elt *elt = back ();
 
-	  tree_identifier *id = elt->ident ();
+          tree_identifier *id = elt->ident ();
 
-	  if (id && id->name () == va_type)
-	    {
-	      if (len == 1)
-		mark_varargs_only ();
-	      else
-		mark_varargs ();
+          if (id && id->name () == va_type)
+            {
+              if (len == 1)
+                mark_varargs_only ();
+              else
+                mark_varargs ();
 
-	      iterator p = end ();
-	      --p;
-	      delete *p;
-	      erase (p);
-	    }
-	}
+              iterator p = end ();
+              --p;
+              delete *p;
+              erase (p);
+            }
+        }
     }
 
   return retval;
 }
 
 void
 tree_parameter_list::initialize_undefined_elements (const std::string& warnfor,
-						    int nargout,
-						    const octave_value& val)
+                                                    int nargout,
+                                                    const octave_value& val)
 {
   bool warned = false;
 
   int count = 0;
 
   for (iterator p = begin (); p != end (); p++)
     {
       if (++count > nargout)
-	break;
+        break;
 
       tree_decl_elt *elt = *p;
 
       if (! elt->is_variable ())
-	{
-	  if (! warned)
-	    {
-	      warned = true;
+        {
+          if (! warned)
+            {
+              warned = true;
 
-	      warning_with_id
-		("Octave:undefined-return-values",
-		 "%s: some elements in list of return values are undefined",
-		 warnfor.c_str ());
-	    }
+              warning_with_id
+                ("Octave:undefined-return-values",
+                 "%s: some elements in list of return values are undefined",
+                 warnfor.c_str ());
+            }
 
-	  octave_lvalue tmp = elt->lvalue ();
+          octave_lvalue tmp = elt->lvalue ();
 
-	  tmp.assign (octave_value::op_asn_eq, val);
-	}
+          tmp.assign (octave_value::op_asn_eq, val);
+        }
     }
 }
 
 void
 tree_parameter_list::define_from_arg_vector (const octave_value_list& args)
 {
   int nargin = args.length ();
 
@@ -169,30 +169,30 @@ tree_parameter_list::define_from_arg_vec
 
   for (int i = 0; i < expected_nargin; i++)
     {
       tree_decl_elt *elt = *p++;
 
       octave_lvalue ref = elt->lvalue ();
 
       if (i < nargin)
-	{
-	  if (args(i).is_defined () && args(i).is_magic_colon ())
-	    {
-	      if (! elt->eval ())
-		{
-		  ::error ("no default value for argument %d\n", i+1);
-		  return;
-		}
-	    }
-	  else
-	    ref.define (args(i));
-	}
+        {
+          if (args(i).is_defined () && args(i).is_magic_colon ())
+            {
+              if (! elt->eval ())
+                {
+                  ::error ("no default value for argument %d\n", i+1);
+                  return;
+                }
+            }
+          else
+            ref.define (args(i));
+        }
       else
-	elt->eval ();
+        elt->eval ();
     }
 }
 
 void
 tree_parameter_list::undefine (void)
 {
   int len = length ();
 
@@ -259,28 +259,28 @@ tree_parameter_list::is_defined (void)
 {
   bool status = true;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
 
       if (! elt->is_variable ())
-	{
-	  status = false;
-	  break;
-	}
+        {
+          status = false;
+          break;
+        }
     }
 
   return status;
 }
 
 tree_parameter_list *
 tree_parameter_list::dup (symbol_table::scope_id scope,
-			  symbol_table::context_id context) const
+                          symbol_table::context_id context) const
 {
   tree_parameter_list *new_list = new tree_parameter_list ();
 
   if (takes_varargs ())
     new_list->mark_varargs ();
 
   for (const_iterator p = begin (); p != end (); p++)
     {
@@ -307,17 +307,17 @@ tree_return_list::~tree_return_list (voi
       iterator p = begin ();
       delete *p;
       erase (p);
     }
 }
 
 tree_return_list *
 tree_return_list::dup (symbol_table::scope_id scope,
-		       symbol_table::context_id context) const
+                       symbol_table::context_id context) const
 {
   tree_return_list *new_list = new tree_return_list ();
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_index_expression *elt = *p;
 
       new_list->append (elt->dup (scope, context));
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -64,22 +64,22 @@ tree_print_code::visit_argument_list (tr
 {
   tree_argument_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_expression *elt = *p++;
 
       if (elt)
-	{
-	  elt->accept (*this);
+        {
+          elt->accept (*this);
 
-	  if (p != lst.end ())
-	    os << ", ";
-	}
+          if (p != lst.end ())
+            os << ", ";
+        }
     }
 }
 
 void
 tree_print_code::visit_binary_expression (tree_binary_expression& expr)
 {
   indent ();
 
@@ -197,22 +197,22 @@ tree_print_code::visit_decl_init_list (t
 {
   tree_decl_init_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_decl_elt *elt = *p++;
 
       if (elt)
-	{
-	  elt->accept (*this);
+        {
+          elt->accept (*this);
 
-	  if (p != lst.end ())
-	    os << ", ";
-	}
+          if (p != lst.end ())
+            os << ", ";
+        }
     }
 }
 
 void
 tree_print_code::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   print_comment_list (cmd.leading_comment ());
 
@@ -346,36 +346,36 @@ tree_print_code::visit_octave_user_funct
 
   if (ret_list)
     {
       bool takes_var_return = fcn.takes_var_return ();
 
       int len = ret_list->length ();
 
       if (len > 1 || takes_var_return)
-	{
-	  os << "[";
-	  nesting.push ('[');
-	}
+        {
+          os << "[";
+          nesting.push ('[');
+        }
 
       ret_list->accept (*this);
 
       if (takes_var_return)
-	{
-	  if (len > 0)
-	    os << ", ";
+        {
+          if (len > 0)
+            os << ", ";
 
-	  os << "varargout";
-	}
+          os << "varargout";
+        }
 
       if (len > 1 || takes_var_return)
-	{
-	  nesting.pop ();
-	  os << "]";
-	}
+        {
+          nesting.pop ();
+          os << "]";
+        }
 
       os << " = ";
     }
 
   std::string fcn_name = fcn.name ();
 
   os << (fcn_name.empty () ? std::string ("(empty)") : fcn_name) << " ";
 
@@ -383,37 +383,37 @@ tree_print_code::visit_octave_user_funct
 
   if (param_list)
     {
       bool takes_varargs = fcn.takes_varargs ();
 
       int len = param_list->length ();
 
       if (len > 0 || takes_varargs)
-	{
-	  os << "(";
-	  nesting.push ('(');
-	}
+        {
+          os << "(";
+          nesting.push ('(');
+        }
 
       param_list->accept (*this);
 
       if (takes_varargs)
-	{
-	  if (len > 0)
-	    os << ", ";
+        {
+          if (len > 0)
+            os << ", ";
 
-	  os << "varargin";
-	}
+          os << "varargin";
+        }
 
       if (len > 0 || takes_varargs)
-	{
-	  nesting.pop ();
-	  os << ")";
-	  newline ();
-	}
+        {
+          nesting.pop ();
+          os << ")";
+          newline ();
+        }
     }
   else
     {
       os << "()";
       newline ();
     }
 }
 
@@ -505,31 +505,31 @@ tree_print_code::visit_if_command_list (
 
   bool first_elt = true;
 
   while (p != lst.end ())
     {
       tree_if_clause *elt = *p++;
 
       if (elt)
-	{
-	  if (! first_elt)
-	    {
-	      print_indented_comment (elt->leading_comment ());
+        {
+          if (! first_elt)
+            {
+              print_indented_comment (elt->leading_comment ());
 
-	      indent ();
+              indent ();
 
-	      if (elt->is_else_clause ())
-		os << "else";
-	      else
-		os << "elseif ";
-	    }
+              if (elt->is_else_clause ())
+                os << "else";
+              else
+                os << "elseif ";
+            }
 
-	  elt->accept (*this);
-	}
+          elt->accept (*this);
+        }
 
       first_elt = false;
     }
 }
 
 void
 tree_print_code::visit_index_expression (tree_index_expression& expr)
 {
@@ -555,66 +555,66 @@ tree_print_code::visit_index_expression 
   int n = type_tags.length ();
 
   std::list<tree_argument_list *>::iterator p_arg_lists = arg_lists.begin ();
   std::list<string_vector>::iterator p_arg_names = arg_names.begin ();
 
   for (int i = 0; i < n; i++)
     {
       switch (type_tags[i])
-	{
-	case '(':
-	  {
-	    char nc = nesting.top ();
-	    if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-	      os << "(";
-	    else
-	      os << " (";
-	    nesting.push ('(');
+        {
+        case '(':
+          {
+            char nc = nesting.top ();
+            if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
+              os << "(";
+            else
+              os << " (";
+            nesting.push ('(');
 
-	    tree_argument_list *l = *p_arg_lists;
-	    if (l)
-	      l->accept (*this);
+            tree_argument_list *l = *p_arg_lists;
+            if (l)
+              l->accept (*this);
 
-	    nesting.pop ();
-	    os << ")";
-	  }
-	  break;
-	    
-	case '{':
-	  {
-	    char nc = nesting.top ();
-	    if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-	      os << "{";
-	    else
-	      os << " {";
-	    // We only care about whitespace inside [] and {} when we
-	    // are defining matrix and cell objects, not when indexing.
-	    nesting.push ('(');
+            nesting.pop ();
+            os << ")";
+          }
+          break;
+            
+        case '{':
+          {
+            char nc = nesting.top ();
+            if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
+              os << "{";
+            else
+              os << " {";
+            // We only care about whitespace inside [] and {} when we
+            // are defining matrix and cell objects, not when indexing.
+            nesting.push ('(');
 
-	    tree_argument_list *l = *p_arg_lists;
-	    if (l)
-	      l->accept (*this);
+            tree_argument_list *l = *p_arg_lists;
+            if (l)
+              l->accept (*this);
 
-	    nesting.pop ();
-	    os << "}";
-	  }
-	  break;
-	    
-	case '.':
-	  {
-	    string_vector nm = *p_arg_names;
-	    assert (nm.length () == 1);
-	    os << "." << nm(0);
-	  }
-	  break;
+            nesting.pop ();
+            os << "}";
+          }
+          break;
+            
+        case '.':
+          {
+            string_vector nm = *p_arg_names;
+            assert (nm.length () == 1);
+            os << "." << nm(0);
+          }
+          break;
 
-	default:
-	  panic_impossible ();
-	}
+        default:
+          panic_impossible ();
+        }
 
       p_arg_lists++;
       p_arg_names++;
     }
 
   print_parens (expr, ")");
 }
 
@@ -630,22 +630,22 @@ tree_print_code::visit_matrix (tree_matr
 
   tree_matrix::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_argument_list *elt = *p++;
 
       if (elt)
-	{
-	  elt->accept (*this);
+        {
+          elt->accept (*this);
 
-	  if (p != lst.end ())
-	    os << "; ";
-	}
+          if (p != lst.end ())
+            os << "; ";
+        }
     }
 
   nesting.pop ();
   os << "]";
 
   print_parens (lst, ")");
 }
 
@@ -661,22 +661,22 @@ tree_print_code::visit_cell (tree_cell& 
 
   tree_cell::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_argument_list *elt = *p++;
 
       if (elt)
-	{
-	  elt->accept (*this);
+        {
+          elt->accept (*this);
 
-	  if (p != lst.end ())
-	    os << "; ";
-	}
+          if (p != lst.end ())
+            os << "; ";
+        }
     }
 
   nesting.pop ();
   os << "}";
 
   print_parens (lst, ")");
 }
 
@@ -689,28 +689,28 @@ tree_print_code::visit_multi_assignment 
 
   tree_argument_list *lhs = expr.left_hand_side ();
 
   if (lhs)
     {
       int len = lhs->length ();
 
       if (len > 1)
-	{
-	  os << "[";
-	  nesting.push ('[');
-	}
+        {
+          os << "[";
+          nesting.push ('[');
+        }
 
       lhs->accept (*this);
 
       if (len > 1)
-	{
-	  nesting.pop ();
-	  os << "]";
-	}
+        {
+          nesting.pop ();
+          os << "]";
+        }
     }
 
   os << " " << expr.oper () << " ";
 
   tree_expression *rhs = expr.right_hand_side ();
 
   if (rhs)
     rhs->accept (*this);
@@ -755,22 +755,22 @@ tree_print_code::visit_parameter_list (t
 {
   tree_parameter_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_decl_elt *elt = *p++;
 
       if (elt)
-	{
-	  elt->accept (*this);
+        {
+          elt->accept (*this);
 
-	  if (p != lst.end ())
-	    os << ", ";
-	}
+          if (p != lst.end ())
+            os << ", ";
+        }
     }
 }
 
 void
 tree_print_code::visit_postfix_expression (tree_postfix_expression& expr)
 {
   indent ();
 
@@ -816,22 +816,22 @@ tree_print_code::visit_return_list (tree
 {
   tree_return_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_index_expression *elt = *p++;
 
       if (elt)
-	{
-	  elt->accept (*this);
+        {
+          elt->accept (*this);
 
-	  if (p != lst.end ())
-	    os << ", ";
-	}
+          if (p != lst.end ())
+            os << ", ";
+        }
     }
 }
 
 void
 tree_print_code::visit_simple_assignment (tree_simple_assignment& expr)
 {
   indent ();
 
@@ -859,51 +859,51 @@ tree_print_code::visit_statement (tree_s
 
   tree_command *cmd = stmt.command ();
 
   if (cmd)
     {
       cmd->accept (*this);
 
       if (! stmt.print_result ())
-	{
-	  os << ";";
-	  newline (" ");
-	}
+        {
+          os << ";";
+          newline (" ");
+        }
       else
-	newline ();
+        newline ();
     }
   else
     {
       tree_expression *expr = stmt.expression ();
 
       if (expr)
-	{
-	  expr->accept (*this);
+        {
+          expr->accept (*this);
 
-	  if (! stmt.print_result ())
-	    {
-	      os << ";";
-	      newline (" ");
-	    }
-	  else
-	    newline ();
-	}
+          if (! stmt.print_result ())
+            {
+              os << ";";
+              newline (" ");
+            }
+          else
+            newline ();
+        }
     }
 }
 
 void
 tree_print_code::visit_statement_list (tree_statement_list& lst)
 {
   for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
       tree_statement *elt = *p;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_print_code::visit_switch_case (tree_switch_case& cs)
 {
   print_comment_list (cs.leading_comment ());
 
@@ -940,17 +940,17 @@ tree_print_code::visit_switch_case_list 
 {
   tree_switch_case_list::iterator p = lst.begin ();
 
   while (p != lst.end ())
     {
       tree_switch_case *elt = *p++;
 
       if (elt)
-	elt->accept (*this);
+        elt->accept (*this);
     }
 }
 
 void
 tree_print_code::visit_switch_command (tree_switch_command& cmd)
 {
   print_comment_list (cmd.leading_comment ());
 
@@ -1158,24 +1158,24 @@ tree_print_code::visit_do_until_command 
 void
 tree_print_code::indent (void)
 {
   assert (curr_print_indent_level >= 0);
 
   if (printing_newlines)
     {
       if (beginning_of_line)
-	{
-	  os << prefix;
+        {
+          os << prefix;
 
-	  for (int i = 0; i < curr_print_indent_level; i++)
-	    os << " ";
+          for (int i = 0; i < curr_print_indent_level; i++)
+            os << " ";
 
-	  beginning_of_line = false;
-	}
+          beginning_of_line = false;
+        }
     }
 }
 
 // All print_code() functions should use this to print new lines.
 
 void
 tree_print_code::newline (const char *alt_txt)
 {
@@ -1221,64 +1221,64 @@ tree_print_code::print_comment_elt (cons
     ; /* Skip leading new lines. */
   i--;
 
   while (i < len)
     {
       char c = comment[i++];
 
       if (c == '\n')
-	{
-	  if (prev_char_was_newline)
-	    os << "##";
+        {
+          if (prev_char_was_newline)
+            os << "##";
 
-	  newline ();
+          newline ();
 
-	  prev_char_was_newline = true;
-	}
+          prev_char_was_newline = true;
+        }
       else
-	{
-	  if (beginning_of_line)
-	    {
-	      printed_something = true;
+        {
+          if (beginning_of_line)
+            {
+              printed_something = true;
 
-	      indent ();
+              indent ();
 
-	      os << "##";
+              os << "##";
 
-	      if (! (isspace (c) || c == '!'))
-		os << " ";
-	    }
+              if (! (isspace (c) || c == '!'))
+                os << " ";
+            }
 
-	  os << static_cast<char> (c);
+          os << static_cast<char> (c);
 
-	  prev_char_was_newline = false;
-	}
+          prev_char_was_newline = false;
+        }
     }
 
   if (printed_something && ! beginning_of_line)
     newline ();
 }
 
 void
 tree_print_code::print_comment_list (octave_comment_list *comment_list)
 {
   if (comment_list)
     {
       octave_comment_list::iterator p = comment_list->begin ();
 
       while (p != comment_list->end ())
-	{
-	  octave_comment_elt elt = *p++;
+        {
+          octave_comment_elt elt = *p++;
 
-	  print_comment_elt (elt);
+          print_comment_elt (elt);
 
-	  if (p != comment_list->end ())
-	    newline ();
-	}
+          if (p != comment_list->end ())
+            newline ();
+        }
     }
 }
 
 void
 tree_print_code::print_indented_comment (octave_comment_list *comment_list)
 {
   increment_indent_level ();
 
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -42,34 +42,34 @@ tree_if_clause::~tree_if_clause (void)
 {
   delete expr;
   delete list;
   delete lead_comm;
 }
 
 tree_if_clause *
 tree_if_clause::dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const
+                     symbol_table::context_id context) const
 {
   return new tree_if_clause (expr ? expr->dup (scope, context) : 0,
-			     list ? list->dup (scope, context) : 0,
-			     lead_comm ? lead_comm->dup () : 0);
+                             list ? list->dup (scope, context) : 0,
+                             lead_comm ? lead_comm->dup () : 0);
 }
 
 void
 tree_if_clause::accept (tree_walker& tw)
 {
   tw.visit_if_clause (*this);
 }
 
 // List of if commands.
 
 tree_if_command_list *
 tree_if_command_list::dup (symbol_table::scope_id scope,
-			   symbol_table::context_id context) const
+                           symbol_table::context_id context) const
 {
   tree_if_command_list *new_icl = new tree_if_command_list ();
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_if_clause *elt = *p;
 
       new_icl->append (elt ? elt->dup (scope, context) : 0);
@@ -96,40 +96,40 @@ tree_if_command::~tree_if_command (void)
 void
 tree_if_command::set_breakpoint (void)
 {
   if (list)
     {
       tree_if_clause *elt = list->front ();
 
       if (elt)
-	elt->set_breakpoint ();
+        elt->set_breakpoint ();
     }
 }
 
 void
 tree_if_command::delete_breakpoint (void)
 {
   if (list)
     {
       tree_if_clause *elt = list->front ();
 
       if (elt)
-	elt->set_breakpoint ();
+        elt->set_breakpoint ();
     }
 }
 
 tree_command *
 tree_if_command::dup (symbol_table::scope_id scope,
-		      symbol_table::context_id context) const
+                      symbol_table::context_id context) const
 {
   return new tree_if_command (list ? list->dup (scope, context) : 0,
-			      lead_comm ? lead_comm->dup () : 0,
-			      trail_comm ? trail_comm->dup () : 0,
-			      line (), column ());
+                              lead_comm ? lead_comm->dup () : 0,
+                              trail_comm ? trail_comm->dup () : 0,
+                              line (), column ());
 }
 
 void
 tree_if_command::accept (tree_walker& tw)
 {
   tw.visit_if_command (*this);
 }
 
@@ -146,66 +146,66 @@ tree_switch_case::~tree_switch_case (voi
 bool
 tree_switch_case::label_matches (const octave_value& val)
 {
   octave_value label_value = label->rvalue1 ();
 
   if (! error_state && label_value.is_defined() )
     {
       if (label_value.is_cell ())
-	{
-	  Cell cell (label_value.cell_value ());
+        {
+          Cell cell (label_value.cell_value ());
 
-	  for (octave_idx_type i = 0; i < cell.rows (); i++)
-	    {
-	      for (octave_idx_type j = 0; j < cell.columns (); j++)
-		{
-		  bool match = val.is_equal (cell(i,j));
+          for (octave_idx_type i = 0; i < cell.rows (); i++)
+            {
+              for (octave_idx_type j = 0; j < cell.columns (); j++)
+                {
+                  bool match = val.is_equal (cell(i,j));
 
-		  if (error_state)
-		    return false;
-		  else if (match)
-		    return true;
-		}
-	    }
-	}
+                  if (error_state)
+                    return false;
+                  else if (match)
+                    return true;
+                }
+            }
+        }
       else
-	{
-	  bool match = val.is_equal (label_value);
+        {
+          bool match = val.is_equal (label_value);
 
-	  if (error_state)
-	    return false;
-	  else
-	    return match;
-	}
+          if (error_state)
+            return false;
+          else
+            return match;
+        }
     }
 
   return false;
 }
 
 tree_switch_case *
 tree_switch_case::dup (symbol_table::scope_id scope,
-		       symbol_table::context_id context) const
+                       symbol_table::context_id context) const
 {
   return new tree_switch_case (label ? label->dup (scope, context) : 0,
-			       list ? list->dup (scope, context) : 0,
-			       lead_comm ? lead_comm->dup () : 0);
+                               list ? list->dup (scope, context) : 0,
+                               lead_comm ? lead_comm->dup () : 0);
 }
 
 void
 tree_switch_case::accept (tree_walker& tw)
 {
   tw.visit_switch_case (*this);
 }
 
 // List of switch cases.
 
 tree_switch_case_list *
 tree_switch_case_list::dup (symbol_table::scope_id scope,
-			    symbol_table::context_id context) const
+                            symbol_table::context_id context) const
 {
   tree_switch_case_list *new_scl = new tree_switch_case_list ();
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_switch_case *elt = *p;
 
       new_scl->append (elt ? elt->dup (scope, context) : 0);
@@ -233,40 +233,40 @@ tree_switch_command::~tree_switch_comman
 void
 tree_switch_command::set_breakpoint (void)
 {
   if (list)
     {
       tree_switch_case *elt = list->front ();
 
       if (elt)
-	elt->set_breakpoint ();
+        elt->set_breakpoint ();
     }
 }
 
 void
 tree_switch_command::delete_breakpoint (void)
 {
   if (list)
     {
       tree_switch_case *elt = list->front ();
 
       if (elt)
-	elt->set_breakpoint ();
+        elt->set_breakpoint ();
     }
 }
 
 tree_command *
 tree_switch_command::dup (symbol_table::scope_id scope,
-			  symbol_table::context_id context) const
+                          symbol_table::context_id context) const
 {
   return new tree_switch_command (expr ? expr->dup (scope, context) : 0,
-				  list ? list->dup (scope, context) : 0,
-				  lead_comm ? lead_comm->dup () : 0,
-				  trail_comm ? trail_comm->dup () : 0,
-				  line (), column ());
+                                  list ? list->dup (scope, context) : 0,
+                                  lead_comm ? lead_comm->dup () : 0,
+                                  trail_comm ? trail_comm->dup () : 0,
+                                  line (), column ());
 }
 
 void
 tree_switch_command::accept (tree_walker& tw)
 {
   tw.visit_switch_command (*this);
 }
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -117,28 +117,28 @@ tree_statement::echo_code (void)
 bool
 tree_statement::is_end_of_fcn_or_script (void) const
 {
   bool retval = false;
 
   if (cmd)
     {
       tree_no_op_command *no_op_cmd
-	= dynamic_cast<tree_no_op_command *> (cmd);
+        = dynamic_cast<tree_no_op_command *> (cmd);
 
       if (no_op_cmd)
-	retval = no_op_cmd->is_end_of_fcn_or_script ();
+        retval = no_op_cmd->is_end_of_fcn_or_script ();
     }
 
   return retval;
 }
 
 tree_statement *
 tree_statement::dup (symbol_table::scope_id scope,
-		     symbol_table::context_id context) const
+                     symbol_table::context_id context) const
 {
   tree_statement *new_stmt = new tree_statement ();
 
   new_stmt->cmd = cmd ? cmd->dup (scope, context) : 0;
 
   new_stmt->expr = expr ? expr->dup (scope, context) : 0;
 
   new_stmt->comm = comm ? comm->dup () : 0;
@@ -166,20 +166,20 @@ tree_statement_list::delete_breakpoint (
 {
   if (line < 0)
     {
       octave_value_list bp_lst = list_breakpoints ();
 
       int len = bp_lst.length ();
 
       for (int i = 0; i < len; i++)
-	{
-	  tree_breakpoint tbp (i, tree_breakpoint::clear);
-	  accept (tbp);
-	}
+        {
+          tree_breakpoint tbp (i, tree_breakpoint::clear);
+          accept (tbp);
+        }
     }
   else
     {
       tree_breakpoint tbp (line, tree_breakpoint::clear); 
       accept (tbp);
     }
 }
 
@@ -189,17 +189,17 @@ tree_statement_list::list_breakpoints (v
   tree_breakpoint tbp (0, tree_breakpoint::list);
   accept (tbp);
 
   return tbp.get_list ();
 }
 
 tree_statement_list *
 tree_statement_list::dup (symbol_table::scope_id scope,
-			  symbol_table::context_id context) const
+                          symbol_table::context_id context) const
 {
   tree_statement_list *new_list = new tree_statement_list ();
 
   new_list->function_body = function_body;
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_statement *elt = *p;
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -45,17 +45,17 @@ tree_unary_expression::oper (void) const
 
 octave_value_list
 tree_prefix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("prefix operator `%s': invalid number of output arguments",
-	   oper () . c_str ());
+           oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_prefix_expression::rvalue1 (int)
@@ -63,60 +63,60 @@ tree_prefix_expression::rvalue1 (int)
   octave_value retval;
 
   if (error_state)
     return retval;
 
   if (op)
     {
       if (etype == octave_value::op_incr || etype == octave_value::op_decr)
-	{
-	  op->rvalue1 ();
+        {
+          op->rvalue1 ();
 
-	  if (! error_state)
-	    {
-	      octave_lvalue ref = op->lvalue ();
+          if (! error_state)
+            {
+              octave_lvalue ref = op->lvalue ();
 
-	      if (! error_state && ref.is_defined ())
-		{
-		  ref.do_unary_op (etype);
+              if (! error_state && ref.is_defined ())
+                {
+                  ref.do_unary_op (etype);
 
-		  retval = ref.value ();
-		}
-	    }
-	}
+                  retval = ref.value ();
+                }
+            }
+        }
       else
-	{
-	  octave_value val = op->rvalue1 ();
+        {
+          octave_value val = op->rvalue1 ();
 
-	  if (! error_state && val.is_defined ())
-	    {
+          if (! error_state && val.is_defined ())
+            {
               // Attempt to do the operation in-place if it is unshared 
               // (a temporary expression).
               if (val.get_count () == 1)
                 retval = val.do_non_const_unary_op (etype);
               else
                 retval = ::do_unary_op (etype, val);
 
-	      if (error_state)
-		retval = octave_value ();
-	    }
-	}
+              if (error_state)
+                retval = octave_value ();
+            }
+        }
     }
 
   return retval;
 }
 
 tree_expression *
 tree_prefix_expression::dup (symbol_table::scope_id scope,
-			     symbol_table::context_id context) const
+                             symbol_table::context_id context) const
 {
   tree_prefix_expression *new_pe
     = new tree_prefix_expression (op ? op->dup (scope, context) : 0,
-				  line (), column (), etype);
+                                  line (), column (), etype);
 
   new_pe->copy_base (*this);
 
   return new_pe;
 }
 
 void
 tree_prefix_expression::accept (tree_walker& tw)
@@ -128,17 +128,17 @@ tree_prefix_expression::accept (tree_wal
 
 octave_value_list
 tree_postfix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("postfix operator `%s': invalid number of output arguments",
-	   oper () . c_str ());
+           oper () . c_str ());
   else
     retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_postfix_expression::rvalue1 (int)
@@ -146,55 +146,55 @@ tree_postfix_expression::rvalue1 (int)
   octave_value retval;
 
   if (error_state)
     return retval;
 
   if (op)
     {
       if (etype == octave_value::op_incr || etype == octave_value::op_decr)
-	{
-	  op->rvalue1 ();
+        {
+          op->rvalue1 ();
 
-	  if (! error_state)
-	    {
-	      octave_lvalue ref = op->lvalue ();
+          if (! error_state)
+            {
+              octave_lvalue ref = op->lvalue ();
 
-	      if (! error_state && ref.is_defined ())
-		{
-		  retval = ref.value ();
+              if (! error_state && ref.is_defined ())
+                {
+                  retval = ref.value ();
 
-		  ref.do_unary_op (etype);
-		}
-	    }
-	}
+                  ref.do_unary_op (etype);
+                }
+            }
+        }
       else
-	{
-	  octave_value val = op->rvalue1 ();
+        {
+          octave_value val = op->rvalue1 ();
 
-	  if (! error_state && val.is_defined ())
-	    {
-	      retval = ::do_unary_op (etype, val);
+          if (! error_state && val.is_defined ())
+            {
+              retval = ::do_unary_op (etype, val);
 
-	      if (error_state)
-		retval = octave_value ();
-	    }
-	}
+              if (error_state)
+                retval = octave_value ();
+            }
+        }
     }
 
   return retval;
 }
 
 tree_expression *
 tree_postfix_expression::dup (symbol_table::scope_id scope,
-			      symbol_table::context_id context) const
+                              symbol_table::context_id context) const
 {
   tree_postfix_expression *new_pe
     = new tree_postfix_expression (op ? op->dup (scope, context) : 0,
-				   line (), column (), etype);
+                                   line (), column (), etype);
 
   new_pe->copy_base (*this);
 
   return new_pe;
 }
 
 void
 tree_postfix_expression::accept (tree_walker& tw)
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -90,44 +90,44 @@ void
 octave_signal_handler (void)
 {
   // The list of signals is relatively short, so we will just go
   // linearly through the list.
 
   for (int i = 0; i < NSIG; i++)
     {
       if (octave_signals_caught[i])
-	{
-	  octave_signals_caught[i] = false;
+        {
+          octave_signals_caught[i] = false;
 
-	  switch (i)
-	    {
+          switch (i)
+            {
 #ifdef SIGCHLD
-	    case SIGCHLD:
-	      octave_child_list::reap ();
-	      break;
+            case SIGCHLD:
+              octave_child_list::reap ();
+              break;
 #endif
 
-	    case SIGFPE:
-	      std::cerr << "warning: floating point exception -- trying to return to prompt" << std::endl;
-	      break;
+            case SIGFPE:
+              std::cerr << "warning: floating point exception -- trying to return to prompt" << std::endl;
+              break;
 
 #ifdef SIGPIPE
-	    case SIGPIPE:
-	      std::cerr << "warning: broken pipe -- some output may be lost" << std::endl;
-	      break;
+            case SIGPIPE:
+              std::cerr << "warning: broken pipe -- some output may be lost" << std::endl;
+              break;
 #endif
-	    }
-	}
+            }
+        }
     }
 }
 
 static void
 my_friendly_exit (const char *sig_name, int sig_number,
-		  bool save_vars = true)
+                  bool save_vars = true)
 {
   static bool been_there_done_that = false;
 
   if (been_there_done_that)
     {
 #if defined (SIGABRT)
       octave_set_signal_handler (SIGABRT, SIG_DFL);
 #endif
@@ -140,43 +140,43 @@ my_friendly_exit (const char *sig_name, 
     }
   else
     {
       been_there_done_that = true;
 
       std::cerr << "panic: " << sig_name << " -- stopping myself...\n";
 
       if (save_vars)
-	dump_octave_core ();
+        dump_octave_core ();
 
       if (sig_number < 0)
-	{
-	  MINGW_SIGNAL_CLEANUP ();
+        {
+          MINGW_SIGNAL_CLEANUP ();
 
-	  exit (1);
-	}
+          exit (1);
+        }
       else
-	{
-	  octave_set_signal_handler (sig_number, SIG_DFL);
+        {
+          octave_set_signal_handler (sig_number, SIG_DFL);
 
 #if defined (HAVE_RAISE)
-	  raise (sig_number);
+          raise (sig_number);
 #elif defined (HAVE_KILL)
-	  kill (getpid (), sig_number);
+          kill (getpid (), sig_number);
 #else
-	  exit (1);
+          exit (1);
 #endif
-	}
+        }
 
     }
 }
 
 sig_handler *
 octave_set_signal_handler (int sig, sig_handler *handler,
-			   bool restart_syscalls)
+                           bool restart_syscalls)
 {
   struct sigaction act, oact;
 
   act.sa_handler = handler;
   act.sa_flags = 0;
 
   if (sig == SIGALRM)
     {
@@ -272,27 +272,27 @@ sig_hup_or_term_handler (int sig)
 {
   MAYBE_ACK_SIGNAL (sig);
 
   switch (sig)
     {
 #if defined (SIGHUP)
     case SIGHUP:
       {
-	if (Vsighup_dumps_octave_core)
-	  dump_octave_core ();
+        if (Vsighup_dumps_octave_core)
+          dump_octave_core ();
       }
       break;
 #endif
 
 #if defined (SIGTERM)
     case SIGTERM:
       {
-	if (Vsigterm_dumps_octave_core)
-	  dump_octave_core ();
+        if (Vsigterm_dumps_octave_core)
+          dump_octave_core ();
       }
       break;
 #endif
 
     default:
       break;
     }
 
@@ -322,59 +322,59 @@ static void
 user_abort (const char *sig_name, int sig_number)
 {
   if (! octave_initialized)
     exit (1);
 
   if (can_interrupt)
     {
       if (Vdebug_on_interrupt)
-	{
-	  if (! octave_debug_on_interrupt_state)
-	    {
-	      tree_evaluator::debug_mode = true;
-	      octave_debug_on_interrupt_state = true;
+        {
+          if (! octave_debug_on_interrupt_state)
+            {
+              tree_evaluator::debug_mode = true;
+              octave_debug_on_interrupt_state = true;
 
-	      return;
-	    }
-	  else
-	    {
-	      // Clear the flag and do normal interrupt stuff.
+              return;
+            }
+          else
+            {
+              // Clear the flag and do normal interrupt stuff.
 
-	      tree_evaluator::debug_mode
+              tree_evaluator::debug_mode
                 = bp_table::have_breakpoints () || Vdebugging;
-	      octave_debug_on_interrupt_state = false;
-	    }
-	}
+              octave_debug_on_interrupt_state = false;
+            }
+        }
 
       if (octave_interrupt_immediately)
-	{
-	  if (octave_interrupt_state == 0)
-	    octave_interrupt_state = 1;
+        {
+          if (octave_interrupt_state == 0)
+            octave_interrupt_state = 1;
 
-	  octave_jump_to_enclosing_context ();
-	}
+          octave_jump_to_enclosing_context ();
+        }
       else
-	{
-	  // If we are already cleaning up from a previous interrupt,
-	  // take note of the fact that another interrupt signal has
-	  // arrived.
+        {
+          // If we are already cleaning up from a previous interrupt,
+          // take note of the fact that another interrupt signal has
+          // arrived.
 
-	  if (octave_interrupt_state < 0)
-	    octave_interrupt_state = 0;
+          if (octave_interrupt_state < 0)
+            octave_interrupt_state = 0;
 
-	  octave_signal_caught = 1;
-	  octave_interrupt_state++;
+          octave_signal_caught = 1;
+          octave_interrupt_state++;
 
-	  if (interactive && octave_interrupt_state == 2)
-	    std::cerr << "Press Control-C again to abort." << std::endl;
+          if (interactive && octave_interrupt_state == 2)
+            std::cerr << "Press Control-C again to abort." << std::endl;
 
-	  if (octave_interrupt_state >= 3)
-	    my_friendly_exit (sig_name, sig_number, true);
-	}
+          if (octave_interrupt_state >= 3)
+            my_friendly_exit (sig_name, sig_number, true);
+        }
     }
 
 }
 
 static void
 sigint_handler (int sig)
 {
   MAYBE_ACK_SIGNAL (sig);
@@ -410,50 +410,50 @@ sigpipe_handler (int /* sig */)
 static BOOL CALLBACK
 w32_sigint_handler (DWORD sig)
 {
   const char *sig_name;
 
   switch(sig)
     {
       case CTRL_BREAK_EVENT:   
-	sig_name = "Ctrl-Break"; 
-	break;
+        sig_name = "Ctrl-Break"; 
+        break;
       case CTRL_C_EVENT:
-	sig_name = "Ctrl-C";
-	break;
+        sig_name = "Ctrl-C";
+        break;
       case CTRL_CLOSE_EVENT:
-	sig_name = "close console";
-	break;
+        sig_name = "close console";
+        break;
       case CTRL_LOGOFF_EVENT:
-	sig_name = "logoff";
-	break;
+        sig_name = "logoff";
+        break;
       case CTRL_SHUTDOWN_EVENT:
-	sig_name = "shutdown";
-	break;
+        sig_name = "shutdown";
+        break;
       default:
-	sig_name = "unknown console event";
-	break;
+        sig_name = "unknown console event";
+        break;
     }
 
   switch(sig)
     {
       case CTRL_BREAK_EVENT:
       case CTRL_C_EVENT:
-	w32_raise (SIGINT);
+        w32_raise (SIGINT);
         break;
 
       case CTRL_CLOSE_EVENT:
       case CTRL_LOGOFF_EVENT:
       case CTRL_SHUTDOWN_EVENT:
       default:
         // We should do the following:
         //    clean_up_and_exit (0);
         // We can't because we aren't running in the normal Octave thread.
-	user_abort(sig_name, sig);
+        user_abort(sig_name, sig);
         break;
     }
 
   // Return TRUE if the event was handled, or FALSE if another handler 
   // should be called.
   // FIXME check that windows terminates the thread.
   return TRUE;
 }
@@ -505,28 +505,28 @@ octave_ignore_interrupts (void)
   retval.brk_handler = octave_set_signal_handler (SIGBREAK, SIG_IGN);
 #endif
 
   return retval;
 }
 
 octave_interrupt_handler
 octave_set_interrupt_handler (const volatile octave_interrupt_handler& h,
-			      bool restart_syscalls)
+                              bool restart_syscalls)
 {
   octave_interrupt_handler retval;
 
 #ifdef SIGINT
   retval.int_handler = octave_set_signal_handler (SIGINT, h.int_handler,
-						  restart_syscalls);
+                                                  restart_syscalls);
 #endif
 
 #ifdef SIGBREAK
   retval.brk_handler = octave_set_signal_handler (SIGBREAK, h.brk_handler,
-						  restart_syscalls);
+                                                  restart_syscalls);
 #endif
 
   return retval;
 }
 
 // Install all the handlers for the signals we might care about.
 
 void
@@ -883,24 +883,24 @@ OCL_REP::reap (void)
       // The call to the octave_child::child_event_handler might
       // invalidate the iterator (for example, by calling
       // octave_child_list::remove), so we increment the iterator
       // here.
 
       octave_child& oc = *p;
 
       if (oc.have_status)
-	{
-	  oc.have_status = 0;
+        {
+          oc.have_status = 0;
 
-	  octave_child::child_event_handler f = oc.handler;
+          octave_child::child_event_handler f = oc.handler;
 
-	  if (f && f (oc.pid, oc.status))
-	    oc.pid = -1;
-	}
+          if (f && f (oc.pid, oc.status))
+            oc.pid = -1;
+        }
     }
 
   remove_if (pid_equal (-1));
 }
 
 // Wait on our children and record any changes in their status.
 
 bool
@@ -910,30 +910,30 @@ OCL_REP::wait (void)
 
   for (iterator p = begin (); p != end (); p++)
     {
       octave_child& oc = *p;
 
       pid_t pid = oc.pid;
 
       if (pid > 0)
-	{
-	  int status;
+        {
+          int status;
 
-	  if (octave_syscalls::waitpid (pid, &status, WNOHANG) > 0)
-	    {
-	      oc.have_status = 1;
+          if (octave_syscalls::waitpid (pid, &status, WNOHANG) > 0)
+            {
+              oc.have_status = 1;
 
-	      oc.status = status;
+              oc.status = status;
 
-	      retval = true;
+              retval = true;
 
-	      break;
-	    }
-	}
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 DEFUN (SIG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SIG ()\n\
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -139,17 +139,17 @@ xdiv (const Matrix& a, const SparseMatri
 
   Matrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   Matrix result = btmp.solve (btyp, atmp, info, rcond, 
-			      solve_singularity_warning);
+                              solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xdiv (const Matrix& a, const SparseComplexMatrix& b, MatrixType &typ)
@@ -219,17 +219,17 @@ xdiv (const SparseMatrix& a, const Spars
 
   SparseMatrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
   SparseMatrix result = btmp.solve (btyp, atmp, info, rcond, 
-				    solve_singularity_warning);
+                                    solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 6 -*-
 SparseComplexMatrix
 xdiv (const SparseMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
@@ -313,22 +313,22 @@ RT do_rightdiv_sm_dm (const SM& a, const
   octave_idx_type k_result = 0;
   for (octave_idx_type j = 0; j < nc; ++j)
     {
       octave_quit ();
       const DM_elt_type s = d.dgelem (j);
       const octave_idx_type colend = a.cidx (j+1);
       r.xcidx (j) = k_result;
       if (s != zero)
-	for (octave_idx_type k = a.cidx (j); k < colend; ++k)
-	  {
-	    r.xdata (k_result) = a.data (k) / s;
-	    r.xridx (k_result) = a.ridx (k);
-	    ++k_result;
-	  }
+        for (octave_idx_type k = a.cidx (j); k < colend; ++k)
+          {
+            r.xdata (k_result) = a.data (k) / s;
+            r.xridx (k_result) = a.ridx (k);
+            ++k_result;
+          }
     }
   r.xcidx (nc) = k_result;
 
   r.maybe_compress (true);
   return r;
 }
 
 // -*- 9 -*-
@@ -381,72 +381,72 @@ x_el_div (double a, const SparseMatrix& 
     result = Matrix (nr, nc, octave_Inf);
   else
     result = Matrix (nr, nc, -octave_Inf);
 
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	octave_quit ();
-	result.elem (b.ridx(i), j) = a / b.data (i);
+        octave_quit ();
+        result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix  result (nr, nc, Complex(octave_NaN, octave_NaN));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	octave_quit ();
-	result.elem (b.ridx(i), j) = a / b.data (i);
+        octave_quit ();
+        result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	octave_quit ();
-	result.elem (b.ridx(i), j) = a / b.data (i);
+        octave_quit ();
+        result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
       {
-	octave_quit ();
-	result.elem (b.ridx(i), j) = a / b.data (i);
+        octave_quit ();
+        result.elem (b.ridx(i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 // Left division functions.  X \ Y = inv(X) * Y
 //
 //               Y  \  X :   sm  scm  dm  dcm
@@ -542,17 +542,17 @@ xleftdiv (const SparseComplexMatrix& a, 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
 xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, 
-	  MatrixType &typ)
+          MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
@@ -579,29 +579,29 @@ RT do_leftdiv_dm_sm (const DM& d, const 
 
   octave_idx_type k_result = 0;
   for (octave_idx_type j = 0; j < a_nc; ++j)
     {
       octave_quit ();
       const octave_idx_type colend = a.cidx (j+1);
       r.xcidx (j) = k_result;
       for (octave_idx_type k = a.cidx (j); k < colend; ++k)
-	{
-	  const octave_idx_type i = a.ridx (k);
-	  if (i < nr)
-	    {
-	      const DM_elt_type s = d.dgelem (i);
-	      if (s != zero)
-		{
-		  r.xdata (k_result) = a.data (k) / s;
-		  r.xridx (k_result) = i;
-		  ++k_result;
-		}
-	    }
-	}
+        {
+          const octave_idx_type i = a.ridx (k);
+          if (i < nr)
+            {
+              const DM_elt_type s = d.dgelem (i);
+              if (s != zero)
+                {
+                  r.xdata (k_result) = a.data (k) / s;
+                  r.xridx (k_result) = i;
+                  ++k_result;
+                }
+            }
+        }
     }
   r.xcidx (a_nc) = k_result;
 
   r.maybe_compress (true);
   return r;
 }
 
 // -*- 9 -*-
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -41,18 +41,18 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "sparse-xpow.h"
 
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
-	  && ((x >= 0 && x < INT_MAX)
-	      || (x <= 0 && x > INT_MIN)));
+          && ((x >= 0 && x < INT_MAX)
+              || (x <= 0 && x > INT_MIN)));
 }
 
 
 // Safer pow functions. Only two make sense for sparse matrices, the
 // others should all promote to full matrices.
 
 octave_value
 xpow (const SparseMatrix& a, double b)
@@ -62,71 +62,71 @@ xpow (const SparseMatrix& a, double b)
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
-	  int btmp = static_cast<int> (b);
-	  if (btmp == 0)
-	    {
-	      SparseMatrix tmp = SparseMatrix (nr, nr, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  tmp.data (i) = 1.0;
-		  tmp.ridx (i) = i;
-		}
-	      for (octave_idx_type i = 0; i < nr + 1; i++)
-		tmp.cidx (i) = i;
+        {
+          int btmp = static_cast<int> (b);
+          if (btmp == 0)
+            {
+              SparseMatrix tmp = SparseMatrix (nr, nr, nr);
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  tmp.data (i) = 1.0;
+                  tmp.ridx (i) = i;
+                }
+              for (octave_idx_type i = 0; i < nr + 1; i++)
+                tmp.cidx (i) = i;
 
-	      retval = tmp;
-	    }
-	  else
-	    {
-	      SparseMatrix atmp;
-	      if (btmp < 0)
-		{
-		  btmp = -btmp;
+              retval = tmp;
+            }
+          else
+            {
+              SparseMatrix atmp;
+              if (btmp < 0)
+                {
+                  btmp = -btmp;
 
-		  octave_idx_type info;
-		  double rcond = 0.0;
-		  MatrixType mattyp (a);
+                  octave_idx_type info;
+                  double rcond = 0.0;
+                  MatrixType mattyp (a);
 
-		  atmp = a.inverse (mattyp, info, rcond, 1);
+                  atmp = a.inverse (mattyp, info, rcond, 1);
 
-		  if (info == -1)
-		    warning ("inverse: matrix singular to machine\
+                  if (info == -1)
+                    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
-		}
-	      else
-		atmp = a;
+                }
+              else
+                atmp = a;
 
-	      SparseMatrix result (atmp);
+              SparseMatrix result (atmp);
 
-	      btmp--;
+              btmp--;
 
-	      while (btmp > 0)
-		{
-		  if (btmp & 1)
-		    result = result * atmp;
+              while (btmp > 0)
+                {
+                  if (btmp & 1)
+                    result = result * atmp;
 
-		  btmp >>= 1;
+                  btmp >>= 1;
 
-		  if (btmp > 0)
-		    atmp = atmp * atmp;
-		}
+                  if (btmp > 0)
+                    atmp = atmp * atmp;
+                }
 
-	      retval = result;
-	    }
-	}
+              retval = result;
+            }
+        }
       else
-	error ("use full(a) ^ full(b)");
+        error ("use full(a) ^ full(b)");
     }
 
   return retval;
 }
 
 octave_value
 xpow (const SparseComplexMatrix& a, double b)
 {
@@ -135,71 +135,71 @@ xpow (const SparseComplexMatrix& a, doub
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
-	  int btmp = static_cast<int> (b);
-	  if (btmp == 0)
-	    {
-	      SparseMatrix tmp = SparseMatrix (nr, nr, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
-		{
-		  tmp.data (i) = 1.0;
-		  tmp.ridx (i) = i;
-		}
-	      for (octave_idx_type i = 0; i < nr + 1; i++)
-		tmp.cidx (i) = i;
+        {
+          int btmp = static_cast<int> (b);
+          if (btmp == 0)
+            {
+              SparseMatrix tmp = SparseMatrix (nr, nr, nr);
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  tmp.data (i) = 1.0;
+                  tmp.ridx (i) = i;
+                }
+              for (octave_idx_type i = 0; i < nr + 1; i++)
+                tmp.cidx (i) = i;
 
-	      retval = tmp;
-	    }
-	  else
-	    {
-	      SparseComplexMatrix atmp;
-	      if (btmp < 0)
-		{
-		  btmp = -btmp;
+              retval = tmp;
+            }
+          else
+            {
+              SparseComplexMatrix atmp;
+              if (btmp < 0)
+                {
+                  btmp = -btmp;
 
-		  octave_idx_type info;
-		  double rcond = 0.0;
-		  MatrixType mattyp (a);
+                  octave_idx_type info;
+                  double rcond = 0.0;
+                  MatrixType mattyp (a);
 
-		  atmp = a.inverse (mattyp, info, rcond, 1);
+                  atmp = a.inverse (mattyp, info, rcond, 1);
 
-		  if (info == -1)
-		    warning ("inverse: matrix singular to machine\
+                  if (info == -1)
+                    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
-		}
-	      else
-		atmp = a;
+                }
+              else
+                atmp = a;
 
-	      SparseComplexMatrix result (atmp);
+              SparseComplexMatrix result (atmp);
 
-	      btmp--;
+              btmp--;
 
-	      while (btmp > 0)
-		{
-		  if (btmp & 1)
-		    result = result * atmp;
+              while (btmp > 0)
+                {
+                  if (btmp & 1)
+                    result = result * atmp;
 
-		  btmp >>= 1;
+                  btmp >>= 1;
 
-		  if (btmp > 0)
-		    atmp = atmp * atmp;
-		}
+                  if (btmp > 0)
+                    atmp = atmp * atmp;
+                }
 
-	      retval = result;
-	    }
-	}
+              retval = result;
+            }
+        }
       else
-	error ("use full(a) ^ full(b)");
+        error ("use full(a) ^ full(b)");
     }
 
   return retval;
 }
 
 // Safer pow functions that work elementwise for matrices.
 //
 //       op2 \ op1:   s   m   cs   cm
@@ -241,38 +241,38 @@ elem_xpow (double a, const SparseMatrix&
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = std::pow (atmp, b(i,j));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = std::pow (atmp, b(i,j));
+            }
+        }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      octave_quit ();
-	      result (i, j) = std::pow (a, b(i,j));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              octave_quit ();
+              result (i, j) = std::pow (a, b(i,j));
+            }
+        }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
@@ -283,20 +283,20 @@ elem_xpow (double a, const SparseComplex
   octave_idx_type nc = b.cols ();
 
   Complex atmp (a);
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  octave_quit ();
-	  result (i, j) = std::pow (atmp, b(i,j));
-	}
+        {
+          octave_quit ();
+          result (i, j) = std::pow (atmp, b(i,j));
+        }
     }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const SparseMatrix& a, double b)
@@ -310,79 +310,79 @@ elem_xpow (const SparseMatrix& a, double
   octave_idx_type nz = a.nzmax ();
 
   if (b <= 0.0)
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       if (static_cast<int> (b) != b && a.any_element_is_negative ())
-	{
-	  ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
+        {
+          ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
-	  // FIXME -- avoid apparent GNU libm bug by
-	  // converting A and B to complex instead of just A.
-	  Complex btmp (b);
+          // FIXME -- avoid apparent GNU libm bug by
+          // converting A and B to complex instead of just A.
+          Complex btmp (b);
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	      {
-		octave_quit ();
-	      
-		Complex atmp (a.data (i));
-		
-		result (a.ridx(i), j) = std::pow (atmp, btmp);
-	      }
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              {
+                octave_quit ();
+              
+                Complex atmp (a.data (i));
+                
+                result (a.ridx(i), j) = std::pow (atmp, btmp);
+              }
 
-	  retval = octave_value (result);
-	}
+          retval = octave_value (result);
+        }
       else
-	{
-	  Matrix result (nr, nc, (std::pow (0.0, b)));
+        {
+          Matrix result (nr, nc, (std::pow (0.0, b)));
 
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	      {
-		octave_quit ();
-		result (a.ridx(i), j) = std::pow (a.data (i), b);
-	      }
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              {
+                octave_quit ();
+                result (a.ridx(i), j) = std::pow (a.data (i), b);
+              }
 
-	  retval = octave_value (result);
-	}
+          retval = octave_value (result);
+        }
     }
   else if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       SparseComplexMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  octave_quit ();
+        {
+          octave_quit ();
 
-	  // FIXME -- avoid apparent GNU libm bug by
-	  // converting A and B to complex instead of just A.
+          // FIXME -- avoid apparent GNU libm bug by
+          // converting A and B to complex instead of just A.
 
-	  Complex atmp (a.data (i));
-	  Complex btmp (b);
+          Complex atmp (a.data (i));
+          Complex btmp (b);
 
-	  result.data (i) = std::pow (atmp, btmp);
-	}
+          result.data (i) = std::pow (atmp, btmp);
+        }
 
       result.maybe_compress (true);
 
       retval = result;
     }
   else
     {
       SparseMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  octave_quit ();
-	  result.data (i) = std::pow (a.data (i), b);
-	}
+        {
+          octave_quit ();
+          result.data (i) = std::pow (a.data (i), b);
+        }
 
       result.maybe_compress (true);
 
       retval = result;
     }
 
   return retval;
 }
@@ -404,63 +404,63 @@ elem_xpow (const SparseMatrix& a, const 
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
       {
-	if (a.data(i) < 0.0)
-	  {
-	    double btmp = b (a.ridx(i), j);
-	    if (static_cast<int> (btmp) != btmp)
-	      {
-		convert_to_complex = 1;
-		goto done;
-	      }
-	  }
+        if (a.data(i) < 0.0)
+          {
+            double btmp = b (a.ridx(i), j);
+            if (static_cast<int> (btmp) != btmp)
+              {
+                convert_to_complex = 1;
+                goto done;
+              }
+          }
       }
 
 done:
 
   // This is a dumb operator for sparse matrices anyway, and there is
   // no sensible way to handle the 0.^0 versus the 0.^x cases. Therefore
   // allocate a full matrix filled for the 0.^0 case and shrink it later
   // as needed
 
   if (convert_to_complex)
     {
       SparseComplexMatrix complex_result (nr, nc, Complex(1.0, 0.0));
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	    {
-	      octave_quit ();
-	      complex_result.xelem(a.ridx(i), j) =
-		std::pow (Complex(a.data(i)), Complex(b(a.ridx(i), j)));
-	    }
-	}
+        {
+          for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            {
+              octave_quit ();
+              complex_result.xelem(a.ridx(i), j) =
+                std::pow (Complex(a.data(i)), Complex(b(a.ridx(i), j)));
+            }
+        }
       complex_result.maybe_compress (true);
       retval = complex_result;
     }
   else
     {
       SparseMatrix result (nr, nc, 1.0);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	    {
-	      octave_quit ();
-	      result.xelem(a.ridx(i), j) = std::pow (a.data(i), 
-						     b (a.ridx(i), j));
-	    }
-	}
+        {
+          for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            {
+              octave_quit ();
+              result.xelem(a.ridx(i), j) = std::pow (a.data(i), 
+                                                     b (a.ridx(i), j));
+            }
+        }
       result.maybe_compress (true);
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -473,20 +473,20 @@ elem_xpow (const SparseMatrix& a, const 
     // Can this case ever happen, due to automatic retyping with maybe_mutate?
     retval = octave_value (NDArray (a.dims (), 1));
   else
     {
       octave_idx_type nz = a.nzmax ();
       SparseComplexMatrix result (a);
       
       for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  octave_quit ();
-	  result.data (i) = std::pow (Complex (a.data (i)), b);
-	}
+        {
+          octave_quit ();
+          result.data (i) = std::pow (Complex (a.data (i)), b);
+        }
   
       result.maybe_compress (true);
 
       retval = result;
     }
 
   return retval;
 }
@@ -506,20 +506,20 @@ elem_xpow (const SparseMatrix& a, const 
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	{
-	  octave_quit ();
-	  result.xelem(a.ridx(i), j) = std::pow (a.data(i), b (a.ridx(i), j));
-	}
+        {
+          octave_quit ();
+          result.xelem(a.ridx(i), j) = std::pow (a.data(i), b (a.ridx(i), j));
+        }
     }
 
   result.maybe_compress (true);
 
   return result;
 }
 
 // -*- 7 -*-
@@ -529,42 +529,42 @@ elem_xpow (const Complex& a, const Spars
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
-	{
-	  octave_quit ();
-	  double btmp = b (i, j);
-	  if (xisint (btmp))
-	    result (i, j) = std::pow (a, static_cast<int> (btmp));
-	  else
-	    result (i, j) = std::pow (a, btmp);
-	}
+        {
+          octave_quit ();
+          double btmp = b (i, j);
+          if (xisint (btmp))
+            result (i, j) = std::pow (a, static_cast<int> (btmp));
+          else
+            result (i, j) = std::pow (a, btmp);
+        }
     }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (a, b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const SparseComplexMatrix& a, double b)
@@ -574,59 +574,59 @@ elem_xpow (const SparseComplexMatrix& a,
   if (b <= 0)
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
       if (xisint (b))
-	{
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	      {
-		octave_quit ();
-		result (a.ridx(i), j) = 
-		  std::pow (a.data (i), static_cast<int> (b));
-	      }
-	}
+        {
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              {
+                octave_quit ();
+                result (a.ridx(i), j) = 
+                  std::pow (a.data (i), static_cast<int> (b));
+              }
+        }
       else
-	{
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	      {
-		octave_quit ();
-		result (a.ridx(i), j) = std::pow (a.data (i), b);
-	      }
-	}  
+        {
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              {
+                octave_quit ();
+                result (a.ridx(i), j) = std::pow (a.data (i), b);
+              }
+        }  
 
       retval = result;
     }
   else
     {
       octave_idx_type nz = a.nzmax ();
 
       SparseComplexMatrix result (a);
   
       if (xisint (b))
-	{
-	  for (octave_idx_type i = 0; i < nz; i++)
-	    {
-	      octave_quit ();
-	      result.data (i) = std::pow (a.data (i), static_cast<int> (b));
-	    }
-	}
+        {
+          for (octave_idx_type i = 0; i < nz; i++)
+            {
+              octave_quit ();
+              result.data (i) = std::pow (a.data (i), static_cast<int> (b));
+            }
+        }
       else
-	{
-	  for (octave_idx_type i = 0; i < nz; i++)
-	    {
-	      octave_quit ();
-	      result.data (i) = std::pow (a.data (i), b);
-	    }
-	}  
+        {
+          for (octave_idx_type i = 0; i < nz; i++)
+            {
+              octave_quit ();
+              result.data (i) = std::pow (a.data (i), b);
+            }
+        }  
 
       result.maybe_compress (true);
 
       retval = result;
     }
 
   return retval;
 }
@@ -646,27 +646,27 @@ elem_xpow (const SparseComplexMatrix& a,
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	{
-	  octave_quit ();
-	  double btmp = b (a.ridx(i), j);
-	  Complex tmp;
+        {
+          octave_quit ();
+          double btmp = b (a.ridx(i), j);
+          Complex tmp;
 
-	  if (xisint (btmp))
-	    result.xelem(a.ridx(i), j) = std::pow (a.data (i), 
-					      static_cast<int> (btmp));
-	  else
-	    result.xelem(a.ridx(i), j) = std::pow (a.data (i), btmp);
-	}
+          if (xisint (btmp))
+            result.xelem(a.ridx(i), j) = std::pow (a.data (i), 
+                                              static_cast<int> (btmp));
+          else
+            result.xelem(a.ridx(i), j) = std::pow (a.data (i), btmp);
+        }
     }
 
   result.maybe_compress (true);
 
   return result;
 }
 
 // -*- 11 -*-
@@ -681,20 +681,20 @@ elem_xpow (const SparseComplexMatrix& a,
   else
     {
 
       octave_idx_type nz = a.nzmax ();
 
       SparseComplexMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  octave_quit ();
-	  result.data (i) = std::pow (a.data (i), b);
-	}
+        {
+          octave_quit ();
+          result.data (i) = std::pow (a.data (i), b);
+        }
 
       result.maybe_compress (true);
       
       retval = result;
     }
 
   return retval;
 }
@@ -714,17 +714,17 @@ elem_xpow (const SparseComplexMatrix& a,
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++) 
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-	{
-	  octave_quit ();
-	  result.xelem(a.ridx(i), j) = std::pow (a.data (i), b (a.ridx(i), j));
-	}
+        {
+          octave_quit ();
+          result.xelem(a.ridx(i), j) = std::pow (a.data (i), b (a.ridx(i), j));
+        }
     }
   result.maybe_compress (true);
 
   return result;
 }
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -77,75 +77,75 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = args(0).convert_to_str (true, true,
-				     args(0).is_dq_string () ? '"' : '\'');
+                                     args(0).is_dq_string () ? '"' : '\'');
   else if (nargin > 1)
     {
       int n_elts = 0;
 
       int max_len = 0;
 
       std::queue<string_vector> args_as_strings;
 
       for (int i = 0; i < nargin; i++)
-	{
-	  string_vector s = args(i).all_strings ();
+        {
+          string_vector s = args(i).all_strings ();
 
-	  if (error_state)
-	    {
-	      error ("char: unable to convert some args to strings");
-	      return retval;
-	    }
+          if (error_state)
+            {
+              error ("char: unable to convert some args to strings");
+              return retval;
+            }
 
-	  if (s.length () > 0)
+          if (s.length () > 0)
             n_elts += s.length ();
           else
             n_elts += 1;
 
-	  int s_max_len = s.max_length ();
+          int s_max_len = s.max_length ();
 
-	  if (s_max_len > max_len)
-	    max_len = s_max_len;
+          if (s_max_len > max_len)
+            max_len = s_max_len;
 
-	  args_as_strings.push (s);
-	}
+          args_as_strings.push (s);
+        }
 
       string_vector result (n_elts);
 
       int k = 0;
 
       for (int i = 0; i < nargin; i++)
-	{
-	  string_vector s = args_as_strings.front ();
-	  args_as_strings.pop ();
+        {
+          string_vector s = args_as_strings.front ();
+          args_as_strings.pop ();
 
-	  int n = s.length ();
+          int n = s.length ();
 
           if (n > 0)
             {
-	      for (int j = 0; j < n; j++)
-	        {
-	          std::string t = s[j];
-	          int t_len = t.length ();
+              for (int j = 0; j < n; j++)
+                {
+                  std::string t = s[j];
+                  int t_len = t.length ();
 
-	          if (max_len > t_len)
-		    t += std::string (max_len - t_len, ' ');
+                  if (max_len > t_len)
+                    t += std::string (max_len - t_len, ' ');
 
-	          result[k++] = t;
-	        }
+                  result[k++] = t;
+                }
             }
           else
-	    result[k++] = std::string (max_len, ' ');
-	}
+            result[k++] = std::string (max_len, ' ');
+        }
 
       retval = octave_value (result, '\'');
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -206,73 +206,73 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
     {
       int n_elts = 0;
 
       size_t max_len = 0;
 
       std::queue<string_vector> args_as_strings;
 
       for (int i = 0; i < nargin; i++)
-	{
-	  string_vector s = args(i).all_strings ();
+        {
+          string_vector s = args(i).all_strings ();
 
-	  if (error_state)
-	    {
-	      error ("strvcat: unable to convert some args to strings");
-	      return retval;
-	    }
+          if (error_state)
+            {
+              error ("strvcat: unable to convert some args to strings");
+              return retval;
+            }
 
           size_t n = s.length ();
 
           // do not count empty strings in calculation of number of elements
           if (n > 0)
             {
               for (size_t j = 0; j < n; j++)
                 {
                   if (s[j].length () > 0)
                     n_elts++;
                 }
             }
 
-	  size_t s_max_len = s.max_length ();
+          size_t s_max_len = s.max_length ();
 
-	  if (s_max_len > max_len)
-	    max_len = s_max_len;
+          if (s_max_len > max_len)
+            max_len = s_max_len;
 
-	  args_as_strings.push (s);
-	}
+          args_as_strings.push (s);
+        }
 
       string_vector result (n_elts);
 
       octave_idx_type k = 0;
 
       for (int i = 0; i < nargin; i++)
-	{
-	  string_vector s = args_as_strings.front ();
-	  args_as_strings.pop ();
+        {
+          string_vector s = args_as_strings.front ();
+          args_as_strings.pop ();
 
-	  size_t n = s.length ();
+          size_t n = s.length ();
 
           if (n > 0)
             {
-	      for (size_t j = 0; j < n; j++)
-	        {
-	          std::string t = s[j];
+              for (size_t j = 0; j < n; j++)
+                {
+                  std::string t = s[j];
                   if (t.length () > 0)
                     {
                       size_t t_len = t.length ();
 
                       if (max_len > t_len)
                         t += std::string (max_len - t_len, ' ');
 
                       result[k++] = t;
                     }
-	        }
+                }
             }
-	}
+        }
 
       retval = octave_value (result, '\'');
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -869,36 +869,36 @@ whos ans\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       string_vector s = args(0).all_strings ();
 
       if (! error_state)
-	{
-	  std::ostringstream buf;
+        {
+          std::ostringstream buf;
 
-	  if (nargin == 1)
-	    // Let list_in_columns query terminal width.
-	    s.list_in_columns (buf);
-	  else
-	    {
-	      int width = args(1).int_value ();
+          if (nargin == 1)
+            // Let list_in_columns query terminal width.
+            s.list_in_columns (buf);
+          else
+            {
+              int width = args(1).int_value ();
 
-	      if (! error_state)
-		s.list_in_columns (buf, width);
-	      else
-		error ("list_in_columns: expecting width to be an integer");
-	    }
+              if (! error_state)
+                s.list_in_columns (buf, width);
+              else
+                error ("list_in_columns: expecting width to be an integer");
+            }
 
-	  retval = buf.str ();
-	}
+          retval = buf.str ();
+        }
       else
-	error ("list_in_columns: expecting cellstr or char array");
+        error ("list_in_columns: expecting cellstr or char array");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -76,24 +76,24 @@ symbol_table::symbol_record::symbol_reco
 {
   octave_value val = varval (xcurrent_context);
 
   os << prefix << name;
 
   if (val.is_defined ())
     {
       os << " ["
-	 << (is_local () ? "l" : "")
-	 << (is_automatic () ? "a" : "")
-	 << (is_formal () ? "f" : "")
-	 << (is_hidden () ? "h" : "")
-	 << (is_inherited () ? "i" : "")
-	 << (is_global () ? "g" : "")
-	 << (is_persistent () ? "p" : "")
-	 << "] ";
+         << (is_local () ? "l" : "")
+         << (is_automatic () ? "a" : "")
+         << (is_formal () ? "f" : "")
+         << (is_hidden () ? "h" : "")
+         << (is_inherited () ? "i" : "")
+         << (is_global () ? "g" : "")
+         << (is_persistent () ? "p" : "")
+         << "] ";
       val.dump (os);
     }
 
   os << "\n";
 }
 
 octave_value
 symbol_table::symbol_record::find (const octave_value_list& args) const
@@ -134,18 +134,18 @@ symbol_table::symbol_record::find (const
 // since the last time the function was loaded/parsed).
 //
 // FIXME -- perhaps this should be done for all loaded functions when
 // the prompt is printed or the directory has changed, and then we
 // would not check for it when finding symbol definitions.
 
 static inline bool
 load_out_of_date_fcn (const std::string& ff, const std::string& dir_name,
-		      octave_value& function,
-		      const std::string& dispatch_type = std::string ())
+                      octave_value& function,
+                      const std::string& dispatch_type = std::string ())
 {
   bool retval = false;
 
   octave_function *fcn = load_fcn_from_file (ff, dir_name, dispatch_type);
 
   if (fcn)
     {
       retval = true;
@@ -167,29 +167,29 @@ out_of_date_check (octave_value& functio
 
   octave_function *fcn = function.function_value (true);
 
   if (fcn)
     {
       // FIXME -- we need to handle nested functions properly here.
 
       if (! fcn->is_nested_function ())
-	{
-	  std::string ff = fcn->fcn_file_name ();
+        {
+          std::string ff = fcn->fcn_file_name ();
 
-	  if (! ff.empty ())
-	    {
-	      octave_time tc = fcn->time_checked ();
+          if (! ff.empty ())
+            {
+              octave_time tc = fcn->time_checked ();
 
-	      bool relative = check_relative && fcn->is_relative ();
+              bool relative = check_relative && fcn->is_relative ();
 
-	      if (tc < Vlast_prompt_time
-		  || (relative && tc < Vlast_chdir_time))
-		{
-		  bool clear_breakpoints = false;
+              if (tc < Vlast_prompt_time
+                  || (relative && tc < Vlast_chdir_time))
+                {
+                  bool clear_breakpoints = false;
                   std::string nm = fcn->name ();
 
                   bool is_same_file = false;
 
                   std::string file;
                   std::string dir_name;
 
                   if (check_relative)
@@ -223,77 +223,77 @@ out_of_date_check (octave_value& functio
                         is_same_file = same_file (file, ff);
                     }
                   else
                     {
                       is_same_file = true;
                       file = ff;
                     }
 
-		  if (file.empty ())
-		    {
-		      // Can't see this function from current
-		      // directory, so we should clear it.
+                  if (file.empty ())
+                    {
+                      // Can't see this function from current
+                      // directory, so we should clear it.
 
-		      function = octave_value ();
+                      function = octave_value ();
 
-		      clear_breakpoints = true;
-		    }
-		  else if (is_same_file)
-		    {
-		      // Same file.  If it is out of date, then reload it.
+                      clear_breakpoints = true;
+                    }
+                  else if (is_same_file)
+                    {
+                      // Same file.  If it is out of date, then reload it.
 
-		      octave_time ottp = fcn->time_parsed ();
-		      time_t tp = ottp.unix_time ();
+                      octave_time ottp = fcn->time_parsed ();
+                      time_t tp = ottp.unix_time ();
 
-		      fcn->mark_fcn_file_up_to_date (octave_time ());
+                      fcn->mark_fcn_file_up_to_date (octave_time ());
 
-		      if (! (Vignore_function_time_stamp == 2
-			     || (Vignore_function_time_stamp
-				 && fcn->is_system_fcn_file ())))
-			{
-			  file_stat fs (ff);
+                      if (! (Vignore_function_time_stamp == 2
+                             || (Vignore_function_time_stamp
+                                 && fcn->is_system_fcn_file ())))
+                        {
+                          file_stat fs (ff);
 
-			  if (fs)
-			    {
-			      if (fs.is_newer (tp))
-				{
-				  retval = load_out_of_date_fcn (ff, dir_name,
-								 function,
-								 dispatch_type);
+                          if (fs)
+                            {
+                              if (fs.is_newer (tp))
+                                {
+                                  retval = load_out_of_date_fcn (ff, dir_name,
+                                                                 function,
+                                                                 dispatch_type);
 
-				  clear_breakpoints = true;
-				}
-			    }
-			  else
-			    {
-			      function = octave_value ();
+                                  clear_breakpoints = true;
+                                }
+                            }
+                          else
+                            {
+                              function = octave_value ();
 
-			      clear_breakpoints = true;
-			    }
-			}
-		    }
-		  else
-		    {
-		      // Not the same file, so load the new file in
-		      // place of the old.
+                              clear_breakpoints = true;
+                            }
+                        }
+                    }
+                  else
+                    {
+                      // Not the same file, so load the new file in
+                      // place of the old.
 
-		      retval = load_out_of_date_fcn (file, dir_name, function,
-						     dispatch_type);
+                      retval = load_out_of_date_fcn (file, dir_name, function,
+                                                     dispatch_type);
 
-		      clear_breakpoints = true;
-		    }
+                      clear_breakpoints = true;
+                    }
 
-		  // If the function has been replaced then clear any 
-		  // breakpoints associated with it
-		  if (clear_breakpoints)
-		    bp_table::remove_all_breakpoints_in_file (nm, true);
-		}
-	    }
-	}
+                  // If the function has been replaced then clear any 
+                  // breakpoints associated with it
+                  if (clear_breakpoints)
+                    bp_table::remove_all_breakpoints_in_file (nm, true);
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::load_private_function
   (const std::string& dir_name)
@@ -302,35 +302,35 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
   std::string file_name = load_path::find_private_fcn (dir_name, name);
 
   if (! file_name.empty ())
     {
       octave_function *fcn = load_fcn_from_file (file_name, dir_name);
 
       if (fcn)
-	{
-	  std::string class_name;
+        {
+          std::string class_name;
 
-	  size_t pos = dir_name.find_last_of (file_ops::dir_sep_chars ());
+          size_t pos = dir_name.find_last_of (file_ops::dir_sep_chars ());
 
-	  if (pos != std::string::npos)
-	    {
-	      std::string tmp = dir_name.substr (pos+1);
+          if (pos != std::string::npos)
+            {
+              std::string tmp = dir_name.substr (pos+1);
 
-	      if (tmp[0] == '@')
-		class_name = tmp.substr (1);
-	    }
+              if (tmp[0] == '@')
+                class_name = tmp.substr (1);
+            }
 
-	  fcn->mark_as_private_function (class_name);
+          fcn->mark_as_private_function (class_name);
 
-	  retval = octave_value (fcn);
+          retval = octave_value (fcn);
 
-	  private_functions[dir_name] = retval;
-	}
+          private_functions[dir_name] = retval;
+        }
     }
 
   return retval;
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::load_class_constructor (void)
 {
@@ -340,21 +340,21 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
   std::string file_name = load_path::find_method (name, name, dir_name);
 
   if (! file_name.empty ())
     {
       octave_function *fcn = load_fcn_from_file (file_name, dir_name, name);
 
       if (fcn)
-	{
-	  retval = octave_value (fcn);
+        {
+          retval = octave_value (fcn);
 
-	  class_constructors[name] = retval;
-	}
+          class_constructors[name] = retval;
+        }
     }
 
   return retval;
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::load_class_method
   (const std::string& dispatch_type)
@@ -363,30 +363,30 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
   if (name == dispatch_type)
     retval = load_class_constructor ();
   else
     {
       std::string dir_name;
 
       std::string file_name = load_path::find_method (dispatch_type, name,
-						      dir_name);
+                                                      dir_name);
 
       if (! file_name.empty ())
-	{
-	  octave_function *fcn = load_fcn_from_file (file_name, dir_name,
-						     dispatch_type);
+        {
+          octave_function *fcn = load_fcn_from_file (file_name, dir_name,
+                                                     dispatch_type);
 
-	  if (fcn)
-	    {
-	      retval = octave_value (fcn);
+          if (fcn)
+            {
+              retval = octave_value (fcn);
 
-	      class_methods[dispatch_type] = retval;
-	    }
-	}
+              class_methods[dispatch_type] = retval;
+            }
+        }
 
       if (retval.is_undefined ())
         {
           // Search parent classes
 
           const_parent_map_iterator r = parent_map.find (dispatch_type);
 
           if (r != parent_map.end ())
@@ -418,36 +418,36 @@ symbol_table::fcn_info::fcn_info_rep::pr
 {
   if (dispatch_map.empty ())
     os << "dispatch: " << name << " is not overloaded" << std::endl;
   else
     {
       os << "Overloaded function " << name << ":\n\n";
 
       for (dispatch_map_const_iterator p = dispatch_map.begin ();
-	   p != dispatch_map.end (); p++)
-	os << "  " << name << " (" << p->first << ", ...) -> " 
-	   << p->second << " (" << p->first << ", ...)\n";
+           p != dispatch_map.end (); p++)
+        os << "  " << name << " (" << p->first << ", ...) -> " 
+           << p->second << " (" << p->first << ", ...)\n";
 
       os << std::endl;
     }
 }
 
 std::string
 symbol_table::fcn_info::fcn_info_rep::help_for_dispatch (void) const
 {
   std::string retval;
 
   if (! dispatch_map.empty ())
     {
       retval = "Overloaded function:\n\n";
 
       for (dispatch_map_const_iterator p = dispatch_map.begin ();
-	   p != dispatch_map.end (); p++)
-	retval += "  " + p->second + " (" + p->first + ", ...)\n\n";
+           p != dispatch_map.end (); p++)
+        retval += "  " + p->second + " (" + p->first + ", ...)\n\n";
     }
 
   return retval;
 }
 
 // :-) JWE, can you parse this? Returns a 2D array with second dimension equal
 // to btyp_num_types (static constant). Only the leftmost dimension can be
 // variable in C/C++. Typedefs are boring.
@@ -484,22 +484,22 @@ get_dispatch_type (const octave_value_li
 
   int n = args.length ();
 
   if (n > 0)
     {
       // Find first object, if any.
 
       for (int i = 0; i < n; i++)
-	{
-	  octave_value arg = args(i);
+        {
+          octave_value arg = args(i);
 
-	  if (arg.is_object ())
-	    {
-	      dispatch_type = arg.class_name ();
+          if (arg.is_object ())
+            {
+              dispatch_type = arg.class_name ();
               for (int j = i+1; j < n; j++)
                 {
                   octave_value arg1 = args(j);
 
                   if (arg1.is_object ())
                     {
                       std::string cname = arg1.class_name ();
 
@@ -508,18 +508,18 @@ get_dispatch_type (const octave_value_li
                       if (! symbol_table::is_superiorto (dispatch_type, cname)
                           && symbol_table::is_superiorto (cname, dispatch_type))
                         dispatch_type = cname;
                     }
                 }
 
               builtin_class = false;
               break;
-	    }
-	}
+            }
+        }
 
       // No object.
 
       if (builtin_class)
         {
           // Use the builtin_type mechanism to do this by one method call per
           // element. 
 
@@ -670,34 +670,34 @@ symbol_table::fcn_info::fcn_info_rep::xf
 
   str_val_iterator q = class_constructors.find (name);
 
   if (q == class_constructors.end ())
     {
       octave_value val = load_class_constructor ();
 
       if (val.is_defined ())
-	return val;
+        return val;
     }
   else
     {
       octave_value& fval = q->second;
 
       if (fval.is_defined ())
-	out_of_date_check (fval, name);
+        out_of_date_check (fval, name);
 
       if (fval.is_defined ())
-	return fval;
+        return fval;
       else
-	{
-	  octave_value val = load_class_constructor ();
+        {
+          octave_value val = load_class_constructor ();
 
-	  if (val.is_defined ())
-	    return val;
-	}
+          if (val.is_defined ())
+            return val;
+        }
     }
 
   // Class methods.
 
   if (! args.empty ())
     {
       std::string dispatch_type = get_dispatch_type (args);
 
@@ -713,28 +713,28 @@ symbol_table::fcn_info::fcn_info_rep::xf
     {
       std::string dispatch_type = args(0).type_name ();
 
       std::string fname;
 
       dispatch_map_iterator p = dispatch_map.find (dispatch_type);
 
       if (p == dispatch_map.end ())
-	p = dispatch_map.find ("any");
+        p = dispatch_map.find ("any");
 
       if (p != dispatch_map.end ())
-	{
-	  fname = p->second;
+        {
+          fname = p->second;
 
-	  octave_value fcn
-	    = symbol_table::find_function (fname, args);
+          octave_value fcn
+            = symbol_table::find_function (fname, args);
 
-	  if (fcn.is_defined ())
-	    return fcn;
-	}
+          if (fcn.is_defined ())
+            return fcn;
+        }
     }
 
   // Command-line function.
 
   if (cmdline_function.is_defined ())
     return cmdline_function;
 
   // Autoload?
@@ -824,44 +824,44 @@ symbol_table::fcn_info::fcn_info_rep::x_
 
   octave_user_function *curr_fcn = symbol_table::get_curr_fcn ();
 
   if (curr_fcn)
     {
       std::string dir_name = curr_fcn->dir_name ();
 
       if (! dir_name.empty ())
-	{
-	  str_val_iterator q = private_functions.find (dir_name);
+        {
+          str_val_iterator q = private_functions.find (dir_name);
 
-	  if (q == private_functions.end ())
-	    {
-	      octave_value val = load_private_function (dir_name);
+          if (q == private_functions.end ())
+            {
+              octave_value val = load_private_function (dir_name);
 
-	      if (val.is_defined ())
-		return val;
-	    }
-	  else
-	    {
-	      octave_value& fval = q->second;
+              if (val.is_defined ())
+                return val;
+            }
+          else
+            {
+              octave_value& fval = q->second;
 
-	      if (fval.is_defined ())
-		out_of_date_check (fval);
+              if (fval.is_defined ())
+                out_of_date_check (fval);
 
-	      if (fval.is_defined ())
-		return fval;
-	      else
-		{
-		  octave_value val = load_private_function (dir_name);
+              if (fval.is_defined ())
+                return fval;
+              else
+                {
+                  octave_value val = load_private_function (dir_name);
 
-		  if (val.is_defined ())
-		    return val;
-		}
-	    }
-	}
+                  if (val.is_defined ())
+                    return val;
+                }
+            }
+        }
     }
 
   // Subfunction.  I think it only makes sense to check for
   // subfunctions if we are currently executing a function defined
   // from a .m file.
 
   scope_val_iterator r = subfunctions.find (xcurrent_scope);
 
@@ -871,26 +871,26 @@ symbol_table::fcn_info::fcn_info_rep::x_
 
       return r->second;
     }
   else if (curr_fcn)
     {
       scope_id pscope = curr_fcn->parent_fcn_scope ();
 
       if (pscope > 0)
-	{
-	  r = subfunctions.find (pscope);
+        {
+          r = subfunctions.find (pscope);
 
-	  if (r != subfunctions.end ())
-	    {
-	      // FIXME -- out-of-date check here.
+          if (r != subfunctions.end ())
+            {
+              // FIXME -- out-of-date check here.
 
-	      return r->second;
-	    }
-	}
+              return r->second;
+            }
+        }
     }
 
   return octave_value ();
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find_method (const std::string& dispatch_type)
 {
@@ -898,34 +898,34 @@ symbol_table::fcn_info::fcn_info_rep::fi
 
   str_val_iterator q = class_methods.find (dispatch_type);
 
   if (q == class_methods.end ())
     {
       octave_value val = load_class_method (dispatch_type);
 
       if (val.is_defined ())
-	return val;
+        return val;
     }
   else
     {
       octave_value& fval = q->second;
 
       if (fval.is_defined ())
-	out_of_date_check (fval, dispatch_type);
+        out_of_date_check (fval, dispatch_type);
 
       if (fval.is_defined ())
-	return fval;
+        return fval;
       else
-	{
-	  octave_value val = load_class_method (dispatch_type);
+        {
+          octave_value val = load_class_method (dispatch_type);
 
-	  if (val.is_defined ())
-	    return val;
-	}
+          if (val.is_defined ())
+            return val;
+        }
     }
 
   return retval;
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find_autoload (void)
 {
@@ -936,27 +936,27 @@ symbol_table::fcn_info::fcn_info_rep::fi
   if (autoload_function.is_defined ())
     out_of_date_check (autoload_function);
 
   if (! autoload_function.is_defined ())
     {
       std::string file_name = lookup_autoload (name);
 
       if (! file_name.empty ())
-	{
-	  size_t pos = file_name.find_last_of (file_ops::dir_sep_chars ());
+        {
+          size_t pos = file_name.find_last_of (file_ops::dir_sep_chars ());
 
-	  std::string dir_name = file_name.substr (0, pos);
+          std::string dir_name = file_name.substr (0, pos);
 
-	  octave_function *fcn = load_fcn_from_file (file_name, dir_name,
-						     "", name, true);
+          octave_function *fcn = load_fcn_from_file (file_name, dir_name,
+                                                     "", name, true);
 
-	  if (fcn)
-	    autoload_function = octave_value (fcn);
-	}
+          if (fcn)
+            autoload_function = octave_value (fcn);
+        }
     }
 
   return autoload_function;
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find_user_function (void)
 {
@@ -967,47 +967,47 @@ symbol_table::fcn_info::fcn_info_rep::fi
 
   if (! function_on_path.is_defined ())
     {
       std::string dir_name;
 
       std::string file_name = load_path::find_fcn (name, dir_name);
 
       if (! file_name.empty ())
-	{
-	  octave_function *fcn = load_fcn_from_file (file_name, dir_name);
+        {
+          octave_function *fcn = load_fcn_from_file (file_name, dir_name);
 
-	  if (fcn)
-	    function_on_path = octave_value (fcn);
-	}
+          if (fcn)
+            function_on_path = octave_value (fcn);
+        }
     }
 
   return function_on_path;
 }
 
 // Insert INF_CLASS in the set of class names that are considered
 // inferior to SUP_CLASS.  Return FALSE if INF_CLASS is currently
 // marked as superior to  SUP_CLASS.
 
 bool
 symbol_table::set_class_relationship (const std::string& sup_class,
-				      const std::string& inf_class)
+                                      const std::string& inf_class)
 {
   class_precedence_table_const_iterator p
     = class_precedence_table.find (inf_class);
 
   if (p != class_precedence_table.end ())
     {
       const std::set<std::string>& inferior_classes = p->second;
 
       std::set<std::string>::const_iterator q
-	= inferior_classes.find (sup_class);
+        = inferior_classes.find (sup_class);
 
       if (q != inferior_classes.end ())
-	return false;
+        return false;
     }
 
   class_precedence_table[sup_class].insert (inf_class);
 
   return true;
 }
 
 // Has class A been marked as superior to class B?  Also returns
@@ -1031,17 +1031,17 @@ symbol_table::is_superiorto (const std::
   class_precedence_table_const_iterator p = class_precedence_table.find (a);
 
   if (p != class_precedence_table.end ())
     {
       const std::set<std::string>& inferior_classes = p->second;
       std::set<std::string>::const_iterator q = inferior_classes.find (b);
 
       if (q != inferior_classes.end ())
-	retval = true;
+        retval = true;
     }
 
   return retval;
 }
 
 static std::string
 fcn_file_name (const octave_value& fcn)
 {
@@ -1068,51 +1068,51 @@ symbol_table::fcn_info::fcn_info_rep::du
 
   if (function_on_path.is_defined ())
     os << tprefix << "function from path: "
        << fcn_file_name (function_on_path) << "\n";
 
   if (! subfunctions.empty ())
     {
       for (scope_val_const_iterator p = subfunctions.begin ();
-	   p != subfunctions.end (); p++)
-	os << tprefix << "subfunction: " << fcn_file_name (p->second)
-	   << " [" << p->first << "]\n";
+           p != subfunctions.end (); p++)
+        os << tprefix << "subfunction: " << fcn_file_name (p->second)
+           << " [" << p->first << "]\n";
     }
 
   if (! private_functions.empty ())
     {
       for (str_val_const_iterator p = private_functions.begin ();
-	   p != private_functions.end (); p++)
-	os << tprefix << "private: " << fcn_file_name (p->second)
-	   << " [" << p->first << "]\n";
+           p != private_functions.end (); p++)
+        os << tprefix << "private: " << fcn_file_name (p->second)
+           << " [" << p->first << "]\n";
     }
 
   if (! class_constructors.empty ())
     {
       for (str_val_const_iterator p = class_constructors.begin ();
-	   p != class_constructors.end (); p++)
-	os << tprefix << "constructor: " << fcn_file_name (p->second)
-	   << " [" << p->first << "]\n";
+           p != class_constructors.end (); p++)
+        os << tprefix << "constructor: " << fcn_file_name (p->second)
+           << " [" << p->first << "]\n";
     }
 
   if (! class_methods.empty ())
     {
       for (str_val_const_iterator p = class_methods.begin ();
-	   p != class_methods.end (); p++)
-	os << tprefix << "method: " << fcn_file_name (p->second)
-	   << " [" << p->first << "]\n";
+           p != class_methods.end (); p++)
+        os << tprefix << "method: " << fcn_file_name (p->second)
+           << " [" << p->first << "]\n";
     }
 
   if (! dispatch_map.empty ())
     {
       for (dispatch_map_const_iterator p = dispatch_map.begin ();
-	   p != dispatch_map.end (); p++)
-	os << tprefix << "dispatch: " << fcn_file_name (p->second)
-	   << " [" << p->first << "]\n";
+           p != dispatch_map.end (); p++)
+        os << tprefix << "dispatch: " << fcn_file_name (p->second)
+           << " [" << p->first << "]\n";
     }
 }
 
 octave_value
 symbol_table::find (const std::string& name, 
                     const octave_value_list& args, 
                     bool skip_variables,
                     bool local_funcs)
@@ -1138,199 +1138,199 @@ symbol_table::find_function (const std::
                              bool local_funcs)
 {
   octave_value retval;
 
   if (! name.empty () && name[0] == '@')
     {
       // Look for a class specific function.
       std::string dispatch_type = 
-	name.substr (1, name.find_first_of (file_ops::dir_sep_str ()) - 1);
+        name.substr (1, name.find_first_of (file_ops::dir_sep_str ()) - 1);
 
       std::string method = 
-	name.substr (name.find_last_of (file_ops::dir_sep_str ()) + 1, 
-		     std::string::npos);
+        name.substr (name.find_last_of (file_ops::dir_sep_str ()) + 1, 
+                     std::string::npos);
 
       retval = find_method (method, dispatch_type);
     }
   else
     {
       size_t pos = name.find_first_of (Vfilemarker);
 
       if (pos == std::string::npos)
-	retval = find (name, args, true, local_funcs);
+        retval = find (name, args, true, local_funcs);
       else
-	{
-	  std::string fcn_scope = name.substr (0, pos);
-	  scope_id stored_scope = xcurrent_scope;
-	  xcurrent_scope = xtop_scope;
-	  octave_value parent = find_function (name.substr(0, pos),
+        {
+          std::string fcn_scope = name.substr (0, pos);
+          scope_id stored_scope = xcurrent_scope;
+          xcurrent_scope = xtop_scope;
+          octave_value parent = find_function (name.substr(0, pos),
                                                octave_value_list (), false);
 
-	  if (parent.is_defined ())
-	    {
-	      octave_function *parent_fcn = parent.function_value ();
+          if (parent.is_defined ())
+            {
+              octave_function *parent_fcn = parent.function_value ();
 
-	      if (parent_fcn)
-		{
-		  xcurrent_scope = parent_fcn->scope ();
+              if (parent_fcn)
+                {
+                  xcurrent_scope = parent_fcn->scope ();
 
-		  if (xcurrent_scope > 1)
-		    retval = find_function (name.substr (pos + 1), args);
-		}
-	    }
+                  if (xcurrent_scope > 1)
+                    retval = find_function (name.substr (pos + 1), args);
+                }
+            }
 
-	  xcurrent_scope = stored_scope;
-	}
+          xcurrent_scope = stored_scope;
+        }
     }
 
   return retval;
 }
 
 void
 symbol_table::dump (std::ostream& os, scope_id scope)
 {
   if (scope == xglobal_scope)
     dump_global (os);
   else
     {
       symbol_table *inst = get_instance (scope, false);
 
       if (inst)
-	{
-	  os << "*** dumping symbol table scope " << scope
-	     << " (" << inst->table_name << ")\n\n";
+        {
+          os << "*** dumping symbol table scope " << scope
+             << " (" << inst->table_name << ")\n\n";
 
-	  std::map<std::string, octave_value> sfuns
-	    = symbol_table::subfunctions_defined_in_scope (scope);
+          std::map<std::string, octave_value> sfuns
+            = symbol_table::subfunctions_defined_in_scope (scope);
 
-	  if (! sfuns.empty ())
-	    {
-	      os << "  subfunctions defined in this scope:\n";
+          if (! sfuns.empty ())
+            {
+              os << "  subfunctions defined in this scope:\n";
 
-	      for (std::map<std::string, octave_value>::const_iterator p = sfuns.begin ();
-		   p != sfuns.end (); p++)
-		os << "    " << p->first << "\n";
+              for (std::map<std::string, octave_value>::const_iterator p = sfuns.begin ();
+                   p != sfuns.end (); p++)
+                os << "    " << p->first << "\n";
 
-	      os << "\n";
-	    }
+              os << "\n";
+            }
 
-	  inst->do_dump (os);
-	}
+          inst->do_dump (os);
+        }
     }
 }
 
 void
 symbol_table::dump_global (std::ostream& os)
 {
   if (! global_table.empty ())
     {
       os << "*** dumping global symbol table\n\n";
 
       for (global_table_const_iterator p = global_table.begin ();
-	   p != global_table.end (); p++)
-	{
-	  std::string nm = p->first;
-	  octave_value val = p->second;
+           p != global_table.end (); p++)
+        {
+          std::string nm = p->first;
+          octave_value val = p->second;
 
-	  os << "  " << nm << " ";
-	  val.dump (os);
-	  os << "\n";
-	}
+          os << "  " << nm << " ";
+          val.dump (os);
+          os << "\n";
+        }
     }
 }
 
 void
 symbol_table::dump_functions (std::ostream& os)
 {
   if (! fcn_table.empty ())
     {
       os << "*** dumping globally visible functions from symbol table\n"
-	 << "    (c=commandline, b=built-in)\n\n";
+         << "    (c=commandline, b=built-in)\n\n";
 
       for (fcn_table_const_iterator p = fcn_table.begin ();
-	   p != fcn_table.end (); p++)
-	p->second.dump (os, "  ");
+           p != fcn_table.end (); p++)
+        p->second.dump (os, "  ");
 
       os << "\n";
     }
 }
 
 void
 symbol_table::stash_dir_name_for_subfunctions (scope_id scope,
-					       const std::string& dir_name)
+                                               const std::string& dir_name)
 {
   // FIXME -- is this the best way to do this?  Maybe it would be
   // better if we had a map from scope to list of subfunctions
   // stored with the function.  Do we?
 
   for (fcn_table_const_iterator p = fcn_table.begin ();
        p != fcn_table.end (); p++)
     {
       std::pair<std::string, octave_value> tmp
-	= p->second.subfunction_defined_in_scope (scope);
+        = p->second.subfunction_defined_in_scope (scope);
 
       std::string nm = tmp.first;
 
       if (! nm.empty ())
-	{
-	  octave_value& fcn = tmp.second;
+        {
+          octave_value& fcn = tmp.second;
 
-	  octave_user_function *f = fcn.user_function_value ();
+          octave_user_function *f = fcn.user_function_value ();
 
-	  if (f)
-	    f->stash_dir_name (dir_name);
-	}
+          if (f)
+            f->stash_dir_name (dir_name);
+        }
     }
 }
 
 octave_value
 symbol_table::do_find (const std::string& name, 
                        const octave_value_list& args,
-		       bool skip_variables,
+                       bool skip_variables,
                        bool local_funcs)
 {
   octave_value retval;
 
   // Variable.
 
   if (! skip_variables)
     {
       table_iterator p = table.find (name);
 
       if (p != table.end ())
-	{
-	  symbol_record sr = p->second;
+        {
+          symbol_record sr = p->second;
 
-	  // FIXME -- should we be using something other than varref here?
+          // FIXME -- should we be using something other than varref here?
 
-	  if (sr.is_global ())
-	    return symbol_table::global_varref (name);
-	  else
-	    {
-	      octave_value& val = sr.varref ();
+          if (sr.is_global ())
+            return symbol_table::global_varref (name);
+          else
+            {
+              octave_value& val = sr.varref ();
 
-	      if (val.is_defined ())
-		return val;
-	    }
-	}
+              if (val.is_defined ())
+                return val;
+            }
+        }
     }
 
   fcn_table_iterator p = fcn_table.find (name);
 
   if (p != fcn_table.end ())
     return p->second.find (args, local_funcs);
   else
     {
       fcn_info finfo (name);
 
       octave_value fcn = finfo.find (args, local_funcs);
 
       if (fcn.is_defined ())
-	fcn_table[name] = finfo;
+        fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
 }
 
 octave_value
@@ -1344,52 +1344,52 @@ symbol_table::do_builtin_find (const std
     return p->second.builtin_find ();
   else
     {
       fcn_info finfo (name);
 
       octave_value fcn = finfo.builtin_find ();
 
       if (fcn.is_defined ())
-	fcn_table[name] = finfo;
+        fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
 }
 
 void
 symbol_table::do_dump (std::ostream& os)
 {
   if (! persistent_table.empty ())
     {
       os << "  persistent variables in this scope:\n\n";
 
       for (persistent_table_const_iterator p = persistent_table.begin ();
-	   p != persistent_table.end (); p++)
-	{
-	  std::string nm = p->first;
-	  octave_value val = p->second;
+           p != persistent_table.end (); p++)
+        {
+          std::string nm = p->first;
+          octave_value val = p->second;
 
-	  os << "    " << nm << " ";
-	  val.dump (os);
-	  os << "\n";
-	}
+          os << "    " << nm << " ";
+          val.dump (os);
+          os << "\n";
+        }
 
       os << "\n";
     }
 
   if (! table.empty ())
     {
       os << "  other symbols in this scope (l=local; a=auto; f=formal\n"
-	 << "    h=hidden; i=inherited; g=global; p=persistent)\n\n";
+         << "    h=hidden; i=inherited; g=global; p=persistent)\n\n";
 
       for (table_const_iterator p = table.begin (); p != table.end (); p++)
-	p->second.dump (os, "    ");
+        p->second.dump (os, "    ");
 
       os << "\n";
     }
 }
 
 void symbol_table::cleanup (void)
 {
   // Clear variables in top scope.
@@ -1440,50 +1440,50 @@ on files to determine whether functions 
 need to recompiled.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (nargout > 0)
     {
       switch (Vignore_function_time_stamp)
-	{
-	case 1:
-	  retval = "system";
-	  break;
+        {
+        case 1:
+          retval = "system";
+          break;
 
-	case 2:
-	  retval = "all";
-	  break;
+        case 2:
+          retval = "all";
+          break;
 
-	default:
-	  retval = "none";
-	  break;
-	}
+        default:
+          retval = "none";
+          break;
+        }
     }
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).string_value ();
 
       if (! error_state)
-	{
-	  if (sval == "all")
-	    Vignore_function_time_stamp = 2;
-	  else if (sval == "system")
-	    Vignore_function_time_stamp = 1;
-	  else if (sval == "none")
-	    Vignore_function_time_stamp = 0;
-	  else
-	    error ("ignore_function_time_stamp: expecting argument to be \"all\", \"system\", or \"none\"");
-	}
+        {
+          if (sval == "all")
+            Vignore_function_time_stamp = 2;
+          else if (sval == "system")
+            Vignore_function_time_stamp = 1;
+          else if (sval == "none")
+            Vignore_function_time_stamp = 0;
+          else
+            error ("ignore_function_time_stamp: expecting argument to be \"all\", \"system\", or \"none\"");
+        }
       else
-	error ("ignore_function_time_stamp: expecting argument to be character string");
+        error ("ignore_function_time_stamp: expecting argument to be character string");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__current_scope__, , ,
@@ -1517,57 +1517,57 @@ Undocumented internal function.\n\
     {
       symbol_table::dump_functions (octave_stdout);
 
       symbol_table::dump_global (octave_stdout);
 
       std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
 
       for (std::list<symbol_table::scope_id>::const_iterator p = lst.begin ();
-	   p != lst.end (); p++)
-	symbol_table::dump (octave_stdout, *p);
+           p != lst.end (); p++)
+        symbol_table::dump (octave_stdout, *p);
     }
   else if (nargin == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_string ())
-	{
-	  std::string s_arg = arg.string_value ();
+        {
+          std::string s_arg = arg.string_value ();
 
-	  if (s_arg == "scopes")
-	    {
-	      std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
+          if (s_arg == "scopes")
+            {
+              std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
 
-	      RowVector v (lst.size ());
+              RowVector v (lst.size ());
 
-	      octave_idx_type k = 0;
+              octave_idx_type k = 0;
 
-	      for (std::list<symbol_table::scope_id>::const_iterator p = lst.begin ();
-		   p != lst.end (); p++)
-		v.xelem (k++) = *p;
+              for (std::list<symbol_table::scope_id>::const_iterator p = lst.begin ();
+                   p != lst.end (); p++)
+                v.xelem (k++) = *p;
 
-	      retval = v;
-	    }
-	  else if (s_arg == "functions")
-	    {
-	      symbol_table::dump_functions (octave_stdout);
-	    }
-	  else
-	    error ("__dump_symtab_info__: expecting \"functions\" or \"scopes\"");
-	}
+              retval = v;
+            }
+          else if (s_arg == "functions")
+            {
+              symbol_table::dump_functions (octave_stdout);
+            }
+          else
+            error ("__dump_symtab_info__: expecting \"functions\" or \"scopes\"");
+        }
       else
-	{
-	  int s = arg.int_value ();
+        {
+          int s = arg.int_value ();
 
-	  if (! error_state)
-	    symbol_table::dump (octave_stdout, s);
-	  else
-	    error ("__dump_symtab_info__: expecting string or scope id");
-	}
+          if (! error_state)
+            symbol_table::dump (octave_stdout, s);
+          else
+            error ("__dump_symtab_info__: expecting string or scope id");
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #if 0
@@ -1578,43 +1578,43 @@ DEFUN (set_variable, args, , "set_variab
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	symbol_table::varref (name) = args(1);
+        symbol_table::varref (name) = args(1);
       else
-	error ("set_variable: expecting variable name as first argument");
+        error ("set_variable: expecting variable name as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (variable_value, args, , "VALUE = variable_value (NAME)")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	{
-	  retval = symbol_table::varval (name);
+        {
+          retval = symbol_table::varval (name);
 
-	  if (retval.is_undefined ())
-	    error ("variable_value: `%s' is not a variable in the current scope",
-		   name.c_str ());
-	}
+          if (retval.is_undefined ())
+            error ("variable_value: `%s' is not a variable in the current scope",
+                   name.c_str ());
+        }
       else
-	error ("variable_value: expecting variable name as first argument");
+        error ("variable_value: expecting variable name as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 #endif
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -100,41 +100,41 @@ system-dependent error message.\n\
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_stream old_stream
-	= octave_stream_list::lookup (args(0), "dup2");
+        = octave_stream_list::lookup (args(0), "dup2");
 
       if (! error_state)
-	{
-	  octave_stream new_stream
-	    = octave_stream_list::lookup (args(1), "dup2");
+        {
+          octave_stream new_stream
+            = octave_stream_list::lookup (args(1), "dup2");
 
-	  if (! error_state)
-	    {
-	      int i_old = old_stream.file_number ();
-	      int i_new = new_stream.file_number ();
+          if (! error_state)
+            {
+              int i_old = old_stream.file_number ();
+              int i_new = new_stream.file_number ();
 
-	      if (i_old >= 0 && i_new >= 0)
-		{
-		  std::string msg;
+              if (i_old >= 0 && i_new >= 0)
+                {
+                  std::string msg;
 
-		  int status = octave_syscalls::dup2 (i_old, i_new, msg);
+                  int status = octave_syscalls::dup2 (i_old, i_new, msg);
 
-		  retval(0) = status;
-		  retval(1) = msg;
-		}
-	    }
-	}
+                  retval(0) = status;
+                  retval(1) = msg;
+                }
+            }
+        }
       else
-	error ("dup2: invalid stream");
+        error ("dup2: invalid stream");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("exec", Fexec, args, ,
@@ -163,56 +163,56 @@ error message.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string exec_file = args(0).string_value ();
 
       if (! error_state)
-	{
-	  string_vector exec_args;
+        {
+          string_vector exec_args;
 
-	  if (nargin == 2)
-	    {
-	      string_vector tmp = args(1).all_strings ();
+          if (nargin == 2)
+            {
+              string_vector tmp = args(1).all_strings ();
 
-	      if (! error_state)
-		{
-		  int len = tmp.length ();
+              if (! error_state)
+                {
+                  int len = tmp.length ();
 
-		  exec_args.resize (len + 1);
+                  exec_args.resize (len + 1);
 
-		  exec_args[0] = exec_file;
+                  exec_args[0] = exec_file;
 
-		  for (int i = 0; i < len; i++)
-		    exec_args[i+1] = tmp[i];
-		}
-	      else
-		error ("exec: arguments must be character strings");
-	    }
-	  else
-	    {
-	      exec_args.resize (1);
+                  for (int i = 0; i < len; i++)
+                    exec_args[i+1] = tmp[i];
+                }
+              else
+                error ("exec: arguments must be character strings");
+            }
+          else
+            {
+              exec_args.resize (1);
 
-	      exec_args[0] = exec_file;
-	    }
+              exec_args[0] = exec_file;
+            }
 
-	  if (! error_state)
-	    {
-	      std::string msg;
+          if (! error_state)
+            {
+              std::string msg;
 
-	      int status = octave_syscalls::execvp (exec_file, exec_args, msg);
+              int status = octave_syscalls::execvp (exec_file, exec_args, msg);
 
-	      retval(0) = status;
-	      retval(1) = msg;
-	    }
-	}
+              retval(0) = status;
+              retval(1) = msg;
+            }
+        }
       else
-	error ("exec: first argument must be a string");
+        error ("exec: first argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("popen2", Fpopen2, args, ,
@@ -267,42 +267,42 @@ exit status, it will linger until Octave
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
     {
       std::string exec_file = args(0).string_value();
 
       if (! error_state)
         {
-	  string_vector arg_list;
+          string_vector arg_list;
 
-	  if (nargin >= 2)
-	    {
-	      string_vector tmp = args(1).all_strings ();
+          if (nargin >= 2)
+            {
+              string_vector tmp = args(1).all_strings ();
 
-	      if (! error_state)
-		{
-		  int len = tmp.length ();
+              if (! error_state)
+                {
+                  int len = tmp.length ();
 
-		  arg_list.resize (len + 1);
+                  arg_list.resize (len + 1);
 
-		  arg_list[0] = exec_file;
+                  arg_list[0] = exec_file;
 
-		  for (int i = 0; i < len; i++)
-		    arg_list[i+1] = tmp[i];
-		}
-	      else
-		error ("popen2: arguments must be character strings");
-	    }
-	  else
-	    {
-	      arg_list.resize (1);
+                  for (int i = 0; i < len; i++)
+                    arg_list[i+1] = tmp[i];
+                }
+              else
+                error ("popen2: arguments must be character strings");
+            }
+          else
+            {
+              arg_list.resize (1);
 
-	      arg_list[0] = exec_file;
-	    }
+              arg_list[0] = exec_file;
+            }
 
           if (! error_state)
             {
               bool sync_mode = (nargin == 3 ? args(2).bool_value() : false);
 
               if (! error_state)
                 {
                   int fildes[2];
@@ -322,19 +322,19 @@ exit status, it will linger until Octave
 
                       octave_stream os = octave_stdiostream::create (nm, ofile,
                           std::ios::out);
 
                       Cell file_ids (1, 2);
 
                       retval(0) = octave_stream_list::insert (os);
                       retval(1) = octave_stream_list::insert (is);
-					  retval(2) = pid;
+                                          retval(2) = pid;
                     }
-				  else
+                                  else
                     error (msg.c_str ());
                 }
             }
           else
             error ("popen2: arguments must be character strings");
         }
       else
         error ("popen2: first argument must be a string");
@@ -452,40 +452,40 @@ system-dependent error message.\n\
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
       octave_stream strm = octave_stream_list::lookup (args (0), "fcntl");
 
       if (! error_state)
-	{
-	  int fid = strm.file_number ();
+        {
+          int fid = strm.file_number ();
 
-	  int req = args(1).int_value (true);
-	  int arg = args(2).int_value (true);
+          int req = args(1).int_value (true);
+          int arg = args(2).int_value (true);
 
-	  if (! error_state)
-	    {
-	      // FIXME -- Need better checking here?
-	      if (fid < 0)
-		error ("fcntl: invalid file id");
-	      else
-		{
-		  std::string msg;
+          if (! error_state)
+            {
+              // FIXME -- Need better checking here?
+              if (fid < 0)
+                error ("fcntl: invalid file id");
+              else
+                {
+                  std::string msg;
 
-		  int status = octave_fcntl (fid, req, arg, msg);
+                  int status = octave_fcntl (fid, req, arg, msg);
 
-		  retval(0) = status;
-		  retval(1) = msg;
-		}
-	    }
-	}
+                  retval(0) = status;
+                  retval(1) = msg;
+                }
+            }
+        }
       else
-	error ("fcntl: file id, request, and argument must be integers");
+        error ("fcntl: file id, request, and argument must be integers");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("fork", Ffork, args, ,
@@ -694,29 +694,29 @@ Return 0 if successful, otherwise return
   retval(1) = std::string ();
   retval(0) = -1;
 
   if (args.length () == 2)
     {
       pid_t pid = args(0).int_value (true);
 
       if (! error_state)
-	{
-	  int sig = args(1).int_value (true);
+        {
+          int sig = args(1).int_value (true);
 
-	  if (! error_state)
-	    {
-	      std::string msg;
+          if (! error_state)
+            {
+              std::string msg;
 
-	      int status = octave_syscalls::kill (pid, sig, msg);
+              int status = octave_syscalls::kill (pid, sig, msg);
 
-	      retval(1) = msg;
-	      retval(0) = status;
-	    }
-	}
+              retval(1) = msg;
+              retval(0) = status;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("fstat", Ffstat, args, ,
@@ -728,32 +728,32 @@ for a description of the contents of @va
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       int fid = octave_stream_list::get_file_number (args(0));
 
       if (! error_state)
-	{
-	  file_fstat fs (fid);
+        {
+          file_fstat fs (fid);
 
-	  if (fs)
-	    {
-	      retval(2) = std::string ();
-	      retval(1) = 0;
-	      retval(0) = octave_value (mk_stat_map (fs));
-	    }
-	  else
-	    {
-	      retval(2) = fs.error ();
-	      retval(1) = -1;
-	      retval(0) = Matrix ();
-	    }
-	}
+          if (fs)
+            {
+              retval(2) = std::string ();
+              retval(1) = 0;
+              retval(0) = octave_value (mk_stat_map (fs));
+            }
+          else
+            {
+              retval(2) = fs.error ();
+              retval(1) = -1;
+              retval(0) = Matrix ();
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("lstat", Flstat, args, ,
@@ -764,32 +764,32 @@ See stat.\n\
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string fname = args(0).string_value ();
 
       if (! error_state)
-	{
-	  file_stat fs (fname, false);
+        {
+          file_stat fs (fname, false);
 
-	  if (fs)
-	    {
-	      retval(2) = std::string ();
-	      retval(1) = 0;
-	      retval(0) = mk_stat_map (fs);
-	    }
-	  else
-	    {
-	      retval(2) = fs.error ();
-	      retval(1) = -1;
-	      retval(0) = Matrix ();
-	    }
-	}
+          if (fs)
+            {
+              retval(2) = std::string ();
+              retval(1) = 0;
+              retval(0) = mk_stat_map (fs);
+            }
+          else
+            {
+              retval(2) = fs.error ();
+              retval(1) = -1;
+              retval(0) = Matrix ();
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 
@@ -809,42 +809,42 @@ system-dependent error message.\n\
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       if (args(0).is_string ())
-	{
-	  std::string name = args(0).string_value ();
+        {
+          std::string name = args(0).string_value ();
 
-	  if (args(1).is_scalar_type ())
-	    {
-	      long mode = args(1).long_value ();
+          if (args(1).is_scalar_type ())
+            {
+              long mode = args(1).long_value ();
 
-	      if (! error_state)
-		{
-		  std::string msg;
+              if (! error_state)
+                {
+                  std::string msg;
 
-		  int status = octave_mkfifo (name, mode, msg);
+                  int status = octave_mkfifo (name, mode, msg);
 
-		  retval(0) = status;
+                  retval(0) = status;
 
-		  if (status < 0)
-		    retval(1) = msg;
-		}
-	      else
-		error ("mkfifo: invalid MODE");
-	    }
-	  else
-	    error ("mkfifo: MODE must be an integer");
-	}
+                  if (status < 0)
+                    retval(1) = msg;
+                }
+              else
+                error ("mkfifo: invalid MODE");
+            }
+          else
+            error ("mkfifo: MODE must be an integer");
+        }
       else
-	error ("mkfifo: file name must be a string");
+        error ("mkfifo: file name must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("pipe", Fpipe, args, ,
@@ -871,35 +871,35 @@ system-dependent error message.\n\
     {
       int fid[2];
 
       std::string msg;
 
       int status = octave_syscalls::pipe (fid, msg);
 
       if (status < 0)
-	retval(3) = msg;
+        retval(3) = msg;
       else
-	{
-	  FILE *ifile = fdopen (fid[0], "r");
-	  FILE *ofile = fdopen (fid[1], "w");
+        {
+          FILE *ifile = fdopen (fid[0], "r");
+          FILE *ofile = fdopen (fid[1], "w");
 
-	  std::string nm;
+          std::string nm;
 
-	  octave_stream is = octave_stdiostream::create (nm, ifile,
-							 std::ios::in);
+          octave_stream is = octave_stdiostream::create (nm, ifile,
+                                                         std::ios::in);
 
-	  octave_stream os = octave_stdiostream::create (nm, ofile,
-							 std::ios::out);
+          octave_stream os = octave_stdiostream::create (nm, ofile,
+                                                         std::ios::out);
 
-	  retval(1) = octave_stream_list::insert (os);
-	  retval(0) = octave_stream_list::insert (is);
+          retval(1) = octave_stream_list::insert (os);
+          retval(0) = octave_stream_list::insert (is);
 
-	  retval(2) = status;
-	}
+          retval(2) = status;
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("stat", Fstat, args, ,
@@ -997,32 +997,32 @@ For example,\n\
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string fname = args(0).string_value ();
 
       if (! error_state)
-	{
-	  file_stat fs (fname);
+        {
+          file_stat fs (fname);
 
-	  if (fs)
-	    {
-	      retval(2) = std::string ();
-	      retval(1) = 0;
-	      retval(0) = octave_value (mk_stat_map (fs));
-	    }
-	  else
-	    {
-	      retval(2) = fs.error ();
-	      retval(1) = -1;
-	      retval(0) = Matrix ();
-	    }
-	}
+          if (fs)
+            {
+              retval(2) = std::string ();
+              retval(1) = 0;
+              retval(0) = octave_value (mk_stat_map (fs));
+            }
+          else
+            {
+              retval(2) = fs.error ();
+              retval(1) = -1;
+              retval(0) = Matrix ();
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISREG", FS_ISREG, args, ,
@@ -1035,19 +1035,19 @@ of @var{mode} is assumed to be returned 
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
-	retval = file_stat::is_reg (static_cast<mode_t> (mode));
+        retval = file_stat::is_reg (static_cast<mode_t> (mode));
       else
-	error ("S_ISREG: invalid mode value");
+        error ("S_ISREG: invalid mode value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
@@ -1060,19 +1060,19 @@ of @var{mode} is assumed to be returned 
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
-	retval = file_stat::is_dir (static_cast<mode_t> (mode));
+        retval = file_stat::is_dir (static_cast<mode_t> (mode));
       else
-	error ("S_ISDIR: invalid mode value");
+        error ("S_ISDIR: invalid mode value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
@@ -1085,19 +1085,19 @@ of @var{mode} is assumed to be returned 
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
-	retval = file_stat::is_chr (static_cast<mode_t> (mode));
+        retval = file_stat::is_chr (static_cast<mode_t> (mode));
       else
-	error ("S_ISCHR: invalid mode value");
+        error ("S_ISCHR: invalid mode value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
@@ -1110,19 +1110,19 @@ of @var{mode} is assumed to be returned 
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
-	retval = file_stat::is_blk (static_cast<mode_t> (mode));
+        retval = file_stat::is_blk (static_cast<mode_t> (mode));
       else
-	error ("S_ISBLK: invalid mode value");
+        error ("S_ISBLK: invalid mode value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
@@ -1135,19 +1135,19 @@ of @var{mode} is assumed to be returned 
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
-	retval = file_stat::is_fifo (static_cast<mode_t> (mode));
+        retval = file_stat::is_fifo (static_cast<mode_t> (mode));
       else
-	error ("S_ISFIFO: invalid mode value");
+        error ("S_ISFIFO: invalid mode value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
@@ -1160,19 +1160,19 @@ of @var{mode} is assumed to be returned 
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
-	retval = file_stat::is_lnk (static_cast<mode_t> (mode));
+        retval = file_stat::is_lnk (static_cast<mode_t> (mode));
       else
-	error ("S_ISLNK: invalid mode value");
+        error ("S_ISLNK: invalid mode value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
@@ -1183,19 +1183,19 @@ DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
-	retval = file_stat::is_sock (static_cast<mode_t> (mode));
+        retval = file_stat::is_sock (static_cast<mode_t> (mode));
       else
-	error ("S_ISSOCK: invalid mode value");
+        error ("S_ISSOCK: invalid mode value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (uname, args, ,
@@ -1260,28 +1260,28 @@ system-dependent error message.\n\
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
-	{
-	  std::string name = args(0).string_value ();
+        {
+          std::string name = args(0).string_value ();
 
-	  std::string msg;
+          std::string msg;
 
-	  int status = octave_unlink (name, msg);
+          int status = octave_unlink (name, msg);
 
-	  retval(0) = status;
-	  retval(1) = msg;	    
-	}
+          retval(0) = status;
+          retval(1) = msg;          
+        }
       else
-	error ("unlink: file name must be a string");
+        error ("unlink: file name must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("waitpid", Fwaitpid, args, ,
@@ -1337,39 +1337,39 @@ information about the subprocess that ex
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       pid_t pid = args(0).int_value (true);
   
       if (! error_state)
-	{
-	  int options = 0;
+        {
+          int options = 0;
 
-	  if (args.length () == 2)
-	    options = args(1).int_value (true);
+          if (args.length () == 2)
+            options = args(1).int_value (true);
 
-	  if (! error_state)
-	    {
-	      std::string msg;
+          if (! error_state)
+            {
+              std::string msg;
 
-	      int status = 0;
+              int status = 0;
 
-	      pid_t result = octave_syscalls::waitpid (pid, &status, options, msg);
+              pid_t result = octave_syscalls::waitpid (pid, &status, options, msg);
 
-	      retval(0) = result;
-	      retval(1) = status;
-	      retval(2) = msg;
-	    }
-	  else
-	    error ("waitpid: OPTIONS must be an integer");
-	}
+              retval(0) = result;
+              retval(1) = status;
+              retval(2) = msg;
+            }
+          else
+            error ("waitpid: OPTIONS must be an integer");
+        }
       else
-	error ("waitpid: PID must be an integer value");
+        error ("waitpid: PID must be an integer value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFEXITED", FWIFEXITED, args, ,
@@ -1383,19 +1383,19 @@ child terminated normally.\n\
   octave_value retval = 0.0;
 
 #if defined (WIFEXITED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WIFEXITED (status);
+        retval = WIFEXITED (status);
       else
-	error ("WIFEXITED: expecting integer argument");
+        error ("WIFEXITED: expecting integer argument");
     }
 #else
   warning ("WIFEXITED always returns false in this version of Octave")
 #endif
 
   return retval;
 }
 
@@ -1411,19 +1411,19 @@ status of the child.  This function shou
   octave_value retval = 0.0;
 
 #if defined (WEXITSTATUS)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WEXITSTATUS (status);
+        retval = WEXITSTATUS (status);
       else
-	error ("WEXITSTATUS: expecting integer argument");
+        error ("WEXITSTATUS: expecting integer argument");
     }
 #else
   warning ("WEXITSTATUS always returns false in this version of Octave")
 #endif
 
   return retval;
 }
 
@@ -1438,19 +1438,19 @@ child process was terminated by a signal
   octave_value retval = 0.0;
 
 #if defined (WIFSIGNALED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WIFSIGNALED (status);
+        retval = WIFSIGNALED (status);
       else
-	error ("WIFSIGNALED: expecting integer argument");
+        error ("WIFSIGNALED: expecting integer argument");
     }
 #else
   warning ("WIFSIGNALED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1466,19 +1466,19 @@ should only be employed if @code{WIFSIGN
   octave_value retval = 0.0;
 
 #if defined (WTERMSIG)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WTERMSIG (status);
+        retval = WTERMSIG (status);
       else
-	error ("WTERMSIG: expecting integer argument");
+        error ("WTERMSIG: expecting integer argument");
     }
 #else
   warning ("WTERMSIG always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1496,19 +1496,19 @@ Unix implementations (e.g., AIX, SunOS).
   octave_value retval = 0.0;
 
 #if defined (WCOREDUMP)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WCOREDUMP (status);
+        retval = WCOREDUMP (status);
       else
-	error ("WCOREDUMP: expecting integer argument");
+        error ("WCOREDUMP: expecting integer argument");
     }
 #else
   warning ("WCOREDUMP always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1525,19 +1525,19 @@ is being traced (see ptrace(2)).\n\
   octave_value retval = 0.0;
 
 #if defined (WIFSTOPPED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WIFSTOPPED (status);
+        retval = WIFSTOPPED (status);
       else
-	error ("WIFSTOPPED: expecting integer argument");
+        error ("WIFSTOPPED: expecting integer argument");
     }
 #else
   warning ("WIFSTOPPED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1553,19 +1553,19 @@ be employed if @code{WIFSTOPPED} returne
   octave_value retval = 0.0;
 
 #if defined (WSTOPSIG)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WSTOPSIG (status);
+        retval = WSTOPSIG (status);
       else
-	error ("WSTOPSIG: expecting integer argument");
+        error ("WSTOPSIG: expecting integer argument");
     }
 #else
   warning ("WSTOPSIG always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1580,19 +1580,19 @@ child process was resumed by delivery of
   octave_value retval = 0.0;
 
 #if defined (WIFCONTINUED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
-	retval = WIFCONTINUED (status);
+        retval = WIFCONTINUED (status);
       else
-	error ("WIFCONTINUED: expecting integer argument");
+        error ("WIFCONTINUED: expecting integer argument");
     }
 #else
   warning ("WIFCONTINUED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1604,27 +1604,27 @@ Return the canonical name of file @var{n
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string msg;
+        {
+          std::string msg;
 
-	  std::string result = octave_canonicalize_file_name (name, msg);
+          std::string result = octave_canonicalize_file_name (name, msg);
 
-	  retval(2) = msg;
-	  retval(1) = msg.empty () ? 0 : -1;
-	  retval(0) = result;
-	}
+          retval(2) = msg;
+          retval(1) = msg.empty () ? 0 : -1;
+          retval(0) = result;
+        }
       else
-	error ("canonicalize_file_name: argument must be a character string");
+        error ("canonicalize_file_name: argument must be a character string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static octave_value
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -110,33 +110,33 @@ w32_set_octave_home (void)
   std::string bin_dir (n, '\0');
 
   while (true)
     {
       HMODULE hMod = GetModuleHandle ("octinterp");
       int status = GetModuleFileName (hMod, &bin_dir[0], n);
 
       if (status < n)
-	{
-	  bin_dir.resize (status);
-	  break;
-	}
+        {
+          bin_dir.resize (status);
+          break;
+        }
       else
-	{
-	  n *= 2;
-	  bin_dir.resize (n);
-	}
+        {
+          n *= 2;
+          bin_dir.resize (n);
+        }
     }
 
   if (! bin_dir.empty ())
     {
       size_t pos = bin_dir.rfind ("\\bin\\");
 
       if (pos != std::string::npos)
-	octave_env::putenv ("OCTAVE_HOME", bin_dir.substr (0, pos));
+        octave_env::putenv ("OCTAVE_HOME", bin_dir.substr (0, pos));
     }
 }
 
 void
 w32_set_quiet_shutdown (void)
 {
   // Let the user close the console window or shutdown without the
   // pesky dialog.
@@ -189,53 +189,53 @@ same_file_internal (const std::string& f
 #ifdef OCTAVE_USE_WINDOWS_API
 
   bool retval = false;
 
   // Windows native code 
   // Reference: http://msdn2.microsoft.com/en-us/library/aa363788.aspx
 
   HANDLE hfile1 = CreateFile (file1.c_str (), 0, FILE_SHARE_READ, 0,
-			      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); 
+                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); 
 
   if (hfile1 != INVALID_HANDLE_VALUE)
     {
       HANDLE hfile2 = CreateFile (file2.c_str (), 0, FILE_SHARE_READ, 0,
-				  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
+                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
 
       if (hfile2 != INVALID_HANDLE_VALUE)
-	{  
-	  BY_HANDLE_FILE_INFORMATION hfi1;
-	  BY_HANDLE_FILE_INFORMATION hfi2;
+        {  
+          BY_HANDLE_FILE_INFORMATION hfi1;
+          BY_HANDLE_FILE_INFORMATION hfi2;
   
-	  if (GetFileInformationByHandle (hfile1, &hfi1)
-	      && GetFileInformationByHandle (hfile2, &hfi2))
+          if (GetFileInformationByHandle (hfile1, &hfi1)
+              && GetFileInformationByHandle (hfile2, &hfi2))
   
-	    retval = (hfi1.dwVolumeSerialNumber == hfi2.dwVolumeSerialNumber
-		      && hfi1.nFileIndexHigh == hfi2.nFileIndexHigh
-		      && hfi1.nFileIndexLow == hfi2.nFileIndexLow);
+            retval = (hfi1.dwVolumeSerialNumber == hfi2.dwVolumeSerialNumber
+                      && hfi1.nFileIndexHigh == hfi2.nFileIndexHigh
+                      && hfi1.nFileIndexLow == hfi2.nFileIndexLow);
 
-	  CloseHandle (hfile2);
-	}
+          CloseHandle (hfile2);
+        }
 
       CloseHandle (hfile1);
     }
 
   return retval;
 
 #else
 
   // POSIX Code
 
   file_stat fs_file1 (file1);
   file_stat fs_file2 (file2);
 
   return (fs_file1 && fs_file2
-	  && fs_file1.ino () == fs_file2.ino ()
-	  && fs_file1.dev () == fs_file2.dev ());
+          && fs_file1.ino () == fs_file2.ino ()
+          && fs_file1.dev () == fs_file2.dev ());
 
 #endif
 }
 
 #if defined (__DECCXX)
 
 // These don't seem to be instantiated automatically...
 
@@ -269,17 +269,17 @@ NeXT_init (void)
   malloc_error (malloc_handler);
 }
 #endif
 
 #if defined (__EMX__)
 OS2_init (void)
 {
   _control87 ((EM_INVALID | EM_DENORMAL | EM_ZERODIVIDE | EM_OVERFLOW
-	       | EM_UNDERFLOW | EM_INEXACT), MCW_EM);
+               | EM_UNDERFLOW | EM_INEXACT), MCW_EM);
 }
 #endif
 
 #if defined (SCO)
 static void
 SCO_init (void)
 {
 #if defined (HAVE_IEEEFP_H)
@@ -314,153 +314,153 @@ sysdep_cleanup (void)
 {
   MINGW_SIGNAL_CLEANUP ();
 }
 
 // Set terminal in raw mode.  From less-177.
 //
 // Change terminal to "raw mode", or restore to "normal" mode.
 // "Raw mode" means 
-//	1. An outstanding read will complete on receipt of a single keystroke.
-//	2. Input is not echoed.  
-//	3. On output, \n is mapped to \r\n.
-//	4. \t is NOT expanded into spaces.
-//	5. Signal-causing characters such as ctrl-C (interrupt),
-//	   etc. are NOT disabled.
+//      1. An outstanding read will complete on receipt of a single keystroke.
+//      2. Input is not echoed.  
+//      3. On output, \n is mapped to \r\n.
+//      4. \t is NOT expanded into spaces.
+//      5. Signal-causing characters such as ctrl-C (interrupt),
+//         etc. are NOT disabled.
 // It doesn't matter whether an input \n is mapped to \r, or vice versa.
 
 void
 raw_mode (bool on, bool wait)
 {
   static bool curr_on = false;
 
   int tty_fd = STDIN_FILENO;
   if (! isatty (tty_fd))
     {
       if (interactive)
-	error ("stdin is not a tty!");
+        error ("stdin is not a tty!");
       return;
     }
 
   if (on == curr_on)
     return;
 
 #if defined (HAVE_TERMIOS_H)
   {
     struct termios s;
     static struct termios save_term;
 
     if (on)
       {
-	// Get terminal modes.
+        // Get terminal modes.
 
-	tcgetattr (tty_fd, &s);
+        tcgetattr (tty_fd, &s);
 
-	// Save modes and set certain variables dependent on modes.
+        // Save modes and set certain variables dependent on modes.
 
-	save_term = s;
-//	ospeed = s.c_cflag & CBAUD;
-//	erase_char = s.c_cc[VERASE];
-//	kill_char = s.c_cc[VKILL];
+        save_term = s;
+//      ospeed = s.c_cflag & CBAUD;
+//      erase_char = s.c_cc[VERASE];
+//      kill_char = s.c_cc[VKILL];
 
-	// Set the modes to the way we want them.
+        // Set the modes to the way we want them.
 
-	s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
-	s.c_oflag |=  (OPOST|ONLCR);
+        s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
+        s.c_oflag |=  (OPOST|ONLCR);
 #if defined (OCRNL)
-	s.c_oflag &= ~(OCRNL);
+        s.c_oflag &= ~(OCRNL);
 #endif
 #if defined (ONOCR)
-	s.c_oflag &= ~(ONOCR);
+        s.c_oflag &= ~(ONOCR);
 #endif
 #if defined (ONLRET)
-	s.c_oflag &= ~(ONLRET);
+        s.c_oflag &= ~(ONLRET);
 #endif
-	s.c_cc[VMIN] = wait ? 1 : 0;
-	s.c_cc[VTIME] = 0;
+        s.c_cc[VMIN] = wait ? 1 : 0;
+        s.c_cc[VTIME] = 0;
       }      
     else
       {
-	// Restore saved modes.
+        // Restore saved modes.
 
-	s = save_term;
+        s = save_term;
       }
 
     tcsetattr (tty_fd, wait ? TCSAFLUSH : TCSADRAIN, &s);
   }
 #elif defined (HAVE_TERMIO_H)
   {
     struct termio s;
     static struct termio save_term;
 
     if (on)
       {
-	// Get terminal modes.
+        // Get terminal modes.
 
-	ioctl (tty_fd, TCGETA, &s);
+        ioctl (tty_fd, TCGETA, &s);
 
-	// Save modes and set certain variables dependent on modes.
+        // Save modes and set certain variables dependent on modes.
 
-	save_term = s;
-//	ospeed = s.c_cflag & CBAUD;
-//	erase_char = s.c_cc[VERASE];
-//	kill_char = s.c_cc[VKILL];
+        save_term = s;
+//      ospeed = s.c_cflag & CBAUD;
+//      erase_char = s.c_cc[VERASE];
+//      kill_char = s.c_cc[VKILL];
 
-	// Set the modes to the way we want them.
+        // Set the modes to the way we want them.
 
-	s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
-	s.c_oflag |=  (OPOST|ONLCR);
+        s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
+        s.c_oflag |=  (OPOST|ONLCR);
 #if defined (OCRNL)
-	s.c_oflag &= ~(OCRNL);
+        s.c_oflag &= ~(OCRNL);
 #endif
 #if defined (ONOCR)
-	s.c_oflag &= ~(ONOCR);
+        s.c_oflag &= ~(ONOCR);
 #endif
 #if defined (ONLRET)
-	s.c_oflag &= ~(ONLRET);
+        s.c_oflag &= ~(ONLRET);
 #endif
-	s.c_cc[VMIN] = wait ? 1 : 0;
+        s.c_cc[VMIN] = wait ? 1 : 0;
       }      
     else
       {
-	// Restore saved modes.
+        // Restore saved modes.
 
-	s = save_term;
+        s = save_term;
       }
 
     ioctl (tty_fd, TCSETAW, &s);
   }
 #elif defined (HAVE_SGTTY_H)
   {
     struct sgttyb s;
     static struct sgttyb save_term;
 
     if (on)
       {
-	// Get terminal modes.
+        // Get terminal modes.
 
-	ioctl (tty_fd, TIOCGETP, &s);
+        ioctl (tty_fd, TIOCGETP, &s);
 
-	// Save modes and set certain variables dependent on modes.
+        // Save modes and set certain variables dependent on modes.
 
-	save_term = s;
-//	ospeed = s.sg_ospeed;
-//	erase_char = s.sg_erase;
-//	kill_char = s.sg_kill;
+        save_term = s;
+//      ospeed = s.sg_ospeed;
+//      erase_char = s.sg_erase;
+//      kill_char = s.sg_kill;
 
-	// Set the modes to the way we want them.
+        // Set the modes to the way we want them.
 
-	s.sg_flags |= CBREAK;
-	s.sg_flags &= ~(ECHO);
+        s.sg_flags |= CBREAK;
+        s.sg_flags &= ~(ECHO);
       } 
     else
       {
-	// Restore saved modes.
+        // Restore saved modes.
 
-	s = save_term;
+        s = save_term;
       }
 
     ioctl (tty_fd, TIOCSETN, &s);
   }
 #else
   warning ("no support for raw mode console I/O on this system");
 
   // Make sure the current mode doesn't toggle.
@@ -564,17 +564,17 @@ returns a string containing the value of
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	retval = octave_env::getenv (name);
+        retval = octave_env::getenv (name);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (putenv, args, ,
@@ -588,27 +588,27 @@ Set the value of the environment variabl
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 1)
     {
       std::string var = args(0).string_value (); 
 
       if (! error_state)
-	{
-	  std::string val = (nargin == 2
-			     ? args(1).string_value () : std::string ()); 
+        {
+          std::string val = (nargin == 2
+                             ? args(1).string_value () : std::string ()); 
 
-	  if (! error_state)
-	    octave_env::putenv (var, val);
-	  else
-	    error ("putenv: second argument should be a string");
-	}
+          if (! error_state)
+            octave_env::putenv (var, val);
+          else
+            error ("putenv: second argument should be a string");
+        }
       else
-	error ("putenv: first argument should be a string");
+        error ("putenv: first argument should be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 DEFALIAS (setenv, putenv);
 
@@ -643,17 +643,17 @@ returning the empty string if no key is 
 
   if (interactive || forced_interactive)
     {
       feval ("drawnow");
 
       int c = octave_kbhit (args.length () == 0);
 
       if (c == -1)
-	c = 0;
+        c = 0;
 
       char *s = new char [2];
       s[0] = c;
       s[1] = '\0';
       retval = s;
     }
 
   return retval;
@@ -687,32 +687,32 @@ clc;\n\
       return retval;
     }
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
-	{
-	  if (! xisnan (dval))
-	    {
-	      feval ("drawnow");
+        {
+          if (! xisnan (dval))
+            {
+              feval ("drawnow");
 
-	      if (xisinf (dval))
-		{
-		  flush_octave_stdout ();
-		  octave_kbhit ();
-		}
-	      else
-		octave_sleep (dval);
-	    }
-	  else
-	    warning ("pause: NaN is an invalid delay");
-	}
+              if (xisinf (dval))
+                {
+                  flush_octave_stdout ();
+                  octave_kbhit ();
+                }
+              else
+                octave_sleep (dval);
+            }
+          else
+            warning ("pause: NaN is an invalid delay");
+        }
     }
   else
     {
       feval ("drawnow");
       flush_octave_stdout ();
       octave_kbhit ();
     }
 
@@ -727,25 +727,25 @@ Suspend the execution of the program for
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
-	{
-	  if (xisnan (dval))
-	    warning ("sleep: NaN is an invalid delay");
-	  else
-	    {
-	      feval ("drawnow");
-	      octave_sleep (dval);
-	    }
-	}
+        {
+          if (xisnan (dval))
+            warning ("sleep: NaN is an invalid delay");
+          else
+            {
+              feval ("drawnow");
+              octave_sleep (dval);
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (usleep, args, ,
@@ -759,29 +759,29 @@ of time less than one second, @code{usle
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
-	{
-	  if (xisnan (dval))
-	    warning ("usleep: NaN is an invalid delay");
-	  else
-	    {
-	      feval ("drawnow");
+        {
+          if (xisnan (dval))
+            warning ("usleep: NaN is an invalid delay");
+          else
+            {
+              feval ("drawnow");
 
-	      int delay = NINT (dval);
+              int delay = NINT (dval);
 
-	      if (delay > 0)
-		octave_usleep (delay);
-	    }
-	}
+              if (delay > 0)
+                octave_usleep (delay);
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // FIXME -- maybe this should only return 1 if IEEE floating
@@ -792,17 +792,17 @@ DEFUN (isieee, , ,
 @deftypefn {Built-in Function} {} isieee ()\n\
 Return 1 if your computer claims to conform to the IEEE standard for\n\
 floating point calculations.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
-		       || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
+                       || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 }
 
 DEFUN (native_float_format, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} native_float_format ()\n\
 Return the native floating point format as a string\n\
 @end deftypefn")
 {
@@ -838,26 +838,26 @@ tilde_expand (\"~/bin\")\n\
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
       string_vector sv = arg.all_strings ();
 
       if (! error_state)
-	{
-	  sv = file_ops::tilde_expand (sv);
+        {
+          sv = file_ops::tilde_expand (sv);
 
-	  if (arg.is_cellstr ())
-	    retval = Cell (arg.dims (), sv);
-	  else
-	    retval = sv;
-	}
+          if (arg.is_cellstr ())
+            retval = Cell (arg.dims (), sv);
+          else
+            retval = sv;
+        }
       else
-	error ("tilde_expand: expecting argument to be char or cellstr object");
+        error ("tilde_expand: expecting argument to be char or cellstr object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #if defined (__EMX__) && defined (OS2)
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -122,25 +122,25 @@ octave_call_stack::do_caller_user_code_l
 
   while (p != cs.begin ())
     {
       const call_stack_elt& elt = *(--p);
 
       octave_function *f = elt.fcn;
 
       if (f && f->is_user_code ())
-	{
-	  tree_statement *stmt = elt.stmt;
+        {
+          tree_statement *stmt = elt.stmt;
 
-	  if (stmt)
-	    {
-	      retval = stmt->line ();
-	      break;
-	    }
-	}
+          if (stmt)
+            {
+              retval = stmt->line ();
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 int
 octave_call_stack::do_caller_user_code_column (void) const
 {
@@ -150,25 +150,25 @@ octave_call_stack::do_caller_user_code_c
 
   while (p != cs.begin ())
     {
       const call_stack_elt& elt = *(--p);
 
       octave_function *f = elt.fcn;
 
       if (f && f->is_user_code ())
-	{
-	  tree_statement *stmt = elt.stmt;
+        {
+          tree_statement *stmt = elt.stmt;
 
-	  if (stmt)
-	    {
-	      retval = stmt->column ();
-	      break;
-	    }
-	}
+          if (stmt)
+            {
+              retval = stmt->column ();
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 size_t
 octave_call_stack::do_num_user_code_frames (octave_idx_type& curr_user_frame) const
 {
@@ -183,25 +183,25 @@ octave_call_stack::do_num_user_code_fram
 
   size_t k = cs.size ();
 
   for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
     {
       octave_function *f = (*p).fcn;
 
       if (--k == frame)
-	found = true;
+        found = true;
 
       if (f && f->is_user_code ())
-	{
-	  if (! found)
-	    curr_user_frame++;
+        {
+          if (! found)
+            curr_user_frame++;
 
-	  retval++;
-	}
+          retval++;
+        }
     }
 
   // We counted how many user frames were not the one, in reverse.
   // Now set curr_user_frame to be the index in the other direction.
   curr_user_frame = retval - curr_user_frame - 1;
 
   return retval;
 }
@@ -215,33 +215,33 @@ octave_call_stack::do_caller_user_code (
 
   while (p != cs.begin ())
     {
       const call_stack_elt& elt = *(--p);
 
       octave_function *f = elt.fcn;
 
       if (f && f->is_user_code ())
-	{
-	  if (nskip > 0)
-	    nskip--;
-	  else
-	    {
-	      retval = dynamic_cast<octave_user_code *> (f);
-	      break;
-	    }
-	}
+        {
+          if (nskip > 0)
+            nskip--;
+          else
+            {
+              retval = dynamic_cast<octave_user_code *> (f);
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
 Octave_map
 octave_call_stack::do_backtrace (size_t nskip,
-				 octave_idx_type& curr_user_frame) const
+                                 octave_idx_type& curr_user_frame) const
 {
   Octave_map retval;
 
   size_t user_code_frames = do_num_user_code_frames (curr_user_frame);
 
   size_t nframes = nskip <= user_code_frames ? user_code_frames - nskip : 0;
 
   // Our list is reversed.
@@ -263,54 +263,54 @@ octave_call_stack::do_backtrace (size_t 
   Cell scope (nframes, 1);
   Cell context (nframes, 1);
 
   if (nframes > 0)
     {
       int k = 0;
 
       for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
-	{
-	  const call_stack_elt& elt = *p;
+        {
+          const call_stack_elt& elt = *p;
 
-	  octave_function *f = elt.fcn;
+          octave_function *f = elt.fcn;
 
-	  if (f && f->is_user_code ())
-	    {
-	      if (nskip > 0)
-		nskip--;
-	      else
-		{
-		  scope(k) = elt.scope;
-		  context(k) = elt.context;
+          if (f && f->is_user_code ())
+            {
+              if (nskip > 0)
+                nskip--;
+              else
+                {
+                  scope(k) = elt.scope;
+                  context(k) = elt.context;
 
-		  file(k) = f->fcn_file_name ();
-		  std::string parent_fcn_name = f->parent_fcn_name ();
-		  if (parent_fcn_name == std::string ())
-		    name(k) = f->name ();
-		  else
-		    name(k) = f->parent_fcn_name () + Vfilemarker + f->name ();
+                  file(k) = f->fcn_file_name ();
+                  std::string parent_fcn_name = f->parent_fcn_name ();
+                  if (parent_fcn_name == std::string ())
+                    name(k) = f->name ();
+                  else
+                    name(k) = f->parent_fcn_name () + Vfilemarker + f->name ();
 
-		  tree_statement *stmt = elt.stmt;
+                  tree_statement *stmt = elt.stmt;
 
-		  if (stmt)
-		    {
-		      line(k) = stmt->line ();
-		      column(k) = stmt->column ();
-		    }
-		  else
-		    {
-		      line(k) = -1;
-		      column(k) = -1;
-		    }
+                  if (stmt)
+                    {
+                      line(k) = stmt->line ();
+                      column(k) = stmt->column ();
+                    }
+                  else
+                    {
+                      line(k) = -1;
+                      column(k) = -1;
+                    }
 
-		  k++;
-		}
-	    }
-	}
+                  k++;
+                }
+            }
+        }
 
       retval.assign ("file", file);
       retval.assign ("name", name);
       retval.assign ("line", line);
       retval.assign ("column", column);
       retval.assign ("scope", scope);
       retval.assign ("context", context);
     }
@@ -329,34 +329,34 @@ octave_call_stack::do_goto_frame (size_t
 
       curr_frame = n;
 
       const call_stack_elt& elt = cs[n];
 
       symbol_table::set_scope_and_context (elt.scope, elt.context);
 
       if (verbose)
-	{
-	  octave_function *f = elt.fcn;
-	  std::string nm = f ? f->name () : std::string ("<unknown>");
+        {
+          octave_function *f = elt.fcn;
+          std::string nm = f ? f->name () : std::string ("<unknown>");
 
-	  tree_statement *s = elt.stmt;
-	  int l = -1;
-	  int c = -1;
-	  if (s)
-	    {
-	      l = s->line ();
-	      c = s->column ();
-	    }
+          tree_statement *s = elt.stmt;
+          int l = -1;
+          int c = -1;
+          if (s)
+            {
+              l = s->line ();
+              c = s->column ();
+            }
 
-	  octave_stdout << "stopped in " << nm
-			<< " at line " << l << " column " << c
-			<< " (" << elt.scope << "[" << elt.context << "])"
-			<< std::endl;
-	}
+          octave_stdout << "stopped in " << nm
+                        << " at line " << l << " column " << c
+                        << " (" << elt.scope << "[" << elt.context << "])"
+                        << std::endl;
+        }
     }
 
   return retval;
 }
 
 bool
 octave_call_stack::do_goto_frame_relative (int nskip, bool verbose)
 {
@@ -370,62 +370,62 @@ octave_call_stack::do_goto_frame_relativ
     incr = 1;
 
   // Start looking with the caller of dbup/dbdown/keyboard.
   size_t frame = cs[curr_frame].prev;
 
   while (true)
     {
       if ((incr < 0 && frame == 0) || (incr > 0 && frame == cs.size () - 1))
-	break;
+        break;
 
       frame += incr;
 
       const call_stack_elt& elt = cs[frame];
 
       octave_function *f = elt.fcn;
 
       if (frame == 0 || (f && f->is_user_code ()))
-	{
-	  if (nskip > 0)
-	    nskip--;
-	  else if (nskip < 0)
-	    nskip++;
+        {
+          if (nskip > 0)
+            nskip--;
+          else if (nskip < 0)
+            nskip++;
 
-	  if (nskip == 0)
-	    {
-	      curr_frame = frame;
-	      cs[cs.size () - 1].prev = curr_frame;
+          if (nskip == 0)
+            {
+              curr_frame = frame;
+              cs[cs.size () - 1].prev = curr_frame;
 
-	      symbol_table::set_scope_and_context (elt.scope, elt.context);
+              symbol_table::set_scope_and_context (elt.scope, elt.context);
 
-	      if (verbose)
-		{
+              if (verbose)
+                {
                   std::ostringstream buf;
 
                   if (f)
                     {
                       tree_statement *s = elt.stmt;
 
                       int l = s ? s->line () : -1;
                       int c = s ? s->column () : -1;
 
                       buf << f->name () << ": " << " line " << l
                           << ", column " << c << std::endl;
                     }
                   else
                     buf << "at top level" << std::endl;
 
-		  octave_stdout << buf.str ();
-		}
+                  octave_stdout << buf.str ();
+                }
 
-	      retval = true;
-	      break;
-	    }
-	}
+              retval = true;
+              break;
+            }
+        }
 
       // There is no need to set scope and context here.  That will
       // happen when the dbup/dbdown/keyboard frame is popped and we
       // jump to the new "prev" frame set above.
     }
 
   return retval;
 }
@@ -441,35 +441,35 @@ octave_call_stack::do_goto_caller_frame 
     {
       frame = cs[frame].prev;
 
       const call_stack_elt& elt = cs[frame];
 
       octave_function *f = elt.fcn;
 
       if (frame == 0 || (f && f->is_user_code ()))
-	{
-	  if (! skipped)
-	    // We found the current user code frame, so skip it.
-	    skipped = true;
-	  else
-	    {
-	      // We found the caller user code frame.
-	      call_stack_elt tmp (elt);
-	      tmp.prev = curr_frame;
+        {
+          if (! skipped)
+            // We found the current user code frame, so skip it.
+            skipped = true;
+          else
+            {
+              // We found the caller user code frame.
+              call_stack_elt tmp (elt);
+              tmp.prev = curr_frame;
 
-	      curr_frame = cs.size ();
+              curr_frame = cs.size ();
 
-	      cs.push_back (tmp);
+              cs.push_back (tmp);
 
-	      symbol_table::set_scope_and_context (tmp.scope, tmp.context);
+              symbol_table::set_scope_and_context (tmp.scope, tmp.context);
 
-	      break;
-	    }
-	}
+              break;
+            }
+        }
     }
 }
 
 void
 octave_call_stack::do_goto_base_frame (void)
 {
   call_stack_elt tmp (cs[0]);
   tmp.prev = curr_frame;
@@ -496,28 +496,28 @@ octave_call_stack::do_backtrace_error_me
       const call_stack_elt& elt = cs.back ();
 
       octave_function *fcn = elt.fcn;
       tree_statement *stmt = elt.stmt;
 
       std::string fcn_name = "?unknown?";
 
       if (fcn)
-	{
-	  fcn_name = fcn->fcn_file_name ();
+        {
+          fcn_name = fcn->fcn_file_name ();
 
-	  if (fcn_name.empty ())
-	    fcn_name = fcn->name ();
-	}
+          if (fcn_name.empty ())
+            fcn_name = fcn->name ();
+        }
 
       int line = stmt ? stmt->line () : -1;
       int column = stmt ? stmt->column () : -1;
 
       error ("  %s at line %d, column %d",
-	     fcn_name.c_str (), line, column);
+             fcn_name.c_str (), line, column);
     }
 }
 
 void
 recover_from_exception (void)
 {
   can_interrupt = true;
   octave_interrupt_immediately = 0;
@@ -544,107 +544,107 @@ main_loop (void)
   octave_initialized = true;
 
   // The big loop.
 
   int retval = 0;
   do
     {
       try
-	{
-	  unwind_protect frame;
+        {
+          unwind_protect frame;
 
-	  reset_error_handler ();
+          reset_error_handler ();
 
-	  reset_parser ();
+          reset_parser ();
 
           if (symbol_table::at_top_level ())
             tree_evaluator::reset_debug_state ();
 
-	  // Do this with an unwind-protect cleanup function so that
-	  // the forced variables will be unmarked in the event of an
-	  // interrupt.
-	  symbol_table::scope_id scope = symbol_table::top_scope ();
-	  frame.add_fcn (symbol_table::unmark_forced_variables, scope);
+          // Do this with an unwind-protect cleanup function so that
+          // the forced variables will be unmarked in the event of an
+          // interrupt.
+          symbol_table::scope_id scope = symbol_table::top_scope ();
+          frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-	  // This is the same as yyparse in parse.y.
-	  retval = octave_parse ();
+          // This is the same as yyparse in parse.y.
+          retval = octave_parse ();
 
-	  if (retval == 0)
-	    {
-	      if (global_command)
-		{
-		  global_command->accept (*current_evaluator);
+          if (retval == 0)
+            {
+              if (global_command)
+                {
+                  global_command->accept (*current_evaluator);
 
-		  delete global_command;
+                  delete global_command;
 
-		  global_command = 0;
+                  global_command = 0;
 
-		  octave_quit ();
+                  octave_quit ();
 
-		  if (! (interactive || forced_interactive))
-		    {
-		      bool quit = (tree_return_command::returning
-				   || tree_break_command::breaking);
+                  if (! (interactive || forced_interactive))
+                    {
+                      bool quit = (tree_return_command::returning
+                                   || tree_break_command::breaking);
 
-		      if (tree_return_command::returning)
-			tree_return_command::returning = 0;
+                      if (tree_return_command::returning)
+                        tree_return_command::returning = 0;
 
-		      if (tree_break_command::breaking)
-			tree_break_command::breaking--;
+                      if (tree_break_command::breaking)
+                        tree_break_command::breaking--;
 
-		      if (quit)
-			break;
-		    }
+                      if (quit)
+                        break;
+                    }
 
-		  if (error_state)
-		    {
-		      if (! (interactive || forced_interactive))
-			{
-			  // We should exit with a non-zero status.
-			  retval = 1;
-			  break;
-			}
-		    }
-		  else
-		    {
-		      if (octave_completion_matches_called)
-			octave_completion_matches_called = false;	    
-		      else
-			command_editor::increment_current_command_number ();
-		    }
-		}
-	      else if (parser_end_of_input)
-		break;
-	    }
-	}
+                  if (error_state)
+                    {
+                      if (! (interactive || forced_interactive))
+                        {
+                          // We should exit with a non-zero status.
+                          retval = 1;
+                          break;
+                        }
+                    }
+                  else
+                    {
+                      if (octave_completion_matches_called)
+                        octave_completion_matches_called = false;           
+                      else
+                        command_editor::increment_current_command_number ();
+                    }
+                }
+              else if (parser_end_of_input)
+                break;
+            }
+        }
       catch (octave_interrupt_exception)
-	{
-	  recover_from_exception ();
+        {
+          recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
             {
               clean_up_and_exit (exit_status);
               break; // If user has overriden the exit func.
             }
-	}
+        }
       catch (octave_execution_exception)
-	{
-	  recover_from_exception ();
-	  std::cerr
-	    << "error: unhandled execution exception -- trying to return to prompt"
-	    << std::endl;
-	}
+        {
+          recover_from_exception ();
+          std::cerr
+            << "error: unhandled execution exception -- trying to return to prompt"
+            << std::endl;
+        }
       catch (std::bad_alloc)
-	{
-	  recover_from_exception ();
-	  std::cerr
-	    << "error: memory exhausted or requested size too large for range of Octave's index type -- trying to return to prompt"
-	    << std::endl;
-	}
+        {
+          recover_from_exception ();
+          std::cerr
+            << "error: memory exhausted or requested size too large for range of Octave's index type -- trying to return to prompt"
+            << std::endl;
+        }
     }
   while (retval == 0);
 
   return retval;
 }
 
 // Call a function with exceptions handled to avoid problems with
 // errors while shutting down.
@@ -692,22 +692,22 @@ Octave's exit status.  The default value
 {
   octave_value_list retval;
 
   if (! quit_allowed)
     error ("quit: not supported in embedded mode.");
   else if (nargout == 0)
     {
       if (args.length () > 0)
-	{
-	  int tmp = args(0).nint_value ();
+        {
+          int tmp = args(0).nint_value ();
 
-	  if (! error_state)
-	    exit_status = tmp;
-	}
+          if (! error_state)
+            exit_status = tmp;
+        }
 
       if (! error_state)
         {
           quitting_gracefully = true;
 
           // Simulate interrupt.
 
           octave_interrupt_state = -1;
@@ -800,17 +800,17 @@ run_command_and_return_output (const std
             output_buf.put (ch);
           else
             {
               if (! cmd->eof () && errno == EAGAIN)
                 {
                   cmd->clear ();
 
                   if (wait_for_input (fid) != 1)
-                    break;			
+                    break;                      
                 }
               else
                 break;
             }
         }
 
       int cmd_status = cmd->close ();
 
@@ -882,102 +882,102 @@ variable @code{status} to the integer @s
     {
       bool return_output = (nargout > 1 || nargin > 1);
 
       std::string cmd_str = args(0).string_value ();
 
       system_exec_type type = et_sync;
 
       if (! error_state)
-	{
-	  if (nargin > 2)
-	    {
-	      std::string type_str = args(2).string_value ();
+        {
+          if (nargin > 2)
+            {
+              std::string type_str = args(2).string_value ();
 
-	      if (! error_state)
-		{
-		  if (type_str == "sync")
-		    type = et_sync;
-		  else if (type_str == "async")
-		    type = et_async;
-		  else
-		    error ("system: third arg must be \"sync\" or \"async\"");
-		}
-	      else
-		error ("system: third argument must be a string");
-	    }
-	}
+              if (! error_state)
+                {
+                  if (type_str == "sync")
+                    type = et_sync;
+                  else if (type_str == "async")
+                    type = et_async;
+                  else
+                    error ("system: third arg must be \"sync\" or \"async\"");
+                }
+              else
+                error ("system: third argument must be a string");
+            }
+        }
       else
-	error ("system: expecting std::string as first argument");
+        error ("system: expecting std::string as first argument");
 
       if (! error_state)
-	{
+        {
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
-	  // Work around weird double-quote handling on Windows systems.
+          // Work around weird double-quote handling on Windows systems.
           if (type == et_sync)
             cmd_str = "\"" + cmd_str + "\"";
 #endif
 
-	  if (type == et_async)
-	    {
-	      // FIXME -- maybe this should go in sysdep.cc?
+          if (type == et_async)
+            {
+              // FIXME -- maybe this should go in sysdep.cc?
 #ifdef HAVE_FORK
-	      pid_t pid = fork ();
+              pid_t pid = fork ();
 
-	      if (pid < 0) 
-		error ("system: fork failed -- can't create child process");
-	      else if (pid == 0)
-		{
-		  // FIXME -- should probably replace this
-		  // call with something portable.
+              if (pid < 0) 
+                error ("system: fork failed -- can't create child process");
+              else if (pid == 0)
+                {
+                  // FIXME -- should probably replace this
+                  // call with something portable.
 
-		  execl ("/bin/sh", "sh", "-c", cmd_str.c_str (),
-			 static_cast<void *> (0));
+                  execl ("/bin/sh", "sh", "-c", cmd_str.c_str (),
+                         static_cast<void *> (0));
 
-		  panic_impossible ();
-		}
-	      else
-		retval(0) = pid;
+                  panic_impossible ();
+                }
+              else
+                retval(0) = pid;
 #elif defined (__WIN32__)
               STARTUPINFO si;
               PROCESS_INFORMATION pi;
               ZeroMemory (&si, sizeof (si));
               ZeroMemory (&pi, sizeof (pi));
-	      OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length()+1);
-	      strcpy (xcmd_str, cmd_str.c_str ());
+              OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length()+1);
+              strcpy (xcmd_str, cmd_str.c_str ());
 
               if (! CreateProcess (0, xcmd_str, 0, 0, FALSE, 0, 0, 0, &si, &pi))
                 error ("system: CreateProcess failed -- can't create child process");
               else
                 {
                   retval(0) = pi.dwProcessId;
                   CloseHandle (pi.hProcess);
                   CloseHandle (pi.hThread);
                 }
 #else
- 	      error ("asynchronous system calls are not supported");
+              error ("asynchronous system calls are not supported");
 #endif
-	    }
-	  else if (return_output)
-	    retval = run_command_and_return_output (cmd_str);
-	  else
-	    {
-	      int status = system (cmd_str.c_str ());
+            }
+          else if (return_output)
+            retval = run_command_and_return_output (cmd_str);
+          else
+            {
+              int status = system (cmd_str.c_str ());
 
-	      // The value in status is as returned by waitpid.  If
-	      // the process exited normally, extract the actual exit
-	      // status of the command.  Otherwise, return 127 as a
-	      // failure code.
+              // The value in status is as returned by waitpid.  If
+              // the process exited normally, extract the actual exit
+              // status of the command.  Otherwise, return 127 as a
+              // failure code.
 
-	      if (WIFEXITED (status))
-		status = WEXITSTATUS (status);
+              if (WIFEXITED (status))
+                status = WEXITSTATUS (status);
 
-	      retval(0) = status;
-	    }
-	}
+              retval(0) = status;
+            }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
@@ -1008,41 +1008,41 @@ do_octave_atexit (void)
     {
       deja_vu = true;
 
       // Do this explicitly so that destructors for mex file objects
       // are called, so that functions registered with mexAtExit are
       // called.
       SAFE_CALL (clear_mex_functions, ())
 
-	SAFE_CALL (command_editor::restore_terminal_state, ())
+        SAFE_CALL (command_editor::restore_terminal_state, ())
 
       // FIXME -- is this needed?  Can it cause any trouble?
       SAFE_CALL (raw_mode, (0))
 
       SAFE_CALL (octave_history_write_timestamp, ())
 
       if (Vsaving_history)
-	SAFE_CALL (command_history::clean_up_and_save, ())
+        SAFE_CALL (command_history::clean_up_and_save, ())
 
       SAFE_CALL (close_files, ())
 
       SAFE_CALL (cleanup_tmp_files, ())
 
       SAFE_CALL (flush_octave_stdout, ())
 
       if (! quitting_gracefully && (interactive || forced_interactive))
-	{
-	  octave_stdout << "\n";
+        {
+          octave_stdout << "\n";
 
-	  // Yes, we want this to be separate from the call to
-	  // flush_octave_stdout above.
+          // Yes, we want this to be separate from the call to
+          // flush_octave_stdout above.
 
-	  SAFE_CALL (flush_octave_stdout, ())
-	}
+          SAFE_CALL (flush_octave_stdout, ())
+        }
     }
 }
 
 void
 octave_add_atexit_function (const std::string& fname)
 {
   octave_atexit_functions.push_front (fname);
 }
@@ -1051,21 +1051,21 @@ bool
 octave_remove_atexit_function (const std::string& fname)
 {
   bool found = false;
 
   for (std::list<std::string>::iterator p = octave_atexit_functions.begin ();
        p != octave_atexit_functions.end (); p++)
     {
       if (*p == fname)
-	{
-	  octave_atexit_functions.erase (p);
-	  found = true;
-	  break;
-	}
+        {
+          octave_atexit_functions.erase (p);
+          found = true;
+          break;
+        }
     }
 
   return found;
 }
 
 
 DEFUN (atexit, args, nargout,
   "-*- texinfo -*-\n\
@@ -1121,28 +1121,28 @@ multiple times.\n\
             {
               add_mode = args(1).bool_value ();
 
               if (error_state)
                 error ("atexit: second argument must be a logical value");
             }
 
           if (! error_state)
-	    {
-	      if (add_mode)
-		octave_add_atexit_function (arg);
-	      else
-		{
-		  bool found = octave_remove_atexit_function (arg);
+            {
+              if (add_mode)
+                octave_add_atexit_function (arg);
+              else
+                {
+                  bool found = octave_remove_atexit_function (arg);
 
-		  if (nargout > 0)
-		    retval(0) = found;
-		}
-	    }
-	}
+                  if (nargout > 0)
+                    retval(0) = found;
+                }
+            }
+        }
       else
         error ("atexit: argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -1343,42 +1343,42 @@ specified option.\n\
     };
 
   if (! initialized)
     {
       m.assign ("dld", octave_value (octave_supports_dynamic_linking));
 
       oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
       m.assign ("float_format",
-		octave_value (oct_mach_info::float_format_as_string (ff)));
+                octave_value (oct_mach_info::float_format_as_string (ff)));
 
       m.assign ("words_big_endian",
-		octave_value (oct_mach_info::words_big_endian ()));
+                octave_value (oct_mach_info::words_big_endian ()));
 
       m.assign ("words_little_endian",
-		octave_value (oct_mach_info::words_little_endian ()));
+                octave_value (oct_mach_info::words_little_endian ()));
 
       int i = 0;
 
       while (true)
-	{
-	  const conf_info_struct& elt = conf_info[i++];
+        {
+          const conf_info_struct& elt = conf_info[i++];
 
-	  const char *key = elt.key;
+          const char *key = elt.key;
 
-	  if (key)
-	    {
-	      if (elt.subst_home)
-		m.assign (key, octave_value (subst_octave_home (elt.val)));
-	      else
-		m.assign (key, octave_value (elt.val));
-	    }
-	  else
-	    break;
-	}
+          if (key)
+            {
+              if (elt.subst_home)
+                m.assign (key, octave_value (subst_octave_home (elt.val)));
+              else
+                m.assign (key, octave_value (elt.val));
+            }
+          else
+            break;
+        }
 
       bool unix_system = true;
       bool mac_system = false;
       bool windows_system = false;
 
 #if defined (WIN32)
       windows_system = true;
 #if !defined (__CYGWIN__)
@@ -1399,24 +1399,24 @@ specified option.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
       if (! error_state)
-	{
-	  Cell c = m.contents (arg.c_str ());
+        {
+          Cell c = m.contents (arg.c_str ());
 
-	  if (c.is_empty ())
-	    error ("octave_config_info: no info for `%s'", arg.c_str ());
-	  else
-	    retval = c(0);
-	}
+          if (c.is_empty ())
+            error ("octave_config_info: no info for `%s'", arg.c_str ());
+          else
+            retval = c(0);
+        }
     }
   else if (nargin == 0)
     retval = m;
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -40,145 +40,145 @@ class
 ft_manager
 {
 public:
   static bool instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
-	instance = new ft_manager ();
+        instance = new ft_manager ();
 
       if (! instance)
-	{
-	  ::error ("unable to create ft_manager!");
+        {
+          ::error ("unable to create ft_manager!");
 
-	  retval = false;
-	}
+          retval = false;
+        }
 
       return retval;
     }
 
   static FT_Face get_font (const std::string& name, const std::string& weight,
-			   const std::string& angle, double size)
+                           const std::string& angle, double size)
     { return (instance_ok ()
-	      ? instance->do_get_font (name, weight, angle, size)
-	      : 0); }
+              ? instance->do_get_font (name, weight, angle, size)
+              : 0); }
 
 private:
   static ft_manager *instance;
 
 private:
   ft_manager (void)
     {
       if (FT_Init_FreeType (&library))
-	{
-	  ::error ("unable to initialize freetype library");
-	}
+        {
+          ::error ("unable to initialize freetype library");
+        }
 
 #if HAVE_FONTCONFIG
       fc_init_done = false;
       if (! FcInit ())
-	{
-	  ::error ("unable to initialize fontconfig library");
-	}
+        {
+          ::error ("unable to initialize fontconfig library");
+        }
       else
-	{
-	  fc_init_done = true;
-	}
+        {
+          fc_init_done = true;
+        }
 #endif
     }
 
   ~ft_manager (void)
     {
 #if HAVE_FONTCONFIG
       FcFini ();
       fc_init_done = false;
 #endif
     }
 
   FT_Face do_get_font (const std::string& name, const std::string& weight,
-		       const std::string& angle, double size)
+                       const std::string& angle, double size)
     {
       FT_Face retval = 0;
 
       std::string file;
 
 #if HAVE_FONTCONFIG
       if (fc_init_done)
-	{
-	  int fc_weight, fc_angle;
+        {
+          int fc_weight, fc_angle;
 
-	  if (weight == "bold")
-	    fc_weight = FC_WEIGHT_BOLD;
-	  else if (weight == "light")
-	    fc_weight = FC_WEIGHT_LIGHT;
-	  else if (weight == "demi")
-	    fc_weight = FC_WEIGHT_DEMIBOLD;
-	  else
-	    fc_weight = FC_WEIGHT_NORMAL;
+          if (weight == "bold")
+            fc_weight = FC_WEIGHT_BOLD;
+          else if (weight == "light")
+            fc_weight = FC_WEIGHT_LIGHT;
+          else if (weight == "demi")
+            fc_weight = FC_WEIGHT_DEMIBOLD;
+          else
+            fc_weight = FC_WEIGHT_NORMAL;
 
-	  if (angle == "italic")
-	    fc_angle = FC_SLANT_ITALIC;
-	  else if (angle == "oblique")
-	    fc_angle = FC_SLANT_OBLIQUE;
-	  else
-	    fc_angle = FC_SLANT_ROMAN;
+          if (angle == "italic")
+            fc_angle = FC_SLANT_ITALIC;
+          else if (angle == "oblique")
+            fc_angle = FC_SLANT_OBLIQUE;
+          else
+            fc_angle = FC_SLANT_ROMAN;
 
-	  FcPattern *pat = FcPatternCreate ();
+          FcPattern *pat = FcPatternCreate ();
 
-	  FcPatternAddString (pat, FC_FAMILY,
-			      (reinterpret_cast<const FcChar8*>
-			       (name == "*" ? "sans" : name.c_str ())));
+          FcPatternAddString (pat, FC_FAMILY,
+                              (reinterpret_cast<const FcChar8*>
+                               (name == "*" ? "sans" : name.c_str ())));
 
-	  FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
-	  FcPatternAddInteger (pat, FC_SLANT, fc_angle);
-	  FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
+          FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
+          FcPatternAddInteger (pat, FC_SLANT, fc_angle);
+          FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
 
-	  if (FcConfigSubstitute (0, pat, FcMatchPattern))
-	    {
-	      FcResult res;
-	      FcPattern *match;
+          if (FcConfigSubstitute (0, pat, FcMatchPattern))
+            {
+              FcResult res;
+              FcPattern *match;
 
-	      FcDefaultSubstitute (pat);
-	      match = FcFontMatch (0, pat, &res);
+              FcDefaultSubstitute (pat);
+              match = FcFontMatch (0, pat, &res);
 
-	      // FIXME -- originally, this test also required that
-	      // res != FcResultNoMatch.  Is that really needed?
-	      if (match)
-		{
-		  unsigned char *tmp;
+              // FIXME -- originally, this test also required that
+              // res != FcResultNoMatch.  Is that really needed?
+              if (match)
+                {
+                  unsigned char *tmp;
 
-		  FcPatternGetString (match, FC_FILE, 0, &tmp);
-		  file = reinterpret_cast<char*> (tmp);
-		}
-	      else
-		::warning ("could not match any font: %s-%s-%s-%g",
-			 name.c_str (), weight.c_str (), angle.c_str (),
-			 size);
+                  FcPatternGetString (match, FC_FILE, 0, &tmp);
+                  file = reinterpret_cast<char*> (tmp);
+                }
+              else
+                ::warning ("could not match any font: %s-%s-%s-%g",
+                         name.c_str (), weight.c_str (), angle.c_str (),
+                         size);
 
-	      if (match)
-		FcPatternDestroy (match);
-	    }
+              if (match)
+                FcPatternDestroy (match);
+            }
 
-	  FcPatternDestroy (pat);
-	}
+          FcPatternDestroy (pat);
+        }
 #endif
 
       if (file.empty ())
-	{
+        {
 #ifdef __WIN32__
-	  file = "C:/WINDOWS/Fonts/verdana.ttf";
+          file = "C:/WINDOWS/Fonts/verdana.ttf";
 #else
-	  // FIXME: find a "standard" font for UNIX platforms
+          // FIXME: find a "standard" font for UNIX platforms
 #endif
-	}
+        }
 
       if (! file.empty () && FT_New_Face (library, file.c_str (), 0, &retval))
-	::warning ("ft_manager: unable to load font: %s", file.c_str ());
+        ::warning ("ft_manager: unable to load font: %s", file.c_str ());
       
       return retval;
     }
 
 private:
   FT_Library library;
 #if HAVE_FONTCONFIG
   bool fc_init_done;
@@ -207,24 +207,24 @@ ft_render::set_font (const base_properti
 {
   if (face)
     FT_Done_Face (face);
 
   // FIXME: take "fontunits" into account
   double font_size = props.get ("fontsize").double_value ();
 
   face = ft_manager::get_font (props.get ("fontname").string_value (),
-			       props.get ("fontweight").string_value (),
-			       props.get ("fontangle").string_value (),
-			       font_size);
+                               props.get ("fontweight").string_value (),
+                               props.get ("fontangle").string_value (),
+                               font_size);
 
   if (face)
     {
       if (FT_Set_Char_Size (face, 0, font_size*64, 0, 0))
-	::warning ("ft_render: unable to set font size to %d", font_size);
+        ::warning ("ft_render: unable to set font size to %d", font_size);
     }
   else
     ::warning ("ft_render: unable to load appropriate font");
 }
 
 void
 ft_render::set_mode (int m)
 {
@@ -233,137 +233,137 @@ ft_render::set_mode (int m)
   switch (mode)
     {
     case MODE_BBOX:
       xoffset = yoffset = 0;
       bbox = Matrix (1, 4, 0.0);
       break;
     case MODE_RENDER:
       if (bbox.numel () != 4)
-	{
-	  ::warning ("ft_render: invalid bounding box, cannot render");
+        {
+          ::warning ("ft_render: invalid bounding box, cannot render");
 
-	  xoffset = yoffset = 0;
-	  pixels = uint8NDArray ();
-	}
+          xoffset = yoffset = 0;
+          pixels = uint8NDArray ();
+        }
       else
-	{
-	  pixels = uint8NDArray (dim_vector (4, bbox(2), bbox(3)),
-				 static_cast<uint8_t> (0));
-	  xoffset = 0;
-	  yoffset = -bbox(1)-1;
-	}
+        {
+          pixels = uint8NDArray (dim_vector (4, bbox(2), bbox(3)),
+                                 static_cast<uint8_t> (0));
+          xoffset = 0;
+          yoffset = -bbox(1)-1;
+        }
       break;
     default:
       ::error ("ft_render: invalid mode `%d'", mode);
       break;
     }
 }
 
 void
 ft_render::visit (text_element_string& e)
 {
   if (face)
     {
       std::string str = e.string_value ();
       FT_UInt glyph_index, previous = 0;
 
       for (int i = 0; i < str.length (); i++)
-	{
-	  glyph_index = FT_Get_Char_Index (face, str[i]);
+        {
+          glyph_index = FT_Get_Char_Index (face, str[i]);
 
-	  if (! glyph_index
-	      || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
-	    ::warning ("ft_render: skipping missing glyph for character `%c'",
-		       str[i]);
-	  else
-	    {
-	      switch (mode)
-		{
-		case MODE_RENDER:
-		  if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
-		    ::warning ("ft_render: unable to render glyph for character `%c'",
-			       str[i]);
-		  else
-		    {
-		      FT_Bitmap& bitmap = face->glyph->bitmap;
-		      int x0, y0;
+          if (! glyph_index
+              || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
+            ::warning ("ft_render: skipping missing glyph for character `%c'",
+                       str[i]);
+          else
+            {
+              switch (mode)
+                {
+                case MODE_RENDER:
+                  if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
+                    ::warning ("ft_render: unable to render glyph for character `%c'",
+                               str[i]);
+                  else
+                    {
+                      FT_Bitmap& bitmap = face->glyph->bitmap;
+                      int x0, y0;
 
-		      if (previous)
-			{
-			  FT_Vector delta;
+                      if (previous)
+                        {
+                          FT_Vector delta;
 
-			  FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
-			  xoffset += (delta.x >> 6);
-			}
+                          FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
+                          xoffset += (delta.x >> 6);
+                        }
 
-		      x0 = xoffset+face->glyph->bitmap_left;
-		      y0 = yoffset+face->glyph->bitmap_top;
-		      for (int r = 0; r < bitmap.rows; r++)
-			for (int c = 0; c < bitmap.width; c++)
-			  {
-			    unsigned char pix = bitmap.buffer[r*bitmap.width+c];
-			    if (x0+c < 0 || x0+c >= pixels.dim2()
-				|| y0-r < 0 || y0-r >= pixels.dim3())
-			      {
-				//::error ("out-of-bound indexing!!");
-			      }
-			    else if (pixels(3, x0+c, y0-r).value () == 0)
-			      {
-				pixels(0, x0+c, y0-r) = red;
-				pixels(1, x0+c, y0-r) = green;
-				pixels(2, x0+c, y0-r) = blue;
-				pixels(3, x0+c, y0-r) = pix;
-			      }
-			  }
+                      x0 = xoffset+face->glyph->bitmap_left;
+                      y0 = yoffset+face->glyph->bitmap_top;
+                      for (int r = 0; r < bitmap.rows; r++)
+                        for (int c = 0; c < bitmap.width; c++)
+                          {
+                            unsigned char pix = bitmap.buffer[r*bitmap.width+c];
+                            if (x0+c < 0 || x0+c >= pixels.dim2()
+                                || y0-r < 0 || y0-r >= pixels.dim3())
+                              {
+                                //::error ("out-of-bound indexing!!");
+                              }
+                            else if (pixels(3, x0+c, y0-r).value () == 0)
+                              {
+                                pixels(0, x0+c, y0-r) = red;
+                                pixels(1, x0+c, y0-r) = green;
+                                pixels(2, x0+c, y0-r) = blue;
+                                pixels(3, x0+c, y0-r) = pix;
+                              }
+                          }
 
-		      xoffset += (face->glyph->advance.x >> 6);
-		    }
-		  break;
+                      xoffset += (face->glyph->advance.x >> 6);
+                    }
+                  break;
 
-		case MODE_BBOX:
-		  // width
-		  if (previous)
-		    {
-		      FT_Vector delta;
+                case MODE_BBOX:
+                  // width
+                  if (previous)
+                    {
+                      FT_Vector delta;
 
-		      FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
-		      bbox(2) += (delta.x >> 6);
-		    }
-		  bbox(2) += (face->glyph->advance.x >> 6);
+                      FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
+                      bbox(2) += (delta.x >> 6);
+                    }
+                  bbox(2) += (face->glyph->advance.x >> 6);
 
-		  int asc, desc;
+                  int asc, desc;
 
-		  if (false /*tight*/)
-		    {
-		      desc = face->glyph->metrics.horiBearingY - face->glyph->metrics.height;
-		      asc = face->glyph->metrics.horiBearingY;
-		    }
-		  else
-		    {
-		      asc = face->size->metrics.ascender;
-		      desc = face->size->metrics.descender;
-		    }
+                  if (false /*tight*/)
+                    {
+                      desc = face->glyph->metrics.horiBearingY - face->glyph->metrics.height;
+                      asc = face->glyph->metrics.horiBearingY;
+                    }
+                  else
+                    {
+                      asc = face->size->metrics.ascender;
+                      desc = face->size->metrics.descender;
+                    }
 
-		  asc = yoffset + (asc >> 6);
-		  desc = yoffset + (desc >> 6);
+                  asc = yoffset + (asc >> 6);
+                  desc = yoffset + (desc >> 6);
 
-		  if (desc < bbox(1))
-		    {
-		      bbox(3) += (bbox(1) - desc);
-		      bbox(1) = desc;
-		    }
-		  if (asc > (bbox(3)+bbox(1)))
-		    bbox(3) = asc-bbox(1);
-		  break;
-		}
+                  if (desc < bbox(1))
+                    {
+                      bbox(3) += (bbox(1) - desc);
+                      bbox(1) = desc;
+                    }
+                  if (asc > (bbox(3)+bbox(1)))
+                    bbox(3) = asc-bbox(1);
+                  break;
+                }
 
-	      previous = glyph_index;
-	    }
-	}
+              previous = glyph_index;
+            }
+        }
     }
 }
 
 void
 ft_render::reset (void)
 {
   set_mode (MODE_BBOX);
   set_color (Matrix (1, 3, 0.0));
@@ -390,57 +390,57 @@ ft_render::render (text_element* elt, Ma
   box = bbox;
 
   set_mode (MODE_RENDER);
   if (pixels.numel () > 0)
     {
       elt->accept (*this);
 
       switch (rotation)
-	{
-	case ROTATION_0:
-	  break;
-	case ROTATION_90:
-	    {
-	      Array<octave_idx_type> perm (3);
-	      perm(0) = 0;
-	      perm(1) = 2;
-	      perm(2) = 1;
-	      pixels = pixels.permute (perm);
+        {
+        case ROTATION_0:
+          break;
+        case ROTATION_90:
+            {
+              Array<octave_idx_type> perm (3);
+              perm(0) = 0;
+              perm(1) = 2;
+              perm(2) = 1;
+              pixels = pixels.permute (perm);
 
-	      Array<idx_vector> idx (3);
-	      idx(0) = idx_vector (':');
-	      idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
-	      idx(2) = idx_vector (':');
-	      pixels = uint8NDArray (pixels.index (idx));
-	    }
-	  break;
-	case ROTATION_180:
-	    {
-	      Array<idx_vector> idx (3);
-	      idx(0) = idx_vector (':');
-	      idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
-	      idx(2)=  idx_vector (pixels.dim3()-1, -1, -1);
-	      pixels = uint8NDArray (pixels.index (idx));
-	    }
-	  break;
-	case ROTATION_270:
-	    {
-	      Array<octave_idx_type> perm (3);
-	      perm(0) = 0;
-	      perm(1) = 2;
-	      perm(2) = 1;
-	      pixels = pixels.permute (perm);
+              Array<idx_vector> idx (3);
+              idx(0) = idx_vector (':');
+              idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
+              idx(2) = idx_vector (':');
+              pixels = uint8NDArray (pixels.index (idx));
+            }
+          break;
+        case ROTATION_180:
+            {
+              Array<idx_vector> idx (3);
+              idx(0) = idx_vector (':');
+              idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
+              idx(2)=  idx_vector (pixels.dim3()-1, -1, -1);
+              pixels = uint8NDArray (pixels.index (idx));
+            }
+          break;
+        case ROTATION_270:
+            {
+              Array<octave_idx_type> perm (3);
+              perm(0) = 0;
+              perm(1) = 2;
+              perm(2) = 1;
+              pixels = pixels.permute (perm);
 
-	      Array<idx_vector> idx (3);
-	      idx(0) = idx_vector (':');
-	      idx(1) = idx_vector (':');
-	      idx(2) = idx_vector (pixels.dim3()-1, -1, -1);
-	      pixels = uint8NDArray (pixels.index (idx));
-	    }
-	  break;
-	}
+              Array<idx_vector> idx (3);
+              idx(0) = idx_vector (':');
+              idx(1) = idx_vector (':');
+              idx(2) = idx_vector (pixels.dim3()-1, -1, -1);
+              pixels = uint8NDArray (pixels.index (idx));
+            }
+          break;
+        }
     }
 
   return pixels;
 }
 
 #endif // HAVE_FREETYPE
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -114,48 +114,48 @@ Return true if @var{name} is a valid var
 bool
 same_file (const std::string& f, const std::string& g)
 {
   return same_file_internal (f, g);
 }
 
 int
 almost_match (const std::string& std, const std::string& s, int min_match_len,
-	      int case_sens)
+              int case_sens)
 {
   int stdlen = std.length ();
   int slen = s.length ();
 
   return (slen <= stdlen
-	  && slen >= min_match_len
-	  && (case_sens
-	      ? (strncmp (std.c_str (), s.c_str (), slen) == 0)
-	      : (octave_strncasecmp (std.c_str (), s.c_str (), slen) == 0)));
+          && slen >= min_match_len
+          && (case_sens
+              ? (strncmp (std.c_str (), s.c_str (), slen) == 0)
+              : (octave_strncasecmp (std.c_str (), s.c_str (), slen) == 0)));
 }
 
 // Ugh.
 
 int
 keyword_almost_match (const char * const *std, int *min_len, const std::string& s,
-		      int min_toks_to_match, int max_toks)
+                      int min_toks_to_match, int max_toks)
 {
   int status = 0;
   int tok_count = 0;
   int toks_matched = 0;
 
   if (s.empty () || max_toks < 1)
     return status;
 
   char *kw = strsave (s.c_str ());
 
   char *t = kw;
   while (*t != '\0')
     {
       if (*t == '\t')
-	*t = ' ';
+        *t = ' ';
       t++;
     }
 
   char *beg = kw;
   while (*beg == ' ')
     beg++;
 
   if (*beg == '\0')
@@ -172,49 +172,49 @@ keyword_almost_match (const char * const
   s2[tok_count] = beg;
   char *end;
   while ((end = strchr (beg, ' ')) != 0)
     {
       *end = '\0';
       beg = end + 1;
 
       while (*beg == ' ')
-	beg++;
+        beg++;
 
       if (*beg == '\0')
-	break;
+        break;
 
       tok_count++;
       if (tok_count >= max_toks)
-	goto done;
+        goto done;
 
       s2[tok_count] = beg;
     }
   s2[tok_count+1] = 0;
 
   s2 = to_match;
 
   for (;;)
     {
       if (! almost_match (*s1, *s2, min_len[toks_matched], 0))
-	goto done;
+        goto done;
 
       toks_matched++;
 
       s1++;
       s2++;
 
       if (! *s2)
-	{
-	  status = (toks_matched >= min_toks_to_match);
-	  goto done;
-	}
+        {
+          status = (toks_matched >= min_toks_to_match);
+          goto done;
+        }
 
       if (! *s1)
-	goto done;
+        goto done;
     }
 
  done:
 
   delete [] kw;
   delete [] to_match;
 
   return status;
@@ -292,40 +292,40 @@ name in the path.  If no files are found
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       string_vector names = args(0).all_strings ();
 
       if (! error_state && names.length () > 0)
-	{
-	  if (nargin == 1)
-	    {
-	      std::string fname
+        {
+          if (nargin == 1)
+            {
+              std::string fname
                 = octave_env::make_absolute (load_path::find_first_of (names));
 
-	      if (fname.empty ())
-		retval = Matrix ();
-	      else
-		retval = fname;
-	    }
-	  else if (nargin == 2)
-	    {
-	      std::string opt = args(1).string_value ();
+              if (fname.empty ())
+                retval = Matrix ();
+              else
+                retval = fname;
+            }
+          else if (nargin == 2)
+            {
+              std::string opt = args(1).string_value ();
 
-	      if (! error_state && opt == "all")
-		retval = Cell (make_absolute
+              if (! error_state && opt == "all")
+                retval = Cell (make_absolute
                                (load_path::find_all_first_of (names)));
-	      else
-		error ("file_in_loadpath: invalid option");
-	    }
-	}
+              else
+                error ("file_in_loadpath: invalid option");
+            }
+        }
       else
-	error ("file_in_loadpath: expecting string as first argument");
+        error ("file_in_loadpath: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (file_in_path, args, ,
@@ -358,46 +358,46 @@ name in the path.  If no files are found
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       std::string path = args(0).string_value ();
 
       if (! error_state)
-	{
-	  string_vector names = args(1).all_strings ();
+        {
+          string_vector names = args(1).all_strings ();
 
-	  if (! error_state && names.length () > 0)
-	    {
-	      if (nargin == 2)
-		{
-		  std::string fname = search_path_for_file (path, names);
+          if (! error_state && names.length () > 0)
+            {
+              if (nargin == 2)
+                {
+                  std::string fname = search_path_for_file (path, names);
 
-		  if (fname.empty ())
-		    retval = Matrix ();
-		  else
-		    retval = fname;
-		}
-	      else if (nargin == 3)
-		{
-		  std::string opt = args(2).string_value ();
+                  if (fname.empty ())
+                    retval = Matrix ();
+                  else
+                    retval = fname;
+                }
+              else if (nargin == 3)
+                {
+                  std::string opt = args(2).string_value ();
 
-		  if (! error_state && opt == "all")
-		    retval = Cell (make_absolute
+                  if (! error_state && opt == "all")
+                    retval = Cell (make_absolute
                                    (search_path_for_all_files (path, names)));
-		  else
-		    error ("file_in_path: invalid option");
-		}
-	    }
-	  else
-	    error ("file_in_path: expecting string as second argument");
-	}
+                  else
+                    error ("file_in_path: invalid option");
+                }
+            }
+          else
+            error ("file_in_path: expecting string as second argument");
+        }
       else
-	error ("file_in_path: expecting string as first argument");
+        error ("file_in_path: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 std::string
@@ -419,55 +419,55 @@ fcn_file_in_path (const std::string& nam
 {
   std::string retval;
 
   int len = name.length ();
   
   if (len > 0)
     {
       if (octave_env::absolute_pathname (name))
-	{
-	  file_stat fs (name);
+        {
+          file_stat fs (name);
 
-	  if (fs.exists ())
-	    retval = name;
-	}
+          if (fs.exists ())
+            retval = name;
+        }
       else if (len > 2 && name [len - 2] == '.' && name [len - 1] == 'm')
-	retval = load_path::find_fcn_file (name.substr (0, len-2));
+        retval = load_path::find_fcn_file (name.substr (0, len-2));
       else
-	{
-	  std::string fname = name;
-	  size_t pos = name.find_first_of (Vfilemarker);
-	  if (pos != std::string::npos)
-	    fname = name.substr (0, pos);
+        {
+          std::string fname = name;
+          size_t pos = name.find_first_of (Vfilemarker);
+          if (pos != std::string::npos)
+            fname = name.substr (0, pos);
 
-	  retval = load_path::find_fcn_file (fname);
-	}
+          retval = load_path::find_fcn_file (fname);
+        }
     }
 
   return retval;
 }
 
 // See if there is a directory called "name" in the path and if it
 // contains a Contents.m file return the full path to this file.
 
 std::string
 contents_file_in_path (const std::string& dir)
 {
   std::string retval;
 
   if (dir.length () > 0)
     {
       std::string tcontents = file_ops::concat (load_path::find_dir (dir), 
-						std::string ("Contents.m"));
+                                                std::string ("Contents.m"));
 
       file_stat fs (tcontents);
 
       if (fs.exists ())
-	retval = octave_env::make_absolute (tcontents);
+        retval = octave_env::make_absolute (tcontents);
     }
 
   return retval;
 }
 
 // See if there is a .oct file in the path.  If so, return the
 // full path to the file.
 
@@ -476,27 +476,27 @@ oct_file_in_path (const std::string& nam
 {
   std::string retval;
 
   int len = name.length ();
   
   if (len > 0)
     {
       if (octave_env::absolute_pathname (name))
-	{
-	  file_stat fs (name);
+        {
+          file_stat fs (name);
 
-	  if (fs.exists ())
-	    retval = name;
-	}
+          if (fs.exists ())
+            retval = name;
+        }
       else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'o'
-	       && name [len - 2] == 'c' && name [len - 1] == 't')
-	retval = load_path::find_oct_file (name.substr (0, len-4));
+               && name [len - 2] == 'c' && name [len - 1] == 't')
+        retval = load_path::find_oct_file (name.substr (0, len-4));
       else
-	retval = load_path::find_oct_file (name);
+        retval = load_path::find_oct_file (name);
     }
 
   return retval;
 }
 
 // See if there is a .mex file in the path.  If so, return the
 // full path to the file.
 
@@ -505,27 +505,27 @@ mex_file_in_path (const std::string& nam
 {
   std::string retval;
 
   int len = name.length ();
   
   if (len > 0)
     {
       if (octave_env::absolute_pathname (name))
-	{
-	  file_stat fs (name);
+        {
+          file_stat fs (name);
 
-	  if (fs.exists ())
-	    retval = name;
-	}
+          if (fs.exists ())
+            retval = name;
+        }
       else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'm'
-	       && name [len - 2] == 'e' && name [len - 1] == 'x')
-	retval = load_path::find_mex_file (name.substr (0, len-4));
+               && name [len - 2] == 'e' && name [len - 1] == 'x')
+        retval = load_path::find_mex_file (name.substr (0, len-4));
       else
-	retval = load_path::find_mex_file (name);
+        retval = load_path::find_mex_file (name);
     }
 
   return retval;
 }
 
 // Replace backslash escapes in a string with the real values.
 
 std::string
@@ -537,74 +537,74 @@ do_string_escapes (const std::string& s)
   size_t j = 0;
   size_t len = s.length ();
 
   retval.resize (len);
 
   while (j < len)
     {
       if (s[j] == '\\' && j+1 < len)
-	{
-	  switch (s[++j])
-	    {
-	    case '0':
-	      retval[i] = '\0';
-	      break;
+        {
+          switch (s[++j])
+            {
+            case '0':
+              retval[i] = '\0';
+              break;
 
-	    case 'a':
-	      retval[i] = '\a';
-	      break;
+            case 'a':
+              retval[i] = '\a';
+              break;
 
-	    case 'b': // backspace
-	      retval[i] = '\b';
-	      break;
+            case 'b': // backspace
+              retval[i] = '\b';
+              break;
 
-	    case 'f': // formfeed
-	      retval[i] = '\f';
-	      break;
+            case 'f': // formfeed
+              retval[i] = '\f';
+              break;
 
-	    case 'n': // newline
-	      retval[i] = '\n';
-	      break;
+            case 'n': // newline
+              retval[i] = '\n';
+              break;
 
-	    case 'r': // carriage return
-	      retval[i] = '\r';
-	      break;
+            case 'r': // carriage return
+              retval[i] = '\r';
+              break;
 
-	    case 't': // horizontal tab
-	      retval[i] = '\t';
-	      break;
+            case 't': // horizontal tab
+              retval[i] = '\t';
+              break;
 
-	    case 'v': // vertical tab
-	      retval[i] = '\v';
-	      break;
+            case 'v': // vertical tab
+              retval[i] = '\v';
+              break;
 
-	    case '\\': // backslash
-	      retval[i] = '\\';
-	      break;
+            case '\\': // backslash
+              retval[i] = '\\';
+              break;
 
-	    case '\'': // quote
-	      retval[i] = '\'';
-	      break;
+            case '\'': // quote
+              retval[i] = '\'';
+              break;
 
-	    case '"': // double quote
-	      retval[i] = '"';
-	      break;
+            case '"': // double quote
+              retval[i] = '"';
+              break;
 
-	    default:
-	      warning ("unrecognized escape sequence `\\%c' --\
+            default:
+              warning ("unrecognized escape sequence `\\%c' --\
  converting to `%c'", s[j], s[j]);
-	      retval[i] = s[j];
-	      break;
-	    }
-	}
+              retval[i] = s[j];
+              break;
+            }
+        }
       else
-	{
-	  retval[i] = s[j];
-	}
+        {
+          retval[i] = s[j];
+        }
 
       i++;
       j++;
     }
 
   retval.resize (i);
 
   return retval;
@@ -618,19 +618,19 @@ Convert special characters in @var{strin
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
-	retval = do_string_escapes (args(0).string_value ());
+        retval = do_string_escapes (args(0).string_value ());
       else
-	error ("do_string_escapes: argument must be a string");
+        error ("do_string_escapes: argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 const char *
@@ -668,20 +668,20 @@ undo_string_escape (char c)
     case '\\': // backslash
       return "\\\\";
 
     case '"': // double quote
       return "\\\"";
 
     default:
       {
-	static char retval[2];
-	retval[0] = c;
-	retval[1] = '\0';
-	return retval;
+        static char retval[2];
+        retval[0] = c;
+        retval[1] = '\0';
+        return retval;
       }
     }
 }
 
 std::string
 undo_string_escapes (const std::string& s)
 {
   std::string retval;
@@ -724,19 +724,19 @@ representation.\n\
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
-	retval = undo_string_escapes (args(0).string_value ());
+        retval = undo_string_escapes (args(0).string_value ());
       else
-	error ("undo_string_escapes: argument must be a string");
+        error ("undo_string_escapes: argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (is_absolute_filename, args, ,
@@ -744,34 +744,34 @@ DEFUN (is_absolute_filename, args, ,
 @deftypefn {Built-in Function} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     retval = (args(0).is_string ()
-	      && octave_env::absolute_pathname (args(0).string_value ()));
+              && octave_env::absolute_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (is_rooted_relative_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_rooted_relative_filename (@var{file})\n\
 Return true if @var{file} is a rooted-relative filename.\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     retval = (args(0).is_string ()
-	      && octave_env::rooted_relative_pathname (args(0).string_value ()));
+              && octave_env::rooted_relative_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (make_absolute_filename, args, ,
   "-*- texinfo -*-\n\
@@ -781,19 +781,19 @@ Return the full name of @var{file}, rela
 {
   octave_value retval = std::string ();
 
   if (args.length () == 1)
     {
       std::string nm = args(0).string_value ();
 
       if (! error_state)
-	retval = octave_env::make_absolute (nm);
+        retval = octave_env::make_absolute (nm);
       else
-	error ("make_absolute_filename: expecting argument to be a file name");
+        error ("make_absolute_filename: expecting argument to be a file name");
     }      
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (find_dir_in_path, args, ,
@@ -815,24 +815,24 @@ containing all the directory names that 
 
   std::string dir;
 
   if (nargin == 1 || nargin == 2)
     {
       dir = args(0).string_value ();
 
       if (! error_state)
-	{
-	  if (nargin == 1)
-	    retval = load_path::find_dir (dir);
-	  else if (nargin == 2)
-	    retval = Cell (load_path::find_matching_dirs (dir));
-	}
+        {
+          if (nargin == 1)
+            retval = load_path::find_dir (dir);
+          else if (nargin == 2)
+            retval = Cell (load_path::find_matching_dirs (dir));
+        }
       else
-	error ("find_dir_in_path: expecting argument to be a directory name");
+        error ("find_dir_in_path: expecting argument to be a directory name");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("errno", Ferrno, args, ,
@@ -848,33 +848,33 @@ if @var{name} is not found.\n\
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
-	{
-	  std::string nm = args(0).string_value ();
+        {
+          std::string nm = args(0).string_value ();
 
-	  if (! error_state)
-	    retval = octave_errno::lookup (nm);
-	  else
-	    error ("errno: expecting character string argument");
-	}
+          if (! error_state)
+            retval = octave_errno::lookup (nm);
+          else
+            error ("errno: expecting character string argument");
+        }
       else
-	{
-	  int val = args(0).int_value ();
+        {
+          int val = args(0).int_value ();
 
-	  if (! error_state)
-	    retval = octave_errno::set (val);
-	  else
-	    error ("errno: expecting integer argument");
-	}
+          if (! error_state)
+            retval = octave_errno::set (val);
+          else
+            error ("errno: expecting integer argument");
+        }
     }
   else if (nargin == 0)
     retval = octave_errno::get ();
   else
     print_usage ();
 
   return retval;
 }
@@ -896,17 +896,17 @@ Return a structure containing the system
 }
 
 static void
 check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       warning_with_id ("Octave:neg-dim-as-zero",
-		       "%s: converting negative dimension to zero", warnfor);
+                       "%s: converting negative dimension to zero", warnfor);
 
       nr = (nr < 0) ? 0 : nr;
       nc = (nc < 0) ? 0 : nc;
     }
 }
 
 void
 check_dimensions (dim_vector& dim, const char *warnfor)
@@ -919,17 +919,17 @@ check_dimensions (dim_vector& dim, const
         {
           dim(i) = 0;
           neg = true;
         }
     }
 
   if (neg)
     warning_with_id ("Octave:neg-dim-as-zero",
-		     "%s: converting negative dimension to zero", warnfor);
+                     "%s: converting negative dimension to zero", warnfor);
 }
 
 
 void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim)
 {
   if (a.is_scalar_type ())
@@ -961,48 +961,48 @@ get_dimensions (const octave_value& a, c
 
   if (! error_state)
     check_dimensions (dim, warn_for); // May set error_state.
 }
 
 
 void
 get_dimensions (const octave_value& a, const char *warn_for,
-		octave_idx_type& nr, octave_idx_type& nc)
+                octave_idx_type& nr, octave_idx_type& nc)
 {
   if (a.is_scalar_type ())
     {
       nr = nc = a.int_value ();
     }
   else
     {
       nr = a.rows ();
       nc = a.columns ();
 
       if ((nr == 1 && nc == 2) || (nr == 2 && nc == 1))
-	{
-	  Array<double> v = a.vector_value ();
+        {
+          Array<double> v = a.vector_value ();
 
-	  if (error_state)
-	    return;
+          if (error_state)
+            return;
 
-	  nr = static_cast<octave_idx_type> (fix (v (0)));
-	  nc = static_cast<octave_idx_type> (fix (v (1)));
-	}
+          nr = static_cast<octave_idx_type> (fix (v (0)));
+          nc = static_cast<octave_idx_type> (fix (v (1)));
+        }
       else
-	error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
+        error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
     }
 
   if (! error_state)
     check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 void
 get_dimensions (const octave_value& a, const octave_value& b,
-		const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
+                const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
 {
   nr = a.is_empty () ? 0 : a.int_value ();
   nc = b.is_empty () ? 0 : b.int_value ();
 
   if (error_state)
     error ("%s: expecting two scalar arguments", warn_for);
   else
     check_dimensions (nr, nc, warn_for); // May set error_state.
@@ -1038,112 +1038,112 @@ dims_to_numel (const dim_vector& dims, c
         }
     }
 
   return retval;
 }
 
 void
 decode_subscripts (const char* name, const octave_value& arg,
-		   std::string& type_string,
-		   std::list<octave_value_list>& idx)
+                   std::string& type_string,
+                   std::list<octave_value_list>& idx)
 {
   Octave_map m = arg.map_value ();
 
   if (! error_state
       && m.nfields () == 2 && m.contains ("type") && m.contains ("subs"))
     {
       Cell& type = m.contents ("type");
       Cell& subs = m.contents ("subs");
 
       type_string = std::string (type.length(), '\0');
 
       for (int k = 0; k < type.length (); k++)
-	{
-	  std::string item = type(k).string_value ();
+        {
+          std::string item = type(k).string_value ();
 
-	  if (! error_state)
-	    {
-	      if (item == "{}")
-		type_string[k] = '{';
-	      else if (item == "()")
-		type_string[k] = '(';
-	      else if (item == ".")
-		type_string[k] = '.';
-	      else
-		{
-		  error("%s: invalid indexing type `%s'", name, item.c_str ());
-		  return;
-		}
-	    }
-	  else
-	    {
-	      error ("%s: expecting type(%d) to be a character string",
-		     name, k+1);
-	      return;
-	    }
+          if (! error_state)
+            {
+              if (item == "{}")
+                type_string[k] = '{';
+              else if (item == "()")
+                type_string[k] = '(';
+              else if (item == ".")
+                type_string[k] = '.';
+              else
+                {
+                  error("%s: invalid indexing type `%s'", name, item.c_str ());
+                  return;
+                }
+            }
+          else
+            {
+              error ("%s: expecting type(%d) to be a character string",
+                     name, k+1);
+              return;
+            }
 
-	  octave_value_list idx_item;
+          octave_value_list idx_item;
 
-	  if (subs(k).is_string ())
-	    idx_item(0) = subs(k);
-	  else if (subs(k).is_cell ())
-	    {
-	      Cell subs_cell = subs(k).cell_value ();
+          if (subs(k).is_string ())
+            idx_item(0) = subs(k);
+          else if (subs(k).is_cell ())
+            {
+              Cell subs_cell = subs(k).cell_value ();
 
-	      for (int n = 0; n < subs_cell.length (); n++)
-		{
-		  if (subs_cell(n).is_string ()
-		      && subs_cell(n).string_value () == ":")
-		    idx_item(n) = octave_value(octave_value::magic_colon_t);
-		  else
-		    idx_item(n) = subs_cell(n);
-		}
-	    }
-	  else
-	    {
-	      error ("%s: expecting subs(%d) to be a character string or cell array",
-		     name, k+1);
-	      return;
-	    }
+              for (int n = 0; n < subs_cell.length (); n++)
+                {
+                  if (subs_cell(n).is_string ()
+                      && subs_cell(n).string_value () == ":")
+                    idx_item(n) = octave_value(octave_value::magic_colon_t);
+                  else
+                    idx_item(n) = subs_cell(n);
+                }
+            }
+          else
+            {
+              error ("%s: expecting subs(%d) to be a character string or cell array",
+                     name, k+1);
+              return;
+            }
 
-	  idx.push_back (idx_item);
-	}
+          idx.push_back (idx_item);
+        }
     }
   else
     error ("%s: second argument must be a structure with fields `type' and `subs'", name);
 }
 
 Matrix
 identity_matrix (octave_idx_type nr, octave_idx_type nc)
 {
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       octave_idx_type n = std::min (nr, nc);
 
       for (octave_idx_type i = 0; i < n; i++)
-	m (i, i) = 1.0;
+        m (i, i) = 1.0;
     }
 
   return m;
 }
 
 FloatMatrix
 float_identity_matrix (octave_idx_type nr, octave_idx_type nc)
 {
   FloatMatrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       octave_idx_type n = std::min (nr, nc);
 
       for (octave_idx_type i = 0; i < n; i++)
-	m (i, i) = 1.0;
+        m (i, i) = 1.0;
     }
 
   return m;
 }
 
 int
 octave_format (std::ostream& os, const char *fmt, ...)
 {
@@ -1283,20 +1283,20 @@ octave_snprintf (const char *fmt, ...)
 void
 octave_sleep (double seconds)
 {
   if (seconds > 0)
     {
       double t;
 
       unsigned int usec
-	= static_cast<unsigned int> (modf (seconds, &t) * 1000000);
+        = static_cast<unsigned int> (modf (seconds, &t) * 1000000);
 
       unsigned int sec
-	= (t > UINT_MAX) ? UINT_MAX : static_cast<unsigned int> (t);
+        = (t > UINT_MAX) ? UINT_MAX : static_cast<unsigned int> (t);
 
       // Versions of these functions that accept unsigned int args are
       // defined in cutils.c.
       octave_sleep (sec);
       octave_usleep (usec);
 
       octave_quit ();
     }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -91,102 +91,102 @@ clear_symbol (const std::string& nm)
 }
 
 // Attributes of variables and functions.
 
 // Is this octave_value a valid function?
 
 octave_function *
 is_valid_function (const std::string& fcn_name,
-		   const std::string& warn_for, bool warn)
+                   const std::string& warn_for, bool warn)
 {
   octave_function *ans = 0;
 
   if (! fcn_name.empty ())
     {
       octave_value val = symbol_table::find_function (fcn_name);
 
       if (val.is_defined ())
-	ans = val.function_value (true);
+        ans = val.function_value (true);
     }
 
   if (! ans && warn)
     error ("%s: the symbol `%s' is not valid as a function",
-	   warn_for.c_str (), fcn_name.c_str ());
+           warn_for.c_str (), fcn_name.c_str ());
 
   return ans;
 }
 
 octave_function *
 is_valid_function (const octave_value& arg,
-		   const std::string& warn_for, bool warn)
+                   const std::string& warn_for, bool warn)
 {
   octave_function *ans = 0;
 
   std::string fcn_name;
 
   if (arg.is_string ())
     {
       fcn_name = arg.string_value ();
 
       if (! error_state)
-	ans = is_valid_function (fcn_name, warn_for, warn);
+        ans = is_valid_function (fcn_name, warn_for, warn);
       else if (warn)
-	error ("%s: expecting function name as argument", warn_for.c_str ());
+        error ("%s: expecting function name as argument", warn_for.c_str ());
     }
   else if (warn)
     error ("%s: expecting function name as argument", warn_for.c_str ());
 
   return ans;
 }
 
 octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
-		  const std::string& fname, const std::string& header,
-		  const std::string& trailer)
+                  const std::string& fname, const std::string& header,
+                  const std::string& trailer)
 {
   octave_function *retval = 0;
 
   retval = is_valid_function (arg, warn_for, 0);
 
   if (! retval)
     {
       std::string s = arg.string_value ();
 
       std::string cmd = header;
       cmd.append (s);
       cmd.append (trailer);
 
       if (! error_state)
-	{
-	  int parse_status;
+        {
+          int parse_status;
 
-	  eval_string (cmd, true, parse_status, 0);
+          eval_string (cmd, true, parse_status, 0);
 
-	  if (parse_status == 0)
-	    {
-	      retval = is_valid_function (fname, warn_for, 0);
+          if (parse_status == 0)
+            {
+              retval = is_valid_function (fname, warn_for, 0);
       
-	      if (! retval)
-		{
-		  error ("%s: `%s' is not valid as a function",
-			 warn_for.c_str (), fname.c_str ());
-		  return retval;
-		}
+              if (! retval)
+                {
+                  error ("%s: `%s' is not valid as a function",
+                         warn_for.c_str (), fname.c_str ());
+                  return retval;
+                }
 
               warning ("%s: passing function body as a string is obsolete."
                        " Please use anonymous functions.", warn_for.c_str ());
-	    }
-	  else
-	    error ("%s: `%s' is not valid as a function",
-		   warn_for.c_str (), fname.c_str ());
-	}
+            }
+          else
+            error ("%s: `%s' is not valid as a function",
+                   warn_for.c_str (), fname.c_str ());
+        }
       else
-	error ("%s: expecting first argument to be a string",
-	       warn_for.c_str ());
+        error ("%s: expecting first argument to be a string",
+               warn_for.c_str ());
     }
 
   return retval;
 }
 
 string_vector
 get_struct_elts (const std::string& text)
 {
@@ -194,36 +194,36 @@ get_struct_elts (const std::string& text
 
   size_t pos = 0;
 
   size_t len = text.length ();
 
   while ((pos = text.find ('.', pos)) != std::string::npos)
     {
       if (++pos == len)
-	break;
+        break;
 
       n++;
     }
 
   string_vector retval (n);
 
   pos = 0;
 
   for (int i = 0; i < n; i++)
     {
       len = text.find ('.', pos);
 
       if (len != std::string::npos)
-	len -= pos;
+        len -= pos;
 
       retval[i] = text.substr (pos, len);
 
       if (len != std::string::npos)
-	pos += len + 1;
+        pos += len + 1;
     }
 
   return retval;
 }
 
 static inline bool
 is_variable (const std::string& name)
 {
@@ -236,76 +236,76 @@ is_variable (const std::string& name)
       retval = val.is_defined ();
     }
 
   return retval;
 }
 
 string_vector
 generate_struct_completions (const std::string& text,
-			     std::string& prefix, std::string& hint)
+                             std::string& prefix, std::string& hint)
 {
   string_vector names;
 
   size_t pos = text.rfind ('.');
 
   if (pos != std::string::npos)
     {
       if (pos == text.length ())
-	hint = "";
+        hint = "";
       else
-	hint = text.substr (pos+1);
+        hint = text.substr (pos+1);
 
       prefix = text.substr (0, pos);
 
       std::string base_name = prefix;
 
       pos = base_name.find_first_of ("{(.");
 
       if (pos != std::string::npos)
-	base_name = base_name.substr (0, pos);
+        base_name = base_name.substr (0, pos);
 
       if (is_variable (base_name))
-	{
-	  int parse_status;
+        {
+          int parse_status;
 
-	  unwind_protect frame;
+          unwind_protect frame;
 
-	  frame.protect_var (error_state);
-	  frame.protect_var (warning_state);
+          frame.protect_var (error_state);
+          frame.protect_var (warning_state);
 
-	  frame.protect_var (discard_error_messages);
-	  frame.protect_var (discard_warning_messages);
+          frame.protect_var (discard_error_messages);
+          frame.protect_var (discard_warning_messages);
 
-	  discard_error_messages = true;
-	  discard_warning_messages = true;
+          discard_error_messages = true;
+          discard_warning_messages = true;
 
-	  octave_value tmp = eval_string (prefix, true, parse_status);
+          octave_value tmp = eval_string (prefix, true, parse_status);
 
-	  frame.run ();
+          frame.run ();
 
-	  if (tmp.is_defined () && tmp.is_map ())
-	    names = tmp.map_keys ();
-	}
+          if (tmp.is_defined () && tmp.is_map ())
+            names = tmp.map_keys ();
+        }
     }
 
   return names;
 }
 
 // FIXME -- this will have to be much smarter to work
 // "correctly".
 
 bool
 looks_like_struct (const std::string& text)
 {
   bool retval = (! text.empty ()
-		 && text != "."
-		 && text.find_first_of (file_ops::dir_sep_chars ()) == std::string::npos
-		 && text.find ("..") == std::string::npos
-		 && text.rfind ('.') != std::string::npos);
+                 && text != "."
+                 && text.find_first_of (file_ops::dir_sep_chars ()) == std::string::npos
+                 && text.find ("..") == std::string::npos
+                 && text.rfind ('.') != std::string::npos);
 
 #if 0
   symbol_record *sr = curr_sym_tab->lookup (text);
 
   if (sr && ! sr->is_function ())
     {
       int parse_status;
 
@@ -423,92 +423,92 @@ symbol_exist (const std::string& name, c
   octave_value val = safe_symbol_lookup (symbol_name);
 
   if (val.is_defined ())
     {
       bool not_a_struct = struct_elts.empty ();
       bool var_ok = not_a_struct /* || val.is_map_element (struct_elts) */;
 
       if (! retval
-	  && var_ok
-	  && (type == "any" || type == "var")
-	  && (val.is_constant () || val.is_object ()
-	      || val.is_inline_function () || val.is_function_handle ()))
-	{
-	  retval = 1;
-	}
+          && var_ok
+          && (type == "any" || type == "var")
+          && (val.is_constant () || val.is_object ()
+              || val.is_inline_function () || val.is_function_handle ()))
+        {
+          retval = 1;
+        }
 
       if (! retval
-	  && (type == "any" || type == "builtin"))
-	{
-	  if (not_a_struct && val.is_builtin_function ())
-	    {
-	      retval = 5;
-	    }
-	}
+          && (type == "any" || type == "builtin"))
+        {
+          if (not_a_struct && val.is_builtin_function ())
+            {
+              retval = 5;
+            }
+        }
 
       if (! retval
-	  && not_a_struct
-	  && (type == "any" || type == "file")
-	  && (val.is_user_function () || val.is_dld_function ()))
-	{
-	  octave_function *f = val.function_value (true);
-	  std::string s = f ? f->fcn_file_name () : std::string ();
+          && not_a_struct
+          && (type == "any" || type == "file")
+          && (val.is_user_function () || val.is_dld_function ()))
+        {
+          octave_function *f = val.function_value (true);
+          std::string s = f ? f->fcn_file_name () : std::string ();
 
-	  retval = s.empty () ? 103 : (val.is_user_function () ? 2 : 3);
-	}
+          retval = s.empty () ? 103 : (val.is_user_function () ? 2 : 3);
+        }
     }
 
   if (! (type == "var" || type == "builtin"))
     {
       if (! retval)
-	{
-	  std::string file_name = lookup_autoload (name);
+        {
+          std::string file_name = lookup_autoload (name);
 
-	  if (file_name.empty ())
-	    file_name = load_path::find_fcn (name);
+          if (file_name.empty ())
+            file_name = load_path::find_fcn (name);
 
-	  size_t len = file_name.length ();
+          size_t len = file_name.length ();
 
-	  if (len > 0)
-	    {
-	      if (type == "any" || type == "file")
-		{
-		  if (len > 4 && (file_name.substr (len-4) == ".oct"
-				  || file_name.substr (len-4) == ".mex"))
-		    retval = 3;
-		  else
-		    retval = 2;
-		}
-	    }
-	}
+          if (len > 0)
+            {
+              if (type == "any" || type == "file")
+                {
+                  if (len > 4 && (file_name.substr (len-4) == ".oct"
+                                  || file_name.substr (len-4) == ".mex"))
+                    retval = 3;
+                  else
+                    retval = 2;
+                }
+            }
+        }
 
       if (! retval)
-	{
-	  std::string file_name = file_in_path (name, "");
+        {
+          std::string file_name = file_in_path (name, "");
 
-	  if (file_name.empty ())
-	    file_name = name;
+          if (file_name.empty ())
+            file_name = name;
 
-	  file_stat fs (file_name);
+          file_stat fs (file_name);
 
-	  if (fs)
-	    {
-	      if ((type == "any" || type == "file")
-		  && fs.is_reg ())
-		{
-		  retval = 2;
-		}
-	      else if ((type == "any" || type == "dir")
-		       && fs.is_dir ())
-		{
-		  retval = 7;
-		}
-	    }
-	}
+          if (fs)
+            {
+              if ((type == "any" || type == "file")
+                  && fs.is_reg ())
+                {
+                  retval = 2;
+                }
+              else if ((type == "any" || type == "dir")
+                       && fs.is_dir ())
+                {
+                  retval = 7;
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 #define GET_IDX(LEN) \
   static_cast<int> ((LEN-1) * static_cast<double> (rand ()) / RAND_MAX)
 
@@ -570,27 +570,27 @@ Check only for directories.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	{
-	  std::string type
-	    = (nargin == 2) ? args(1).string_value () : std::string ("any");
+        {
+          std::string type
+            = (nargin == 2) ? args(1).string_value () : std::string ("any");
 
-	  if (! error_state)
-	    retval = symbol_exist (name, type);
-	  else
-	    error ("exist: expecting second argument to be a string");
-	}
+          if (! error_state)
+            retval = symbol_exist (name, type);
+          else
+            error ("exist: expecting second argument to be a string");
+        }
       else
-	error ("exist: expecting first argument to be a string");
+        error ("exist: expecting first argument to be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 octave_value
@@ -634,174 +634,174 @@ set_top_level_value (const std::string& 
 {
   symbol_table::top_level_varref (nm) = val;
 }
 
 // Variable values.
 
 octave_value
 set_internal_variable (bool& var, const octave_value_list& args,
-		       int nargout, const char *nm)
+                       int nargout, const char *nm)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (nargin == 1)
     {
       bool bval = args(0).bool_value ();
 
       if (! error_state)
-	var = bval;
+        var = bval;
       else
-	error ("%s: expecting arg to be a logical value", nm);
+        error ("%s: expecting arg to be a logical value", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (char& var, const octave_value_list& args,
-		       int nargout, const char *nm)
+                       int nargout, const char *nm)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (nargin == 1)
     {
       std::string sval = args(0).string_value ();
 
       if (! error_state)
-	{
-	  switch (sval.length ())
-	    {
-	    case 1:
-	      var = sval[0];
-	      break;
+        {
+          switch (sval.length ())
+            {
+            case 1:
+              var = sval[0];
+              break;
 
-	    case 0:
-	      var = '\0';
-	      break;
+            case 0:
+              var = '\0';
+              break;
 
-	    default:
-	      error ("%s: argument must be a single character", nm);
-	      break;
-	    }
-	}
+            default:
+              error ("%s: argument must be a single character", nm);
+              break;
+            }
+        }
       else
-	error ("%s: argument must be a single character", nm);
+        error ("%s: argument must be a single character", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (int& var, const octave_value_list& args,
-		       int nargout, const char *nm,
-		       int minval, int maxval)
+                       int nargout, const char *nm,
+                       int minval, int maxval)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (nargin == 1)
     {
       int ival = args(0).int_value ();
 
       if (! error_state)
-	{
-	  if (ival < minval)
-	    error ("%s: expecting arg to be greater than %d", nm, minval);
-	  else if (ival > maxval)
-	    error ("%s: expecting arg to be less than or equal to %d",
-		   nm, maxval);
-	  else
-	    var = ival;
-	}
+        {
+          if (ival < minval)
+            error ("%s: expecting arg to be greater than %d", nm, minval);
+          else if (ival > maxval)
+            error ("%s: expecting arg to be less than or equal to %d",
+                   nm, maxval);
+          else
+            var = ival;
+        }
       else
-	error ("%s: expecting arg to be an integer value", nm);
+        error ("%s: expecting arg to be an integer value", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (double& var, const octave_value_list& args,
-		       int nargout, const char *nm,
-		       double minval, double maxval)
+                       int nargout, const char *nm,
+                       double minval, double maxval)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (nargin == 1)
     {
       double dval = args(0).scalar_value ();
 
       if (! error_state)
-	{
-	  if (dval < minval)
-	    error ("%s: expecting arg to be greater than %g", minval);
-	  else if (dval > maxval)
-	    error ("%s: expecting arg to be less than or equal to %g", maxval);
-	  else
-	    var = dval;
-	}
+        {
+          if (dval < minval)
+            error ("%s: expecting arg to be greater than %g", minval);
+          else if (dval > maxval)
+            error ("%s: expecting arg to be less than or equal to %g", maxval);
+          else
+            var = dval;
+        }
       else
-	error ("%s: expecting arg to be a scalar value", nm);
+        error ("%s: expecting arg to be a scalar value", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
-		       int nargout, const char *nm, bool empty_ok)
+                       int nargout, const char *nm, bool empty_ok)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (nargin == 1)
     {
       std::string sval = args(0).string_value ();
 
       if (! error_state)
-	{
-	  if (empty_ok || ! sval.empty ())
-	    var = sval;
-	  else
-	    error ("%s: value must not be empty", nm);
-	}
+        {
+          if (empty_ok || ! sval.empty ())
+            var = sval;
+          else
+            error ("%s: value must not be empty", nm);
+        }
       else
-	error ("%s: expecting arg to be a character string", nm);
+        error ("%s: expecting arg to be a character string", nm);
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 struct
@@ -824,83 +824,83 @@ print_descriptor (std::ostream& os, std:
   std::ostringstream param_buf;
 
   while (i != params.end ())
     {
       whos_parameter param = *i;
 
       if (param.command != '\0')
         {
-	  // Do the actual printing
-	  switch (param.modifier)
-	    {
-	    case 'l':
-	      os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	      param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	      break;
+          // Do the actual printing
+          switch (param.modifier)
+            {
+            case 'l':
+              os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+              param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+              break;
 
-	    case 'r':
-	      os << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
-	      param_buf << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
-	      break;
+            case 'r':
+              os << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
+              param_buf << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
+              break;
 
-	    case 'c':
-	      if (param.command != 's')
-	        {
-		  os << std::setiosflags (std::ios::left)
-		     << std::setw (param.parameter_length);
-		  param_buf << std::setiosflags (std::ios::left)
-			    << std::setw (param.parameter_length);
-		}
-	      break;
+            case 'c':
+              if (param.command != 's')
+                {
+                  os << std::setiosflags (std::ios::left)
+                     << std::setw (param.parameter_length);
+                  param_buf << std::setiosflags (std::ios::left)
+                            << std::setw (param.parameter_length);
+                }
+              break;
 
-	    default:
-	      os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	      param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-	    }
+            default:
+              os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+              param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+            }
 
-	  if (param.command == 's' && param.modifier == 'c')
-	    {
-	      int a, b;
-	     
-	      if (param.modifier == 'c')
-	        {
-		  a = param.first_parameter_length - param.balance;
-		  a = (a < 0 ? 0 : a);
-		  b = param.parameter_length - a - param.text . length ();
-		  b = (b < 0 ? 0 : b);
-		  os << std::setiosflags (std::ios::left) << std::setw (a)
-		     << "" << std::resetiosflags (std::ios::left) << param.text
-		     << std::setiosflags (std::ios::left)
-		     << std::setw (b) << ""
-		     << std::resetiosflags (std::ios::left);
-		  param_buf << std::setiosflags (std::ios::left) << std::setw (a)
-		     << "" << std::resetiosflags (std::ios::left) << param.line
-		     << std::setiosflags (std::ios::left)
-		     << std::setw (b) << ""
-		     << std::resetiosflags (std::ios::left);
-		}
-	    }
-	  else
-	    {
-	      os << param.text;
-	      param_buf << param.line;
-	    }
-	  os << std::resetiosflags (std::ios::left)
-	     << std::resetiosflags (std::ios::right);
-	  param_buf << std::resetiosflags (std::ios::left)
-		    << std::resetiosflags (std::ios::right);
-	  i++;
-	}
+          if (param.command == 's' && param.modifier == 'c')
+            {
+              int a, b;
+             
+              if (param.modifier == 'c')
+                {
+                  a = param.first_parameter_length - param.balance;
+                  a = (a < 0 ? 0 : a);
+                  b = param.parameter_length - a - param.text . length ();
+                  b = (b < 0 ? 0 : b);
+                  os << std::setiosflags (std::ios::left) << std::setw (a)
+                     << "" << std::resetiosflags (std::ios::left) << param.text
+                     << std::setiosflags (std::ios::left)
+                     << std::setw (b) << ""
+                     << std::resetiosflags (std::ios::left);
+                  param_buf << std::setiosflags (std::ios::left) << std::setw (a)
+                     << "" << std::resetiosflags (std::ios::left) << param.line
+                     << std::setiosflags (std::ios::left)
+                     << std::setw (b) << ""
+                     << std::resetiosflags (std::ios::left);
+                }
+            }
+          else
+            {
+              os << param.text;
+              param_buf << param.line;
+            }
+          os << std::resetiosflags (std::ios::left)
+             << std::resetiosflags (std::ios::right);
+          param_buf << std::resetiosflags (std::ios::left)
+                    << std::resetiosflags (std::ios::right);
+          i++;
+        }
       else
-	{
-	  os << param.text;
-	  param_buf << param.line;
-	  i++;
-	}
+        {
+          os << param.text;
+          param_buf << param.line;
+          i++;
+        }
     }
 
   os << param_buf.str ();
 }
 
 // FIXME -- This is a bit of a kluge.  We'd like to just use val.dims()
 // and if val is an object, expect that dims will call size if it is
 // overloaded by a user-defined method.  But there are currently some
@@ -923,145 +923,145 @@ get_dims_str (const octave_value& val)
 
 class
 symbol_info_list
 {
 private:
   struct symbol_info
   {
     symbol_info (const symbol_table::symbol_record& sr,
-		 const std::string& expr_str = std::string (),
-		 const octave_value& expr_val = octave_value ())
+                 const std::string& expr_str = std::string (),
+                 const octave_value& expr_val = octave_value ())
       : name (expr_str.empty () ? sr.name () : expr_str),
-	is_automatic (sr.is_automatic ()),
-	is_formal (sr.is_formal ()),
-	is_global (sr.is_global ()),
-	is_persistent (sr.is_persistent ()),
-	varval (expr_val.is_undefined () ? sr.varval () : expr_val)
+        is_automatic (sr.is_automatic ()),
+        is_formal (sr.is_formal ()),
+        is_global (sr.is_global ()),
+        is_persistent (sr.is_persistent ()),
+        varval (expr_val.is_undefined () ? sr.varval () : expr_val)
     { }
 
     void display_line (std::ostream& os,
-		       const std::list<whos_parameter>& params) const
+                       const std::list<whos_parameter>& params) const
     {
       std::string dims_str = get_dims_str (varval);
 
       std::list<whos_parameter>::const_iterator i = params.begin ();
 
       while (i != params.end ())
-	{
-	  whos_parameter param = *i;
+        {
+          whos_parameter param = *i;
 
-	  if (param.command != '\0')
-	    {
-	      // Do the actual printing.
+          if (param.command != '\0')
+            {
+              // Do the actual printing.
 
-	      switch (param.modifier)
-		{
-		case 'l':
-		  os << std::setiosflags (std::ios::left)
-		     << std::setw (param.parameter_length);
-		  break;
+              switch (param.modifier)
+                {
+                case 'l':
+                  os << std::setiosflags (std::ios::left)
+                     << std::setw (param.parameter_length);
+                  break;
 
-		case 'r':
-		  os << std::setiosflags (std::ios::right)
-		     << std::setw (param.parameter_length);
-		  break;
+                case 'r':
+                  os << std::setiosflags (std::ios::right)
+                     << std::setw (param.parameter_length);
+                  break;
 
-		case 'c':
-		  if (param.command == 's')
-		    {
-		      int front = param.first_parameter_length
-			- dims_str.find ('x');
-		      int back = param.parameter_length
-			- dims_str.length ()
-			- front;
-		      front = (front > 0) ? front : 0;
-		      back = (back > 0) ? back : 0;
+                case 'c':
+                  if (param.command == 's')
+                    {
+                      int front = param.first_parameter_length
+                        - dims_str.find ('x');
+                      int back = param.parameter_length
+                        - dims_str.length ()
+                        - front;
+                      front = (front > 0) ? front : 0;
+                      back = (back > 0) ? back : 0;
 
-		      os << std::setiosflags (std::ios::left)
-			 << std::setw (front)
-			 << ""
-			 << std::resetiosflags (std::ios::left)
-			 << dims_str
-			 << std::setiosflags (std::ios::left)
-			 << std::setw (back)
-			 << ""
-			 << std::resetiosflags (std::ios::left);
-		    }
-		  else
-		    {
-		      os << std::setiosflags (std::ios::left)
-			 << std::setw (param.parameter_length);
-		    }
-		  break;
+                      os << std::setiosflags (std::ios::left)
+                         << std::setw (front)
+                         << ""
+                         << std::resetiosflags (std::ios::left)
+                         << dims_str
+                         << std::setiosflags (std::ios::left)
+                         << std::setw (back)
+                         << ""
+                         << std::resetiosflags (std::ios::left);
+                    }
+                  else
+                    {
+                      os << std::setiosflags (std::ios::left)
+                         << std::setw (param.parameter_length);
+                    }
+                  break;
 
-		default:
-		  error ("whos_line_format: modifier `%c' unknown",
-			 param.modifier);
+                default:
+                  error ("whos_line_format: modifier `%c' unknown",
+                         param.modifier);
 
-		  os << std::setiosflags (std::ios::right)
-		     << std::setw (param.parameter_length);
-		}
+                  os << std::setiosflags (std::ios::right)
+                     << std::setw (param.parameter_length);
+                }
 
-	      switch (param.command)
-		{
-		case 'a':
-		  {
-		    char tmp[5];
+              switch (param.command)
+                {
+                case 'a':
+                  {
+                    char tmp[5];
 
-		    tmp[0] = (is_automatic ? 'a' : ' ');
-		    tmp[1] = (is_formal ? 'f' : ' ');
-		    tmp[2] = (is_global ? 'g' : ' ');
-		    tmp[3] = (is_persistent ? 'p' : ' ');
-		    tmp[4] = 0;
+                    tmp[0] = (is_automatic ? 'a' : ' ');
+                    tmp[1] = (is_formal ? 'f' : ' ');
+                    tmp[2] = (is_global ? 'g' : ' ');
+                    tmp[3] = (is_persistent ? 'p' : ' ');
+                    tmp[4] = 0;
 
-		    os << tmp;
-		  }
-		  break;
+                    os << tmp;
+                  }
+                  break;
 
-		case 'b':
-		  os << varval.byte_size ();
-		  break;
+                case 'b':
+                  os << varval.byte_size ();
+                  break;
 
-		case 'c':
-		  os << varval.class_name ();
-		  break;
+                case 'c':
+                  os << varval.class_name ();
+                  break;
 
-		case 'e':
-		  os << varval.capacity ();
-		  break;
+                case 'e':
+                  os << varval.capacity ();
+                  break;
 
-		case 'n':
-		  os << name;
-		  break;
+                case 'n':
+                  os << name;
+                  break;
 
-		case 's':
-		  if (param.modifier != 'c')
-		    os << dims_str;
-		  break;
+                case 's':
+                  if (param.modifier != 'c')
+                    os << dims_str;
+                  break;
 
-		case 't':
-		  os << varval.type_name ();
-		  break;
-	    
-		default:
-		  error ("whos_line_format: command `%c' unknown",
-			 param.command);
-		}
+                case 't':
+                  os << varval.type_name ();
+                  break;
+            
+                default:
+                  error ("whos_line_format: command `%c' unknown",
+                         param.command);
+                }
 
-	      os << std::resetiosflags (std::ios::left)
-		 << std::resetiosflags (std::ios::right);
-	      i++;
-	    }
-	  else
-	    {
-	      os << param.text;
-	      i++;
-	    }
-	}
+              os << std::resetiosflags (std::ios::left)
+                 << std::resetiosflags (std::ios::right);
+              i++;
+            }
+          else
+            {
+              os << param.text;
+              i++;
+            }
+        }
     }
 
     std::string name;
     bool is_automatic;
     bool is_formal;
     bool is_global;
     bool is_persistent;
     octave_value varval;
@@ -1083,18 +1083,18 @@ public:
   ~symbol_info_list (void) { }
 
   void append (const symbol_table::symbol_record& sr)
   {
     lst.push_back (symbol_info (sr));
   }
 
   void append (const symbol_table::symbol_record& sr,
-	       const std::string& expr_str,
-	       const octave_value& expr_val)
+               const std::string& expr_str,
+               const octave_value& expr_val)
   {
     lst.push_back (symbol_info (sr, expr_str, expr_val));
   }
 
   size_t size (void) const { return lst.size (); }
 
   bool empty (void) const { return lst.empty (); }
 
@@ -1112,35 +1112,35 @@ public:
     Cell complex_info (len, 1);
     Cell nesting_info (len, 1);
     Cell persistent_info (len, 1);
 
     std::list<symbol_info>::const_iterator p = lst.begin ();
 
     for (size_t j = 0; j < len; j++)
       {
-	const symbol_info& si = *p++;
+        const symbol_info& si = *p++;
 
-	Octave_map ni;
+        Octave_map ni;
 
-	ni.assign ("function", caller_function_name);
-	ni.assign ("level", nesting_level);
+        ni.assign ("function", caller_function_name);
+        ni.assign ("level", nesting_level);
 
-	name_info(j) = si.name;
-	global_info(j) = si.is_global;
-	persistent_info(j) = si.is_persistent;
+        name_info(j) = si.name;
+        global_info(j) = si.is_global;
+        persistent_info(j) = si.is_persistent;
 
-	octave_value val = si.varval;
+        octave_value val = si.varval;
 
-	size_info(j) = val.size ();
-	bytes_info(j) = val.byte_size ();
-	class_info(j) = val.class_name ();
-	sparse_info(j) = val.is_sparse_type ();
-	complex_info(j) = val.is_complex_type ();
-	nesting_info(j) = ni;
+        size_info(j) = val.size ();
+        bytes_info(j) = val.byte_size ();
+        class_info(j) = val.class_name ();
+        sparse_info(j) = val.is_sparse_type ();
+        complex_info(j) = val.is_complex_type ();
+        nesting_info(j) = ni;
       }
 
     Octave_map info;
 
     info.assign ("name", name_info);
     info.assign ("size", size_info);
     info.assign ("bytes", bytes_info);
     info.assign ("class", class_info);
@@ -1152,40 +1152,40 @@ public:
 
     return info;
   }
 
   void display (std::ostream& os)
   {
     if (! lst.empty ())
       {
-	size_t bytes = 0;
-	size_t elements = 0;
+        size_t bytes = 0;
+        size_t elements = 0;
 
-	std::list<whos_parameter> params = parse_whos_line_format ();
+        std::list<whos_parameter> params = parse_whos_line_format ();
 
-	print_descriptor (os, params);
+        print_descriptor (os, params);
 
-	octave_stdout << "\n";
+        octave_stdout << "\n";
 
-	for (std::list<symbol_info>::const_iterator p = lst.begin ();
-	     p != lst.end (); p++)
-	  {
-	    p->display_line (os, params);
+        for (std::list<symbol_info>::const_iterator p = lst.begin ();
+             p != lst.end (); p++)
+          {
+            p->display_line (os, params);
 
-	    octave_value val = p->varval;
+            octave_value val = p->varval;
 
-	    elements += val.capacity ();
-	    bytes += val.byte_size ();
-	  }
+            elements += val.capacity ();
+            bytes += val.byte_size ();
+          }
 
-	os << "\nTotal is " << elements
-	   << (elements == 1 ? " element" : " elements")
-	   << " using " << bytes << (bytes == 1 ? " byte" : " bytes")
-	   << "\n";
+        os << "\nTotal is " << elements
+           << (elements == 1 ? " element" : " elements")
+           << " using " << bytes << (bytes == 1 ? " byte" : " bytes")
+           << "\n";
       }
   }
 
   // Parse the string whos_line_format, and return a parameter list,
   // containing all information needed to print the given
   // attributtes of the symbols.
   std::list<whos_parameter> parse_whos_line_format (void)
   {
@@ -1220,398 +1220,398 @@ public:
 
     for (size_t i = 0; i < param_string.length (); i++)
       param_length(i) = param_names(i) . length ();
 
     // Calculating necessary spacing for name column,
     // bytes column, elements column and class column
 
     for (std::list<symbol_info>::const_iterator p = lst.begin ();
-	 p != lst.end (); p++)
+         p != lst.end (); p++)
       {
-	std::stringstream ss1, ss2;
-	std::string str;
+        std::stringstream ss1, ss2;
+        std::string str;
 
-	str = p->name;
-	param_length(pos_n) = ((str.length ()
-				> static_cast<size_t> (param_length(pos_n)))
-			       ? str.length () : param_length(pos_n));
+        str = p->name;
+        param_length(pos_n) = ((str.length ()
+                                > static_cast<size_t> (param_length(pos_n)))
+                               ? str.length () : param_length(pos_n));
 
-	octave_value val = p->varval;
+        octave_value val = p->varval;
 
-	str = val.type_name ();
-	param_length(pos_t) = ((str.length ()
-				> static_cast<size_t> (param_length(pos_t)))
-			       ? str.length () : param_length(pos_t));
+        str = val.type_name ();
+        param_length(pos_t) = ((str.length ()
+                                > static_cast<size_t> (param_length(pos_t)))
+                               ? str.length () : param_length(pos_t));
 
-	elements1 = val.capacity ();
-	ss1 << elements1;
-	str = ss1.str ();
-	param_length(pos_e) = ((str.length ()
-				> static_cast<size_t> (param_length(pos_e)))
-			       ? str.length () : param_length(pos_e));
+        elements1 = val.capacity ();
+        ss1 << elements1;
+        str = ss1.str ();
+        param_length(pos_e) = ((str.length ()
+                                > static_cast<size_t> (param_length(pos_e)))
+                               ? str.length () : param_length(pos_e));
 
-	bytes1 = val.byte_size ();
-	ss2 << bytes1;
-	str = ss2.str ();
-	param_length(pos_b) = ((str.length ()
-				> static_cast<size_t> (param_length(pos_b)))
-			       ? str.length () : param_length (pos_b));
+        bytes1 = val.byte_size ();
+        ss2 << bytes1;
+        str = ss2.str ();
+        param_length(pos_b) = ((str.length ()
+                                > static_cast<size_t> (param_length(pos_b)))
+                               ? str.length () : param_length (pos_b));
       }
 
     idx = 0;
     while (static_cast<size_t> (idx) < format_len)
       {
-	whos_parameter param;
-	param.command = '\0';
+        whos_parameter param;
+        param.command = '\0';
 
-	if (Vwhos_line_format[idx] == '%')
-	  {
-	    bool error_encountered = false;
-	    param.modifier = 'r';
-	    param.parameter_length = 0;
+        if (Vwhos_line_format[idx] == '%')
+          {
+            bool error_encountered = false;
+            param.modifier = 'r';
+            param.parameter_length = 0;
 
-	    int a = 0, b = -1, balance = 1;
-	    unsigned int items;
-	    size_t pos;
-	    std::string cmd;
+            int a = 0, b = -1, balance = 1;
+            unsigned int items;
+            size_t pos;
+            std::string cmd;
 
-	    // Parse one command from whos_line_format
-	    cmd = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
-	    pos = cmd.find (';');
-	    if (pos != std::string::npos)
-	      cmd = cmd.substr (0, pos+1);
-	    else
-	      error ("parameter without ; in whos_line_format");
+            // Parse one command from whos_line_format
+            cmd = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
+            pos = cmd.find (';');
+            if (pos != std::string::npos)
+              cmd = cmd.substr (0, pos+1);
+            else
+              error ("parameter without ; in whos_line_format");
 
-	    idx += cmd.length ();
+            idx += cmd.length ();
 
-	    // FIXME -- use iostream functions instead of sscanf!
+            // FIXME -- use iostream functions instead of sscanf!
 
-	    if (cmd.find_first_of ("crl") != 1)
-	      items = sscanf (cmd.c_str (), "%c%c:%d:%d:%d;",
-			      &garbage, &param.command, &a, &b, &balance);
-	    else
-	      items = sscanf (cmd.c_str (), "%c%c%c:%d:%d:%d;",
-			      &garbage, &param.modifier, &param.command,
-			      &a, &b, &balance) - 1;
+            if (cmd.find_first_of ("crl") != 1)
+              items = sscanf (cmd.c_str (), "%c%c:%d:%d:%d;",
+                              &garbage, &param.command, &a, &b, &balance);
+            else
+              items = sscanf (cmd.c_str (), "%c%c%c:%d:%d:%d;",
+                              &garbage, &param.modifier, &param.command,
+                              &a, &b, &balance) - 1;
 
-	    if (items < 2)
-	      {
-		error ("whos_line_format: parameter structure without command in whos_line_format");
-		error_encountered = true;
-	      }
+            if (items < 2)
+              {
+                error ("whos_line_format: parameter structure without command in whos_line_format");
+                error_encountered = true;
+              }
 
-	    // Insert data into parameter
-	    param.first_parameter_length = 0;
-	    pos = param_string.find (param.command);
-	    if (pos != std::string::npos)
-	      {
-		param.parameter_length = param_length(pos);
-		param.text = param_names(pos);
-		param.line.assign (param_names(pos).length (), '=');
+            // Insert data into parameter
+            param.first_parameter_length = 0;
+            pos = param_string.find (param.command);
+            if (pos != std::string::npos)
+              {
+                param.parameter_length = param_length(pos);
+                param.text = param_names(pos);
+                param.line.assign (param_names(pos).length (), '=');
 
-		param.parameter_length = (a > param.parameter_length
-					  ? a : param.parameter_length);
-		if (param.command == 's' && param.modifier == 'c' && b > 0)
-		  param.first_parameter_length = b;
-	      }
-	    else
-	      {
-		error ("whos_line_format: '%c' is not a command",
-		       param.command);
-		error_encountered = true;
-	      }
+                param.parameter_length = (a > param.parameter_length
+                                          ? a : param.parameter_length);
+                if (param.command == 's' && param.modifier == 'c' && b > 0)
+                  param.first_parameter_length = b;
+              }
+            else
+              {
+                error ("whos_line_format: '%c' is not a command",
+                       param.command);
+                error_encountered = true;
+              }
 
-	    if (param.command == 's')
-	      {
-		// Have to calculate space needed for printing
-		// matrix dimensions Space needed for Size column is
-		// hard to determine in prior, because it depends on
-		// dimensions to be shown. That is why it is
-		// recalculated for each Size-command int first,
-		// rest = 0, total;
-		int rest = 0;
-		int first = param.first_parameter_length;
-		int total = param.parameter_length;
+            if (param.command == 's')
+              {
+                // Have to calculate space needed for printing
+                // matrix dimensions Space needed for Size column is
+                // hard to determine in prior, because it depends on
+                // dimensions to be shown. That is why it is
+                // recalculated for each Size-command int first,
+                // rest = 0, total;
+                int rest = 0;
+                int first = param.first_parameter_length;
+                int total = param.parameter_length;
 
-		for (std::list<symbol_info>::const_iterator p = lst.begin ();
-		     p != lst.end (); p++)
-		  {
-		    octave_value val = p->varval;
-		    std::string dims_str = get_dims_str (val);
-		    int first1 = dims_str.find ('x');
-		    int total1 = dims_str.length ();
-		    int rest1 = total1 - first1;
-		    rest = (rest1 > rest ? rest1 : rest);
-		    first = (first1 > first ? first1 : first);
-		    total = (total1 > total ? total1 : total);
-		  }
+                for (std::list<symbol_info>::const_iterator p = lst.begin ();
+                     p != lst.end (); p++)
+                  {
+                    octave_value val = p->varval;
+                    std::string dims_str = get_dims_str (val);
+                    int first1 = dims_str.find ('x');
+                    int total1 = dims_str.length ();
+                    int rest1 = total1 - first1;
+                    rest = (rest1 > rest ? rest1 : rest);
+                    first = (first1 > first ? first1 : first);
+                    total = (total1 > total ? total1 : total);
+                  }
 
-		if (param.modifier == 'c')
-		  {
-		    if (first < balance)
-		      first += balance - first;
-		    if (rest + balance < param.parameter_length)
-		      rest += param.parameter_length - rest - balance;
+                if (param.modifier == 'c')
+                  {
+                    if (first < balance)
+                      first += balance - first;
+                    if (rest + balance < param.parameter_length)
+                      rest += param.parameter_length - rest - balance;
 
-		    param.parameter_length = first + rest;
-		    param.first_parameter_length = first;
-		    param.balance = balance;
-		  }
-		else
-		  {
-		    param.parameter_length = total;
-		    param.first_parameter_length = 0;
-		  }
-	      }
-	    else if (param.modifier == 'c')
-	      {
-		error ("whos_line_format: modifier 'c' not available for command '%c'",
-		       param.command);
-		error_encountered = true;
-	      }
+                    param.parameter_length = first + rest;
+                    param.first_parameter_length = first;
+                    param.balance = balance;
+                  }
+                else
+                  {
+                    param.parameter_length = total;
+                    param.first_parameter_length = 0;
+                  }
+              }
+            else if (param.modifier == 'c')
+              {
+                error ("whos_line_format: modifier 'c' not available for command '%c'",
+                       param.command);
+                error_encountered = true;
+              }
 
-	    // What happens if whos_line_format contains negative numbers
-	    // at param_length positions?
-	    param.balance = (b < 0 ? 0 : param.balance);
-	    param.first_parameter_length = (b < 0 ? 0 :
-					    param.first_parameter_length);
-	    param.parameter_length = (a < 0
-				      ? 0
-				      : (param.parameter_length
-					 < param_length(pos_s)
-					 ? param_length(pos_s)
-					 : param.parameter_length));
+            // What happens if whos_line_format contains negative numbers
+            // at param_length positions?
+            param.balance = (b < 0 ? 0 : param.balance);
+            param.first_parameter_length = (b < 0 ? 0 :
+                                            param.first_parameter_length);
+            param.parameter_length = (a < 0
+                                      ? 0
+                                      : (param.parameter_length
+                                         < param_length(pos_s)
+                                         ? param_length(pos_s)
+                                         : param.parameter_length));
 
-	    // Parameter will not be pushed into parameter list if ...
-	    if (! error_encountered)
-	      params.push_back (param);
-	  }
-	else
-	  {
-	    // Text string, to be printed as it is ...
-	    std::string text;
-	    size_t pos;
-	    text = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
-	    pos = text.find ('%');
-	    if (pos != std::string::npos)
-	      text = text.substr (0, pos);
+            // Parameter will not be pushed into parameter list if ...
+            if (! error_encountered)
+              params.push_back (param);
+          }
+        else
+          {
+            // Text string, to be printed as it is ...
+            std::string text;
+            size_t pos;
+            text = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
+            pos = text.find ('%');
+            if (pos != std::string::npos)
+              text = text.substr (0, pos);
 
-	    // Push parameter into list ...
-	    idx += text.length ();
-	    param.text=text;
-	    param.line.assign (text.length(), ' ');
-	    params.push_back (param);
-	  }
+            // Push parameter into list ...
+            idx += text.length ();
+            param.text=text;
+            param.line.assign (text.length(), ' ');
+            params.push_back (param);
+          }
       }
 
     return params;
   }
 
 private:
   std::list<symbol_info> lst;
 
 };
 
 static octave_value
 do_who (int argc, const string_vector& argv, bool return_list,
-	bool verbose = false, std::string msg = std::string ())
+        bool verbose = false, std::string msg = std::string ())
 {
   octave_value retval;
 
   std::string my_name = argv[0];
 
   bool global_only = false;
   bool have_regexp = false;
 
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-file")
-	{
-	  // FIXME. This is an inefficient manner to implement this as the 
-	  // variables are loaded in to a temporary context and then treated.
-	  // It would be better to refecat symbol_info_list to not store the
-	  // symbol records and then use it in load-save.cc (do_load) to
-	  // implement this option there so that the variables are never 
-	  // stored at all.
-	  if (i == argc - 1)
-	    error ("whos: -file argument must be followed by a file name");
-	  else
-	    {
-	      std::string nm = argv [i + 1];
+        {
+          // FIXME. This is an inefficient manner to implement this as the 
+          // variables are loaded in to a temporary context and then treated.
+          // It would be better to refecat symbol_info_list to not store the
+          // symbol records and then use it in load-save.cc (do_load) to
+          // implement this option there so that the variables are never 
+          // stored at all.
+          if (i == argc - 1)
+            error ("whos: -file argument must be followed by a file name");
+          else
+            {
+              std::string nm = argv [i + 1];
 
-	      unwind_protect frame;
+              unwind_protect frame;
 
-	      // Set up temporary scope.
+              // Set up temporary scope.
 
-	      symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
-	      frame.add_fcn (symbol_table::erase_scope, tmp_scope);
+              symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
+              frame.add_fcn (symbol_table::erase_scope, tmp_scope);
 
-	      symbol_table::set_scope (tmp_scope);
+              symbol_table::set_scope (tmp_scope);
 
-	      octave_call_stack::push (tmp_scope, 0);
-	      frame.add_fcn (octave_call_stack::pop);
+              octave_call_stack::push (tmp_scope, 0);
+              frame.add_fcn (octave_call_stack::pop);
 
-	      frame.add_fcn (symbol_table::clear_variables);
+              frame.add_fcn (symbol_table::clear_variables);
 
-	      feval ("load", octave_value (nm), 0);
+              feval ("load", octave_value (nm), 0);
 
-	      if (! error_state)
-		{
-		  std::string newmsg = std::string ("Variables in the file ") + 
-		    nm + ":\n\n";
+              if (! error_state)
+                {
+                  std::string newmsg = std::string ("Variables in the file ") + 
+                    nm + ":\n\n";
 
-		  retval =  do_who (i, argv, return_list, verbose, newmsg);
-		}
-	    }
+                  retval =  do_who (i, argv, return_list, verbose, newmsg);
+                }
+            }
 
-	  return retval;
-	}
+          return retval;
+        }
       else if (argv[i] == "-regexp")
-	have_regexp = true;
+        have_regexp = true;
       else if (argv[i] == "global")
-	global_only = true;
+        global_only = true;
       else if (argv[i][0] == '-')
-	warning ("%s: unrecognized option `%s'", my_name.c_str (),
-		 argv[i].c_str ());
+        warning ("%s: unrecognized option `%s'", my_name.c_str (),
+                 argv[i].c_str ());
       else
-	break;
+        break;
     }
 
   int npats = argc - i;
   string_vector pats;
   if (npats > 0)
     {
       pats.resize (npats);
       for (int j = 0; j < npats; j++)
-	pats[j] = argv[i+j];
+        pats[j] = argv[i+j];
     }
   else
     {
       pats.resize (++npats);
       pats[0] = "*";
     }
     
   symbol_info_list symbol_stats;
   std::list<std::string> symbol_names;
 
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
-	{
-	  std::list<symbol_table::symbol_record> tmp = global_only
-	    ? symbol_table::regexp_global_variables (pat)
-	    : symbol_table::regexp_variables (pat);
+        {
+          std::list<symbol_table::symbol_record> tmp = global_only
+            ? symbol_table::regexp_global_variables (pat)
+            : symbol_table::regexp_variables (pat);
 
-	  for (std::list<symbol_table::symbol_record>::const_iterator p = tmp.begin ();
-	       p != tmp.end (); p++)
-	    {
-	      if (p->is_variable ())
-		{
-		  if (verbose)
-		    symbol_stats.append (*p);
-		  else
-		    symbol_names.push_back (p->name ());
-		}
-	    }
-	}
+          for (std::list<symbol_table::symbol_record>::const_iterator p = tmp.begin ();
+               p != tmp.end (); p++)
+            {
+              if (p->is_variable ())
+                {
+                  if (verbose)
+                    symbol_stats.append (*p);
+                  else
+                    symbol_names.push_back (p->name ());
+                }
+            }
+        }
       else
-	{
-	  size_t pos = pat.find_first_of (".({");
+        {
+          size_t pos = pat.find_first_of (".({");
 
-	  if (pos != std::string::npos && pos > 0)
-	    {
-	      if (verbose)
-		{
-		  // NOTE: we can only display information for
-		  // expressions based on global values if the variable is
-		  // global in the current scope because we currently have
-		  // no way of looking up the base value in the global
-		  // scope and then evaluating the arguments in the
-		  // current scope.
+          if (pos != std::string::npos && pos > 0)
+            {
+              if (verbose)
+                {
+                  // NOTE: we can only display information for
+                  // expressions based on global values if the variable is
+                  // global in the current scope because we currently have
+                  // no way of looking up the base value in the global
+                  // scope and then evaluating the arguments in the
+                  // current scope.
 
-		  std::string base_name = pat.substr (0, pos);
+                  std::string base_name = pat.substr (0, pos);
 
-		  if (symbol_table::is_variable (base_name))
-		    {
-		      symbol_table::symbol_record sr
-			= symbol_table::find_symbol (base_name);
+                  if (symbol_table::is_variable (base_name))
+                    {
+                      symbol_table::symbol_record sr
+                        = symbol_table::find_symbol (base_name);
 
-		      if (! global_only || sr.is_global ())
-			{
-			  int parse_status;
+                      if (! global_only || sr.is_global ())
+                        {
+                          int parse_status;
 
-			  octave_value expr_val
-			    = eval_string (pat, true, parse_status);
+                          octave_value expr_val
+                            = eval_string (pat, true, parse_status);
 
-			  if (! error_state)
-			    symbol_stats.append (sr, pat, expr_val);
-			  else
-			    return retval;
-			}
-		    }
-		}
-	    }
-	  else
-	    {
-	      std::list<symbol_table::symbol_record> tmp = global_only
-		? symbol_table::glob_global_variables (pat)
-		: symbol_table::glob_variables (pat);
+                          if (! error_state)
+                            symbol_stats.append (sr, pat, expr_val);
+                          else
+                            return retval;
+                        }
+                    }
+                }
+            }
+          else
+            {
+              std::list<symbol_table::symbol_record> tmp = global_only
+                ? symbol_table::glob_global_variables (pat)
+                : symbol_table::glob_variables (pat);
 
-	      for (std::list<symbol_table::symbol_record>::const_iterator p = tmp.begin ();
-		   p != tmp.end (); p++)
-		{
+              for (std::list<symbol_table::symbol_record>::const_iterator p = tmp.begin ();
+                   p != tmp.end (); p++)
+                {
                   if (p->is_variable ())
                     {
                       if (verbose)
                         symbol_stats.append (*p);
                       else
                         symbol_names.push_back (p->name ());
                     }
-		}
-	    }
-	}
+                }
+            }
+        }
     }
 
   if (return_list)
     {
       if (verbose)
-	{
-	  std::string caller_function_name;
-	  octave_function *caller = octave_call_stack::caller ();
-	  if (caller)
-	    caller_function_name = caller->name ();
+        {
+          std::string caller_function_name;
+          octave_function *caller = octave_call_stack::caller ();
+          if (caller)
+            caller_function_name = caller->name ();
 
-	  retval = symbol_stats.map_value (caller_function_name, 1);
-	}
+          retval = symbol_stats.map_value (caller_function_name, 1);
+        }
       else
-	retval = Cell (string_vector (symbol_names));
+        retval = Cell (string_vector (symbol_names));
     }
   else if (! (symbol_stats.empty () && symbol_names.empty ()))
     {
       if (msg.length () == 0)
-	if (global_only)
-	  octave_stdout << "Global variables:\n\n";
-	else
-	  octave_stdout << "Variables in the current scope:\n\n";
+        if (global_only)
+          octave_stdout << "Global variables:\n\n";
+        else
+          octave_stdout << "Variables in the current scope:\n\n";
       else
-	octave_stdout << msg;
+        octave_stdout << msg;
 
       if (verbose)
-	symbol_stats.display (octave_stdout);
+        symbol_stats.display (octave_stdout);
       else
-	{
-	  string_vector names (symbol_names);
+        {
+          string_vector names (symbol_names);
 
-	  names.list_in_columns (octave_stdout);
-	}
+          names.list_in_columns (octave_stdout);
+        }
 
       octave_stdout << "\n";
     }
 
   return retval;
 }
 
 DEFUN (who, args, nargout,
@@ -1649,17 +1649,17 @@ matching the given patterns.\n\
 
   if (nargout < 2)
     {
       int argc = args.length () + 1;
 
       string_vector argv = args.make_argv ("who");
 
       if (! error_state)
-	retval = do_who (argc, argv, nargout == 1);
+        retval = do_who (argc, argv, nargout == 1);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (whos, args, nargout,
@@ -1710,17 +1710,17 @@ complex, nesting, persistent.\n\
 
   if (nargout < 2)
     {
       int argc = args.length () + 1;
 
       string_vector argv = args.make_argv ("whos");
 
       if (! error_state)
-	retval = do_who (argc, argv, nargout == 1, true);
+        retval = do_who (argc, argv, nargout == 1, true);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // Defining variables.
@@ -1728,29 +1728,29 @@ complex, nesting, persistent.\n\
 void
 bind_ans (const octave_value& val, bool print)
 {
   static std::string ans = "ans";
 
   if (val.is_defined ())
     {
       if (val.is_cs_list ())
-	{
-	  octave_value_list lst = val.list_value ();
+        {
+          octave_value_list lst = val.list_value ();
 
-	  for (octave_idx_type i = 0; i < lst.length (); i++)
-	    bind_ans (lst(i), print);
-	}
+          for (octave_idx_type i = 0; i < lst.length (); i++)
+            bind_ans (lst(i), print);
+        }
       else
-	{
-	  symbol_table::varref (ans) = val;
+        {
+          symbol_table::varref (ans) = val;
 
-	  if (print)
-	    val.print_with_name (octave_stdout, ans);
-	}
+          if (print)
+            val.print_with_name (octave_stdout, ans);
+        }
     }
 }
 
 void
 bind_internal_variable (const std::string& fname, const octave_value& val)
 {
   octave_value_list args;
 
@@ -1775,33 +1775,33 @@ munlock (const std::string& nm)
 {
   octave_value val = symbol_table::find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
-	fcn->unlock ();
+        fcn->unlock ();
     }
 }
 
 bool
 mislocked (const std::string& nm)
 {
   bool retval = false;
 
   octave_value val = symbol_table::find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
-	retval = fcn->islocked ();
+        retval = fcn->islocked ();
     }
 
   return retval;
 }
 
 DEFUN (mlock, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mlock ()\n\
@@ -1811,19 +1811,19 @@ Lock the current function into memory so
 {
   octave_value_list retval;
 
   if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
-	fcn->lock ();
+        fcn->lock ();
       else
-	error ("mlock: invalid use outside a function");
+        error ("mlock: invalid use outside a function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (munlock, args, ,
@@ -1838,17 +1838,17 @@ then unlock the current function.\n\
 
   if (args.length() == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         munlock (name);
       else
-	error ("munlock: expecting argument to be a function name");
+        error ("munlock: expecting argument to be a function name");
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
         fcn->unlock ();
       else
@@ -1873,17 +1873,17 @@ then return true if the current function
 
   if (args.length() == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         retval = mislocked (name);
       else
-	error ("mislocked: expecting argument to be a function name");
+        error ("mislocked: expecting argument to be a function name");
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
         retval = fcn->islocked ();
       else
@@ -1894,222 +1894,222 @@ then return true if the current function
 
   return retval;
 }
 
 // Deleting names from the symbol tables.
 
 static inline bool
 name_matches_any_pattern (const std::string& nm, const string_vector& argv, 
-			  int argc, int idx, bool have_regexp = false)
+                          int argc, int idx, bool have_regexp = false)
 {
   bool retval = false;
 
   for (int k = idx; k < argc; k++)
     {
       std::string patstr = argv[k];
       if (! patstr.empty ())
-	{
-	  if (have_regexp)
-	    {
-	      regex_match pattern (patstr);
+        {
+          if (have_regexp)
+            {
+              regex_match pattern (patstr);
 
-	      if (pattern.match (nm))
-		{
-		  retval = true;
-		  break;
-		}
-	    }
-	  else
-	    {
-	      glob_match pattern (patstr);
+              if (pattern.match (nm))
+                {
+                  retval = true;
+                  break;
+                }
+            }
+          else
+            {
+              glob_match pattern (patstr);
 
-	      if (pattern.match (nm))
-		{
-		  retval = true;
-		  break;
-		}
-	    }
-	}
+              if (pattern.match (nm))
+                {
+                  retval = true;
+                  break;
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 static inline void
 maybe_warn_exclusive (bool exclusive)
 {
   if (exclusive)
     warning ("clear: ignoring --exclusive option");
 }
 
 static void
 do_clear_functions (const string_vector& argv, int argc, int idx,
-		    bool exclusive = false)
+                    bool exclusive = false)
 {
   if (idx == argc)
     symbol_table::clear_functions ();
   else
     {
       if (exclusive)
-	{
-	  string_vector fcns = symbol_table::user_function_names ();
+        {
+          string_vector fcns = symbol_table::user_function_names ();
 
-	  int fcount = fcns.length ();
+          int fcount = fcns.length ();
 
-	  for (int i = 0; i < fcount; i++)
-	    {
-	      std::string nm = fcns[i];
+          for (int i = 0; i < fcount; i++)
+            {
+              std::string nm = fcns[i];
 
-	      if (! name_matches_any_pattern (nm, argv, argc, idx))
-		symbol_table::clear_function (nm);
-	    }
-	}
+              if (! name_matches_any_pattern (nm, argv, argc, idx))
+                symbol_table::clear_function (nm);
+            }
+        }
       else
-	{
-	  while (idx < argc)
-	    symbol_table::clear_function_pattern (argv[idx++]);
-	}
+        {
+          while (idx < argc)
+            symbol_table::clear_function_pattern (argv[idx++]);
+        }
     }
 }
 
 static void
 do_clear_globals (const string_vector& argv, int argc, int idx,
-		  bool exclusive = false)
+                  bool exclusive = false)
 {
   if (idx == argc)
     {
       string_vector gvars = symbol_table::global_variable_names ();
 
       int gcount = gvars.length ();
 
       for (int i = 0; i < gcount; i++)
-	symbol_table::clear_global (gvars[i]);
+        symbol_table::clear_global (gvars[i]);
     }
   else
     {
       if (exclusive)
-	{
-	  string_vector gvars = symbol_table::global_variable_names ();
+        {
+          string_vector gvars = symbol_table::global_variable_names ();
 
-	  int gcount = gvars.length ();
+          int gcount = gvars.length ();
 
-	  for (int i = 0; i < gcount; i++)
-	    {
-	      std::string nm = gvars[i];
+          for (int i = 0; i < gcount; i++)
+            {
+              std::string nm = gvars[i];
 
-	      if (! name_matches_any_pattern (nm, argv, argc, idx))
-		symbol_table::clear_global (nm);
-	    }
-	}
+              if (! name_matches_any_pattern (nm, argv, argc, idx))
+                symbol_table::clear_global (nm);
+            }
+        }
       else
-	{
-	  while (idx < argc)
-	    symbol_table::clear_global_pattern (argv[idx++]);
-	}
+        {
+          while (idx < argc)
+            symbol_table::clear_global_pattern (argv[idx++]);
+        }
     }
 }
 
 static void
 do_clear_variables (const string_vector& argv, int argc, int idx,
-		    bool exclusive = false, bool have_regexp = false)
+                    bool exclusive = false, bool have_regexp = false)
 {
   if (idx == argc)
     symbol_table::clear_variables ();
   else
     {
       if (exclusive)
-	{
-	  string_vector lvars = symbol_table::variable_names ();
+        {
+          string_vector lvars = symbol_table::variable_names ();
 
-	  int lcount = lvars.length ();
+          int lcount = lvars.length ();
 
-	  for (int i = 0; i < lcount; i++)
-	    {
-	      std::string nm = lvars[i];
+          for (int i = 0; i < lcount; i++)
+            {
+              std::string nm = lvars[i];
 
-	      if (! name_matches_any_pattern (nm, argv, argc, idx, have_regexp))
-		symbol_table::clear_variable (nm);
-	    }
-	}
+              if (! name_matches_any_pattern (nm, argv, argc, idx, have_regexp))
+                symbol_table::clear_variable (nm);
+            }
+        }
       else
-	{
-	  if (have_regexp)
-	    while (idx < argc)
-	      symbol_table::clear_variable_regexp (argv[idx++]);
-	  else
-	    while (idx < argc)
-	      symbol_table::clear_variable_pattern (argv[idx++]);
-	}
+        {
+          if (have_regexp)
+            while (idx < argc)
+              symbol_table::clear_variable_regexp (argv[idx++]);
+          else
+            while (idx < argc)
+              symbol_table::clear_variable_pattern (argv[idx++]);
+        }
     }
 }
 
 static void
 do_clear_symbols (const string_vector& argv, int argc, int idx,
-		  bool exclusive = false)
+                  bool exclusive = false)
 {
   if (idx == argc)
     symbol_table::clear_variables ();
   else
     {
       if (exclusive)
-	{
-	  // FIXME -- is this really what we want, or do we
-	  // somehow want to only clear the functions that are not
-	  // shadowed by local variables?  It seems that would be a
-	  // bit harder to do.
+        {
+          // FIXME -- is this really what we want, or do we
+          // somehow want to only clear the functions that are not
+          // shadowed by local variables?  It seems that would be a
+          // bit harder to do.
 
-	  do_clear_variables (argv, argc, idx, exclusive);
-	  do_clear_functions (argv, argc, idx, exclusive);
-	}
+          do_clear_variables (argv, argc, idx, exclusive);
+          do_clear_functions (argv, argc, idx, exclusive);
+        }
       else
-	{
-	  while (idx < argc)
-	    symbol_table::clear_symbol_pattern (argv[idx++]);
-	}
+        {
+          while (idx < argc)
+            symbol_table::clear_symbol_pattern (argv[idx++]);
+        }
     }
 }
 
 static void
 do_matlab_compatible_clear (const string_vector& argv, int argc, int idx)
 {
   // This is supposed to be mostly Matlab compatible.
 
   for (; idx < argc; idx++)
     {
       if (argv[idx] == "all"
-	  && ! symbol_table::is_local_variable ("all"))
-	{
-	  symbol_table::clear_all ();
-	}
+          && ! symbol_table::is_local_variable ("all"))
+        {
+          symbol_table::clear_all ();
+        }
       else if (argv[idx] == "functions"
-	       && ! symbol_table::is_local_variable ("functions"))
-	{
-	  do_clear_functions (argv, argc, ++idx);
-	}
+               && ! symbol_table::is_local_variable ("functions"))
+        {
+          do_clear_functions (argv, argc, ++idx);
+        }
       else if (argv[idx] == "global"
-	       && ! symbol_table::is_local_variable ("global"))
-	{
-	  do_clear_globals (argv, argc, ++idx);
-	}
+               && ! symbol_table::is_local_variable ("global"))
+        {
+          do_clear_globals (argv, argc, ++idx);
+        }
       else if (argv[idx] == "variables"
-	       && ! symbol_table::is_local_variable ("variables"))
-	{
-	  symbol_table::clear_variables ();
-	}
+               && ! symbol_table::is_local_variable ("variables"))
+        {
+          symbol_table::clear_variables ();
+        }
       else if (argv[idx] == "classes"
-	       && ! symbol_table::is_local_variable ("classes"))
-	{
-	  symbol_table::clear_objects ();
-	  octave_class::clear_exemplar_map ();
-	}
+               && ! symbol_table::is_local_variable ("classes"))
+        {
+          symbol_table::clear_objects ();
+          octave_class::clear_exemplar_map ();
+        }
       else
-	{
-	  symbol_table::clear_symbol_pattern (argv[idx]);
-	}
+        {
+          symbol_table::clear_symbol_pattern (argv[idx]);
+        }
     }
 }
 
 #define CLEAR_OPTION_ERROR(cond) \
   do \
     { \
       if (cond) \
         { \
@@ -2188,132 +2188,132 @@ without the dash as well.\n\
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("clear");
 
   if (! error_state)
     {
       if (argc == 1)
-	{
+        {
           do_clear_globals (argv, argc, 1);
           do_clear_variables (argv, argc, 1); 
-	}
+        }
       else
-	{
-	  int idx = 0;
+        {
+          int idx = 0;
 
-	  bool clear_all = false;
-	  bool clear_functions = false;
-	  bool clear_globals = false;
-	  bool clear_variables = false;
+          bool clear_all = false;
+          bool clear_functions = false;
+          bool clear_globals = false;
+          bool clear_variables = false;
           bool clear_objects = false;
-	  bool exclusive = false;
-	  bool have_regexp = false;
-	  bool have_dash_option = false;
+          bool exclusive = false;
+          bool have_regexp = false;
+          bool have_dash_option = false;
 
-	  while (++idx < argc)
-	    {
-	      if (argv[idx] == "-all" || argv[idx] == "-a")
-		{
-		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+          while (++idx < argc)
+            {
+              if (argv[idx] == "-all" || argv[idx] == "-a")
+                {
+                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  have_dash_option = true;
-		  clear_all = true;
-		}
-	      else if (argv[idx] == "-exclusive" || argv[idx] == "-x")
-		{
-		  have_dash_option = true;
-		  exclusive = true;
-		}
-	      else if (argv[idx] == "-functions" || argv[idx] == "-f")
-		{
-		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+                  have_dash_option = true;
+                  clear_all = true;
+                }
+              else if (argv[idx] == "-exclusive" || argv[idx] == "-x")
+                {
+                  have_dash_option = true;
+                  exclusive = true;
+                }
+              else if (argv[idx] == "-functions" || argv[idx] == "-f")
+                {
+                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  have_dash_option = true;
-		  clear_functions = true;
-		}
-	      else if (argv[idx] == "-global" || argv[idx] == "-g")
-		{
-		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+                  have_dash_option = true;
+                  clear_functions = true;
+                }
+              else if (argv[idx] == "-global" || argv[idx] == "-g")
+                {
+                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  have_dash_option = true;
-		  clear_globals = true;
-		}
-	      else if (argv[idx] == "-variables" || argv[idx] == "-v")
-		{
-		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+                  have_dash_option = true;
+                  clear_globals = true;
+                }
+              else if (argv[idx] == "-variables" || argv[idx] == "-v")
+                {
+                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  have_dash_option = true;
-		  clear_variables = true;
-		}
-	      else if (argv[idx] == "-classes" || argv[idx] == "-c")
-		{
-		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+                  have_dash_option = true;
+                  clear_variables = true;
+                }
+              else if (argv[idx] == "-classes" || argv[idx] == "-c")
+                {
+                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  have_dash_option = true;
-		  clear_objects = true;
-		}
-	      else if (argv[idx] == "-regexp" || argv[idx] == "-r")
-		{
-		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+                  have_dash_option = true;
+                  clear_objects = true;
+                }
+              else if (argv[idx] == "-regexp" || argv[idx] == "-r")
+                {
+                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  have_dash_option = true;
-		  have_regexp = true;
-		}
-	      else
-		break;
-	    }
+                  have_dash_option = true;
+                  have_regexp = true;
+                }
+              else
+                break;
+            }
 
-	  if (idx <= argc)
-	    {
-	      if (! have_dash_option)
-		{
-		  do_matlab_compatible_clear (argv, argc, idx);
-		}
-	      else
-		{
-		  if (clear_all)
-		    {
-		      maybe_warn_exclusive (exclusive);
+          if (idx <= argc)
+            {
+              if (! have_dash_option)
+                {
+                  do_matlab_compatible_clear (argv, argc, idx);
+                }
+              else
+                {
+                  if (clear_all)
+                    {
+                      maybe_warn_exclusive (exclusive);
 
-		      if (++idx < argc)
-			warning
-			  ("clear: ignoring extra arguments after -all");
+                      if (++idx < argc)
+                        warning
+                          ("clear: ignoring extra arguments after -all");
 
-		      symbol_table::clear_all ();
-		    }
-		  else if (have_regexp)
-		    {
-		      do_clear_variables (argv, argc, idx, exclusive, true);
-		    }
-		  else if (clear_functions)
-		    {
-		      do_clear_functions (argv, argc, idx, exclusive);
-		    }
-		  else if (clear_globals)
-		    {
-		      do_clear_globals (argv, argc, idx, exclusive);
-		    }
-		  else if (clear_variables)
-		    {
-		      do_clear_variables (argv, argc, idx, exclusive);
-		    }
-		  else if (clear_objects)
-		    {
-		      symbol_table::clear_objects ();
-		      octave_class::clear_exemplar_map ();
-		    }
-		  else
-		    {
-		      do_clear_symbols (argv, argc, idx, exclusive);
-		    }
-		}
-	    }
-	}
+                      symbol_table::clear_all ();
+                    }
+                  else if (have_regexp)
+                    {
+                      do_clear_variables (argv, argc, idx, exclusive, true);
+                    }
+                  else if (clear_functions)
+                    {
+                      do_clear_functions (argv, argc, idx, exclusive);
+                    }
+                  else if (clear_globals)
+                    {
+                      do_clear_globals (argv, argc, idx, exclusive);
+                    }
+                  else if (clear_variables)
+                    {
+                      do_clear_variables (argv, argc, idx, exclusive);
+                    }
+                  else if (clear_objects)
+                    {
+                      symbol_table::clear_objects ();
+                      octave_class::clear_exemplar_map ();
+                    }
+                  else
+                    {
+                      do_clear_symbols (argv, argc, idx, exclusive);
+                    }
+                }
+            }
+        }
     }
 
   return retval;
 }
 
 DEFUN (whos_line_format, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} whos_line_format ()\n\
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -208,72 +208,72 @@ x_el_div (double a, const Matrix& b)
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const ComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const Matrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const ComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 // Funny element by element division operations.
 //
 //          op2 \ op1:   s   cs
@@ -506,72 +506,72 @@ x_el_div (float a, const FloatMatrix& b)
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 x_el_div (float a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 x_el_div (const FloatComplex a, const FloatMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 x_el_div (const FloatComplex a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.columns ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = a / b (i, j);
+        octave_quit ();
+        result (i, j) = a / b (i, j);
       }
 
   return result;
 }
 
 // Funny element by element division operations.
 //
 //          op2 \ op1:   s   cs
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -52,18 +52,18 @@ along with Octave; see the file COPYING.
 #ifdef _OPENMP
 #include <omp.h>
 #endif
 
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
-	  && ((x >= 0 && x < INT_MAX)
-	      || (x <= 0 && x > INT_MIN)));
+          && ((x >= 0 && x < INT_MAX)
+              || (x <= 0 && x > INT_MIN)));
 }
 
 // Safer pow functions.
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
 //   scalar   |     | 1 | 5 |  7 | 11 |
 //                  +---+---+----+----+
@@ -103,34 +103,34 @@ xpow (double a, const Matrix& b)
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
-	{
-	  ComplexColumnVector lambda (b_eig.eigenvalues ());
-	  ComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      Complex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  ComplexDiagMatrix D (lambda);
-
-	  retval = ComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          ComplexColumnVector lambda (b_eig.eigenvalues ());
+          ComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              Complex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          ComplexDiagMatrix D (lambda);
+
+          retval = ComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
 xpow (double a, const Complex& b)
@@ -150,34 +150,34 @@ xpow (double a, const ComplexMatrix& b)
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
-	{
-	  ComplexColumnVector lambda (b_eig.eigenvalues ());
-	  ComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      Complex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  ComplexDiagMatrix D (lambda);
-
-	  retval = ComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          ComplexColumnVector lambda (b_eig.eigenvalues ());
+          ComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              Complex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          ComplexDiagMatrix D (lambda);
+
+          retval = ComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 5 -*-
 octave_value
 xpow (const Matrix& a, double b)
@@ -187,83 +187,83 @@ xpow (const Matrix& a, double b)
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
-	  int btmp = static_cast<int> (b);
-	  if (btmp == 0)
-	    {
-	      retval = DiagMatrix (nr, nr, 1.0);
-	    }
-	  else
-	    {
-	      // Too much copying?
-	      // FIXME -- we shouldn't do this if the exponent is
-	      // large...
-
-	      Matrix atmp;
-	      if (btmp < 0)
-		{
-		  btmp = -btmp;
-
-		  octave_idx_type info;
-		  double rcond = 0.0;
-		  MatrixType mattype (a);
-
-		  atmp = a.inverse (mattype, info, rcond, 1);
-
-		  if (info == -1)
-		    warning ("inverse: matrix singular to machine\
+        {
+          int btmp = static_cast<int> (b);
+          if (btmp == 0)
+            {
+              retval = DiagMatrix (nr, nr, 1.0);
+            }
+          else
+            {
+              // Too much copying?
+              // FIXME -- we shouldn't do this if the exponent is
+              // large...
+
+              Matrix atmp;
+              if (btmp < 0)
+                {
+                  btmp = -btmp;
+
+                  octave_idx_type info;
+                  double rcond = 0.0;
+                  MatrixType mattype (a);
+
+                  atmp = a.inverse (mattype, info, rcond, 1);
+
+                  if (info == -1)
+                    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
-		}
-	      else
-		atmp = a;
-
-	      Matrix result (atmp);
-
-	      btmp--;
-
-	      while (btmp > 0)
-		{
-		  if (btmp & 1)
-		    result = result * atmp;
-
-		  btmp >>= 1;
-
-		  if (btmp > 0)
-		    atmp = atmp * atmp;
-		}
-
-	      retval = result;
-	    }
-	}
+                }
+              else
+                atmp = a;
+
+              Matrix result (atmp);
+
+              btmp--;
+
+              while (btmp > 0)
+                {
+                  if (btmp & 1)
+                    result = result * atmp;
+
+                  btmp >>= 1;
+
+                  if (btmp > 0)
+                    atmp = atmp * atmp;
+                }
+
+              retval = result;
+            }
+        }
       else
-	{
-	  EIG a_eig (a);
-
-	  if (! error_state)
-	    {
-	      ComplexColumnVector lambda (a_eig.eigenvalues ());
-	      ComplexMatrix Q (a_eig.eigenvectors ());
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		lambda(i) = std::pow (lambda(i), b);
-
-	      ComplexDiagMatrix D (lambda);
-
-	      retval = ComplexMatrix (Q * D * Q.inverse ());
-	    }
-	  else
-	    error ("xpow: matrix diagonalization failed");
-	}
+        {
+          EIG a_eig (a);
+
+          if (! error_state)
+            {
+              ComplexColumnVector lambda (a_eig.eigenvalues ());
+              ComplexMatrix Q (a_eig.eigenvectors ());
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                lambda(i) = std::pow (lambda(i), b);
+
+              ComplexDiagMatrix D (lambda);
+
+              retval = ComplexMatrix (Q * D * Q.inverse ());
+            }
+          else
+            error ("xpow: matrix diagonalization failed");
+        }
     }
 
   return retval;
 }
 
 // -*- 5d -*-
 octave_value
 xpow (const DiagMatrix& a, double b)
@@ -273,29 +273,29 @@ xpow (const DiagMatrix& a, double b)
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
+        {
           DiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
             r(i, i) = std::pow (a(i, i), b);
           retval = r;
         }
       else
-	{
+        {
           ComplexDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
             r(i, i) = std::pow (static_cast<Complex> (a(i, i)), b);
           retval = r;
-	}
+        }
     }
 
   return retval;
 }
 
 // -*- 5p -*-
 octave_value
 xpow (const PermMatrix& a, double b)
@@ -319,29 +319,29 @@ xpow (const Matrix& a, const Complex& b)
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       EIG a_eig (a);
 
       if (! error_state)
-	{
-	  ComplexColumnVector lambda (a_eig.eigenvalues ());
-	  ComplexMatrix Q (a_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    lambda(i) = std::pow (lambda(i), b);
-
-	  ComplexDiagMatrix D (lambda);
-
-	  retval = ComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          ComplexColumnVector lambda (a_eig.eigenvalues ());
+          ComplexMatrix Q (a_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            lambda(i) = std::pow (lambda(i), b);
+
+          ComplexDiagMatrix D (lambda);
+
+          retval = ComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 7 -*-
 octave_value
 xpow (const Complex& a, double b)
@@ -367,34 +367,34 @@ xpow (const Complex& a, const Matrix& b)
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
-	{
-	  ComplexColumnVector lambda (b_eig.eigenvalues ());
-	  ComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      Complex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  ComplexDiagMatrix D (lambda);
-
-	  retval = ComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          ComplexColumnVector lambda (b_eig.eigenvalues ());
+          ComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              Complex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          ComplexDiagMatrix D (lambda);
+
+          retval = ComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 xpow (const Complex& a, const Complex& b)
@@ -415,34 +415,34 @@ xpow (const Complex& a, const ComplexMat
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       EIG b_eig (b);
 
       if (! error_state)
-	{
-	  ComplexColumnVector lambda (b_eig.eigenvalues ());
-	  ComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      Complex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  ComplexDiagMatrix D (lambda);
-
-	  retval = ComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          ComplexColumnVector lambda (b_eig.eigenvalues ());
+          ComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              Complex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          ComplexDiagMatrix D (lambda);
+
+          retval = ComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 11 -*-
 octave_value
 xpow (const ComplexMatrix& a, double b)
@@ -452,83 +452,83 @@ xpow (const ComplexMatrix& a, double b)
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
-	  int btmp = static_cast<int> (b);
-	  if (btmp == 0)
-	    {
-	      retval = DiagMatrix (nr, nr, 1.0);
-	    }
-	  else
-	    {
-	      // Too much copying?
-	      // FIXME -- we shouldn't do this if the exponent is
-	      // large...
-
-	      ComplexMatrix atmp;
-	      if (btmp < 0)
-		{
-		  btmp = -btmp;
-
-		  octave_idx_type info;
-		  double rcond = 0.0;
-		  MatrixType mattype (a);
-
-		  atmp = a.inverse (mattype, info, rcond, 1);
-
-		  if (info == -1)
-		    warning ("inverse: matrix singular to machine\
+        {
+          int btmp = static_cast<int> (b);
+          if (btmp == 0)
+            {
+              retval = DiagMatrix (nr, nr, 1.0);
+            }
+          else
+            {
+              // Too much copying?
+              // FIXME -- we shouldn't do this if the exponent is
+              // large...
+
+              ComplexMatrix atmp;
+              if (btmp < 0)
+                {
+                  btmp = -btmp;
+
+                  octave_idx_type info;
+                  double rcond = 0.0;
+                  MatrixType mattype (a);
+
+                  atmp = a.inverse (mattype, info, rcond, 1);
+
+                  if (info == -1)
+                    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
-		}
-	      else
-		atmp = a;
-
-	      ComplexMatrix result (atmp);
-
-	      btmp--;
-
-	      while (btmp > 0)
-		{
-		  if (btmp & 1)
-		    result = result * atmp;
-
-		  btmp >>= 1;
-
-		  if (btmp > 0)
-		    atmp = atmp * atmp;
-		}
-
-	      retval = result;
-	    }
-	}
+                }
+              else
+                atmp = a;
+
+              ComplexMatrix result (atmp);
+
+              btmp--;
+
+              while (btmp > 0)
+                {
+                  if (btmp & 1)
+                    result = result * atmp;
+
+                  btmp >>= 1;
+
+                  if (btmp > 0)
+                    atmp = atmp * atmp;
+                }
+
+              retval = result;
+            }
+        }
       else
-	{
-	  EIG a_eig (a);
-
-	  if (! error_state)
-	    {
-	      ComplexColumnVector lambda (a_eig.eigenvalues ());
-	      ComplexMatrix Q (a_eig.eigenvectors ());
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		lambda(i) = std::pow (lambda(i), b);
-
-	      ComplexDiagMatrix D (lambda);
-
-	      retval = ComplexMatrix (Q * D * Q.inverse ());
-	    }
-	  else
-	    error ("xpow: matrix diagonalization failed");
-	}
+        {
+          EIG a_eig (a);
+
+          if (! error_state)
+            {
+              ComplexColumnVector lambda (a_eig.eigenvalues ());
+              ComplexMatrix Q (a_eig.eigenvectors ());
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                lambda(i) = std::pow (lambda(i), b);
+
+              ComplexDiagMatrix D (lambda);
+
+              retval = ComplexMatrix (Q * D * Q.inverse ());
+            }
+          else
+            error ("xpow: matrix diagonalization failed");
+        }
     }
 
   return retval;
 }
 
 // -*- 12 -*-
 octave_value
 xpow (const ComplexMatrix& a, const Complex& b)
@@ -540,29 +540,29 @@ xpow (const ComplexMatrix& a, const Comp
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       EIG a_eig (a);
 
       if (! error_state)
-	{
-	  ComplexColumnVector lambda (a_eig.eigenvalues ());
-	  ComplexMatrix Q (a_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    lambda(i) = std::pow (lambda(i), b);
-
-	  ComplexDiagMatrix D (lambda);
-
-	  retval = ComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          ComplexColumnVector lambda (a_eig.eigenvalues ());
+          ComplexMatrix Q (a_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            lambda(i) = std::pow (lambda(i), b);
+
+          ComplexDiagMatrix D (lambda);
+
+          retval = ComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 12d -*-
 octave_value
 xpow (const ComplexDiagMatrix& a, const Complex& b)
@@ -640,34 +640,34 @@ elem_xpow (double a, const Matrix& b)
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (atmp, b (i, j));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (atmp, b (i, j));
+          }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a, b (i, j));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a, b (i, j));
+          }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
@@ -678,18 +678,18 @@ elem_xpow (double a, const ComplexMatrix
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   Complex atmp (a);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (atmp, b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (atmp, b (i, j));
       }
 
   return result;
 }
 
 static inline bool 
 same_sign (double a, double b)
 {
@@ -743,37 +743,37 @@ elem_xpow (const Matrix& a, double b)
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (! xisint (b) && a.any_element_is_negative ())
     {
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit (); 
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit (); 
       
-	    Complex atmp (a (i, j));
-
-	    result (i, j) = std::pow (atmp, b);
-	  }
+            Complex atmp (a (i, j));
+
+            result (i, j) = std::pow (atmp, b);
+          }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), b);
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), b);
+          }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 4 -*-
@@ -793,53 +793,53 @@ elem_xpow (const Matrix& a, const Matrix
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	double atmp = a (i, j);
-	double btmp = b (i, j);
-	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
-	  {
-	    convert_to_complex = 1;
-	    goto done;
-	  }
+        octave_quit ();
+        double atmp = a (i, j);
+        double btmp = b (i, j);
+        if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
+          {
+            convert_to_complex = 1;
+            goto done;
+          }
       }
 
 done:
 
   if (convert_to_complex)
     {
       ComplexMatrix complex_result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    Complex atmp (a (i, j));
-	    Complex btmp (b (i, j));
-	    complex_result (i, j) = std::pow (atmp, btmp);
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            Complex atmp (a (i, j));
+            Complex btmp (b (i, j));
+            complex_result (i, j) = std::pow (atmp, btmp);
+          }
 
       retval = complex_result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), b (i, j));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), b (i, j));
+          }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -849,18 +849,18 @@ elem_xpow (const Matrix& a, const Comple
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (Complex (a (i, j)), b);
+        octave_quit ();
+        result (i, j) = std::pow (Complex (a (i, j)), b);
       }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const Matrix& a, const ComplexMatrix& b)
@@ -877,18 +877,18 @@ elem_xpow (const Matrix& a, const Comple
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
       }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const Matrix& b)
@@ -896,22 +896,22 @@ elem_xpow (const Complex& a, const Matri
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	double btmp = b (i, j);
-	if (xisint (btmp))
-	  result (i, j) = std::pow (a, static_cast<int> (btmp));
-	else
-	  result (i, j) = std::pow (a, btmp);
+        octave_quit ();
+        double btmp = b (i, j);
+        if (xisint (btmp))
+          result (i, j) = std::pow (a, static_cast<int> (btmp));
+        else
+          result (i, j) = std::pow (a, btmp);
       }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexMatrix& b)
@@ -919,18 +919,18 @@ elem_xpow (const Complex& a, const Compl
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (a, b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 octave_value
 elem_xpow (const Complex& a, const Range& r)
 {
@@ -978,30 +978,30 @@ elem_xpow (const ComplexMatrix& a, doubl
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), static_cast<int> (b));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), static_cast<int> (b));
+          }
     }
   else
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), b);
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), b);
+          }
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Matrix& b)
@@ -1018,22 +1018,22 @@ elem_xpow (const ComplexMatrix& a, const
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	double btmp = b (i, j);
-	if (xisint (btmp))
-	  result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
-	else
-	  result (i, j) = std::pow (a (i, j), btmp);
+        octave_quit ();
+        double btmp = b (i, j);
+        if (xisint (btmp))
+          result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
+        else
+          result (i, j) = std::pow (a (i, j), btmp);
       }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Complex& b)
@@ -1041,18 +1041,18 @@ elem_xpow (const ComplexMatrix& a, const
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (a (i, j), b);
+        octave_quit ();
+        result (i, j) = std::pow (a (i, j), b);
       }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
@@ -1069,18 +1069,18 @@ elem_xpow (const ComplexMatrix& a, const
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (a (i, j), b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 // Safer pow functions that work elementwise for N-d arrays.
 //
 //       op2 \ op1:   s   nd  cs   cnd
@@ -1118,31 +1118,31 @@ elem_xpow (double a, const NDArray& b)
 
   double d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexNDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
-	{
-	  octave_quit ();
-	  result(i) = std::pow (atmp, b(i));
-	}
+        {
+          octave_quit ();
+          result(i) = std::pow (atmp, b(i));
+        }
 
       retval = result;
     }
   else
     {
       NDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
-	{
-	  octave_quit ();
-	  result (i) = std::pow (a, b(i));
-	}
+        {
+          octave_quit ();
+          result (i) = std::pow (a, b(i));
+        }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
@@ -1250,46 +1250,46 @@ elem_xpow (const NDArray& a, const NDArr
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       octave_quit ();
       double atmp = a(i);
       double btmp = b(i);
       if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
-	{
-	  convert_to_complex = true;
-	  goto done;
-	}
+        {
+          convert_to_complex = true;
+          goto done;
+        }
     }
 
 done:
 
   if (convert_to_complex)
     {
       ComplexNDArray complex_result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  octave_quit ();
-	  Complex atmp (a(i));
-	  complex_result(i) = std::pow (atmp, b(i));
-	}
+        {
+          octave_quit ();
+          Complex atmp (a(i));
+          complex_result(i) = std::pow (atmp, b(i));
+        }
 
       retval = complex_result;
     }
   else
     {
       NDArray result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  octave_quit ();
-	  result(i) = std::pow (a(i), b(i));
-	}
+        {
+          octave_quit ();
+          result(i) = std::pow (a(i), b(i));
+        }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -1337,19 +1337,19 @@ elem_xpow (const Complex& a, const NDArr
 {
   ComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
       octave_quit ();
       double btmp = b(i);
       if (xisint (btmp))
-	result(i) = std::pow (a, static_cast<int> (btmp));
+        result(i) = std::pow (a, static_cast<int> (btmp));
       else
-	result(i) = std::pow (a, btmp);
+        result(i) = std::pow (a, btmp);
     }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexNDArray& b)
@@ -1385,20 +1385,20 @@ elem_xpow (const ComplexNDArray& a, doub
               octave_quit ();
               result(i) = std::pow (a(i), static_cast<int> (b));
             }
         }
     }
   else
     {
       for (octave_idx_type i = 0; i < a.length (); i++)
-	{
-	  octave_quit ();
-	  result(i) = std::pow (a(i), b);
-	}
+        {
+          octave_quit ();
+          result(i) = std::pow (a(i), b);
+        }
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, const NDArray& b)
@@ -1414,19 +1414,19 @@ elem_xpow (const ComplexNDArray& a, cons
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       double btmp = b(i);
       if (xisint (btmp))
-	result(i) = std::pow (a(i), static_cast<int> (btmp));
+        result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
-	result(i) = std::pow (a(i), btmp);
+        result(i) = std::pow (a(i), btmp);
     }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, const Complex& b)
@@ -1465,18 +1465,18 @@ elem_xpow (const ComplexNDArray& a, cons
 
   return result;
 }
 
 static inline int
 xisint (float x)
 {
   return (D_NINT (x) == x
-	  && ((x >= 0 && x < INT_MAX)
-	      || (x <= 0 && x > INT_MIN)));
+          && ((x >= 0 && x < INT_MAX)
+              || (x <= 0 && x > INT_MIN)));
 }
 
 // Safer pow functions.
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
 //   scalar   |     | 1 | 5 |  7 | 11 |
 //                  +---+---+----+----+
@@ -1516,34 +1516,34 @@ xpow (float a, const FloatMatrix& b)
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
-	{
-	  FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-	  FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      FloatComplex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  FloatComplexDiagMatrix D (lambda);
-
-	  retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+          FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              FloatComplex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          FloatComplexDiagMatrix D (lambda);
+
+          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
 xpow (float a, const FloatComplex& b)
@@ -1563,34 +1563,34 @@ xpow (float a, const FloatComplexMatrix&
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
-	{
-	  FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-	  FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      FloatComplex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  FloatComplexDiagMatrix D (lambda);
-
-	  retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+          FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              FloatComplex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          FloatComplexDiagMatrix D (lambda);
+
+          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 5 -*-
 octave_value
 xpow (const FloatMatrix& a, float b)
@@ -1600,83 +1600,83 @@ xpow (const FloatMatrix& a, float b)
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
-	  int btmp = static_cast<int> (b);
-	  if (btmp == 0)
-	    {
-	      retval = FloatDiagMatrix (nr, nr, 1.0);
-	    }
-	  else
-	    {
-	      // Too much copying?
-	      // FIXME -- we shouldn't do this if the exponent is
-	      // large...
-
-	      FloatMatrix atmp;
-	      if (btmp < 0)
-		{
-		  btmp = -btmp;
-
-		  octave_idx_type info;
-		  float rcond = 0.0;
-		  MatrixType mattype (a);
-
-		  atmp = a.inverse (mattype, info, rcond, 1);
-
-		  if (info == -1)
-		    warning ("inverse: matrix singular to machine\
+        {
+          int btmp = static_cast<int> (b);
+          if (btmp == 0)
+            {
+              retval = FloatDiagMatrix (nr, nr, 1.0);
+            }
+          else
+            {
+              // Too much copying?
+              // FIXME -- we shouldn't do this if the exponent is
+              // large...
+
+              FloatMatrix atmp;
+              if (btmp < 0)
+                {
+                  btmp = -btmp;
+
+                  octave_idx_type info;
+                  float rcond = 0.0;
+                  MatrixType mattype (a);
+
+                  atmp = a.inverse (mattype, info, rcond, 1);
+
+                  if (info == -1)
+                    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
-		}
-	      else
-		atmp = a;
-
-	      FloatMatrix result (atmp);
-
-	      btmp--;
-
-	      while (btmp > 0)
-		{
-		  if (btmp & 1)
-		    result = result * atmp;
-
-		  btmp >>= 1;
-
-		  if (btmp > 0)
-		    atmp = atmp * atmp;
-		}
-
-	      retval = result;
-	    }
-	}
+                }
+              else
+                atmp = a;
+
+              FloatMatrix result (atmp);
+
+              btmp--;
+
+              while (btmp > 0)
+                {
+                  if (btmp & 1)
+                    result = result * atmp;
+
+                  btmp >>= 1;
+
+                  if (btmp > 0)
+                    atmp = atmp * atmp;
+                }
+
+              retval = result;
+            }
+        }
       else
-	{
-	  FloatEIG a_eig (a);
-
-	  if (! error_state)
-	    {
-	      FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-	      FloatComplexMatrix Q (a_eig.eigenvectors ());
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		lambda(i) = std::pow (lambda(i), b);
-
-	      FloatComplexDiagMatrix D (lambda);
-
-	      retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	    }
-	  else
-	    error ("xpow: matrix diagonalization failed");
-	}
+        {
+          FloatEIG a_eig (a);
+
+          if (! error_state)
+            {
+              FloatComplexColumnVector lambda (a_eig.eigenvalues ());
+              FloatComplexMatrix Q (a_eig.eigenvectors ());
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                lambda(i) = std::pow (lambda(i), b);
+
+              FloatComplexDiagMatrix D (lambda);
+
+              retval = FloatComplexMatrix (Q * D * Q.inverse ());
+            }
+          else
+            error ("xpow: matrix diagonalization failed");
+        }
     }
 
   return retval;
 }
 
 // -*- 5d -*-
 octave_value
 xpow (const FloatDiagMatrix& a, float b)
@@ -1686,29 +1686,29 @@ xpow (const FloatDiagMatrix& a, float b)
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
+        {
           FloatDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
             r(i, i) = std::pow (a(i, i), b);
           retval = r;
         }
       else
-	{
+        {
           FloatComplexDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
             r(i, i) = std::pow (static_cast<FloatComplex> (a(i, i)), b);
           retval = r;
-	}
+        }
     }
 
   return retval;
 }
 
 // -*- 6 -*-
 octave_value
 xpow (const FloatMatrix& a, const FloatComplex& b)
@@ -1720,29 +1720,29 @@ xpow (const FloatMatrix& a, const FloatC
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       FloatEIG a_eig (a);
 
       if (! error_state)
-	{
-	  FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-	  FloatComplexMatrix Q (a_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    lambda(i) = std::pow (lambda(i), b);
-
-	  FloatComplexDiagMatrix D (lambda);
-
-	  retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          FloatComplexColumnVector lambda (a_eig.eigenvalues ());
+          FloatComplexMatrix Q (a_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            lambda(i) = std::pow (lambda(i), b);
+
+          FloatComplexDiagMatrix D (lambda);
+
+          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 7 -*-
 octave_value
 xpow (const FloatComplex& a, float b)
@@ -1768,34 +1768,34 @@ xpow (const FloatComplex& a, const Float
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
-	{
-	  FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-	  FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      FloatComplex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  FloatComplexDiagMatrix D (lambda);
-
-	  retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+          FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              FloatComplex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          FloatComplexDiagMatrix D (lambda);
+
+          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 xpow (const FloatComplex& a, const FloatComplex& b)
@@ -1816,34 +1816,34 @@ xpow (const FloatComplex& a, const Float
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be square");
   else
     {
       FloatEIG b_eig (b);
 
       if (! error_state)
-	{
-	  FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-	  FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      FloatComplex elt = lambda(i);
-	      if (std::imag (elt) == 0.0)
-		lambda(i) = std::pow (a, std::real (elt));
-	      else
-		lambda(i) = std::pow (a, elt);
-	    }
-	  FloatComplexDiagMatrix D (lambda);
-
-	  retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+          FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              FloatComplex elt = lambda(i);
+              if (std::imag (elt) == 0.0)
+                lambda(i) = std::pow (a, std::real (elt));
+              else
+                lambda(i) = std::pow (a, elt);
+            }
+          FloatComplexDiagMatrix D (lambda);
+
+          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 11 -*-
 octave_value
 xpow (const FloatComplexMatrix& a, float b)
@@ -1853,83 +1853,83 @@ xpow (const FloatComplexMatrix& a, float
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
-	{
-	  int btmp = static_cast<int> (b);
-	  if (btmp == 0)
-	    {
-	      retval = FloatDiagMatrix (nr, nr, 1.0);
-	    }
-	  else
-	    {
-	      // Too much copying?
-	      // FIXME -- we shouldn't do this if the exponent is
-	      // large...
-
-	      FloatComplexMatrix atmp;
-	      if (btmp < 0)
-		{
-		  btmp = -btmp;
-
-		  octave_idx_type info;
-		  float rcond = 0.0;
-		  MatrixType mattype (a);
-
-		  atmp = a.inverse (mattype, info, rcond, 1);
-
-		  if (info == -1)
-		    warning ("inverse: matrix singular to machine\
+        {
+          int btmp = static_cast<int> (b);
+          if (btmp == 0)
+            {
+              retval = FloatDiagMatrix (nr, nr, 1.0);
+            }
+          else
+            {
+              // Too much copying?
+              // FIXME -- we shouldn't do this if the exponent is
+              // large...
+
+              FloatComplexMatrix atmp;
+              if (btmp < 0)
+                {
+                  btmp = -btmp;
+
+                  octave_idx_type info;
+                  float rcond = 0.0;
+                  MatrixType mattype (a);
+
+                  atmp = a.inverse (mattype, info, rcond, 1);
+
+                  if (info == -1)
+                    warning ("inverse: matrix singular to machine\
  precision, rcond = %g", rcond);
-		}
-	      else
-		atmp = a;
-
-	      FloatComplexMatrix result (atmp);
-
-	      btmp--;
-
-	      while (btmp > 0)
-		{
-		  if (btmp & 1)
-		    result = result * atmp;
-
-		  btmp >>= 1;
-
-		  if (btmp > 0)
-		    atmp = atmp * atmp;
-		}
-
-	      retval = result;
-	    }
-	}
+                }
+              else
+                atmp = a;
+
+              FloatComplexMatrix result (atmp);
+
+              btmp--;
+
+              while (btmp > 0)
+                {
+                  if (btmp & 1)
+                    result = result * atmp;
+
+                  btmp >>= 1;
+
+                  if (btmp > 0)
+                    atmp = atmp * atmp;
+                }
+
+              retval = result;
+            }
+        }
       else
-	{
-	  FloatEIG a_eig (a);
-
-	  if (! error_state)
-	    {
-	      FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-	      FloatComplexMatrix Q (a_eig.eigenvectors ());
-
-	      for (octave_idx_type i = 0; i < nr; i++)
-		lambda(i) = std::pow (lambda(i), b);
-
-	      FloatComplexDiagMatrix D (lambda);
-
-	      retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	    }
-	  else
-	    error ("xpow: matrix diagonalization failed");
-	}
+        {
+          FloatEIG a_eig (a);
+
+          if (! error_state)
+            {
+              FloatComplexColumnVector lambda (a_eig.eigenvalues ());
+              FloatComplexMatrix Q (a_eig.eigenvectors ());
+
+              for (octave_idx_type i = 0; i < nr; i++)
+                lambda(i) = std::pow (lambda(i), b);
+
+              FloatComplexDiagMatrix D (lambda);
+
+              retval = FloatComplexMatrix (Q * D * Q.inverse ());
+            }
+          else
+            error ("xpow: matrix diagonalization failed");
+        }
     }
 
   return retval;
 }
 
 // -*- 12 -*-
 octave_value
 xpow (const FloatComplexMatrix& a, const FloatComplex& b)
@@ -1941,29 +1941,29 @@ xpow (const FloatComplexMatrix& a, const
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       FloatEIG a_eig (a);
 
       if (! error_state)
-	{
-	  FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-	  FloatComplexMatrix Q (a_eig.eigenvectors ());
-
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    lambda(i) = std::pow (lambda(i), b);
-
-	  FloatComplexDiagMatrix D (lambda);
-
-	  retval = FloatComplexMatrix (Q * D * Q.inverse ());
-	}
+        {
+          FloatComplexColumnVector lambda (a_eig.eigenvalues ());
+          FloatComplexMatrix Q (a_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            lambda(i) = std::pow (lambda(i), b);
+
+          FloatComplexDiagMatrix D (lambda);
+
+          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+        }
       else
-	error ("xpow: matrix diagonalization failed");
+        error ("xpow: matrix diagonalization failed");
     }
 
   return retval;
 }
 
 // -*- 12d -*-
 octave_value
 xpow (const FloatComplexDiagMatrix& a, const FloatComplex& b)
@@ -2040,34 +2040,34 @@ elem_xpow (float a, const FloatMatrix& b
   float d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       FloatComplex atmp (a);
       FloatComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (atmp, b (i, j));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (atmp, b (i, j));
+          }
 
       retval = result;
     }
   else
     {
       FloatMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a, b (i, j));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a, b (i, j));
+          }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
@@ -2078,18 +2078,18 @@ elem_xpow (float a, const FloatComplexMa
   octave_idx_type nc = b.cols ();
 
   FloatComplexMatrix result (nr, nc);
   FloatComplex atmp (a);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (atmp, b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (atmp, b (i, j));
       }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const FloatMatrix& a, float b)
@@ -2099,37 +2099,37 @@ elem_xpow (const FloatMatrix& a, float b
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (! xisint (b) && a.any_element_is_negative ())
     {
       FloatComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit (); 
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit (); 
       
-	    FloatComplex atmp (a (i, j));
-
-	    result (i, j) = std::pow (atmp, b);
-	  }
+            FloatComplex atmp (a (i, j));
+
+            result (i, j) = std::pow (atmp, b);
+          }
 
       retval = result;
     }
   else
     {
       FloatMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), b);
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), b);
+          }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 4 -*-
@@ -2149,53 +2149,53 @@ elem_xpow (const FloatMatrix& a, const F
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	float atmp = a (i, j);
-	float btmp = b (i, j);
-	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
-	  {
-	    convert_to_complex = 1;
-	    goto done;
-	  }
+        octave_quit ();
+        float atmp = a (i, j);
+        float btmp = b (i, j);
+        if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
+          {
+            convert_to_complex = 1;
+            goto done;
+          }
       }
 
 done:
 
   if (convert_to_complex)
     {
       FloatComplexMatrix complex_result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    FloatComplex atmp (a (i, j));
-	    FloatComplex btmp (b (i, j));
-	    complex_result (i, j) = std::pow (atmp, btmp);
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            FloatComplex atmp (a (i, j));
+            FloatComplex btmp (b (i, j));
+            complex_result (i, j) = std::pow (atmp, btmp);
+          }
 
       retval = complex_result;
     }
   else
     {
       FloatMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), b (i, j));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), b (i, j));
+          }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -2205,18 +2205,18 @@ elem_xpow (const FloatMatrix& a, const F
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (FloatComplex (a (i, j)), b);
+        octave_quit ();
+        result (i, j) = std::pow (FloatComplex (a (i, j)), b);
       }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const FloatMatrix& a, const FloatComplexMatrix& b)
@@ -2233,18 +2233,18 @@ elem_xpow (const FloatMatrix& a, const F
       return octave_value ();
     }
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (FloatComplex (a (i, j)), b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (FloatComplex (a (i, j)), b (i, j));
       }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const FloatComplex& a, const FloatMatrix& b)
@@ -2252,22 +2252,22 @@ elem_xpow (const FloatComplex& a, const 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	float btmp = b (i, j);
-	if (xisint (btmp))
-	  result (i, j) = std::pow (a, static_cast<int> (btmp));
-	else
-	  result (i, j) = std::pow (a, btmp);
+        octave_quit ();
+        float btmp = b (i, j);
+        if (xisint (btmp))
+          result (i, j) = std::pow (a, static_cast<int> (btmp));
+        else
+          result (i, j) = std::pow (a, btmp);
       }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const FloatComplex& a, const FloatComplexMatrix& b)
@@ -2275,18 +2275,18 @@ elem_xpow (const FloatComplex& a, const 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (a, b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const FloatComplexMatrix& a, float b)
@@ -2294,30 +2294,30 @@ elem_xpow (const FloatComplexMatrix& a, 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), static_cast<int> (b));
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), static_cast<int> (b));
+          }
     }
   else
     {
       for (octave_idx_type j = 0; j < nc; j++)
-	for (octave_idx_type i = 0; i < nr; i++)
-	  {
-	    octave_quit ();
-	    result (i, j) = std::pow (a (i, j), b);
-	  }
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            octave_quit ();
+            result (i, j) = std::pow (a (i, j), b);
+          }
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const FloatComplexMatrix& a, const FloatMatrix& b)
@@ -2334,22 +2334,22 @@ elem_xpow (const FloatComplexMatrix& a, 
       return octave_value ();
     }
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	float btmp = b (i, j);
-	if (xisint (btmp))
-	  result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
-	else
-	  result (i, j) = std::pow (a (i, j), btmp);
+        octave_quit ();
+        float btmp = b (i, j);
+        if (xisint (btmp))
+          result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
+        else
+          result (i, j) = std::pow (a (i, j), btmp);
       }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const FloatComplexMatrix& a, const FloatComplex& b)
@@ -2357,18 +2357,18 @@ elem_xpow (const FloatComplexMatrix& a, 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (a (i, j), b);
+        octave_quit ();
+        result (i, j) = std::pow (a (i, j), b);
       }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
@@ -2385,18 +2385,18 @@ elem_xpow (const FloatComplexMatrix& a, 
       return octave_value ();
     }
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
-	octave_quit ();
-	result (i, j) = std::pow (a (i, j), b (i, j));
+        octave_quit ();
+        result (i, j) = std::pow (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 // Safer pow functions that work elementwise for N-d arrays.
 //
 //       op2 \ op1:   s   nd  cs   cnd
@@ -2434,31 +2434,31 @@ elem_xpow (float a, const FloatNDArray& 
 
   float d1, d2;
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       FloatComplex atmp (a);
       FloatComplexNDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
-	{
-	  octave_quit ();
-	  result(i) = std::pow (atmp, b(i));
-	}
+        {
+          octave_quit ();
+          result(i) = std::pow (atmp, b(i));
+        }
 
       retval = result;
     }
   else
     {
       FloatNDArray result (b.dims ());
       for (octave_idx_type i = 0; i < b.length (); i++)
-	{
-	  octave_quit ();
-	  result (i) = std::pow (a, b(i));
-	}
+        {
+          octave_quit ();
+          result (i) = std::pow (a, b(i));
+        }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 2 -*-
@@ -2566,46 +2566,46 @@ elem_xpow (const FloatNDArray& a, const 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       octave_quit ();
       float atmp = a(i);
       float btmp = b(i);
       if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
-	{
-	  convert_to_complex = true;
-	  goto done;
-	}
+        {
+          convert_to_complex = true;
+          goto done;
+        }
     }
 
 done:
 
   if (convert_to_complex)
     {
       FloatComplexNDArray complex_result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  octave_quit ();
-	  FloatComplex atmp (a(i));
-	  complex_result(i) = std::pow (atmp, b(i));
-	}
+        {
+          octave_quit ();
+          FloatComplex atmp (a(i));
+          complex_result(i) = std::pow (atmp, b(i));
+        }
 
       retval = complex_result;
     }
   else
     {
       FloatNDArray result (a_dims);
 
       for (octave_idx_type i = 0; i < len; i++)
-	{
-	  octave_quit ();
-	  result(i) = std::pow (a(i), b(i));
-	}
+        {
+          octave_quit ();
+          result(i) = std::pow (a(i), b(i));
+        }
 
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 5 -*-
@@ -2653,19 +2653,19 @@ elem_xpow (const FloatComplex& a, const 
 {
   FloatComplexNDArray result (b.dims ());
 
   for (octave_idx_type i = 0; i < b.length (); i++)
     {
       octave_quit ();
       float btmp = b(i);
       if (xisint (btmp))
-	result(i) = std::pow (a, static_cast<int> (btmp));
+        result(i) = std::pow (a, static_cast<int> (btmp));
       else
-	result(i) = std::pow (a, btmp);
+        result(i) = std::pow (a, btmp);
     }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const FloatComplex& a, const FloatComplexNDArray& b)
@@ -2701,20 +2701,20 @@ elem_xpow (const FloatComplexNDArray& a,
               octave_quit ();
               result(i) = std::pow (a(i), static_cast<int> (b));
             }
         }
     }
   else
     {
       for (octave_idx_type i = 0; i < a.length (); i++)
-	{
-	  octave_quit ();
-	  result(i) = std::pow (a(i), b);
-	}
+        {
+          octave_quit ();
+          result(i) = std::pow (a(i), b);
+        }
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatNDArray& b)
@@ -2730,19 +2730,19 @@ elem_xpow (const FloatComplexNDArray& a,
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       float btmp = b(i);
       if (xisint (btmp))
-	result(i) = std::pow (a(i), static_cast<int> (btmp));
+        result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
-	result(i) = std::pow (a(i), btmp);
+        result(i) = std::pow (a(i), btmp);
     }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatComplex& b)
