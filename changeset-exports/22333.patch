# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1471471069 14400
#      Wed Aug 17 17:57:49 2016 -0400
# Node ID 2758af148ced2b847ee7132d3c21a9e570ff5282
# Parent  1d85005fc6b72cd682f76500ff5950a0f03ec08d
move base_list and regexp classes to octave namespace

* base-list.h (class octave_base_list): Move class to octave
namespace and rename to base_list.

* lo-regexp.cc, lo-regexp.h (class regexp): Move class to octave
namespace.  Move global functions to static functions in regexp
class.

* comment-list.h, regexp.cc, symtab.h, txt-eng.h, variables.cc,
pt-arg-list.cc, pt-arg-list.h, pt-array-list.h, pt-classdef.h,
pt-decl.h, pt-mat.cc, pt-misc.h, pt-select.h, pt-stmt.h, child-list.h:
Update for namespace changes.

diff --git a/libinterp/corefcn/comment-list.h b/libinterp/corefcn/comment-list.h
--- a/libinterp/corefcn/comment-list.h
+++ b/libinterp/corefcn/comment-list.h
@@ -79,24 +79,24 @@ private:
   // The text of the comment.
   std::string txt;
 
   // The type of comment.
   comment_type typ;
 };
 
 class
-octave_comment_list : public octave_base_list<octave_comment_elt>
+octave_comment_list : public octave::base_list<octave_comment_elt>
 {
 public:
 
   octave_comment_list (void) { }
 
   void append (const octave_comment_elt& elt)
-  { octave_base_list<octave_comment_elt>::append (elt); }
+  { octave::base_list<octave_comment_elt>::append (elt); }
 
   void append (const std::string& s,
                octave_comment_elt::comment_type t = octave_comment_elt::unknown)
   { append (octave_comment_elt (s, t)); }
 
   octave_comment_list *dup (void) const;
 };
 
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -269,17 +269,17 @@ do_regexp_rep_string_escapes (const std:
     }
 
   retval.resize (i);
 
   return retval;
 }
 
 static void
-parse_options (regexp::opts& options, const octave_value_list& args,
+parse_options (octave::regexp::opts& options, const octave_value_list& args,
                const std::string& who, int skip, bool& extra_args)
 {
   extra_args = false;
 
   for (int i = skip; i < args.length (); i++)
     {
       std::string str;
 
@@ -334,22 +334,23 @@ octregexp (const octave_value_list &args
   const std::string buffer = args(0).string_value ();
 
   std::string pattern = args(1).string_value ();
 
   // Matlab compatibility.
   if (args(1).is_sq_string ())
     pattern = do_regexp_ptn_string_escapes (pattern);
 
-  regexp::opts options;
+  octave::regexp::opts options;
   options.case_insensitive (case_insensitive);
   bool extra_options = false;
   parse_options (options, args, who, 2, extra_options);
 
-  regexp::match_data rx_lst = regexp_match (pattern, buffer, options, who);
+  octave::regexp::match_data rx_lst
+    = octave::regexp::match (pattern, buffer, options, who);
 
   string_vector named_pats = rx_lst.named_patterns ();
 
   size_t sz = rx_lst.size ();
 
   // Converted the linked list in the correct form for the return values
 
   octave_idx_type i = 0;
@@ -368,33 +369,33 @@ octregexp (const octave_value_list &args
     }
   else
     {
       for (int j = 0; j < named_pats.numel (); j++)
         {
           Cell tmp (dim_vector (1, sz));
 
           i = 0;
-          for (regexp::match_data::const_iterator p = rx_lst.begin ();
+          for (octave::regexp::match_data::const_iterator p = rx_lst.begin ();
                p != rx_lst.end (); p++)
             {
               string_vector named_tokens = p->named_tokens ();
 
               tmp(i++) = named_tokens(j);
             }
 
           nmap.assign (named_pats(j), octave_value (tmp));
         }
 
       retval(5) = nmap;
     }
 
   if (options.once ())
     {
-      regexp::match_data::const_iterator p = rx_lst.begin ();
+      octave::regexp::match_data::const_iterator p = rx_lst.begin ();
 
       retval(4) = sz ? p->tokens () : Cell ();
       retval(3) = sz ? p->match_string () : "";
       retval(2) = sz ? p->token_extents () : Matrix ();
 
       if (sz)
         {
           double start = p->start ();
@@ -421,17 +422,17 @@ octregexp (const octave_value_list &args
       Cell match_string (dim_vector (1, sz));
       Cell token_extents (dim_vector (1, sz));
       NDArray end (dim_vector (1, sz));
       NDArray start (dim_vector (1, sz));
       Cell split (dim_vector (1, sz+1));
       size_t sp_start = 0;
 
       i = 0;
-      for (regexp::match_data::const_iterator p = rx_lst.begin ();
+      for (octave::regexp::match_data::const_iterator p = rx_lst.begin ();
            p != rx_lst.end (); p++)
         {
           double s = p->start ();
           double e = p->end ();
 
           string_vector tmp = p->tokens ();
           tokens(i) = Cell (dim_vector (1, tmp.numel ()), tmp);
           match_string(i) = p->match_string ();
@@ -1317,21 +1318,21 @@ octregexprep (const octave_value_list &a
           && opt != "tokenextents" && opt != "match" && opt != "tokens"
           && opt != "names"  && opt != "split" && opt != "warnings")
         {
           regexpargs(len++) = args(i);
         }
     }
   regexpargs.resize (len);
 
-  regexp::opts options;
+  octave::regexp::opts options;
   bool extra_args = false;
   parse_options (options, regexpargs, who, 0, extra_args);
 
-  return regexp_replace (pattern, buffer, replacement, options, who);
+  return octave::regexp::replace (pattern, buffer, replacement, options, who);
 }
 
 DEFUN (regexprep, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})
 @deftypefnx {} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, "@var{opt1}", @dots{})
 Replace occurrences of pattern @var{pat} in @var{string} with @var{repstr}.
 
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -2050,17 +2050,17 @@ public:
     return retval;
   }
 
   static std::list<symbol_record>
   regexp_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
-    ::regexp pat (pattern);
+    octave::regexp pat (pattern);
 
     for (global_table_const_iterator p = global_table.begin ();
          p != global_table.end (); p++)
       {
         // We generate a list of symbol_record objects so that
         // the results from regexp_variables and regexp_global_variables
         // may be handled the same way.
 
@@ -2790,17 +2790,17 @@ private:
             if (pattern.match (sr.name ()))
               sr.clear (my_scope);
           }
       }
   }
 
   void do_clear_variable_regexp (const std::string& pat)
   {
-    ::regexp pattern (pat);
+    octave::regexp pattern (pat);
 
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
         symbol_record& sr = p->second;
 
         if (sr.is_defined () || sr.is_global ())
           {
             if (pattern.is_match (sr.name ()))
@@ -2867,17 +2867,17 @@ private:
     return retval;
   }
 
   std::list<symbol_record> do_regexp (const std::string& pattern,
                                       bool vars_only = false) const
   {
     std::list<symbol_record> retval;
 
-    ::regexp pat (pattern);
+    octave::regexp pat (pattern);
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
         if (pat.is_match (p->first))
           {
             const symbol_record& sr = p->second;
 
             if (vars_only && ! sr.is_variable ())
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -103,24 +103,24 @@ public:
 
 private:
   int symbol;
 };
 
 class
 OCTINTERP_API
 text_element_list
-  : public text_element, public octave_base_list<text_element *>
+  : public text_element, public octave::base_list<text_element *>
 {
 public:
   text_element_list (void)
-    : text_element (), octave_base_list<text_element*> () { }
+    : text_element (), octave::base_list<text_element*> () { }
 
   text_element_list (text_element* e)
-    : text_element (), octave_base_list<text_element*> ()
+    : text_element (), octave::base_list<text_element*> ()
   { push_back (e); }
 
   ~text_element_list (void)
   {
     while (! empty ())
       {
         iterator it = begin ();
         delete (*it);
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -2114,17 +2114,17 @@ name_matches_any_pattern (const std::str
 
   for (int k = idx; k < argc; k++)
     {
       std::string patstr = argv[k];
       if (! patstr.empty ())
         {
           if (have_regexp)
             {
-              if (is_regexp_match (patstr, nm))
+              if (octave::regexp::is_match (patstr, nm))
                 {
                   retval = true;
                   break;
                 }
             }
           else
             {
               glob_match pattern (patstr);
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -68,17 +68,17 @@ tree_argument_list::has_magic_end (void)
     }
 
   return false;
 }
 
 void
 tree_argument_list::append (const element_type& s)
 {
-  octave_base_list<tree_expression *>::append (s);
+  octave::base_list<tree_expression *>::append (s);
 
   if (! list_includes_magic_end && s && s->has_magic_end ())
     list_includes_magic_end = true;
 
   if (! list_includes_magic_tilde && s && s->is_identifier ())
     {
       tree_identifier *id = dynamic_cast<tree_identifier *> (s);
       list_includes_magic_tilde = id && id->is_black_hole ();
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -36,17 +36,17 @@ class tree_walker;
 
 #include "base-list.h"
 #include "symtab.h"
 
 // Argument lists.  Used to hold the list of expressions that are the
 // arguments in a function call or index expression.
 
 class
-tree_argument_list : public octave_base_list<tree_expression *>
+tree_argument_list : public octave::base_list<tree_expression *>
 {
 public:
 
   typedef tree_expression* element_type;
 
   tree_argument_list (void)
     : list_includes_magic_end (false), list_includes_magic_tilde (false),
       simple_assign_lhs (false) { }
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -29,25 +29,25 @@ along with Octave; see the file COPYING.
 #include "pt-arg-list.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
 // Base class for cell arrays and matrices.
 
 class
 tree_array_list : public tree_expression,
-                  public octave_base_list<tree_argument_list *>
+                  public octave::base_list<tree_argument_list *>
 {
 public:
 
-  typedef octave_base_list<tree_argument_list *>::iterator iterator;
-  typedef octave_base_list<tree_argument_list *>::const_iterator const_iterator;
+  typedef octave::base_list<tree_argument_list *>::iterator iterator;
+  typedef octave::base_list<tree_argument_list *>::const_iterator const_iterator;
 
   tree_array_list (tree_argument_list *row = 0, int l = -1, int c = -1)
-    : tree_expression (l, c), octave_base_list<tree_argument_list *> ()
+    : tree_expression (l, c), octave::base_list<tree_argument_list *> ()
   {
     if (row)
       append (row);
   }
 
   ~tree_array_list (void);
 
   bool all_elements_are_constant (void) const;
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -69,26 +69,26 @@ private:
 
   // No copying!
 
   tree_classdef_attribute (const tree_classdef_attribute&);
 
   tree_classdef_attribute& operator = (const tree_classdef_attribute&);
 };
 
-class tree_classdef_attribute_list : public octave_base_list<tree_classdef_attribute *>
+class tree_classdef_attribute_list : public octave::base_list<tree_classdef_attribute *>
 {
 public:
 
   tree_classdef_attribute_list (void) { }
 
   tree_classdef_attribute_list (tree_classdef_attribute *a) { append (a); }
 
-  tree_classdef_attribute_list (const octave_base_list<tree_classdef_attribute *>& a)
-    : octave_base_list<tree_classdef_attribute *> (a) { }
+  tree_classdef_attribute_list (const octave::base_list<tree_classdef_attribute *>& a)
+    : octave::base_list<tree_classdef_attribute *> (a) { }
 
   ~tree_classdef_attribute_list (void);
 
   void accept (tree_walker&);
 
 private:
 
   // No copying!
@@ -117,26 +117,26 @@ private:
 
   // No copying!
 
   tree_classdef_superclass (const tree_classdef_superclass&);
 
   tree_classdef_superclass& operator = (const tree_classdef_superclass&);
 };
 
-class tree_classdef_superclass_list : public octave_base_list<tree_classdef_superclass *>
+class tree_classdef_superclass_list : public octave::base_list<tree_classdef_superclass *>
 {
 public:
 
   tree_classdef_superclass_list (void) { }
 
   tree_classdef_superclass_list (tree_classdef_superclass *sc) { append (sc); }
 
-  tree_classdef_superclass_list (const octave_base_list<tree_classdef_superclass *>& a)
-    : octave_base_list<tree_classdef_superclass *> (a) { }
+  tree_classdef_superclass_list (const octave::base_list<tree_classdef_superclass *>& a)
+    : octave::base_list<tree_classdef_superclass *> (a) { }
 
   ~tree_classdef_superclass_list (void);
 
   void accept (tree_walker&);
 
 private:
 
   // No copying!
@@ -147,48 +147,48 @@ private:
 };
 
 template <typename T>
 class tree_classdef_element : public tree
 {
 public:
 
   tree_classdef_element (tree_classdef_attribute_list *a,
-                         octave_base_list<T> *elist,
+                         octave::base_list<T> *elist,
                          octave_comment_list *lc, octave_comment_list *tc,
                          int l = -1, int c = -1)
     : tree (l, c), attr_list (a), elt_list (elist),
       lead_comm (lc), trail_comm (tc)
   { }
 
   ~tree_classdef_element (void)
   {
     delete attr_list;
     delete elt_list;
     delete lead_comm;
     delete trail_comm;
   }
 
   tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
 
-  octave_base_list<T> *element_list (void) { return elt_list; }
+  octave::base_list<T> *element_list (void) { return elt_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   void accept (tree_walker&) { }
 
 private:
 
   // List of attributes that apply to this class.
   tree_classdef_attribute_list *attr_list;
 
   // The list of objects contained in this block.
-  octave_base_list<T> *elt_list;
+  octave::base_list<T> *elt_list;
 
   // Comment preceding the token marking the beginning of the block.
   octave_comment_list *lead_comm;
 
   // Comment preceding END token.
   octave_comment_list *trail_comm;
 
   // No copying!
@@ -224,26 +224,26 @@ private:
 
   // No copying!
 
   tree_classdef_property (const tree_classdef_property&);
 
   tree_classdef_property& operator = (const tree_classdef_property&);
 };
 
-class tree_classdef_property_list : public octave_base_list<tree_classdef_property *>
+class tree_classdef_property_list : public octave::base_list<tree_classdef_property *>
 {
 public:
 
   tree_classdef_property_list (void) { }
 
   tree_classdef_property_list (tree_classdef_property* p) { append (p); }
 
-  tree_classdef_property_list (const octave_base_list<tree_classdef_property *>& a)
-    : octave_base_list<tree_classdef_property *> (a) { }
+  tree_classdef_property_list (const octave::base_list<tree_classdef_property *>& a)
+    : octave::base_list<tree_classdef_property *> (a) { }
 
   ~tree_classdef_property_list (void);
 
   void accept (tree_walker&);
 
 private:
 
   // No copying!
@@ -273,26 +273,26 @@ private:
 
   // No copying!
 
   tree_classdef_properties_block (const tree_classdef_properties_block&);
 
   tree_classdef_properties_block& operator = (const tree_classdef_properties_block&);
 };
 
-class tree_classdef_methods_list : public octave_base_list<octave_value>
+class tree_classdef_methods_list : public octave::base_list<octave_value>
 {
 public:
 
   tree_classdef_methods_list (void) { }
 
   tree_classdef_methods_list (const octave_value& f) { append (f); }
 
-  tree_classdef_methods_list (const octave_base_list<octave_value>& a)
-    : octave_base_list<octave_value> (a) { }
+  tree_classdef_methods_list (const octave::base_list<octave_value>& a)
+    : octave::base_list<octave_value> (a) { }
 
   ~tree_classdef_methods_list (void) { }
 
   void accept (tree_walker&);
 
 private:
 
   // No copying!
@@ -346,26 +346,26 @@ private:
 
   // No copying!
 
   tree_classdef_event (const tree_classdef_event&);
 
   tree_classdef_event& operator = (const tree_classdef_event&);
 };
 
-class tree_classdef_events_list : public octave_base_list<tree_classdef_event *>
+class tree_classdef_events_list : public octave::base_list<tree_classdef_event *>
 {
 public:
 
   tree_classdef_events_list (void) { }
 
   tree_classdef_events_list (tree_classdef_event *e) { append (e); }
 
-  tree_classdef_events_list (const octave_base_list<tree_classdef_event *>& a)
-    : octave_base_list<tree_classdef_event *> (a) { }
+  tree_classdef_events_list (const octave::base_list<tree_classdef_event *>& a)
+    : octave::base_list<tree_classdef_event *> (a) { }
 
   ~tree_classdef_events_list (void);
 
   void accept (tree_walker&);
 
 private:
 
   // No copying!
@@ -427,26 +427,26 @@ private:
 
   // No copying!
 
   tree_classdef_enum (const tree_classdef_enum&);
 
   tree_classdef_enum& operator = (const tree_classdef_enum&);
 };
 
-class tree_classdef_enum_list : public octave_base_list<tree_classdef_enum *>
+class tree_classdef_enum_list : public octave::base_list<tree_classdef_enum *>
 {
 public:
 
   tree_classdef_enum_list (void) { }
 
   tree_classdef_enum_list (tree_classdef_enum *e) { append (e); }
 
-  tree_classdef_enum_list (const octave_base_list<tree_classdef_enum *>& a)
-    : octave_base_list<tree_classdef_enum *> (a) { }
+  tree_classdef_enum_list (const octave::base_list<tree_classdef_enum *>& a)
+    : octave::base_list<tree_classdef_enum *> (a) { }
 
   ~tree_classdef_enum_list (void);
 
   void accept (tree_walker&);
 
 private:
 
   // No copying!
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -106,17 +106,17 @@ private:
   // No copying!
 
   tree_decl_elt (const tree_decl_elt&);
 
   tree_decl_elt& operator = (const tree_decl_elt&);
 };
 
 class
-tree_decl_init_list : public octave_base_list<tree_decl_elt *>
+tree_decl_init_list : public octave::base_list<tree_decl_elt *>
 {
 public:
 
   tree_decl_init_list (void) { }
 
   tree_decl_init_list (tree_decl_elt *t) { append (t); }
 
   ~tree_decl_init_list (void)
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -59,17 +59,17 @@ char Vstring_fill_char = ' ';
 // But first, some internal classes that make our job much easier.
 
 class
 tm_row_const
 {
 private:
 
   class
-  tm_row_const_rep : public octave_base_list<octave_value>
+  tm_row_const_rep : public octave::base_list<octave_value>
   {
   public:
 
     tm_row_const_rep (void)
       : count (1), dv (0, 0), all_str (false),
         all_sq_str (false), all_dq_str (false),
         some_str (false), all_real (false), all_cmplx (false),
         all_mt (true), any_cell (false), any_sparse (false),
@@ -457,17 +457,17 @@ tm_row_const::tm_row_const_rep::cellify 
               else if (! dv.hvcat (this_elt_dv, 1))
                 eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
             }
         }
     }
 }
 
 class
-tm_const : public octave_base_list<tm_row_const>
+tm_const : public octave::base_list<tm_row_const>
 {
 public:
 
   tm_const (const tree_matrix& tm)
     : dv (0, 0), all_str (false), all_sq_str (false), all_dq_str (false),
       some_str (false), all_real (false), all_cmplx (false),
       all_mt (true), any_cell (false), any_sparse (false),
       any_class (false), class_nm (), ok (false)
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -40,17 +40,17 @@ class tree_walker;
 #include "pt-decl.h"
 #include "symtab.h"
 
 // Parameter lists.  Used to hold the list of input and output
 // parameters in a function definition.  Elements are identifiers
 // only.
 
 class
-tree_parameter_list : public octave_base_list<tree_decl_elt *>
+tree_parameter_list : public octave::base_list<tree_decl_elt *>
 {
 public:
 
   enum in_or_out
   {
     in = 1,
     out = 2
   };
@@ -107,17 +107,17 @@ private:
 
   tree_parameter_list& operator = (const tree_parameter_list&);
 };
 
 // Return lists.  Used to hold the right hand sides of multiple
 // assignment expressions.
 
 class
-tree_return_list : public octave_base_list<tree_index_expression *>
+tree_return_list : public octave::base_list<tree_index_expression *>
 {
 public:
 
   tree_return_list (void) { }
 
   tree_return_list (tree_index_expression *t) { append (t); }
 
   ~tree_return_list (void);
@@ -132,17 +132,17 @@ private:
   // No copying!
 
   tree_return_list (const tree_return_list&);
 
   tree_return_list& operator = (const tree_return_list&);
 };
 
 class
-tree_va_return_list : public octave_base_list<octave_value>
+tree_va_return_list : public octave::base_list<octave_value>
 {
 public:
 
   tree_va_return_list (void) { }
 
   ~tree_va_return_list (void) { }
 
 private:
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -83,17 +83,17 @@ private:
   // No copying!
 
   tree_if_clause (const tree_if_clause&);
 
   tree_if_clause& operator = (const tree_if_clause&);
 };
 
 class
-tree_if_command_list : public octave_base_list<tree_if_clause *>
+tree_if_command_list : public octave::base_list<tree_if_clause *>
 {
 public:
 
   tree_if_command_list (void) { }
 
   tree_if_command_list (tree_if_clause *t) { append (t); }
 
   ~tree_if_command_list (void)
@@ -213,17 +213,17 @@ private:
   // No copying!
 
   tree_switch_case (const tree_switch_case&);
 
   tree_switch_case& operator = (const tree_switch_case&);
 };
 
 class
-tree_switch_case_list : public octave_base_list<tree_switch_case *>
+tree_switch_case_list : public octave::base_list<tree_switch_case *>
 {
 public:
 
   tree_switch_case_list (void) { }
 
   tree_switch_case_list (tree_switch_case *t) { append (t); }
 
   ~tree_switch_case_list (void)
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -123,17 +123,17 @@ private:
   tree_statement (const tree_statement&);
 
   tree_statement& operator = (const tree_statement&);
 };
 
 // A list of statements to evaluate.
 
 class
-tree_statement_list : public octave_base_list<tree_statement *>
+tree_statement_list : public octave::base_list<tree_statement *>
 {
 public:
 
   tree_statement_list (void)
     : function_body (false), anon_function_body (false),
       script_body (false) { }
 
   tree_statement_list (tree_statement *s)
diff --git a/liboctave/system/child-list.h b/liboctave/system/child-list.h
--- a/liboctave/system/child-list.h
+++ b/liboctave/system/child-list.h
@@ -85,17 +85,17 @@ namespace octave
   class
   OCTAVE_API
   child_list
   {
   protected:
 
     child_list (void) { }
 
-    class child_list_rep : public octave_base_list<child>
+    class child_list_rep : public base_list<child>
     {
     public:
 
       void insert (pid_t pid, child::child_event_handler f);
 
       void reap (void);
 
       bool wait (void);
diff --git a/liboctave/util/base-list.h b/liboctave/util/base-list.h
--- a/liboctave/util/base-list.h
+++ b/liboctave/util/base-list.h
@@ -24,108 +24,111 @@ along with Octave; see the file COPYING.
 #define octave_base_list_h 1
 
 #include "octave-config.h"
 
 #include <cstdlib>
 
 #include <list>
 
-template <typename elt_type>
-class
-octave_base_list
+namespace octave
 {
-public:
-
-  typedef typename std::list<elt_type>::iterator iterator;
-  typedef typename std::list<elt_type>::const_iterator const_iterator;
-
-  typedef typename std::list<elt_type>::reverse_iterator reverse_iterator;
-  typedef typename std::list<elt_type>::const_reverse_iterator const_reverse_iterator;
+  template <typename elt_type>
+  class
+  base_list
+  {
+  public:
 
-  bool empty (void) const { return lst.empty (); }
+    typedef typename std::list<elt_type>::iterator iterator;
+    typedef typename std::list<elt_type>::const_iterator const_iterator;
 
-  size_t size (void) const { return lst.size (); }
-  size_t length (void) const { return size (); }
+    typedef typename std::list<elt_type>::reverse_iterator reverse_iterator;
+    typedef typename std::list<elt_type>::const_reverse_iterator const_reverse_iterator;
 
-  iterator erase (iterator pos) { return lst.erase (pos); }
+    bool empty (void) const { return lst.empty (); }
 
-  template <typename P>
-  void remove_if (P pred)
-  {
-    lst.remove_if (pred);
+    size_t size (void) const { return lst.size (); }
+    size_t length (void) const { return size (); }
+
+    iterator erase (iterator pos) { return lst.erase (pos); }
 
-    // FIXME: kluge removed 8/7/13.  Eventually this commented
-    //        code should be deleted.
-    //
-    // FIXME: this kluge should be removed at some point.
-    // We would like to simply call
-    //
-    //   lst.remove_if (pred);
-    //
-    // but the Sun Studio compiler chokes on that.
-    //
-    // iterator b = lst.begin ();
-    // iterator e = lst.end ();
-    // while (b != e)
-    //   {
-    //     iterator n = b;
-    //     n++;
-    //     if (pred (*b))
-    //       lst.erase (b);
-    //     b = n;
-    //   }
-  }
+    template <typename P>
+    void remove_if (P pred)
+    {
+      lst.remove_if (pred);
 
-  void clear (void) { lst.clear (); }
+      // FIXME: kluge removed 8/7/13.  Eventually this commented
+      //        code should be deleted.
+      //
+      // FIXME: this kluge should be removed at some point.
+      // We would like to simply call
+      //
+      //   lst.remove_if (pred);
+      //
+      // but the Sun Studio compiler chokes on that.
+      //
+      // iterator b = lst.begin ();
+      // iterator e = lst.end ();
+      // while (b != e)
+      //   {
+      //     iterator n = b;
+      //     n++;
+      //     if (pred (*b))
+      //       lst.erase (b);
+      //     b = n;
+      //   }
+    }
+
+    void clear (void) { lst.clear (); }
 
-  iterator begin (void) { return iterator (lst.begin ()); }
-  const_iterator begin (void) const { return const_iterator (lst.begin ()); }
+    iterator begin (void) { return iterator (lst.begin ()); }
+    const_iterator begin (void) const { return const_iterator (lst.begin ()); }
 
-  iterator end (void) { return iterator (lst.end ()); }
-  const_iterator end (void) const { return const_iterator (lst.end ()); }
+    iterator end (void) { return iterator (lst.end ()); }
+    const_iterator end (void) const { return const_iterator (lst.end ()); }
 
-  reverse_iterator rbegin (void) { return reverse_iterator (lst.rbegin ()); }
-  const_reverse_iterator rbegin (void) const
-  { return const_reverse_iterator (lst.rbegin ()); }
+    reverse_iterator rbegin (void) { return reverse_iterator (lst.rbegin ()); }
+    const_reverse_iterator rbegin (void) const
+    { return const_reverse_iterator (lst.rbegin ()); }
 
-  reverse_iterator rend (void) { return reverse_iterator (lst.rend ()); }
-  const_reverse_iterator rend (void) const
-  { return const_reverse_iterator (lst.rend ()); }
+    reverse_iterator rend (void) { return reverse_iterator (lst.rend ()); }
+    const_reverse_iterator rend (void) const
+    { return const_reverse_iterator (lst.rend ()); }
+
+    elt_type& front (void) { return lst.front (); }
+    elt_type& back (void) { return lst.back (); }
 
-  elt_type& front (void) { return lst.front (); }
-  elt_type& back (void) { return lst.back (); }
+    const elt_type& front (void) const { return lst.front (); }
+    const elt_type& back (void) const { return lst.back (); }
 
-  const elt_type& front (void) const { return lst.front (); }
-  const elt_type& back (void) const { return lst.back (); }
+    void push_front (const elt_type& s) { lst.push_front (s); }
+    void push_back (const elt_type& s) { lst.push_back (s); }
 
-  void push_front (const elt_type& s) { lst.push_front (s); }
-  void push_back (const elt_type& s) { lst.push_back (s); }
+    void pop_front (void) { lst.pop_front (); }
+    void pop_back (void) { lst.pop_back (); }
 
-  void pop_front (void) { lst.pop_front (); }
-  void pop_back (void) { lst.pop_back (); }
-
-  // For backward compatibility.
-  void append (const elt_type& s) { lst.push_back (s); }
+    // For backward compatibility.
+    void append (const elt_type& s) { lst.push_back (s); }
 
-  octave_base_list (void) : lst () { }
+    base_list (void) : lst () { }
 
-  octave_base_list (const std::list<elt_type>& l) : lst (l) { }
+    base_list (const std::list<elt_type>& l) : lst (l) { }
 
-  octave_base_list (const octave_base_list& bl) : lst (bl.lst) { }
+    base_list (const base_list& bl) : lst (bl.lst) { }
 
-  octave_base_list& operator = (const octave_base_list& bl)
-  {
-    if (this != &bl)
-      {
-        lst = bl.lst;
-      }
-    return *this;
-  }
+    base_list& operator = (const base_list& bl)
+    {
+      if (this != &bl)
+        {
+          lst = bl.lst;
+        }
+      return *this;
+    }
 
-  virtual ~octave_base_list (void) { }
+    virtual ~base_list (void) { }
+
+  private:
 
-private:
-
-  std::list<elt_type> lst;
-};
+    std::list<elt_type> lst;
+  };
+}
 
 #endif
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -52,561 +52,564 @@ along with Octave; see the file COPYING.
 // FIXME: should this be configurable?
 #define MAXLOOKBEHIND 10
 
 static bool lookbehind_warned = false;
 
 // FIXME: don't bother collecting and composing return values
 //        the user doesn't want.
 
-void
-regexp::free (void)
-{
-  if (data)
-    pcre_free (static_cast<pcre *> (data));
-}
-
-void
-regexp::compile_internal (void)
+namespace octave
 {
-  // If we had a previously compiled pattern, release it.
-  free ();
-
-  size_t max_length = MAXLOOKBEHIND;
+  void
+  regexp::free (void)
+  {
+    if (data)
+      pcre_free (static_cast<pcre *> (data));
+  }
 
-  size_t pos = 0;
-  size_t new_pos;
-  int inames = 0;
-  std::ostringstream buf;
+  void
+  regexp::compile_internal (void)
+  {
+    // If we had a previously compiled pattern, release it.
+    free ();
+
+    size_t max_length = MAXLOOKBEHIND;
+
+    size_t pos = 0;
+    size_t new_pos;
+    int inames = 0;
+    std::ostringstream buf;
 
-  while ((new_pos = pattern.find ("(?", pos)) != std::string::npos)
-    {
-      if (pattern.at (new_pos + 2) == '<'
-          && !(pattern.at (new_pos + 3) == '='
-               || pattern.at (new_pos + 3) == '!'))
-        {
-          // The syntax of named tokens in pcre is "(?P<name>...)" while
-          // we need a syntax "(?<name>...)", so fix that here.  Also an
-          // expression like
-          // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)"
-          // should be perfectly legal, while pcre does not allow the same
-          // named token name on both sides of the alternative.  Also fix
-          // that here by replacing name tokens by dummy names, and dealing
-          // with the dummy names later.
+    while ((new_pos = pattern.find ("(?", pos)) != std::string::npos)
+      {
+        if (pattern.at (new_pos + 2) == '<'
+            && !(pattern.at (new_pos + 3) == '='
+                 || pattern.at (new_pos + 3) == '!'))
+          {
+            // The syntax of named tokens in pcre is "(?P<name>...)" while
+            // we need a syntax "(?<name>...)", so fix that here.  Also an
+            // expression like
+            // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)"
+            // should be perfectly legal, while pcre does not allow the same
+            // named token name on both sides of the alternative.  Also fix
+            // that here by replacing name tokens by dummy names, and dealing
+            // with the dummy names later.
 
-          size_t tmp_pos = pattern.find_first_of ('>', new_pos);
-
-          if (tmp_pos == std::string::npos)
-            (*current_liboctave_error_handler)
-              ("regexp: syntax error in pattern");
+            size_t tmp_pos = pattern.find_first_of ('>', new_pos);
 
-          std::string tmp_name =
-            pattern.substr (new_pos+3, tmp_pos-new_pos-3);
+            if (tmp_pos == std::string::npos)
+              (*current_liboctave_error_handler)
+                ("regexp: syntax error in pattern");
 
-          bool found = false;
+            std::string tmp_name =
+              pattern.substr (new_pos+3, tmp_pos-new_pos-3);
+
+            bool found = false;
 
-          for (int i = 0; i < nnames; i++)
-            {
-              if (named_pats(i) == tmp_name)
-                {
-                  named_idx.resize (dim_vector (inames+1, 1));
-                  named_idx(inames) = i;
-                  found = true;
-                  break;
-                }
-            }
-
-          if (! found)
-            {
-              named_idx.resize (dim_vector (inames+1, 1));
-              named_idx(inames) = nnames;
-              named_pats.append (tmp_name);
-              nnames++;
-            }
+            for (int i = 0; i < nnames; i++)
+              {
+                if (named_pats(i) == tmp_name)
+                  {
+                    named_idx.resize (dim_vector (inames+1, 1));
+                    named_idx(inames) = i;
+                    found = true;
+                    break;
+                  }
+              }
 
-          if (new_pos - pos > 0)
-            buf << pattern.substr (pos, new_pos-pos);
-          if (inames < 10)
-            buf << "(?P<n00" << inames++;
-          else if (inames < 100)
-            buf << "(?P<n0" << inames++;
-          else
-            buf << "(?P<n" << inames++;
+            if (! found)
+              {
+                named_idx.resize (dim_vector (inames+1, 1));
+                named_idx(inames) = nnames;
+                named_pats.append (tmp_name);
+                nnames++;
+              }
+
+            if (new_pos - pos > 0)
+              buf << pattern.substr (pos, new_pos-pos);
+            if (inames < 10)
+              buf << "(?P<n00" << inames++;
+            else if (inames < 100)
+              buf << "(?P<n0" << inames++;
+            else
+              buf << "(?P<n" << inames++;
 
-          pos = tmp_pos;
-        }
-      else if (pattern.at (new_pos + 2) == '<')
-        {
-          // Find lookbehind operators of arbitrary length (ie like
-          // "(?<=[a-z]*)") and replace with a maximum length operator
-          // as PCRE can not yet handle arbitrary length lookahead
-          // operators.  Use the string length as the maximum length to
-          // avoid issues.
+            pos = tmp_pos;
+          }
+        else if (pattern.at (new_pos + 2) == '<')
+          {
+            // Find lookbehind operators of arbitrary length (ie like
+            // "(?<=[a-z]*)") and replace with a maximum length operator
+            // as PCRE can not yet handle arbitrary length lookahead
+            // operators.  Use the string length as the maximum length to
+            // avoid issues.
 
-          int brackets = 1;
-          size_t tmp_pos1 = new_pos + 2;
-          size_t tmp_pos2 = tmp_pos1;
+            int brackets = 1;
+            size_t tmp_pos1 = new_pos + 2;
+            size_t tmp_pos2 = tmp_pos1;
 
-          while (tmp_pos1 < pattern.length () && brackets > 0)
-            {
-              char ch = pattern.at (tmp_pos1);
-
-              if (ch == '(')
-                brackets++;
-              else if (ch == ')')
-                {
-                  if (brackets > 1)
-                    tmp_pos2 = tmp_pos1;
+            while (tmp_pos1 < pattern.length () && brackets > 0)
+              {
+                char ch = pattern.at (tmp_pos1);
 
-                  brackets--;
-                }
-
-              tmp_pos1++;
-            }
+                if (ch == '(')
+                  brackets++;
+                else if (ch == ')')
+                  {
+                    if (brackets > 1)
+                      tmp_pos2 = tmp_pos1;
 
-          if (brackets != 0)
-            {
-              buf << pattern.substr (pos, new_pos - pos) << "(?";
-              pos = new_pos + 2;
-            }
-          else
-            {
-              size_t tmp_pos3 = pattern.find_first_of ("*+", tmp_pos2);
+                    brackets--;
+                  }
+
+                tmp_pos1++;
+              }
 
-              if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
-                {
-                  if (! lookbehind_warned)
-                    {
-                      lookbehind_warned = true;
-                      (*current_liboctave_warning_with_id_handler)
-                        ("Octave:regexp-lookbehind-limit",
-                         "%s: arbitrary length lookbehind patterns are only supported up to length %d",
-                         who.c_str (), MAXLOOKBEHIND);
-                    }
+            if (brackets != 0)
+              {
+                buf << pattern.substr (pos, new_pos - pos) << "(?";
+                pos = new_pos + 2;
+              }
+            else
+              {
+                size_t tmp_pos3 = pattern.find_first_of ("*+", tmp_pos2);
 
-                  buf << pattern.substr (pos, new_pos - pos) << "(";
-
-                  size_t i;
+                if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
+                  {
+                    if (! lookbehind_warned)
+                      {
+                        lookbehind_warned = true;
+                        (*current_liboctave_warning_with_id_handler)
+                          ("Octave:regexp-lookbehind-limit",
+                           "%s: arbitrary length lookbehind patterns are only supported up to length %d",
+                           who.c_str (), MAXLOOKBEHIND);
+                      }
 
-                  if (pattern.at (tmp_pos3) == '*')
-                    i = 0;
-                  else
-                    i = 1;
+                    buf << pattern.substr (pos, new_pos - pos) << "(";
+
+                    size_t i;
 
-                  for (; i < max_length + 1; i++)
-                    {
-                      buf << pattern.substr (new_pos, tmp_pos3 - new_pos)
-                          << "{" << i << "}";
-                      buf << pattern.substr (tmp_pos3 + 1,
-                                             tmp_pos1 - tmp_pos3 - 1);
-                      if (i != max_length)
-                        buf << "|";
-                    }
-                  buf << ")";
-                }
-              else
-                buf << pattern.substr (pos, tmp_pos1 - pos);
+                    if (pattern.at (tmp_pos3) == '*')
+                      i = 0;
+                    else
+                      i = 1;
 
-              pos = tmp_pos1;
-            }
-        }
-      else
-        {
-          buf << pattern.substr (pos, new_pos - pos) << "(?";
-          pos = new_pos + 2;
-        }
+                    for (; i < max_length + 1; i++)
+                      {
+                        buf << pattern.substr (new_pos, tmp_pos3 - new_pos)
+                            << "{" << i << "}";
+                        buf << pattern.substr (tmp_pos3 + 1,
+                                               tmp_pos1 - tmp_pos3 - 1);
+                        if (i != max_length)
+                          buf << "|";
+                      }
+                    buf << ")";
+                  }
+                else
+                  buf << pattern.substr (pos, tmp_pos1 - pos);
 
-    }
-
-  buf << pattern.substr (pos);
+                pos = tmp_pos1;
+              }
+          }
+        else
+          {
+            buf << pattern.substr (pos, new_pos - pos) << "(?";
+            pos = new_pos + 2;
+          }
 
-  const char *err;
-  int erroffset;
-  std::string buf_str = buf.str ();
+      }
+
+    buf << pattern.substr (pos);
 
-  int pcre_options
-    = ((options.case_insensitive () ? PCRE_CASELESS : 0)
-       | (options.dotexceptnewline () ? 0 : PCRE_DOTALL)
-       | (options.lineanchors () ? PCRE_MULTILINE : 0)
-       | (options.freespacing () ? PCRE_EXTENDED : 0));
-
-  data = pcre_compile (buf_str.c_str (), pcre_options, &err, &erroffset, 0);
+    const char *err;
+    int erroffset;
+    std::string buf_str = buf.str ();
 
-  if (! data)
-    (*current_liboctave_error_handler)
-      ("%s: %s at position %d of expression", who.c_str (), err, erroffset);
-}
+    int pcre_options
+      = ((options.case_insensitive () ? PCRE_CASELESS : 0)
+         | (options.dotexceptnewline () ? 0 : PCRE_DOTALL)
+         | (options.lineanchors () ? PCRE_MULTILINE : 0)
+         | (options.freespacing () ? PCRE_EXTENDED : 0));
 
-regexp::match_data
-regexp::match (const std::string& buffer)
-{
-  regexp::match_data retval;
+    data = pcre_compile (buf_str.c_str (), pcre_options, &err, &erroffset, 0);
+
+    if (! data)
+      (*current_liboctave_error_handler)
+        ("%s: %s at position %d of expression", who.c_str (), err, erroffset);
+  }
 
-  std::list<regexp::match_element> lst;
+  regexp::match_data
+  regexp::match (const std::string& buffer)
+  {
+    regexp::match_data retval;
 
-  int subpatterns;
-  int namecount;
-  int nameentrysize;
-  char *nametable;
-  size_t idx = 0;
+    std::list<regexp::match_element> lst;
 
-  pcre *re = static_cast<pcre *> (data);
+    int subpatterns;
+    int namecount;
+    int nameentrysize;
+    char *nametable;
+    size_t idx = 0;
 
-  pcre_fullinfo (re, 0, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
-  pcre_fullinfo (re, 0, PCRE_INFO_NAMECOUNT, &namecount);
-  pcre_fullinfo (re, 0, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
-  pcre_fullinfo (re, 0, PCRE_INFO_NAMETABLE, &nametable);
+    pcre *re = static_cast<pcre *> (data);
 
-  OCTAVE_LOCAL_BUFFER (int, ovector, (subpatterns+1)*3);
-  OCTAVE_LOCAL_BUFFER (int, nidx, namecount);
+    pcre_fullinfo (re, 0, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
+    pcre_fullinfo (re, 0, PCRE_INFO_NAMECOUNT, &namecount);
+    pcre_fullinfo (re, 0, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
+    pcre_fullinfo (re, 0, PCRE_INFO_NAMETABLE, &nametable);
 
-  for (int i = 0; i < namecount; i++)
-    {
-      // Index of subpattern in first two bytes MSB first of name.
-      // Extract index.
-      nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
-                | static_cast<int> (nametable[i*nameentrysize+1]);
-    }
+    OCTAVE_LOCAL_BUFFER (int, ovector, (subpatterns+1)*3);
+    OCTAVE_LOCAL_BUFFER (int, nidx, namecount);
 
-  while (true)
-    {
-      OCTAVE_QUIT;
+    for (int i = 0; i < namecount; i++)
+      {
+        // Index of subpattern in first two bytes MSB first of name.
+        // Extract index.
+        nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
+          | static_cast<int> (nametable[i*nameentrysize+1]);
+      }
+
+    while (true)
+      {
+        OCTAVE_QUIT;
 
-      int matches = pcre_exec (re, 0, buffer.c_str (),
-                               buffer.length (), idx,
-                               (idx ? PCRE_NOTBOL : 0),
-                               ovector, (subpatterns+1)*3);
+        int matches = pcre_exec (re, 0, buffer.c_str (),
+                                 buffer.length (), idx,
+                                 (idx ? PCRE_NOTBOL : 0),
+                                 ovector, (subpatterns+1)*3);
 
-      if (matches == PCRE_ERROR_MATCHLIMIT)
-        {
-          // Try harder; start with default value for MATCH_LIMIT
-          // and increase it.
-          (*current_liboctave_warning_with_id_handler)
-            ("Octave:regexp-match-limit",
-             "your pattern caused PCRE to hit its MATCH_LIMIT; trying harder now, but this will be slow");
+        if (matches == PCRE_ERROR_MATCHLIMIT)
+          {
+            // Try harder; start with default value for MATCH_LIMIT
+            // and increase it.
+            (*current_liboctave_warning_with_id_handler)
+              ("Octave:regexp-match-limit",
+               "your pattern caused PCRE to hit its MATCH_LIMIT; trying harder now, but this will be slow");
 
-          pcre_extra pe;
+            pcre_extra pe;
 
-          pcre_config (PCRE_CONFIG_MATCH_LIMIT,
-                       static_cast<void *> (&pe.match_limit));
+            pcre_config (PCRE_CONFIG_MATCH_LIMIT,
+                         static_cast<void *> (&pe.match_limit));
 
-          pe.flags = PCRE_EXTRA_MATCH_LIMIT;
+            pe.flags = PCRE_EXTRA_MATCH_LIMIT;
 
-          int i = 0;
-          while (matches == PCRE_ERROR_MATCHLIMIT
-                 && i++ < PCRE_MATCHLIMIT_MAX)
-            {
-              OCTAVE_QUIT;
+            int i = 0;
+            while (matches == PCRE_ERROR_MATCHLIMIT
+                   && i++ < PCRE_MATCHLIMIT_MAX)
+              {
+                OCTAVE_QUIT;
 
-              pe.match_limit *= 10;
-              matches = pcre_exec (re, &pe, buffer.c_str (),
-                                   buffer.length (), idx,
-                                   (idx ? PCRE_NOTBOL : 0),
-                                   ovector, (subpatterns+1)*3);
-            }
-        }
+                pe.match_limit *= 10;
+                matches = pcre_exec (re, &pe, buffer.c_str (),
+                                     buffer.length (), idx,
+                                     (idx ? PCRE_NOTBOL : 0),
+                                     ovector, (subpatterns+1)*3);
+              }
+          }
 
-      if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
-        (*current_liboctave_error_handler)
-          ("%s: internal error calling pcre_exec; "
-           "error code from pcre_exec is %i", who.c_str (), matches);
+        if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
+          (*current_liboctave_error_handler)
+            ("%s: internal error calling pcre_exec; "
+             "error code from pcre_exec is %i", who.c_str (), matches);
 
-      if (matches == PCRE_ERROR_NOMATCH)
-        break;
-      else if (ovector[1] <= ovector[0] && ! options.emptymatch ())
-        {
-          // Zero length match.  Skip to next char.
-          idx = ovector[0] + 1;
-          if (idx < buffer.length ())
-            continue;
-          else
-            break;
-        }
-      else
-        {
-          int pos_match = 0;
-          Matrix token_extents (matches-1, 2);
+        if (matches == PCRE_ERROR_NOMATCH)
+          break;
+        else if (ovector[1] <= ovector[0] && ! options.emptymatch ())
+          {
+            // Zero length match.  Skip to next char.
+            idx = ovector[0] + 1;
+            if (idx < buffer.length ())
+              continue;
+            else
+              break;
+          }
+        else
+          {
+            int pos_match = 0;
+            Matrix token_extents (matches-1, 2);
 
-          for (int i = 1; i < matches; i++)
-            {
-              if (ovector[2*i] >= 0 && ovector[2*i+1] > 0
-                  && (i == 1 || ovector[2*i] != ovector[2*i-2]
-                      || ovector[2*i-1] != ovector[2*i+1]))
-                {
-                  token_extents(pos_match,0) = double (ovector[2*i]+1);
-                  token_extents(pos_match++,1) = double (ovector[2*i+1]);
-                }
-            }
+            for (int i = 1; i < matches; i++)
+              {
+                if (ovector[2*i] >= 0 && ovector[2*i+1] > 0
+                    && (i == 1 || ovector[2*i] != ovector[2*i-2]
+                        || ovector[2*i-1] != ovector[2*i+1]))
+                  {
+                    token_extents(pos_match,0) = double (ovector[2*i]+1);
+                    token_extents(pos_match++,1) = double (ovector[2*i+1]);
+                  }
+              }
 
-          token_extents.resize (pos_match, 2);
+            token_extents.resize (pos_match, 2);
 
-          double start = double (ovector[0]+1);
-          double end = double (ovector[1]);
+            double start = double (ovector[0]+1);
+            double end = double (ovector[1]);
 
-          const char **listptr;
-          int status = pcre_get_substring_list (buffer.c_str (), ovector,
-                                                matches, &listptr);
+            const char **listptr;
+            int status = pcre_get_substring_list (buffer.c_str (), ovector,
+                                                  matches, &listptr);
 
-          if (status == PCRE_ERROR_NOMEMORY)
-            (*current_liboctave_error_handler)
-              ("%s: cannot allocate memory in pcre_get_substring_list",
-               who.c_str ());
+            if (status == PCRE_ERROR_NOMEMORY)
+              (*current_liboctave_error_handler)
+                ("%s: cannot allocate memory in pcre_get_substring_list",
+                 who.c_str ());
 
-          string_vector tokens (pos_match);
-          string_vector named_tokens (nnames);
-          int pos_offset = 0;
-          pos_match = 0;
+            string_vector tokens (pos_match);
+            string_vector named_tokens (nnames);
+            int pos_offset = 0;
+            pos_match = 0;
 
-          for (int i = 1; i < matches; i++)
-            {
-              if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
-                {
-                  if (i == 1 || ovector[2*i] != ovector[2*i-2]
-                      || ovector[2*i-1] != ovector[2*i+1])
-                    {
-                      if (namecount > 0)
-                        {
-                          // FIXME: Should probably do this with a map()
-                          //        rather than a linear search.  However,
-                          //        the number of captured, named expressions
-                          //        is usually pretty small (< 4)
-                          for (int j = 0; j < namecount; j++)
-                            {
-                              if (nidx[j] == i)
-                                {
-                                  named_tokens(named_idx(j)) =
-                                    std::string (*(listptr+i-pos_offset));
-                                  break;
-                                }
-                            }
-                        }
+            for (int i = 1; i < matches; i++)
+              {
+                if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
+                  {
+                    if (i == 1 || ovector[2*i] != ovector[2*i-2]
+                        || ovector[2*i-1] != ovector[2*i+1])
+                      {
+                        if (namecount > 0)
+                          {
+                            // FIXME: Should probably do this with a map()
+                            //        rather than a linear search.  However,
+                            //        the number of captured, named expressions
+                            //        is usually pretty small (< 4)
+                            for (int j = 0; j < namecount; j++)
+                              {
+                                if (nidx[j] == i)
+                                  {
+                                    named_tokens(named_idx(j)) =
+                                      std::string (*(listptr+i-pos_offset));
+                                    break;
+                                  }
+                              }
+                          }
 
-                      tokens(pos_match++) = std::string (*(listptr+i));
-                    }
-                  else
-                    pos_offset++;
-                }
-            }
+                        tokens(pos_match++) = std::string (*(listptr+i));
+                      }
+                    else
+                      pos_offset++;
+                  }
+              }
 
-          std::string match_string = std::string (*listptr);
+            std::string match_string = std::string (*listptr);
 
-          pcre_free_substring_list (listptr);
+            pcre_free_substring_list (listptr);
 
-          regexp::match_element new_elem (named_tokens, tokens, match_string,
-                                          token_extents, start, end);
-          lst.push_back (new_elem);
+            regexp::match_element new_elem (named_tokens, tokens, match_string,
+                                            token_extents, start, end);
+            lst.push_back (new_elem);
 
-          if (ovector[1] <= ovector[0])
-            {
-              // Zero length match.  Skip to next char.
-              idx = ovector[0] + 1;
-              if (idx <= buffer.length ())
-                continue;
-            }
-          else
-            idx = ovector[1];
+            if (ovector[1] <= ovector[0])
+              {
+                // Zero length match.  Skip to next char.
+                idx = ovector[0] + 1;
+                if (idx <= buffer.length ())
+                  continue;
+              }
+            else
+              idx = ovector[1];
 
-          if (options.once () || idx >= buffer.length ())
-            break;
-        }
-    }
+            if (options.once () || idx >= buffer.length ())
+              break;
+          }
+      }
 
-  retval = regexp::match_data (lst, named_pats);
+    retval = regexp::match_data (lst, named_pats);
 
-  return retval;
-}
+    return retval;
+  }
 
-bool
-regexp::is_match (const std::string& buffer)
-{
-  regexp::match_data rx_lst = match (buffer);
+  bool
+  regexp::is_match (const std::string& buffer)
+  {
+    regexp::match_data rx_lst = match (buffer);
 
-  return rx_lst.size () > 0;
-}
+    return rx_lst.size () > 0;
+  }
 
-Array<bool>
-regexp::is_match (const string_vector& buffer)
-{
-  octave_idx_type len = buffer.numel ();
+  Array<bool>
+  regexp::is_match (const string_vector& buffer)
+  {
+    octave_idx_type len = buffer.numel ();
 
-  Array<bool> retval (dim_vector (len, 1));
+    Array<bool> retval (dim_vector (len, 1));
 
-  for (octave_idx_type i = 0; i < buffer.numel (); i++)
-    retval(i) = is_match (buffer(i));
+    for (octave_idx_type i = 0; i < buffer.numel (); i++)
+      retval(i) = is_match (buffer(i));
 
-  return retval;
-}
+    return retval;
+  }
 
-// Declare rep_token_t used in processing replacement string
-typedef struct
-{
-  size_t pos;
-  int num;
-} rep_token_t;
+  // Declare rep_token_t used in processing replacement string
+  typedef struct
+  {
+    size_t pos;
+    int num;
+  } rep_token_t;
 
-std::string
-regexp::replace (const std::string& buffer, const std::string& replacement)
-{
-  std::string retval;
+  std::string
+  regexp::replace (const std::string& buffer, const std::string& replacement)
+  {
+    std::string retval;
 
-  regexp::match_data rx_lst = match (buffer);
+    regexp::match_data rx_lst = match (buffer);
 
-  size_t num_matches = rx_lst.size ();
+    size_t num_matches = rx_lst.size ();
 
-  if (num_matches == 0)
-    {
-      retval = buffer;
-      return retval;
-    }
+    if (num_matches == 0)
+      {
+        retval = buffer;
+        return retval;
+      }
 
-  // Identify replacement tokens; build a vector of group numbers in
-  // the replacement string so that we can quickly calculate the size
-  // of the replacement.
+    // Identify replacement tokens; build a vector of group numbers in
+    // the replacement string so that we can quickly calculate the size
+    // of the replacement.
 
-  // FIXME: All code assumes that only 10 tokens ($0-$9) exist.
-  //        $11 represents $1 followed by the character '1' rather than
-  //        the eleventh capture buffer.
+    // FIXME: All code assumes that only 10 tokens ($0-$9) exist.
+    //        $11 represents $1 followed by the character '1' rather than
+    //        the eleventh capture buffer.
 
-  std::string repstr = replacement;
-  std::vector<rep_token_t> tokens;
-  tokens.reserve (5);  // Reserve memory for 5 pattern replacements
+    std::string repstr = replacement;
+    std::vector<rep_token_t> tokens;
+    tokens.reserve (5);  // Reserve memory for 5 pattern replacements
 
-  for (size_t i=0; i < repstr.size (); i++)
-    {
-      if (repstr[i] == '\\')
-        {
-          if (i < repstr.size () - 1 && repstr[i+1] == '$')
-            {
-              repstr.erase (i,1);  // erase backslash
-              i++;                 // skip over '$'
-              continue;
-            }
-          if (i < repstr.size () - 1 && repstr[i+1] == '\\')
-            {
-              repstr.erase (i,1);  // erase 1st backslash
-              continue;
-            }
-        }
-      else if (repstr[i] == '$')
-        {
-          if (i < repstr.size () - 1 && isdigit (repstr[i+1]))
-            {
-              rep_token_t tmp_token;
+    for (size_t i=0; i < repstr.size (); i++)
+      {
+        if (repstr[i] == '\\')
+          {
+            if (i < repstr.size () - 1 && repstr[i+1] == '$')
+              {
+                repstr.erase (i,1);  // erase backslash
+                i++;                 // skip over '$'
+                continue;
+              }
+            if (i < repstr.size () - 1 && repstr[i+1] == '\\')
+              {
+                repstr.erase (i,1);  // erase 1st backslash
+                continue;
+              }
+          }
+        else if (repstr[i] == '$')
+          {
+            if (i < repstr.size () - 1 && isdigit (repstr[i+1]))
+              {
+                rep_token_t tmp_token;
 
-              tmp_token.pos = i;
-              tmp_token.num = repstr[i+1]-'0';
-              tokens.push_back (tmp_token);
-            }
-        }
-    }
+                tmp_token.pos = i;
+                tmp_token.num = repstr[i+1]-'0';
+                tokens.push_back (tmp_token);
+              }
+          }
+      }
 
-  std::string rep;
-  int num_tokens = tokens.size ();
+    std::string rep;
+    int num_tokens = tokens.size ();
 
-  if (num_tokens > 0)
-    {
-      // Determine replacement length
-      const size_t replen = repstr.size () - 2*num_tokens;
-      int delta = 0;
-      regexp::match_data::const_iterator p = rx_lst.begin ();
-      for (size_t i = 0; i < num_matches; i++)
-        {
-          OCTAVE_QUIT;
+    if (num_tokens > 0)
+      {
+        // Determine replacement length
+        const size_t replen = repstr.size () - 2*num_tokens;
+        int delta = 0;
+        regexp::match_data::const_iterator p = rx_lst.begin ();
+        for (size_t i = 0; i < num_matches; i++)
+          {
+            OCTAVE_QUIT;
 
-          double start = p->start ();
-          double end = p->end ();
+            double start = p->start ();
+            double end = p->end ();
 
-          const Matrix pairs (p->token_extents ());
-          size_t pairlen = 0;
-          for (int j = 0; j < num_tokens; j++)
-            {
-              if (tokens[j].num == 0)
-                pairlen += static_cast<size_t> (end - start) + 1;
-              else if (tokens[j].num <= pairs.rows ())
-                pairlen += static_cast<size_t> (pairs(tokens[j].num-1,1)
-                                                - pairs(tokens[j].num-1,0)) + 1;
-            }
-          delta += (static_cast<int> (replen + pairlen)
-                    - static_cast<int> (end - start + 1));
-          p++;
-        }
+            const Matrix pairs (p->token_extents ());
+            size_t pairlen = 0;
+            for (int j = 0; j < num_tokens; j++)
+              {
+                if (tokens[j].num == 0)
+                  pairlen += static_cast<size_t> (end - start) + 1;
+                else if (tokens[j].num <= pairs.rows ())
+                  pairlen += static_cast<size_t> (pairs(tokens[j].num-1,1)
+                                                  - pairs(tokens[j].num-1,0)) + 1;
+              }
+            delta += (static_cast<int> (replen + pairlen)
+                      - static_cast<int> (end - start + 1));
+            p++;
+          }
 
-      // Build replacement string
-      rep.reserve (buffer.size () + delta);
-      size_t from = 0;
-      p = rx_lst.begin ();
-      for (size_t i = 0; i < num_matches; i++)
-        {
-          OCTAVE_QUIT;
+        // Build replacement string
+        rep.reserve (buffer.size () + delta);
+        size_t from = 0;
+        p = rx_lst.begin ();
+        for (size_t i = 0; i < num_matches; i++)
+          {
+            OCTAVE_QUIT;
 
-          double start = p->start ();
-          double end = p->end ();
+            double start = p->start ();
+            double end = p->end ();
 
-          const Matrix pairs (p->token_extents ());
-          rep.append (&buffer[from], static_cast<size_t> (start - 1) - from);
-          from = static_cast<size_t> (end);
+            const Matrix pairs (p->token_extents ());
+            rep.append (&buffer[from], static_cast<size_t> (start - 1) - from);
+            from = static_cast<size_t> (end);
 
-          size_t cur_pos = 0;
+            size_t cur_pos = 0;
 
-          for (int j = 0; j < num_tokens; j++)
-            {
-              rep.append (&repstr[cur_pos], (tokens[j].pos) - cur_pos);
-              cur_pos = tokens[j].pos+2;
+            for (int j = 0; j < num_tokens; j++)
+              {
+                rep.append (&repstr[cur_pos], (tokens[j].pos) - cur_pos);
+                cur_pos = tokens[j].pos+2;
 
-              int k = tokens[j].num;
-              if (k == 0)
-                {
-                  // replace with entire match
-                  rep.append (&buffer[static_cast<size_t> (end - 1)],
-                              static_cast<size_t> (end - start) + 1);
-                }
-              else if (k <= pairs.rows ())
-                {
-                  // replace with group capture
-                  rep.append (&buffer[static_cast<size_t> (pairs(k-1,0)-1)],
-                              static_cast<size_t> (pairs(k-1,1)
-                                                   - pairs(k-1,0)) + 1);
-                }
-              else
-                {
-                  // replace with nothing
-                }
-            }
-          if (cur_pos < repstr.size ())
-            rep.append (&repstr[cur_pos], repstr.size () - cur_pos);
+                int k = tokens[j].num;
+                if (k == 0)
+                  {
+                    // replace with entire match
+                    rep.append (&buffer[static_cast<size_t> (end - 1)],
+                                static_cast<size_t> (end - start) + 1);
+                  }
+                else if (k <= pairs.rows ())
+                  {
+                    // replace with group capture
+                    rep.append (&buffer[static_cast<size_t> (pairs(k-1,0)-1)],
+                                static_cast<size_t> (pairs(k-1,1)
+                                                     - pairs(k-1,0)) + 1);
+                  }
+                else
+                  {
+                    // replace with nothing
+                  }
+              }
+            if (cur_pos < repstr.size ())
+              rep.append (&repstr[cur_pos], repstr.size () - cur_pos);
 
-          p++;
-        }
-      rep.append (&buffer[from], buffer.size () - from);
-    }
-  else
-    {
-      // Determine repstr length
-      const size_t replen = repstr.size ();
-      int delta = 0;
-      regexp::match_data::const_iterator p = rx_lst.begin ();
-      for (size_t i = 0; i < num_matches; i++)
-        {
-          OCTAVE_QUIT;
-          delta += static_cast<int> (replen)
-                   - static_cast<int> (p->end () - p->start () + 1);
-          p++;
-        }
+            p++;
+          }
+        rep.append (&buffer[from], buffer.size () - from);
+      }
+    else
+      {
+        // Determine repstr length
+        const size_t replen = repstr.size ();
+        int delta = 0;
+        regexp::match_data::const_iterator p = rx_lst.begin ();
+        for (size_t i = 0; i < num_matches; i++)
+          {
+            OCTAVE_QUIT;
+            delta += static_cast<int> (replen)
+              - static_cast<int> (p->end () - p->start () + 1);
+            p++;
+          }
 
-      // Build replacement string
-      rep.reserve (buffer.size () + delta);
-      size_t from = 0;
-      p = rx_lst.begin ();
-      for (size_t i = 0; i < num_matches; i++)
-        {
-          OCTAVE_QUIT;
-          rep.append (&buffer[from],
-                      static_cast<size_t> (p->start () - 1) - from);
-          from = static_cast<size_t> (p->end ());
-          rep.append (repstr);
-          p++;
-        }
-      rep.append (&buffer[from], buffer.size () - from);
-    }
+        // Build replacement string
+        rep.reserve (buffer.size () + delta);
+        size_t from = 0;
+        p = rx_lst.begin ();
+        for (size_t i = 0; i < num_matches; i++)
+          {
+            OCTAVE_QUIT;
+            rep.append (&buffer[from],
+                        static_cast<size_t> (p->start () - 1) - from);
+            from = static_cast<size_t> (p->end ());
+            rep.append (repstr);
+            p++;
+          }
+        rep.append (&buffer[from], buffer.size () - from);
+      }
 
-  retval = rep;
-  return retval;
+    retval = rep;
+    return retval;
+  }
 }
diff --git a/liboctave/util/lo-regexp.h b/liboctave/util/lo-regexp.h
--- a/liboctave/util/lo-regexp.h
+++ b/liboctave/util/lo-regexp.h
@@ -30,262 +30,309 @@ along with Octave; see the file COPYING.
 #include <sstream>
 #include <string>
 
 #include "Array.h"
 #include "Matrix.h"
 #include "base-list.h"
 #include "str-vec.h"
 
-class
-OCTAVE_API
-regexp
+namespace octave
 {
-public:
-
-  class opts;
-  class match_data;
-
-  regexp (const std::string& pat = "",
-          const regexp::opts& opt = regexp::opts (),
-          const std::string& w = "regexp")
-    : pattern (pat), options (opt), data (0), named_pats (),
-      nnames (0), named_idx (), who (w)
-  {
-    compile_internal ();
-  }
-
-  regexp (const regexp& rx)
-    : pattern (rx.pattern), data (rx.data), named_pats (rx.named_pats),
-      nnames (rx.nnames), named_idx (rx.named_idx)
-  { }
-
-  regexp& operator = (const regexp& rx)
-  {
-    if (this != &rx)
-      {
-        pattern = rx.pattern;
-        data = rx.data;
-        named_pats = rx.named_pats;
-        nnames = rx.nnames;
-        named_idx = rx.named_idx;
-      }
-
-    return *this;
-  }
-
-  ~regexp (void) { free (); }
-
-  void compile (const std::string& pat,
-                const regexp::opts& opt = regexp::opts ())
-  {
-    pattern = pat;
-    options = opt;
-    compile_internal ();
-  }
-
-  match_data match (const std::string& buffer);
-
-  bool is_match (const std::string& buffer);
-
-  Array<bool> is_match (const string_vector& buffer);
-
-  std::string replace (const std::string& buffer,
-                       const std::string& replacement);
-
-  class opts
+  class
+  OCTAVE_API
+  regexp
   {
   public:
 
-    opts (void)
-      : x_case_insensitive (false), x_dotexceptnewline (false),
-        x_emptymatch (false), x_freespacing (false), x_lineanchors (false),
-        x_once (false) { }
+    class opts;
+    class match_data;
+
+    regexp (const std::string& pat = "",
+            const regexp::opts& opt = regexp::opts (),
+            const std::string& w = "regexp")
+      : pattern (pat), options (opt), data (0), named_pats (),
+      nnames (0), named_idx (), who (w)
+    {
+      compile_internal ();
+    }
+
+    regexp (const regexp& rx)
+      : pattern (rx.pattern), data (rx.data), named_pats (rx.named_pats),
+      nnames (rx.nnames), named_idx (rx.named_idx)
+      { }
 
-    opts (const opts& o)
-      : x_case_insensitive (o.x_case_insensitive),
-        x_dotexceptnewline (o.x_dotexceptnewline),
-        x_emptymatch (o.x_emptymatch),
-        x_freespacing (o.x_freespacing),
-        x_lineanchors (o.x_lineanchors),
-        x_once (o.x_once)
-    { }
+    regexp& operator = (const regexp& rx)
+      {
+        if (this != &rx)
+          {
+            pattern = rx.pattern;
+            data = rx.data;
+            named_pats = rx.named_pats;
+            nnames = rx.nnames;
+            named_idx = rx.named_idx;
+          }
+
+        return *this;
+      }
+
+    ~regexp (void) { free (); }
+
+    void compile (const std::string& pat,
+                  const regexp::opts& opt = regexp::opts ())
+    {
+      pattern = pat;
+      options = opt;
+      compile_internal ();
+    }
+
+    match_data match (const std::string& buffer);
+
+    bool is_match (const std::string& buffer);
 
-    opts& operator = (const opts& o)
+    Array<bool> is_match (const string_vector& buffer);
+
+    std::string replace (const std::string& buffer,
+                         const std::string& replacement);
+
+    static regexp::match_data
+    match (const std::string& pat, const std::string& buffer,
+           const regexp::opts& opt = regexp::opts (),
+           const std::string& who = "regexp")
+    {
+      regexp rx (pat, opt, who);
+
+      return rx.match (buffer);
+    }
+
+    static bool
+    is_match (const std::string& pat, const std::string& buffer,
+              const regexp::opts& opt = regexp::opts (),
+              const std::string& who = "regexp")
     {
-      if (this != &o)
-        {
-          x_case_insensitive = o.x_case_insensitive;
-          x_dotexceptnewline = o.x_dotexceptnewline;
-          x_emptymatch = o.x_emptymatch;
-          x_freespacing = o.x_freespacing;
-          x_lineanchors = o.x_lineanchors;
-          x_once = o.x_once;
-        }
+      regexp rx (pat, opt, who);
+
+      return rx.is_match (buffer);
+    }
+
+    static Array<bool>
+    is_match (const std::string& pat, const string_vector& buffer,
+              const regexp::opts& opt = regexp::opts (),
+              const std::string& who = "regexp")
+    {
+      regexp rx (pat, opt, who);
 
-      return *this;
+      return rx.is_match (buffer);
+    }
+
+    static std::string
+    replace (const std::string& pat, const std::string& buffer,
+             const std::string& replacement,
+             const regexp::opts& opt = regexp::opts (),
+             const std::string& who = "regexp")
+    {
+      regexp rx (pat, opt, who);
+
+      return rx.replace (buffer, replacement);
     }
 
-    ~opts (void) { }
+    class opts
+    {
+    public:
+
+      opts (void)
+        : x_case_insensitive (false), x_dotexceptnewline (false),
+          x_emptymatch (false), x_freespacing (false), x_lineanchors (false),
+          x_once (false) { }
+
+      opts (const opts& o)
+        : x_case_insensitive (o.x_case_insensitive),
+          x_dotexceptnewline (o.x_dotexceptnewline),
+          x_emptymatch (o.x_emptymatch),
+          x_freespacing (o.x_freespacing),
+          x_lineanchors (o.x_lineanchors),
+          x_once (o.x_once)
+      { }
+
+      opts& operator = (const opts& o)
+      {
+        if (this != &o)
+          {
+            x_case_insensitive = o.x_case_insensitive;
+            x_dotexceptnewline = o.x_dotexceptnewline;
+            x_emptymatch = o.x_emptymatch;
+            x_freespacing = o.x_freespacing;
+            x_lineanchors = o.x_lineanchors;
+            x_once = o.x_once;
+          }
+
+        return *this;
+      }
+
+      ~opts (void) { }
+
+      void case_insensitive (bool val) { x_case_insensitive = val; }
+      void dotexceptnewline (bool val) { x_dotexceptnewline = val; }
+      void emptymatch (bool val) { x_emptymatch = val; }
+      void freespacing (bool val) { x_freespacing = val; }
+      void lineanchors (bool val) { x_lineanchors = val; }
+      void once (bool val) { x_once = val; }
+
+      bool case_insensitive (void) const { return x_case_insensitive; }
+      bool dotexceptnewline (void) const { return x_dotexceptnewline; }
+      bool emptymatch (void) const { return x_emptymatch; }
+      bool freespacing (void) const { return x_freespacing; }
+      bool lineanchors (void) const { return x_lineanchors; }
+      bool once (void) const { return x_once; }
+
+    private:
+
+      bool x_case_insensitive;
+      bool x_dotexceptnewline;
+      bool x_emptymatch;
+      bool x_freespacing;
+      bool x_lineanchors;
+      bool x_once;
+    };
+
+    class match_element
+    {
+    public:
 
-    void case_insensitive (bool val) { x_case_insensitive = val; }
-    void dotexceptnewline (bool val) { x_dotexceptnewline = val; }
-    void emptymatch (bool val) { x_emptymatch = val; }
-    void freespacing (bool val) { x_freespacing = val; }
-    void lineanchors (bool val) { x_lineanchors = val; }
-    void once (bool val) { x_once = val; }
+      match_element (const string_vector& nt, const string_vector& t,
+                     const std::string& ms, const Matrix& te,
+                     double s, double e)
+        : x_match_string (ms), x_named_tokens (nt), x_tokens (t),
+          x_token_extents (te), x_start (s), x_end (e)
+      { }
+
+      match_element (const match_element &a)
+        : x_match_string (a.x_match_string),
+          x_named_tokens (a.x_named_tokens), x_tokens (a.x_tokens),
+          x_token_extents (a.x_token_extents),
+          x_start (a.x_start), x_end (a.x_end)
+      { }
+
+      std::string match_string (void) const { return x_match_string; }
+      string_vector named_tokens (void) const { return x_named_tokens; }
+      string_vector tokens (void) const { return x_tokens; }
+      Matrix token_extents (void) const { return x_token_extents; }
+      double start (void) const { return x_start; }
+      double end (void) const { return x_end; }
+
+    private:
+
+      std::string x_match_string;
+      string_vector x_named_tokens;
+      string_vector x_tokens;
+      Matrix x_token_extents;
+      double x_start;
+      double x_end;
+    };
 
-    bool case_insensitive (void) const { return x_case_insensitive; }
-    bool dotexceptnewline (void) const { return x_dotexceptnewline; }
-    bool emptymatch (void) const { return x_emptymatch; }
-    bool freespacing (void) const { return x_freespacing; }
-    bool lineanchors (void) const { return x_lineanchors; }
-    bool once (void) const { return x_once; }
+    class match_data : public base_list<match_element>
+    {
+    public:
+
+      match_data (void)
+        : base_list<match_element> (), named_pats ()
+      { }
+
+      match_data (const std::list<match_element>& l, const string_vector& np)
+        : base_list<match_element> (l), named_pats (np)
+      { }
+
+      match_data (const match_data& rx_lst)
+        : base_list<match_element> (rx_lst),
+        named_pats (rx_lst.named_pats)
+      { }
+
+      match_data& operator = (const match_data& rx_lst)
+      {
+        if (this != &rx_lst)
+          {
+            base_list<match_element>::operator = (rx_lst);
+            named_pats = rx_lst.named_pats;
+          }
+
+        return *this;
+      }
+
+      ~match_data (void) { }
+
+      string_vector named_patterns (void) { return named_pats; }
+
+    private:
+
+      string_vector named_pats;
+    };
 
   private:
 
-    bool x_case_insensitive;
-    bool x_dotexceptnewline;
-    bool x_emptymatch;
-    bool x_freespacing;
-    bool x_lineanchors;
-    bool x_once;
-  };
-
-  class match_element
-  {
-  public:
-
-    match_element (const string_vector& nt, const string_vector& t,
-                   const std::string& ms, const Matrix& te,
-                   double s, double e)
-      : x_match_string (ms), x_named_tokens (nt), x_tokens (t),
-        x_token_extents (te), x_start (s), x_end (e)
-    { }
+    // The pattern we've been asked to match.
+    std::string pattern;
 
-    match_element (const match_element &a)
-      : x_match_string (a.x_match_string),
-        x_named_tokens (a.x_named_tokens), x_tokens (a.x_tokens),
-        x_token_extents (a.x_token_extents),
-        x_start (a.x_start), x_end (a.x_end)
-    { }
-
-    std::string match_string (void) const { return x_match_string; }
-    string_vector named_tokens (void) const { return x_named_tokens; }
-    string_vector tokens (void) const { return x_tokens; }
-    Matrix token_extents (void) const { return x_token_extents; }
-    double start (void) const { return x_start; }
-    double end (void) const { return x_end; }
-
-  private:
+    opts options;
 
-    std::string x_match_string;
-    string_vector x_named_tokens;
-    string_vector x_tokens;
-    Matrix x_token_extents;
-    double x_start;
-    double x_end;
-  };
-
-  class match_data : public octave_base_list<match_element>
-  {
-  public:
-
-    match_data (void)
-      : octave_base_list<match_element> (), named_pats ()
-    { }
+    // Internal data describing the regular expression.
+    void *data;
 
-    match_data (const std::list<match_element>& l, const string_vector& np)
-      : octave_base_list<match_element> (l), named_pats (np)
-    { }
-
-    match_data (const match_data& rx_lst)
-      : octave_base_list<match_element> (rx_lst),
-        named_pats (rx_lst.named_pats)
-    { }
+    std::string m;
+    string_vector named_pats;
+    int nnames;
+    Array<int> named_idx;
+    std::string who;
 
-    match_data& operator = (const match_data& rx_lst)
-    {
-      if (this != &rx_lst)
-        {
-          octave_base_list<match_element>::operator = (rx_lst);
-          named_pats = rx_lst.named_pats;
-        }
-
-      return *this;
-    }
-
-    ~match_data (void) { }
-
-    string_vector named_patterns (void) { return named_pats; }
+    void free (void);
 
-  private:
-
-    string_vector named_pats;
+    void compile_internal (void);
   };
-
-private:
-
-  // The pattern we've been asked to match.
-  std::string pattern;
-
-  opts options;
+}
 
-  // Internal data describing the regular expression.
-  void *data;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  std::string m;
-  string_vector named_pats;
-  int nnames;
-  Array<int> named_idx;
-  std::string who;
+OCTAVE_DEPRECATED ("use 'octave::regexp' instead")
+typedef octave::regexp regexp;
 
-  void free (void);
-
-  void compile_internal (void);
-};
-
+OCTAVE_DEPRECATED ("use 'octave::regexp::match' instead")
 inline regexp::match_data
 regexp_match (const std::string& pat,
               const std::string& buffer,
               const regexp::opts& opt = regexp::opts (),
               const std::string& who = "regexp")
 {
-  regexp rx (pat, opt, who);
-
-  return rx.match (buffer);
+  return octave::regexp::match (pat, buffer, opt, who);
 }
 
+OCTAVE_DEPRECATED ("use 'octave::regexp::is_match' instead")
 inline bool
 is_regexp_match (const std::string& pat,
                  const std::string& buffer,
                  const regexp::opts& opt = regexp::opts (),
                  const std::string& who = "regexp")
 {
-  regexp rx (pat, opt, who);
-
-  return rx.is_match (buffer);
+  return octave::regexp::is_match (pat, buffer, opt, who);
 }
 
+OCTAVE_DEPRECATED ("use 'octave::regexp::is_match' instead")
 inline Array<bool>
 is_regexp_match (const std::string& pat,
                  const string_vector& buffer,
                  const regexp::opts& opt = regexp::opts (),
                  const std::string& who = "regexp")
 {
-  regexp rx (pat, opt, who);
-
-  return rx.is_match (buffer);
+  return octave::regexp::is_match (pat, buffer, opt, who);
 }
 
+OCTAVE_DEPRECATED ("use 'octave::regexp::replace' instead")
 inline std::string
 regexp_replace (const std::string& pat,
                 const std::string& buffer,
                 const std::string& replacement,
                 const regexp::opts& opt = regexp::opts (),
                 const std::string& who = "regexp")
 {
-  regexp rx (pat, opt, who);
-
-  return rx.replace (buffer, replacement);
+  return octave::regexp::replace (pat, buffer, replacement, opt, who);
 }
 
 #endif
+
+#endif
