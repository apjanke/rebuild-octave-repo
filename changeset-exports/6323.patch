# HG changeset patch
# User jwe
# Date 1171680663 0
#      Sat Feb 17 02:51:03 2007 +0000
# Node ID ea65de49e18ef7952a600d15c560d3a3859b1e1f
# Parent  723a32c8ee10aa1c8d0c51ea24c0eb7ea26ed960
[project @ 2007-02-17 02:51:02 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,14 @@
+2007-02-16  John W. Eaton  <jwe@octave.org>
+
+	* oct-shlib.h (octave_shlib::relative): New data member.
+	(octave_shlib::mark_relative, octave_shlib::is_relative):
+	New functions.
+
 2007-02-16  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* lo-sysdep.cc (octave_popen2): New function to simulate popen2 on
 	windows platform.
 	* lo-sysdep.h (octave_popen2): Declare it.
 	* oct-syscalls.cc (octave_syscalls::popen2): New function.
 	* oct-syscalls.h (octave_syscalls::popen2): Declare it.
 
diff --git a/liboctave/oct-shlib.h b/liboctave/oct-shlib.h
--- a/liboctave/oct-shlib.h
+++ b/liboctave/oct-shlib.h
@@ -45,19 +45,20 @@ OCTAVE_API
 octave_shlib
 {
 public:
 
   typedef std::string (*name_mangler) (const std::string&);
 
   typedef void (*close_hook) (const std::string&);
 
-  octave_shlib (void) : rep (make_shlib ()) { }
+  octave_shlib (void) : relative (false), rep (make_shlib ()) { }
 
-  octave_shlib (const std::string& f) : rep (make_shlib ()) { open (f); }
+  octave_shlib (const std::string& f)
+    : relative (false), rep (make_shlib ()) { open (f); }
 
   virtual ~octave_shlib (void)
     {
       if (rep && --rep->count == 0)
 	{
 	  delete rep;
 	  rep = 0;
 	}
@@ -97,16 +98,20 @@ public:
     { rep->close (cl_hook); }
 
   virtual bool remove (const std::string& fcn_name)
     { return rep->remove (fcn_name); }
 
   virtual bool is_out_of_date (void) const
     { return rep->is_out_of_date (); }
 
+  void mark_relative (void) { relative = true; }
+
+  bool is_relative (void) const { return relative; }
+
   virtual int number_of_functions_loaded (void) const
     { return rep->number_of_functions_loaded (); }
 
   virtual std::string file_name (void) const
     { return rep->file_name (); }
 
   virtual octave_time time_loaded (void) const
     { return rep->time_loaded (); }
@@ -114,16 +119,19 @@ public:
 protected:
 
   octave_shlib (const octave_xshlib&) : rep (0) { }
 
   virtual bool is_open (void) const { return rep->is_open (); }
 
   static octave_shlib *make_shlib (void);
 
+  // TRUE if this function was found from a relative path element.
+  bool relative;
+
   union
     {
       octave_shlib *rep;
       int count;
     };
 };
 
 #endif
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+2007-02-16  John W. Eaton  <jwe@octave.org>
+
+	* miscellaneous/Makefile.in (SOURCES): Remove popen2.m from the list.
+
 2007-02-16  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* miscellaneous/popen2.m: Remove as replaced with builtin.
 
 2007-02-16  Muthiah Annamalai  <muthuspost@gmail.com>
 
 	* specfun/nchoosek.m: Check nargin.
 
diff --git a/scripts/miscellaneous/Makefile.in b/scripts/miscellaneous/Makefile.in
--- a/scripts/miscellaneous/Makefile.in
+++ b/scripts/miscellaneous/Makefile.in
@@ -22,17 +22,17 @@ INSTALL_DATA = @INSTALL_DATA@
 
 SOURCES = ans.m bincoeff.m bug_report.m bunzip2.m comma.m \
   compare_versions.m computer.m copyfile.m cputime.m \
   delete.m dir.m doc.m dos.m dump_prefs.m \
   fileattrib.m fileparts.m flops.m fullfile.m getfield.m gunzip.m \
   inputname.m ispc.m isunix.m license.m list_primes.m ls.m \
   ls_command.m menu.m mex.m mexext.m mkoctfile.m movefile.m \
   news.m not.m orderfields.m pack.m paren.m parseparams.m \
-  popen2.m semicolon.m setfield.m single.m substruct.m tar.m \
+  semicolon.m setfield.m single.m substruct.m tar.m \
   tempdir.m tempname.m texas_lotto.m unix.m unpack.m untar.m \
   unzip.m ver.m version.m warning_ids.m xor.m zip.m
 
 DISTFILES = Makefile.in $(SOURCES)
 
 FCN_FILES = $(addprefix $(srcdir)/, $(SOURCES))
 FCN_FILES_NO_DIR = $(notdir $(FCN_FILES))
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,20 +1,91 @@
+2007-02-16  John W. Eaton  <jwe@octave.org>
+
+	* dynamic-ld.cc (octave_dynamic_loader::do_load_oct): Clear
+	function if original was loaded from relative path and the name
+	can no longer be found in path.  Mark files found from relative
+	path as relative.
+	(clear): Only warn if there is more than one function to clear.
+
+	* variables.cc (symbol_out_of_date): Don't ignore return value in
+	call to octave_env::make_absolute.
+	(symbol_out_of_date): Clear symbol if original was loaded from
+	relative path and name can no longer be found in path.
+
+	* dynamic-ld.cc (octave_dynamic_loader::do_load_oct):
+	Also check whether new file is same as the old file.
+
+	* utils.cc (same_file): Move here from variables.cc.
+	* utils.h: (same_file): Provide decl.
+
+	* parse.y (frob_function): Stash parent function name if parsing
+	nested function.
+
+	* ov-fcn-handle.cc (make_fcn_handle): Pass current function name
+	as parent in call to lookup_function.
+
+	* ov-fcn.h (octave_function::parent_fcn_name): New virtual function.
+
+	* ov-usr-fcn.h (octave_user_function::parent_name): New data member.
+	(octave_user_function::stash_parent_function_name,
+	octave_user_function::parent_function_name): New methods.
+	* ov-usr-fcn.cc (octave_user_function::octave_user_function):
+	Initialize parent_name.
+
+	* variables.h, variables.cc (lookup_function): New arg, parent.
+	If not empty, try this first for lookup.
+
+	* dynamic-ld.cc (octave_dynamic_loader::do_load_mex): If doing
+	path lookup, check relative status. Pass relative to oct_file_in_path.
+	(octave_dynamic_loader::do_load_mex): Likewise, for mex_file_in_path
+
+	* defun-int.h, defun.cc (install_mex_function): New arg, relative.
+	(install_dld_function): Likewise.
+	(octave_dld_fcn_installer): Likewise.
+	(DEFINE_FUNX_INSTALLER_FUN3): Pass relative to install_dld_function.
+
+	* dynamic-ld.h (octave_dynamic_loader::load_oct,
+	octave_dynamic_loader::load_mex,
+	octave_dynamic_loader::do_load_oct
+	octave_dynamic_loader::do_load_mex): New arg, relative.
+
+	* dirfns.h (Vcurrent_directory): Delete unused variable.
+
+	* variables.cc (symbol_out_of_date): Also compare function time
+	stamp to Vlast_chdir_time if function is from relative lookup.
+
+	* dirfns.cc (Vlast_chdir_time): New variable.
+	(octave_change_to_directory): Update it if chdir succeeds.
+	* dirfns.h (Vlast_chdir_time): Provide decl.
+
+	* ov-fcn.h (octave_function::relative): New data member.
+	(octave_function::mark_relative, octave_function::is_relative):
+	New functions.
+
+	* parse.y (fcn_file_from_relative_lookup): New static variable.
+	(load_fcn_from_file): Note whether function file was found from
+	relative path element.
+	(frob_function): Maybe mark function as relative.
+
+	* parse.y (lookup_autoload): Don't call octave_env::make_absolute
+	on return value.
+	* variables.cc (symbol_out_of_date): Make name absolute after call
+	to lookup_autoload.
+
+	* input.cc (interactive_input): New arg, DEBUG.  Don't call
+	drawnow if debugging.
+	(get_user_input): Pass DEBUG to interactive_input.
+
 2007-02-16  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* syscalls.cc (Fpopen2): New function.
 	(pipe): Modify to return input and output file descriptor
 	seperately rather than in a list.
 	
-2007-02-16  John W. Eaton  <jwe@octave.org>
-
-	* input.cc (interactive_input): New arg, DEBUG.  Don't call
-	drawnow if debugging.
-	(get_user_input): Pass DEBUG to interactive_input.
-
 2007-02-16  Muthiah Annamalai  <muthuspost@gmail.com>
 
 	* debug.cc (Fdbtype): Improve compatibility.
 
 2007-02-16  John W. Eaton  <jwe@octave.org>
 
 	* toplev.cc (wait_for_input): New function.
 	(run_command_and_return_output): Use it instead of napping.
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -45,37 +45,39 @@ install_builtin_mapper (octave_mapper *m
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn = false,
 			  bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
-		      const std::string& doc, bool is_text_fcn = false);
+		      const std::string& doc, bool is_text_fcn = false,
+		      bool relative = false);
 
 extern OCTINTERP_API void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-		      const octave_shlib& shl, bool is_text_fcn = false);
+		      const octave_shlib& shl, bool is_text_fcn = false,
+		      bool relative = false);
 
 extern OCTINTERP_API void
 alias_builtin (const std::string& alias, const std::string& name);
 
 #define DECLARE_FUNX(name, args_name, nargout_name) \
   OCTAVE_EXPORT octave_value_list \
   name (const octave_value_list& args_name, int nargout_name)
 
 #define DECLARE_FUN(name, args_name, nargout_name) \
   DECLARE_FUNX (F ## name, args_name, nargout_name)
 
 // Define the code that will be used to insert the new function into
 // the symbol table.  We look for this name instead of the actual
 // function so that we can easily install the doc std::string too.
 
-typedef bool (*octave_dld_fcn_installer) (const octave_shlib&);
+typedef bool (*octave_dld_fcn_installer) (const octave_shlib&, bool relative);
 
 #define DEFINE_FUN_INSTALLER_FUN(name, doc) \
   DEFINE_FUN_INSTALLER_FUN2(name, doc, CXX_ABI)
 
 #define DEFINE_FUN_INSTALLER_FUN2(name, doc, cxx_abi) \
   DEFINE_FUN_INSTALLER_FUN3(name, doc, cxx_abi)
 
 #define DEFINE_FUN_INSTALLER_FUN3(name, doc, cxx_abi) \
@@ -86,20 +88,20 @@ typedef bool (*octave_dld_fcn_installer)
 
 #define DEFINE_FUNX_INSTALLER_FUN2(name, fname, fsname, doc, cxx_abi) \
   DEFINE_FUNX_INSTALLER_FUN3(name, fname, fsname, doc, cxx_abi)
 
 #define DEFINE_FUNX_INSTALLER_FUN3(name, fname, fsname, doc, cxx_abi) \
   extern "C" \
   OCTAVE_EXPORT \
   bool \
-  fsname ## _ ## cxx_abi (const octave_shlib& shl) \
+  fsname ## _ ## cxx_abi (const octave_shlib& shl, bool relative) \
   { \
     check_version (OCTAVE_API_VERSION, name); \
-    install_dld_function (fname, name, shl, doc); \
+    install_dld_function (fname, name, shl, doc, false, relative); \
     return error_state ? false : true; \
   }
 
 // MAKE_BUILTINS is defined to extract function names and related
 // information and create the *.df files that are eventually used to
 // create the builtins.cc file.
 
 #if defined (MAKE_BUILTINS)
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -160,51 +160,65 @@ install_builtin_function (octave_builtin
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
-		      const std::string& doc, bool is_text_fcn)
+		      const std::string& doc, bool is_text_fcn,
+		      bool relative)
 {
   symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::DLD_FUNCTION;
 
   if (is_text_fcn)
     t |= symbol_record::COMMAND;
 
   sym_rec->unprotect ();
-  sym_rec->define (new octave_dld_function (f, shl, name, doc), t);
+
+  octave_dld_function *df = new octave_dld_function (f, shl, name, doc);
+
+  if (relative)
+    df->mark_relative ();
+
+  sym_rec->define (df, t);
   sym_rec->document (doc);
 
   // Also insert the full name in the symbol table.  This way, we can
   // properly cope with changes to LOAD_PATH.
 
   symbol_record *full_sr = fbi_sym_tab->lookup (shl.file_name (), true);
 
   full_sr->alias (sym_rec, true);
   full_sr->hide ();
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-		      const octave_shlib& shl, bool is_text_fcn)
+		      const octave_shlib& shl, bool is_text_fcn,
+		      bool relative)
 {
   symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::MEX_FUNCTION;
 
   if (is_text_fcn)
     t |= symbol_record::COMMAND;
 
   sym_rec->unprotect ();
-  sym_rec->define (new octave_mex_function (fptr, fmex, shl, name), t);
+
+  octave_mex_function *mf = new octave_mex_function (fptr, fmex, shl, name);
+
+  if (relative)
+    mf->mark_relative ();
+
+  sym_rec->define (mf, t);
 
   // Also insert the full name in the symbol table.  This way, we can
   // properly cope with changes to LOAD_PATH.
 
   symbol_record *full_sr = fbi_sym_tab->lookup (shl.file_name (), true);
 
   full_sr->alias (sym_rec, true);
   full_sr->hide ();
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -64,23 +64,28 @@ 02110-1301, USA.
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means we ask for confirmation before recursively removing a
 // directory tree.
 static bool Vconfirm_recursive_rmdir = true;
 
+// The time we last time we changed directories.
+octave_time Vlast_chdir_time = 0.0;
+
 static int
 octave_change_to_directory (const std::string& newdir)
 {
   int cd_ok = octave_env::chdir (file_ops::tilde_expand (newdir));
 
   if (cd_ok)
     {
+      Vlast_chdir_time.stamp ();
+
       // FIXME -- should this be handled as a list of functions
       // to call so users can add their own chdir handlers?
 
       load_path::update ();
     }
   else
     {
       using namespace std;
diff --git a/src/dirfns.h b/src/dirfns.h
--- a/src/dirfns.h
+++ b/src/dirfns.h
@@ -23,22 +23,25 @@ 02110-1301, USA.
 
 #if !defined (octave_dirfns_h)
 #define octave_dirfns_h 1
 
 #include <ctime>
 
 #include <string>
 
+#include "oct-time.h"
+
 extern std::string polite_directory_format (const std::string&);
 extern std::string base_pathname (const std::string&);
 extern std::string make_absolute (const std::string&, const std::string&);
 extern std::string get_working_directory (const std::string&);
 
-extern std::string Vcurrent_directory;
+// The time we last time we changed directories.
+extern octave_time Vlast_chdir_time;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -22,16 +22,17 @@ 02110-1301, USA.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <list>
 
+#include "oct-env.h"
 #include "oct-time.h"
 #include "file-stat.h"
 
 #include <defaults.h>
 
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "parse.h"
@@ -297,108 +298,141 @@ void do_clear_function (const std::strin
   curr_sym_tab->clear (fcn_name);
 
   if (curr_sym_tab != top_level_sym_tab)
     top_level_sym_tab->clear (fcn_name);
 
   fbi_sym_tab->clear (fcn_name);
 }
 
+static void
+clear (octave_shlib& oct_file)
+{
+  if (oct_file.number_of_functions_loaded () > 1)
+    warning_with_id ("Octave:reload-forces-clear",
+		     "reloading %s clears the following functions:",
+		     oct_file.file_name().c_str ());
+
+  octave_shlib_list::remove (oct_file, do_clear_function);
+}
+
 bool
 octave_dynamic_loader::do_load_oct (const std::string& fcn_name,
-				    const std::string& file_name)
+				    const std::string& file_name,
+				    bool relative)
 {
   bool retval = false;
 
   octave_shlib oct_file;
 
   unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
 
   unwind_protect_bool (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   void *function
     = octave_shlib_list::search (fcn_name, oct_file, mangle_name);
 
   if (! error_state)
     {
-      if (function && oct_file.is_out_of_date ())
+      if (function
+	  && (! same_file (file_name, oct_file.file_name ())
+	      || oct_file.is_out_of_date ()))
 	{
-	  int n = oct_file.number_of_functions_loaded ();
-
-	  if (n > 0)
-	    warning_with_id ("Octave:reload-forces-clear",
-			     "reloading %s clears the following functions:",
-			     oct_file.file_name().c_str ());
-
-	  octave_shlib_list::remove (oct_file, do_clear_function);
-
+	  clear (oct_file);
 	  function = 0;
 	}
 
       if (! function)
 	{
-	  std::string oct_file_name
-	    = file_name.empty () ? oct_file_in_path (fcn_name) : file_name;
+	  std::string oct_file_name = file_name;
+
+	  if (oct_file_name.empty ())
+	    {
+	      oct_file_name = oct_file_in_path (fcn_name);
+
+	      if (! oct_file_name.empty ())
+		relative = ! octave_env::absolute_pathname (oct_file_name);
+	    }
 
-	  if (! oct_file_name.empty ())
+	  if (oct_file_name.empty ())
+	    {
+	      if (oct_file.is_relative ())
+		{
+		  // Can't see this function from current
+		  // directory, so we should clear it.
+		  clear (oct_file);
+		  function = 0;
+		}
+	    }
+	  else
 	    {
 	      oct_file.open (oct_file_name);
 
 	      if (! error_state)
 		{
 		  if (oct_file)
 		    {
+		      if (relative)
+			oct_file.mark_relative ();
+
 		      octave_shlib_list::append (oct_file);
 
 		      function = oct_file.search (fcn_name, mangle_name);
 		    }
 		  else
 		    ::error ("%s is not a valid shared library",
 			     oct_file_name.c_str ());
 		}
 	    }
-
 	}
     }
 
   if (function)
     {
       octave_dld_fcn_installer f
 	= FCN_PTR_CAST (octave_dld_fcn_installer, function);
 
-      retval = f (oct_file);
+      retval = f (oct_file, relative);
 
       if (! retval)
 	::error ("failed to install .oct file function `%s'",
 		 fcn_name.c_str ());
     }
   
   unwind_protect::run_frame ("octave_dynamic_loader::do_load");
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
-				    const std::string& file_name)
+				    const std::string& file_name,
+				    bool relative)
 {
   bool retval = false;
 
   octave_shlib mex_file;
 
   unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
 
   unwind_protect_bool (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
-  std::string mex_file_name
-    = file_name.empty () ? mex_file_in_path (fcn_name) : file_name;
+  std::string mex_file_name = file_name;
+
+  if (mex_file_name.empty ())
+    {
+      mex_file_name = mex_file_in_path (fcn_name);
+
+      if (! mex_file_name.empty ())
+	relative = ! octave_env::absolute_pathname (mex_file_name);
+    }
 
   void *function = 0;
 
   bool have_fmex = false;
 
   if (! mex_file_name.empty ())
     {
       mex_file.open (mex_file_name);
@@ -429,17 +463,17 @@ octave_dynamic_loader::do_load_mex (cons
 	  else
 	    ::error ("%s is not a valid shared library",
 		     mex_file_name.c_str ());
 	}
     }
 
   if (function)
     {
-      install_mex_function (function, have_fmex, fcn_name, mex_file);
+      install_mex_function (function, have_fmex, fcn_name, mex_file, relative);
 
       retval = true;
     }
   else
     ::error ("failed to install .mex file function `%s'", fcn_name.c_str ());
   
   unwind_protect::run_frame ("octave_dynamic_loader::do_load");
 
@@ -462,26 +496,30 @@ octave_dynamic_loader::do_remove (const 
 	octave_shlib_list::remove (shl);
     }
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::load_oct (const std::string& fcn_name,
-				 const std::string& file_name)
+				 const std::string& file_name,
+				 bool relative)
 {
-  return (instance_ok ()) ? instance->do_load_oct (fcn_name, file_name) : false;
+  return (instance_ok ())
+    ? instance->do_load_oct (fcn_name, file_name, relative) : false;
 }
 
 bool
 octave_dynamic_loader::load_mex (const std::string& fcn_name,
-				 const std::string& file_name)
+				 const std::string& file_name,
+				 bool relative)
 {
-  return (instance_ok ()) ? instance->do_load_mex (fcn_name, file_name) : false;
+  return (instance_ok ())
+    ? instance->do_load_mex (fcn_name, file_name, relative) : false;
 }
 
 bool
 octave_dynamic_loader::remove (const std::string& fcn_name, octave_shlib& shl)
 {
   return (instance_ok ()) ? instance->do_remove (fcn_name, shl) : false;
 }
 
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -35,40 +35,44 @@ protected:
 
   octave_dynamic_loader (void) { }
 
 public:
 
   virtual ~octave_dynamic_loader (void) { }
 
   static bool load_oct (const std::string& fcn_name,
-			const std::string& file_name = std::string ());
+			const std::string& file_name = std::string (),
+			bool relative = false);
 
   static bool load_mex (const std::string& fcn_name,
-			const std::string& file_name = std::string ());
+			const std::string& file_name = std::string (),
+			bool relative = false);
 
   static bool remove (const std::string& fcn_name, octave_shlib& shl);
 
 private:
 
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
 
   static octave_dynamic_loader *instance;
 
   static bool instance_ok (void);
 
   bool do_load_oct (const std::string& fcn_name,
-		    const std::string& file_name = std::string ());
+		    const std::string& file_name = std::string (),
+		    bool relative = false);
 
   bool do_load_mex (const std::string& fcn_name,
-		    const std::string& file_name = std::string ());
+		    const std::string& file_name = std::string (),
+		    bool relative = false);
 
   bool do_remove (const std::string& fcn_name, octave_shlib& shl);
 
   static bool doing_load;
 
 protected:
 
   static std::string mangle_name (const std::string& name);
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -607,17 +607,19 @@ octave_fcn_handle::print_raw (std::ostre
 			   current_print_indent_level ());
 }
 
 octave_value
 make_fcn_handle (const std::string& nm)
 {
   octave_value retval;
 
-  octave_value f = lookup_function (nm);
+  octave_function *fcn = octave_call_stack::current ();
+
+  octave_value f = lookup_function (nm, fcn->name ());
 
   if (f.is_function ())
     retval = octave_value (new octave_fcn_handle (f, nm));
   else
     error ("error creating function handle \"@%s\"", nm.c_str ());
 
   return retval;
 }
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -56,16 +56,18 @@ public:
   bool is_function (void) const { return true; }
 
   virtual bool is_dynamically_loaded_function (void) const { return false; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
 
   virtual std::string fcn_file_name (void) const { return std::string (); }
 
+  virtual std::string parent_fcn_name (void) const { return std::string (); }
+
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
 
   virtual octave_time time_parsed (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
   virtual octave_time time_checked (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
@@ -74,31 +76,38 @@ public:
   virtual bool is_user_script (void) const { return false; }
 
   virtual bool is_user_function (void) const { return false; }
 
   virtual bool takes_varargs (void) const { return false; }
 
   virtual bool takes_var_return (void) const { return false; }
 
+  void mark_relative (void) { relative = true; }
+
+  bool is_relative (void) const { return relative; }
+
   std::string name (void) const { return my_name; }
 
   void document (const std::string& ds) { doc = ds; }
 
   std::string doc_string (void) const { return doc; }
 
   virtual void unload (void) { }
 
   virtual void accept (tree_walker&) { }
 
 protected:
 
   octave_function (const std::string& nm,
 		   const std::string& ds = std::string ())
-    : my_name (nm), doc (ds) { }
+    : relative (false), my_name (nm), doc (ds) { }
+
+  // TRUE if this function was found from a relative path element.
+  bool relative;
 
   // The name of this function.
   std::string my_name;
 
   // The help text for this function.
   std::string doc;
 
 private:
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -69,17 +69,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
   (tree_parameter_list *pl, tree_parameter_list *rl,
    tree_statement_list *cl, symbol_table *st)
   : octave_function (std::string (), std::string ()),
     param_list (pl), ret_list (rl), cmd_list (cl),
     sym_tab (st), lead_comm (), trail_comm (), file_name (),
-    t_parsed (static_cast<time_t> (0)),
+    parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (0), num_named_args (0),
     nested_function (false), inline_function (false), args_passed (),
     num_args_passed (0), symtab_entry (0), argn_sr (0),
     nargin_sr (0), nargout_sr (0), varargin_sr (0)
 {
   if (param_list)
     num_named_args = param_list->length ();
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -103,32 +103,36 @@ public:
   octave_user_function *user_function_value (bool = false) { return this; }
 
   octave_user_function *define_param_list (tree_parameter_list *t);
 
   octave_user_function *define_ret_list (tree_parameter_list *t);
 
   void stash_fcn_file_name (const std::string& nm);
 
+  void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
+
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave_time& t)
     {
       t_parsed = t;
       mark_fcn_file_up_to_date (t);
     }
 
   void stash_symtab_ptr (symbol_record *sr) { symtab_entry = sr; }
 
   std::string fcn_file_name (void) const { return file_name; }
 
+  std::string parent_fcn_name (void) const { return parent_name; }
+
   octave_time time_parsed (void) const { return t_parsed; }
 
   octave_time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
@@ -215,19 +219,22 @@ private:
   symbol_table *sym_tab;
 
   // The comments preceding the FUNCTION token.
   octave_comment_list *lead_comm;
 
   // The comments preceding the ENDFUNCTION token.
   octave_comment_list *trail_comm;
 
-  // The name of the file we parsed
+  // The name of the file we parsed.
   std::string file_name;
 
+  // The name of the parent function, if any.
+  std::string parent_name;
+
   // The time the file was parsed.
   octave_time t_parsed;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   octave_time t_checked;
 
   // True if this function came from a file that is considered to be a
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -113,16 +113,20 @@ std::stack<symbol_table*> symtab_context
 
 // Name of parent function when parsing function files that might
 // contain nested functions.
 std::string parent_function_name;
 
 // TRUE means we are in the process of autoloading a function.
 static bool autoloading = false;
 
+// TRUE means the current function file was found in a relative path
+// element.
+static bool fcn_file_from_relative_lookup = false;
+
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 // Generic error messages.
 static void
@@ -2478,16 +2482,22 @@ frob_function (const std::string& fname,
 	}
 
       octave_time now;
 
       fcn->stash_fcn_file_name (curr_fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
+      if (fcn_file_from_relative_lookup)
+	fcn->mark_relative ();
+
+      if (lexer_flags.parsing_nested_function)
+        fcn->stash_parent_fcn_name (parent_function_name);
+
       std::string nm = fcn->fcn_file_name ();
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
 			 "time stamp for `%s' is in the future", nm.c_str ());
     }
@@ -3224,17 +3234,18 @@ restore_command_history (void *)
 
 static void
 restore_input_stream (void *f)
 {
   command_editor::set_input_stream (static_cast<FILE *> (f));
 }
 
 static bool
-parse_fcn_file (const std::string& ff, bool exec_script, bool force_script = false)
+parse_fcn_file (const std::string& ff, bool exec_script,
+		bool force_script = false)
 {
   unwind_protect::begin_frame ("parse_fcn_file");
 
   int script_file_executed = false;
 
   // Open function file and parse.
 
   bool old_reading_fcn_file_state = reading_fcn_file;
@@ -3361,18 +3372,17 @@ lookup_autoload (const std::string& nm)
 {
   std::string retval;
 
   typedef std::map<std::string, std::string>::const_iterator am_iter;
 
   am_iter p = autoload_map.find (nm);
 
   if (p != autoload_map.end ())
-    retval = octave_env::make_absolute (load_path::find_file (p->second),
-					octave_env::getcwd ());
+    retval = load_path::find_file (p->second);
 
   return retval;
 }
 
 string_vector 
 autoloaded_functions (void)
 {
   string_vector names (autoload_map.size());
@@ -3406,16 +3416,20 @@ load_fcn_from_file (const std::string& n
   bool script_file_executed = false;
 
   std::string nm = nm_arg;
 
   size_t nm_len = nm.length ();
 
   std::string file;
 
+  unwind_protect_bool (fcn_file_from_relative_lookup);
+
+  fcn_file_from_relative_lookup = false;
+
   if (octave_env::absolute_pathname (nm)
       && ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
 	  || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
 	  || (nm_len > 2 && nm.substr (nm_len-2) == ".m")))
     {
       file = nm;
 
       nm = octave_env::base_pathname (file);
@@ -3428,30 +3442,33 @@ load_fcn_from_file (const std::string& n
       if (! file.empty ())
 	{
 	  unwind_protect_bool (autoloading);
 
 	  autoloading = true;
 	  exec_script = true;
 	}
       else
-	file = octave_env::make_absolute
-	  (load_path::find_fcn (nm), octave_env::getcwd ());
+        file = load_path::find_fcn (nm);
+
+      fcn_file_from_relative_lookup = ! octave_env::absolute_pathname (file);
+
+      file = octave_env::make_absolute (file, octave_env::getcwd ());
     }
 
   int len = file.length ();
 
   if (len > 4 && file.substr (len-4, len-1) == ".oct")
     {
-      if (octave_dynamic_loader::load_oct (nm, file))
+      if (octave_dynamic_loader::load_oct (nm, file, fcn_file_from_relative_lookup))
         force_link_to_function (nm);
     }
   else if (len > 4 && file.substr (len-4, len-1) == ".mex")
     {
-      if (octave_dynamic_loader::load_mex (nm, file))
+      if (octave_dynamic_loader::load_mex (nm, file, fcn_file_from_relative_lookup))
         force_link_to_function (nm);
     }
   else if (len > 2)
     {
       // These are needed by yyparse.
 
       unwind_protect_str (curr_fcn_file_name);
       unwind_protect_str (curr_fcn_file_full_name);
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -108,16 +108,30 @@ Return true if @var{name} is a valid var
   if (argc == 2)
     retval = valid_identifier (argv[1]);
   else
     print_usage ();
 
   return retval;
 }
 
+// Return TRUE if F and G are both names for the same file.
+
+bool
+same_file (const std::string& f, const std::string& g)
+{
+  std::string c_f = file_ops::canonicalize_file_name (f);
+  std::string c_g = file_ops::canonicalize_file_name (g);
+
+  file_stat f_fs (c_f);
+  file_stat g_fs (c_g);
+
+  return (f_fs.ino () == g_fs.ino () && f_fs.dev () == g_fs.dev ());
+}
+
 int
 almost_match (const std::string& std, const std::string& s, int min_match_len,
 	      int case_sens)
 {
   int stdlen = std.length ();
   int slen = s.length ();
 
   return (slen <= stdlen
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -34,33 +34,41 @@ 02110-1301, USA.
 
 class octave_value;
 class octave_value_list;
 class string_vector;
 
 extern OCTINTERP_API bool valid_identifier (const char *s);
 extern OCTINTERP_API bool valid_identifier (const std::string& s);
 
-extern OCTINTERP_API int almost_match (const std::string& std, const std::string& s,
-			 int min_match_len = 1, int case_sens = 1);
+extern OCTINTERP_API bool
+same_file (const std::string& f, const std::string& g);
+
+extern OCTINTERP_API int almost_match (const std::string& std,
+				       const std::string& s,
+				       int min_match_len = 1,
+				       int case_sens = 1);
 
 extern OCTINTERP_API int
 keyword_almost_match (const char * const *std, int *min_len,
 		      const std::string& s, int min_toks_to_match,
 		      int max_toks);
 
-extern OCTINTERP_API int empty_arg (const char *name, octave_idx_type nr, octave_idx_type nc);
+extern OCTINTERP_API int empty_arg (const char *name, octave_idx_type nr,
+				    octave_idx_type nc);
 
 extern OCTINTERP_API std::string
 search_path_for_file (const std::string&, const string_vector&);
 
 extern OCTINTERP_API string_vector
 search_path_for_all_files (const std::string&, const string_vector&);
 
-extern OCTINTERP_API std::string file_in_path (const std::string&, const std::string&);
+extern OCTINTERP_API std::string
+file_in_path (const std::string&, const std::string&);
+
 extern OCTINTERP_API std::string fcn_file_in_path (const std::string&);
 extern OCTINTERP_API std::string oct_file_in_path (const std::string&);
 extern OCTINTERP_API std::string mex_file_in_path (const std::string&);
 
 extern OCTINTERP_API std::string do_string_escapes (const std::string& s);
 
 extern OCTINTERP_API const char *undo_string_escape (char c);
 
@@ -70,23 +78,25 @@ extern OCTINTERP_API void
 check_dimensions (dim_vector& dim, const char *warnfor);
 
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a, const char *warn_for,
                 dim_vector& dim);
 
 extern OCTINTERP_API void
 get_dimensions (const octave_value& a, const octave_value& b,
-		const char *warn_for, octave_idx_type& nr, octave_idx_type& nc);
+		const char *warn_for, octave_idx_type& nr,
+		octave_idx_type& nc);
 
 extern OCTINTERP_API void
-get_dimensions (const octave_value& a,
-		const char *warn_for, octave_idx_type& nr, octave_idx_type& nc);
+get_dimensions (const octave_value& a,const char *warn_for,
+		octave_idx_type& nr, octave_idx_type& nc);
 
-extern OCTINTERP_API Matrix identity_matrix (octave_idx_type nr, octave_idx_type nc);
+extern OCTINTERP_API Matrix
+identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
 extern OCTINTERP_API int
 octave_format (std::ostream& os, const char *fmt, ...);
 
 extern OCTINTERP_API int
 octave_vformat (std::ostream& os, const char *fmt, va_list args);
 
 extern OCTINTERP_API char *octave_vsnprintf (const char *fmt, va_list args);
@@ -94,18 +104,18 @@ extern OCTINTERP_API char *octave_vsnpri
 extern OCTINTERP_API char *octave_snprintf (const char *fmt, ...);
 
 extern OCTINTERP_API void octave_sleep (double seconds);
 
 extern "C" OCTINTERP_API void octave_sleep (unsigned int seconds);
 
 extern "C" OCTINTERP_API void octave_usleep (unsigned int useconds);
 
-extern "C" OCTINTERP_API int octave_raw_vsnprintf (char *buf, size_t n, const char *fmt,
-				     va_list args);
+extern "C" OCTINTERP_API int
+octave_raw_vsnprintf (char *buf, size_t n, const char *fmt, va_list args);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -957,30 +957,16 @@ Check only for directories.\n\
 	error ("exist: expecting first argument to be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-// Return TRUE if F and G are both names for the same file.
-
-static bool
-same_file (const std::string& f, const std::string& g)
-{
-  std::string c_f = file_ops::canonicalize_file_name (f);
-  std::string c_g = file_ops::canonicalize_file_name (g);
-
-  file_stat f_fs (c_f);
-  file_stat g_fs (c_g);
-
-  return (f_fs.ino () == g_fs.ino () && f_fs.dev () == g_fs.dev ());
-}
-
 bool
 fcn_out_of_date (octave_function *fcn, const std::string& ff, time_t tp)
 {
   bool retval = false;
 
   fcn->mark_fcn_file_up_to_date (octave_time ());
 
   if (! (Vignore_function_time_stamp == 2
@@ -1015,17 +1001,22 @@ symbol_out_of_date (symbol_record *sr)
       // check the parent.
 
       if (fcn && ! fcn->is_nested_function ())
 	{
 	  std::string ff = fcn->fcn_file_name ();
 
 	  if (! ff.empty ())
 	    {
-	      if (fcn->time_checked () < Vlast_prompt_time)
+	      octave_time tc = fcn->time_checked ();
+
+	      bool relative = fcn->is_relative ();
+
+	      if (tc < Vlast_prompt_time
+		  || (relative && tc < Vlast_chdir_time))
 		{
 		  time_t tp = fcn->time_parsed ();
 
 		  std::string nm = fcn->name ();
 
 		  // FIXME -- the following code is repeated
 		  // in load_fcn_from_file in parse.y.
 
@@ -1042,29 +1033,37 @@ symbol_out_of_date (symbol_record *sr)
 		    {
 		      file = nm;
 		    }
 		  else
 		    {
 		      file = lookup_autoload (nm);
 
 		      if (file.empty ())
-			{
-			  file = octave_env::make_absolute
-			    (load_path::find_fcn (nm), octave_env::getcwd ());
-			}
+			file = load_path::find_fcn (nm);
+
+		      file = octave_env::make_absolute (file, octave_env::getcwd ());
 		    }
 
-		  if (same_file (file, ff))
+		  if (relative && file.empty ())
+		    {
+		      // Can't see this function from current
+		      // directory, so we should clear it.
+
+		      sr->clear ();
+
+		      retval = true;
+		    }
+		  else if (same_file (file, ff))
 		    {
 		      retval = fcn_out_of_date (fcn, ff, tp);
 		    }
 		  else
 		    {
-		      // Check the full function name.  Maybe we alrady
+		      // Check the full function name.  Maybe we already
 		      // parsed it.
 
 		      symbol_record *full_sr = fbi_sym_tab->lookup (file);
 
 		      if (full_sr)
 			{
 			  octave_value v = full_sr->def ();
 
@@ -1142,28 +1141,27 @@ lookup_by_name (const std::string& nm, b
   symbol_record *sym_rec = curr_sym_tab->lookup (nm, true);
 
   lookup (sym_rec, exec_script);
 
   return sym_rec;
 }
 
 octave_value
-lookup_function (const std::string& nm)
+lookup_function (const std::string& nm, const std::string& parent)
 {
   octave_value retval;
 
   symbol_record *sr = 0;
 
-  if (curr_parent_function)
-    {
-      std::string parent = curr_parent_function->name ();
-
-      sr = fbi_sym_tab->lookup (parent + ":" + nm);
-    }
+  if (! parent.empty ())
+    sr = fbi_sym_tab->lookup (parent + ":" + nm);
+
+  if (! sr || ! sr->is_function () && curr_parent_function)
+    sr = fbi_sym_tab->lookup (curr_parent_function->name () + ":" + nm);
 
   if (! sr || ! sr->is_function ())
     {
       sr = fbi_sym_tab->lookup (nm, true);
 
       if (sr && ! sr->is_function ())
 	load_fcn_from_file (sr, false);
     }
@@ -1459,22 +1457,25 @@ link_to_global_variable (symbol_record *
 
 void
 link_to_builtin_or_function (symbol_record *sr)
 {
   std::string nm = sr->name ();
 
   symbol_record *tmp_sym = 0;
 
-  if (curr_parent_function)
-    {
-      std::string parent = curr_parent_function->name ();
-
-      tmp_sym = fbi_sym_tab->lookup (parent + ":" + nm);
-    }
+  octave_function *fcn = octave_call_stack::current ();
+
+  std::string parent = fcn ? fcn->parent_fcn_name () : std::string ();
+
+  if (! parent.empty ())
+    tmp_sym = fbi_sym_tab->lookup (parent + ":" + nm);
+
+  if (! tmp_sym && curr_parent_function)
+    tmp_sym = fbi_sym_tab->lookup (curr_parent_function->name () + ":" + nm);
 
   if (! tmp_sym)
     tmp_sym = fbi_sym_tab->lookup (nm);
 
   if (tmp_sym
       && tmp_sym->is_function ()
       && ! tmp_sym->is_formal_parameter ())
     sr->alias (tmp_sym);
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -94,17 +94,19 @@ unique_symbol_name (const std::string& b
 extern OCTINTERP_API bool
 fcn_out_of_date (octave_function *fcn, const std::string& ff, time_t tp);
 
 extern OCTINTERP_API bool lookup (symbol_record *s, bool exec_script = true);
 
 extern OCTINTERP_API symbol_record *
 lookup_by_name (const std::string& nm, bool exec_script = true);
 
-extern OCTINTERP_API octave_value lookup_function (const std::string& nm);
+extern OCTINTERP_API octave_value
+lookup_function (const std::string& nm,
+		 const std::string& parent = std::string ());
 
 extern OCTINTERP_API octave_value lookup_user_function (const std::string& nm);
 
 extern OCTINTERP_API octave_value lookup_function_handle (const std::string& nm);
 
 extern OCTINTERP_API octave_value
 get_global_value (const std::string& nm, bool silent = false);
 
