# HG changeset patch
# User jwe
# Date 781539224 0
#      Fri Oct 07 14:13:44 1994 +0000
# Node ID a2f9d3fd720c11762bef5bd9b140d1e27ffa4b8c
# Parent  f19fb97286c63002b1bb0a405a22291d8f1b3cb7
[project @ 1994-10-07 14:01:53 by jwe]

diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -230,37 +230,45 @@ mx_stupid_bool_op (Matrix_bool_op op, do
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = s < a.elem (i,j);
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = s <= a.elem (i,j);
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = s == a.elem (i,j);
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = s >= a.elem (i,j);
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = s > a.elem (i,j);
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = s != a.elem (i,j);
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = s && a.elem (i,j);
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = s || a.elem (i,j);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -285,37 +293,45 @@ mx_stupid_bool_op (Matrix_bool_op op, do
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = s < real (a.elem (i,j));
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = s <= real (a.elem (i,j));
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = s == a.elem (i,j);
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = s >= real (a.elem (i,j));
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = s > real (a.elem (i,j));
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = s != a.elem (i,j);
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = s && (a.elem (i,j) != 0.0);
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = s || (a.elem (i,j) != 0.0);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -340,37 +356,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = a.elem (i,j) < s;
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = a.elem (i,j) <= s;
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = a.elem (i,j) == s;
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = a.elem (i,j) >= s;
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = a.elem (i,j) > s;
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = a.elem (i,j) != s;
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = a.elem (i,j) && s;
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = a.elem (i,j) || s;
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -395,37 +419,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = a.elem (i,j) < real (s);
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = a.elem (i,j) <= real (s);
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = a.elem (i,j) == s;
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = a.elem (i,j) >= real (s);
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = a.elem (i,j) > real (s);
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = a.elem (i,j) != s;
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = a.elem (i,j) && (s != 0.0);
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = a.elem (i,j) || (s != 0.0);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -453,37 +485,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    c.elem (i, j) = a.elem (i, j) <  b.elem (i, j);
 	    break;
+
 	  case Matrix_LE:
 	    c.elem (i, j) = a.elem (i, j) <= b.elem (i, j);
 	    break;
+
 	  case Matrix_EQ:
 	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
 	    break;
+
 	  case Matrix_GE:
 	    c.elem (i, j) = a.elem (i, j) >= b.elem (i, j);
 	    break;
+
 	  case Matrix_GT:
 	    c.elem (i, j) = a.elem (i, j) >  b.elem (i, j);
 	    break;
+
 	  case Matrix_NE:
 	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
 	    break;
+
 	  case Matrix_AND:
 	    c.elem (i, j) = a.elem (i, j) && b.elem (i, j);
 	    break;
+
 	  case Matrix_OR:
 	    c.elem (i, j) = a.elem (i, j) || b.elem (i, j);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
 
   return c;
 }
@@ -511,37 +551,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    c.elem (i, j) = a.elem (i, j) <  real (b.elem (i, j));
 	    break;
+
 	  case Matrix_LE:
 	    c.elem (i, j) = a.elem (i, j) <= real (b.elem (i, j));
 	    break;
+
 	  case Matrix_EQ:
 	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
 	    break;
+
 	  case Matrix_GE:
 	    c.elem (i, j) = a.elem (i, j) >= real (b.elem (i, j));
 	    break;
+
 	  case Matrix_GT:
 	    c.elem (i, j) = a.elem (i, j) >  real (b.elem (i, j));
 	    break;
+
 	  case Matrix_NE:
 	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
 	    break;
+
 	  case Matrix_AND:
 	    c.elem (i, j) = a.elem (i, j) && (b.elem (i, j) != 0.0);
 	    break;
+
 	  case Matrix_OR:
 	    c.elem (i, j) = a.elem (i, j) || (b.elem (i, j) != 0.0);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
   return c;
 }
 
@@ -565,37 +613,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (s) < a.elem (i,j);
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = real (s) <= a.elem (i,j);
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = s == a.elem (i,j);
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = real (s) >= a.elem (i,j);
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = real (s) > a.elem (i,j);
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = s != a.elem (i,j);
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = (s != 0.0) && a.elem (i,j);
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = (s != 0.0) || a.elem (i,j);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -620,37 +676,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (s) < real (a.elem (i,j));
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = real (s) <= real (a.elem (i,j));
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = s == a.elem (i,j);
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = real (s) >= real (a.elem (i,j));
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = real (s) > real (a.elem (i,j));
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = s != a.elem (i,j);
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = (s != 0.0) && (a.elem (i,j) != 0.0);
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = (s != 0.0) || (a.elem (i,j) != 0.0);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -675,37 +739,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (a.elem (i,j)) < s;
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = real (a.elem (i,j)) <= s;
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = a.elem (i,j) == s;
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = real (a.elem (i,j)) >= s;
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = real (a.elem (i,j)) > s;
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = a.elem (i,j) != s;
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = (a.elem (i,j) != 0.0) && s;
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = (a.elem (i,j) != 0.0) || s;
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -730,37 +802,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (a.elem (i,j)) < real (s);
 	    break;
+
 	  case Matrix_LE:
 	    t.elem (i,j) = real (a.elem (i,j)) <= real (s);
 	    break;
+
 	  case Matrix_EQ:
 	    t.elem (i,j) = a.elem (i,j) == s;
 	    break;
+
 	  case Matrix_GE:
 	    t.elem (i,j) = real (a.elem (i,j)) >= real (s);
 	    break;
+
 	  case Matrix_GT:
 	    t.elem (i,j) = real (a.elem (i,j)) > real (s);
 	    break;
+
 	  case Matrix_NE:
 	    t.elem (i,j) = a.elem (i,j) != s;
 	    break;
+
 	  case Matrix_AND:
 	    t.elem (i,j) = (a.elem (i,j) != 0.0) && (s != 0.0);
 	    break;
+
 	  case Matrix_OR:
 	    t.elem (i,j) = (a.elem (i,j) != 0.0) || (s != 0.0);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
@@ -788,37 +868,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    c.elem (i, j) = real (a.elem (i, j)) <  b.elem (i, j);
 	    break;
+
 	  case Matrix_LE:
 	    c.elem (i, j) = real (a.elem (i, j)) <= b.elem (i, j);
 	    break;
+
 	  case Matrix_EQ:
 	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
 	    break;
+
 	  case Matrix_GE:
 	    c.elem (i, j) = real (a.elem (i, j)) >= b.elem (i, j);
 	    break;
+
 	  case Matrix_GT:
 	    c.elem (i, j) = real (a.elem (i, j)) >  b.elem (i, j);
 	    break;
+
 	  case Matrix_NE:
 	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
 	    break;
+
 	  case Matrix_AND:
 	    c.elem (i, j) = (a.elem (i, j) != 0.0)  && b.elem (i, j);
 	    break;
+
 	  case Matrix_OR:
 	    c.elem (i, j) = (a.elem (i, j) != 0.0) || b.elem (i, j);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
   return c;
 }
 
@@ -846,37 +934,45 @@ mx_stupid_bool_op (Matrix_bool_op op, co
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    c.elem (i, j) = real (a.elem (i, j)) <  real (b.elem (i, j));
 	    break;
+
 	  case Matrix_LE:
 	    c.elem (i, j) = real (a.elem (i, j)) <= real (b.elem (i, j));
 	    break;
+
 	  case Matrix_EQ:
 	    c.elem (i, j) = a.elem (i, j) == b.elem (i, j);
 	    break;
+
 	  case Matrix_GE:
 	    c.elem (i, j) = real (a.elem (i, j)) >= real (b.elem (i, j));
 	    break;
+
 	  case Matrix_GT:
 	    c.elem (i, j) = real (a.elem (i, j)) >  real (b.elem (i, j));
 	    break;
+
 	  case Matrix_NE:
 	    c.elem (i, j) = a.elem (i, j) != b.elem (i, j);
 	    break;
+
 	  case Matrix_AND:
 	    c.elem (i, j) = (a.elem (i, j) != 0.0) && (b.elem (i, j) != 0.0);
 	    break;
+
 	  case Matrix_OR:
 	    c.elem (i, j) = (a.elem (i, j) != 0.0) || (b.elem (i, j) != 0.0);
 	    break;
+
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
 
   return c;
 }
@@ -893,23 +989,26 @@ do_unary_op (double d, tree_expression::
 {
   double result = 0.0;
 
   switch (t)
     {
     case tree_expression::not:
       result = (! d);
       break;
+
     case tree_expression::uminus:
       result = -d;
       break;
+
     case tree_expression::hermitian:
     case tree_expression::transpose:
       result = d;
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
@@ -918,23 +1017,26 @@ do_unary_op (const Matrix& a, tree_expre
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::not:
       result = (! a);
       break;
+
     case tree_expression::uminus:
       result = -a;
       break;
+
     case tree_expression::hermitian:
     case tree_expression::transpose:
       result = a.transpose ();
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
@@ -943,25 +1045,29 @@ do_unary_op (const Complex& c, tree_expr
 {
   Complex result = 0.0;
 
   switch (t)
     {
     case tree_expression::not:
       result = (c == 0.0);
       break;
+
     case tree_expression::uminus:
       result = -c;
       break;
+
     case tree_expression::hermitian:
       result = conj (c);
       break;
+
     case tree_expression::transpose:
       result = c;
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
@@ -970,25 +1076,29 @@ do_unary_op (const ComplexMatrix& a, tre
 {
   ComplexMatrix result;
 
   switch (t)
     {
     case tree_expression::not:
       result = (! a);
       break;
+
     case tree_expression::uminus:
       result = -a;
       break;
+
     case tree_expression::hermitian:
       result = a.hermitian ();
       break;
+
     case tree_expression::transpose:
       result = a.transpose ();
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
@@ -1012,63 +1122,77 @@ do_binary_op (double a, double b, tree_e
 {
   double result = 0.0;
 
   switch (t)
     {
     case tree_expression::add:
       result = a + b;
       break;
+
     case tree_expression::subtract:
       result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       if (b == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       result = a / b;
       break;
+
     case tree_expression::leftdiv:
     case tree_expression::el_leftdiv:
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       result = b / a;
       break;
+
     case tree_expression::power:
     case tree_expression::elem_pow:
       return xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result = a < b;
       break;
+
     case tree_expression::cmp_le:
       result = a <= b;
       break;
+
     case tree_expression::cmp_eq:
       result = a == b;
       break;
+
     case tree_expression::cmp_ge:
       result = a >= b;
       break;
+
     case tree_expression::cmp_gt:
       result = a > b;
       break;
+
     case tree_expression::cmp_ne:
       result = a != b;
       break;
+
     case tree_expression::and:
       result = (a && b);
       break;
+
     case tree_expression::or:
       result = (a || b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1081,65 +1205,81 @@ do_binary_op (double a, const Matrix& b,
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
       result = a + b;
       break;
+
     case tree_expression::subtract:
       result = a - b;
       break;
+
     case tree_expression::el_leftdiv:
     case tree_expression::leftdiv:
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       a = 1.0 / a;
 // fall through...
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result = a * b;
       break;
+
     case tree_expression::el_div:
       return x_el_div (a, b);
       break;
+
     case tree_expression::divide:
       gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1157,75 +1297,89 @@ do_binary_op (double a, const Complex& b
   Complex complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       result_type = RT_complex;
       if (b == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       complex_result = a / b;
       break;
+
     case tree_expression::leftdiv:
     case tree_expression::el_leftdiv:
       result_type = RT_complex;
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       complex_result = b / a;
       break;
+
     case tree_expression::power:
     case tree_expression::elem_pow:
       return xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = a < real (b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = a <= real (b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = a == b;
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = a >= real (b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = a > real (b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = a != b;
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = (a && (b != 0.0));
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = (a || (b != 0.0));
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1248,75 +1402,91 @@ do_binary_op (double a, const ComplexMat
   ComplexMatrix complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::el_leftdiv:
     case tree_expression::leftdiv:
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       a = 1.0 / a;
 // fall through...
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::el_div:
       return x_el_div (a, b);
       break;
+
     case tree_expression::divide:
       gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1334,63 +1504,79 @@ do_binary_op (const Matrix& a, double b,
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
       result = a + b;
       break;
+
     case tree_expression::subtract:
       result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       result = a / b;
       break;
+
     case tree_expression::el_leftdiv:
       return x_el_div (b, a);
       break;
+
     case tree_expression::leftdiv:
       gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1404,81 +1590,99 @@ do_binary_op (const Matrix& a, const Mat
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
       if (m_add_conform (a, b, 1))
 	result = a + b;
       break;
+
     case tree_expression::subtract:
       if (m_add_conform (a, b, 1))
 	result = a - b;
       break;
+
     case tree_expression::el_mul:
       if (m_add_conform (a, b, 1))
 	result = product (a, b);
       break;
+
     case tree_expression::multiply:
       if (m_mul_conform (a, b, 1))
 	result = a * b;
       break;
+
     case tree_expression::el_div:
       if (m_add_conform (a, b, 1))
 	result = quotient (a, b);
       break;
+
     case tree_expression::el_leftdiv:
       if (m_add_conform (a, b, 1))
 	result = quotient (b, a);
       break;
+
     case tree_expression::leftdiv:
       return xleftdiv (a, b);
       break;
+
     case tree_expression::divide:
       return xdiv (a, b);
       break;
+
     case tree_expression::power:
       error ("can't do A ^ B for A and B both matrices");
       break;
+
     case tree_expression::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1496,74 +1700,90 @@ do_binary_op (const Matrix& a, const Com
   ComplexMatrix complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       result_type = RT_complex;
       complex_result = a / b;
       break;
+
     case tree_expression::el_leftdiv:
       return x_el_div (b, a);
       break;
+
     case tree_expression::leftdiv:
       gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1587,94 +1807,112 @@ do_binary_op (const Matrix& a, const Com
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
       break;
+
     case tree_expression::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = product (a, b);
       break;
+
     case tree_expression::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
       break;
+
     case tree_expression::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = quotient (a, b);
       break;
+
     case tree_expression::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = quotient (b, a);
       break;
+
     case tree_expression::leftdiv:
       return xleftdiv (a, b);
       break;
+
     case tree_expression::divide:
       return xdiv (a, b);
       break;
+
     case tree_expression::power:
       error ("can't do A ^ B for A and B both matrices");
       break;
+
     case tree_expression::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1697,75 +1935,89 @@ do_binary_op (const Complex& a, double b
   Complex complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       result_type = RT_complex;
       if (b == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       complex_result = a / b;
       break;
+
     case tree_expression::leftdiv:
     case tree_expression::el_leftdiv:
       result_type = RT_complex;
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       complex_result = b / a;
       break;
+
     case tree_expression::power:
     case tree_expression::elem_pow:
       return xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = real (a) < b;
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = real (a) <= b;
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = a == b;
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = real (a) >= b;
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = real (a) > b;
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = a != b;
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = ((a != 0.0) && b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = ((a != 0.0) || b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1788,76 +2040,92 @@ do_binary_op (const Complex& a, const Ma
   ComplexMatrix complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::el_leftdiv:
     case tree_expression::leftdiv:
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       result_type = RT_complex;
       complex_result = b / a;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::el_div:
       return x_el_div (a, b);
       break;
+
     case tree_expression::divide:
       gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1880,75 +2148,89 @@ do_binary_op (const Complex& a, const Co
   Complex complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       result_type = RT_complex;
       if (b == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       complex_result = a / b;
       break;
+
     case tree_expression::leftdiv:
     case tree_expression::el_leftdiv:
       result_type = RT_complex;
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       complex_result = b / a;
       break;
+
     case tree_expression::power:
     case tree_expression::elem_pow:
       return xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = real (a) < real (b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = real (a) <= real (b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = a == b;
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = real (a) >= real (b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = real (a) > real (b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = a != b;
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = ((a != 0.0) && (b != 0.0));
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = ((a != 0.0) || (b != 0.0));
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -1972,76 +2254,92 @@ do_binary_op (const Complex& a, const Co
   ComplexMatrix complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::el_leftdiv:
     case tree_expression::leftdiv:
       if (a == 0.0)
 	DIVIDE_BY_ZERO_ERROR;
       result_type = RT_complex;
       complex_result = b / a;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::el_div:
       return x_el_div (a, b);
       break;
+
     case tree_expression::divide:
       gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -2064,74 +2362,90 @@ do_binary_op (const ComplexMatrix& a, do
   ComplexMatrix complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       result_type = RT_complex;
       complex_result = a / b;
       break;
+
     case tree_expression::el_leftdiv:
       return x_el_div (b, a);
       break;
+
     case tree_expression::leftdiv:
       gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -2155,94 +2469,112 @@ do_binary_op (const ComplexMatrix& a, co
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
       break;
+
     case tree_expression::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = product (a, b);
       break;
+
     case tree_expression::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
       break;
+
     case tree_expression::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = quotient (a, b);
       break;
+
     case tree_expression::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = quotient (b, a);
       break;
+
     case tree_expression::leftdiv:
       return xleftdiv (a, b);
       break;
+
     case tree_expression::divide:
       return xdiv (a, b);
       break;
+
     case tree_expression::power:
       error ("can't do A ^ B for A and B both matrices");
       break;
+
     case tree_expression::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -2266,74 +2598,90 @@ do_binary_op (const ComplexMatrix& a, co
   ComplexMatrix complex_result;
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       complex_result = a - b;
       break;
+
     case tree_expression::multiply:
     case tree_expression::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
+
     case tree_expression::divide:
     case tree_expression::el_div:
       result_type = RT_complex;
       complex_result = a / b;
       break;
+
     case tree_expression::el_leftdiv:
       return x_el_div (b, a);
       break;
+
     case tree_expression::leftdiv:
       gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
+
     case tree_expression::power:
       return xpow (a, b);
       break;
+
     case tree_expression::elem_pow:
       return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
@@ -2358,94 +2706,112 @@ do_binary_op (const ComplexMatrix& a, co
 
   switch (t)
     {
     case tree_expression::add:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a + b;
       break;
+
     case tree_expression::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
       break;
+
     case tree_expression::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = product (a, b);
       break;
+
     case tree_expression::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
       break;
+
     case tree_expression::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = quotient (a, b);
       break;
+
     case tree_expression::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = quotient (b, a);
       break;
+
     case tree_expression::leftdiv:
       return xleftdiv (a, b);
       break;
+
     case tree_expression::divide:
       return xdiv (a, b);
       break;
+
     case tree_expression::power:
       error ("can't do A ^ B for A and B both matrices");
       break;
+
     case tree_expression::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
       break;
+
     case tree_expression::cmp_lt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
       break;
+
     case tree_expression::cmp_le:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
       break;
+
     case tree_expression::cmp_eq:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
       break;
+
     case tree_expression::cmp_ge:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
       break;
+
     case tree_expression::cmp_gt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
       break;
+
     case tree_expression::cmp_ne:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
       break;
+
     case tree_expression::and:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
       break;
+
     case tree_expression::or:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (error_state)
     return tree_constant ();
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -33,16 +33,17 @@ Software Foundation, Inc.
 #include "config.h"
 #endif
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "help.h"
 #include "utils.h"
 #include "error.h"
+#include "gripes.h"
 #include "defun.h"
 
 #ifndef MIN
 #define MIN(a,b) ((a) < (b) ? (a) : (b))
 #endif
 
 #ifndef ABS
 #define ABS(x) (((x) < 0) ? (-x) : (x))
@@ -823,22 +824,25 @@ DEFUN ("ones", Fones, Sones, 2, 1,
 
   int nargin = args.length ();
 
   switch (nargin)
     {
     case 0:
       retval = 1.0;
       break;
+
     case 1:
       retval = fill_matrix (args(0), 1.0, "ones");
       break;
+
     case 2:
       retval = fill_matrix (args(0), args(1), 1.0, "ones");
       break;
+
     default:
       print_usage ("ones");
       break;
     }
 
   return retval;
 }
 
@@ -849,22 +853,25 @@ DEFUN ("zeros", Fzeros, Szeros, 2, 1,
 
   int nargin = args.length ();
 
   switch (nargin)
     {
     case 0:
       retval = 0.0;
       break;
+
     case 1:
       retval = fill_matrix (args(0), 0.0, "zeros");
       break;
+
     case 2:
       retval = fill_matrix (args(0), args(1), 0.0, "zeros");
       break;
+
     default:
       print_usage ("zeros");
       break;
     }
 
   return retval;
 }
 
@@ -917,22 +924,25 @@ DEFUN ("eye", Feye, Seye, 2, 1,
 
   int nargin = args.length ();
 
   switch (nargin)
     {
     case 0:
       retval = 1.0;
       break;
+
     case 1:
       retval = identity_matrix (args(0));
       break;
+
     case 2:
       retval = identity_matrix (args(0), args(1));
       break;
+
     default:
       print_usage ("eye");
       break;
     }
 
   return retval;
 }
 
diff --git a/src/find.cc b/src/find.cc
--- a/src/find.cc
+++ b/src/find.cc
@@ -22,16 +22,17 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "tree-const.h"
 #include "error.h"
+$include "gripes.h"
 #include "help.h"
 #include "defun-dld.h"
 
 static Octave_object
 find_to_fortran_idx (const ColumnVector i_idx, const ColumnVector j_idx,
 		     const tree_constant& val, int nr, int nc, int nargout)
 {
   Octave_object retval;
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#include "tree-const.h"
 #include "gripes.h"
 #include "error.h"
 
 void
 gripe_string_invalid (void)
 {
   error ("string constant used in invalid context");
 }
@@ -81,14 +82,56 @@ gripe_user_returned_invalid (const char 
 }
 
 void
 gripe_invalid_conversion (const char *from, const char *to)
 {
   error ("invalid conversion from %s to %s", from, to);
 }
 
+void
+gripe_2_or_3_dim_plot (void)
+{
+  error ("plot: can only plot in 2 or 3 dimensions");
+}
+
+void
+gripe_unrecognized_float_fmt (void)
+{
+  error ("unrecognized floating point format requested");
+}
+
+void
+gripe_unrecognized_data_fmt (const char *warn_for)
+{
+  error ("%s: unrecognized data format requested", warn_for);
+}
+
+void
+gripe_data_conversion (const char *from, const char *to)
+{
+  error ("unable to convert from %s to %s format", from, to);
+}
+
+void
+gripe_wrong_type_arg (const char *name, const tree_constant& tc)
+{
+  error ("%s: wrong type argument `%s'", name, tc.type_as_string ());
+}
+
+void
+gripe_wrong_type_arg_for_unary_op (const tree_constant& op)
+{
+  error ("invalid operand `%s' for unary operator", op.type_as_string ());
+}
+
+void
+gripe_wrong_type_arg_for_binary_op (const tree_constant& op)
+{
+  error ("invalid operand `%s' for binary operator", op.type_as_string ());
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -30,16 +30,23 @@ extern void gripe_string_invalid (void);
 extern void gripe_range_invalid (void);
 extern void gripe_nonconformant (void);
 extern void gripe_nonconformant (int r1, int c1, int r2, int c2);
 extern void gripe_empty_arg (const char *name, int is_error);
 extern void gripe_square_matrix_required (const char *name);
 extern void gripe_user_supplied_eval (const char *name);
 extern void gripe_user_returned_invalid (const char *name);
 extern void gripe_invalid_conversion (const char *from, const char *to);
+extern void gripe_2_or_3_dim_plot (void);
+extern void gripe_unrecognized_float_fmt (void);
+extern void gripe_unrecognized_data_fmt (const char *warn_for);
+extern void gripe_data_conversion (const char *from, const char *to);
+extern void gripe_wrong_type_arg (const char *name, const tree_constant& tc);
+extern void gripe_wrong_type_arg_for_unary_op (const tree_constant& op);
+extern void gripe_wrong_type_arg_for_binary_op (const tree_constant& op);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -721,46 +721,56 @@ do_string_escapes (char *s)
     {
       if (*p2 == '\\' && *(p2+1) != '\0')
 	{
 	  switch (*++p2)
 	    {
 	    case 'a':
 	      *p1 = '\a';
 	      break;
+
 	    case 'b': // backspace
 	      *p1 = '\b';
 	      break;
+
 	    case 'f': // formfeed
 	      *p1 = '\f';
 	      break;
+
 	    case 'n': // newline
 	      *p1 = '\n';
 	      break;
+
 	    case 'r': // carriage return
 	      *p1 = '\r';
 	      break;
+
 	    case 't': // horizontal tab
 	      *p1 = '\t';
 	      break;
+
 	    case 'v': // vertical tab
 	      *p1 = '\v';
 	      break;
+
 	    case '\\': // backslash
 	      *p1 = '\\';
 	      break;
+
 	    case '\'': // quote
 	      *p1 = '\'';
 	      break;
+
 	    case '"': // double quote
 	      *p1 = '"';
 	      break;
+
 	    default:
-          warning ("unrecognized escape sequence `\\%c' -- converting to `%c'",
-		   *p2, *p2);
+	      warning ("unrecognized escape sequence `\\%c' --\
+ converting to `%c'", *p2, *p2);
 	      *p1 = *p2;
 	      break;
 	    }
 	}
       else if (*p2 == '\'' && *(p2+1) == '\'')
 	{
 	  *p1 = '\'';
 	  p2++;
@@ -1132,19 +1142,22 @@ grab_help_text (void)
 	}
       else
 	{
 	  switch (c)
 	    {
 	    case '%':
 	    case '#':
 	      in_comment = 1;
+	      break;
+
 	    case ' ':
 	    case '\t':
 	      break;
+
 	    default:
 	      goto done;
 	    }
 	}
 
       if (len > max_len)
 	{
 	  warning ("grab_help_text: buffer overflow after caching %d chars",
@@ -1230,18 +1243,22 @@ next_token_is_bin_op (int spc_prev, char
   int bin_op = 0;
   int spc_next = 0;
 
   int c0 = yyinput ();
   int c1 = yyinput ();
 
   switch (c0)
     {
-    case '+':  case '-':  case '/':
-    case ':':  case '\\': case '^':
+    case '+':
+    case '-':
+    case '/':
+    case ':':
+    case '\\':
+    case '^':
       spc_next = (c1 == ' ' || c1 == '\t');
       break;
 
     case '&':
       if (c1 == '&')
 	spc_next = next_char_is_space ();
       else
 	spc_next = (c1 == ' ' || c1 == '\t');
@@ -1270,17 +1287,19 @@ next_token_is_bin_op (int spc_prev, char
 
     case '>':
       if (c1 == '=')
 	spc_next = next_char_is_space ();
       else
 	spc_next = (c1 == ' ' || c1 == '\t');
       break;
 
-    case '~':  case '!':  case '=':
+    case '~':
+    case '!':
+    case '=':
       if (c1 == '=')
 	spc_next = next_char_is_space ();
       else
 	goto done;
       break;
 
     case '.':
       if (c1 == '*')
@@ -1487,24 +1506,27 @@ check_for_garbage_after_fcn_def (void)
     {
       switch (c)
 	{
 	case ' ':
 	case '\t':
 	case ';':
 	case ',':
 	  break;
+
 	case '\n':
 	  if (in_comment)
 	    in_comment = 0;
 	  break;
+
 	case '%':
 	case '#':
 	  in_comment = 1;
 	  break;
+
 	default:
 	  if (in_comment)
 	    break;
 	  else
 	    {
 	      warning ("ignoring trailing garbage after end of function\n\
          near line %d of file `%s.m'", lineno, curr_fcn_file_name);
 	      
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -37,16 +37,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-expr.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "unwind-prot.h"
 #include "load-save.h"
 #include "symtab.h"
 #include "pager.h"
 #include "error.h"
+#include "gripes.h"
 #include "defun.h"
 #include "utils.h"
 #include "help.h"
 
 extern "C"
 {
 #include <readline/tilde.h>
 
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -24,16 +24,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include <math.h>
 
 #include "tree-const.h"
 #include "error.h"
+#include "gripes.h"
 #include "help.h"
 #include "defun-dld.h"
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
 
 #ifndef MIN
@@ -159,19 +160,21 @@ DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 3,
   tree_constant arg1;
   tree_constant arg2;
 
   switch (nargin)
     {
     case 2:
       arg2 = args(1);
 // Fall through...
+
     case 1:
       arg1 = args(0);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (nargin == 1 && (nargout == 1 || nargout == 0))
     {
       if (arg1.is_real_scalar ())
@@ -334,19 +337,21 @@ DEFUN_DLD_BUILTIN ("max", Fmax, Smax, 3,
   tree_constant arg1;
   tree_constant arg2;
 
   switch (nargin)
     {
     case 2:
       arg2 = args(1);
 // Fall through...
+
     case 1:
       arg1 = args(0);
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   if (nargin == 1 && (nargout == 1 || nargout == 0))
     {
       if (arg1.is_real_scalar ())
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -203,22 +203,25 @@ do_history (int argc, char **argv)
 			result =
 			  append_history (history_lines_this_session, file);
 			history_lines_in_file += history_lines_this_session;
 			history_lines_this_session = 0;
 		      }
 		  }
 	      }
 	      break;
+
 	    case 'w':		// Write entire history.
 	      result = write_history (file);
 	      break;
+
 	    case 'r':		// Read entire file.
 	      result = read_history (file);
 	      break;
+
 	    case 'n':		// Read `new' history from file.
 // Read all of the lines in the file that we haven't already read.
 	      using_history ();
 	      result = read_history_range (file, history_lines_in_file, -1);
 	      using_history ();
 	      history_lines_in_file = where_history ();
 	      break;
 	    }
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -450,43 +450,52 @@ main (int argc, char **argv)
   int optc;
   while ((optc = getopt_long (argc, argv, short_opts, long_opts, 0)) != EOF)
     {
       switch (optc)
 	{
 	case 'd':
 	  yydebug++;
 	  break;
+
 	case 'f':
 	  read_init_files = 0;
 	  break;
+
 	case 'h':
 	case '?':
 	  verbose_usage ();
 	  break;
+
 	case 'i':
 	  forced_interactive = 1;
 	  break;
+
 	case 'p':
 	  if (optarg)
 	    load_path = strsave (optarg);
 	  break;
+
 	case 'q':
 	  inhibit_startup_message = 1;
 	  break;
+
 	case 'x':
 	  echo_input = 1;
 	  break;
+
 	case 'v':
 	  print_version_and_exit ();
 	  break;
+
 	case INFO_FILE_OPTION:
 	  if (optarg)
 	    info_file = strsave (optarg);
 	  break;
+
 	default:
 	  usage ();
 	  break;
 	}
     }
 
 #if defined (HAVE_ATEXIT) || (HAVE_ON_EXIT)
 // Make sure we clean up when we exit.  If we don't have atexit or
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -214,16 +214,17 @@ redirect all input and screen output to 
 	else
 	  {
 	    delete [] diary_file;
 	    diary_file = strsave (arg);
 	    open_diary_file ();
 	  }
       }
       break;
+
     default:
       print_usage ("diary");
       break;
     }
 
   DELETE_ARGV;
 
   return retval;
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1202,28 +1202,33 @@ end_error (char *type, token::end_tok_ty
 {
   static char *fmt = "`%s' command matched by `%s' near line %d column %d";
 
   switch (ettype)
     {
     case token::simple_end:
       error (fmt, type, "end", l, c);
       break;
+
     case token::for_end:
       error (fmt, type, "endfor", l, c);
       break;
+
     case token::function_end:
       error (fmt, type, "endfunction", l, c);
       break;
+
     case token::if_end:
       error (fmt, type, "endif", l, c);
       break;
+
     case token::while_end:
       error (fmt, type, "endwhile", l, c); 
       break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 // Check to see that end tokens are properly matched.
 
@@ -1238,25 +1243,29 @@ check_end (token *tok, token::end_tok_ty
       int l = tok->line ();
       int c = tok->column ();
 
       switch (expected)
 	{
 	case token::for_end:
 	  end_error ("for", ettype, l, c);
 	  break;
+
 	case token::function_end:
 	  end_error ("function", ettype, l, c);
 	  break;
+
 	case token::if_end:
 	  end_error ("if", ettype, l, c);
 	  break;
+
 	case token::while_end:
 	  end_error ("while", ettype, l, c);
 	  break;
+
 	default:
 	  panic_impossible ();
 	  break;
 	}
       return 1;
     }
   else
     return 0;
@@ -1323,73 +1332,93 @@ make_binary_op (int op, tree_expression 
 		tree_expression *op2)
 {
   tree_expression::type t;
   switch (op)
     {
     case POW:
       t = tree_expression::power;
       break;
+
     case EPOW:
       t = tree_expression::elem_pow;
       break;
+
     case '+':
       t = tree_expression::add;
       break;
+
     case '-':
       t = tree_expression::subtract;
       break;
+
     case '*':
       t = tree_expression::multiply;
       break;
+
     case '/':
       t = tree_expression::divide;
       break;
+
     case EMUL:
       t = tree_expression::el_mul;
       break;
+
     case EDIV:
       t = tree_expression::el_div;
       break;
+
     case LEFTDIV:
       t = tree_expression::leftdiv;
       break;
+
     case ELEFTDIV:
       t = tree_expression::el_leftdiv;
       break;
+
     case EXPR_LT:
       t = tree_expression::cmp_lt;
       break;
+
     case EXPR_LE:
       t = tree_expression::cmp_le;
       break;
+
     case EXPR_EQ:
       t = tree_expression::cmp_eq;
       break;
+
     case EXPR_GE:
       t = tree_expression::cmp_ge;
       break;
+
     case EXPR_GT:
       t = tree_expression::cmp_gt;
       break;
+
     case EXPR_NE:
       t = tree_expression::cmp_ne;
       break;
+
     case EXPR_AND_AND:
       t = tree_expression::and_and;
       break;
+
     case EXPR_OR_OR:
       t = tree_expression::or_or;
       break;
+
     case EXPR_AND:
       t = tree_expression::and;
       break;
+
     case EXPR_OR:
       t = tree_expression::or;
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
@@ -1402,19 +1431,21 @@ static tree_expression *
 make_prefix_op (int op, tree_identifier *op1, token *tok_val)
 {
   tree_expression::type t;
   switch (op)
     {
     case PLUS_PLUS:
       t = tree_expression::increment;
       break;
+
     case MINUS_MINUS:
       t = tree_expression::decrement;
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
@@ -1427,19 +1458,21 @@ static tree_expression *
 make_postfix_op (int op, tree_identifier *op1, token *tok_val)
 {
   tree_expression::type t;
   switch (op)
     {
     case PLUS_PLUS:
       t = tree_expression::increment;
       break;
+
     case MINUS_MINUS:
       t = tree_expression::decrement;
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
@@ -1452,25 +1485,29 @@ static tree_expression *
 make_unary_op (int op, tree_expression *op1, token *tok_val)
 {
   tree_expression::type t;
   switch (op)
     {
     case QUOTE:
       t = tree_expression::hermitian;
       break;
+
     case TRANSPOSE:
       t = tree_expression::transpose;
       break;
+
     case EXPR_NOT:
       t = tree_expression::not;
       break;
+
     case '-':
       t = tree_expression::uminus;
       break;
+
     default:
       panic_impossible ();
       break;
     }
 
   int l = tok_val->line ();
   int c = tok_val->column ();
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -227,22 +227,16 @@ tree_constant::print_code (ostream& os)
 
   if (rep)
     rep->print_code (os);
 
   if (in_parens)
     os << ")";
 }
 
-void
-gripe_wrong_type_arg (const char *name, const tree_constant& tc)
-{
-  error ("%s: wrong type argument `%s'", name, tc.type_as_string ());
-}
-
 // Construct return vector of empty matrices.  Return empty matrices
 // and/or gripe when appropriate.
 
 Octave_object
 vector_of_empties (int nargout, const char *fcn_name)
 {
   Octave_object retval;
 
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -337,20 +337,16 @@ public:
 
   void stash_original_text (char *s)
     { rep->stash_original_text (s); }
 
 // Pretty print this constant.
  
   void print_code (ostream& os);
 
-// Complain about unknown types used as args.
-
-  friend void gripe_wrong_type_arg (const char *name, const tree_constant& tc);
-
   char *type_as_string (void) const
     { return rep->type_as_string (); }
 
 // We really do need this, and it should be private:
 
 private:
 
   void make_unique (void);
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -41,16 +41,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <ctype.h>
 #include <stdio.h>
 
 #include "variables.h"
 #include "user-prefs.h"
 #include "dynamic-ld.h"
 #include "help.h"
 #include "error.h"
+#include "gripes.h"
 #include "pager.h"
 #include "tree-base.h"
 #include "tree-expr.h"
 #include "tree-misc.h"
 #include "tree-const.h"
 #include "input.h"
 #include "symtab.h"
 #include "utils.h"
@@ -451,29 +452,31 @@ tree_matrix::eval (int print)
 		else
 		  {
 		    cols_this_row += nc;
 		    if (first_row)
 		      col_total = cols_this_row;
 		  }
 	      }
 	      break;
+
 	    case md_down:
 	      {
 		if (cols_this_row != col_total)
 		  {
 		    ::error ("number of columns must match");
 		    goto done;
 		  }
 		first_row = 0;
 		row_total += nr;
 		row_height = nr;
 		cols_this_row = nc;
 	      }
 	      break;
+
 	    default:
 	      panic_impossible ();
 	      break;
 	    }
 	}
     }
 
 // Don\'t forget to check to see if the last element will fit.
@@ -514,20 +517,22 @@ tree_matrix::eval (int print)
 	}
       else
 	{
 	  switch (list[i].direction)
 	    {
 	    case md_right:
 	      put_col += prev_nc;
 	      break;
+
 	    case md_down:
 	      put_row += prev_nr;
 	      put_col = 0;
 	      break;
+
 	    default:
 	      panic_impossible ();
 	      break;
 	    }
 	}
 
       if (found_complex)
 	{
@@ -612,19 +617,21 @@ tree_matrix::print_code (ostream& os)
 
       if (list)
 	{
 	  switch (list->direction)
 	    {
 	    case md_right:
 	      os << ", ";
 	      break;
+
 	    case md_down:
 	      os << "; ";
 	      break;
+
 	    default:
 	      break;
 	    }
 	}
     }
 
   os << "]";
 
@@ -639,17 +646,17 @@ tree_multi_val_ret::eval (int print)
 {
   panic ("invalid evaluation of generic expression");
   return tree_constant ();
 }
 
 // A base class for objects that can be evaluated with argument lists.
 
 tree_constant
-tree_fvc::assign (tree_constant& t, const Octave_object& args)
+tree_fvc::assign (const tree_constant& t, const Octave_object& args)
 {
   panic_impossible ();
   return tree_constant ();
 }
 
 tree_constant
 tree_fvc::lookup_map_element (SLList<char*>& list)
 {
@@ -682,17 +689,17 @@ tree_identifier::define (tree_function *
 void
 tree_identifier::document (char *s)
 {
   if (sym && s)
     sym->document (strsave (s));
 }
 
 tree_constant
-tree_identifier::assign (tree_constant& rhs)
+tree_identifier::assign (const tree_constant& rhs)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
@@ -713,17 +720,17 @@ tree_identifier::assign (tree_constant& 
       else
 	delete tmp;
     }
 
   return retval;
 }
 
 tree_constant
-tree_identifier::assign (tree_constant& rhs, const Octave_object& args)
+tree_identifier::assign (const tree_constant& rhs, const Octave_object& args)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
@@ -760,17 +767,17 @@ tree_identifier::assign (tree_constant& 
 	    }
 	}
     }
 
   return retval;
 }
 
 tree_constant
-tree_identifier::assign (SLList<char*> list, tree_constant& rhs)
+tree_identifier::assign (SLList<char*> list, const tree_constant& rhs)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
 
@@ -792,17 +799,17 @@ tree_identifier::assign (SLList<char*> l
       if (tmp)
 	retval = tmp->assign_map_element (list, rhs);
     }
 
   return retval;
 }
 
 tree_constant
-tree_identifier::assign (SLList<char*> list, tree_constant& rhs,
+tree_identifier::assign (SLList<char*> list, const tree_constant& rhs,
 			 const Octave_object& args)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
@@ -1087,30 +1094,30 @@ tree_indirect_ref::name (void)
 
       tmp << ends;
       nm = tmp.str ();
       return nm;
     }
 }
 
 tree_constant
-tree_indirect_ref::assign (tree_constant& t)
+tree_indirect_ref::assign (const tree_constant& t)
 {
   tree_constant retval;
 
   if (refs.empty ())
     retval = id->assign (t);
   else
     retval = id->assign (refs, t);
 
   return retval;
 }
 
 tree_constant
-tree_indirect_ref::assign (tree_constant& t, const Octave_object& args)
+tree_indirect_ref::assign (const tree_constant& t, const Octave_object& args)
 {
   tree_constant retval;
 
   if (refs.empty ())
     retval = id->assign (t, args);
   else
     retval = id->assign (refs, t, args);
 
@@ -1374,19 +1381,27 @@ tree_prefix_expression::eval (int print)
 }
 
 char *
 tree_prefix_expression::oper (void) const
 {
   static char *op;
   switch (etype)
     {
-    case tree_expression::increment: op = "++";        break;
-    case tree_expression::decrement: op = "--";        break;
-    default:                         op = "<unknown>"; break;
+    case tree_expression::increment:
+      op = "++";
+      break;
+
+    case tree_expression::decrement:
+      op = "--";
+      break;
+
+    default:
+      op = "<unknown>";
+      break;
     }
   return op;
 }
 
 void
 tree_prefix_expression::eval_error (void)
 {
   if (error_state > 0)
@@ -1440,19 +1455,27 @@ tree_postfix_expression::eval (int print
 }
 
 char *
 tree_postfix_expression::oper (void) const
 {
   static char *op;
   switch (etype)
     {
-    case tree_expression::increment: op = "++";        break;
-    case tree_expression::decrement: op = "--";        break;
-    default:                         op = "<unknown>"; break;
+    case tree_expression::increment:
+      op = "++";
+      break;
+
+    case tree_expression::decrement:
+      op = "--";
+      break;
+
+    default:
+      op = "<unknown>";
+      break;
     }
   return op;
 }
 
 void
 tree_postfix_expression::eval_error (void)
 {
   if (error_state > 0)
@@ -1509,35 +1532,50 @@ tree_unary_expression::eval (int print)
 		{
 		  retval = tree_constant ();
 		  if (error_state)
 		    eval_error ();
 		}
 	    }
 	}
       break;
+
     default:
       ::error ("unary operator %d not implemented", etype);
       break;
     }
 
   return retval;
 }
 
 char *
 tree_unary_expression::oper (void) const
 {
   static char *op;
   switch (etype)
     {
-    case tree_expression::not:        op = "!";         break;
-    case tree_expression::uminus:     op = "-";         break;
-    case tree_expression::hermitian:  op = "'";         break;
-    case tree_expression::transpose:  op = ".'";        break;
-    default:                          op = "<unknown>"; break;
+    case tree_expression::not:
+      op = "!";
+      break;
+
+    case tree_expression::uminus:
+      op = "-";
+      break;
+
+    case tree_expression::hermitian:
+      op = "'";
+      break;
+
+    case tree_expression::transpose:
+      op = ".'";
+      break;
+
+    default:
+      op = "<unknown>";
+      break;
     }
   return op;
 }
 
 void
 tree_unary_expression::eval_error (void)
 {
   if (error_state > 0)
@@ -1560,22 +1598,24 @@ tree_unary_expression::print_code (ostre
   switch (etype)
     {
     case tree_expression::not:
     case tree_expression::uminus:
       os << oper ();
       if (op)
 	op->print_code (os);
       break;
+
     case tree_expression::hermitian:
     case tree_expression::transpose:
       if (op)
 	op->print_code (os);
       os << oper ();
       break;
+
     default:
       os << oper ();
       if (op)
 	op->print_code (os);
       break;
     }
 
   if (in_parens)
@@ -1630,16 +1670,17 @@ tree_binary_expression::eval (int print)
 		      retval = tree_constant ();
 		      if (error_state)
 			eval_error ();
 		    }
 		}
 	    }
 	}
       break;
+
     case tree_expression::and_and:
     case tree_expression::or_or:
       {
 	int result = 0;
 	if (op1)
 	  {
 	    tree_constant a = op1->eval (0);
 	    if (error_state)
@@ -1688,51 +1729,114 @@ tree_binary_expression::eval (int print)
 		    break;
 		  }
 	      }
 	  }
       done:
 	retval = tree_constant ((double) result);
       }
       break;
+
     default:
       ::error ("binary operator %d not implemented", etype);
       break;
     }
 
   return retval;
 }
 
 char *
 tree_binary_expression::oper (void) const
 {
   static char *op;
   switch (etype)
     {
-    case tree_expression::add:        op = "+";         break;
-    case tree_expression::subtract:   op = "-";         break;
-    case tree_expression::multiply:   op = "*";         break;
-    case tree_expression::el_mul:     op = ".*";        break;
-    case tree_expression::divide:     op = "/";         break;
-    case tree_expression::el_div:     op = "./";        break;
-    case tree_expression::leftdiv:    op = "\\";        break;
-    case tree_expression::el_leftdiv: op = ".\\";       break;
-    case tree_expression::power:      op = "^";         break;
-    case tree_expression::elem_pow:   op = ".^";        break;
-    case tree_expression::cmp_lt:     op = "<";         break;
-    case tree_expression::cmp_le:     op = "<=";        break;
-    case tree_expression::cmp_eq:     op = "==";        break;
-    case tree_expression::cmp_ge:     op = ">=";        break;
-    case tree_expression::cmp_gt:     op = ">";         break;
-    case tree_expression::cmp_ne:     op = "!=";        break;
-    case tree_expression::and_and:    op = "&&";        break;
-    case tree_expression::or_or:      op = "||";        break;
-    case tree_expression::and:        op = "&";         break;
-    case tree_expression::or:         op = "|";         break;
-    default:                          op = "<unknown>"; break;
+    case tree_expression::add:
+      op = "+";
+      break;
+
+    case tree_expression::subtract:
+      op = "-";
+      break;
+
+    case tree_expression::multiply:
+      op = "*";
+      break;
+
+    case tree_expression::el_mul:
+      op = ".*";
+      break;
+
+    case tree_expression::divide:
+      op = "/";
+      break;
+
+    case tree_expression::el_div:
+      op = "./";
+      break;
+
+    case tree_expression::leftdiv:
+      op = "\\";
+      break;
+
+    case tree_expression::el_leftdiv:
+      op = ".\\";
+      break;
+
+    case tree_expression::power:
+      op = "^";
+      break;
+
+    case tree_expression::elem_pow:
+      op = ".^";
+      break;
+
+    case tree_expression::cmp_lt:
+      op = "<";
+      break;
+
+    case tree_expression::cmp_le:
+      op = "<=";
+      break;
+
+    case tree_expression::cmp_eq:
+      op = "==";
+      break;
+
+    case tree_expression::cmp_ge:
+      op = ">=";
+      break;
+
+    case tree_expression::cmp_gt:
+      op = ">";
+      break;
+
+    case tree_expression::cmp_ne:
+      op = "!=";
+      break;
+
+    case tree_expression::and_and:
+      op = "&&";
+      break;
+
+    case tree_expression::or_or:
+      op = "||";
+      break;
+
+    case tree_expression::and:
+      op = "&";
+      break;
+
+    case tree_expression::or:
+      op = "|";
+      break;
+
+    default:
+      op = "<unknown>";
+      break;
     }
   return op;
 }
 
 void
 tree_binary_expression::eval_error (void)
 {
   if (error_state > 0)
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -215,17 +215,18 @@ class
 tree_fvc : public tree_multi_val_ret
 {
 public:
   tree_fvc (int l = -1, int c = -1) : tree_multi_val_ret (l, c) { }
 
   virtual int is_constant (void) const
     { return 0; }
 
-  virtual tree_constant assign (tree_constant& t, const Octave_object& args);
+  virtual tree_constant assign (const tree_constant& t,
+				const Octave_object& args);
 
   virtual char *name (void) const
     { panic_impossible (); return 0; }
 
   virtual void bump_value (tree_expression::type)
     { panic_impossible (); }
 
   virtual tree_constant lookup_map_element (SLList<char*>& list);
@@ -274,21 +275,21 @@ public:
 
   char *name (void) const;
 
   tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
   void document (char *s);
 
-  tree_constant assign (tree_constant& t);
-  tree_constant assign (tree_constant& t, const Octave_object& args);
+  tree_constant assign (const tree_constant& t);
+  tree_constant assign (const tree_constant& t, const Octave_object& args);
 
-  tree_constant assign (SLList<char*> list, tree_constant& t);
-  tree_constant assign (SLList<char*> list, tree_constant& t,
+  tree_constant assign (SLList<char*> list, const tree_constant& t);
+  tree_constant assign (SLList<char*> list, const tree_constant& t,
 			const Octave_object& args); 
 
   int is_defined (void);
 
   void bump_value (tree_expression::type);
 
   tree_fvc *do_lookup (int& script_file_executed, int exec_script = 1);
 
@@ -344,18 +345,18 @@ public:
   tree_identifier *ident (void)
     { return id; }
 
   void preserve_identifier (void)
     { preserve_ident = 1; }
 
   char *name (void);
 
-  tree_constant assign (tree_constant& t);
-  tree_constant assign (tree_constant& t, const Octave_object& args);
+  tree_constant assign (const tree_constant& t);
+  tree_constant assign (const tree_constant& t, const Octave_object& args);
 
   void mark_for_possible_ans_assign (void)
     { id->mark_for_possible_ans_assign (); }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -45,16 +45,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-base.h"
 #include "tree-expr.h"
 #include "tree-cmd.h"
 #include "tree-const.h"
 #include "tree-plot.h"
 #include "load-save.h"
 #include "help.h"
 #include "error.h"
+#include "gripes.h"
 #include "utils.h"
 #include "defun.h"
 
 extern "C"
 {
 #include <readline/tilde.h>
 }
 
@@ -204,31 +205,34 @@ tree_plot_command::eval (void)
 	    {
 	      ::error ("replot: must have something to plot");
 	      return;
 	    }
 	}
       else
 	plot_buf << "replot";
       break;
+
     case 2:
       if (clear_before_plotting || plot_line_count == 0)
 	{
 	  plot_line_count = 0;
 	  plot_buf << "plot";
 	}
       else
 	plot_buf << "replot";
       break;
+
     case 3:
       {
 	plot_line_count = 0;
 	plot_buf << "splot";
       }
       break;
+
     default:
       gripe_2_or_3_dim_plot ();
       return;
     }
 
   if (range)
     {
       if (plot_line_count == 0)
@@ -277,22 +281,25 @@ tree_plot_command::print_code (ostream& 
 {
   print_code_indent (os);
 
   switch (ndim)
     {
     case 1:
       os << "replot";
       break;
+
     case 2:
       os << "gplot";
       break;
+
     case 3:
       os << "gsplot";
       break;
+
     default:
       os << "<unkown plot command>";
       break;
     }
 
   if (range)
     range->print_code (os);
 
@@ -682,19 +689,21 @@ subplot::print (int ndim, ostrstream& pl
 	    }
 
 	  nc = data.columns ();
 	  switch (ndim)
 	    {
 	    case 2:
 	      file = save_in_tmp_file (data, ndim);
 	      break;
+
 	    case 3:
 	      file = save_in_tmp_file (data, ndim, parametric_plot);
 	      break;
+
 	    default:
 	      gripe_2_or_3_dim_plot ();
 	      break;
 	    }
 
 	  if (file)
 	    {
 	      mark_for_deletion (file);
@@ -812,19 +821,21 @@ save_in_tmp_file (tree_constant& t, int 
       ofstream file (name);
       if (file)
 	{
 	  switch (ndim)
 	    {
 	    case 2:
 	      save_ascii_data (file, t);
 	      break;
+
 	    case 3:
 	      save_three_d (file, t, parametric);
 	      break;
+
 	    default:
 	      gripe_2_or_3_dim_plot ();
 	      break;
 	    }
 	}
       else
 	{
 	  error ("couldn't open temporary output file `%s'", name);
@@ -879,24 +890,26 @@ drawn.  With no argument, toggle the cur
 
   DEFINE_ARGV("hold");
 
   switch (argc)
     {
     case 1:
       clear_before_plotting = ! clear_before_plotting;
       break;
+
     case 2:
       if (strcasecmp (argv[1], "on") == 0)
 	clear_before_plotting = 0;
       else if (strcasecmp (argv[1], "off") == 0)
 	clear_before_plotting = 1;
       else
 	print_usage ("hold");
       break;
+
     default:
       print_usage ("hold");
       break;
     }
 
   DELETE_ARGV;
 
   return retval;
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -25,16 +25,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "config.h"
 #endif
 
 #include <time.h>
 
 #include "tree-const.h"
 #include "f77-uscore.h"
 #include "error.h"
+#include "gripes.h"
 #include "utils.h"
 #include "help.h"
 #include "defun-dld.h"
 
 // Possible distributions of random numbers.
 enum rand_dist { uniform, normal };
 
 // Current distribution of random numbers.
@@ -244,20 +245,22 @@ rand (SEED, N)        -- set seed")
 	    double d_one = 1.0;
 	    double val;
 	    switch (current_distribution)
 	      {
 	      case uniform:
 		F77_FCN (dgenunf) (&d_zero, &d_one, &val);
 		rand_mat.elem (i, j) = val;
 		break;
+
 	      case normal:
 		F77_FCN (dgennor) (&d_zero, &d_one, &val);
 		rand_mat.elem (i, j) = val;
 		break;
+
 	      default:
 		panic_impossible ();
 		break;
 	      }
 	  }
 
       retval(0) = rand_mat;
     }
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -21,16 +21,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "tree-const.h"
+#include "error.h"
+#include "gripes.h"
 #include "help.h"
 #include "defun-dld.h"
 
 static void
 mx_sort (Matrix& m, Matrix& idx, int return_idx)
 {
   int nr = m.rows ();
   int nc = m.columns ();
diff --git a/src/tc-rep-ass.cc b/src/tc-rep-ass.cc
--- a/src/tc-rep-ass.cc
+++ b/src/tc-rep-ass.cc
@@ -44,54 +44,51 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "pager.h"
 #include "pr-output.h"
 #include "tree-const.h"
 #include "idx-vector.h"
 #include "oct-map.h"
 
 #include "tc-inlines.h"
 
-// Top-level tree-constant function that handle assignments.  Only
+// Top-level tree-constant function that handles assignments.  Only
 // decide if the left-hand side is currently a scalar or a matrix and
 // hand off to other functions to do the real work.
 
 void
 TC_REP::assign (const tree_constant& rhs, const Octave_object& args)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
 // This is easier than actually handling assignments to strings.
 // An assignment to a range will normally require a conversion to a
 // vector since it will normally destroy the equally-spaced property
 // of the range elements.
 
-  if (type_tag == string_constant || type_tag == range_constant)
+  if (! is_numeric_type ())
     force_numeric ();
 
+  if (error_state)
+    return;
+
   switch (type_tag)
     {
     case complex_scalar_constant:
     case scalar_constant:
     case unknown_constant:
       do_scalar_assignment (rhs_tmp, args);
       break;
 
     case complex_matrix_constant:
     case matrix_constant:
       do_matrix_assignment (rhs_tmp, args);
       break;
 
-    case string_constant:
-      ::error ("invalid assignment to string type");
-      break;
-
-    case range_constant:
-    case magic_colon:
     default:
-      panic_impossible ();
+      ::error ("invalid assignment to %s", type_as_string ());
       break;
     }
 }
 
 // Assignments to scalars.  If resize_on_range_error is true,
 // this can convert the left-hand side to a matrix.
 
 void
@@ -660,16 +657,17 @@ TC_REP::vector_assignment (const tree_co
 	if (! indexed_assign_conforms (nr, nc, rhs_nr, rhs_nc))
 	  {
 	    ::error ("A(:) = X: X and A must have the same dimensions");
 	    return;
 	  }
 	do_matrix_assignment (rhs, magic_colon, magic_colon);
       }
       break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 // Check whether an indexed assignment to a vector is valid.
 
@@ -1184,16 +1182,17 @@ TC_REP::do_matrix_assignment (const tree
 	    ::error ("A(int,:) = X: X must be a row vector with the same");
 	    ::error ("number of columns as A");
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, i, magic_colon);
       }
       break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 /* MA2 */
 void
@@ -1320,16 +1319,17 @@ TC_REP::do_matrix_assignment (const tree
 	    ::error ("number of elements in matrix, and the number of columns");
 	    ::error ("in X must match the number of columns in A");
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, iv, magic_colon);
       }
       break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 /* MA3 */
 void
@@ -1461,16 +1461,17 @@ TC_REP::do_matrix_assignment (const tree
 	    ::error ("number of elements in range, and the number of columns");
 	    ::error ("in X must match the number of columns in A");
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, ri, magic_colon);
       }
       break;
+
     default:
       panic_impossible ();
       break;
     }
 }
 
 /* MA4 */
 void
diff --git a/src/tc-rep-idx.cc b/src/tc-rep-idx.cc
--- a/src/tc-rep-idx.cc
+++ b/src/tc-rep-idx.cc
@@ -46,16 +46,18 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "idx-vector.h"
 #include "oct-map.h"
 
 #include "tc-inlines.h"
 
 // Indexing functions.
 
+// This is the top-level indexing function.
+
 tree_constant
 TC_REP::do_index (const Octave_object& args)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
@@ -92,27 +94,26 @@ TC_REP::do_index (const Octave_object& a
       retval = do_matrix_index (args);
       break;
 
     case string_constant:
       gripe_string_invalid ();
 //      retval = do_string_index (args);
       break;
 
-    case magic_colon:
-    case range_constant:
+    default:
+
 // This isn\'t great, but it\'s easier than implementing a lot of
-// range indexing functions.
+// other special indexing functions.
+
       force_numeric ();
-      assert (type_tag != magic_colon && type_tag != range_constant);
-      retval = do_index (args);
-      break;
 
-    default:
-      panic_impossible ();
+      if (! error_state && is_numeric_type ())
+	retval = do_index (args);
+
       break;
     }
 
   return retval;
 }
 
 tree_constant
 TC_REP::do_scalar_index (const Octave_object& args) const
@@ -1419,18 +1420,18 @@ TC_REP::do_matrix_index (TC_REP::constan
     {
     case complex_scalar_constant:
       retval = *complex_scalar;
       break;
 
     case scalar_constant:
       retval = scalar;
       break;
+
     case complex_matrix_constant:
-
       retval = *complex_matrix;
       break;
 
     case matrix_constant:
       retval = *matrix;
       break;
 
     case range_constant:
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -287,65 +287,69 @@ TC_REP::tree_constant_rep (const char *s
   type_tag = string_constant;
   orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
-  if (nel < 0)
-    {
-      delete range;
-      type_tag = unknown_constant;
-      if (nel == -1)
-	::error ("number of elements in range exceeds INT_MAX");
-      else
-	::error ("invalid range");
-    }
-  else if (nel > 1)
+  if (nel > 1)
     type_tag = range_constant;
   else
     {
       delete range;
       if (nel == 1)
 	{
 	  scalar = b;
 	  type_tag = scalar_constant;
 	}
       else if (nel == 0)
 	{
 	  matrix = new Matrix ();
 	  type_tag = matrix_constant;
 	}
       else
-	panic_impossible ();
+	{
+	  type_tag = unknown_constant;
+	  if (nel == -1)
+	    ::error ("number of elements in range exceeds INT_MAX");
+	  else
+	    ::error ("invalid range");
+	}
     }
   orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const Range& r)
 {
-  if (r.nelem () > 1)
+  int nel = r.nelem ();
+  if (nel > 1)
     {
       range = new Range (r);
       type_tag = range_constant;
     }
-  else if (r.nelem () == 1)
+  else if (nel == 1)
     {
       scalar = r.base ();
       type_tag = scalar_constant;
     }
-  else if (r.nelem () == 0)
+  else if (nel == 0)
     {
       matrix = new Matrix ();
       type_tag = matrix_constant;
     }
   else
-    panic_impossible ();
+    {
+      type_tag = unknown_constant;
+      if (nel == -1)
+	::error ("number of elements in range exceeds INT_MAX");
+      else
+	::error ("invalid range");
+    }
 
   orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const Octave_map& m)
 {
   a_map = new Octave_map (m);
   type_tag = map_constant;
@@ -393,20 +397,16 @@ TC_REP::tree_constant_rep (const tree_co
       break;
 
     case map_constant:
       a_map = new Octave_map (*(t.a_map));
       break;
 
     case magic_colon:
       break;
-
-    default:
-      panic_impossible ();
-      break;
     }
 
   orig_text = strsave (t.orig_text);
 }
 
 TC_REP::~tree_constant_rep (void)
 {
   switch (type_tag)
@@ -430,17 +430,19 @@ TC_REP::~tree_constant_rep (void)
     case range_constant:
       delete range;
       break;
 
     case map_constant:
       delete a_map;
       break;
 
-    default:
+    case unknown_constant:
+    case scalar_constant:
+    case magic_colon:
       break;
     }
 
   delete [] orig_text;
 }
 
 #if defined (MDEBUG)
 void *
@@ -483,24 +485,19 @@ TC_REP::rows (void) const
     case complex_matrix_constant:
       retval = complex_matrix->rows ();
       break;
 
     case magic_colon:
       ::error ("invalid use of colon operator");
       break;
 
-    case unknown_constant:
-    case map_constant:
+    default:
       retval = -1;
       break;
-
-    default:
-      panic_impossible ();
-      break;
     }
 
   return retval;
 }
 
 int
 TC_REP::columns (void) const
 {
@@ -528,40 +525,38 @@ TC_REP::columns (void) const
     case range_constant:
       retval = range->nelem ();
       break;
 
     case magic_colon:
       ::error ("invalid use of colon operator");
       break;
 
-    case unknown_constant:
-    case map_constant:
+    default:
       retval = -1;
       break;
-
-    default:
-      panic_impossible ();
-      break;
     }
 
   return retval;
 }
 
 tree_constant
 TC_REP::all (void) const
 {
-  if (type_tag == string_constant || type_tag == range_constant)
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  if (! is_numeric_type ())
     {
       tree_constant tmp = make_numeric ();
       return tmp.all ();
     }
 
-  tree_constant retval;
-
   switch (type_tag)
     {
     case scalar_constant:
       {
 	double status = (scalar != 0.0);
 	retval = tree_constant (status);
       }
       break;
@@ -582,38 +577,38 @@ TC_REP::all (void) const
 
     case complex_matrix_constant:
       {
 	Matrix m = complex_matrix->all ();
 	retval = tree_constant (m);
       }
       break;
 
-    case string_constant:
-    case range_constant:
-    case magic_colon:
     default:
-      panic_impossible ();
+      gripe_wrong_type_arg ("all", *this);
       break;
     }
 
   return retval;
 }
 
 tree_constant
 TC_REP::any (void) const
 {
-  if (type_tag == string_constant || type_tag == range_constant)
+  tree_constant retval;
+
+  if (error_state)
+    return retval;
+
+  if (! is_numeric_type ())
     {
       tree_constant tmp = make_numeric ();
       return tmp.any ();
     }
 
-  tree_constant retval;
-
   switch (type_tag)
     {
     case scalar_constant:
       {
 	double status = (scalar != 0.0);
 	retval = tree_constant (status);
       }
       break;
@@ -634,21 +629,18 @@ TC_REP::any (void) const
 
     case complex_matrix_constant:
       {
 	Matrix m = complex_matrix->any ();
 	retval = tree_constant (m);
       }
       break;
 
-    case string_constant:
-    case range_constant:
-    case magic_colon:
     default:
-      panic_impossible ();
+      gripe_wrong_type_arg ("any", *this);
       break;
     }
 
   return retval;
 }
 
 int
 TC_REP::valid_as_scalar_index (void) const
@@ -657,24 +649,27 @@ TC_REP::valid_as_scalar_index (void) con
 	  || (type_tag == scalar_constant && NINT (scalar) == 1)
 	  || (type_tag == range_constant
 	      && range->nelem () == 1 && NINT (range->base ()) == 1));
 }
 
 int
 TC_REP::is_true (void) const
 {
-  if (type_tag == string_constant || type_tag == range_constant)
+  int retval = 0;
+
+  if (error_state)
+    return retval;
+
+  if (! is_numeric_type ())
     {
       tree_constant tmp = make_numeric ();
       return tmp.is_true ();
     }
 
-  int retval;
-
   switch (type_tag)
     {
     case scalar_constant:
       retval = (scalar != 0.0);
       break;
 
     case matrix_constant:
       {
@@ -693,21 +688,18 @@ TC_REP::is_true (void) const
       {
 	Matrix m = (complex_matrix->all ()) . all ();
 	retval = (m.rows () == 1
 		  && m.columns () == 1
 		  && m.elem (0, 0) != 0.0);
       }
       break;
 
-    case string_constant:
-    case range_constant:
-    case magic_colon:
     default:
-      panic_impossible ();
+      gripe_wrong_type_arg (0, *this);
       break;
     }
 
   return retval;
 }
 
 static void
 warn_implicit_conversion (const char *from, const char *to)
@@ -1215,19 +1207,18 @@ TC_REP::convert_to_str (void) const
 	delete [] s;
       }
       break;
 
     case string_constant:
       retval = string;
       break;
 
-    case magic_colon:
     default:
-      panic_impossible ();
+      gripe_invalid_conversion (type_as_string (), "string");
       break;
     }
 
   return retval;
 }
 
 void
 TC_REP::convert_to_row_or_column_vector (void)
@@ -1349,19 +1340,18 @@ TC_REP::force_numeric (int force_str_con
 	else if (len == 1)
 	  {
 	    type_tag = scalar_constant;
 	    scalar = range->base ();
 	  }
       }
       break;
 
-    case magic_colon:
     default:
-      panic_impossible ();
+      gripe_invalid_conversion (type_as_string (), "numeric type");
       break;
     }
 }
 
 tree_constant
 TC_REP::make_numeric (int force_str_conv) const
 {
   tree_constant retval;
@@ -1389,19 +1379,18 @@ TC_REP::make_numeric (int force_str_conv
       retval.force_numeric (force_str_conv);
       break;
 
     case range_constant:
       retval = tree_constant (*range);
       retval.force_numeric (force_str_conv);
       break;
 
-    case magic_colon:
     default:
-      panic_impossible ();
+      gripe_invalid_conversion (type_as_string (), "numeric value");
       break;
     }
 
   return retval;
 }
 
 void
 TC_REP::bump_value (tree_expression::type etype)
@@ -1422,55 +1411,45 @@ TC_REP::bump_value (tree_expression::typ
 	case complex_scalar_constant:
 	  *complex_scalar = *complex_scalar + 1.0;
 	  break;
 
 	case complex_matrix_constant:
 	  *complex_matrix = *complex_matrix + 1.0;
 	  break;
 
-	case string_constant:
-	  ::error ("string++ and ++string not implemented yet, ok?");
-	  break;
-
 	case range_constant:
 	  range->set_base (range->base () + 1.0);
 	  range->set_limit (range->limit () + 1.0);
 	  break;
 
-	case magic_colon:
 	default:
-	  panic_impossible ();
+	  gripe_wrong_type_arg ("operator ++", type_as_string ());
 	  break;
 	}
       break;
 
     case tree_expression::decrement:
       switch (type_tag)
 	{
 	case scalar_constant:
 	  scalar--;
 	  break;
 
 	case matrix_constant:
 	  *matrix = *matrix - 1.0;
 	  break;
 
-	case string_constant:
-	  ::error ("string-- and -- string not implemented yet, ok?");
-	  break;
-
 	case range_constant:
 	  range->set_base (range->base () - 1.0);
 	  range->set_limit (range->limit () - 1.0);
 	  break;
 
-	case magic_colon:
 	default:
-	  panic_impossible ();
+	  gripe_wrong_type_arg ("operator --", type_as_string ());
 	  break;
 	}
       break;
 
     default:
       panic_impossible ();
       break;
     }
@@ -1485,17 +1464,17 @@ TC_REP::resize (int i, int j)
       matrix->resize (i, j);
       break;
 
     case complex_matrix_constant:
       complex_matrix->resize (i, j);
       break;
 
     default:
-      panic_impossible ();
+      gripe_wrong_type_arg ("resize", type_as_string ());
       break;
     }
 }
 
 void
 TC_REP::resize (int i, int j, double val)
 {
   switch (type_tag)
@@ -1504,17 +1483,17 @@ TC_REP::resize (int i, int j, double val
       matrix->resize (i, j, val);
       break;
 
     case complex_matrix_constant:
       complex_matrix->resize (i, j, val);
       break;
 
     default:
-      panic_impossible ();
+      gripe_wrong_type_arg ("resize", type_as_string ());
       break;
     }
 }
 
 void
 TC_REP::maybe_resize (int i, int j)
 {
   int nr = rows ();
@@ -1620,26 +1599,17 @@ TC_REP::maybe_mutate (void)
 	{
 	  Matrix *m = new Matrix (::real (*complex_matrix));
 	  delete complex_matrix;
 	  matrix = m;
 	  type_tag = matrix_constant;
 	}
       break;
 
-    case scalar_constant:
-    case matrix_constant:
-    case string_constant:
-    case range_constant:
-    case map_constant:
-    case magic_colon:
-      break;
-
     default:
-      panic_impossible ();
       break;
     }
 
 // Avoid calling rows() and columns() for things like magic_colon.
 
   int nr = 1;
   int nc = 1;
   if (type_tag == matrix_constant
@@ -1735,18 +1705,18 @@ TC_REP::print (void)
 		    first = 0;
 		  }
 		output_buf << " " << a_map->key (p);
 	      }
 	    output_buf << ">\n";
 	  }
 	  break;
 
+	case unknown_constant:
 	case magic_colon:
-	default:
 	  panic_impossible ();
 	  break;
 	}
 
       output_buf << ends;
       maybe_page_output (output_buf);
     }
 }
@@ -1844,22 +1814,33 @@ TC_REP::print_code (ostream& os)
     case range_constant:
       octave_print_internal (os, *range, 1);
       break;
 
     case magic_colon:
       os << ":";
       break;
 
-    default:
+    case map_constant:
+    case unknown_constant:
       panic_impossible ();
       break;
     }
 }
 
+void
+TC_REP::gripe_wrong_type_arg (const char *name,
+			      const tree_constant_rep& tcr) const
+{
+  if (name)
+    ::error ("%s: wrong type argument `%s'", name, tcr.type_as_string ());
+  else
+    ::error ("wrong type argument `%s'", name, tcr.type_as_string ());
+}
+
 char *
 TC_REP::type_as_string (void) const
 {
   switch (type_tag)
     {
     case scalar_constant:
       return "real scalar";
 
@@ -1873,44 +1854,54 @@ TC_REP::type_as_string (void) const
       return "complex matrix";
 
     case string_constant:
       return "string";
 
     case range_constant:
       return "range";
 
+    case map_constant:
+      return "structure";
+
     default:
       return "<unknown type>";
     }
 }
 
 tree_constant
 do_binary_op (tree_constant& a, tree_constant& b, tree_expression::type t)
 {
-  tree_constant ans;
+  tree_constant retval;
 
   int first_empty = (a.rows () == 0 || a.columns () == 0);
   int second_empty = (b.rows () == 0 || b.columns () == 0);
 
   if (first_empty || second_empty)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("binary operation on empty matrix");
       else if (flag == 0)
 	{
 	  ::error ("invalid binary operation on empty matrix");
-	  return ans;
+	  return retval;
 	}
     }
 
   tree_constant tmp_a = a.make_numeric ();
+
+  if (error_state)
+    return retval;
+
   tree_constant tmp_b = b.make_numeric ();
 
+  if (error_state)
+    return retval;
+
   TC_REP::constant_type a_type = tmp_a.const_type ();
   TC_REP::constant_type b_type = tmp_b.const_type ();
 
   double d1, d2;
   Matrix m1, m2;
   Complex c1, c2;
   ComplexMatrix cm1, cm2;
 
@@ -1919,199 +1910,196 @@ do_binary_op (tree_constant& a, tree_con
     case TC_REP::scalar_constant:
 
       d1 = tmp_a.double_value ();
 
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
-	  ans = do_binary_op (d1, d2, t);
+	  retval = do_binary_op (d1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
 	  m2 = tmp_b.matrix_value ();
-	  ans = do_binary_op (d1, m2, t);
+	  retval = do_binary_op (d1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
-	  ans = do_binary_op (d1, c2, t);
+	  retval = do_binary_op (d1, c2, t);
 	  break;
 
 	case TC_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
-	  ans = do_binary_op (d1, cm2, t);
+	  retval = do_binary_op (d1, cm2, t);
 	  break;
 
-	case TC_REP::magic_colon:
 	default:
-	  panic_impossible ();
+	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
     case TC_REP::matrix_constant:
 
       m1 = tmp_a.matrix_value ();
 
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
-	  ans = do_binary_op (m1, d2, t);
+	  retval = do_binary_op (m1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
 	  m2 = tmp_b.matrix_value ();
-	  ans = do_binary_op (m1, m2, t);
+	  retval = do_binary_op (m1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
-	  ans = do_binary_op (m1, c2, t);
+	  retval = do_binary_op (m1, c2, t);
 	  break;
 
 	case TC_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
-	  ans = do_binary_op (m1, cm2, t);
+	  retval = do_binary_op (m1, cm2, t);
 	  break;
 
-	case TC_REP::magic_colon:
 	default:
-	  panic_impossible ();
+	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
     case TC_REP::complex_scalar_constant:
 
       c1 = tmp_a.complex_value ();
 
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
-	  ans = do_binary_op (c1, d2, t);
+	  retval = do_binary_op (c1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
 	  m2 = tmp_b.matrix_value ();
-	  ans = do_binary_op (c1, m2, t);
+	  retval = do_binary_op (c1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
-	  ans = do_binary_op (c1, c2, t);
+	  retval = do_binary_op (c1, c2, t);
 	  break;
 
 	case TC_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
-	  ans = do_binary_op (c1, cm2, t);
+	  retval = do_binary_op (c1, cm2, t);
 	  break;
 
-	case TC_REP::magic_colon:
 	default:
-	  panic_impossible ();
+	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
     case TC_REP::complex_matrix_constant:
 
       cm1 = tmp_a.complex_matrix_value ();
 
       switch (b_type)
 	{
 	case TC_REP::scalar_constant:
 	  d2 = tmp_b.double_value ();
-	  ans = do_binary_op (cm1, d2, t);
+	  retval = do_binary_op (cm1, d2, t);
 	  break;
 
 	case TC_REP::matrix_constant:
 	  m2 = tmp_b.matrix_value ();
-	  ans = do_binary_op (cm1, m2, t);
+	  retval = do_binary_op (cm1, m2, t);
 	  break;
 
 	case TC_REP::complex_scalar_constant:
 	  c2 = tmp_b.complex_value ();
-	  ans = do_binary_op (cm1, c2, t);
+	  retval = do_binary_op (cm1, c2, t);
 	  break;
 
 	case TC_REP::complex_matrix_constant:
 	  cm2 = tmp_b.complex_matrix_value ();
-	  ans = do_binary_op (cm1, cm2, t);
+	  retval = do_binary_op (cm1, cm2, t);
 	  break;
 
-	case TC_REP::magic_colon:
 	default:
-	  panic_impossible ();
+	  gripe_wrong_type_arg_for_binary_op (tmp_b);
 	  break;
 	}
       break;
 
-    case TC_REP::magic_colon:
     default:
-      panic_impossible ();
+      gripe_wrong_type_arg_for_binary_op (tmp_a);
       break;
     }
 
-  return ans;
+  return retval;
 }
 
 tree_constant
 do_unary_op (tree_constant& a, tree_expression::type t)
 {
-  tree_constant ans;
+  tree_constant retval;
 
   if (a.rows () == 0 || a.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("unary operation on empty matrix");
       else if (flag == 0)
 	{
 	  ::error ("invalid unary operation on empty matrix");
-	  return ans;
+	  return retval;
 	}
     }
 
   tree_constant tmp_a = a.make_numeric ();
 
+  if (error_state)
+    return retval;
+
   switch (tmp_a.const_type ())
     {
     case TC_REP::scalar_constant:
-      ans = do_unary_op (tmp_a.double_value (), t);
+      retval = do_unary_op (tmp_a.double_value (), t);
       break;
 
     case TC_REP::matrix_constant:
       {
 	Matrix m = tmp_a.matrix_value ();
-	ans = do_unary_op (m, t);
+	retval = do_unary_op (m, t);
       }
       break;
 
     case TC_REP::complex_scalar_constant:
-      ans = do_unary_op (tmp_a.complex_value (), t);
+      retval = do_unary_op (tmp_a.complex_value (), t);
       break;
 
     case TC_REP::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp_a.complex_matrix_value ();
-	ans = do_unary_op (m, t);
+	retval = do_unary_op (m, t);
       }
       break;
 
-    case TC_REP::magic_colon:
     default:
-      panic_impossible ();
+      gripe_wrong_type_arg_for_unary_op (tmp_a);
       break;
     }
 
-  return ans;
+  return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/tc-rep.h b/src/tc-rep.h
--- a/src/tc-rep.h
+++ b/src/tc-rep.h
@@ -204,16 +204,19 @@ private:
   void stash_original_text (char *s);
 
   void maybe_mutate (void);
 
   void print (void);
 
   void print_code (ostream& os);
 
+  void gripe_wrong_type_arg (const char *name,
+			     const tree_constant_rep& tcr) const;
+
   char *type_as_string (void) const;
 
 // Binary and unary operations.
 
   friend tree_constant do_binary_op (tree_constant& a, tree_constant& b,
 				     tree_expression::type t);
 
   friend tree_constant do_unary_op (tree_constant& a,
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -264,24 +264,28 @@ saved_variable::~saved_variable (void)
 void
 saved_variable::restore_value (void)
 {
   switch (type_tag)
     {
     case integer:
       *ptr_to_int = int_value;
       break;
+
     case generic_ptr:
       *ptr_to_gen_ptr = gen_ptr_value;
       break;
+
     case generic:
       memcpy (gen_ptr, gen_ptr_value, size);
       break;
+
     default:
       panic_impossible ();
+      break;
     }
 }
 
 static void
 restore_saved_variable (void *s)
 {
   saved_variable *sv = (saved_variable *) s;
   sv->restore_value ();
