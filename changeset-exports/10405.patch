# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1268118390 -3600
#      Tue Mar 09 08:06:30 2010 +0100
# Node ID cc69a17ec801ca7376f120d5d1e7766e215b7de5
# Parent  b40a5fd3af4157c64b6c236307249cc133fdc72e
remove integer math warnings

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,19 @@
+2010-03-09  Jaroslav Hajek  <highegg@gmail.com>
+
+	* oct-inttypes.h (octave_int_base::ftrunc, octave_int_base::fnon_int,
+	octave_int_base::fnan, octave_int_base::get_trunc_flag,
+	octave_int_base::get_nan_flag,
+	octave_int_base::get_non_int_flag,
+	octave_int_base::get_math_trunc_flag,
+	octave_int_base::clear_conv_flags): Remove.
+	Remove occurences of ftrunc, fnon_int and fnan eveywhere.
+	* oct-inttypes.cc: Ditto last sentence. Remove warning tests.
+
 2010-03-07  Soren Hauberg  <hauberg@gmail.com>
 
 	* dim-vector.h: New constructor accepting a C array of dimensions.
 
 2010-03-05  Jaroslav Hajek  <highegg@gmail.com>
 
 	* MArray.cc (MArray<T>::idx_add_nd): New method.
 	* MArray.h: Declare it.
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -175,17 +175,16 @@ octave_int_arith_base<uint64_t, false>::
       uint64_t lx = static_cast<uint32_t> (x);
       uint64_t ly = static_cast<uint32_t> (y);
       res = lx*ly;
     }
 
   return res;
 
 overflow:
-  ftrunc = true;
   return max_val ();
 }
 
 template <>
 int64_t 
 octave_int_arith_base<int64_t, true>::mul (int64_t x, int64_t y)
 { 
   // The signed case is far worse. The problem is that
@@ -235,36 +234,33 @@ octave_int_arith_base<int64_t, true>::mu
       uint64_t ly = static_cast<uint32_t> (usy);
       res = lx*ly;
     }
 
   if (positive)
     {
       if (res > static_cast<uint64_t> (max_val ()))
         {
-          ftrunc = true;
           return max_val ();
         }
       else
         return static_cast<int64_t> (res);
     }
   else
     {
       if (res > static_cast<uint64_t> (-min_val ()))
         {
-          ftrunc = true;
           return min_val ();
         }
       else
         return -static_cast<int64_t> (res);
     }
 
 
 overflow:
-  ftrunc = true;
   return positive ? max_val () : min_val ();
 
 }
 
 #define INT_DOUBLE_BINOP_DECL(OP,SUFFIX) \
   template <> \
   OCTAVE_API octave_ ## SUFFIX \
   operator OP (const octave_ ## SUFFIX & x, const double& y)
@@ -617,37 +613,22 @@ INSTANTIATE_INTTYPE (uint64_t);
 
 // Tests follow.
 
 /*
 
 %!assert(intmax("int64")/intmin("int64"),int64(-1))
 %!assert(intmin("int64")/int64(-1),intmax("int64"))
 %!assert(int64(2**63),intmax("int64"))
-%!test
-%! wstate = warning("query", "Octave:int-convert-overflow");
-%! warning("on", "Octave:int-convert-overflow");
-%! fail("int64(2**63)","warning",".*")
-%! warning(wstate.state, "Octave:int-convert-overflow");
 %!assert(uint64(2**64),intmax("uint64"))
 %!test
 %! a = 1.9*2^61; b = uint64(a); b++; assert(b > a)
 %!test
 %! a = -1.9*2^61; b = int64(a); b++; assert(b > a)
 %!test
 %! a = int64(-2**60) + 2; assert(1.25*a == (5*a)/4)
 %!test
 %! a = uint64(2**61) + 2; assert(1.25*a == (5*a)/4)
 %!assert(int32(2**31+0.5),intmax('int32'))
-%!test
-%! wstate = warning("query", "Octave:int-convert-overflow");
-%! warning("on", "Octave:int-convert-overflow");
-%! fail("int32(2**31+0.5)","warning",".*")
-%! warning(wstate.state, "Octave:int-convert-overflow");
 %!assert(int32(-2**31-0.5),intmin('int32'))
-%!test
-%! wstate = warning("query", "Octave:int-convert-overflow");
-%! warning("on", "Octave:int-convert-overflow");
-%! fail("int32(-2**31-0.5)","warning",".*")
-%! warning(wstate.state, "Octave:int-convert-overflow");
 %!assert((int64(2**62)+1)**1, int64(2**62)+1)
 %!assert((int64(2**30)+1)**2, int64(2**60+2**31) + 1)
 */
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -241,22 +241,20 @@ public:
       typedef octave_int_cmp_op::gt gt;
       typedef typename if_then_else<omit_chk_min, cf, lt>::result chk_min;
       typedef typename if_then_else<omit_chk_max, cf, gt>::result chk_max;
 
       // Efficiency of the following depends on inlining and dead code
       // elimination, but that should be a piece of cake for most compilers.
       if (chk_min::op (value, static_cast<S> (min_val ())))
         {
-          ftrunc = true;
           return min_val ();
         }
       else if (chk_max::op (value, static_cast<S> (max_val ())))
         {
-          ftrunc = true;
           return max_val ();
         }
       else
         return static_cast<T> (value);
     }
 
 private:
 
@@ -279,72 +277,34 @@ public:
   static T 
   convert_real (const S& value)
     {
       // Compute proper thresholds.
       static const S thmin = compute_threshold (static_cast<S> (min_val ()), min_val ());
       static const S thmax = compute_threshold (static_cast<S> (max_val ()), max_val ());
       if (xisnan (value))
         {
-          fnan = true;
           return static_cast<T> (0);
         }
       else if (value < thmin)
         {
-          ftrunc = true;
           return min_val ();
         }
       else if (value > thmax)
         {
-          ftrunc = true;
           return max_val ();
         }
       else
         {
           S rvalue = xround (value);
-          if (rvalue != value) fnon_int = true;
           return static_cast<T> (rvalue);
         }
     }
-
-  // Exception flags rationale:
-  // There is little reason to distinguish math and conversion exceptions at
-  // octave_int level. Doing this would require special constructors for
-  // intermediate int results in math computations.
-  // 
-  // Boolean flags are used rather than a single flag, because raising a boolean
-  // flag is faster than masking an int flag (single mov versus mov, or, mov).
-  // Also, it is atomic, and thus thread-safe (but there is *one* flag for all
-  // threads).
-
-  static bool get_trunc_flag () { return ftrunc; }
-  static bool get_nan_flag () { return fnan; }
-  static bool get_non_int_flag () { return fnon_int; }
-  static void clear_conv_flags () 
-    { 
-      ftrunc = false;
-      fnan = false;
-      fnon_int = false;
-    }
-  // For compatibility.
-  static bool get_math_trunc_flag () { return ftrunc || fnan; }
-  static void clear_conv_flag () { clear_conv_flags (); }
-
-protected:
-
-  // Conversion flags.
-  static bool ftrunc;
-  static bool fnon_int;
-  static bool fnan;
 };
 
-template<class T> bool octave_int_base<T>::ftrunc = false;
-template<class T> bool octave_int_base<T>::fnon_int = false;
-template<class T> bool octave_int_base<T>::fnan = false;
-
 // Saturated (homogeneous) integer arithmetics. The signed and unsigned
 // implementations are significantly different, so we implement another layer
 // and completely specialize. Arithmetics inherits from octave_int_base so that
 // it can use its exceptions and truncation functions.
 
 template <class T, bool is_signed>
 class octave_int_arith_base
 { };
@@ -365,44 +325,41 @@ public:
   // Shifts do not overflow.
   static T
   rshift (T x, int n) { return x >> n; }
 
   static T
   lshift (T x, int n) { return x << n; }
 
   static T
-  minus (T x)
+  minus (T)
     {
-      if (x != 0) octave_int_base<T>::ftrunc = true;
       return static_cast<T> (0);
     }
 
   // the overflow behaviour for unsigned integers is guaranteed by C/C++,
   // so the following should always work.
   static T 
   add (T x, T y)
     {
       T u = x + y;
       if (u < x)
         {
           u = octave_int_base<T>::max_val ();
-          octave_int_base<T>::ftrunc = true; 
         }
       return u;
     }
 
   static T 
   sub (T x, T y)
     {
       T u = x - y;
       if (u > x)
         {
           u = 0;
-          octave_int_base<T>::ftrunc = true; 
         }
       return u;
     }
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized. 
   static T 
   mul (T x, T y)
@@ -421,32 +378,30 @@ public:
       if (y != 0)
         {
           T z = x / y, w = x % y;
           if (w >= y-w) z += 1;
           return z;
         }
       else
         {
-          octave_int_base<T>::ftrunc = true; 
           return x ? octave_int_base<T>::max_val () : 0;
         }
     }
 };
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 // Handle 64-bit multiply using long double
 template <>
 inline uint64_t
 octave_int_arith_base<uint64_t, false>:: mul (uint64_t x, uint64_t y)
 {
   long double p = static_cast<long double> (x) * static_cast<long double> (y);
   if (p > static_cast<long double> (octave_int_base<uint64_t>::max_val ()))
     {
-      octave_int_base<uint64_t>::ftrunc = true;
       return octave_int_base<uint64_t>::max_val ();
     }
   else
     return static_cast<uint64_t> (p);
 }
 #else
 // Special handler for 64-bit integer multiply.
 template <>
@@ -499,30 +454,28 @@ public:
       // This is close to how GCC does std::abs, but we can't just use std::abs,
       // because its behaviour for INT_MIN is undefined and the compiler could
       // discard the following test.
       T m = x >> std::numeric_limits<T>::digits;
       T y = (x ^ m) - m;
       if (y < 0) 
         {
           y = octave_int_base<T>::max_val ();
-          octave_int_base<T>::ftrunc = true;
         }
       return y;
 #else
       // -INT_MAX is safe because C++ actually allows only three implementations
       // of integers: sign & magnitude, ones complement and twos complement.
       // The first test will, with modest optimizations, evaluate at compile
       // time, and maybe eliminate the branch completely.
       T y;
       if (octave_int_base<T>::min_val () < -octave_int_base<T>::max_val ()
           && x == octave_int_base<T>::min_val ())
         {
           y = octave_int_base<T>::max_val ();
-          octave_int_base<T>::ftrunc = true;
         }
       else
         y = (x < 0) ? -x : x;
       return y;
 #endif
     }
 
   static T
@@ -546,26 +499,24 @@ public:
   static T
   minus (T x)
     {
 #ifdef HAVE_FAST_INT_OPS
       T y = -x;
       if (y == octave_int_base<T>::min_val ())
         {
           --y;
-          octave_int_base<T>::ftrunc = false;
         }
       return y;
 #else
       T y;
       if (octave_int_base<T>::min_val () < -octave_int_base<T>::max_val ()
           && x == octave_int_base<T>::min_val ())
         {
           y = octave_int_base<T>::max_val ();
-          octave_int_base<T>::ftrunc = true;
         }
       else
         y = -x;
       return y;
 #endif
     }
 
   static T 
@@ -575,38 +526,35 @@ public:
     // The typecasts do nothing, but they are here to prevent an optimizing
     // compiler from interfering. Also, the signed operations on small types
     // actually return int.
       T u = static_cast<UT> (x) + static_cast<UT> (y);
       T ux = u ^ x, uy = u ^ y; 
       if ((ux & uy) < 0) 
         {
           u = octave_int_base<T>::max_val () + signbit (~u);
-          octave_int_base<T>::ftrunc = true;
         }
       return u;
 #else
       // We shall carefully avoid anything that may overflow.
       T u;
       if (y < 0)
         {
           if (x < octave_int_base<T>::min_val () - y)
             {
               u = octave_int_base<T>::min_val ();
-              octave_int_base<T>::ftrunc = true;
             }
           else
             u = x + y;
         }
       else
         {
           if (x > octave_int_base<T>::max_val () - y)
             {
               u = octave_int_base<T>::max_val ();
-              octave_int_base<T>::ftrunc = true;
             }
           else
             u = x + y;
         }
 
       return u;
 #endif
     }
@@ -619,38 +567,35 @@ public:
     // The typecasts do nothing, but they are here to prevent an optimizing
     // compiler from interfering. Also, the signed operations on small types
     // actually return int.
       T u = static_cast<UT> (x) - static_cast<UT> (y);
       T ux = u ^ x, uy = u ^ ~y; 
       if ((ux & uy) < 0) 
         {
           u = octave_int_base<T>::max_val () + signbit (~u);
-          octave_int_base<T>::ftrunc = true;
         }
       return u;
 #else
       // We shall carefully avoid anything that may overflow.
       T u;
       if (y < 0)
         {
           if (x > octave_int_base<T>::max_val () + y)
             {
               u = octave_int_base<T>::max_val ();
-              octave_int_base<T>::ftrunc = true;
             }
           else
             u = x - y;
         }
       else
         {
           if (x < octave_int_base<T>::min_val () + y)
             {
               u = octave_int_base<T>::min_val ();
-              octave_int_base<T>::ftrunc = true;
             }
           else
             u = x - y;
         }
 
       return u;
 #endif
     }
@@ -668,30 +613,28 @@ public:
 
   // Division.
   static T 
   div (T x, T y)
     {
       T z;
       if (y == 0)
         {
-          octave_int_base<T>::ftrunc = true;
           if (x < 0)
             z = octave_int_base<T>::min_val ();
           else if (x != 0)
             z = octave_int_base<T>::max_val ();
           else
             z = 0;
         }
       else if (y < 0)
         {
           // This is a special case that overflows as well.
           if (y == -1 && x == octave_int_base<T>::min_val ())
             {
-              octave_int_base<T>::ftrunc = true;
               z = octave_int_base<T>::max_val ();
             }
           else
             {
               z = x / y;
               T w = -octave_int_abs (x % y); // Can't overflow, but std::abs (x) can!
               if (w <= y - w) 
                 z -= 1 - (signbit (x) << 1);
@@ -720,22 +663,20 @@ inline int64_t
 octave_int_arith_base<int64_t, true>:: mul (int64_t x, int64_t y)
 {
   long double p = static_cast<long double> (x) * static_cast<long double> (y);
   // NOTE: We could maybe do it with a single branch if HAVE_FAST_INT_OPS, but it
   // would require one more runtime conversion, so the question is whether it would
   // really be faster.
   if (p > static_cast<long double> (octave_int_base<int64_t>::max_val ()))
     {
-      octave_int_base<int64_t>::ftrunc = true;
       return octave_int_base<int64_t>::max_val ();
     }
   else if (p < static_cast<long double> (octave_int_base<int64_t>::min_val ()))
     {
-      octave_int_base<int64_t>::ftrunc = true;
       return octave_int_base<int64_t>::min_val ();
     }
   else
     return static_cast<int64_t> (p);
 }
 #else
 // Special handler for 64-bit integer multiply.
 template <>
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,32 @@
+
+2010-03-09  Jaroslav Hajek  <highegg@gmail.com>
+
+	* ov-intx.h 
+	(OCTAVE_INT_NDARRAY_T::convert_gripe): Remove method.
+	(OCTAVE_INT_NDARRAY_T): Remove all uses.
+	(OCTAVE_INT_T::convert_gripe): Remove method.
+	(OCTAVE_INT_T): Remove all uses.
+	* ov.cc (convert_to_int_array, convert_to_octave_idx_type_array): 
+	Remove int conversion warnings.
+	* data.cc (NATIVE_REDUCTION_1): Ditto.
+
+	* OPERATORS/op-intx.h: Remove integer warning stubs.
+	* OPERATORS/opt-int-conv.cc: Ditto.
+
+	* gripes.cc (gripe_truncated_conversion,
+	gripe_binop_integer_math_truncated,
+	gripe_native_integer_math_truncated,
+	gripe_unop_integer_math_truncated, gripe_non_integer_conversion,
+	gripe_nan_conversion): Remove.
+	* gripes.h: Remove decls.
+	* error.cc (initialize_default_warning_state): Don't initialize
+	removed warnings.
+
 2010-03-07  Michael Goffioul  <michael.goffioul@gmail.com>
 
 	* gl-render.cc (draw_figure): disable depth test on the 3rd pass.
 	(draw_text): use get_data_position to get text position.
 	* graphics.h.in (graphics_xform): New zlim field.
 	(graphics_xform::untransform(double,double,bool)): New method.
 	(axes::properties::get_transform): Provide zlim data to graphics_xform
 	constructor.
diff --git a/src/OPERATORS/op-int-conv.cc b/src/OPERATORS/op-int-conv.cc
--- a/src/OPERATORS/op-int-conv.cc
+++ b/src/OPERATORS/op-int-conv.cc
@@ -46,28 +46,17 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #define DEFINTCONVFN(name, tfrom, tto) \
   CONVDECL (name) \
   { \
     CAST_CONV_ARG (const octave_ ## tfrom&); \
  \
-    octave_ ## tto ::clear_conv_flag (); \
     octave_ ## tto ## _matrix v2 = v.tto ## _array_value (); \
-    if (octave_ ## tto ::get_trunc_flag ()) \
-      gripe_truncated_conversion (v.type_name (). c_str (), \
-                                  v2.type_name (). c_str ()); \
-    if (octave_ ## tto ::get_nan_flag ()) \
-      gripe_nan_conversion (v.type_name (). c_str (), \
-                            v2.type_name (). c_str ()); \
-    if (octave_ ## tto ::get_non_int_flag ()) \
-      gripe_non_integer_conversion (v.type_name (). c_str (), \
-                                    v2.type_name (). c_str ()); \
-    octave_ ## tto ::clear_conv_flag (); \
     return new octave_ ## tto ## _matrix (v2); \
   }
 
 // conversion ops
 
 DEFINTCONVFN (scalar_to_int8, scalar, int8)
 DEFINTCONVFN (scalar_to_int16, scalar, int16)
 DEFINTCONVFN (scalar_to_int32, scalar, int32)
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -23,57 +23,41 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 
 #define DEFINTBINOP_OP(name, t1, t2, op, t3) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value \
       (v1.t1 ## _value () op v2.t2 ## _value ()); \
-    if (octave_ ## t3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define DEFINTNDBINOP_OP(name, t1, t2, e1, e2, op, t3) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value \
       (v1.e1 ## _value () op v2.e2 ## _value ()); \
-    if (octave_ ## t3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define DEFINTBINOP_FN(name, t1, t2, f, t3, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value (f (v1.t1 ## _value (), v2.t2 ## _value ())); \
-    if (octave_ ## t3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define DEFINTNDBINOP_FN(name, t1, t2, e1, e2, f, t3, op)       \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value (f (v1.e1 ## _value (), v2.e2 ## _value ())); \
-    if (octave_ ## t3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (#op, v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## t3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_CONCAT_FN2(T1, T2) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _s_s, T1 ## _scalar, T2 ## _scalar, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _s_m, T1 ## _scalar, T2 ## _matrix, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _m_s, T1 ## _matrix, T2 ## _scalar, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _m_m, T1 ## _matrix, T2 ## _matrix, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat)
@@ -171,19 +155,16 @@ along with Octave; see the file COPYING.
   /* scalar unary ops. */  \
  \
   DEFUNOP_OP (s_not, TYPE ## _scalar, !) \
   DEFUNOP_OP (s_uplus, TYPE ## _scalar, /* no-op */) \
   DEFUNOP (s_uminus, TYPE ## _scalar) \
   { \
     CAST_UNOP_ARG (const octave_ ## TYPE ## _scalar &); \
     octave_value retval = octave_value (- v. TYPE ## _scalar_value ()); \
-    if (octave_ ## TYPE ::get_math_trunc_flag ()) \
-      gripe_unop_integer_math_truncated ("-", v.type_name (). c_str ()); \
-    octave_ ## TYPE ::clear_conv_flag (); \
     return retval; \
   } \
   DEFUNOP_OP (s_transpose, TYPE ## _scalar, /* no-op */) \
   DEFUNOP_OP (s_hermitian, TYPE ## _scalar, /* no-op */) \
  \
   DEFNCUNOP_METHOD (s_incr, TYPE ## _scalar, increment) \
   DEFNCUNOP_METHOD (s_decr, TYPE ## _scalar, decrement)
 
@@ -197,71 +178,55 @@ along with Octave; see the file COPYING.
   DEFBINOP (PFX ## _div, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v2.T2 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
-    if (octave_ ## T3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated ("/", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTBINOP_FN (PFX ## _pow, T1 ## scalar, T2 ## scalar, xpow, T3, ^) \
  \
   DEFBINOP (PFX ## _ldiv, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v1.T1 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
-    if (octave_ ## T3 ::get_math_trunc_flag ()) \
-          gripe_binop_integer_math_truncated ("\\", v1.type_name (). c_str (), \
-                                              v2.type_name (). c_str ()); \
-    octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTBINOP_OP (PFX ## _el_mul, T1 ## scalar, T2 ## scalar, *, T3)    \
  \
   DEFBINOP (PFX ## _el_div, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v2.T2 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
-    if (octave_ ## T3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ()); \
-    octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTBINOP_FN (PFX ## _el_pow, T1 ## scalar, T2 ## scalar, xpow, T3, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v1.T1 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
-    if (octave_ ## T3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   } \
 
 #define OCTAVE_SS_INT_BOOL_OPS(PFX, T1, T2, Z1, Z2) \
   DEFBINOP (PFX ## _el_and, T2, T2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
@@ -355,50 +320,38 @@ along with Octave; see the file COPYING.
   DEFBINOP (PFX ## _ldiv, TS ## scalar, TM ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     if (! v1.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TS ## scalar_value () / v1.TS ## scalar_value ()); \
-    if (octave_ ## TI ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated ("\\", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, *, TI) \
   DEFBINOP (PFX ## _el_div, TS ## scalar, TM ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     octave_value retval = octave_value (v1.TS ## scalar_value () / v2.TM ## array_value ()); \
-    if (octave_ ## TI ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TS ## scalar, TM ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     if (! v1.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
-    if (octave_ ## TI ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_SM_INT_CMP_OPS(PFX, TS, TM) \
   DEFNDBINOP_FN (PFX ## _lt, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_le) \
   DEFNDBINOP_FN (PFX ## _eq, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_eq) \
   DEFNDBINOP_FN (PFX ## _ge, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_ge) \
@@ -512,20 +465,16 @@ along with Octave; see the file COPYING.
   DEFBINOP (PFX ## _div, TM ## matrix, TS ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
  \
     if (! v2.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
-    if (octave_ ## TI ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated ("/", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   /* DEFBINOP_FN (PFX ## _pow, TM ## matrix, TS ## scalar, xpow) */ \
  \
   /* DEFBINOP (PFX ## _ldiv, TM ## matrix, TS ## scalar) */ \
   /* { */ \
   /* CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); */ \
@@ -541,34 +490,26 @@ along with Octave; see the file COPYING.
   DEFBINOP (PFX ## _el_div, TM ## matrix, TS ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
  \
     if (! v2.TS ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
-    if (octave_ ## TI ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated ("./", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TM ## matrix, TS ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
     \
     octave_value retval = v2.TS ## scalar_value () / v1.TM ## array_value (); \
-    if (octave_ ## TI ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (".^", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## TI ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_MS_INT_CMP_OPS(PFX, TM, TS) \
   DEFNDBINOP_FN (PFX ## _lt, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_le) \
   DEFNDBINOP_FN (PFX ## _eq, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_eq) \
   DEFNDBINOP_FN (PFX ## _ge, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_ge) \
@@ -673,19 +614,16 @@ octave_value elem_xpow (FloatNDArray a, 
   /* matrix unary ops. */ \
  \
   DEFNDUNOP_OP (m_not, TYPE ## _matrix, TYPE ## _array, !) \
   DEFNDUNOP_OP (m_uplus, TYPE ## _matrix, TYPE ## _array, /* no-op */) \
   DEFUNOP (m_uminus, TYPE ## _matrix) \
   { \
     CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix &); \
     octave_value retval = octave_value (- v. TYPE ## _array_value ()); \
-    if (octave_ ## TYPE ::get_math_trunc_flag ()) \
-      gripe_unop_integer_math_truncated ("-", v.type_name (). c_str ()); \
-    octave_ ## TYPE ::clear_conv_flag (); \
     return retval; \
   } \
  \
   DEFUNOP (m_transpose, TYPE ## _matrix) \
   { \
     CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix&); \
  \
     if (v.ndims () > 2) \
@@ -724,20 +662,16 @@ octave_value elem_xpow (FloatNDArray a, 
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, elem_xpow, T3, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, T1 ## matrix, T2 ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## matrix&, const octave_ ## T2 ## matrix&); \
     \
     octave_value retval = octave_value (quotient (v2.T2 ## array_value (), v1.T1 ## array_value ())); \
-    if (octave_ ## T3 ::get_math_trunc_flag ()) \
-      gripe_binop_integer_math_truncated (".\\", v1.type_name (). c_str (), \
-                                          v2.type_name (). c_str ());   \
-    octave_ ## T3 ::clear_conv_flag (); \
     return retval; \
   }
 
 #define OCTAVE_MM_INT_CMP_OPS(PFX, T1, T2) \
   DEFNDBINOP_FN (PFX ## _lt, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_le) \
   DEFNDBINOP_FN (PFX ## _eq, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_eq) \
   DEFNDBINOP_FN (PFX ## _ge, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_ge) \
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1288,24 +1288,17 @@ sign as @var{x}.  If @var{y} is zero, th
 
 #define NATIVE_REDUCTION_1(FCN, TYPE, DIM) \
   (arg.is_ ## TYPE ## _type ()) \
     { \
       TYPE ## NDArray tmp = arg. TYPE ##_array_value (); \
       \
       if (! error_state) \
         { \
-          octave_ ## TYPE::clear_conv_flags (); \
           retval = tmp.FCN (DIM); \
-          if (octave_ ## TYPE::get_trunc_flag ()) \
-            { \
-              gripe_native_integer_math_truncated (#FCN, \
-                                                   octave_ ## TYPE::type_name ()); \
-              octave_ ## TYPE::clear_conv_flags (); \
-            } \
         } \
     }
 
 #define NATIVE_REDUCTION(FCN, BOOL_FCN) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1467,20 +1467,16 @@ initialize_default_warning_state (void)
   disable_warning ("Octave:missing-semicolon");
   disable_warning ("Octave:neg-dim-as-zero");
   disable_warning ("Octave:resize-on-range-error");
   disable_warning ("Octave:separator-insert");
   disable_warning ("Octave:single-quote-string");
   disable_warning ("Octave:str-to-num");
   disable_warning ("Octave:string-concat");
   disable_warning ("Octave:variable-switch-label");
-  disable_warning ("Octave:int-convert-nan");
-  disable_warning ("Octave:int-convert-non-int-val");
-  disable_warning ("Octave:int-convert-overflow");
-  disable_warning ("Octave:int-math-overflow");
   disable_warning ("Octave:complex-cmp-ops");
 }
 
 DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{err} =} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror ('reset')\n\
 Returns or sets the last error message.  Called without any arguments\n\
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -200,71 +200,25 @@ gripe_divide_by_zero (void)
 void
 gripe_logical_conversion (void)
 {
   warning_with_id ("Octave:logical-conversion",
                    "value not equal to 1 or 0 converted to logical 1");
 }
 
 void
-gripe_truncated_conversion (const char *srctype, const char *desttype)
-{
-  warning_with_id ("Octave:int-convert-overflow", 
-                   "data truncated converting from %s to %s",
-                   srctype, desttype);
-}
-
-void
-gripe_binop_integer_math_truncated (const char *op, const char *type1, const char *type2)
-{
-  warning_with_id ("Octave:int-math-overflow",
-                   "data truncated for %s by %s binary operator %s",
-                   type1, type2, op);
-}
-
-void
-gripe_native_integer_math_truncated (const char *fcn, const char *type)
-{
-  warning_with_id ("Octave:int-math-overflow",
-                   "data truncated for %s native %s operation",
-                   type, fcn);
-}
-
-void
-gripe_unop_integer_math_truncated (const char* op, const char *type)
-{
-  warning_with_id ("Octave:int-math-overflow",
-                   "data truncated for the %s unary operator %s", type, op);
-}
-
-void
 gripe_library_execution_error (void)
 {
   octave_exception_state = octave_no_exception;
 
   if (! error_state)
     error ("caught execution error in library function");
 }
 
 void
-gripe_non_integer_conversion (const char *srctype, const char *desttype)
-{
-  warning_with_id ("Octave:int-convert-non-int-val", 
-                   "Conversion of non-integer value from %s to %s",
-                   srctype, desttype);
-}
-void
-gripe_nan_conversion (const char *srctype, const char *desttype)
-{
-  warning_with_id ("Octave:int-convert-nan", 
-                   "Conversion of NaN from %s to %s",
-                   srctype, desttype);
-}
-
-void
 gripe_invalid_inquiry_subscript (void)
 {
   error ("invalid dimension inquiry of a non-existent value");
 }
 
 void
 gripe_indexed_cs_list (void)
 {
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -101,34 +101,16 @@ gripe_wrong_type_arg_for_binary_op (cons
 extern OCTINTERP_API void
 gripe_implicit_conversion (const char *id, const char *from, const char *to);
 
 extern OCTINTERP_API void
 gripe_implicit_conversion (const std::string& id, const std::string& from,
                            const std::string& to);
 
 extern OCTINTERP_API void
-gripe_truncated_conversion (const char *srctype, const char *desttype);
-
-extern OCTINTERP_API void
-gripe_binop_integer_math_truncated (const char *op, const char *type1, const char *type2);
-
-extern OCTINTERP_API void
-gripe_native_integer_math_truncated (const char *fcn, const char *type);
-
-extern OCTINTERP_API void
-gripe_unop_integer_math_truncated (const char *op, const char *type);
-
-extern OCTINTERP_API void
-gripe_non_integer_conversion (const char *srctype, const char *desttype);
-
-extern OCTINTERP_API void
-gripe_nan_conversion (const char *srctype, const char *desttype);
-
-extern OCTINTERP_API void
 gripe_divide_by_zero (void);
 
 extern OCTINTERP_API void
 gripe_logical_conversion (void);
 
 extern OCTINTERP_API void
 gripe_library_execution_error (void);
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -65,57 +65,41 @@ public:
     { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
   bool OCTAVE_TYPE_PREDICATE_FUNCTION (void) const { return true; }
 
   bool is_integer_type (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return OCTAVE_INT_BTYP; }
 
-private:
-
-  template <class IM>
-  IM convert_gripe () const
-    {
-      typedef typename IM::element_type dest_el_type;
-      typedef intNDArray<OCTAVE_INT_T>::element_type src_el_type;
-      dest_el_type::clear_conv_flag ();
-      IM retval (matrix);
-      if (dest_el_type::get_trunc_flag ())
-        gripe_truncated_conversion (src_el_type::type_name (),
-                                    dest_el_type::type_name ());
-      dest_el_type::clear_conv_flag ();
-      return retval;
-    }
-
 public:
 
   int8NDArray
-  int8_array_value (void) const { return convert_gripe<int8NDArray> (); }
+  int8_array_value (void) const { return int8NDArray (matrix); }
 
   int16NDArray
-  int16_array_value (void) const { return convert_gripe<int16NDArray> (); }
+  int16_array_value (void) const { return int16NDArray (matrix); }
 
   int32NDArray
-  int32_array_value (void) const { return convert_gripe<int32NDArray> (); }
+  int32_array_value (void) const { return int32NDArray (matrix); }
 
   int64NDArray
-  int64_array_value (void) const { return convert_gripe<int64NDArray> (); }
+  int64_array_value (void) const { return int64NDArray (matrix); }
 
   uint8NDArray
-  uint8_array_value (void) const { return convert_gripe<uint8NDArray> (); }
+  uint8_array_value (void) const { return uint8NDArray (matrix); }
 
   uint16NDArray
-  uint16_array_value (void) const { return convert_gripe<uint16NDArray> (); }
+  uint16_array_value (void) const { return uint16NDArray (matrix); }
 
   uint32NDArray
-  uint32_array_value (void) const { return convert_gripe<uint32NDArray> (); }
+  uint32_array_value (void) const { return uint32NDArray (matrix); }
 
   uint64NDArray
-  uint64_array_value (void) const { return convert_gripe<uint64NDArray> (); }
+  uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double
   double_value (bool = false) const
     {
       double retval = lo_ieee_nan_value ();
 
       if (numel () > 0)
         {
@@ -300,36 +284,26 @@ public:
 
     return retval;
   }
 
   // Use matrix_ref here to clear index cache.
   void increment (void) 
    { 
      matrix_ref() += OCTAVE_INT_T (1); 
-     if (OCTAVE_INT_T::get_math_trunc_flag ())
-       gripe_unop_integer_math_truncated ("++", type_name (). c_str ());
-
-      OCTAVE_INT_T::clear_conv_flag ();
    }
 
   void decrement (void)
    { 
      matrix_ref() -= OCTAVE_INT_T (1); 
-     if (OCTAVE_INT_T::get_math_trunc_flag ())
-       gripe_unop_integer_math_truncated ("--", type_name (). c_str ());
-      OCTAVE_INT_T::clear_conv_flag ();
    }
 
   void changesign (void)
    { 
      matrix_ref ().changesign (); 
-     if (OCTAVE_INT_T::get_math_trunc_flag ())
-       gripe_unop_integer_math_truncated ("-", type_name (). c_str ());
-      OCTAVE_INT_T::clear_conv_flag ();
    }
 
   idx_vector index_vector (void) const 
     { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
@@ -436,58 +410,41 @@ public:
     }
 
   bool OCTAVE_TYPE_PREDICATE_FUNCTION (void) const { return true; }
 
   bool is_integer_type (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return OCTAVE_INT_BTYP; }
 
-private:
-
-  template <class IS>
-  IS convert_gripe () const
-    {
-      typedef IS dest_el_type;
-      typedef OCTAVE_INT_T src_el_type;
-      dest_el_type::clear_conv_flag ();
-      IS retval (scalar);
-
-      if (dest_el_type::get_trunc_flag ())
-        gripe_truncated_conversion (src_el_type::type_name (),
-                                    dest_el_type::type_name ());
-      dest_el_type::clear_conv_flag ();
-      return retval;
-    }
-
 public:
 
   octave_int8
-  int8_scalar_value (void) const { return convert_gripe<octave_int8> (); }
+  int8_scalar_value (void) const { return octave_int8 (scalar); }
 
   octave_int16
-  int16_scalar_value (void) const { return convert_gripe<octave_int16> (); }
+  int16_scalar_value (void) const { return octave_int16 (scalar); }
 
   octave_int32
-  int32_scalar_value (void) const { return convert_gripe<octave_int32> (); }
+  int32_scalar_value (void) const { return octave_int32 (scalar); }
 
   octave_int64
-  int64_scalar_value (void) const { return convert_gripe<octave_int64> (); }
+  int64_scalar_value (void) const { return octave_int64 (scalar); }
 
   octave_uint8
-  uint8_scalar_value (void) const { return convert_gripe<octave_uint8> (); }
+  uint8_scalar_value (void) const { return octave_uint8 (scalar); }
 
   octave_uint16
-  uint16_scalar_value (void) const { return convert_gripe<octave_uint16> (); }
+  uint16_scalar_value (void) const { return octave_uint16 (scalar); }
 
   octave_uint32
-  uint32_scalar_value (void) const { return convert_gripe<octave_uint32> (); }
+  uint32_scalar_value (void) const { return octave_uint32 (scalar); }
 
   octave_uint64
-  uint64_scalar_value (void) const { return convert_gripe<octave_uint64> (); }
+  uint64_scalar_value (void) const { return octave_uint64 (scalar); }
 
   int8NDArray
   int8_array_value (void) const
     { return int8NDArray (dim_vector (1, 1), int8_scalar_value ()); }
 
   int16NDArray
   int16_array_value (void) const
     { return int16NDArray (dim_vector (1, 1), int16_scalar_value ()); }
@@ -625,27 +582,21 @@ public:
     charNDArray retval (dim_vector (1, 1));
     retval(0) = scalar.char_value ();
     return retval;
   }
 
   void increment (void) 
    { 
      scalar += OCTAVE_INT_T (1); 
-     if (OCTAVE_INT_T::get_math_trunc_flag ())
-       gripe_unop_integer_math_truncated ("++", type_name (). c_str ());
-      OCTAVE_INT_T::clear_conv_flag ();
    }
 
   void decrement (void)
    { 
      scalar -= OCTAVE_INT_T (1); 
-     if (OCTAVE_INT_T::get_math_trunc_flag ())
-       gripe_unop_integer_math_truncated ("--", type_name (). c_str ());
-      OCTAVE_INT_T::clear_conv_flag ();
    }
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, octave_idx_type skip,
              oct_mach_info::float_format flt_fmt) const
     {
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1544,25 +1544,19 @@ octave_value::vector_value (bool force_s
 
 template <class T>
 static Array<int>
 convert_to_int_array (const Array<octave_int<T> >& A)
 {
   Array<int> retval (A.dims ());
   octave_idx_type n = A.numel ();
 
-  octave_int<int>::clear_conv_flag ();
   for (octave_idx_type i = 0; i < n; i++)
     retval.xelem (i) = octave_int<int> (A.xelem (i));
 
-  if (octave_int<int>::get_trunc_flag ())
-    gripe_truncated_conversion (octave_int<T>::type_name (), "int");
-
-  octave_int<int>::clear_conv_flag ();
-
   return retval;
 }
 
 Array<int>
 octave_value::int_vector_value (bool force_string_conv, bool require_int,
                                 bool force_vector_conversion) const
 {
   Array<int> retval;
@@ -1625,25 +1619,19 @@ octave_value::int_vector_value (bool for
 
 template <class T>
 static Array<octave_idx_type>
 convert_to_octave_idx_type_array (const Array<octave_int<T> >& A)
 {
   Array<octave_idx_type> retval (A.dims ());
   octave_idx_type n = A.numel ();
 
-  octave_int<int>::clear_conv_flag ();
   for (octave_idx_type i = 0; i < n; i++)
     retval.xelem (i) = octave_int<octave_idx_type> (A.xelem (i));
 
-  if (octave_int<int>::get_trunc_flag ())
-    gripe_truncated_conversion (octave_int<T>::type_name (), "int");
-
-  octave_int<int>::clear_conv_flag ();
-
   return retval;
 }
 
 Array<octave_idx_type>
 octave_value::octave_idx_type_vector_value (bool require_int,
                                             bool force_string_conv,
                                             bool force_vector_conversion) const
 {
