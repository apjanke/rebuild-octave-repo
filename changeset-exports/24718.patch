# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1518210866 18000
#      Fri Feb 09 16:14:26 2018 -0500
# Node ID ea1c88bd44306b5104cab2c6168ee795f685bf04
# Parent  63b5ac6a5ee780765d04ebf1ae4eb32834e4d66a
move more GUI classes inside octave namespace

* color-picker.cc, color-picker.h, dialog.cc, dialog.h,
documentation-dock-widget.cc, documentation-dock-widget.h,
external-editor-interface.cc, external-editor-interface.h,
octave-cmd.cc, octave-cmd.h, octave-qt-link.cc, octave-qt-link.h,
qtinfo/webinfo.cc, qtinfo/webinfo.h, resource-manager.cc,
resource-manager.h, shortcut-manager.cc, shortcut-manager.h,
tab-bar.cc, tab-bar.h, welcome-wizard.cc, welcome-wizard.h: Move class
declarations and definitions inside octave namespace.

* thread-manager.h, thread-manager.cc (octave::thread_manager):
Rename from octave_thread_manager.  Change all uses.
(octave::base_thread_manager): Rename from
octave_base_thread_manager.  Change all uses.

* color-picker.h: Provide temporary using decl for
octave::color_picker to import it into the global namespace.
* resource-manager.h: Likewise, for octave::resource_manager.
* shortcut-manager.h: Likewise, for octave::shortcut_manager.
* tab-bar.h: Likewise, for octave::tab_bar.

diff --git a/libgui/src/color-picker.cc b/libgui/src/color-picker.cc
--- a/libgui/src/color-picker.cc
+++ b/libgui/src/color-picker.cc
@@ -26,49 +26,50 @@ along with Octave; see the file COPYING.
 // Author: Torsten <ttl@justmail.de>
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "color-picker.h"
 
-// Constructor with initial color as parameter
-color_picker::color_picker (QColor old_color, QWidget *p)
-  : QPushButton (p)
+namespace octave
 {
-  m_color = old_color;
-  setFlat (true);
-  setFocusPolicy (Qt::NoFocus);  // no focus, would changes the color
-  update_button ();
-  connect (this, SIGNAL (clicked (void)), SLOT (select_color (void)));
-}
+  // Constructor with initial color as parameter
+  color_picker::color_picker (QColor old_color, QWidget *p)
+    : QPushButton (p)
+  {
+    m_color = old_color;
+    setFlat (true);
+    setFocusPolicy (Qt::NoFocus);  // no focus, would changes the color
+    update_button ();
+    connect (this, SIGNAL (clicked (void)), SLOT (select_color (void)));
+  }
 
-// Slot for button clicked: select a new color using QColorDialog
-void
-color_picker::select_color (void)
-{
-  QColor new_color = QColorDialog::getColor (m_color);
+  // Slot for button clicked: select a new color using QColorDialog
+  void color_picker::select_color (void)
+  {
+    QColor new_color = QColorDialog::getColor (m_color);
 
-  if (new_color.isValid () && new_color != m_color)
-    {
-      m_color = new_color;
-      update_button ();
-    }
-}
+    if (new_color.isValid () && new_color != m_color)
+      {
+        m_color = new_color;
+        update_button ();
+      }
+  }
 
-// Draw the button with the actual color (using a stylesheet)
-void
-color_picker::update_button (void)
-{
-  // Is this the right place to look for a "foreground" color that would
-  // provide a reasonable border for the color swatches?
-  QWidget *p = parentWidget ();
+  // Draw the button with the actual color (using a stylesheet)
+  void color_picker::update_button (void)
+  {
+    // Is this the right place to look for a "foreground" color that would
+    // provide a reasonable border for the color swatches?
+    QWidget *p = parentWidget ();
 
-  QString bordercolor
-    = (p ? p->palette ().text ().color ().name () : QString ("#000000"));
+    QString bordercolor
+      = (p ? p->palette ().text ().color ().name () : QString ("#000000"));
 
-  setStyleSheet (QString ("background-color: %1; border: 1px solid %2;")
-                 .arg (m_color.name ())
-                 .arg (bordercolor));
+    setStyleSheet (QString ("background-color: %1; border: 1px solid %2;")
+                   .arg (m_color.name ())
+                   .arg (bordercolor));
 
-  repaint ();
+    repaint ();
+  }
 }
diff --git a/libgui/src/color-picker.h b/libgui/src/color-picker.h
--- a/libgui/src/color-picker.h
+++ b/libgui/src/color-picker.h
@@ -27,30 +27,37 @@ along with Octave; see the file COPYING.
 // Author: Torsten <ttl@justmail.de>
 
 #if ! defined (octave_color_picker_h)
 #define octave_color_picker_h 1
 
 #include <QPushButton>
 #include <QColorDialog>
 
-class color_picker : public QPushButton
+namespace octave
 {
-  Q_OBJECT
+  class color_picker : public QPushButton
+  {
+    Q_OBJECT
 
-public:
+  public:
+
+    color_picker (QColor color = QColor (0, 0, 0), QWidget *parent = nullptr);
 
-  color_picker (QColor color = QColor (0, 0, 0), QWidget *parent = nullptr);
+    QColor color (void) const { return m_color; }
 
-  QColor color (void) const { return m_color; }
+  private slots:
 
-private slots:
+    void select_color (void);
 
-  void select_color (void);
+  private:
+
+    virtual void update_button (void);
 
-private:
+    QColor m_color;
+  };
+}
 
-  virtual void update_button (void);
-
-  QColor m_color;
-};
+// FIXME: This is temporary and should be removed when all classes that
+// use the color_picker class are also inside the octave namespace.
+using octave::color_picker;
 
 #endif
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -36,515 +36,508 @@ along with Octave; see the file COPYING.
 #include <QMessageBox>
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 #include <QPushButton>
 #include <QGroupBox>
 #include <QGridLayout>
 #include <QLabel>
 
-
-QUIWidgetCreator uiwidget_creator;
-
-QUIWidgetCreator::QUIWidgetCreator (void)
-  : QObject (), m_dialog_result (-1), m_dialog_button (),
-    m_string_list (new QStringList ()), m_list_index (new QIntList ()),
-    m_path_name (new QString ())
-{ }
-
-QUIWidgetCreator::~QUIWidgetCreator (void)
+namespace octave
 {
-  delete m_string_list;
-  delete m_list_index;
-  delete m_path_name;
-}
+  QUIWidgetCreator uiwidget_creator;
+
+  QUIWidgetCreator::QUIWidgetCreator (void)
+    : QObject (), m_dialog_result (-1), m_dialog_button (),
+      m_string_list (new QStringList ()), m_list_index (new QIntList ()),
+      m_path_name (new QString ())
+  { }
 
-QString
-QUIWidgetCreator::rm_amp (const QString& text)
-{
-  QString text_wo_amp = text;
-  text_wo_amp.replace (QRegExp ("&(\\w)"), "\\1");
-  return text_wo_amp;
-}
+  QUIWidgetCreator::~QUIWidgetCreator (void)
+  {
+    delete m_string_list;
+    delete m_list_index;
+    delete m_path_name;
+  }
 
-void
-QUIWidgetCreator::dialog_button_clicked (QAbstractButton *button)
-{
-  // Wait for link thread to go to sleep state.
-  lock ();
+  QString QUIWidgetCreator::rm_amp (const QString& text)
+  {
+    QString text_wo_amp = text;
+    text_wo_amp.replace (QRegExp ("&(\\w)"), "\\1");
+    return text_wo_amp;
+  }
+
+  void QUIWidgetCreator::dialog_button_clicked (QAbstractButton *button)
+  {
+    // Wait for link thread to go to sleep state.
+    lock ();
 
-  // Check for a matching button text while ignoring accelerators because
-  // the window manager may have added one in the passed button
-  QString text_clean = rm_amp (button->text ());
-  for (int i = 0; i < m_button_list.count (); i++)
-    {
-      if (rm_amp (m_button_list.at (i)) == text_clean)
-        {
-          m_dialog_button = m_button_list.at (i); // text w/o extra accelerator
-          break;
-        }
-    }
+    // Check for a matching button text while ignoring accelerators because
+    // the window manager may have added one in the passed button
+    QString text_clean = rm_amp (button->text ());
+    for (int i = 0; i < m_button_list.count (); i++)
+      {
+        if (rm_amp (m_button_list.at (i)) == text_clean)
+          {
+            m_dialog_button = m_button_list.at (i); // text w/o extra accelerator
+            break;
+          }
+      }
 
-  // The value should always be 1 for the Octave functions.
-  m_dialog_result = 1;
+    // The value should always be 1 for the Octave functions.
+    m_dialog_result = 1;
 
-  unlock ();
+    unlock ();
 
-  // Wake up Octave process so that it continues.
-  wake_all ();
-}
+    // Wake up Octave process so that it continues.
+    wake_all ();
+  }
 
-void
-QUIWidgetCreator::list_select_finished (const QIntList& selected,
-                                        int button_pressed)
-{
-  // Wait for link thread to go to sleep state.
-  lock ();
+  void QUIWidgetCreator::list_select_finished (const QIntList& selected,
+                                               int button_pressed)
+  {
+    // Wait for link thread to go to sleep state.
+    lock ();
 
-  // Store the value so that builtin functions can retrieve.
-  *m_list_index = selected;
-  m_dialog_result = button_pressed;
+    // Store the value so that builtin functions can retrieve.
+    *m_list_index = selected;
+    m_dialog_result = button_pressed;
 
-  unlock ();
+    unlock ();
 
-  // Wake up Octave process so that it continues.
-  wake_all ();
-}
+    // Wake up Octave process so that it continues.
+    wake_all ();
+  }
 
-void
-QUIWidgetCreator::input_finished (const QStringList& input, int button_pressed)
-{
-  // Wait for link thread to go to sleep state.
-  lock ();
+  void QUIWidgetCreator::input_finished (const QStringList& input,
+                                         int button_pressed)
+  {
+    // Wait for link thread to go to sleep state.
+    lock ();
 
-  // Store the value so that builtin functions can retrieve.
-  *m_string_list = input;
-  m_dialog_result = button_pressed;
+    // Store the value so that builtin functions can retrieve.
+    *m_string_list = input;
+    m_dialog_result = button_pressed;
 
-  unlock ();
+    unlock ();
 
-  // Wake up Octave process so that it continues.
-  wake_all ();
-}
+    // Wake up Octave process so that it continues.
+    wake_all ();
+  }
 
-void
-QUIWidgetCreator::filedialog_finished (const QStringList& files,
-                                       const QString& path, int filterindex)
-{
-  // Wait for link thread to go to sleep state.
-  lock ();
+  void QUIWidgetCreator::filedialog_finished (const QStringList& files,
+                                              const QString& path,
+                                              int filterindex)
+  {
+    // Wait for link thread to go to sleep state.
+    lock ();
 
-  // Store the value so that builtin functions can retrieve.
-  *m_string_list = files;
-  m_dialog_result = filterindex;
-  *m_path_name = path;
+    // Store the value so that builtin functions can retrieve.
+    *m_string_list = files;
+    m_dialog_result = filterindex;
+    *m_path_name = path;
 
-  unlock ();
+    unlock ();
 
-  // Wake up Octave process so that it continues.
-  wake_all ();
-}
+    // Wake up Octave process so that it continues.
+    wake_all ();
+  }
 
-MessageDialog::MessageDialog (const QString& message,
-                              const QString& title,
-                              const QString& qsicon,
-                              const QStringList& qsbutton,
-                              const QString& defbutton,
-                              const QStringList& role)
-  : QMessageBox (QMessageBox::NoIcon, title.isEmpty () ? " " : title,
-                 message, nullptr, nullptr)
-{
-  // Create a NonModal message.
-  setWindowModality (Qt::NonModal);
+  MessageDialog::MessageDialog (const QString& message,
+                                const QString& title,
+                                const QString& qsicon,
+                                const QStringList& qsbutton,
+                                const QString& defbutton,
+                                const QStringList& role)
+    : QMessageBox (QMessageBox::NoIcon, title.isEmpty () ? " " : title,
+                   message, nullptr, nullptr)
+  {
+    // Create a NonModal message.
+    setWindowModality (Qt::NonModal);
 
-  // Interpret the icon string, because enumeration QMessageBox::Icon can't
-  // easily be made to pass through a signal.
-  QMessageBox::Icon eicon = QMessageBox::NoIcon;
-  if (qsicon == "error")
-    eicon = QMessageBox::Critical;
-  else if (qsicon == "warn")
-    eicon = QMessageBox::Warning;
-  else if (qsicon == "help")
-    eicon = QMessageBox::Information;
-  else if (qsicon == "quest")
-    eicon = QMessageBox::Question;
-  setIcon (eicon);
+    // Interpret the icon string, because enumeration QMessageBox::Icon can't
+    // easily be made to pass through a signal.
+    QMessageBox::Icon eicon = QMessageBox::NoIcon;
+    if (qsicon == "error")
+      eicon = QMessageBox::Critical;
+    else if (qsicon == "warn")
+      eicon = QMessageBox::Warning;
+    else if (qsicon == "help")
+      eicon = QMessageBox::Information;
+    else if (qsicon == "quest")
+      eicon = QMessageBox::Question;
+    setIcon (eicon);
 
-  int N = (qsbutton.size () < role.size () ? qsbutton.size () : role.size ());
-  if (N == 0)
-    addButton (QMessageBox::Ok);
-  else
-    {
-      for (int i = 0; i < N; i++)
-        {
-          // Interpret the button role string, because enumeration
-          // QMessageBox::ButtonRole can't be made to pass through a signal.
-          QString srole = role.at (i);
-          QMessageBox::ButtonRole erole = QMessageBox::InvalidRole;
-          if (srole == "ResetRole")
-            erole = QMessageBox::ResetRole;
-          else if (srole == "YesRole")
-            erole = QMessageBox::YesRole;
-          else if (srole == "NoRole")
-            erole = QMessageBox::NoRole;
-          else if (srole == "RejectRole")
-            erole = QMessageBox::RejectRole;
-          else if (srole == "AcceptRole")
-            erole = QMessageBox::AcceptRole;
+    int N = (qsbutton.size () < role.size () ? qsbutton.size () : role.size ());
+    if (N == 0)
+      addButton (QMessageBox::Ok);
+    else
+      {
+        for (int i = 0; i < N; i++)
+          {
+            // Interpret the button role string, because enumeration
+            // QMessageBox::ButtonRole can't be made to pass through a signal.
+            QString srole = role.at (i);
+            QMessageBox::ButtonRole erole = QMessageBox::InvalidRole;
+            if (srole == "ResetRole")
+              erole = QMessageBox::ResetRole;
+            else if (srole == "YesRole")
+              erole = QMessageBox::YesRole;
+            else if (srole == "NoRole")
+              erole = QMessageBox::NoRole;
+            else if (srole == "RejectRole")
+              erole = QMessageBox::RejectRole;
+            else if (srole == "AcceptRole")
+              erole = QMessageBox::AcceptRole;
 
-          QPushButton *pbutton = addButton (qsbutton.at (i), erole);
-          if (qsbutton.at (i) == defbutton)
-            setDefaultButton (pbutton);
-          // Make the last button the button pressed when <esc> key activated.
-          if (i == N-1)
-            {
-// FIXME: Why define and then immediately test value?
+            QPushButton *pbutton = addButton (qsbutton.at (i), erole);
+            if (qsbutton.at (i) == defbutton)
+              setDefaultButton (pbutton);
+            // Make the last button the button pressed when <esc> key activated.
+            if (i == N-1)
+              {
+                // FIXME: Why define and then immediately test value?
 #define ACTIVE_ESCAPE 1
 #if ACTIVE_ESCAPE
-              setEscapeButton (pbutton);
+                setEscapeButton (pbutton);
 #else
-              setEscapeButton (0);
+                setEscapeButton (0);
 #endif
 #undef ACTIVE_ESCAPE
-            }
-        }
-    }
+              }
+          }
+      }
 
-  connect (this, SIGNAL (buttonClicked (QAbstractButton *)),
-           &uiwidget_creator, SLOT (dialog_button_clicked (QAbstractButton *)));
-}
+    connect (this, SIGNAL (buttonClicked (QAbstractButton *)),
+             &uiwidget_creator,
+             SLOT (dialog_button_clicked (QAbstractButton *)));
+  }
 
-ListDialog::ListDialog (const QStringList& list, const QString& mode,
-                        int wd, int ht, const QList<int>& initial,
-                        const QString& title, const QStringList& prompt,
-                        const QString& ok_string, const QString& cancel_string)
-  : QDialog (), m_model (new QStringListModel (list))
-{
-  QListView *view = new QListView;
-  view->setModel (m_model);
+  ListDialog::ListDialog (const QStringList& list, const QString& mode,
+                          int wd, int ht, const QList<int>& initial,
+                          const QString& title, const QStringList& prompt,
+                          const QString& ok_string,
+                          const QString& cancel_string)
+    : QDialog (), m_model (new QStringListModel (list))
+  {
+    QListView *view = new QListView;
+    view->setModel (m_model);
 
-  if (mode == "single")
-    view->setSelectionMode (QAbstractItemView::SingleSelection);
-  else if (mode == "multiple")
-    view->setSelectionMode (QAbstractItemView::ExtendedSelection);
-  else
-    view->setSelectionMode (QAbstractItemView::NoSelection);
+    if (mode == "single")
+      view->setSelectionMode (QAbstractItemView::SingleSelection);
+    else if (mode == "multiple")
+      view->setSelectionMode (QAbstractItemView::ExtendedSelection);
+    else
+      view->setSelectionMode (QAbstractItemView::NoSelection);
 
-  selector = view->selectionModel ();
-  int i = 0;
-  for (QList<int>::const_iterator it = initial.begin ();
-       it != initial.end (); it++)
-    {
-      QModelIndex idx = m_model->index (initial.value (i++) - 1, 0,
-                                        QModelIndex ());
-      selector->select (idx, QItemSelectionModel::Select);
-    }
+    selector = view->selectionModel ();
+    int i = 0;
+    for (QList<int>::const_iterator it = initial.begin ();
+         it != initial.end (); it++)
+      {
+        QModelIndex idx = m_model->index (initial.value (i++) - 1, 0,
+                                          QModelIndex ());
+        selector->select (idx, QItemSelectionModel::Select);
+      }
 
-  bool fixed_layout = false;
-  if (wd > 0 && ht > 0)
-    {
-      view->setFixedSize (wd, ht);
-      fixed_layout = true;
-    }
+    bool fixed_layout = false;
+    if (wd > 0 && ht > 0)
+      {
+        view->setFixedSize (wd, ht);
+        fixed_layout = true;
+      }
 
-  view->setEditTriggers (QAbstractItemView::NoEditTriggers);
+    view->setEditTriggers (QAbstractItemView::NoEditTriggers);
 
-  QVBoxLayout *listLayout = new QVBoxLayout;
-  if (! prompt.isEmpty ())
-    {
-      // For now, assume html-like Rich Text.  May be incompatible
-      // with something down the road, but just testing capability.
-      QString prompt_string;
-      for (int j = 0; j < prompt.length (); j++)
-        {
-          if (j > 0)
-// FIXME: Why define and then immediately test value?
+    QVBoxLayout *listLayout = new QVBoxLayout;
+    if (! prompt.isEmpty ())
+      {
+        // For now, assume html-like Rich Text.  May be incompatible
+        // with something down the road, but just testing capability.
+        QString prompt_string;
+        for (int j = 0; j < prompt.length (); j++)
+          {
+            if (j > 0)
+              // FIXME: Why define and then immediately test value?
 #define RICH_TEXT 1
 #if RICH_TEXT
-            prompt_string.append ("<br>");
+              prompt_string.append ("<br>");
 #else
             prompt_string.append ("\n");
 #endif
-          prompt_string.append (prompt.at (j));
-        }
-      QLabel *plabel = new QLabel (prompt_string);
+            prompt_string.append (prompt.at (j));
+          }
+        QLabel *plabel = new QLabel (prompt_string);
 #if RICH_TEXT
-      plabel->setTextFormat (Qt::RichText);
+        plabel->setTextFormat (Qt::RichText);
 #endif
 #undef RICH_TEXT
-      listLayout->addWidget (plabel);
-    }
-  listLayout->addWidget (view);
-  QPushButton *select_all = new QPushButton (tr ("Select All"));
-  select_all->setVisible (mode == "multiple");
-  listLayout->addWidget (select_all);
+        listLayout->addWidget (plabel);
+      }
+    listLayout->addWidget (view);
+    QPushButton *select_all = new QPushButton (tr ("Select All"));
+    select_all->setVisible (mode == "multiple");
+    listLayout->addWidget (select_all);
 
-  QPushButton *buttonOk = new QPushButton (ok_string);
-  QPushButton *buttonCancel = new QPushButton (cancel_string);
-  QHBoxLayout *buttonsLayout = new QHBoxLayout;
-  buttonsLayout->addStretch (1);
-  buttonsLayout->addWidget (buttonOk);
-  buttonsLayout->addWidget (buttonCancel);
-  buttonOk->setDefault (true);
+    QPushButton *buttonOk = new QPushButton (ok_string);
+    QPushButton *buttonCancel = new QPushButton (cancel_string);
+    QHBoxLayout *buttonsLayout = new QHBoxLayout;
+    buttonsLayout->addStretch (1);
+    buttonsLayout->addWidget (buttonOk);
+    buttonsLayout->addWidget (buttonCancel);
+    buttonOk->setDefault (true);
 
-  QVBoxLayout *mainLayout = new QVBoxLayout;
-  mainLayout->addLayout (listLayout);
-  mainLayout->addSpacing (12);
-  mainLayout->addLayout (buttonsLayout);
-  setLayout (mainLayout);
-  if (fixed_layout)
-    layout ()->setSizeConstraint (QLayout::SetFixedSize);
+    QVBoxLayout *mainLayout = new QVBoxLayout;
+    mainLayout->addLayout (listLayout);
+    mainLayout->addSpacing (12);
+    mainLayout->addLayout (buttonsLayout);
+    setLayout (mainLayout);
+    if (fixed_layout)
+      layout ()->setSizeConstraint (QLayout::SetFixedSize);
 
-  // If empty, make blank rather than use default OS behavior.
-  setWindowTitle (title.isEmpty () ? " " : title);
+    // If empty, make blank rather than use default OS behavior.
+    setWindowTitle (title.isEmpty () ? " " : title);
 
-  connect (select_all, SIGNAL (clicked ()),
-           view, SLOT (selectAll ()));
+    connect (select_all, SIGNAL (clicked ()),
+             view, SLOT (selectAll ()));
 
-  connect (buttonOk, SIGNAL (clicked ()),
-           this, SLOT (buttonOk_clicked ()));
+    connect (buttonOk, SIGNAL (clicked ()),
+             this, SLOT (buttonOk_clicked ()));
 
-  connect (buttonCancel, SIGNAL (clicked ()),
-           this, SLOT (buttonCancel_clicked ()));
+    connect (buttonCancel, SIGNAL (clicked ()),
+             this, SLOT (buttonCancel_clicked ()));
 
-  connect (this, SIGNAL (finish_selection (const QIntList&, int)),
-           &uiwidget_creator,
-           SLOT (list_select_finished (const QIntList&, int)));
+    connect (this, SIGNAL (finish_selection (const QIntList&, int)),
+             &uiwidget_creator,
+             SLOT (list_select_finished (const QIntList&, int)));
 
-  connect (view, SIGNAL (doubleClicked (const QModelIndex&)),
-           this, SLOT (item_double_clicked (const QModelIndex&)));
-}
+    connect (view, SIGNAL (doubleClicked (const QModelIndex&)),
+             this, SLOT (item_double_clicked (const QModelIndex&)));
+  }
 
-ListDialog::~ListDialog (void)
-{
-  delete m_model;
-}
+  ListDialog::~ListDialog (void)
+  {
+    delete m_model;
+  }
 
-void
-ListDialog::buttonOk_clicked (void)
-{
-  // Store information about what button was pressed so that builtin
-  // functions can retrieve.
-  QModelIndexList selected_index = selector->selectedIndexes ();
-  QIntList selected_int;
+  void ListDialog::buttonOk_clicked (void)
+  {
+    // Store information about what button was pressed so that builtin
+    // functions can retrieve.
+    QModelIndexList selected_index = selector->selectedIndexes ();
+    QIntList selected_int;
 
-  for (int i = 0; i < selected_index.size (); i++)
-    selected_int << selected_index.at (i).row () + 1;
+    for (int i = 0; i < selected_index.size (); i++)
+      selected_int << selected_index.at (i).row () + 1;
 
-  emit finish_selection (selected_int, 1);
+    emit finish_selection (selected_int, 1);
 
-  done (QDialog::Accepted);
-}
+    done (QDialog::Accepted);
+  }
 
-void
-ListDialog::buttonCancel_clicked (void)
-{
-  // Store information about what button was pressed so that builtin
-  // functions can retrieve.
-  QIntList empty;
+  void ListDialog::buttonCancel_clicked (void)
+  {
+    // Store information about what button was pressed so that builtin
+    // functions can retrieve.
+    QIntList empty;
 
-  emit finish_selection (empty, 0);
+    emit finish_selection (empty, 0);
 
-  done (QDialog::Rejected);
-}
+    done (QDialog::Rejected);
+  }
 
-void
-ListDialog::reject (void)
-{
-  buttonCancel_clicked ();
-}
+  void ListDialog::reject (void)
+  {
+    buttonCancel_clicked ();
+  }
 
-void
-ListDialog::item_double_clicked (const QModelIndex&)
-{
-  buttonOk_clicked ();
-}
+  void ListDialog::item_double_clicked (const QModelIndex&)
+  {
+    buttonOk_clicked ();
+  }
 
-InputDialog::InputDialog (const QStringList& prompt, const QString& title,
-                          const QFloatList& nr, const QFloatList& nc,
-                          const QStringList& defaults)
-  : QDialog ()
-{
-// FIXME: Why define and then immediately test value?
+  InputDialog::InputDialog (const QStringList& prompt, const QString& title,
+                            const QFloatList& nr, const QFloatList& nc,
+                            const QStringList& defaults)
+    : QDialog ()
+  {
+    // FIXME: Why define and then immediately test value?
 #define LINE_EDIT_FOLLOWS_PROMPT 0
 
 #if LINE_EDIT_FOLLOWS_PROMPT
-  // Prompt on left followed by input on right.
-  QGridLayout *promptInputLayout = new QGridLayout;
+    // Prompt on left followed by input on right.
+    QGridLayout *promptInputLayout = new QGridLayout;
 #else
-  // Prompt aligned above input.
-  QVBoxLayout *promptInputLayout = new QVBoxLayout;
+    // Prompt aligned above input.
+    QVBoxLayout *promptInputLayout = new QVBoxLayout;
 #endif
-  int N_gridrows = prompt.size ();
-  for (int i = 0; i < N_gridrows; i++)
-    {
-      QLabel *label = new QLabel (prompt.at (i));
-      QLineEdit *line_edit = new QLineEdit (defaults.at (i));
-      if (nr.at (i) > 0)
-        {
-          QSize qsize = line_edit->sizeHint ();
-          int intval = qsize.height () * nr.at (i);
-          line_edit->setFixedHeight (intval);
-          if (nc.at (i) > 0)
-            {
-              intval = qsize.height () * nc.at (i) / 2;
-              line_edit->setFixedWidth (intval);
-            }
-        }
-      input_line << line_edit;
+    int N_gridrows = prompt.size ();
+    for (int i = 0; i < N_gridrows; i++)
+      {
+        QLabel *label = new QLabel (prompt.at (i));
+        QLineEdit *line_edit = new QLineEdit (defaults.at (i));
+        if (nr.at (i) > 0)
+          {
+            QSize qsize = line_edit->sizeHint ();
+            int intval = qsize.height () * nr.at (i);
+            line_edit->setFixedHeight (intval);
+            if (nc.at (i) > 0)
+              {
+                intval = qsize.height () * nc.at (i) / 2;
+                line_edit->setFixedWidth (intval);
+              }
+          }
+        input_line << line_edit;
 #if LINE_EDIT_FOLLOWS_PROMPT
-      promptInputLayout->addWidget (label, i + 1, 0);
-      promptInputLayout->addWidget (line_edit, i + 1, 1);
+        promptInputLayout->addWidget (label, i + 1, 0);
+        promptInputLayout->addWidget (line_edit, i + 1, 1);
 #else
-      promptInputLayout->addWidget (label);
-      promptInputLayout->addWidget (line_edit);
+        promptInputLayout->addWidget (label);
+        promptInputLayout->addWidget (line_edit);
 #endif
-    }
+      }
 #undef LINE_EDIT_FOLLOWS_PROMPT
 
-  QPushButton *buttonOk = new QPushButton ("OK");
-  QPushButton *buttonCancel = new QPushButton ("Cancel");
-  QHBoxLayout *buttonsLayout = new QHBoxLayout;
-  buttonsLayout->addStretch (1);
-  buttonsLayout->addWidget (buttonOk);
-  buttonsLayout->addWidget (buttonCancel);
+    QPushButton *buttonOk = new QPushButton ("OK");
+    QPushButton *buttonCancel = new QPushButton ("Cancel");
+    QHBoxLayout *buttonsLayout = new QHBoxLayout;
+    buttonsLayout->addStretch (1);
+    buttonsLayout->addWidget (buttonOk);
+    buttonsLayout->addWidget (buttonCancel);
 
-  QVBoxLayout *mainLayout = new QVBoxLayout;
-  mainLayout->addLayout (promptInputLayout);
-  mainLayout->addSpacing (12);
-  mainLayout->addLayout (buttonsLayout);
-  setLayout (mainLayout);
+    QVBoxLayout *mainLayout = new QVBoxLayout;
+    mainLayout->addLayout (promptInputLayout);
+    mainLayout->addSpacing (12);
+    mainLayout->addLayout (buttonsLayout);
+    setLayout (mainLayout);
 
-  // If empty, make blank rather than use default OS behavior.
-  setWindowTitle (title.isEmpty () ? " " : title);
+    // If empty, make blank rather than use default OS behavior.
+    setWindowTitle (title.isEmpty () ? " " : title);
 
-  connect (buttonOk, SIGNAL (clicked ()),
-           this, SLOT (buttonOk_clicked ()));
+    connect (buttonOk, SIGNAL (clicked ()),
+             this, SLOT (buttonOk_clicked ()));
 
-  connect (buttonCancel, SIGNAL (clicked ()),
-           this, SLOT (buttonCancel_clicked ()));
+    connect (buttonCancel, SIGNAL (clicked ()),
+             this, SLOT (buttonCancel_clicked ()));
 
-  connect (this, SIGNAL (finish_input (const QStringList&, int)),
-           &uiwidget_creator,
-           SLOT (input_finished (const QStringList&, int)));
-}
+    connect (this, SIGNAL (finish_input (const QStringList&, int)),
+             &uiwidget_creator,
+             SLOT (input_finished (const QStringList&, int)));
+  }
 
-void
-InputDialog::buttonOk_clicked (void)
-{
-  // Store information about what button was pressed so that builtin
-  // functions can retrieve.
-  QStringList string_result;
-  for (int i = 0; i < input_line.size (); i++)
-    string_result << input_line.at (i)->text ();
-  emit finish_input (string_result, 1);
-  done (QDialog::Accepted);
-}
+  void InputDialog::buttonOk_clicked (void)
+  {
+    // Store information about what button was pressed so that builtin
+    // functions can retrieve.
+    QStringList string_result;
+    for (int i = 0; i < input_line.size (); i++)
+      string_result << input_line.at (i)->text ();
+    emit finish_input (string_result, 1);
+    done (QDialog::Accepted);
+  }
 
-void
-InputDialog::buttonCancel_clicked (void)
-{
-  // Store information about what button was pressed so that builtin
-  // functions can retrieve.
-  QStringList empty;
-  emit finish_input (empty, 0);
-  done (QDialog::Rejected);
-}
+  void InputDialog::buttonCancel_clicked (void)
+  {
+    // Store information about what button was pressed so that builtin
+    // functions can retrieve.
+    QStringList empty;
+    emit finish_input (empty, 0);
+    done (QDialog::Rejected);
+  }
 
-void
-InputDialog::reject (void)
-{
-  buttonCancel_clicked ();
-}
+  void InputDialog::reject (void)
+  {
+    buttonCancel_clicked ();
+  }
 
-FileDialog::FileDialog (const QStringList& name_filters, const QString& title,
-                        const QString& filename, const QString& dirname,
-                        const QString& multimode)
-  : QFileDialog ()
-{
-  // Create a NonModal message.
-  setWindowModality (Qt::NonModal);
+  FileDialog::FileDialog (const QStringList& name_filters, const QString& title,
+                          const QString& filename, const QString& dirname,
+                          const QString& multimode)
+    : QFileDialog ()
+  {
+    // Create a NonModal message.
+    setWindowModality (Qt::NonModal);
 
-  setWindowTitle (title.isEmpty () ? " " : title);
-  setDirectory (dirname);
+    setWindowTitle (title.isEmpty () ? " " : title);
+    setDirectory (dirname);
 
-  if (multimode == "on")         // uigetfile multiselect=on
-    {
-      setFileMode (QFileDialog::ExistingFiles);
-      setAcceptMode (QFileDialog::AcceptOpen);
-    }
-  else if (multimode == "create") // uiputfile
-    {
-      setFileMode (QFileDialog::AnyFile);
-      setAcceptMode (QFileDialog::AcceptSave);
-      setOption (QFileDialog::DontConfirmOverwrite, false);
-      setConfirmOverwrite (true);
-    }
-  else if (multimode == "dir")    // uigetdir
-    {
-      setFileMode (QFileDialog::Directory);
-      setOption (QFileDialog::ShowDirsOnly, true);
-      setOption (QFileDialog::HideNameFilterDetails, true);
-      setAcceptMode (QFileDialog::AcceptOpen);
-    }
-  else                           // uigetfile multiselect=off
-    {
-      setFileMode (QFileDialog::ExistingFile);
-      setAcceptMode (QFileDialog::AcceptOpen);
-    }
+    if (multimode == "on")         // uigetfile multiselect=on
+      {
+        setFileMode (QFileDialog::ExistingFiles);
+        setAcceptMode (QFileDialog::AcceptOpen);
+      }
+    else if (multimode == "create") // uiputfile
+      {
+        setFileMode (QFileDialog::AnyFile);
+        setAcceptMode (QFileDialog::AcceptSave);
+        setOption (QFileDialog::DontConfirmOverwrite, false);
+        setConfirmOverwrite (true);
+      }
+    else if (multimode == "dir")    // uigetdir
+      {
+        setFileMode (QFileDialog::Directory);
+        setOption (QFileDialog::ShowDirsOnly, true);
+        setOption (QFileDialog::HideNameFilterDetails, true);
+        setAcceptMode (QFileDialog::AcceptOpen);
+      }
+    else                           // uigetfile multiselect=off
+      {
+        setFileMode (QFileDialog::ExistingFile);
+        setAcceptMode (QFileDialog::AcceptOpen);
+      }
 
-  setNameFilters (name_filters);
+    setNameFilters (name_filters);
 
-  selectFile (filename);
+    selectFile (filename);
 
-  connect (this,
-           SIGNAL (finish_input (const QStringList&, const QString&, int)),
-           &uiwidget_creator,
-           SLOT (filedialog_finished (const QStringList&, const QString&,
-                                      int)));
-  connect (this, SIGNAL (accepted ()), this, SLOT (acceptSelection ()));
-  connect (this, SIGNAL (rejected ()), this, SLOT (rejectSelection ()));
-}
+    connect (this,
+             SIGNAL (finish_input (const QStringList&, const QString&, int)),
+             &uiwidget_creator,
+             SLOT (filedialog_finished (const QStringList&, const QString&,
+                                        int)));
+    connect (this, SIGNAL (accepted ()), this, SLOT (acceptSelection ()));
+    connect (this, SIGNAL (rejected ()), this, SLOT (rejectSelection ()));
+  }
 
-void
-FileDialog::rejectSelection (void)
-{
-  QStringList empty;
-  emit finish_input (empty, "", 0);
-}
+  void FileDialog::rejectSelection (void)
+  {
+    QStringList empty;
+    emit finish_input (empty, "", 0);
+  }
 
-void FileDialog::acceptSelection (void)
-{
-  QStringList string_result;
-  QString path;
-  int idx = 1;
+  void FileDialog::acceptSelection (void)
+  {
+    QStringList string_result;
+    QString path;
+    int idx = 1;
 
-  string_result = selectedFiles ();
+    string_result = selectedFiles ();
 
-  if (testOption (QFileDialog::ShowDirsOnly)  == true &&
-      string_result.size () > 0)
-    {
-      path = string_result[0];
-    }
-  else
-    {
-      path = directory ().absolutePath ();
-    }
+    if (testOption (QFileDialog::ShowDirsOnly)  == true &&
+        string_result.size () > 0)
+      {
+        path = string_result[0];
+      }
+    else
+      {
+        path = directory ().absolutePath ();
+      }
 
-  // Matlab expects just the filename, whereas the file dialog gave us
-  // full path names, so fix it.
+    // Matlab expects just the filename, whereas the file dialog gave us
+    // full path names, so fix it.
 
-  for (int i = 0; i < string_result.size (); i++)
-    string_result[i] = QFileInfo (string_result[i]).fileName ();
+    for (int i = 0; i < string_result.size (); i++)
+      string_result[i] = QFileInfo (string_result[i]).fileName ();
 
-  // if not showing only dirs, add end slash for the path component
-  if (testOption (QFileDialog::ShowDirsOnly)  == false)
-    path += '/';
+    // if not showing only dirs, add end slash for the path component
+    if (testOption (QFileDialog::ShowDirsOnly)  == false)
+      path += '/';
 
-  // convert to native slashes
-  path = QDir::toNativeSeparators (path);
+    // convert to native slashes
+    path = QDir::toNativeSeparators (path);
 
-  QStringList name_filters = nameFilters ();
-  idx = name_filters.indexOf (selectedNameFilter ()) + 1;
+    QStringList name_filters = nameFilters ();
+    idx = name_filters.indexOf (selectedNameFilter ()) + 1;
 
-  // send the selected info
-  emit finish_input (string_result, path, idx);
+    // send the selected info
+    emit finish_input (string_result, path, idx);
+  }
 }
diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -35,244 +35,248 @@ along with Octave; see the file COPYING.
 #include <QFileDialog>
 
 // Defined for purposes of sending QList<int> as part of signal.
 typedef QList<int> QIntList;
 
 // Defined for purposes of sending QList<float> as part of signal.
 typedef QList<float> QFloatList;
 
-
-class QUIWidgetCreator : public QObject
+namespace octave
 {
-  Q_OBJECT
+  class QUIWidgetCreator : public QObject
+  {
+    Q_OBJECT
+
+  public:
 
-public:
+    QUIWidgetCreator (void);
+
+    ~QUIWidgetCreator (void);
+
+  public:
+
+    QString rm_amp (const QString& text);
 
-  QUIWidgetCreator (void);
-
-  ~QUIWidgetCreator (void);
+    void signal_dialog (const QString& message, const QString& title,
+                        const QString& icon, const QStringList& button,
+                        const QString& defbutton, const QStringList& role)
+    {
+      // Store button text before a window-manager adds accelerators
+      m_button_list = button;
 
-public:
+      // Use the last button in the list as the reject result, i.e., when no
+      // button is pressed such as in the case of the upper right close tab.
+      if (! button.isEmpty ())
+        m_dialog_button = button.last ();
 
-  QString rm_amp (const QString& text);
+      QString xicon = icon;
+      if (xicon.isEmpty ())
+        xicon = "none";
 
-  void signal_dialog (const QString& message, const QString& title,
-                      const QString& icon, const QStringList& button,
-                      const QString& defbutton, const QStringList& role)
-  {
-    // Store button text before a window-manager adds accelerators
-    m_button_list = button;
+      emit create_dialog (message, title, xicon, button, defbutton, role);
+    };
+
+    int get_dialog_result (void) { return m_dialog_result; }
+
+    QString get_dialog_button (void) { return m_dialog_button; }
+
+    bool signal_listview (const QStringList& list, const QString& mode,
+                          int wd, int ht, const QList<int>& initial,
+                          const QString& name, const QStringList& prompt,
+                          const QString& ok_string,
+                          const QString& cancel_string)
+    {
+      if (list.isEmpty ())
+        return false;
 
-    // Use the last button in the list as the reject result, i.e., when no
-    // button is pressed such as in the case of the upper right close tab.
-    if (! button.isEmpty ())
-      m_dialog_button = button.last ();
+      emit create_listview (list, mode, wd, ht, initial, name,
+                            prompt, ok_string, cancel_string);
+
+      return true;
+    };
+
+    const QIntList * get_list_index (void) { return m_list_index; }
 
-    QString xicon = icon;
-    if (xicon.isEmpty ())
-      xicon = "none";
+    bool signal_inputlayout (const QStringList& prompt, const QString& title,
+                             const QFloatList& nr, const QFloatList& nc,
+                             const QStringList& defaults)
+    {
+      if (prompt.isEmpty ())
+        return false;
+
+      emit create_inputlayout (prompt, title, nr, nc, defaults);
 
-    emit create_dialog (message, title, xicon, button, defbutton, role);
-  };
+      return true;
+    };
+
+    const QStringList * get_string_list (void) { return m_string_list; }
 
-  int get_dialog_result (void) { return m_dialog_result; }
+    bool signal_filedialog (const QStringList& filters, const QString& title,
+                            const QString& filename, const QString& dirname,
+                            const QString& multimode)
+    {
+      emit create_filedialog (filters, title, filename, dirname, multimode);
+      return true;
+    }
 
-  QString get_dialog_button (void) { return m_dialog_button; }
+    const QString * get_dialog_path (void) { return m_path_name; }
 
-  bool signal_listview (const QStringList& list, const QString& mode,
-                        int wd, int ht, const QList<int>& initial,
-                        const QString& name, const QStringList& prompt,
-                        const QString& ok_string, const QString& cancel_string)
-  {
-    if (list.isEmpty ())
-      return false;
+    void lock (void) { m_mutex.lock (); }
+    void wait (void) { m_waitcondition.wait (&m_mutex); }
+    void unlock (void) { m_mutex.unlock (); }
+    void wake_all (void) { m_waitcondition.wakeAll (); }
+
+  signals:
+
+    void create_dialog (const QString&, const QString&, const QString&,
+                        const QStringList&, const QString&, const QStringList&);
+
+    void create_listview (const QStringList&, const QString&, int, int,
+                          const QIntList&, const QString&, const QStringList&,
+                          const QString&, const QString&);
+
+    void create_inputlayout (const QStringList&, const QString&,
+                             const QFloatList&, const QFloatList&,
+                             const QStringList&);
 
-    emit create_listview (list, mode, wd, ht, initial, name,
-                          prompt, ok_string, cancel_string);
+    void create_filedialog (const QStringList& filters, const QString& title,
+                            const QString& filename, const QString& dirname,
+                            const QString& multimode);
+  public slots:
+
+    void dialog_button_clicked (QAbstractButton *button);
 
-    return true;
-  };
+    void list_select_finished (const QIntList& selected, int button_pressed);
+
+    void input_finished (const QStringList& input, int button_pressed);
 
-  const QIntList * get_list_index (void) { return m_list_index; }
+    void filedialog_finished (const QStringList& files, const QString& path,
+                              int filterindex);
+
+  private:
 
-  bool signal_inputlayout (const QStringList& prompt, const QString& title,
-                           const QFloatList& nr, const QFloatList& nc,
-                           const QStringList& defaults)
-  {
-    if (prompt.isEmpty ())
-      return false;
+    int m_dialog_result;
+    QString m_dialog_button;
+
+    // A copy of the dialogs button texts
+    QStringList m_button_list;
 
-    emit create_inputlayout (prompt, title, nr, nc, defaults);
+    // The list could conceivably be big.  Not sure how things are
+    // stored internally, so keep off of the stack.
+    QStringList *m_string_list;
+    QIntList *m_list_index;
 
-    return true;
+    QString *m_path_name;
+
+    // GUI objects cannot be accessed in the non-GUI thread.  However,
+    // signals can be sent to slots across threads with proper
+    // synchronization.  Hence, the use of QWaitCondition.
+    QMutex m_mutex;
+    QWaitCondition m_waitcondition;
   };
 
-  const QStringList * get_string_list (void) { return m_string_list; }
-
-  bool signal_filedialog (const QStringList& filters, const QString& title,
-                          const QString& filename, const QString& dirname,
-                          const QString& multimode)
-  {
-    emit create_filedialog (filters, title, filename, dirname, multimode);
-    return true;
-  }
-
-  const QString * get_dialog_path (void) { return m_path_name; }
-
-  void lock (void) { m_mutex.lock (); }
-  void wait (void) { m_waitcondition.wait (&m_mutex); }
-  void unlock (void) { m_mutex.unlock (); }
-  void wake_all (void) { m_waitcondition.wakeAll (); }
-
-signals:
+  extern QUIWidgetCreator uiwidget_creator;
 
-  void create_dialog (const QString&, const QString&, const QString&,
-                      const QStringList&, const QString&, const QStringList&);
-
-  void create_listview (const QStringList&, const QString&, int, int,
-                        const QIntList&, const QString&, const QStringList&,
-                        const QString&, const QString&);
-
-  void create_inputlayout (const QStringList&, const QString&,
-                           const QFloatList&, const QFloatList&,
-                           const QStringList&);
+  class MessageDialog : public QMessageBox
+  {
+    Q_OBJECT
 
-  void create_filedialog (const QStringList& filters, const QString& title,
-                          const QString& filename, const QString& dirname,
-                          const QString& multimode);
-public slots:
-
-  void dialog_button_clicked (QAbstractButton *button);
-
-  void list_select_finished (const QIntList& selected, int button_pressed);
-
-  void input_finished (const QStringList& input, int button_pressed);
+  public:
 
-  void filedialog_finished (const QStringList& files, const QString& path,
-                            int filterindex);
-
-private:
-
-  int m_dialog_result;
-  QString m_dialog_button;
+    explicit MessageDialog (const QString& message, const QString& title,
+                            const QString& icon, const QStringList& button,
+                            const QString& defbutton,
+                            const QStringList& role);
 
-  // A copy of the dialogs button texts
-  QStringList m_button_list;
-
-  // The list could conceivably be big.  Not sure how things are
-  // stored internally, so keep off of the stack.
-  QStringList *m_string_list;
-  QIntList *m_list_index;
-
-  QString *m_path_name;
+  private:
 
-  // GUI objects cannot be accessed in the non-GUI thread.  However,
-  // signals can be sent to slots across threads with proper
-  // synchronization.  Hence, the use of QWaitCondition.
-  QMutex m_mutex;
-  QWaitCondition m_waitcondition;
-};
-
-extern QUIWidgetCreator uiwidget_creator;
+    void closeEvent (QCloseEvent *)
+    {
+      // Reroute the close tab to a button click so there is only a single
+      // route to waking the wait condition.
+      emit buttonClicked (nullptr);
+    }
+  };
 
-class MessageDialog : public QMessageBox
-{
-  Q_OBJECT
-
-public:
-
-  explicit MessageDialog (const QString& message, const QString& title,
-                          const QString& icon, const QStringList& button,
-                          const QString& defbutton,
-                          const QStringList& role);
-
-private:
-
-  void closeEvent (QCloseEvent *)
+  class ListDialog : public QDialog
   {
-    // Reroute the close tab to a button click so there is only a single
-    // route to waking the wait condition.
-    emit buttonClicked (nullptr);
-  }
-};
+    Q_OBJECT
+
+    QItemSelectionModel *selector;
+
+  public:
 
-class ListDialog : public QDialog
-{
-  Q_OBJECT
-
-  QItemSelectionModel *selector;
+    explicit ListDialog (const QStringList& list, const QString& mode,
+                         int width, int height, const QList<int>& initial,
+                         const QString& name, const QStringList& prompt,
+                         const QString& ok_string,
+                         const QString& cancel_string);
 
-public:
+    ~ListDialog (void);
 
-  explicit ListDialog (const QStringList& list, const QString& mode,
-                       int width, int height, const QList<int>& initial,
-                       const QString& name, const QStringList& prompt,
-                       const QString& ok_string, const QString& cancel_string);
+  signals:
+
+    void finish_selection (const QIntList&, int);
 
-  ~ListDialog (void);
+  public slots:
 
-signals:
+    void buttonOk_clicked (void);
 
-  void finish_selection (const QIntList&, int);
+    void buttonCancel_clicked (void);
 
-public slots:
+    void reject (void);
 
-  void buttonOk_clicked (void);
+    void item_double_clicked (const QModelIndex&);
 
-  void buttonCancel_clicked (void);
+  private:
 
-  void reject (void);
+    QAbstractItemModel *m_model;
+  };
 
-  void item_double_clicked (const QModelIndex&);
+  class InputDialog : public QDialog
+  {
+    Q_OBJECT
 
-private:
-
-  QAbstractItemModel *m_model;
-};
+    QList<QLineEdit *> input_line;
 
-class InputDialog : public QDialog
-{
-  Q_OBJECT
+  public:
 
-  QList<QLineEdit *> input_line;
+    explicit InputDialog (const QStringList& prompt, const QString& title,
+                          const QFloatList& nr, const QFloatList& nc,
+                          const QStringList& defaults);
 
-public:
+  signals:
 
-  explicit InputDialog (const QStringList& prompt, const QString& title,
-                        const QFloatList& nr, const QFloatList& nc,
-                        const QStringList& defaults);
+    void finish_input (const QStringList&, int);
 
-signals:
+  public slots:
 
-  void finish_input (const QStringList&, int);
-
-public slots:
+    void buttonOk_clicked (void);
 
-  void buttonOk_clicked (void);
+    void buttonCancel_clicked (void);
 
-  void buttonCancel_clicked (void);
+    void reject (void);
+  };
 
-  void reject (void);
-};
+  class FileDialog : public QFileDialog
+  {
+    Q_OBJECT
 
-class FileDialog : public QFileDialog
-{
-  Q_OBJECT
+  public:
 
-public:
+    explicit FileDialog (const QStringList& filters,
+                         const QString& title, const QString& filename,
+                         const QString& dirname, const QString& multimode);
 
-  explicit FileDialog (const QStringList& filters,
-                       const QString& title, const QString& filename,
-                       const QString& dirname, const QString& multimode);
+  signals:
 
-signals:
+    void finish_input (const QStringList&, const QString&, int);
+
+  private slots:
 
-  void finish_input (const QStringList&, const QString&, int);
-
-private slots:
+    void acceptSelection (void);
 
-  void acceptSelection (void);
-
-  void rejectSelection (void);
-};
+    void rejectSelection (void);
+  };
+}
 
 #endif
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 documentation_dock_widget::documentation_dock_widget (QWidget *p)
   : octave_dock_widget (p)
 {
   setObjectName ("DocumentationDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Documentation"));
   setStatusTip (tr ("See the documentation for help."));
 
-  m_webinfo = new webinfo (this);
+  m_webinfo = new octave::webinfo (this);
   setWidget (m_webinfo);
   setFocusProxy (m_webinfo);
 
   connect (p, SIGNAL (show_doc_signal (const QString&)),
            this, SLOT (showDoc (const QString&)));
 }
 
 void
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -46,12 +46,12 @@ protected slots:
   void copyClipboard (void);
   void pasteClipboard (void);
   void selectAll (void);
 
   void showDoc (const QString & name);
 
 private:
 
-  webinfo *m_webinfo;
+  octave::webinfo *m_webinfo;
 };
 
 #endif
diff --git a/libgui/src/external-editor-interface.cc b/libgui/src/external-editor-interface.cc
--- a/libgui/src/external-editor-interface.cc
+++ b/libgui/src/external-editor-interface.cc
@@ -26,98 +26,98 @@ along with Octave; see the file COPYING.
 
 #include <QSettings>
 #include <QMessageBox>
 #include <QProcess>
 
 #include "external-editor-interface.h"
 #include "resource-manager.h"
 
-external_editor_interface::external_editor_interface (QWidget *p)
-  : QWidget (p)
-{ }
-
-// Calling the external editor
-bool
-external_editor_interface::call_custom_editor (const QString& file, int line)
+namespace octave
 {
-  if (line > -1)  // check for a specific line (debugging)
-    return true;  // yes: do not open a file in external editor
-  else
-    line = 0;     // no: start external editor at beginning of file
+  external_editor_interface::external_editor_interface (QWidget *p)
+    : QWidget (p)
+  { }
 
-  QString editor = external_editor ();
-  if (editor.isEmpty ())
-    return true;
+  // Calling the external editor
+  bool
+  external_editor_interface::call_custom_editor (const QString& file, int line)
+  {
+    if (line > -1)  // check for a specific line (debugging)
+      return true;  // yes: do not open a file in external editor
+    else
+      line = 0;     // no: start external editor at beginning of file
+
+    QString editor = external_editor ();
+    if (editor.isEmpty ())
+      return true;
 
-  // replace macros
-  editor.replace ("%f", file);
-  editor.replace ("%l", QString::number (line));
+    // replace macros
+    editor.replace ("%f", file);
+    editor.replace ("%l", QString::number (line));
 
-  // start the process and check for success
-  bool started_ok = QProcess::startDetached (editor);
+    // start the process and check for success
+    bool started_ok = QProcess::startDetached (editor);
 
-  if (started_ok != true)
-    {
-      QMessageBox *msgBox = new QMessageBox (QMessageBox::Critical,
-                               tr ("Octave Editor"),
-                               tr ("Could not start custom file editor\n%1").
-                               arg (editor),
-                               QMessageBox::Ok);
+    if (started_ok != true)
+      {
+        QMessageBox *msgBox = new QMessageBox (QMessageBox::Critical,
+                                               tr ("Octave Editor"),
+                                               tr ("Could not start custom file editor\n%1").
+                                               arg (editor),
+                                               QMessageBox::Ok);
 
-      msgBox->setWindowModality (Qt::NonModal);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-      msgBox->show ();
-    }
+        msgBox->setWindowModality (Qt::NonModal);
+        msgBox->setAttribute (Qt::WA_DeleteOnClose);
+        msgBox->show ();
+      }
 
-  return started_ok;
-}
+    return started_ok;
+  }
 
 
-// Slots for the several signals for invoking the editor
+  // Slots for the several signals for invoking the editor
 
-void
-external_editor_interface::request_new_file (const QString&)
-{
-  call_custom_editor ();
-}
+  void external_editor_interface::request_new_file (const QString&)
+  {
+    call_custom_editor ();
+  }
 
-void
-external_editor_interface::request_open_file (const QString& file_name,
-                                              const QString&, int line,
-                                              bool, bool, bool, const QString&)
-{
-  call_custom_editor (file_name, line);
-}
+  void external_editor_interface::request_open_file (const QString& file_name,
+                                                     const QString&, int line,
+                                                     bool, bool, bool,
+                                                     const QString&)
+  {
+    call_custom_editor (file_name, line);
+  }
 
-void
-external_editor_interface::handle_edit_file_request (const QString& file)
-{
-  call_custom_editor (file);
-}
+  void external_editor_interface::handle_edit_file_request (const QString& file)
+  {
+    call_custom_editor (file);
+  }
 
-// Get and verify the settings of the external editor program
-QString
-external_editor_interface::external_editor (void)
-{
-  QSettings *settings = resource_manager::get_settings ();
-  QString editor = settings->value ("customFileEditor").toString ();
+  // Get and verify the settings of the external editor program
+  QString external_editor_interface::external_editor (void)
+  {
+    QSettings *settings = resource_manager::get_settings ();
+    QString editor = settings->value ("customFileEditor").toString ();
 
-  // check the settings (avoid an empty string)
-  if (editor.trimmed ().isEmpty ())
-    {
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Warning,
-                           tr ("Octave Editor"),
-                           tr ("There is no custom editor configured yet.\n"
-                               "Do you want to open the preferences?"),
-                           QMessageBox::No | QMessageBox::Yes);
-      msgBox->setDefaultButton (QMessageBox::Yes);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+    // check the settings (avoid an empty string)
+    if (editor.trimmed ().isEmpty ())
+      {
+        QMessageBox *msgBox
+          = new QMessageBox (QMessageBox::Warning,
+                             tr ("Octave Editor"),
+                             tr ("There is no custom editor configured yet.\n"
+                                 "Do you want to open the preferences?"),
+                             QMessageBox::No | QMessageBox::Yes);
+        msgBox->setDefaultButton (QMessageBox::Yes);
+        msgBox->setAttribute (Qt::WA_DeleteOnClose);
 
-      int button = msgBox->exec ();
+        int button = msgBox->exec ();
 
-      if (button == QMessageBox::Yes)
-        emit request_settings_dialog ("editor");
-    }
+        if (button == QMessageBox::Yes)
+          emit request_settings_dialog ("editor");
+      }
 
-  return editor;
+    return editor;
+  }
 }
diff --git a/libgui/src/external-editor-interface.h b/libgui/src/external-editor-interface.h
--- a/libgui/src/external-editor-interface.h
+++ b/libgui/src/external-editor-interface.h
@@ -22,43 +22,46 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_external_editor_interface_h)
 #define octave_external_editor_interface_h 1
 
 #include <QWidget>
 #include <QString>
 
-class external_editor_interface : public QWidget
+namespace octave
 {
+  class external_editor_interface : public QWidget
+  {
 
-  Q_OBJECT
-
-public:
+    Q_OBJECT
 
-  external_editor_interface (QWidget *main_win);
+  public:
 
-  ~external_editor_interface (void) = default;
+    external_editor_interface (QWidget *main_win);
 
-signals:
+    ~external_editor_interface (void) = default;
 
-  void request_settings_dialog (const QString&);
+  signals:
 
-public slots:
+    void request_settings_dialog (const QString&);
 
-  bool call_custom_editor (const QString& file = QString (), int line = -1);
+  public slots:
+
+    bool call_custom_editor (const QString& file = QString (), int line = -1);
 
-  void request_open_file (const QString& fileName,
-                          const QString& encoding = QString (),
-                          int line = -1, bool debug_pointer = false,
-                          bool breakpoint_marker = false, bool insert = true,
-                          const QString& cond = "");
+    void request_open_file (const QString& fileName,
+                            const QString& encoding = QString (),
+                            int line = -1, bool debug_pointer = false,
+                            bool breakpoint_marker = false, bool insert = true,
+                            const QString& cond = "");
 
-  void request_new_file (const QString&);
+    void request_new_file (const QString&);
 
-  void handle_edit_file_request (const QString& file);
+    void handle_edit_file_request (const QString& file);
 
-private:
+  private:
 
-  QString external_editor (void);
-};
+    QString external_editor (void);
+  };
+}
 
 #endif
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -69,17 +69,17 @@ class octave_value;
 namespace octave
 {
   class octave_interpreter : public QObject
   {
     Q_OBJECT
 
   public:
 
-    octave_interpreter (octave::application *app_context);
+    octave_interpreter (application *app_context);
 
     ~octave_interpreter (void) = default;
 
     void interrupt (void);
 
   signals:
 
     void octave_ready_signal (void);
@@ -88,33 +88,33 @@ namespace octave
   public slots:
 
     //! Initialize and execute the octave interpreter.
 
     void execute (void);
 
   private:
 
-    octave_thread_manager m_thread_manager;
+    thread_manager m_thread_manager;
 
-    octave::application *m_app_context;
+    application *m_app_context;
   };
 
   //! Represents the main window.
 
   class main_window : public QMainWindow
   {
     Q_OBJECT
 
   public:
 
     typedef std::pair <std::string, std::string> name_pair;
     typedef std::pair <int, int> int_pair;
 
-    main_window (QWidget *parent, octave::gui_application *app_context);
+    main_window (QWidget *parent, gui_application *app_context);
 
     ~main_window (void);
 
     bool command_window_has_focus (void) const;
 
     void focus_command_window (void);
 
   signals:
@@ -348,17 +348,17 @@ namespace octave
     void new_figure_callback (void);
 
     void change_directory_callback (const std::string& directory);
 
     void configure_shortcuts (void);
 
     QList<octave_dock_widget *> dock_widget_list (void);
 
-    octave::gui_application *m_app_context;
+    gui_application *m_app_context;
 
     octave_interpreter *m_interpreter;
 
     QThread *m_main_thread;
 
     workspace_model *m_workspace_model;
 
     QHash<QMenu*, QStringList> m_hash_menu_text;
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -28,123 +28,110 @@ along with Octave; see the file COPYING.
 
 #include "octave-cmd.h"
 
 #include "octave-qt-link.h"
 #include "cmd-edit.h"
 #include "builtin-defun-decls.h"
 #include "utils.h"
 
-
-// ---------------------------------------------------------------------
-//  class octave_cmd_exec: executing a command
-
-void
-octave_cmd_exec::execute (void)
-{
-  std::string pending_input = octave::command_editor::get_current_line ();
-
-  octave::command_editor::set_initial_input (pending_input);
-  octave::command_editor::replace_line (m_cmd.toStdString ());
-  octave::command_editor::redisplay ();
-  octave::command_editor::accept_line ();
-}
-
-// ---------------------------------------------------------------------
-//  class octave_cmd_eval: running a file
-
-void
-octave_cmd_eval::execute (void)
-{
-  QString function_name = m_info.fileName ();
-  function_name.chop (m_info.suffix ().length () + 1);
-  std::string file_path = m_info.absoluteFilePath ().toStdString ();
-
-  std::string pending_input = octave::command_editor::get_current_line ();
-
-  if (valid_identifier (function_name.toStdString ()))
-    {
-      // valid identifier: call as function with possibility to debug
-      std::string path = m_info.absolutePath ().toStdString ();
-      if (octave_qt_link::file_in_path (file_path, path))
-        octave::command_editor::replace_line (function_name.toStdString ());
-    }
-  else
-    {
-      // no valid identifier: use Fsource (), no debug possible
-      Fsource (ovl (file_path));
-      octave::command_editor::replace_line ("");
-    }
-
-  octave::command_editor::set_initial_input (pending_input);
-  octave::command_editor::redisplay ();
-
-  octave::command_editor::accept_line ();
-}
-
-// ---------------------------------------------------------------------
-//  class octave_cmd_debug: executing a debugger command
-
-void
-octave_cmd_debug::execute (void)
+namespace octave
 {
-  if (m_cmd == "step")
-    {
-      F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
-      Fdbstep ();
-    }
-  else if (m_cmd == "cont")
-    {
-      F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
-      Fdbcont ();
-    }
-  else if (m_cmd == "quit")
-    Fdbquit ();
-  else
-    {
-      F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
-      Fdbstep (ovl (m_cmd.toStdString ()));
-    }
+  void octave_cmd_exec::execute (void)
+  {
+    std::string pending_input = octave::command_editor::get_current_line ();
+
+    octave::command_editor::set_initial_input (pending_input);
+    octave::command_editor::replace_line (m_cmd.toStdString ());
+    octave::command_editor::redisplay ();
+    octave::command_editor::accept_line ();
+  }
+
+  void octave_cmd_eval::execute (void)
+  {
+    QString function_name = m_info.fileName ();
+    function_name.chop (m_info.suffix ().length () + 1);
+    std::string file_path = m_info.absoluteFilePath ().toStdString ();
+
+    std::string pending_input = octave::command_editor::get_current_line ();
 
-  octave::command_editor::interrupt (true);
-}
+    if (valid_identifier (function_name.toStdString ()))
+      {
+        // valid identifier: call as function with possibility to debug
+        std::string path = m_info.absolutePath ().toStdString ();
+        if (octave_qt_link::file_in_path (file_path, path))
+          octave::command_editor::replace_line (function_name.toStdString ());
+      }
+    else
+      {
+        // no valid identifier: use Fsource (), no debug possible
+        Fsource (ovl (file_path));
+        octave::command_editor::replace_line ("");
+      }
 
-// ---------------------------------------------------------------------
-//  class octave_command_queue: queue of octave commands
+    octave::command_editor::set_initial_input (pending_input);
+    octave::command_editor::redisplay ();
+
+    octave::command_editor::accept_line ();
+  }
 
-// add_cmd: add a command to the queue
-void
-octave_command_queue::add_cmd (octave_cmd *cmd)
-{
-  m_queue_mutex.lock ();
-  m_queue.append (cmd);
-  m_queue_mutex.unlock ();
+  void octave_cmd_debug::execute (void)
+  {
+    if (m_cmd == "step")
+      {
+        F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
+        Fdbstep ();
+      }
+    else if (m_cmd == "cont")
+      {
+        F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
+        Fdbcont ();
+      }
+    else if (m_cmd == "quit")
+      Fdbquit ();
+    else
+      {
+        F__db_next_breakpoint_quiet__ (ovl (m_suppress_dbg_location));
+        Fdbstep (ovl (m_cmd.toStdString ()));
+      }
 
-  if (m_processing.tryAcquire ())  // if callback not processing, post event
-    octave_link::post_event (this, &octave_command_queue::execute_command_callback);
-}
+    octave::command_editor::interrupt (true);
+  }
+
+  // add a command to the queue
 
-// callback for executing the command by the worker thread
-void
-octave_command_queue::execute_command_callback (void)
-{
-  bool repost = false;          // flag for reposting event for this callback
+  void octave_command_queue::add_cmd (octave_cmd *cmd)
+  {
+    m_queue_mutex.lock ();
+    m_queue.append (cmd);
+    m_queue_mutex.unlock ();
 
-  if (! m_queue.isEmpty ())  // list can not be empty here, just to make sure
-    {
-      m_queue_mutex.lock ();     // critical path
+    if (m_processing.tryAcquire ())  // if callback not processing, post event
+      octave_link::post_event (this, &octave_command_queue::execute_command_callback);
+  }
+
+  // callback for executing the command by the worker thread
 
-      octave_cmd *cmd = m_queue.takeFirst ();
+  void octave_command_queue::execute_command_callback (void)
+  {
+    bool repost = false;          // flag for reposting event for this callback
+
+    if (! m_queue.isEmpty ())  // list can not be empty here, just to make sure
+      {
+        m_queue_mutex.lock ();     // critical path
+
+        octave_cmd *cmd = m_queue.takeFirst ();
 
-      if (m_queue.isEmpty ())
-        m_processing.release (); // cmd queue empty, processing will stop
-      else
-        repost = true;          // not empty, repost at end
-      m_queue_mutex.unlock ();
+        if (m_queue.isEmpty ())
+          m_processing.release (); // cmd queue empty, processing will stop
+        else
+          repost = true;          // not empty, repost at end
+        m_queue_mutex.unlock ();
+
+        cmd->execute ();
 
-      cmd->execute ();
+        delete cmd;
+      }
 
-      delete cmd;
-    }
-
-  if (repost)  // queue not empty, so repost event for further processing
-    octave_link::post_event (this, &octave_command_queue::execute_command_callback);
+    if (repost)  // queue not empty, so repost event for further processing
+      octave_link::post_event (this, &octave_command_queue::execute_command_callback);
+  }
 }
diff --git a/libgui/src/octave-cmd.h b/libgui/src/octave-cmd.h
--- a/libgui/src/octave-cmd.h
+++ b/libgui/src/octave-cmd.h
@@ -27,101 +27,95 @@ along with Octave; see the file COPYING.
 
 #include <QSemaphore>
 #include <QMutex>
 #include <QString>
 #include <QFileInfo>
 
 #include "octave-qt-link.h"
 
-class octave_cmd
+namespace octave
 {
-public:
+  class octave_cmd
+  {
+  public:
 
-  octave_cmd (void) = default;
+    octave_cmd (void) = default;
 
-  virtual ~octave_cmd (void) = default;
-
-  virtual void execute (void) { }
-};
+    virtual ~octave_cmd (void) = default;
 
-// ---------------------------------------------------------------------
-//  class octave_cmd_exec
+    virtual void execute (void) { }
+  };
 
-class octave_cmd_exec : public octave_cmd
-{
-public:
+  class octave_cmd_exec : public octave_cmd
+  {
+  public:
 
-  octave_cmd_exec (const QString& cmd) : octave_cmd () { m_cmd = cmd; }
+    octave_cmd_exec (const QString& cmd) : octave_cmd () { m_cmd = cmd; }
 
-  void execute (void);
+    void execute (void);
 
-protected:
+  protected:
 
-  QString m_cmd;
-};
+    QString m_cmd;
+  };
 
-// ---------------------------------------------------------------------
-//  class octave_cmd_eval
+  class octave_cmd_eval : public octave_cmd
+  {
+  public:
 
-class octave_cmd_eval : public octave_cmd
-{
-public:
+    octave_cmd_eval (const QFileInfo& info) : octave_cmd () { m_info = info; }
 
-  octave_cmd_eval (const QFileInfo& info) : octave_cmd () { m_info = info; }
+    void execute (void);
 
-  void execute (void);
-
-protected:
+  protected:
 
-  QFileInfo m_info;
-};
+    QFileInfo m_info;
+  };
 
-// ---------------------------------------------------------------------
-//  class octave_cmd_debug
+  class octave_cmd_debug : public octave_cmd_exec
+  {
+  public:
 
-class octave_cmd_debug : public octave_cmd_exec
-{
-public:
+    octave_cmd_debug (const QString& cmd, bool suppress_location)
+      : octave_cmd_exec (cmd), m_suppress_dbg_location (suppress_location) { }
 
-  octave_cmd_debug (const QString& cmd, bool suppress_location)
-    : octave_cmd_exec (cmd), m_suppress_dbg_location (suppress_location) { }
+    void execute (void);
 
-  void execute (void);
-
-protected:
+  protected:
 
-  bool m_suppress_dbg_location;
-};
+    bool m_suppress_dbg_location;
+  };
 
-//! Queuing octave commands from the GUI for the worker thread.
+  //! Queuing octave commands from the GUI for the worker thread.
 
-class octave_command_queue : QObject
-{
-  Q_OBJECT;
+  class octave_command_queue : QObject
+  {
+    Q_OBJECT;
 
-public:
+  public:
 
-  octave_command_queue (void)
-    : QObject (), m_queue (QList<octave_cmd *> ()), m_processing (1),
-      m_queue_mutex ()
-  { }
+    octave_command_queue (void)
+      : QObject (), m_queue (QList<octave_cmd *> ()), m_processing (1),
+        m_queue_mutex ()
+    { }
 
-  ~octave_command_queue (void) = default;
+    ~octave_command_queue (void) = default;
 
-  //! Adds a new octave command to the command queue.
-  //!
-  //! @param cmd The octave command to be queued.
+    //! Adds a new octave command to the command queue.
+    //!
+    //! @param cmd The octave command to be queued.
 
-  void add_cmd (octave_cmd *cmd);
+    void add_cmd (octave_cmd *cmd);
 
-  //! Callback routine for executing the command by the worker thread.
+    //! Callback routine for executing the command by the worker thread.
 
-  void execute_command_callback (void);
+    void execute_command_callback (void);
 
-private:
+  private:
 
-  QList<octave_cmd *> m_queue;
-  QSemaphore m_processing;
-  QMutex m_queue_mutex;
-};
+    QList<octave_cmd *> m_queue;
+    QSemaphore m_processing;
+    QMutex m_queue_mutex;
+  };
+}
 
 #endif
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -125,17 +125,17 @@ namespace octave
     if (! code_to_eval.empty () || m_have_script_file)
       return false;
 
     return true;
   }
 
   int gui_application::execute (void)
   {
-    octave_thread_manager::block_interrupt_signal ();
+    thread_manager::block_interrupt_signal ();
 
     set_application_id ();
 
     std::string show_gui_msgs =
       sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
 
     // Installing our handler suppresses the messages.
 
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -46,578 +46,563 @@ along with Octave; see the file COPYING.
 
 #include "octave-gui.h"
 #include "octave-qt-link.h"
 #include "resource-manager.h"
 
 Q_DECLARE_METATYPE (octave_value)
 Q_DECLARE_METATYPE (octave::symbol_scope)
 
-octave_qt_link::octave_qt_link (QWidget *,
-                                octave::gui_application *app_context)
-  : octave_link (), m_app_context (app_context)
+namespace octave
 {
-  qRegisterMetaType<octave_value> ("octave_value");
-  qRegisterMetaType<octave::symbol_scope> ("symbol_scope");
-}
+  octave_qt_link::octave_qt_link (QWidget *,
+                                  octave::gui_application *app_context)
+    : octave_link (), m_app_context (app_context)
+  {
+    qRegisterMetaType<octave_value> ("octave_value");
+    qRegisterMetaType<octave::symbol_scope> ("symbol_scope");
+  }
 
-bool
-octave_qt_link::do_confirm_shutdown (void)
-{
-  // Lock the mutex before emitting signal.
-  lock ();
+  bool octave_qt_link::do_confirm_shutdown (void)
+  {
+    // Lock the mutex before emitting signal.
+    lock ();
 
-  emit confirm_shutdown_signal ();
+    emit confirm_shutdown_signal ();
 
-  // Wait while the GUI shuts down.
-  wait ();
+    // Wait while the GUI shuts down.
+    wait ();
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // The GUI has sent a signal and the thread has been awakened.
 
-  unlock ();
+    unlock ();
 
-  return m_shutdown_confirm_result;
-}
+    return m_shutdown_confirm_result;
+  }
 
-bool
-octave_qt_link::do_copy_image_to_clipboard (const std::string& file)
-{
-  emit copy_image_to_clipboard_signal (QString::fromStdString (file), true);
+  bool octave_qt_link::do_copy_image_to_clipboard (const std::string& file)
+  {
+    emit copy_image_to_clipboard_signal (QString::fromStdString (file), true);
 
-  return true;
-}
+    return true;
+  }
 
-bool
-octave_qt_link::do_edit_file (const std::string& file)
-{
-  emit edit_file_signal (QString::fromStdString (file));
+  bool octave_qt_link::do_edit_file (const std::string& file)
+  {
+    emit edit_file_signal (QString::fromStdString (file));
 
-  return true;
-}
+    return true;
+  }
 
-bool
-octave_qt_link::do_prompt_new_edit_file (const std::string& file)
-{
-  QSettings *settings = resource_manager::get_settings ();
+  bool octave_qt_link::do_prompt_new_edit_file (const std::string& file)
+  {
+    QSettings *settings = resource_manager::get_settings ();
 
-  if (! settings || settings->value ("editor/create_new_file",false).toBool ())
-    return true;
+    if (! settings || settings->value ("editor/create_new_file",false).toBool ())
+      return true;
 
-  QFileInfo file_info (QString::fromStdString (file));
-  QStringList btn;
-  QStringList role;
-  role << "YesRole" << "RejectRole";
-  btn << tr ("Create") << tr ("Cancel");
+    QFileInfo file_info (QString::fromStdString (file));
+    QStringList btn;
+    QStringList role;
+    role << "YesRole" << "RejectRole";
+    btn << tr ("Create") << tr ("Cancel");
 
-  // Lock mutex before signaling.
-  uiwidget_creator.lock ();
+    // Lock mutex before signaling.
+    uiwidget_creator.lock ();
 
-  uiwidget_creator.signal_dialog (
-    tr ("File\n%1\ndoes not exist. Do you want to create it?").
-    arg (QDir::currentPath () + QDir::separator ()
-         + QString::fromStdString (file)),
-    tr ("Octave Editor"), "quest", btn, tr ("Create"), role);
+    uiwidget_creator.signal_dialog (
+                                    tr ("File\n%1\ndoes not exist. Do you want to create it?").
+                                    arg (QDir::currentPath () + QDir::separator ()
+                                         + QString::fromStdString (file)),
+                                    tr ("Octave Editor"), "quest", btn, tr ("Create"), role);
 
-  // Wait while the user is responding to message box.
-  uiwidget_creator.wait ();
+    // Wait while the user is responding to message box.
+    uiwidget_creator.wait ();
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // The GUI has sent a signal and the thread has been awakened.
 
-  QString answer = uiwidget_creator.get_dialog_button ();
+    QString answer = uiwidget_creator.get_dialog_button ();
 
-  uiwidget_creator.unlock ();
+    uiwidget_creator.unlock ();
 
-  return (answer == tr ("Create"));
-}
+    return (answer == tr ("Create"));
+  }
 
-int
-octave_qt_link::do_message_dialog (const std::string& dlg,
-                                   const std::string& msg,
-                                   const std::string& title)
-{
-  // Lock mutex before signaling.
-  uiwidget_creator.lock ();
+  int octave_qt_link::do_message_dialog (const std::string& dlg,
+                                         const std::string& msg,
+                                         const std::string& title)
+  {
+    // Lock mutex before signaling.
+    uiwidget_creator.lock ();
 
-  uiwidget_creator.signal_dialog (QString::fromStdString (msg),
-                                  QString::fromStdString (title),
-                                  QString::fromStdString (dlg),
-                                  QStringList (), QString (),
-                                  QStringList ());
+    uiwidget_creator.signal_dialog (QString::fromStdString (msg),
+                                    QString::fromStdString (title),
+                                    QString::fromStdString (dlg),
+                                    QStringList (), QString (),
+                                    QStringList ());
 
-  // Wait while the user is responding to message box.
-  uiwidget_creator.wait ();
+    // Wait while the user is responding to message box.
+    uiwidget_creator.wait ();
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // The GUI has sent a signal and the thread has been awakened.
 
-  int answer = uiwidget_creator.get_dialog_result ();
+    int answer = uiwidget_creator.get_dialog_result ();
 
-  uiwidget_creator.unlock ();
+    uiwidget_creator.unlock ();
 
-  return answer;
-}
+    return answer;
+  }
 
-std::string
-octave_qt_link::do_question_dialog (const std::string& msg,
-                                    const std::string& title,
-                                    const std::string& btn1,
-                                    const std::string& btn2,
-                                    const std::string& btn3,
-                                    const std::string& btndef)
-{
-  QStringList btn;
-  QStringList role;
-  // Must use ResetRole which is left-aligned for all OS and WM.
-  role << "ResetRole" << "ResetRole" << "ResetRole";
-  btn << QString::fromStdString (btn1);
-  if (btn2 == "")
-    role.removeAt (0);
-  else
-    btn << QString::fromStdString (btn2);
-  btn << QString::fromStdString (btn3);
+  std::string octave_qt_link::do_question_dialog (const std::string& msg,
+                                                  const std::string& title,
+                                                  const std::string& btn1,
+                                                  const std::string& btn2,
+                                                  const std::string& btn3,
+                                                  const std::string& btndef)
+  {
+    QStringList btn;
+    QStringList role;
+    // Must use ResetRole which is left-aligned for all OS and WM.
+    role << "ResetRole" << "ResetRole" << "ResetRole";
+    btn << QString::fromStdString (btn1);
+    if (btn2 == "")
+      role.removeAt (0);
+    else
+      btn << QString::fromStdString (btn2);
+    btn << QString::fromStdString (btn3);
 
-  // Lock mutex before signaling.
-  uiwidget_creator.lock ();
+    // Lock mutex before signaling.
+    uiwidget_creator.lock ();
 
-  uiwidget_creator.signal_dialog (QString::fromStdString (msg),
-                                  QString::fromStdString (title),
-                                  "quest",
-                                  btn,
-                                  QString::fromStdString (btndef),
-                                  role);
+    uiwidget_creator.signal_dialog (QString::fromStdString (msg),
+                                    QString::fromStdString (title),
+                                    "quest",
+                                    btn,
+                                    QString::fromStdString (btndef),
+                                    role);
 
-  // Wait while the user is responding to message box.
-  uiwidget_creator.wait ();
+    // Wait while the user is responding to message box.
+    uiwidget_creator.wait ();
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // The GUI has sent a signal and the thread has been awakened.
 
-  std::string answer = uiwidget_creator.get_dialog_button ().toStdString ();
+    std::string answer = uiwidget_creator.get_dialog_button ().toStdString ();
 
-  uiwidget_creator.unlock ();
+    uiwidget_creator.unlock ();
 
-  return answer;
-}
+    return answer;
+  }
 
-static QStringList
-make_qstring_list (const std::list<std::string>& lst)
-{
-  QStringList retval;
+  static QStringList
+  make_qstring_list (const std::list<std::string>& lst)
+  {
+    QStringList retval;
 
-  for (std::list<std::string>::const_iterator it = lst.begin ();
-       it != lst.end (); it++)
-    {
-      retval.append (QString::fromStdString (*it));
-    }
+    for (std::list<std::string>::const_iterator it = lst.begin ();
+         it != lst.end (); it++)
+      {
+        retval.append (QString::fromStdString (*it));
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-static QStringList
-make_filter_list (const octave_link::filter_list& lst)
-{
-  QStringList retval;
+  static QStringList
+  make_filter_list (const octave_link::filter_list& lst)
+  {
+    QStringList retval;
 
-  // We have pairs of data, first being the list of extensions
-  // exta;exb;extc etc second the name to use as filter name
-  // (optional).  Qt wants a list of filters in the format of
-  // 'FilterName (space separated exts)'.
+    // We have pairs of data, first being the list of extensions
+    // exta;exb;extc etc second the name to use as filter name
+    // (optional).  Qt wants a list of filters in the format of
+    // 'FilterName (space separated exts)'.
 
-  for (octave_link::filter_list::const_iterator it = lst.begin ();
-       it != lst.end (); it++)
-    {
-      QString ext = QString::fromStdString (it->first);
-      QString name = QString::fromStdString (it->second);
+    for (octave_link::filter_list::const_iterator it = lst.begin ();
+         it != lst.end (); it++)
+      {
+        QString ext = QString::fromStdString (it->first);
+        QString name = QString::fromStdString (it->second);
 
-      // Strip out extensions from name and replace ';' with spaces in
-      // list.
+        // Strip out extensions from name and replace ';' with spaces in
+        // list.
 
-      name.replace (QRegExp ("\\(.*\\)"), "");
-      ext.replace (";", " ");
+        name.replace (QRegExp ("\\(.*\\)"), "");
+        ext.replace (";", " ");
 
-      if (name.isEmpty ())
-        {
-          // No name field.  Build one from the extensions.
-          name = ext.toUpper () + " Files";
-        }
+        if (name.isEmpty ())
+          {
+            // No name field.  Build one from the extensions.
+            name = ext.toUpper () + " Files";
+          }
 
-      retval.append (name + " (" + ext + ')');
-    }
+        retval.append (name + " (" + ext + ')');
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-std::pair<std::list<int>, int>
-octave_qt_link::do_list_dialog (const std::list<std::string>& list,
-                                const std::string& mode,
-                                int width, int height,
-                                const std::list<int>& initial,
-                                const std::string& name,
-                                const std::list<std::string>& prompt,
-                                const std::string& ok_string,
-                                const std::string& cancel_string)
-{
-  // Lock mutex before signaling.
-  uiwidget_creator.lock ();
+  std::pair<std::list<int>, int>
+  octave_qt_link::do_list_dialog (const std::list<std::string>& list,
+                                  const std::string& mode,
+                                  int width, int height,
+                                  const std::list<int>& initial,
+                                  const std::string& name,
+                                  const std::list<std::string>& prompt,
+                                  const std::string& ok_string,
+                                  const std::string& cancel_string)
+  {
+    // Lock mutex before signaling.
+    uiwidget_creator.lock ();
 
-  uiwidget_creator.signal_listview (make_qstring_list (list),
-                                    QString::fromStdString (mode),
-                                    width, height,
-                                    QList<int>::fromStdList (initial),
-                                    QString::fromStdString (name),
-                                    make_qstring_list (prompt),
-                                    QString::fromStdString (ok_string),
-                                    QString::fromStdString (cancel_string));
+    uiwidget_creator.signal_listview (make_qstring_list (list),
+                                      QString::fromStdString (mode),
+                                      width, height,
+                                      QList<int>::fromStdList (initial),
+                                      QString::fromStdString (name),
+                                      make_qstring_list (prompt),
+                                      QString::fromStdString (ok_string),
+                                      QString::fromStdString (cancel_string));
 
-  // Wait while the user is responding to message box.
-  uiwidget_creator.wait ();
+    // Wait while the user is responding to message box.
+    uiwidget_creator.wait ();
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // The GUI has sent a signal and the thread has been awakened.
 
-  const QIntList *selected = uiwidget_creator.get_list_index ();
-  int ok = uiwidget_creator.get_dialog_result ();
+    const QIntList *selected = uiwidget_creator.get_list_index ();
+    int ok = uiwidget_creator.get_dialog_result ();
 
-  uiwidget_creator.unlock ();
+    uiwidget_creator.unlock ();
 
-  return std::pair<std::list<int>, int> (selected->toStdList (), ok);
-}
+    return std::pair<std::list<int>, int> (selected->toStdList (), ok);
+  }
 
-std::list<std::string>
-octave_qt_link::do_input_dialog (const std::list<std::string>& prompt,
-                                 const std::string& title,
-                                 const std::list<float>& nr,
-                                 const std::list<float>& nc,
-                                 const std::list<std::string>& defaults)
-{
-  std::list<std::string> retval;
+  std::list<std::string>
+  octave_qt_link::do_input_dialog (const std::list<std::string>& prompt,
+                                   const std::string& title,
+                                   const std::list<float>& nr,
+                                   const std::list<float>& nc,
+                                   const std::list<std::string>& defaults)
+  {
+    std::list<std::string> retval;
 
-  // Lock mutex before signaling.
-  uiwidget_creator.lock ();
+    // Lock mutex before signaling.
+    uiwidget_creator.lock ();
 
-  uiwidget_creator.signal_inputlayout (make_qstring_list (prompt),
-                                       QString::fromStdString (title),
-                                       QFloatList::fromStdList (nr),
-                                       QFloatList::fromStdList (nc),
-                                       make_qstring_list (defaults));
+    uiwidget_creator.signal_inputlayout (make_qstring_list (prompt),
+                                         QString::fromStdString (title),
+                                         QFloatList::fromStdList (nr),
+                                         QFloatList::fromStdList (nc),
+                                         make_qstring_list (defaults));
 
-  // Wait while the user is responding to message box.
-  uiwidget_creator.wait ();
+    // Wait while the user is responding to message box.
+    uiwidget_creator.wait ();
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // The GUI has sent a signal and the thread has been awakened.
 
-  const QStringList *inputLine = uiwidget_creator.get_string_list ();
+    const QStringList *inputLine = uiwidget_creator.get_string_list ();
 
-  uiwidget_creator.unlock ();
+    uiwidget_creator.unlock ();
 
-  for (QStringList::const_iterator it = inputLine->begin ();
-       it != inputLine->end (); it++)
-    {
-      retval.push_back (it->toStdString ());
-    }
+    for (QStringList::const_iterator it = inputLine->begin ();
+         it != inputLine->end (); it++)
+      {
+        retval.push_back (it->toStdString ());
+      }
 
-  return retval;
-}
-
-std::list<std::string>
-octave_qt_link::do_file_dialog (const filter_list& filter,
-                                const std::string& title,
-                                const std::string& filename,
-                                const std::string& dirname,
-                                const std::string& multimode)
-{
-  std::list<std::string> retval;
+    return retval;
+  }
 
-  // Lock mutex before signaling.
-  uiwidget_creator.lock ();
+  std::list<std::string>
+  octave_qt_link::do_file_dialog (const filter_list& filter,
+                                  const std::string& title,
+                                  const std::string& filename,
+                                  const std::string& dirname,
+                                  const std::string& multimode)
+  {
+    std::list<std::string> retval;
 
-  uiwidget_creator.signal_filedialog (make_filter_list (filter),
-                                      QString::fromStdString (title),
-                                      QString::fromStdString (filename),
-                                      QString::fromStdString (dirname),
-                                      QString::fromStdString (multimode));
+    // Lock mutex before signaling.
+    uiwidget_creator.lock ();
 
-  // Wait while the user is responding to dialog.
-  uiwidget_creator.wait ();
+    uiwidget_creator.signal_filedialog (make_filter_list (filter),
+                                        QString::fromStdString (title),
+                                        QString::fromStdString (filename),
+                                        QString::fromStdString (dirname),
+                                        QString::fromStdString (multimode));
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // Wait while the user is responding to dialog.
+    uiwidget_creator.wait ();
 
-  // Add all the file dialog results to a string list.
-  const QStringList *inputLine = uiwidget_creator.get_string_list ();
+    // The GUI has sent a signal and the thread has been awakened.
+
+    // Add all the file dialog results to a string list.
+    const QStringList *inputLine = uiwidget_creator.get_string_list ();
 
-  for (QStringList::const_iterator it = inputLine->begin ();
-       it != inputLine->end (); it++)
-    retval.push_back (it->toStdString ());
+    for (QStringList::const_iterator it = inputLine->begin ();
+         it != inputLine->end (); it++)
+      retval.push_back (it->toStdString ());
 
-  retval.push_back (uiwidget_creator.get_dialog_path ()->toStdString ());
-  retval.push_back ((QString ("%1").arg (
-                       uiwidget_creator.get_dialog_result ())).toStdString ());
-
-  uiwidget_creator.unlock ();
+    retval.push_back (uiwidget_creator.get_dialog_path ()->toStdString ());
+    retval.push_back ((QString ("%1").arg (
+                                           uiwidget_creator.get_dialog_result ())).toStdString ());
 
-  return retval;
-}
+    uiwidget_creator.unlock ();
+
+    return retval;
+  }
 
-// Prompt to allow file to be run by setting cwd (or if addpath_option==true,
-// alternatively setting the path).
-// This uses a QMessageBox unlike other functions in this file,
-// because uiwidget_creator.waitcondition.wait hangs when called from
-// file_editor_tab::handle_context_menu_break_condition().  (FIXME: why hang?)
-int
-octave_qt_link::do_debug_cd_or_addpath_error (const std::string& file,
-                                              const std::string& dir,
-                                              bool addpath_option)
-{
-  int retval = -1;
+  // Prompt to allow file to be run by setting cwd (or if addpath_option==true,
+  // alternatively setting the path).
+  // This uses a QMessageBox unlike other functions in this file,
+  // because uiwidget_creator.waitcondition.wait hangs when called from
+  // file_editor_tab::handle_context_menu_break_condition().  (FIXME: why hang?)
+  int octave_qt_link::do_debug_cd_or_addpath_error (const std::string& file,
+                                                    const std::string& dir,
+                                                    bool addpath_option)
+  {
+    int retval = -1;
 
-  QString qdir = QString::fromStdString (dir);
-  QString qfile = QString::fromStdString (file);
-  QString msg
-    = (addpath_option
-       ? tr ("The file %1 does not exist in the load path.  To run or debug the function you are editing, you must either change to the directory %2 or add that directory to the load path.").arg (qfile).arg (qdir)
-       : tr ("The file %1 is shadowed by a file with the same name in the load path. To run or debug the function you are editing, change to the directory %2.").arg (qfile).arg (qdir));
+    QString qdir = QString::fromStdString (dir);
+    QString qfile = QString::fromStdString (file);
+    QString msg
+      = (addpath_option
+         ? tr ("The file %1 does not exist in the load path.  To run or debug the function you are editing, you must either change to the directory %2 or add that directory to the load path.").arg (qfile).arg (qdir)
+         : tr ("The file %1 is shadowed by a file with the same name in the load path. To run or debug the function you are editing, change to the directory %2.").arg (qfile).arg (qdir));
 
-  QString title = tr ("Change Directory or Add Directory to Load Path");
+    QString title = tr ("Change Directory or Add Directory to Load Path");
 
-  QString cd_txt = tr ("&Change Directory");
-  QString addpath_txt = tr ("&Add Directory to Load Path");
-  QString cancel_txt = tr ("Cancel");
+    QString cd_txt = tr ("&Change Directory");
+    QString addpath_txt = tr ("&Add Directory to Load Path");
+    QString cancel_txt = tr ("Cancel");
 
-  QStringList btn;
-  QStringList role;
-  btn << cd_txt;
-  role << "YesRole";
-  if (addpath_option)
-    {
-      btn << addpath_txt;
-      role << "AcceptRole";
-    }
-  btn << cancel_txt;
-  role << "RejectRole";
+    QStringList btn;
+    QStringList role;
+    btn << cd_txt;
+    role << "YesRole";
+    if (addpath_option)
+      {
+        btn << addpath_txt;
+        role << "AcceptRole";
+      }
+    btn << cancel_txt;
+    role << "RejectRole";
 
-  // Lock mutex before signaling.
-  uiwidget_creator.lock ();
+    // Lock mutex before signaling.
+    uiwidget_creator.lock ();
 
-  uiwidget_creator.signal_dialog (msg, title, "quest", btn, cancel_txt, role);
+    uiwidget_creator.signal_dialog (msg, title, "quest", btn, cancel_txt, role);
 
-  // Wait while the user is responding to message box.
-  uiwidget_creator.wait ();
+    // Wait while the user is responding to message box.
+    uiwidget_creator.wait ();
 
-  // The GUI has sent a signal and the thread has been awakened.
+    // The GUI has sent a signal and the thread has been awakened.
 
-  QString result = uiwidget_creator.get_dialog_button ();
-
-  uiwidget_creator.unlock ();
+    QString result = uiwidget_creator.get_dialog_button ();
 
-  if (result == cd_txt)
-    retval = 1;
-  else if (result == addpath_txt)
-    retval = 2;
+    uiwidget_creator.unlock ();
+
+    if (result == cd_txt)
+      retval = 1;
+    else if (result == addpath_txt)
+      retval = 2;
 
-  return retval;
-}
+    return retval;
+  }
 
-void
-octave_qt_link::do_change_directory (const std::string& dir)
-{
-  emit change_directory_signal (QString::fromStdString (dir));
-}
+  void octave_qt_link::do_change_directory (const std::string& dir)
+  {
+    emit change_directory_signal (QString::fromStdString (dir));
+  }
 
-void
-octave_qt_link::do_execute_command_in_terminal (const std::string& command)
-{
-  emit execute_command_in_terminal_signal (QString::fromStdString (command));
-}
+  void octave_qt_link::do_execute_command_in_terminal
+    (const std::string& command)
+  {
+    emit execute_command_in_terminal_signal (QString::fromStdString (command));
+  }
 
-void
-octave_qt_link::do_set_workspace (bool top_level, bool debug,
-                                  const octave::symbol_scope& scope,
-                                  bool update_variable_editor)
-{
-  if (! top_level && ! debug)
-    return;
+  void octave_qt_link::do_set_workspace (bool top_level, bool debug,
+                                         const octave::symbol_scope& scope,
+                                         bool update_variable_editor)
+  {
+    if (! top_level && ! debug)
+      return;
 
-  emit set_workspace_signal (top_level, debug, scope);
+    emit set_workspace_signal (top_level, debug, scope);
 
-  if (update_variable_editor)
-    emit refresh_variable_editor_signal ();
-}
+    if (update_variable_editor)
+      emit refresh_variable_editor_signal ();
+  }
 
-void
-octave_qt_link::do_clear_workspace (void)
-{
-  emit clear_workspace_signal ();
-}
+  void octave_qt_link::do_clear_workspace (void)
+  {
+    emit clear_workspace_signal ();
+  }
 
-void
-octave_qt_link::do_set_history (const string_vector& hist)
-{
-  QStringList qt_hist;
+  void octave_qt_link::do_set_history (const string_vector& hist)
+  {
+    QStringList qt_hist;
 
-  for (octave_idx_type i = 0; i < hist.numel (); i++)
-    qt_hist.append (QString::fromStdString (hist[i]));
+    for (octave_idx_type i = 0; i < hist.numel (); i++)
+      qt_hist.append (QString::fromStdString (hist[i]));
 
-  emit set_history_signal (qt_hist);
-}
+    emit set_history_signal (qt_hist);
+  }
 
-void
-octave_qt_link::do_append_history (const std::string& hist_entry)
-{
-  emit append_history_signal (QString::fromStdString (hist_entry));
-}
+  void octave_qt_link::do_append_history (const std::string& hist_entry)
+  {
+    emit append_history_signal (QString::fromStdString (hist_entry));
+  }
+
+  void octave_qt_link::do_clear_history (void)
+  {
+    emit clear_history_signal ();
+  }
 
-void
-octave_qt_link::do_clear_history (void)
-{
-  emit clear_history_signal ();
-}
+  void octave_qt_link::do_pre_input_event (void)
+  { }
 
-void
-octave_qt_link::do_pre_input_event (void)
-{ }
+  void octave_qt_link::do_post_input_event (void)
+  { }
 
-void
-octave_qt_link::do_post_input_event (void)
-{ }
+  void octave_qt_link::do_enter_debugger_event (const std::string& file,
+                                                int line)
+  {
+    do_insert_debugger_pointer (file, line);
 
-void
-octave_qt_link::do_enter_debugger_event (const std::string& file, int line)
-{
-  do_insert_debugger_pointer (file, line);
+    emit enter_debugger_signal ();
+  }
 
-  emit enter_debugger_signal ();
-}
+  void octave_qt_link::do_execute_in_debugger_event (const std::string& file,
+                                                     int line)
+  {
+    do_delete_debugger_pointer (file, line);
+  }
 
-void
-octave_qt_link::do_execute_in_debugger_event (const std::string& file, int line)
-{
-  do_delete_debugger_pointer (file, line);
-}
+  void octave_qt_link::do_exit_debugger_event (void)
+  {
+    emit exit_debugger_signal ();
+  }
 
-void
-octave_qt_link::do_exit_debugger_event (void)
-{
-  emit exit_debugger_signal ();
-}
+  // Display (if @insert true) or remove the appropriate symbol for a breakpoint
+  // in @file at @line with condition @cond.
+  void octave_qt_link::do_update_breakpoint (bool insert,
+                                             const std::string& file,
+                                             int line,
+                                             const std::string& cond)
+  {
+    emit update_breakpoint_marker_signal (insert, QString::fromStdString (file),
+                                          line, QString::fromStdString (cond));
+  }
 
-// Display (if @insert true) or remove the appropriate symbol for a breakpoint
-// in @file at @line with condition @cond.
-void
-octave_qt_link::do_update_breakpoint (bool insert,
-                                      const std::string& file, int line,
-                                      const std::string& cond)
-{
-  emit update_breakpoint_marker_signal (insert, QString::fromStdString (file),
-                                        line, QString::fromStdString (cond));
-}
+  void octave_qt_link::do_set_default_prompts (std::string& ps1,
+                                               std::string& ps2,
+                                               std::string& ps4)
+  {
+    if (m_app_context->start_gui_p ())
+      {
+        ps1 = ">> ";
+        ps2 = "";
+        ps4 = "";
+      }
+  }
+
+  bool octave_qt_link::file_in_path (const std::string& file,
+                                     const std::string& dir)
+  {
+
+    bool ok = false;
+    bool addpath_option = true;
+
+    std::string curr_dir = octave::sys::env::get_current_directory ();
 
-void
-octave_qt_link::do_set_default_prompts (std::string& ps1, std::string& ps2,
-                                        std::string& ps4)
-{
-  if (m_app_context->start_gui_p ())
-    {
-      ps1 = ">> ";
-      ps2 = "";
-      ps4 = "";
-    }
-}
+    if (same_file (curr_dir, dir))
+      ok = true;
+    else
+      {
+        octave::load_path& lp = octave::__get_load_path__ ("octave_qt_link::file_in_path");
 
-bool
-octave_qt_link::file_in_path (const std::string& file, const std::string& dir)
-{
+        bool dir_in_load_path = lp.contains_canonical (dir);
 
-  bool ok = false;
-  bool addpath_option = true;
+        // get base name, allowing "@class/method.m" (bug #41514)
+        std::string base_file = (file.length () > dir.length ())
+          ? file.substr (dir.length () + 1)
+          : octave::sys::env::base_pathname (file);
+
+        std::string lp_file = lp.find_file (base_file);
 
-  std::string curr_dir = octave::sys::env::get_current_directory ();
-
-  if (same_file (curr_dir, dir))
-    ok = true;
-  else
-    {
-      octave::load_path& lp = octave::__get_load_path__ ("octave_qt_link::file_in_path");
-
-      bool dir_in_load_path = lp.contains_canonical (dir);
+        if (dir_in_load_path)
+          {
+            if (same_file (lp_file, file))
+              ok = true;
+          }
+        else
+          {
+            // File directory is not in path.  Is the file in the path in
+            // the current directory?  If so, then changing the current
+            // directory will be needed.  Adding directory to path is
+            // not enough because the file in the current directory would
+            // still be found.
 
-      // get base name, allowing "@class/method.m" (bug #41514)
-      std::string base_file = (file.length () > dir.length ())
-                              ? file.substr (dir.length () + 1)
-                              : octave::sys::env::base_pathname (file);
+            if (same_file (lp_file, base_file))
+              {
+                if (same_file (curr_dir, dir))
+                  ok = true;
+                else
+                  addpath_option = false;
+              }
+          }
+      }
 
-      std::string lp_file = lp.find_file (base_file);
-
-      if (dir_in_load_path)
-        {
-          if (same_file (lp_file, file))
+    if (! ok)
+      {
+        int action = debug_cd_or_addpath_error (file, dir, addpath_option);
+        switch (action)
+          {
+          case 1:
+            Fcd (ovl (dir));
             ok = true;
-        }
-      else
-        {
-          // File directory is not in path.  Is the file in the path in
-          // the current directory?  If so, then changing the current
-          // directory will be needed.  Adding directory to path is
-          // not enough because the file in the current directory would
-          // still be found.
+            break;
 
-          if (same_file (lp_file, base_file))
+          case 2:
             {
-              if (same_file (curr_dir, dir))
-                ok = true;
-              else
-                addpath_option = false;
+              octave::load_path& lp = octave::__get_load_path__ ("octave_qt_link::file_in_path");
+
+              lp.prepend (dir);
+              ok = true;
             }
-        }
-    }
+            break;
 
-  if (! ok)
-    {
-      int action = debug_cd_or_addpath_error (file, dir, addpath_option);
-      switch (action)
-        {
-        case 1:
-          Fcd (ovl (dir));
-          ok = true;
-          break;
+          default:
+            break;
+          }
+      }
 
-        case 2:
-          {
-            octave::load_path& lp = octave::__get_load_path__ ("octave_qt_link::file_in_path");
+    return ok;
+  }
 
-            lp.prepend (dir);
-            ok = true;
-          }
-          break;
+  void octave_qt_link::do_show_preferences (void)
+  {
+    emit show_preferences_signal ();
+  }
 
-        default:
-          break;
-        }
-    }
+  void octave_qt_link::do_show_doc (const std::string& file)
+  {
+    emit show_doc_signal (QString::fromStdString (file));
+  }
 
-  return ok;
-}
+  void octave_qt_link::do_edit_variable (const std::string& expr,
+                                         const octave_value& val)
+  {
+    emit edit_variable_signal (QString::fromStdString (expr), val);
+  }
 
-void
-octave_qt_link::do_show_preferences (void)
-{
-  emit show_preferences_signal ();
-}
+  void octave_qt_link::do_insert_debugger_pointer (const std::string& file,
+                                                   int line)
+  {
+    emit insert_debugger_pointer_signal (QString::fromStdString (file), line);
+  }
 
-void
-octave_qt_link::do_show_doc (const std::string& file)
-{
-  emit show_doc_signal (QString::fromStdString (file));
+  void octave_qt_link::do_delete_debugger_pointer (const std::string& file,
+                                                   int line)
+  {
+    emit delete_debugger_pointer_signal (QString::fromStdString (file), line);
+  }
 }
-
-void
-octave_qt_link::do_edit_variable (const std::string& expr, const octave_value& val)
-{
-  emit edit_variable_signal (QString::fromStdString (expr), val);
-}
-
-void
-octave_qt_link::do_insert_debugger_pointer (const std::string& file, int line)
-{
-  emit insert_debugger_pointer_signal (QString::fromStdString (file), line);
-}
-
-void
-octave_qt_link::do_delete_debugger_pointer (const std::string& file, int line)
-{
-  emit delete_debugger_pointer_signal (QString::fromStdString (file), line);
-}
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -17,18 +17,18 @@ MERCHANTABILITY or FITNESS FOR A PARTICU
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <https://www.gnu.org/licenses/>.
 
 */
 
-#if ! defined (octave_octave_qt_link_h)
-#define octave_octave_qt_link_h 1
+#if ! defined (octave_qt_link_h)
+#define octave_qt_link_h 1
 
 #include <list>
 #include <string>
 
 #include <QList>
 #include <QObject>
 #include <QString>
 #include <QMutex>
@@ -39,170 +39,169 @@ along with Octave; see the file COPYING.
 
 // Defined for purposes of sending QList<int> as part of signal.
 typedef QList<int> QIntList;
 
 class octave_value;
 
 namespace octave
 {
-  class symbol_scope;
+
+  //! Provides threadsafe access to octave.
+  //! @author Jacob Dawid
+  //!
+  //! This class is a wrapper around octave and provides thread safety by
+  //! buffering access operations to octave and executing them in the
+  //! readline event hook, which lives in the octave thread.
+
+  class octave_qt_link : public QObject, public octave_link
+  {
+    Q_OBJECT
+
+  public:
+
+    octave_qt_link (QWidget *p, octave::gui_application *app_context);
+
+    // No copying!
+
+    octave_qt_link (const octave_qt_link&) = delete;
+
+    octave_qt_link& operator = (const octave_qt_link&) = delete;
+
+    ~octave_qt_link (void) = default;
+
+    bool do_confirm_shutdown (void);
+
+    bool do_copy_image_to_clipboard (const std::string& file);
+
+    bool do_edit_file (const std::string& file);
+    bool do_prompt_new_edit_file (const std::string& file);
+
+    int do_message_dialog (const std::string& dlg, const std::string& msg,
+                           const std::string& title);
+
+    std::string
+    do_question_dialog (const std::string& msg, const std::string& title,
+                        const std::string& btn1, const std::string& btn2,
+                        const std::string& btn3, const std::string& btndef);
+
+    std::pair<std::list<int>, int>
+    do_list_dialog (const std::list<std::string>& list,
+                    const std::string& mode,
+                    int width, int height,
+                    const std::list<int>& initial_value,
+                    const std::string& name,
+                    const std::list<std::string>& prompt,
+                    const std::string& ok_string,
+                    const std::string& cancel_string);
+
+    std::list<std::string>
+    do_input_dialog (const std::list<std::string>& prompt,
+                     const std::string& title,
+                     const std::list<float>& nr,
+                     const std::list<float>& nc,
+                     const std::list<std::string>& defaults);
+
+    std::list<std::string>
+    do_file_dialog (const filter_list& filter, const std::string& title,
+                    const std::string& filename, const std::string& pathname,
+                    const std::string& multimode);
+
+    int
+    do_debug_cd_or_addpath_error (const std::string& file,
+                                  const std::string& dir,
+                                  bool addpath_option);
+
+    void do_change_directory (const std::string& dir);
+
+    void do_execute_command_in_terminal (const std::string& command);
+
+    void do_set_workspace (bool top_level, bool debug,
+                           const octave::symbol_scope& scope,
+                           bool update_variable_editor);
+
+    void do_clear_workspace (void);
+
+    void do_set_history (const string_vector& hist);
+    void do_append_history (const std::string& hist_entry);
+    void do_clear_history (void);
+
+    void do_pre_input_event (void);
+    void do_post_input_event (void);
+
+    void do_enter_debugger_event (const std::string& file, int line);
+    void do_execute_in_debugger_event (const std::string& file, int line);
+    void do_exit_debugger_event (void);
+
+    void do_update_breakpoint (bool insert, const std::string& file, int line,
+                               const std::string& cond);
+
+    void do_set_default_prompts (std::string& ps1, std::string& ps2,
+                                 std::string& ps4);
+
+    static bool file_in_path (const std::string& file, const std::string& dir);
+
+    void do_show_preferences (void);
+
+    void do_show_doc (const std::string& file);
+
+    void do_edit_variable (const std::string& name, const octave_value& val);
+
+    void shutdown_confirmation (bool sd) { m_shutdown_confirm_result = sd; }
+
+    void lock (void) { m_mutex.lock (); }
+    void wait (void) { m_waitcondition.wait (&m_mutex); }
+    void unlock (void) { m_mutex.unlock (); }
+    void wake_all (void) { m_waitcondition.wakeAll (); }
+
+  private:
+
+    void do_insert_debugger_pointer (const std::string& file, int line);
+    void do_delete_debugger_pointer (const std::string& file, int line);
+
+    octave::gui_application *m_app_context;
+
+    bool m_shutdown_confirm_result;
+
+    QMutex m_mutex;
+    QWaitCondition m_waitcondition;
+
+  signals:
+
+    void copy_image_to_clipboard_signal (const QString& file, bool remove_file);
+
+    void edit_file_signal (const QString& file);
+
+    void change_directory_signal (const QString& dir);
+
+    void execute_command_in_terminal_signal (const QString& command);
+
+    void set_workspace_signal (bool top_level, bool debug,
+                               const octave::symbol_scope& scope);
+
+    void clear_workspace_signal (void);
+
+    void set_history_signal (const QStringList& hist);
+    void append_history_signal (const QString& hist_entry);
+    void clear_history_signal (void);
+
+    void enter_debugger_signal (void);
+    void exit_debugger_signal (void);
+
+    void update_breakpoint_marker_signal (bool insert, const QString& file,
+                                          int line, const QString& cond);
+
+    void insert_debugger_pointer_signal (const QString&, int);
+    void delete_debugger_pointer_signal (const QString&, int);
+
+    void show_preferences_signal (void);
+
+    void show_doc_signal (const QString& file);
+
+    void edit_variable_signal (const QString& name, const octave_value& val);
+
+    void refresh_variable_editor_signal (void);
+
+    void confirm_shutdown_signal (void);
+  };
 }
 
-//! Provides threadsafe access to octave.
-//! @author Jacob Dawid
-//!
-//! This class is a wrapper around octave and provides thread safety by
-//! buffering access operations to octave and executing them in the
-//! readline event hook, which lives in the octave thread.
-
-class octave_qt_link : public QObject, public octave_link
-{
-  Q_OBJECT
-
-public:
-
-  octave_qt_link (QWidget *p, octave::gui_application *app_context);
-
-  // No copying!
-
-  octave_qt_link (const octave_qt_link&) = delete;
-
-  octave_qt_link& operator = (const octave_qt_link&) = delete;
-
-  ~octave_qt_link (void) = default;
-
-  bool do_confirm_shutdown (void);
-
-  bool do_copy_image_to_clipboard (const std::string& file);
-
-  bool do_edit_file (const std::string& file);
-  bool do_prompt_new_edit_file (const std::string& file);
-
-  int do_message_dialog (const std::string& dlg, const std::string& msg,
-                         const std::string& title);
-
-  std::string
-  do_question_dialog (const std::string& msg, const std::string& title,
-                      const std::string& btn1, const std::string& btn2,
-                      const std::string& btn3, const std::string& btndef);
-
-  std::pair<std::list<int>, int>
-  do_list_dialog (const std::list<std::string>& list,
-                  const std::string& mode,
-                  int width, int height,
-                  const std::list<int>& initial_value,
-                  const std::string& name,
-                  const std::list<std::string>& prompt,
-                  const std::string& ok_string,
-                  const std::string& cancel_string);
-
-  std::list<std::string>
-  do_input_dialog (const std::list<std::string>& prompt,
-                   const std::string& title,
-                   const std::list<float>& nr,
-                   const std::list<float>& nc,
-                   const std::list<std::string>& defaults);
-
-  std::list<std::string>
-  do_file_dialog (const filter_list& filter, const std::string& title,
-                  const std::string& filename, const std::string& pathname,
-                  const std::string& multimode);
-
-  int
-  do_debug_cd_or_addpath_error (const std::string& file,
-                                const std::string& dir,
-                                bool addpath_option);
-
-  void do_change_directory (const std::string& dir);
-
-  void do_execute_command_in_terminal (const std::string& command);
-
-  void do_set_workspace (bool top_level, bool debug,
-                         const octave::symbol_scope& scope,
-                         bool update_variable_editor);
-
-  void do_clear_workspace (void);
-
-  void do_set_history (const string_vector& hist);
-  void do_append_history (const std::string& hist_entry);
-  void do_clear_history (void);
-
-  void do_pre_input_event (void);
-  void do_post_input_event (void);
-
-  void do_enter_debugger_event (const std::string& file, int line);
-  void do_execute_in_debugger_event (const std::string& file, int line);
-  void do_exit_debugger_event (void);
-
-  void do_update_breakpoint (bool insert, const std::string& file, int line,
-                             const std::string& cond);
-
-  void do_set_default_prompts (std::string& ps1, std::string& ps2,
-                               std::string& ps4);
-
-  static bool file_in_path (const std::string& file, const std::string& dir);
-
-  void do_show_preferences (void);
-
-  void do_show_doc (const std::string& file);
-
-  void do_edit_variable (const std::string& name, const octave_value& val);
-
-  void shutdown_confirmation (bool sd) { m_shutdown_confirm_result = sd; }
-
-  void lock (void) { m_mutex.lock (); }
-  void wait (void) { m_waitcondition.wait (&m_mutex); }
-  void unlock (void) { m_mutex.unlock (); }
-  void wake_all (void) { m_waitcondition.wakeAll (); }
-
-private:
-
-  void do_insert_debugger_pointer (const std::string& file, int line);
-  void do_delete_debugger_pointer (const std::string& file, int line);
-
-  octave::gui_application *m_app_context;
-
-  bool m_shutdown_confirm_result;
-
-  QMutex m_mutex;
-  QWaitCondition m_waitcondition;
-
-signals:
-
-  void copy_image_to_clipboard_signal (const QString& file, bool remove_file);
-
-  void edit_file_signal (const QString& file);
-
-  void change_directory_signal (const QString& dir);
-
-  void execute_command_in_terminal_signal (const QString& command);
-
-  void set_workspace_signal (bool top_level, bool debug,
-                             const octave::symbol_scope& scope);
-
-  void clear_workspace_signal (void);
-
-  void set_history_signal (const QStringList& hist);
-  void append_history_signal (const QString& hist_entry);
-  void clear_history_signal (void);
-
-  void enter_debugger_signal (void);
-  void exit_debugger_signal (void);
-
-  void update_breakpoint_marker_signal (bool insert, const QString& file,
-                                        int line, const QString& cond);
-
-  void insert_debugger_pointer_signal (const QString&, int);
-  void delete_debugger_pointer_signal (const QString&, int);
-
-  void show_preferences_signal (void);
-
-  void show_doc_signal (const QString& file);
-
-  void edit_variable_signal (const QString& name, const octave_value& val);
-
-  void refresh_variable_editor_signal (void);
-
-  void confirm_shutdown_signal (void);
-};
-
 #endif
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -35,345 +35,321 @@ along with Octave; see the file COPYING.
 #include <QClipboard>
 
 #include "file-ops.h"
 #include "help.h"
 #include "defaults.h"
 #include "resource-manager.h"
 #include "shortcut-manager.h"
 
-
-webinfo::webinfo (QWidget *p)
-  : QWidget (p)
+namespace octave
 {
-  _font_web = font ();
+  webinfo::webinfo (QWidget *p)
+    : QWidget (p)
+  {
+    _font_web = font ();
+
+    QVBoxLayout *vbox_layout = new QVBoxLayout ();
+    vbox_layout->setMargin (0);
+    setLayout (vbox_layout);
+
+    QHBoxLayout *hbox_layout = new QHBoxLayout ();
+    hbox_layout->setMargin (0);
+    hbox_layout->setSpacing (0);
+    vbox_layout->addLayout (hbox_layout);
 
-  QVBoxLayout *vbox_layout = new QVBoxLayout ();
-  vbox_layout->setMargin (0);
-  setLayout (vbox_layout);
+    _tab_bar = new octave::tab_bar (this);
+    _tab_bar->setSizePolicy (QSizePolicy::Preferred,QSizePolicy::Preferred);
+    _tab_bar->setExpanding (false);
+    _tab_bar->setTabsClosable (true);
+#if defined (HAVE_QTABWIDGET_SETMOVABLE)
+    _tab_bar->setMovable (true);
+#endif
+    hbox_layout->addWidget (_tab_bar);
+
+    _zoom_in_button = new QToolButton (this);
+    _zoom_in_button->setIcon (resource_manager::icon ("zoom-in"));
+    hbox_layout->addWidget (_zoom_in_button);
+
+    _zoom_out_button = new QToolButton (this);
+    _zoom_out_button->setIcon (resource_manager::icon ("zoom-out"));
+    hbox_layout->addWidget (_zoom_out_button);
+
+    _stacked_widget = new QStackedWidget (this);
+    vbox_layout->addWidget (_stacked_widget);
 
-  QHBoxLayout *hbox_layout = new QHBoxLayout ();
-  hbox_layout->setMargin (0);
-  hbox_layout->setSpacing (0);
-  vbox_layout->addLayout (hbox_layout);
+    hbox_layout = new QHBoxLayout ();
+    vbox_layout->addLayout (hbox_layout);
+
+    _search_line_edit = new QLineEdit (this);
+#if defined (HAVE_QLINEEDIT_SETPLACEHOLDERTEXT)
+    _search_line_edit->setPlaceholderText (
+                                           tr ("Type here and press \'Return\' to search"));
+#endif
+    hbox_layout->addWidget (_search_line_edit);
+
+    _search_check_box = new QCheckBox (tr ("Global search"));
+    hbox_layout->addWidget (_search_check_box);
 
-  _tab_bar = new tab_bar (this);
-  _tab_bar->setSizePolicy (QSizePolicy::Preferred,QSizePolicy::Preferred);
-  _tab_bar->setExpanding (false);
-  _tab_bar->setTabsClosable (true);
-#if defined (HAVE_QTABWIDGET_SETMOVABLE)
-  _tab_bar->setMovable (true);
-#endif
-  hbox_layout->addWidget (_tab_bar);
+    _close_action = add_action (_tab_bar->get_context_menu (),
+                                resource_manager::icon ("window-close",false), tr ("&Close"),
+                                SLOT (request_close_tab (bool)));
+    _close_others_action = add_action (_tab_bar->get_context_menu (),
+                                       resource_manager::icon ("window-close",false), tr ("Close &Other Tabs"),
+                                       SLOT (request_close_other_tabs (bool)));
+    _close_action->setEnabled (false);
+    _close_others_action->setEnabled (false);
+
+    connect (_tab_bar, SIGNAL (close_current_tab_signal (bool)),
+             this, SLOT (request_close_tab (bool)));
+    connect (_tab_bar, SIGNAL (currentChanged (int)), this,
+             SLOT (current_tab_changed (int)));
+    connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
+    connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
+    connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
+
+    resize (500, 300);
+  }
+
+  // Add an action to a menu or the widget itself
+  QAction * webinfo::add_action (QMenu *menu, const QIcon& icon,
+                                 const QString& text, const char *member)
+  {
+    QAction *a;
 
-  _zoom_in_button = new QToolButton (this);
-  _zoom_in_button->setIcon (resource_manager::icon ("zoom-in"));
-  hbox_layout->addWidget (_zoom_in_button);
+    if (menu)
+      a = menu->addAction (icon, text, this, member);
+    else
+      {
+        a = new QAction (this);
+        connect (a, SIGNAL (triggered ()), this, member);
+      }
+
+    addAction (a);  // important for shortcut context
+    a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
+
+    return a;
+  }
 
-  _zoom_out_button = new QToolButton (this);
-  _zoom_out_button->setIcon (resource_manager::icon ("zoom-out"));
-  hbox_layout->addWidget (_zoom_out_button);
+  // Slot for the close tab action
+  void webinfo::request_close_tab (bool)
+  {
+    close_tab (_tab_bar->currentIndex ());
+  }
 
-  _stacked_widget = new QStackedWidget (this);
-  vbox_layout->addWidget (_stacked_widget);
+  // Slot for the close other tabs action
+  void webinfo::request_close_other_tabs (bool)
+  {
+    int current = _tab_bar->currentIndex ();
+
+    for (int index = _tab_bar->count ()-1; index >= 0; index--)
+      {
+        if (current != index)
+          close_tab (index);
+      }
+  }
 
-  hbox_layout = new QHBoxLayout ();
-  vbox_layout->addLayout (hbox_layout);
+  void webinfo::load_info_file (const QString& info_file)
+  {
+    if (! set_info_path (info_file))
+      {
+        // Info file does not exist
+        _search_check_box->setEnabled (false);
+        _search_line_edit->setEnabled (false);
+
+        QTextBrowser *msg = addNewTab (tr ("Error"));
+        QString msg_text = QString (
+                                    "<html><body><br><br><center><b>%1</b></center></body></html>").
+          arg (tr ("The info file<p>%1<p>or compressed versions do not exist").
+               arg (info_file));
+        msg->setHtml (msg_text);
+      }
+  }
 
-  _search_line_edit = new QLineEdit (this);
-#if defined (HAVE_QLINEEDIT_SETPLACEHOLDERTEXT)
-  _search_line_edit->setPlaceholderText (
-    tr ("Type here and press \'Return\' to search"));
-#endif
-  hbox_layout->addWidget (_search_line_edit);
+  bool webinfo::set_info_path (const QString& info_path)
+  {
+    if (_parser.set_info_path (info_path))
+      {
+        load_node ("Top");
+        return true;
+      }
+    else
+      return false;
+  }
 
-  _search_check_box = new QCheckBox (tr ("Global search"));
-  hbox_layout->addWidget (_search_check_box);
+  void webinfo::load_node (const QString& node_name)
+  {
+    // no XREF in the tabs
+    QString tab_text = node_name;
+    tab_text.replace ("XREF", "");
+
+    //Check if node has been already opened.
+    for (int i = 0; i < _tab_bar->count (); i++)
+      {
+        if (tab_text == _tab_bar->tabText (i))
+          {
+            _tab_bar->setCurrentIndex (i);
+            return;
+          }
+      }
+
+    _text_browser = addNewTab (tab_text);
+    _text_browser->setHtml (_parser.node_as_html (node_name, "anchor"));
 
-  _close_action = add_action (_tab_bar->get_context_menu (),
-        resource_manager::icon ("window-close",false), tr ("&Close"),
-        SLOT (request_close_tab (bool)));
-  _close_others_action = add_action (_tab_bar->get_context_menu (),
-        resource_manager::icon ("window-close",false), tr ("Close &Other Tabs"),
-        SLOT (request_close_other_tabs (bool)));
-  _close_action->setEnabled (false);
-  _close_others_action->setEnabled (false);
+    if (_parser.is_reference (node_name))
+      _text_browser->scrollToAnchor ("anchor");
+  }
+
+  void webinfo::link_clicked (const QUrl& link)
+  {
+    QString node = link.toString ();
+    if (node.at (0) != '#')
+      load_node (node);
+    else
+      _text_browser->scrollToAnchor (node);
+  }
+
+  void webinfo::tab_state_changed (void)
+  {
+    _close_action->setEnabled (_tab_bar->count () > 1);
+    _close_others_action->setEnabled (_tab_bar->count () > 1);
+    setFocusProxy (_stacked_widget->currentWidget ());
+  }
+
+  void webinfo::current_tab_changed (int index)
+  {
+    QVariant tab_data = _tab_bar->tabData (index);
+    _text_browser = static_cast<QTextBrowser *> (tab_data.value<void*> ());
+
+    _stacked_widget->setCurrentIndex (_stacked_widget->indexOf (_text_browser));
+
+    if (_text_browser->font () != _font_web)
+      _text_browser->setFont (_font_web);
+
+    tab_state_changed ();
+  }
 
-  connect (_tab_bar, SIGNAL (close_current_tab_signal (bool)),
-           this, SLOT (request_close_tab (bool)));
-  connect (_tab_bar, SIGNAL (currentChanged (int)), this,
-           SLOT (current_tab_changed (int)));
-  connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
-  connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
-  connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
+  QTextBrowser * webinfo::addNewTab (const QString& name)
+  {
+    _text_browser = new QTextBrowser (this);
+    _text_browser->setOpenLinks (false);
+    _text_browser->show ();
+
+    connect (_text_browser, SIGNAL (anchorClicked (const QUrl&)), this,
+             SLOT (link_clicked (const QUrl&)));
+    disconnect (_tab_bar, SIGNAL (currentChanged (int)), this,
+                SLOT (current_tab_changed (int)));
+
+    int ns = _stacked_widget->addWidget (_text_browser);
+    _stacked_widget->setCurrentIndex (ns);
+
+    int nt = _tab_bar->addTab (name);
+    _tab_bar->setCurrentIndex (nt);
+    QVariant tab_data;
+    tab_data.setValue (static_cast<void *> (_text_browser));
+    _tab_bar->setTabData (nt, tab_data);
 
-  resize (500, 300);
-}
+    connect (_tab_bar, SIGNAL (currentChanged (int)), this,
+             SLOT (current_tab_changed (int)));
+
+    tab_state_changed ();
+
+    if (_text_browser->font () != _font_web)
+      _text_browser->setFont (_font_web);
+
+    return _text_browser;
+  }
 
-// Add an action to a menu or the widget itself
-QAction*
-webinfo::add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                         const char *member)
-{
-  QAction *a;
+  void webinfo::close_tab (int index)
+  {
+    if (_tab_bar->count () > 1)
+      {
+        QVariant tab_data = _tab_bar->tabData (index);
+        QWidget *w = static_cast<QWidget *> (tab_data.value<void*> ());
+        _stacked_widget->removeWidget (w);
+        delete w;
+
+        _tab_bar->removeTab (index);
+      }
 
-  if (menu)
-    a = menu->addAction (icon, text, this, member);
-  else
-    {
-      a = new QAction (this);
-      connect (a, SIGNAL (triggered ()), this, member);
-    }
+    tab_state_changed ();
+  }
+
+  void webinfo::load_ref (const QString& ref_name)
+  {
+    // Will load "Top", if ref_name was not found.
+    load_node (_parser.find_reference (ref_name));
+
+    if (_text_browser)
+      _text_browser->setFocus ();
+  }
+
+  void webinfo::search (void)
+  {
+    if (_search_line_edit->text ().trimmed ().isEmpty ())
+      return;   // do nothing if search field is empty or only has whitespaces
 
-  addAction (a);  // important for shortcut context
-  a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
+    if (_search_check_box->isChecked ())
+      {
+        // Global search
+        QString results = _parser.global_search (_search_line_edit->text (), 5);
+        _text_browser=addNewTab ("Results for: " + _search_line_edit->text ());
+        _text_browser->setHtml (results);
+      }
+    else
+      {
+        // Local search
+        _text_browser->find (_search_line_edit->text ());
+      }
+  }
 
-  return a;
-}
+  void webinfo::zoom_in (void)
+  {
+    _font_web.setPointSize (_font_web.pointSize () + 1);
+    _text_browser->setFont (_font_web);
+  }
 
-// Slot for the close tab action
-void
-webinfo::request_close_tab (bool)
-{
-  close_tab (_tab_bar->currentIndex ());
-}
+  void webinfo::zoom_out (void)
+  {
+    _font_web.setPointSize (_font_web.pointSize () - 1);
+    _text_browser->setFont (_font_web);
+  }
+
+  void webinfo::copyClipboard (void)
+  {
+    if (_search_line_edit->hasFocus () && _search_line_edit->hasSelectedText ())
+      {
+        QClipboard *clipboard = QApplication::clipboard ();
+
+        clipboard->setText (_search_line_edit->selectedText ());
+      }
+
+    if (_text_browser->hasFocus ())
+      _text_browser->copy ();
+  }
 
-// Slot for the close other tabs action
-void
-webinfo::request_close_other_tabs (bool)
-{
-  int current = _tab_bar->currentIndex ();
+  void webinfo::selectAll (void)
+  {
+    if (_search_line_edit->hasFocus ())
+      _search_line_edit->selectAll ();
+
+    if (_text_browser->hasFocus ())
+      _text_browser->selectAll ();
+  }
 
-  for (int index = _tab_bar->count ()-1; index >= 0; index--)
+  void webinfo::pasteClipboard (void)
   {
-    if (current != index)
-      close_tab (index);
+    if (_search_line_edit->hasFocus ())
+      {
+        QClipboard *clipboard = QApplication::clipboard ();
+        QString str = clipboard->text ();
+        if (str.length () > 0)
+          _search_line_edit->insert (str);
+      }
+  }
+
+  void webinfo::notice_settings (const QSettings *)
+  {
+    shortcut_manager::set_shortcut (_close_action, "editor_file:close");
+    shortcut_manager::set_shortcut (_close_others_action, "editor_file:close_other");
   }
 }
 
-void
-webinfo::load_info_file (const QString& info_file)
-{
-  if (! set_info_path (info_file))
-    {
-      // Info file does not exist
-      _search_check_box->setEnabled (false);
-      _search_line_edit->setEnabled (false);
-
-      QTextBrowser *msg = addNewTab (tr ("Error"));
-      QString msg_text = QString (
-          "<html><body><br><br><center><b>%1</b></center></body></html>").
-          arg (tr ("The info file<p>%1<p>or compressed versions do not exist").
-          arg (info_file));
-      msg->setHtml (msg_text);
-    }
-}
-
-bool
-webinfo::set_info_path (const QString& info_path)
-{
-  if (_parser.set_info_path (info_path))
-    {
-      load_node ("Top");
-      return true;
-    }
-  else
-    return false;
-}
-
-void
-webinfo::load_node (const QString& node_name)
-{
-  // no XREF in the tabs
-  QString tab_text = node_name;
-  tab_text.replace ("XREF", "");
-
-  //Check if node has been already opened.
-  for (int i = 0; i < _tab_bar->count (); i++)
-    {
-      if (tab_text == _tab_bar->tabText (i))
-        {
-          _tab_bar->setCurrentIndex (i);
-          return;
-        }
-    }
-
-  _text_browser = addNewTab (tab_text);
-  _text_browser->setHtml (_parser.node_as_html (node_name, "anchor"));
-
-  if (_parser.is_reference (node_name))
-    _text_browser->scrollToAnchor ("anchor");
-}
-
-void
-webinfo::link_clicked (const QUrl & link)
-{
-  QString node = link.toString ();
-  if (node.at (0) != '#')
-    load_node (node);
-  else
-    _text_browser->scrollToAnchor (node);
-}
-
-void
-webinfo::tab_state_changed ()
-{
-  _close_action->setEnabled (_tab_bar->count () > 1);
-  _close_others_action->setEnabled (_tab_bar->count () > 1);
-  setFocusProxy (_stacked_widget->currentWidget ());
-}
-
-void
-webinfo::current_tab_changed (int index)
-{
-  QVariant tab_data = _tab_bar->tabData (index);
-  _text_browser = static_cast<QTextBrowser *> (tab_data.value<void*> ());
-
-  _stacked_widget->setCurrentIndex (_stacked_widget->indexOf (_text_browser));
-
-  if (_text_browser->font () != _font_web)
-    {
-      _text_browser->setFont (_font_web);
-    }
-
-  tab_state_changed ();
-}
-
-QTextBrowser *
-webinfo::addNewTab (const QString& name)
-{
-  _text_browser = new QTextBrowser (this);
-  _text_browser->setOpenLinks (false);
-  _text_browser->show ();
-
-  connect (_text_browser, SIGNAL (anchorClicked (const QUrl &)), this,
-           SLOT (link_clicked (const QUrl &)));
-  disconnect (_tab_bar, SIGNAL (currentChanged (int)), this,
-              SLOT (current_tab_changed (int)));
-
-  int ns = _stacked_widget->addWidget (_text_browser);
-  _stacked_widget->setCurrentIndex (ns);
-
-  int nt = _tab_bar->addTab (name);
-  _tab_bar->setCurrentIndex (nt);
-  QVariant tab_data;
-  tab_data.setValue (static_cast<void *> (_text_browser));
-  _tab_bar->setTabData (nt, tab_data);
-
-  connect (_tab_bar, SIGNAL (currentChanged (int)), this,
-           SLOT (current_tab_changed (int)));
-
-  tab_state_changed ();
-
-  if (_text_browser->font () != _font_web)
-    {
-      _text_browser->setFont (_font_web);
-    }
-  return _text_browser;
-}
-
-void
-webinfo::close_tab (int index)
-{
-  if (_tab_bar->count () > 1)
-    {
-      QVariant tab_data = _tab_bar->tabData (index);
-      QWidget *w = static_cast<QWidget *> (tab_data.value<void*> ());
-      _stacked_widget->removeWidget (w);
-      delete w;
-
-      _tab_bar->removeTab (index);
-    }
-
-  tab_state_changed ();
-}
-
-void
-webinfo::load_ref (const QString& ref_name)
-{
-  // Will load "Top", if ref_name was not found.
-  load_node (_parser.find_reference (ref_name));
-
-  if (_text_browser)
-    _text_browser->setFocus ();
-}
-
-void
-webinfo::search ()
-{
-  if (_search_line_edit->text ().trimmed ().isEmpty ())
-    return;   // do nothing if search field is empty or only has whitespaces
-
-  if (_search_check_box->isChecked ())
-    {
-      // Global search
-      QString results = _parser.global_search (_search_line_edit->text (), 5);
-      _text_browser=addNewTab ("Results for: " + _search_line_edit->text ());
-      _text_browser->setHtml (results);
-    }
-  else
-    {
-      // Local search
-      _text_browser->find (_search_line_edit->text ());
-    }
-}
-
-void
-webinfo::zoom_in ()
-{
-  _font_web.setPointSize (_font_web.pointSize () + 1);
-  _text_browser->setFont (_font_web);
-}
-
-void
-webinfo::zoom_out ()
-{
-  _font_web.setPointSize (_font_web.pointSize () - 1);
-  _text_browser->setFont (_font_web);
-}
-
-void
-webinfo::copyClipboard ()
-{
-  if (_search_line_edit->hasFocus () && _search_line_edit->hasSelectedText ())
-    {
-      QClipboard *clipboard = QApplication::clipboard ();
-
-      clipboard->setText (_search_line_edit->selectedText ());
-    }
-  if (_text_browser->hasFocus ())
-    {
-      _text_browser->copy ();
-    }
-}
-
-void
-webinfo::selectAll ()
-{
-  if (_search_line_edit->hasFocus ())
-    {
-      _search_line_edit->selectAll ();
-    }
-  if (_text_browser->hasFocus ())
-    {
-      _text_browser->selectAll ();
-    }
-}
-
-void
-webinfo::pasteClipboard ()
-{
-  if (_search_line_edit->hasFocus ())
-    {
-      QClipboard *clipboard = QApplication::clipboard ();
-      QString str = clipboard->text ();
-      if (str.length () > 0)
-        _search_line_edit->insert (str);
-    }
-}
-
-void
-webinfo::notice_settings (const QSettings*)
-{
-  shortcut_manager::set_shortcut (_close_action, "editor_file:close");
-  shortcut_manager::set_shortcut (_close_others_action, "editor_file:close_other");
-}
-
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -37,64 +37,67 @@ along with Octave; see the file COPYING.
 #include <QToolButton>
 #include <QMenu>
 #include <QAction>
 #include <QMouseEvent>
 #include <QSettings>
 
 #include "tab-bar.h"
 
-// The webinfo class
-class webinfo : public QWidget
+namespace octave
 {
-  Q_OBJECT
+  // The webinfo class
+  class webinfo : public QWidget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  webinfo (QWidget *parent = nullptr);
+    webinfo (QWidget *parent = nullptr);
 
-  bool set_info_path (const QString& info_path);
-  void load_node (const QString& node_name);
-  void load_ref (const QString& ref_name);
-  void notice_settings (const QSettings *settings);
+    bool set_info_path (const QString& info_path);
+    void load_node (const QString& node_name);
+    void load_ref (const QString& ref_name);
+    void notice_settings (const QSettings *settings);
 
-  void load_info_file (const QString& info_file);
+    void load_info_file (const QString& info_file);
 
-public slots:
+  public slots:
 
-  void link_clicked (const QUrl& link);
-  void current_tab_changed (int index);
-  void close_tab (int index);
-  void search ();
-  void zoom_in ();
-  void zoom_out ();
+    void link_clicked (const QUrl& link);
+    void current_tab_changed (int index);
+    void close_tab (int index);
+    void search (void);
+    void zoom_in (void);
+    void zoom_out (void);
 
-  void copyClipboard ();
-  void pasteClipboard ();
-  void selectAll ();
+    void copyClipboard (void);
+    void pasteClipboard (void);
+    void selectAll (void);
 
-  void request_close_tab (bool);
-  void request_close_other_tabs (bool);
+    void request_close_tab (bool);
+    void request_close_other_tabs (bool);
 
-private:
+  private:
 
-  QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                        const char *member);
-  void tab_state_changed (void);
+    QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                          const char *member);
+    void tab_state_changed (void);
 
-  QTextBrowser        *_text_browser;
-  tab_bar             *_tab_bar;
-  QStackedWidget      *_stacked_widget;
-  QLineEdit           *_search_line_edit;
-  QCheckBox           *_search_check_box;
-  QToolButton         *_zoom_in_button;
-  QToolButton         *_zoom_out_button;
+    QTextBrowser *_text_browser;
+    tab_bar *_tab_bar;
+    QStackedWidget *_stacked_widget;
+    QLineEdit *_search_line_edit;
+    QCheckBox *_search_check_box;
+    QToolButton *_zoom_in_button;
+    QToolButton *_zoom_out_button;
 
-  texinfo_parser      _parser;
-  QFont               _font_web;
+    texinfo_parser _parser;
+    QFont _font_web;
 
-  QTextBrowser * addNewTab (const QString& name);
-  QAction *_close_action;
-  QAction *_close_others_action;
+    QTextBrowser * addNewTab (const QString& name);
+    QAction *_close_action;
+    QAction *_close_others_action;
 
-};
+  };
+}
 
 #endif
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -43,365 +43,348 @@ along with Octave; see the file COPYING.
 
 #include "defaults.h"
 
 #include "QTerminal.h"
 #include "workspace-model.h"
 #include "variable-editor.h"
 #include "resource-manager.h"
 
-resource_manager *resource_manager::instance = nullptr;
-
-static QString
-default_qt_settings_file (void)
+namespace octave
 {
-  std::string dsf = octave::sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
+  resource_manager *resource_manager::instance = nullptr;
 
-  if (dsf.empty ())
-    dsf = (octave::config::oct_etc_dir ()
-           + octave::sys::file_ops::dir_sep_str ()
-           + "default-qt-settings");
+  static QString
+  default_qt_settings_file (void)
+  {
+    std::string dsf = octave::sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
+
+    if (dsf.empty ())
+      dsf = (octave::config::oct_etc_dir ()
+             + octave::sys::file_ops::dir_sep_str ()
+             + "default-qt-settings");
 
-  return QString::fromStdString (dsf);
-}
+    return QString::fromStdString (dsf);
+  }
 
-resource_manager::resource_manager (void)
-  : m_settings_directory (), m_settings_file (), m_settings (nullptr),
-    m_default_settings (nullptr)
-{
+  resource_manager::resource_manager (void)
+    : m_settings_directory (), m_settings_file (), m_settings (nullptr),
+      m_default_settings (nullptr)
+  {
 #if defined (HAVE_QT4)
-  QString home_path
-    = QDesktopServices::storageLocation (QDesktopServices::HomeLocation);
+    QString home_path
+      = QDesktopServices::storageLocation (QDesktopServices::HomeLocation);
 #else
-  QString home_path
-    = QStandardPaths::writableLocation (QStandardPaths::HomeLocation);
+    QString home_path
+      = QStandardPaths::writableLocation (QStandardPaths::HomeLocation);
 #endif
 
-  m_settings_directory = home_path + "/.config/octave";
+    m_settings_directory = home_path + "/.config/octave";
 
-  m_settings_file = m_settings_directory + "/qt-settings";
+    m_settings_file = m_settings_directory + "/qt-settings";
 
-  m_default_settings = new QSettings (default_qt_settings_file (),
-                                    QSettings::IniFormat);
-}
+    m_default_settings = new QSettings (default_qt_settings_file (),
+                                        QSettings::IniFormat);
+  }
 
-resource_manager::~resource_manager (void)
-{
-  delete m_settings;
-  delete m_default_settings;
-}
+  resource_manager::~resource_manager (void)
+  {
+    delete m_settings;
+    delete m_default_settings;
+  }
 
-QString
-resource_manager::get_gui_translation_dir (void)
-{
-  // get environment variable for the locale dir (e.g. from run-octave)
-  std::string dldir = octave::sys::env::getenv ("OCTAVE_LOCALE_DIR");
-  if (dldir.empty ())
-    dldir = octave::config::oct_locale_dir (); // env-var empty, load the default location
-  return QString::fromStdString (dldir);
-}
+  QString resource_manager::get_gui_translation_dir (void)
+  {
+    // get environment variable for the locale dir (e.g. from run-octave)
+    std::string dldir = octave::sys::env::getenv ("OCTAVE_LOCALE_DIR");
+    if (dldir.empty ())
+      dldir = octave::config::oct_locale_dir (); // env-var empty, load the default location
+    return QString::fromStdString (dldir);
+  }
 
-void
-resource_manager::config_translators (QTranslator *qt_tr,
-                                      QTranslator *qsci_tr,
-                                      QTranslator *gui_tr)
-{
-  bool loaded;
+  void resource_manager::config_translators (QTranslator *qt_tr,
+                                             QTranslator *qsci_tr,
+                                             QTranslator *gui_tr)
+  {
+    bool loaded;
 
-  QString qt_trans_dir
-    = QLibraryInfo::location (QLibraryInfo::TranslationsPath);
+    QString qt_trans_dir
+      = QLibraryInfo::location (QLibraryInfo::TranslationsPath);
 
-  QString language = "SYSTEM";  // take system language per default
+    QString language = "SYSTEM";  // take system language per default
 
-  QSettings *settings = resource_manager::get_settings ();
+    QSettings *settings = resource_manager::get_settings ();
 
-  if (settings)
-    {
-      // get the locale from the settings if already available
-      language = settings->value ("language", "SYSTEM").toString ();
-    }
+    if (settings)
+      {
+        // get the locale from the settings if already available
+        language = settings->value ("language", "SYSTEM").toString ();
+      }
 
-  if (language == "SYSTEM")
-    language = QLocale::system ().name ();    // get system wide locale
+    if (language == "SYSTEM")
+      language = QLocale::system ().name ();    // get system wide locale
 
-  // load the translator file for qt strings
-  loaded = qt_tr->load ("qt_" + language, qt_trans_dir);
-
-  if (! loaded) // try lower case
-    qt_tr->load ("qt_" + language.toLower (), qt_trans_dir);
+    // load the translator file for qt strings
+    loaded = qt_tr->load ("qt_" + language, qt_trans_dir);
 
-  // load the translator file for qscintilla settings
-  loaded = qsci_tr->load ("qscintilla_" + language, qt_trans_dir);
+    if (! loaded) // try lower case
+      qt_tr->load ("qt_" + language.toLower (), qt_trans_dir);
 
-  if (! loaded) // try lower case
-    qsci_tr->load ("qscintilla_" + language.toLower (), qt_trans_dir);
+    // load the translator file for qscintilla settings
+    loaded = qsci_tr->load ("qscintilla_" + language, qt_trans_dir);
 
-  // load the translator file for gui strings
-  gui_tr->load (language, get_gui_translation_dir ());
-}
+    if (! loaded) // try lower case
+      qsci_tr->load ("qscintilla_" + language.toLower (), qt_trans_dir);
 
-QStringList
-resource_manager::storage_class_names (void)
-{
-  return workspace_model::storage_class_names ();
-}
+    // load the translator file for gui strings
+    gui_tr->load (language, get_gui_translation_dir ());
+  }
 
-QList<QColor>
-resource_manager::storage_class_default_colors (void)
-{
-  return workspace_model::storage_class_default_colors ();
-}
+  QStringList resource_manager::storage_class_names (void)
+  {
+    return workspace_model::storage_class_names ();
+  }
 
-QStringList
-resource_manager::terminal_color_names (void)
-{
-  return QTerminal::color_names ();
-}
+  QList<QColor> resource_manager::storage_class_default_colors (void)
+  {
+    return workspace_model::storage_class_default_colors ();
+  }
+
+  QStringList resource_manager::terminal_color_names (void)
+  {
+    return QTerminal::color_names ();
+  }
 
-QList<QColor>
-resource_manager::terminal_default_colors (void)
-{
-  return QTerminal::default_colors ();
-}
+  QList<QColor> resource_manager::terminal_default_colors (void)
+  {
+    return QTerminal::default_colors ();
+  }
 
-QList<QColor>
-resource_manager::varedit_default_colors(void)
-{
-  return variable_editor::default_colors ();
-}
+  QList<QColor> resource_manager::varedit_default_colors(void)
+  {
+    return variable_editor::default_colors ();
+  }
 
-QStringList
-resource_manager::varedit_color_names(void)
-{
-  return variable_editor::color_names ();
-}
+  QStringList resource_manager::varedit_color_names(void)
+  {
+    return variable_editor::color_names ();
+  }
 
-bool
-resource_manager::instance_ok (void)
-{
-  bool retval = true;
+  bool resource_manager::instance_ok (void)
+  {
+    bool retval = true;
 
-  if (! instance)
-    instance = new resource_manager ();
+    if (! instance)
+      instance = new resource_manager ();
 
-  if (! instance)
-    {
-      error ("unable to create resource_manager object!");
+    if (! instance)
+      {
+        error ("unable to create resource_manager object!");
 
-      retval = false;
-    }
-
-  return retval;
-}
+        retval = false;
+      }
 
-QSettings *
-resource_manager::do_get_settings (void) const
-{
-  return m_settings;
-}
+    return retval;
+  }
+
+  QSettings * resource_manager::do_get_settings (void) const
+  {
+    return m_settings;
+  }
 
-QSettings *
-resource_manager::do_get_default_settings (void) const
-{
-  return m_default_settings;
-}
+  QSettings * resource_manager::do_get_default_settings (void) const
+  {
+    return m_default_settings;
+  }
 
-QString
-resource_manager::do_get_settings_directory (void)
-{
-  return m_settings_directory;
-}
+  QString resource_manager::do_get_settings_directory (void)
+  {
+    return m_settings_directory;
+  }
 
-QString
-resource_manager::do_get_settings_file (void)
-{
-  return m_settings_file;
-}
+  QString resource_manager::do_get_settings_file (void)
+  {
+    return m_settings_file;
+  }
 
-void
-resource_manager::do_reload_settings (void)
-{
-  if (! QFile::exists (m_settings_file))
-    {
-      QDir ("/").mkpath (m_settings_directory);
-      QFile qt_settings (default_qt_settings_file ());
+  void resource_manager::do_reload_settings (void)
+  {
+    if (! QFile::exists (m_settings_file))
+      {
+        QDir ("/").mkpath (m_settings_directory);
+        QFile qt_settings (default_qt_settings_file ());
 
-      if (! qt_settings.open (QFile::ReadOnly))
-        return;
+        if (! qt_settings.open (QFile::ReadOnly))
+          return;
 
-      QTextStream in (&qt_settings);
-      QString settings_text = in.readAll ();
-      qt_settings.close ();
+        QTextStream in (&qt_settings);
+        QString settings_text = in.readAll ();
+        qt_settings.close ();
 
-      // Get the default monospaced font
+        // Get the default monospaced font
 #if defined (HAVE_QFONT_MONOSPACE)
-      QFont fixed_font;
-      fixed_font.setStyleHint (QFont::Monospace);
-      QString default_family = fixed_font.defaultFamily ();
+        QFont fixed_font;
+        fixed_font.setStyleHint (QFont::Monospace);
+        QString default_family = fixed_font.defaultFamily ();
 #elif defined (Q_WS_X11) || defined (Q_WS_WIN)
-      QString default_family = "Courier New";
+        QString default_family = "Courier New";
 #elif defined (Q_WS_MAC)
-      QString default_family = "Courier";
+        QString default_family = "Courier";
 #else
-      QString default_family = "courier";
+        QString default_family = "courier";
 #endif
 
-      // Get the default custom editor
+        // Get the default custom editor
 #if defined (Q_OS_WIN32)
-      QString custom_editor = "notepad++ -n%l %f";
+        QString custom_editor = "notepad++ -n%l %f";
 #else
-      QString custom_editor = "emacs +%l %f";
+        QString custom_editor = "emacs +%l %f";
 #endif
 
-      // Replace placeholders
-      settings_text.replace ("__default_custom_editor__", custom_editor);
-      settings_text.replace ("__default_font__", default_family);
-      settings_text.replace ("__default_font_size__", "10");
+        // Replace placeholders
+        settings_text.replace ("__default_custom_editor__", custom_editor);
+        settings_text.replace ("__default_font__", default_family);
+        settings_text.replace ("__default_font_size__", "10");
 
-      QFile user_settings (m_settings_file);
+        QFile user_settings (m_settings_file);
 
-      if (! user_settings.open (QIODevice::WriteOnly))
-        return;
+        if (! user_settings.open (QIODevice::WriteOnly))
+          return;
 
-      QTextStream out (&user_settings);
+        QTextStream out (&user_settings);
 
-      out << settings_text;
+        out << settings_text;
 
-      user_settings.close ();
-    }
+        user_settings.close ();
+      }
 
-  do_set_settings (m_settings_file);
-}
+    do_set_settings (m_settings_file);
+  }
 
-void
-resource_manager::do_set_settings (const QString& file)
-{
-  delete m_settings;
-  m_settings = new QSettings (file, QSettings::IniFormat);
+  void resource_manager::do_set_settings (const QString& file)
+  {
+    delete m_settings;
+    m_settings = new QSettings (file, QSettings::IniFormat);
 
-  if (! (m_settings
-         && QFile::exists (m_settings->fileName ())
-         && m_settings->isWritable ()
-         && m_settings->status () == QSettings::NoError))
-    {
-      QString msg = QString (QT_TR_NOOP (
-        "The settings file\n%1\n"
-        "does not exist and can not be created.\n"
-        "Make sure you have read and write permissions to\n%2\n\n"
-        "Octave GUI must be closed now."));
-      QMessageBox::critical (nullptr, QString (QT_TR_NOOP ("Octave Critical Error")),
-          msg.arg (do_get_settings_file ()).arg (do_get_settings_directory ()));
-      exit (1);
-    }
-}
+    if (! (m_settings
+           && QFile::exists (m_settings->fileName ())
+           && m_settings->isWritable ()
+           && m_settings->status () == QSettings::NoError))
+      {
+        QString msg = QString (QT_TR_NOOP (
+                                           "The settings file\n%1\n"
+                                           "does not exist and can not be created.\n"
+                                           "Make sure you have read and write permissions to\n%2\n\n"
+                                           "Octave GUI must be closed now."));
+        QMessageBox::critical (nullptr, QString (QT_TR_NOOP ("Octave Critical Error")),
+                               msg.arg (do_get_settings_file ()).arg (do_get_settings_directory ()));
+        exit (1);
+      }
+  }
 
-bool
-resource_manager::do_update_settings_key (const QString& old_key,
-                                          const QString& new_key)
-{
-  if (m_settings->contains (old_key))
-    {
-      QVariant preference = m_settings->value (old_key);
-      m_settings->setValue (new_key, preference);
-      m_settings->remove (old_key);
-      return true;
-    }
+  bool resource_manager::do_update_settings_key (const QString& old_key,
+                                                 const QString& new_key)
+  {
+    if (m_settings->contains (old_key))
+      {
+        QVariant preference = m_settings->value (old_key);
+        m_settings->setValue (new_key, preference);
+        m_settings->remove (old_key);
+        return true;
+      }
 
-  return false;
-}
+    return false;
+  }
 
-bool
-resource_manager::do_is_first_run (void) const
-{
-  return ! QFile::exists (m_settings_file);
-}
+  bool resource_manager::do_is_first_run (void) const
+  {
+    return ! QFile::exists (m_settings_file);
+  }
 
-void
-resource_manager::do_update_network_settings (void)
-{
-  if (m_settings)
-    {
-      QNetworkProxy::ProxyType proxyType = QNetworkProxy::NoProxy;
+  void resource_manager::do_update_network_settings (void)
+  {
+    if (m_settings)
+      {
+        QNetworkProxy::ProxyType proxyType = QNetworkProxy::NoProxy;
 
-      if (m_settings->value ("useProxyServer",false).toBool ())
-        {
-          QString proxyTypeString = m_settings->value ("proxyType").toString ();
+        if (m_settings->value ("useProxyServer",false).toBool ())
+          {
+            QString proxyTypeString = m_settings->value ("proxyType").toString ();
 
-          if (proxyTypeString == "Socks5Proxy")
-            proxyType = QNetworkProxy::Socks5Proxy;
-          else if (proxyTypeString == "HttpProxy")
-            proxyType = QNetworkProxy::HttpProxy;
-        }
+            if (proxyTypeString == "Socks5Proxy")
+              proxyType = QNetworkProxy::Socks5Proxy;
+            else if (proxyTypeString == "HttpProxy")
+              proxyType = QNetworkProxy::HttpProxy;
+          }
 
-      QNetworkProxy proxy;
+        QNetworkProxy proxy;
 
-      proxy.setType (proxyType);
-      proxy.setHostName (m_settings->value ("proxyHostName").toString ());
-      proxy.setPort (m_settings->value ("proxyPort",80).toInt ());
-      proxy.setUser (m_settings->value ("proxyUserName").toString ());
-      proxy.setPassword (m_settings->value ("proxyPassword").toString ());
+        proxy.setType (proxyType);
+        proxy.setHostName (m_settings->value ("proxyHostName").toString ());
+        proxy.setPort (m_settings->value ("proxyPort",80).toInt ());
+        proxy.setUser (m_settings->value ("proxyUserName").toString ());
+        proxy.setPassword (m_settings->value ("proxyPassword").toString ());
 
-      QNetworkProxy::setApplicationProxy (proxy);
-    }
-  else
-    {
-      // FIXME: Is this an error?  If so, what should we do?
-    }
-}
+        QNetworkProxy::setApplicationProxy (proxy);
+      }
+    else
+      {
+        // FIXME: Is this an error?  If so, what should we do?
+      }
+  }
 
-QIcon
-resource_manager::do_icon (const QString& icon_name, bool fallback)
-{
-  if (fallback)
-    return QIcon::fromTheme (icon_name,
-                             QIcon (":/actions/icons/" + icon_name + ".png"));
-  else
-    return QIcon::fromTheme (icon_name);
-}
+  QIcon resource_manager::do_icon (const QString& icon_name, bool fallback)
+  {
+    if (fallback)
+      return QIcon::fromTheme (icon_name,
+                               QIcon (":/actions/icons/" + icon_name + ".png"));
+    else
+      return QIcon::fromTheme (icon_name);
+  }
 
-// initialize a given combo box with available text encodings
-void
-resource_manager::do_combo_encoding (QComboBox *combo, QString current)
-{
-  // get the codec name for each mib
-  QList<int> all_mibs = QTextCodec::availableMibs ();
-  QStringList all_codecs;
-  foreach (int mib, all_mibs)
-    {
-      QTextCodec *c = QTextCodec::codecForMib (mib);
-      all_codecs << c->name ().toUpper ();
-    }
-  all_codecs.removeDuplicates ();
-  qSort (all_codecs);
+  // initialize a given combo box with available text encodings
+  void resource_manager::do_combo_encoding (QComboBox *combo, QString current)
+  {
+    // get the codec name for each mib
+    QList<int> all_mibs = QTextCodec::availableMibs ();
+    QStringList all_codecs;
+    foreach (int mib, all_mibs)
+      {
+        QTextCodec *c = QTextCodec::codecForMib (mib);
+        all_codecs << c->name ().toUpper ();
+      }
+    all_codecs.removeDuplicates ();
+    qSort (all_codecs);
 
-  // the default encoding
+    // the default encoding
 #if defined (Q_OS_WIN32)
-  QString def_enc = "SYSTEM";
+    QString def_enc = "SYSTEM";
 #else
-  QString def_enc = "UTF-8";
+    QString def_enc = "UTF-8";
 #endif
 
-  // get the value from the settings file if no current encoding is given
-  QString enc = current;
-  if (enc.isEmpty ())
-    {
-      enc = m_settings->value ("editor/default_encoding",def_enc).toString ();
-      if (enc.isEmpty ())  // still empty?
-        enc = def_enc;     // take default
-    }
+    // get the value from the settings file if no current encoding is given
+    QString enc = current;
+    if (enc.isEmpty ())
+      {
+        enc = m_settings->value ("editor/default_encoding",def_enc).toString ();
+        if (enc.isEmpty ())  // still empty?
+          enc = def_enc;     // take default
+      }
 
-  // fill the combo box
-  foreach (QString c, all_codecs)
-    combo->addItem (c);
+    // fill the combo box
+    foreach (QString c, all_codecs)
+      combo->addItem (c);
 
-  // prepend the default item
-  combo->insertSeparator (0);
-  combo->insertItem (0, def_enc);
+    // prepend the default item
+    combo->insertSeparator (0);
+    combo->insertItem (0, def_enc);
 
-  // select the current/default item
-  int idx = combo->findText (enc);
-  if (idx >= 0)
-    combo->setCurrentIndex (idx);
-  else
-    combo->setCurrentIndex (0);
+    // select the current/default item
+    int idx = combo->findText (enc);
+    if (idx >= 0)
+      combo->setCurrentIndex (idx);
+    else
+      combo->setCurrentIndex (0);
 
-  combo->setMaxVisibleItems (12);
+    combo->setMaxVisibleItems (12);
+  }
 }
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -25,143 +25,151 @@ along with Octave; see the file COPYING.
 
 #include <QDesktopServices>
 #include <QIcon>
 #include <QComboBox>
 #include <QMap>
 #include <QSettings>
 #include <QTranslator>
 
-class resource_manager : public QObject
+namespace octave
 {
-  Q_OBJECT
-
-protected:
-
-public:
-
-  resource_manager (void);
-
-  // No copying!
-
-  resource_manager (const resource_manager&) = delete;
-
-  resource_manager& operator = (const resource_manager&) = delete;
-
-  ~resource_manager ();
-
-  static QSettings * get_settings (void)
-  {
-    return instance_ok () ? instance->do_get_settings () : nullptr;
-  }
-
-  static QIcon icon (const QString& icon_name, bool fallback = true)
-  {
-    if (instance_ok ())
-      return instance->do_icon (icon_name, fallback);
-
-    return QIcon ();
-  }
-
-  static QSettings * get_default_settings (void)
+  class resource_manager : public QObject
   {
-    return instance_ok () ? instance->do_get_default_settings () : nullptr;
-  }
+    Q_OBJECT
+
+  protected:
+
+    public:
+
+    resource_manager (void);
+
+    // No copying!
+
+    resource_manager (const resource_manager&) = delete;
+
+    resource_manager& operator = (const resource_manager&) = delete;
 
-  static QString get_settings_file (void)
-  {
-    return instance_ok () ? instance->do_get_settings_file () : QString ();
-  }
+    ~resource_manager ();
+
+    static QSettings * get_settings (void)
+    {
+      return instance_ok () ? instance->do_get_settings () : nullptr;
+    }
 
-  static void reload_settings (void)
-  {
-    if (instance_ok ())
-      instance->do_reload_settings ();
-  }
+    static QIcon icon (const QString& icon_name, bool fallback = true)
+    {
+      if (instance_ok ())
+        return instance->do_icon (icon_name, fallback);
+
+      return QIcon ();
+    }
 
-  static void set_settings (const QString& file)
-  {
-    if (instance_ok ())
-      instance->do_set_settings (file);
-  }
+    static QSettings * get_default_settings (void)
+    {
+      return instance_ok () ? instance->do_get_default_settings () : nullptr;
+    }
+
+    static QString get_settings_file (void)
+    {
+      return instance_ok () ? instance->do_get_settings_file () : QString ();
+    }
+
+    static void reload_settings (void)
+    {
+      if (instance_ok ())
+        instance->do_reload_settings ();
+    }
 
-  static bool update_settings_key (const QString& new_key,
-                                   const QString& old_key)
-  {
-    return instance_ok () ? instance->do_update_settings_key (new_key, old_key)
-                          : false;
-  }
+    static void set_settings (const QString& file)
+    {
+      if (instance_ok ())
+        instance->do_set_settings (file);
+    }
 
-  static void combo_encoding (QComboBox *combo, QString current = QString ())
-  {
-    if (instance_ok ())
-      instance->do_combo_encoding (combo, current);
-  }
+    static bool update_settings_key (const QString& new_key,
+                                     const QString& old_key)
+    {
+      return (instance_ok ()
+              ? instance->do_update_settings_key (new_key, old_key)
+              : false);
+    }
+
+    static void combo_encoding (QComboBox *combo, QString current = QString ())
+    {
+      if (instance_ok ())
+        instance->do_combo_encoding (combo, current);
+    }
+
+    static QString get_gui_translation_dir (void);
 
-  static QString get_gui_translation_dir (void);
+    static void config_translators (QTranslator*, QTranslator*, QTranslator*);
 
-  static void config_translators (QTranslator*, QTranslator*, QTranslator*);
+    static void update_network_settings (void)
+    {
+      if (instance_ok ())
+        instance->do_update_network_settings ();
+    }
 
-  static void update_network_settings (void)
-  {
-    if (instance_ok ())
-      instance->do_update_network_settings ();
-  }
+    static bool is_first_run (void)
+    {
+      return instance_ok () ? instance->do_is_first_run () : true;
+    }
 
-  static bool is_first_run (void)
-  {
-    return instance_ok () ? instance->do_is_first_run () : true;
-  }
+    static QString storage_class_chars (void) { return "afghip"; }
+    static QStringList storage_class_names (void);
+    static QList<QColor> storage_class_default_colors (void);
 
-  static QString storage_class_chars (void) { return "afghip"; }
-  static QStringList storage_class_names (void);
-  static QList<QColor> storage_class_default_colors (void);
+    static QString terminal_color_chars (void) { return "fbsc"; }
+    static QStringList terminal_color_names (void);
+    static QList<QColor> terminal_default_colors (void);
 
-  static QString terminal_color_chars (void) { return "fbsc"; }
-  static QStringList terminal_color_names (void);
-  static QList<QColor> terminal_default_colors (void);
+    static resource_manager *instance;
+
+  public slots:
 
-  static resource_manager *instance;
-
-public slots:
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
-  static void cleanup_instance (void) { delete instance; instance = nullptr; }
+    static QString varedit_color_chars (void) {return "fbsha"; }
+    static QStringList varedit_color_names (void);
+    static QList<QColor> varedit_default_colors (void);
 
-  static QString varedit_color_chars (void) {return "fbsha"; }
-  static QStringList varedit_color_names (void);
-  static QList<QColor> varedit_default_colors (void);
+  private:
+
+    static bool instance_ok (void);
 
-private:
+    QSettings * do_get_settings (void) const;
 
-  static bool instance_ok (void);
+    QSettings * do_get_default_settings (void) const;
 
-  QSettings * do_get_settings (void) const;
+    QString do_get_settings_directory (void);
 
-  QSettings * do_get_default_settings (void) const;
+    QString do_get_settings_file (void);
 
-  QString do_get_settings_directory (void);
+    void do_reload_settings (void);
 
-  QString do_get_settings_file (void);
+    void do_set_settings (const QString& file);
 
-  void do_reload_settings (void);
+    bool do_update_settings_key (const QString& new_key, const QString& old_key);
 
-  void do_set_settings (const QString& file);
+    bool do_is_first_run (void) const;
+
+    void do_update_network_settings (void);
 
-  bool do_update_settings_key (const QString& new_key, const QString& old_key);
+    QIcon do_icon (const QString& icon, bool fallback);
 
-  bool do_is_first_run (void) const;
+    void do_combo_encoding (QComboBox *combo, QString current);
 
-  void do_update_network_settings (void);
+    QString m_settings_directory;
 
-  QIcon do_icon (const QString& icon, bool fallback);
+    QString m_settings_file;
 
-  void do_combo_encoding (QComboBox *combo, QString current);
-
-  QString m_settings_directory;
+    QSettings *m_settings;
 
-  QString m_settings_file;
+    QSettings *m_default_settings;
+  };
+}
 
-  QSettings *m_settings;
-
-  QSettings *m_default_settings;
-};
+// FIXME: This is temporary and should be removed when all classes that
+// use the resource_manager class are also inside the octave namespace.
+using octave::resource_manager;
 
 #endif
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -37,765 +37,754 @@ along with Octave; see the file COPYING.
 #include <QHeaderView>
 #include <QAction>
 #include <QFileDialog>
 
 #include "error.h"
 #include "resource-manager.h"
 #include "shortcut-manager.h"
 
-// enter_shortcut:
-// class derived from QLineEdit for directly entering key sequences which
-
-enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
-{
-  m_direct_shortcut = true;      // the shortcut is directly entered
-}
-
-// new keyPressEvent
-void
-enter_shortcut::keyPressEvent (QKeyEvent *e)
+namespace octave
 {
-  if (! m_direct_shortcut)
-    {
-      QLineEdit::keyPressEvent (e);
-      return;
-    }
+  // enter_shortcut:
+  // class derived from QLineEdit for directly entering key sequences which
+
+  enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
+  {
+    m_direct_shortcut = true;      // the shortcut is directly entered
+  }
 
-  if (e->type () == QEvent::KeyPress)
-    {
-      int key = e->key ();
+  // new keyPressEvent
+  void enter_shortcut::keyPressEvent (QKeyEvent *e)
+  {
+    if (! m_direct_shortcut)
+      {
+        QLineEdit::keyPressEvent (e);
+        return;
+      }
 
-      if (key == Qt::Key_unknown || key == 0)
-        return;
+    if (e->type () == QEvent::KeyPress)
+      {
+        int key = e->key ();
 
-      Qt::KeyboardModifiers modifiers = e->modifiers ();
+        if (key == Qt::Key_unknown || key == 0)
+          return;
+
+        Qt::KeyboardModifiers modifiers = e->modifiers ();
 
-      if (modifiers & Qt::ShiftModifier)
-        key += Qt::SHIFT;
-      if (modifiers & Qt::ControlModifier)
-        key += Qt::CTRL;
-      if (modifiers & Qt::AltModifier)
-        key += Qt::ALT;
-      if (modifiers & Qt::MetaModifier)
-        key += Qt::META;
+        if (modifiers & Qt::ShiftModifier)
+          key += Qt::SHIFT;
+        if (modifiers & Qt::ControlModifier)
+          key += Qt::CTRL;
+        if (modifiers & Qt::AltModifier)
+          key += Qt::ALT;
+        if (modifiers & Qt::MetaModifier)
+          key += Qt::META;
 
-      setText (QKeySequence (key).toString ());
-    }
-}
+        setText (QKeySequence (key).toString ());
+      }
+  }
 
-// slot for checkbox whether the shortcut is directly entered or not
-void
-enter_shortcut::handle_direct_shortcut (int state)
-{
-  if (state)
-    m_direct_shortcut = true;  // the shortcut is directly entered
-  else
-    m_direct_shortcut = false; // the shortcut has to be written as text
-}
+  // slot for checkbox whether the shortcut is directly entered or not
+  void enter_shortcut::handle_direct_shortcut (int state)
+  {
+    if (state)
+      m_direct_shortcut = true;  // the shortcut is directly entered
+    else
+      m_direct_shortcut = false; // the shortcut has to be written as text
+  }
 
-shortcut_manager *shortcut_manager::instance = nullptr;
+  shortcut_manager *shortcut_manager::instance = nullptr;
 
-shortcut_manager::shortcut_manager (void)
-{
-  setObjectName ("Shortcut_Manager");
+  shortcut_manager::shortcut_manager (void)
+  {
+    setObjectName ("Shortcut_Manager");
 
-  // Mac: don't let Qt interpret CMD key ("Meta" in Qt terminology) as Ctrl
+    // Mac: don't let Qt interpret CMD key ("Meta" in Qt terminology) as Ctrl
 #if defined (Q_OS_MAC)
-  QCoreApplication::setAttribute (Qt::AA_MacDontSwapCtrlAndMeta, true);
+    QCoreApplication::setAttribute (Qt::AA_MacDontSwapCtrlAndMeta, true);
 #endif
 
-  m_settings = resource_manager::get_settings ();
-}
+    m_settings = resource_manager::get_settings ();
+  }
 
-void
-shortcut_manager::handle_double_clicked (QTreeWidgetItem *item, int col)
-{
-  if (col != 2)
-    return;
+  void shortcut_manager::handle_double_clicked (QTreeWidgetItem *item, int col)
+  {
+    if (col != 2)
+      return;
 
-  int i = m_item_index_hash[item];
-  if (i == 0)
-    return;  // top-level-item clicked
+    int i = m_item_index_hash[item];
+    if (i == 0)
+      return;  // top-level-item clicked
 
-  shortcut_dialog (i-1); // correct to index starting at 0
-}
+    shortcut_dialog (i-1); // correct to index starting at 0
+  }
 
-void
-shortcut_manager::shortcut_dialog_finished (int result)
-{
-  if (result == QDialog::Rejected)
-    return;
+  void shortcut_manager::shortcut_dialog_finished (int result)
+  {
+    if (result == QDialog::Rejected)
+      return;
 
-  // check for duplicate
-  int double_index = m_shortcut_hash[m_edit_actual->text ()] - 1;
+    // check for duplicate
+    int double_index = m_shortcut_hash[m_edit_actual->text ()] - 1;
 
-  if (double_index >= 0 && double_index != m_handled_index)
-    {
-      int ret = QMessageBox::warning (this, tr ("Double Shortcut"),
-                  tr ("The chosen shortcut\n  \"%1\"\n"
-                      "is already used for the action\n  \"%2\".\n"
-                      "Do you want to use the shortcut anyhow removing it "
-                      "from the previous action?")
-                     .arg (m_edit_actual->text ())
-                     .arg (m_sc.at (double_index).m_description),
-                  QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+    if (double_index >= 0 && double_index != m_handled_index)
+      {
+        int ret = QMessageBox::warning (this, tr ("Double Shortcut"),
+                                        tr ("The chosen shortcut\n  \"%1\"\n"
+                                            "is already used for the action\n  \"%2\".\n"
+                                            "Do you want to use the shortcut anyhow removing it "
+                                            "from the previous action?")
+                                        .arg (m_edit_actual->text ())
+                                        .arg (m_sc.at (double_index).m_description),
+                                        QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
 
-      if (ret == QMessageBox::Yes)
-        {
-          shortcut_t double_shortcut = m_sc.at (double_index);
-          double_shortcut.m_actual_sc = QKeySequence ();
-          m_sc.replace (double_index, double_shortcut);
-          m_index_item_hash[double_index]->setText (2, QString ());
-        }
-      else
-        return;
-    }
+        if (ret == QMessageBox::Yes)
+          {
+            shortcut_t double_shortcut = m_sc.at (double_index);
+            double_shortcut.m_actual_sc = QKeySequence ();
+            m_sc.replace (double_index, double_shortcut);
+            m_index_item_hash[double_index]->setText (2, QString ());
+          }
+        else
+          return;
+      }
 
-  shortcut_t shortcut = m_sc.at (m_handled_index);
-  if (! shortcut.m_actual_sc.isEmpty ())
-    m_shortcut_hash.remove (shortcut.m_actual_sc.toString ());
-  shortcut.m_actual_sc = m_edit_actual->text ();
-  m_sc.replace (m_handled_index, shortcut);
+    shortcut_t shortcut = m_sc.at (m_handled_index);
+    if (! shortcut.m_actual_sc.isEmpty ())
+      m_shortcut_hash.remove (shortcut.m_actual_sc.toString ());
+    shortcut.m_actual_sc = m_edit_actual->text ();
+    m_sc.replace (m_handled_index, shortcut);
 
-  m_index_item_hash[m_handled_index]->setText (2, shortcut.m_actual_sc.toString ());
+    m_index_item_hash[m_handled_index]->setText (2, shortcut.m_actual_sc.toString ());
 
-  if (! shortcut.m_actual_sc.isEmpty ())
-    m_shortcut_hash[shortcut.m_actual_sc.toString ()] = m_handled_index + 1;
-}
+    if (! shortcut.m_actual_sc.isEmpty ())
+      m_shortcut_hash[shortcut.m_actual_sc.toString ()] = m_handled_index + 1;
+  }
 
-void
-shortcut_manager::shortcut_dialog_set_default (void)
-{
-  m_edit_actual->setText (m_label_default->text ());
-}
+  void shortcut_manager::shortcut_dialog_set_default (void)
+  {
+    m_edit_actual->setText (m_label_default->text ());
+  }
 
-bool
-shortcut_manager::instance_ok (void)
-{
-  bool retval = true;
+  bool shortcut_manager::instance_ok (void)
+  {
+    bool retval = true;
 
-  if (! instance)
-    instance = new shortcut_manager ();
+    if (! instance)
+      instance = new shortcut_manager ();
 
-  if (! instance)
-    {
-      error ("unable to create shortcut_manager object!");
+    if (! instance)
+      {
+        error ("unable to create shortcut_manager object!");
 
-      retval = false;
-    }
+        retval = false;
+      }
 
-  return retval;
-}
+    return retval;
+  }
 
-void
-shortcut_manager::init (const QString& description, const QString& key,
-                        const QKeySequence& def_sc)
-{
-  QKeySequence actual
-    = QKeySequence (m_settings->value ("shortcuts/" + key, def_sc).toString ());
+  void shortcut_manager::init (const QString& description, const QString& key,
+                               const QKeySequence& def_sc)
+  {
+    QKeySequence actual
+      = QKeySequence (m_settings->value ("shortcuts/" + key, def_sc).toString ());
 
-  // append the new shortcut to the list
-  shortcut_t shortcut_info;
-  shortcut_info.m_description = description;
-  shortcut_info.m_settings_key = key;
-  shortcut_info.m_actual_sc = actual;
-  shortcut_info.m_default_sc = def_sc;
-  m_sc << shortcut_info;
+    // append the new shortcut to the list
+    shortcut_t shortcut_info;
+    shortcut_info.m_description = description;
+    shortcut_info.m_settings_key = key;
+    shortcut_info.m_actual_sc = actual;
+    shortcut_info.m_default_sc = def_sc;
+    m_sc << shortcut_info;
 
-  // insert shortcut in order check for duplicates later
-  if (! actual.isEmpty ())
-    m_shortcut_hash[actual.toString ()] = m_sc.count ();
-  m_action_hash[key] = m_sc.count ();
+    // insert shortcut in order check for duplicates later
+    if (! actual.isEmpty ())
+      m_shortcut_hash[actual.toString ()] = m_sc.count ();
+    m_action_hash[key] = m_sc.count ();
 
-  // check whether ctrl+d is used from main window, i.e. is a global shortcut
-  if (key.startsWith ("main_")
-      && actual == QKeySequence (Qt::ControlModifier+Qt::Key_D))
-    m_settings->setValue ("shortcuts/main_ctrld",true);
-}
+    // check whether ctrl+d is used from main window, i.e. is a global shortcut
+    if (key.startsWith ("main_")
+        && actual == QKeySequence (Qt::ControlModifier+Qt::Key_D))
+      m_settings->setValue ("shortcuts/main_ctrld",true);
+  }
 
-void
-shortcut_manager::do_init_data (void)
-{
-  Qt::KeyboardModifier ctrl;
-  int prefix;
+  void shortcut_manager::do_init_data (void)
+  {
+    Qt::KeyboardModifier ctrl;
+    int prefix;
 #if defined (Q_OS_MAC)
-  // Use CMD key as an equivalent of Ctrl key on other platforms
-  ctrl = Qt::MetaModifier;
-  // Some of octave default shortcuts on windows/linux are already defined
-  // as system wide shortcuts on Mac Os X (almost all Function keys).
-  // Prefix those with Option (Alt) modifier to avoid conflicts.
-  prefix = Qt::AltModifier;
+    // Use CMD key as an equivalent of Ctrl key on other platforms
+    ctrl = Qt::MetaModifier;
+    // Some of octave default shortcuts on windows/linux are already defined
+    // as system wide shortcuts on Mac Os X (almost all Function keys).
+    // Prefix those with Option (Alt) modifier to avoid conflicts.
+    prefix = Qt::AltModifier;
 #else
-  ctrl = Qt::ControlModifier;
-  prefix = Qt::NoModifier;
+    ctrl = Qt::ControlModifier;
+    prefix = Qt::NoModifier;
 #endif
 
-  Qt::KeyboardModifiers ctrl_shift = ctrl | Qt::ShiftModifier;
-  Qt::KeyboardModifiers ctrl_alt = ctrl | Qt::AltModifier;
+    Qt::KeyboardModifiers ctrl_shift = ctrl | Qt::ShiftModifier;
+    Qt::KeyboardModifiers ctrl_alt = ctrl | Qt::AltModifier;
 
-  // actions of the main window
+    // actions of the main window
 
-  m_settings->setValue ("shortcuts/main_ctrld",false); // reset use fo ctrl-d
+    m_settings->setValue ("shortcuts/main_ctrld",false); // reset use fo ctrl-d
 
-  // file
-  init (tr ("New File"), "main_file:new_file", QKeySequence::New);
-  init (tr ("New Function"), "main_file:new_function",
-        QKeySequence (ctrl_shift + Qt::Key_N));
-  init (tr ("New Figure"), "main_file:new_figure", QKeySequence ());
-  init (tr ("Open File"), "main_file:open_file", QKeySequence::Open);
-  init (tr ("Load Workspace"), "main_file:load_workspace", QKeySequence ());
-  init (tr ("Save Workspace As"), "main_file:save_workspace", QKeySequence ());
-  init (tr ("Exit Octave"), "main_file:exit", QKeySequence::Quit);
+    // file
+    init (tr ("New File"), "main_file:new_file", QKeySequence::New);
+    init (tr ("New Function"), "main_file:new_function",
+          QKeySequence (ctrl_shift + Qt::Key_N));
+    init (tr ("New Figure"), "main_file:new_figure", QKeySequence ());
+    init (tr ("Open File"), "main_file:open_file", QKeySequence::Open);
+    init (tr ("Load Workspace"), "main_file:load_workspace", QKeySequence ());
+    init (tr ("Save Workspace As"), "main_file:save_workspace", QKeySequence ());
+    init (tr ("Exit Octave"), "main_file:exit", QKeySequence::Quit);
 
-  // edit
-  init (tr ("Copy"), "main_edit:copy", QKeySequence::Copy);
-  init (tr ("Paste"), "main_edit:paste", QKeySequence::Paste);
-  init (tr ("Undo"), "main_edit:undo", QKeySequence::Undo);
-  init (tr ("Select All"), "main_edit:select_all", QKeySequence::SelectAll);
-  init (tr ("Clear Clipboard"), "main_edit:clear_clipboard", QKeySequence ());
-  init (tr ("Find in Files"), "main_edit:find_in_files",
-        QKeySequence (ctrl_shift + Qt::Key_F));
-  init (tr ("Clear Command Window"), "main_edit:clear_command_window",
-        QKeySequence ());
-  init (tr ("Clear Command History"), "main_edit:clear_history",
-        QKeySequence ());
-  init (tr ("Clear Workspace"), "main_edit:clear_workspace", QKeySequence ());
-  init (tr ("Preferences"), "main_edit:preferences", QKeySequence ());
+    // edit
+    init (tr ("Copy"), "main_edit:copy", QKeySequence::Copy);
+    init (tr ("Paste"), "main_edit:paste", QKeySequence::Paste);
+    init (tr ("Undo"), "main_edit:undo", QKeySequence::Undo);
+    init (tr ("Select All"), "main_edit:select_all", QKeySequence::SelectAll);
+    init (tr ("Clear Clipboard"), "main_edit:clear_clipboard", QKeySequence ());
+    init (tr ("Find in Files"), "main_edit:find_in_files",
+          QKeySequence (ctrl_shift + Qt::Key_F));
+    init (tr ("Clear Command Window"), "main_edit:clear_command_window",
+          QKeySequence ());
+    init (tr ("Clear Command History"), "main_edit:clear_history",
+          QKeySequence ());
+    init (tr ("Clear Workspace"), "main_edit:clear_workspace", QKeySequence ());
+    init (tr ("Preferences"), "main_edit:preferences", QKeySequence ());
 
-  // debug
-  init (tr ("Step"), "main_debug:step_over",
-        QKeySequence (prefix + Qt::Key_F10));
-  init (tr ("Step Into"), "main_debug:step_into",
-        QKeySequence (prefix + Qt::Key_F11));
-  init (tr ("Step Out"), "main_debug:step_out",
-        QKeySequence (prefix + Qt::ShiftModifier + Qt::Key_F11));
-  init (tr ("Continue"), "main_debug:continue",
-        QKeySequence (prefix + Qt::Key_F5));
-  init (tr ("Quit Debug Mode"), "main_debug:quit",
-        QKeySequence (prefix + Qt::ShiftModifier + Qt::Key_F5));
+    // debug
+    init (tr ("Step"), "main_debug:step_over",
+          QKeySequence (prefix + Qt::Key_F10));
+    init (tr ("Step Into"), "main_debug:step_into",
+          QKeySequence (prefix + Qt::Key_F11));
+    init (tr ("Step Out"), "main_debug:step_out",
+          QKeySequence (prefix + Qt::ShiftModifier + Qt::Key_F11));
+    init (tr ("Continue"), "main_debug:continue",
+          QKeySequence (prefix + Qt::Key_F5));
+    init (tr ("Quit Debug Mode"), "main_debug:quit",
+          QKeySequence (prefix + Qt::ShiftModifier + Qt::Key_F5));
 
-  // window
-  init (tr ("Show Command Window"), "main_window:show_command",
-        prefix + ctrl_shift + Qt::Key_0);
-  init (tr ("Show Command History"), "main_window:show_history",
-        prefix + ctrl_shift + Qt::Key_1);
-  init (tr ("Show File Browser"), "main_window:show_file_browser",
-        prefix + ctrl_shift + Qt::Key_2);
-  init (tr ("Show Workspace"), "main_window:show_workspace",
-        prefix + ctrl_shift + Qt::Key_3);
-  init (tr ("Show Editor"), "main_window:show_editor",
-        prefix + ctrl_shift + Qt::Key_4);
-  init (tr ("Show Documentation"), "main_window:show_doc",
-        prefix + ctrl_shift + Qt::Key_5);
-  init (tr ("Show Variable Editor"), "main_window:show_variable_editor",
-        prefix + ctrl_shift + Qt::Key_6);
-  init (tr ("Command Window"), "main_window:command",
-        prefix + ctrl + Qt::Key_0);
-  init (tr ("Command History"), "main_window:history",
-        prefix + ctrl + Qt::Key_1);
-  init (tr ("File Browser"), "main_window:file_browser",
-        prefix + ctrl + Qt::Key_2);
-  init (tr ("Workspace"), "main_window:workspace",
-        prefix + ctrl + Qt::Key_3);
-  init (tr ("Editor"), "main_window:editor",
-        prefix + ctrl + Qt::Key_4);
-  init (tr ("Documentation"), "main_window:doc",
-        prefix + ctrl + Qt::Key_5);
-  init (tr ("Variable Editor"), "main_window:variable_editor",
-        prefix + ctrl + Qt::Key_6);
-  init (tr ("Reset Default Window Layout"), "main_window:reset", QKeySequence ());
+    // window
+    init (tr ("Show Command Window"), "main_window:show_command",
+          prefix + ctrl_shift + Qt::Key_0);
+    init (tr ("Show Command History"), "main_window:show_history",
+          prefix + ctrl_shift + Qt::Key_1);
+    init (tr ("Show File Browser"), "main_window:show_file_browser",
+          prefix + ctrl_shift + Qt::Key_2);
+    init (tr ("Show Workspace"), "main_window:show_workspace",
+          prefix + ctrl_shift + Qt::Key_3);
+    init (tr ("Show Editor"), "main_window:show_editor",
+          prefix + ctrl_shift + Qt::Key_4);
+    init (tr ("Show Documentation"), "main_window:show_doc",
+          prefix + ctrl_shift + Qt::Key_5);
+    init (tr ("Show Variable Editor"), "main_window:show_variable_editor",
+          prefix + ctrl_shift + Qt::Key_6);
+    init (tr ("Command Window"), "main_window:command",
+          prefix + ctrl + Qt::Key_0);
+    init (tr ("Command History"), "main_window:history",
+          prefix + ctrl + Qt::Key_1);
+    init (tr ("File Browser"), "main_window:file_browser",
+          prefix + ctrl + Qt::Key_2);
+    init (tr ("Workspace"), "main_window:workspace",
+          prefix + ctrl + Qt::Key_3);
+    init (tr ("Editor"), "main_window:editor",
+          prefix + ctrl + Qt::Key_4);
+    init (tr ("Documentation"), "main_window:doc",
+          prefix + ctrl + Qt::Key_5);
+    init (tr ("Variable Editor"), "main_window:variable_editor",
+          prefix + ctrl + Qt::Key_6);
+    init (tr ("Reset Default Window Layout"), "main_window:reset", QKeySequence ());
 
-  // help
-  init (tr ("Show Ondisk Documentation"), "main_help:ondisk_doc",
-        QKeySequence ());
-  init (tr ("Show Online Documentation"), "main_help:online_doc",
-        QKeySequence ());
-  init (tr ("Report Bug"), "main_help:report_bug", QKeySequence ());
-  init (tr ("Octave Packages"), "main_help:packages", QKeySequence ());
-  init (tr ("Contribute to Octave"), "main_help:contribute", QKeySequence ());
-  init (tr ("Octave Developer Resources"), "main_help:developer",
-        QKeySequence ());
-  init (tr ("About Octave"), "main_help:about", QKeySequence ());
+    // help
+    init (tr ("Show Ondisk Documentation"), "main_help:ondisk_doc",
+          QKeySequence ());
+    init (tr ("Show Online Documentation"), "main_help:online_doc",
+          QKeySequence ());
+    init (tr ("Report Bug"), "main_help:report_bug", QKeySequence ());
+    init (tr ("Octave Packages"), "main_help:packages", QKeySequence ());
+    init (tr ("Contribute to Octave"), "main_help:contribute", QKeySequence ());
+    init (tr ("Octave Developer Resources"), "main_help:developer",
+          QKeySequence ());
+    init (tr ("About Octave"), "main_help:about", QKeySequence ());
 
-  // news
-  init (tr ("Release Notes"), "main_news:release_notes", QKeySequence ());
-  init (tr ("Community News"), "main_news:community_news", QKeySequence ());
+    // news
+    init (tr ("Release Notes"), "main_news:release_notes", QKeySequence ());
+    init (tr ("Community News"), "main_news:community_news", QKeySequence ());
 
-  // Tab handling
-  // The following shortcuts are moved into a separate tab. The key names
-  // are not change for preserving compatibility with older versions
-  init (tr ("Close Tab"), "editor_file:close", QKeySequence::Close);
-  init (tr ("Close All Tabs"), "editor_file:close_all", QKeySequence ());
-  init (tr ("Close Other Tabs"), "editor_file:close_other", QKeySequence ());
+    // Tab handling
+    // The following shortcuts are moved into a separate tab. The key names
+    // are not change for preserving compatibility with older versions
+    init (tr ("Close Tab"), "editor_file:close", QKeySequence::Close);
+    init (tr ("Close All Tabs"), "editor_file:close_all", QKeySequence ());
+    init (tr ("Close Other Tabs"), "editor_file:close_other", QKeySequence ());
 
-  // actions of the editor
+    // actions of the editor
 
-  // file
-  init (tr ("Edit Function"), "editor_file:edit_function",
-        QKeySequence (ctrl + Qt::Key_E));
-  init (tr ("Save File"), "editor_file:save", QKeySequence::Save);
-  init (tr ("Save File As"), "editor_file:save_as", QKeySequence::SaveAs);
-  init (tr ("Print"), "editor_file:print", QKeySequence::Print);
+    // file
+    init (tr ("Edit Function"), "editor_file:edit_function",
+          QKeySequence (ctrl + Qt::Key_E));
+    init (tr ("Save File"), "editor_file:save", QKeySequence::Save);
+    init (tr ("Save File As"), "editor_file:save_as", QKeySequence::SaveAs);
+    init (tr ("Print"), "editor_file:print", QKeySequence::Print);
 
-  // edit
-  init (tr ("Redo"), "editor_edit:redo", QKeySequence::Redo);
-  init (tr ("Cut"), "editor_edit:cut", QKeySequence::Cut);
-  init (tr ("Find and Replace"), "editor_edit:find_replace",
-        QKeySequence::Find);
-  init (tr ("Find Next"), "editor_edit:find_next",
-        QKeySequence::FindNext);
-  init (tr ("Find Previous"), "editor_edit:find_previous",
-        QKeySequence::FindPrevious);
-  init (tr ("Delete to Start of Word"), "editor_edit:delete_start_word",
-        QKeySequence::DeleteStartOfWord);
-  init (tr ("Delete to End of Word"), "editor_edit:delete_end_word",
-        QKeySequence::DeleteEndOfWord);
-  init (tr ("Delete to Start of Line"), "editor_edit:delete_start_line",
-        QKeySequence (ctrl_shift + Qt::Key_Backspace));
-  init (tr ("Delete to End of Line"), "editor_edit:delete_end_line",
-        QKeySequence (ctrl_shift + Qt::Key_Delete));
-  init (tr ("Delete Line"), "editor_edit:delete_line",
-        QKeySequence (ctrl_shift + Qt::Key_L));
-  init (tr ("Copy Line"), "editor_edit:copy_line",
-        QKeySequence (ctrl_shift + Qt::Key_C));
-  init (tr ("Cut Line"), "editor_edit:cut_line",
-        QKeySequence (ctrl_shift + Qt::Key_X));
-  init (tr ("Duplicate Selection/Line"), "editor_edit:duplicate_selection",
-        QKeySequence (ctrl + Qt::Key_D));
-  init (tr ("Transpose Line"), "editor_edit:transpose_line",
-        QKeySequence (ctrl + Qt::Key_T));
-  init (tr ("Show Completion List"), "editor_edit:completion_list",
-        QKeySequence (ctrl + Qt::Key_Space));
+    // edit
+    init (tr ("Redo"), "editor_edit:redo", QKeySequence::Redo);
+    init (tr ("Cut"), "editor_edit:cut", QKeySequence::Cut);
+    init (tr ("Find and Replace"), "editor_edit:find_replace",
+          QKeySequence::Find);
+    init (tr ("Find Next"), "editor_edit:find_next",
+          QKeySequence::FindNext);
+    init (tr ("Find Previous"), "editor_edit:find_previous",
+          QKeySequence::FindPrevious);
+    init (tr ("Delete to Start of Word"), "editor_edit:delete_start_word",
+          QKeySequence::DeleteStartOfWord);
+    init (tr ("Delete to End of Word"), "editor_edit:delete_end_word",
+          QKeySequence::DeleteEndOfWord);
+    init (tr ("Delete to Start of Line"), "editor_edit:delete_start_line",
+          QKeySequence (ctrl_shift + Qt::Key_Backspace));
+    init (tr ("Delete to End of Line"), "editor_edit:delete_end_line",
+          QKeySequence (ctrl_shift + Qt::Key_Delete));
+    init (tr ("Delete Line"), "editor_edit:delete_line",
+          QKeySequence (ctrl_shift + Qt::Key_L));
+    init (tr ("Copy Line"), "editor_edit:copy_line",
+          QKeySequence (ctrl_shift + Qt::Key_C));
+    init (tr ("Cut Line"), "editor_edit:cut_line",
+          QKeySequence (ctrl_shift + Qt::Key_X));
+    init (tr ("Duplicate Selection/Line"), "editor_edit:duplicate_selection",
+          QKeySequence (ctrl + Qt::Key_D));
+    init (tr ("Transpose Line"), "editor_edit:transpose_line",
+          QKeySequence (ctrl + Qt::Key_T));
+    init (tr ("Show Completion List"), "editor_edit:completion_list",
+          QKeySequence (ctrl + Qt::Key_Space));
 
-  init (tr ("Comment Selection"), "editor_edit:comment_selection",
-        QKeySequence (ctrl + Qt::Key_R));
-  init (tr ("Uncomment Selection"), "editor_edit:uncomment_selection",
-        QKeySequence (ctrl_shift + Qt::Key_R));
-  init (tr ("Comment Selection (Choosing String)"), "editor_edit:comment_var_selection",
-        QKeySequence (ctrl_alt + Qt::Key_R));
-  init (tr ("Uppercase Selection"), "editor_edit:upper_case",
-        QKeySequence (ctrl + Qt::Key_U));
-  init (tr ("Lowercase Selection"), "editor_edit:lower_case",
-        QKeySequence (ctrl_alt + Qt::Key_U));
+    init (tr ("Comment Selection"), "editor_edit:comment_selection",
+          QKeySequence (ctrl + Qt::Key_R));
+    init (tr ("Uncomment Selection"), "editor_edit:uncomment_selection",
+          QKeySequence (ctrl_shift + Qt::Key_R));
+    init (tr ("Comment Selection (Choosing String)"), "editor_edit:comment_var_selection",
+          QKeySequence (ctrl_alt + Qt::Key_R));
+    init (tr ("Uppercase Selection"), "editor_edit:upper_case",
+          QKeySequence (ctrl + Qt::Key_U));
+    init (tr ("Lowercase Selection"), "editor_edit:lower_case",
+          QKeySequence (ctrl_alt + Qt::Key_U));
 
 #if defined (Q_OS_MAC)
-  init (tr ("Indent Selection Rigidly"), "editor_edit:indent_selection",
-        QKeySequence (prefix + Qt::Key_Tab));
-  init (tr ("Unindent Selection Rigidly"), "editor_edit:unindent_selection",
-        QKeySequence (prefix + Qt::ShiftModifier + Qt::Key_Tab));
+    init (tr ("Indent Selection Rigidly"), "editor_edit:indent_selection",
+          QKeySequence (prefix + Qt::Key_Tab));
+    init (tr ("Unindent Selection Rigidly"), "editor_edit:unindent_selection",
+          QKeySequence (prefix + Qt::ShiftModifier + Qt::Key_Tab));
 #else
-  init (tr ("Indent Selection Rigidly"), "editor_edit:indent_selection",
-        QKeySequence (ctrl + Qt::Key_Tab));
-  init (tr ("Unindent Selection Rigidly"), "editor_edit:unindent_selection",
-        QKeySequence (ctrl_shift + Qt::Key_Tab));
+    init (tr ("Indent Selection Rigidly"), "editor_edit:indent_selection",
+          QKeySequence (ctrl + Qt::Key_Tab));
+    init (tr ("Unindent Selection Rigidly"), "editor_edit:unindent_selection",
+          QKeySequence (ctrl_shift + Qt::Key_Tab));
 #endif
-  init (tr ("Indent Code"), "editor_edit:smart_indent_line_or_selection",
-        QKeySequence ());
+    init (tr ("Indent Code"), "editor_edit:smart_indent_line_or_selection",
+          QKeySequence ());
 
-  init (tr ("Convert Line Endings to Windows"), "editor_edit:conv_eol_winows",
-        QKeySequence ());
-  init (tr ("Convert Line Endings to Unix"), "editor_edit:conv_eol_unix",
-        QKeySequence ());
-  init (tr ("Convert Line Endings to Mac"), "editor_edit:conv_eol_mac",
-        QKeySequence ());
+    init (tr ("Convert Line Endings to Windows"), "editor_edit:conv_eol_winows",
+          QKeySequence ());
+    init (tr ("Convert Line Endings to Unix"), "editor_edit:conv_eol_unix",
+          QKeySequence ());
+    init (tr ("Convert Line Endings to Mac"), "editor_edit:conv_eol_mac",
+          QKeySequence ());
 
-  init (tr ("Goto Line"), "editor_edit:goto_line",
-        QKeySequence (ctrl + Qt::Key_L));
-  init (tr ("Move to Matching Brace"), "editor_edit:move_to_brace",
-        QKeySequence (ctrl + Qt::Key_M));
-  init (tr ("Select to Matching Brace"), "editor_edit:select_to_brace",
-        QKeySequence (ctrl_shift + Qt::Key_M));
-  init (tr ("Toggle Bookmark"), "editor_edit:toggle_bookmark",
-        QKeySequence (prefix + Qt::Key_F7));
-  init (tr ("Next Bookmark"), "editor_edit:next_bookmark",
-        QKeySequence (prefix + Qt::Key_F2));
-  init (tr ("Previous Bookmark"), "editor_edit:previous_bookmark",
-        QKeySequence (prefix + Qt::SHIFT + Qt::Key_F2));
-  init (tr ("Remove All Bookmark"), "editor_edit:remove_bookmark",
-        QKeySequence ());
+    init (tr ("Goto Line"), "editor_edit:goto_line",
+          QKeySequence (ctrl + Qt::Key_L));
+    init (tr ("Move to Matching Brace"), "editor_edit:move_to_brace",
+          QKeySequence (ctrl + Qt::Key_M));
+    init (tr ("Select to Matching Brace"), "editor_edit:select_to_brace",
+          QKeySequence (ctrl_shift + Qt::Key_M));
+    init (tr ("Toggle Bookmark"), "editor_edit:toggle_bookmark",
+          QKeySequence (prefix + Qt::Key_F7));
+    init (tr ("Next Bookmark"), "editor_edit:next_bookmark",
+          QKeySequence (prefix + Qt::Key_F2));
+    init (tr ("Previous Bookmark"), "editor_edit:previous_bookmark",
+          QKeySequence (prefix + Qt::SHIFT + Qt::Key_F2));
+    init (tr ("Remove All Bookmark"), "editor_edit:remove_bookmark",
+          QKeySequence ());
 
-  init (tr ("Preferences"), "editor_edit:preferences", QKeySequence ());
-  init (tr ("Styles Preferences"), "editor_edit:styles_preferences",
-        QKeySequence ());
+    init (tr ("Preferences"), "editor_edit:preferences", QKeySequence ());
+    init (tr ("Styles Preferences"), "editor_edit:styles_preferences",
+          QKeySequence ());
 
-  // view
-  init (tr ("Show Line Numbers"), "editor_view:show_line_numbers",
-        QKeySequence ());
-  init (tr ("Show Whitespace Characters"), "editor_view:show_white_spaces",
-        QKeySequence ());
-  init (tr ("Show Line Endings"), "editor_view:show_eol_chars", QKeySequence ());
-  init (tr ("Show Indentation Guides"), "editor_view:show_ind_guides",
-        QKeySequence ());
-  init (tr ("Show Long Line Marker"), "editor_view:show_long_line",
-        QKeySequence ());
-  init (tr ("Show Toolbar"), "editor_view:show_toolbar",
-        QKeySequence ());
-  init (tr ("Show Statusbar"), "editor_view:show_statusbar",
-        QKeySequence ());
-  init (tr ("Show Horizontal Scrollbar"), "editor_view:show_hscrollbar",
-        QKeySequence ());
-  init (tr ("Zoom In"), "editor_view:zoom_in", QKeySequence::ZoomIn);
-  init (tr ("Zoom Out"), "editor_view:zoom_out", QKeySequence::ZoomOut);
+    // view
+    init (tr ("Show Line Numbers"), "editor_view:show_line_numbers",
+          QKeySequence ());
+    init (tr ("Show Whitespace Characters"), "editor_view:show_white_spaces",
+          QKeySequence ());
+    init (tr ("Show Line Endings"), "editor_view:show_eol_chars", QKeySequence ());
+    init (tr ("Show Indentation Guides"), "editor_view:show_ind_guides",
+          QKeySequence ());
+    init (tr ("Show Long Line Marker"), "editor_view:show_long_line",
+          QKeySequence ());
+    init (tr ("Show Toolbar"), "editor_view:show_toolbar",
+          QKeySequence ());
+    init (tr ("Show Statusbar"), "editor_view:show_statusbar",
+          QKeySequence ());
+    init (tr ("Show Horizontal Scrollbar"), "editor_view:show_hscrollbar",
+          QKeySequence ());
+    init (tr ("Zoom In"), "editor_view:zoom_in", QKeySequence::ZoomIn);
+    init (tr ("Zoom Out"), "editor_view:zoom_out", QKeySequence::ZoomOut);
 #if defined (Q_OS_MAC)
-  init (tr ("Zoom Normal"), "editor_view:zoom_normal",
-        QKeySequence (ctrl + Qt::Key_Underscore));
+    init (tr ("Zoom Normal"), "editor_view:zoom_normal",
+          QKeySequence (ctrl + Qt::Key_Underscore));
 #else
-  init (tr ("Zoom Normal"), "editor_view:zoom_normal",
-        QKeySequence (ctrl + Qt::Key_Period));
+    init (tr ("Zoom Normal"), "editor_view:zoom_normal",
+          QKeySequence (ctrl + Qt::Key_Period));
 #endif
 
-  // debug
-  init (tr ("Toggle Breakpoint"), "editor_debug:toggle_breakpoint",
-        QKeySequence ());
-  init (tr ("Next Breakpoint"), "editor_debug:next_breakpoint",
-        QKeySequence ());
-  init (tr ("Previous Breakpoint"), "editor_debug:previous_breakpoint",
-        QKeySequence ());
-  init (tr ("Remove All Breakpoints"), "editor_debug:remove_breakpoints",
-        QKeySequence ());
+    // debug
+    init (tr ("Toggle Breakpoint"), "editor_debug:toggle_breakpoint",
+          QKeySequence ());
+    init (tr ("Next Breakpoint"), "editor_debug:next_breakpoint",
+          QKeySequence ());
+    init (tr ("Previous Breakpoint"), "editor_debug:previous_breakpoint",
+          QKeySequence ());
+    init (tr ("Remove All Breakpoints"), "editor_debug:remove_breakpoints",
+          QKeySequence ());
 
-  // run
-  init (tr ("Run File"), "editor_run:run_file",
-        QKeySequence (prefix + Qt::Key_F5));
-  init (tr ("Run Selection"), "editor_run:run_selection",
-        QKeySequence (prefix + Qt::Key_F9));
+    // run
+    init (tr ("Run File"), "editor_run:run_file",
+          QKeySequence (prefix + Qt::Key_F5));
+    init (tr ("Run Selection"), "editor_run:run_selection",
+          QKeySequence (prefix + Qt::Key_F9));
 
-  // help
-  init (tr ("Help on Keyword"), "editor_help:help_keyword",
-        QKeySequence::HelpContents);
-  init (tr ("Document on Keyword"), "editor_help:doc_keyword",
-        QKeySequence (Qt::SHIFT + Qt::Key_F1));
+    // help
+    init (tr ("Help on Keyword"), "editor_help:help_keyword",
+          QKeySequence::HelpContents);
+    init (tr ("Document on Keyword"), "editor_help:doc_keyword",
+          QKeySequence (Qt::SHIFT + Qt::Key_F1));
 
-  // tab navigation
-  init (tr ("Switch to Left Tab"), "editor_tabs:switch_left_tab",
-        QKeySequence (ctrl + Qt::Key_PageUp));
-  init (tr ("Switch to Right Tab"), "editor_tabs:switch_right_tab",
-        QKeySequence (ctrl + Qt::Key_PageDown));
-  init (tr ("Move Tab Left"), "editor_tabs:move_tab_left",
-        QKeySequence (Qt::AltModifier + Qt::Key_PageUp));
-  init (tr ("Move Tab Right"), "editor_tabs:move_tab_right",
-        QKeySequence (Qt::AltModifier + Qt::Key_PageDown));
+    // tab navigation
+    init (tr ("Switch to Left Tab"), "editor_tabs:switch_left_tab",
+          QKeySequence (ctrl + Qt::Key_PageUp));
+    init (tr ("Switch to Right Tab"), "editor_tabs:switch_right_tab",
+          QKeySequence (ctrl + Qt::Key_PageDown));
+    init (tr ("Move Tab Left"), "editor_tabs:move_tab_left",
+          QKeySequence (Qt::AltModifier + Qt::Key_PageUp));
+    init (tr ("Move Tab Right"), "editor_tabs:move_tab_right",
+          QKeySequence (Qt::AltModifier + Qt::Key_PageDown));
 
-}
-
-// write one or all actual shortcut set(s) into a settings file
-void
-shortcut_manager::do_write_shortcuts (QSettings *settings,
-                                      bool closing)
-{
-  bool sc_ctrld = false;
+  }
 
-  for (int i = 0; i < m_sc.count (); i++)  // loop over all shortcuts
-    {
-      settings->setValue ("shortcuts/" + m_sc.at (i).m_settings_key,
-                          m_sc.at (i).m_actual_sc.toString ());
-      // special: check main-window for Ctrl-D (Terminal)
-      if (m_sc.at (i).m_settings_key.startsWith ("main_")
-          && m_sc.at (i).m_actual_sc == QKeySequence (Qt::ControlModifier+Qt::Key_D))
-        sc_ctrld = true;
-    }
+  // write one or all actual shortcut set(s) into a settings file
+  void shortcut_manager::do_write_shortcuts (QSettings *settings,
+                                             bool closing)
+  {
+    bool sc_ctrld = false;
 
-  settings->setValue ("shortcuts/main_ctrld",sc_ctrld);
+    for (int i = 0; i < m_sc.count (); i++)  // loop over all shortcuts
+      {
+        settings->setValue ("shortcuts/" + m_sc.at (i).m_settings_key,
+                            m_sc.at (i).m_actual_sc.toString ());
+        // special: check main-window for Ctrl-D (Terminal)
+        if (m_sc.at (i).m_settings_key.startsWith ("main_")
+            && m_sc.at (i).m_actual_sc == QKeySequence (Qt::ControlModifier+Qt::Key_D))
+          sc_ctrld = true;
+      }
 
-  if (closing)
-    {
-      delete m_dialog;     // the dialog for key sequences can be removed now
-      m_dialog = nullptr;  // make sure it is zero again
-    }
+    settings->setValue ("shortcuts/main_ctrld",sc_ctrld);
 
-  settings->sync ();      // sync the settings file
-}
+    if (closing)
+      {
+        delete m_dialog;     // the dialog for key sequences can be removed now
+        m_dialog = nullptr;  // make sure it is zero again
+      }
 
-void
-shortcut_manager::do_set_shortcut (QAction *action, const QString& key)
-{
-  int index;
+    settings->sync ();      // sync the settings file
+  }
 
-  index = m_action_hash[key] - 1;
+  void shortcut_manager::do_set_shortcut (QAction *action, const QString& key)
+  {
+    int index;
 
-  if (index > -1 && index < m_sc.count ())
-    action->setShortcut (QKeySequence (
-      m_settings->value ("shortcuts/" + key, m_sc.at (index).m_default_sc).toString ()));
-  else
-    qDebug () << "Key: " << key << " not found in m_action_hash";
-}
+    index = m_action_hash[key] - 1;
 
-void
-shortcut_manager::do_fill_treewidget (QTreeWidget *tree_view)
-{
-  m_dialog = nullptr;
-  m_level_hash.clear ();
+    if (index > -1 && index < m_sc.count ())
+      action->setShortcut (QKeySequence (
+                                         m_settings->value ("shortcuts/" + key, m_sc.at (index).m_default_sc).toString ()));
+    else
+      qDebug () << "Key: " << key << " not found in m_action_hash";
+  }
+
+  void shortcut_manager::do_fill_treewidget (QTreeWidget *tree_view)
+  {
+    m_dialog = nullptr;
+    m_level_hash.clear ();
 
 #if defined (HAVE_QT4)
-  tree_view->header ()->setResizeMode (QHeaderView::ResizeToContents);
+    tree_view->header ()->setResizeMode (QHeaderView::ResizeToContents);
 #else
-  tree_view->header ()->setSectionResizeMode (QHeaderView::ResizeToContents);
+    tree_view->header ()->setSectionResizeMode (QHeaderView::ResizeToContents);
 #endif
 
-  QTreeWidgetItem *main = new QTreeWidgetItem (tree_view);
-  main->setText (0, tr ("Global"));
-  main->setExpanded (true);
-  QTreeWidgetItem *main_file = new QTreeWidgetItem (main);
-  main_file->setText (0, tr ("File Menu"));
-  QTreeWidgetItem *main_edit = new QTreeWidgetItem (main);
-  main_edit->setText (0, tr ("Edit Menu"));
-  QTreeWidgetItem *main_debug = new QTreeWidgetItem (main);
-  main_debug->setText (0, tr ("Debug Menu"));
-  QTreeWidgetItem *main_window = new QTreeWidgetItem (main);
-  main_window->setText (0, tr ("Window Menu"));
-  QTreeWidgetItem *main_help = new QTreeWidgetItem (main);
-  main_help->setText (0, tr ("Help Menu"));
-  QTreeWidgetItem *main_news = new QTreeWidgetItem (main);
-  main_news->setText (0, tr ("News Menu"));
-  QTreeWidgetItem *main_tabs = new QTreeWidgetItem (main);
-  main_tabs->setText (0, tr ("Tab Handling in Dock Widgets"));
+    QTreeWidgetItem *main = new QTreeWidgetItem (tree_view);
+    main->setText (0, tr ("Global"));
+    main->setExpanded (true);
+    QTreeWidgetItem *main_file = new QTreeWidgetItem (main);
+    main_file->setText (0, tr ("File Menu"));
+    QTreeWidgetItem *main_edit = new QTreeWidgetItem (main);
+    main_edit->setText (0, tr ("Edit Menu"));
+    QTreeWidgetItem *main_debug = new QTreeWidgetItem (main);
+    main_debug->setText (0, tr ("Debug Menu"));
+    QTreeWidgetItem *main_window = new QTreeWidgetItem (main);
+    main_window->setText (0, tr ("Window Menu"));
+    QTreeWidgetItem *main_help = new QTreeWidgetItem (main);
+    main_help->setText (0, tr ("Help Menu"));
+    QTreeWidgetItem *main_news = new QTreeWidgetItem (main);
+    main_news->setText (0, tr ("News Menu"));
+    QTreeWidgetItem *main_tabs = new QTreeWidgetItem (main);
+    main_tabs->setText (0, tr ("Tab Handling in Dock Widgets"));
 
-  m_level_hash["main_file"]   = main_file;
-  m_level_hash["main_edit"]   = main_edit;
-  m_level_hash["main_debug"]   = main_debug;
-  m_level_hash["main_window"]   = main_window;
-  m_level_hash["main_help"]   = main_help;
-  m_level_hash["main_news"]   = main_news;
-  m_level_hash["main_tabs"]   = main_tabs;
+    m_level_hash["main_file"]   = main_file;
+    m_level_hash["main_edit"]   = main_edit;
+    m_level_hash["main_debug"]   = main_debug;
+    m_level_hash["main_window"]   = main_window;
+    m_level_hash["main_help"]   = main_help;
+    m_level_hash["main_news"]   = main_news;
+    m_level_hash["main_tabs"]   = main_tabs;
 
-  QTreeWidgetItem *editor = new QTreeWidgetItem (tree_view);
-  editor->setText (0, tr ("Editor"));
-  editor->setExpanded (true);
-  QTreeWidgetItem *editor_file = new QTreeWidgetItem (editor);
-  editor_file->setText (0, tr ("File Menu"));
-  QTreeWidgetItem *editor_edit = new QTreeWidgetItem (editor);
-  editor_edit->setText (0, tr ("Edit Menu"));
-  QTreeWidgetItem *editor_view = new QTreeWidgetItem (editor);
-  editor_view->setText (0, tr ("View Menu"));
-  QTreeWidgetItem *editor_debug = new QTreeWidgetItem (editor);
-  editor_debug->setText (0, tr ("Debug Menu"));
-  QTreeWidgetItem *editor_run = new QTreeWidgetItem (editor);
-  editor_run->setText (0, tr ("Run Menu"));
-  QTreeWidgetItem *editor_help = new QTreeWidgetItem (editor);
-  editor_help->setText (0, tr ("Help Menu"));
-  QTreeWidgetItem *editor_tabs = new QTreeWidgetItem (editor);
-  editor_tabs->setText (0, tr ("Tab Handling"));
+    QTreeWidgetItem *editor = new QTreeWidgetItem (tree_view);
+    editor->setText (0, tr ("Editor"));
+    editor->setExpanded (true);
+    QTreeWidgetItem *editor_file = new QTreeWidgetItem (editor);
+    editor_file->setText (0, tr ("File Menu"));
+    QTreeWidgetItem *editor_edit = new QTreeWidgetItem (editor);
+    editor_edit->setText (0, tr ("Edit Menu"));
+    QTreeWidgetItem *editor_view = new QTreeWidgetItem (editor);
+    editor_view->setText (0, tr ("View Menu"));
+    QTreeWidgetItem *editor_debug = new QTreeWidgetItem (editor);
+    editor_debug->setText (0, tr ("Debug Menu"));
+    QTreeWidgetItem *editor_run = new QTreeWidgetItem (editor);
+    editor_run->setText (0, tr ("Run Menu"));
+    QTreeWidgetItem *editor_help = new QTreeWidgetItem (editor);
+    editor_help->setText (0, tr ("Help Menu"));
+    QTreeWidgetItem *editor_tabs = new QTreeWidgetItem (editor);
+    editor_tabs->setText (0, tr ("Tab Handling"));
 
-  m_level_hash["editor_file"] = editor_file;
-  m_level_hash["editor_edit"] = editor_edit;
-  m_level_hash["editor_view"] = editor_view;
-  m_level_hash["editor_debug"] = editor_debug;
-  m_level_hash["editor_run"] = editor_run;
-  m_level_hash["editor_help"] = editor_help;
-  m_level_hash["editor_tabs"] = editor_tabs;
+    m_level_hash["editor_file"] = editor_file;
+    m_level_hash["editor_edit"] = editor_edit;
+    m_level_hash["editor_view"] = editor_view;
+    m_level_hash["editor_debug"] = editor_debug;
+    m_level_hash["editor_run"] = editor_run;
+    m_level_hash["editor_help"] = editor_help;
+    m_level_hash["editor_tabs"] = editor_tabs;
 
-  connect (tree_view, SIGNAL (itemDoubleClicked (QTreeWidgetItem*, int)),
-           this, SLOT (handle_double_clicked (QTreeWidgetItem*, int)));
+    connect (tree_view, SIGNAL (itemDoubleClicked (QTreeWidgetItem*, int)),
+             this, SLOT (handle_double_clicked (QTreeWidgetItem*, int)));
 
-  for (int i = 0; i < m_sc.count (); i++)
-    {
-      shortcut_t sc = m_sc.at (i);
-
-      QTreeWidgetItem *section = m_level_hash[sc.m_settings_key.section (':',0,0)];
+    for (int i = 0; i < m_sc.count (); i++)
+      {
+        shortcut_t sc = m_sc.at (i);
 
-      // handle sections which have changed and do not correspond to the
-      // previously defined keyname
-      if (section == editor_file)
-        {
-          // Closing tabs now in global tab handling section
-          if (sc.m_description.mid (0,6) == "Close ")
-            section = main_tabs;
-        }
+        QTreeWidgetItem *section = m_level_hash[sc.m_settings_key.section (':',0,0)];
 
-      QTreeWidgetItem *tree_item = new QTreeWidgetItem (section);
+        // handle sections which have changed and do not correspond to the
+        // previously defined keyname
+        if (section == editor_file)
+          {
+            // Closing tabs now in global tab handling section
+            if (sc.m_description.mid (0,6) == "Close ")
+              section = main_tabs;
+          }
+
+        QTreeWidgetItem *tree_item = new QTreeWidgetItem (section);
 
-      // set a slightly transparent foreground for default columns
-      QColor fg = QColor (tree_item->foreground (1).color ());
-      fg.setAlpha (128);
-      tree_item->setForeground (1, QBrush (fg));
+        // set a slightly transparent foreground for default columns
+        QColor fg = QColor (tree_item->foreground (1).color ());
+        fg.setAlpha (128);
+        tree_item->setForeground (1, QBrush (fg));
 
-      // write the shortcuts
-      tree_item->setText (0, sc.m_description);
-      tree_item->setText (1, sc.m_default_sc.toString ());
-      tree_item->setText (2, sc.m_actual_sc.toString ());
+        // write the shortcuts
+        tree_item->setText (0, sc.m_description);
+        tree_item->setText (1, sc.m_default_sc.toString ());
+        tree_item->setText (2, sc.m_actual_sc.toString ());
 
-      m_item_index_hash[tree_item] = i + 1; // index+1 to avoid 0
-      m_index_item_hash[i] = tree_item;
-    }
+        m_item_index_hash[tree_item] = i + 1; // index+1 to avoid 0
+        m_index_item_hash[i] = tree_item;
+      }
 
-}
+  }
 
-// import or export of shortcut sets,
-// called from settings dialog when related buttons are clicked;
-// returns true on success, false otherwise
-bool
-shortcut_manager::do_import_export (int action)
-{
-  // ask to save the current shortcuts, maybe abort import
-  if (action == OSC_DEFAULT || action == OSC_IMPORT)
-    {
-      if (! overwrite_all_shortcuts ())
-        return false;
-    }
-
-  // get the filename to read or write the shortcuts,
-  // the default extension is .osc (octave shortcuts)
-  if (action != OSC_DEFAULT)
-    {
-      QString file;
+  // import or export of shortcut sets,
+  // called from settings dialog when related buttons are clicked;
+  // returns true on success, false otherwise
+  bool
+  shortcut_manager::do_import_export (int action)
+  {
+    // ask to save the current shortcuts, maybe abort import
+    if (action == OSC_DEFAULT || action == OSC_IMPORT)
+      {
+        if (! overwrite_all_shortcuts ())
+          return false;
+      }
 
-      if (action == OSC_IMPORT)
-        file = QFileDialog::getOpenFileName (this,
-                    tr ("Import shortcuts from file ..."), QString (),
-                    tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
-                    nullptr, QFileDialog::DontUseNativeDialog);
-      else if (action == OSC_EXPORT)
-        file = QFileDialog::getSaveFileName (this,
-                    tr ("Export shortcuts into file ..."), QString (),
-                    tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
-                    nullptr, QFileDialog::DontUseNativeDialog);
+    // get the filename to read or write the shortcuts,
+    // the default extension is .osc (octave shortcuts)
+    if (action != OSC_DEFAULT)
+      {
+        QString file;
 
-      if (file.isEmpty ())
-        return false;
-
-      QSettings *osc_settings = new QSettings (file, QSettings::IniFormat);
+        if (action == OSC_IMPORT)
+          file = QFileDialog::getOpenFileName (this,
+                                               tr ("Import shortcuts from file ..."), QString (),
+                                               tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
+                                               nullptr, QFileDialog::DontUseNativeDialog);
+        else if (action == OSC_EXPORT)
+          file = QFileDialog::getSaveFileName (this,
+                                               tr ("Export shortcuts into file ..."), QString (),
+                                               tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
+                                               nullptr, QFileDialog::DontUseNativeDialog);
 
-      if (! osc_settings)
-        {
-          qWarning () << tr ("Failed to open %1 as octave shortcut file")
-                         .arg (file);
+        if (file.isEmpty ())
           return false;
-        }
-      else
-        {
-          if (action == OSC_IMPORT)
-            import_shortcuts (osc_settings);   // import (special action)
-          else if (action == OSC_EXPORT)
-            do_write_shortcuts (osc_settings, false); // export, (save settings)
-        }
-    }
-  else
-    {
-      import_shortcuts (nullptr);
-    }
 
-  return true;
-}
+        QSettings *osc_settings = new QSettings (file, QSettings::IniFormat);
 
-void
-shortcut_manager::shortcut_dialog (int index)
-{
-  if (! m_dialog)
-    {
-      m_dialog = new QDialog (this);
+        if (! osc_settings)
+          {
+            qWarning () << tr ("Failed to open %1 as octave shortcut file")
+              .arg (file);
+            return false;
+          }
+        else
+          {
+            if (action == OSC_IMPORT)
+              import_shortcuts (osc_settings);   // import (special action)
+            else if (action == OSC_EXPORT)
+              do_write_shortcuts (osc_settings, false); // export, (save settings)
+          }
+      }
+    else
+      {
+        import_shortcuts (nullptr);
+      }
 
-      m_dialog->setWindowTitle (tr ("Enter new Shortcut"));
-
-      QVBoxLayout *box = new QVBoxLayout (m_dialog);
+    return true;
+  }
 
-      QLabel *help = new QLabel (tr ("Apply the desired shortcut or click "
-                                     "on the right button to reset the "
-                                     "shortcut to its default."));
-      help->setWordWrap (true);
-      box->addWidget (help);
+  void shortcut_manager::shortcut_dialog (int index)
+  {
+    if (! m_dialog)
+      {
+        m_dialog = new QDialog (this);
+
+        m_dialog->setWindowTitle (tr ("Enter new Shortcut"));
 
-      QCheckBox *direct = new QCheckBox (
-        tr ("Enter shortcut directly by performing it"));
-      direct->setCheckState (Qt::Checked);
-      box->addWidget (direct);
+        QVBoxLayout *box = new QVBoxLayout (m_dialog);
 
-      QGridLayout *grid = new QGridLayout ();
+        QLabel *help = new QLabel (tr ("Apply the desired shortcut or click "
+                                       "on the right button to reset the "
+                                       "shortcut to its default."));
+        help->setWordWrap (true);
+        box->addWidget (help);
 
-      QLabel *actual = new QLabel (tr ("Actual shortcut"));
-      m_edit_actual = new enter_shortcut (m_dialog);
-      m_edit_actual->setAlignment (Qt::AlignHCenter);
-      grid->addWidget (actual, 0, 0);
-      grid->addWidget (m_edit_actual, 0, 1);
+        QCheckBox *direct = new QCheckBox (
+                                           tr ("Enter shortcut directly by performing it"));
+        direct->setCheckState (Qt::Checked);
+        box->addWidget (direct);
+
+        QGridLayout *grid = new QGridLayout ();
 
-      QLabel *def = new QLabel (tr ("Default shortcut"));
-      m_label_default = new QLabel (m_dialog);
-      m_label_default->setAlignment (Qt::AlignHCenter);
-      grid->addWidget (def, 1, 0);
-      grid->addWidget (m_label_default, 1, 1);
-
-      QPushButton *set_default = new QPushButton (tr ("Set to default"));
-      grid->addWidget (set_default, 0, 2);
-      connect (set_default, SIGNAL (clicked ()),
-               this, SLOT (shortcut_dialog_set_default ()));
+        QLabel *actual = new QLabel (tr ("Actual shortcut"));
+        m_edit_actual = new enter_shortcut (m_dialog);
+        m_edit_actual->setAlignment (Qt::AlignHCenter);
+        grid->addWidget (actual, 0, 0);
+        grid->addWidget (m_edit_actual, 0, 1);
 
-      box->addLayout (grid);
+        QLabel *def = new QLabel (tr ("Default shortcut"));
+        m_label_default = new QLabel (m_dialog);
+        m_label_default->setAlignment (Qt::AlignHCenter);
+        grid->addWidget (def, 1, 0);
+        grid->addWidget (m_label_default, 1, 1);
 
-      QDialogButtonBox *button_box = new QDialogButtonBox (QDialogButtonBox::Ok
-                                                   | QDialogButtonBox::Cancel);
-      QList<QAbstractButton *> buttons = button_box->buttons ();
-      for (int i = 0; i < buttons.count (); i++)
-        buttons.at (i)->setShortcut (QKeySequence ());
-      connect (button_box, SIGNAL (accepted ()), m_dialog, SLOT (accept ()));
-      connect (button_box, SIGNAL (rejected ()), m_dialog, SLOT (reject ()));
-      box->addWidget (button_box);
+        QPushButton *set_default = new QPushButton (tr ("Set to default"));
+        grid->addWidget (set_default, 0, 2);
+        connect (set_default, SIGNAL (clicked ()),
+                 this, SLOT (shortcut_dialog_set_default ()));
+
+        box->addLayout (grid);
 
-      m_dialog->setLayout (box);
+        QDialogButtonBox *button_box = new QDialogButtonBox (QDialogButtonBox::Ok
+                                                             | QDialogButtonBox::Cancel);
+        QList<QAbstractButton *> buttons = button_box->buttons ();
+        for (int i = 0; i < buttons.count (); i++)
+          buttons.at (i)->setShortcut (QKeySequence ());
+        connect (button_box, SIGNAL (accepted ()), m_dialog, SLOT (accept ()));
+        connect (button_box, SIGNAL (rejected ()), m_dialog, SLOT (reject ()));
+        box->addWidget (button_box);
 
-      connect (direct, SIGNAL (stateChanged (int)),
-               m_edit_actual, SLOT (handle_direct_shortcut (int)));
-      connect (m_dialog, SIGNAL (finished (int)),
-               this, SLOT (shortcut_dialog_finished (int)));
+        m_dialog->setLayout (box);
 
-    }
+        connect (direct, SIGNAL (stateChanged (int)),
+                 m_edit_actual, SLOT (handle_direct_shortcut (int)));
+        connect (m_dialog, SIGNAL (finished (int)),
+                 this, SLOT (shortcut_dialog_finished (int)));
 
-  m_edit_actual->setText (m_sc.at (index).m_actual_sc.toString ());
-  m_label_default->setText (m_sc.at (index).m_default_sc.toString ());
-  m_handled_index = index;
+      }
 
-  m_edit_actual->setFocus ();
-  m_dialog->setFocusProxy (m_edit_actual);
-  m_dialog->exec ();
-}
+    m_edit_actual->setText (m_sc.at (index).m_actual_sc.toString ());
+    m_label_default->setText (m_sc.at (index).m_default_sc.toString ());
+    m_handled_index = index;
+
+    m_edit_actual->setFocus ();
+    m_dialog->setFocusProxy (m_edit_actual);
+    m_dialog->exec ();
+  }
 
-// import a shortcut set from a given settings file or reset to
-// the defaults (settings = 0) and refresh the tree view
-void
-shortcut_manager::import_shortcuts (QSettings *settings)
-{
-  for (int i = 0; i < m_sc.count (); i++)
-    {
-      // update the list of all shortcuts
-      shortcut_t sc = m_sc.at (i);           // make a copy
-
-      if (settings)
-        sc.m_actual_sc = QKeySequence (         // get new shortcut from settings
-          settings->value ("shortcuts/" + sc.m_settings_key,sc.m_actual_sc).
-                          toString ());       // and use the old one as default
-      else
-        sc.m_actual_sc = QKeySequence (sc.m_default_sc); // get default shortcut
+  // import a shortcut set from a given settings file or reset to
+  // the defaults (settings = 0) and refresh the tree view
+  void shortcut_manager::import_shortcuts (QSettings *settings)
+  {
+    for (int i = 0; i < m_sc.count (); i++)
+      {
+        // update the list of all shortcuts
+        shortcut_t sc = m_sc.at (i);           // make a copy
 
-      m_sc.replace (i,sc);                   // replace the old with the new one
+        if (settings)
+          sc.m_actual_sc = QKeySequence (         // get new shortcut from settings
+                                         settings->value ("shortcuts/" + sc.m_settings_key,sc.m_actual_sc).
+                                         toString ());       // and use the old one as default
+        else
+          sc.m_actual_sc = QKeySequence (sc.m_default_sc); // get default shortcut
 
-      // update the tree view
-      QTreeWidgetItem *tree_item = m_index_item_hash[i]; // get related tree item
-      tree_item->setText (2, sc.m_actual_sc.toString ()); // display new shortcut
-    }
-}
+        m_sc.replace (i,sc);                   // replace the old with the new one
+
+        // update the tree view
+        QTreeWidgetItem *tree_item = m_index_item_hash[i]; // get related tree item
+        tree_item->setText (2, sc.m_actual_sc.toString ()); // display new shortcut
+      }
+  }
 
-// ask the user whether to save the current shortcut set;
-// returns true to proceed with import action, false to abort it
-bool
-shortcut_manager::overwrite_all_shortcuts (void)
-{
-  QMessageBox msg_box;
-  msg_box.setWindowTitle (tr ("Overwriting Shortcuts"));
-  msg_box.setIcon (QMessageBox::Warning);
-  msg_box.setText (tr ("You are about to overwrite all shortcuts.\n"
-     "Would you like to save the current shortcut set or cancel the action?"));
-  msg_box.setStandardButtons (QMessageBox::Save | QMessageBox::Cancel);
-  QPushButton *discard = msg_box.addButton (tr ("Don't save"),
-                                            QMessageBox::DestructiveRole);
-  msg_box.setDefaultButton (QMessageBox::Save);
+  // ask the user whether to save the current shortcut set;
+  // returns true to proceed with import action, false to abort it
+  bool shortcut_manager::overwrite_all_shortcuts (void)
+  {
+    QMessageBox msg_box;
+    msg_box.setWindowTitle (tr ("Overwriting Shortcuts"));
+    msg_box.setIcon (QMessageBox::Warning);
+    msg_box.setText (tr ("You are about to overwrite all shortcuts.\n"
+                         "Would you like to save the current shortcut set or cancel the action?"));
+    msg_box.setStandardButtons (QMessageBox::Save | QMessageBox::Cancel);
+    QPushButton *discard = msg_box.addButton (tr ("Don't save"),
+                                              QMessageBox::DestructiveRole);
+    msg_box.setDefaultButton (QMessageBox::Save);
 
-  int ret = msg_box.exec ();
+    int ret = msg_box.exec ();
 
-  if (msg_box.clickedButton () == discard)
-    return true;  // do not save and go ahead
+    if (msg_box.clickedButton () == discard)
+      return true;  // do not save and go ahead
 
-  if (ret == QMessageBox::Save)
-    {
-      if (do_import_export (OSC_EXPORT))
-        return true;  // go ahead
-    }
+    if (ret == QMessageBox::Save)
+      {
+        if (do_import_export (OSC_EXPORT))
+          return true;  // go ahead
+      }
 
-  return false; // abort the import
+    return false; // abort the import
+  }
 }
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -25,170 +25,176 @@ along with Octave; see the file COPYING.
 
 #include <QWidget>
 #include <QTreeWidget>
 #include <QLineEdit>
 #include <QKeyEvent>
 #include <QLabel>
 #include <QSettings>
 
-class enter_shortcut : public QLineEdit
+namespace octave
 {
-  Q_OBJECT
-
-public:
-
-  enter_shortcut (QWidget *p = nullptr);
+  class enter_shortcut : public QLineEdit
+  {
+    Q_OBJECT
 
-  ~enter_shortcut (void) = default;
-
-  virtual void keyPressEvent (QKeyEvent *e);
+  public:
 
-public slots:
-
-  void handle_direct_shortcut (int);
+    enter_shortcut (QWidget *p = nullptr);
 
-private:
+    ~enter_shortcut (void) = default;
 
-  bool m_direct_shortcut;
+    virtual void keyPressEvent (QKeyEvent *e);
 
-};
-
+  public slots:
 
-class shortcut_manager : public QWidget
-{
-  Q_OBJECT
-
-public:
+    void handle_direct_shortcut (int);
 
-  enum
-  {
-    OSC_IMPORT  = 0,
-    OSC_EXPORT  = 1,
-    OSC_DEFAULT = 2
+  private:
+
+    bool m_direct_shortcut;
+
   };
 
-  shortcut_manager (void);
-
-  // No copying!
-
-  shortcut_manager (const shortcut_manager&) = delete;
-
-  shortcut_manager& operator = (const shortcut_manager&) = delete;
-
-  ~shortcut_manager (void) = default;
-
-  static void init_data (void)
+  class shortcut_manager : public QWidget
   {
-    if (instance_ok ())
-      instance->do_init_data ();
-  }
-
-  static void write_shortcuts (QSettings *settings, bool closing)
-  {
-    if (instance_ok ())
-      instance->do_write_shortcuts (settings, closing);
-  }
-
-  static void set_shortcut (QAction *action, const QString& key)
-  {
-    if (instance_ok ())
-      instance->do_set_shortcut (action, key);
-  }
-
-  static void fill_treewidget (QTreeWidget *tree_view)
-  {
-    if (instance_ok ())
-      instance->do_fill_treewidget (tree_view);
-  }
+    Q_OBJECT
 
-  static void import_export (int action)
-  {
-    if (instance_ok ())
-      instance->do_import_export (action);
-  }
-
-  static shortcut_manager *instance;
-
-public slots:
-
-  static void cleanup_instance (void) { delete instance; instance = nullptr; }
-
-protected slots:
-
-  void handle_double_clicked (QTreeWidgetItem*, int);
-  void shortcut_dialog_finished (int);
-  void shortcut_dialog_set_default ();
-
-private:
-
-  static bool instance_ok (void);
-
-  void init (const QString&, const QString&, const QKeySequence&);
-  void do_init_data ();
-  void do_write_shortcuts (QSettings *settings, bool closing);
-  void do_set_shortcut (QAction *action, const QString& key);
-  void do_fill_treewidget (QTreeWidget *tree_view);
-  bool do_import_export (int action);
-  void shortcut_dialog (int);
-  void import_shortcuts (QSettings *settings);
-  bool overwrite_all_shortcuts (void);
-
-  class shortcut_t
-  {
   public:
 
-    shortcut_t (void)
-      : m_tree_item (nullptr), m_description (), m_settings_key (),
-        m_actual_sc (QKeySequence ()), m_default_sc (QKeySequence ())
-    { }
+    enum
+      {
+        OSC_IMPORT  = 0,
+        OSC_EXPORT  = 1,
+        OSC_DEFAULT = 2
+      };
+
+    shortcut_manager (void);
+
+    // No copying!
+
+    shortcut_manager (const shortcut_manager&) = delete;
+
+    shortcut_manager& operator = (const shortcut_manager&) = delete;
+
+    ~shortcut_manager (void) = default;
+
+    static void init_data (void)
+    {
+      if (instance_ok ())
+        instance->do_init_data ();
+    }
 
-    shortcut_t (const shortcut_t& x)
-      : m_tree_item (x.m_tree_item), m_description (x.m_description),
-        m_settings_key (x.m_settings_key)
+    static void write_shortcuts (QSettings *settings, bool closing)
+    {
+      if (instance_ok ())
+        instance->do_write_shortcuts (settings, closing);
+    }
+
+    static void set_shortcut (QAction *action, const QString& key)
     {
-      m_actual_sc = x.m_actual_sc;
-      m_default_sc = x.m_default_sc;
+      if (instance_ok ())
+        instance->do_set_shortcut (action, key);
+    }
+
+    static void fill_treewidget (QTreeWidget *tree_view)
+    {
+      if (instance_ok ())
+        instance->do_fill_treewidget (tree_view);
+    }
+
+    static void import_export (int action)
+    {
+      if (instance_ok ())
+        instance->do_import_export (action);
     }
 
-    shortcut_t& operator = (const shortcut_t& x)
-    {
-      if (&x != this)
-        {
-          m_tree_item = x.m_tree_item;
-          m_description = x.m_description;
-          m_settings_key = x.m_settings_key;
+    static shortcut_manager *instance;
+
+  public slots:
+
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
+
+  protected slots:
+
+    void handle_double_clicked (QTreeWidgetItem*, int);
+    void shortcut_dialog_finished (int);
+    void shortcut_dialog_set_default ();
+
+  private:
+
+    static bool instance_ok (void);
 
-          m_actual_sc = QKeySequence ();
-          m_default_sc = QKeySequence ();
+    void init (const QString&, const QString&, const QKeySequence&);
+    void do_init_data ();
+    void do_write_shortcuts (QSettings *settings, bool closing);
+    void do_set_shortcut (QAction *action, const QString& key);
+    void do_fill_treewidget (QTreeWidget *tree_view);
+    bool do_import_export (int action);
+    void shortcut_dialog (int);
+    void import_shortcuts (QSettings *settings);
+    bool overwrite_all_shortcuts (void);
 
-          m_actual_sc = x.m_actual_sc;
-          m_default_sc = x.m_default_sc;
-        }
+    class shortcut_t
+    {
+    public:
 
-      return *this;
-    }
+      shortcut_t (void)
+        : m_tree_item (nullptr), m_description (), m_settings_key (),
+          m_actual_sc (QKeySequence ()), m_default_sc (QKeySequence ())
+      { }
 
-    ~shortcut_t (void) = default;
+      shortcut_t (const shortcut_t& x)
+        : m_tree_item (x.m_tree_item), m_description (x.m_description),
+          m_settings_key (x.m_settings_key)
+      {
+        m_actual_sc = x.m_actual_sc;
+        m_default_sc = x.m_default_sc;
+      }
 
-    QTreeWidgetItem *m_tree_item;
-    QString m_description;
-    QString m_settings_key;
-    QKeySequence m_actual_sc;
-    QKeySequence m_default_sc;
-  };
+      shortcut_t& operator = (const shortcut_t& x)
+      {
+        if (&x != this)
+          {
+            m_tree_item = x.m_tree_item;
+            m_description = x.m_description;
+            m_settings_key = x.m_settings_key;
+
+            m_actual_sc = QKeySequence ();
+            m_default_sc = QKeySequence ();
+
+            m_actual_sc = x.m_actual_sc;
+            m_default_sc = x.m_default_sc;
+          }
+
+        return *this;
+      }
+
+      ~shortcut_t (void) = default;
 
-  QList<shortcut_t> m_sc;
-  QHash<QString, int> m_shortcut_hash;
-  QHash<QString, int> m_action_hash;
-  QHash <QString, QTreeWidgetItem*> m_level_hash;
-  QHash<int, QTreeWidgetItem*> m_index_item_hash;
-  QHash<QTreeWidgetItem*, int> m_item_index_hash;
+      QTreeWidgetItem *m_tree_item;
+      QString m_description;
+      QString m_settings_key;
+      QKeySequence m_actual_sc;
+      QKeySequence m_default_sc;
+    };
 
-  QDialog *m_dialog;
-  enter_shortcut *m_edit_actual;
-  QLabel *m_label_default;
-  int m_handled_index;
+    QList<shortcut_t> m_sc;
+    QHash<QString, int> m_shortcut_hash;
+    QHash<QString, int> m_action_hash;
+    QHash <QString, QTreeWidgetItem*> m_level_hash;
+    QHash<int, QTreeWidgetItem*> m_index_item_hash;
+    QHash<QTreeWidgetItem*, int> m_item_index_hash;
 
-  QSettings *m_settings;
-};
+    QDialog *m_dialog;
+    enter_shortcut *m_edit_actual;
+    QLabel *m_label_default;
+    int m_handled_index;
+
+    QSettings *m_settings;
+  };
+}
+
+// FIXME: This is temporary and should be removed when all classes that
+// use the shortcut_manager class are also inside the octave namespace.
+using octave::shortcut_manager;
 
 #endif
diff --git a/libgui/src/tab-bar.cc b/libgui/src/tab-bar.cc
--- a/libgui/src/tab-bar.cc
+++ b/libgui/src/tab-bar.cc
@@ -20,97 +20,98 @@ along with Octave; see the file COPYING.
 
 */
 
 // This file implements a tab bar derived from QTabBar with a contextmenu
 // and possibility to close a tab via double-left and middle mouse click.
 
 #include "tab-bar.h"
 
-
-tab_bar::tab_bar (QWidget *p)
-  : QTabBar (p), m_context_menu (new QMenu (this))
-{ }
-
-tab_bar::~tab_bar (void)
-{
-  delete m_context_menu;
-}
-
-// Reimplement mouse event for filtering out the desired mouse clicks
-void
-tab_bar::mousePressEvent (QMouseEvent *me)
+namespace octave
 {
-  QPoint click_pos;
-  int clicked_idx = -1;
+  tab_bar::tab_bar (QWidget *p)
+    : QTabBar (p), m_context_menu (new QMenu (this))
+  { }
+
+  tab_bar::~tab_bar (void)
+  {
+    delete m_context_menu;
+  }
 
-  // detect the tab where the click occured
-  for (int i = 0; i < count (); i++)
-    {
-      click_pos = mapToGlobal (me->pos ());
-      if (tabRect (i).contains (mapFromGlobal (click_pos)))
-        {
-          clicked_idx = i;
-          break;
-        }
-    }
+  // Reimplement mouse event for filtering out the desired mouse clicks
+  void tab_bar::mousePressEvent (QMouseEvent *me)
+  {
+    QPoint click_pos;
+    int clicked_idx = -1;
+
+    // detect the tab where the click occured
+    for (int i = 0; i < count (); i++)
+      {
+        click_pos = mapToGlobal (me->pos ());
+        if (tabRect (i).contains (mapFromGlobal (click_pos)))
+          {
+            clicked_idx = i;
+            break;
+          }
+      }
 
-  // If a tab was clicked
-  if (clicked_idx >= 0)
-    {
-      int current_idx = currentIndex ();
-      // detect the mouse click
-      if ((me->type () == QEvent::MouseButtonDblClick &&
-           me->button() == Qt::LeftButton) ||
-          (me->type () != QEvent::MouseButtonDblClick &&
-           me->button() == Qt::MidButton))
-        {
-          // Middle click or double click -> close the tab
-          // Make the clicked tab the current one and close it
-          setCurrentIndex (clicked_idx);
-          emit close_current_tab_signal (true);
-          // Was the closed tab before or after the previously current tab?
-          // According to the result, use previous index or reduce it by one
-          if (current_idx - clicked_idx > 0)
-            setCurrentIndex (current_idx - 1);
-          else if (current_idx - clicked_idx < 0)
-            setCurrentIndex (current_idx);
-        }
-      else if (me->type () != QEvent::MouseButtonDblClick &&
-               me->button() == Qt::RightButton)
-        {
-          // Right click, show context menu
-          setCurrentIndex (clicked_idx);
-          if (! m_context_menu->exec (click_pos))
-            {
-              // No action selected, back to previous tab
+    // If a tab was clicked
+    if (clicked_idx >= 0)
+      {
+        int current_idx = currentIndex ();
+        // detect the mouse click
+        if ((me->type () == QEvent::MouseButtonDblClick &&
+             me->button() == Qt::LeftButton) ||
+            (me->type () != QEvent::MouseButtonDblClick &&
+             me->button() == Qt::MidButton))
+          {
+            // Middle click or double click -> close the tab
+            // Make the clicked tab the current one and close it
+            setCurrentIndex (clicked_idx);
+            emit close_current_tab_signal (true);
+            // Was the closed tab before or after the previously current tab?
+            // According to the result, use previous index or reduce it by one
+            if (current_idx - clicked_idx > 0)
+              setCurrentIndex (current_idx - 1);
+            else if (current_idx - clicked_idx < 0)
               setCurrentIndex (current_idx);
-            }
-          else
-            {
-              // Was the possibly only closed tab before or after the
-              // previously current tab? According to the result, use previous
-              // index or reduce it by one. Also prevent using a too large
-              // if other or all files were closed.
-              int new_idx = count () - 1;
-              if (new_idx > 0)
-                {
-                  if (current_idx - clicked_idx > 0)
-                    new_idx = current_idx - 1;
-                  else if (current_idx - clicked_idx < 0)
-                    new_idx = current_idx;
-                }
-              if (new_idx >= 0)
-                setCurrentIndex (new_idx);
-            }
-        }
-      else
-        {
-          // regular handling of the mouse event
-          QTabBar::mousePressEvent (me);
-        }
-    }
-  else
-    {
-      // regular handling of the mouse event
-      QTabBar::mousePressEvent (me);
-    }
+          }
+        else if (me->type () != QEvent::MouseButtonDblClick &&
+                 me->button() == Qt::RightButton)
+          {
+            // Right click, show context menu
+            setCurrentIndex (clicked_idx);
+            if (! m_context_menu->exec (click_pos))
+              {
+                // No action selected, back to previous tab
+                setCurrentIndex (current_idx);
+              }
+            else
+              {
+                // Was the possibly only closed tab before or after the
+                // previously current tab? According to the result, use previous
+                // index or reduce it by one. Also prevent using a too large
+                // if other or all files were closed.
+                int new_idx = count () - 1;
+                if (new_idx > 0)
+                  {
+                    if (current_idx - clicked_idx > 0)
+                      new_idx = current_idx - 1;
+                    else if (current_idx - clicked_idx < 0)
+                      new_idx = current_idx;
+                  }
+                if (new_idx >= 0)
+                  setCurrentIndex (new_idx);
+              }
+          }
+        else
+          {
+            // regular handling of the mouse event
+            QTabBar::mousePressEvent (me);
+          }
+      }
+    else
+      {
+        // regular handling of the mouse event
+        QTabBar::mousePressEvent (me);
+      }
+  }
 }
diff --git a/libgui/src/tab-bar.h b/libgui/src/tab-bar.h
--- a/libgui/src/tab-bar.h
+++ b/libgui/src/tab-bar.h
@@ -25,36 +25,43 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_tab_bar_h)
 #define octave_tab_bar_h 1
 
 #include <QMenu>
 #include <QTabBar>
 #include <QMouseEvent>
 
-// Subclassed QTabBar for usable tab-bar and reimplemented mouse event
+namespace octave
+{
+  // Subclassed QTabBar for usable tab-bar and reimplemented mouse event
 
-class tab_bar : public QTabBar
-{
-  Q_OBJECT
+  class tab_bar : public QTabBar
+  {
+    Q_OBJECT
 
-public:
+  public:
+
+    tab_bar (QWidget *p);
 
-  tab_bar (QWidget *p);
+    ~tab_bar (void);
 
-  ~tab_bar (void);
+    QMenu *get_context_menu (void) { return m_context_menu; };
 
-  QMenu *get_context_menu (void) { return m_context_menu; };
+  signals:
+
+    void close_current_tab_signal (bool);
 
-signals:
+  protected:
 
-  void close_current_tab_signal (bool);
+    void mousePressEvent(QMouseEvent *event);
 
-protected:
-
-  void mousePressEvent(QMouseEvent *event);
+  private:
 
-private:
+    QMenu *m_context_menu;
+  };
+}
 
-  QMenu *m_context_menu;
-};
+// FIXME: This is temporary and should be removed when all classes that
+// use the tab_bar class are also inside the octave namespace.
+using octave::tab_bar;
 
 #endif
diff --git a/libgui/src/thread-manager.cc b/libgui/src/thread-manager.cc
--- a/libgui/src/thread-manager.cc
+++ b/libgui/src/thread-manager.cc
@@ -29,95 +29,95 @@ along with Octave; see the file COPYING.
 #else
 #  include <pthread.h>
 #endif
 
 #include "signal-wrappers.h"
 
 #include "thread-manager.h"
 
+namespace octave
+{
 #if defined (OCTAVE_USE_WINDOWS_API)
 
-class windows_thread_manager : public octave_base_thread_manager
-{
-public:
+  class windows_thread_manager : public base_thread_manager
+  {
+  public:
 
-  windows_thread_manager (void) : octave_base_thread_manager () { }
+    windows_thread_manager (void) : base_thread_manager () { }
 
-  void register_current_thread (void) { }
+    void register_current_thread (void) { }
 
-  void interrupt (void)
-  {
-    GenerateConsoleCtrlEvent (CTRL_C_EVENT, 0);
-  }
-};
+    void interrupt (void)
+    {
+      GenerateConsoleCtrlEvent (CTRL_C_EVENT, 0);
+    }
+  };
 
 #else
 
-class pthread_thread_manager : public octave_base_thread_manager
-{
-public:
-
-  pthread_thread_manager (void)
-    : octave_base_thread_manager (), m_my_thread (), m_initialized (false)
-  { }
-
-  void register_current_thread (void)
+  class pthread_thread_manager : public base_thread_manager
   {
-    m_my_thread = pthread_self ();
-    m_initialized = true;
-  }
+  public:
+
+    pthread_thread_manager (void)
+      : base_thread_manager (), m_my_thread (), m_initialized (false)
+    { }
 
-  void interrupt (void)
-  {
-    if (m_initialized)
-      {
-        // Send SIGINT to all other processes in our process group.
-        // This is needed to interrupt calls to system (), for example.
+    void register_current_thread (void)
+    {
+      m_my_thread = pthread_self ();
+      m_initialized = true;
+    }
+
+    void interrupt (void)
+    {
+      if (m_initialized)
+        {
+          // Send SIGINT to all other processes in our process group.
+          // This is needed to interrupt calls to system (), for example.
 
-        // FIXME: What happens if some code inside a
-        // {BEGIN,END}_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE block starts
-        // additional threads and one of those happens to catch this signal?
-        // Would the interrupt handler and the subsequent longjmp and exception
-        // all be executed in the wrong thread?  If so, is there any way to
-        // prevent that from happening?
+          // FIXME: What happens if some code inside a
+          // {BEGIN,END}_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE block starts
+          // additional threads and one of those happens to catch this signal?
+          // Would the interrupt handler and the subsequent longjmp and exception
+          // all be executed in the wrong thread?  If so, is there any way to
+          // prevent that from happening?
 
-        int sigint;
-        octave_get_sig_number ("SIGINT", &sigint);
+          int sigint;
+          octave_get_sig_number ("SIGINT", &sigint);
 
-        octave_kill_wrapper (0, sigint);
-      }
-  }
+          octave_kill_wrapper (0, sigint);
+        }
+    }
 
-private:
+  private:
 
-  pthread_t m_my_thread;
+    pthread_t m_my_thread;
 
-  bool m_initialized;
-};
+    bool m_initialized;
+  };
 
 #endif
 
-octave_thread_manager::octave_thread_manager (void)
-  : m_rep (octave_thread_manager::create_rep ())
-{ }
+  thread_manager::thread_manager (void)
+    : m_rep (thread_manager::create_rep ())
+  { }
 
-void
-octave_thread_manager::block_interrupt_signal (void)
-{
-  octave_block_interrupt_signal ();
-}
+  void thread_manager::block_interrupt_signal (void)
+  {
+    octave_block_interrupt_signal ();
+  }
 
-void
-octave_thread_manager::unblock_interrupt_signal (void)
-{
-  octave_unblock_interrupt_signal ();
-}
+  void thread_manager::unblock_interrupt_signal (void)
+  {
+    octave_unblock_interrupt_signal ();
+  }
 
-octave_base_thread_manager *
-octave_thread_manager::create_rep (void)
-{
+  base_thread_manager * thread_manager::create_rep (void)
+  {
 #if defined (OCTAVE_USE_WINDOWS_API)
-  return new windows_thread_manager ();
+    return new windows_thread_manager ();
 #else
-  return new pthread_thread_manager ();
+    return new pthread_thread_manager ();
 #endif
+  }
 }
diff --git a/libgui/src/thread-manager.h b/libgui/src/thread-manager.h
--- a/libgui/src/thread-manager.h
+++ b/libgui/src/thread-manager.h
@@ -22,53 +22,56 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_thread_manager_h)
 #define octave_thread_manager_h 1
 
 #include "octave-config.h"
 
 #include <memory>
 
-class octave_base_thread_manager
+namespace octave
 {
-public:
+  class base_thread_manager
+  {
+  public:
 
-  friend class octave_thread_manager;
+    friend class thread_manager;
 
-  octave_base_thread_manager (void) = default;
-
-  octave_base_thread_manager (const octave_base_thread_manager&) = default;
+    base_thread_manager (void) = default;
 
-  virtual ~octave_base_thread_manager (void) = default;
+    base_thread_manager (const base_thread_manager&) = default;
 
-  virtual void register_current_thread (void) = 0;
+    virtual ~base_thread_manager (void) = default;
+
+    virtual void register_current_thread (void) = 0;
 
-  virtual void interrupt (void) = 0;
-};
+    virtual void interrupt (void) = 0;
+  };
 
-class octave_thread_manager
-{
-public:
+  class thread_manager
+  {
+  public:
 
-  octave_thread_manager (void);
+    thread_manager (void);
 
-  ~octave_thread_manager (void) = default;
+    ~thread_manager (void) = default;
+
+    thread_manager (const thread_manager& tm) = default;
 
-  octave_thread_manager (const octave_thread_manager& tm) = default;
+    thread_manager& operator = (const thread_manager& tm) = default;
 
-  octave_thread_manager& operator = (const octave_thread_manager& tm) = default;
+    void register_current_thread (void) { m_rep->register_current_thread (); }
 
-  void register_current_thread (void) { m_rep->register_current_thread (); }
+    void interrupt (void) { m_rep->interrupt (); }
 
-  void interrupt (void) { m_rep->interrupt (); }
+    static void block_interrupt_signal (void);
 
-  static void block_interrupt_signal (void);
+    static void unblock_interrupt_signal (void);
 
-  static void unblock_interrupt_signal (void);
+  private:
 
-private:
+    std::shared_ptr<base_thread_manager> m_rep;
 
-  std::shared_ptr<octave_base_thread_manager> m_rep;
-
-  static octave_base_thread_manager * create_rep (void);
-};
+    static base_thread_manager * create_rep (void);
+  };
+}
 
 #endif
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -42,307 +42,305 @@ static QLabel *
 make_octave_logo (QWidget *p = nullptr, int height = 100)
 {
   QLabel *logo = new QLabel (p);
   QPixmap logo_pixmap (":/actions/icons/logo.png");
   logo->setPixmap (logo_pixmap.scaledToHeight (height));
   return logo;
 };
 
-welcome_wizard::welcome_wizard (QWidget *p)
-  : QDialog (p), m_page_ctor_list (), m_page_list_iterator (),
-    m_current_page (initial_page::create (this)),
-    m_allow_web_connect_state (false)
+namespace octave
 {
-  m_page_ctor_list.push_back (initial_page::create);
-  m_page_ctor_list.push_back (setup_community_news::create);
-  m_page_ctor_list.push_back (final_page::create);
+  welcome_wizard::welcome_wizard (QWidget *p)
+    : QDialog (p), m_page_ctor_list (), m_page_list_iterator (),
+      m_current_page (initial_page::create (this)),
+      m_allow_web_connect_state (false)
+  {
+    m_page_ctor_list.push_back (initial_page::create);
+    m_page_ctor_list.push_back (setup_community_news::create);
+    m_page_ctor_list.push_back (final_page::create);
 
-  m_page_list_iterator = m_page_ctor_list.begin ();
+    m_page_list_iterator = m_page_ctor_list.begin ();
 
-  setWindowTitle (tr ("Welcome to GNU Octave"));
+    setWindowTitle (tr ("Welcome to GNU Octave"));
 
-  setEnabled (true);
-  resize (600, 480);
-  setMinimumSize (QSize (600, 480));
+    setEnabled (true);
+    resize (600, 480);
+    setMinimumSize (QSize (600, 480));
 
-  show_page ();
+    show_page ();
 
 #if defined (OCTAVE_USE_WINDOWS_API)
-  // HACK to forceshow of dialog if started minimized
-  ShowWindow (reinterpret_cast<HWND> (winId ()), SW_SHOWNORMAL);
+    // HACK to forceshow of dialog if started minimized
+    ShowWindow (reinterpret_cast<HWND> (winId ()), SW_SHOWNORMAL);
 #endif
-}
+  }
 
-void
-welcome_wizard::handle_web_connect_option (int state)
-{
-  m_allow_web_connect_state = state == Qt::Checked;
-}
+  void welcome_wizard::handle_web_connect_option (int state)
+  {
+    m_allow_web_connect_state = state == Qt::Checked;
+  }
+
+  void welcome_wizard::show_page (void)
+  {
+    delete m_current_page;
+    delete layout ();
+
+    m_current_page = (*m_page_list_iterator) (this);
 
-void
-welcome_wizard::show_page (void)
-{
-  delete m_current_page;
-  delete layout ();
+    QVBoxLayout *new_layout = new QVBoxLayout ();
+    setLayout (new_layout);
 
-  m_current_page = (*m_page_list_iterator) (this);
+    new_layout->addWidget (m_current_page);
+  }
 
-  QVBoxLayout *new_layout = new QVBoxLayout ();
-  setLayout (new_layout);
+  void welcome_wizard::previous_page (void)
+  {
+    --m_page_list_iterator;
 
-  new_layout->addWidget (m_current_page);
-}
+    show_page ();
+  }
 
-void
-welcome_wizard::previous_page (void)
-{
-  --m_page_list_iterator;
+  void welcome_wizard::next_page (void)
+  {
+    ++m_page_list_iterator;
 
-  show_page ();
-}
+    show_page ();
+  }
+
+  void welcome_wizard::accept (void)
+  {
+    // Create default settings file.
 
-void
-welcome_wizard::next_page (void)
-{
-  ++m_page_list_iterator;
+    resource_manager::reload_settings ();
+
+    QSettings *settings = resource_manager::get_settings ();
 
-  show_page ();
-}
+    if (settings)
+      {
+        settings->setValue ("news/allow_web_connection",
+                            m_allow_web_connect_state);
 
-void
-welcome_wizard::accept (void)
-{
-  // Create default settings file.
+        settings->sync ();
+      }
 
-  resource_manager::reload_settings ();
-
-  QSettings *settings = resource_manager::get_settings ();
+    QDialog::accept ();
+  }
 
-  if (settings)
-    {
-      settings->setValue ("news/allow_web_connection",
-                          m_allow_web_connect_state);
-
-      settings->sync ();
-    }
-
-  QDialog::accept ();
-}
+  initial_page::initial_page (welcome_wizard *wizard)
+    : QWidget (wizard),
+      m_title (new QLabel (tr ("Welcome to Octave!"), this)),
+      m_message (new QLabel (this)),
+      m_logo (make_octave_logo (this)),
+      m_next (new QPushButton (tr ("Next"), this)),
+      m_cancel (new QPushButton (tr ("Cancel"), this))
+  {
+    QFont ft;
+    ft.setPointSize (20);
+    m_title->setFont (ft);
 
-initial_page::initial_page (welcome_wizard *wizard)
-  : QWidget (wizard),
-    m_title (new QLabel (tr ("Welcome to Octave!"), this)),
-    m_message (new QLabel (this)),
-    m_logo (make_octave_logo (this)),
-    m_next (new QPushButton (tr ("Next"), this)),
-    m_cancel (new QPushButton (tr ("Cancel"), this))
-{
-  QFont ft;
-  ft.setPointSize (20);
-  m_title->setFont (ft);
+    m_message->setText
+      (tr ("<html><body>\n"
+           "<p>You seem to be using the Octave graphical interface for the first time on this computer.\n"
+           "Click 'Next' to create a configuration file and launch Octave.</p>\n"
+           "<p>The configuration file is stored in<br>%1.</p>\n"
+           "</body></html>").
+       arg (resource_manager::get_settings_file ()));
+    m_message->setWordWrap (true);
+    m_message->setMinimumWidth (400);
+
+    QVBoxLayout *message_layout = new QVBoxLayout;
+
+    message_layout->addWidget (m_title);
+    message_layout->addWidget (m_message);
+
+    QHBoxLayout *message_and_logo = new QHBoxLayout;
 
-  m_message->setText
-  (tr ("<html><body>\n"
-       "<p>You seem to be using the Octave graphical interface for the first time on this computer.\n"
-       "Click 'Next' to create a configuration file and launch Octave.</p>\n"
-       "<p>The configuration file is stored in<br>%1.</p>\n"
-       "</body></html>").
-   arg (resource_manager::get_settings_file ()));
-  m_message->setWordWrap (true);
-  m_message->setMinimumWidth (400);
+    message_and_logo->addLayout (message_layout);
+    message_and_logo->addStretch (10);
+    message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
 
-  QVBoxLayout *message_layout = new QVBoxLayout;
+    QHBoxLayout *button_bar = new QHBoxLayout;
 
-  message_layout->addWidget (m_title);
-  message_layout->addWidget (m_message);
-
-  QHBoxLayout *message_and_logo = new QHBoxLayout;
+    button_bar->addStretch (10);
+    button_bar->addWidget (m_next);
+    button_bar->addWidget (m_cancel);
 
-  message_and_logo->addLayout (message_layout);
-  message_and_logo->addStretch (10);
-  message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
+    QVBoxLayout *page_layout = new QVBoxLayout (this);
+    setLayout (page_layout);
 
-  QHBoxLayout *button_bar = new QHBoxLayout;
-
-  button_bar->addStretch (10);
-  button_bar->addWidget (m_next);
-  button_bar->addWidget (m_cancel);
+    page_layout->addLayout (message_and_logo);
+    page_layout->addStretch (10);
+    page_layout->addLayout (button_bar);
 
-  QVBoxLayout *page_layout = new QVBoxLayout (this);
-  setLayout (page_layout);
-
-  page_layout->addLayout (message_and_logo);
-  page_layout->addStretch (10);
-  page_layout->addLayout (button_bar);
+    m_next->setDefault (true);
+    m_next->setFocus ();
 
-  m_next->setDefault (true);
-  m_next->setFocus ();
-
-  connect (m_next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
-  connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-}
+    connect (m_next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
+    connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+  }
 
-setup_community_news::setup_community_news (welcome_wizard *wizard)
-  : QWidget (wizard),
-    m_title (new QLabel (tr ("Community News"), this)),
-    m_message (new QLabel (this)),
-    m_checkbox (new QCheckBox (this)),
-    m_checkbox_message (new QLabel (this)),
-    m_logo (make_octave_logo (this)),
-    m_previous (new QPushButton (tr ("Previous"), this)),
-    m_next (new QPushButton (tr ("Next"), this)),
-    m_cancel (new QPushButton (tr ("Cancel"), this))
-{
-  QFont ft;
-  ft.setPointSize (20);
-  m_title->setFont (ft);
+  setup_community_news::setup_community_news (welcome_wizard *wizard)
+    : QWidget (wizard),
+      m_title (new QLabel (tr ("Community News"), this)),
+      m_message (new QLabel (this)),
+      m_checkbox (new QCheckBox (this)),
+      m_checkbox_message (new QLabel (this)),
+      m_logo (make_octave_logo (this)),
+      m_previous (new QPushButton (tr ("Previous"), this)),
+      m_next (new QPushButton (tr ("Next"), this)),
+      m_cancel (new QPushButton (tr ("Cancel"), this))
+  {
+    QFont ft;
+    ft.setPointSize (20);
+    m_title->setFont (ft);
 
-  m_message->setText
-  (tr ("<html><body>\n"
-       "<p>When Octave starts, it will optionally check the Octave web site for current news and information about the Octave community.\n"
-       "The check will happen at most once each day and news will only be displayed if there is something new since the last time you viewed the news.</p>\n"
-       "<p>You may also view the news by selecting the \"Community News\" item in the \"Help\" menu, or by visiting\n"
-       "<a href=\"http://octave.org/community-news.html\">http://octave.org/community-news.html</a>.</p>\n"
-       "</body></html>"));
-  m_message->setWordWrap (true);
-  m_message->setMinimumWidth (400);
-  m_message->setOpenExternalLinks (true);
+    m_message->setText
+      (tr ("<html><body>\n"
+           "<p>When Octave starts, it will optionally check the Octave web site for current news and information about the Octave community.\n"
+           "The check will happen at most once each day and news will only be displayed if there is something new since the last time you viewed the news.</p>\n"
+           "<p>You may also view the news by selecting the \"Community News\" item in the \"Help\" menu, or by visiting\n"
+           "<a href=\"http://octave.org/community-news.html\">http://octave.org/community-news.html</a>.</p>\n"
+           "</body></html>"));
+    m_message->setWordWrap (true);
+    m_message->setMinimumWidth (400);
+    m_message->setOpenExternalLinks (true);
+
+    QVBoxLayout *message_layout = new QVBoxLayout;
 
-  QVBoxLayout *message_layout = new QVBoxLayout;
+    message_layout->addWidget (m_title);
+    message_layout->addWidget (m_message);
 
-  message_layout->addWidget (m_title);
-  message_layout->addWidget (m_message);
+    QHBoxLayout *message_and_logo = new QHBoxLayout;
 
-  QHBoxLayout *message_and_logo = new QHBoxLayout;
+    message_and_logo->addLayout (message_layout);
+    message_and_logo->addStretch (10);
+    message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
 
-  message_and_logo->addLayout (message_layout);
-  message_and_logo->addStretch (10);
-  message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
-
-  QHBoxLayout *checkbox_layout = new QHBoxLayout;
+    QHBoxLayout *checkbox_layout = new QHBoxLayout;
 
-  // FIXME: Synchronize the initial state of this checkbox with the default
-  // value of "news/allow_web_connection" stored elsewhere.
-  m_checkbox->setCheckState (Qt::Unchecked);
+    // FIXME: Synchronize the initial state of this checkbox with the default
+    // value of "news/allow_web_connection" stored elsewhere.
+    m_checkbox->setCheckState (Qt::Unchecked);
 
-  m_checkbox_message->setText
-  (tr ("<html><head>\n"
-       "<style>\n"
-       "a:link { text-decoration: underline; color: #0000ff; }\n"
-       "</style>\n"
-       "<head/><body>\n"
-       "<p>Allow Octave to connect to the Octave web site when it starts to display current news and information about the Octave community.</p>\n"
-       "</body></html>"));
-  m_checkbox_message->setWordWrap (true);
-  m_checkbox_message->setOpenExternalLinks (true);
-  m_checkbox_message->setMinimumWidth (500);
+    m_checkbox_message->setText
+      (tr ("<html><head>\n"
+           "<style>\n"
+           "a:link { text-decoration: underline; color: #0000ff; }\n"
+           "</style>\n"
+           "<head/><body>\n"
+           "<p>Allow Octave to connect to the Octave web site when it starts to display current news and information about the Octave community.</p>\n"
+           "</body></html>"));
+    m_checkbox_message->setWordWrap (true);
+    m_checkbox_message->setOpenExternalLinks (true);
+    m_checkbox_message->setMinimumWidth (500);
 
-  checkbox_layout->addWidget (m_checkbox, 0, Qt::AlignTop);
-  checkbox_layout->addSpacing (20);
-  checkbox_layout->addWidget (m_checkbox_message, 0, Qt::AlignTop);
-  checkbox_layout->addStretch (10);
+    checkbox_layout->addWidget (m_checkbox, 0, Qt::AlignTop);
+    checkbox_layout->addSpacing (20);
+    checkbox_layout->addWidget (m_checkbox_message, 0, Qt::AlignTop);
+    checkbox_layout->addStretch (10);
 
-  QVBoxLayout *message_logo_and_checkbox = new QVBoxLayout;
+    QVBoxLayout *message_logo_and_checkbox = new QVBoxLayout;
 
-  message_logo_and_checkbox->addLayout (message_and_logo);
-  message_logo_and_checkbox->addSpacing (20);
-  message_logo_and_checkbox->addLayout (checkbox_layout);
+    message_logo_and_checkbox->addLayout (message_and_logo);
+    message_logo_and_checkbox->addSpacing (20);
+    message_logo_and_checkbox->addLayout (checkbox_layout);
 
-  QHBoxLayout *button_bar = new QHBoxLayout;
+    QHBoxLayout *button_bar = new QHBoxLayout;
 
-  button_bar->addStretch (10);
-  button_bar->addWidget (m_previous);
-  button_bar->addWidget (m_next);
-  button_bar->addWidget (m_cancel);
+    button_bar->addStretch (10);
+    button_bar->addWidget (m_previous);
+    button_bar->addWidget (m_next);
+    button_bar->addWidget (m_cancel);
 
-  QVBoxLayout *page_layout = new QVBoxLayout (this);
-  setLayout (page_layout);
+    QVBoxLayout *page_layout = new QVBoxLayout (this);
+    setLayout (page_layout);
 
-  page_layout->addLayout (message_logo_and_checkbox);
-  page_layout->addStretch (10);
-  page_layout->addLayout (button_bar);
+    page_layout->addLayout (message_logo_and_checkbox);
+    page_layout->addStretch (10);
+    page_layout->addLayout (button_bar);
 
-  m_next->setDefault (true);
-  m_next->setFocus ();
+    m_next->setDefault (true);
+    m_next->setFocus ();
 
-  connect (m_checkbox, SIGNAL (stateChanged (int)),
-           wizard, SLOT (handle_web_connect_option (int)));
+    connect (m_checkbox, SIGNAL (stateChanged (int)),
+             wizard, SLOT (handle_web_connect_option (int)));
 
-  connect (m_previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
-  connect (m_next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
-  connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-}
+    connect (m_previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
+    connect (m_next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
+    connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+  }
 
-final_page::final_page (welcome_wizard *wizard)
-  : QWidget (wizard),
-    m_title (new QLabel (tr ("Enjoy!"), this)),
-    m_message (new QLabel (this)),
-    m_logo (make_octave_logo (this)),
-    m_links (new QLabel (this)),
-    m_previous (new QPushButton (tr ("Previous"), this)),
-    m_finish (new QPushButton (tr ("Finish"), this)),
-    m_cancel (new QPushButton (tr ("Cancel"), this))
-{
-  QFont ft;
-  ft.setPointSize (20);
-  m_title->setFont (ft);
+  final_page::final_page (welcome_wizard *wizard)
+    : QWidget (wizard),
+      m_title (new QLabel (tr ("Enjoy!"), this)),
+      m_message (new QLabel (this)),
+      m_logo (make_octave_logo (this)),
+      m_links (new QLabel (this)),
+      m_previous (new QPushButton (tr ("Previous"), this)),
+      m_finish (new QPushButton (tr ("Finish"), this)),
+      m_cancel (new QPushButton (tr ("Cancel"), this))
+  {
+    QFont ft;
+    ft.setPointSize (20);
+    m_title->setFont (ft);
 
-  m_message->setText
-  (tr ("<html><body>\n"
-       "<p>We hope you find Octave to be a useful tool.</p>\n"
-       "<p>If you encounter problems, there are a number of ways to get help, including commercial support options, a mailing list, a wiki, and other community-based support channels.\n"
-       "You can find more information about each of these by visiting <a href=\"http://octave.org/support.html\">http://octave.org/support.html</a> (opens in external browser).</p>\n"
-       "</body></html>"));
-  m_message->setWordWrap (true);
-  m_message->setMinimumWidth (400);
-  m_message->setOpenExternalLinks (true);
+    m_message->setText
+      (tr ("<html><body>\n"
+           "<p>We hope you find Octave to be a useful tool.</p>\n"
+           "<p>If you encounter problems, there are a number of ways to get help, including commercial support options, a mailing list, a wiki, and other community-based support channels.\n"
+           "You can find more information about each of these by visiting <a href=\"http://octave.org/support.html\">http://octave.org/support.html</a> (opens in external browser).</p>\n"
+           "</body></html>"));
+    m_message->setWordWrap (true);
+    m_message->setMinimumWidth (400);
+    m_message->setOpenExternalLinks (true);
 
-  QVBoxLayout *message_layout = new QVBoxLayout;
+    QVBoxLayout *message_layout = new QVBoxLayout;
 
-  message_layout->addWidget (m_title);
-  message_layout->addWidget (m_message);
+    message_layout->addWidget (m_title);
+    message_layout->addWidget (m_message);
 
-  QHBoxLayout *message_and_logo = new QHBoxLayout;
+    QHBoxLayout *message_and_logo = new QHBoxLayout;
 
-  message_and_logo->addLayout (message_layout);
-  message_and_logo->addStretch (10);
-  message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
+    message_and_logo->addLayout (message_layout);
+    message_and_logo->addStretch (10);
+    message_and_logo->addWidget (m_logo, 0, Qt::AlignTop);
 
-  m_links->setText
-  (tr ("<html><head>\n"
-       "<style>\n"
-       "a:link { text-decoration: underline; color: #0000ff; }\n"
-       "</style>\n"
-       "<head/><body>\n"
-       "<p>For more information about Octave:</p>\n"
-       "<ul>\n"
-       "<li>Visit <a href=\"http://octave.org\">http://octave.org</a> (opens in external browser)</li>\n"
-       "<li>Get the documentation online as <a href=\"http://www.gnu.org/software/octave/doc/interpreter/index.html\">html</a>- or <a href=\"http://www.gnu.org/software/octave/octave.pdf\">pdf</span></a>-document (opens in external browser)</li>\n"
-       "<li>Open the documentation browser of the Octave GUI with the help menu</li>\n"
-       "</ul>\n"
-       "</body></html>"));
-  m_links->setWordWrap (true);
-  m_links->setOpenExternalLinks (true);
+    m_links->setText
+      (tr ("<html><head>\n"
+           "<style>\n"
+           "a:link { text-decoration: underline; color: #0000ff; }\n"
+           "</style>\n"
+           "<head/><body>\n"
+           "<p>For more information about Octave:</p>\n"
+           "<ul>\n"
+           "<li>Visit <a href=\"http://octave.org\">http://octave.org</a> (opens in external browser)</li>\n"
+           "<li>Get the documentation online as <a href=\"http://www.gnu.org/software/octave/doc/interpreter/index.html\">html</a>- or <a href=\"http://www.gnu.org/software/octave/octave.pdf\">pdf</span></a>-document (opens in external browser)</li>\n"
+           "<li>Open the documentation browser of the Octave GUI with the help menu</li>\n"
+           "</ul>\n"
+           "</body></html>"));
+    m_links->setWordWrap (true);
+    m_links->setOpenExternalLinks (true);
 
-  QHBoxLayout *button_bar = new QHBoxLayout;
+    QHBoxLayout *button_bar = new QHBoxLayout;
 
-  button_bar->addStretch (10);
-  button_bar->addWidget (m_previous);
-  button_bar->addWidget (m_finish);
-  button_bar->addWidget (m_cancel);
+    button_bar->addStretch (10);
+    button_bar->addWidget (m_previous);
+    button_bar->addWidget (m_finish);
+    button_bar->addWidget (m_cancel);
 
-  QVBoxLayout *page_layout = new QVBoxLayout (this);
-  setLayout (page_layout);
+    QVBoxLayout *page_layout = new QVBoxLayout (this);
+    setLayout (page_layout);
 
-  page_layout->addLayout (message_and_logo);
-  page_layout->addSpacing (20);
-  page_layout->addWidget (m_links);
-  page_layout->addStretch (10);
-  page_layout->addLayout (button_bar);
+    page_layout->addLayout (message_and_logo);
+    page_layout->addSpacing (20);
+    page_layout->addWidget (m_links);
+    page_layout->addStretch (10);
+    page_layout->addLayout (button_bar);
 
-  m_finish->setDefault (true);
-  m_finish->setFocus ();
+    m_finish->setDefault (true);
+    m_finish->setFocus ();
 
-  connect (m_previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
-  connect (m_finish, SIGNAL (clicked ()), wizard, SLOT (accept ()));
-  connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+    connect (m_previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
+    connect (m_finish, SIGNAL (clicked ()), wizard, SLOT (accept ()));
+    connect (m_cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+  }
 }
diff --git a/libgui/src/welcome-wizard.h b/libgui/src/welcome-wizard.h
--- a/libgui/src/welcome-wizard.h
+++ b/libgui/src/welcome-wizard.h
@@ -23,113 +23,116 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_welcome_wizard_h)
 #define octave_welcome_wizard_h 1
 
 #include <QDialog>
 #include <QCheckBox>
 #include <QLabel>
 
-class welcome_wizard : public QDialog
+namespace octave
 {
-  Q_OBJECT
+  class welcome_wizard : public QDialog
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  typedef QWidget *(*page_creator_fptr) (welcome_wizard *wizard);
+    typedef QWidget *(*page_creator_fptr) (welcome_wizard *wizard);
 
-  welcome_wizard (QWidget *parent = nullptr);
+    welcome_wizard (QWidget *parent = nullptr);
 
-  ~welcome_wizard (void) = default;
+    ~welcome_wizard (void) = default;
 
-private:
+  private:
 
-  QList<page_creator_fptr> m_page_ctor_list;
-  QList<page_creator_fptr>::iterator m_page_list_iterator;
-  QWidget *m_current_page;
-  bool m_allow_web_connect_state;
+    QList<page_creator_fptr> m_page_ctor_list;
+    QList<page_creator_fptr>::iterator m_page_list_iterator;
+    QWidget *m_current_page;
+    bool m_allow_web_connect_state;
 
-private slots:
+  private slots:
 
-  void handle_web_connect_option (int state);
+    void handle_web_connect_option (int state);
 
-  void show_page (void);
-  void previous_page (void);
-  void next_page (void);
+    void show_page (void);
+    void previous_page (void);
+    void next_page (void);
 
-  void accept (void);
-};
+    void accept (void);
+  };
 
 
-class initial_page : public QWidget
-{
-  Q_OBJECT
+  class initial_page : public QWidget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  initial_page (welcome_wizard *wizard);
+    initial_page (welcome_wizard *wizard);
 
-  ~initial_page (void) = default;
+    ~initial_page (void) = default;
 
-  static QWidget *
-  create (welcome_wizard *wizard) { return new initial_page (wizard); }
+    static QWidget *
+    create (welcome_wizard *wizard) { return new initial_page (wizard); }
 
-private:
+  private:
 
-  QLabel *m_title;
-  QLabel *m_message;
-  QLabel *m_logo;
-  QPushButton *m_next;
-  QPushButton *m_cancel;
-};
+    QLabel *m_title;
+    QLabel *m_message;
+    QLabel *m_logo;
+    QPushButton *m_next;
+    QPushButton *m_cancel;
+  };
 
 
-class setup_community_news : public QWidget
-{
-  Q_OBJECT
+  class setup_community_news : public QWidget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  setup_community_news (welcome_wizard *wizard);
+    setup_community_news (welcome_wizard *wizard);
 
-  ~setup_community_news (void) = default;
+    ~setup_community_news (void) = default;
 
-  static QWidget *
-  create (welcome_wizard *wizard) { return new setup_community_news (wizard); }
+    static QWidget *
+    create (welcome_wizard *wizard) { return new setup_community_news (wizard); }
 
-private:
+  private:
 
-  QLabel *m_title;
-  QLabel *m_message;
-  QCheckBox *m_checkbox;
-  QLabel *m_checkbox_message;
-  QLabel *m_logo;
-  QPushButton *m_previous;
-  QPushButton *m_next;
-  QPushButton *m_cancel;
-};
+    QLabel *m_title;
+    QLabel *m_message;
+    QCheckBox *m_checkbox;
+    QLabel *m_checkbox_message;
+    QLabel *m_logo;
+    QPushButton *m_previous;
+    QPushButton *m_next;
+    QPushButton *m_cancel;
+  };
 
 
-class final_page : public QWidget
-{
-  Q_OBJECT
+  class final_page : public QWidget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  final_page (welcome_wizard *wizard);
+    final_page (welcome_wizard *wizard);
 
-  ~final_page (void) = default;
+    ~final_page (void) = default;
 
-  static QWidget *
-  create (welcome_wizard *wizard) { return new final_page (wizard); }
+    static QWidget *
+    create (welcome_wizard *wizard) { return new final_page (wizard); }
 
-private:
+  private:
 
-  QLabel *m_title;
-  QLabel *m_message;
-  QLabel *m_logo;
-  QLabel *m_links;
-  QPushButton *m_previous;
-  QPushButton *m_finish;
-  QPushButton *m_cancel;
-};
+    QLabel *m_title;
+    QLabel *m_message;
+    QLabel *m_logo;
+    QLabel *m_links;
+    QPushButton *m_previous;
+    QPushButton *m_finish;
+    QPushButton *m_cancel;
+  };
+}
 
 #endif
