# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1265908488 18000
#      Thu Feb 11 12:14:48 2010 -0500
# Node ID cbc402e64d83faa370dc21ceb99bda46ee16b01c
# Parent  a217e1d743536bb57f929280edcc5a211ba4685c
untabify liboctave header files

diff --git a/liboctave/Array-util.h b/liboctave/Array-util.h
--- a/liboctave/Array-util.h
+++ b/liboctave/Array-util.h
@@ -26,21 +26,21 @@ along with Octave; see the file COPYING.
 #include <cassert>
 
 #include "Array.h"
 #include "dim-vector.h"
 #include "idx-vector.h"
 #include "lo-error.h"
 
 extern OCTAVE_API bool index_in_bounds (const Array<octave_idx_type>& ra_idx,
-			     const dim_vector& dimensions);
+                             const dim_vector& dimensions);
 
 extern OCTAVE_API void increment_index (Array<octave_idx_type>& ra_idx,
-			     const dim_vector& dimensions,
-			     int start_dimension = 0);
+                             const dim_vector& dimensions,
+                             int start_dimension = 0);
 
 extern OCTAVE_API octave_idx_type get_scalar_idx (Array<octave_idx_type>& idx, dim_vector& dims);
 
 extern OCTAVE_API octave_idx_type num_ones (const Array<octave_idx_type>& ra_idx);
 
 extern OCTAVE_API bool is_scalar (const dim_vector& dim);
 
 extern OCTAVE_API bool is_vector (const dim_vector& dim);
@@ -49,31 +49,31 @@ extern OCTAVE_API bool any_ones (const A
 
 extern OCTAVE_API octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims);
 
 extern OCTAVE_API Array<octave_idx_type> conv_to_int_array (const Array<idx_vector>& a);
 
 extern OCTAVE_API Array<idx_vector> conv_to_array (const idx_vector *tmp, const octave_idx_type len);
 
 extern OCTAVE_API dim_vector freeze (Array<idx_vector>& ra_idx,
-			  const dim_vector& dimensions, int resize_ok);
+                          const dim_vector& dimensions, int resize_ok);
 
 extern OCTAVE_API bool vector_equivalent (const dim_vector& dv);
 
 extern OCTAVE_API bool all_ok (const Array<idx_vector>& ra_idx);
 
 extern OCTAVE_API bool any_orig_empty (const Array<idx_vector>& ra_idx);
 
 extern OCTAVE_API bool all_colon_equiv (const Array<idx_vector>& ra_idx,
-			     const dim_vector& frozen_lengths);
+                             const dim_vector& frozen_lengths);
 
 extern OCTAVE_API bool all_ones (const Array<octave_idx_type>& arr);
 
 extern OCTAVE_API Array<octave_idx_type> get_elt_idx (const Array<idx_vector>& ra_idx,
-			       const Array<octave_idx_type>& result_idx);
+                               const Array<octave_idx_type>& result_idx);
 
 extern OCTAVE_API Array<octave_idx_type> get_ra_idx (octave_idx_type idx, const dim_vector& dims);
 
 extern OCTAVE_API dim_vector zero_dims_inquire (const Array<idx_vector>& ia,
                                                 const dim_vector& rhdv);
 
 extern OCTAVE_API dim_vector zero_dims_inquire (const idx_vector& i, const idx_vector& j,
                                                 const dim_vector& rhdv);
@@ -91,15 +91,15 @@ permute_vector
 
 extern int OCTAVE_API permute_vector_compare (const void *a, const void *b);
 
 extern void OCTAVE_API gripe_nan_to_logical_conversion (void);
 
 extern void OCTAVE_API gripe_nonconformant (const char *op, int op1_len, int op2_len);
 
 extern void OCTAVE_API gripe_nonconformant (const char *op, int op1_nr, int op1_nc,
-				 int op2_nr, int op2_nc);
+                                 int op2_nr, int op2_nc);
 
 
 extern void OCTAVE_API gripe_nonconformant (const char *op, dim_vector& op1_dims,
-				 dim_vector& op2_dims);
+                                 dim_vector& op2_dims);
 
 #endif
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -109,17 +109,17 @@ public:
         }
     }
 
   typedef T element_type;
 
   typedef typename ref_param<T>::type crefT;
 
   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
-				    typename ref_param<T>::type);
+                                    typename ref_param<T>::type);
 
 protected:
 
   typename Array<T>::ArrayRep *rep;
 
   dim_vector dimensions;
 
   // Rationale:
@@ -159,17 +159,17 @@ protected:
       dimensions.chop_trailing_singletons ();
     }
 
 private:
 
   typename Array<T>::ArrayRep *nil_rep (void) const
     {
       static typename Array<T>::ArrayRep *nr
-	= new typename Array<T>::ArrayRep ();
+        = new typename Array<T>::ArrayRep ();
 
       return nr;
     }
 
   template <class U>
   T *
   coerce (const U *a, octave_idx_type len)
   {
@@ -335,48 +335,48 @@ public:
 
   // FIXME -- would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
   T& checkelem (octave_idx_type n)
     {
       if (n < 0 || n >= slice_len)
-	return range_error ("T& Array<T>::checkelem", n);
+        return range_error ("T& Array<T>::checkelem", n);
       else
-	{
-	  make_unique ();
-	  return xelem (n);
-	}
+        {
+          make_unique ();
+          return xelem (n);
+        }
     }
 
   T& checkelem (octave_idx_type i, octave_idx_type j)
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
-	return range_error ("T& Array<T>::checkelem", i, j);
+        return range_error ("T& Array<T>::checkelem", i, j);
       else
-	return elem (dim1()*j+i);
+        return elem (dim1()*j+i);
     }
 
   T& checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
     {
       if (i < 0 || j < 0 || k < 0 || i >= dim1 () || j >= dim2 () || k >= dim3 ())
-	return range_error ("T& Array<T>::checkelem", i, j, k);
+        return range_error ("T& Array<T>::checkelem", i, j, k);
       else
-	return elem (i, dim2()*k+j);
+        return elem (i, dim2()*k+j);
     }
 
   T& checkelem (const Array<octave_idx_type>& ra_idx)
     {
       octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
-	return range_error ("T& Array<T>::checkelem", ra_idx);
+        return range_error ("T& Array<T>::checkelem", ra_idx);
       else
-	return elem (i);
+        return elem (i);
     }
 
   T& elem (octave_idx_type n)
     {
       make_unique ();
       return xelem (n);
     }
 
@@ -397,45 +397,45 @@ public:
   T& operator () (octave_idx_type i, octave_idx_type j) { return elem (i, j); }
   T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, j, k); }
   T& operator () (const Array<octave_idx_type>& ra_idx) { return elem (ra_idx); }
 #endif
 
   crefT checkelem (octave_idx_type n) const
     {
       if (n < 0 || n >= slice_len)
-	return range_error ("T Array<T>::checkelem", n);
+        return range_error ("T Array<T>::checkelem", n);
       else
-	return xelem (n);
+        return xelem (n);
     }
 
   crefT checkelem (octave_idx_type i, octave_idx_type j) const
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
-	return range_error ("T Array<T>::checkelem", i, j);
+        return range_error ("T Array<T>::checkelem", i, j);
       else
-	return elem (dim1()*j+i);
+        return elem (dim1()*j+i);
     }
 
   crefT checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
     {
       if (i < 0 || j < 0 || k < 0 || i >= dim1 () || j >= dim2 () || k >= dim3 ())
-	return range_error ("T Array<T>::checkelem", i, j, k);
+        return range_error ("T Array<T>::checkelem", i, j, k);
       else
-	return Array<T>::elem (i, Array<T>::dim1()*k+j);
+        return Array<T>::elem (i, Array<T>::dim1()*k+j);
     }
 
   crefT checkelem (const Array<octave_idx_type>& ra_idx) const
     {
       octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
-	return range_error ("T Array<T>::checkelem", ra_idx);
+        return range_error ("T Array<T>::checkelem", ra_idx);
       else
-	return Array<T>::elem (i);
+        return Array<T>::elem (i);
     }
 
   crefT elem (octave_idx_type n) const { return xelem (n); }
 
   crefT elem (octave_idx_type i, octave_idx_type j) const { return elem (dim1()*j+i); }
 
   crefT elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return elem (i, dim2()*k+j); }
 
@@ -608,17 +608,17 @@ public:
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (data ()); }
 
   Array<T> sort (int dim = 0, sortmode mode = ASCENDING) const;
   Array<T> sort (Array<octave_idx_type> &sidx, int dim = 0,
-		 sortmode mode = ASCENDING) const;
+                 sortmode mode = ASCENDING) const;
 
   // Ordering is auto-detected or can be specified.
   sortmode is_sorted (sortmode mode = UNSORTED) const;
 
   // Sort by rows returns only indices.
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const;
 
   // Ordering is auto-detected or can be specified.
@@ -654,17 +654,17 @@ public:
     const T *m = data ();
 
     Array<U> result (dims ());
     U *p = result.fortran_vec ();
 
     octave_idx_type i;
     for (i = 0; i < len - 3; i += 4)
       {
-	octave_quit ();
+        octave_quit ();
 
         p[i] = fcn (m[i]);
         p[i+1] = fcn (m[i+1]);
         p[i+2] = fcn (m[i+2]);
         p[i+3] = fcn (m[i+3]);
       }
 
     octave_quit ();
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -52,25 +52,25 @@ public:
   Array2 (octave_idx_type r, octave_idx_type c) : Array<T> (dim_vector (r, c)) { }
 
   Array2 (octave_idx_type r, octave_idx_type c, const T& val)
     : Array<T> (dim_vector (r, c), val) { }
 
   Array2 (const dim_vector& dv) : Array<T> (dv) 
     { 
       if (dv.length () != 2)
-	(*current_liboctave_error_handler) ("too many dimensions");
+        (*current_liboctave_error_handler) ("too many dimensions");
     }
 
   Array2 (const dim_vector& dv, const T& val) : Array<T> (dv) 
     { 
       if (dv.length () != 2)
-	(*current_liboctave_error_handler) ("too many dimensions");
+        (*current_liboctave_error_handler) ("too many dimensions");
       else
-	Array<T>::fill (val); 
+        Array<T>::fill (val); 
     }
 
   Array2 (const Array2<T>& a) : Array<T> (a, a.dims ()) { }
 
   Array2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
     : Array<T> (a, dim_vector (r, c)) { }
 
   template <class U>
@@ -80,17 +80,17 @@ public:
   Array2 (const Array<U>& a, const dim_vector& dv)
     : Array<T> (a, dv) { }
 
   ~Array2 (void) { }
 
   Array2<T>& operator = (const Array2<T>& a)
     {
       if (this != &a)
-	Array<T>::operator = (a);
+        Array<T>::operator = (a);
 
       return *this;
     }
 
   void resize (octave_idx_type r, octave_idx_type c)
     { Array<T>::resize_fill (r, c, Array<T>::resize_fill_value ()); }
 
   void resize (octave_idx_type r, octave_idx_type c, const T& val)
@@ -110,37 +110,37 @@ public:
 
   Array2<T> hermitian (T (*fcn) (const T&) = 0) const
     {
       Array<T> tmp = Array<T>::hermitian (fcn);
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
 
   Array2<T> index (const idx_vector& i, bool resize_ok = false,
-		   const T& rfv = Array<T>::resize_fill_value ()) const
+                   const T& rfv = Array<T>::resize_fill_value ()) const
     {
       Array<T> tmp = Array<T>::index (i, resize_ok, rfv);
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
 
   Array2<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok = false,
-		   const T& rfv = Array<T>::resize_fill_value ()) const
+                   const T& rfv = Array<T>::resize_fill_value ()) const
     {
       Array<T> tmp = Array<T>::index (i, j, resize_ok, rfv);
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
 
   Array2<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (dim, mode);
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
 
   Array2<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		 sortmode mode = ASCENDING) const
+                 sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (sidx, dim, mode);
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
 
   Array2<T> diag (octave_idx_type k) const
   {
     return Array<T>::diag (k);
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -58,17 +58,17 @@ public:
   Array3 (const Array<T>& a, octave_idx_type r, octave_idx_type c, octave_idx_type p)
     : Array<T> (a, dim_vector (r, c, p)) { }
 
   ~Array3 (void) { }
 
   Array3<T>& operator = (const Array3<T>& a)
     {
       if (this != &a)
-	Array<T>::operator = (a);
+        Array<T>::operator = (a);
 
       return *this;
     }
 
   void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p) 
     { Array<T>::resize (dim_vector (r, c, p)); }
 
   void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
@@ -76,16 +76,16 @@ public:
 
   Array3<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (dim, mode);
       return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
     }
 
   Array3<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		 sortmode mode = ASCENDING) const
+                 sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (sidx, dim, mode);
       return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
     }
 };
 
 #endif
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -88,36 +88,36 @@ public:
   // column vector by column vector -> column vector operations
 
   ComplexColumnVector& operator += (const ColumnVector& a);
   ComplexColumnVector& operator -= (const ColumnVector& a);
 
   // matrix by column vector -> column vector operations
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexMatrix& a,
-					 const ColumnVector& b);
+                                         const ColumnVector& b);
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexMatrix& a,
-					 const ComplexColumnVector& b);
+                                         const ComplexColumnVector& b);
 
   // matrix by column vector -> column vector operations
 
   friend OCTAVE_API ComplexColumnVector operator * (const Matrix& a,
-					 const ComplexColumnVector& b);
+                                         const ComplexColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
   friend OCTAVE_API ComplexColumnVector operator * (const DiagMatrix& a,
-					 const ComplexColumnVector& b);
+                                         const ComplexColumnVector& b);
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexDiagMatrix& a,
-					 const ColumnVector& b);
+                                         const ColumnVector& b);
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexDiagMatrix& a,
-					 const ComplexColumnVector& b);
+                                         const ComplexColumnVector& b);
 
   // other operations
 
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -151,32 +151,32 @@ public:
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
 private:
   ComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
-			  double& rcon, int force, int calc_cond) const;
+                          double& rcon, int force, int calc_cond) const;
 
   ComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
-			  double& rcon, int force, int calc_cond) const;
+                          double& rcon, int force, int calc_cond) const;
 
 public:
   ComplexMatrix inverse (void) const;
   ComplexMatrix inverse (octave_idx_type& info) const;
   ComplexMatrix inverse (octave_idx_type& info, double& rcon, int force = 0, 
-			 int calc_cond = 1) const;
+                         int calc_cond = 1) const;
 
   ComplexMatrix inverse (MatrixType &mattype) const;
   ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
-			 double& rcon, int force = 0, 
-			 int calc_cond = 1) const;
+                         double& rcon, int force = 0, 
+                         int calc_cond = 1) const;
 
   ComplexMatrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
@@ -188,139 +188,139 @@ public:
                           double& rcon, int calc_cond = 1) const;
 
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-		  octave_idx_type& info, double& rcon, 
-		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false, 
+                  octave_idx_type& info, double& rcon, 
+                  solve_singularity_handler sing_handler,
+                  bool calc_cond = false, 
                   blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-		  octave_idx_type& info, double& rcon, 
-		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  octave_idx_type& info, double& rcon, 
+                  solve_singularity_handler sing_handler,
+                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-		 octave_idx_type& info, double& rcon, 
-		 solve_singularity_handler sing_handler,
-		 bool calc_cond = false) const;
+                 octave_idx_type& info, double& rcon, 
+                 solve_singularity_handler sing_handler,
+                 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
-		       octave_idx_type& info, double& rcon) const;
+                       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		       double& rcon, solve_singularity_handler sing_handler,
-		       bool singular_fallback = true, 
+                       double& rcon, solve_singularity_handler sing_handler,
+                       bool singular_fallback = true, 
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcon) const;
+                       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true, 
+                       octave_idx_type& info, double& rcon,
+                       solve_singularity_handler sing_handler,
+                       bool singular_fallback = true, 
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-			     octave_idx_type& info, double& rcon) const;
+                             octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-			     octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler, 
+                             octave_idx_type& info, double& rcon,
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
-			     const ComplexColumnVector& b) const;
+                             const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcon) const;
+                             octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler, 
+                             octave_idx_type& info, double& rcon,
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler, 
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler, 
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
-			     double& rcon) const;
+                             double& rcon) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcon) const;
+                             double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcon, solve_singularity_handler sing_handler, 
+                             double& rcon, solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix lssolve (const Matrix& b) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
-			 octave_idx_type& rank) const;
+                         octave_idx_type& rank) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
-			 octave_idx_type& rank, double& rcon) const;
+                         octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank) const;
+                         octave_idx_type& rank) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, double& rcon) const;
+                         octave_idx_type& rank, double& rcon) const;
 
   ComplexColumnVector lssolve (const ColumnVector& b) const;
   ComplexColumnVector lssolve (const ColumnVector& b,
-			       octave_idx_type& info) const;
+                               octave_idx_type& info) const;
   ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank) const;
+                               octave_idx_type& rank) const;
   ComplexColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank, double& rcon) const;
+                               octave_idx_type& rank, double& rcon) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
-			       octave_idx_type& info) const;
+                               octave_idx_type& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
-			       octave_idx_type& info,
-			       octave_idx_type& rank) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
-			       octave_idx_type& info,
-			       octave_idx_type& rank, double& rcon) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank, double& rcon) const;
 
   // matrix by diagonal matrix -> matrix operations
 
   ComplexMatrix& operator += (const DiagMatrix& a);
   ComplexMatrix& operator -= (const DiagMatrix& a);
 
   ComplexMatrix& operator += (const ComplexDiagMatrix& a);
   ComplexMatrix& operator -= (const ComplexDiagMatrix& a);
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -119,21 +119,21 @@ public:
   ComplexNDArray fourierNd (void) const;
   ComplexNDArray ifourierNd (void) const;
 
   ComplexMatrix matrix_value (void) const;
 
   ComplexNDArray squeeze (void) const { return MArrayN<Complex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension = 0);
+                               const dim_vector& dimensions,
+                               int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions);
+                            const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexNDArray& a);
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -86,20 +86,20 @@ public:
   // row vector by row vector -> row vector operations
 
   ComplexRowVector& operator += (const RowVector& a);
   ComplexRowVector& operator -= (const RowVector& a);
 
   // row vector by matrix -> row vector
 
   friend ComplexRowVector operator * (const ComplexRowVector& a,
-				      const ComplexMatrix& b);
+                                      const ComplexMatrix& b);
 
   friend ComplexRowVector operator * (const RowVector& a,
-				      const ComplexMatrix& b);
+                                      const ComplexMatrix& b);
 
   // other operations
 
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -74,24 +74,24 @@ public:
 
   explicit SparseComplexMatrix (const ComplexMatrix& a) 
     : MSparse<Complex> (a) { }
 
   explicit SparseComplexMatrix (const ComplexNDArray& a) 
     : MSparse<Complex> (a) { }
 
   explicit SparseComplexMatrix (const Array<Complex> a, const Array<octave_idx_type>& r, 
-			 const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
-			 octave_idx_type nc = -1, bool sum_terms = true)
+                         const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+                         octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<Complex> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseComplexMatrix (const Array<Complex> a, 
-				const Array<double>& r, 
-				const Array<double>& c, octave_idx_type nr = -1, 
-				octave_idx_type nc = -1, bool sum_terms = true)
+                                const Array<double>& r, 
+                                const Array<double>& c, octave_idx_type nr = -1, 
+                                octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<Complex> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseComplexMatrix (const SparseMatrix& a);
 
   explicit SparseComplexMatrix (const SparseBoolMatrix& a);
 
   explicit SparseComplexMatrix (const ComplexDiagMatrix& a);
 
@@ -115,19 +115,19 @@ public:
   SparseComplexMatrix min (Array<octave_idx_type>& index, int dim = -1) const;
 
   SparseComplexMatrix& insert (const SparseComplexMatrix& a, octave_idx_type r, octave_idx_type c);
   SparseComplexMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
   SparseComplexMatrix& insert (const SparseComplexMatrix& a, const Array<octave_idx_type>& indx);
   SparseComplexMatrix& insert (const SparseMatrix& a, const Array<octave_idx_type>& indx);
 
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
-			      const Array<octave_idx_type>& ra_idx);
+                              const Array<octave_idx_type>& ra_idx);
   SparseComplexMatrix concat (const SparseMatrix& rb,
-			      const Array<octave_idx_type>& ra_idx);
+                              const Array<octave_idx_type>& ra_idx);
 
   ComplexMatrix matrix_value (void) const;
 
   SparseComplexMatrix hermitian (void) const;  // complex conjugate transpose
   SparseComplexMatrix transpose (void) const
     { return MSparse<Complex>::transpose (); }
 
   friend SparseComplexMatrix conj (const SparseComplexMatrix& a);
@@ -135,286 +135,286 @@ public:
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
 private:
   SparseComplexMatrix dinverse (MatrixType &mattyp, octave_idx_type& info, 
-				double& rcond, const bool force = false, 
-				const bool calccond = true) const;
+                                double& rcond, const bool force = false, 
+                                const bool calccond = true) const;
 
   SparseComplexMatrix tinverse (MatrixType &mattyp, octave_idx_type& info, 
-				double& rcond, const bool force = false, 
-				const bool calccond = true) const;
+                                double& rcond, const bool force = false, 
+                                const bool calccond = true) const;
 
 public:
   SparseComplexMatrix inverse (void) const;
   SparseComplexMatrix inverse (MatrixType& mattype) const;
   SparseComplexMatrix inverse (MatrixType& mattype, 
-			       octave_idx_type& info) const;
+                               octave_idx_type& info) const;
   SparseComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info, 
-			       double& rcond, int force = 0, 
-			       int calc_cond = 1) const;
+                               double& rcond, int force = 0, 
+                               int calc_cond = 1) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcond, 
-				int calc_cond = 1) const;
+                                int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
   ComplexMatrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler, 
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler, 
+                bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseMatrix& b, 
-		octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond,
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (MatrixType &typ, const SparseMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   ComplexMatrix ltsolve (MatrixType &typ, const Matrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
   ComplexMatrix trisolve (MatrixType &typ, const Matrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
   ComplexMatrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond,
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, 
-		Matrix &Info, solve_singularity_handler sing_handler,
-		bool calc_cond) const;
+                Matrix &Info, solve_singularity_handler sing_handler,
+                bool calc_cond) const;
 
   ComplexMatrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseMatrix& b, 
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		       double& rcond) const;
+                       double& rcond) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		       double& rcond, solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+                       double& rcond, solve_singularity_handler sing_handler,
+                       bool singular_fallback = true) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcond) const;
+                       octave_idx_type& info, double& rcond) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
-		       octave_idx_type& info, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+                       octave_idx_type& info, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool singular_fallback = true) const;
 
   SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
-			     octave_idx_type& info, double& rcond) const;
+                             octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
-			     octave_idx_type& info, double& rcond, 
-			     solve_singularity_handler sing_handler,
-			     bool singular_fallback = true) const;
+                             octave_idx_type& info, double& rcond, 
+                             solve_singularity_handler sing_handler,
+                             bool singular_fallback = true) const;
 
   SparseComplexMatrix solve (MatrixType &typ, 
-			     const SparseComplexMatrix& b) const;
+                             const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
-			     octave_idx_type& info, double& rcond) const;
+                             octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
-			     octave_idx_type& info, double& rcond, 
-			     solve_singularity_handler sing_handler,
-			     bool singular_fallback = true) const;
+                             octave_idx_type& info, double& rcond, 
+                             solve_singularity_handler sing_handler,
+                             bool singular_fallback = true) const;
 
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-			     octave_idx_type& info, double& rcond) const;
+                             octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
-			     octave_idx_type& info, double& rcond, 
-			     solve_singularity_handler sing_handler) const;
+                             octave_idx_type& info, double& rcond, 
+                             solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
-			     const ComplexColumnVector& b) const;
+                             const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
-			     octave_idx_type& info, double& rcond) const;
+                             octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
-			     octave_idx_type& info, double& rcond,
-			     solve_singularity_handler sing_handler) const;
+                             octave_idx_type& info, double& rcond,
+                             solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, 
-		       double& rcond) const;
+                       double& rcond) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond, 
-		       solve_singularity_handler sing_handler) const;
+                       solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, 
-		       double& rcond) const;
+                       double& rcond) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
-		       double& rcond, solve_singularity_handler sing_handler) const;
+                       double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseMatrix& b) const;
   SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
   SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
-			     double& rcond) const;
+                             double& rcond) const;
   SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
-			     double& rcond, 
-			     solve_singularity_handler sing_handler) const;
+                             double& rcond, 
+                             solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b,
-			     octave_idx_type& info, double& rcond) const;
+                             octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b,
-			     octave_idx_type& info, double& rcond,
-			     solve_singularity_handler sing_handler) const;
+                             octave_idx_type& info, double& rcond,
+                             solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
-			     double& rcond) const;
+                             double& rcond) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, 
-			     double& rcond,
-			     solve_singularity_handler sing_handler) const;
+                             double& rcond,
+                             solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond) const;
+                             double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond,
-			     solve_singularity_handler sing_handler) const;
+                             double& rcond,
+                             solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix squeeze (void) const;
 
   SparseComplexMatrix index (idx_vector& i, int resize_ok) const;
 
   SparseComplexMatrix index (idx_vector& i, idx_vector& j, int resize_ok) const;
   
   SparseComplexMatrix index (Array<idx_vector>& ra_idx, int resize_ok) const;
 
   SparseComplexMatrix reshape (const dim_vector& new_dims) const;
 
   SparseComplexMatrix permute (const Array<octave_idx_type>& vec, 
-			       bool inv = false) const;
+                               bool inv = false) const;
 
   SparseComplexMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
@@ -430,49 +430,49 @@ public:
   SparseComplexMatrix sum (int dim = -1) const;
   SparseComplexMatrix sumsq (int dim = -1) const;
   SparseMatrix abs (void) const;
 
   SparseComplexMatrix diag (octave_idx_type k = 0) const;
 
   // i/o
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, 
-				    const SparseComplexMatrix& a);
+                                    const SparseComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, 
-				    SparseComplexMatrix& a);
+                                    SparseComplexMatrix& a);
 };
 
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&,        
-				       const SparseComplexMatrix&);
+                                       const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
-				       const SparseMatrix&);
+                                       const SparseMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
-				       const SparseComplexMatrix&);
+                                       const SparseComplexMatrix&);
 
 extern OCTAVE_API ComplexMatrix operator * (const Matrix&,        
-				       const SparseComplexMatrix&);
+                                       const SparseComplexMatrix&);
 extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, 
-				       const SparseMatrix&);
+                                       const SparseMatrix&);
 extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, 
-				       const SparseComplexMatrix&);
+                                       const SparseComplexMatrix&);
 extern OCTAVE_API ComplexMatrix mul_trans (const ComplexMatrix&, 
-				       const SparseComplexMatrix&);
+                                       const SparseComplexMatrix&);
 extern OCTAVE_API ComplexMatrix mul_herm (const ComplexMatrix&, 
-				       const SparseComplexMatrix&);
+                                       const SparseComplexMatrix&);
 
 extern OCTAVE_API ComplexMatrix operator * (const SparseMatrix&,        
-				       const ComplexMatrix&);
+                                       const ComplexMatrix&);
 extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&, 
-				       const Matrix&);
+                                       const Matrix&);
 extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&, 
-				       const ComplexMatrix&);
+                                       const ComplexMatrix&);
 extern OCTAVE_API ComplexMatrix trans_mul (const SparseComplexMatrix&, 
-				       const ComplexMatrix&);
+                                       const ComplexMatrix&);
 extern OCTAVE_API ComplexMatrix herm_mul (const SparseComplexMatrix&, 
-				       const ComplexMatrix&);
+                                       const ComplexMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const DiagMatrix&, const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, const DiagMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const ComplexDiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&, const ComplexDiagMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const ComplexDiagMatrix&, const SparseComplexMatrix&);
@@ -488,33 +488,33 @@ extern OCTAVE_API SparseComplexMatrix op
 extern OCTAVE_API SparseComplexMatrix operator - (const ComplexDiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator - (const DiagMatrix&, const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator - (const ComplexDiagMatrix&, const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator - (const SparseMatrix&, const ComplexDiagMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&, const DiagMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&, const ComplexDiagMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const PermMatrix&,
-						  const SparseComplexMatrix&);
+                                                  const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
-						  const PermMatrix&);
+                                                  const PermMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix min (const Complex& c, 
-				const SparseComplexMatrix& m);
+                                const SparseComplexMatrix& m);
 extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& m, 
-				const Complex& c);
+                                const Complex& c);
 extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& a, 
-				const SparseComplexMatrix& b);
+                                const SparseComplexMatrix& b);
 
 extern OCTAVE_API SparseComplexMatrix max (const Complex& c, 
-				const SparseComplexMatrix& m);
+                                const SparseComplexMatrix& m);
 extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& m, 
-				const Complex& c);
+                                const Complex& c);
 extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& a, 
-				const SparseComplexMatrix& b);
+                                const SparseComplexMatrix& b);
 
 SPARSE_SMS_CMP_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
 SPARSE_SMS_BOOL_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
 
 SPARSE_SSM_CMP_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 SPARSE_SSM_BOOL_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 
 SPARSE_SMSM_CMP_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix, OCTAVE_API)
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,36 @@
+2010-02-11  John W. Eaton  <jwe@octave.org>
+
+	* Array-util.h, Array.h, Array2.h, Array3.h, CColVector.h,
+	CMatrix.h, CNDArray.h, CRowVector.h, CSparse.h, CmplxCHOL.h,
+	CmplxGEPBAL.h, CmplxHESS.h, CmplxLU.h, CmplxQRP.h, CmplxSCHUR.h,
+	CmplxSVD.h, CollocWt.h, DAE.h, DAEFunc.h, DAERT.h, DAERTFunc.h,
+	DASPK.h, DASRT.h, DASSL.h, DiagArray2.h, EIG.h, MArrayN.h,
+	MDiagArray2.h, MSparse-defs.h, MSparse.h, MatrixType.h, ODE.h,
+	ODEFunc.h, ODES.h, ODESFunc.h, Quad.h, Range.h,
+	Sparse-diag-op-defs.h, Sparse-op-defs.h, Sparse-perm-op-defs.h,
+	Sparse.h, SparseCmplxCHOL.h, SparseCmplxLU.h, SparseCmplxQR.h,
+	SparseQR.h, SparsedbleCHOL.h, SparsedbleLU.h, base-dae.h,
+	base-de.h, base-lu.h, base-min.h, base-qr.h, boolNDArray.h,
+	boolSparse.h, chNDArray.h, cmd-hist.h, dMatrix.h, dNDArray.h,
+	dSparse.h, data-conv.h, dbleCHOL.h, dbleGEPBAL.h, dbleHESS.h,
+	dbleLU.h, dbleQRP.h, dbleSCHUR.h, dbleSVD.h, dir-ops.h,
+	fCColVector.h, fCMatrix.h, fCNDArray.h, fCRowVector.h,
+	fCmplxCHOL.h, fCmplxGEPBAL.h, fCmplxHESS.h, fCmplxLU.h,
+	fCmplxQRP.h, fCmplxSCHUR.h, fCmplxSVD.h, fEIG.h, fMatrix.h,
+	fNDArray.h, file-stat.h, floatCHOL.h, floatGEPBAL.h,
+	floatHESS.h, floatLU.h, floatQRP.h, floatSCHUR.h, floatSVD.h,
+	glob-match.h, idx-vector.h, intNDArray.h, lo-ieee.h,
+	lo-specfun.h, mx-op-decl.h, mx-op-defs.h, oct-env.h, oct-fftw.h,
+	oct-group.h, oct-inttypes.h, oct-mutex.h, oct-passwd.h,
+	oct-rand.h, oct-shlib.h, oct-sort.h, oct-spparms.h, oct-time.h,
+	oct-uname.h, pathsearch.h, sparse-base-chol.h, sparse-base-lu.h,
+	sparse-sort.h, sparse-util.h, statdefs.h, str-vec.h: Untabify.
+
 2010-02-10  John W. Eaton  <jwe@octave.org>
 
 	* dMatrix.h (template <class U> Matrix (const Array<U>&)):
 	New constructor.
 	* CMatrix.h (template <class U> ComplexMatrix (const Array<U>&)):
 	New constructor.
 	* fMatrix.h (template <class U> FloatMatrix (const Array<U>&)):
 	New constructor.
diff --git a/liboctave/CmplxCHOL.h b/liboctave/CmplxCHOL.h
--- a/liboctave/CmplxCHOL.h
+++ b/liboctave/CmplxCHOL.h
@@ -46,20 +46,20 @@ public:
     }
 
   ComplexCHOL (const ComplexCHOL& a)
     : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   ComplexCHOL& operator = (const ComplexCHOL& a)
     {
       if (this != &a)
-	{
-	  chol_mat = a.chol_mat;
-	  xrcond = a.xrcond;
-	}
+        {
+          chol_mat = a.chol_mat;
+          xrcond = a.xrcond;
+        }
 
       return *this;
     }
 
   ComplexMatrix chol_matrix (void) const { return chol_mat; }
 
   double rcond (void) const { return xrcond; }
 
diff --git a/liboctave/CmplxGEPBAL.h b/liboctave/CmplxGEPBAL.h
--- a/liboctave/CmplxGEPBAL.h
+++ b/liboctave/CmplxGEPBAL.h
@@ -45,22 +45,22 @@ public:
 
   ComplexGEPBALANCE (const ComplexGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
     balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   ComplexGEPBALANCE& operator = (const ComplexGEPBALANCE& a)
     {
       if (this != &a)
-	{
-	  balanced_mat = a.balanced_mat;
-	  balanced_mat2 = a.balanced_mat2;
-	  balancing_mat = a.balancing_mat;
-	  balancing_mat2 = a.balancing_mat2;
-	}
+        {
+          balanced_mat = a.balanced_mat;
+          balanced_mat2 = a.balanced_mat2;
+          balancing_mat = a.balancing_mat;
+          balancing_mat2 = a.balancing_mat2;
+        }
       return *this;
     }
 
   ~ComplexGEPBALANCE (void) { }
 
   ComplexMatrix balanced_matrix (void) const { return balanced_mat; }
 
   ComplexMatrix balanced_matrix2 (void) const { return balanced_mat2; }
@@ -74,12 +74,12 @@ public:
 private:
 
   ComplexMatrix balanced_mat;
   ComplexMatrix balanced_mat2;
   Matrix balancing_mat;
   Matrix balancing_mat2;
 
   octave_idx_type init (const ComplexMatrix& a, const ComplexMatrix& b, 
-			const std::string& balance_job);
+                        const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/CmplxHESS.h b/liboctave/CmplxHESS.h
--- a/liboctave/CmplxHESS.h
+++ b/liboctave/CmplxHESS.h
@@ -41,20 +41,20 @@ public:
   ComplexHESS (const ComplexMatrix& a, octave_idx_type& info) { info = init (a); }
 
   ComplexHESS (const ComplexHESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   ComplexHESS& operator = (const ComplexHESS& a)
     {
       if (this != &a)
-	{
-	  hess_mat = a.hess_mat;
-	  unitary_hess_mat = a.unitary_hess_mat;
-	}
+        {
+          hess_mat = a.hess_mat;
+          unitary_hess_mat = a.unitary_hess_mat;
+        }
       return *this;
     }
 
   ~ComplexHESS (void) { }
 
   ComplexMatrix hess_matrix (void) const { return hess_mat; }
 
   ComplexMatrix unitary_hess_matrix (void) const
diff --git a/liboctave/CmplxLU.h b/liboctave/CmplxLU.h
--- a/liboctave/CmplxLU.h
+++ b/liboctave/CmplxLU.h
@@ -44,17 +44,17 @@ public:
 
   ComplexLU (const ComplexMatrix& l, const ComplexMatrix& u, 
              const PermMatrix& p)
     : base_lu <ComplexMatrix> (l, u, p) { }
 
   ComplexLU& operator = (const ComplexLU& a)
     {
       if (this != &a)
-	base_lu <ComplexMatrix> :: operator = (a);
+        base_lu <ComplexMatrix> :: operator = (a);
 
       return *this;
     }
 
   ~ComplexLU (void) { }
 
   void update (const ComplexColumnVector& u, const ComplexColumnVector& v);
 
diff --git a/liboctave/CmplxQRP.h b/liboctave/CmplxQRP.h
--- a/liboctave/CmplxQRP.h
+++ b/liboctave/CmplxQRP.h
@@ -40,20 +40,20 @@ public:
 
   ComplexQRP (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   ComplexQRP (const ComplexQRP& a) : ComplexQR (a), p (a.p) { }
 
   ComplexQRP& operator = (const ComplexQRP& a)
     {
       if (this != &a)
-	{
-	  ComplexQR::operator = (a);
-	  p = a.p;
-	}
+        {
+          ComplexQR::operator = (a);
+          p = a.p;
+        }
       return *this;
     }
 
   ~ComplexQRP (void) { }
 
   void init (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
diff --git a/liboctave/CmplxSCHUR.h b/liboctave/CmplxSCHUR.h
--- a/liboctave/CmplxSCHUR.h
+++ b/liboctave/CmplxSCHUR.h
@@ -34,33 +34,33 @@ OCTAVE_API
 ComplexSCHUR
 {
 public:
 
   ComplexSCHUR (void)
     : schur_mat (), unitary_mat () { }
 
   ComplexSCHUR (const ComplexMatrix& a, const std::string& ord,
-		bool calc_unitary = true)
+                bool calc_unitary = true)
     : schur_mat (), unitary_mat () { init (a, ord, calc_unitary); }
 
   ComplexSCHUR (const ComplexMatrix& a, const std::string& ord, octave_idx_type& info,
-		bool calc_unitary = true)
+                bool calc_unitary = true)
     : schur_mat (), unitary_mat () { info = init (a, ord, calc_unitary); }
 
   ComplexSCHUR (const ComplexSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat) { }
 
   ComplexSCHUR& operator = (const ComplexSCHUR& a)
     {
       if (this != &a)
-	{
-	  schur_mat = a.schur_mat;
-	  unitary_mat = a.unitary_mat;
-	}
+        {
+          schur_mat = a.schur_mat;
+          unitary_mat = a.unitary_mat;
+        }
       return *this;
     }
 
   ~ComplexSCHUR (void) { }
 
   ComplexMatrix schur_matrix (void) const { return schur_mat; }
 
   ComplexMatrix unitary_matrix (void) const { return unitary_mat; }
diff --git a/liboctave/CmplxSVD.h b/liboctave/CmplxSVD.h
--- a/liboctave/CmplxSVD.h
+++ b/liboctave/CmplxSVD.h
@@ -39,34 +39,34 @@ public:
   ComplexSVD (void) { }
 
   ComplexSVD (const ComplexMatrix& a, SVD::type svd_type = SVD::std)
     {
       init (a, svd_type);
     }
 
   ComplexSVD (const ComplexMatrix& a, octave_idx_type& info,
-	      SVD::type svd_type = SVD::std)
+              SVD::type svd_type = SVD::std)
     {
       info = init (a, svd_type);
     }
 
   ComplexSVD (const ComplexSVD& a)
     : type_computed (a.type_computed),
       sigma (a.sigma), left_sm (a.left_sm), right_sm (a.right_sm) { }
 
   ComplexSVD& operator = (const ComplexSVD& a)
     {
       if (this != &a)
-	{
-	  type_computed = a.type_computed;
-	  sigma = a.sigma;
-	  left_sm = a.left_sm;
-	  right_sm = a.right_sm;
-	}
+        {
+          type_computed = a.type_computed;
+          sigma = a.sigma;
+          left_sm = a.left_sm;
+          right_sm = a.right_sm;
+        }
       return *this;
     }
 
   ~ComplexSVD (void) { }
 
   DiagMatrix singular_values (void) const { return sigma; }
 
   ComplexMatrix left_singular_matrix (void) const;
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -47,41 +47,41 @@ public:
     : n (nc), inc_left (il), inc_right (ir), lb (l), rb (rr),
       Alpha (0.0), Beta (0.0), r (), q (), A (), B (), initialized (0) { }
 
   CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il, octave_idx_type ir)
     : n (nc), inc_left (il), inc_right (ir), lb (0.0), rb (1.0),
       Alpha (a), Beta (b), initialized (0) { }
 
   CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il, octave_idx_type ir,
-		      double ll, double rr)  
+                      double ll, double rr)  
     : n (nc), inc_left (il), inc_right (ir), lb (ll), rb (rr),
       Alpha (a), Beta (b), r (), q (), A (), B (), initialized (0) { }
 
   CollocWt (const CollocWt& a)
     : n (a.n), inc_left (a.inc_left), inc_right (a.inc_right),
       lb (a.lb), rb (a.rb), Alpha (a.Alpha), Beta (a.Beta),
       r (a.r), q (a.q), A (a.A), B (a.B),
       initialized (a.initialized) { } 
 
   CollocWt& operator = (const CollocWt& a)
     {
       if (this != &a)
-	{
-	  n = a.n;
-	  inc_left = a.inc_left;
-	  inc_right = a.inc_right;
-	  lb = a.lb;
-	  rb = a.rb;
-	  r = a.r;
-	  q = a.q;
-	  A = a.A;
-	  B = a.B;
-	  initialized = a.initialized;
-	}
+        {
+          n = a.n;
+          inc_left = a.inc_left;
+          inc_right = a.inc_right;
+          lb = a.lb;
+          rb = a.rb;
+          r = a.r;
+          q = a.q;
+          A = a.A;
+          B = a.B;
+          initialized = a.initialized;
+        }
       return *this;
     }
 
   ~CollocWt (void) { }
 
   CollocWt& resize (octave_idx_type nc)
     {
       n = nc;
diff --git a/liboctave/DAE.h b/liboctave/DAE.h
--- a/liboctave/DAE.h
+++ b/liboctave/DAE.h
@@ -44,19 +44,19 @@ public:
     : base_diff_alg_eqn (xx, xxdot, tt), DAEFunc (f) { }
 
   DAE (const DAE& a)
     : base_diff_alg_eqn (a), DAEFunc (a){ }
 
   DAE& operator = (const DAE& a)
     {
       if (this != &a)
-	{
-	  base_diff_alg_eqn::operator = (a);
-	  DAEFunc::operator = (a);
-	}
+        {
+          base_diff_alg_eqn::operator = (a);
+          DAEFunc::operator = (a);
+        }
       return *this;
     }
 
   ~DAE (void) { }
 };
 
 #endif
diff --git a/liboctave/DAEFunc.h b/liboctave/DAEFunc.h
--- a/liboctave/DAEFunc.h
+++ b/liboctave/DAEFunc.h
@@ -28,47 +28,47 @@ class Matrix;
 class ColumnVector;
 
 class
 DAEFunc
 {
 public:
 
   typedef ColumnVector (*DAERHSFunc) (const ColumnVector& x,
-				      const ColumnVector& xdot,
-				      double t, octave_idx_type& ires);
+                                      const ColumnVector& xdot,
+                                      double t, octave_idx_type& ires);
 
   // This is really the form used by DASSL:
   //
   //   PD = DG/DY + CJ * DG/DYPRIME
 
   typedef Matrix (*DAEJacFunc) (const ColumnVector& x,
-				const ColumnVector& xdot,
-				double t, double cj);
+                                const ColumnVector& xdot,
+                                double t, double cj);
 
   DAEFunc (void)
     : fun (0), jac (0), reset (true) { }
 
   DAEFunc (DAERHSFunc f)
     : fun (f), jac (0), reset (true) { }
 
   DAEFunc (DAERHSFunc f, DAEJacFunc j)
     : fun (f), jac (j), reset (true) { }
 
   DAEFunc (const DAEFunc& a)
     : fun (a.fun), jac (a.jac), reset (a.reset) { }
 
   DAEFunc& operator = (const DAEFunc& a)
     {
       if (this != &a)
-	{
-	  fun = a.fun;
-	  jac = a.jac;
-	  reset = a.reset;
-	}
+        {
+          fun = a.fun;
+          jac = a.jac;
+          reset = a.reset;
+        }
       return *this;
     }
 
   ~DAEFunc (void) { }
 
   DAERHSFunc function (void) const { return fun; }
 
   DAEFunc& set_function (DAERHSFunc f)
diff --git a/liboctave/DAERT.h b/liboctave/DAERT.h
--- a/liboctave/DAERT.h
+++ b/liboctave/DAERT.h
@@ -34,35 +34,35 @@ public:
 
   DAERT (void)
     : base_diff_alg_eqn (), DAERTFunc () { }
 
   DAERT (const ColumnVector& xx, double tt, DAERTFunc& f)
     : base_diff_alg_eqn (xx, tt), DAERTFunc (f) { }
 
   DAERT (const ColumnVector& xx, const ColumnVector& xxdot, double tt,
-	DAERTFunc& f)
+        DAERTFunc& f)
     : base_diff_alg_eqn (xx, xxdot, tt), DAERTFunc (f) { }
 
   DAERT (const DAERT& a)
     : base_diff_alg_eqn (a), DAERTFunc (a) { }
 
   DAERT& operator = (const DAERT& a)
     {
       if (this != &a)
-	{
-	  base_diff_alg_eqn::operator = (a);
-	  DAERTFunc::operator = (a);
+        {
+          base_diff_alg_eqn::operator = (a);
+          DAERTFunc::operator = (a);
 
-	}
+        }
       return *this;
     }
 
   ~DAERT (void) { }
 
   void initialize (const ColumnVector& xx, const ColumnVector& xxdot,
-		   double tt)
+                   double tt)
     {
       base_diff_alg_eqn::initialize (xx, xxdot, tt);
     }
 };
 
 #endif
diff --git a/liboctave/DAERTFunc.h b/liboctave/DAERTFunc.h
--- a/liboctave/DAERTFunc.h
+++ b/liboctave/DAERTFunc.h
@@ -48,21 +48,21 @@ public:
     : DAEFunc (f, j), constr (cf), reset (true) { }
 
   DAERTFunc (const DAERTFunc& a)
     : DAEFunc (a), constr (a.constr), reset (a.reset) { }
 
   DAERTFunc& operator = (const DAERTFunc& a)
     {
       if (this != &a)
-	{
-	  DAEFunc::operator = (a);
-	  constr = a.constr;
-	  reset = a.reset;
-	}
+        {
+          DAEFunc::operator = (a);
+          constr = a.constr;
+          reset = a.reset;
+        }
       return *this;
     }
 
   ~DAERTFunc (void) { }
 
   DAERTConstrFunc constraint_function (void) const { return constr; }
 
   DAERTFunc& set_constraint_function (DAERTConstrFunc cf)
diff --git a/liboctave/DASPK.h b/liboctave/DASPK.h
--- a/liboctave/DASPK.h
+++ b/liboctave/DASPK.h
@@ -36,31 +36,31 @@ DASPK : public DAE, public DASPK_options
 public:
 
   DASPK (void) : DAE (), DASPK_options (), initialized (false) { }
 
   DASPK (const ColumnVector& s, double tm, DAEFunc& f)
     : DAE (s, tm, f), DASPK_options (), initialized (false) { }
 
   DASPK (const ColumnVector& s, const ColumnVector& deriv,
-	 double tm, DAEFunc& f)
+         double tm, DAEFunc& f)
     : DAE (s, deriv, tm, f), DASPK_options (), initialized (false) { }
 
   ~DASPK (void) { }
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
   Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit); 
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out);
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out,
-		    const ColumnVector& tcrit); 
+                    const ColumnVector& tcrit); 
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
   octave_idx_type liw;  
diff --git a/liboctave/DASRT.h b/liboctave/DASRT.h
--- a/liboctave/DASRT.h
+++ b/liboctave/DASRT.h
@@ -39,21 +39,21 @@ public:
     : x (xx), xdot (xxdot), t (tt) { }
 
   DASRT_result (const DASRT_result& r)
     : x (r.x), xdot (r.xdot), t (r.t) { }
 
   DASRT_result& operator = (const DASRT_result& r)
     {
       if (this != &r)
-	{
-	  x = r.x;
-	  xdot = r.xdot;
+        {
+          x = r.x;
+          xdot = r.xdot;
           t = r.t;
-	}
+        }
       return *this;
     }
 
   ~DASRT_result (void) { }
 
   Matrix state (void) const { return x; }
   Matrix deriv (void) const { return xdot; }
   ColumnVector times (void) const { return t; }
@@ -72,25 +72,25 @@ DASRT : public DAERT, public DASRT_optio
 public:
 
   DASRT (void) : DAERT (), DASRT_options (), initialized (false) { }
 
   DASRT (const ColumnVector& s, double tm, DAERTFunc& f)
     : DAERT (s, tm, f), DASRT_options (), initialized (false) { }
 
   DASRT (const ColumnVector& s, const ColumnVector& deriv,
-	 double tm, DAERTFunc& f)
+         double tm, DAERTFunc& f)
     : DAERT (s, deriv, tm, f), DASRT_options (), initialized (false) { }
 
   ~DASRT (void) { }
 
   DASRT_result integrate (const ColumnVector& tout);
 
   DASRT_result integrate (const ColumnVector& tout,
-			  const ColumnVector& tcrit); 
+                          const ColumnVector& tcrit); 
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
   octave_idx_type liw;  
diff --git a/liboctave/DASSL.h b/liboctave/DASSL.h
--- a/liboctave/DASSL.h
+++ b/liboctave/DASSL.h
@@ -36,31 +36,31 @@ DASSL : public DAE, public DASSL_options
 public:
 
   DASSL (void) : DAE (), DASSL_options (), initialized (false) { }
 
   DASSL (const ColumnVector& s, double tm, DAEFunc& f)
     : DAE (s, tm, f), DASSL_options (), initialized (false) { }
 
   DASSL (const ColumnVector& s, const ColumnVector& deriv,
-	 double tm, DAEFunc& f)
+         double tm, DAEFunc& f)
     : DAE (s, deriv, tm, f), DASSL_options (), initialized (false) { }
 
   ~DASSL (void) { }
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
   Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit); 
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out);
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out,
-		    const ColumnVector& tcrit); 
+                    const ColumnVector& tcrit); 
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
   octave_idx_type liw;  
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -104,17 +104,17 @@ public:
 
   DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) 
     : Array<T> (std::min (r, c), val), d1 (r), d2 (c) { }
 
   DiagArray2 (const dim_vector& dv)
     : Array<T> (std::min (dv(0), dv(1))), d1 (dv(0)), d2 (dv(0))
     {
       if (dv.length () != 2)
-	(*current_liboctave_error_handler) ("too many dimensions");
+        (*current_liboctave_error_handler) ("too many dimensions");
     }
 
   DiagArray2 (const Array<T>& a) 
     : Array<T> (a), d1 (a.numel ()), d2 (a.numel ()) { }
 
   DiagArray2 (const DiagArray2<T>& a) 
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
diff --git a/liboctave/EIG.h b/liboctave/EIG.h
--- a/liboctave/EIG.h
+++ b/liboctave/EIG.h
@@ -67,20 +67,20 @@ public:
     { info = init (a, b, calc_eigenvectors); }
 
   EIG (const EIG& a)
     : lambda (a.lambda), v (a.v) { }
 
   EIG& operator = (const EIG& a)
     {
       if (this != &a)
-	{
-	  lambda = a.lambda;
-	  v = a.v;
-	}
+        {
+          lambda = a.lambda;
+          v = a.v;
+        }
       return *this;
     }
 
   ~EIG (void) { }
 
   ComplexColumnVector eigenvalues (void) const { return lambda; }
 
   ComplexMatrix eigenvectors (void) const { return v; }
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -69,17 +69,17 @@ public:
       Array<T>::operator = (a);
       return *this;
     }
 
   MArrayN<T> reshape (const dim_vector& new_dims) const
     { return Array<T>::reshape (new_dims); }
 
   MArrayN<T> permute (const Array<octave_idx_type>& vec, 
-		      bool inv = false) const
+                      bool inv = false) const
     { return Array<T>::permute (vec, inv); }
 
   MArrayN<T> ipermute (const Array<octave_idx_type>& vec) const
     { return Array<T>::ipermute (vec); }
 
   MArrayN squeeze (void) const { return Array<T>::squeeze (); }
 
   MArrayN<T> diag (octave_idx_type k) const
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -81,20 +81,20 @@ public:
     {
       octave_idx_type retval = 0;
 
       const T *d = this->data ();
 
       octave_idx_type nel = this->length ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-	{
-	  if (d[i] != T ())
-	    retval++;
-	}
+        {
+          if (d[i] != T ())
+            retval++;
+        }
 
       return retval;
     }
 
   MArray<T> diag (octave_idx_type k = 0) const
     { return DiagArray2<T>::diag (k); }
 
   MDiagArray2<T> transpose (void) const { return DiagArray2<T>::transpose (); }
diff --git a/liboctave/MSparse-defs.h b/liboctave/MSparse-defs.h
--- a/liboctave/MSparse-defs.h
+++ b/liboctave/MSparse-defs.h
@@ -101,44 +101,44 @@ along with Octave; see the file COPYING.
 // A macro that can be used to declare and instantiate binary operators.
 #define SPARSE_BINOP_DECL(A_T, E_T, F, PFX, API, LTGT, X_T, Y_T) \
   PFX API A_T<E_T> \
   F LTGT (const X_T&, const Y_T&)
 
 // All the binary operators that we care about.  We have two
 // sets of macros since the MArray OP MArray operations use functions
 // (product and quotient) instead of operators (*, /).
-#define SPARSE_BINOP_DECLS(A_T, F_T, E_T, PFX, API, LTGT, X_T, Y_T)	 \
+#define SPARSE_BINOP_DECLS(A_T, F_T, E_T, PFX, API, LTGT, X_T, Y_T)      \
   SPARSE_BINOP_DECL (F_T, E_T, operator +, PFX, API, LTGT, X_T, Y_T); \
   SPARSE_BINOP_DECL (F_T, E_T, operator -, PFX, API, LTGT, X_T, Y_T); \
   SPARSE_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
   SPARSE_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
 
 #define SPARSE_AA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
   SPARSE_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
   SPARSE_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
   SPARSE_BINOP_DECL (A_T, E_T, quotient,   PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
   SPARSE_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
 
 // Generate forward declarations for binary operators.
 #define SPARSE_BINOP_FWD_DECLS(A_T, F_T, API) \
-  SPARSE_BINOP_DECLS (A_T, F_T, T, template <typename T>, API, , A_T<T>, T)	\
+  SPARSE_BINOP_DECLS (A_T, F_T, T, template <typename T>, API, , A_T<T>, T)     \
   SPARSE_BINOP_DECLS (A_T, F_T, T, template <typename T>, API, , T, A_T<T>) \
   SPARSE_AA_BINOP_DECLS (A_T, T, template <typename T>, API, )
 
 // Generate friend declarations for the binary operators.
-#define SPARSE_BINOP_FRIENDS(A_T, F_T, API)		     \
-  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, API, <>, A_T<T>, T)	\
-  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, API, <>, T, A_T<T>)	\
+#define SPARSE_BINOP_FRIENDS(A_T, F_T, API)                  \
+  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, API, <>, A_T<T>, T)  \
+  SPARSE_BINOP_DECLS (A_T, F_T, T, friend, API, <>, T, A_T<T>)  \
   SPARSE_AA_BINOP_DECLS (A_T, T, friend, API, <>)
 
 // Instantiate the binary operators.
 #define SPARSE_BINOP_DEFS(A_T, F_T, E_T, API) \
-  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template, API, , A_T<E_T>, E_T)	\
-  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template, API, , E_T, A_T<E_T>)	\
+  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template, API, , A_T<E_T>, E_T)    \
+  SPARSE_BINOP_DECLS (A_T, F_T, E_T, template, API, , E_T, A_T<E_T>)    \
   SPARSE_AA_BINOP_DECLS (A_T, E_T, template, API, )
 
 // A function that can be used to forward binary operations from derived
 // classes back to us.
 #define SPARSE_BINOP_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
   inline R \
   F (const X_T& x, const Y_T& y) \
   { \
@@ -183,31 +183,31 @@ along with Octave; see the file COPYING.
 #define INSTANTIATE_SPARSE_FRIENDS(T, API) \
   /* SPARSE_OP_ASSIGN_DEFS (MSparse, T, T) */ \
   SPARSE_OP_ASSIGN_DEFS (MSparse, T, MSparse<T>, API) \
   SPARSE_UNOP_DEFS (MSparse, T, API) \
   SPARSE_BINOP_DEFS (MSparse, MArray2, T, API)
 
 // Define all the MSparse forwarding functions for return type R and
 // MSparse element type T
-#define SPARSE_FORWARD_DEFS(B, R, F, T) 	\
-  /* SPARSE_OP_ASSIGN_FWD_DEFS	*/ \
-  /* (R, T, dynamic_cast<B<T>&>, R, , T) */	\
+#define SPARSE_FORWARD_DEFS(B, R, F, T)         \
+  /* SPARSE_OP_ASSIGN_FWD_DEFS  */ \
+  /* (R, T, dynamic_cast<B<T>&>, R, , T) */     \
  \
   SPARSE_OP_ASSIGN_FWD_DEFS \
     (R, T, \
      dynamic_cast<B<T>&>, R, dynamic_cast<const B<T>&>, R) \
  \
   SPARSE_UNOP_FWD_DEFS \
     (R, T, dynamic_cast<const B<T>&>, R) \
  \
   SPARSE_BINOP_FWD_DEFS \
     (R, F, T, dynamic_cast<const B<T>&>, R, , T) \
  \
   SPARSE_BINOP_FWD_DEFS \
-    (R, F, T, , T, dynamic_cast<const B<T>&>, R)	\
+    (R, F, T, , T, dynamic_cast<const B<T>&>, R)        \
  \
   SPARSE_AA_BINOP_FWD_DEFS \
     (R, T, dynamic_cast<const B<T>&>, R, dynamic_cast<const B<T>&>, R)
 
 // Now we have all the definitions we need.
 
 #endif
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -51,23 +51,23 @@ public:
 
   MSparse (const MSparse<T>& a) : Sparse<T> (a) { }
 
   MSparse (const MSparse<T>& a, const dim_vector& dv) : Sparse<T> (a, dv) { }
 
   MSparse (const Sparse<T>& a) : Sparse<T> (a) { }
 
   MSparse (const Array<T> a, const Array<octave_idx_type>& r, 
-	   const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
-	   octave_idx_type nc = -1, bool sum_terms = true)
+           const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+           octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<T> (a, r, c, nr, nc, sum_terms) { }
 
   MSparse (const Array<T> a, const Array<double>& r, 
-	   const Array<double>& c, octave_idx_type nr = -1, 
-	   octave_idx_type nc = -1, bool sum_terms = true)
+           const Array<double>& c, octave_idx_type nr = -1, 
+           octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<T> (a, r, c, nr, nc, sum_terms) { }
 
   explicit MSparse (octave_idx_type r, octave_idx_type c, T val) : Sparse<T> (r, c, val) { }
 
   MSparse (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<T> (r, c, num_nz) { }
 
   ~MSparse (void) { }
 
diff --git a/liboctave/MatrixType.h b/liboctave/MatrixType.h
--- a/liboctave/MatrixType.h
+++ b/liboctave/MatrixType.h
@@ -67,20 +67,20 @@ public:
 
   MatrixType (const SparseMatrix &a);
 
   MatrixType (const SparseComplexMatrix &a);
 
   MatrixType (const matrix_type t, bool _full = false);
 
   MatrixType (const matrix_type t, const octave_idx_type np,
-	      const octave_idx_type *p, bool _full = false);
+              const octave_idx_type *p, bool _full = false);
 
   MatrixType (const matrix_type t, const octave_idx_type ku, 
-	      const octave_idx_type kl, bool _full = false);
+              const octave_idx_type kl, bool _full = false);
 
   ~MatrixType (void);
 
   MatrixType& operator = (const MatrixType& a);
 
   int type (bool quiet = true);
 
   int type (const Matrix &a);
@@ -115,17 +115,17 @@ public:
    bool is_banded (void)
     { return (typ == Banded || typ == Banded_Hermitian); }
   
   bool is_tridiagonal (void) const
     { return (typ == Tridiagonal || typ == Tridiagonal_Hermitian); }
   
   bool is_hermitian (void) const
     { return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian ||
-	      typ == Hermitian); }
+              typ == Hermitian); }
 
   bool is_rectangular (void) const { return (typ == Rectangular); }
 
   bool is_known (void) const { return (typ != Unknown); }
 
   bool is_unknown (void) const { return (typ == Unknown); }
 
   void info (void) const;
diff --git a/liboctave/ODE.h b/liboctave/ODE.h
--- a/liboctave/ODE.h
+++ b/liboctave/ODE.h
@@ -39,20 +39,20 @@ public:
     : base_diff_eqn (s, tm), ODEFunc (f) { }
 
   ODE (const ODE& a)
     : base_diff_eqn (a), ODEFunc (a) { }
 
   ODE& operator = (const ODE& a)
     {
       if (this != &a)
-	{
-	  base_diff_eqn::operator = (a);
-	  ODEFunc::operator = (a);
-	}
+        {
+          base_diff_eqn::operator = (a);
+          ODEFunc::operator = (a);
+        }
       return *this;
     }
 
   ~ODE (void) { }
 
   // Derived classes must provide functions to actually do the
   // integration.
 
@@ -60,17 +60,17 @@ public:
   virtual ColumnVector do_integrate (double tt) = 0;
 
   // Return a matrix of states at each output time specified by t.
   // The rows of the result matrix should each correspond to a new
   // output time.
   virtual Matrix do_integrate (const ColumnVector& tt) = 0;
 
   virtual Matrix do_integrate (const ColumnVector& tt,
-			       const ColumnVector& ttcrit) = 0;
+                               const ColumnVector& ttcrit) = 0;
 
   // Lots of ways to call the single function and optionally set and
   // get additional information.
 
   // Integrate to t from current point.
   virtual ColumnVector integrate (double tt)
     { return do_integrate (tt); }
 
@@ -84,32 +84,32 @@ public:
   // Integrate from current point and return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& tt)
     { return do_integrate (tt); }
 
   // Set new x0, t0 and integrate to return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& x0, double t0,
-			    const ColumnVector& tt)
+                            const ColumnVector& tt)
     {
       initialize (x0, t0);
       return do_integrate (tt);
     }
 
   // Integrate from current point and return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& tt,
-			    const ColumnVector& ttcrit)
+                            const ColumnVector& ttcrit)
     { return do_integrate (tt, ttcrit); }
 
   // Set new x0, t0 and integrate to return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& x0, double t0,
-			    const ColumnVector& tt,
-			    const ColumnVector& ttcrit)
+                            const ColumnVector& tt,
+                            const ColumnVector& ttcrit)
     {
       initialize (x0, t0);
       return do_integrate (tt, ttcrit);
     }
 };
 
 #endif
diff --git a/liboctave/ODEFunc.h b/liboctave/ODEFunc.h
--- a/liboctave/ODEFunc.h
+++ b/liboctave/ODEFunc.h
@@ -45,21 +45,21 @@ public:
     : fun (f), jac (j), reset (true) { }
 
   ODEFunc (const ODEFunc& a)
     : fun (a.fun), jac (a.jac), reset (true) { }
 
   ODEFunc& operator = (const ODEFunc& a)
     {
       if (this != &a)
-	{
-	  fun = a.fun;
-	  jac = a.jac;
-	  reset = a.reset;
-	}
+        {
+          fun = a.fun;
+          jac = a.jac;
+          reset = a.reset;
+        }
       return *this;
     }
 
   ~ODEFunc (void) { }
 
   ODERHSFunc function (void) const { return fun; }
 
   ODEFunc& set_function (ODERHSFunc f)
diff --git a/liboctave/ODES.h b/liboctave/ODES.h
--- a/liboctave/ODES.h
+++ b/liboctave/ODES.h
@@ -33,44 +33,44 @@ public:
 
   ODES (void)
     : base_diff_eqn (), ODESFunc (), theta () { }
 
   ODES (const ColumnVector& s, double tm, ODESFunc& f)
     : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.length (), 0.0), theta () { }
 
   ODES (const ColumnVector& s, const ColumnVector& xtheta, double tm,
-	ODESFunc& f)
+        ODESFunc& f)
     : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.length (), 0.0),
       theta (xtheta) { }
 
   ODES (const ODES& a)
     : base_diff_eqn (a), ODESFunc (a), theta (a.theta) { }
 
   ODES& operator = (const ODES& a)
     {
       if (this != &a)
-	{
-	  base_diff_eqn::operator = (a);
-	  ODESFunc::operator = (a);
+        {
+          base_diff_eqn::operator = (a);
+          ODESFunc::operator = (a);
 
-	  xdot = a.xdot;
-	  theta = a.theta;
-	}
+          xdot = a.xdot;
+          theta = a.theta;
+        }
       return *this;
     }
 
   ~ODES (void) { }
 
   ColumnVector parameter_vector (void) { return theta; }
 
   void initialize (const ColumnVector& x, double t);
 
   void initialize (const ColumnVector& x, double t,
-		   const ColumnVector& theta);
+                   const ColumnVector& theta);
 
 protected:
 
   // State vector time derivatives.
   ColumnVector xdot;
 
   // Parameter vector.
   ColumnVector theta;
diff --git a/liboctave/ODESFunc.h b/liboctave/ODESFunc.h
--- a/liboctave/ODESFunc.h
+++ b/liboctave/ODESFunc.h
@@ -32,23 +32,23 @@ public:
 
   struct DAEJac
     {
       Matrix *dfdxdot;
       Matrix *dfdx;
     };
 
   typedef ColumnVector (*ODES_fsub) (const ColumnVector& x, double,
-				     const ColumnVector& theta); 
+                                     const ColumnVector& theta); 
 
   typedef ColumnVector (*ODES_bsub) (const ColumnVector& x, double,
-				     const ColumnVector& theta, int column);
+                                     const ColumnVector& theta, int column);
 
   typedef Matrix (*ODES_jsub) (const ColumnVector& x, double,
-			       const ColumnVector& theta);
+                               const ColumnVector& theta);
 
   ODESFunc (void)
     : fsub (0), bsub (0), jsub (0) { }
 
   ODESFunc (ODES_fsub f)
     : fsub (f), bsub (0), jsub (0) { }
 
   ODESFunc (ODES_fsub f, ODES_bsub b)
@@ -58,21 +58,21 @@ public:
     : fsub (f), bsub (b), jsub (j) { }
 
   ODESFunc (const ODESFunc& a)
     : fsub (a.fsub), bsub (a.bsub), jsub (a.jsub) { }
 
   ODESFunc& operator = (const ODESFunc& a)
     {
       if (this != &a)
-	{
-	  fsub = a.fsub;
-	  bsub = a.bsub;
-	  jsub = a.jsub;
-	}
+        {
+          fsub = a.fsub;
+          bsub = a.bsub;
+          jsub = a.jsub;
+        }
       return *this;
     }
 
   ~ODESFunc (void) { }
 
   ODES_fsub fsub_function (void) const { return fsub; }
 
   ODESFunc& set_fsub_function (ODES_fsub f)
diff --git a/liboctave/Quad.h b/liboctave/Quad.h
--- a/liboctave/Quad.h
+++ b/liboctave/Quad.h
@@ -128,17 +128,17 @@ DefQuad : public Quad
 
   DefQuad (integrand_fcn fcn)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0), singularities () { }
 
   DefQuad (integrand_fcn fcn, double ll, double ul)
     : Quad (fcn), lower_limit (ll), upper_limit (ul), singularities () { }
 
   DefQuad (integrand_fcn fcn, double ll, double ul,
-	   const ColumnVector& sing)
+           const ColumnVector& sing)
     : Quad (fcn), lower_limit (ll), upper_limit (ul),
       singularities (sing) { }
 
   DefQuad (integrand_fcn fcn, const ColumnVector& sing)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0),
       singularities (sing) { }
 
   ~DefQuad (void) { }
@@ -190,17 +190,17 @@ FloatDefQuad : public Quad
 
   FloatDefQuad (float_integrand_fcn fcn)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0), singularities () { }
 
   FloatDefQuad (float_integrand_fcn fcn, float ll, float ul)
     : Quad (fcn), lower_limit (ll), upper_limit (ul), singularities () { }
 
   FloatDefQuad (float_integrand_fcn fcn, float ll, float ul,
-	   const FloatColumnVector& sing)
+           const FloatColumnVector& sing)
     : Quad (fcn), lower_limit (ll), upper_limit (ul),
       singularities (sing) { }
 
   FloatDefQuad (float_integrand_fcn fcn, const FloatColumnVector& sing)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0),
       singularities (sing) { }
 
   ~FloatDefQuad (void) { }
diff --git a/liboctave/Range.h b/liboctave/Range.h
--- a/liboctave/Range.h
+++ b/liboctave/Range.h
@@ -68,17 +68,17 @@ Range
   void sort_internal (bool ascending = true);
   void sort_internal (Array<octave_idx_type>& sidx, bool ascending = true);
 
   Matrix diag (octave_idx_type k = 0) const;
 
   Range sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
 
   Range sort (Array<octave_idx_type>& sidx, octave_idx_type dim = 0,
-	      sortmode mode = ASCENDING) const;
+              sortmode mode = ASCENDING) const;
 
   sortmode is_sorted (sortmode mode = ASCENDING) const;
 
   // Support for single-index subscripting, without generating matrix cache.
 
   double checkelem (octave_idx_type i) const;
 
   double elem (octave_idx_type i) const
@@ -91,36 +91,36 @@ Range
     }
 
   Array<double> index (const idx_vector& i) const;
 
   void set_base (double b)
   {
     if (rng_base != b)
       {
-	rng_base = b;
-	clear_cache ();
+        rng_base = b;
+        clear_cache ();
       }
   }
 
   void set_limit (double l)
   {
     if (rng_limit != l)
       {
-	rng_limit = l;
-	clear_cache ();
+        rng_limit = l;
+        clear_cache ();
       }
   }
 
   void set_inc (double i)
   {
     if (rng_inc != i)
       {
-	rng_inc = i;
-	clear_cache ();
+        rng_inc = i;
+        clear_cache ();
       }
   }
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const Range& r);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, Range& r);
 
   friend OCTAVE_API Range operator - (const Range& r);
   friend OCTAVE_API Range operator + (double x, const Range& r);
diff --git a/liboctave/Sparse-diag-op-defs.h b/liboctave/Sparse-diag-op-defs.h
--- a/liboctave/Sparse-diag-op-defs.h
+++ b/liboctave/Sparse-diag-op-defs.h
@@ -43,17 +43,17 @@ RT do_mul_dm_sm (const DM& d, const SM& 
    {
      RT r (nr, a_nc, a.nnz ());
 
      octave_idx_type l = 0;
 
      for (octave_idx_type j = 0; j < a_nc; j++)
        {
          r.xcidx (j) = l;
-	 const octave_idx_type colend = a.cidx (j+1);
+         const octave_idx_type colend = a.cidx (j+1);
          for (octave_idx_type k = a.cidx (j); k < colend; k++)
            {
              const octave_idx_type i = a.ridx (k);
              if (i >= nr) break;
              r.xdata (l) = d.dgelem (i) * a.data (k);
              r.xridx (l) = i;
              l++;
            }
@@ -83,24 +83,24 @@ RT do_mul_sm_dm (const SM& a, const DM& 
   else
    {
 
      const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
      RT r (a_nr, nc, a.cidx (mnc));
 
      for (octave_idx_type j = 0; j < mnc; ++j)
        {
-	 const typename DM::element_type s = d.dgelem (j);
-	 const octave_idx_type colend = a.cidx (j+1);
-	 r.xcidx (j) = a.cidx (j);
-	 for (octave_idx_type k = a.cidx (j); k < colend; ++k)
-	   {
-	     r.xdata (k) = s * a.data (k);
-	     r.xridx (k) = a.ridx (k);
-	   }
+         const typename DM::element_type s = d.dgelem (j);
+         const octave_idx_type colend = a.cidx (j+1);
+         r.xcidx (j) = a.cidx (j);
+         for (octave_idx_type k = a.cidx (j); k < colend; ++k)
+           {
+             r.xdata (k) = s * a.data (k);
+             r.xridx (k) = a.ridx (k);
+           }
        }
      for (octave_idx_type j = mnc; j <= nc; ++j)
        r.xcidx (j) = a.cidx (mnc);
 
      r.maybe_compress (true);
      return r;
    }
 }
@@ -173,18 +173,18 @@ RT inner_do_add_sm_dm (const SM& a, cons
   return r;
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_commutative_add_dm_sm (const DM& d, const SM& a)
 {
   // Extra function to ensure this is only emitted once.
   return inner_do_add_sm_dm<RT> (a, d,
-				 identity_val<typename SM::element_type> (),
-				 identity_val<typename DM::element_type> ());
+                                 identity_val<typename SM::element_type> (),
+                                 identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_add_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
       gripe_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
@@ -199,17 +199,17 @@ RT do_sub_dm_sm (const DM& d, const SM& 
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
       gripe_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
       return RT ();
     }
   else
     return inner_do_add_sm_dm<RT> (a, d, std::negate<typename SM::element_type> (),
-				   identity_val<typename DM::element_type> ());
+                                   identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_add_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
       gripe_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
@@ -224,13 +224,13 @@ RT do_sub_sm_dm (const SM& a, const DM& 
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
       gripe_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
       return RT ();
     }
   else
     return inner_do_add_sm_dm<RT> (a, d,
-				   identity_val<typename SM::element_type> (),
-				   std::negate<typename DM::element_type> ());
+                                   identity_val<typename SM::element_type> (),
+                                   std::negate<typename DM::element_type> ());
 }
 
 #endif // octave_sparse_diag_op_defs_h
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -41,45 +41,45 @@ along with Octave; see the file COPYING.
 // matrix by scalar operations.
 
 #define SPARSE_SMS_BIN_OP_DECLS(R1, R2, M, S, API)  \
   SPARSE_BIN_OP_DECL (R1, operator +, M, S, API); \
   SPARSE_BIN_OP_DECL (R1, operator -, M, S, API); \
   SPARSE_BIN_OP_DECL (R2, operator *, M, S, API); \
   SPARSE_BIN_OP_DECL (R2, operator /, M, S, API);
 
-#define SPARSE_SMS_BIN_OP_1(R, F, OP, M, S)	\
+#define SPARSE_SMS_BIN_OP_1(R, F, OP, M, S)     \
   R \
   F (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
  \
     R r (nr, nc, (0.0 OP s)); \
  \
     for (octave_idx_type j = 0; j < nc; j++) \
       for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
         r.elem (m.ridx (i), j) = m.data (i) OP s; \
     return r; \
   }
 
-#define SPARSE_SMS_BIN_OP_2(R, F, OP, M, S)	\
+#define SPARSE_SMS_BIN_OP_2(R, F, OP, M, S)     \
   R \
   F (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-	r.data(i) = m.data(i) OP s; \
-	r.ridx(i) = m.ridx(i); \
+        r.data(i) = m.data(i) OP s; \
+        r.ridx(i) = m.ridx(i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = m.cidx(i); \
     \
     r.maybe_compress (true); \
     return r; \
   }
 
@@ -96,118 +96,118 @@ along with Octave; see the file COPYING.
   SPARSE_CMP_OP_DECL (mx_el_gt, M, S, API); \
   SPARSE_CMP_OP_DECL (mx_el_eq, M, S, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M, S, API);
 
 #define SPARSE_SMS_EQNE_OP_DECLS(M, S, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, M, S, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M, S, API);
 
-#define SPARSE_SMS_CMP_OP(F, OP, M, MZ, MC, S, SZ, SC)	\
+#define SPARSE_SMS_CMP_OP(F, OP, M, MZ, MC, S, SZ, SC)  \
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (MC (MZ) OP SC (s)) \
       { \
         r = SparseBoolMatrix (nr, nc, true); \
-	for (octave_idx_type j = 0; j < nc; j++) \
-	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+        for (octave_idx_type j = 0; j < nc; j++) \
+          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
             if (! (MC (m.data (i)) OP SC (s))) \
               r.data (m.ridx (i) + j * nr) = false; \
         r.maybe_compress (true); \
       } \
     else \
       { \
         r = SparseBoolMatrix (nr, nc, m.nnz ()); \
         r.cidx (0) = static_cast<octave_idx_type> (0); \
         octave_idx_type nel = 0; \
-	for (octave_idx_type j = 0; j < nc; j++) \
+        for (octave_idx_type j = 0; j < nc; j++) \
           { \
-	    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
               if (MC (m.data (i)) OP SC (s)) \
                 { \
                   r.ridx (nel) = m.ridx (i); \
                   r.data (nel++) = true; \
                 } \
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
       } \
     return r; \
   }
 
-#define SPARSE_SMS_CMP_OPS(M, MZ, CM, S, SZ, CS)	\
-  SPARSE_SMS_CMP_OP (mx_el_lt, <,  M, MZ,   , S, SZ,   )	\
-  SPARSE_SMS_CMP_OP (mx_el_le, <=, M, MZ,   , S, SZ,   )	\
-  SPARSE_SMS_CMP_OP (mx_el_ge, >=, M, MZ,   , S, SZ,   )	\
-  SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, MZ,   , S, SZ,   )	\
-  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )	\
+#define SPARSE_SMS_CMP_OPS(M, MZ, CM, S, SZ, CS)        \
+  SPARSE_SMS_CMP_OP (mx_el_lt, <,  M, MZ,   , S, SZ,   )        \
+  SPARSE_SMS_CMP_OP (mx_el_le, <=, M, MZ,   , S, SZ,   )        \
+  SPARSE_SMS_CMP_OP (mx_el_ge, >=, M, MZ,   , S, SZ,   )        \
+  SPARSE_SMS_CMP_OP (mx_el_gt, >,  M, MZ,   , S, SZ,   )        \
+  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )        \
   SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ,   , S, SZ,   )
 
-#define SPARSE_SMS_EQNE_OPS(M, MZ, CM, S, SZ, CS)	\
-  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )	\
+#define SPARSE_SMS_EQNE_OPS(M, MZ, CM, S, SZ, CS)       \
+  SPARSE_SMS_CMP_OP (mx_el_eq, ==, M, MZ,   , S, SZ,   )        \
   SPARSE_SMS_CMP_OP (mx_el_ne, !=, M, MZ,   , S, SZ,   )
 
 #define SPARSE_SMS_BOOL_OP_DECLS(M, S, API) \
   SPARSE_BOOL_OP_DECL (mx_el_and, M, S, API); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  M, S, API);
 
 #define SPARSE_SMS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
-	if (LHS_ZERO OP (s != RHS_ZERO)) \
-	  { \
+        if (LHS_ZERO OP (s != RHS_ZERO)) \
+          { \
             r = SparseBoolMatrix (nr, nc, true); \
-	    for (octave_idx_type j = 0; j < nc; j++) \
-	      for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type j = 0; j < nc; j++) \
+              for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
                 if (! ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))) \
                   r.data (m.ridx (i) + j * nr) = false; \
             r.maybe_compress (true); \
           } \
-	else \
-	  { \
+        else \
+          { \
             r = SparseBoolMatrix (nr, nc, m.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < nc; j++) \
+            for (octave_idx_type j = 0; j < nc; j++) \
               { \
-	        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+                for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
                   if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO)) \
                     { \
                       r.ridx (nel) = m.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
-      }	\
+      } \
     return r; \
   }
 
 #define SPARSE_SMS_BOOL_OPS2(M, S, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMS_BOOL_OP (mx_el_and, &&, M, S, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMS_BOOL_OP (mx_el_or,  ||, M, S, LHS_ZERO, RHS_ZERO)
 
 #define SPARSE_SMS_BOOL_OPS(M, S, ZERO) \
   SPARSE_SMS_BOOL_OPS2(M, S, ZERO, ZERO)
 
 #define SPARSE_SMS_OP_DECLS(R1, R2, M, S, API) \
-  SPARSE_SMS_BIN_OP_DECLS (R1, R2, M, S, API)	 \
+  SPARSE_SMS_BIN_OP_DECLS (R1, R2, M, S, API)    \
   SPARSE_SMS_CMP_OP_DECLS (M, S, API) \
   SPARSE_SMS_BOOL_OP_DECLS (M, S, API)
 
 // scalar by matrix operations.
 
 #define SPARSE_SSM_BIN_OP_DECLS(R1, R2, S, M, API)    \
   SPARSE_BIN_OP_DECL (R1, operator +, S, M, API); \
   SPARSE_BIN_OP_DECL (R1, operator -, S, M, API); \
@@ -237,18 +237,18 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-	r.data(i) = s OP m.data(i); \
-	r.ridx(i) = m.ridx(i); \
+        r.data(i) = s OP m.data(i); \
+        r.ridx(i) = m.ridx(i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
       r.cidx(i) = m.cidx(i); \
  \
     r.maybe_compress(true); \
     return r; \
   }
 
@@ -265,130 +265,130 @@ along with Octave; see the file COPYING.
   SPARSE_CMP_OP_DECL (mx_el_gt, S, M, API); \
   SPARSE_CMP_OP_DECL (mx_el_eq, S, M, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, S, M, API);
 
 #define SPARSE_SSM_EQNE_OP_DECLS(S, M, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, S, M, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, S, M, API);
 
-#define SPARSE_SSM_CMP_OP(F, OP, S, SZ, SC, M, MZ, MC)	\
+#define SPARSE_SSM_CMP_OP(F, OP, S, SZ, SC, M, MZ, MC)  \
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (SC (s) OP SC (MZ)) \
       { \
         r = SparseBoolMatrix (nr, nc, true); \
-	for (octave_idx_type j = 0; j < nc; j++) \
-	  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+        for (octave_idx_type j = 0; j < nc; j++) \
+          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
             if (! (SC (s) OP MC (m.data (i)))) \
               r.data (m.ridx (i) + j * nr) = false; \
         r.maybe_compress (true); \
       } \
     else \
       { \
         r = SparseBoolMatrix (nr, nc, m.nnz ()); \
         r.cidx (0) = static_cast<octave_idx_type> (0); \
         octave_idx_type nel = 0; \
-	for (octave_idx_type j = 0; j < nc; j++) \
+        for (octave_idx_type j = 0; j < nc; j++) \
           { \
-	    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
               if (SC (s) OP MC (m.data (i))) \
                 { \
                   r.ridx (nel) = m.ridx (i); \
                   r.data (nel++) = true; \
                 } \
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
       } \
     return r; \
   }
 
-#define SPARSE_SSM_CMP_OPS(S, SZ, SC, M, MZ, MC)	\
-  SPARSE_SSM_CMP_OP (mx_el_lt, <,  S, SZ,   , M, MZ,   )	\
-  SPARSE_SSM_CMP_OP (mx_el_le, <=, S, SZ,   , M, MZ,   )	\
-  SPARSE_SSM_CMP_OP (mx_el_ge, >=, S, SZ,   , M, MZ,   )	\
-  SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, SZ,   , M, MZ,   )	\
-  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )	\
+#define SPARSE_SSM_CMP_OPS(S, SZ, SC, M, MZ, MC)        \
+  SPARSE_SSM_CMP_OP (mx_el_lt, <,  S, SZ,   , M, MZ,   )        \
+  SPARSE_SSM_CMP_OP (mx_el_le, <=, S, SZ,   , M, MZ,   )        \
+  SPARSE_SSM_CMP_OP (mx_el_ge, >=, S, SZ,   , M, MZ,   )        \
+  SPARSE_SSM_CMP_OP (mx_el_gt, >,  S, SZ,   , M, MZ,   )        \
+  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )        \
   SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ,   , M, MZ,   )
 
-#define SPARSE_SSM_EQNE_OPS(S, SZ, SC, M, MZ, MC)	\
-  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )	\
+#define SPARSE_SSM_EQNE_OPS(S, SZ, SC, M, MZ, MC)       \
+  SPARSE_SSM_CMP_OP (mx_el_eq, ==, S, SZ,   , M, MZ,   )        \
   SPARSE_SSM_CMP_OP (mx_el_ne, !=, S, SZ,   , M, MZ,   )
 
 #define SPARSE_SSM_BOOL_OP_DECLS(S, M, API) \
   SPARSE_BOOL_OP_DECL (mx_el_and, S, M, API); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  S, M, API); \
 
 #define SPARSE_SSM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
-	if ((s != LHS_ZERO) OP RHS_ZERO) \
-	  { \
+        if ((s != LHS_ZERO) OP RHS_ZERO) \
+          { \
             r = SparseBoolMatrix (nr, nc, true); \
-	    for (octave_idx_type j = 0; j < nc; j++) \
-	      for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type j = 0; j < nc; j++) \
+              for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
                 if (! ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO))) \
                   r.data (m.ridx (i) + j * nr) = false; \
             r.maybe_compress (true); \
           } \
-	else \
-	  { \
+        else \
+          { \
             r = SparseBoolMatrix (nr, nc, m.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < nc; j++) \
+            for (octave_idx_type j = 0; j < nc; j++) \
               { \
-	        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+                for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
                   if ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO)) \
                     { \
                       r.ridx (nel) = m.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
-      }	\
+      } \
     return r; \
   }
 
 #define SPARSE_SSM_BOOL_OPS2(S, M, LHS_ZERO, RHS_ZERO) \
   SPARSE_SSM_BOOL_OP (mx_el_and, &&, S, M, LHS_ZERO, RHS_ZERO) \
   SPARSE_SSM_BOOL_OP (mx_el_or,  ||, S, M, LHS_ZERO, RHS_ZERO)
 
 #define SPARSE_SSM_BOOL_OPS(S, M, ZERO) \
   SPARSE_SSM_BOOL_OPS2(S, M, ZERO, ZERO)
 
 #define SPARSE_SSM_OP_DECLS(R1, R2, S, M, API) \
-  SPARSE_SSM_BIN_OP_DECLS (R1, R2, S, M, API)	 \
+  SPARSE_SSM_BIN_OP_DECLS (R1, R2, S, M, API)    \
   SPARSE_SSM_CMP_OP_DECLS (S, M, API) \
   SPARSE_SSM_BOOL_OP_DECLS (S, M, API) \
 
 // matrix by matrix operations.
 
-#define SPARSE_SMSM_BIN_OP_DECLS(R1, R2, M1, M2, API)	\
+#define SPARSE_SMSM_BIN_OP_DECLS(R1, R2, M1, M2, API)   \
   SPARSE_BIN_OP_DECL (R1, operator +, M1, M2, API); \
   SPARSE_BIN_OP_DECL (R1, operator -, M1, M2, API); \
   SPARSE_BIN_OP_DECL (R2, product,    M1, M2, API); \
   SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2, API);
 
-#define SPARSE_SMSM_BIN_OP_1(R, F, OP, M1, M2)	\
+#define SPARSE_SMSM_BIN_OP_1(R, F, OP, M1, M2)  \
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
@@ -396,57 +396,57 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if (m1.elem(0,0) == 0.) \
           r = OP R (m2); \
         else \
           { \
-	    r = R (m2_nr, m2_nc, m1.data(0) OP 0.); \
+            r = R (m2_nr, m2_nc, m1.data(0) OP 0.); \
             \
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
                 for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + m2.ridx(i)) = m1.data(0) OP m2.data(i); \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m2.elem(0,0) == 0.) \
           r = R (m1); \
         else \
           { \
-	    r = R (m1_nr, m1_nc, 0. OP m2.data(0)); \
+            r = R (m1_nr, m1_nc, 0. OP m2.data(0)); \
             \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
                 for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.data(0); \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
-	r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
+        r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx(i); \
             octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -465,46 +465,46 @@ along with Octave; see the file COPYING.
                     r.data(jx) = m1.data(ja) OP 0.; \
                     jx++; \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
                   { \
-		    r.ridx(jx) = m2.ridx(jb); \
-		    r.data(jx) = 0. OP m2.data(jb); \
-		    jx++; \
+                    r.ridx(jx) = m2.ridx(jb); \
+                    r.data(jx) = 0. OP m2.data(jb); \
+                    jx++; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-		     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
-	               { \
+                     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
+                       { \
                           r.data(jx) = m1.data(ja) OP m2.data(jb); \
                           r.ridx(jx) = m1.ridx(ja); \
                           jx++; \
                        } \
                      ja++; \
                      ja_lt_max= ja < ja_max; \
                      jb++; \
                      jb_lt_max= jb < jb_max; \
                   } \
               } \
             r.cidx(i+1) = jx; \
           } \
         \
-	r.maybe_compress (); \
+        r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
-#define SPARSE_SMSM_BIN_OP_2(R, F, OP, M1, M2)	\
+#define SPARSE_SMSM_BIN_OP_2(R, F, OP, M1, M2)  \
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
@@ -512,34 +512,34 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if (m1.elem(0,0) == 0.) \
           r = R (m2_nr, m2_nc); \
         else \
           { \
-	    r = R (m2); \
+            r = R (m2); \
             octave_idx_type m2_nnz = m2.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = m1.data(0) OP r.data(i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m2.elem(0,0) == 0.) \
           r = R (m1_nr, m1_nc); \
         else \
           { \
-	    r = R (m1); \
+            r = R (m1); \
             octave_idx_type m1_nnz = m1.nnz(); \
             \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = r.data(i) OP m2.data(0); \
               } \
             r.maybe_compress (); \
@@ -547,17 +547,17 @@ along with Octave; see the file COPYING.
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
-	r.cidx (0) = 0; \
+        r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx(i); \
             octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = m2.cidx(i); \
             octave_idx_type  jb_max = m2.cidx(i+1); \
@@ -573,36 +573,36 @@ along with Octave; see the file COPYING.
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
                   { \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-		     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
-	               { \
+                     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
+                       { \
                           r.data(jx) = m1.data(ja) OP m2.data(jb); \
                           r.ridx(jx) = m1.ridx(ja); \
                           jx++; \
                        } \
                      ja++; ja_lt_max= ja < ja_max; \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
               } \
             r.cidx(i+1) = jx; \
           } \
         \
-	r.maybe_compress (); \
+        r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
-#define SPARSE_SMSM_BIN_OP_3(R, F, OP, M1, M2)	\
+#define SPARSE_SMSM_BIN_OP_3(R, F, OP, M1, M2)  \
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
@@ -625,17 +625,17 @@ along with Octave; see the file COPYING.
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
                 for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + m2.ridx(i)) = m1.elem(0,0) OP m2.data(i); \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if ((Complex() OP m1.elem (0,0)) == Complex()) \
           { \
@@ -651,17 +651,17 @@ along with Octave; see the file COPYING.
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
                 for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.elem(0,0); \
-		  } \
+                  } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
@@ -680,40 +680,40 @@ along with Octave; see the file COPYING.
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
                   { \
-		    /* keep those kludges coming */ \
+                    /* keep those kludges coming */ \
                     r.elem(m1.ridx(ja),i) = m1.data(ja) OP Complex (); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
                      (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
                   { \
-		    /* keep those kludges coming */ \
-                    r.elem(m2.ridx(jb),i) = Complex () OP m2.data(jb);	\
+                    /* keep those kludges coming */ \
+                    r.elem(m2.ridx(jb),i) = Complex () OP m2.data(jb);  \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
                     r.elem(m1.ridx(ja),i) = m1.data(ja) OP m2.data(jb); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
               } \
           } \
-	r.maybe_compress (true); \
+        r.maybe_compress (true); \
       } \
  \
     return r; \
   }
 
 // Note that SM ./ SM needs to take into account the NaN and Inf values
 // implied by the division by zero.
 // FIXME Are the NaNs double(NaN) or Complex(NaN,Nan) in the complex
@@ -735,94 +735,94 @@ along with Octave; see the file COPYING.
 #define SPARSE_SMSM_EQNE_OP_DECLS(M1, M2, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 // FIXME -- this macro duplicatest the bodies of the template
 // functions defined in the SPARSE_SSM_CMP_OP and SPARSE_SMS_CMP_OP
 // macros.
 
-#define SPARSE_SMSM_CMP_OP(F, OP, M1, Z1, C1, M2, Z2, C2)	\
+#define SPARSE_SMSM_CMP_OP(F, OP, M1, Z1, C1, M2, Z2, C2)       \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
     if (C1 (m1.elem(0,0)) OP C2 (Z2)) \
-	  { \
-	    r = SparseBoolMatrix (m2_nr, m2_nc, true); \
-	    for (octave_idx_type j = 0; j < m2_nc; j++) \
-	      for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-		if (! (C1 (m1.elem (0,0)) OP C2 (m2.data(i)))) \
-		  r.data (m2.ridx (i) + j * m2_nr) = false; \
-	    r.maybe_compress (true); \
-	  } \
-	else \
-	  { \
-	    r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
-	    r.cidx (0) = static_cast<octave_idx_type> (0); \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m2_nc; j++) \
-	      { \
-		for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-		  if (C1 (m1.elem (0,0)) OP C2 (m2.data(i))) \
-		    { \
-		      r.ridx (nel) = m2.ridx (i); \
-		      r.data (nel++) = true; \
-		    } \
-		r.cidx (j + 1) = nel; \
-	      }	\
-	    r.maybe_compress (false); \
-	  } \
+          { \
+            r = SparseBoolMatrix (m2_nr, m2_nc, true); \
+            for (octave_idx_type j = 0; j < m2_nc; j++) \
+              for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
+                if (! (C1 (m1.elem (0,0)) OP C2 (m2.data(i)))) \
+                  r.data (m2.ridx (i) + j * m2_nr) = false; \
+            r.maybe_compress (true); \
+          } \
+        else \
+          { \
+            r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
+            r.cidx (0) = static_cast<octave_idx_type> (0); \
+            octave_idx_type nel = 0; \
+            for (octave_idx_type j = 0; j < m2_nc; j++) \
+              { \
+                for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
+                  if (C1 (m1.elem (0,0)) OP C2 (m2.data(i))) \
+                    { \
+                      r.ridx (nel) = m2.ridx (i); \
+                      r.data (nel++) = true; \
+                    } \
+                r.cidx (j + 1) = nel; \
+              } \
+            r.maybe_compress (false); \
+          } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-	if (C1 (Z1) OP C2 (m2.elem (0,0))) \
-	  { \
-	    r = SparseBoolMatrix (m1_nr, m1_nc, true); \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-		if (! (C1 (m1.data (i)) OP C2 (m2.elem(0,0)))) \
-		  r.data (m1.ridx (i) + j * m1_nr) = false; \
-	    r.maybe_compress (true); \
-	  } \
-	else \
-	  { \
-	    r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
-	    r.cidx (0) = static_cast<octave_idx_type> (0); \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      { \
-		for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-		  if (C1 (m1.data (i)) OP C2 (m2.elem(0,0))) \
-		    { \
-		      r.ridx (nel) = m1.ridx (i); \
-		      r.data (nel++) = true; \
-		    } \
-		r.cidx (j + 1) = nel; \
-	      }	\
-	    r.maybe_compress (false); \
-	  } \
+        if (C1 (Z1) OP C2 (m2.elem (0,0))) \
+          { \
+            r = SparseBoolMatrix (m1_nr, m1_nc, true); \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
+                if (! (C1 (m1.data (i)) OP C2 (m2.elem(0,0)))) \
+                  r.data (m1.ridx (i) + j * m1_nr) = false; \
+            r.maybe_compress (true); \
+          } \
+        else \
+          { \
+            r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
+            r.cidx (0) = static_cast<octave_idx_type> (0); \
+            octave_idx_type nel = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              { \
+                for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
+                  if (C1 (m1.data (i)) OP C2 (m2.elem(0,0))) \
+                    { \
+                      r.ridx (nel) = m1.ridx (i); \
+                      r.data (nel++) = true; \
+                    } \
+                r.cidx (j + 1) = nel; \
+              } \
+            r.maybe_compress (false); \
+          } \
       } \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
-	if (m1_nr != 0 || m1_nc != 0) \
-	  { \
+        if (m1_nr != 0 || m1_nc != 0) \
+          { \
             if (C1 (Z1) OP C2 (Z2)) \
-	      { \
+              { \
                 r = SparseBoolMatrix (m1_nr, m1_nc, true); \
-	        for (octave_idx_type j = 0; j < m1_nc; j++) \
+                for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
                      octave_idx_type i1 = m1.cidx (j); \
                      octave_idx_type e1 = m1.cidx (j+1); \
                      octave_idx_type i2 = m2.cidx (j); \
                      octave_idx_type e2 = m2.cidx (j+1); \
                      while (i1 < e1 || i2 < e2) \
                        { \
                          if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
@@ -848,17 +848,17 @@ along with Octave; see the file COPYING.
                   } \
                 r.maybe_compress (true); \
               } \
             else \
               { \
                 r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz () + m2.nnz ()); \
                 r.cidx (0) = static_cast<octave_idx_type> (0); \
                 octave_idx_type nel = 0; \
-	        for (octave_idx_type j = 0; j < m1_nc; j++) \
+                for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
                      octave_idx_type i1 = m1.cidx (j); \
                      octave_idx_type e1 = m1.cidx (j+1); \
                      octave_idx_type i2 = m2.cidx (j); \
                      octave_idx_type e2 = m2.cidx (j+1); \
                      while (i1 < e1 || i2 < e2) \
                        { \
                          if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
@@ -889,22 +889,22 @@ along with Octave; see the file COPYING.
                              i1++; \
                              i2++; \
                            } \
                        } \
                      r.cidx (j + 1) = nel; \
                   } \
                 r.maybe_compress (false); \
               } \
-	  } \
-      }	      \
+          } \
+      }       \
     else \
       { \
-	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+        if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
+          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, Z1,   , M2, Z2,   ) \
@@ -933,86 +933,86 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-	if (m2_nr > 0 && m2_nc > 0) \
-	  { \
-	    if ((m1.elem(0,0) != LHS_ZERO) OP RHS_ZERO)	\
-	      { \
-		r = SparseBoolMatrix (m2_nr, m2_nc, true); \
-		for (octave_idx_type j = 0; j < m2_nc; j++) \
-		  for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-		    if (! ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO))) \
-		      r.data (m2.ridx (i) + j * m2_nr) = false; \
-		r.maybe_compress (true); \
-	      } \
-	    else \
-	      { \
-		r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
-		r.cidx (0) = static_cast<octave_idx_type> (0); \
-		octave_idx_type nel = 0; \
-		for (octave_idx_type j = 0; j < m2_nc; j++) \
-		  { \
-		    for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-		      if ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO)) \
-			{ \
-			  r.ridx (nel) = m2.ridx (i); \
-			  r.data (nel++) = true; \
-			} \
-		    r.cidx (j + 1) = nel; \
-		  } \
-		r.maybe_compress (false); \
-	      } \
-	  } \
+        if (m2_nr > 0 && m2_nc > 0) \
+          { \
+            if ((m1.elem(0,0) != LHS_ZERO) OP RHS_ZERO) \
+              { \
+                r = SparseBoolMatrix (m2_nr, m2_nc, true); \
+                for (octave_idx_type j = 0; j < m2_nc; j++) \
+                  for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
+                    if (! ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO))) \
+                      r.data (m2.ridx (i) + j * m2_nr) = false; \
+                r.maybe_compress (true); \
+              } \
+            else \
+              { \
+                r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
+                r.cidx (0) = static_cast<octave_idx_type> (0); \
+                octave_idx_type nel = 0; \
+                for (octave_idx_type j = 0; j < m2_nc; j++) \
+                  { \
+                    for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
+                      if ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO)) \
+                        { \
+                          r.ridx (nel) = m2.ridx (i); \
+                          r.data (nel++) = true; \
+                        } \
+                    r.cidx (j + 1) = nel; \
+                  } \
+                r.maybe_compress (false); \
+              } \
+          } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-	if (m1_nr > 0 && m1_nc > 0) \
-	  { \
-	    if (LHS_ZERO OP (m2.elem(0,0) != RHS_ZERO)) \
-	      { \
-		r = SparseBoolMatrix (m1_nr, m1_nc, true); \
-		for (octave_idx_type j = 0; j < m1_nc; j++) \
-		  for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-		    if (! ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO))) \
-		      r.data (m1.ridx (i) + j * m1_nr) = false; \
-		r.maybe_compress (true); \
-	      } \
-	    else \
-	      { \
-		r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
-		r.cidx (0) = static_cast<octave_idx_type> (0); \
-		octave_idx_type nel = 0; \
-		for (octave_idx_type j = 0; j < m1_nc; j++) \
-		  { \
-		    for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-		      if ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO)) \
-			{ \
-			  r.ridx (nel) = m1.ridx (i); \
-			  r.data (nel++) = true; \
-			} \
-		    r.cidx (j + 1) = nel; \
-		  } \
-		r.maybe_compress (false); \
-	      } \
-	  } \
+        if (m1_nr > 0 && m1_nc > 0) \
+          { \
+            if (LHS_ZERO OP (m2.elem(0,0) != RHS_ZERO)) \
+              { \
+                r = SparseBoolMatrix (m1_nr, m1_nc, true); \
+                for (octave_idx_type j = 0; j < m1_nc; j++) \
+                  for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
+                    if (! ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO))) \
+                      r.data (m1.ridx (i) + j * m1_nr) = false; \
+                r.maybe_compress (true); \
+              } \
+            else \
+              { \
+                r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
+                r.cidx (0) = static_cast<octave_idx_type> (0); \
+                octave_idx_type nel = 0; \
+                for (octave_idx_type j = 0; j < m1_nc; j++) \
+                  { \
+                    for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
+                      if ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO)) \
+                        { \
+                          r.ridx (nel) = m1.ridx (i); \
+                          r.data (nel++) = true; \
+                        } \
+                    r.cidx (j + 1) = nel; \
+                  } \
+                r.maybe_compress (false); \
+              } \
+          } \
       } \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
-	if (m1_nr != 0 || m1_nc != 0) \
-	  { \
+        if (m1_nr != 0 || m1_nc != 0) \
+          { \
             r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz () + m2.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 octave_idx_type i1 = m1.cidx (j); \
                 octave_idx_type e1 = m1.cidx (j+1); \
                 octave_idx_type i2 = m2.cidx (j); \
                 octave_idx_type e2 = m2.cidx (j+1); \
                 while (i1 < e1 || i2 < e2) \
                   { \
                     if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
@@ -1042,22 +1042,22 @@ along with Octave; see the file COPYING.
                           } \
                         i1++; \
                         i2++; \
                       } \
                   } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
-	  } \
-      }	      \
+          } \
+      }       \
     else \
       { \
-	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+        if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
+          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
 
@@ -1066,23 +1066,23 @@ along with Octave; see the file COPYING.
 
 #define SPARSE_SMSM_OP_DECLS(R1, R2, M1, M2, API) \
   SPARSE_SMSM_BIN_OP_DECLS (R1, R2, M1, M2, API) \
   SPARSE_SMSM_CMP_OP_DECLS (M1, M2, API) \
   SPARSE_SMSM_BOOL_OP_DECLS (M1, M2, API)
 
 // matrix by matrix operations.
 
-#define SPARSE_MSM_BIN_OP_DECLS(R1, R2, M1, M2, API)	\
+#define SPARSE_MSM_BIN_OP_DECLS(R1, R2, M1, M2, API)    \
   SPARSE_BIN_OP_DECL (R1, operator +, M1, M2, API); \
   SPARSE_BIN_OP_DECL (R1, operator -, M1, M2, API); \
   SPARSE_BIN_OP_DECL (R2, product,    M1, M2, API); \
   SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2, API);
 
-#define SPARSE_MSM_BIN_OP_1(R, F, OP, M1, M2)	\
+#define SPARSE_MSM_BIN_OP_1(R, F, OP, M1, M2)   \
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
@@ -1093,18 +1093,18 @@ along with Octave; see the file COPYING.
       r = R (m1 OP m2.elem(0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc); \
         \
         for (octave_idx_type j = 0; j < m1_nc; j++) \
-	  for (octave_idx_type i = 0; i < m1_nr; i++) \
-	    r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
+          for (octave_idx_type i = 0; i < m1_nr; i++) \
+            r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_BIN_OP_2(R, F, OP, M1, M2, ZERO) \
   R \
   F (const M1& m1, const M2& m2) \
   { \
@@ -1117,39 +1117,39 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m2_nr == 1 && m2_nc == 1) \
       r = R (m1 OP m2.elem(0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
-	/* Count num of non-zero elements */ \
-	octave_idx_type nel = 0; \
-	for (octave_idx_type j = 0; j < m1_nc; j++) \
-	  for (octave_idx_type i = 0; i < m1_nr; i++) \
-	    if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
-	      nel++; \
-	\
+        /* Count num of non-zero elements */ \
+        octave_idx_type nel = 0; \
+        for (octave_idx_type j = 0; j < m1_nc; j++) \
+          for (octave_idx_type i = 0; i < m1_nr; i++) \
+            if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
+              nel++; \
+        \
         r = R (m1_nr, m1_nc, nel); \
         \
-	octave_idx_type ii = 0; \
-	r.cidx (0) = 0; \
+        octave_idx_type ii = 0; \
+        r.cidx (0) = 0; \
         for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
           { \
-	    for (octave_idx_type i = 0 ; i < m1_nr ; i++)	\
-	      {	\
-	        if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
-		  { \
-		    r.data (ii) = m1.elem(i, j) OP m2.elem(i,j); \
-		    r.ridx (ii++) = i; \
-		  } \
-	      } \
-	    r.cidx(j+1) = ii; \
-	  } \
+            for (octave_idx_type i = 0 ; i < m1_nr ; i++)       \
+              { \
+                if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
+                  { \
+                    r.data (ii) = m1.elem(i, j) OP m2.elem(i,j); \
+                    r.ridx (ii++) = i; \
+                  } \
+              } \
+            r.cidx(j+1) = ii; \
+          } \
       } \
  \
     return r; \
   }
 
 // FIXME Pass a specific ZERO value
 #define SPARSE_MSM_BIN_OPS(R1, R2, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
@@ -1164,64 +1164,64 @@ along with Octave; see the file COPYING.
   SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define SPARSE_MSM_EQNE_OP_DECLS(M1, M2, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
-#define SPARSE_MSM_CMP_OP(F, OP, M1, C1, M2, C2)	\
+#define SPARSE_MSM_CMP_OP(F, OP, M1, C1, M2, C2)        \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
       r = SparseBoolMatrix (F (m1, m2.elem(0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
-	if (m1_nr != 0 || m1_nc != 0) \
-	  { \
-	    /* Count num of non-zero elements */ \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      for (octave_idx_type i = 0; i < m1_nr; i++) \
-		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
-		  nel++; \
+        if (m1_nr != 0 || m1_nc != 0) \
+          { \
+            /* Count num of non-zero elements */ \
+            octave_idx_type nel = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              for (octave_idx_type i = 0; i < m1_nr; i++) \
+                if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
+                  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      { \
-	        for (octave_idx_type i = 0; i < m1_nr; i++) \
-		  { \
-		    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-      }	      \
+            octave_idx_type ii = 0; \
+            r.cidx (0) = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              { \
+                for (octave_idx_type i = 0; i < m1_nr; i++) \
+                  { \
+                    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
+                    if (el) \
+                      { \
+                        r.data(ii) = el; \
+                        r.ridx(ii++) = i; \
+                      } \
+                  } \
+                r.cidx(j+1) = ii; \
+              } \
+          } \
+      }       \
     else \
       { \
-	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+        if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
+          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_MSM_CMP_OP (mx_el_lt, <,  M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_le, <=, M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_ge, >=, M1,   , M2,   ) \
@@ -1248,50 +1248,50 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
       r = SparseBoolMatrix  (F (m1, m2.elem(0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
-	if (m1_nr != 0 || m1_nc != 0) \
-	  { \
-	    /* Count num of non-zero elements */ \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      for (octave_idx_type i = 0; i < m1_nr; i++) \
-		if ((m1.elem(i, j) != LHS_ZERO) \
-		    OP (m2.elem(i, j) != RHS_ZERO)) \
-		  nel++; \
+        if (m1_nr != 0 || m1_nc != 0) \
+          { \
+            /* Count num of non-zero elements */ \
+            octave_idx_type nel = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              for (octave_idx_type i = 0; i < m1_nr; i++) \
+                if ((m1.elem(i, j) != LHS_ZERO) \
+                    OP (m2.elem(i, j) != RHS_ZERO)) \
+                  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      { \
-	        for (octave_idx_type i = 0; i < m1_nr; i++) \
-		  { \
-		    bool el = (m1.elem(i, j) != LHS_ZERO) \
-		      OP (m2.elem(i, j) != RHS_ZERO);	  \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-      }	      \
+            octave_idx_type ii = 0; \
+            r.cidx (0) = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              { \
+                for (octave_idx_type i = 0; i < m1_nr; i++) \
+                  { \
+                    bool el = (m1.elem(i, j) != LHS_ZERO) \
+                      OP (m2.elem(i, j) != RHS_ZERO);     \
+                    if (el) \
+                      { \
+                        r.data(ii) = el; \
+                        r.ridx(ii++) = i; \
+                      } \
+                  } \
+                r.cidx(j+1) = ii; \
+              } \
+          } \
+      }       \
     else \
       { \
-	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+        if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
+          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_MSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_MSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
 
@@ -1300,23 +1300,23 @@ along with Octave; see the file COPYING.
 
 #define SPARSE_MSM_OP_DECLS(R1, R2, M1, M2, API) \
   SPARSE_MSM_BIN_OP_DECLS (R1, R2, M1, M2, API) \
   SPARSE_MSM_CMP_OP_DECLS (M1, M2, API) \
   SPARSE_MSM_BOOL_OP_DECLS (M1, M2, API)
 
 // matrix by matrix operations.
 
-#define SPARSE_SMM_BIN_OP_DECLS(R1, R2, M1, M2, API)	\
+#define SPARSE_SMM_BIN_OP_DECLS(R1, R2, M1, M2, API)    \
   SPARSE_BIN_OP_DECL (R1, operator +, M1, M2, API); \
   SPARSE_BIN_OP_DECL (R1, operator -, M1, M2, API); \
   SPARSE_BIN_OP_DECL (R2, product,    M1, M2, API); \
   SPARSE_BIN_OP_DECL (R2, quotient,   M1, M2, API);
 
-#define SPARSE_SMM_BIN_OP_1(R, F, OP, M1, M2)	\
+#define SPARSE_SMM_BIN_OP_1(R, F, OP, M1, M2)   \
   R \
   F (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
@@ -1327,18 +1327,18 @@ along with Octave; see the file COPYING.
       r = R (m1.elem(0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc); \
         \
         for (octave_idx_type j = 0; j < m1_nc; j++) \
-	  for (octave_idx_type i = 0; i < m1_nr; i++) \
-	    r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
+          for (octave_idx_type i = 0; i < m1_nr; i++) \
+            r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_BIN_OP_2(R, F, OP, M1, M2, ZERO) \
   R \
   F (const M1& m1, const M2& m2) \
   { \
@@ -1351,39 +1351,39 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       r = R (m1.elem(0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
-	/* Count num of non-zero elements */ \
-	octave_idx_type nel = 0; \
-	for (octave_idx_type j = 0; j < m1_nc; j++) \
-	  for (octave_idx_type i = 0; i < m1_nr; i++) \
-	    if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
-	      nel++; \
-	\
+        /* Count num of non-zero elements */ \
+        octave_idx_type nel = 0; \
+        for (octave_idx_type j = 0; j < m1_nc; j++) \
+          for (octave_idx_type i = 0; i < m1_nr; i++) \
+            if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
+              nel++; \
+        \
         r = R (m1_nr, m1_nc, nel); \
         \
-	octave_idx_type ii = 0; \
-	r.cidx (0) = 0; \
+        octave_idx_type ii = 0; \
+        r.cidx (0) = 0; \
         for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
           { \
-	    for (octave_idx_type i = 0 ; i < m1_nr ; i++)	\
-	      {	\
-	        if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
-		  { \
-		    r.data (ii) = m1.elem(i, j) OP m2.elem(i,j); \
-		    r.ridx (ii++) = i; \
-		  } \
-	      } \
-	    r.cidx(j+1) = ii; \
-	  } \
+            for (octave_idx_type i = 0 ; i < m1_nr ; i++)       \
+              { \
+                if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
+                  { \
+                    r.data (ii) = m1.elem(i, j) OP m2.elem(i,j); \
+                    r.ridx (ii++) = i; \
+                  } \
+              } \
+            r.cidx(j+1) = ii; \
+          } \
       } \
  \
     return r; \
   }
 
 // FIXME Pass a specific ZERO value
 #define SPARSE_SMM_BIN_OPS(R1, R2, M1, M2) \
   SPARSE_SMM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
@@ -1398,64 +1398,64 @@ along with Octave; see the file COPYING.
   SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define SPARSE_SMM_EQNE_OP_DECLS(M1, M2, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
-#define SPARSE_SMM_CMP_OP(F, OP, M1, C1, M2, C2)	\
+#define SPARSE_SMM_CMP_OP(F, OP, M1, C1, M2, C2)        \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
-	if (m1_nr != 0 || m1_nc != 0) \
-	  { \
-	    /* Count num of non-zero elements */ \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      for (octave_idx_type i = 0; i < m1_nr; i++) \
-		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
-		  nel++; \
+        if (m1_nr != 0 || m1_nc != 0) \
+          { \
+            /* Count num of non-zero elements */ \
+            octave_idx_type nel = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              for (octave_idx_type i = 0; i < m1_nr; i++) \
+                if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
+                  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      { \
-	        for (octave_idx_type i = 0; i < m1_nr; i++) \
-		  { \
-		    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-      }	      \
+            octave_idx_type ii = 0; \
+            r.cidx (0) = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              { \
+                for (octave_idx_type i = 0; i < m1_nr; i++) \
+                  { \
+                    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
+                    if (el) \
+                      { \
+                        r.data(ii) = el; \
+                        r.ridx(ii++) = i; \
+                      } \
+                  } \
+                r.cidx(j+1) = ii; \
+              } \
+          } \
+      }       \
     else \
       { \
-	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+        if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
+          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMM_CMP_OP (mx_el_lt, <,  M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_le, <=, M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_ge, >=, M1,   , M2,   ) \
@@ -1482,50 +1482,50 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
-	if (m1_nr != 0 || m1_nc != 0) \
-	  { \
-	    /* Count num of non-zero elements */ \
-	    octave_idx_type nel = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      for (octave_idx_type i = 0; i < m1_nr; i++) \
-		if ((m1.elem(i, j) != LHS_ZERO) \
-		    OP (m2.elem(i, j) != RHS_ZERO)) \
-		  nel++; \
+        if (m1_nr != 0 || m1_nc != 0) \
+          { \
+            /* Count num of non-zero elements */ \
+            octave_idx_type nel = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              for (octave_idx_type i = 0; i < m1_nr; i++) \
+                if ((m1.elem(i, j) != LHS_ZERO) \
+                    OP (m2.elem(i, j) != RHS_ZERO)) \
+                  nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
-	    octave_idx_type ii = 0; \
-	    r.cidx (0) = 0; \
-	    for (octave_idx_type j = 0; j < m1_nc; j++) \
-	      { \
-	        for (octave_idx_type i = 0; i < m1_nr; i++) \
-		  { \
-		    bool el = (m1.elem(i, j) != LHS_ZERO) \
-		      OP (m2.elem(i, j) != RHS_ZERO);	  \
-		    if (el) \
-		      { \
-			r.data(ii) = el; \
-			r.ridx(ii++) = i; \
-		      } \
-		  } \
-		r.cidx(j+1) = ii; \
-	      } \
-	  } \
-      }	      \
+            octave_idx_type ii = 0; \
+            r.cidx (0) = 0; \
+            for (octave_idx_type j = 0; j < m1_nc; j++) \
+              { \
+                for (octave_idx_type i = 0; i < m1_nr; i++) \
+                  { \
+                    bool el = (m1.elem(i, j) != LHS_ZERO) \
+                      OP (m2.elem(i, j) != RHS_ZERO);     \
+                    if (el) \
+                      { \
+                        r.data(ii) = el; \
+                        r.ridx(ii++) = i; \
+                      } \
+                  } \
+                r.cidx(j+1) = ii; \
+              } \
+          } \
+      }       \
     else \
       { \
-	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+        if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
+          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
 
@@ -1534,210 +1534,210 @@ along with Octave; see the file COPYING.
 
 #define SPARSE_SMM_OP_DECLS(R1, R2, M1, M2, API) \
   SPARSE_SMM_BIN_OP_DECLS (R1, R2, M1, M2, API) \
   SPARSE_SMM_CMP_OP_DECLS (M1, M2, API) \
   SPARSE_SMM_BOOL_OP_DECLS (M1, M2, API)
 
 // Avoid some code duplication.  Maybe we should use templates.
 
-#define SPARSE_CUMSUM(RET_TYPE, ELT_TYPE, FCN)	\
+#define SPARSE_CUMSUM(RET_TYPE, ELT_TYPE, FCN)  \
  \
   octave_idx_type nr = rows (); \
   octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
-	/* Ugly!! Is there a better way? */ \
+        /* Ugly!! Is there a better way? */ \
         retval = transpose (). FCN (0) .transpose (); \
       else \
-	{ \
+        { \
           octave_idx_type nel = 0; \
-	  for (octave_idx_type i = 0; i < nc; i++) \
+          for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
-	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)	\
+              for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)   \
                 { \
                   t += data(j); \
                   if (t != ELT_TYPE ()) \
-		    { \
+                    { \
                       if (j == cidx(i+1) - 1) \
-			nel += nr - ridx(j);  \
-		      else \
-			nel += ridx(j+1) - ridx(j); \
-		    } \
+                        nel += nr - ridx(j);  \
+                      else \
+                        nel += ridx(j+1) - ridx(j); \
+                    } \
                 } \
-	    } \
-	  retval = RET_TYPE (nr, nc, nel); \
+            } \
+          retval = RET_TYPE (nr, nc, nel); \
           retval.cidx(0) = 0; \
-	  octave_idx_type ii = 0; \
-	  for (octave_idx_type i = 0; i < nc; i++) \
+          octave_idx_type ii = 0; \
+          for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
-	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)	\
+              for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)   \
                 { \
                   t += data(j); \
                   if (t != ELT_TYPE ()) \
                     { \
                       if (j == cidx(i+1) - 1) \
                         { \
                           for (octave_idx_type k = ridx(j); k < nr; k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
-		      else \
-			{ \
+                      else \
+                        { \
                           for (octave_idx_type k = ridx(j); k < ridx(j+1); k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
                     } \
                 } \
               retval.cidx(i+1) = ii; \
-	    } \
-	} \
+            } \
+        } \
     } \
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
 
-#define SPARSE_CUMPROD(RET_TYPE, ELT_TYPE, FCN)	\
+#define SPARSE_CUMPROD(RET_TYPE, ELT_TYPE, FCN) \
  \
   octave_idx_type nr = rows (); \
   octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
-	/* Ugly!! Is there a better way? */ \
+        /* Ugly!! Is there a better way? */ \
         retval = transpose (). FCN (0) .transpose (); \
       else \
-	{ \
+        { \
           octave_idx_type nel = 0; \
-	  for (octave_idx_type i = 0; i < nc; i++) \
+          for (octave_idx_type i = 0; i < nc; i++) \
             { \
-	      octave_idx_type jj = 0; \
-	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
+              octave_idx_type jj = 0; \
+              for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
-		  if (jj == ridx(j)) \
+                  if (jj == ridx(j)) \
                     { \
                       nel++; \
                       jj++; \
                     } \
                   else \
                     break; \
                 } \
-	    } \
-	  retval = RET_TYPE (nr, nc, nel); \
+            } \
+          retval = RET_TYPE (nr, nc, nel); \
           retval.cidx(0) = 0; \
-	  octave_idx_type ii = 0; \
-	  for (octave_idx_type i = 0; i < nc; i++) \
+          octave_idx_type ii = 0; \
+          for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (1.); \
-	      octave_idx_type jj = 0; \
-	      for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
+              octave_idx_type jj = 0; \
+              for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
-		  if (jj == ridx(j)) \
+                  if (jj == ridx(j)) \
                     { \
                       t *= data(j); \
                       retval.data(ii) = t; \
                       retval.ridx(ii++) = jj++; \
                     } \
                   else \
                     break; \
                 } \
               retval.cidx(i+1) = ii; \
-	    } \
-	} \
+            } \
+        } \
     } \
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
 #define SPARSE_BASE_REDUCTION_OP(RET_TYPE, EL_TYPE, ROW_EXPR, COL_EXPR, \
-			         INIT_VAL, MT_RESULT) \
+                                 INIT_VAL, MT_RESULT) \
  \
   octave_idx_type nr = rows (); \
   octave_idx_type nc = cols (); \
  \
   RET_TYPE retval; \
  \
   if (nr > 0 && nc > 0) \
     { \
       if ((nr == 1 && dim == -1) || dim == 1) \
-	{ \
+        { \
           /* Define j here to allow fancy definition for prod method */ \
           octave_idx_type j = 0; \
-	  OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nr); \
+          OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nr); \
           \
-	  for (octave_idx_type i = 0; i < nr; i++) \
-	    tmp[i] = INIT_VAL; \
-	  for (j = 0; j < nc; j++) \
+          for (octave_idx_type i = 0; i < nr; i++) \
+            tmp[i] = INIT_VAL; \
+          for (j = 0; j < nc; j++) \
             { \
-	      for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+              for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
                 { \
-	          ROW_EXPR; \
+                  ROW_EXPR; \
                 } \
-	    } \
-	  octave_idx_type nel = 0; \
-	  for (octave_idx_type i = 0; i < nr; i++) \
-	    if (tmp[i] != EL_TYPE ())  \
-	      nel++ ; \
-	  retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nel); \
-	  retval.cidx(0) = 0; \
-	  retval.cidx(1) = nel; \
-	  nel = 0; \
-	  for (octave_idx_type i = 0; i < nr; i++) \
-	    if (tmp[i] != EL_TYPE ())  \
-	      { \
-		retval.data(nel) = tmp[i]; \
-		retval.ridx(nel++) = i; \
-	      } \
-	} \
+            } \
+          octave_idx_type nel = 0; \
+          for (octave_idx_type i = 0; i < nr; i++) \
+            if (tmp[i] != EL_TYPE ())  \
+              nel++ ; \
+          retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nel); \
+          retval.cidx(0) = 0; \
+          retval.cidx(1) = nel; \
+          nel = 0; \
+          for (octave_idx_type i = 0; i < nr; i++) \
+            if (tmp[i] != EL_TYPE ())  \
+              { \
+                retval.data(nel) = tmp[i]; \
+                retval.ridx(nel++) = i; \
+              } \
+        } \
       else \
-	{ \
-	  OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nc); \
+        { \
+          OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nc); \
           \
-	  for (octave_idx_type j = 0; j < nc; j++) \
-	    { \
-	      tmp[j] = INIT_VAL; \
-	      for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+          for (octave_idx_type j = 0; j < nc; j++) \
+            { \
+              tmp[j] = INIT_VAL; \
+              for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
                 { \
-		  COL_EXPR; \
+                  COL_EXPR; \
                 } \
-	    } \
-	  octave_idx_type nel = 0; \
-	  for (octave_idx_type i = 0; i < nc; i++) \
-	    if (tmp[i] != EL_TYPE ())  \
-	      nel++ ; \
-	  retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nel); \
-	  retval.cidx(0) = 0; \
-	  nel = 0; \
-	  for (octave_idx_type i = 0; i < nc; i++) \
-	    if (tmp[i] != EL_TYPE ())  \
-	      { \
-		retval.data(nel) = tmp[i]; \
-		retval.ridx(nel++) = 0; \
-		retval.cidx(i+1) = retval.cidx(i) + 1; \
-	      } \
-	    else \
-	      retval.cidx(i+1) = retval.cidx(i); \
-	} \
+            } \
+          octave_idx_type nel = 0; \
+          for (octave_idx_type i = 0; i < nc; i++) \
+            if (tmp[i] != EL_TYPE ())  \
+              nel++ ; \
+          retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nel); \
+          retval.cidx(0) = 0; \
+          nel = 0; \
+          for (octave_idx_type i = 0; i < nc; i++) \
+            if (tmp[i] != EL_TYPE ())  \
+              { \
+                retval.data(nel) = tmp[i]; \
+                retval.ridx(nel++) = 0; \
+                retval.cidx(i+1) = retval.cidx(i) + 1; \
+              } \
+            else \
+              retval.cidx(i+1) = retval.cidx(i); \
+        } \
     } \
   else if (nc == 0 && (nr == 0 || (nr == 1 && dim == -1))) \
     { \
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1)); \
@@ -1756,56 +1756,56 @@ along with Octave; see the file COPYING.
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nc); \
           retval.cidx (0) = 0; \
           for (octave_idx_type i = 0; i < nc ; i++) \
             { \
               retval.ridx (i) = 0; \
               retval.cidx (i+1) = i; \
-	      retval.data (i) = MT_RESULT; \
-	    } \
+              retval.data (i) = MT_RESULT; \
+            } \
         } \
       else \
         retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, \
-			   static_cast<octave_idx_type> (0)); \
+                           static_cast<octave_idx_type> (0)); \
     } \
   else if (nc == 0 && dim == 1) \
     { \
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nr); \
           retval.cidx(0) = 0; \
           retval.cidx(1) = nr; \
           for (octave_idx_type i = 0; i < nr; i++) \
-	    { \
-	      retval.ridx(i) = i; \
-	      retval.data(i) = MT_RESULT; \
-	    } \
+            { \
+              retval.ridx(i) = i; \
+              retval.data(i) = MT_RESULT; \
+            } \
         } \
       else \
         retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), \
-			   static_cast<octave_idx_type> (0)); \
+                           static_cast<octave_idx_type> (0)); \
     } \
   else \
     retval.resize (nr > 0, nc > 0); \
  \
   return retval
 
 #define SPARSE_REDUCTION_OP_ROW_EXPR(OP) \
   tmp[ridx(i)] OP data (i)
 
 #define SPARSE_REDUCTION_OP_COL_EXPR(OP) \
   tmp[j] OP data (i)
 
-#define SPARSE_REDUCTION_OP(RET_TYPE, EL_TYPE, OP, INIT_VAL, MT_RESULT)	\
+#define SPARSE_REDUCTION_OP(RET_TYPE, EL_TYPE, OP, INIT_VAL, MT_RESULT) \
   SPARSE_BASE_REDUCTION_OP (RET_TYPE, EL_TYPE, \
-			SPARSE_REDUCTION_OP_ROW_EXPR (OP), \
-			SPARSE_REDUCTION_OP_COL_EXPR (OP), \
-			INIT_VAL, MT_RESULT)
+                        SPARSE_REDUCTION_OP_ROW_EXPR (OP), \
+                        SPARSE_REDUCTION_OP_COL_EXPR (OP), \
+                        INIT_VAL, MT_RESULT)
 
 
 // Don't break from this loop if the test succeeds because
 // we are looping over the rows and not the columns in the inner
 // loop.
 #define SPARSE_ANY_ALL_OP_ROW_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
     tmp[ridx(i)] = TEST_TRUE_VAL; \
@@ -1814,27 +1814,27 @@ along with Octave; see the file COPYING.
   if (data (i) TEST_OP 0.0) \
     { \
       tmp[j] = TEST_TRUE_VAL; \
       break; \
     }
 
 #define SPARSE_ANY_ALL_OP(DIM, INIT_VAL, MT_RESULT, TEST_OP, TEST_TRUE_VAL) \
   SPARSE_BASE_REDUCTION_OP (SparseBoolMatrix, char, \
-			SPARSE_ANY_ALL_OP_ROW_CODE (TEST_OP, TEST_TRUE_VAL), \
-			SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
-			INIT_VAL, MT_RESULT)
+                        SPARSE_ANY_ALL_OP_ROW_CODE (TEST_OP, TEST_TRUE_VAL), \
+                        SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
+                        INIT_VAL, MT_RESULT)
 
 #define SPARSE_ALL_OP(DIM) \
   if ((rows() == 1 && dim == -1) || dim == 1) \
     return transpose (). all (0). transpose(); \
   else \
     { \
       SPARSE_ANY_ALL_OP (DIM, (cidx(j+1) - cidx(j) < nr ? false : true), \
-			 true, ==, false); \
+                         true, ==, false); \
     }
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, false, !=, true)
 
 #define SPARSE_SPARSE_MUL( RET_TYPE, RET_EL_TYPE, EL_TYPE ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
@@ -1845,18 +1845,18 @@ along with Octave; see the file COPYING.
    { \
      RET_EL_TYPE s = m.elem(0,0); \
      octave_idx_type nz = a.nnz(); \
      RET_TYPE r (a_nr, a_nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
-	 r.data(i) = s * a.data(i); \
-	 r.ridx(i) = a.ridx(i); \
+         r.data(i) = s * a.data(i); \
+         r.ridx(i) = a.ridx(i); \
        } \
      for (octave_idx_type i = 0; i < a_nc + 1; i++) \
        { \
          octave_quit (); \
          r.cidx(i) = a.cidx(i); \
        } \
      \
      r.maybe_compress (true); \
@@ -1866,18 +1866,18 @@ along with Octave; see the file COPYING.
    { \
      RET_EL_TYPE s = a.elem(0,0); \
      octave_idx_type nz = m.nnz(); \
      RET_TYPE r (nr, nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
-	 r.data(i) = m.data(i) * s; \
-	 r.ridx(i) = m.ridx(i); \
+         r.data(i) = m.data(i) * s; \
+         r.ridx(i) = m.ridx(i); \
        } \
      for (octave_idx_type i = 0; i < nc + 1; i++) \
        { \
          octave_quit (); \
          r.cidx(i) = m.cidx(i); \
        } \
      \
      r.maybe_compress (true); \
@@ -1888,124 +1888,124 @@ along with Octave; see the file COPYING.
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr); \
       RET_TYPE retval (nr, a_nc, static_cast<octave_idx_type> (0)); \
       for (octave_idx_type i = 0; i < nr; i++) \
-	w[i] = 0; \
+        w[i] = 0; \
       retval.xcidx(0) = 0; \
       \
       octave_idx_type nel = 0; \
       \
       for (octave_idx_type i = 0; i < a_nc; i++) \
         { \
           for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
             { \
               octave_idx_type  col = a.ridx(j); \
               for (octave_idx_type k = m.cidx(col) ; k < m.cidx(col+1); k++) \
-		{ \
-		  if (w[m.ridx(k)] < i + 1) \
+                { \
+                  if (w[m.ridx(k)] < i + 1) \
                     { \
-		      w[m.ridx(k)] = i + 1; \
-		      nel++; \
-		    } \
-	          octave_quit (); \
-		} \
-	    } \
+                      w[m.ridx(k)] = i + 1; \
+                      nel++; \
+                    } \
+                  octave_quit (); \
+                } \
+            } \
           retval.xcidx(i+1) = nel; \
-	} \
+        } \
       \
       if (nel == 0) \
-	return RET_TYPE (nr, a_nc); \
+        return RET_TYPE (nr, a_nc); \
       else \
-	{  \
+        {  \
           for (octave_idx_type i = 0; i < nr; i++) \
-	    w[i] = 0; \
-	  \
+            w[i] = 0; \
+          \
           OCTAVE_LOCAL_BUFFER (RET_EL_TYPE, Xcol, nr); \
           \
-	  retval.change_capacity (nel); \
-	  /* The optimal break-point as estimated from simulations */ \
-	  /* Note that Mergesort is O(nz log(nz)) while searching all */ \
-	  /* values is O(nr), where nz here is non-zero per row of */ \
-	  /* length nr. The test itself was then derived from the */ \
-	  /* simulation with random square matrices and the observation */ \
-	  /* of the number of non-zero elements in the output matrix */ \
-	  /* it was found that the breakpoints were */ \
-	  /*   nr: 500  1000  2000  5000 10000 */ \
-	  /*   nz:   6    25    97   585  2202 */ \
-	  /* The below is a simplication of the 'polyfit'-ed parameters */ \
-	  /* to these breakpoints */ \
+          retval.change_capacity (nel); \
+          /* The optimal break-point as estimated from simulations */ \
+          /* Note that Mergesort is O(nz log(nz)) while searching all */ \
+          /* values is O(nr), where nz here is non-zero per row of */ \
+          /* length nr. The test itself was then derived from the */ \
+          /* simulation with random square matrices and the observation */ \
+          /* of the number of non-zero elements in the output matrix */ \
+          /* it was found that the breakpoints were */ \
+          /*   nr: 500  1000  2000  5000 10000 */ \
+          /*   nz:   6    25    97   585  2202 */ \
+          /* The below is a simplication of the 'polyfit'-ed parameters */ \
+          /* to these breakpoints */ \
           octave_idx_type n_per_col = (a_nc > 43000 ? 43000 : \
-					(a_nc * a_nc) / 43000); \
-	  octave_idx_type ii = 0; \
-	  octave_idx_type *ri = retval.xridx(); \
-	  octave_sort<octave_idx_type> sort; \
-	  \
-	  for (octave_idx_type i = 0; i < a_nc ; i++) \
-	    { \
-	      if (retval.xcidx(i+1) - retval.xcidx(i) > n_per_col) \
-		{ \
-		  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
-		    { \
-		      octave_idx_type col = a.ridx(j); \
-		      EL_TYPE tmpval = a.data(j); \
-		      for (octave_idx_type k = m.cidx(col) ; \
-			   k < m.cidx(col+1); k++) \
-			{ \
-			  octave_quit (); \
-			  octave_idx_type row = m.ridx(k); \
-			  if (w[row] < i + 1) \
-			    { \
-			      w[row] = i + 1; \
-			      Xcol[row] = tmpval * m.data(k); \
-			    } \
-			  else \
-			    Xcol[row] += tmpval * m.data(k); \
-			} \
-		    } \
-		  for (octave_idx_type k = 0; k < nr; k++) \
-		    if (w[k] == i + 1) \
-		      { \
-		        retval.xdata(ii) = Xcol[k]; \
-		        retval.xridx(ii++) = k; \
-		      } \
-		} \
-	      else \
-		{ \
-		  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
-		    { \
-		      octave_idx_type col = a.ridx(j); \
-		      EL_TYPE tmpval = a.data(j); \
-		      for (octave_idx_type k = m.cidx(col) ; \
-			  k < m.cidx(col+1); k++) \
-			{ \
-			  octave_quit (); \
-			  octave_idx_type row = m.ridx(k); \
-			  if (w[row] < i + 1) \
-			    { \
-			      w[row] = i + 1; \
-			      retval.xridx(ii++) = row;\
-			      Xcol[row] = tmpval * m.data(k); \
-			    } \
-			  else \
-			    Xcol[row] += tmpval * m.data(k); \
-			} \
-		    } \
-		  sort.sort (ri + retval.xcidx(i), ii - retval.xcidx(i)); \
-	          for (octave_idx_type k = retval.xcidx(i); k < ii; k++) \
-		    retval.xdata(k) = Xcol[retval.xridx(k)]; \
-		}  \
-	    } \
-	  retval.maybe_compress (true);\
-	  return retval; \
-	} \
+                                        (a_nc * a_nc) / 43000); \
+          octave_idx_type ii = 0; \
+          octave_idx_type *ri = retval.xridx(); \
+          octave_sort<octave_idx_type> sort; \
+          \
+          for (octave_idx_type i = 0; i < a_nc ; i++) \
+            { \
+              if (retval.xcidx(i+1) - retval.xcidx(i) > n_per_col) \
+                { \
+                  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+                    { \
+                      octave_idx_type col = a.ridx(j); \
+                      EL_TYPE tmpval = a.data(j); \
+                      for (octave_idx_type k = m.cidx(col) ; \
+                           k < m.cidx(col+1); k++) \
+                        { \
+                          octave_quit (); \
+                          octave_idx_type row = m.ridx(k); \
+                          if (w[row] < i + 1) \
+                            { \
+                              w[row] = i + 1; \
+                              Xcol[row] = tmpval * m.data(k); \
+                            } \
+                          else \
+                            Xcol[row] += tmpval * m.data(k); \
+                        } \
+                    } \
+                  for (octave_idx_type k = 0; k < nr; k++) \
+                    if (w[k] == i + 1) \
+                      { \
+                        retval.xdata(ii) = Xcol[k]; \
+                        retval.xridx(ii++) = k; \
+                      } \
+                } \
+              else \
+                { \
+                  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+                    { \
+                      octave_idx_type col = a.ridx(j); \
+                      EL_TYPE tmpval = a.data(j); \
+                      for (octave_idx_type k = m.cidx(col) ; \
+                          k < m.cidx(col+1); k++) \
+                        { \
+                          octave_quit (); \
+                          octave_idx_type row = m.ridx(k); \
+                          if (w[row] < i + 1) \
+                            { \
+                              w[row] = i + 1; \
+                              retval.xridx(ii++) = row;\
+                              Xcol[row] = tmpval * m.data(k); \
+                            } \
+                          else \
+                            Xcol[row] += tmpval * m.data(k); \
+                        } \
+                    } \
+                  sort.sort (ri + retval.xcidx(i), ii - retval.xcidx(i)); \
+                  for (octave_idx_type k = retval.xcidx(i); k < ii; k++) \
+                    retval.xdata(k) = Xcol[retval.xridx(k)]; \
+                }  \
+            } \
+          retval.maybe_compress (true);\
+          return retval; \
+        } \
     }
 
 #define SPARSE_FULL_MUL( RET_TYPE, EL_TYPE, ZERO ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -58,17 +58,17 @@ SM octinternal_do_mul_pm_sm (const PermM
     }
 
   if (p.is_row_perm ())
     {
       // Form the column permutation and then call the colpm_sm routine.
       const octave_idx_type *prow = p.pvec ().data ();
       OCTAVE_LOCAL_BUFFER(octave_idx_type, pcol, nr);
       for (octave_idx_type i = 0; i < nr; ++i)
-	pcol[prow[i]] = i;
+        pcol[prow[i]] = i;
       return octinternal_do_mul_colpm_sm (pcol, a);
     }
   else
     return octinternal_do_mul_colpm_sm (p.pvec ().data (), a);
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_rowpm (const SM& a, const octave_idx_type *prow)
@@ -93,20 +93,20 @@ SM octinternal_do_mul_sm_rowpm (const SM
 
   octave_idx_type k_src = 0;
   for (octave_idx_type j_src = 0; j_src < nc; ++j_src)
     {
       octave_quit ();
       const octave_idx_type j = prow[j_src];
       const octave_idx_type kend_src = a.cidx (j_src + 1);
       for (k = r.xcidx (j); k_src < kend_src; ++k, ++k_src)
-	{
-	  r.xridx (k) = a.ridx (k_src);
-	  r.xdata (k) = a.data (k_src);
-	}
+        {
+          r.xridx (k) = a.ridx (k_src);
+          r.xdata (k) = a.data (k_src);
+        }
     }
   assert (k_src == nent);
 
   r.maybe_compress (false);
   return r;
 }
 
 template <typename SM>
@@ -129,20 +129,20 @@ SM octinternal_do_mul_sm_colpm (const SM
   octave_idx_type k = 0;
   for (octave_idx_type j = 0; j < nc; ++j)
     {
       octave_quit ();
       const octave_idx_type j_src = pcol[j];
       octave_idx_type k_src;
       const octave_idx_type kend_src = a.cidx (j_src + 1);
       for (k_src = a.cidx (j_src); k_src < kend_src; ++k_src, ++k)
-	{
-	  r.xridx (k) = a.ridx (k_src);
-	  r.xdata (k) = a.data (k_src);
-	}
+        {
+          r.xridx (k) = a.ridx (k_src);
+          r.xdata (k) = a.data (k_src);
+        }
     }
   assert (k == nent);
 
   r.maybe_compress (false);
   return r;
 }
 
 template <typename SM>
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -64,51 +64,51 @@ protected:
     octave_idx_type *r;
     octave_idx_type *c;
     octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     int count;
 
     SparseRep (void) : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
-		       ncols (0), count (1) { c[0] = 0; }
+                       ncols (0), count (1) { c[0] = 0; }
 
     SparseRep (octave_idx_type n) : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
       { 
-	for (octave_idx_type i = 0; i < n + 1; i++)
-	  c[i] = 0;
+        for (octave_idx_type i = 0; i < n + 1; i++)
+          c[i] = 0;
       }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc) : d (0), r (0), c (new octave_idx_type [nc+1]), nzmx (0), 
       nrows (nr), ncols (nc), count (1)
       { 
-	for (octave_idx_type i = 0; i < nc + 1; i++)
-	  c[i] = 0;
+        for (octave_idx_type i = 0; i < nc + 1; i++)
+          c[i] = 0;
       }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz) : d (new T [nz]), 
       r (new octave_idx_type [nz]), c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr), 
       ncols (nc), count (1)
       { 
-	for (octave_idx_type i = 0; i < nc + 1; i++)
-	  c[i] = 0;
+        for (octave_idx_type i = 0; i < nc + 1; i++)
+          c[i] = 0;
       }
 
     SparseRep (const SparseRep& a)
       : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]), c (new octave_idx_type [a.ncols + 1]), 
       nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
       {
-	for (octave_idx_type i = 0; i < nzmx; i++)
-	  {
-	    d[i] = a.d[i];
-	    r[i] = a.r[i];
-	  }
-	for (octave_idx_type i = 0; i < ncols + 1; i++)
-	  c[i] = a.c[i];
+        for (octave_idx_type i = 0; i < nzmx; i++)
+          {
+            d[i] = a.d[i];
+            r[i] = a.r[i];
+          }
+        for (octave_idx_type i = 0; i < ncols + 1; i++)
+          c[i] = a.c[i];
       }
  
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
     octave_idx_type length (void) const { return nzmx; }
 
     octave_idx_type nnz (void) const { return c [ncols]; }
 
@@ -141,20 +141,20 @@ protected:
     SparseRep& operator = (const SparseRep& a);
   };
 
   //--------------------------------------------------------------------
 
   void make_unique (void)
     {
       if (rep->count > 1)
-	{
-	  --rep->count;
-	  rep = new SparseRep (*rep);
-	}
+        {
+          --rep->count;
+          rep = new SparseRep (*rep);
+        }
     }
 
 public:
 
   // !!! WARNING !!! -- these should be protected, not public.  You
   // should not access these data members directly!
 
   typename Sparse<T>::SparseRep *rep;
@@ -165,17 +165,17 @@ protected:
   idx_vector *idx;
   octave_idx_type idx_count;
 
 private:
 
   typename Sparse<T>::SparseRep *nil_rep (void) const
     {
       static typename Sparse<T>::SparseRep *nr
-	= new typename Sparse<T>::SparseRep ();
+        = new typename Sparse<T>::SparseRep ();
 
       nr->count++;
 
       return nr;
     }
 
 public:
 
@@ -213,20 +213,20 @@ public:
 
 public:
 
   Sparse (const dim_vector& dv);
 
   Sparse (const Sparse<T>& a, const dim_vector& dv);
 
   Sparse (const Array<T>& a, const Array<octave_idx_type>& r, const Array<octave_idx_type>& c,
-	  octave_idx_type nr, octave_idx_type nc, bool sum_terms);
+          octave_idx_type nr, octave_idx_type nc, bool sum_terms);
 
   Sparse (const Array<T>& a, const Array<double>& r, const Array<double>& c,
-	  octave_idx_type nr, octave_idx_type nc, bool sum_terms);
+          octave_idx_type nr, octave_idx_type nc, bool sum_terms);
 
   // Sparsify a normal matrix
   Sparse (const Array2<T>& a);
   Sparse (const Array<T>& a);
 
   virtual ~Sparse (void);
 
   Sparse<T>& operator = (const Sparse<T>& a);
@@ -308,43 +308,43 @@ public:
 
   // FIXME -- would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
   T& checkelem (octave_idx_type n)
     {
       if (n < 0 || n >= numel ())
-	return range_error ("T& Sparse<T>::checkelem", n);
+        return range_error ("T& Sparse<T>::checkelem", n);
       else
-	{
-	  make_unique ();
-	  return xelem (n);
-	}
+        {
+          make_unique ();
+          return xelem (n);
+        }
     }
 
   T& checkelem (octave_idx_type i, octave_idx_type j)
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
-	return range_error ("T& Sparse<T>::checkelem", i, j);
+        return range_error ("T& Sparse<T>::checkelem", i, j);
       else
-	{
-	  make_unique ();
-	  return xelem (i, j);
-	}
+        {
+          make_unique ();
+          return xelem (i, j);
+        }
     }
 
   T& checkelem (const Array<octave_idx_type>& ra_idx)
     {
       octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
-	return range_error ("T& Sparse<T>::checkelem", ra_idx);
+        return range_error ("T& Sparse<T>::checkelem", ra_idx);
       else
-	return elem (i);
+        return elem (i);
     }
 
   T& elem (octave_idx_type n)
     {
       make_unique ();
       return xelem (n);
     }
 
@@ -365,37 +365,37 @@ public:
   T& operator () (octave_idx_type n) { return elem (n); }
   T& operator () (octave_idx_type i, octave_idx_type j) { return elem (i, j); }
   T& operator () (const Array<octave_idx_type>& ra_idx) { return elem (ra_idx); }
 #endif
 
   T checkelem (octave_idx_type n) const
     {
       if (n < 0 || n >= numel ())
-	return range_error ("T Sparse<T>::checkelem", n);
+        return range_error ("T Sparse<T>::checkelem", n);
       else
-	return xelem (n);
+        return xelem (n);
     }
 
   T checkelem (octave_idx_type i, octave_idx_type j) const
     {
       if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
-	return range_error ("T Sparse<T>::checkelem", i, j);
+        return range_error ("T Sparse<T>::checkelem", i, j);
       else
-	return xelem (i, j);
+        return xelem (i, j);
     }
 
   T checkelem (const Array<octave_idx_type>& ra_idx) const
     {
       octave_idx_type i = compute_index (ra_idx);
 
       if (i < 0)
-	return range_error ("T Sparse<T>::checkelem", ra_idx);
+        return range_error ("T Sparse<T>::checkelem", ra_idx);
       else
-	return Sparse<T>::elem (i);
+        return Sparse<T>::elem (i);
     }
 
   T elem (octave_idx_type n) const { return xelem (n); }
 
   T elem (octave_idx_type i, octave_idx_type j) const { return xelem (i, j); }
 
   T elem (const Array<octave_idx_type>& ra_idx) const
     { return Sparse<T>::elem (compute_index (ra_idx)); }
@@ -505,70 +505,70 @@ public:
   void *mex_get_data (void) const { return const_cast<T *> (data ()); }
 
   octave_idx_type *mex_get_ir (void) const { return const_cast<octave_idx_type *> (ridx ()); }
 
   octave_idx_type *mex_get_jc (void) const { return const_cast<octave_idx_type *> (cidx ()); }
 
   Sparse<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   Sparse<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-		 sortmode mode = ASCENDING) const;
+                 sortmode mode = ASCENDING) const;
 
   Sparse<T> diag (octave_idx_type k = 0) const;
 
   template <class U, class F>
   Sparse<U>
   map (F fcn) const
   {
     Sparse<U> result;
     U f_zero = fcn (0.);
 
     if (f_zero != 0.)
       {
-	octave_idx_type nr = rows ();
-	octave_idx_type nc = cols ();
+        octave_idx_type nr = rows ();
+        octave_idx_type nc = cols ();
       
-	result = Sparse<U> (nr, nc, f_zero);
+        result = Sparse<U> (nr, nc, f_zero);
 
-	for (octave_idx_type j = 0; j < nc; j++)
-	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
-	    {
-	      octave_quit ();
-	      /* Use data instead of elem for better performance.  */
-	      result.data (ridx (i) + j * nr) = fcn (data(i));
-	    }
+        for (octave_idx_type j = 0; j < nc; j++)
+          for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+            {
+              octave_quit ();
+              /* Use data instead of elem for better performance.  */
+              result.data (ridx (i) + j * nr) = fcn (data(i));
+            }
 
-	result.maybe_compress (true);
+        result.maybe_compress (true);
       }
     else
       {
-	octave_idx_type nz = nnz ();
-	octave_idx_type nr = rows ();
-	octave_idx_type nc = cols ();
+        octave_idx_type nz = nnz ();
+        octave_idx_type nr = rows ();
+        octave_idx_type nc = cols ();
 
-	result = Sparse<U> (nr, nc, nz);
-	octave_idx_type ii = 0;
-	result.cidx (ii) = 0;
+        result = Sparse<U> (nr, nc, nz);
+        octave_idx_type ii = 0;
+        result.cidx (ii) = 0;
 
-	for (octave_idx_type j = 0; j < nc; j++)
-	  {
-	    for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
-	      {
-		U val = fcn (data (i));
-		if (val != 0.0)
-		  {
-		    result.data (ii) = val;
-		    result.ridx (ii++) = ridx (i);
-		  }
-		octave_quit ();
-	      }
-	    result.cidx (j+1) = ii;
-	  }
+        for (octave_idx_type j = 0; j < nc; j++)
+          {
+            for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+              {
+                U val = fcn (data (i));
+                if (val != 0.0)
+                  {
+                    result.data (ii) = val;
+                    result.ridx (ii++) = ridx (i);
+                  }
+                octave_quit ();
+              }
+            result.cidx (j+1) = ii;
+          }
 
-	result.maybe_compress (false);
+        result.maybe_compress (false);
       }
 
     return result;
   }
 
   // Overloads for function references.
   template <class U>
   Sparse<U>
@@ -593,95 +593,95 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 
 template <class LT, class RT>
 /* friend */ int
 assign1 (Sparse<LT>& lhs, const Sparse<RT>& rhs);
 
 template<typename T>
 std::istream&
 read_sparse_matrix (std::istream& is, Sparse<T>& a,
-		    T (*read_fcn) (std::istream&))
+                    T (*read_fcn) (std::istream&))
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nzmax ();
 
   if (nr > 0 && nc > 0)
     {
       octave_idx_type itmp;
       octave_idx_type jtmp;
       octave_idx_type iold = 0;
       octave_idx_type jold = 0;
       octave_idx_type ii = 0;
       T tmp;
        
       a.cidx (0) = 0;
       for (octave_idx_type i = 0; i < nz; i++)
-	{
+        {
           itmp = 0; jtmp = 0;
-	  is >> itmp;
-	  itmp--;
+          is >> itmp;
+          itmp--;
 
-	  is >> jtmp;
-	  jtmp--;
+          is >> jtmp;
+          jtmp--;
 
-	  if (itmp < 0 || itmp >= nr)
-	    {
-	      (*current_liboctave_error_handler)
-		("invalid sparse matrix: row index = %d out of range",
-		 itmp + 1);
-	      is.setstate (std::ios::failbit);
-	      goto done;
-	    }
+          if (itmp < 0 || itmp >= nr)
+            {
+              (*current_liboctave_error_handler)
+                ("invalid sparse matrix: row index = %d out of range",
+                 itmp + 1);
+              is.setstate (std::ios::failbit);
+              goto done;
+            }
 
-	  if (jtmp < 0 || jtmp >= nc)
-	    {
-	      (*current_liboctave_error_handler)
-		("invalid sparse matrix: column index = %d out of range",
-		 jtmp + 1);
-	      is.setstate (std::ios::failbit);
-	      goto done;
-	    }
+          if (jtmp < 0 || jtmp >= nc)
+            {
+              (*current_liboctave_error_handler)
+                ("invalid sparse matrix: column index = %d out of range",
+                 jtmp + 1);
+              is.setstate (std::ios::failbit);
+              goto done;
+            }
 
-	  if (jtmp < jold)
-	    {
-	      (*current_liboctave_error_handler)
-		("invalid sparse matrix: column indices must appear in ascending order");
-	      is.setstate (std::ios::failbit);
-	      goto done;
-	    }
+          if (jtmp < jold)
+            {
+              (*current_liboctave_error_handler)
+                ("invalid sparse matrix: column indices must appear in ascending order");
+              is.setstate (std::ios::failbit);
+              goto done;
+            }
           else if (jtmp > jold)
             {
               for (octave_idx_type j = jold; j < jtmp; j++)
                 a.cidx(j+1) = ii;
             }
           else if (itmp < iold)
-	    {
-	      (*current_liboctave_error_handler)
-		("invalid sparse matrix: row indices must appear in ascending order in each column");
-	      is.setstate (std::ios::failbit);
-	      goto done;
-	    }
+            {
+              (*current_liboctave_error_handler)
+                ("invalid sparse matrix: row indices must appear in ascending order in each column");
+              is.setstate (std::ios::failbit);
+              goto done;
+            }
 
-	  iold = itmp;
+          iold = itmp;
           jold = jtmp;
 
-	  tmp = read_fcn (is);
-	  
-	  if (is)
-	    {
-	      a.data (ii) = tmp;
-	      a.ridx (ii++) = itmp;
-	    }
-	  else
-	    goto done;
-	}
+          tmp = read_fcn (is);
+          
+          if (is)
+            {
+              a.data (ii) = tmp;
+              a.ridx (ii++) = itmp;
+            }
+          else
+            goto done;
+        }
 
       for (octave_idx_type j = jold; j < nc; j++)
-	a.cidx(j+1) = ii;
+        a.cidx(j+1) = ii;
     }
   
  done:
 
   return is;
 }
 
 #define INSTANTIATE_SPARSE_ASSIGN(LT, RT, API) \
diff --git a/liboctave/SparseCmplxCHOL.h b/liboctave/SparseCmplxCHOL.h
--- a/liboctave/SparseCmplxCHOL.h
+++ b/liboctave/SparseCmplxCHOL.h
@@ -38,61 +38,61 @@ public:
   SparseComplexCHOL (void) : 
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> () { }
 
   SparseComplexCHOL (const SparseComplexMatrix& a, bool natural = true) : 
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> 
   (a, natural) { }
 
   SparseComplexCHOL (const SparseComplexMatrix& a, octave_idx_type& info, 
-		     bool natural = true) :
+                     bool natural = true) :
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> 
   (a, info, natural) { }
 
   SparseComplexCHOL (const SparseComplexCHOL& a) : 
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a) { }
 
   ~SparseComplexCHOL (void) { }
 
   SparseComplexCHOL& operator = (const SparseComplexCHOL& a)
     {
       if (this != &a)
-	sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
-	  operator = (a);
+        sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
+          operator = (a);
 
       return *this;
     }
 
   SparseComplexMatrix chol_matrix (void) const { return R(); }
 
   SparseComplexMatrix L (void) const 
     { return sparse_base_chol<SparseComplexMatrix, Complex, 
-	SparseMatrix>:: L (); }
+        SparseMatrix>:: L (); }
 
   SparseComplexMatrix R (void) const 
     { return sparse_base_chol<SparseComplexMatrix, Complex,
-	SparseMatrix>:: R (); }
+        SparseMatrix>:: R (); }
 
   octave_idx_type P (void) const 
    { return sparse_base_chol<SparseComplexMatrix, Complex, 
         SparseMatrix>:: P (); }
 
   ColumnVector perm (void) const 
     { return sparse_base_chol<SparseComplexMatrix, Complex, 
-	SparseMatrix>:: perm (); }
+        SparseMatrix>:: perm (); }
 
   SparseMatrix Q (void) const 
     { return sparse_base_chol<SparseComplexMatrix, Complex, 
-	SparseMatrix>:: Q (); }
+        SparseMatrix>:: Q (); }
 
   double rcond (void) const
     { return sparse_base_chol<SparseComplexMatrix, Complex, 
-	SparseMatrix>:: rcond (); }
+        SparseMatrix>:: rcond (); }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
   SparseComplexMatrix inverse (void) const
     { return sparse_base_chol<SparseComplexMatrix, Complex, 
-	SparseMatrix>:: inverse (); }
+        SparseMatrix>:: inverse (); }
 };
 
 SparseComplexMatrix OCTAVE_API chol2inv (const SparseComplexMatrix& r);
 
 #endif
diff --git a/liboctave/SparseCmplxLU.h b/liboctave/SparseCmplxLU.h
--- a/liboctave/SparseCmplxLU.h
+++ b/liboctave/SparseCmplxLU.h
@@ -34,33 +34,33 @@ SparseComplexLU
   : public sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>
 {
 public:
 
   SparseComplexLU (void) 
     : sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> () { }
 
   SparseComplexLU (const SparseComplexMatrix& a, 
-		   const Matrix& piv_thres = Matrix (),
-		   bool scale = false);
+                   const Matrix& piv_thres = Matrix (),
+                   bool scale = false);
 
   SparseComplexLU (const SparseComplexMatrix& a, const ColumnVector& Qinit,
-		   const Matrix& piv_thres = Matrix (), 
-		   bool scale = false, bool FixedQ = false,
-		   double droptol = -1., bool milu = false,
-		   bool udiag = false);
+                   const Matrix& piv_thres = Matrix (), 
+                   bool scale = false, bool FixedQ = false,
+                   double droptol = -1., bool milu = false,
+                   bool udiag = false);
 
   SparseComplexLU (const SparseComplexLU& a) 
     : sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> (a) { }
 
   SparseComplexLU& operator = (const SparseComplexLU& a)
     {
       if (this != &a)
-	sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> 
-	  :: operator = (a);
+        sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> 
+          :: operator = (a);
 
       return *this;
     }
 
   ~SparseComplexLU (void) { }
 };
 
 #endif
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -84,29 +84,29 @@ public:
   SparseComplexQR (const SparseComplexMatrix& a, int order = 0) : 
     rep (new SparseComplexQR_rep (a, order)) { }
 
   SparseComplexQR (const SparseComplexQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseComplexQR (void)
     {
       if (--rep->count <= 0)
-	delete rep;
+        delete rep;
     }
 
   SparseComplexQR& operator = (const SparseComplexQR& a)
     {
       if (this != &a)
-	{
-	  if (--rep->count <= 0)
-	    delete rep;
+        {
+          if (--rep->count <= 0)
+            delete rep;
 
-	  rep = a.rep;
-	  rep->count++;
-	}
+          rep = a.rep;
+          rep->count++;
+        }
       return *this;
     }
 
   bool ok (void) const { return rep->ok(); }
 
   SparseComplexMatrix V (void) const { return rep->V(); }
 
   ColumnVector Pinv (void) const { return rep->P(); }
@@ -116,56 +116,56 @@ public:
   SparseComplexMatrix R (const bool econ = false) const 
     { return rep->R(econ); }
 
   ComplexMatrix C (const ComplexMatrix &b) const { return rep->C(b); }
 
   ComplexMatrix Q (void) const { return rep->Q(); }
 
   friend ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
-				octave_idx_type &info);
+                                octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-				      const SparseMatrix &b,
-				      octave_idx_type &info);
+                                      const SparseMatrix &b,
+                                      octave_idx_type &info);
 
   friend ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-				const ComplexMatrix &b,
-				octave_idx_type &info);
+                                const ComplexMatrix &b,
+                                octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-				      const SparseComplexMatrix &b,
-				      octave_idx_type &info);
+                                      const SparseComplexMatrix &b,
+                                      octave_idx_type &info);
 
 protected:
 #ifdef HAVE_CXSPARSE
   CXSPARSE_ZNAME (s) * S (void) { return rep->S; }
 
   CXSPARSE_ZNAME (n) * N (void) { return rep->N; }
 #endif
 };
 
 
 // Publish externally used friend functions.
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
-			      octave_idx_type &info);
+                              octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-			      const MArray2<double> &b, 
-			      octave_idx_type &info);
+                              const MArray2<double> &b, 
+                              octave_idx_type &info);
 
 extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-				    const SparseMatrix &b,
-				    octave_idx_type &info);
+                                    const SparseMatrix &b,
+                                    octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-			      const ComplexMatrix &b,
-			      octave_idx_type &info);
+                              const ComplexMatrix &b,
+                              octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-			      const MArray2<Complex> &b, 
-			      octave_idx_type &info);
+                              const MArray2<Complex> &b, 
+                              octave_idx_type &info);
 
 extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-				    const SparseComplexMatrix &b,
-				    octave_idx_type &info);
+                                    const SparseComplexMatrix &b,
+                                    octave_idx_type &info);
 #endif
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -83,29 +83,29 @@ public:
   SparseQR (const SparseMatrix& a, int order = 0) : 
     rep (new SparseQR_rep (a, order)) { }
 
   SparseQR (const SparseQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseQR (void)
     {
       if (--rep->count <= 0)
-	delete rep;
+        delete rep;
     }
 
   SparseQR& operator = (const SparseQR& a)
     {
       if (this != &a)
-	{
-	  if (--rep->count <= 0)
-	    delete rep;
+        {
+          if (--rep->count <= 0)
+            delete rep;
 
-	  rep = a.rep;
-	  rep->count++;
-	}
+          rep = a.rep;
+          rep->count++;
+        }
       return *this;
     }
 
   bool ok (void) const { return rep->ok(); }
 
   SparseMatrix V (void) const { return rep->V(); }
 
   ColumnVector Pinv (void) const { return rep->P(); }
@@ -114,51 +114,51 @@ public:
 
   SparseMatrix R (const bool econ = false) const { return rep->R(econ); }
 
   Matrix C (const Matrix &b) const { return rep->C(b); }
 
   Matrix Q (void) const { return rep->Q(); }
 
   friend Matrix qrsolve (const SparseMatrix &a, const Matrix &b, 
-			 octave_idx_type &info);
+                         octave_idx_type &info);
 
   friend SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
-			 octave_idx_type &info);
+                         octave_idx_type &info);
 
   friend ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
-				octave_idx_type &info);
+                                octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseMatrix &a, 
-				      const SparseComplexMatrix &b,
-				      octave_idx_type &info);
+                                      const SparseComplexMatrix &b,
+                                      octave_idx_type &info);
 
 protected:
 #ifdef HAVE_CXSPARSE
   CXSPARSE_DNAME (s) * S (void) { return rep->S; }
 
   CXSPARSE_DNAME (n) * N (void) { return rep->N; }
 #endif
 };
 
 
 // Publish externally used friend functions.
 
 extern Matrix qrsolve (const SparseMatrix &a, const Matrix &b, 
-		       octave_idx_type &info);
+                       octave_idx_type &info);
 
 extern Matrix qrsolve (const SparseMatrix &a, const MArray2<double> &b, 
-		       octave_idx_type &info);
+                       octave_idx_type &info);
 
 extern SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
-			     octave_idx_type &info);
+                             octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
-			      octave_idx_type &info);
+                              octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseMatrix &a, const MArray2<Complex> &b, 
-			      octave_idx_type &info);
+                              octave_idx_type &info);
 
 extern SparseComplexMatrix qrsolve (const SparseMatrix &a, 
-				    const SparseComplexMatrix &b,
-				    octave_idx_type &info);
+                                    const SparseComplexMatrix &b,
+                                    octave_idx_type &info);
 
 #endif
diff --git a/liboctave/SparsedbleCHOL.h b/liboctave/SparsedbleCHOL.h
--- a/liboctave/SparsedbleCHOL.h
+++ b/liboctave/SparsedbleCHOL.h
@@ -34,28 +34,28 @@ SparseCHOL : public sparse_base_chol <Sp
 public:
 
   SparseCHOL (void) : sparse_base_chol<SparseMatrix, double, SparseMatrix> () { }
 
   SparseCHOL (const SparseMatrix& a, bool natural = true) : 
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, natural) { }
 
   SparseCHOL (const SparseMatrix& a, octave_idx_type& info, 
-	      bool natural = true) : 
+              bool natural = true) : 
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, info, natural) { }
 
   SparseCHOL (const SparseCHOL& a) : 
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a) { }
 
   ~SparseCHOL (void) { }
 
   SparseCHOL& operator = (const SparseCHOL& a)
     {
       if (this != &a)
-	sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
+        sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
 
       return *this;
     }
 
   SparseMatrix chol_matrix (void) const { return R(); }
 
   SparseMatrix L (void) const 
   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: L (); }
diff --git a/liboctave/SparsedbleLU.h b/liboctave/SparsedbleLU.h
--- a/liboctave/SparsedbleLU.h
+++ b/liboctave/SparsedbleLU.h
@@ -32,31 +32,31 @@ OCTAVE_API
 SparseLU : public sparse_base_lu <SparseMatrix, double, SparseMatrix, double>
 {
 public:
 
   SparseLU (void) 
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> () { }
 
   SparseLU (const SparseMatrix& a, const Matrix& piv_thres = Matrix(),
-	    bool scale = false);
+            bool scale = false);
 
   SparseLU (const SparseMatrix& a, const ColumnVector& Qinit, 
-	    const Matrix& piv_thres = Matrix(), bool scale = false, 
-	    bool FixedQ = false, double droptol = -1., 
-	    bool milu = false, bool udiag = false);
+            const Matrix& piv_thres = Matrix(), bool scale = false, 
+            bool FixedQ = false, double droptol = -1., 
+            bool milu = false, bool udiag = false);
 
   SparseLU (const SparseLU& a) 
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> (a) { }
 
   SparseLU& operator = (const SparseLU& a)
     {
       if (this != &a)
-	sparse_base_lu <SparseMatrix, double, SparseMatrix, double> 
-	  :: operator = (a);
+        sparse_base_lu <SparseMatrix, double, SparseMatrix, double> 
+          :: operator = (a);
 
       return *this;
     }
 
   ~SparseLU (void) { }
 };
 
 #endif
diff --git a/liboctave/base-dae.h b/liboctave/base-dae.h
--- a/liboctave/base-dae.h
+++ b/liboctave/base-dae.h
@@ -32,42 +32,42 @@ public:
 
   base_diff_alg_eqn (void)
     : base_diff_eqn (), xdot () { }
 
   base_diff_alg_eqn (const ColumnVector& xx, double tt)
     : base_diff_eqn (xx, tt), xdot (xx.length (), 0.0) { }
 
   base_diff_alg_eqn (const ColumnVector& xx, const ColumnVector& xxdot,
-		     double tt)
+                     double tt)
     : base_diff_eqn (xx, tt), xdot (xxdot) { }
 
   base_diff_alg_eqn (const base_diff_alg_eqn& a)
     : base_diff_eqn (a), xdot (a.xdot) { }
 
   virtual ~base_diff_alg_eqn (void) { }
 
   base_diff_alg_eqn& operator = (const base_diff_alg_eqn& a)
     {
       if (this != &a)
-	{
-	  base_diff_eqn::operator = (a);
-	  xdot = a.xdot;
-	}
+        {
+          base_diff_eqn::operator = (a);
+          xdot = a.xdot;
+        }
       return *this;
     }
 
   void initialize (const ColumnVector& x0, double t0)
     {
       base_diff_eqn::initialize (x0, t0);
       xdot = ColumnVector (x0.length (), 0.0);
     }
 
   void initialize (const ColumnVector& x0, const ColumnVector& xdot0,
-		   double t0)
+                   double t0)
     {
       base_diff_eqn::initialize (x0, t0);
       xdot = xdot0;
     }
 
   ColumnVector state_derivative (void) { return xdot; }
 
 protected:
diff --git a/liboctave/base-de.h b/liboctave/base-de.h
--- a/liboctave/base-de.h
+++ b/liboctave/base-de.h
@@ -45,25 +45,25 @@ public:
     : x (a.x), t (a.t), stop_time (0.0), stop_time_set (false),
       restart (true), integration_error (false), istate (0) { }
 
   virtual ~base_diff_eqn (void) { }
 
   base_diff_eqn& operator = (const base_diff_eqn& a)
     {
       if (this != &a)
-	{
-	  x = a.x;
-	  t = a.t;
-	  stop_time = a.stop_time;
-	  stop_time_set = a.stop_time_set;
-	  restart = a.restart;
-	  integration_error = a.integration_error;
-	  istate = a.istate;
-	}
+        {
+          x = a.x;
+          t = a.t;
+          stop_time = a.stop_time;
+          stop_time_set = a.stop_time_set;
+          restart = a.restart;
+          integration_error = a.integration_error;
+          istate = a.istate;
+        }
 
       return *this;
     }
 
   void initialize (const ColumnVector& x0, double t0)
     {
       x = x0;
       t = t0;
diff --git a/liboctave/base-lu.h b/liboctave/base-lu.h
--- a/liboctave/base-lu.h
+++ b/liboctave/base-lu.h
@@ -41,21 +41,21 @@ public:
     a_fact (a.a_fact), l_fact (a.l_fact), ipvt (a.ipvt) { }
 
   base_lu (const lu_type& l, const lu_type& u, 
            const PermMatrix& p);
 
   base_lu& operator = (const base_lu& a)
     {
       if (this != &a)
-	{
-	  a_fact = a.a_fact;
+        {
+          a_fact = a.a_fact;
           l_fact = a.l_fact;
-	  ipvt = a.ipvt;
-	}
+          ipvt = a.ipvt;
+        }
       return *this;
     }
 
   ~base_lu (void) { }
 
   bool packed (void) const;
 
   void unpack (void);
diff --git a/liboctave/base-min.h b/liboctave/base-min.h
--- a/liboctave/base-min.h
+++ b/liboctave/base-min.h
@@ -36,26 +36,26 @@ public:
 
   base_minimizer (const base_minimizer& a) : x (a.x) { }
 
   virtual ~base_minimizer (void) { }
 
   base_minimizer& operator = (const base_minimizer& a)
     {
       if (this != &a)
-	x = a.x;
+        x = a.x;
 
       return *this;
     }
 
   // Derived classes must provide a function to actually do the
   // minimization.
 
   virtual ColumnVector do_minimize (double& objf, octave_idx_type& inform,
-				    ColumnVector& lambda) = 0;
+                                    ColumnVector& lambda) = 0;
 
   // Lots of ways to call the single function and optionally set and
   // get additional information.
 
   virtual ColumnVector minimize (void)
     {
       double objf;
       octave_idx_type inform;
@@ -72,17 +72,17 @@ public:
 
   virtual ColumnVector minimize (double& objf, octave_idx_type& inform)
     {
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (double& objf, octave_idx_type& inform,
-				 ColumnVector& lambda)
+                                 ColumnVector& lambda)
     {
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (const ColumnVector& x0)
     {
       x = x0;
       double objf;
@@ -95,25 +95,25 @@ public:
     {
       x = x0;
       octave_idx_type inform;
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf,
-				 octave_idx_type& inform)
+                                 octave_idx_type& inform)
     {
       x = x0;
       ColumnVector lambda;
       return do_minimize (objf, inform, lambda);
     }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf,
-				 octave_idx_type& inform, ColumnVector& lambda)
+                                 octave_idx_type& inform, ColumnVector& lambda)
     {
       x = x0;
       return do_minimize (objf, inform, lambda);
     }
 
   octave_idx_type size (void) const { return x.capacity (); }
 
 protected:
diff --git a/liboctave/base-qr.h b/liboctave/base-qr.h
--- a/liboctave/base-qr.h
+++ b/liboctave/base-qr.h
@@ -47,20 +47,20 @@ public:
   base_qr (const qr_type& q, const qr_type& r);
 
   base_qr (const base_qr& a) : 
     q (a.q), r (a.r) { }
 
   base_qr& operator = (const base_qr& a)
     {
       if (this != &a)
-	{
-	  q = a.q;
-	  r = a.r;
-	}
+        {
+          q = a.q;
+          r = a.r;
+        }
       return *this;
     }
 
   qr_type Q (void) const { return q; }
 
   qr_type R (void) const { return r; }
 
   qr_type_t get_type (void) const;
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -80,21 +80,21 @@ public:
   boolNDArray& insert (const boolNDArray& a, octave_idx_type r, octave_idx_type c);
   boolNDArray& insert (const boolNDArray& a, const Array<octave_idx_type>& ra_idx);
 
   boolMatrix matrix_value (void) const;
 
   boolNDArray squeeze (void) const { return Array<bool>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension = 0);
+                               const dim_vector& dimensions,
+                               int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions);
+                            const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const NDArray& a);
   // friend std::istream& operator >> (std::istream& is, NDArray& a);
 
   static bool resize_fill_value (void) { return false; }
 
diff --git a/liboctave/boolSparse.h b/liboctave/boolSparse.h
--- a/liboctave/boolSparse.h
+++ b/liboctave/boolSparse.h
@@ -51,23 +51,23 @@ public:
   SparseBoolMatrix (const SparseBoolMatrix& a, const dim_vector& dv) 
     : Sparse<bool> (a, dv) { }
 
   explicit SparseBoolMatrix (const boolMatrix& a) : Sparse<bool> (a) { }
 
   explicit SparseBoolMatrix (const boolNDArray& a) : Sparse<bool> (a) { }
 
   explicit SparseBoolMatrix (const Array<bool> a, const Array<octave_idx_type>& r, 
-			     const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
-			     octave_idx_type nc = -1, bool sum_terms = true)
+                             const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+                             octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<bool> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseBoolMatrix (const Array<bool> a, const Array<double>& r, 
-			     const Array<double>& c, octave_idx_type nr = -1, 
-			     octave_idx_type nc = -1, bool sum_terms = true)
+                             const Array<double>& c, octave_idx_type nr = -1, 
+                             octave_idx_type nc = -1, bool sum_terms = true)
     : Sparse<bool> (a, r, c, nr, nc, sum_terms) { }
 
   SparseBoolMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<bool> (r, c, num_nz) { }
 
   SparseBoolMatrix& operator = (const SparseBoolMatrix& a)
     {
       Sparse<bool>::operator = (a);
       return *this;
@@ -81,17 +81,17 @@ public:
 
   // destructive insert/delete/reorder operations
 
   SparseBoolMatrix& insert (const SparseBoolMatrix& a, octave_idx_type r, octave_idx_type c);
 
   SparseBoolMatrix& insert (const SparseBoolMatrix& a, const Array<octave_idx_type>& indx);
 
   SparseBoolMatrix concat (const SparseBoolMatrix& rb, 
-			   const Array<octave_idx_type>& ra_idx);
+                           const Array<octave_idx_type>& ra_idx);
 
   SparseBoolMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix matrix_value (void) const;
 
   SparseBoolMatrix squeeze (void) const;
 
   SparseBoolMatrix index (idx_vector& i, int resize_ok) const;
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -76,21 +76,21 @@ public:
   charNDArray& insert (const charNDArray& a, octave_idx_type r, octave_idx_type c);
   charNDArray& insert (const charNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   charMatrix matrix_value (void) const;
 
   charNDArray squeeze (void) const { return Array<char>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension = 0);
+                               const dim_vector& dimensions,
+                               int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions);
+                            const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   static char resize_fill_value (void) { return '\0'; }
 
diff --git a/liboctave/cmd-hist.h b/liboctave/cmd-hist.h
--- a/liboctave/cmd-hist.h
+++ b/liboctave/cmd-hist.h
@@ -82,17 +82,17 @@ public:
 
   static void read (bool = true);
 
   static void read (const std::string&, bool = true);
 
   static void read_range (int = -1, int = -1, bool = true);
 
   static void read_range (const std::string&, int = -1, int = -1,
-			  bool = true);
+                          bool = true);
 
   static void write (const std::string& = std::string ());
 
   static void append (const std::string& = std::string ());
 
   static void truncate_file (const std::string& = std::string (), int = -1);
 
   static string_vector list (int = -1, bool = false);
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -123,31 +123,31 @@ public:
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
 private:
   Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
-		   int force, int calc_cond) const;
+                   int force, int calc_cond) const;
 
   Matrix finverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
-		   int force, int calc_cond) const;
+                   int force, int calc_cond) const;
 
 public:
   Matrix inverse (void) const;
   Matrix inverse (octave_idx_type& info) const;
   Matrix inverse (octave_idx_type& info, double& rcon, int force = 0,
-		  int calc_cond = 1) const;
+                  int calc_cond = 1) const;
 
   Matrix inverse (MatrixType &mattype) const;
   Matrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   Matrix inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
-		  int force = 0, int calc_cond = 1) const;
+                  int force = 0, int calc_cond = 1) const;
 
   Matrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
@@ -159,132 +159,132 @@ public:
                    double& rcon, int calc_cond = 1) const;
 
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		  double& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  double& rcon, solve_singularity_handler sing_handler,
+                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		  double& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  double& rcon, solve_singularity_handler sing_handler,
+                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		 double& rcon, solve_singularity_handler sing_handler,
-		 bool calc_cond = false) const;
+                 double& rcon, solve_singularity_handler sing_handler,
+                 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		double& rcon) const;
+                double& rcon) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcon, solve_singularity_handler sing_handler,
-		bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
+                double& rcon, solve_singularity_handler sing_handler,
+                bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcon) const;
+                       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true, 
+                       octave_idx_type& info, double& rcon,
+                       solve_singularity_handler sing_handler,
+                       bool singular_fallback = true, 
                        blas_trans_type transt = blas_no_trans) const;
 
   ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info) const;
+                      octave_idx_type& info) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcon) const;
+                      octave_idx_type& info, double& rcon) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler, 
+                      octave_idx_type& info, double& rcon,
+                      solve_singularity_handler sing_handler, 
                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
-			     const ComplexColumnVector& b) const;
+                             const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcon) const;
+                             octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler, 
+                             octave_idx_type& info, double& rcon,
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
-		solve_singularity_handler sing_handler, 
+                solve_singularity_handler sing_handler, 
                 blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler, 
                        blas_trans_type transt = blas_no_trans) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler, 
+                      solve_singularity_handler sing_handler, 
                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcon) const;
+                             double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcon, solve_singularity_handler sing_handler, 
+                             double& rcon, solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   Matrix lssolve (const Matrix& b) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info, 
-		  octave_idx_type& rank) const;
+                  octave_idx_type& rank) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info, 
-		  octave_idx_type& rank, double& rcon) const;
+                  octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank) const;
+                         octave_idx_type& rank) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, double &rcon) const;
+                         octave_idx_type& rank, double &rcon) const;
 
   ColumnVector lssolve (const ColumnVector& b) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank) const;
+                        octave_idx_type& rank) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, double& rcon) const;
+                        octave_idx_type& rank, double& rcon) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, 
-			       octave_idx_type& info) const;
+                               octave_idx_type& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
-			       octave_idx_type& info,
-			       octave_idx_type& rank) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, 
-			       octave_idx_type& info,
-			       octave_idx_type& rank, double& rcon) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank, double& rcon) const;
 
   Matrix& operator += (const DiagMatrix& a);
   Matrix& operator -= (const DiagMatrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -47,17 +47,17 @@ public:
   NDArray (const dim_vector& dv, double val)
     : MArrayN<double> (dv, val) { }
   
   NDArray (const NDArray& a) : MArrayN<double> (a) { }
 
   NDArray (const Matrix& a) : MArrayN<double> (a) { }
 
   NDArray (const Array<octave_idx_type>& a, bool zero_based = false, 
-	   bool negative_to_nan = false);
+           bool negative_to_nan = false);
 
   template <class U>
   NDArray (const MArrayN<U>& a) : MArrayN<double> (a) { }
 
   template <class U>
   NDArray (const Array<U>& a) : MArrayN<double> (a) { }
 
   template <class U>
@@ -134,21 +134,21 @@ public:
 
   friend class ComplexNDArray;
 
   Matrix matrix_value (void) const;
 
   NDArray squeeze (void) const { return MArrayN<double>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension = 0);
+                               const dim_vector& dimensions,
+                               int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions);
+                            const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
   static double resize_fill_value (void) { return 0; }
 
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -68,23 +68,23 @@ SparseMatrix : public MSparse<double>
 
   explicit SparseMatrix (const SparseBoolMatrix& a);
 
   explicit SparseMatrix (const Matrix& a) : MSparse<double> (a) { }
 
   explicit SparseMatrix (const NDArray& a) : MSparse<double> (a) { }
 
   explicit SparseMatrix (const Array<double> a, const Array<octave_idx_type>& r, 
-			 const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
-			 octave_idx_type nc = -1, bool sum_terms = true)
+                         const Array<octave_idx_type>& c, octave_idx_type nr = -1, 
+                         octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<double> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseMatrix (const Array<double> a, const Array<double>& r, 
-			 const Array<double>& c, octave_idx_type nr = -1, 
-			 octave_idx_type nc = -1, bool sum_terms = true)
+                         const Array<double>& c, octave_idx_type nr = -1, 
+                         octave_idx_type nc = -1, bool sum_terms = true)
     : MSparse<double> (a, r, c, nr, nc, sum_terms) { }
 
   explicit SparseMatrix (const DiagMatrix& a);
 
   explicit SparseMatrix (const PermMatrix& a);
 
   SparseMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : MSparse<double> (r, c, num_nz) { }
 
@@ -107,17 +107,17 @@ SparseMatrix : public MSparse<double>
   // destructive insert/delete/reorder operations
 
   SparseMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
 
   SparseMatrix& insert (const SparseMatrix& a, const Array<octave_idx_type>& indx);
 
   SparseMatrix concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx);
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
-			      const Array<octave_idx_type>& ra_idx);
+                              const Array<octave_idx_type>& ra_idx);
 
   friend OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
   friend OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
   friend OCTAVE_API SparseMatrix atan2 (const double& x, const SparseMatrix& y);
   friend OCTAVE_API SparseMatrix atan2 (const SparseMatrix& x, const double& y);
   friend OCTAVE_API SparseMatrix atan2 (const SparseMatrix& x, const SparseMatrix& y);
 
@@ -130,261 +130,261 @@ SparseMatrix : public MSparse<double>
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
 private:
   SparseMatrix dinverse (MatrixType &mattyp, octave_idx_type& info, 
-			 double& rcond, const bool force = false, 
-			 const bool calccond = true) const;
+                         double& rcond, const bool force = false, 
+                         const bool calccond = true) const;
 
   SparseMatrix tinverse (MatrixType &mattyp, octave_idx_type& info, 
-			 double& rcond, const bool force = false, 
-			 const bool calccond = true) const;
+                         double& rcond, const bool force = false, 
+                         const bool calccond = true) const;
 
 public:
   SparseMatrix inverse (void) const;
   SparseMatrix inverse (MatrixType& mattype) const;
   SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
   SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info, 
-		        double& rcond, int force = 0, int calc_cond = 1) const;
+                        double& rcond, int force = 0, int calc_cond = 1) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
   Matrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler, 
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler, 
+                bool calc_cond = false) const;
 
   SparseMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond,
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
   Matrix trisolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond,
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
   Matrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
-		    Matrix &Info, solve_singularity_handler sing_handler,
-		    bool calc_cond = false) const;
+                    Matrix &Info, solve_singularity_handler sing_handler,
+                    bool calc_cond = false) const;
 
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
-		octave_idx_type& info, double& rcond, 
-		solve_singularity_handler sing_handler,
-		bool calc_cond = false) const;
+                octave_idx_type& info, double& rcond, 
+                solve_singularity_handler sing_handler,
+                bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
-		double& rcond) const;
+                double& rcond) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-		double& rcond, solve_singularity_handler sing_handler,
-		bool singular_fallback = true) const;
+                double& rcond, solve_singularity_handler sing_handler,
+                bool singular_fallback = true) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
-		       octave_idx_type& info, double& rcond) const;
+                       octave_idx_type& info, double& rcond) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
-		       octave_idx_type& info, double& rcond, 
-		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+                       octave_idx_type& info, double& rcond, 
+                       solve_singularity_handler sing_handler,
+                       bool singular_fallback = true) const;
 
   SparseMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
   SparseMatrix solve (MatrixType &typ, const SparseMatrix& b, 
-		      octave_idx_type& info) const;
+                      octave_idx_type& info) const;
   SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
-		      octave_idx_type& info, double& rcond) const;
+                      octave_idx_type& info, double& rcond) const;
   SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
-		      octave_idx_type& info, double& rcond, 
-		      solve_singularity_handler sing_handler,
-		      bool singular_fallback = true) const;
+                      octave_idx_type& info, double& rcond, 
+                      solve_singularity_handler sing_handler,
+                      bool singular_fallback = true) const;
 
   SparseComplexMatrix solve (MatrixType &typ, 
-			     const SparseComplexMatrix& b) const;
+                             const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
-			     octave_idx_type& info, double& rcond) const;
+                             octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
-			     octave_idx_type& info, double& rcond, 
-			     solve_singularity_handler sing_handler,
-			     bool singular_fallabck = true) const;
+                             octave_idx_type& info, double& rcond, 
+                             solve_singularity_handler sing_handler,
+                             bool singular_fallabck = true) const;
 
   ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info) const;
+                      octave_idx_type& info) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
-		      octave_idx_type& info, double& rcond) const;
+                      octave_idx_type& info, double& rcond) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b,
-		      octave_idx_type& info, double& rcond, 
-		      solve_singularity_handler sing_handler) const;
+                      octave_idx_type& info, double& rcond, 
+                      solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
-			     const ComplexColumnVector& b) const;
+                             const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
-			     octave_idx_type& info, double& rcond) const;
+                             octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
-			     octave_idx_type& info, double& rcond,
-			     solve_singularity_handler sing_handler) const;
+                             octave_idx_type& info, double& rcond,
+                             solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+                solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, 
-		       double& rcond) const;
+                       double& rcond) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
-		       solve_singularity_handler sing_handler) const;
+                       solve_singularity_handler sing_handler) const;
 
   SparseMatrix solve (const SparseMatrix& b) const;
   SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
   SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
-		      double& rcond) const;
+                      double& rcond) const;
   SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info, double& rcond,
-		solve_singularity_handler sing_handler) const;
+                solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
-			     double& rcond) const;
+                             double& rcond) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
-			     double& rcond,
-			     solve_singularity_handler sing_handler) const;
+                             double& rcond,
+                             solve_singularity_handler sing_handler) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
-		      solve_singularity_handler sing_handler) const;
+                      solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond) const;
+                             double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcond,
-			     solve_singularity_handler sing_handler) const;
+                             double& rcond,
+                             solve_singularity_handler sing_handler) const;
 
   // other operations
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_zero (void) const;
@@ -432,25 +432,25 @@ public:
 // Publish externally used friend functions.
 
 extern OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
 extern OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
 // Other operators.
 
 extern OCTAVE_API SparseMatrix operator * (const SparseMatrix& a, 
-				const SparseMatrix& b);
+                                const SparseMatrix& b);
 extern OCTAVE_API Matrix operator * (const Matrix& a, 
-				const SparseMatrix& b);
+                                const SparseMatrix& b);
 extern OCTAVE_API Matrix mul_trans (const Matrix& a, 
-				const SparseMatrix& b);
+                                const SparseMatrix& b);
 extern OCTAVE_API Matrix operator * (const SparseMatrix& a, 
-				const Matrix& b);
+                                const Matrix& b);
 extern OCTAVE_API Matrix trans_mul (const SparseMatrix& a, 
-				const Matrix& b);
+                                const Matrix& b);
 
 extern OCTAVE_API SparseMatrix operator * (const DiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseMatrix operator * (const SparseMatrix&, const DiagMatrix&);
 
 extern OCTAVE_API SparseMatrix operator + (const DiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseMatrix operator + (const SparseMatrix&, const DiagMatrix&);
 extern OCTAVE_API SparseMatrix operator - (const DiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseMatrix operator - (const SparseMatrix&, const DiagMatrix&);
diff --git a/liboctave/data-conv.h b/liboctave/data-conv.h
--- a/liboctave/data-conv.h
+++ b/liboctave/data-conv.h
@@ -59,21 +59,21 @@ public:
       dt_ulonglong = 21,
       dt_float     = 22,
       dt_unknown   = 23 // Must be last, have largest value!
     };
 
   static data_type string_to_data_type (const std::string& s);
 
   static void string_to_data_type (const std::string& s, int& block_size,
-				   data_type& input_type,
-				   data_type& output_type);
+                                   data_type& input_type,
+                                   data_type& output_type);
 
   static void string_to_data_type (const std::string& s, int& block_size,
-				   data_type& output_type);
+                                   data_type& output_type);
 
   static std::string data_type_as_string (data_type dt);
 };
 
 // Add new entries to the end of this enum, otherwise Octave will not
 // be able to read binary data files stored in Octave's binary data
 // format that were created with previous versions of Octave.
 
@@ -88,37 +88,37 @@ enum save_type
     LS_FLOAT   = 6,
     LS_DOUBLE  = 7,
     LS_U_LONG  = 8,
     LS_LONG    = 9
   };
 
 extern OCTAVE_API void
 do_double_format_conversion (void *data, int len,
-			     oct_mach_info::float_format from_fmt,
-			     oct_mach_info::float_format to_fmt
-			       = oct_mach_info::native_float_format ());
+                             oct_mach_info::float_format from_fmt,
+                             oct_mach_info::float_format to_fmt
+                               = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
 do_float_format_conversion (void *data, int len,
-			    oct_mach_info::float_format from_fmt,
-			    oct_mach_info::float_format to_fmt
-			      = oct_mach_info::native_float_format ());
+                            oct_mach_info::float_format from_fmt,
+                            oct_mach_info::float_format to_fmt
+                              = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
 do_float_format_conversion (void *data, size_t sz, int len,
-			    oct_mach_info::float_format from_fmt,
-			    oct_mach_info::float_format to_fmt
-			      = oct_mach_info::native_float_format ());
+                            oct_mach_info::float_format from_fmt,
+                            oct_mach_info::float_format to_fmt
+                              = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
 read_doubles (std::istream& is, double *data, save_type type, int len,
-	      bool swap, oct_mach_info::float_format fmt);
+              bool swap, oct_mach_info::float_format fmt);
 extern OCTAVE_API void
 write_doubles (std::ostream& os, const double *data, save_type type, int len);
 
 extern OCTAVE_API void
 read_floats (std::istream& is, float *data, save_type type, int len,
-	      bool swap, oct_mach_info::float_format fmt);
+              bool swap, oct_mach_info::float_format fmt);
 extern OCTAVE_API void
 write_floats (std::ostream& os, const float *data, save_type type, int len);
 
 #endif
diff --git a/liboctave/dbleCHOL.h b/liboctave/dbleCHOL.h
--- a/liboctave/dbleCHOL.h
+++ b/liboctave/dbleCHOL.h
@@ -43,20 +43,20 @@ public:
   CHOL (const Matrix& a, octave_idx_type& info, bool calc_cond = false) 
     { info = init (a, calc_cond); }
 
   CHOL (const CHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   CHOL& operator = (const CHOL& a)
     {
       if (this != &a)
-	{
-	  chol_mat = a.chol_mat;
-	  xrcond = a.xrcond;
-	}
+        {
+          chol_mat = a.chol_mat;
+          xrcond = a.xrcond;
+        }
       return *this;
     }
 
   Matrix chol_matrix (void) const { return chol_mat; }
 
   double rcond (void) const { return xrcond; }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
diff --git a/liboctave/dbleGEPBAL.h b/liboctave/dbleGEPBAL.h
--- a/liboctave/dbleGEPBAL.h
+++ b/liboctave/dbleGEPBAL.h
@@ -44,22 +44,22 @@ public:
 
   GEPBALANCE (const GEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
     balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   GEPBALANCE& operator = (const GEPBALANCE& a)
     {
       if (this != &a)
-	{
-	  balanced_mat = a.balanced_mat;
-	  balanced_mat2 = a.balanced_mat2;
-	  balancing_mat = a.balancing_mat;
-	  balancing_mat2 = a.balancing_mat2;
-	}
+        {
+          balanced_mat = a.balanced_mat;
+          balanced_mat2 = a.balanced_mat2;
+          balancing_mat = a.balancing_mat;
+          balancing_mat2 = a.balancing_mat2;
+        }
       return *this;
     }
 
   ~GEPBALANCE (void) { }
 
   Matrix balanced_matrix (void) const { return balanced_mat; }
 
   Matrix balanced_matrix2 (void) const { return balanced_mat2; }
@@ -73,12 +73,12 @@ public:
 private:
 
   Matrix balanced_mat;
   Matrix balanced_mat2;
   Matrix balancing_mat;
   Matrix balancing_mat2;
 
   octave_idx_type init (const Matrix& a, const Matrix& b, 
-			const std::string& balance_job);
+                        const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/dbleHESS.h b/liboctave/dbleHESS.h
--- a/liboctave/dbleHESS.h
+++ b/liboctave/dbleHESS.h
@@ -41,20 +41,20 @@ public:
   HESS (const Matrix& a, octave_idx_type& info) { info = init (a); }
 
   HESS (const HESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   HESS& operator = (const HESS& a)
     {
       if (this != &a)
-	{
-	  hess_mat = a.hess_mat;
-	  unitary_hess_mat = a.unitary_hess_mat;
-	}
+        {
+          hess_mat = a.hess_mat;
+          unitary_hess_mat = a.unitary_hess_mat;
+        }
       return *this;
     }
 
   ~HESS (void) { }
 
   Matrix hess_matrix (void) const { return hess_mat; }
 
   Matrix unitary_hess_matrix (void) const { return unitary_hess_mat; }
diff --git a/liboctave/dbleLU.h b/liboctave/dbleLU.h
--- a/liboctave/dbleLU.h
+++ b/liboctave/dbleLU.h
@@ -40,17 +40,17 @@ public:
   LU (const LU& a) : base_lu <Matrix> (a) { }
 
   LU (const Matrix& l, const Matrix& u, const PermMatrix& p)
     : base_lu <Matrix> (l, u, p) { }
 
   LU& operator = (const LU& a)
     {
       if (this != &a)
-	base_lu <Matrix> :: operator = (a);
+        base_lu <Matrix> :: operator = (a);
 
       return *this;
     }
 
   ~LU (void) { }
 
   void update (const ColumnVector& u, const ColumnVector& v);
 
diff --git a/liboctave/dbleQRP.h b/liboctave/dbleQRP.h
--- a/liboctave/dbleQRP.h
+++ b/liboctave/dbleQRP.h
@@ -40,20 +40,20 @@ public:
 
   QRP (const Matrix&, qr_type_t = qr_type_std);
 
   QRP (const QRP& a) : QR (a), p (a.p) { }
 
   QRP& operator = (const QRP& a)
     {
       if (this != &a)
-	{
-	  QR::operator = (a);
-	  p = a.p;
-	}
+        {
+          QR::operator = (a);
+          p = a.p;
+        }
 
       return *this;
     }
 
   ~QRP (void) { }
 
   void init (const Matrix&, qr_type_t = qr_type_std);
 
diff --git a/liboctave/dbleSCHUR.h b/liboctave/dbleSCHUR.h
--- a/liboctave/dbleSCHUR.h
+++ b/liboctave/dbleSCHUR.h
@@ -37,29 +37,29 @@ public:
 
   SCHUR (void)
     : schur_mat (), unitary_mat () { }
 
   SCHUR (const Matrix& a, const std::string& ord, bool calc_unitary = true)
     : schur_mat (), unitary_mat () { init (a, ord, calc_unitary); }
 
   SCHUR (const Matrix& a, const std::string& ord, int& info, 
-	 bool calc_unitary = true)
+         bool calc_unitary = true)
     : schur_mat (), unitary_mat () { info = init (a, ord, calc_unitary); }
 
   SCHUR (const SCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat) { }
 
   SCHUR& operator = (const SCHUR& a)
     {
       if (this != &a)
-	{
-	  schur_mat = a.schur_mat;
-	  unitary_mat = a.unitary_mat;
-	}
+        {
+          schur_mat = a.schur_mat;
+          unitary_mat = a.unitary_mat;
+        }
       return *this;
     }
 
   ~SCHUR (void) { }
 
   Matrix schur_matrix (void) const { return schur_mat; }
 
   Matrix unitary_matrix (void) const { return unitary_mat; }
diff --git a/liboctave/dbleSVD.h b/liboctave/dbleSVD.h
--- a/liboctave/dbleSVD.h
+++ b/liboctave/dbleSVD.h
@@ -53,22 +53,22 @@ public:
 
   SVD (const SVD& a)
     : type_computed (a.type_computed),
       sigma (a.sigma), left_sm (a.left_sm), right_sm (a.right_sm) { }
 
   SVD& operator = (const SVD& a)
     {
       if (this != &a)
-	{
-	  type_computed = a.type_computed;
-	  sigma = a.sigma;
-	  left_sm = a.left_sm;
-	  right_sm = a.right_sm;
-	}
+        {
+          type_computed = a.type_computed;
+          sigma = a.sigma;
+          left_sm = a.left_sm;
+          right_sm = a.right_sm;
+        }
 
       return *this;
     }
 
   ~SVD (void) { }
 
   DiagMatrix singular_values (void) const { return sigma; }
 
diff --git a/liboctave/dir-ops.h b/liboctave/dir-ops.h
--- a/liboctave/dir-ops.h
+++ b/liboctave/dir-ops.h
@@ -39,17 +39,17 @@ public:
         open ();
     }
 
   dir_entry (const dir_entry& d) { copy (d); }
 
   dir_entry& operator = (const dir_entry& d)
     {
       if (this != &d)
-	copy (d);
+        copy (d);
 
       return *this;
     }
 
   ~dir_entry (void) { close (); }
 
   bool open (const std::string& = std::string ());
 
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -88,36 +88,36 @@ public:
   // column vector by column vector -> column vector operations
 
   FloatComplexColumnVector& operator += (const FloatColumnVector& a);
   FloatComplexColumnVector& operator -= (const FloatColumnVector& a);
 
   // matrix by column vector -> column vector operations
 
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexMatrix& a,
-					 const FloatColumnVector& b);
+                                         const FloatColumnVector& b);
 
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexMatrix& a,
-					 const FloatComplexColumnVector& b);
+                                         const FloatComplexColumnVector& b);
 
   // matrix by column vector -> column vector operations
 
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatMatrix& a,
-					 const FloatComplexColumnVector& b);
+                                         const FloatComplexColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatDiagMatrix& a,
-					 const FloatComplexColumnVector& b);
+                                         const FloatComplexColumnVector& b);
 
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexDiagMatrix& a,
-					 const ColumnVector& b);
+                                         const ColumnVector& b);
 
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexDiagMatrix& a,
-					 const FloatComplexColumnVector& b);
+                                         const FloatComplexColumnVector& b);
 
   // other operations
 
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -151,32 +151,32 @@ public:
   // extract row or column i.
 
   FloatComplexRowVector row (octave_idx_type i) const;
 
   FloatComplexColumnVector column (octave_idx_type i) const;
 
 private:
   FloatComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
-			  float& rcon, int force, int calc_cond) const;
+                          float& rcon, int force, int calc_cond) const;
 
   FloatComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
-			  float& rcon, int force, int calc_cond) const;
+                          float& rcon, int force, int calc_cond) const;
 
 public:
   FloatComplexMatrix inverse (void) const;
   FloatComplexMatrix inverse (octave_idx_type& info) const;
   FloatComplexMatrix inverse (octave_idx_type& info, float& rcon, int force = 0, 
-			 int calc_cond = 1) const;
+                         int calc_cond = 1) const;
 
   FloatComplexMatrix inverse (MatrixType &mattype) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
-			 float& rcon, int force = 0, 
-			 int calc_cond = 1) const;
+                         float& rcon, int force = 0, 
+                         int calc_cond = 1) const;
 
   FloatComplexMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
@@ -188,139 +188,139 @@ public:
                                float& rcon, int calc_cond = 1) const;
 
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatComplexMatrix utsolve (MatrixType &typ, const FloatComplexMatrix& b,
-		  octave_idx_type& info, float& rcon, 
-		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  octave_idx_type& info, float& rcon, 
+                  solve_singularity_handler sing_handler,
+                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   FloatComplexMatrix ltsolve (MatrixType &typ, const FloatComplexMatrix& b,
-		  octave_idx_type& info, float& rcon, 
-		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  octave_idx_type& info, float& rcon, 
+                  solve_singularity_handler sing_handler,
+                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   FloatComplexMatrix fsolve (MatrixType &typ, const FloatComplexMatrix& b,
-		 octave_idx_type& info, float& rcon, 
-		 solve_singularity_handler sing_handler,
-		 bool calc_cond = false) const;
+                 octave_idx_type& info, float& rcon, 
+                 solve_singularity_handler sing_handler,
+                 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
-		       octave_idx_type& info, float& rcon) const;
+                       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		       float& rcon, solve_singularity_handler sing_handler,
-		       bool singular_fallback = true, 
+                       float& rcon, solve_singularity_handler sing_handler,
+                       bool singular_fallback = true, 
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcon) const;
+                       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true, 
+                       octave_idx_type& info, float& rcon,
+                       solve_singularity_handler sing_handler,
+                       bool singular_fallback = true, 
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-			     octave_idx_type& info, float& rcon) const;
+                             octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-			     octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler, 
+                             octave_idx_type& info, float& rcon,
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, 
-			     const FloatComplexColumnVector& b) const;
+                             const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcon) const;
+                             octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler, 
+                             octave_idx_type& info, float& rcon,
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatComplexMatrix solve (const FloatMatrix& b) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler, 
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler, 
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info,
-			     float& rcon) const;
+                             float& rcon) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcon) const;
+                             float& rcon) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcon,
-			     solve_singularity_handler sing_handler, 
+                             float& rcon,
+                             solve_singularity_handler sing_handler, 
                              blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix lssolve (const FloatMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
-			 octave_idx_type& rank) const;
+                         octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
-			 octave_idx_type& rank, float& rcon) const;
+                         octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank) const;
+                         octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, float& rcon) const;
+                         octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatColumnVector& b,
-			       octave_idx_type& info) const;
+                               octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank) const;
+                               octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank, float& rcon) const;
+                               octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-			       octave_idx_type& info) const;
+                               octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-			       octave_idx_type& info,
-			       octave_idx_type& rank) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-			       octave_idx_type& info,
-			       octave_idx_type& rank, float& rcon) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank, float& rcon) const;
 
   // matrix by diagonal matrix -> matrix operations
 
   FloatComplexMatrix& operator += (const FloatDiagMatrix& a);
   FloatComplexMatrix& operator -= (const FloatDiagMatrix& a);
 
   FloatComplexMatrix& operator += (const FloatComplexDiagMatrix& a);
   FloatComplexMatrix& operator -= (const FloatComplexDiagMatrix& a);
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -119,21 +119,21 @@ public:
   FloatComplexNDArray fourierNd (void) const;
   FloatComplexNDArray ifourierNd (void) const;
 
   FloatComplexMatrix matrix_value (void) const;
 
   FloatComplexNDArray squeeze (void) const { return MArrayN<FloatComplex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension = 0);
+                               const dim_vector& dimensions,
+                               int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions);
+                            const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexNDArray& a);
 
   static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
 
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -86,20 +86,20 @@ public:
   // row vector by row vector -> row vector operations
 
   FloatComplexRowVector& operator += (const FloatRowVector& a);
   FloatComplexRowVector& operator -= (const FloatRowVector& a);
 
   // row vector by matrix -> row vector
 
   friend FloatComplexRowVector operator * (const FloatComplexRowVector& a,
-				      const FloatComplexMatrix& b);
+                                      const FloatComplexMatrix& b);
 
   friend FloatComplexRowVector operator * (const FloatRowVector& a,
-				      const FloatComplexMatrix& b);
+                                      const FloatComplexMatrix& b);
 
   // other operations
 
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
diff --git a/liboctave/fCmplxCHOL.h b/liboctave/fCmplxCHOL.h
--- a/liboctave/fCmplxCHOL.h
+++ b/liboctave/fCmplxCHOL.h
@@ -46,20 +46,20 @@ public:
     }
 
   FloatComplexCHOL (const FloatComplexCHOL& a)
     : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   FloatComplexCHOL& operator = (const FloatComplexCHOL& a)
     {
       if (this != &a)
-	{
-	  chol_mat = a.chol_mat;
-	  xrcond = a.xrcond;
-	}
+        {
+          chol_mat = a.chol_mat;
+          xrcond = a.xrcond;
+        }
 
       return *this;
     }
 
   FloatComplexMatrix chol_matrix (void) const { return chol_mat; }
 
   float rcond (void) const { return xrcond; }
 
diff --git a/liboctave/fCmplxGEPBAL.h b/liboctave/fCmplxGEPBAL.h
--- a/liboctave/fCmplxGEPBAL.h
+++ b/liboctave/fCmplxGEPBAL.h
@@ -45,22 +45,22 @@ public:
 
   FloatComplexGEPBALANCE (const FloatComplexGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
     balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   FloatComplexGEPBALANCE& operator = (const FloatComplexGEPBALANCE& a)
     {
       if (this != &a)
-	{
-	  balanced_mat = a.balanced_mat;
-	  balanced_mat2 = a.balanced_mat2;
-	  balancing_mat = a.balancing_mat;
-	  balancing_mat2 = a.balancing_mat2;
-	}
+        {
+          balanced_mat = a.balanced_mat;
+          balanced_mat2 = a.balanced_mat2;
+          balancing_mat = a.balancing_mat;
+          balancing_mat2 = a.balancing_mat2;
+        }
       return *this;
     }
 
   ~FloatComplexGEPBALANCE (void) { }
 
   FloatComplexMatrix balanced_matrix (void) const { return balanced_mat; }
 
   FloatComplexMatrix balanced_matrix2 (void) const { return balanced_mat2; }
@@ -74,12 +74,12 @@ public:
 private:
 
   FloatComplexMatrix balanced_mat;
   FloatComplexMatrix balanced_mat2;
   FloatMatrix balancing_mat;
   FloatMatrix balancing_mat2;
 
   octave_idx_type init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, 
-			const std::string& balance_job);
+                        const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/fCmplxHESS.h b/liboctave/fCmplxHESS.h
--- a/liboctave/fCmplxHESS.h
+++ b/liboctave/fCmplxHESS.h
@@ -41,20 +41,20 @@ public:
   FloatComplexHESS (const FloatComplexMatrix& a, octave_idx_type& info) { info = init (a); }
 
   FloatComplexHESS (const FloatComplexHESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   FloatComplexHESS& operator = (const FloatComplexHESS& a)
     {
       if (this != &a)
-	{
-	  hess_mat = a.hess_mat;
-	  unitary_hess_mat = a.unitary_hess_mat;
-	}
+        {
+          hess_mat = a.hess_mat;
+          unitary_hess_mat = a.unitary_hess_mat;
+        }
       return *this;
     }
 
   ~FloatComplexHESS (void) { }
 
   FloatComplexMatrix hess_matrix (void) const { return hess_mat; }
 
   FloatComplexMatrix unitary_hess_matrix (void) const
diff --git a/liboctave/fCmplxLU.h b/liboctave/fCmplxLU.h
--- a/liboctave/fCmplxLU.h
+++ b/liboctave/fCmplxLU.h
@@ -44,17 +44,17 @@ public:
 
   FloatComplexLU (const FloatComplexMatrix& l, const FloatComplexMatrix& u, 
                   const PermMatrix& p)
     : base_lu <FloatComplexMatrix> (l, u, p) { }
 
   FloatComplexLU& operator = (const FloatComplexLU& a)
     {
       if (this != &a)
-	base_lu <FloatComplexMatrix> :: operator = (a);
+        base_lu <FloatComplexMatrix> :: operator = (a);
 
       return *this;
     }
 
   ~FloatComplexLU (void) { }
 
   void update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v);
 
diff --git a/liboctave/fCmplxQRP.h b/liboctave/fCmplxQRP.h
--- a/liboctave/fCmplxQRP.h
+++ b/liboctave/fCmplxQRP.h
@@ -40,20 +40,20 @@ public:
 
   FloatComplexQRP (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   FloatComplexQRP (const FloatComplexQRP& a) : FloatComplexQR (a), p (a.p) { }
 
   FloatComplexQRP& operator = (const FloatComplexQRP& a)
     {
       if (this != &a)
-	{
-	  FloatComplexQR::operator = (a);
-	  p = a.p;
-	}
+        {
+          FloatComplexQR::operator = (a);
+          p = a.p;
+        }
       return *this;
     }
 
   ~FloatComplexQRP (void) { }
 
   void init (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
diff --git a/liboctave/fCmplxSCHUR.h b/liboctave/fCmplxSCHUR.h
--- a/liboctave/fCmplxSCHUR.h
+++ b/liboctave/fCmplxSCHUR.h
@@ -34,33 +34,33 @@ OCTAVE_API
 FloatComplexSCHUR
 {
 public:
 
   FloatComplexSCHUR (void)
     : schur_mat (), unitary_mat () { }
 
   FloatComplexSCHUR (const FloatComplexMatrix& a, const std::string& ord,
-		bool calc_unitary = true)
+                bool calc_unitary = true)
     : schur_mat (), unitary_mat () { init (a, ord, calc_unitary); }
 
   FloatComplexSCHUR (const FloatComplexMatrix& a, const std::string& ord, octave_idx_type& info,
-		bool calc_unitary = true)
+                bool calc_unitary = true)
     : schur_mat (), unitary_mat () { info = init (a, ord, calc_unitary); }
 
   FloatComplexSCHUR (const FloatComplexSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat) { }
 
   FloatComplexSCHUR& operator = (const FloatComplexSCHUR& a)
     {
       if (this != &a)
-	{
-	  schur_mat = a.schur_mat;
-	  unitary_mat = a.unitary_mat;
-	}
+        {
+          schur_mat = a.schur_mat;
+          unitary_mat = a.unitary_mat;
+        }
       return *this;
     }
 
   ~FloatComplexSCHUR (void) { }
 
   FloatComplexMatrix schur_matrix (void) const { return schur_mat; }
 
   FloatComplexMatrix unitary_matrix (void) const { return unitary_mat; }
diff --git a/liboctave/fCmplxSVD.h b/liboctave/fCmplxSVD.h
--- a/liboctave/fCmplxSVD.h
+++ b/liboctave/fCmplxSVD.h
@@ -39,34 +39,34 @@ public:
   FloatComplexSVD (void) { }
 
   FloatComplexSVD (const FloatComplexMatrix& a, SVD::type svd_type = SVD::std)
     {
       init (a, svd_type);
     }
 
   FloatComplexSVD (const FloatComplexMatrix& a, octave_idx_type& info,
-	      SVD::type svd_type = SVD::std)
+              SVD::type svd_type = SVD::std)
     {
       info = init (a, svd_type);
     }
 
   FloatComplexSVD (const FloatComplexSVD& a)
     : type_computed (a.type_computed),
       sigma (a.sigma), left_sm (a.left_sm), right_sm (a.right_sm) { }
 
   FloatComplexSVD& operator = (const FloatComplexSVD& a)
     {
       if (this != &a)
-	{
-	  type_computed = a.type_computed;
-	  sigma = a.sigma;
-	  left_sm = a.left_sm;
-	  right_sm = a.right_sm;
-	}
+        {
+          type_computed = a.type_computed;
+          sigma = a.sigma;
+          left_sm = a.left_sm;
+          right_sm = a.right_sm;
+        }
       return *this;
     }
 
   ~FloatComplexSVD (void) { }
 
   FloatDiagMatrix singular_values (void) const { return sigma; }
 
   FloatComplexMatrix left_singular_matrix (void) const;
diff --git a/liboctave/fEIG.h b/liboctave/fEIG.h
--- a/liboctave/fEIG.h
+++ b/liboctave/fEIG.h
@@ -67,20 +67,20 @@ public:
     { info = init (a, b, calc_eigenvectors); }
 
   FloatEIG (const FloatEIG& a)
     : lambda (a.lambda), v (a.v) { }
 
   FloatEIG& operator = (const FloatEIG& a)
     {
       if (this != &a)
-	{
-	  lambda = a.lambda;
-	  v = a.v;
-	}
+        {
+          lambda = a.lambda;
+          v = a.v;
+        }
       return *this;
     }
 
   ~FloatEIG (void) { }
 
   FloatComplexColumnVector eigenvalues (void) const { return lambda; }
 
   FloatComplexMatrix eigenvectors (void) const { return v; }
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -124,31 +124,31 @@ public:
   // extract row or column i.
 
   FloatRowVector row (octave_idx_type i) const;
 
   FloatColumnVector column (octave_idx_type i) const;
 
 private:
   FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
-		   int force, int calc_cond) const;
+                   int force, int calc_cond) const;
 
   FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
-		   int force, int calc_cond) const;
+                   int force, int calc_cond) const;
 
 public:
   FloatMatrix inverse (void) const;
   FloatMatrix inverse (octave_idx_type& info) const;
   FloatMatrix inverse (octave_idx_type& info, float& rcon, int force = 0,
-		  int calc_cond = 1) const;
+                  int calc_cond = 1) const;
 
   FloatMatrix inverse (MatrixType &mattype) const;
   FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
-		  int force = 0, int calc_cond = 1) const;
+                  int force = 0, int calc_cond = 1) const;
 
   FloatMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
@@ -160,69 +160,69 @@ public:
                         float& rcon, int calc_cond = 1) const;
 
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatMatrix utsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		  float& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  float& rcon, solve_singularity_handler sing_handler,
+                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   FloatMatrix ltsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		  float& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  float& rcon, solve_singularity_handler sing_handler,
+                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
   FloatMatrix fsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		 float& rcon, solve_singularity_handler sing_handler,
-		 bool calc_cond = false) const;
+                 float& rcon, solve_singularity_handler sing_handler,
+                 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
-		float& rcon) const;
+                float& rcon) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		float& rcon, solve_singularity_handler sing_handler,
-		bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
+                float& rcon, solve_singularity_handler sing_handler,
+                bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info) const;
+                       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcon) const;
+                       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true, 
+                       octave_idx_type& info, float& rcon,
+                       solve_singularity_handler sing_handler,
+                       bool singular_fallback = true, 
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info) const;
+                      octave_idx_type& info) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcon) const;
+                      octave_idx_type& info, float& rcon) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler, 
+                      octave_idx_type& info, float& rcon,
+                      solve_singularity_handler sing_handler, 
                       blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, 
-			     const FloatComplexColumnVector& b) const;
+                             const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info) const;
+                             octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcon) const;
+                             octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler, blas_trans_type transt = blas_no_trans) const;
+                             octave_idx_type& info, float& rcon,
+                             solve_singularity_handler sing_handler, blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatMatrix solve (const FloatMatrix& b) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
                      solve_singularity_handler sing_handler, 
                      blas_trans_type transt = blas_no_trans) const;
@@ -248,43 +248,43 @@ public:
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
                                   float& rcon, solve_singularity_handler sing_handler, 
                                   blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   FloatMatrix lssolve (const FloatMatrix& b) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
-		  octave_idx_type& rank) const;
+                  octave_idx_type& rank) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
-		  octave_idx_type& rank, float& rcon) const;
+                  octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank) const;
+                         octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, float &rcon) const;
+                         octave_idx_type& rank, float &rcon) const;
 
   FloatColumnVector lssolve (const FloatColumnVector& b) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank) const;
+                        octave_idx_type& rank) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, float& rcon) const;
+                        octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b, 
-			       octave_idx_type& info) const;
+                               octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-			       octave_idx_type& info,
-			       octave_idx_type& rank) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b, 
-			       octave_idx_type& info,
-			       octave_idx_type& rank, float& rcon) const;
+                               octave_idx_type& info,
+                               octave_idx_type& rank, float& rcon) const;
 
   FloatMatrix& operator += (const FloatDiagMatrix& a);
   FloatMatrix& operator -= (const FloatDiagMatrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -131,21 +131,21 @@ public:
 
   friend class FloatComplexNDArray;
 
   FloatMatrix matrix_value (void) const;
 
   FloatNDArray squeeze (void) const { return MArrayN<float>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension = 0);
+                               const dim_vector& dimensions,
+                               int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions);
+                            const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatNDArray& a);
 
   static float resize_fill_value (void) { return 0; }
 
diff --git a/liboctave/file-stat.h b/liboctave/file-stat.h
--- a/liboctave/file-stat.h
+++ b/liboctave/file-stat.h
@@ -49,32 +49,32 @@ public:
       fs_size (fs.fs_size), fs_atime (fs.fs_atime), fs_mtime (fs.fs_mtime),
       fs_ctime (fs.fs_ctime), fs_rdev (fs.fs_rdev),
       fs_blksize (fs.fs_blksize), fs_blocks (fs.fs_blocks) { }
 
   base_file_stat& operator = (const base_file_stat& fs)
   {
     if (this != &fs)
       {
-	initialized = fs.initialized;
-	fail = fs.fail;
-	errmsg = fs.errmsg;
-	fs_mode = fs.fs_mode;
-	fs_ino = fs.fs_ino;
-	fs_dev = fs.fs_dev;
-	fs_nlink = fs.fs_nlink;
-	fs_uid = fs.fs_uid;
-	fs_gid = fs.fs_gid;
-	fs_size = fs.fs_size;
-	fs_atime = fs.fs_atime;
-	fs_mtime = fs.fs_mtime;
-	fs_ctime = fs.fs_ctime;
-	fs_rdev = fs.fs_rdev;
-	fs_blksize = fs.fs_blksize;
-	fs_blocks = fs.fs_blocks;
+        initialized = fs.initialized;
+        fail = fs.fail;
+        errmsg = fs.errmsg;
+        fs_mode = fs.fs_mode;
+        fs_ino = fs.fs_ino;
+        fs_dev = fs.fs_dev;
+        fs_nlink = fs.fs_nlink;
+        fs_uid = fs.fs_uid;
+        fs_gid = fs.fs_gid;
+        fs_size = fs.fs_size;
+        fs_atime = fs.fs_atime;
+        fs_mtime = fs.fs_mtime;
+        fs_ctime = fs.fs_ctime;
+        fs_rdev = fs.fs_rdev;
+        fs_blksize = fs.fs_blksize;
+        fs_blocks = fs.fs_blocks;
       }
 
     return *this;
   }
 
   ~base_file_stat (void) { }
 
   // The minimum difference in file time stamp values.
@@ -212,20 +212,20 @@ public:
   file_stat (const file_stat& fs)
     : base_file_stat (fs), file_name (fs.file_name),
       follow_links (fs.follow_links) { }
 
   file_stat& operator = (const file_stat& fs)
   {
     if (this != &fs)
       {
-	base_file_stat::operator = (fs);
+        base_file_stat::operator = (fs);
 
-	file_name = fs.file_name;
-	follow_links = fs.follow_links;
+        file_name = fs.file_name;
+        follow_links = fs.follow_links;
       }
 
     return *this;
   }
 
   ~file_stat (void) { }
 
   void get_stats (bool force = false)
@@ -233,21 +233,21 @@ public:
     if (! initialized || force)
       update_internal (force);
   }
 
   void get_stats (const std::string& n, bool force = false)
   {
     if (n != file_name || ! initialized  || force)
       {
-	initialized = false;
+        initialized = false;
 
-	file_name = n;
+        file_name = n;
 
-	update_internal (force);
+        update_internal (force);
       }
   }
 
 private:
 
   // Name of the file.
   std::string file_name;
 
@@ -271,19 +271,19 @@ public:
 
   file_fstat (const file_fstat& fs)
     : base_file_stat (fs), fid (fs.fid) { }
 
   file_fstat& operator = (const file_fstat& fs)
   {
     if (this != &fs)
       {
-	base_file_stat::operator = (fs);
+        base_file_stat::operator = (fs);
 
-	fid = fs.fid;
+        fid = fs.fid;
       }
 
     return *this;
   }
 
   ~file_fstat (void) { }
 
   void get_stats (bool force = false)
@@ -291,21 +291,21 @@ public:
     if (! initialized || force)
       update_internal (force);
   }
 
   void get_stats (int n, bool force = false)
   {
     if (n != fid || ! initialized  || force)
       {
-	initialized = false;
+        initialized = false;
 
-	fid = n;
+        fid = n;
 
-	update_internal (force);
+        update_internal (force);
       }
   }
 
 private:
 
   // Open file descriptor.
   int fid;
 
diff --git a/liboctave/floatCHOL.h b/liboctave/floatCHOL.h
--- a/liboctave/floatCHOL.h
+++ b/liboctave/floatCHOL.h
@@ -43,20 +43,20 @@ public:
   FloatCHOL (const FloatMatrix& a, octave_idx_type& info, bool calc_cond = false) 
     { info = init (a, calc_cond); }
 
   FloatCHOL (const FloatCHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   FloatCHOL& operator = (const FloatCHOL& a)
     {
       if (this != &a)
-	{
-	  chol_mat = a.chol_mat;
-	  xrcond = a.xrcond;
-	}
+        {
+          chol_mat = a.chol_mat;
+          xrcond = a.xrcond;
+        }
       return *this;
     }
 
   FloatMatrix chol_matrix (void) const { return chol_mat; }
 
   float rcond (void) const { return xrcond; }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
diff --git a/liboctave/floatGEPBAL.h b/liboctave/floatGEPBAL.h
--- a/liboctave/floatGEPBAL.h
+++ b/liboctave/floatGEPBAL.h
@@ -44,22 +44,22 @@ public:
 
   FloatGEPBALANCE (const FloatGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
     balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   FloatGEPBALANCE& operator = (const FloatGEPBALANCE& a)
     {
       if (this != &a)
-	{
-	  balanced_mat = a.balanced_mat;
-	  balanced_mat2 = a.balanced_mat2;
-	  balancing_mat = a.balancing_mat;
-	  balancing_mat2 = a.balancing_mat2;
-	}
+        {
+          balanced_mat = a.balanced_mat;
+          balanced_mat2 = a.balanced_mat2;
+          balancing_mat = a.balancing_mat;
+          balancing_mat2 = a.balancing_mat2;
+        }
       return *this;
     }
 
   ~FloatGEPBALANCE (void) { }
 
   FloatMatrix balanced_matrix (void) const { return balanced_mat; }
 
   FloatMatrix balanced_matrix2 (void) const { return balanced_mat2; }
@@ -73,12 +73,12 @@ public:
 private:
 
   FloatMatrix balanced_mat;
   FloatMatrix balanced_mat2;
   FloatMatrix balancing_mat;
   FloatMatrix balancing_mat2;
 
   octave_idx_type init (const FloatMatrix& a, const FloatMatrix& b, 
-			const std::string& balance_job);
+                        const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/floatHESS.h b/liboctave/floatHESS.h
--- a/liboctave/floatHESS.h
+++ b/liboctave/floatHESS.h
@@ -41,20 +41,20 @@ public:
   FloatHESS (const FloatMatrix& a, octave_idx_type& info) { info = init (a); }
 
   FloatHESS (const FloatHESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   FloatHESS& operator = (const FloatHESS& a)
     {
       if (this != &a)
-	{
-	  hess_mat = a.hess_mat;
-	  unitary_hess_mat = a.unitary_hess_mat;
-	}
+        {
+          hess_mat = a.hess_mat;
+          unitary_hess_mat = a.unitary_hess_mat;
+        }
       return *this;
     }
 
   ~FloatHESS (void) { }
 
   FloatMatrix hess_matrix (void) const { return hess_mat; }
 
   FloatMatrix unitary_hess_matrix (void) const { return unitary_hess_mat; }
diff --git a/liboctave/floatLU.h b/liboctave/floatLU.h
--- a/liboctave/floatLU.h
+++ b/liboctave/floatLU.h
@@ -42,17 +42,17 @@ public:
 
   FloatLU (const FloatMatrix& l, const FloatMatrix& u, 
            const PermMatrix& p)
     : base_lu <FloatMatrix> (l, u, p) { }
 
   FloatLU& operator = (const FloatLU& a)
     {
       if (this != &a)
-	base_lu <FloatMatrix> :: operator = (a);
+        base_lu <FloatMatrix> :: operator = (a);
 
       return *this;
     }
 
   ~FloatLU (void) { }
 
   void update (const FloatColumnVector& u, const FloatColumnVector& v);
 
diff --git a/liboctave/floatQRP.h b/liboctave/floatQRP.h
--- a/liboctave/floatQRP.h
+++ b/liboctave/floatQRP.h
@@ -40,20 +40,20 @@ public:
 
   FloatQRP (const FloatMatrix&, qr_type_t = qr_type_std);
 
   FloatQRP (const FloatQRP& a) : FloatQR (a), p (a.p) { }
 
   FloatQRP& operator = (const FloatQRP& a)
     {
       if (this != &a)
-	{
-	  FloatQR::operator = (a);
-	  p = a.p;
-	}
+        {
+          FloatQR::operator = (a);
+          p = a.p;
+        }
 
       return *this;
     }
 
   ~FloatQRP (void) { }
 
   void init (const FloatMatrix&, qr_type_t = qr_type_std);
 
diff --git a/liboctave/floatSCHUR.h b/liboctave/floatSCHUR.h
--- a/liboctave/floatSCHUR.h
+++ b/liboctave/floatSCHUR.h
@@ -37,29 +37,29 @@ public:
 
   FloatSCHUR (void)
     : schur_mat (), unitary_mat () { }
 
   FloatSCHUR (const FloatMatrix& a, const std::string& ord, bool calc_unitary = true)
     : schur_mat (), unitary_mat () { init (a, ord, calc_unitary); }
 
   FloatSCHUR (const FloatMatrix& a, const std::string& ord, int& info, 
-	 bool calc_unitary = true)
+         bool calc_unitary = true)
     : schur_mat (), unitary_mat () { info = init (a, ord, calc_unitary); }
 
   FloatSCHUR (const FloatSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat) { }
 
   FloatSCHUR& operator = (const FloatSCHUR& a)
     {
       if (this != &a)
-	{
-	  schur_mat = a.schur_mat;
-	  unitary_mat = a.unitary_mat;
-	}
+        {
+          schur_mat = a.schur_mat;
+          unitary_mat = a.unitary_mat;
+        }
       return *this;
     }
 
   ~FloatSCHUR (void) { }
 
   FloatMatrix schur_matrix (void) const { return schur_mat; }
 
   FloatMatrix unitary_matrix (void) const { return unitary_mat; }
diff --git a/liboctave/floatSVD.h b/liboctave/floatSVD.h
--- a/liboctave/floatSVD.h
+++ b/liboctave/floatSVD.h
@@ -47,22 +47,22 @@ public:
 
   FloatSVD (const FloatSVD& a)
     : type_computed (a.type_computed),
       sigma (a.sigma), left_sm (a.left_sm), right_sm (a.right_sm) { }
 
   FloatSVD& operator = (const FloatSVD& a)
     {
       if (this != &a)
-	{
-	  type_computed = a.type_computed;
-	  sigma = a.sigma;
-	  left_sm = a.left_sm;
-	  right_sm = a.right_sm;
-	}
+        {
+          type_computed = a.type_computed;
+          sigma = a.sigma;
+          left_sm = a.left_sm;
+          right_sm = a.right_sm;
+        }
 
       return *this;
     }
 
   ~FloatSVD (void) { }
 
   FloatDiagMatrix singular_values (void) const { return sigma; }
 
diff --git a/liboctave/glob-match.h b/liboctave/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/glob-match.h
@@ -37,21 +37,21 @@ public:
   enum opts
   {
     pathname = 1,  // No wildcard can ever match `/'.
     noescape = 2,  // Backslashes don't quote special chars.
     period = 4     // Leading `.' is matched only explicitly.
   };
 
   glob_match (const std::string& p,
-	      unsigned int xopts = pathname|noescape|period)
+              unsigned int xopts = pathname|noescape|period)
     : pat (p), fnmatch_flags (opts_to_fnmatch_flags (xopts)) { }
 
   glob_match (const string_vector& p = string_vector (),
-	      unsigned int xopts = pathname|noescape|period)
+              unsigned int xopts = pathname|noescape|period)
     : pat (p), fnmatch_flags (opts_to_fnmatch_flags (xopts)) { }
 
   glob_match (const glob_match& gm)
     : pat (gm.pat), fnmatch_flags (gm.fnmatch_flags) { }
 
   glob_match& operator = (const glob_match& gm)
   {
     if (this != &gm)
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -518,29 +518,29 @@ public:
   idx_vector (const Sparse<bool>& nda) : rep (new idx_vector_rep (nda))
     { chkerr (); }
 
   idx_vector (const idx_vector& a) : rep (a.rep) { rep->count++; }
 
   ~idx_vector (void)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
   idx_vector& operator = (const idx_vector& a)
     {
       if (this != &a)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
+        {
+          if (--rep->count == 0)
+            delete rep;
 
-	  rep = a.rep;
-	  rep->count++;
-	}
+          rep = a.rep;
+          rep->count++;
+        }
       return *this;
     }
 
   idx_class_type idx_class (void) const { return rep->idx_class (); }
 
   octave_idx_type length (octave_idx_type n = 0) const 
     { return rep->length (n); }
 
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -103,21 +103,21 @@ public:
     { return intNDArray<T> (MArrayN<T>::transpose ()); }
 
   intNDArray concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx);
 
   intNDArray& insert (const intNDArray<T>& a, octave_idx_type r, octave_idx_type c);
   intNDArray& insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx);
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
-			       const dim_vector& dimensions,
-			       int start_dimension = 0);
+                               const dim_vector& dimensions,
+                               int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-			    const dim_vector& dimensions);
+                            const dim_vector& dimensions);
 
   static T resize_fill_value (void) { return 0; }
 
 protected:
 
   intNDArray (T *d, dim_vector& dv) : MArrayN<T> (d, dv) { }
 };
 
diff --git a/liboctave/lo-ieee.h b/liboctave/lo-ieee.h
--- a/liboctave/lo-ieee.h
+++ b/liboctave/lo-ieee.h
@@ -19,17 +19,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_liboctave_ieee_h)
 #define octave_liboctave_ieee_h 1
 
-#ifdef	__cplusplus
+#ifdef  __cplusplus
 extern "C" {
 #endif
 
 /*  Octave's idea of infinity.  */
 extern OCTAVE_API double octave_Inf;
 
 /* Octave's idea of a missing value.  */
 extern OCTAVE_API double octave_NA;
@@ -106,28 +106,28 @@ extern OCTAVE_API int __lo_ieee_float_is
 extern OCTAVE_API int __lo_ieee_float_is_NaN_or_NA (float) GCC_ATTR_DEPRECATED;
 
 extern OCTAVE_API float lo_ieee_float_inf_value (void);
 extern OCTAVE_API float lo_ieee_float_na_value (void);
 extern OCTAVE_API float lo_ieee_float_nan_value (void);
 
 extern OCTAVE_API int __lo_ieee_float_signbit (float);
 
-#ifdef	__cplusplus
+#ifdef  __cplusplus
 }
 #endif
 
 #define lo_ieee_isnan(x) (sizeof (x) == sizeof (float) ? \
-			 __lo_ieee_float_isnan (x) : __lo_ieee_isnan (x))
+                         __lo_ieee_float_isnan (x) : __lo_ieee_isnan (x))
 #define lo_ieee_finite(x) (sizeof (x) == sizeof (float) ? \
-			   __lo_ieee_float_finite (x) : __lo_ieee_finite (x))
+                           __lo_ieee_float_finite (x) : __lo_ieee_finite (x))
 #define lo_ieee_isinf(x) (sizeof (x) == sizeof (float) ? \
-			  __lo_ieee_float_isinf (x) : __lo_ieee_isinf (x))
+                          __lo_ieee_float_isinf (x) : __lo_ieee_isinf (x))
 
 
 #define lo_ieee_is_NA(x) (sizeof (x) == sizeof (float) ? \
-			  __lo_ieee_float_is_NA (x) : __lo_ieee_is_NA (x))
+                          __lo_ieee_float_is_NA (x) : __lo_ieee_is_NA (x))
 #define lo_ieee_is_NaN_or_NA(x) (sizeof (x) == sizeof (float) ? \
-			  __lo_ieee_float_is_NaN_or_NA (x) : __lo_ieee_is_NaN_or_NA (x))
+                          __lo_ieee_float_is_NaN_or_NA (x) : __lo_ieee_is_NaN_or_NA (x))
 #define lo_ieee_signbit(x) (sizeof (x) == sizeof (float) ? \
-			  __lo_ieee_float_signbit (x) : __lo_ieee_signbit (x))
+                          __lo_ieee_float_signbit (x) : __lo_ieee_signbit (x))
 
 #endif
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -125,181 +125,181 @@ besselk (double alpha, const Complex& x,
 extern OCTAVE_API Complex
 besselh1 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API Complex
 besselh2 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (double alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (double alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (double alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (const Matrix& alpha, const Complex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (const Matrix& alpha, const Complex& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const Matrix& alpha, const Complex& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselj (double alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 bessely (double alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besseli (double alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselk (double alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh1 (double alpha, const ComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh2 (double alpha, const ComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselj (const NDArray& alpha, const Complex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 bessely (const NDArray& alpha, const Complex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besseli (const NDArray& alpha, const Complex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselk (const NDArray& alpha, const Complex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh1 (const NDArray& alpha, const Complex& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh2 (const NDArray& alpha, const Complex& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplex
 besselj (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
 bessely (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
@@ -311,181 +311,181 @@ besselk (float alpha, const FloatComplex
 extern OCTAVE_API FloatComplex
 besselh1 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
 besselh2 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (float alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (float alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (float alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (float alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (float alpha, const FloatComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (float alpha, const FloatComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselj (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 bessely (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besseli (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselk (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh1 (float alpha, const FloatComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (float alpha, const FloatComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselj (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 bessely (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besseli (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselk (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh1 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselj (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 bessely (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besseli (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselk (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 Array<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	  Array<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-	 Array2<octave_idx_type>& ierr);
+         Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-	  Array2<octave_idx_type>& ierr);
+          Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API Complex airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 extern OCTAVE_API Complex biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API ComplexMatrix
 airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
diff --git a/liboctave/mx-op-decl.h b/liboctave/mx-op-decl.h
--- a/liboctave/mx-op-decl.h
+++ b/liboctave/mx-op-decl.h
@@ -282,21 +282,21 @@ class boolNDArray;
   DMDM_BIN_OP_DECLS (R, DM1, DM2, API)
 
 // scalar by N-d array min/max ops
 
 #define MINMAX_DECLS(T) \
   extern OCTAVE_API T ## NDArray min (octave_ ## T d, const T ## NDArray& m); \
   extern OCTAVE_API T ## NDArray min (const T ## NDArray& m, octave_ ## T d); \
   extern OCTAVE_API T ## NDArray min (const T ## NDArray& a,  \
-				       const T ## NDArray& b); \
+                                       const T ## NDArray& b); \
   extern OCTAVE_API T ## NDArray max (octave_ ## T d, const T ## NDArray& m); \
   extern OCTAVE_API T ## NDArray max (const T ## NDArray& m, octave_ ## T d); \
   extern OCTAVE_API T ## NDArray max (const T ## NDArray& a, \
-				       const T ## NDArray& b);
+                                       const T ## NDArray& b);
 
 // permutation matrix by matrix ops and vice versa
 
 #define PMM_BIN_OP_DECLS(R, PM, M, API) \
   BIN_OP_DECL (R, operator *, PM, M, API);
 
 #define MPM_BIN_OP_DECLS(R, M, PM, API) \
   BIN_OP_DECL (R, operator *, M, PM, API);
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -383,24 +383,24 @@ OP (const M& m, const DM& dm) \
  \
   if (m_nr != dm_nr || m_nc != dm_nc) \
     gripe_nonconformant (#OP, m_nr, m_nc, dm_nr, dm_nc); \
   else \
     { \
       r.resize (m_nr, m_nc); \
  \
       if (m_nr > 0 && m_nc > 0) \
-	{ \
-	  r = R (m); \
+        { \
+          r = R (m); \
  \
-	  octave_idx_type len = dm.length (); \
+          octave_idx_type len = dm.length (); \
  \
-	  for (octave_idx_type i = 0; i < len; i++) \
-	    r.elem(i, i) OPEQ dm.elem(i, i); \
-	} \
+          for (octave_idx_type i = 0; i < len; i++) \
+            r.elem(i, i) OPEQ dm.elem(i, i); \
+        } \
     } \
  \
   return r; \
 }
 
 #define MDM_MULTIPLY_OP(R, M, DM, R_ZERO) \
 R \
 operator * (const M& m, const DM& dm) \
@@ -453,26 +453,26 @@ OP (const DM& dm, const M& m) \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   if (dm_nr != m_nr || dm_nc != m_nc) \
     gripe_nonconformant (#OP, dm_nr, dm_nc, m_nr, m_nc); \
   else \
     { \
       if (m_nr > 0 && m_nc > 0) \
-	{ \
-	  r = R (PREOP m); \
+        { \
+          r = R (PREOP m); \
  \
-	  octave_idx_type len = dm.length (); \
+          octave_idx_type len = dm.length (); \
  \
-	  for (octave_idx_type i = 0; i < len; i++) \
-	    r.elem(i, i) OPEQ dm.elem(i, i); \
-	} \
+          for (octave_idx_type i = 0; i < len; i++) \
+            r.elem(i, i) OPEQ dm.elem(i, i); \
+        } \
       else \
-	r.resize (m_nr, m_nc); \
+        r.resize (m_nr, m_nc); \
     } \
  \
   return r; \
 }
 
 #define DMM_MULTIPLY_OP(R, DM, M, R_ZERO) \
 R \
 operator * (const DM& dm, const M& m) \
@@ -525,20 +525,20 @@ operator * (const DM& dm, const M& m) \
  \
     octave_idx_type dm2_nr = dm2.rows (); \
     octave_idx_type dm2_nc = dm2.cols (); \
  \
     if (dm1_nr != dm2_nr || dm1_nc != dm2_nc) \
       gripe_nonconformant (#OP, dm1_nr, dm1_nc, dm2_nr, dm2_nc); \
     else \
       { \
-	r.resize (dm1_nr, dm1_nc); \
+        r.resize (dm1_nr, dm1_nc); \
  \
-	if (dm1_nr > 0 && dm1_nc > 0) \
-	  F (dm1.length (), r.fortran_vec (), dm1.data (), dm2.data ()); \
+        if (dm1_nr > 0 && dm1_nc > 0) \
+          F (dm1.length (), r.fortran_vec (), dm1.data (), dm2.data ()); \
       } \
  \
     return r; \
   }
 
 #define DMDM_BIN_OPS(R, DM1, DM2) \
   DMDM_BIN_OP (R, operator +, DM1, DM2, mx_inline_add) \
   DMDM_BIN_OP (R, operator -, DM1, DM2, mx_inline_sub) \
diff --git a/liboctave/oct-env.h b/liboctave/oct-env.h
--- a/liboctave/oct-env.h
+++ b/liboctave/oct-env.h
@@ -77,17 +77,17 @@ private:
 
   bool do_absolute_pathname (const std::string& s) const;
 
   bool do_rooted_relative_pathname (const std::string& s) const;
 
   std::string do_base_pathname (const std::string& s) const;
 
   std::string do_make_absolute (const std::string& s,
-				const std::string& dot_path) const;
+                                const std::string& dot_path) const;
 
   std::string do_getcwd (void) const;
 
   std::string do_get_home_directory (void) const;
 
   std::string do_get_user_name (void) const;
 
   std::string do_get_host_name (void) const;
diff --git a/liboctave/oct-fftw.h b/liboctave/oct-fftw.h
--- a/liboctave/oct-fftw.h
+++ b/liboctave/oct-fftw.h
@@ -55,32 +55,32 @@ public:
     EXHAUSTIVE,
     HYBRID
   };
 
   static bool instance_ok (void);
 
   static fftw_plan
   create_plan (int dir, const int rank, const dim_vector dims, 
-	       octave_idx_type howmany, octave_idx_type stride,
-	       octave_idx_type dist, const Complex *in,
-	       Complex *out)
+               octave_idx_type howmany, octave_idx_type stride,
+               octave_idx_type dist, const Complex *in,
+               Complex *out)
   {
     static fftw_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (dir, rank, dims, howmany, stride,
-				  dist, in, out)
+                                  dist, in, out)
       : dummy;
   }
 
   static fftw_plan
   create_plan (const int rank, const dim_vector dims, 
-	       octave_idx_type howmany, octave_idx_type stride,
-	       octave_idx_type dist, const double *in, Complex *out)
+               octave_idx_type howmany, octave_idx_type stride,
+               octave_idx_type dist, const double *in, Complex *out)
   {
     static fftw_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (rank, dims, howmany, stride, dist, in, out)
       : dummy;
   }
 
@@ -99,24 +99,24 @@ public:
   }
 
 private:
 
   static octave_fftw_planner *instance;
 
   fftw_plan
   do_create_plan (int dir, const int rank, const dim_vector dims, 
-		  octave_idx_type howmany, octave_idx_type stride,
-		  octave_idx_type dist, const Complex *in,
-		  Complex *out);
+                  octave_idx_type howmany, octave_idx_type stride,
+                  octave_idx_type dist, const Complex *in,
+                  Complex *out);
 
   fftw_plan
   do_create_plan (const int rank, const dim_vector dims, 
-		  octave_idx_type howmany, octave_idx_type stride,
-		  octave_idx_type dist, const double *in, Complex *out);
+                  octave_idx_type howmany, octave_idx_type stride,
+                  octave_idx_type dist, const double *in, Complex *out);
 
   FftwMethod do_method (void);
 
   FftwMethod do_method (FftwMethod _meth);
 
   FftwMethod meth;
 
   // FIXME -- perhaps this should be split into two classes?
@@ -184,32 +184,32 @@ public:
     EXHAUSTIVE,
     HYBRID
   };
 
   static bool instance_ok (void);
   
   static fftwf_plan
   create_plan (int dir, const int rank, const dim_vector dims, 
-	       octave_idx_type howmany, octave_idx_type stride,
-	       octave_idx_type dist, const FloatComplex *in,
-	       FloatComplex *out)
+               octave_idx_type howmany, octave_idx_type stride,
+               octave_idx_type dist, const FloatComplex *in,
+               FloatComplex *out)
   {
     static fftwf_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (dir, rank, dims, howmany, stride,
-				  dist, in, out)
+                                  dist, in, out)
       : dummy;
   }
 
   static fftwf_plan
   create_plan (const int rank, const dim_vector dims, 
-	       octave_idx_type howmany, octave_idx_type stride,
-	       octave_idx_type dist, const float *in, FloatComplex *out)
+               octave_idx_type howmany, octave_idx_type stride,
+               octave_idx_type dist, const float *in, FloatComplex *out)
   {
     static fftwf_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (rank, dims, howmany, stride, dist, in, out)
       : dummy;
   }
 
@@ -228,24 +228,24 @@ public:
   }
 
 private:
 
   static octave_float_fftw_planner *instance;
 
   fftwf_plan
   do_create_plan (int dir, const int rank, const dim_vector dims, 
-		  octave_idx_type howmany, octave_idx_type stride,
-		  octave_idx_type dist, const FloatComplex *in,
-		  FloatComplex *out);
+                  octave_idx_type howmany, octave_idx_type stride,
+                  octave_idx_type dist, const FloatComplex *in,
+                  FloatComplex *out);
 
   fftwf_plan
   do_create_plan (const int rank, const dim_vector dims, 
-		  octave_idx_type howmany, octave_idx_type stride,
-		  octave_idx_type dist, const float *in, FloatComplex *out);
+                  octave_idx_type howmany, octave_idx_type stride,
+                  octave_idx_type dist, const float *in, FloatComplex *out);
 
   FftwMethod do_method (void);
 
   FftwMethod do_method (FftwMethod _meth);
 
   FftwMethod meth;
 
   // FIXME -- perhaps this should be split into two classes?
@@ -294,40 +294,40 @@ private:
 
 class
 OCTAVE_API
 octave_fftw
 {
 public:
 
   static int fft (const double *in, Complex *out, size_t npts, 
-		  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int fft (const Complex *in, Complex *out, size_t npts, 
-		  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int ifft (const Complex *in, Complex *out, size_t npts,
-		   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
 
   static int fftNd (const double*, Complex*, const int, const dim_vector &);
   static int fftNd (const Complex*, Complex*, const int, 
-		    const dim_vector &);
+                    const dim_vector &);
   static int ifftNd (const Complex*, Complex*, const int, 
-		     const dim_vector &);
+                     const dim_vector &);
 
   static int fft (const float *in, FloatComplex *out, size_t npts, 
-		  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int fft (const FloatComplex *in, FloatComplex *out, size_t npts, 
-		  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int ifft (const FloatComplex *in, FloatComplex *out, size_t npts,
-		   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
 
   static int fftNd (const float*, FloatComplex*, const int, const dim_vector &);
   static int fftNd (const FloatComplex*, FloatComplex*, const int, 
-		    const dim_vector &);
+                    const dim_vector &);
   static int ifftNd (const FloatComplex*, FloatComplex*, const int, 
-		     const dim_vector &);
+                     const dim_vector &);
 
 private:
   octave_fftw (void);
   octave_fftw (const octave_fftw&);
   octave_fftw& operator = (const octave_fftw&);
 };
 
 #endif
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -43,21 +43,21 @@ public:
     : gr_name (gr.gr_name), gr_passwd (gr.gr_passwd),
       gr_gid (gr.gr_gid), gr_mem (gr.gr_mem), valid (gr.valid) 
   { }
 
   octave_group& operator = (const octave_group& gr)
   {
     if (this != &gr)
       {
-	gr_name  = gr.gr_name;
-	gr_passwd = gr.gr_passwd;
-	gr_gid = gr.gr_gid;
-	gr_mem = gr.gr_mem;
-	valid = gr.valid;
+        gr_name  = gr.gr_name;
+        gr_passwd = gr.gr_passwd;
+        gr_gid = gr.gr_gid;
+        gr_mem = gr.gr_mem;
+        valid = gr.valid;
       }
 
     return *this;
   }
 
   std::string name (void) const;
 
   std::string passwd (void) const;
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -704,17 +704,17 @@ public:
             }
         }
       else
         {
           z = x / y;
           // FIXME -- this is a workaround due to MSVC's absence of
           // std::abs (int64_t).  The call to octave_int_abs can't
           // overflow, but std::abs (x) can!
-	  T w = octave_int_abs (x % y);
+          T w = octave_int_abs (x % y);
 
           if (w >= y - w) 
             z += 1 - (signbit (x) << 1);
         }
       return z;
     }
 
 };
@@ -950,17 +950,17 @@ OCTAVE_INT_BITCMP_OP (|)
 OCTAVE_INT_BITCMP_OP (^)
 
 #undef OCTAVE_INT_BITCMP_OP
 
 // General bit shift.
 template <class T>
 octave_int<T>
 bitshift (const octave_int<T>& a, int n,
-	  const octave_int<T>& mask = std::numeric_limits<T>::max ())
+          const octave_int<T>& mask = std::numeric_limits<T>::max ())
 {
   if (n > 0)
     return (a << n) & mask;
   else if (n < 0)
     return (a >> -n) & mask;
   else
     return a & mask;
 }
diff --git a/liboctave/oct-mutex.h b/liboctave/oct-mutex.h
--- a/liboctave/oct-mutex.h
+++ b/liboctave/oct-mutex.h
@@ -61,21 +61,21 @@ public:
     if (--rep->count == 0)
       delete rep;
   }
 
   octave_mutex& operator = (const octave_mutex& m)
   {
     if (rep != m.rep)
       {
-	if (--rep->count == 0)
-	  delete rep;
+        if (--rep->count == 0)
+          delete rep;
 
-	rep = m.rep;
-	rep->count++;
+        rep = m.rep;
+        rep->count++;
       }
 
     return *this;
   }
 
   void lock (void)
   {
     rep->lock ();
diff --git a/liboctave/oct-passwd.h b/liboctave/oct-passwd.h
--- a/liboctave/oct-passwd.h
+++ b/liboctave/oct-passwd.h
@@ -43,24 +43,24 @@ public:
       pw_uid (pw.pw_uid), pw_gid (pw.pw_gid), pw_gecos (pw.pw_gecos),
       pw_dir (pw.pw_dir), pw_shell (pw.pw_shell), valid (pw.valid)
   { }
 
   octave_passwd& operator = (const octave_passwd& pw)
   {
     if (this != &pw)
       {
-	pw_name = pw.pw_name;
-	pw_passwd = pw.pw_passwd;
-	pw_uid = pw.pw_uid;
-	pw_gid = pw.pw_gid;
-	pw_gecos = pw.pw_gecos;
-	pw_dir = pw.pw_dir;
-	pw_shell = pw.pw_shell;
-	valid = pw.valid;
+        pw_name = pw.pw_name;
+        pw_passwd = pw.pw_passwd;
+        pw_uid = pw.pw_uid;
+        pw_gid = pw.pw_gid;
+        pw_gecos = pw.pw_gecos;
+        pw_dir = pw.pw_dir;
+        pw_shell = pw.pw_shell;
+        valid = pw.valid;
       }
 
     return *this;
   }
 
   ~octave_passwd (void) { }
 
   std::string name (void) const;
diff --git a/liboctave/oct-rand.h b/liboctave/oct-rand.h
--- a/liboctave/oct-rand.h
+++ b/liboctave/oct-rand.h
@@ -61,17 +61,17 @@ public:
   // Return the current state.
   static ColumnVector state (const std::string& d = std::string ())
   {
     return instance_ok () ? instance->do_state (d) : ColumnVector ();
   }
 
   // Set the current state/
   static void state (const ColumnVector &s,
-		     const std::string& d = std::string ())
+                     const std::string& d = std::string ())
   {
     if (instance_ok ())
       instance->do_state (s, d);
   }
   
   // Return the current distribution.
   static std::string distribution (void)
   {
diff --git a/liboctave/oct-shlib.h b/liboctave/oct-shlib.h
--- a/liboctave/oct-shlib.h
+++ b/liboctave/oct-shlib.h
@@ -124,23 +124,23 @@ public:
     {
       rep = sl.rep;
       rep->count++;
     }
 
   octave_shlib& operator = (const octave_shlib& sl)
     {
       if (rep != sl.rep)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
+        {
+          if (--rep->count == 0)
+            delete rep;
 
-	  rep = sl.rep;
-	  rep->count++;
-	}
+          rep = sl.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
   bool operator == (const octave_shlib& sl) const
     { return (rep == sl.rep); }
 
   operator bool () const { return rep->is_open (); }
diff --git a/liboctave/oct-sort.h b/liboctave/oct-sort.h
--- a/liboctave/oct-sort.h
+++ b/liboctave/oct-sort.h
@@ -103,17 +103,17 @@ enum sortmode { UNSORTED = 0, ASCENDING,
 
 template <class T>
 class
 octave_sort
 {
 public:
 
   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
-				    typename ref_param<T>::type);
+                                    typename ref_param<T>::type);
 
   octave_sort (void);
 
   octave_sort (compare_fcn_type);
   
   ~octave_sort (void); 
 
   void set_compare (compare_fcn_type comp) { compare = comp; }
@@ -154,20 +154,20 @@ public:
                       octave_idx_type *idx, bool rev = false);
 
   // Rearranges the array so that the elements with indices
   // lo..up-1 are in their correct place. 
   void nth_element (T *data, octave_idx_type nel,
                     octave_idx_type lo, octave_idx_type up = -1);
 
   static bool ascending_compare (typename ref_param<T>::type,
-				 typename ref_param<T>::type);
+                                 typename ref_param<T>::type);
 
   static bool descending_compare (typename ref_param<T>::type,
-				  typename ref_param<T>::type);
+                                  typename ref_param<T>::type);
 
 private:
 
   // One MergeState exists on the stack per invocation of mergesort.
   // It's just a convenient way to pass state around among the helper
   // functions.
   //
   // DGB: This isn't needed with mergesort in a class, but it doesn't
diff --git a/liboctave/oct-spparms.h b/liboctave/oct-spparms.h
--- a/liboctave/oct-spparms.h
+++ b/liboctave/oct-spparms.h
@@ -53,18 +53,18 @@ public:
 
   octave_sparse_params (const octave_sparse_params& a)
     : params (a.params), keys (a.keys) { }
 
   octave_sparse_params& operator = (const octave_sparse_params& a)
   {
     if (&a != this)
       {
-	params = a.params;
-	keys = a.keys;
+        params = a.params;
+        keys = a.keys;
       }
     
     return *this;
   }
 
   ~octave_sparse_params (void) { }
 
   static bool instance_ok (void);
diff --git a/liboctave/oct-time.h b/liboctave/oct-time.h
--- a/liboctave/oct-time.h
+++ b/liboctave/oct-time.h
@@ -44,25 +44,25 @@ public:
 
   octave_time (time_t t, int us)
     : ot_unix_time (t), ot_usec ()
   {
     int rem, extra;
 
     if (us >= 0)
       {
-	rem = us % 1000000;
-	extra = (us - rem) / 1000000;
+        rem = us % 1000000;
+        extra = (us - rem) / 1000000;
       }
     else
       {
-	us = -us;
-	rem = us % 1000000;
-	extra = - (1 + (us - rem) / 1000000);
-	rem = 1000000 - us % 1000000;
+        us = -us;
+        rem = us % 1000000;
+        extra = - (1 + (us - rem) / 1000000);
+        rem = 1000000 - us % 1000000;
       }
 
     ot_usec = rem;
     ot_unix_time += extra;
   }
 
   octave_time (double d)
     : ot_unix_time (static_cast<time_t> (d)), ot_usec (0)
@@ -75,18 +75,18 @@ public:
 
   octave_time (const octave_time& ot)
     : ot_unix_time (ot.ot_unix_time), ot_usec (ot.ot_usec) { }
 
   octave_time& operator = (const octave_time& ot)
   {
     if (this != &ot)
       {
-	ot_unix_time = ot.ot_unix_time;
-	ot_usec = ot.ot_usec;
+        ot_unix_time = ot.ot_unix_time;
+        ot_usec = ot.ot_usec;
       }
 
     return *this;
   }
 
   ~octave_time (void) { }
 
   void stamp (void);
@@ -157,17 +157,17 @@ operator >= (const octave_time& t1, cons
 {
   return (t1 > t2 || t1 == t2);
 }
 
 inline octave_time
 operator + (const octave_time& t1, const octave_time& t2)
 {
   return octave_time (t1.unix_time () + t2.unix_time (),
-		      t1.usec () + t2.usec ());
+                      t1.usec () + t2.usec ());
 }
 
 class
 OCTAVE_API
 octave_base_tm
 {
 public:
 
@@ -183,27 +183,27 @@ public:
       tm_year (tm.tm_year), tm_wday (tm.tm_wday), tm_yday (tm.tm_yday),
       tm_isdst (tm.tm_isdst), tm_zone (tm.tm_zone)
   { }
 
   octave_base_tm& operator = (const octave_base_tm& tm)
   {
     if (this != &tm)
       {
-	tm_usec = tm.tm_usec;
-	tm_sec = tm.tm_sec;
-	tm_min = tm.tm_min;
-	tm_hour = tm.tm_hour;
-	tm_mday = tm.tm_mday;
-	tm_mon = tm.tm_mon;
-	tm_year = tm.tm_year;
-	tm_wday = tm.tm_wday;
-	tm_yday = tm.tm_yday;
-	tm_isdst = tm.tm_isdst;
-	tm_zone = tm.tm_zone;
+        tm_usec = tm.tm_usec;
+        tm_sec = tm.tm_sec;
+        tm_min = tm.tm_min;
+        tm_hour = tm.tm_hour;
+        tm_mday = tm.tm_mday;
+        tm_mon = tm.tm_mon;
+        tm_year = tm.tm_year;
+        tm_wday = tm.tm_wday;
+        tm_yday = tm.tm_yday;
+        tm_isdst = tm.tm_isdst;
+        tm_zone = tm.tm_zone;
       }
 
     return *this;
   }
 
   virtual ~octave_base_tm (void) { }
 
   int usec (void) const { return tm_usec; }
diff --git a/liboctave/oct-uname.h b/liboctave/oct-uname.h
--- a/liboctave/oct-uname.h
+++ b/liboctave/oct-uname.h
@@ -46,24 +46,24 @@ public:
       utsname_machine (unm.utsname_machine),
       msg (unm.msg), err (unm.err)
   { }
 
   octave_uname& operator = (const octave_uname& unm)
   {
     if (this != &unm)
       {
-	utsname_sysname = unm.utsname_sysname;
-	utsname_nodename = unm.utsname_nodename;
-	utsname_release = unm.utsname_release;
-	utsname_version = unm.utsname_version;
-	utsname_machine = unm.utsname_machine;
+        utsname_sysname = unm.utsname_sysname;
+        utsname_nodename = unm.utsname_nodename;
+        utsname_release = unm.utsname_release;
+        utsname_version = unm.utsname_version;
+        utsname_machine = unm.utsname_machine;
 
-	msg = unm.msg;
-	err = unm.err;
+        msg = unm.msg;
+        err = unm.err;
       }
 
     return *this;
   }
 
   ~octave_uname (void) { }
 
   std::string sysname (void) const { return utsname_sysname; }
diff --git a/liboctave/pathsearch.h b/liboctave/pathsearch.h
--- a/liboctave/pathsearch.h
+++ b/liboctave/pathsearch.h
@@ -30,21 +30,21 @@ along with Octave; see the file COPYING.
 
 class
 OCTAVE_API
 dir_path
 {
 public:
 
   dir_path (const std::string& s = std::string (),
-	    const std::string& d = std::string ())
+            const std::string& d = std::string ())
     : p_orig (s), p_default (d), initialized (false)
     {
       if (! p_orig.empty ())
-	init ();
+        init ();
     }
 
   dir_path (const dir_path& dp)
     : p_orig (dp.p_orig), p_default (dp.p_default),
       initialized (dp.initialized), p (dp.p), pv (dp.pv)
   { }
 
   dir_path& operator = (const dir_path& dp)
@@ -134,20 +134,20 @@ private:
     static char path_sep_char (void)
     {
       return instance_ok () ? instance->xpath_sep_char : 0;
     }
 
     static void path_sep_char (char c)
     {
       if (instance_ok ())
-	{
-	  instance->xpath_sep_char = c;
-	  instance->xpath_sep_str = std::string (1, c);
-	}
+        {
+          instance->xpath_sep_char = c;
+          instance->xpath_sep_str = std::string (1, c);
+        }
     }
 
     static std::string path_sep_str (void)
     {
       return instance_ok () ? instance->xpath_sep_str : std::string ();
     }
 
   private:
diff --git a/liboctave/sparse-base-chol.h b/liboctave/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/sparse-base-chol.h
@@ -32,34 +32,34 @@ class
 sparse_base_chol
 {
 protected:
 #ifdef HAVE_CHOLMOD
   class sparse_base_chol_rep
   {
   public:
     sparse_base_chol_rep (void) : count (1), Lsparse (0), 
-				  is_pd (false), minor_p (0) { }
+                                  is_pd (false), minor_p (0) { }
 
     sparse_base_chol_rep (const chol_type& a, 
-			  const bool natural) : count (1)
+                          const bool natural) : count (1)
       { init (a, natural); }
 
     sparse_base_chol_rep (const chol_type& a, octave_idx_type& info, 
-			  const bool natural) : count (1)
+                          const bool natural) : count (1)
       { info = init (a, natural); }
 
     ~sparse_base_chol_rep (void)
       { if (is_pd) CHOLMOD_NAME(free_sparse) (&Lsparse, &Common); }
 
     cholmod_sparse * L (void) const { return Lsparse; }
 
     octave_idx_type P (void) const 
       { return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ? 
-		0 : minor_p + 1); }
+                0 : minor_p + 1); }
 
     ColumnVector perm (void) const { return perms + 1; }
 
     p_type Q (void) const;
 
     bool is_positive_definite (void) const { return is_pd; }
 
     double rcond (void) const { return cond; }
@@ -88,21 +88,21 @@ protected:
   };
 #else
   class sparse_base_chol_rep
   {
   public:
     sparse_base_chol_rep (void) : count (1), is_pd (false), minor_p (0) { }
 
     sparse_base_chol_rep (const chol_type& a, 
-			  const bool natural) : count (1)
+                          const bool natural) : count (1)
       { init (a, natural); }
 
     sparse_base_chol_rep (const chol_type& a, octave_idx_type& info, 
-			  const bool natural) : count (1)
+                          const bool natural) : count (1)
       { info = init (a, natural); }
 
     ~sparse_base_chol_rep (void) { }
 
     octave_idx_type P (void) const { return 0; }
 
     ColumnVector perm (void) const { return perms + 1; }
 
@@ -135,41 +135,41 @@ protected:
   
 public:
 
   sparse_base_chol (void) : rep (new typename 
     sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep ()) { }
 
   sparse_base_chol (const chol_type& a, const bool n) : rep (new typename 
     sparse_base_chol<chol_type, chol_elt, p_type>::
-	sparse_base_chol_rep (a, n)) { }
+        sparse_base_chol_rep (a, n)) { }
 
   sparse_base_chol (const chol_type& a, octave_idx_type& info, const bool n) :
     rep (new typename sparse_base_chol<chol_type, chol_elt, p_type>::
-	sparse_base_chol_rep (a, info, n)) { }
+        sparse_base_chol_rep (a, info, n)) { }
 
   sparse_base_chol (const sparse_base_chol<chol_type, chol_elt, p_type>& a) : 
     rep (a.rep) { rep->count++; }
 
   ~sparse_base_chol (void) 
     {
       if (--rep->count <= 0)
-	delete rep;
+        delete rep;
     }
 
   sparse_base_chol& operator = (const sparse_base_chol& a)
     {
       if (this != &a)
-	{
-	  if (--rep->count <= 0)
-	    delete rep;
+        {
+          if (--rep->count <= 0)
+            delete rep;
 
-	  rep = a.rep;
-	  rep->count++;
-	}
+          rep = a.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
   chol_type L (void) const;
 
   chol_type R (void) const { return L().hermitian (); }
 
diff --git a/liboctave/sparse-base-lu.h b/liboctave/sparse-base-lu.h
--- a/liboctave/sparse-base-lu.h
+++ b/liboctave/sparse-base-lu.h
@@ -37,23 +37,23 @@ public:
   sparse_base_lu (void) { }
 
   sparse_base_lu (const sparse_base_lu& a) 
     : Lfact (a.Lfact), Ufact (a.Ufact), cond (a.cond), P (a.P), Q (a.Q) { }
 
   sparse_base_lu& operator = (const sparse_base_lu& a)
     {
       if (this != &a)
-	{
-	  Lfact = a.Lfact;
-	  Ufact = a.Ufact;
-	  cond = a.cond;
-	  P = a.P;
-	  Q = a.Q;
-	}
+        {
+          Lfact = a.Lfact;
+          Ufact = a.Ufact;
+          cond = a.cond;
+          P = a.P;
+          Q = a.Q;
+        }
       return *this;
     }
 
   ~sparse_base_lu (void) { }
 
   lu_type L (void) const { return Lfact; }
 
   lu_type U (void) const { return Ufact; }
diff --git a/liboctave/sparse-sort.h b/liboctave/sparse-sort.h
--- a/liboctave/sparse-sort.h
+++ b/liboctave/sparse-sort.h
@@ -31,22 +31,22 @@ octave_sparse_sort_idxl
 {
 public:
   octave_idx_type r;
   octave_idx_type c;
   octave_idx_type idx; 
 };
 
 bool octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i,
-			       octave_sparse_sort_idxl* j);
+                               octave_sparse_sort_idxl* j);
 
 class
 octave_idx_vector_sort
 {
 public:
   octave_idx_type i;
   octave_idx_type idx;
 };
 
 bool octave_idx_vector_comp (octave_idx_vector_sort* i,
-			     octave_idx_vector_sort* j);
+                             octave_idx_vector_sort* j);
 
 #endif
diff --git a/liboctave/sparse-util.h b/liboctave/sparse-util.h
--- a/liboctave/sparse-util.h
+++ b/liboctave/sparse-util.h
@@ -28,12 +28,12 @@ along with Octave; see the file COPYING.
 extern OCTAVE_API void SparseCholError (int status, char *file, 
                                         int line, char *message);
 extern OCTAVE_API void SparseCholError (int status, const char *file, 
                                         int line, const char *message);
 extern OCTAVE_API int SparseCholPrint (const char *fmt, ...);
 
 extern OCTAVE_API bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
-		   octave_idx_type nrows, octave_idx_type ncols,
-		   octave_idx_type nnz);
+                   octave_idx_type nrows, octave_idx_type ncols,
+                   octave_idx_type nnz);
 
 #endif
diff --git a/liboctave/statdefs.h b/liboctave/statdefs.h
--- a/liboctave/statdefs.h
+++ b/liboctave/statdefs.h
@@ -25,41 +25,41 @@ along with Octave; see the file COPYING.
 #define octave_statdefs_h 1
 
 #include <sys/types.h>
 
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
-#ifndef S_ISREG			/* Doesn't have POSIX.1 stat stuff. */
+#ifndef S_ISREG                 /* Doesn't have POSIX.1 stat stuff. */
 #ifndef mode_t
 #define mode_t unsigned short
 #endif
 #endif
 #if !defined(S_ISBLK) && defined(S_IFBLK)
-#define	S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
 #endif
 #if !defined(S_ISCHR) && defined(S_IFCHR)
-#define	S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
 #endif
 #if !defined(S_ISDIR) && defined(S_IFDIR)
-#define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
 #endif
 #if !defined(S_ISREG) && defined(S_IFREG)
-#define	S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
 #endif
 #if !defined(S_ISFIFO) && defined(S_IFIFO)
-#define	S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
 #endif
 #if !defined(S_ISLNK) && defined(S_IFLNK)
-#define	S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
 #endif
 #if !defined(S_ISSOCK) && defined(S_IFSOCK)
-#define	S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
 #endif
 #if !defined(S_ISMPB) && defined(S_IFMPB) /* V7 */
 #define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
 #define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
 #endif
 #if !defined(S_ISNWK) && defined(S_IFNWK) /* HP/UX */
 #define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
 #endif
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -69,20 +69,20 @@ public:
 
   octave_idx_type max_length (void) const
   {
     octave_idx_type n = length ();
     octave_idx_type longest = 0;
 
     for (octave_idx_type i = 0; i < n; i++)
       {
-	octave_idx_type tmp = elem(i).length ();
+        octave_idx_type tmp = elem(i).length ();
 
-	if (tmp > longest)
-	  longest = tmp;
+        if (tmp > longest)
+          longest = tmp;
       }
 
     return longest;
   }
 
   std::string& operator[] (octave_idx_type i) { return Array<std::string>::elem (i); }
 
   std::string operator[] (octave_idx_type i) const { return Array<std::string>::elem (i); }
