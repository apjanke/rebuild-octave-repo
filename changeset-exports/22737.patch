# HG changeset patch
# User Rik <rik@octave.org>
# Date 1478628077 28800
#      Tue Nov 08 10:01:17 2016 -0800
# Node ID 7abc25e6206a288d25bd4b12754e27e70ef68ac1
# Parent  44d9d526d1e3d02d7a834cc2b9ee4538ac293907
maint: Clean up code base to follow Octave coding conventions.
Space between '!' and expression that follows.
Eliminate whitespace at end of line.
Use '#' rather than '%' for comment character.
* ButtonGroup.cc, ListBoxControl.cc, file-editor-tab.cc, file-editor.cc,
bsxfun.cc, cellfun.cc, conv2.cc, data.cc, dot.cc, fft2.cc, file-io.cc,
filter.cc, graphics.cc, kron.cc, oct-stream.cc, quadcc.cc, spparms.cc,
sylvester.cc, convhulln.cc, qr.cc, ov-class.cc, ov-cx-mat.cc, ov-usr-fcn.cc,
pt.h, Array.cc, gsvd.h, inputdlg.m, krylov.m, shrinkfaces.m, padecoef.m,
polyout.m, durbinlevinson.m:
maint: Clean up code base to follow Octave coding conventions.

diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -438,17 +438,17 @@ namespace QtHandles
     m_buttongroup->addButton(btn);
     connect (btn, SIGNAL (toggled (bool)), SLOT (buttonToggled (bool)));
   }
 
   void
   ButtonGroup::buttonToggled (bool toggled)
   {
     Q_UNUSED (toggled);
-    if (!m_blockUpdates)
+    if (! m_blockUpdates)
       {
         gh_manager::auto_lock lock;
         uibuttongroup::properties& bp = properties<uibuttongroup> ();
 
         graphics_handle oldValue = bp.get_selectedobject();
 
         QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
 
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -184,89 +184,90 @@ namespace QtHandles
 
   void
   ListBoxControl::itemSelectionChanged (void)
   {
     if (! m_blockCallback)
       m_selectionChanged = true;
   }
 
-  void 
+  void
   ListBoxControl::itemActivated (const QModelIndex &)
   {
     m_selectionChanged = true;
   }
-  void 
+  void
   ListBoxControl::itemPressed (QListWidgetItem*)
   {
     m_selectionChanged = true;
   }
 
-  bool 
+  bool
   ListBoxControl::eventFilter (QObject* watched, QEvent* e)
   {
     // listbox change
     if (watched == m_qobject)
       {
         switch (e->type ())
           {
             case QEvent::KeyRelease:
               if (m_selectionChanged)
                 sendSelectionChange ();
               m_selectionChanged = false;
               break;
- 
+
             default:
               break;
-          } 
-          
+          }
+
         return Object::eventFilter (watched, e);
       }
     // listbox viewport
     else
       {
         bool override_return = false;
         QListWidget* list = qWidget<QListWidget> ();
 
         switch (e->type ())
           {
-            case QEvent::MouseButtonPress: 
+            case QEvent::MouseButtonPress:
               {
                 QMouseEvent* m = dynamic_cast<QMouseEvent*> (e);
 
                 if (m->button () & Qt::RightButton)
                   override_return = true;
                 else
                   {
-                    if(!list->indexAt(m->pos()).isValid()) override_return = true;
+                    if (! list->indexAt(m->pos()).isValid())
+                      override_return = true;
                     m_selectionChanged = true;
                   }
                 break;
               }
             case QEvent::MouseButtonRelease:
               {
                 QMouseEvent* m = dynamic_cast<QMouseEvent*> (e);
-  
+
                 if (m->button () & Qt::RightButton)
                   override_return = true;
 
-                else if(!list->indexAt(m->pos()).isValid()) 
+                else if (! list->indexAt(m->pos()).isValid())
                   {
-                    list->setCurrentRow(list->count()-1); 
+                    list->setCurrentRow(list->count()-1);
                     override_return = true;
                   }
 
                 if (m_selectionChanged)
                   sendSelectionChange ();
                 m_selectionChanged = false;
-              
+
                 break;
               }
             default:
               break;
- 
+
           }
         return BaseControl::eventFilter (watched, e) || override_return;
       }
   }
 }
 
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -370,17 +370,17 @@ file_editor_tab::handle_context_menu_bre
         cond = _edit_area->selectedText ();
       else
         cond = "(" + cond + ") || (" + _edit_area->selectedText () + ")";
     }
 
   bool valid = false;
   std::string prompt = "dbstop if";
   bool ok;
-  while (!valid)
+  while (! valid)
     {
       QString new_condition
         = QInputDialog::getText (this, tr ("Breakpoint condition"),
                                  tr (prompt.c_str ()), QLineEdit::Normal, cond,
                                  &ok);
       if (ok)     // If cancel, don't change breakpoint condition.
         {
           try
@@ -1765,17 +1765,17 @@ file_editor_tab::exit_debug_and_clear (c
     }
   catch (const octave::execution_exception& e)
     {
       // Ignore syntax error.
       // It was in the old file on disk; the user may have fixed it already.
     }
 
   // Return early if this file is not loaded in the symbol table
-  if (!sym.is_defined () || !sym.is_user_code ())
+  if (! sym.is_defined () || ! sym.is_user_code ())
     return true;
 
   octave_user_code *fcn = sym.user_code_value ();
 
   std::string full_name = full_name_q.toStdString ();
   if (octave::sys::canonicalize_file_name (full_name.c_str ())
       != octave::sys::canonicalize_file_name (fcn->fcn_file_name ().c_str ()))
     return true;
@@ -1835,17 +1835,17 @@ file_editor_tab::save_file (const QStrin
 
   // get the absolute path (if existing)
   QFileInfo file_info = QFileInfo (saveFileName);
   QString file_to_save;
   if (file_info.exists ())
     {
       file_to_save = file_info.canonicalFilePath ();
       // Force reparse of this function next time it is used (bug #46632)
-      if (!exit_debug_and_clear (file_to_save, file_info.baseName ()))
+      if (! exit_debug_and_clear (file_to_save, file_info.baseName ()))
         return;
     }
   else
     file_to_save = saveFileName;
   QFile file (file_to_save);
 
   // stop watching file
   QStringList trackedFiles = _file_system_watcher.files ();
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -469,28 +469,28 @@ file_editor::request_open_file (const QS
               fileEditorTab = static_cast<file_editor_tab *>(tab);
               if (fileEditorTab->qsci_edit_area ()->isModified ())
                 fileEditorTab = 0;
               else
                 reusing = true;
             }
 
           // If <unnamed> was absent or modified, create a new tab.
-          if (!fileEditorTab)
+          if (! fileEditorTab)
             fileEditorTab = new file_editor_tab ();
 
           if (fileEditorTab)
             {
               fileEditorTab->set_encoding (encoding);
               QString result = fileEditorTab->load_file (openFileName);
               if (result == "")
                 {
                   // Supply empty title then have the file_editor_tab update
                   // with full or short name.
-                  if (!reusing)
+                  if (! reusing)
                     add_file_editor_tab (fileEditorTab, "");
                   fileEditorTab->update_window_title (false);
                   // file already loaded, add file to mru list here
                   QFileInfo file_info = QFileInfo (openFileName);
                   handle_mru_add_file (file_info.canonicalFilePath (),
                                        encoding);
 
                   if (line > 0)
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -739,17 +739,17 @@ dimensionality as the other array.
 %!assert (bsxfun (f, ones ([4, 4, 1]), ones ([4, 1, 4])), zeros ([4, 4, 4]))
 %!assert (bsxfun (f, ones ([4, 1, 4]), ones ([1, 4, 4])), zeros ([4, 4, 4]))
 %!assert (bsxfun (f, ones ([4, 1, 4]), ones ([1, 4, 1])), zeros ([4, 4, 4]))
 %!assert (bsxfun (f, a, b), a - repmat (b, [4, 1, 1]))
 %!assert (bsxfun (f, a, c), a - repmat (c, [1, 4, 1]))
 %!assert (bsxfun (f, a, d), a - repmat (d, [1, 1, 4]))
 %!assert (bsxfun ("minus", ones ([4, 0, 4]), ones ([4, 1, 4])), zeros ([4, 0, 4]))
 
-%% The test below is a very hard case to treat
+## The test below is a very hard case to treat
 %!assert (bsxfun (f, ones ([4, 1, 4, 1]), ones ([1, 4, 1, 4])), zeros ([4, 4, 4, 4]))
 
 %!shared a, b, aa, bb
 %! a = randn (3, 1, 3);
 %! aa = a(:, ones (1, 3), :, ones (1, 3));
 %! b = randn (1, 3, 3, 3);
 %! bb = b(ones (1, 3), :, :, :);
 %!assert (bsxfun (@plus, a, b), aa + bb)
@@ -765,17 +765,17 @@ dimensionality as the other array.
 %!assert (bsxfun (@le, a, b), aa <= bb)
 %!assert (bsxfun (@gt, a, b), aa > bb)
 %!assert (bsxfun (@ge, a, b), aa >= bb)
 %!assert (bsxfun (@min, a, b), min (aa, bb))
 %!assert (bsxfun (@max, a, b), max (aa, bb))
 %!assert (bsxfun (@and, a > 0, b > 0), (aa > 0) & (bb > 0))
 %!assert (bsxfun (@or, a > 0, b > 0), (aa > 0) | (bb > 0))
 
-%% Test automatic bsxfun
+## Test automatic bsxfun
 %
 %!test
 %! funs = {@plus, @minus, @times, @rdivide, @ldivide, @power, @max, @min, ...
 %!         @rem, @mod, @atan2, @hypot, @eq, @ne, @lt, @le, @gt, @ge, ...
 %!         @and, @or, @xor };
 %!
 %! float_types = {@single, @double};
 %! int_types = {@int8, @int16, @int32, @int64, ...
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -717,38 +717,38 @@ v = cellfun (@@det, a); # faster
 %! assert (a, zeros (2, 0));
 %! assert (b, zeros (2, 0));
 
 %!test
 %! [a,b] = cellfun (@(x) x, cell (2, 0), "uniformoutput", false);
 %! assert (a, cell (2, 0));
 %! assert (b, cell (2, 0));
 
-%% Test function to check the "Errorhandler" option
+## Test function to check the "Errorhandler" option
 %!function z = __cellfunerror (S, varargin)
 %!  z = S;
 %!endfunction
 
-%% First input argument can be a string, an inline function,
-%% a function_handle or an anonymous function
+## First input argument can be a string, an inline function,
+## a function_handle or an anonymous function
 %!test
 %! A = cellfun ("islogical", {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (@islogical, {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (@(x) islogical (x), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 
-%% First input argument can be the special string "isreal",
-%% "isempty", "islogical", "isnumeric", "length", "ndims" or "prodofsize"
+## First input argument can be the special string "isreal",
+## "isempty", "islogical", "isnumeric", "length", "ndims" or "prodofsize"
 %!test
 %! A = cellfun ("isreal", {true, 0.1, {}, i*2, [], "abc"});
 %! assert (A, [true, true, false, false, true, true]);
 %!test
 %! A = cellfun ("isempty", {true, 0.1, false, i*2, [], "abc"});
 %! assert (A, [false, false, false, false, true, false]);
 %!test
 %! A = cellfun ("islogical", {true, 0.1, false, i*2, [], "abc"});
@@ -761,139 +761,139 @@ v = cellfun (@@det, a); # faster
 %! assert (A, [1, 1, 1, 1, 0, 3]);
 %!test
 %! A = cellfun ("ndims", {[1, 2; 3, 4]; (cell (1,2,3,4))});
 %! assert (A, [2; 4]);
 %!test
 %! A = cellfun ("prodofsize", {[1, 2; 3, 4], (cell (1,2,3,4))});
 %! assert (A, [4, 24]);
 
-%% Number of input and output arguments may not be limited to one
+## Number of input and output arguments may not be limited to one
 %!test
 %! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5});
 %! assert (A, [6, 7, 8]);
 %!test
 %! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5}, ...
 %!              "UniformOutput", false);
 %! assert (A, {6, 7, 8});
-%!test %% Two input arguments of different types
+%!test  # Two input arguments of different types
 %! A = cellfun (@(x,y) islogical (x) && ischar (y), {false, true}, {"a", 3});
 %! assert (A, [true, false]);
-%!test %% Pass another variable to the anonymous function
+%!test  # Pass another variable to the anonymous function
 %! y = true;
 %! A = cellfun (@(x) islogical (x) && y, {false, 0.3});
 %! assert (A, [true, false]);
-%!test %% Three ouptut arguments of different type
+%!test  # Three ouptut arguments of different type
 %! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 
-%% Input arguments can be of type cell array of logical
+## Input arguments can be of type cell array of logical
 %!test
 %! A = cellfun (@(x,y) x == y, {false, true}, {true, true});
 %! assert (A, [false, true]);
 %!test
 %! A = cellfun (@(x,y) x == y, {false; true}, {true; true}, ...
 %!              "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x) x, {false, true; false, true}, "UniformOutput", false);
 %! assert (A, {false, true; false, true});
-%!test %% Three ouptut arguments of same type
+%!test  # Three ouptut arguments of same type
 %! [A, B, C] = cellfun (@find, {true, false; false, true}, ...
 %!                      "UniformOutput", false);
 %! assert (isequal (A, {true, []; [], true}));
 %! assert (isequal (B, {true, []; [], true}));
 %! assert (isequal (C, {true, []; [], true}));
 %!test
 %! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
-%% Input arguments can be of type cell array of numeric
+## Input arguments can be of type cell array of numeric
 %!test
 %! A = cellfun (@(x,y) x>y, {1.1, 4.2}, {3.1, 2+3*i});
 %! assert (A, [false, true]);
 %!test
 %! A = cellfun (@(x,y) x>y, {1.1, 4.2; 2, 4}, {3.1, 2; 2, 4+2*i}, ...
 %!              "UniformOutput", true);
 %! assert (A, [false, true; false, false]);
 %!test
 %! A = cellfun (@(x,y) x:y, {1.1, 4}, {3.1, 6}, "UniformOutput", false);
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
-%!test %% Three ouptut arguments of different type
+%!test  # Three ouptut arguments of different type
 %! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
 %! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
-%% Input arguments can be of type cell arrays of character or strings
-%!error %% "UniformOutput" false should be used
+## Input arguments can be of type cell arrays of character or strings
+%!error  # "UniformOutput" false should be used
 %! A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
 %!test
 %! A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
 %! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
-%% Structures cannot be handled by cellfun
+## Structures cannot be handled by cellfun
 %!error
 %! vst1.a = 1.1;  vst1.b = 4.2;  vst2.a = 3.1;  vst2.b = 2;
 %! A = cellfun (@(x,y) (x.a < y.a) && (x.b > y.b), vst1, vst2);
 
-%% Input arguments can be of type cell array of cell arrays
+## Input arguments can be of type cell array of cell arrays
 %!test
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}});
 %! assert (A, [1, 0], 1e-16);
 %!test
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, ...
 %!              "UniformOutput", true);
 %! assert (A, [1; 0], 1e-16);
 %!test
@@ -903,26 +903,26 @@ v = cellfun (@@det, a); # faster
 %!test
 %! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
-%% Input arguments can be of type cell array of structure arrays
+## Input arguments can be of type cell array of structure arrays
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
 %! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b), {a}, {b});
 %! assert (A, true);
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
 %! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, ...
 %!              "UniformOutput", true);
@@ -936,27 +936,27 @@ v = cellfun (@@det, a); # faster
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
 %! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
 %! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
-%% A lot of other tests
+## A lot of other tests
 %!assert (cellfun (@sin, {0,1}), sin ([0,1]))
 %!assert (cellfun (inline ("sin (x)"), {0,1}), sin ([0,1]))
 %!assert (cellfun ("sin", {0,1}), sin ([0,1]))
 %!assert (cellfun ("isempty", {1,[]}), [false,true])
 %!assert (cellfun ("islogical", {false,pi}), [true,false])
 %!assert (cellfun ("isnumeric", {false,pi,struct()}), [false,true,false])
 %!assert (cellfun ("isreal", {1i,1}), [false,true])
 %!assert (cellfun ("length", {zeros(2,2),1}), [2,1])
@@ -1409,22 +1409,22 @@ arrayfun (@@str2num, [1234],
 %!test
 %! assert (arrayfun (@__f11, [1, 2]), [1, 2]);
 %! assert (arrayfun (@__f11, [1, 2], "uniformoutput", false), {1, 2});
 %! assert (arrayfun (@__f11, {1, 2}), {1, 2});
 %! assert (arrayfun (@__f11, {1, 2}, "uniformoutput", false), {{1}, {2}});
 
 %!assert (arrayfun (@ones, 1, [2,3], "uniformoutput", false), {[1,1], [1,1,1]})
 
-%% Test function to check the "Errorhandler" option
+## Test function to check the "Errorhandler" option
 %!function z = __arrayfunerror (S, varargin)
 %!  z = S;
 %!endfunction
-%% First input argument can be a string, an inline function, a
-%% function_handle or an anonymous function
+## First input argument can be a string, an inline function, a
+## function_handle or an anonymous function
 %!test
 %! arrayfun (@isequal, [false, true], [true, true]);  # No output argument
 %!error
 %! arrayfun (@isequal);  # One or less input arguments
 %!test
 %! A = arrayfun ("isequal", [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
@@ -1432,120 +1432,120 @@ arrayfun (@@str2num, [1234],
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@isequal, [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@(x,y) isequal (x,y), [false, true], [true, true]);
 %! assert (A, [false, true]);
 
-%% Number of input and output arguments may be greater than one
-%#!test
+## Number of input and output arguments may be greater than one
+%!test
 %! A = arrayfun (@(x) islogical (x), false);
 %! assert (A, true);
 %!test
 %! A = arrayfun (@(x,y,z) x + y + z, [1, 1, 1], [2, 2, 2], [3, 4, 5]);
 %! assert (A, [6, 7, 8], 1e-16);
-%!test %% Two input arguments of different types
+%!test  # Two input arguments of different types
 %! A = arrayfun (@(x,y) islogical (x) && ischar (y), false, "a");
 %! assert (A, true);
-%!test %% Pass another variable to the anonymous function
+%!test  # Pass another variable to the anonymous function
 %! y = true;
 %! A = arrayfun (@(x) islogical (x && y), false);
 %! assert (A, true);
-%!test %% Three ouptut arguments of different type
+%!test  # Three ouptut arguments of different type
 %! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 
-%% Input arguments can be of type logical
+## Input arguments can be of type logical
 %!test
 %! A = arrayfun (@(x,y) x == y, [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@(x,y) x == y, [false; true], [true; true], "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
 %! assert (A, {false, true, false, true});
-%!test %% Three ouptut arguments of same type
+%!test  # Three ouptut arguments of same type
 %! [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
 %! assert (isequal (A, {true, []; [], true}));
 %! assert (isequal (B, {true, []; [], true}));
 %! assert (isequal (C, {true, []; [], true}));
 %!test
 %! A = arrayfun (@(x,y) array2str (x,y), true, true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! A = arrayfun (@(x,y) array2str (x,y), true, true, "UniformOutput", true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
-%% Input arguments can be of type numeric
+## Input arguments can be of type numeric
 %!test
 %! A = arrayfun (@(x,y) x>y, [1.1, 4.2], [3.1, 2+3*i]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@(x,y) x>y, [1.1, 4.2; 2, 4], [3.1, 2; 2, 4+2*i], "UniformOutput", true);
 %! assert (A, [false, true; false, false]);
 %!test
 %! A = arrayfun (@(x,y) x:y, [1.1, 4], [3.1, 6], "UniformOutput", false);
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
-%!test %% Three ouptut arguments of different type
+%!test  # Three ouptut arguments of different type
 %! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
 %! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
-%% Input arguments can be of type character or strings
+## Input arguments can be of type character or strings
 %!test
 %! A = arrayfun (@(x,y) x>y, ["ad", "c", "ghi"], ["cc", "d", "fgh"]);
 %! assert (A, [false, true, false, true, true, true]);
 %!test
 %! A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
 %! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %! assert (B, true);
 
-%% Input arguments can be of type structure
+## Input arguments can be of type structure
 %!test
 %! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
 %! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
 %! assert (A, true);
 %!test
 %! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
 %! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b, "UniformOutput", true);
 %! assert (A, true);
@@ -1555,26 +1555,26 @@ arrayfun (@@str2num, [1234],
 %! assert (isequal (A, {[1.1, 2.1, 3.1]}));
 %!test
 %! A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
-%!test %% Overwriting setting of "UniformOutput" true
+%!test  # Overwriting setting of "UniformOutput" true
 %! A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
-%% Input arguments can be of type cell array
+## Input arguments can be of type cell array
 %!test
 %! A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2});
 %! assert (A, [true, false]);
 %!test
 %! A = arrayfun (@(x,y) x{1} < y{1}, {1.1; 4.2}, {3.1; 2}, "UniformOutput", true);
 %! assert (A, [true; false]);
 %!test
 %! A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2}, "UniformOutput", false);
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -228,17 +228,17 @@ When the third argument is a matrix, ret
 
 %!test
 %! c = [1,4,4;5,18,16;14,48,40;19,62,48;15,48,36];
 %! assert (conv2 (1:3, 1:2, [1,2;3,4;5,6]), c);
 
 %!assert (conv2 (1:3, 1:2, [1,2;3,4;5,6], "full"),
 %!        conv2 (1:3, 1:2, [1,2;3,4;5,6]));
 
-%% Test shapes
+## Test shapes
 %!shared A, B, C
 %! A = rand (3, 4);
 %! B = rand (4);
 %! C = conv2 (A, B);
 %!assert (conv2 (A,B, "full"), C)
 %!assert (conv2 (A,B, "same"), C(3:5,3:6))
 %!assert (conv2 (A,B, "valid"), zeros (0, 1))
 %!assert (size (conv2 (B,A, "valid")), [2 1])
@@ -246,20 +246,20 @@ When the third argument is a matrix, ret
 %!test
 %! B = rand (5);
 %! C = conv2 (A, B);
 %!assert (conv2 (A,B, "full"), C)
 %!assert (conv2 (A,B, "same"), C(3:5,3:6))
 %!assert (conv2 (A,B, "valid"), zeros (0, 0))
 %!assert (size (conv2 (B,A, "valid")), [3 2])
 
-%% Clear shared variables so they are not reported for tests below
+## Clear shared variables so they are not reported for tests below
 %!shared
 
-%% Test cases from Bug #34893
+## Test cases from Bug #34893
 %!assert <34893> (conv2 ([1:5;1:5], [1:2], "same"),
 %!                [4 7 10 13 10; 4 7 10 13 10])
 %!assert <34893> (conv2 ([1:5;1:5]', [1:2]', "same"),
 %!                [4 7 10 13 10; 4 7 10 13 10]')
 %!assert <34893> (conv2 ([1:5;1:5], [1:2], "valid"),
 %!                [4 7 10 13; 4 7 10 13])
 %!assert <34893> (conv2 ([1:5;1:5]', [1:2]', "valid"),
 %!                [4 7 10 13; 4 7 10 13]')
@@ -267,22 +267,22 @@ When the third argument is a matrix, ret
 %!test
 %! rand ("seed", 42);
 %! x = rand (100);
 %! y = ones (5);
 %! A = conv2 (x, y)(5:end-4,5:end-4);
 %! B = conv2 (x, y, "valid");
 %! assert (B, A);   # Yes, this test is for *exact* equivalence.
 
-%% Test input validation
+## Test input validation
 %!error conv2 ()
 %!error conv2 (1)
 %!error <must be 1-D vectors or 2-D matrices> conv2 (ones (2), ones (2,2,2))
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
-%% Test alternate calling form which should be 2 vectors and a matrix
+## Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
 */
 
 DEFUN (convn, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{C} =} convn (@var{A}, @var{B})
 @deftypefnx {} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1429,17 +1429,17 @@ Given a matrix argument, instead of a ve
 %!assert (diag ({1}, 2, 3), {1,[],[]; [],[],[]})
 %!assert (diag ({1,2}, 3, 4), {1,[],[],[]; [],2,[],[]; [],[],[],[]})
 
 ## Test out-of-range diagonals
 %!assert (diag (ones (3,3), 4), zeros (0, 1))
 %!assert (diag (cell (3,3), 4), cell (0, 1))
 %!assert (diag (sparse (ones (3,3)), 4), sparse (zeros (0, 1)))
 
-%% Test input validation
+## Test input validation
 %!error <Invalid call to diag> diag ()
 %!error <Invalid call to diag> diag (1,2,3,4)
 %!error diag (ones (2), 3, 3)
 %!error diag (1:3, -4, 3)
 
 %!assert (diag (1, 3, 3), diag ([1, 0, 0]))
 %!assert (diag (i, 3, 3), diag ([i, 0, 0]))
 %!assert (diag (single (1), 3, 3), diag ([single(1), 0, 0]))
@@ -1593,17 +1593,17 @@ in double precision even for single prec
 %!assert (prod ([i, 2+i, -3+2i, 4]), -4 - 32i)
 %!assert (prod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [-1+i, -8+8i, -27+27i])
 
 %!assert (prod (single ([1, 2, 3])), single (6))
 %!assert (prod (single ([-1; -2; -3])), single (-6))
 %!assert (prod (single ([i, 2+i, -3+2i, 4])), single (-4 - 32i))
 %!assert (prod (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([-1+i, -8+8i, -27+27i]))
 
-%% Test sparse
+## Test sparse
 %!assert (prod (sparse ([1, 2, 3])), sparse (6))
 %!assert (prod (sparse ([-1; -2; -3])), sparse (-6))
 ## Commented out until bug #42290 is fixed
 #%!assert (prod (sparse ([i, 2+i, -3+2i, 4])), sparse (-4 - 32i))
 #%!assert (prod (sparse ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), sparse ([-1+i, -8+8i, -27+27i]))
 
 %!assert (prod ([1, 2; 3, 4], 1), [3, 8])
 %!assert (prod ([1, 2; 3, 4], 2), [2; 12])
@@ -1630,31 +1630,31 @@ in double precision even for single prec
 %!assert (prod (zeros (0, 1, "single"), 2), zeros (0, 1, "single"))
 %!assert (prod (zeros (2, 0, "single")), zeros (1, 0, "single"))
 %!assert (prod (zeros (2, 0, "single"), 1), zeros (1, 0, "single"))
 %!assert (prod (zeros (2, 0, "single"), 2), single ([1; 1]))
 %!assert (prod (zeros (0, 2, "single")), single ([1, 1]))
 %!assert (prod (zeros (0, 2, "single"), 1), single ([1, 1]))
 %!assert (prod (zeros (0, 2, "single"), 2), zeros (0, 1, "single"))
 
-%% Test "double" type argument
+## Test "double" type argument
 %!assert (prod (single ([1, 2, 3]), "double"), 6)
 %!assert (prod (single ([-1; -2; -3]), "double"), -6)
 %!assert (prod (single ([i, 2+i, -3+2i, 4]), "double"), -4 - 32i)
 %!assert (prod (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), "double"), [-1+i, -8+8i, -27+27i])
 
-%% Test "native" type argument
+## Test "native" type argument
 %!assert (prod (uint8 ([1, 2, 3]), "native"), uint8 (6))
 %!assert (prod (uint8 ([-1; -2; -3]), "native"), uint8 (0))
 %!assert (prod (int8 ([1, 2, 3]), "native"), int8 (6))
 %!assert (prod (int8 ([-1; -2; -3]), "native"), int8 (-6))
 %!assert (prod ([true false; true true], "native"), [true false])
 %!assert (prod ([true false; true true], 2, "native"), [false; true])
 
-%% Test input validation
+## Test input validation
 %!error prod ()
 %!error prod (1,2,3)
 %!error <unrecognized type argument 'foobar'> prod (1, "foobar")
 */
 
 static bool
 all_scalar_1x1 (const octave_value_list& args)
 {
@@ -3641,17 +3641,17 @@ zero).
 {
   if (args.length () != 1)
     print_usage ();
 
   return ovl (args(0).is_empty ());
 }
 
 /*
-%% Debian bug #706376
+## Debian bug #706376
 %!assert (isempty (speye(2^16)), false)
 */
 
 DEFUN (isnumeric, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isnumeric (@var{x})
 Return true if @var{x} is a numeric object, i.e., an integer, real, or
 complex array.
@@ -3704,17 +3704,17 @@ Return true if @var{x} is a scalar.
 %!assert (isscalar ("t"))
 %!assert (isscalar ("test"), false)
 %!assert (isscalar (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
 %! assert (isscalar (s));
 
-%% Test input validation
+## Test input validation
 %!error isscalar ()
 %!error isscalar (1, 2)
 */
 
 DEFUN (isvector, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isvector (@var{x})
 Return true if @var{x} is a vector.
@@ -3742,17 +3742,17 @@ consequence a 1x1 array, or scalar, is a
 %!assert (isvector ("t"), true)
 %!assert (isvector ("test"), true)
 %!assert (isvector (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
 %! assert (isvector (s), true);
 
-%% Test input validation
+## Test input validation
 %!error isvector ()
 %!error isvector ([1, 2], 2)
 */
 
 DEFUN (isrow, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isrow (@var{x})
 Return true if @var{x} is a row vector 1xN with non-negative N.
@@ -3786,17 +3786,17 @@ Return true if @var{x} is a row vector 1
 %!assert (isrow ("t"), true)
 %!assert (isrow ("test"), true)
 %!assert (isrow (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
 %! assert (isrow (s), true);
 
-%% Test input validation
+## Test input validation
 %!error isrow ()
 %!error isrow ([1, 2], 2)
 */
 
 DEFUN (iscolumn, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} iscolumn (@var{x})
 Return true if @var{x} is a column vector Nx1 with non-negative N.
@@ -3830,17 +3830,17 @@ Return true if @var{x} is a column vecto
 
 %!assert (iscolumn (ones (0, 0)), false)
 %!assert (iscolumn (ones (0, 1, 0)), false)
 
 %!test
 %! s.a = 1;
 %! assert (iscolumn (s));
 
-%% Test input validation
+## Test input validation
 %!error iscolumn ()
 %!error iscolumn ([1, 2], 2)
 */
 
 DEFUN (ismatrix, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} ismatrix (@var{a})
 Return true if @var{a} is a 2-D array.
@@ -3909,17 +3909,17 @@ Return true if @var{x} is a square matri
 %!assert (! issquare ("test"))
 %!assert (issquare (["test"; "ing"; "1"; "2"]))
 %!test
 %! s.a = 1;
 %! assert (issquare (s));
 %!assert (issquare ({1, 2; 3, 4}))
 %!assert (sparse (([1, 2; 3, 4])))
 
-%% Test input validation
+## Test input validation
 %!error issquare ()
 %!error issquare ([1, 2; 3, 4], 2)
 */
 
 static octave_value
 fill_matrix (const octave_value_list& args, int val, const char *fcn)
 {
   octave_value retval;
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -205,17 +205,17 @@ but avoids forming a temporary array and
 
 %!test
 %! x = int8 ([1 2; 3 4]);
 %! y = int8 ([5 6; 7 8]);
 %! assert (dot (x, y), [26 44]);
 %! assert (dot (x, y, 2), [17; 53]);
 %! assert (dot (x, y, 3), [5 12; 21 32]);
 
-%% Test input validation
+## Test input validation
 %!error dot ()
 %!error dot (1)
 %!error dot (1,2,3,4)
 %!error <X and Y must be numeric> dot ({1,2}, [3,4])
 %!error <X and Y must be numeric> dot ([1,2], {3,4})
 %!error <sizes of X and Y must match> dot ([1 2], [1 2 3])
 %!error <sizes of X and Y must match> dot ([1 2]', [1 2 3]')
 %!error <sizes of X and Y must match> dot (ones (2,2), ones (2,3))
@@ -342,17 +342,17 @@ endfor
 %! x(:,:,1) = [1 2; 3 4];
 %! x(:,:,2) = [1i 1i; 1i 1i];
 %! z(:,:,1) = [7 10; 15 22];
 %! z(:,:,2) = [-2 -2; -2 -2];
 %! assert (blkmm (x,x), z);
 %! assert (blkmm (single (x), single (x)), single (z));
 %! assert (blkmm (x, single (x)), single (z));
 
-%% Test input validation
+## Test input validation
 %!error blkmm ()
 %!error blkmm (1)
 %!error blkmm (1,2,3)
 %!error <A and B dimensions don't match> blkmm (ones (2,2), ones (3,3))
 %!error <A and B must be numeric> blkmm ({1,2}, [3,4])
 %!error <A and B must be numeric> blkmm ([3,4], {1,2})
 */
 
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -174,38 +174,38 @@ If @var{A} is a multi-dimensional matrix
 of @var{A} is treated separately
 @seealso{fft2, ifft, ifftn, fftw}
 @end deftypefn */)
 {
   return do_fft2 (args, "ifft2", 1);
 }
 
 /*
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! M = 16;
 %! N = 8;
 %!
 %! m = 5;
 %! n = 3;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
 %! sx = cos (m*x);
 %! sy = sin (n*y);
 %! s = kron (sx',sy);
 %! S = fft2 (s);
 %! answer = kron (fft (sx)', fft (sy));
 %! assert (S, answer, 4*M*N*eps);
 
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! M = 12;
 %! N = 7;
 %!
 %! m = 3;
 %! n = 2;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
@@ -215,38 +215,38 @@ of @var{A} is treated separately
 %! sy = cos (n*y);
 %!
 %! S = kron (fft (sx)', fft (sy));
 %! answer = kron (sx', sy);
 %! s = ifft2 (S);
 %!
 %! assert (s, answer, 30*eps);
 
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! M = 16;
 %! N = 8;
 %!
 %! m = 5;
 %! n = 3;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
 %! sx = single (cos (m*x));
 %! sy = single (sin (n*y));
 %! s = kron (sx', sy);
 %! S = fft2 (s);
 %! answer = kron (fft (sx)', fft (sy));
 %! assert (S, answer, 4*M*N*eps ("single"));
 
-%% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
-%%         Comalco Research and Technology
-%%         02 May 2000
+## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
+##         Comalco Research and Technology
+##         02 May 2000
 %!test
 %! M = 12;
 %! N = 7;
 %!
 %! m = 3;
 %! n = 2;
 %!
 %! x = single (2*pi*(0:1:M-1)/M);
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1552,22 +1552,22 @@ as the name of the function when reporti
 %! c = textscan ("L1\nL2", "%s");
 %! assert (c{:}, {"L1"; "L2"});
 
 ## Test with EndofLine parameter set to "" (empty) - newline should be in word
 %!test
 %! c = textscan ("L1\nL2", "%s", "endofline", "");
 %! assert (int8 ([c{:}{:}]), int8 ([76, 49, 10, 76, 50]));
 
-###  Matlab fails this test.  A literal after a conversion is not a delimiter
-#%!test
-#%! ## No delimiters at all besides EOL.  Skip fields, even empty fields
-#%! str = "Text1Text2Text\nTextText4Text\nText57Text";
-#%! c = textscan (str, "Text%*dText%dText");
-#%! assert (c{1}, int32 ([2; 4; 0]));
+##  Matlab fails this test.  A literal after a conversion is not a delimiter
+%!#test
+%! ## No delimiters at all besides EOL.  Skip fields, even empty fields
+%! str = "Text1Text2Text\nTextText4Text\nText57Text";
+%! c = textscan (str, "Text%*dText%dText");
+%! assert (c{1}, int32 ([2; 4; 0]));
 
 ## CollectOutput test
 %!test
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
 %! c = textscan (str, fmt, "collectoutput", 1);
@@ -1624,29 +1624,29 @@ as the name of the function when reporti
 
 ## Multi-character delimiter
 %!test
 %! str = "99end2 space88gap 4564";
 %! c = textscan (str, "%d %s", "delimiter", {"end", "gap", "space"});
 %! assert (c{1}, int32 ([99; 88]));
 %! assert (c{2}, {"2 "; "4564"});
 
-## FIXME: Following two tests still fail (4/13/2016)?
-### Delimiters as part of literals, and following literals
-#%!test
-#%! str = "12 R&D & 7";
-#%! c = textscan (str, "%f R&D %f", "delimiter", "&", "collectOutput", 1,
-#%!                    "EmptyValue", -99);
-#%! assert (c, {[12, -99; 7, -99]});
-#
-### Delimiters as part of literals, and before literals
-#%!test
-#%! str = "12 & R&D 7";
-#%! c = textscan (str, "%f R&D %f", "delimiter", "&", "collectOutput", 1);
-#%! assert (c, {[12 7]});
+## FIXME: Following two tests still fail (4/13/2016).
+## Delimiters as part of literals, and following literals
+%!#test
+%! str = "12 R&D & 7";
+%! c = textscan (str, "%f R&D %f", "delimiter", "&", "collectOutput", 1,
+%!                    "EmptyValue", -99);
+%! assert (c, {[12, -99; 7, -99]});
+
+## Delimiters as part of literals, and before literals
+%!#test
+%! str = "12 & R&D 7";
+%! c = textscan (str, "%f R&D %f", "delimiter", "&", "collectOutput", 1);
+%! assert (c, {[12 7]});
 
 ## Check number of lines read, not number of passes through format string
 %!test
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! fprintf (fid, "1\n2\n3\n4\n5\n6");
 %! fseek (fid, 0, "bof");
 %! c = textscan (fid, "%f %f", 2);
@@ -1735,21 +1735,21 @@ as the name of the function when reporti
 %! assert (c, {[1;4], [NaN;5], [3;6]});
 
 ## Check ReturnOnError in first column
 %!test
 %! c = textscan ("1 2 3\ns 5 6", "", "ReturnOnError", 1);
 %! assert (c, {1, 2, 3});
 
 ## FIXME: This test fails (4/14/16)
-### Test incomplete first data line
-#%!test
-#%! R = textscan (['Empty1' char(10)], 'Empty%d %f');
-#%! assert (R{1}, int32 (1));
-#%! assert (isempty (R{2}), true);
+## Test incomplete first data line
+%!#test
+%! R = textscan (['Empty1' char(10)], 'Empty%d %f');
+%! assert (R{1}, int32 (1));
+%! assert (isempty (R{2}), true);
 
 %!test <37023>
 %! data = textscan ("   1. 1 \n 2 3\n", '%f %f');
 %! assert (data{1}, [1; 2], 1e-15);
 %! assert (data{2}, [1; 3], 1e-15);
 
 ## Whitespace test using delimiter ";"
 %!test <37333>
@@ -1875,17 +1875,17 @@ as the name of the function when reporti
 
 %!test
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! msg1 = "textscan: 1 parameters given, but only 0 values";
 %! try
 %!   C = textscan (fid, "", "headerlines");
 %! end_try_catch;
-%! assert (!feof (fid));
+%! assert (! feof (fid));
 %! fclose (fid);
 %! unlink (f);
 %! assert (msg1, lasterr);
 
 %!test
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! msg1 = "textscan: HeaderLines must be numeric";
@@ -1977,24 +1977,25 @@ as the name of the function when reporti
 %! assert (c{2}', [12, 22]);
 %! assert (c{3}', [13, 23]);
 
 %!test <44750>
 %! c = textscan ("/home/foo/", "%s", "delimiter", "/",
 %!               "MultipleDelimsAsOne", 1);
 %! assert (c{1}, {"home"; "foo"});
 
-## FIXME: Test still fails (4/13/2016)?
+## FIXME: Test still fails (4/13/2016).
 ## Allow cuddling %sliteral, but warn it is ambiguous
-#%!test
-#%! C = textscan ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
-#%! assert (C{1}([1 3]), {"abc"; "##"});
-#%! assert (isempty (C{1}{2}), true);
-#%! assert (C{2}, int32 ([51; 83; 101]));
-### Literals are not delimiters.
+%!#test
+%! C = textscan ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
+%! assert (C{1}([1 3]), {"abc"; "##"});
+%! assert (isempty (C{1}{2}), true);
+%! assert (C{2}, int32 ([51; 83; 101]));
+
+## Literals are not delimiters.
 
 ## Test for false positives in check for non-supported format specifiers
 %!test
 %! c = textscan ("Total: 32.5 % (of cm values)",
 %!               "Total: %f %% (of cm values)");
 %! assert (c{1}, 32.5, 1e-5);
 
 ## Test various forms of string format specifiers
@@ -2104,17 +2105,17 @@ as the name of the function when reporti
 %! C = textscan ("+i +in +inf +infinity", "%f %f%s %f %f %s", "ExpChars", "eE");
 %! assert (C, {i, i, {"n"}, Inf, Inf, {"inity"}});
 
 ## Check single quoted format interprets control sequences
 %!test
 %! C = textscan ("1 2\t3 4", '%f %[^\t] %f %f');
 %! assert (C, {1, {"2"}, 3, 4});
 
-%% Check a non-empty line with no valid conversion registers empytValue
+## Check a non-empty line with no valid conversion registers empytValue
 %!test
 %! C = textscan ("Empty\n", "Empty%f %f");
 %! assert (C, { NaN, NaN });
 
 ## Check overflow and underflow of integer types
 %!test
 %! a = "-1e90 ";
 %! b = "1e90 ";
@@ -2182,20 +2183,20 @@ as the name of the function when reporti
 %! unlink (f);
 %! assert (C{1}, {"abc";"def"});
 %! assert (C{2}, [2; NaN]);
 %! assert (C{3}, [NaN; 5]);
 %! assert (C{4}, [3; 6]);
 %! assert (C{5}, [4; 7]);
 
 ## FIXME: Almost passes.  Second return value is {"/"}.  Tested 4/14/16.
-### Test start of comment as string
-#%!test
-#%! c = textscan ("1 / 2 // 3", "%n %s %u8", "CommentStyle", {"//"});
-#%! assert (c(1), {1, "/", 2});
+## Test start of comment as string
+%!#test
+%! c = textscan ("1 / 2 // 3", "%n %s %u8", "CommentStyle", {"//"});
+%! assert (c(1), {1, "/", 2});
 
 %!assert (textscan (["1 2 3 4"; "5 6 7 8"], "%f"), {[15; 26; 37; 48]})
 
 ## Check for delimiter after exponent
 %!assert (textscan ("1e-3|42", "%f", "delimiter", "|"), {[1e-3; 42]})
 */
 
 // These tests have end-comment sequences, so can't just be in a comment
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -593,17 +593,17 @@ filter (MArray<FloatComplex>&, MArray<Fl
 %! y0 = zeros (4,4,2);  y0(1:2,1:4,1) = +1;  y0(1:2,1:4,2) = -1;
 %! y = filter (b, [1], x);
 %! assert (y, y0);
 
 %!assert (filter (1, ones (10,1) / 10, []), [])
 %!assert (filter (1, ones (10,1) / 10, zeros (0,10)), zeros (0,10))
 %!assert (filter (1, ones (10,1) / 10, single (1:5)), repmat (single (10), 1, 5))
 
-%% Test using initial conditions
+## Test using initial conditions
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]), [2 2])
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]'), [2 2])
 %!assert (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]), [5 7; 6 10; 14 18])
 %!error (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'))
 %!assert (filter ([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21])
 
 ## Test of DIM parameter
 %!test
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -6274,19 +6274,19 @@ axes::properties::update_font (std::stri
         }
       else if (prop == "fontweight")
         tval = get ("titlefontweight");
 
       gh_manager::get_object (get_xlabel ()).set (prop, val);
       gh_manager::get_object (get_ylabel ()).set (prop, val);
       gh_manager::get_object (get_zlabel ()).set (prop, val);
       gh_manager::get_object (get_title ()).set (prop, tval);
-        
-    }
-  
+
+    }
+
   txt_renderer.set_font (get ("fontname").string_value (),
                          get ("fontweight").string_value (),
                          get ("fontangle").string_value (),
                          get ("__fontsize_points__").double_value ());
 }
 
 // The INTERNAL flag defines whether position or outerposition is used.
 
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -306,19 +306,18 @@ Since the Kronecker product is associati
 %!assert (kron (x, y, z), kron (x, kron (y, z)))
 %!assert (kron (p1, p1), kron (p2, p2))
 %!assert (kron (p1, p2), kron (p2, p1))
 %!assert (kron (d1, d1), kron (d2, d2))
 %!assert (kron (d1, d2), kron (d2, d1))
 
 %!assert (kron (diag ([1, 2]), diag ([3, 4])), diag ([3, 4, 6, 8]))
 
-%% Test for two diag matrices.  See the comments above in
-%% dispatch_kron for this case.
-%%
+## Test for two diag matrices.
+## See the comments above in dispatch_kron for this case.
 %!test
 %! expected = zeros (16, 16);
 %! expected (1, 11) = 3;
 %! expected (2, 12) = 4;
 %! expected (5, 15) = 6;
 %! expected (6, 16) = 8;
 %! assert (kron (diag ([1, 2], 2), diag ([3, 4], 2)), expected);
 */
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3480,17 +3480,17 @@ namespace octave
           {
             if (! elem->discard)
               no_conversions = false;
           }
         else
           {
             is.clear (is.rdstate () & ~std::ios::failbit);
 
-            if (!is.eof () && ~is_delim (is.peek ()))
+            if (! is.eof () && ~is_delim (is.peek ()))
               this_conversion_failed = true;
           }
 
         if (! elem->discard)
           out++;
 
         elem = fmt_list.next ();
         char *pos = is.tellg ();
@@ -3517,17 +3517,17 @@ namespace octave
               {
                 // done_after = first failure
                 done_after = i; // note fail, but parse others to get empty_val
                 conversion_failed = true;
               }
             else
               this_conversion_failed = false;
           }
-        else if (! done && !conversion_failed)
+        else if (! done && ! conversion_failed)
           nothing_worked = false;
       }
 
     if (done)
       is.setstate (std::ios::eofbit);
 
     return no_conversions
            + (is.eof () ? 2 : 0)
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -2206,17 +2206,17 @@ Mathematical Software, Vol. 37, Issue 3,
 %!  y(idx < 1e-10) = NaN;
 %!endfunction
 
 %!test
 %! [q, err, npoints] = quadcc ("__nansin", -pi, pi);
 %! assert (q, 0, 1e-6);
 %! assert (err, 0, 15*eps);
 
-%% Test input validation
+## Test input validation
 %!error (quadcc ())
 %!error (quadcc (@sin))
 %!error (quadcc (@sin, 0))
 %!error (quadcc (@sin, ones (2), pi))
 %!error (quadcc (@sin, -i, pi))
 %!error (quadcc (@sin, 0, ones (2)))
 %!error (quadcc (@sin, 0, i))
 %!error (quadcc (@sin, 0, pi, 0))
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -189,17 +189,17 @@ longer running time.
 %! assert (vals, [0 1 1 0 3 3 0.5 1.0 1.0 0.1 0.5 1.0 0.001]');
 %! spparms ([3 2 1]);
 %! assert (spparms ()(1:3), [3, 2, 1]');
 %! assert (spparms ("ths_rel"), 2);
 %! spparms ("exact_d", 5);
 %! assert (spparms ("exact_d"), 5);
 %! spparms (old_vals);     # restore state
 
-%% Test input validation
+## Test input validation
 %!error <too many input arguments> spparms (1, 2, 3)
 %!error <too many output arguments> [x, y, z] = spparms ()
 %!error <KEY not recognized> spparms ("UNKNOWN_KEY")
 %!#error <input must be a string> spparms ({1, 2, 3})
 %!error spparms ({1, 2, 3})
 %!error <too many elements in vector VALS> spparms (ones (14, 1))
 %!error <first argument must be a string> spparms (1, 1)
 %!#error <second argument must be a real scalar> spparms ("ths_rel", "hello")
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -151,17 +151,17 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
 
   return retval;
 }
 
 /*
 %!assert (sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12]), [1/2, 2/3; 2/3, 1/2], sqrt (eps))
 %!assert (sylvester (single ([1, 2; 3, 4]), single ([5, 6; 7, 8]), single ([9, 10; 11, 12])), single ([1/2, 2/3; 2/3, 1/2]), sqrt (eps ("single")))
 
-%% Test input validation
+## Test input validation
 %!error sylvester ()
 %!error sylvester (1)
 %!error sylvester (1,2)
 %!error sylvester (1, 2, 3, 4)
 %!error <A must be a square matrix> sylvester (ones (2,3), ones (2,2), ones (2,2))
 %!error <B must be a square matrix> sylvester (ones (2,2), ones (2,3), ones (2,2))
 %!error <nonconformant matrices> sylvester (ones (2,2), ones (2,2), ones (3,3))
 */
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -305,17 +305,17 @@ convex hull is calculated.
 /*
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "Qt");
 %! assert (size (h), [12 3]);
 %! h = sortrows (sort (h, 2), [1:3]);
 %! assert (h, [1 2 4; 1 2 6; 1 4 8; 1 5 6; 1 5 8; 2 3 4; 2 3 7; 2 6 7; 3 4 7; 4 7 8; 5 6 7; 5 7 8]);
 %! assert (v, 1, 10*eps);
-%! [h2, v2] = convhulln (cube); % Test defaut option = "Qt"
+%! [h2, v2] = convhulln (cube);  # Test default option = "Qt"
 %! assert (size (h2), size (h));
 %! h2 = sortrows (sort (h2, 2), [1:3]);
 %! assert (h2, h);
 %! assert (v2, v, 10*eps);
 
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "QJ");
@@ -326,13 +326,13 @@ convex hull is calculated.
 %!testif HAVE_QHULL
 %! tetrahedron = [1 1 1;-1 -1 1;-1 1 -1;1 -1 -1];
 %! [h, v] = convhulln (tetrahedron);
 %! h = sortrows (sort (h, 2), [1 2 3]);
 %! assert (h, [1 2 3;1 2 4; 1 3 4; 2 3 4]);
 %! assert (v, 8/3, 10*eps);
 
 %!testif HAVE_QHULL
-%! triangle=[0 0; 1 1; 1 0; 1 2];
+%! triangle = [0 0; 1 1; 1 0; 1 2];
 %! h = convhulln (triangle);
 %! assert (size (h), [3 2]);
 */
 
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -807,17 +807,17 @@ permutation vector instead of a permutat
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = sprandn (n,n,d) + speye (n,n);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
 %! assert (r\c, full (a)\b, 10e-10);
 
-%% Test under-determined systems!!
+## Test under-determined systems!!
 %!#testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = sprandn (n,n+1,d) + speye (n,n+1);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
 %! assert (r\c, full (a)\b, 10e-10);
 
 %!testif HAVE_CXSPARSE
@@ -842,17 +842,17 @@ permutation vector instead of a permutat
 
 %!testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = 1i*sprandn (n,n,d) + speye (n,n);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
 %! assert (r\c, full (a)\b, 10e-10);
 
-%% Test under-determined systems!!
+## Test under-determined systems!!
 %!#testif HAVE_CXSPARSE
 %! n = 20;  d = 0.2;
 %! a = 1i*sprandn (n,n+1,d) + speye (n,n+1);
 %! b = randn (n,2);
 %! [c,r] = qr (a, b);
 %! assert (r\c, full (a)\b, 10e-10);
 
 */
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1780,17 +1780,17 @@ is derived.
 %!assert (class (uint8 (1)), "uint8")
 %!testif HAVE_JAVA
 %! if (! usejava ("jvm"))
 %!   return;
 %! endif
 %! jobj = javaObject ("java.lang.StringBuffer");
 %! assert (class (jobj), "java.lang.StringBuffer");
 
-%% Test Input Validation
+## Test Input Validation
 %!error class ()
 */
 
 DEFUN (isa, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isa (@var{obj}, @var{classname})
 Return true if @var{obj} is an object from the class @var{classname}.
 
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -370,17 +370,17 @@ octave_complex_matrix::load_ascii (std::
 
       if (! is)
         error ("load: failed to read dimensions");
 
       ComplexNDArray tmp(dv);
 
       is >> tmp;
 
-      if (!is)
+      if (! is)
         error ("load: failed to load matrix constant");
 
       matrix = tmp;
     }
   else if (kw == "rows")
     {
       octave_idx_type nr = val;
       octave_idx_type nc = 0;
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -1118,28 +1118,28 @@ element-by-element and a logical array i
 %! assert (x, -1);
 %!
 %!test
 %! [~, y] = try_isargout ();
 %! assert (y, -2);
 %!
 %!error [~, ~] = try_isargout ()
 %!
-%% Check to see that isargout isn't sticky:
+## Check to see that isargout isn't sticky:
 %!test
 %! [x, y] = try_isargout ();
 %! assert ([x, y], [1, 2]);
 %!
-%% It should work without ():
+## It should work without ():
 %!test
 %! [~, y] = try_isargout;
 %! assert (y, -2);
 %!
-%% It should work in function handles, anonymous functions, and cell
-%% arrays of handles or anonymous functions.
+## It should work in function handles, anonymous functions, and cell
+## arrays of handles or anonymous functions.
 %!test
 %! fh = @try_isargout;
 %! af = @() try_isargout;
 %! c = {fh, af};
 %! [~, y] = fh ();
 %! assert (y, -2);
 %! [~, y] = af ();
 %! assert (y, -2);
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -68,17 +68,17 @@ public:
       bp = new std::string(condition);
   }
 
   virtual void delete_breakpoint (void) { if (bp) delete bp; bp = NULL; }
 
   bool meets_bp_condition (void) const;
 
   bool is_breakpoint (bool check_active = false) const
-  { return bp && (!check_active || meets_bp_condition ()); }
+  { return bp && (! check_active || meets_bp_condition ()); }
 
   // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
   // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
   const std::string bp_cond (void) const
   { return bp ? *bp : std::string("0"); }
 
   std::string str_print_code (void);
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -1716,18 +1716,18 @@ Array<T>::hermitian (T (*fcn) (const T&)
           result.xelem (j, i) = fcn (xelem (i, j));
 
       return result;
     }
 }
 
 /*
 
-%% Tranpose tests for matrices of the tile size and plus or minus a row
-%% and with four tiles.
+## Tranpose tests for matrices of the tile size and plus or minus a row
+## and with four tiles.
 
 %!shared m7, mt7, m8, mt8, m9, mt9
 %! m7 = reshape (1 : 7*8, 8, 7);
 %! mt7 = [1:8; 9:16; 17:24; 25:32; 33:40; 41:48; 49:56];
 %! m8 = reshape (1 : 8*8, 8, 8);
 %! mt8 = mt8 = [mt7; 57:64];
 %! m9 = reshape (1 : 9*8, 8, 9);
 %! mt9 = [mt8; 65:72];
diff --git a/liboctave/numeric/gsvd.h b/liboctave/numeric/gsvd.h
--- a/liboctave/numeric/gsvd.h
+++ b/liboctave/numeric/gsvd.h
@@ -10,17 +10,17 @@
 // This program is distributed in the hope that it will be useful, but WITHOUT
 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 // FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 // details.
 //
 // You should have received a copy of the GNU General Public License along with
 // this program; if not, see <http://www.gnu.org/licenses/>.
 
-#if !defined (octave_gsvd_h)
+#if ! defined (octave_gsvd_h)
 #define octave_gsvd_h 1
 
 #include "octave-config.h"
 
 namespace octave
 {
   namespace math
   {
diff --git a/scripts/gui/inputdlg.m b/scripts/gui/inputdlg.m
--- a/scripts/gui/inputdlg.m
+++ b/scripts/gui/inputdlg.m
@@ -187,34 +187,34 @@ endfunction
 %!    helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', ...
 %!                      volume, surface), 'Box Dimensions');
 %! endif
 
 %!demo
 %! disp ('- test inputdlg with prescribed vector [1,2,3] for # of lines per text field and defaults.');
 %! prompt = {'Width', 'Height', 'Depth'};
 %! default = {'1.10', '2.10', '3.10'};
-%! rc = [1,2,3];  % NOTE: must be an array
+%! rc = [1,2,3];  # NOTE: must be an array
 %! dims = inputdlg (prompt, 'Enter Box Dimensions', rc, default);
 %! if (isempty (dims))
 %!   helpdlg ('Canceled by user', 'Information');
 %! else
 %!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
 %!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
 %!                  str2num (dims{2}) * str2num (dims{3}) + ...
 %!                  str2num (dims{1}) * str2num (dims{3}));
 %!   helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', ...
 %!                     volume, surface), 'Box Dimensions');
 %! endif
 
 %!demo
 %! disp ('- test inputdlg with prescribed row by column sizes and defaults.');
 %! prompt = {'Width', 'Height', 'Depth'};
 %! default = {'1.10', '2.20', '3.30'};
-%! rc = [1,10; 2,20; 3,30];  % NOTE: must be an array
+%! rc = [1,10; 2,20; 3,30];  # NOTE: must be an array
 %! dims = inputdlg (prompt, 'Enter Box Dimensions', rc, default);
 %! if (isempty (dims))
 %!   helpdlg ('Canceled by user', 'Information');
 %! else
 %!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
 %!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
 %!                  str2num (dims{2}) * str2num (dims{3}) + ...
 %!                  str2num (dims{1}) * str2num (dims{3}));
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -160,17 +160,17 @@ function [Uret, H, nu] = krylov (A, V, k
         jdx = pivot_vec(1:nu);
 
         [hv, av, z] = housh (q(idx), 1, 0);
         alpha(nu) = av;
         U(idx,nu) = hv;
 
         ## Reduce V per the reflection.
         V(idx,:) = V(idx,:) - av*hv*(hv' * V(idx,:));
-        if(iter > 1)
+        if (iter > 1)
           ## FIXME: not done correctly for block case.
           H(nu,nu-1) = V(pivot_vec(nu),jj);
         endif
 
         ## Advance to next column of V.
         jj += 1;
       endif
     endwhile
diff --git a/scripts/plot/draw/shrinkfaces.m b/scripts/plot/draw/shrinkfaces.m
--- a/scripts/plot/draw/shrinkfaces.m
+++ b/scripts/plot/draw/shrinkfaces.m
@@ -193,17 +193,17 @@ endfunction
 %! fv = shrinkfaces (p);
 %! patch (fv);
 %! axis auto;   # Kludge required for Octave
 %! axis equal;
 %! grid on;
 
 %!demo
 %! clf;
-%! N = 10;  % N intervals per axis
+%! N = 10;  # N intervals per axis
 %! [x, y, z] = meshgrid (linspace (-4,4,N+1));
 %! val = x.^3 + y.^3 + z.^3;
 %! fv = isosurface (x, y, z, val, 3, z, "noshare");
 %!
 %! p = patch ("Faces", fv.faces, "Vertices", fv.vertices, "FaceVertexCData", ...
 %!            fv.facevertexcdata, "FaceColor", "interp", "EdgeColor", "black");
 %! axis auto;   # Kludge required for Octave
 %! axis equal;
diff --git a/scripts/polynomial/padecoef.m b/scripts/polynomial/padecoef.m
--- a/scripts/polynomial/padecoef.m
+++ b/scripts/polynomial/padecoef.m
@@ -160,17 +160,17 @@ endfunction
 %! n_exp ./= d_exp(1);
 %! d_exp ./= d_exp(1);
 %! [n_obs, d_obs] = padecoef (T, N);
 %! assert ([n_obs, d_obs], [n_exp, d_exp], 1e-2);
 
 ## For checking in Wolfram Alpha (look at Alternate forms -> more):
 ## PadeApproximant[Exp[-x * T], {x, 0, {n, n}}]
 
-%% Test input validation
+## Test input validation
 %!error padecoef ()
 %!error padecoef (1,2,3)
 %!error <T must be a non-negative scalar> padecoef ([1,2])
 %!error <T must be a non-negative scalar> padecoef ({1})
 %!error <T must be a non-negative scalar> padecoef (-1)
 %!error <N must be a non-negative scalar> padecoef (1, [1,2])
 %!error <N must be a non-negative scalar> padecoef (1, {1})
 %!error <N must be a non-negative scalar> padecoef (1, -1)
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -56,17 +56,17 @@ function y = polyout (c, x)
 
   if (nargin == 1)
     x = "s";
   elseif (! ischar (x))
     error ("polyout: second argument must be a string");
   endif
 
   n = length (c);
-  if(n > 0)
+  if (n > 0)
     n1 = n+1;
 
     tmp = coeff (c(1));
     for ii = 2:n
       if (real (c(ii)) < 0)
         ns = " - ";
         c(ii) = -c(ii);
       else
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -63,17 +63,17 @@ function [newphi, newv] = durbinlevinson
 
     newphi = zeros (1, t);
     newphi(1) = (c(t+1) - oldphi * c(2:t)) / oldv;
     for i = 2 : t
       newphi(i) = oldphi(i-1) - newphi(1) * oldphi(t-i+1);
     endfor
     newv = (1 - newphi(1)^2) * oldv;
 
-  elseif(nargin == 1)
+  elseif (nargin == 1)
 
     tt = length (c)-1;
     oldphi = c(2) / c(1);
     oldv = (1 - oldphi^2) * c(1);
 
     for t = 2 : tt
 
       newphi = zeros (1, t);
