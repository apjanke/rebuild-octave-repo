# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1492662059 14400
#      Thu Apr 20 00:20:59 2017 -0400
# Node ID d24d01273bd031b3f805d072177a6098a42a3f2c
# Parent  442fe5b5afb543f298292bdd1e119d810f103332
eliminate load-path singleton

* load-path.h, load-path.cc (class load_path): Don't use singleton
idiom.

* interpreter-private.h, interpreter-private.cc: New files.

* interpreter.cc, interpreter.h (interpreter::m_load_path):
New data member.  Manage initialization of load_path in interpreter
class.
(interpreter::get_load_path): New method.

Change all uses of static load_path methods to use global load_path
object instead.

diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include <QPushButton>
 
 #include "oct-env.h"
 #include "str-vec.h"
 
 #include "builtin-defun-decls.h"
 #include "dialog.h"
 #include "error.h"
+#include "interpreter-private.h"
 #include "load-path.h"
 #include "utils.h"
 
 #include "octave-gui.h"
 #include "octave-qt-link.h"
 #include "resource-manager.h"
 #include "workspace-element.h"
 
@@ -558,24 +559,26 @@ octave_qt_link::file_in_path (const std:
   bool addpath_option = true;
 
   std::string curr_dir = octave::sys::env::get_current_directory ();
 
   if (same_file (curr_dir, dir))
     ok = true;
   else
     {
-      bool dir_in_load_path = load_path::contains_canonical (dir);
+      load_path& lp = octave::__get_load_path__ ("octave_qt_link::file_in_path");
+
+      bool dir_in_load_path = lp.contains_canonical (dir);
 
       // get base name, allowing "@class/method.m" (bug #41514)
       std::string base_file = (file.length () > dir.length ())
                               ? file.substr (dir.length () + 1)
                               : octave::sys::env::base_pathname (file);
 
-      std::string lp_file = load_path::find_file (base_file);
+      std::string lp_file = lp.find_file (base_file);
 
       if (dir_in_load_path)
         {
           if (same_file (lp_file, file))
             ok = true;
         }
       else
         {
@@ -601,18 +604,22 @@ octave_qt_link::file_in_path (const std:
       switch (action)
         {
         case 1:
           Fcd (ovl (dir));
           ok = true;
           break;
 
         case 2:
-          load_path::prepend (dir);
-          ok = true;
+          {
+            load_path& lp = octave::__get_load_path__ ("octave_qt_link::file_in_path");
+
+            lp.prepend (dir);
+            ok = true;
+          }
           break;
 
         default:
           break;
         }
     }
 
   return ok;
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -50,16 +50,17 @@ along with Octave; see the file COPYING.
 #include "input.h"
 #include "load-path.h"
 #include "octave.h"
 #include "octave-link.h"
 #include "ovl.h"
 #include "pager.h"
 #include "procstream.h"
 #include "sysdep.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means we ask for confirmation before recursively removing a
 // directory tree.
 static bool Vconfirm_recursive_rmdir = true;
@@ -77,17 +78,19 @@ octave_change_to_directory (const std::s
   if (! cd_ok)
     error ("%s: %s", newdir.c_str (), std::strerror (errno));
 
   Vlast_chdir_time.stamp ();
 
   // FIXME: should these actions be handled as a list of functions
   // to call so users can add their own chdir handlers?
 
-  load_path::update ();
+  load_path& lp = octave::__get_load_path__ ("octave_change_to_directory");
+
+  lp.update ();
 
   octave_link::change_directory (octave::sys::env::get_current_directory ());
 
   return cd_ok;
 }
 
 DEFUN (cd, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -45,16 +45,17 @@ along with Octave; see the file COPYING.
 #include "builtin-defun-decls.h"
 #include "call-stack.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "errwarn.h"
 #include "help.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "ovl.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
@@ -187,17 +188,19 @@ make_name_list (void)
   const int bif_len = bif.numel ();
 
   const string_vector cfl = symbol_table::cmdline_function_names ();
   const int cfl_len = cfl.numel ();
 
   const string_vector lcl = symbol_table::variable_names ();
   const int lcl_len = lcl.numel ();
 
-  const string_vector ffl = load_path::fcn_names ();
+  load_path& lp = octave::__get_load_path__ ("make_name_list");
+
+  const string_vector ffl = lp.fcn_names ();
   const int ffl_len = ffl.numel ();
 
   const string_vector afl = octave::autoloaded_functions ();
   const int afl_len = afl.numel ();
 
   const string_vector lfl = local_functions ();
   const int lfl_len = lfl.numel ();
 
@@ -726,28 +729,32 @@ do_which (const std::string& name, std::
                 type = val.is_user_script ()
                        ? std::string ("script") : std::string ("function");
             }
         }
       else
         {
           // We might find a file that contains only a doc string.
 
-          file = load_path::find_fcn_file (name);
+          load_path& lp = octave::__get_load_path__ ("do_which");
+
+          file = lp.find_fcn_file (name);
         }
     }
   else
     {
       // File query.
 
+      load_path& lp = octave::__get_load_path__ ("do_which");
+
       // For compatibility: "file." queries "file".
       if (name.size () > 1 && name[name.size () - 1] == '.')
-        file = load_path::find_file (name.substr (0, name.size () - 1));
+        file = lp.find_file (name.substr (0, name.size () - 1));
       else
-        file = load_path::find_file (name);
+        file = lp.find_file (name);
 
       file = octave::sys::env::make_absolute (file);
     }
 
   return file;
 }
 
 std::string
@@ -832,29 +839,31 @@ Return a list of all functions (.m and .
 
 If the optional argument @var{directory} is given then list only the functions
 in that directory.
 @seealso{path}
 @end deftypefn */)
 {
   octave_value retval;
 
+  load_path& lp = octave::__get_load_path__ ("__list_functions__");
+
   if (args.length () == 0)
     {
       // Get list of all functions
-      string_vector ffl = load_path::fcn_names ();
+      string_vector ffl = lp.fcn_names ();
       string_vector afl = octave::autoloaded_functions ();
 
       retval = Cell (ffl.append (afl));
     }
   else
     {
       std::string dir = args(0).xstring_value ("__list_functions__: DIRECTORY argument must be a string");
 
-      string_vector fl = load_path::files (dir, true);
+      string_vector fl = lp.files (dir, true);
 
       // Return a sorted list with unique entries (in case of .m and .oct
       // versions of the same function in a given directory, for example).
       fl.sort (true);
 
       retval = Cell (fl);
     }
 
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -45,16 +45,17 @@ along with Octave; see the file COPYING.
 #include "call-stack.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "errwarn.h"
 #include "help.h"
 #include "hook-fcn.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave.h"
 #include "octave-link.h"
 #include "oct-map.h"
 #include "oct-hist.h"
 #include "interpreter.h"
@@ -275,17 +276,19 @@ namespace octave
 
     retval = interactive_input (prompt, eof);
 
     // There is no need to update the load_path cache if there is no
     // user input.
     if (retval != "\n"
         && retval.find_first_not_of (" \t\n\r") != std::string::npos)
       {
-        load_path::update ();
+        load_path& lp = octave::__get_load_path__ ("base_reader::octave_gets");
+
+        lp.update ();
 
         if (Vdebugging)
           last_debugging_command = retval;
         else
           last_debugging_command = "\n";
       }
     else if (Vdebugging)
       {
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -0,0 +1,51 @@
+/*
+
+Copyright (C) 2017 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include <string>
+
+#include "error.h"
+#include "interpreter-private.h"
+#include "octave.h"
+
+namespace octave
+{
+  interpreter& __get_interpreter__ (const std::string& who)
+  {
+    interpreter *interp = octave::application::the_interpreter ();
+
+    if (! interp)
+      error ("%s: interpreter context missing", who.c_str ());
+
+    return *interp;
+  }
+
+  load_path& __get_load_path__ (const std::string& who)
+  {
+    interpreter& interp = __get_interpreter__ (who);
+
+    return interp.get_load_path ();
+  }
+}
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/interpreter-private.h
@@ -0,0 +1,40 @@
+/*
+
+Copyright (C) 2017 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_interpreter_private_h)
+#define octave_interpreter_private_h 1
+
+#include "octave-config.h"
+
+#include <string>
+
+#include "interpreter.h"
+
+namespace octave
+{
+  // Expect these functions to change without warning.
+  extern interpreter& __get_interpreter__ (const std::string& who);
+
+  extern load_path& __get_load_path__ (const std::string& who);
+}
+
+#endif
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -42,16 +42,17 @@ along with Octave; see the file COPYING.
 #include "builtins.h"
 #include "defaults.h"
 #include "Cell.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
 #include "file-io.h"
 #include "graphics.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "load-save.h"
 #include "octave-link.h"
 #include "octave.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "oct-mutex.h"
@@ -337,19 +338,21 @@ safe_source_file (const std::string& fil
   return 0;
 }
 
 static void
 execute_pkg_add (const std::string& dir)
 {
   std::string file_name = octave::sys::file_ops::concat (dir, "PKG_ADD");
 
+  load_path& lp = octave::__get_load_path__ ("execute_pkg_add");
+
   try
     {
-      load_path::execute_pkg_add (dir);
+      lp.execute_pkg_add (dir);
     }
   catch (const octave::interrupt_exception&)
     {
       octave::interpreter::recover_from_exception ();
     }
   catch (const octave::execution_exception&)
     {
       octave::interpreter::recover_from_exception ();
@@ -361,17 +364,17 @@ namespace octave
   tree_evaluator *current_evaluator = 0;
 
   // Create an interpreter object and perform initialization up to the
   // point of setting reading command history and setting the load
   // path.
 
   interpreter::interpreter (application *app_context)
     : m_app_context (app_context), m_evaluator (new tree_evaluator (this)),
-      m_interactive (false), m_read_site_files (true),
+      m_load_path (), m_interactive (false), m_read_site_files (true),
       m_read_init_files (m_app_context != 0), m_verbose (false),
       m_inhibit_startup_message (false), m_load_path_initialized (false),
       m_history_initialized (false), m_initialized (false)
   {
     current_evaluator = m_evaluator;
 
     // This should probably happen early.
     sysdep_init ();
@@ -441,17 +444,17 @@ namespace octave
 
         m_app_context->intern_argv (options.all_args ());
 
         bool is_octave_program = m_app_context->is_octave_program ();
 
         std::list<std::string> command_line_path = options.command_line_path ();
 
         for (const auto& pth : command_line_path)
-          load_path::set_command_line_path (pth);
+          m_load_path.set_command_line_path (pth);
 
         std::string exec_path = options.exec_path ();
         if (! exec_path.empty ())
           set_exec_path (exec_path);
 
         std::string image_path = options.image_path ();
         if (! image_path.empty ())
           set_image_path (image_path);
@@ -556,21 +559,22 @@ namespace octave
         // not stop executing PKG_ADD files at the first exception.
         // It's also better than changing the default execute_pkg_add
         // function to use safe_source file because that will normally
         // be evaluated from the normal intepreter loop where exceptions
         // are already handled.
 
         octave::unwind_protect frame;
 
-        frame.add_fcn (load_path::set_add_hook, load_path::get_add_hook ());
+        frame.add_method (m_load_path, &load_path::set_add_hook,
+                          m_load_path.get_add_hook ());
 
-        load_path::set_add_hook (execute_pkg_add);
+        m_load_path.set_add_hook (execute_pkg_add);
 
-        load_path::initialize (set_initial_path);
+        m_load_path.initialize (set_initial_path);
 
         m_load_path_initialized = true;
       }
   }
 
   // This may be called separately from execute
 
   int interpreter::initialize (void)
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -25,16 +25,18 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "quit.h"
 #include "str-vec.h"
 
+#include "load-path.h"
+
 extern OCTINTERP_API bool quit_allowed;
 
 // TRUE means we are ready to interpret commands, but not everything
 // is ready for interactive use.
 extern OCTINTERP_API bool octave_interpreter_ready;
 
 // TRUE means we've processed all the init code and we are good to go.
 extern OCTINTERP_API bool octave_initialized;
@@ -125,16 +127,21 @@ namespace octave
       m_inhibit_startup_message = flag;
     }
 
     bool initialized (void) const
     {
       return m_initialized;
     }
 
+    load_path& get_load_path (void)
+    {
+      return m_load_path;
+    }
+
     static void recover_from_exception (void);
 
     static void add_atexit_function (const std::string& fname);
 
     static bool remove_atexit_function (const std::string& fname);
 
   private:
 
@@ -151,16 +158,18 @@ namespace octave
     int main_loop (void);
 
     void cleanup (void);
 
     application *m_app_context;
 
     tree_evaluator *m_evaluator;
 
+    load_path m_load_path;
+
     // TRUE means this is an interactive interpreter (forced or not).
     bool m_interactive;
 
     bool m_read_site_files;
 
     bool m_read_init_files;
 
     bool m_verbose;
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -1,62 +1,1119 @@
 /*
 
-Copyright (C) 2006-2017 John W. Eaton
-Copyright (C) 2010 VZLU Prague
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3 of the License, or
-(at your option) any later version.
-
-Octave is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
+  Copyright (C) 2006-2017 John W. Eaton
+  Copyright (C) 2010 VZLU Prague
+
+  This file is part of Octave.
+
+  Octave is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 3 of the License, or
+  (at your option) any later version.
+
+  Octave is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with Octave; see the file COPYING.  If not, see
+  <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <algorithm>
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
 #include "pathsearch.h"
-#include "singleton-cleanup.h"
 
 #include "defaults.h"
 #include "defun.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
-load_path *load_path::instance = 0;
-load_path::hook_fcn_ptr load_path::add_hook = load_path::execute_pkg_add;
-load_path::hook_fcn_ptr load_path::remove_hook = load_path::execute_pkg_del;
-std::string load_path::command_line_path;
 std::string load_path::sys_path;
 load_path::abs_dir_cache_type load_path::abs_dir_cache;
 
+static void
+maybe_add_path_elts (std::string& path, const std::string& dir)
+{
+  std::string tpath = genpath (dir);
+
+  if (! tpath.empty ())
+    {
+      if (path.empty ())
+        path = tpath;
+      else
+        path += octave::directory_path::path_sep_str () + tpath;
+    }
+}
+
+static std::list<std::string>
+split_path (const std::string& p)
+{
+  std::list<std::string> retval;
+
+  size_t beg = 0;
+  size_t end = p.find (octave::directory_path::path_sep_char ());
+
+  size_t len = p.length ();
+
+  while (end != std::string::npos)
+    {
+      std::string elt = p.substr (beg, end-beg);
+
+      if (! elt.empty ())
+        retval.push_back (elt);
+
+      beg = end + 1;
+
+      if (beg == len)
+        break;
+
+      end = p.find (octave::directory_path::path_sep_char (), beg);
+    }
+
+  std::string elt = p.substr (beg);
+
+  if (! elt.empty ())
+    retval.push_back (elt);
+
+  return retval;
+}
+
+// Strip trailing directory separators.
+
+static std::string
+strip_trailing_separators (const std::string& dir_arg)
+{
+  std::string dir = dir_arg;
+
+  size_t k = dir.length ();
+
+  while (k > 1 && octave::sys::file_ops::is_dir_sep (dir[k-1]))
+    k--;
+
+  if (k < dir.length ())
+    dir.resize (k);
+
+  return dir;
+}
+
+// Should we cache all files in private directories, or is it OK to just
+// look them up each time as needed?
+
+static std::string
+find_private_file (const std::string& fname)
+{
+  std::string retval;
+
+  // Look in private directory corresponding to current function (if
+  // any).
+
+  octave_user_function *curr_fcn = symbol_table::get_curr_fcn ();
+
+  if (curr_fcn)
+    {
+      // Even for private functions, dir_name doesn't contain the
+      // "private" directory component so we append it here in all
+      // cases.
+
+      std::string dir_name = curr_fcn->dir_name ();
+
+      if (! dir_name.empty ())
+        {
+          std::string pfname = dir_name + octave::sys::file_ops::dir_sep_str ()
+                               + "private" + octave::sys::file_ops::dir_sep_str () + fname;
+
+          octave::sys::file_stat fs (pfname);
+
+          if (fs.exists () && fs.is_reg ())
+            retval = pfname;
+        }
+    }
+
+  return retval;
+}
+
+static void
+execute_pkg_add_or_del (const std::string& dir,
+                        const std::string& script_file)
+{
+  if (! octave_interpreter_ready)
+    return;
+
+  octave::unwind_protect frame;
+
+  std::string file = octave::sys::file_ops::concat (dir, script_file);
+
+  octave::sys::file_stat fs (file);
+
+  if (fs.exists ())
+    octave::source_file (file, "base");
+}
+
+// True if a path is contained in a path list separated by path_sep_char
+
+static bool
+in_path_list (const std::string& path_list, const std::string& path)
+{
+  size_t ps = path.size ();
+  size_t pls = path_list.size ();
+  size_t pos = path_list.find (path);
+  char psc = octave::directory_path::path_sep_char ();
+  while (pos != std::string::npos)
+    {
+      if ((pos == 0 || path_list[pos-1] == psc)
+          && (pos + ps == pls || path_list[pos + ps] == psc))
+        return true;
+      else
+        pos = path_list.find (path, pos + 1);
+    }
+
+  return false;
+}
+
+static void
+rehash_internal (void)
+{
+  load_path& lp = octave::__get_load_path__ ("rehash_internal");
+
+  lp.update ();
+
+  // FIXME: maybe we should rename this variable since it is being
+  // used for more than keeping track of the prompt time.
+
+  // This will force updated functions to be found.
+  Vlast_prompt_time.stamp ();
+}
+
+void
+load_path::initialize (bool set_initial_path)
+{
+  sys_path = "";
+
+  if (set_initial_path)
+    {
+      maybe_add_path_elts (sys_path, Vlocal_ver_oct_file_dir);
+      maybe_add_path_elts (sys_path, Vlocal_api_oct_file_dir);
+      maybe_add_path_elts (sys_path, Vlocal_oct_file_dir);
+      maybe_add_path_elts (sys_path, Vlocal_ver_fcn_file_dir);
+      maybe_add_path_elts (sys_path, Vlocal_api_fcn_file_dir);
+      maybe_add_path_elts (sys_path, Vlocal_fcn_file_dir);
+      maybe_add_path_elts (sys_path, Voct_file_dir);
+      maybe_add_path_elts (sys_path, Vfcn_file_dir);
+      maybe_add_path_elts (sys_path, Voct_data_dir);
+    }
+
+  std::string tpath = load_path::m_command_line_path;
+
+  if (tpath.empty ())
+    tpath = octave::sys::env::getenv ("OCTAVE_PATH");
+
+  std::string xpath;
+
+  if (! tpath.empty ())
+    {
+      xpath = tpath;
+
+      if (! sys_path.empty ())
+        xpath += octave::directory_path::path_sep_str () + sys_path;
+    }
+  else
+    xpath = sys_path;
+
+  set (xpath, false, true);
+}
+
+void
+load_path::clear (void)
+{
+  dir_info_list.clear ();
+
+  top_level_package.clear ();
+
+  package_map.clear ();
+}
+
+void
+load_path::set (const std::string& p, bool warn, bool is_init)
+{
+  // Use a list when we need to preserve order.
+  std::list<std::string> elts = split_path (p);
+
+  // Use a set when we need to search and order is not important.
+  std::set<std::string> elts_set (elts.begin (), elts.end ());
+
+  if (is_init)
+    init_dirs = elts_set;
+  else
+    {
+      for (const auto& init_dir : init_dirs)
+        {
+          if (elts_set.find (init_dir) == elts_set.end ())
+            {
+              warning_with_id ("Octave:remove-init-dir",
+                               "default load path altered.  Some built-in functions may not be found.  Try restoredefaultpath() to recover it.");
+              break;
+            }
+        }
+    }
+
+  // Temporarily disable add hook.
+
+  octave::unwind_protect frame;
+  frame.protect_var (add_hook);
+
+  add_hook = 0;
+
+  clear ();
+
+  for (const auto& elt : elts)
+    append (elt, warn);
+
+  // Restore add hook and execute for all newly added directories.
+  frame.run_first ();
+
+  // FIXME: Shouldn't the test for add_hook be outside the for loop?
+  //        Why not use const here?  Does add_hook change dir_info_list?
+  for (auto& di : dir_info_list)
+    {
+      if (add_hook)
+        add_hook (di.dir_name);
+    }
+
+  // Always prepend current directory.
+  prepend (".", warn);
+}
+
+void
+load_path::append (const std::string& dir, bool warn)
+{
+  if (! dir.empty ())
+    add (dir, true, warn);
+}
+
+void
+load_path::prepend (const std::string& dir, bool warn)
+{
+  if (! dir.empty ())
+    add (dir, false, warn);
+}
+
+bool
+load_path::remove (const std::string& dir_arg)
+{
+  bool retval = false;
+
+  if (! dir_arg.empty ())
+    {
+      if (dir_arg == ".")
+        {
+          warning ("rmpath: can't remove \".\" from path");
+
+          // Avoid additional warnings.
+          retval = true;
+        }
+      else
+        {
+          std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+
+          dir = strip_trailing_separators (dir);
+
+          dir_info_list_iterator i = find_dir_info (dir);
+
+          if (i != dir_info_list.end ())
+            {
+              retval = true;
+
+              if (remove_hook)
+                remove_hook (dir);
+
+              dir_info& di = *i;
+
+              remove (di);
+
+              dir_info_list.erase (i);
+            }
+        }
+    }
+
+  return retval;
+}
+
+void
+load_path::update (void) const
+{
+  // I don't see a better way to do this because we need to
+  // preserve the correct directory ordering for new files that
+  // have appeared.
+
+  top_level_package.clear ();
+
+  package_map.clear ();
+
+  for (auto& di : dir_info_list)
+    {
+      di.update ();
+
+      add (di, true, "", true);
+    }
+}
+
+bool
+load_path::contains_canonical (const std::string& dir) const
+{
+  bool retval = false;
+
+  for (const auto& d : dir_info_list)
+    {
+      if (same_file (dir, d.dir_name))
+        {
+          retval = true;
+          break;
+        }
+    }
+
+  return retval;
+}
+
+std::list<std::string>
+load_path::overloads (const std::string& meth) const
+{
+  std::list<std::string> retval;
+
+  //  update ();
+
+  top_level_package.overloads (meth, retval);
+
+  for (const auto& nm_ldr : package_map)
+    nm_ldr.second.overloads (meth, retval);
+
+  return retval;
+}
+
+std::list<std::string>
+load_path::get_all_package_names (bool only_top_level) const
+{
+  std::list<std::string> retval;
+
+  for (const auto& dir_ldr : package_map)
+    {
+      if (! only_top_level || dir_ldr.first.find ('.') == std::string::npos)
+        retval.push_back (dir_ldr.first);
+    }
+
+  return retval;
+}
+
+std::string
+load_path::find_file (const std::string& file) const
+{
+  std::string retval;
+
+  if (octave::sys::env::absolute_pathname (file)
+      || octave::sys::env::rooted_relative_pathname (file))
+    {
+      octave::sys::file_stat fs (file);
+
+      return fs.exists () ? file : retval;
+    }
+  else
+    {
+      std::string tfile = find_private_file (file);
+
+      if (! tfile.empty ())
+        return tfile;
+    }
+
+  if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+      != std::string::npos)
+    {
+      // Given name has a directory separator, so append it to each
+      // element of the load path in turn.
+      for (const auto& di : dir_info_list)
+        {
+          std::string tfile = octave::sys::file_ops::concat (di.dir_name, file);
+
+          octave::sys::file_stat fs (tfile);
+
+          if (fs.exists ())
+            return tfile;
+        }
+    }
+  else
+    {
+      // Look in cache.
+      for (const auto & di : dir_info_list)
+        {
+          string_vector all_files = di.all_files;
+
+          octave_idx_type len = all_files.numel ();
+
+          for (octave_idx_type i = 0; i < len; i++)
+            {
+              if (all_files[i] == file)
+                return octave::sys::file_ops::concat (di.dir_name, file);
+            }
+        }
+    }
+
+  return retval;
+}
+
+std::string
+load_path::find_dir (const std::string& dir) const
+{
+  std::string retval;
+
+  if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
+      && (octave::sys::env::absolute_pathname (dir)
+          || octave::sys::env::rooted_relative_pathname (dir)))
+    {
+      octave::sys::file_stat fs (dir);
+
+      if (fs.exists () && fs.is_dir ())
+        return dir;
+    }
+  else
+    {
+      for (const auto& di : dir_info_list)
+        {
+          std::string dname = octave::sys::env::make_absolute (di.dir_name);
+
+          size_t dname_len = dname.length ();
+
+          if (dname.substr (dname_len - 1)
+              == octave::sys::file_ops::dir_sep_str ())
+            {
+              dname = dname.substr (0, dname_len - 1);
+              dname_len--;
+            }
+
+          size_t dir_len = dir.length ();
+
+          if (dname_len > dir_len
+              && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+              && dir == dname.substr (dname_len - dir_len))
+            {
+              octave::sys::file_stat fs (di.dir_name);
+
+              if (fs.exists () && fs.is_dir ())
+                return di.dir_name;
+            }
+        }
+    }
+
+  return retval;
+}
+
+string_vector
+load_path::find_matching_dirs (const std::string& dir) const
+{
+  std::list<std::string> retlist;
+
+  if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
+      && (octave::sys::env::absolute_pathname (dir)
+          || octave::sys::env::rooted_relative_pathname (dir)))
+    {
+      octave::sys::file_stat fs (dir);
+
+      if (fs.exists () && fs.is_dir ())
+        retlist.push_back (dir);
+    }
+  else
+    {
+      for (const auto& di : dir_info_list)
+        {
+          std::string dname = octave::sys::env::make_absolute (di.dir_name);
+
+          size_t dname_len = dname.length ();
+
+          if (dname.substr (dname_len - 1)
+              == octave::sys::file_ops::dir_sep_str ())
+            {
+              dname = dname.substr (0, dname_len - 1);
+              dname_len--;
+            }
+
+          size_t dir_len = dir.length ();
+
+          if (dname_len > dir_len
+              && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+              && dir == dname.substr (dname_len - dir_len))
+            {
+              octave::sys::file_stat fs (di.dir_name);
+
+              if (fs.exists () && fs.is_dir ())
+                retlist.push_back (di.dir_name);
+            }
+        }
+    }
+
+  return retlist;
+}
+
+std::string
+load_path::find_first_of (const string_vector& flist) const
+{
+  std::string retval;
+
+  std::string dir_name;
+  std::string file_name;
+
+  octave_idx_type flen = flist.numel ();
+  octave_idx_type rel_flen = 0;
+
+  string_vector rel_flist (flen);
+
+  for (octave_idx_type i = 0; i < flen; i++)
+    {
+      std::string file = flist[i];
+
+      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+          != std::string::npos)
+        {
+          if (octave::sys::env::absolute_pathname (file)
+              || octave::sys::env::rooted_relative_pathname (file))
+            {
+              octave::sys::file_stat fs (file);
+
+              if (fs.exists ())
+                return file;
+            }
+          else
+            {
+              for (const auto& di : dir_info_list)
+                {
+                  std::string tfile;
+                  tfile = octave::sys::file_ops::concat (di.dir_name, file);
+
+                  octave::sys::file_stat fs (tfile);
+
+                  if (fs.exists ())
+                    return tfile;
+                }
+            }
+        }
+      else
+        rel_flist[rel_flen++] = file;
+    }
+
+  rel_flist.resize (rel_flen);
+
+  for (const auto& di : dir_info_list)
+    {
+      string_vector all_files = di.all_files;
+
+      octave_idx_type len = all_files.numel ();
+
+      for (octave_idx_type i = 0; i < len; i++)
+        {
+          for (octave_idx_type j = 0; j < rel_flen; j++)
+            {
+              if (all_files[i] == rel_flist[j])
+                {
+                  dir_name = di.dir_name;
+                  file_name = rel_flist[j];
+
+                  goto done;
+                }
+            }
+        }
+    }
+
+ done:
+
+  if (! dir_name.empty ())
+    retval = octave::sys::file_ops::concat (dir_name, file_name);
+
+  return retval;
+}
+
+string_vector
+load_path::find_all_first_of (const string_vector& flist) const
+{
+  std::list<std::string> retlist;
+
+  std::string dir_name;
+  std::string file_name;
+
+  octave_idx_type flen = flist.numel ();
+  octave_idx_type rel_flen = 0;
+
+  string_vector rel_flist (flen);
+
+  for (octave_idx_type i = 0; i < flen; i++)
+    {
+      std::string file = flist[i];
+
+      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+          != std::string::npos)
+        {
+          if (octave::sys::env::absolute_pathname (file)
+              || octave::sys::env::rooted_relative_pathname (file))
+            {
+              octave::sys::file_stat fs (file);
+
+              if (fs.exists ())
+                retlist.push_back (file);
+            }
+          else
+            {
+              for (const auto& di : dir_info_list)
+                {
+                  std::string tfile;
+                  tfile = octave::sys::file_ops::concat (di.dir_name, file);
+
+                  octave::sys::file_stat fs (tfile);
+
+                  if (fs.exists ())
+                    retlist.push_back (tfile);
+                }
+            }
+        }
+      else
+        rel_flist[rel_flen++] = file;
+    }
+
+  rel_flist.resize (rel_flen);
+
+  for (const auto& di : dir_info_list)
+    {
+      string_vector all_files = di.all_files;
+
+      octave_idx_type len = all_files.numel ();
+
+      for (octave_idx_type i = 0; i < len; i++)
+        {
+          for (octave_idx_type j = 0; j < rel_flen; j++)
+            {
+              if (all_files[i] == rel_flist[j])
+                retlist.push_back (octave::sys::file_ops::concat (di.dir_name,
+                                                                  rel_flist[j]));
+            }
+        }
+    }
+
+  return retlist;
+}
+
+string_vector
+load_path::dirs (void) const
+{
+  size_t len = dir_info_list.size ();
+
+  string_vector retval (len);
+
+  octave_idx_type k = 0;
+
+  for (const auto& di : dir_info_list)
+    retval[k++] = di.dir_name;
+
+  return retval;
+}
+
+std::list<std::string>
+load_path::dir_list (void) const
+{
+  std::list<std::string> retval;
+
+  for (const auto& di : dir_info_list)
+    retval.push_back (di.dir_name);
+
+  return retval;
+}
+
+string_vector
+load_path::files (const std::string& dir, bool omit_exts) const
+{
+  string_vector retval;
+
+  const_dir_info_list_iterator p = find_dir_info (dir);
+
+  if (p != dir_info_list.end ())
+    retval = p->fcn_files;
+
+  if (omit_exts)
+    {
+      octave_idx_type len = retval.numel ();
+
+      for (octave_idx_type i = 0; i < len; i++)
+        {
+          std::string fname = retval[i];
+
+          size_t pos = fname.rfind ('.');
+
+          if (pos != std::string::npos)
+            retval[i] = fname.substr (0, pos);
+        }
+    }
+
+  return retval;
+}
+
+string_vector
+load_path::fcn_names (void) const
+{
+  return top_level_package.fcn_names ();
+}
+
+std::string
+load_path::path (void) const
+{
+  std::string xpath;
+
+  string_vector xdirs = load_path::dirs ();
+
+  octave_idx_type len = xdirs.numel ();
+
+  if (len > 0)
+    xpath = xdirs[0];
+
+  for (octave_idx_type i = 1; i < len; i++)
+    xpath += octave::directory_path::path_sep_str () + xdirs[i];
+
+  return xpath;
+}
+
+void
+load_path::display (std::ostream& os) const
+{
+  for (const auto& di : dir_info_list)
+    {
+      string_vector fcn_files = di.fcn_files;
+
+      if (! fcn_files.empty ())
+        {
+          os << "\n*** function files in " << di.dir_name << ":\n\n";
+
+          fcn_files.list_in_columns (os);
+        }
+
+      const dir_info::method_file_map_type& method_file_map
+        = di.method_file_map;
+
+      if (! method_file_map.empty ())
+        {
+          for (const auto& cls_ci : method_file_map)
+            {
+              os << "\n*** methods in " << di.dir_name
+                 << "/@" << cls_ci.first << ":\n\n";
+
+              const dir_info::class_info& ci = cls_ci.second;
+
+              string_vector method_files = get_file_list (ci.method_file_map);
+
+              method_files.list_in_columns (os);
+            }
+        }
+    }
+
+  top_level_package.display (os);
+
+  for (const auto& nm_ldr : package_map)
+    nm_ldr.second.display (os);
+}
+
+void
+load_path::execute_pkg_add (const std::string& dir)
+{
+  execute_pkg_add_or_del (dir, "PKG_ADD");
+}
+
+void
+load_path::execute_pkg_del (const std::string& dir)
+{
+  execute_pkg_add_or_del (dir, "PKG_DEL");
+}
+
+// FIXME: maybe we should also maintain a map to speed up this method of access.
+
+load_path::const_dir_info_list_iterator
+load_path::find_dir_info (const std::string& dir_arg) const
+{
+  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+
+  const_dir_info_list_iterator retval = dir_info_list.begin ();
+
+  while (retval != dir_info_list.end ())
+    {
+      if (retval->dir_name == dir)
+        break;
+
+      retval++;
+    }
+
+  return retval;
+}
+
+load_path::dir_info_list_iterator
+load_path::find_dir_info (const std::string& dir_arg)
+{
+  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+
+  dir_info_list_iterator retval = dir_info_list.begin ();
+
+  while (retval != dir_info_list.end ())
+    {
+      if (retval->dir_name == dir)
+        break;
+
+      retval++;
+    }
+
+  return retval;
+}
+
+bool
+load_path::contains (const std::string& dir) const
+{
+  return find_dir_info (dir) != dir_info_list.end ();
+}
+
+void
+load_path::move (dir_info_list_iterator i, bool at_end)
+{
+  if (dir_info_list.size () > 1)
+    {
+      dir_info di = *i;
+
+      dir_info_list.erase (i);
+
+      if (at_end)
+        dir_info_list.push_back (di);
+      else
+        dir_info_list.push_front (di);
+
+      move (di, at_end);
+    }
+}
+
+void
+load_path::move (const dir_info& di, bool at_end, const std::string& pname)
+{
+  package_info& l = get_package (pname);
+
+  l.move (di, at_end);
+
+  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
+
+  for (const auto& pkg_di : package_dir_map)
+    {
+      std::string full_name = pkg_di.first;
+
+      if (! pname.empty ())
+        full_name = pname + "." + full_name;
+
+      move (pkg_di.second, at_end, full_name);
+    }
+}
+
+void
+load_path::add (const std::string& dir_arg, bool at_end, bool warn)
+{
+  size_t len = dir_arg.length ();
+
+  if (len > 1 && dir_arg.substr (len-2) == "//")
+    warning_with_id ("Octave:recursive-path-search",
+                     "trailing '//' is no longer special in search path elements");
+
+  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+
+  dir = strip_trailing_separators (dir);
+
+  dir_info_list_iterator i = find_dir_info (dir);
+
+  if (i != dir_info_list.end ())
+    move (i, at_end);
+  else
+    {
+      octave::sys::file_stat fs (dir);
+
+      if (fs)
+        {
+          if (fs.is_dir ())
+            {
+              dir_info di (dir);
+
+              if (at_end)
+                dir_info_list.push_back (di);
+              else
+                dir_info_list.push_front (di);
+
+              add (di, at_end);
+
+              if (add_hook)
+                add_hook (dir);
+            }
+          else if (warn)
+            warning ("addpath: %s: not a directory", dir_arg.c_str ());
+        }
+      else if (warn)
+        {
+          std::string msg = fs.error ();
+          warning ("addpath: %s: %s", dir_arg.c_str (), msg.c_str ());
+        }
+    }
+
+  // FIXME: is there a better way to do this?
+
+  i = find_dir_info (".");
+
+  if (i != dir_info_list.end ())
+    move (i, false);
+}
+
+void
+load_path::remove (const dir_info& di, const std::string& pname)
+{
+  package_info& l = get_package (pname);
+
+  l.remove (di);
+
+  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
+
+  for (const auto& pkg_di : package_dir_map)
+    {
+      std::string full_name = pkg_di.first;
+
+      if (! pname.empty ())
+        full_name = pname + "." + full_name;
+
+      remove (pkg_di.second, full_name);
+    }
+}
+
+bool
+load_path::is_package (const std::string& name) const
+{
+  for (const auto& di : dir_info_list)
+    {
+      if (di.is_package (name))
+        return true;
+    }
+
+  return false;
+}
+
+void
+load_path::add (const dir_info& di, bool at_end,
+                const std::string& pname, bool updating) const
+{
+  package_info& l = get_package (pname);
+
+  l.add (di, at_end, updating);
+
+  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
+
+  for (const auto& pkg_di : package_dir_map)
+    {
+      std::string full_name = pkg_di.first;
+
+      if (! pname.empty ())
+        full_name = pname + "." + full_name;
+
+      add (pkg_di.second, at_end, full_name);
+    }
+}
+
+string_vector
+load_path::get_file_list (const load_path::dir_info::fcn_file_map_type& lst) const
+{
+  octave_idx_type n = lst.size ();
+
+  string_vector retval (n);
+
+  octave_idx_type count = 0;
+
+  for (const auto& nm_typ : lst)
+    {
+      std::string nm = nm_typ.first;
+
+      int types = nm_typ.second;
+
+      if (types & load_path::OCT_FILE)
+        nm += ".oct";
+      else if (types & load_path::MEX_FILE)
+        nm += ".mex";
+      else
+        nm += ".m";
+
+      retval[count++] = nm;
+    }
+
+  return retval;
+}
+
+load_path::dir_info::fcn_file_map_type
+get_fcn_files (const std::string& d)
+{
+  load_path::dir_info::fcn_file_map_type retval;
+
+  octave::sys::dir_entry dir (d);
+
+  if (dir)
+    {
+      string_vector flist = dir.read ();
+
+      octave_idx_type len = flist.numel ();
+
+      for (octave_idx_type i = 0; i < len; i++)
+        {
+          std::string fname = flist[i];
+
+          size_t pos = fname.rfind ('.');
+
+          if (pos != std::string::npos)
+            {
+              std::string base = fname.substr (0, pos);
+              std::string ext = fname.substr (pos);
+
+              if (valid_identifier (base))
+                {
+                  int t = 0;
+
+                  if (ext == ".m")
+                    t = load_path::M_FILE;
+                  else if (ext == ".oct")
+                    t = load_path::OCT_FILE;
+                  else if (ext == ".mex")
+                    t = load_path::MEX_FILE;
+
+                  if (t)
+                    retval[base] = t;
+                }
+            }
+        }
+    }
+  else
+    {
+      std::string msg = dir.error ();
+      warning ("load_path: %s: %s", d.c_str (), msg.c_str ());
+    }
+
+  return retval;
+}
+
 void
 load_path::dir_info::update (void)
 {
   octave::sys::file_stat fs (dir_name);
 
   if (! fs)
     {
       std::string msg = fs.error ();
@@ -65,17 +1122,17 @@ load_path::dir_info::update (void)
   else
     {
       if (is_relative)
         {
           try
             {
               std::string abs_name = octave::sys::env::make_absolute (dir_name);
 
-              abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
+              const_abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
 
               if (p != abs_dir_cache.end ())
                 {
                   // The directory is in the cache of all directories we have
                   // visited (indexed by absolute name).  If it is out of date,
                   // initialize it.  Otherwise, copy the info from the cache.
                   // By doing that, we avoid unnecessary calls to stat that can
                   // slow things down tremendously for large directories.
@@ -245,66 +1302,16 @@ load_path::dir_info::get_file_list (cons
     }
   else
     {
       std::string msg = dir.error ();
       warning ("load_path: %s: %s", d.c_str (), msg.c_str ());
     }
 }
 
-load_path::dir_info::fcn_file_map_type
-get_fcn_files (const std::string& d)
-{
-  load_path::dir_info::fcn_file_map_type retval;
-
-  octave::sys::dir_entry dir (d);
-
-  if (dir)
-    {
-      string_vector flist = dir.read ();
-
-      octave_idx_type len = flist.numel ();
-
-      for (octave_idx_type i = 0; i < len; i++)
-        {
-          std::string fname = flist[i];
-
-          size_t pos = fname.rfind ('.');
-
-          if (pos != std::string::npos)
-            {
-              std::string base = fname.substr (0, pos);
-              std::string ext = fname.substr (pos);
-
-              if (valid_identifier (base))
-                {
-                  int t = 0;
-
-                  if (ext == ".m")
-                    t = load_path::M_FILE;
-                  else if (ext == ".oct")
-                    t = load_path::OCT_FILE;
-                  else if (ext == ".mex")
-                    t = load_path::MEX_FILE;
-
-                  if (t)
-                    retval[base] = t;
-                }
-            }
-        }
-    }
-  else
-    {
-      std::string msg = dir.error ();
-      warning ("load_path: %s: %s", d.c_str (), msg.c_str ());
-    }
-
-  return retval;
-}
-
 void
 load_path::dir_info::get_private_file_map (const std::string& d)
 {
   private_file_map = get_fcn_files (d);
 }
 
 void
 load_path::dir_info::get_method_file_map (const std::string& d,
@@ -322,225 +1329,16 @@ load_path::dir_info::get_method_file_map
 
 void
 load_path::dir_info::get_package_dir (const std::string& d,
                                       const std::string& package_name)
 {
   package_dir_map[package_name] = dir_info (d);
 }
 
-bool
-load_path::instance_ok (void)
-{
-  bool retval = true;
-
-  if (! instance)
-    {
-      instance = new load_path ();
-
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
-    }
-
-  if (! instance)
-    error ("unable to create load path object!");
-
-  return retval;
-}
-
-// FIXME: maybe we should also maintain a map to speed up this method of access.
-
-load_path::const_dir_info_list_iterator
-load_path::find_dir_info (const std::string& dir_arg) const
-{
-  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
-
-  const_dir_info_list_iterator retval = dir_info_list.begin ();
-
-  while (retval != dir_info_list.end ())
-    {
-      if (retval->dir_name == dir)
-        break;
-
-      retval++;
-    }
-
-  return retval;
-}
-
-load_path::dir_info_list_iterator
-load_path::find_dir_info (const std::string& dir_arg)
-{
-  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
-
-  dir_info_list_iterator retval = dir_info_list.begin ();
-
-  while (retval != dir_info_list.end ())
-    {
-      if (retval->dir_name == dir)
-        break;
-
-      retval++;
-    }
-
-  return retval;
-}
-
-bool
-load_path::contains (const std::string& dir) const
-{
-  return find_dir_info (dir) != dir_info_list.end ();
-}
-
-bool
-load_path::do_contains_canonical (const std::string& dir) const
-{
-  bool retval = false;
-
-  for (const auto& d : dir_info_list)
-    {
-      if (same_file (dir, d.dir_name))
-        {
-          retval = true;
-          break;
-        }
-    }
-
-  return retval;
-}
-
-void
-load_path::package_info::move_fcn_map (const std::string& dir_name,
-                                 const string_vector& fcn_files, bool at_end)
-{
-  octave_idx_type len = fcn_files.numel ();
-
-  for (octave_idx_type k = 0; k < len; k++)
-    {
-      std::string fname = fcn_files[k];
-
-      std::string ext;
-      std::string base = fname;
-
-      size_t pos = fname.rfind ('.');
-
-      if (pos != std::string::npos)
-        {
-          base = fname.substr (0, pos);
-          ext = fname.substr (pos);
-        }
-
-      file_info_list_type& file_info_list = fcn_map[base];
-
-      if (file_info_list.size () == 1)
-        continue;
-      else
-        {
-          for (auto fi_it = file_info_list.begin ();
-               fi_it != file_info_list.end ();
-               fi_it++)
-            {
-              if (fi_it->dir_name == dir_name)
-                {
-                  file_info fi_tmp = *fi_it;
-
-                  file_info_list.erase (fi_it);
-
-                  if (at_end)
-                    file_info_list.push_back (fi_tmp);
-                  else
-                    file_info_list.push_front (fi_tmp);
-
-                  break;
-                }
-            }
-        }
-    }
-}
-
-void
-load_path::package_info::move_method_map (const std::string& dir_name, bool at_end)
-{
-  for (auto& cls_fnmap : method_map)
-    {
-      std::string class_name = cls_fnmap.first;
-
-      fcn_map_type& fn_map = cls_fnmap.second;
-
-      std::string full_dir_name
-        = octave::sys::file_ops::concat (dir_name, "@" + class_name);
-
-      for (auto& nm_filst : fn_map)
-        {
-          file_info_list_type& file_info_list = nm_filst.second;
-
-          if (file_info_list.size () == 1)
-            continue;
-          else
-            {
-              for (auto fi_it = file_info_list.begin ();
-                   fi_it != file_info_list.end (); fi_it++)
-                {
-                  if (fi_it->dir_name == full_dir_name)
-                    {
-                      file_info fi_tmp = *fi_it;
-
-                      file_info_list.erase (fi_it);
-
-                      if (at_end)
-                        file_info_list.push_back (fi_tmp);
-                      else
-                        file_info_list.push_front (fi_tmp);
-
-                      break;
-                    }
-                }
-            }
-        }
-    }
-}
-
-void
-load_path::do_move (dir_info_list_iterator i, bool at_end)
-{
-  if (dir_info_list.size () > 1)
-    {
-      dir_info di = *i;
-
-      dir_info_list.erase (i);
-
-      if (at_end)
-        dir_info_list.push_back (di);
-      else
-        dir_info_list.push_front (di);
-
-      move (di, at_end);
-    }
-}
-
-void
-load_path::move (const dir_info& di, bool at_end, const std::string& pname)
-{
-  package_info& pkg = get_package (pname);
-
-  pkg.move (di, at_end);
-
-  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
-
-  for (const auto& pkg_di : package_dir_map)
-    {
-      std::string full_name = pkg_di.first;
-
-      if (! pname.empty ())
-        full_name = pname + "." + full_name;
-
-      move (pkg_di.second, at_end, full_name);
-    }
-}
-
 void
 load_path::package_info::move (const dir_info& di, bool at_end)
 {
   std::string dir_name = di.dir_name;
 
   std::list<std::string>::iterator s =
     std::find (dir_list.begin (), dir_list.end (), dir_name);
 
@@ -556,397 +1354,16 @@ load_path::package_info::move (const dir
 
   move_fcn_map (dir_name, di.fcn_files, at_end);
 
   // No need to move elements of private function map.
 
   move_method_map (dir_name, at_end);
 }
 
-static void
-maybe_add_path_elts (std::string& path, const std::string& dir)
-{
-  std::string tpath = genpath (dir);
-
-  if (! tpath.empty ())
-    {
-      if (path.empty ())
-        path = tpath;
-      else
-        path += octave::directory_path::path_sep_str () + tpath;
-    }
-}
-
-void
-load_path::do_initialize (bool set_initial_path)
-{
-  sys_path = "";
-
-  if (set_initial_path)
-    {
-      maybe_add_path_elts (sys_path, Vlocal_ver_oct_file_dir);
-      maybe_add_path_elts (sys_path, Vlocal_api_oct_file_dir);
-      maybe_add_path_elts (sys_path, Vlocal_oct_file_dir);
-      maybe_add_path_elts (sys_path, Vlocal_ver_fcn_file_dir);
-      maybe_add_path_elts (sys_path, Vlocal_api_fcn_file_dir);
-      maybe_add_path_elts (sys_path, Vlocal_fcn_file_dir);
-      maybe_add_path_elts (sys_path, Voct_file_dir);
-      maybe_add_path_elts (sys_path, Vfcn_file_dir);
-      maybe_add_path_elts (sys_path, Voct_data_dir);
-    }
-
-  std::string tpath = load_path::command_line_path;
-
-  if (tpath.empty ())
-    tpath = octave::sys::env::getenv ("OCTAVE_PATH");
-
-  std::string xpath;
-
-  if (! tpath.empty ())
-    {
-      xpath = tpath;
-
-      if (! sys_path.empty ())
-        xpath += octave::directory_path::path_sep_str () + sys_path;
-    }
-  else
-    xpath = sys_path;
-
-  do_set (xpath, false, true);
-}
-
-void
-load_path::do_clear (void)
-{
-  dir_info_list.clear ();
-
-  top_level_package.clear ();
-
-  package_map.clear ();
-}
-
-static std::list<std::string>
-split_path (const std::string& p)
-{
-  std::list<std::string> retval;
-
-  size_t beg = 0;
-  size_t end = p.find (octave::directory_path::path_sep_char ());
-
-  size_t len = p.length ();
-
-  while (end != std::string::npos)
-    {
-      std::string elt = p.substr (beg, end-beg);
-
-      if (! elt.empty ())
-        retval.push_back (elt);
-
-      beg = end + 1;
-
-      if (beg == len)
-        break;
-
-      end = p.find (octave::directory_path::path_sep_char (), beg);
-    }
-
-  std::string elt = p.substr (beg);
-
-  if (! elt.empty ())
-    retval.push_back (elt);
-
-  return retval;
-}
-
-void
-load_path::do_set (const std::string& p, bool warn, bool is_init)
-{
-  // Use a list when we need to preserve order.
-  std::list<std::string> elts = split_path (p);
-
-  // Use a set when we need to search and order is not important.
-  std::set<std::string> elts_set (elts.begin (), elts.end ());
-
-  if (is_init)
-    init_dirs = elts_set;
-  else
-    {
-      for (const auto& init_dir : init_dirs)
-        {
-          if (elts_set.find (init_dir) == elts_set.end ())
-            {
-              warning_with_id ("Octave:remove-init-dir",
-                               "default load path altered.  Some built-in functions may not be found.  Try restoredefaultpath() to recover it.");
-              break;
-            }
-        }
-    }
-
-  // Temporarily disable add hook.
-
-  octave::unwind_protect frame;
-  frame.protect_var (add_hook);
-
-  add_hook = 0;
-
-  do_clear ();
-
-  for (const auto& elt : elts)
-    do_append (elt, warn);
-
-  // Restore add hook and execute for all newly added directories.
-  frame.run_first ();
-
-  // FIXME: Shouldn't the test for add_hook be outside the for loop?
-  //        Why not use const here?  Does add_hook change dir_info_list?
-  for (auto& di : dir_info_list)
-    {
-      if (add_hook)
-        add_hook (di.dir_name);
-    }
-
-  // Always prepend current directory.
-  do_prepend (".", warn);
-}
-
-void
-load_path::do_append (const std::string& dir, bool warn)
-{
-  if (! dir.empty ())
-    do_add (dir, true, warn);
-}
-
-void
-load_path::do_prepend (const std::string& dir, bool warn)
-{
-  if (! dir.empty ())
-    do_add (dir, false, warn);
-}
-
-// Strip trailing directory separators.
-
-static std::string
-strip_trailing_separators (const std::string& dir_arg)
-{
-  std::string dir = dir_arg;
-
-  size_t k = dir.length ();
-
-  while (k > 1 && octave::sys::file_ops::is_dir_sep (dir[k-1]))
-    k--;
-
-  if (k < dir.length ())
-    dir.resize (k);
-
-  return dir;
-}
-
-void
-load_path::do_add (const std::string& dir_arg, bool at_end, bool warn)
-{
-  size_t len = dir_arg.length ();
-
-  if (len > 1 && dir_arg.substr (len-2) == "//")
-    warning_with_id ("Octave:recursive-path-search",
-                     "trailing '//' is no longer special in search path elements");
-
-  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
-
-  dir = strip_trailing_separators (dir);
-
-  dir_info_list_iterator i = find_dir_info (dir);
-
-  if (i != dir_info_list.end ())
-    do_move (i, at_end);
-  else
-    {
-      octave::sys::file_stat fs (dir);
-
-      if (fs)
-        {
-          if (fs.is_dir ())
-            {
-              dir_info di (dir);
-
-              if (at_end)
-                dir_info_list.push_back (di);
-              else
-                dir_info_list.push_front (di);
-
-              add (di, at_end);
-
-              if (add_hook)
-                add_hook (dir);
-            }
-          else if (warn)
-            warning ("addpath: %s: not a directory", dir_arg.c_str ());
-        }
-      else if (warn)
-        {
-          std::string msg = fs.error ();
-          warning ("addpath: %s: %s", dir_arg.c_str (), msg.c_str ());
-        }
-    }
-
-  // FIXME: is there a better way to do this?
-
-  i = find_dir_info (".");
-
-  if (i != dir_info_list.end ())
-    do_move (i, false);
-}
-
-void
-load_path::package_info::remove_fcn_map (const std::string& dir,
-                                   const string_vector& fcn_files)
-{
-  octave_idx_type len = fcn_files.numel ();
-
-  for (octave_idx_type k = 0; k < len; k++)
-    {
-      std::string fname = fcn_files[k];
-
-      std::string ext;
-      std::string base = fname;
-
-      size_t pos = fname.rfind ('.');
-
-      if (pos != std::string::npos)
-        {
-          base = fname.substr (0, pos);
-          ext = fname.substr (pos);
-        }
-
-      file_info_list_type& file_info_list = fcn_map[base];
-
-      for (auto fi_it = file_info_list.begin ();
-           fi_it != file_info_list.end ();
-           fi_it++)
-        {
-          if (fi_it->dir_name == dir)
-            {
-              file_info_list.erase (fi_it);
-
-              if (file_info_list.empty ())
-                fcn_map.erase (fname);
-
-              break;
-            }
-        }
-    }
-}
-
-void
-load_path::package_info::remove_private_fcn_map (const std::string& dir)
-{
-  private_fcn_map_iterator p = private_fcn_map.find (dir);
-
-  if (p != private_fcn_map.end ())
-    private_fcn_map.erase (p);
-}
-
-void
-load_path::package_info::remove_method_map (const std::string& dir)
-{
-  for (auto& cls_fnmap : method_map)
-    {
-      std::string class_name = cls_fnmap.first;
-
-      fcn_map_type& fn_map = cls_fnmap.second;
-
-      std::string full_dir_name
-        = octave::sys::file_ops::concat (dir, "@" + class_name);
-
-      for (auto& nm_filst : fn_map)
-        {
-          file_info_list_type& file_info_list = nm_filst.second;
-
-          if (file_info_list.size () == 1)
-            continue;
-          else
-            {
-              for (auto fi_it = file_info_list.begin ();
-                   fi_it != file_info_list.end (); fi_it++)
-                {
-                  if (fi_it->dir_name == full_dir_name)
-                    {
-                      file_info_list.erase (fi_it);
-                      // FIXME: if there are no other elements, we
-                      // should remove this element of fn_map but calling
-                      // erase here would invalidate the iterator fi_it.
-
-                      break;
-                    }
-                }
-            }
-        }
-    }
-}
-
-bool
-load_path::do_remove (const std::string& dir_arg)
-{
-  bool retval = false;
-
-  if (! dir_arg.empty ())
-    {
-      if (dir_arg == ".")
-        {
-          warning ("rmpath: can't remove \".\" from path");
-
-          // Avoid additional warnings.
-          retval = true;
-        }
-      else
-        {
-          std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
-
-          dir = strip_trailing_separators (dir);
-
-          dir_info_list_iterator i = find_dir_info (dir);
-
-          if (i != dir_info_list.end ())
-            {
-              retval = true;
-
-              if (remove_hook)
-                remove_hook (dir);
-
-              dir_info& di = *i;
-
-              remove (di);
-
-              dir_info_list.erase (i);
-            }
-        }
-    }
-
-  return retval;
-}
-
-void
-load_path::remove (const dir_info& di, const std::string& pname)
-{
-  package_info& pkg = get_package (pname);
-
-  pkg.remove (di);
-
-  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
-
-  for (const auto& pkg_di : package_dir_map)
-    {
-      std::string full_name = pkg_di.first;
-
-      if (! pname.empty ())
-        full_name = pname + "." + full_name;
-
-      remove (pkg_di.second, full_name);
-    }
-}
-
 void
 load_path::package_info::remove (const dir_info& di)
 {
   std::string dir = di.dir_name;
 
   string_vector fcn_files = di.fcn_files;
 
   dir_list.remove (dir);
@@ -954,131 +1371,84 @@ load_path::package_info::remove (const d
   remove_fcn_map (dir, fcn_files);
 
   remove_private_fcn_map (dir);
 
   remove_method_map (dir);
 }
 
 void
-load_path::do_update (void) const
-{
-  // I don't see a better way to do this because we need to
-  // preserve the correct directory ordering for new files that
-  // have appeared.
-
-  top_level_package.clear ();
-
-  package_map.clear ();
-
-  for (auto& di : dir_info_list)
-    {
-      di.update ();
-
-      add (di, true, "", true);
-    }
-}
-
-bool
-load_path::check_file_type (std::string& fname, int type, int possible_types,
-                            const std::string& fcn, const char *who)
+load_path::package_info::display (std::ostream& os) const
 {
-  bool retval = false;
-
-  if (type == load_path::OCT_FILE)
-    {
-      if ((type & possible_types) == load_path::OCT_FILE)
-        {
-          fname += ".oct";
-          retval = true;
-        }
-    }
-  else if (type == load_path::M_FILE)
+  os << "*** package_info: "
+     << (m_package_name.empty () ? "<top-level>" : m_package_name)
+     << "\n\n";
+
+  for (const auto& dir : dir_list)
+    os << dir << "\n";
+  os << "\n";
+
+  for (const auto& dir_fnlst : private_fcn_map)
     {
-      if ((type & possible_types) == load_path::M_FILE)
-        {
-          fname += ".m";
-          retval = true;
-        }
+      os << "\n*** private functions in "
+         << octave::sys::file_ops::concat (dir_fnlst.first, "private")
+         << ":\n\n";
+
+      print_fcn_list (os, dir_fnlst.second);
     }
-  else if (type == load_path::MEX_FILE)
+
+#if defined (DEBUG_LOAD_PATH)
+
+  for (const auto& nm_filst : fcn_map)
     {
-      if ((type & possible_types) == load_path::MEX_FILE)
+      os << nm_filst.first << ":\n";
+
+      const file_info_list_type& file_info_list = nm_filst.second;
+
+      for (const auto& finfo : file_info_list)
         {
-          fname += ".mex";
-          retval = true;
+          os << "  " << finfo.dir_name << " (";
+
+          print_types (os, finfo.types);
+
+          os << ")\n";
         }
     }
-  else if (type == (load_path::M_FILE | load_path::OCT_FILE))
+
+  for (const auto& cls_fnmap : method_map)
     {
-      if (possible_types & load_path::OCT_FILE)
-        {
-          fname += ".oct";
-          retval = true;
-        }
-      else if (possible_types & load_path::M_FILE)
+      os << "CLASS " << cls_fnmap.first << ":\n";
+
+      const fcn_map_type& fm = cls_fnmap.second;
+
+      for (const auto& nm_fnlst : fcn_map)
         {
-          fname += ".m";
-          retval = true;
-        }
-    }
-  else if (type == (load_path::M_FILE | load_path::MEX_FILE))
-    {
-      if (possible_types & load_path::MEX_FILE)
-        {
-          fname += ".mex";
-          retval = true;
-        }
-      else if (possible_types & load_path::M_FILE)
-        {
-          fname += ".m";
-          retval = true;
+          os << "  " << nm_fnlst.first << ":\n";
+
+          const file_info_list_type& file_info_list = nm_fnlst.second;
+
+          for (const auto& finfo : file_info_list)
+            {
+              os << "  " << finfo.dir_name << " (";
+
+              print_types (os, finfo.types);
+
+              os << ")\n";
+            }
         }
     }
-  else if (type == (load_path::OCT_FILE | load_path::MEX_FILE))
-    {
-      if (possible_types & load_path::OCT_FILE)
-        {
-          fname += ".oct";
-          retval = true;
-        }
-      else if (possible_types & load_path::MEX_FILE)
-        {
-          fname += ".mex";
-          retval = true;
-        }
-    }
-  else if (type == (load_path::M_FILE | load_path::OCT_FILE
-                    | load_path::MEX_FILE))
-    {
-      if (possible_types & load_path::OCT_FILE)
-        {
-          fname += ".oct";
-          retval = true;
-        }
-      else if (possible_types & load_path::MEX_FILE)
-        {
-          fname += ".mex";
-          retval = true;
-        }
-      else if (possible_types & load_path::M_FILE)
-        {
-          fname += ".m";
-          retval = true;
-        }
-    }
-  else
-    error ("%s: %s: invalid type code = %d", who, fcn.c_str (), type);
-
-  return retval;
+
+  os << "\n";
+
+#endif
 }
 
 std::string
 load_path::package_info::find_fcn (const std::string& fcn, std::string& dir_name,
-                             int type) const
+                                   int type) const
 {
   std::string retval;
 
   //  update ();
 
   if (fcn.length () > 0 && fcn[0] == '@')
     {
       size_t pos = fcn.find ('/');
@@ -1103,33 +1473,33 @@ load_path::package_info::find_fcn (const
         {
           const file_info_list_type& file_info_list = p->second;
 
           for (const auto& fi : file_info_list)
             {
               retval = octave::sys::file_ops::concat (fi.dir_name, fcn);
 
               if (check_file_type (retval, type, fi.types,
-                                   fcn, "load_path::do_find_fcn"))
+                                   fcn, "load_path::find_fcn"))
                 {
                   dir_name = fi.dir_name;
                   break;
                 }
               else
                 retval = "";
             }
         }
     }
 
   return retval;
 }
 
 std::string
 load_path::package_info::find_private_fcn (const std::string& dir,
-                                     const std::string& fcn, int type) const
+                                           const std::string& fcn, int type) const
 {
   std::string retval;
 
   //  update ();
 
   const_private_fcn_map_iterator q = private_fcn_map.find (dir);
 
   if (q != private_fcn_map.end ())
@@ -1149,18 +1519,18 @@ load_path::package_info::find_private_fc
         }
     }
 
   return retval;
 }
 
 std::string
 load_path::package_info::find_method (const std::string& class_name,
-                                const std::string& meth,
-                                std::string& dir_name, int type) const
+                                      const std::string& meth,
+                                      std::string& dir_name, int type) const
 {
   std::string retval;
 
   //  update ();
 
   dir_name = "";
 
   const_method_map_iterator q = method_map.find (class_name);
@@ -1175,17 +1545,17 @@ load_path::package_info::find_method (co
         {
           const file_info_list_type& file_info_list = p->second;
 
           for (const auto& fi : file_info_list)
             {
               retval = octave::sys::file_ops::concat (fi.dir_name, meth);
 
               bool found = check_file_type (retval, type, fi.types,
-                                            meth, "load_path::do_find_method");
+                                            meth, "load_path::find_method");
 
               if (found)
                 {
                   dir_name = fi.dir_name;
                   break;
                 }
               else
                 retval = "";
@@ -1212,46 +1582,19 @@ load_path::package_info::methods (const 
     }
 
   if (! retval.empty ())
     retval.sort ();
 
   return retval;
 }
 
-bool
-load_path::is_package (const std::string& name) const
-{
-  for (const auto& di : dir_info_list)
-    {
-      if (di.is_package (name))
-        return true;
-    }
-
-  return false;
-}
-
-std::list<std::string>
-load_path::do_overloads (const std::string& meth) const
-{
-  std::list<std::string> retval;
-
-  //  update ();
-
-  top_level_package.overloads (meth, retval);
-
-  for (const auto& nm_ldr : package_map)
-    nm_ldr.second.overloads (meth, retval);
-
-  return retval;
-}
-
 void
 load_path::package_info::overloads (const std::string& meth,
-                              std::list<std::string>& l) const
+                                    std::list<std::string>& l) const
 {
   for (const auto& cls_fnmap : method_map)
     {
       const fcn_map_type& m = cls_fnmap.second;
 
       if (m.find (meth) != m.end ())
         {
           std::string class_name = cls_fnmap.first;
@@ -1259,590 +1602,34 @@ load_path::package_info::overloads (cons
           if (! m_package_name.empty ())
             class_name = m_package_name + "." + class_name;
 
           l.push_back (class_name);
         }
     }
 }
 
-// Should we cache all files in private directories, or is it OK to just
-// look them up each time as needed?
-
-std::string
-find_private_file (const std::string& fname)
-{
-  std::string retval;
-
-  // Look in private directory corresponding to current function (if
-  // any).
-
-  octave_user_function *curr_fcn = symbol_table::get_curr_fcn ();
-
-  if (curr_fcn)
-    {
-      // Even for private functions, dir_name doesn't contain the
-      // "private" directory component so we append it here in all
-      // cases.
-
-      std::string dir_name = curr_fcn->dir_name ();
-
-      if (! dir_name.empty ())
-        {
-          std::string pfname = dir_name + octave::sys::file_ops::dir_sep_str ()
-                               + "private" + octave::sys::file_ops::dir_sep_str () + fname;
-
-          octave::sys::file_stat fs (pfname);
-
-          if (fs.exists () && fs.is_reg ())
-            retval = pfname;
-        }
-    }
-
-  return retval;
-}
-
-std::string
-load_path::do_find_file (const std::string& file) const
-{
-  std::string retval;
-
-  if (octave::sys::env::absolute_pathname (file)
-      || octave::sys::env::rooted_relative_pathname (file))
-    {
-      octave::sys::file_stat fs (file);
-
-      return fs.exists () ? file : retval;
-    }
-  else
-    {
-      std::string tfile = find_private_file (file);
-
-      if (! tfile.empty ())
-        return tfile;
-    }
-
-  if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
-      != std::string::npos)
-    {
-      // Given name has a directory separator, so append it to each
-      // element of the load path in turn.
-      for (const auto& di : dir_info_list)
-        {
-          std::string tfile = octave::sys::file_ops::concat (di.dir_name, file);
-
-          octave::sys::file_stat fs (tfile);
-
-          if (fs.exists ())
-            return tfile;
-        }
-    }
-  else
-    {
-      // Look in cache.
-      for (const auto & di : dir_info_list)
-        {
-          string_vector all_files = di.all_files;
-
-          octave_idx_type len = all_files.numel ();
-
-          for (octave_idx_type i = 0; i < len; i++)
-            {
-              if (all_files[i] == file)
-                return octave::sys::file_ops::concat (di.dir_name, file);
-            }
-        }
-    }
-
-  return retval;
-}
-
-std::string
-load_path::do_find_dir (const std::string& dir) const
-{
-  std::string retval;
-
-  if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
-      && (octave::sys::env::absolute_pathname (dir)
-          || octave::sys::env::rooted_relative_pathname (dir)))
-    {
-      octave::sys::file_stat fs (dir);
-
-      if (fs.exists () && fs.is_dir ())
-        return dir;
-    }
-  else
-    {
-      for (const auto& di : dir_info_list)
-        {
-          std::string dname = octave::sys::env::make_absolute (di.dir_name);
-
-          size_t dname_len = dname.length ();
-
-          if (dname.substr (dname_len - 1)
-              == octave::sys::file_ops::dir_sep_str ())
-            {
-              dname = dname.substr (0, dname_len - 1);
-              dname_len--;
-            }
-
-          size_t dir_len = dir.length ();
-
-          if (dname_len > dir_len
-              && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
-              && dir == dname.substr (dname_len - dir_len))
-            {
-              octave::sys::file_stat fs (di.dir_name);
-
-              if (fs.exists () && fs.is_dir ())
-                return di.dir_name;
-            }
-        }
-    }
-
-  return retval;
-}
-
-string_vector
-load_path::do_find_matching_dirs (const std::string& dir) const
-{
-  std::list<std::string> retlist;
-
-  if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
-      && (octave::sys::env::absolute_pathname (dir)
-          || octave::sys::env::rooted_relative_pathname (dir)))
-    {
-      octave::sys::file_stat fs (dir);
-
-      if (fs.exists () && fs.is_dir ())
-        retlist.push_back (dir);
-    }
-  else
-    {
-      for (const auto& di : dir_info_list)
-        {
-          std::string dname = octave::sys::env::make_absolute (di.dir_name);
-
-          size_t dname_len = dname.length ();
-
-          if (dname.substr (dname_len - 1)
-              == octave::sys::file_ops::dir_sep_str ())
-            {
-              dname = dname.substr (0, dname_len - 1);
-              dname_len--;
-            }
-
-          size_t dir_len = dir.length ();
-
-          if (dname_len > dir_len
-              && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
-              && dir == dname.substr (dname_len - dir_len))
-            {
-              octave::sys::file_stat fs (di.dir_name);
-
-              if (fs.exists () && fs.is_dir ())
-                retlist.push_back (di.dir_name);
-            }
-        }
-    }
-
-  return retlist;
-}
-
-std::string
-load_path::do_find_first_of (const string_vector& flist) const
-{
-  std::string retval;
-
-  std::string dir_name;
-  std::string file_name;
-
-  octave_idx_type flen = flist.numel ();
-  octave_idx_type rel_flen = 0;
-
-  string_vector rel_flist (flen);
-
-  for (octave_idx_type i = 0; i < flen; i++)
-    {
-      std::string file = flist[i];
-
-      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
-          != std::string::npos)
-        {
-          if (octave::sys::env::absolute_pathname (file)
-              || octave::sys::env::rooted_relative_pathname (file))
-            {
-              octave::sys::file_stat fs (file);
-
-              if (fs.exists ())
-                return file;
-            }
-          else
-            {
-              for (const auto& di : dir_info_list)
-                {
-                  std::string tfile;
-                  tfile = octave::sys::file_ops::concat (di.dir_name, file);
-
-                  octave::sys::file_stat fs (tfile);
-
-                  if (fs.exists ())
-                    return tfile;
-                }
-            }
-        }
-      else
-        rel_flist[rel_flen++] = file;
-    }
-
-  rel_flist.resize (rel_flen);
-
-  for (const auto& di : dir_info_list)
-    {
-      string_vector all_files = di.all_files;
-
-      octave_idx_type len = all_files.numel ();
-
-      for (octave_idx_type i = 0; i < len; i++)
-        {
-          for (octave_idx_type j = 0; j < rel_flen; j++)
-            {
-              if (all_files[i] == rel_flist[j])
-                {
-                  dir_name = di.dir_name;
-                  file_name = rel_flist[j];
-
-                  goto done;
-                }
-            }
-        }
-    }
-
-done:
-
-  if (! dir_name.empty ())
-    retval = octave::sys::file_ops::concat (dir_name, file_name);
-
-  return retval;
-}
-
-string_vector
-load_path::do_find_all_first_of (const string_vector& flist) const
-{
-  std::list<std::string> retlist;
-
-  std::string dir_name;
-  std::string file_name;
-
-  octave_idx_type flen = flist.numel ();
-  octave_idx_type rel_flen = 0;
-
-  string_vector rel_flist (flen);
-
-  for (octave_idx_type i = 0; i < flen; i++)
-    {
-      std::string file = flist[i];
-
-      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
-          != std::string::npos)
-        {
-          if (octave::sys::env::absolute_pathname (file)
-              || octave::sys::env::rooted_relative_pathname (file))
-            {
-              octave::sys::file_stat fs (file);
-
-              if (fs.exists ())
-                retlist.push_back (file);
-            }
-          else
-            {
-              for (const auto& di : dir_info_list)
-                {
-                  std::string tfile;
-                  tfile = octave::sys::file_ops::concat (di.dir_name, file);
-
-                  octave::sys::file_stat fs (tfile);
-
-                  if (fs.exists ())
-                    retlist.push_back (tfile);
-                }
-            }
-        }
-      else
-        rel_flist[rel_flen++] = file;
-    }
-
-  rel_flist.resize (rel_flen);
-
-  for (const auto& di : dir_info_list)
-    {
-      string_vector all_files = di.all_files;
-
-      octave_idx_type len = all_files.numel ();
-
-      for (octave_idx_type i = 0; i < len; i++)
-        {
-          for (octave_idx_type j = 0; j < rel_flen; j++)
-            {
-              if (all_files[i] == rel_flist[j])
-                retlist.push_back (octave::sys::file_ops::concat (di.dir_name,
-                                                                  rel_flist[j]));
-            }
-        }
-    }
-
-  return retlist;
-}
-
-string_vector
-load_path::do_dirs (void) const
-{
-  size_t len = dir_info_list.size ();
-
-  string_vector retval (len);
-
-  octave_idx_type k = 0;
-
-  for (const auto& di : dir_info_list)
-    retval[k++] = di.dir_name;
-
-  return retval;
-}
-
-std::list<std::string>
-load_path::do_dir_list (void) const
-{
-  std::list<std::string> retval;
-
-  for (const auto& di : dir_info_list)
-    retval.push_back (di.dir_name);
-
-  return retval;
-}
-
-string_vector
-load_path::do_files (const std::string& dir, bool omit_exts) const
-{
-  string_vector retval;
-
-  const_dir_info_list_iterator p = find_dir_info (dir);
-
-  if (p != dir_info_list.end ())
-    retval = p->fcn_files;
-
-  if (omit_exts)
-    {
-      octave_idx_type len = retval.numel ();
-
-      for (octave_idx_type i = 0; i < len; i++)
-        {
-          std::string fname = retval[i];
-
-          size_t pos = fname.rfind ('.');
-
-          if (pos != std::string::npos)
-            retval[i] = fname.substr (0, pos);
-        }
-    }
-
-  return retval;
-}
-
-string_vector
-load_path::do_fcn_names (void) const
-{
-  return top_level_package.fcn_names ();
-}
-
 string_vector
 load_path::package_info::fcn_names (void) const
 {
   size_t len = fcn_map.size ();
 
   string_vector retval (len);
 
   octave_idx_type count = 0;
 
   for (const auto& nm_filst : fcn_map)
     retval[count++] = nm_filst.first;
 
   return retval;
 }
 
-std::string
-load_path::do_path (void) const
-{
-  std::string xpath;
-
-  string_vector xdirs = load_path::dirs ();
-
-  octave_idx_type len = xdirs.numel ();
-
-  if (len > 0)
-    xpath = xdirs[0];
-
-  for (octave_idx_type i = 1; i < len; i++)
-    xpath += octave::directory_path::path_sep_str () + xdirs[i];
-
-  return xpath;
-}
-
 void
-print_types (std::ostream& os, int types)
-{
-  bool printed_type = false;
-
-  if (types & load_path::OCT_FILE)
-    {
-      os << "oct";
-      printed_type = true;
-    }
-
-  if (types & load_path::MEX_FILE)
-    {
-      if (printed_type)
-        os << "|";
-      os << "mex";
-      printed_type = true;
-    }
-
-  if (types & load_path::M_FILE)
-    {
-      if (printed_type)
-        os << "|";
-      os << "m";
-      printed_type = true;
-    }
-}
-
-void
-print_fcn_list (std::ostream& os,
-                const load_path::dir_info::fcn_file_map_type& lst)
-{
-  for (const auto& nm_typ : lst)
-    {
-      os << "  " << nm_typ.first << " (";
-
-      print_types (os, nm_typ.second);
-
-      os << ")\n";
-    }
-}
-
-string_vector
-get_file_list (const load_path::dir_info::fcn_file_map_type& lst)
-{
-  octave_idx_type n = lst.size ();
-
-  string_vector retval (n);
-
-  octave_idx_type count = 0;
-
-  for (const auto& nm_typ : lst)
-    {
-      std::string nm = nm_typ.first;
-
-      int types = nm_typ.second;
-
-      if (types & load_path::OCT_FILE)
-        nm += ".oct";
-      else if (types & load_path::MEX_FILE)
-        nm += ".mex";
-      else
-        nm += ".m";
-
-      retval[count++] = nm;
-    }
-
-  return retval;
-}
-
-void
-load_path::do_display (std::ostream& os) const
-{
-  for (const auto& di : dir_info_list)
-    {
-      string_vector fcn_files = di.fcn_files;
-
-      if (! fcn_files.empty ())
-        {
-          os << "\n*** function files in " << di.dir_name << ":\n\n";
-
-          fcn_files.list_in_columns (os);
-        }
-
-      const dir_info::method_file_map_type& method_file_map
-        = di.method_file_map;
-
-      if (! method_file_map.empty ())
-        {
-          for (const auto& cls_ci : method_file_map)
-            {
-              os << "\n*** methods in " << di.dir_name
-                 << "/@" << cls_ci.first << ":\n\n";
-
-              const dir_info::class_info& ci = cls_ci.second;
-
-              string_vector method_files = get_file_list (ci.method_file_map);
-
-              method_files.list_in_columns (os);
-            }
-        }
-    }
-
-  top_level_package.display (os);
-
-  for (const auto& nm_ldr : package_map)
-    nm_ldr.second.display (os);
-}
-
-// True if a path is contained in a path list separated by path_sep_char
-static bool
-in_path_list (const std::string& path_list, const std::string& path)
-{
-  size_t ps = path.size ();
-  size_t pls = path_list.size ();
-  size_t pos = path_list.find (path);
-  char psc = octave::directory_path::path_sep_char ();
-  while (pos != std::string::npos)
-    {
-      if ((pos == 0 || path_list[pos-1] == psc)
-          && (pos + ps == pls || path_list[pos + ps] == psc))
-        return true;
-      else
-        pos = path_list.find (path, pos + 1);
-    }
-
-  return false;
-}
-
-void
-load_path::add (const dir_info& di, bool at_end,
-                const std::string& pname, bool updating) const
-{
-  package_info& pkg = get_package (pname);
-
-  pkg.add (di, at_end, updating);
-
-  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
-
-  for (const auto& pkg_di : package_dir_map)
-    {
-      std::string full_name = pkg_di.first;
-
-      if (! pname.empty ())
-        full_name = pname + "." + full_name;
-
-      add (pkg_di.second, at_end, full_name);
-    }
-}
-
-void
-load_path::package_info::add_to_fcn_map (const dir_info& di, bool at_end,
-                                   bool updating)
+load_path::package_info::add_to_fcn_map (const dir_info& di,
+                                         bool at_end, bool updating)
 {
   std::string dir_name = di.dir_name;
 
   string_vector fcn_files = di.fcn_files;
 
   octave_idx_type len = fcn_files.numel ();
 
   for (octave_idx_type i = 0; i < len; i++)
@@ -2007,77 +1794,329 @@ load_path::package_info::add_to_method_m
       dir_info::fcn_file_map_type private_file_map = ci.private_file_map;
 
       if (! private_file_map.empty ())
         private_fcn_map[full_dir_name] = private_file_map;
     }
 }
 
 void
-load_path::package_info::display (std::ostream& os) const
+load_path::package_info::move_fcn_map (const std::string& dir_name,
+                                       const string_vector& fcn_files, bool at_end)
 {
-  os << "*** package info: "
-     << (m_package_name.empty () ? "<top-level>" : m_package_name) << "\n\n";
-
-  for (const auto& dir : dir_list)
-    os << dir << "\n";
-  os << "\n";
-
-  for (const auto& dir_fnlst : private_fcn_map)
+  octave_idx_type len = fcn_files.numel ();
+
+  for (octave_idx_type k = 0; k < len; k++)
     {
-      os << "\n*** private functions in "
-         << octave::sys::file_ops::concat (dir_fnlst.first, "private") << ":\n\n";
-
-      print_fcn_list (os, dir_fnlst.second);
-    }
-
-#if defined (DEBUG_LOAD_PATH)
-
-  for (const auto& nm_filst : fcn_map)
-    {
-      os << nm_filst.first << ":\n";
-
-      const file_info_list_type& file_info_list = nm_filst.second;
-
-      for (const auto& finfo : file_info_list)
+      std::string fname = fcn_files[k];
+
+      std::string ext;
+      std::string base = fname;
+
+      size_t pos = fname.rfind ('.');
+
+      if (pos != std::string::npos)
+        {
+          base = fname.substr (0, pos);
+          ext = fname.substr (pos);
+        }
+
+      file_info_list_type& file_info_list = fcn_map[base];
+
+      if (file_info_list.size () == 1)
+        continue;
+      else
         {
-          os << "  " << finfo.dir_name << " (";
-
-          print_types (os, finfo.types);
-
-          os << ")\n";
+          for (auto fi_it = file_info_list.begin ();
+               fi_it != file_info_list.end ();
+               fi_it++)
+            {
+              if (fi_it->dir_name == dir_name)
+                {
+                  file_info fi_tmp = *fi_it;
+
+                  file_info_list.erase (fi_it);
+
+                  if (at_end)
+                    file_info_list.push_back (fi_tmp);
+                  else
+                    file_info_list.push_front (fi_tmp);
+
+                  break;
+                }
+            }
         }
     }
-
-  for (const auto& cls_fnmap : method_map)
+}
+
+void
+load_path::package_info::move_method_map (const std::string& dir_name, bool at_end)
+{
+  for (auto& cls_fnmap : method_map)
     {
-      os << "CLASS " << cls_fnmap.first << ":\n";
-
-      const fcn_map_type& fm = cls_fnmap.second;
-
-      for (const auto& nm_fnlst : fcn_map)
+      std::string class_name = cls_fnmap.first;
+
+      fcn_map_type& fn_map = cls_fnmap.second;
+
+      std::string full_dir_name
+        = octave::sys::file_ops::concat (dir_name, "@" + class_name);
+
+      for (auto& nm_filst : fn_map)
         {
-          os << "  " << nm_fnlst.first << ":\n";
-
-          const file_info_list_type& file_info_list = nm_fnlst.second;
-
-          for (const auto& finfo : file_info_list)
+          file_info_list_type& file_info_list = nm_filst.second;
+
+          if (file_info_list.size () == 1)
+            continue;
+          else
             {
-              os << "  " << finfo.dir_name << " (";
-
-              print_types (os, finfo.types);
-
-              os << ")\n";
+              for (auto fi_it = file_info_list.begin ();
+                   fi_it != file_info_list.end (); fi_it++)
+                {
+                  if (fi_it->dir_name == full_dir_name)
+                    {
+                      file_info fi_tmp = *fi_it;
+
+                      file_info_list.erase (fi_it);
+
+                      if (at_end)
+                        file_info_list.push_back (fi_tmp);
+                      else
+                        file_info_list.push_front (fi_tmp);
+
+                      break;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void
+load_path::package_info::remove_fcn_map (const std::string& dir,
+                                         const string_vector& fcn_files)
+{
+  octave_idx_type len = fcn_files.numel ();
+
+  for (octave_idx_type k = 0; k < len; k++)
+    {
+      std::string fname = fcn_files[k];
+
+      std::string ext;
+      std::string base = fname;
+
+      size_t pos = fname.rfind ('.');
+
+      if (pos != std::string::npos)
+        {
+          base = fname.substr (0, pos);
+          ext = fname.substr (pos);
+        }
+
+      file_info_list_type& file_info_list = fcn_map[base];
+
+      for (auto fi_it = file_info_list.begin ();
+           fi_it != file_info_list.end ();
+           fi_it++)
+        {
+          if (fi_it->dir_name == dir)
+            {
+              file_info_list.erase (fi_it);
+
+              if (file_info_list.empty ())
+                fcn_map.erase (fname);
+
+              break;
             }
         }
     }
-
-  os << "\n";
-
-#endif
+}
+
+void
+load_path::package_info::remove_private_fcn_map (const std::string& dir)
+{
+  private_fcn_map_iterator p = private_fcn_map.find (dir);
+
+  if (p != private_fcn_map.end ())
+    private_fcn_map.erase (p);
+}
+
+void
+load_path::package_info::remove_method_map (const std::string& dir)
+{
+  for (auto& cls_fnmap : method_map)
+    {
+      std::string class_name = cls_fnmap.first;
+
+      fcn_map_type& fn_map = cls_fnmap.second;
+
+      std::string full_dir_name
+        = octave::sys::file_ops::concat (dir, "@" + class_name);
+
+      for (auto& nm_filst : fn_map)
+        {
+          file_info_list_type& file_info_list = nm_filst.second;
+
+          if (file_info_list.size () == 1)
+            continue;
+          else
+            {
+              for (auto fi_it = file_info_list.begin ();
+                   fi_it != file_info_list.end (); fi_it++)
+                {
+                  if (fi_it->dir_name == full_dir_name)
+                    {
+                      file_info_list.erase (fi_it);
+                      // FIXME: if there are no other elements, we
+                      // should remove this element of fn_map but calling
+                      // erase here would invalidate the iterator fi_it.
+
+                      break;
+                    }
+                }
+            }
+        }
+    }
+}
+
+bool
+load_path::package_info::check_file_type (std::string& fname, int type,
+                                          int possible_types,
+                                          const std::string& fcn,
+                                          const char *who) const
+{
+  bool retval = false;
+
+  if (type == load_path::OCT_FILE)
+    {
+      if ((type & possible_types) == load_path::OCT_FILE)
+        {
+          fname += ".oct";
+          retval = true;
+        }
+    }
+  else if (type == load_path::M_FILE)
+    {
+      if ((type & possible_types) == load_path::M_FILE)
+        {
+          fname += ".m";
+          retval = true;
+        }
+    }
+  else if (type == load_path::MEX_FILE)
+    {
+      if ((type & possible_types) == load_path::MEX_FILE)
+        {
+          fname += ".mex";
+          retval = true;
+        }
+    }
+  else if (type == (load_path::M_FILE | load_path::OCT_FILE))
+    {
+      if (possible_types & load_path::OCT_FILE)
+        {
+          fname += ".oct";
+          retval = true;
+        }
+      else if (possible_types & load_path::M_FILE)
+        {
+          fname += ".m";
+          retval = true;
+        }
+    }
+  else if (type == (load_path::M_FILE | load_path::MEX_FILE))
+    {
+      if (possible_types & load_path::MEX_FILE)
+        {
+          fname += ".mex";
+          retval = true;
+        }
+      else if (possible_types & load_path::M_FILE)
+        {
+          fname += ".m";
+          retval = true;
+        }
+    }
+  else if (type == (load_path::OCT_FILE | load_path::MEX_FILE))
+    {
+      if (possible_types & load_path::OCT_FILE)
+        {
+          fname += ".oct";
+          retval = true;
+        }
+      else if (possible_types & load_path::MEX_FILE)
+        {
+          fname += ".mex";
+          retval = true;
+        }
+    }
+  else if (type == (load_path::M_FILE | load_path::OCT_FILE
+                    | load_path::MEX_FILE))
+    {
+      if (possible_types & load_path::OCT_FILE)
+        {
+          fname += ".oct";
+          retval = true;
+        }
+      else if (possible_types & load_path::MEX_FILE)
+        {
+          fname += ".mex";
+          retval = true;
+        }
+      else if (possible_types & load_path::M_FILE)
+        {
+          fname += ".m";
+          retval = true;
+        }
+    }
+  else
+    error ("%s: %s: invalid type code = %d", who, fcn.c_str (), type);
+
+  return retval;
+}
+
+void
+load_path::package_info::print_types (std::ostream& os, int types) const
+{
+  bool printed_type = false;
+
+  if (types & load_path::OCT_FILE)
+    {
+      os << "oct";
+      printed_type = true;
+    }
+
+  if (types & load_path::MEX_FILE)
+    {
+      if (printed_type)
+        os << "|";
+      os << "mex";
+      printed_type = true;
+    }
+
+  if (types & load_path::M_FILE)
+    {
+      if (printed_type)
+        os << "|";
+      os << "m";
+      printed_type = true;
+    }
+}
+
+void
+load_path::package_info::print_fcn_list (std::ostream& os,
+                                         const load_path::dir_info::fcn_file_map_type& lst) const
+{
+  for (const auto& nm_typ : lst)
+    {
+      os << "  " << nm_typ.first << " (";
+
+      print_types (os, nm_typ.second);
+
+      os << ")\n";
+    }
 }
 
 std::string
 genpath (const std::string& dirname, const string_vector& skip)
 {
   std::string retval;
 
   octave::sys::dir_entry dir (dirname);
@@ -2117,59 +2156,16 @@ genpath (const std::string& dirname, con
                 }
             }
         }
     }
 
   return retval;
 }
 
-std::list<std::string>
-load_path::do_get_all_package_names (bool only_top_level) const
-{
-  std::list<std::string> retval;
-
-  for (const auto& dir_ldr : package_map)
-    {
-      if (! only_top_level || dir_ldr.first.find ('.') == std::string::npos)
-        retval.push_back (dir_ldr.first);
-    }
-
-  return retval;
-}
-
-static void
-execute_pkg_add_or_del (const std::string& dir,
-                        const std::string& script_file)
-{
-  if (! octave_interpreter_ready)
-    return;
-
-  octave::unwind_protect frame;
-
-  std::string file = octave::sys::file_ops::concat (dir, script_file);
-
-  octave::sys::file_stat fs (file);
-
-  if (fs.exists ())
-    octave::source_file (file, "base");
-}
-
-void
-load_path::execute_pkg_add (const std::string& dir)
-{
-  execute_pkg_add_or_del (dir, "PKG_ADD");
-}
-
-void
-load_path::execute_pkg_del (const std::string& dir)
-{
-  execute_pkg_add_or_del (dir, "PKG_DEL");
-}
-
 DEFUN (genpath, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} genpath (@var{dir})
 @deftypefnx {} {} genpath (@var{dir}, @var{skip}, @dots{})
 Return a path constructed from @var{dir} and all its subdirectories.
 
 If additional string parameters are given, the resulting path will exclude
 directories with those names.
@@ -2198,75 +2194,77 @@ directories with those names.
         skip[i-1] = args(i).xstring_value ("genpath: all arguments must be strings");
 
       retval = genpath (dirname, skip);
     }
 
   return retval;
 }
 
-static void
-rehash_internal (void)
-{
-  load_path::update ();
-
-  // FIXME: maybe we should rename this variable since it is being
-  // used for more than keeping track of the prompt time.
-
-  // This will force updated functions to be found.
-  Vlast_prompt_time.stamp ();
-}
-
 DEFUN (rehash, , ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} rehash ()
 Reinitialize Octave's load path directory cache.
 @end deftypefn */)
 {
   rehash_internal ();
 
   return ovl ();
 }
 
-DEFUN (command_line_path, , ,
+DEFUN (command_line_path, args, ,
        doc: /* -*- texinfo -*-
-@deftypefn {} {} command_line_path (@dots{})
+@deftypefn {} {} command_line_path ()
 Return the command line path variable.
 
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}
 @end deftypefn */)
 {
-  return ovl (load_path::get_command_line_path ());
+  if (! args.empty ())
+    print_usage ();
+
+  load_path& lp = octave::__get_load_path__ ("command_line_path");
+
+  return ovl (lp.get_command_line_path ());
 }
 
-DEFUN (restoredefaultpath, , ,
+DEFUN (restoredefaultpath, args, ,
        doc: /* -*- texinfo -*-
-@deftypefn {} {} restoredefaultpath (@dots{})
+@deftypefn {} {} restoredefaultpath ()
 Restore Octave's path to its initial state at startup.
 
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}
 @end deftypefn */)
 {
-  load_path::initialize (true);
-
-  return ovl (load_path::system_path ());
+  if (! args.empty ())
+    print_usage ();
+
+  load_path& lp = octave::__get_load_path__ ("restoredefaultpath");
+
+  lp.initialize (true);
+
+  return ovl (lp.system_path ());
 }
 
 // Return Octave's original default list of directories in which to
 // search for function files.  This corresponds to the path that
 // exists prior to running the system's octaverc file or the user's
 // ~/.octaverc file
 
 DEFUN (__pathorig__, , ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {@var{val} =} __pathorig__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
-  return ovl (load_path::system_path ());
+  load_path& lp = octave::__get_load_path__ ("__pathorig__");
+
+  lp.initialize (true);
+
+  return ovl (lp.system_path ());
 }
 
 DEFUN (path, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} path ()
 @deftypefnx {} {@var{str} =} path ()
 @deftypefnx {} {@var{str} =} path (@var{path1}, @dots{})
 Modify or display Octave's load path.
@@ -2284,36 +2282,38 @@ to the result and return it.
 No checks are made for duplicate elements.
 @seealso{addpath, rmpath, genpath, pathdef, savepath, pathsep}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   string_vector argv = args.make_argv ("path");
 
+  load_path& lp = octave::__get_load_path__ ("path");
+
   if (nargin > 0)
     {
       std::string path = argv[1];
 
       for (int i = 2; i <= nargin; i++)
         path += octave::directory_path::path_sep_str () + argv[i];
 
-      load_path::set (path, true);
+      lp.set (path, true);
 
       rehash_internal ();
     }
 
   if (nargout > 0)
-    return ovl (load_path::path ());
+    return ovl (lp.path ());
   else if (nargin == 0 && nargout == 0)
     {
       octave_stdout <<
         "\nOctave's search path contains the following directories:\n\n";
 
-      string_vector dirs = load_path::dirs ();
+      string_vector dirs = lp.dirs ();
 
       dirs.list_in_columns (octave_stdout);
 
       octave_stdout << "\n";
     }
 
   return ovl ();
 }
@@ -2346,20 +2346,22 @@ For each directory that is added, and th
   // Originally written by Bill Denney and Etienne Grossman.
   // Heavily modified and translated to C++ by jwe.
 
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
+  load_path& lp = octave::__get_load_path__ ("addpath");
+
   octave_value retval;
 
   if (nargout > 0)
-    retval = load_path::path ();
+    retval = lp.path ();
 
   bool append = false;
 
   octave_value option_arg = args(nargin-1);
 
   if (option_arg.is_string ())
     {
       std::string option = option_arg.string_value ();
@@ -2409,19 +2411,19 @@ For each directory that is added, and th
                                   [](char l, char r)
                                   {
                                     return l == r &&
                                            octave::sys::file_ops::is_dir_sep (l);
                                   }),
                      dir.end ());
 
           if (append)
-            load_path::append (dir, true);
+            lp.append (dir, true);
           else
-            load_path::prepend (dir, true);
+            lp.prepend (dir, true);
 
           need_to_update = true;
         }
     }
 
   if (need_to_update)
     rehash_internal ();
 
@@ -2452,32 +2454,34 @@ and runs it if it exists.
 
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
   octave_value retval;
 
+  load_path& lp = octave::__get_load_path__ ("rmpath");
+
   if (nargout > 0)
-    retval = load_path::path ();
+    retval = lp.path ();
 
   bool need_to_update = false;
 
   for (int i = 0; i < nargin; i++)
     {
       std::string arg = args(i).xstring_value ("rmpath: all arguments must be strings");
       std::list<std::string> dir_elts = split_path (arg);
 
       for (const auto& dir : dir_elts)
         {
           //dir = regexprep (dir_elts{j}, '//+', "/");
           //dir = regexprep (dir, '/$', "");
 
-          if (! load_path::remove (dir))
+          if (! lp.remove (dir))
             warning ("rmpath: %s: not found", dir.c_str ());
           else
             need_to_update = true;
         }
     }
 
   if (need_to_update)
     rehash_internal ();
@@ -2486,12 +2490,14 @@ and runs it if it exists.
 }
 
 DEFUN (__dump_load_path__, , ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} __dump_load_path__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
-  load_path::display (octave_stdout);
+  load_path& lp = octave::__get_load_path__ ("__dump_load_path__");
+
+  lp.display (octave_stdout);
 
   return ovl ();
 }
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -27,271 +27,170 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <iosfwd>
 #include <list>
 #include <map>
 #include <set>
 #include <string>
 
+#include "oct-time.h"
 #include "pathsearch.h"
 #include "str-vec.h"
 
 class
 OCTINTERP_API
 load_path
 {
-protected:
+public:
 
   load_path (void)
-    : package_map (), top_level_package (), dir_info_list (), init_dirs () { }
-
-public:
+    : package_map (), top_level_package (), dir_info_list (), init_dirs (),
+      m_command_line_path (), add_hook (load_path::execute_pkg_add),
+      remove_hook (load_path::execute_pkg_del)
+    { }
 
   typedef void (*hook_fcn_ptr) (const std::string& dir);
 
+  load_path (const load_path&) = delete;
+
+  load_path& operator = (const load_path&) = delete;
+
   ~load_path (void) = default;
 
-  static void initialize (bool set_initial_path = false)
-  {
-    if (instance_ok ())
-      instance->do_initialize (set_initial_path);
-  }
+  void initialize (bool set_initial_path = false);
+
+  void clear (void);
+
+  void set (const std::string& p, bool warn = false, bool is_init = false);
+
+  void append (const std::string& dir, bool warn = false);
+
+  void prepend (const std::string& dir, bool warn = false);
 
-  static void clear (void)
-  {
-    if (instance_ok ())
-      instance->do_clear ();
-  }
+  bool remove (const std::string& dir);
+
+  void update (void) const;
 
-  static void set (const std::string& p, bool warn = false)
+  bool contains_canonical (const std::string& dir_name) const;
+
+  std::string find_method (const std::string& class_name,
+                           const std::string& meth,
+                           std::string& dir_name,
+                           const std::string& pack_name = "")
   {
-    if (instance_ok ())
-      instance->do_set (p, warn);
-  }
-
-  static void append (const std::string& dir, bool warn = false)
-  {
-    if (instance_ok ())
-      instance->do_append (dir, warn);
-  }
-
-  static void prepend (const std::string& dir, bool warn = false)
-  {
-    if (instance_ok ())
-      instance->do_prepend (dir, warn);
+    return get_package (pack_name).find_method (class_name, meth, dir_name);
   }
 
-  static bool remove (const std::string& dir)
-  {
-    return instance_ok () ? instance->do_remove (dir) : false;
-  }
-
-  static void update (void)
-  {
-    if (instance_ok ())
-      instance->do_update ();
-  }
-
-  static bool contains_canonical (const std::string& dir_name)
-  {
-    return instance_ok () ? instance->do_contains_canonical (dir_name) : false;
-  }
-
-  static std::string find_method (const std::string& class_name,
-                                  const std::string& meth,
-                                  std::string& dir_name,
-                                  const std::string& pack_name = "")
-  {
-    return instance_ok ()
-      ? instance->get_package (pack_name).find_method (class_name, meth,
-                                                      dir_name)
-      : "";
-  }
-
-  static std::string find_method (const std::string& class_name,
-                                  const std::string& meth,
-                                  const std::string& pack_name = "")
+  std::string find_method (const std::string& class_name,
+                           const std::string& meth,
+                           const std::string& pack_name = "")
   {
     std::string dir_name;
     return find_method (class_name, meth, dir_name, pack_name);
   }
 
-  static std::list<std::string> methods (const std::string& class_name,
-                                         const std::string& pack_name = "")
+  std::list<std::string> methods (const std::string& class_name,
+                                  const std::string& pack_name = "")
   {
-    return instance_ok ()
-      ? instance->get_package (pack_name).methods (class_name)
-      : std::list<std::string> ();
-  }
-
-  static std::list<std::string> overloads (const std::string& meth)
-  {
-    return instance_ok ()
-           ? instance->do_overloads (meth) : std::list<std::string> ();
+    return get_package (pack_name).methods (class_name);
   }
 
-  static bool find_package (const std::string& package_name)
+  std::list<std::string> overloads (const std::string& meth) const;
+
+  bool find_package (const std::string& package_name) const
   {
-    return instance_ok ()
-      ? instance->do_find_package (package_name) : false;
+    return (package_map.find (package_name) != package_map.end ());
   }
 
-  static std::list<std::string>
-  get_all_package_names (bool only_top_level = true)
+  std::list<std::string> get_all_package_names (bool only_top_level = true) const;
+
+  std::string find_fcn (const std::string& fcn, std::string& dir_name,
+                        const std::string& pack_name = "")
   {
-    return instance_ok ()
-      ? instance->do_get_all_package_names (only_top_level)
-      : std::list<std::string> ();
+    return get_package (pack_name).find_fcn (fcn, dir_name);
   }
 
-  static std::string find_fcn (const std::string& fcn, std::string& dir_name,
-                               const std::string& pack_name = "")
-  {
-    return instance_ok ()
-      ? instance->get_package (pack_name).find_fcn (fcn, dir_name)
-      : "";
-  }
-
-  static std::string find_fcn (const std::string& fcn,
-                               const std::string& pack_name = "")
+  std::string find_fcn (const std::string& fcn,
+                        const std::string& pack_name = "")
   {
     std::string dir_name;
     return find_fcn (fcn, dir_name, pack_name);
   }
 
-  static std::string find_private_fcn (const std::string& dir,
-                                       const std::string& fcn,
-                                       const std::string& pack_name = "")
+  std::string find_private_fcn (const std::string& dir,
+                                const std::string& fcn,
+                                const std::string& pack_name = "")
   {
-    return instance_ok ()
-      ? instance->get_package (pack_name).find_private_fcn (dir, fcn)
-      : "";
+    return get_package (pack_name).find_private_fcn (dir, fcn);
   }
 
-  static std::string find_fcn_file (const std::string& fcn,
-                                    const std::string& pack_name = "")
-  {
-    std::string dir_name;
-
-    return instance_ok ()
-      ? instance->get_package (pack_name).find_fcn (fcn, dir_name, M_FILE)
-      : "";
-  }
-
-  static std::string find_oct_file (const std::string& fcn,
-                                    const std::string& pack_name = "")
+  std::string find_fcn_file (const std::string& fcn,
+                             const std::string& pack_name = "")
   {
     std::string dir_name;
-
-    return instance_ok ()
-      ? instance->get_package (pack_name).find_fcn (fcn, dir_name, M_FILE)
-      : "";
+    return get_package (pack_name).find_fcn (fcn, dir_name, M_FILE);
   }
 
-  static std::string find_mex_file (const std::string& fcn,
-                                    const std::string& pack_name = "")
+  std::string find_oct_file (const std::string& fcn,
+                             const std::string& pack_name = "")
   {
     std::string dir_name;
-
-    return instance_ok ()
-      ? instance->get_package (pack_name).find_fcn (fcn, dir_name, M_FILE)
-      : "";
+    return get_package (pack_name).find_fcn (fcn, dir_name, M_FILE);
   }
 
-  static std::string find_file (const std::string& file)
+  std::string find_mex_file (const std::string& fcn,
+                             const std::string& pack_name = "")
   {
-    return instance_ok ()
-           ? instance->do_find_file (file) : "";
-  }
-
-  static std::string find_dir (const std::string& dir)
-  {
-    return instance_ok ()
-           ? instance->do_find_dir (dir) : "";
+    std::string dir_name;
+    return get_package (pack_name).find_fcn (fcn, dir_name, M_FILE);
   }
 
-  static string_vector find_matching_dirs (const std::string& dir)
-  {
-    return instance_ok ()
-           ? instance->do_find_matching_dirs (dir) : string_vector ();
-  }
+  std::string find_file (const std::string& file) const;
+
+  std::string find_dir (const std::string& dir) const;
+
+  string_vector find_matching_dirs (const std::string& dir) const;
 
-  static std::string find_first_of (const string_vector& files)
-  {
-    return instance_ok () ?
-           instance->do_find_first_of (files) : "";
-  }
+  std::string find_first_of (const string_vector& files) const;
+
+  string_vector find_all_first_of (const string_vector& files) const;
 
-  static string_vector find_all_first_of (const string_vector& files)
-  {
-    return instance_ok () ?
-           instance->do_find_all_first_of (files) : string_vector ();
-  }
+  string_vector dirs (void) const;
 
-  static string_vector dirs (void)
-  {
-    return instance_ok () ? instance->do_dirs () : string_vector ();
-  }
+  std::list<std::string> dir_list (void) const;
 
-  static std::list<std::string> dir_list (void)
-  {
-    return instance_ok ()
-           ? instance->do_dir_list () : std::list<std::string> ();
-  }
+  string_vector files (const std::string& dir, bool omit_exts = false) const;
 
-  static string_vector files (const std::string& dir, bool omit_exts = false)
-  {
-    return instance_ok ()
-           ? instance->do_files (dir, omit_exts) : string_vector ();
-  }
+  string_vector fcn_names (void) const;
 
-  static string_vector fcn_names (void)
-  {
-    return instance_ok () ? instance->do_fcn_names () : string_vector ();
-  }
+  std::string path (void) const;
 
-  static std::string path (void)
-  {
-    return instance_ok () ? instance->do_path () : "";
-  }
+  void display (std::ostream& os) const;
 
-  static void display (std::ostream& os)
-  {
-    if (instance_ok ())
-      instance->do_display (os);
-  }
+  hook_fcn_ptr get_add_hook (void) { return add_hook; }
+  hook_fcn_ptr get_remove_hook (void) { return remove_hook; }
 
-  static hook_fcn_ptr get_add_hook (void) { return add_hook; }
-  static hook_fcn_ptr get_remove_hook (void) { return remove_hook; }
-
-  static void set_add_hook (hook_fcn_ptr f) { add_hook = f; }
-  static void set_remove_hook (hook_fcn_ptr f) { remove_hook = f; }
+  void set_add_hook (hook_fcn_ptr f) { add_hook = f; }
+  void set_remove_hook (hook_fcn_ptr f) { remove_hook = f; }
 
   static void execute_pkg_add (const std::string& dir);
   static void execute_pkg_del (const std::string& dir);
 
-  static void set_command_line_path (const std::string& p)
+  void set_command_line_path (const std::string& p)
   {
-    if (command_line_path.empty ())
-      command_line_path = p;
+    if (m_command_line_path.empty ())
+      m_command_line_path = p;
     else
-      command_line_path += octave::directory_path::path_sep_str () + p;
+      m_command_line_path += octave::directory_path::path_sep_str () + p;
   }
 
-  static std::string get_command_line_path (void)
-  {
-    return instance_ok () ? instance->do_get_command_line_path ()
-                          : "";
-  }
+  std::string get_command_line_path (void) const { return m_command_line_path; }
 
-  static std::string system_path (void)
-  {
-    return instance_ok () ? instance->do_system_path () : "";
-  }
+  std::string system_path (void) const { return sys_path; }
 
 private:
 
   static const int M_FILE = 1;
   static const int OCT_FILE = 2;
   static const int MEX_FILE = 4;
 
   class dir_info
@@ -338,62 +237,31 @@ private:
     typedef std::map<std::string, dir_info> package_dir_map_type;
 
     typedef package_dir_map_type::const_iterator const_package_dir_map_iterator;
     typedef package_dir_map_type::iterator package_dir_map_iterator;
 
     // This default constructor is only provided so we can create a
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
-    dir_info (void)
-      : dir_name (), abs_dir_name (), is_relative (false),
-        dir_mtime (), dir_time_last_checked (),
-        all_files (), fcn_files (), private_file_map (), method_file_map (),
-        package_dir_map ()
-    { }
+    dir_info (void) = default;
 
     dir_info (const std::string& d)
       : dir_name (d), abs_dir_name (), is_relative (false),
-        dir_mtime (), dir_time_last_checked (),
-        all_files (), fcn_files (), private_file_map (), method_file_map (),
-        package_dir_map ()
+        dir_mtime (), dir_time_last_checked (), all_files (), fcn_files (),
+        private_file_map (), method_file_map (), package_dir_map ()
     {
       initialize ();
     }
 
-    dir_info (const dir_info& di)
-      : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
-        is_relative (di.is_relative),
-        dir_mtime (di.dir_mtime),
-        dir_time_last_checked (di.dir_time_last_checked),
-        all_files (di.all_files), fcn_files (di.fcn_files),
-        private_file_map (di.private_file_map),
-        method_file_map (di.method_file_map),
-        package_dir_map (di.package_dir_map) { }
+    dir_info (const dir_info& di) = default;
 
     ~dir_info (void) = default;
 
-    dir_info& operator = (const dir_info& di)
-    {
-      if (&di != this)
-        {
-          dir_name = di.dir_name;
-          abs_dir_name = di.abs_dir_name;
-          is_relative = di.is_relative;
-          dir_mtime = di.dir_mtime;
-          dir_time_last_checked = di.dir_time_last_checked;
-          all_files = di.all_files;
-          fcn_files = di.fcn_files;
-          private_file_map = di.private_file_map;
-          method_file_map = di.method_file_map;
-          package_dir_map = di.package_dir_map;
-        }
-
-      return *this;
-    }
+    dir_info& operator = (const dir_info& di) = default;
 
     void update (void);
 
     std::string dir_name;
     std::string abs_dir_name;
     bool is_relative;
     octave::sys::time dir_mtime;
     octave::sys::time dir_time_last_checked;
@@ -493,16 +361,17 @@ private:
   typedef std::map<std::string, fcn_map_type> method_map_type;
 
   typedef method_map_type::const_iterator const_method_map_iterator;
   typedef method_map_type::iterator method_map_iterator;
 
   class package_info
   {
   public:
+
     package_info (const std::string& package_name = "")
       : m_package_name (package_name), dir_list (), fcn_map (), private_fcn_map (),
         method_map () { }
 
     package_info (const package_info& l)
       : m_package_name (l.m_package_name), dir_list (l.dir_list),
         private_fcn_map (l.private_fcn_map), method_map (l.method_map) { }
 
@@ -568,16 +437,17 @@ private:
 
     std::list<std::string> methods (const std::string& class_name) const;
 
     void overloads (const std::string& meth, std::list<std::string>& l) const;
 
     string_vector fcn_names (void) const;
 
   private:
+
     void add_to_fcn_map (const dir_info& di, bool at_end, bool updating);
 
     void add_to_private_fcn_map (const dir_info& di);
 
     void add_to_method_map (const dir_info& di, bool at_end);
 
     void move_fcn_map (const std::string& dir,
                        const string_vector& fcn_files, bool at_end);
@@ -586,158 +456,94 @@ private:
 
     void remove_fcn_map (const std::string& dir,
                          const string_vector& fcn_files);
 
     void remove_private_fcn_map (const std::string& dir);
 
     void remove_method_map (const std::string& dir);
 
-  private:
+    bool check_file_type (std::string& fname, int type, int possible_types,
+                          const std::string& fcn, const char *who) const;
+
+    void print_types (std::ostream& os, int types) const;
+
+    void print_fcn_list (std::ostream& os,
+                         const dir_info::fcn_file_map_type& lst) const;
 
     std::string m_package_name;
 
     std::list<std::string> dir_list;
 
     fcn_map_type fcn_map;
 
     private_fcn_map_type private_fcn_map;
 
     method_map_type method_map;
   };
 
-  // <PACKAGE_NAME, LOADER>
+  // <PACKAGE_NAME, PACKAGE_INFO>
   typedef std::map<std::string, package_info> package_map_type;
 
   typedef package_map_type::const_iterator const_package_map_iterator;
   typedef package_map_type::iterator package_map_iterator;
 
   mutable package_map_type package_map;
 
   mutable package_info top_level_package;
 
   mutable dir_info_list_type dir_info_list;
 
   mutable std::set<std::string> init_dirs;
 
-  static load_path *instance;
-
-  static void cleanup_instance (void) { delete instance; instance = 0; }
-
-  static hook_fcn_ptr add_hook;
-
-  static hook_fcn_ptr remove_hook;
-
-  static std::string command_line_path;
+  std::string m_command_line_path;
 
   static std::string sys_path;
 
   static abs_dir_cache_type abs_dir_cache;
 
-  static bool instance_ok (void);
+  hook_fcn_ptr add_hook;
+
+  hook_fcn_ptr remove_hook;
 
   const_dir_info_list_iterator find_dir_info (const std::string& dir) const;
   dir_info_list_iterator find_dir_info (const std::string& dir);
 
   bool contains (const std::string& dir) const;
 
-  bool do_contains_canonical (const std::string& dir) const;
-
-  void do_move (dir_info_list_iterator i, bool at_end);
-
-  void move (const dir_info& di, bool at_end,
-             const std::string& pname = "");
+  void move (dir_info_list_iterator i, bool at_end);
 
-  void remove (const dir_info& di,
-               const std::string& pname = "");
-
-  void do_initialize (bool set_initial_path);
-
-  void do_clear (void);
+  void move (const dir_info& di, bool at_end, const std::string& pname = "");
 
-  void do_set (const std::string& p, bool warn, bool is_init = false);
-
-  void do_append (const std::string& dir, bool warn);
-
-  void do_prepend (const std::string& dir, bool warn);
-
-  void do_add (const std::string& dir, bool at_end, bool warn);
+  void remove (const dir_info& di, const std::string& pname = "");
 
-  bool do_remove (const std::string& dir);
-
-  void do_update (void) const;
+  void add (const std::string& dir, bool at_end, bool warn);
 
-  static bool
-  check_file_type (std::string& fname, int type, int possible_types,
-                   const std::string& fcn, const char *who);
+  void add (const dir_info& di, bool at_end, const std::string& pname = "",
+            bool updating = false) const;
 
   bool is_package (const std::string& name) const;
 
   package_info& get_package (const std::string& name) const
   {
     if (! name.empty () && is_package (name))
       {
-        package_map_iterator pi = package_map.find (name);
+        package_map_iterator l = package_map.find (name);
 
-        if (pi == package_map.end ())
-          pi = package_map.insert (package_map.end (),
-                                   package_map_type::value_type (name, package_info (name)));
+        if (l == package_map.end ())
+          l = package_map.insert (package_map.end (),
+                                  package_map_type::value_type (name, package_info (name)));
 
-        return pi->second;
+        return l->second;
       }
 
     return top_level_package;
   }
 
-  std::list<std::string> do_overloads (const std::string& meth) const;
-
-  bool do_find_package (const std::string& package_name) const
-  {
-    return (package_map.find (package_name) != package_map.end ());
-  }
-
-  std::list<std::string> do_get_all_package_names (bool only_top_level) const;
-
-  std::string do_find_file (const std::string& file) const;
-
-  std::string do_find_dir (const std::string& dir) const;
-
-  string_vector do_find_matching_dirs (const std::string& dir) const;
-
-  std::string do_find_first_of (const string_vector& files) const;
-
-  string_vector do_find_all_first_of (const string_vector& files) const;
-
-  string_vector do_dirs (void) const;
-
-  std::list<std::string> do_dir_list (void) const;
-
-  string_vector do_files (const std::string& dir, bool omit_exts) const;
-
-  string_vector do_fcn_names (void) const;
-
-  std::string do_path (void) const;
-
-  friend void print_types (std::ostream& os, int types);
-
-  friend string_vector get_file_list (const dir_info::fcn_file_map_type& lst);
-
-  friend void
-  print_fcn_list (std::ostream& os, const dir_info::fcn_file_map_type& lst);
-
-  void do_display (std::ostream& os) const;
-
-  std::string do_system_path (void) const { return sys_path; }
-
-  std::string do_get_command_line_path (void) const
-  { return command_line_path; }
-
-  void add (const dir_info& di, bool at_end,
-            const std::string& pname = "",
-            bool updating = false) const;
+  string_vector get_file_list (const dir_info::fcn_file_map_type& lst) const;
 
   friend dir_info::fcn_file_map_type get_fcn_files (const std::string& d);
 };
 
 extern std::string
 genpath (const std::string& dir, const string_vector& skip = "private");
 
 #endif
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -60,16 +60,17 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "ov-class.h"
 #include "ov-fcn-inline.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 #include "ls-utils.h"
@@ -900,17 +901,19 @@ read_mat5_binary_element (std::istream& 
                     else
                       {
                         // Next just search for it anywhere in the system path
                         std::list<std::string> names;
                         names.push_back (fname + ".oct");
                         names.push_back (fname + ".mex");
                         names.push_back (fname + ".m");
 
-                        octave::directory_path p (load_path::system_path ());
+                        load_path& lp = octave::__get_load_path__ ("read_mat5_binary_element");
+
+                        octave::directory_path p (lp.system_path ());
 
                         str =
                           octave::sys::env::make_absolute (p.find_first_of (names));
 
                         size_t xpos
                           = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
@@ -1199,18 +1202,20 @@ read_mat5_binary_element (std::istream& 
 
                 if (cls->reconstruct_exemplar ())
                   {
 
                     if (! cls->reconstruct_parents ())
                       warning ("load: unable to reconstruct object inheritance");
 
                     tc = cls;
-                    if (load_path::find_method (classname, "loadobj")
-                        != "")
+
+                    load_path& lp = octave::__get_load_path__ ("read_mat5_binary_element");
+
+                    if (lp.find_method (classname, "loadobj") != "")
                       {
                         try
                           {
                             octave_value_list tmp = octave::feval ("loadobj", tc, 1);
 
                             tc = tmp(0);
                           }
                         catch (const octave::execution_exception&)
@@ -2595,19 +2600,20 @@ save_mat5_binary_element (std::ostream& 
           OCTAVE_LOCAL_BUFFER (char, paddedname, paddedlength);
           memset (paddedname, 0, paddedlength);
           strncpy (paddedname, classname.c_str (), namelen);
           os.write (paddedname, paddedlength);
         }
 
       octave_map m;
 
+      load_path& lp = octave::__get_load_path__ ("read_mat5_binary_element");
+
       if (tc.is_object ()
-          && load_path::find_method (tc.class_name (),
-                                     "saveobj") != "")
+          && lp.find_method (tc.class_name (), "saveobj") != "")
         {
           try
             {
               octave_value_list tmp = octave::feval ("saveobj", tc, 1);
 
               m = tmp(0).map_value ();
             }
           catch (const octave::execution_exception&)
diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -88,16 +88,17 @@ COREFCN_INC = \
   libinterp/corefcn/variables.h \
   libinterp/corefcn/workspace-element.h \
   libinterp/corefcn/xdiv.h \
   libinterp/corefcn/xnorm.h \
   libinterp/corefcn/xpow.h \
   libinterp/corefcn/zfstream.h
 
 NOINSTALL_COREFCN_INC = \
+  libinterp/corefcn/interpreter-private.h \
   libinterp/corefcn/oct-hdf5.h \
   libinterp/corefcn/oct-opengl.h
 
 ## oct-tex-parser.h is in the SRC list so that it will be distributed
 ## but not installed.
 
 COREFCN_SRC = \
   libinterp/corefcn/Cell.cc \
@@ -161,16 +162,17 @@ COREFCN_SRC = \
   libinterp/corefcn/gsvd.cc \
   libinterp/corefcn/hash.cc \
   libinterp/corefcn/help.cc \
   libinterp/corefcn/hess.cc \
   libinterp/corefcn/hex2num.cc \
   libinterp/corefcn/hook-fcn.cc \
   libinterp/corefcn/input.cc \
   libinterp/corefcn/inv.cc \
+  libinterp/corefcn/interpreter-private.cc \
   libinterp/corefcn/interpreter.cc \
   libinterp/corefcn/kron.cc \
   libinterp/corefcn/load-path.cc \
   libinterp/corefcn/load-save.cc \
   libinterp/corefcn/lookup.cc \
   libinterp/corefcn/ls-ascii-helper.cc \
   libinterp/corefcn/ls-hdf5.cc \
   libinterp/corefcn/ls-mat-ascii.cc \
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "oct-env.h"
 #include "oct-time.h"
 #include "singleton-cleanup.h"
 
 #include "bp-table.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "load-path.h"
 #include "ov-classdef.h"
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-pr-code.h"
 #include "symtab.h"
@@ -259,54 +260,58 @@ out_of_date_check (octave_value& functio
                       else
                         {
                           // We don't want to make this an absolute name,
                           // because load_fcn_file looks at the name to
                           // decide whether it came from a relative lookup.
 
                           if (! dispatch_type.empty ())
                             {
-                              file = load_path::find_method (dispatch_type, nm,
-                                                             dir_name, pack);
+                              load_path& lp = octave::__get_load_path__ ("out_of_date_check");
+
+                              file = lp.find_method (dispatch_type, nm,
+                                                     dir_name, pack);
 
                               if (file.empty ())
                                 {
                                   std::string s_name;
                                   std::string s_pack;
 
                                   const std::list<std::string>& plist
                                     = symbol_table::parent_classes (dispatch_type);
                                   std::list<std::string>::const_iterator it
                                     = plist.begin ();
 
                                   while (it != plist.end ())
                                     {
                                       split_name_with_package (*it, s_name,
                                                                s_pack);
 
-                                      file = load_path::find_method (*it, nm,
-                                                                     dir_name,
-                                                                     s_pack);
+                                      file = lp.find_method (*it, nm, dir_name,
+                                                             s_pack);
                                       if (! file.empty ())
                                         {
                                           pack = s_pack;
                                           break;
                                         }
 
                                       it++;
                                     }
                                 }
                             }
 
                           // Maybe it's an autoload?
                           if (file.empty ())
                             file = octave::lookup_autoload (nm);
 
                           if (file.empty ())
-                            file = load_path::find_fcn (nm, dir_name, pack);
+                            {
+                              load_path& lp = octave::__get_load_path__ ("out_of_date_check");
+                              file = lp.find_fcn (nm, dir_name, pack);
+                            }
                         }
 
                       if (! file.empty ())
                         is_same_file = same_file (file, ff);
                     }
                   else
                     {
                       is_same_file = true;
@@ -382,17 +387,19 @@ out_of_date_check (octave_value& functio
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::load_private_function
   (const std::string& dir_name)
 {
   octave_value retval;
 
-  std::string file_name = load_path::find_private_fcn (dir_name, name);
+  load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_private_function");
+
+  std::string file_name = lp.find_private_fcn (dir_name, name);
 
   if (! file_name.empty ())
     {
       octave_function *fcn = octave::load_fcn_from_file (file_name, dir_name);
 
       if (fcn)
         {
           std::string class_name;
@@ -420,18 +427,19 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::load_class_constructor (void)
 {
   octave_value retval;
 
   std::string dir_name;
 
-  std::string file_name = load_path::find_method (name, name, dir_name,
-                                                  package_name);
+  load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_constructor");
+
+  std::string file_name = lp.find_method (name, name, dir_name, package_name);
 
   if (! file_name.empty ())
     {
       octave_function *fcn
         = octave::load_fcn_from_file (file_name, dir_name, name,
                                       package_name);
 
       if (fcn)
@@ -487,18 +495,20 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
       if (cm)
         retval = octave_value (cm);
 
       if (! retval.is_defined ())
         {
           std::string dir_name;
 
-          std::string file_name = load_path::find_method (dispatch_type, name,
-                                                          dir_name);
+          load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+
+          std::string file_name = lp.find_method (dispatch_type, name,
+                                                  dir_name);
 
           if (! file_name.empty ())
             {
               octave_function *fcn
                 = octave::load_fcn_from_file (file_name, dir_name,
                                               dispatch_type);
 
               if (fcn)
@@ -687,17 +697,19 @@ symbol_table::fcn_info::fcn_info_rep::fi
   octave_value retval = xfind (args, local_funcs);
 
   if (retval.is_undefined ())
     {
       // It is possible that the user created a file on the fly since
       // the last prompt or chdir, so try updating the load path and
       // searching again.
 
-      load_path::update ();
+      load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find");
+
+      lp.update ();
 
       retval = xfind (args, local_funcs);
     }
 
   return retval;
 }
 
 octave_value
@@ -887,17 +899,19 @@ symbol_table::fcn_info::fcn_info_rep::bu
   octave_value retval = x_builtin_find ();
 
   if (! retval.is_defined ())
     {
       // It is possible that the user created a file on the fly since
       // the last prompt or chdir, so try updating the load path and
       // searching again.
 
-      load_path::update ();
+      load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::builtin_find");
+
+      lp.update ();
 
       retval = x_builtin_find ();
     }
 
   return retval;
 }
 
 octave_value
@@ -1085,18 +1099,20 @@ symbol_table::fcn_info::fcn_info_rep::fi
 
   if (function_on_path.is_defined ())
     out_of_date_check (function_on_path);
 
   if (function_on_path.is_undefined ())
     {
       std::string dir_name;
 
-      std::string file_name = load_path::find_fcn (name, dir_name,
-                                                   package_name);
+      load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find_user_function");
+
+
+      std::string file_name = lp.find_fcn (name, dir_name, package_name);
 
       if (! file_name.empty ())
         {
           octave_function *fcn
             = octave::load_fcn_from_file (file_name, dir_name, "",
                                           package_name);
 
           if (fcn)
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -49,16 +49,17 @@ along with Octave; see the file COPYING.
 
 #include "Cell.h"
 #include <defaults.h>
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "oct-errno.h"
 #include "oct-hist.h"
 #include "ovl.h"
 #include "ov-range.h"
 #include "pager.h"
@@ -306,26 +307,28 @@ If no files are found, return an empty c
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   string_vector names = args(0).xstring_vector_value ("file_in_loadpath: FILE argument must be a string");
 
   if (names.empty ())
     error ("file_in_loadpath: FILE argument must not be empty");
 
+  load_path& lp = octave::__get_load_path__ ("file_in_loadpath");
+
   if (nargin == 1)
-    return ovl (octave::sys::env::make_absolute (load_path::find_first_of (names)));
+    return ovl (octave::sys::env::make_absolute (lp.find_first_of (names)));
   else
     {
       std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
 
       if (opt != "all")
         error ("file_in_loadpath: \"all\" is only valid second argument");
 
-      return ovl (Cell (make_absolute (load_path::find_all_first_of (names))));
+      return ovl (Cell (make_absolute (lp.find_all_first_of (names))));
     }
 }
 
 /*
 %!test
 %! f = file_in_loadpath ("plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
@@ -420,17 +423,19 @@ If no files are found, return an empty c
 std::string
 file_in_path (const std::string& name, const std::string& suffix)
 {
   std::string nm = name;
 
   if (! suffix.empty ())
     nm.append (suffix);
 
-  return octave::sys::env::make_absolute (load_path::find_file (nm));
+  load_path& lp = octave::__get_load_path__ ("file_in_path");
+
+  return octave::sys::env::make_absolute (lp.find_file (nm));
 }
 
 std::string
 find_data_file_in_load_path  (const std::string& fcn,
                               const std::string& file,
                               bool require_regular_file)
 {
   std::string fname = file;
@@ -443,19 +448,21 @@ find_data_file_in_load_path  (const std:
       // so do an explicit check for that.
       octave::sys::file_stat fs (fname);
 
       bool local_file_ok
         = fs.exists () && (fs.is_reg () || ! require_regular_file);
 
       if (! local_file_ok)
         {
+          load_path& lp = octave::__get_load_path__ ("find_data_file_in_load_path");
+
           // Not directly found; search load path.
           std::string tmp
-            = octave::sys::env::make_absolute (load_path::find_file (fname));
+            = octave::sys::env::make_absolute (lp.find_file (fname));
 
           if (! tmp.empty ())
             {
               warn_data_file_in_path (fcn, tmp);
 
               fname = tmp;
             }
         }
@@ -479,43 +486,52 @@ fcn_file_in_path (const std::string& nam
       if (octave::sys::env::absolute_pathname (name))
         {
           octave::sys::file_stat fs (name);
 
           if (fs.exists () && ! fs.is_dir ())
             retval = name;
         }
       else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
-        retval = load_path::find_fcn_file (name.substr (0, len-2));
+        {
+          load_path& lp = octave::__get_load_path__ ("fcn_file_in_path");
+
+          retval = lp.find_fcn_file (name.substr (0, len-2));
+        }
       else
         {
           std::string fname = name;
           size_t pos = name.find_first_of (Vfilemarker);
           if (pos != std::string::npos)
             fname = name.substr (0, pos);
 
-          retval = load_path::find_fcn_file (fname);
+          load_path& lp = octave::__get_load_path__ ("fcn_file_in_path");
+
+          retval = lp.find_fcn_file (fname);
         }
     }
 
   return retval;
 }
 
 // See if there is a directory called "name" in the path and if it
 // contains a Contents.m file.  If so, return the full path to this file.
 
 std::string
 contents_file_in_path (const std::string& dir)
 {
   std::string retval;
 
   if (dir.length () > 0)
     {
-      std::string tcontents = octave::sys::file_ops::concat (load_path::find_dir (dir),
-                                                std::string ("Contents.m"));
+      load_path& lp = octave::__get_load_path__ ("contents_in_file_path");
+
+      std::string tcontents
+        = octave::sys::file_ops::concat (lp.find_dir (dir),
+                                         std::string ("Contents.m"));
 
       octave::sys::file_stat fs (tcontents);
 
       if (fs.exists ())
         retval = octave::sys::env::make_absolute (tcontents);
     }
 
   return retval;
@@ -537,19 +553,27 @@ oct_file_in_path (const std::string& nam
       if (octave::sys::env::absolute_pathname (name))
         {
           octave::sys::file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
       else if (len > 4 && name.find (".oct", len-5))
-        retval = load_path::find_oct_file (name.substr (0, len-4));
+        {
+          load_path& lp = octave::__get_load_path__ ("oct_file_in_path");
+
+          retval = lp.find_oct_file (name.substr (0, len-4));
+        }
       else
-        retval = load_path::find_oct_file (name);
+        {
+          load_path& lp = octave::__get_load_path__ ("oct_file_in_path");
+
+          retval = lp.find_oct_file (name);
+        }
     }
 
   return retval;
 }
 
 // Deprecated in 4.2, remove in 4.6.
 // See if there is a .mex file in the path.
 // If so, return the full path to the file.
@@ -566,19 +590,27 @@ mex_file_in_path (const std::string& nam
       if (octave::sys::env::absolute_pathname (name))
         {
           octave::sys::file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
       else if (len > 4 && name.find (".mex", len-5))
-        retval = load_path::find_mex_file (name.substr (0, len-4));
+        {
+          load_path& lp = octave::__get_load_path__ ("mex_file_in_path");
+
+          retval = lp.find_mex_file (name.substr (0, len-4));
+        }
       else
-        retval = load_path::find_mex_file (name);
+        {
+          load_path& lp = octave::__get_load_path__ ("mex_file_in_path");
+
+          retval = lp.find_mex_file (name);
+        }
     }
 
   return retval;
 }
 
 // Replace backslash escapes in a string with the real values.
 
 std::string
@@ -971,20 +1003,22 @@ all name matches rather than just the fi
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string dir;
 
   dir = args(0).xstring_value ("dir_in_loadpath: DIR must be a directory name");
 
+  load_path& lp = octave::__get_load_path__ ("dir_in_loadpath");
+
   if (nargin == 1)
-    return ovl (load_path::find_dir (dir));
+    return ovl (lp.find_dir (dir));
   else
-    return ovl (Cell (load_path::find_matching_dirs (dir)));
+    return ovl (Cell (lp.find_matching_dirs (dir)));
 }
 
 /*
 %!test
 %! f = dir_in_loadpath ("plot");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -43,16 +43,17 @@ along with Octave; see the file COPYING.
 #include <defaults.h>
 #include "Cell.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "errwarn.h"
 #include "help.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave-link.h"
 #include "octave-preserve-stream-state.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "ov.h"
@@ -421,17 +422,21 @@ symbol_exist (const std::string& name, c
         return 103;
     }
 
   if (search_any || search_file || search_dir)
     {
       std::string file_name = octave::lookup_autoload (name);
 
       if (file_name.empty ())
-        file_name = load_path::find_fcn (name);
+        {
+          load_path& lp = octave::__get_load_path__ ("symbol_exist");
+
+          file_name = lp.find_fcn (name);
+        }
 
       size_t len = file_name.length ();
 
       if (len > 0)
         {
           if (search_any || search_file)
             {
               if (len > 4 && (file_name.substr (len-4) == ".oct"
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 
 #include "Cell.h"
 #include "call-stack.h"
 #include "defun.h"
 #include "error.h"
 #include "file-ops.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "ls-hdf5.h"
 #include "ls-oct-text.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
@@ -1136,17 +1137,20 @@ octave_class::reconstruct_parents (void)
   return retval;
 }
 
 bool
 octave_class::save_ascii (std::ostream& os)
 {
   os << "# classname: " << class_name () << "\n";
   octave_map m;
-  if (load_path::find_method (class_name (), "saveobj") != "")
+
+  load_path& lp = octave::__get_load_path__ ("octave_class::save_ascii");
+
+  if (lp.find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = octave::feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
@@ -1208,18 +1212,19 @@ octave_class::load_ascii (std::istream& 
       c_name = classname;
       reconstruct_exemplar ();
 
       map = m;
 
       if (! reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
-      if (load_path::find_method (classname, "loadobj")
-          != "")
+      load_path& lp = octave::__get_load_path__ ("octave_class::load_ascii");
+
+      if (lp.find_method (classname, "loadobj") != "")
         {
           octave_value in = new octave_class (*this);
           octave_value_list tmp = octave::feval ("loadobj", in, 1);
 
           map = tmp(0).map_value ();
         }
     }
   else if (len == 0)
@@ -1237,17 +1242,20 @@ bool
 octave_class::save_binary (std::ostream& os, bool& save_as_floats)
 {
   int32_t classname_len = class_name ().length ();
 
   os.write (reinterpret_cast<char *> (&classname_len), 4);
   os << class_name ();
 
   octave_map m;
-  if (load_path::find_method (class_name (), "saveobj") != "")
+
+  load_path& lp = octave::__get_load_path__ ("octave_class::save_binary");
+
+  if (lp.find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = octave::feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
@@ -1324,17 +1332,19 @@ octave_class::load_binary (std::istream&
 
       if (is)
         {
           map = m;
 
           if (! reconstruct_parents ())
             warning ("load: unable to reconstruct object inheritance");
 
-          if (load_path::find_method (c_name, "loadobj") != "")
+          load_path& lp = octave::__get_load_path__ ("octave_class::load_binary");
+
+          if (lp.find_method (c_name, "loadobj") != "")
             {
               octave_value in = new octave_class (*this);
               octave_value_list tmp = octave::feval ("loadobj", in, 1);
 
               map = tmp(0).map_value ();
             }
         }
       else
@@ -1361,16 +1371,18 @@ octave_class::save_hdf5 (octave_hdf5_id 
   hid_t group_hid = -1;
   hid_t type_hid = -1;
   hid_t space_hid = -1;
   hid_t class_hid = -1;
   hid_t data_hid = -1;
   octave_map m;
   octave_map::iterator i;
 
+  load_path& lp = octave::__get_load_path__ ("octave_class::save_hdf5");
+
 #if defined (HAVE_HDF5_18)
   group_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                          octave_H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     goto error_cleanup;
@@ -1401,17 +1413,17 @@ octave_class::save_hdf5 (octave_hdf5_id 
   data_hid = H5Gcreate (group_hid, "value", octave_H5P_DEFAULT,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
-  if (load_path::find_method (class_name (), "saveobj") != "")
+  if (lp.find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = octave::feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
@@ -1569,17 +1581,19 @@ octave_class::load_hdf5 (octave_hdf5_id 
 
   if (retval2 >= 0)
     {
       map = m;
 
       if (! reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
-      if (load_path::find_method (c_name, "loadobj") != "")
+      load_path& lp = octave::__get_load_path__ ("octave_class::load_hdf5");
+
+      if (lp.find_method (c_name, "loadobj") != "")
         {
           octave_value in = new octave_class (*this);
           octave_value_list tmp = octave::feval ("loadobj", in, 1);
 
           map = tmp(0).map_value ();
           retval = true;
         }
     }
@@ -1907,17 +1921,19 @@ Return true if the string @var{method} i
     class_name = arg.class_name ();
   else if (arg.is_string ())
     class_name = arg.string_value ();
   else
     error ("ismethod: first argument must be object or class name");
 
   std::string method = args(1).string_value ();
 
-  if (load_path::find_method (class_name, method) != "")
+  load_path& lp = octave::__get_load_path__ ("ismethod");
+
+  if (lp.find_method (class_name, method) != "")
     return ovl (true);
   else
     return ovl (false);
 }
 
 DEFUN (__methods__, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} __methods__ (@var{x})
@@ -1933,17 +1949,19 @@ Implements @code{methods} for Octave cla
 
   std::string class_name;
 
   if (arg.is_object ())
     class_name = arg.class_name ();
   else if (arg.is_string ())
     class_name = arg.string_value ();
 
-  string_vector sv = load_path::methods (class_name);
+  load_path& lp = octave::__get_load_path__ ("__methods__");
+
+  string_vector sv = lp.methods (class_name);
 
   return ovl (Cell (sv));
 }
 
 static bool
 is_built_in_class (const std::string& cn)
 {
   static std::set<std::string> built_in_class_names;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <algorithm>
 
 #include "call-stack.h"
 #include "defun.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "ov-builtin.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-typeinfo.h"
 #include "ov-usr-fcn.h"
 #include "pt-assign.h"
@@ -2627,16 +2628,18 @@ cdef_class::make_meta_class (octave::tre
 
       std::map<std::string, octave_value> get_methods;
       std::map<std::string, octave_value> set_methods;
 
       // Method blocks
 
       std::list<octave::tree_classdef_methods_block *> mb_list = b->methods_list ();
 
+      load_path& lp = octave::__get_load_path__ ("cdef_class::make_meta_class");
+
       for (auto& mb_p : mb_list)
         {
           std::map<std::string, octave_value> amap;
 
 #if DEBUG_TRACE
           std::cerr << "method block" << std::endl;
 #endif
 
@@ -2697,18 +2700,18 @@ cdef_class::make_meta_class (octave::tre
         {
           // Look for all external methods visible on octave path at the
           // time of loading of the class.
           //
           // FIXME: This is an "extension" to Matlab behavior, which only looks
           // in the @-folder containing the original classdef file.  However,
           // this is easier to implement it that way at the moment.
 
-          std::list<std::string> external_methods =
-            load_path::methods (full_class_name);
+          std::list<std::string> external_methods
+            = lp.methods (full_class_name);
 
           for (const auto& mtdnm : external_methods)
             {
               // FIXME: should we issue a warning if the method is already
               // defined in the classdef file?
 
               if (mtdnm != class_name
                   && ! retval.find_method (mtdnm, true).ok ())
@@ -2974,31 +2977,33 @@ cdef_property::cdef_property_rep::check_
 
 void
 cdef_method::cdef_method_rep::check_method (void)
 {
   if (is_external ())
     {
       if (is_dummy_method (function))
         {
+          load_path& lp = octave::__get_load_path__ ("cdef_method::cdef_method_rep::check_method");
+
           std::string name = get_name ();
           std::string cls_name = dispatch_type;
           std::string pack_name;
 
           size_t pos = cls_name.rfind ('.');
 
           if (pos != std::string::npos)
             {
               pack_name = cls_name.substr (0, pos);
               cls_name = cls_name.substr (pos + 1);
             }
 
           std::string dir_name;
-          std::string file_name = load_path::find_method (cls_name, name,
-                                                          dir_name, pack_name);
+          std::string file_name = lp.find_method (cls_name, name,
+                                                  dir_name, pack_name);
 
           if (! file_name.empty ())
             {
               octave_function *fcn = octave::load_fcn_from_file (file_name, dir_name,
                                                                  dispatch_type,
                                                                  pack_name);
 
               if (fcn)
@@ -3185,17 +3190,19 @@ package_get_packages (const octave_value
   return retval;
 }
 
 static octave_value_list
 package_getAllPackages (const octave_value_list& /* args */, int /* nargout */)
 {
   std::map<std::string, cdef_package> toplevel_packages;
 
-  std::list<std::string> names = load_path::get_all_package_names ();
+  load_path& lp = octave::__get_load_path__ ("package_getAllPackages");
+
+  std::list<std::string> names = lp.get_all_package_names ();
 
   toplevel_packages["meta"] = cdef_manager::find_package ("meta", false,
                                                           false);
 
   for (const auto& nm : names)
     toplevel_packages[nm] = cdef_manager::find_package (nm, false, true);
 
   Cell c (toplevel_packages.size (), 1);
@@ -3620,17 +3627,19 @@ cdef_manager::do_find_package (const std
     {
       retval = it->second;
 
       if (! retval.ok ())
         error ("invalid package `%s'", name.c_str ());
     }
   else
     {
-      if (load_if_not_found && load_path::find_package (name))
+      load_path& lp = octave::__get_load_path__ ("cdef_manager::do_find_package");
+
+      if (load_if_not_found && lp.find_package (name))
         {
           size_t pos = name.find ('.');
 
           if (pos == std::string::npos)
             retval = make_package (name, "");
           else
             {
               std::string parent_name = name.substr (0, pos);
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -36,16 +36,17 @@ along with Octave; see the file COPYING.
 
 #include "call-stack.h"
 #include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "file-stat.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-hdf5.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
@@ -292,17 +293,19 @@ octave_fcn_handle::set_fcn (const std::s
       else
         {
           // Next just search for it anywhere in the system path
           std::list<std::string> names;
           names.push_back (nm + ".oct");
           names.push_back (nm + ".mex");
           names.push_back (nm + ".m");
 
-          octave::directory_path p (load_path::system_path ());
+          load_path& lp = octave::__get_load_path__ ("octave_fcn_handle::set_fcn");
+
+          octave::directory_path p (lp.system_path ());
 
           str = octave::sys::env::make_absolute (p.find_first_of (names));
 
           size_t xpos = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn = octave::load_fcn_from_file (str, dir_name, "", "", nm);
@@ -1579,24 +1582,26 @@ make_fcn_handle (const std::string& nm, 
           || fptr->is_class_constructor ()
           || fptr->is_classdef_constructor ()))
     {
       // Locally visible function.
       retval = octave_value (new octave_fcn_handle (f, tnm));
     }
   else
     {
+      load_path& lp = octave::__get_load_path__ ("make_fcn_handle");
+
       // Globally visible (or no match yet).  Query overloads.
-      std::list<std::string> classes = load_path::overloads (tnm);
+      std::list<std::string> classes = lp.overloads (tnm);
       bool any_match = fptr != 0 || classes.size () > 0;
       if (! any_match)
         {
           // No match found, try updating load_path and query classes again.
-          load_path::update ();
-          classes = load_path::overloads (tnm);
+          lp.update ();
+          classes = lp.overloads (tnm);
           any_match = classes.size () > 0;
         }
 
       if (! any_match)
         error ("@%s: no function and no method found", tnm.c_str ());
 
       octave_fcn_handle *fh = new octave_fcn_handle (f, tnm);
       retval = fh;
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -56,16 +56,17 @@ along with Octave; see the file COPYING.
 #include "call-stack.h"
 #include "comment-list.h"
 #include "defaults.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "lex.h"
 #include "load-path.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
@@ -4425,17 +4426,21 @@ namespace octave
   {
     std::string retval;
 
     typedef std::map<std::string, std::string>::const_iterator am_iter;
 
     am_iter p = autoload_map.find (nm);
 
     if (p != autoload_map.end ())
-      retval = load_path::find_file (p->second);
+      {
+        load_path& lp = octave::__get_load_path__ ("lookup_autoload");
+
+        retval = lp.find_file (p->second);
+      }
 
     return retval;
   }
 
   string_vector
   autoloaded_functions (void)
   {
     string_vector names (autoload_map.size ());
