# HG changeset patch
# User jwe
# Date 781392744 0
#      Wed Oct 05 21:32:24 1994 +0000
# Node ID 42731861ee09eb4a6e40da8883da1a4dc39437c4
# Parent  b70e0404a8daaa10d9bc54d2cf8174eb140e9739
[project @ 1994-10-05 21:26:54 by jwe]

diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -69,19 +69,18 @@ Matrix_bool_op
   Matrix_EQ,
   Matrix_GE,
   Matrix_GT,
   Matrix_NE,
   Matrix_AND,
   Matrix_OR, 
 };
 
-/*
- * Check row and column dimensions for binary matrix operations.
- */
+// Check row and column dimensions for binary matrix operations.
+
 static inline int
 m_add_conform (const Matrix& a, const Matrix& b, int warn)
 {
   int ar = a.rows ();
   int ac = a.columns ();
   int br = b.rows ();
   int bc = b.columns ();
 
@@ -192,33 +191,31 @@ m_mul_conform (const ComplexMatrix& a, c
   int ok = (a.columns () == br);
 
   if (! ok && warn)
     gripe_nonconformant (a.rows (), ac, br, b.columns ());
 
   return ok;
 }
 
-/*
- * Stupid binary comparison operations like the ones Matlab provides.
- * One for each type combination, in the order given here:
- *
- *       op2 \ op1:   s   m   cs   cm
- *            +--   +---+---+----+----+
- *   scalar   |     | * | 3 |  * |  9 |
- *                  +---+---+----+----+
- *   matrix         | 1 | 4 |  7 | 10 |
- *                  +---+---+----+----+
- *   complex_scalar | * | 5 |  * | 11 |
- *                  +---+---+----+----+
- *   complex_matrix | 2 | 6 |  8 | 12 |
- *                  +---+---+----+----+
- */
+// Stupid binary comparison operations like the ones Matlab provides.
+// One for each type combination, in the order given here:
+//
+//       op2 \ op1:   s   m   cs   cm
+//            +--   +---+---+----+----+
+//   scalar   |     | * | 3 |  * |  9 |
+//                  +---+---+----+----+
+//   matrix         | 1 | 4 |  7 | 10 |
+//                  +---+---+----+----+
+//   complex_scalar | * | 5 |  * | 11 |
+//                  +---+---+----+----+
+//   complex_matrix | 2 | 6 |  8 | 12 |
+//                  +---+---+----+----+
 
-/* 1 */
+// -*- 1 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, double s, const Matrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -263,17 +260,17 @@ mx_stupid_bool_op (Matrix_bool_op op, do
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 2 */
+// -*- 2 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, double s, const ComplexMatrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -318,17 +315,17 @@ mx_stupid_bool_op (Matrix_bool_op op, do
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 3 */
+// -*- 3 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, double s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -373,17 +370,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 4 */
+// -*- 4 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, const Complex& s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -428,17 +425,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 5 */
+// -*- 5 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, const Matrix& b)
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
   int ac = a.columns ();
@@ -486,17 +483,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	  }
       }
 
   return c;
 }
 
-/* 6 */
+// -*- 6 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const Matrix& a, const ComplexMatrix& b)
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
   int ac = a.columns ();
@@ -543,17 +540,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
   return c;
 }
 
-/* 7 */
+// -*- 7 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const Complex& s, const Matrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -598,17 +595,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 8 */
+// -*- 8 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const Complex& s, const ComplexMatrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -653,17 +650,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 9 */
+// -*- 9 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a, double s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -708,17 +705,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 10 */
+// -*- 10 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a, const Complex& s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
 
   if (ar == 0 || ac == 0)
     {
@@ -763,17 +760,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	}
     }
 
   return t;
 }
 
-/* 11 */
+// -*- 11 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a, const Matrix& b)
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
   int ac = a.columns ();
@@ -820,17 +817,17 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
   return c;
 }
 
-/* 12 */
+// -*- 12 -*-
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, const ComplexMatrix& a,
 		   const ComplexMatrix& b) 
 {
   if (! m_add_conform (a, b, 1))
     return Matrix ();
      
   int ar = a.rows ();
@@ -879,25 +876,22 @@ mx_stupid_bool_op (Matrix_bool_op op, co
 	    panic_impossible ();
 	    break;
 	  }
       }
 
   return c;
 }
 
-/*
- * Unary operations.  One for each numeric data type:
- *
- *   scalar
- *   complex_scalar
- *   matrix
- *   complex_matrix
- *
- */
+// Unary operations.  One for each numeric data type:
+//
+//   scalar
+//   complex_scalar
+//   matrix
+//   complex_matrix
 
 tree_constant
 do_unary_op (double d, tree_expression::type t)
 {
   double result = 0.0;
 
   switch (t)
     {
@@ -993,33 +987,31 @@ do_unary_op (const ComplexMatrix& a, tre
     default:
       panic_impossible ();
       break;
     }
 
   return tree_constant (result);
 }
 
-/*
- * Binary operations.  One for each type combination, in the order
- * given here:
- *
- *       op2 \ op1:   s   m   cs   cm
- *            +--   +---+---+----+----+
- *   scalar   |     | 1 | 5 | 9  | 13 |
- *                  +---+---+----+----+
- *   matrix         | 2 | 6 | 10 | 14 |
- *                  +---+---+----+----+
- *   complex_scalar | 3 | 7 | 11 | 15 |
- *                  +---+---+----+----+
- *   complex_matrix | 4 | 8 | 12 | 16 |
- *                  +---+---+----+----+
- */
+// Binary operations.  One for each type combination, in the order
+// given here:
+//
+//       op2 \ op1:   s   m   cs   cm
+//            +--   +---+---+----+----+
+//   scalar   |     | 1 | 5 | 9  | 13 |
+//                  +---+---+----+----+
+//   matrix         | 2 | 6 | 10 | 14 |
+//                  +---+---+----+----+
+//   complex_scalar | 3 | 7 | 11 | 15 |
+//                  +---+---+----+----+
+//   complex_matrix | 4 | 8 | 12 | 16 |
+//                  +---+---+----+----+
 
-/* 1 */
+// -*- 1 -*-
 tree_constant
 do_binary_op (double a, double b, tree_expression::type t)
 {
   double result = 0.0;
 
   switch (t)
     {
     case tree_expression::add:
@@ -1078,17 +1070,17 @@ do_binary_op (double a, double b, tree_e
     }
 
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
-/* 2 */
+// -*- 2 -*-
 tree_constant
 do_binary_op (double a, const Matrix& b, tree_expression::type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
@@ -1149,17 +1141,17 @@ do_binary_op (double a, const Matrix& b,
     }
 
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
-/* 3 */
+// -*- 3 -*-
 tree_constant
 do_binary_op (double a, const Complex& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
@@ -1240,17 +1232,17 @@ do_binary_op (double a, const Complex& b
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 4 */
+// -*- 4 -*-
 tree_constant
 do_binary_op (double a, const ComplexMatrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -1331,17 +1323,17 @@ do_binary_op (double a, const ComplexMat
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 5 */
+// -*- 5 -*-
 tree_constant
 do_binary_op (const Matrix& a, double b, tree_expression::type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
@@ -1400,17 +1392,17 @@ do_binary_op (const Matrix& a, double b,
     }
 
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
-/* 6 */
+// -*- 6 -*-
 tree_constant
 do_binary_op (const Matrix& a, const Matrix& b, tree_expression::type t)
 {
   Matrix result;
 
   switch (t)
     {
     case tree_expression::add:
@@ -1488,17 +1480,17 @@ do_binary_op (const Matrix& a, const Mat
     }
 
   if (error_state)
     return tree_constant ();
 
   return tree_constant (result);
 }
 
-/* 7 */
+// -*- 7 -*-
 tree_constant
 do_binary_op (const Matrix& a, const Complex& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -1578,17 +1570,17 @@ do_binary_op (const Matrix& a, const Com
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 8 */
+// -*- 8 -*-
 tree_constant
 do_binary_op (const Matrix& a, const ComplexMatrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -1689,17 +1681,17 @@ do_binary_op (const Matrix& a, const Com
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 9 */
+// -*- 9 -*-
 tree_constant
 do_binary_op (const Complex& a, double b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
@@ -1780,17 +1772,17 @@ do_binary_op (const Complex& a, double b
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 10 */
+// -*- 10 -*-
 tree_constant
 do_binary_op (const Complex& a, const Matrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -1872,17 +1864,17 @@ do_binary_op (const Complex& a, const Ma
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 11 */
+// -*- 11 -*-
 tree_constant
 do_binary_op (const Complex& a, const Complex& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
@@ -1963,17 +1955,17 @@ do_binary_op (const Complex& a, const Co
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 12 */
+// -*- 12 -*-
 tree_constant
 do_binary_op (const Complex& a, const ComplexMatrix& b,
 	      tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
@@ -2056,17 +2048,17 @@ do_binary_op (const Complex& a, const Co
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 13 */
+// -*- 13 -*-
 tree_constant
 do_binary_op (const ComplexMatrix& a, double b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -2146,17 +2138,17 @@ do_binary_op (const ComplexMatrix& a, do
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 14 */
+// -*- 14 -*-
 tree_constant
 do_binary_op (const ComplexMatrix& a, const Matrix& b, tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
@@ -2257,17 +2249,17 @@ do_binary_op (const ComplexMatrix& a, co
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 15 */
+// -*- 15 -*-
 tree_constant
 do_binary_op (const ComplexMatrix& a, const Complex& b,
 	      tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
@@ -2348,17 +2340,17 @@ do_binary_op (const ComplexMatrix& a, co
   assert (result_type != RT_unknown);
 
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
-/* 16 */
+// -*- 16 -*-
 tree_constant
 do_binary_op (const ComplexMatrix& a, const ComplexMatrix& b,
 	      tree_expression::type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -39,16 +39,20 @@ Software Foundation, Inc.
 #include "utils.h"
 #include "error.h"
 #include "defun.h"
 
 #ifndef MIN
 #define MIN(a,b) ((a) < (b) ? (a) : (b))
 #endif
 
+#ifndef ABS
+#define ABS(x) (((x) < 0) ? (-x) : (x))
+#endif
+
 DEFUN ("all", Fall, Sall, 1, 1,
   "all (X): are all elements of X nonzero?")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
@@ -283,27 +287,272 @@ DEFUN ("cumsum", Fcumsum, Scumsum, 1, 1,
 	}
     }
   else
     print_usage ("cumsum");
 
   return retval;
 }
 
+static tree_constant
+make_diag (const Matrix& v, int k)
+{
+  int nr = v.rows ();
+  int nc = v.columns ();
+  assert (nc == 1 || nr == 1);
+
+  tree_constant retval;
+
+  int roff = 0;
+  int coff = 0;
+  if (k > 0)
+    {
+      roff = 0;
+      coff = k;
+    }
+  else if (k < 0)
+    {
+      roff = -k;
+      coff = 0;
+    }
+
+  if (nr == 1)
+    {
+      int n = nc + ABS (k);
+      Matrix m (n, n, 0.0);
+      for (int i = 0; i < nc; i++)
+	m.elem (i+roff, i+coff) = v.elem (0, i);
+      retval = tree_constant (m);
+    }
+  else
+    {
+      int n = nr + ABS (k);
+      Matrix m (n, n, 0.0);
+      for (int i = 0; i < nr; i++)
+	m.elem (i+roff, i+coff) = v.elem (i, 0);
+      retval = tree_constant (m);
+    }
+
+  return retval;
+}
+
+static tree_constant
+make_diag (const ComplexMatrix& v, int k)
+{
+  int nr = v.rows ();
+  int nc = v.columns ();
+  assert (nc == 1 || nr == 1);
+
+  tree_constant retval;
+
+  int roff = 0;
+  int coff = 0;
+  if (k > 0)
+    {
+      roff = 0;
+      coff = k;
+    }
+  else if (k < 0)
+    {
+      roff = -k;
+      coff = 0;
+    }
+
+  if (nr == 1)
+    {
+      int n = nc + ABS (k);
+      ComplexMatrix m (n, n, 0.0);
+      for (int i = 0; i < nc; i++)
+	m.elem (i+roff, i+coff) = v.elem (0, i);
+      retval = tree_constant (m);
+    }
+  else
+    {
+      int n = nr + ABS (k);
+      ComplexMatrix m (n, n, 0.0);
+      for (int i = 0; i < nr; i++)
+	m.elem (i+roff, i+coff) = v.elem (i, 0);
+      retval = tree_constant (m);
+    }
+
+  return retval;
+}
+
+static tree_constant
+make_diag (const tree_constant& arg)
+{
+  tree_constant retval;
+
+  if (arg.is_real_type ())
+    {
+      Matrix m = arg.matrix_value ();
+
+      if (! error_state)
+	{
+	  int nr = m.rows ();
+	  int nc = m.columns ();
+
+	  if (nr == 0 || nc == 0)
+	    retval = Matrix ();
+	  else if (nr == 1 || nc == 1)
+	    retval = make_diag (m, 0);
+	  else
+	    {
+	      ColumnVector v = m.diag ();
+	      if (v.capacity () > 0)
+		retval = v;
+	    }
+	}
+      else
+	gripe_wrong_type_arg ("diag", arg);
+    }
+  else if (arg.is_complex_type ())
+    {
+      ComplexMatrix cm = arg.complex_matrix_value ();
+
+      if (! error_state)
+	{
+	  int nr = cm.rows ();
+	  int nc = cm.columns ();
+
+	  if (nr == 0 || nc == 0)
+	    retval = Matrix ();
+	  else if (nr == 1 || nc == 1)
+	    retval = make_diag (cm, 0);
+	  else
+	    {
+	      ComplexColumnVector v = cm.diag ();
+	      if (v.capacity () > 0)
+		retval = v;
+	    }
+	}
+      else
+	gripe_wrong_type_arg ("diag", arg);
+    }
+  else
+    gripe_wrong_type_arg ("diag", arg);
+
+  return retval;
+}
+
+static tree_constant
+make_diag (const tree_constant& a, const tree_constant& b)
+{
+  tree_constant retval;
+
+  double tmp = b.double_value ();
+
+  if (error_state)
+    {
+      error ("diag: invalid second argument");      
+      return retval;
+    }
+
+  int k = NINT (tmp);
+  int n = ABS (k) + 1;
+
+  if (a.is_real_type ())
+    {
+      if (a.is_scalar_type ())
+	{
+	  double d = a.double_value ();
+
+	  if (k == 0)
+	    retval = d;
+	  else if (k > 0)
+	    {
+	      Matrix m (n, n, 0.0);
+	      m.elem (0, k) = d;
+	      retval = m;
+	    }
+	  else if (k < 0)
+	    {
+	      Matrix m (n, n, 0.0);
+	      m.elem (-k, 0) = d;
+	      retval = m;
+	    }
+	}
+      else if (a.is_matrix_type ())
+	{
+	  Matrix m = a.matrix_value ();
+
+	  int nr = m.rows ();
+	  int nc = m.columns ();
+
+	  if (nr == 0 || nc == 0)
+	    retval = Matrix ();
+	  else if (nr == 1 || nc == 1)
+	    retval = make_diag (m, k);
+	  else
+	    {
+	      ColumnVector d = m.diag (k);
+	      retval = d;
+	    }
+	}
+      else
+	gripe_wrong_type_arg ("diag", a);
+    }
+  else if (a.is_complex_type ())
+    {
+      if (a.is_scalar_type ())
+	{
+	  Complex c = a.complex_value ();
+
+	  if (k == 0)
+	    retval = c;
+	  else if (k > 0)
+	    {
+	      ComplexMatrix m (n, n, 0.0);
+	      m.elem (0, k) = c;
+	      retval = m;
+	    }
+	  else if (k < 0)
+	    {
+	      ComplexMatrix m (n, n, 0.0);
+	      m.elem (-k, 0) = c;
+	      retval = m;
+	    }
+	}
+      else if (a.is_matrix_type ())
+	{
+	  ComplexMatrix cm = a.complex_matrix_value ();
+
+	  int nr = cm.rows ();
+	  int nc = cm.columns ();
+
+	  if (nr == 0 || nc == 0)
+	    retval = Matrix ();
+	  else if (nr == 1 || nc == 1)
+	    retval = make_diag (cm, k);
+	  else
+	    {
+	      ComplexColumnVector d = cm.diag (k);
+	      retval = d;
+	    }
+	}
+      else
+	gripe_wrong_type_arg ("diag", a);
+    }
+  else
+    gripe_wrong_type_arg ("diag", a);
+
+  return retval;
+}
+
 DEFUN ("diag", Fdiag, Sdiag, 2, 1,
   "diag (X [,k]): form/extract diagonals")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
-    retval = args(0).diag ();
+    retval = make_diag (args(0));
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
-    retval = args(0).diag (args(1));
+    retval = make_diag (args(0), args(1));
   else
     print_usage ("diag");
 
   return retval;
 }
 
 DEFUN ("isstr", Fisstr, Sisstr, 1, 1,
   "isstr (X): return 1 if X is a string, 0 otherwise")
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -620,35 +620,33 @@ EXPON	([DdEe][+-]?{D}+)
 // We return everything else as single character tokens, which should
 // eventually result in a parse error.
 
 		  TOK_RETURN (yytext[0]);
 		}
 
 %%
 
-/*
- * GAG.
- *
- * If we're reading a matrix and the next character is '[', make sure
- * that we insert a comma ahead of it.
- */
+// GAG.
+//
+// If we're reading a matrix and the next character is '[', make sure
+// that we insert a comma ahead of it.
+
 void
 do_comma_insert_check (void)
 {
   int c = yyinput ();
   yyunput (c, yytext);
   do_comma_insert = (braceflag && c == '[');
 }
 
-/*
- * Fix things up for errors or interrupts.  The parser is never called
- * recursively, so it is always safe to reinitialize its state before
- * doing any parsing.
- */
+// Fix things up for errors or interrupts.  The parser is never called
+// recursively, so it is always safe to reinitialize its state before
+// doing any parsing.
+
 void
 reset_parser (void)
 {
 // Start off on the right foot.
   BEGIN 0;
   error_state = 0;
 
 // We do want a prompt by default.
@@ -707,19 +705,18 @@ reset_parser (void)
     input_line_number = current_command_number - 1;
 
 // Only ask for input from stdin if we are expecting interactive
 // input.
   if (interactive && ! (reading_fcn_file || get_input_from_eval_string))
     yyrestart (stdin);
 }
 
-/*
- * Replace backslash escapes in a string with the real values.
- */
+// Replace backslash escapes in a string with the real values.
+
 static void
 do_string_escapes (char *s)
 {
   char *p1 = s;
   char *p2 = s;
   while (*p2 != '\0')
     {
       if (*p2 == '\\' && *(p2+1) != '\0')
@@ -775,50 +772,46 @@ do_string_escapes (char *s)
 
       p1++;
       p2++;
     }
 
   *p1 = '\0';
 }
 
-/*
- * If we read some newlines, we need figure out what column we're
- * really looking at.
- */
+// If we read some newlines, we need figure out what column we're
+// really looking at.
+
 static void
 fixup_column_count (char *s)
 {
   char c;
   while ((c = *s++) != '\0')
     {
       if (c == '\n')
 	  current_input_column = 1;
       else
 	current_input_column++;
     }
 }
 
-/*
- * Include these so that we don't have to link to libfl.a.
- */
+// Include these so that we don't have to link to libfl.a.
 
 #ifdef yywrap
 #undef yywrap
 #endif
 static int
 yywrap (void)
 {
   return 1;
 }
 
-/*
- * These are not needed with flex-2.4.6, but may be needed with
- * earlier 2.4.x versions.
- */
+// These are not needed with flex-2.4.6, but may be needed with
+// earlier 2.4.x versions.
+
 #if 0
 static void *
 yy_flex_alloc (int size)
 {
   return (void *) malloc ((unsigned) size);
 }
 
 static void *
@@ -829,74 +822,67 @@ yy_flex_realloc (void *ptr, int size)
 
 static void
 yy_flex_free (void *ptr)
 {
   free (ptr);
 }
 #endif
 
-/*
- * Tell us all what the current buffer is.
- */
+// Tell us all what the current buffer is.
+
 YY_BUFFER_STATE
 current_buffer (void)
 {
   return YY_CURRENT_BUFFER;
 }
 
-/*
- * Create a new buffer.
- */
+// Create a new buffer.
+
 YY_BUFFER_STATE
 create_buffer (FILE *f)
 {
   return yy_create_buffer (f, YY_BUF_SIZE);
 }
 
-/*
- * Start reading a new buffer.
- */
+// Start reading a new buffer.
+
 void
 switch_to_buffer (YY_BUFFER_STATE buf)
 {
   yy_switch_to_buffer (buf);
 }
 
-/*
- * Delete a buffer.
- */
+// Delete a buffer.
+
 void
 delete_buffer (YY_BUFFER_STATE buf)
 {
   yy_delete_buffer (buf);
 }
 
-/*
- * Restore a buffer (for unwind-prot).
- */
+// Restore a buffer (for unwind-prot).
+
 void
 restore_input_buffer (void *buf)
 {
   switch_to_buffer ((YY_BUFFER_STATE) buf);
 }
 
-/*
- * Delete a buffer (for unwind-prot).
- */
+// Delete a buffer (for unwind-prot).
+
 void
 delete_input_buffer (void *buf)
 {
   delete_buffer ((YY_BUFFER_STATE) buf);
 }
 
-/*
- * Check to see if a character string matches any of the possible line
- * styles for plots.
- */
+// Check to see if a character string matches any of the possible line
+// styles for plots.
+
 static char *
 plot_style_token (char *s)
 {
   static char *plot_styles[] = 
     {
       "dots",
       "errorbars",
       "impulses",
@@ -913,20 +899,19 @@ plot_style_token (char *s)
 	return *tmp;
 
       tmp++;
     }
 
   return 0;
 }
 
-/*
- * Check to see if a character string matches any one of the plot
- * option keywords. 
- */
+// Check to see if a character string matches any one of the plot
+// option keywords. 
+
 static int
 is_plot_keyword (char *s)
 {
   if (almost_match ("title", s))
     {
       return TITLE;
     }
   else if (almost_match ("using", s))
@@ -942,19 +927,18 @@ is_plot_keyword (char *s)
       return WITH;
     }
   else
     {
       return 0;
     }
 }
 
-/*
- * Handle keywords.  Could probably be more efficient...
- */
+// Handle keywords.  Could probably be more efficient...
+
 static int
 is_keyword (char *s)
 {
   if (plotting && in_plot_style)
     {
       char *sty = plot_style_token (s);
       if (sty)
 	{
@@ -1113,29 +1097,27 @@ is_keyword (char *s)
       if (! defining_func && ! looping)
 	promptflag++;
       return END;
     }
 
   return 0;
 }
 
-/*
- * Try to find an identifier.  All binding to global or builtin
- * variables occurs when expressions are evaluated.
- */
+// Try to find an identifier.  All binding to global or builtin
+// variables occurs when expressions are evaluated.
+
 static symbol_record *
 lookup_identifier (char *name)
 {
   return curr_sym_tab->lookup (name, 1, 0);
 }
 
-/*
- * Grab the help text from an function file.
- */
+// Grab the help text from an function file.
+
 static void
 grab_help_text (void)
 {
   int max_len = HELP_BUF_LENGTH - 1;
 
   int in_comment = 1;
   int len = 0;
   int c = 0;
@@ -1174,60 +1156,56 @@ grab_help_text (void)
  done:
 
   if (c)
     yyunput (c, yytext);
 
   help_buf[len] =  '\0';
 }
 
-/*
- * Return 1 if the given character matches any character in the given
- * string.
- */
+// Return 1 if the given character matches any character in the given
+// string.
+
 static int
 match_any (char c, char *s)
 {
   char tmp;
   while ((tmp = *s++) != '\0')
     {
       if (c == tmp)
 	return 1;
     }
   return 0;
 }
 
-/*
- * Given information about the spacing surrounding an operator,
- * return 1 if it looks like it should be treated as a binary
- * operator.  For example,
- *
- *   [ 1 + 2 ]  or  [ 1+ 2]  or  [ 1+2 ]  ==> binary
- */
+// Given information about the spacing surrounding an operator,
+// return 1 if it looks like it should be treated as a binary
+// operator.  For example,
+//
+//   [ 1 + 2 ]  or  [ 1+ 2]  or  [ 1+2 ]  ==> binary
+
 static int
 looks_like_bin_op (int spc_prev, int spc_next)
 {
   return ((spc_prev && spc_next) || ! spc_prev);
 }
 
-/*
- * Duh.
- */
+// Duh.
+
 static int
 next_char_is_space (void)
 {
   int c = yyinput ();
   yyunput (c, yytext);
   return (c == ' ' || c == '\t');
 }
 
-/*
- * Try to determine if the next token should be treated as a postfix
- * unary operator.  This is ugly, but it seems to do the right thing.
- */
+// Try to determine if the next token should be treated as a postfix
+// unary operator.  This is ugly, but it seems to do the right thing.
+
 static int
 next_token_is_postfix_unary_op (int spc_prev, char *yytext)
 {
   int un_op = 0;
 
   int c0 = yyinput ();
   int c1 = yyinput ();
 
@@ -1237,21 +1215,20 @@ next_token_is_postfix_unary_op (int spc_
   int transpose = (c0 == '.' && c1 == '\'');
   int hermitian = (c0 == '\'');
 
   un_op = (transpose || (hermitian && ! spc_prev));
 
   return un_op;
 }
 
-/*
- * Try to determine if the next token should be treated as a binary
- * operator.  This is even uglier, but it also seems to do the right
- * thing.
- */
+// Try to determine if the next token should be treated as a binary
+// operator.  This is even uglier, but it also seems to do the right
+// thing.
+
 static int
 next_token_is_bin_op (int spc_prev, char *yytext)
 {
   int bin_op = 0;
   int spc_next = 0;
 
   int c0 = yyinput ();
   int c1 = yyinput ();
@@ -1329,39 +1306,37 @@ next_token_is_bin_op (int spc_prev, char
 
  done:
   yyunput (c1, yytext);
   yyunput (c0, yytext);
 
   return bin_op;
 }
 
-/*
- * Used to delete trailing white space from tokens.
- */
+// Used to delete trailing white space from tokens.
+
 static char *
 strip_trailing_whitespace (char *s)
 {
   char *retval = strsave (s);
 
   char *t = strchr (retval, ' ');
   if (t)
     *t = '\0';
 
   t = strchr (retval, '\t');
   if (t)
     *t = '\0';
 
   return retval;
 }
 
-/*
- * Figure out exactly what kind of token to return when we have seen
- * an identifier.  Handles keywords.
- */
+// Figure out exactly what kind of token to return when we have seen
+// an identifier.  Handles keywords.
+
 static int
 handle_identifier (char *tok, int next_tok_is_eq)
 {
 // If we are expecting a structure element, we just want to return
 // TEXT_ID, which is a string that is also a valid identifier.
 
   if (looking_at_indirect_ref)
     {
@@ -1489,21 +1464,20 @@ handle_identifier (char *tok, int next_t
 
       if (! (postfix_un_op || bin_op || other_op || index_op))
 	unput (',');
     }
 
   return NAME;
 }
 
-/*
- * Print a warning if a function file that defines a function has
- * anything other than comments and whitespace following the END token
- * that matches the FUNCTION statement.
- */
+// Print a warning if a function file that defines a function has
+// anything other than comments and whitespace following the END token
+// that matches the FUNCTION statement.
+
 void
 check_for_garbage_after_fcn_def (void)
 {
 // By making a newline be the next character to be read, we will force
 // the parser to return after reading the function.  Calling yyunput
 // with EOF seems not to work...
 
   int in_comment = 0;
@@ -1537,17 +1511,19 @@ check_for_garbage_after_fcn_def (void)
 	      yyunput ('\n', yytext);
 	      return;
 	    }
 	}
     }
   yyunput ('\n', yytext);
 }
 
-/* Maybe someday...
+/*
+
+Maybe someday...
 
 "+="		return ADD_EQ;
 "-="		return SUB_EQ;
 "*="		return MUL_EQ;
 "/="		return DIV_EQ;
 "\\="		return LEFTDIV_EQ;
 ".+="		return ADD_EQ;
 ".-="		return SUB_EQ;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -2700,18 +2700,22 @@ save variables in a file")
 
   if (save_as_floats && format == LS_ASCII)
     {
       error ("save: cannot specify both -ascii and -float-binary");
       DELETE_ARGV;
       return retval;
     }
 
-  ostream stream;
-  ofstream file;
+// Not declaring these static causes trouble on some systems with
+// g++/libg++ iostream.  Hmm.
+
+  static ostream stream;
+  static ofstream file;
+
   if (strcmp (*argv, "-") == 0)
     {
 // XXX FIXME XXX -- should things intended for the screen end up in a 
 // tree_constant (string)?
       stream = cout;
     }
   else if (argc == 1 && glob_pattern_p (*argv)) // Guard against things
     {						// like `save a*',
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -48,19 +48,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif
 
 #if defined (HAVE_LGAMMA) && ! defined (SIGNGAM_DECLARED)
 extern int signgam;
 #endif
 
-/*
- * Double -> double mappers.
- */
+// Double -> double mappers.
 
 double
 arg (double x)
 {
   if (x < 0.0)
     return M_PI;
   else
     return 0.0;
@@ -179,19 +177,17 @@ xlgamma (double x)
 {
 #if defined (HAVE_LGAMMA)
   return lgamma (x);
 #else
   error ("lgamma (x) not available on this system");
 #endif
 }
 
-/*
- * Complex -> double mappers.
- */
+// Complex -> double mappers.
 
 double
 xisnan (const Complex& x)
 {
 #if defined (HAVE_ISNAN)
   double rx = real (x);
   double ix = imag (x);
   return (double) (isnan (rx) || isnan (ix));
@@ -209,19 +205,17 @@ xfinite (const Complex& x)
 }
 
 double
 xisinf (const Complex& x)
 {
   return (double) (! (int) xfinite (x));
 }
 
-/*
- * Complex -> complex mappers.
- */
+// Complex -> complex mappers.
 
 Complex
 acos (const Complex& x)
 {
   static Complex i (0, 1);
   Complex retval = -i * log (x + sqrt (x*x - 1.0));
   return retval;
 }
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -17,19 +17,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Parser for Octave.
 
-/*
- * C decarations.
- */
+// C decarations.
+
 %{
 #define YYDEBUG 1
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include <strstream.h>
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -356,33 +356,21 @@ private:
   void make_unique (void);
 
   tree_constant_rep *make_unique_map (void);
 
 public:
 
 // -------------------------------------------------------------------
 
-// These may not need to be member functions.
-
-  tree_constant diag (void) const { return rep->diag (); }
-  tree_constant diag (const tree_constant& a) const { return rep->diag (a); }
-
-  tree_constant mapper (Mapper_fcn& m_fcn, int print) const
-    { return rep->mapper (m_fcn, print); }
-
-// -------------------------------------------------------------------
-
 // We want to eliminate this, or at least make it private.
 
   tree_constant_rep::constant_type const_type (void) const
     { return rep->const_type (); }
 
-// -------------------------------------------------------------------
-
 private:
 
 // Can we make these go away?
 
 // These need better names, since a range really is a numeric type.
 
   void force_numeric (int force_str_conv = 0)
     { rep->force_numeric (force_str_conv); }
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -86,16 +86,40 @@ list_to_vector (tree *list, int& len)
       args[k] = tmp_list;
       tmp_list = tmp_list->next_elem ();
     }
   return args;
 }
 #endif
 
 static int
+any_element_less_than (const Matrix& a, double val)
+{
+  int nr = a.rows ();
+  int nc = a.columns ();
+  for (int j = 0; j < nc; j++)
+    for (int i = 0; i < nr; i++)
+      if (a.elem (i, j) < val)
+	return 1;
+  return 0;
+}
+
+static int
+any_element_greater_than (const Matrix& a, double val)
+{
+  int nr = a.rows ();
+  int nc = a.columns ();
+  for (int j = 0; j < nc; j++)
+    for (int i = 0; i < nr; i++)
+      if (a.elem (i, j) > val)
+	return 1;
+  return 0;
+}
+
+static int
 print_as_scalar (const tree_constant& val)
 {
   int nr = val.rows ();
   int nc = val.columns ();
   return (val.is_scalar_type ()
 	  || val.is_string ()
 	  || (val.is_matrix_type ()
 	      && ((nr == 1 && nc == 1)
@@ -2228,16 +2252,94 @@ tree_builtin::eval (int print)
 	goto eval_fcn;
       else
 	::error ("unable to load builtin function %s", my_name);
     }
 
   return retval;
 }
 
+static tree_constant
+apply_mapper_fcn (const tree_constant& arg, Mapper_fcn& m_fcn, int print)
+{
+  tree_constant retval;
+
+  if (arg.is_real_type ())
+    {
+      if (arg.is_scalar_type ())
+	{
+	  double d = arg.double_value ();
+
+	  if (m_fcn.can_return_complex_for_real_arg
+	      && (d < m_fcn.lower_limit || d > m_fcn.upper_limit))
+	    {
+	      if (m_fcn.c_c_mapper)
+		retval = m_fcn.c_c_mapper (Complex (d));
+	      else
+		error ("%s: unable to handle real arguments", m_fcn.name);
+	    }
+	  else if (m_fcn.d_d_mapper)
+	    retval = m_fcn.d_d_mapper (d);
+	  else
+	    error ("%s: unable to handle real arguments", m_fcn.name);
+	}
+      else if (arg.is_matrix_type ())
+	{
+	  Matrix m = arg.matrix_value ();
+
+	  if (m_fcn.can_return_complex_for_real_arg
+	      && (any_element_less_than (m, m_fcn.lower_limit)
+		  || any_element_greater_than (m, m_fcn.upper_limit)))
+	    {
+	      if (m_fcn.c_c_mapper)
+		retval = map (m_fcn.c_c_mapper, ComplexMatrix (m));
+	      else
+		error ("%s: unable to handle real arguments", m_fcn.name);
+	    }
+	  else if (m_fcn.d_d_mapper)
+	    retval = map (m_fcn.d_d_mapper, m);
+	  else
+	    error ("%s: unable to handle real arguments", m_fcn.name);
+	}
+      else
+	gripe_wrong_type_arg ("mapper", arg);
+    }
+  else if (arg.is_complex_type ())
+    {
+      if (arg.is_scalar_type ())
+	{
+	  Complex c = arg.complex_value ();
+
+	  if (m_fcn.d_c_mapper)
+	    retval = m_fcn.d_c_mapper (c);
+	  else if (m_fcn.c_c_mapper)
+	    retval = m_fcn.c_c_mapper (c);
+	  else
+	    error ("%s: unable to handle complex arguments", m_fcn.name);
+	}
+      else if (arg.is_matrix_type ())
+	{
+	  ComplexMatrix cm = arg.complex_matrix_value ();
+
+	  if (m_fcn.d_c_mapper)
+	    retval = map (m_fcn.d_c_mapper, cm);
+	  else if (m_fcn.c_c_mapper)
+	    retval = map (m_fcn.c_c_mapper, cm);
+	  else
+	    error ("%s: unable to handle complex arguments", m_fcn.name);
+	}
+      else
+	gripe_wrong_type_arg ("mapper", arg);
+    }
+  else
+    gripe_wrong_type_arg ("mapper", arg);
+
+  return retval;
+}
+
 Octave_object
 tree_builtin::eval (int print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
@@ -2253,17 +2355,17 @@ tree_builtin::eval (int print, int nargo
 	retval = (*fcn) (args, nargout);
     }
   else if (is_mapper)
     {
       if (nargin > nargin_max)
 	::error ("%s: too many arguments", my_name);
       else if (nargin > 0 && args(0).is_defined ())
 	{
-	  tree_constant tmp = args(0).mapper (mapper_fcn, 0);
+	  tree_constant tmp = apply_mapper_fcn (args(0), mapper_fcn, 0);
 	  retval(0) = tmp;
 	}	
     }
   else
     {
       fcn = load_octave_builtin (my_name);
 
       if (fcn)
@@ -2299,19 +2401,17 @@ tree_function::define (tree statement_li
 
 tree_function *
 tree_function::define_param_list (tree_parameter_list *t)
 {
   param_list = t;
 
   if (param_list)
     {
-      int len = param_list->length ();
-      int va_only = param_list->varargs_only ();
-      num_named_args = va_only ? len - 1 : len;
+      num_named_args = param_list->length ();
       curr_va_arg_number = num_named_args;
     }
 
   return this;
 }
 
 tree_function *
 tree_function::define_ret_list (tree_parameter_list *t)
@@ -2364,20 +2464,20 @@ tree_function::takes_varargs (void) cons
 }
 
 tree_constant
 tree_function::octave_va_arg (void)
 {
   tree_constant retval;
 
   if (curr_va_arg_number < num_args_passed)
-    retval = args_passed (++curr_va_arg_number);
+    retval = args_passed (curr_va_arg_number++);
   else
-    ::error ("error getting arg number %d -- only %d provided",
-	     curr_va_arg_number, num_args_passed-1);
+    ::error ("va_arg: error getting arg number %d -- only %d provided",
+	     curr_va_arg_number + 1, num_args_passed);
 
   return retval;
 }
 
 int
 tree_function::takes_var_return (void) const
 {
   return (ret_list && ret_list->takes_varargs ());
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -37,19 +37,18 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-expr.h"
 #include "tree-const.h"
 
 extern "C"
 {
 #include "fnmatch.h"
 }
 
-/*
- * Variables and functions.
- */
+// Variables and functions.
+
 symbol_def::symbol_def (void)
 {
   init_state ();
 }
 
 symbol_def::symbol_def (tree_constant *t)
 {
   init_state ();
@@ -207,19 +206,18 @@ maybe_delete (symbol_def *def)
       def->count--;
       count = def->count;
       if (def->count == 0)
 	delete def;
     }
   return count;
 }
 
-/*
- * Individual records in a symbol table.
- */
+// Individual records in a symbol table.
+
 symbol_record::symbol_record (void)
 {
   init_state ();
 }
 
 symbol_record::symbol_record (const char *n, symbol_record *nxt)
 {
   init_state ();
@@ -655,19 +653,17 @@ symbol_def *
 symbol_record::pop_def (void)
 {
   symbol_def *top = definition;
   if (definition)
     definition = definition->next_elem;
   return top;
 }
 
-/*
- * A structure for handling verbose information about a symbol_record.
- */
+// A structure for handling verbose information about a symbol_record.
 
 symbol_record_info::symbol_record_info (void)
 {
   init_state ();
 }
 
 symbol_record_info::symbol_record_info (const symbol_record& sr)
 {
@@ -841,19 +837,17 @@ symbol_record_info::init_state (void)
   hides = SR_INFO_NONE;
   eternal = 0;
   read_only = 0;
   nr = -1;
   nc = -1;
   nm = 0;
 }
 
-/*
- * A symbol table.
- */
+// A symbol table.
 
 symbol_table::symbol_table (void)
 {
 }
 
 symbol_record *
 symbol_table::lookup (const char *nm, int insert, int warn)
 {
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -29,33 +29,33 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "SLStack.h"
 
 #include "variables.h"
 
 class ostream;
 
-#define HASH_TABLE_SIZE 1024             /* Must be multiple of 2 */
+// Must be multiple of 2.
+#define HASH_TABLE_SIZE 1024
 #define HASH_MASK (HASH_TABLE_SIZE - 1)
 
 class tree;
 class tree_fvc;
 class tree_builtin;
 class tree_constant;
 class tree_function;
 
 class symbol_def;
 class symbol_record;
 class symbol_record_info;
 class symbol_table;
 
-/*
- * Variables or functions.
- */
+// Variables or functions.
+
 class symbol_def
 {
   friend class symbol_record;
   friend class symbol_record_info;
 
 public:
 
   symbol_def (void);
@@ -111,19 +111,18 @@ private:
   int count;
 
   void init_state (void);
 
   symbol_def (const symbol_def& sd);
   symbol_def& operator = (const symbol_def& sd);
 };
 
-/*
- * Individual records in a symbol table.
- */
+// Individual records in a symbol table.
+
 class
 symbol_record
 {
   friend class symbol_record_info;
 
 public:
   symbol_record (void);
   symbol_record (const char *n, symbol_record *nxt = 0);
@@ -202,19 +201,17 @@ private:
   int read_only_error (void);
 
   void push_def (symbol_def *sd);
   symbol_def *pop_def (void);
 
   symbol_record& operator = (const symbol_record& s);
 };
 
-/*
- * A structure for handling verbose information about a symbol_record.
- */
+// A structure for handling verbose information about a symbol_record.
 
 class
 symbol_record_info
 {
 public:
 
   symbol_record_info (void);
   symbol_record_info (const symbol_record& s);
@@ -265,19 +262,17 @@ private:
   unsigned read_only : 1;
   int nr;
   int nc;
   char *nm;
   
   int initialized;
 };
 
-/*
- * A symbol table.
- */
+// A symbol table.
 
 #define SYMTAB_LOCAL_SCOPE 1
 #define SYMTAB_GLOBAL_SCOPE 2
 
 #define SYMTAB_ALL_SCOPES (SYMTAB_LOCAL_SCOPE | SYMTAB_GLOBAL_SCOPE)
 
 #define SYMTAB_ALL_TYPES (symbol_def::USER_FUNCTION \
 			  | symbol_def::USER_VARIABLE \
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -135,18 +135,16 @@ octave_ieee_init (void)
       if (octave_Inf == tmp)
 	break;
       tmp = octave_Inf;
     }
 #endif
 #endif
 #endif
 
-
-
 #if defined (HAVE_QUIET_NAN)
   octave_NaN = (double) quiet_nan ();
 #else
 #ifdef linux
   octave_NaN = NAN;
 #else
 #ifdef __alpha__
   extern unsigned int DQNAN[2];
@@ -163,17 +161,16 @@ octave_ieee_init (void)
 // off completely, or writing an entire IEEE emulation package?
 
   octave_Inf = DBL_MAX;
   octave_NaN = DBL_MAX;
 
 #endif
 }
 
-
 #if defined (EXCEPTION_IN_MATH)
 extern "C"
 {
 int
 matherr (struct exception *x)
 {
 // Possibly print our own message someday.  Should probably be
 // user-switchable.
@@ -207,29 +204,28 @@ sysdep_init (void)
 
 #ifdef NeXT
   NeXT_init ();
 #endif
 
   octave_ieee_init ();
 }
 
-/*
- * Set terminal in raw mode.  From less-177.
- *
- * Change terminal to "raw mode", or restore to "normal" mode.
- * "Raw mode" means 
- *	1. An outstanding read will complete on receipt of a single keystroke.
- *	2. Input is not echoed.  
- *	3. On output, \n is mapped to \r\n.
- *	4. \t is NOT expanded into spaces.
- *	5. Signal-causing characters such as ctrl-C (interrupt),
- *	   etc. are NOT disabled.
- * It doesn't matter whether an input \n is mapped to \r, or vice versa.
- */
+// Set terminal in raw mode.  From less-177.
+//
+// Change terminal to "raw mode", or restore to "normal" mode.
+// "Raw mode" means 
+//	1. An outstanding read will complete on receipt of a single keystroke.
+//	2. Input is not echoed.  
+//	3. On output, \n is mapped to \r\n.
+//	4. \t is NOT expanded into spaces.
+//	5. Signal-causing characters such as ctrl-C (interrupt),
+//	   etc. are NOT disabled.
+// It doesn't matter whether an input \n is mapped to \r, or vice versa.
+
 void
 raw_mode (int on)
 {
   static int curr_on = 0;
 
   int tty_fd = STDIN_FILENO;
   if (! isatty (tty_fd))
     {
@@ -355,19 +351,18 @@ raw_mode (int on)
   }
 #else
 LOSE! LOSE!
 #endif
 
   curr_on = on;
 }
 
-/*
- * Read one character from the terminal.
- */
+// Read one character from the terminal.
+
 int
 kbhit (void)
 {
   int c;
   raw_mode (1);
   c = cin.get ();
   raw_mode (0);
   return c;
diff --git a/src/tc-assign.cc b/src/tc-assign.cc
--- a/src/tc-assign.cc
+++ b/src/tc-assign.cc
@@ -29,21 +29,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "user-prefs.h"
 #include "tree-const.h"
 #include "utils.h"
 #include "gripes.h"
 #include "error.h"
 
 #include "tc-inlines.cc"
 
-/*
- * Top-level tree-constant function that handles assignments.  Only
- * decide if the left-hand side is currently a scalar or a matrix and
- * hand off to other functions to do the real work.
- */
+// Top-level tree-constant function that handles assignments.  Only
+// decide if the left-hand side is currently a scalar or a matrix and
+// hand off to other functions to do the real work.
+
 void
 tree_constant_rep::assign (tree_constant& rhs, tree_constant *args, int nargs)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
 // This is easier than actually handling assignments to strings.
 // An assignment to a range will normally require a conversion to a
 // vector since it will normally destroy the equally-spaced property
@@ -69,20 +68,19 @@ tree_constant_rep::assign (tree_constant
     case range_constant:
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Assignments to scalars.  If resize_on_range_error is true,
- * this can convert the left-hand size to a matrix.
- */
+// Assignments to scalars.  If resize_on_range_error is true,
+// this can convert the left-hand size to a matrix.
+
 void
 tree_constant_rep::do_scalar_assignment (tree_constant& rhs,
 					 tree_constant *args, int nargs)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == scalar_constant
 	  || type_tag == complex_scalar_constant);
 
@@ -172,22 +170,21 @@ tree_constant_rep::do_scalar_assignment 
 	}
     }
   else if (nargs > 3 || nargs < 2)
     ::error ("invalid index expression for scalar type");
   else
     ::error ("index invalid or out of range for scalar type");
 }
 
-/*
- * Assignments to matrices (and vectors).
- *
- * For compatibility with Matlab, we allow assignment of an empty
- * matrix to an expression with empty indices to do nothing.
- */
+// Assignments to matrices (and vectors).
+//
+// For compatibility with Matlab, we allow assignment of an empty
+// matrix to an expression with empty indices to do nothing.
+
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant *args, int nargs)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == matrix_constant
 	  || type_tag == complex_matrix_constant);
 
@@ -246,19 +243,18 @@ tree_constant_rep::do_matrix_assignment 
 	do_matrix_assignment (rhs, args[1], args[2]);
       break;
     default:
       ::error ("too many indices for matrix expression");
       break;
     }
 }
 
-/*
- * Matrix assignments indexed by a single value.
- */
+// Matrix assignments indexed by a single value.
+
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant& i_arg)
 {
   int nr = rows ();
   int nc = columns ();
 
   if (user_pref.do_fortran_indexing || nr <= 1 || nc <= 1)
@@ -290,21 +286,20 @@ tree_constant_rep::do_matrix_assignment 
 	vector_assignment (rhs, i_arg);
       else
 	panic_impossible ();
     }
   else
     ::error ("single index only valid for row or column vector");
 }
 
-/*
- * Fortran-style assignments.  Matrices are assumed to be stored in
- * column-major order and it is ok to use a single index for
- * multi-dimensional matrices.
- */
+// Fortran-style assignments.  Matrices are assumed to be stored in
+// column-major order and it is ok to use a single index for
+// multi-dimensional matrices.
+
 void
 tree_constant_rep::fortran_style_matrix_assignment (tree_constant& rhs,
 						    tree_constant& i_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
@@ -455,19 +450,18 @@ tree_constant_rep::fortran_style_matrix_
 	fortran_style_matrix_assignment (rhs, magic_colon);
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Fortran-style assignment for vector index.
- */
+// Fortran-style assignment for vector index.
+
 void
 tree_constant_rep::fortran_style_matrix_assignment (tree_constant& rhs,
 						    idx_vector& i)
 {
   assert (rhs.is_matrix_type ());
 
   int ilen = i.capacity ();
 
@@ -500,19 +494,18 @@ tree_constant_rep::fortran_style_matrix_
 	      complex_matrix->elem (ii, jj) = *cop_out++;
 	    }
 	}
     }
   else
     ::error ("number of rows and columns must match for indexed assignment");
 }
 
-/*
- * Fortran-style assignment for colon index.
- */
+// Fortran-style assignment for colon index.
+
 void
 tree_constant_rep::fortran_style_matrix_assignment
   (tree_constant& rhs, tree_constant_rep::constant_type mci)
 {
   assert (rhs.is_matrix_type () && mci == tree_constant_rep::magic_colon);
 
   int nr = rows ();
   int nc = columns ();
@@ -548,21 +541,20 @@ tree_constant_rep::fortran_style_matrix_
     {
       Complex *cop_out = rhs_cm.fortran_vec ();
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  complex_matrix->elem (i, j) = *cop_out++;
     }
 }
 
-/*
- * Assignments to vectors.  Hand off to other functions once we know
- * what kind of index we have.  For a colon, it is the same as
- * assignment to a matrix indexed by two colons.
- */
+// Assignments to vectors.  Hand off to other functions once we know
+// what kind of index we have.  For a colon, it is the same as
+// assignment to a matrix indexed by two colons.
+
 void
 tree_constant_rep::vector_assignment (tree_constant& rhs, tree_constant& i_arg)
 {
   int nr = rows ();
   int nc = columns ();
 
   assert ((nr == 1 || nc == 1 || (nr == 0 && nc == 0))
 	  && ! user_pref.do_fortran_indexing); 
@@ -631,19 +623,18 @@ tree_constant_rep::vector_assignment (tr
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Check whether an indexed assignment to a vector is valid.
- */
+// Check whether an indexed assignment to a vector is valid.
+
 void
 tree_constant_rep::check_vector_assign (int rhs_nr, int rhs_nc,
 					int ilen, const char *rm)
 {
   int nr = rows ();
   int nc = columns ();
 
   if ((nr == 1 && nc == 1) || nr == 0 || nc == 0)  // No orientation.
@@ -669,19 +660,18 @@ tree_constant_rep::check_vector_assign (
 	  ::error ("A(%s) = X: where A is a column vector, X must also be", rm);
 	  ::error ("a column vector with the same number of elements as %s", rm);
 	}
     }
   else
     panic_impossible ();
 }
 
-/*
- * Assignment to a vector with an integer index.
- */
+// Assignment to a vector with an integer index.
+
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, int i)
 {
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
   if (indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
     {
@@ -727,19 +717,18 @@ tree_constant_rep::do_vector_assign (tre
     }
   else
     {
       ::error ("for A(int) = X: X must be a scalar");
       return;
     }
 }
 
-/*
- * Assignment to a vector with a vector index.
- */
+// Assignment to a vector with a vector index.
+
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, idx_vector& iv)
 {
   if (rhs.is_zero_by_zero ())
     {
       int nr = rows ();
       int nc = columns ();
 
@@ -832,19 +821,18 @@ tree_constant_rep::do_vector_assign (tre
 	}
       else
 	panic_impossible ();
     }
   else
     panic_impossible ();
 }
 
-/*
- * Assignment to a vector with a range index.
- */
+// Assignment to a vector with a range index.
+
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, Range& ri)
 {
   if (rhs.is_zero_by_zero ())
     {
       int nr = rows ();
       int nc = columns ();
 
@@ -930,30 +918,29 @@ tree_constant_rep::do_vector_assign (tre
 	}
       else
 	panic_impossible ();
     }
   else
     panic_impossible ();
 }
 
-/*
- * Matrix assignment indexed by two values.  This function determines
- * the type of the first arugment, checks as much as possible, and
- * then calls one of a set of functions to handle the specific cases:
- *
- *   M (integer, arg2) = RHS  (MA1)
- *   M (vector,  arg2) = RHS  (MA2)
- *   M (range,   arg2) = RHS  (MA3)
- *   M (colon,   arg2) = RHS  (MA4)
- *
- * Each of those functions determines the type of the second argument
- * and calls another function to handle the real work of doing the
- * assignment.
- */
+// Matrix assignment indexed by two values.  This function determines
+// the type of the first arugment, checks as much as possible, and
+// then calls one of a set of functions to handle the specific cases:
+//
+//   M (integer, arg2) = RHS  (MA1)
+//   M (vector,  arg2) = RHS  (MA2)
+//   M (range,   arg2) = RHS  (MA3)
+//   M (colon,   arg2) = RHS  (MA4)
+//
+// Each of those functions determines the type of the second argument
+// and calls another function to handle the real work of doing the
+// assignment.
+
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant& i_arg, 
 					 tree_constant& j_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
@@ -1007,17 +994,17 @@ tree_constant_rep::do_matrix_assignment 
       do_matrix_assignment (rhs, magic_colon, j_arg);
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA1 */
+// -*- MA1 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i,
 					 tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
@@ -1145,17 +1132,17 @@ tree_constant_rep::do_matrix_assignment 
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA2 */
+// -*- MA2 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, idx_vector& iv,
 					 tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
@@ -1277,17 +1264,17 @@ tree_constant_rep::do_matrix_assignment 
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA3 */
+// -*- MA3 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 Range& ri, tree_constant& j_arg) 
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
@@ -1414,17 +1401,17 @@ tree_constant_rep::do_matrix_assignment 
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/* MA4 */
+// -*- MA4 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant_rep::constant_type i,
 					 tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
@@ -1579,55 +1566,53 @@ tree_constant_rep::do_matrix_assignment 
       do_matrix_assignment (rhs, magic_colon, magic_colon);
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Functions that actually handle assignment to a matrix using two
- * index values.
- *
- *                   idx2
- *            +---+---+----+----+
- *   idx1     | i | v |  r | c  |
- *   ---------+---+---+----+----+
- *   integer  | 1 | 5 |  9 | 13 |
- *   ---------+---+---+----+----+
- *   vector   | 2 | 6 | 10 | 14 |
- *   ---------+---+---+----+----+
- *   range    | 3 | 7 | 11 | 15 |
- *   ---------+---+---+----+----+
- *   colon    | 4 | 8 | 12 | 16 |
- *   ---------+---+---+----+----+
- */
+// Functions that actually handle assignment to a matrix using two
+// index values.
+//
+//                   idx2
+//            +---+---+----+----+
+//   idx1     | i | v |  r | c  |
+//   ---------+---+---+----+----+
+//   integer  | 1 | 5 |  9 | 13 |
+//   ---------+---+---+----+----+
+//   vector   | 2 | 6 | 10 | 14 |
+//   ---------+---+---+----+----+
+//   range    | 3 | 7 | 11 | 15 |
+//   ---------+---+---+----+----+
+//   colon    | 4 | 8 | 12 | 16 |
+//   ---------+---+---+----+----+
 
-/* 1 */
+// -*- 1 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i, int j)
 {
   REP_ELEM_ASSIGN (i, j, rhs.double_value (), rhs.complex_value (),
 		   rhs.is_real_type ());
 }
 
-/* 2 */
+// -*- 2 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i,
 					 idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int j = 0; j < jv.capacity (); j++)
     REP_ELEM_ASSIGN (i, jv.elem (j), rhs_m.elem (0, j),
 		     rhs_cm.elem (0, j), rhs.is_real_type ());
 }
 
-/* 3 */
+// -*- 3 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i, Range& rj)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = rj.base ();
   double increment = rj.inc ();
 
@@ -1635,17 +1620,17 @@ tree_constant_rep::do_matrix_assignment 
     {
       double tmp = b + j * increment;
       int col = tree_to_mat_idx (tmp);
       REP_ELEM_ASSIGN (i, col, rhs_m.elem (0, j), rhs_cm.elem (0, j),
 		       rhs.is_real_type ());
     }
 }
 
-/* 4 */
+// -*- 4 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   int nc = columns ();
 
@@ -1665,32 +1650,32 @@ tree_constant_rep::do_matrix_assignment 
     {
       REP_ELEM_ASSIGN (i, 0, rhs.double_value (),
 		       rhs.complex_value (), rhs.is_real_type ()); 
     }
   else
     panic_impossible ();
 }
   
-/* 5 */
+// -*- 5 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 idx_vector& iv, int j)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int i = 0; i < iv.capacity (); i++)
     {
       int row = iv.elem (i);
       REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, 0),
 		       rhs_cm.elem (i, 0), rhs.is_real_type ());
     }
 }
 
-/* 6 */
+// -*- 6 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 idx_vector& iv, idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int i = 0; i < iv.capacity (); i++)
     {
@@ -1699,17 +1684,17 @@ tree_constant_rep::do_matrix_assignment 
 	{
 	  int col = jv.elem (j);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 7 */
+// -*- 7 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 idx_vector& iv, Range& rj)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = rj.base ();
   double increment = rj.inc ();
@@ -1722,17 +1707,17 @@ tree_constant_rep::do_matrix_assignment 
 	  double tmp = b + j * increment;
 	  int col = tree_to_mat_idx (tmp);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 8 */
+// -*- 8 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, idx_vector& iv,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
@@ -1751,17 +1736,17 @@ tree_constant_rep::do_matrix_assignment 
 	      int row = iv.elem (i);
 	      REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, j),
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
-/* 9 */
+// -*- 9 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri, int j)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = ri.base ();
   double increment = ri.inc ();
 
@@ -1769,17 +1754,17 @@ tree_constant_rep::do_matrix_assignment 
     {
       double tmp = b + i * increment;
       int row = tree_to_mat_idx (tmp);
       REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, 0),
 		       rhs_cm.elem (i, 0), rhs.is_real_type ());
     }
 }
 
-/* 10 */
+// -*- 10 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri,
 					 idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = ri.base ();
   double increment = ri.inc ();
@@ -1792,17 +1777,17 @@ tree_constant_rep::do_matrix_assignment 
 	  double tmp = b + i * increment;
 	  int row = tree_to_mat_idx (tmp);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_m.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 11 */
+// -*- 11 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri,
 					 Range& rj)
 {
   double ib = ri.base ();
   double iinc = ri.inc ();
   double jb = rj.base ();
   double jinc = rj.inc ();
@@ -1818,17 +1803,17 @@ tree_constant_rep::do_matrix_assignment 
 	  double jtmp = jb + j * jinc;
 	  int col = tree_to_mat_idx (jtmp);
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem  (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 12 */
+// -*- 12 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
@@ -1849,17 +1834,17 @@ tree_constant_rep::do_matrix_assignment 
 	  int row = tree_to_mat_idx (itmp);
 	  for (int j = 0; j < nc; j++)
 	    REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, j),
 			     rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
-/* 13 */
+// -*- 13 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 int j)
 {
   assert (mci == magic_colon);
 
   int nr = rows ();
@@ -1880,17 +1865,17 @@ tree_constant_rep::do_matrix_assignment 
     {
       REP_ELEM_ASSIGN (0, j, rhs.double_value (),
 		       rhs.complex_value (), rhs.is_real_type ());
     }
   else
     panic_impossible ();
 }
 
-/* 14 */
+// -*- 14 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 idx_vector& jv)
 {
   assert (mci == magic_colon);
 
   if (rhs.is_zero_by_zero ())
@@ -1910,17 +1895,17 @@ tree_constant_rep::do_matrix_assignment 
 	      int col = jv.elem (j);
 	      REP_ELEM_ASSIGN (i, col, rhs_m.elem (i, j),
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
-/* 15 */
+// -*- 15 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 Range& rj)
 {
   assert (mci == magic_colon);
 
   if (rhs.is_zero_by_zero ())
@@ -1944,17 +1929,17 @@ tree_constant_rep::do_matrix_assignment 
 	    {
 	      REP_ELEM_ASSIGN (i, col, rhs_m.elem (i, j),
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
-/* 16 */
+// -*- 16 -*-
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mci == magic_colon && mcj == magic_colon);
 
   switch (type_tag)
@@ -2006,22 +1991,21 @@ tree_constant_rep::do_matrix_assignment 
       break;
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
 }
 
-/*
- * Functions for deleting rows or columns of a matrix.  These are used
- * to handle statements like
- *
- *   M (i, j) = []
- */
+// Functions for deleting rows or columns of a matrix.  These are used
+// to handle statements like
+//
+//  M (i, j) = []
+
 void
 tree_constant_rep::delete_row (int idx)
 {
   if (type_tag == matrix_constant)
     {
       int nr = matrix->rows ();
       int nc = matrix->columns ();
       Matrix *new_matrix = new Matrix (nr-1, nc);
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -44,42 +44,16 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "pager.h"
 #include "pr-output.h"
 #include "tree-const.h"
 #include "idx-vector.h"
 #include "oct-map.h"
 
 #include "tc-inlines.h"
 
-// And still some more handy helper functions.
-
-static int
-any_element_less_than (const Matrix& a, double val)
-{
-  int nr = a.rows ();
-  int nc = a.columns ();
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      if (a.elem (i, j) < val)
-	return 1;
-  return 0;
-}
-
-static int
-any_element_greater_than (const Matrix& a, double val)
-{
-  int nr = a.rows ();
-  int nc = a.columns ();
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      if (a.elem (i, j) > val)
-	return 1;
-  return 0;
-}
-
 static int
 any_element_is_complex (const ComplexMatrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       if (imag (a.elem (i, j)) != 0.0)
@@ -1185,33 +1159,44 @@ TC_REP::convert_to_str (void) const
 	s[1] = '\0';
 	retval = tree_constant (s);
       }
       break;
 
     case complex_matrix_constant:
     case matrix_constant:
       {
-	ColumnVector v = vector_value ();
-	int len = v.length ();
-	if (len == 0)
-	  ::error ("can only convert vectors and scalars to strings");
+	if (rows () == 0 && columns () == 0)
+	  {
+	    char s = '\0';
+	    retval = tree_constant (&s);
+	  }
 	else
 	  {
-	    char *s = new char [len+1];
-	    s[len] = '\0';
-	    for (int i = 0; i < len; i++)
+	    ColumnVector v = vector_value ();
+	    int len = v.length ();
+	    if (len == 0)
+	      {
+		char s = '\0';
+		retval = tree_constant (&s);
+	      }
+	    else
 	      {
-		double d = v.elem (i);
-		int ival = NINT (d);
+		char *s = new char [len+1];
+		s[len] = '\0';
+		for (int i = 0; i < len; i++)
+		  {
+		    double d = v.elem (i);
+		    int ival = NINT (d);
 // Warn about out of range conversions?
-		s[i] = (char) ival;
+		    s[i] = (char) ival;
+		  }
+		retval = tree_constant (s);
+		delete [] s;
 	      }
-	    retval = tree_constant (s);
-	    delete [] s;
 	  }
       }
       break;
 
     case range_constant:
       {
 	Range r = range_value ();
 	double b = r.base ();
@@ -2119,402 +2104,14 @@ do_unary_op (tree_constant& a, tree_expr
     default:
       panic_impossible ();
       break;
     }
 
   return ans;
 }
 
-static tree_constant
-make_diag (const Matrix& v, int k)
-{
-  int nr = v.rows ();
-  int nc = v.columns ();
-  assert (nc == 1 || nr == 1);
-
-  tree_constant retval;
-
-  int roff = 0;
-  int coff = 0;
-  if (k > 0)
-    {
-      roff = 0;
-      coff = k;
-    }
-  else if (k < 0)
-    {
-      roff = -k;
-      coff = 0;
-    }
-
-  if (nr == 1)
-    {
-      int n = nc + ABS (k);
-      Matrix m (n, n, 0.0);
-      for (int i = 0; i < nc; i++)
-	m.elem (i+roff, i+coff) = v.elem (0, i);
-      retval = tree_constant (m);
-    }
-  else
-    {
-      int n = nr + ABS (k);
-      Matrix m (n, n, 0.0);
-      for (int i = 0; i < nr; i++)
-	m.elem (i+roff, i+coff) = v.elem (i, 0);
-      retval = tree_constant (m);
-    }
-
-  return retval;
-}
-
-static tree_constant
-make_diag (const ComplexMatrix& v, int k)
-{
-  int nr = v.rows ();
-  int nc = v.columns ();
-  assert (nc == 1 || nr == 1);
-
-  tree_constant retval;
-
-  int roff = 0;
-  int coff = 0;
-  if (k > 0)
-    {
-      roff = 0;
-      coff = k;
-    }
-  else if (k < 0)
-    {
-      roff = -k;
-      coff = 0;
-    }
-
-  if (nr == 1)
-    {
-      int n = nc + ABS (k);
-      ComplexMatrix m (n, n, 0.0);
-      for (int i = 0; i < nc; i++)
-	m.elem (i+roff, i+coff) = v.elem (0, i);
-      retval = tree_constant (m);
-    }
-  else
-    {
-      int n = nr + ABS (k);
-      ComplexMatrix m (n, n, 0.0);
-      for (int i = 0; i < nr; i++)
-	m.elem (i+roff, i+coff) = v.elem (i, 0);
-      retval = tree_constant (m);
-    }
-
-  return retval;
-}
-
-tree_constant
-TC_REP::diag (void) const
-{
-  if (type_tag == string_constant || type_tag == range_constant)
-    {
-      tree_constant tmp = make_numeric ();
-      return tmp.diag ();
-    }
-
-  tree_constant retval;
-
-  switch (type_tag)
-    {
-    case scalar_constant:
-      retval = tree_constant (scalar);
-      break;
-
-    case matrix_constant:
-      {
-	int nr = rows ();
-	int nc = columns ();
-	if (nr == 0 || nc == 0)
-	  {
-	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
-	  }
-	else if (nr == 1 || nc == 1)
-	  retval = make_diag (matrix_value (), 0);
-	else
-	  {
-	    ColumnVector v = matrix->diag ();
-	    if (v.capacity () > 0)
-	      retval = tree_constant (v);
-	  }
-      }
-      break;
-
-    case complex_scalar_constant:
-      retval = tree_constant (*complex_scalar);
-      break;
-
-    case complex_matrix_constant:
-      {
-	int nr = rows ();
-	int nc = columns ();
-	if (nr == 0 || nc == 0)
-	  {
-	    Matrix mtmp;
-	    retval = tree_constant (mtmp);
-	  }
-	else if (nr == 1 || nc == 1)
-	  retval = make_diag (complex_matrix_value (), 0);
-	else
-	  {
-	    ComplexColumnVector v = complex_matrix->diag ();
-	    if (v.capacity () > 0)
-	      retval = tree_constant (v);
-	  }
-      }
-      break;
-
-    case string_constant:
-    case range_constant:
-    case magic_colon:
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  return retval;
-}
-
-tree_constant
-TC_REP::diag (const tree_constant& a) const
-{
-  if (type_tag == string_constant || type_tag == range_constant)
-    {
-      tree_constant tmp = make_numeric ();
-      return tmp.diag (a);
-    }
-
-  tree_constant tmp_a = a.make_numeric ();
-
-  TC_REP::constant_type a_type = tmp_a.const_type ();
-
-  tree_constant retval;
-
-  switch (type_tag)
-    {
-    case scalar_constant:
-      if (a_type == scalar_constant)
-	{
-	  int k = NINT (tmp_a.double_value ());
-	  int n = ABS (k) + 1;
-	  if (k == 0)
-	    retval = tree_constant (scalar);
-	  else if (k > 0)
-	    {
-	      Matrix m (n, n, 0.0);
-	      m.elem (0, k) = scalar;
-	      retval = tree_constant (m);
-	    }
-	  else if (k < 0)
-	    {
-	      Matrix m (n, n, 0.0);
-	      m.elem (-k, 0) = scalar;
-	      retval = tree_constant (m);
-	    }
-	}
-      break;
-
-    case matrix_constant:
-      if (a_type == scalar_constant)
-	{
-	  int k = NINT (tmp_a.double_value ());
-	  int nr = rows ();
-	  int nc = columns ();
-	  if (nr == 0 || nc == 0)
-	    {
-	      Matrix mtmp;
-	      retval = tree_constant (mtmp);
-	    }
-	  else if (nr == 1 || nc == 1)
-	    retval = make_diag (matrix_value (), k);
-	  else
-	    {
-	      ColumnVector d = matrix->diag (k);
-	      retval = tree_constant (d);
-	    }
-	}
-      else
-	::error ("diag: invalid second argument");
-
-      break;
-
-    case complex_scalar_constant:
-      if (a_type == scalar_constant)
-	{
-	  int k = NINT (tmp_a.double_value ());
-	  int n = ABS (k) + 1;
-	  if (k == 0)
-	    retval = tree_constant (*complex_scalar);
-	  else if (k > 0)
-	    {
-	      ComplexMatrix m (n, n, 0.0);
-	      m.elem (0, k) = *complex_scalar;
-	      retval = tree_constant (m);
-	    }
-	  else if (k < 0)
-	    {
-	      ComplexMatrix m (n, n, 0.0);
-	      m.elem (-k, 0) = *complex_scalar;
-	      retval = tree_constant (m);
-	    }
-	}
-      break;
-
-    case complex_matrix_constant:
-      if (a_type == scalar_constant)
-	{
-	  int k = NINT (tmp_a.double_value ());
-	  int nr = rows ();
-	  int nc = columns ();
-	  if (nr == 0 || nc == 0)
-	    {
-	      Matrix mtmp;
-	      retval = tree_constant (mtmp);
-	    }
-	  else if (nr == 1 || nc == 1)
-	    retval = make_diag (complex_matrix_value (), k);
-	  else
-	    {
-	      ComplexColumnVector d = complex_matrix->diag (k);
-	      retval = tree_constant (d);
-	    }
-	}
-      else
-	::error ("diag: invalid second argument");
-
-      break;
-
-    case string_constant:
-    case range_constant:
-    case magic_colon:
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  return retval;
-}
-
-// XXX FIXME XXX -- this can probably be rewritten efficiently as a
-// nonmember function...
-
-tree_constant
-TC_REP::mapper (Mapper_fcn& m_fcn, int print) const
-{
-  tree_constant retval;
-
-  if (type_tag == string_constant || type_tag == range_constant)
-    {
-      tree_constant tmp = make_numeric ();
-      return tmp.mapper (m_fcn, print);
-    }
-
-  switch (type_tag)
-    {
-    case scalar_constant:
-      if (m_fcn.can_return_complex_for_real_arg
-	  && (scalar < m_fcn.lower_limit
-	      || scalar > m_fcn.upper_limit))
-	{
-	  if (m_fcn.c_c_mapper)
-	    {
-	      Complex c = m_fcn.c_c_mapper (Complex (scalar));
-	      retval = tree_constant (c);
-	    }
-	  else
-	    ::error ("%s: unable to handle real arguments", m_fcn.name);
-	}
-      else
-	{
-	  if (m_fcn.d_d_mapper)
-	    {
-	      double d = m_fcn.d_d_mapper (scalar);
-	      retval = tree_constant (d);
-	    }
-	  else
-	    ::error ("%s: unable to handle real arguments", m_fcn.name);
-	}
-      break;
-
-    case matrix_constant:
-      if (m_fcn.can_return_complex_for_real_arg
-	  && (any_element_less_than (*matrix, m_fcn.lower_limit)
-	      || any_element_greater_than (*matrix, m_fcn.upper_limit)))
-	{
-	  if (m_fcn.c_c_mapper)
-	    {
-	      ComplexMatrix cm = map (m_fcn.c_c_mapper,
-				      ComplexMatrix (*matrix));
-	      retval = tree_constant (cm);
-	    }
-	  else
-	    ::error ("%s: unable to handle real arguments", m_fcn.name);
-	}
-      else
-	{
-	  if (m_fcn.d_d_mapper)
-	    {
-	      Matrix m = map (m_fcn.d_d_mapper, *matrix);
-	      retval = tree_constant (m);
-	    }
-	  else
-	    ::error ("%s: unable to handle real arguments", m_fcn.name);
-	}
-      break;
-
-    case complex_scalar_constant:
-      if (m_fcn.d_c_mapper)
-	{
-	  double d;
-	  d = m_fcn.d_c_mapper (*complex_scalar);
-	  retval = tree_constant (d);
-	}
-      else if (m_fcn.c_c_mapper)
-	{
-	  Complex c;
-	  c = m_fcn.c_c_mapper (*complex_scalar);
-	  retval = tree_constant (c);
-	}
-      else
-	::error ("%s: unable to handle complex arguments", m_fcn.name);
-      break;
-
-    case complex_matrix_constant:
-      if (m_fcn.d_c_mapper)
-	{
-	  Matrix m;
-	  m = map (m_fcn.d_c_mapper, *complex_matrix);
-	  retval = tree_constant (m);
-	}
-      else if (m_fcn.c_c_mapper)
-	{
-	  ComplexMatrix cm;
-	  cm = map (m_fcn.c_c_mapper, *complex_matrix);
-	  retval = tree_constant (cm);
-	}
-      else
-	::error ("%s: unable to handle complex arguments", m_fcn.name);
-      break;
-
-    case string_constant:
-    case range_constant:
-    case magic_colon:
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  return retval;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/tc-rep.h b/src/tc-rep.h
--- a/src/tc-rep.h
+++ b/src/tc-rep.h
@@ -216,25 +216,16 @@ private:
   friend tree_constant do_binary_op (tree_constant& a, tree_constant& b,
 				     tree_expression::type t);
 
   friend tree_constant do_unary_op (tree_constant& a,
 				    tree_expression::type t);
 
 // -------------------------------------------------------------------
 
-// These may not need to be member functions.
-
-  tree_constant diag (void) const;
-  tree_constant diag (const tree_constant& a) const;
-
-  tree_constant mapper (Mapper_fcn& m_fcn, int print) const;
-
-// -------------------------------------------------------------------
-
 // We want to eliminate this.
 
   constant_type const_type (void) const { return type_tag; }
 
 // We want to get rid of these too:
 
   void force_numeric (int force_str_conv = 0);
   tree_constant make_numeric (int force_str_conv = 0) const;
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -67,28 +67,26 @@ mx_div_conform (int b_nr, int b_nc, int 
     {
       error ("number of columns must be the same for right division");
       return 0;
     }
 
   return 1;
 }
 
-/*
- * Right division functions.
- *
- *       op2 / op1:   m   cm
- *            +--   +---+----+
- *   matrix         | 1 |  3 |
- *                  +---+----+
- *   complex_matrix | 2 |  4 |
- *                  +---+----+
- */
+// Right division functions.
+//
+//       op2 / op1:   m   cm
+//            +--   +---+----+
+//   matrix         | 1 |  3 |
+//                  +---+----+
+//   complex_matrix | 2 |  4 |
+//                  +---+----+
 
-/* 1 */
+// -*- 1 -*-
 tree_constant
 xdiv (const Matrix& a, const Matrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   Matrix atmp = a.transpose ();
   Matrix btmp = b.transpose ();
@@ -103,17 +101,17 @@ xdiv (const Matrix& a, const Matrix& b)
     }
 
   int rank;
   Matrix result = btmp.lssolve (atmp, info, rank);
 
   return tree_constant (result.transpose ());
 }
 
-/* 2 */
+// -*- 2 -*-
 tree_constant
 xdiv (const Matrix& a, const ComplexMatrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   Matrix atmp = a.transpose ();
   ComplexMatrix btmp = b.hermitian ();
@@ -128,17 +126,17 @@ xdiv (const Matrix& a, const ComplexMatr
     }
 
   int rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return tree_constant (result.hermitian ());
 }
 
-/* 3 */
+// -*- 3 -*-
 tree_constant
 xdiv (const ComplexMatrix& a, const Matrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   ComplexMatrix atmp = a.hermitian ();
   Matrix btmp = b.transpose ();
@@ -153,17 +151,17 @@ xdiv (const ComplexMatrix& a, const Matr
     }
 
   int rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return tree_constant (result.hermitian ());
 }
 
-/* 4 */
+// -*- 4 -*-
 tree_constant
 xdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
     return tree_constant ();
 
   ComplexMatrix atmp = a.hermitian ();
   ComplexMatrix btmp = b.hermitian ();
@@ -178,26 +176,24 @@ xdiv (const ComplexMatrix& a, const Comp
     }
 
   int rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
 
   return tree_constant (result.hermitian ());
 }
 
-/*
- * Funny element by element division operations.
- *
- *       op2 \ op1:   s   cs
- *            +--   +---+----+
- *   matrix         | 1 |  3 |
- *                  +---+----+
- *   complex_matrix | 2 |  4 |
- *                  +---+----+
- */
+// Funny element by element division operations.
+//
+//       op2 \ op1:   s   cs
+//            +--   +---+----+
+//   matrix         | 1 |  3 |
+//                  +---+----+
+//   complex_matrix | 2 |  4 |
+//                  +---+----+
 
 tree_constant
 x_el_div (double a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   Matrix result (nr, nc);
@@ -249,28 +245,26 @@ x_el_div (const Complex a, const Complex
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = a / b.elem (i, j);
 
   return tree_constant (result);
 }
 
-/*
- * Left division functions.
- *
- *       op2 \ op1:   m   cm
- *            +--   +---+----+
- *   matrix         | 1 |  3 |
- *                  +---+----+
- *   complex_matrix | 2 |  4 |
- *                  +---+----+
- */
+// Left division functions.
+//
+//       op2 \ op1:   m   cm
+//            +--   +---+----+
+//   matrix         | 1 |  3 |
+//                  +---+----+
+//   complex_matrix | 2 |  4 |
+//                  +---+----+
 
-/* 1 */
+// -*- 1 -*-
 tree_constant
 xleftdiv (const Matrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
@@ -282,17 +276,17 @@ xleftdiv (const Matrix& a, const Matrix&
     }
 
   int rank;
   Matrix result = a.lssolve (b, info, rank);
 
   return tree_constant (result);
 }
 
-/* 2 */
+// -*- 2 -*-
 tree_constant
 xleftdiv (const Matrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
@@ -304,17 +298,17 @@ xleftdiv (const Matrix& a, const Complex
     }
 
   int rank;
   ComplexMatrix result = a.lssolve (b, info, rank);
 
   return tree_constant (result);
 }
 
-/* 3 */
+// -*- 3 -*-
 tree_constant
 xleftdiv (const ComplexMatrix& a, const Matrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
@@ -326,17 +320,17 @@ xleftdiv (const ComplexMatrix& a, const 
     }
 
   int rank;
   ComplexMatrix result = a.lssolve (b, info, rank);
 
   return tree_constant (result);
 }
 
-/* 4 */
+// -*- 4 -*-
 tree_constant
 xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -48,45 +48,45 @@ any_element_is_negative (const Matrix& a
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       if (a.elem (i, j) < 0.0)
 	return 1;
   return 0;
 }
 
-/*
- * Safer pow functions.
- *
- *       op2 \ op1:   s   m   cs   cm
- *            +--   +---+---+----+----+
- *   scalar   |     | 1 | 5 |  7 | 11 |
- *                  +---+---+----+----+
- *   matrix         | 2 | E |  8 |  E |
- *                  +---+---+----+----+
- *   complex_scalar | 3 | 6 |  9 | 12 |
- *                  +---+---+----+----+
- *   complex_matrix | 4 | E | 10 |  E |
- *                  +---+---+----+----+
- *
- *   E -> error, trapped in arith-ops.cc.
- */
+// Safer pow functions.
+//
+//       op2 \ op1:   s   m   cs   cm
+//            +--   +---+---+----+----+
+//   scalar   |     | 1 | 5 |  7 | 11 |
+//                  +---+---+----+----+
+//   matrix         | 2 | E |  8 |  E |
+//                  +---+---+----+----+
+//   complex_scalar | 3 | 6 |  9 | 12 |
+//                  +---+---+----+----+
+//   complex_matrix | 4 | E | 10 |  E |
+//                  +---+---+----+----+
+//
+//   E -> error, trapped in arith-ops.cc.
 
+// -*- 1 -*-
 tree_constant
 xpow (double a, double b)
 {
   if (a < 0.0 && (int) b != b)
     {
       Complex atmp (a);
       return tree_constant (pow (atmp, b));
     }
   else
     return tree_constant (pow (a, b));
 }
 
+// -*- 2 -*-
 tree_constant
 xpow (double a, const Matrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
@@ -110,25 +110,27 @@ xpow (double a, const Matrix& b)
 
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 3 -*-
 tree_constant
 xpow (double a, const Complex& b)
 {
   Complex result;
   Complex atmp (a);
   result = pow (atmp, b);
   return tree_constant (result);
 }
 
+// -*- 4 -*-
 tree_constant
 xpow (double a, const ComplexMatrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
@@ -152,16 +154,17 @@ xpow (double a, const ComplexMatrix& b)
 
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 5 -*-
 tree_constant
 xpow (const Matrix& a, double b)
 {
   tree_constant retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
@@ -212,16 +215,17 @@ xpow (const Matrix& a, double b)
 
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 6 -*-
 tree_constant
 xpow (const Matrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
@@ -238,24 +242,26 @@ xpow (const Matrix& a, const Complex& b)
 
   ComplexDiagMatrix D (lambda);
 
   ComplexMatrix result = Q * D * Q.inverse ();
 
   return tree_constant (result);
 }
 
+// -*- 7 -*-
 tree_constant
 xpow (const Complex& a, double b)
 {
   Complex result;
   result = pow (a, b);
   return tree_constant (result);
 }
 
+// -*- 8 -*-
 tree_constant
 xpow (const Complex& a, const Matrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
@@ -281,24 +287,26 @@ xpow (const Complex& a, const Matrix& b)
 
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 9 -*-
 tree_constant
 xpow (const Complex& a, const Complex& b)
 {
   Complex result;
   result = pow (a, b);
   return tree_constant (result);
 }
 
+// -*- 10 -*-
 tree_constant
 xpow (const Complex& a, const ComplexMatrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
@@ -322,16 +330,17 @@ xpow (const Complex& a, const ComplexMat
 
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 11 -*-
 tree_constant
 xpow (const ComplexMatrix& a, double b)
 {
   tree_constant retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
@@ -382,16 +391,17 @@ xpow (const ComplexMatrix& a, double b)
 
       ComplexMatrix result = Q * D * Q.inverse ();
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 12 -*-
 tree_constant
 xpow (const ComplexMatrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
@@ -408,33 +418,32 @@ xpow (const ComplexMatrix& a, const Comp
 
   ComplexDiagMatrix D (lambda);
 
   ComplexMatrix result = Q * D * Q.inverse ();
 
   return tree_constant (result);
 }
 
-/*
- * Safer pow functions that work elementwise for matrices.
- *
- *       op2 \ op1:   s   m   cs   cm
- *            +--   +---+---+----+----+
- *   scalar   |     | * | 3 |  * |  9 |
- *                  +---+---+----+----+
- *   matrix         | 1 | 4 |  7 | 10 |
- *                  +---+---+----+----+
- *   complex_scalar | * | 5 |  * | 11 |
- *                  +---+---+----+----+
- *   complex_matrix | 2 | 6 |  8 | 12 |
- *                  +---+---+----+----+
- *
- *   * -> not needed.
- */
+// Safer pow functions that work elementwise for matrices.
+//
+//       op2 \ op1:   s   m   cs   cm
+//            +--   +---+---+----+----+
+//   scalar   |     | * | 3 |  * |  9 |
+//                  +---+---+----+----+
+//   matrix         | 1 | 4 |  7 | 10 |
+//                  +---+---+----+----+
+//   complex_scalar | * | 5 |  * | 11 |
+//                  +---+---+----+----+
+//   complex_matrix | 2 | 6 |  8 | 12 |
+//                  +---+---+----+----+
+//
+//   * -> not needed.
 
+// -*- 1 -*-
 tree_constant
 elem_xpow (double a, const Matrix& b)
 {
   tree_constant retval;
 
   int nr = b.rows ();
   int nc = b.columns ();
 
@@ -457,30 +466,32 @@ elem_xpow (double a, const Matrix& b)
 	  result.elem (i, j) = pow (a, b.elem (i, j)); 
 
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 2 -*-
 tree_constant
 elem_xpow (double a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return tree_constant (result);
 }
 
+// -*- 3 -*-
 tree_constant
 elem_xpow (const Matrix& a, double b)
 {
   tree_constant retval;
 
   int nr = a.rows ();
   int nc = a.columns ();
 
@@ -504,16 +515,17 @@ elem_xpow (const Matrix& a, double b)
 	  result.elem (i, j) = pow (a.elem (i, j), b);
 
       retval = tree_constant (result);
     }
 
   return retval;
 }
 
+// -*- 4 -*-
 tree_constant
 elem_xpow (const Matrix& a, const Matrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
@@ -553,118 +565,126 @@ elem_xpow (const Matrix& a, const Matrix
       for (j = 0; j < nc; j++)
 	for (i = 0; i < nr; i++)
 	  result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
 
       return tree_constant (result);
     }
 }
 
+// -*- 5 -*-
 tree_constant
 elem_xpow (const Matrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return tree_constant (result);
 }
 
+// -*- 6 -*-
 tree_constant
 elem_xpow (const Matrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
 
   return tree_constant (result);
 }
 
+// -*- 7 -*-
 tree_constant
 elem_xpow (const Complex& a, const Matrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return tree_constant (result);
 }
 
+// -*- 8 -*-
 tree_constant
 elem_xpow (const Complex& a, const ComplexMatrix& b)
 {
   int nr = b.rows ();
   int nc = b.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a, b.elem (i, j));
 
   return tree_constant (result);
 }
 
+// -*- 9 -*-
 tree_constant
 elem_xpow (const ComplexMatrix& a, double b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return tree_constant (result);
 }
 
+// -*- 10 -*-
 tree_constant
 elem_xpow (const ComplexMatrix& a, const Matrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   assert (nr == b.rows () && nc == b.columns ());
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b.elem (i, j));
 
   return tree_constant (result);
 }
 
+// -*- 11 -*-
 tree_constant
 elem_xpow (const ComplexMatrix& a, const Complex& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       result.elem (i, j) = pow (a.elem (i, j), b);
 
   return tree_constant (result);
 }
 
+// -*- 12 -*-
 tree_constant
 elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   ComplexMatrix result (nr, nc);
 
