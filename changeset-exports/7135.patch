# HG changeset patch
# User jwe
# Date 1194548050 0
#      Thu Nov 08 18:54:10 2007 +0000
# Node ID 8aa770b6c5bfd5771bd12c4b5b0532bbf5e1f899
# Parent  ff0b965b65bc6f02e264886cce6d6ce3d7ae2d22
[project @ 2007-11-08 18:54:10 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -13,16 +13,25 @@ 2007-11-08  John W. Eaton  <jwe@octave.o
 	control/hinf/hinfnorm.m, control/hinf/hinfsyn.m,
 	control/hinf/hinfsyn_chk.m, control/hinf/is_dgkf.m,
 	control/hinf/wgt1o.m, control/obsolete/dezero.m,
 	control/obsolete/dlqg.m, control/obsolete/minfo.m,
 	control/obsolete/packsys.m, control/obsolete/qzval.m,
 	control/obsolete/rotg.m, control/obsolete/series.m,
 	control/obsolete/swapcols.m, control/obsolete/swaprows.m,
 	control/obsolete/syschnames.m, control/obsolete/unpacksys.m,
+	control/system/buildssic.m, control/system/c2d.m,
+	control/system/d2c.m, control/system/dmr2d.m, control/system/ss.m,
+	control/system/ss2sys.m, control/system/sysadd.m,
+	control/system/sysappend.m, control/system/sysconnect.m,
+	control/system/sysdup.m, control/system/sysgetsignals.m,
+	control/system/sysgroup.m, control/system/sysmin.m,
+	control/system/sysout.m, control/system/sysprune.m,
+	control/system/sysscale.m, control/system/syssetsignals.m,
+	control/system/tf.m, control/system/zp2ss.m,
 	control/util/__outlist__.m, control/util/__zgpbal__.m,
 	control/util/axis2dlim.m, control/util/prompt.m,
 	control/util/sortcom.m, control/util/zgfmul.m,
 	control/util/zgfslv.m, control/util/zginit.m,
 	control/util/zgreduce.m, control/util/zgrownorm.m,
 	control/util/zgscal.m: Style fixes.
 
 2007-11-08  David Bateman  <dbateman@free.fr>
diff --git a/scripts/control/system/buildssic.m b/scripts/control/system/buildssic.m
--- a/scripts/control/system/buildssic.m
+++ b/scripts/control/system/buildssic.m
@@ -154,176 +154,180 @@
 ## (e.g. @code{One = ugain(1);})
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function sys = buildssic (Clst, Ulst, Olst, Ilst, s1, s2, s3, s4, s5, s6, s7, s8)
 
-  if((nargin < 5) || (nargin > 12))
+  if (nargin < 5 || nargin > 12)
     print_usage ();
   endif
   if (nargin >= 5)
-    if (!isstruct(s1))
-      error("---> s1 must be a structed system.");
+    if (! isstruct (s1))
+      error ("---> s1 must be a structed system.");
     endif
-    s1 = sysupdate(s1, "ss");
-    [n, nz, m, p] = sysdimensions(s1);
-    if (!n && !nz)
-      error("---> pure static system must not be the first in list.");
+    s1 = sysupdate (s1, "ss");
+    [n, nz, m, p] = sysdimensions (s1);
+    if (! n && ! nz)
+      error ("---> pure static system must not be the first in list.");
     endif
     if (n && nz)
-      error("---> cannot handle mixed continuous and discrete systems.");
+      error ("---> cannot handle mixed continuous and discrete systems.");
     endif
     D_SYS = (nz > 0);
-    [A,B,C,D,tsam] = sys2ss(s1);
+    [A, B, C, D, tsam] = sys2ss (s1);
     nt = n + nz;
   endif
   for ii = 6:nargin
-    eval(["mysys = s", num2str(ii-4), ";"]);
-    if (!isstruct(mysys))
-      error("---> Parameter must be a structed system.");
+    eval (["mysys = s", num2str(ii-4), ";"]);
+    if (! isstruct (mysys))
+      error ("---> Parameter must be a structed system.");
     endif
-    mysys = sysupdate(mysys, "ss");
-    [n1, nz1, m1, p1] = sysdimensions(mysys);
+    mysys = sysupdate (mysys, "ss");
+    [n1, nz1, m1, p1] = sysdimensions (mysys);
     if (n1 && nz1)
-      error("---> cannot handle mixed continuous and discrete systems.");
+      error ("---> cannot handle mixed continuous and discrete systems.");
     endif
     if (D_SYS)
       if (n1)
-        error("---> cannot handle mixed cont. and discr. systems.");
+        error ("---> cannot handle mixed cont. and discr. systems.");
       endif
-      if (tsam != sysgettsam(mysys))
-        error("---> sampling time of all systems must match.");
+      if (tsam != sysgettsam (mysys))
+        error ("---> sampling time of all systems must match.");
       endif
     endif
-    [as,bs,cs,ds] = sys2ss(mysys);
+    [as, bs, cs, ds] = sys2ss (mysys);
     nt1 = n1 + nz1;
-    if (!nt1)
+    if (! nt1)
       ## pure gain (pad B, C with zeros)
       B = [B, zeros(nt,m1)];
       C = [C; zeros(p1,nt)];
     else
       A = [A, zeros(nt,nt1); zeros(nt1,nt), as];
-      B = [B, zeros(nt,m1);  zeros(nt1,m),  bs];
-      C = [C, zeros(p,nt1);  zeros(p1,nt),  cs];
+      B = [B, zeros(nt,m1); zeros(nt1,m), bs];
+      C = [C, zeros(p,nt1); zeros(p1,nt), cs];
     endif
     D = [D, zeros(p,m1); zeros(p1,m), ds];
     n = n + n1;
     nz = nz + nz1;
     nt = nt + nt1;
     m = m + m1;
     p = p + p1;
   endfor
 
   ## check maximum dimensions
-  [nx, mx] = size(Clst);
+  [nx, mx] = size (Clst);
   if (nx > m)
-    error("---> more rows in Clst than total number of inputs.");
+    error ("---> more rows in Clst than total number of inputs.");
   endif
   if (mx > p+1)
-    error("---> more cols in Clst than total number of outputs.");
+    error ("---> more cols in Clst than total number of outputs.");
   endif
   ## empty vector Ulst is OK
-  lul = length(Ulst);
+  lul = length (Ulst);
   if (lul)
-    if (!isvector(Ulst))
-      error("---> Input u list Ulst must be a vector.");
+    if (! isvector (Ulst))
+      error ("---> Input u list Ulst must be a vector.");
     endif
     if (lul > m)
-      error("---> more values in Ulst than number of inputs.");
+      error ("---> more values in Ulst than number of inputs.");
     endif
   endif
-  if (!length(Olst))  Olst = [1:(p+lul)];  endif
-  if (!length(Ilst))  Ilst = [1:m];        endif
-  if (!isvector(Olst))
-    error("---> Output list Olst must be a vector.");
+  if (! length (Olst))
+    Olst = 1:(p+lul);
+  endif
+  if (! length (Ilst))
+    Ilst = 1:m;
   endif
-  if (!isvector(Ilst))
-    error("---> Input list Ilst must be a vector.");
+  if (! isvector(Olst))
+    error ("---> Output list Olst must be a vector.");
+  endif
+  if (! isvector (Ilst))
+    error ("---> Input list Ilst must be a vector.");
   endif
 
   ## build the feedback "K" from the interconnection data Clst
-  K = zeros(m, p);
-  inp_used = zeros(m,1);
+  K = zeros (m, p);
+  inp_used = zeros (m, 1);
   for ii = 1:nx
     xx = Clst(ii,:);
     iu = xx(1);
-    if ((iu < 1) || (iu > m))
-      error("---> invalid value in first col of Clst.");
+    if (iu < 1 || iu > m)
+      error ("---> invalid value in first col of Clst.");
     endif
     if (inp_used(iu))
-      error("---> Input specified more than once.");
+      error ("---> Input specified more than once.");
     endif
     inp_used(iu) = 1;
     for kk = 2:mx
       it = xx(kk);
-      if (abs(it) > p)
-        error("---> invalid row value in Clst.");
+      if (abs (it) > p)
+        error ("---> invalid row value in Clst.");
       elseif (it)
-        K(iu,abs(it)) = sign(it);
+        K(iu,abs(it)) = sign (it);
       endif
     endfor
   endfor
 
   ## form the "closed loop", i.e replace u in
   ## .
   ## x = Ax + Bu
   ##                            ~
   ## y = Cx + Du   by   u = K*y+u
   ##
   ##            -1
   ## R = (I-D*K)   must exist.
 
-  R = eye(p) - D*K;
-  if (rank(R) < p)
-    error("---> singularity in algebraic loop.");
+  R = eye (p) - D*K;
+  if (rank (R) < p)
+    error ("---> singularity in algebraic loop.");
   else
-    R = inv(R);
+    R = inv (R);
   endif
   A = A + B*K*R*C;
   B = B + B*K*R*D;
   C = R*C;
   D = R*D;
 
   ## append old inputs u to the outputs (if lul > 0)
   kc = K*C;
-  kdi = eye(m) + K*D;
+  kdi = eye (m) + K*D;
   for ii = 1:lul
     it = Ulst(ii);
-    if ((it < 1) || (it > m))
-      error("---> invalid value in Ulst.");
+    if (it < 1 || it > m)
+      error ("---> invalid value in Ulst.");
     endif
     C = [C; kc(it,:)];
     D = [D; kdi(it,:)];
   endfor
 
   ## select and rearrange outputs
-  nn = length(A);
-  lol = length(Olst);
-  Cnew = zeros(lol,nn);
-  Dnew = zeros(lol,m);
+  nn = length (A);
+  lol = length (Olst);
+  Cnew = zeros (lol, nn);
+  Dnew = zeros (lol, m);
   for ii = 1:lol
     iu = Olst(ii);
-    if (!iu || (abs(iu) > p+lul))
-      error("---> invalid value in Olst.");
+    if (! iu || abs(iu) > p+lul)
+      error ("---> invalid value in Olst.");
     endif
     Cnew(ii,:) = sign(iu)*C(abs(iu),:);
     Dnew(ii,:) = sign(iu)*D(abs(iu),:);
   endfor
   C = Cnew;
   D = Dnew;
-  lil = length(Ilst);
-  Bnew = zeros(nn,lil);
-  Dnew = zeros(lol,lil);
+  lil = length (Ilst);
+  Bnew = zeros (nn, lil);
+  Dnew = zeros (lol, lil);
   for ii = 1:lil
     iu = Ilst(ii);
-    if (!iu || (abs(iu) > m))
-      error("---> invalid value in Ilst.");
+    if (! iu || abs(iu) > m)
+      error ("---> invalid value in Ilst.");
     endif
-    Bnew(:,ii) = sign(iu)*B(:,abs(iu));
-    Dnew(:,ii) = sign(iu)*D(:,abs(iu));
+    Bnew(:,ii) = sign (iu) * B(:,abs(iu));
+    Dnew(:,ii) = sign (iu) * D(:,abs(iu));
   endfor
 
-  sys = ss(A, Bnew, C, Dnew, tsam, n, nz);
+  sys = ss (A, Bnew, C, Dnew, tsam, n, nz);
 
 endfunction
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -95,133 +95,133 @@
 ## to the names of the new discrete states.
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: October 1993
 ## Updated by John Ingram for system data structure August 1996
 
 function dsys = c2d (sys, opt, T)
+
   ## parse input arguments
-  if(nargin < 1 | nargin > 3)
+  if (nargin < 1 || nargin > 3)
     print_usage ();
-  elseif (!isstruct(sys))
-    error("sys must be a system data structure");
+  elseif (! isstruct (sys))
+    error ("sys must be a system data structure");
   elseif (nargin == 1)
     opt = "ex";
-  elseif (nargin == 2 & !ischar(opt) )
+  elseif (nargin == 2 && ! ischar (opt))
     T = opt;
     opt = "ex";
   endif
 
   if (! ischar (opt))
     error ("expecting option as a string");
   endif
 
   ## check if sampling period T was passed.
-  Ts = sysgettsam(sys);
-  if(!exist("T"))
+  Ts = sysgettsam (sys);
+  if (! exist ("T"))
     T = Ts;
-    if(T == 0)
-      error("sys is purely continuous; no sampling period T provided");
+    if (T == 0)
+      error ("sys is purely continuous; no sampling period T provided");
     endif
-  elseif (T != Ts & Ts > 0)
-    warning(["c2d: T=",num2str(T),", system tsam==",num2str(Ts), ...
-      ": using T=", num2str(min(T,Ts))]);
-    T = min(T,Ts);
+  elseif (T != Ts && Ts > 0)
+    warning ("c2d: T=%g, system tsam=%g: using T=", T, Ts, min (T, Ts));
+    T = min (T, Ts);
   endif
 
-  if (!is_sample(T))
-    error("sampling period T must be a positive, real scalar");
+  if (! is_sample (T))
+    error ("sampling period T must be a positive, real scalar");
   elseif (! (strcmp (opt, "ex")
 	     || strcmp (opt, "bi")
 	     || strcmp (opt, "matched")))
     error ("invalid option passed: %s", opt);
   endif
 
-  sys = sysupdate(sys,"ss");
-  [n,nz,m,p] = sysdimensions(sys);
-  if(n == 0)
-    dsys = syssetsignals(sys,"yd",ones(1:p));
-  elseif(strcmp(opt,"ex"));
-    [aa,bb,cc,dd] = sys2ss(sys);
+  sys = sysupdate (sys, "ss");
+  [n, nz, m, p] = sysdimensions (sys);
+  if (n == 0)
+    dsys = syssetsignals (sys, "yd", ones(1:p));
+  elseif (strcmp (opt, "ex"));
+    [aa, bb, cc, dd] = sys2ss (sys);
     crng= 1:n;
     drng = n+(1:nz);
 
     ## partition state equations into continuous, imaginary subsystems
     Ac = aa(crng,crng);
     Bc = bb(crng,:);
-    if(nz == 0)
+    if (nz == 0)
       Acd = Adc = Add = Bd = 0;
     else
       Acd = aa(crng,drng);
       Adc = aa(drng,crng);
       Add = aa(drng,drng);
       Bd  = bb(drng,:);
       Bc  = [Bc, Acd];   ## append discrete states as inputs to cont system
     endif
 
     ## convert state equations
     mat = [Ac, Bc; zeros(m+nz,n+nz+m)];
-    matexp = expm(mat * T);
+    matexp = expm (mat * T);
 
     ## replace Ac
     aa(crng,crng) = matexp(crng,crng);    ## discretized homegenous diff eqn
 
     ## replace Bc
-    bb(crng,:)    = matexp(crng,n+(1:m));
+    bb(crng,:) = matexp(crng,n+(1:m));
 
     ## replace Acd
-    if(nz)
+    if (nz)
       aa(crng,drng) = matexp(crng,n+m+(1:nz));
     end
 
-    stnames = sysgetsignals(sys,"st");   ## continuous states renamed below
-    innames = sysgetsignals(sys,"in");
-    outnames = sysgetsignals(sys,"out");
+    stnames = sysgetsignals (sys, "st");   ## continuous states renamed below
+    innames = sysgetsignals (sys, "in");
+    outnames = sysgetsignals (sys, "out");
     outlist = 1:p;
-    dsys = ss(aa,bb,cc,dd,T,0,n+nz,stnames,innames, ...
-        outnames,outlist);
+    dsys = ss (aa, bb, cc, dd, T, 0, n+nz, stnames, innames,
+	       outnames, outlist);
     ## rename states
-    for ii=1:n
-      strval = sprintf("%s_d",sysgetsignals(dsys,"st",ii,1));
-      dsys = syssetsignals(dsys,"st",strval,ii);
+    for ii = 1:n
+      strval = sprintf ("%s_d", sysgetsignals (dsys, "st", ii, 1));
+      dsys = syssetsignals (dsys, "st", strval, ii);
     endfor
 
-  elseif(strcmp(opt,"bi"))
-    if(is_digital(sys))
-      error("c2d: system is already digital")
+  elseif (strcmp (opt, "bi"))
+    if (is_digital (sys))
+      error ("c2d: system is already digital")
     else
       ## convert with bilinear transform
-      [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys);
-      IT = (2/T)*eye(size(a));
+      [a, b, c, d, tsam, n, nz, stname, inname, outname, yd] = sys2ss (sys);
+      IT = (2/T) * eye (size (a));
       A = (IT+a)/(IT-a);
       iab = (IT-a)\b;
-      tk=2/sqrt(T);
+      tk = 2 / sqrt (T);
       B = tk*iab;
       C = tk*(c/(IT-a));
       D = d + (c*iab);
-      stnamed = strappend(stname,"_d");
-      dsys = ss(A,B,C,D,T,0,rows(A),stnamed,inname,outname);
+      stnamed = strappend (stname, "_d");
+      dsys = ss (A, B, C, D, T, 0, rows (A), stnamed, inname, outname);
      endif
-   elseif(strcmp(opt,"matched"))
-     if(is_digital(sys))
-       error("c2d: system is already digital");
-     elseif((length(sys.inname) != 1) || (length(sys.outname) != 1))
-       error("c2d: system in not single input, single output");
+   elseif (strcmp (opt, "matched"))
+     if (is_digital (sys))
+       error ("c2d: system is already digital");
+     elseif (length (sys.inname) != 1 || length (sys.outname) != 1)
+       error ("c2d: system in not single input, single output");
      else
-       sys = sysupdate(sys,"zp");
-       p = exp(sys.pol*T);
-       z = exp(sys.zer*T);
-       infinite_zeros = max(size(sys.pol))-max(size(sys.zer))-1;
+       sys = sysupdate (sys, "zp");
+       p = exp (sys.pol*T);
+       z = exp (sys.zer*T);
+       infinite_zeros = max (size (sys.pol)) - max (size (sys.zer)) - 1;
        for i = 1:infinite_zeros
 	 z = [z ; -1];
        endfor
        ## Should the freaquency we adjust around always be 1?   
-       [cmag,cphase,cw] = bode(sys,1);
-       [dmag,dpahse,dw] = bode(zp(z,p,1,T),1);
-      dsys = zp(z,p,cmag/dmag,T);
-    endif
+       [cmag, cphase, cw] = bode (sys, 1);
+       [dmag, dpahse, dw] = bode (zp (z, p, 1, T), 1);
+       dsys = zp (z, p, cmag/dmag, T);
+     endif
   else
     error ("invalid option = %s", opt);
   endif
 
 endfunction
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -61,166 +61,166 @@
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: August 23, 1994
 ## Updated by John Ingram for system data structure  August 1996
 
 function csys = d2c (sys, opt)
 
   ## SYS_INTERNAL accesses members of system data structure
 
-  if( (nargin != 1) & (nargin != 2) )
+  if (nargin != 1 && nargin != 2)
     print_usage ();
-  elseif (!isstruct(sys))
-    error("sys must be in system data structure");
-  elseif(nargin == 1)
+  elseif (! isstruct (sys))
+    error ("sys must be in system data structure");
+  elseif (nargin == 1)
     opt = "log";
     tol = 1e-12;
-  elseif(ischar(opt))   # all remaining cases are for nargin == 2
+  elseif (ischar (opt))   # all remaining cases are for nargin == 2
     tol = 1e-12;
-    if( !(strcmp(opt,"log") | strcmp(opt,"bi") ) )
-      error(["d2c: invalid opt passed=",opt]);
+    if (! (strcmp (opt, "log") || strcmp (opt, "bi")))
+      error ("d2c: invalid opt passed=%s", opt);
     endif
-  elseif(!is_sample(opt))
-    error("tol must be a positive scalar")
-  elseif(opt > 1e-2)
-    warning(["d2c: ridiculous error tolerance passed=",num2str(opt); ...
-        ", intended c2d call?"])
+  elseif (! is_sample (opt))
+    error ("tol must be a positive scalar")
+  elseif (opt > 1e-2)
+    warning ("d2c: ridiculous error tolerance passed=%g, intended c2d call?",
+	     opt);
   else
     tol = opt;
     opt = "log";
   endif
-  T = sysgettsam(sys);
+  T = sysgettsam (sys);
 
-  if(strcmp(opt,"bi"))
+  if (strcmp (opt, "bi"))
     ## bilinear transform
     ## convert with bilinear transform
-    if (! is_digital(sys) )
-       error("d2c requires a discrete time system for input")
+    if (! is_digital (sys) )
+       error ("d2c requires a discrete time system for input")
     endif
-    [a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys);
+    [a, b, c, d, tsam, n, nz, stname, inname, outname, yd] = sys2ss (sys);
 
-    poles = eig(a);
-    if( find(abs(poles-1) < 200*(n+nz)*eps) )
-      warning("d2c: some poles very close to one.  May get bad results.");
+    poles = eig (a);
+    if (find (abs (poles-1) < 200*(n+nz)*eps))
+      warning ("d2c: some poles very close to one.  May get bad results.");
     endif
 
-    I = eye(size(a));
-    tk = 2/sqrt(T);
+    I = eye (size (a));
+    tk = 2 / sqrt (T);
     A = (2/T)*(a-I)/(a+I);
     iab = (I+a)\b;
     B = tk*iab;
     C = tk*(c/(I+a));
     D = d- (c*iab);
-    stnamec = strappend(stname,"_c");
-    csys = ss(A,B,C,D,0,rows(A),0,stnamec,inname,outname);
-  elseif(strcmp(opt,"log"))
-    sys = sysupdate(sys,"ss");
-    [n,nz,m,p] = sysdimensions(sys);
+    stnamec = strappend (stname, "_c");
+    csys = ss (A, B, C, D, 0, rows (A), 0, stnamec, inname, outname);
+  elseif (strcmp (opt, "log"))
+    sys = sysupdate (sys, "ss");
+    [n, nz, m, p] = sysdimensions (sys);
 
-    if(nz == 0)
-      warning("d2c: all states continuous; setting outputs to agree");
-      csys = syssetsignals(sys,"yd",zeros(1,1:p));
+    if (nz == 0)
+      warning ("d2c: all states continuous; setting outputs to agree");
+      csys = syssetsignals (sys, "yd", zeros (1, 1:p));
       return;
-    elseif(n != 0)
-      warning(["d2c: n=",num2str(n),">0; performing c2d first"]);
-      sys = c2d(sys,T);
+    elseif (n != 0)
+      warning ("d2c: n=%d > 0; performing c2d first", n);
+      sys = c2d (sys, T);
     endif
-    [a,b] = sys2ss(sys);
+    [a, b] = sys2ss (sys);
 
-    [ma,na] = size(a);
-    [mb,nb] = size(b);
+    [ma, na] = size (a);
+    [mb, nb] = size (b);
 
-    if(isempty(b) )
-      warning("d2c: empty b matrix");
+    if (isempty (b))
+      warning ("d2c: empty b matrix");
       Amat = a;
     else
       Amat = [a, b; zeros(nb,na), eye(nb)];
     endif
 
-    poles = eig(a);
-    if( find(abs(poles) < 200*(n+nz)*eps) )
-      warning("d2c: some poles very close to zero.  logm not performed");
-      Mtop = zeros(ma, na+nb);
-    elseif( find(abs(poles-1) < 200*(n+nz)*eps) )
-      warning("d2c: some poles very close to one.  May get bad results.");
-      logmat = real(logm(Amat)/T);
+    poles = eig (a);
+    if (find (abs (poles) < 200*(n+nz)*eps))
+      warning ("d2c: some poles very close to zero.  logm not performed");
+      Mtop = zeros (ma, na+nb);
+    elseif (find (abs (poles-1) < 200*(n+nz)*eps))
+      warning ("d2c: some poles very close to one.  May get bad results.");
+      logmat = real (logm (Amat) / T);
       Mtop = logmat(1:na,:);
     else
-      logmat = real(logm(Amat)/T);
+      logmat = real (logm (Amat) / T);
       Mtop = logmat(1:na,:);
     endif
 
     ## perform simplistic, stupid optimization approach.
     ## should re-write with a Davidson-Fletcher CG approach
-    mxthresh = norm(Mtop);
-    if(mxthresh == 0)
+    mxthresh = norm (Mtop);
+    if (mxthresh == 0)
       mxthresh = 1;
     endif
     eps1 = mxthresh;    #gradient descent step size
-    cnt = max(20,(n*nz)*4);     #max number of iterations
+    cnt = max (20, (n*nz)*4);     #max number of iterations
     newgrad=1;  #signal for new gradient
-    while( (eps1/mxthresh > tol) & cnt)
-      cnt = cnt-1;
+    while ((eps1/mxthresh > tol) && cnt)
+      cnt--;
       ## calculate the gradient of error with respect to Amat...
-      geps = norm(Mtop)*1e-8;
-      if(geps == 0)
+      geps = norm (Mtop) * 1e-8;
+      if (geps == 0)
         geps = 1e-8;
       endif
       DMtop = Mtop;
-      if(isempty(b))
+      if (isempty (b))
         Mall = Mtop;
         DMall = DMtop;
       else
         Mall = [Mtop; zeros(nb,na+nb)];
         DMall = [DMtop; zeros(nb,na+nb) ];
       endif
 
-      if(newgrad)
-        GrMall = zeros(size(Mall));
-        for ii=1:rows(Mtop)
-          for jj=1:columns(Mtop)
+      if (newgrad)
+        GrMall = zeros (size (Mall));
+        for ii = 1:rows(Mtop)
+          for jj = 1:columns(Mtop)
           DMall(ii,jj) = Mall(ii,jj) + geps;
             GrMall(ii,jj) = norm (Amat - expm (DMall*T), "fro") ...
                 - norm (Amat - expm (Mall*T), "fro");
           DMall(ii,jj) = Mall(ii,jj);
           endfor
         endfor
         GrMall = GrMall/norm(GrMall,1);
         newgrad = 0;
       endif
 
       ## got a gradient, now try to use it
       DMall = Mall-eps1*GrMall;
 
-      FMall = expm(Mall*T);
-      FDMall = expm(DMall*T);
-      FmallErr = norm(Amat - FMall);
-      FdmallErr = norm(Amat - FDMall);
-      if( FdmallErr < FmallErr)
+      FMall = expm (Mall*T);
+      FDMall = expm (DMall*T);
+      FmallErr = norm (Amat - FMall);
+      FdmallErr = norm (Amat - FDMall);
+      if (FdmallErr < FmallErr)
         Mtop = DMall(1:na,:);
-        eps1 = min(eps1*2,1e12);
+        eps1 = min (eps1*2, 1e12);
         newgrad = 1;
       else
         eps1 = eps1/2;
       endif
 
-      if(FmallErr == 0)
+      if (FmallErr == 0)
         eps1 = 0;
       endif
 
     endwhile
 
-    [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
+    [aa, bb, cc, dd, tsam, nn, nz, stnam, innam, outnam, yd] = sys2ss (sys);
     aa = Mall(1:na,1:na);
-    if(!isempty(b))
+    if (! isempty (b))
       bb = Mall(1:na,(na+1):(na+nb));
     endif
-    csys = ss(aa,bb,cc,dd,0,na,0,stnam,innam,outnam);
+    csys = ss (aa, bb, cc, dd, 0, na, 0, stnam, innam, outnam);
 
     ## update names
-    nn = sysdimensions(sys);
+    nn = sysdimensions (sys);
     for ii = (nn+1):na
-      strval = sprintf("%s_c",sysgetsignals(csys,"st",ii,1));
-      csys = syssetsignals(csys,"st",strval,ii);
+      strval = sprintf ("%s_c", sysgetsignals (csys, "st", ii, 1));
+      csys = syssetsignals (csys, "st", strval, ii);
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/system/dmr2d.m b/scripts/control/system/dmr2d.m
--- a/scripts/control/system/dmr2d.m
+++ b/scripts/control/system/dmr2d.m
@@ -73,192 +73,184 @@
 
 ## Adapted from c2d by a.s.hodel@eng.auburn.edu
 
 function [dsys, fidx] = dmr2d (sys, idx, sprefix, Ts2, cuflg)
 
   ## parse input arguments
   if (nargin != 4)
     print_usage ();
-
-  elseif (!isstruct(sys))
-    error("sys must be in system data structure form");
-
-  elseif(!is_digital(sys))
-    error("sys must be discrete-time; continuous time passed");
-  
+  elseif (! isstruct (sys))
+    error ("sys must be in system data structure form");
+  elseif (! is_digital (sys))
+    error ("sys must be discrete-time; continuous time passed");
   endif
 
-  if(is_signal_list(idx) | ischar(idx))
-    idx = sysidx(sys,"st",idx);
-
-  elseif (!(isvector(idx) | isempty(idx)))
-    error(["idx(",num2str(rows(idx)),"x",num2str(columns(idx)), ...
-      ") must be a vector"]);
-
-  elseif (any(idx <= 0))
-    idv = find(idx <= 0);
+  if (is_signal_list (idx) || ischar (idx))
+    idx = sysidx (sys, "st", idx);
+  elseif (! (isvector (idx) || isempty (idx)))
+    error ("idx(%dx%d) must be a vector", rows (idx), columns (idx));
+  elseif (any (idx <= 0))
+    idv = find (idx <= 0);
     ii = idv(1);
-    error(["idx(",num2str(ii),")=",num2str(idx(ii)), ...
-      "; entries of idx must be positive"]);
-
-  elseif(!(is_signal_list(sprefix) | isempty(sprefix)))
-    error("sprefix must be a signal list (see is_signal_list) or empty");
-
-  elseif(!is_sample(Ts2))
-    error(["Ts2=",num2str(Ts2),"; invalid sampling time"]);
-
+    error ("idx(%d)=%g; entries of idx must be positive", ii, idx(ii));
+  elseif (! (is_signal_list (sprefix) || isempty (sprefix)))
+    error ("sprefix must be a signal list (see is_signal_list) or empty");
+  elseif (! is_sample (Ts2))
+    error ("Ts2=%g; invalid sampling time", Ts2);
   endif
 
   ## optional argument: cuflg
-  if(nargin <= 4)
+  if (nargin <= 4)
     cuflg = 1;          # default: constant inputs over Ts2 sampling interv.
-  elseif( !isscalar(cuflg) )
-    error("cuflg must be a scalar")
-  elseif( cuflg != 0 | cuflg != 1)
-    error(["cuflg = ",num2str(cuflg),", should be 0 or 1"]);
+  elseif (! isscalar (cuflg))
+    error ("cuflg must be a scalar")
+  elseif (cuflg != 0 || cuflg != 1)
+    error ("cuflg = %g, should be 0 or 1", cuflg);
   endif
 
   ## extract  state space information
-  [da,db,dc,dd,Ts1,nc,nz,stname,inname,outname,yd] = sys2ss(sys);
+  [da, db, dc, dd, Ts1, nc, nz, stname, inname, outname, yd] = sys2ss (sys);
 
   ## compute number of steps
-  if(Ts1 > Ts2)
-    error(["Current sampling time=",num2str(Ts1)," > Ts2=",num2str(Ts2)]);
+  if (Ts1 > Ts2)
+    error ("Current sampling time=%g > Ts2=%g", Ts1, Ts2);
   endif
-  nstp = floor(Ts2/Ts1+0.5);
-  if(abs((Ts2 - Ts1*nstp)/Ts1) > 1e-12)
-    warning(["dmr2d: Ts1=",num2str(Ts1),", Ts2=",num2str(Ts2), ...
-      ", selecting nsteps=",num2str(nstp),"; mismatch"]);
+  nstp = floor (Ts2/Ts1+0.5);
+  if (abs ((Ts2 - Ts1*nstp)/Ts1) > 1e-12)
+    warning ("dmr2d: Ts1=%g, Ts2=%g, selecting nsteps=%d; mismatch",
+	     Ts1, Ts2, nstp);
   endif
 
-  if(isempty(sprefix) & isempty(idx))
-    warning("both sprefix and idx are empty; returning dsys=sys");
+  if (isempty (sprefix) && isempty (idx))
+    warning ("both sprefix and idx are empty; returning dsys=sys");
     fidx = [];
     dsys = sys;
     return
-  elseif(isempty(sprefix))
+  elseif (isempty (sprefix))
     fidx = idx;
   else
-    fidx = reshape(idx,1,length(idx));
+    fidx = reshape (idx, 1, length(idx));
     ## find states whose name begins with any strings in sprefix.
-    ns = length(sprefix);
-    for kk=1:ns
+    ns = length (sprefix);
+    for kk = 1:ns
       spk = sprefix{kk};  # get next prefix and length
-      spl = length(spk);
+      spl = length (spk);
 
       ## check each state name
-      for ii=1:nz
+      for ii = 1:nz
         sti = stname{ii};  # compare spk with this state name
-        if(length(sti) >= spl)
+        if (length (sti) >= spl)
           ## if the prefix matches and ii isn't already in the list, add ii
-          if(strcmp(sti(1:spl),spk) & !any(fidx == ii) )
-            fidx = sort([fidx,ii]);
+          if (strcmp (sti(1:spl), spk) && ! any (fidx == ii))
+            fidx = sort ([fidx, ii]);
           endif
         endif
       endfor
     endfor
   endif
 
-  if(nstp == 0)
-    warning("dmr2d: nstp = 0; setting tsam and returning");
-    dsys = syschtsam(sys,Ts2);
-    return
-  elseif(nstp < 0)
-    error(["nstp = ", num2str(nstp)," < 0; this shouldn't be!"]);
+  if (nstp == 0)
+    warning ("dmr2d: nstp = 0; setting tsam and returning");
+    dsys = syschtsam (sys, Ts2);
+    return;
+  elseif (nstp < 0)
+    error ("nstp = %d < 0; this shouldn't be!", nstp);
   endif
 
   ## permute system matrices
-  pv = sysreorder(nz,fidx);
+  pv = sysreorder (nz, fidx);
   pv = pv(nz:-1:1);          # reverse order to put fast modes in leading block
 
   ## construct inverse permutation
-  Inz = eye(nz);
+  Inz = eye (nz);
   pvi = (Inz(pv,:)'*[1:nz]')';
 
   ## permute A, B (stname permuted for debugging only)
   da = da(pv,pv);
   db = db(pv,:);
-  stname = stname(pv);
+  stname = stname (pv);
 
   ## partition A, B:
-  lfidx = length(fidx);
+  lfidx = length (fidx);
   bki = 1:lfidx;
   a11 = da(bki,bki);
   b1 = db(bki,:);
 
-  if(lfidx < nz)
+  if (lfidx < nz)
     lfidx1 = lfidx+1;
     bki2 = (lfidx1):nz;
     a12 = da(bki,bki2);
     b2 = db(bki2,:);
   else
-    warning("dmr2d: converting entire A,B matrices to new sampling rate");
+    warning ("dmr2d: converting entire A,B matrices to new sampling rate");
     lfidx1 = -1;
     bki2 = [];
   endif
 
   ## begin system conversion: nstp steps
 
   ## compute abar_{n-1}*a12 and appropriate b matrix stuff
   a12b = a12;      # running  total of abar_{n-1}*a12
   a12w = a12;      # current a11^n*a12  (start with n = 0)
-  if(cuflg)
+  if (cuflg)
     b1b = b1;
     b1w = b1;
   else
     ## cuflg == 0, need to keep track of intersample inputs too
-    nzdx = find(max(abs(b1)) != 0);  # FIXME: check tolerance relative to ||b1||
+    ## FIXME: check tolerance relative to ||b1||
+    nzdx = find (max (abs (b1)) != 0);
     b1w = b1(nzdx);
     innamenz = inname(nzdx);
     b1b = b1;                        # initial b1 must match columns in b2
   endif
 
   ## compute a11h = a11^nstp by squaring
-  a11h = eye(size(a11));
+  a11h = eye (size (a11));
   p2 = 1;
   a11p2 = a11;        #a11^p2
 
   nstpw = nstp;       # workspace for computing a11^nstp
-  while(nstpw > 0.5)
-    oddv = rem(nstpw,2);
-    if(oddv)
+  while (nstpw > 0.5)
+    oddv = rem (nstpw, 2);
+    if (oddv)
       a11h = a11h*a11p2;
     endif
     nstpw = (nstpw-oddv)/2;
-    if(nstpw > 0.5)
+    if (nstpw > 0.5)
       a11p2 = a11p2*a11p2;    # a11^(next power of 2)
     endif
   endwhile
 
   ## FIXME: this part should probably also use squaring, but
   ## that would require exponentially growing memory.  What do do?
-  for kk=2:nstp
+  for kk = 2:nstp
     ## update a12 block to sum(a12 + ... + a11^(kk-1)*a12)
     a12w = a11*a12w;
     a12b = a12b + a12w;
 
     ## similar for b1 block (checking for cuflg first!)
     b1w = a11*b1w;
-    if(cuflg)
+    if (cuflg)
       b1b = b1b + b1w;        # update b1 block just like we did a12
     else
       b1b = [b1b, b1w];       # append new inputs
-      newin = strappend(innamenz,["_d",num2str(kk-1)]);
-      inname = __sysconcat__(inname,newin);
+      newin = sprintf ("%s_d%d", innamenz, kk-1);
+      inname = __sysconcat__ (inname, newin);
     endif
   endfor
 
   ## reconstruct system and return
   da(bki,bki) = a11h;
   db(bki,1:columns(b1b)) = b1b;
-  if(!isempty(bki2))
+  if (! isempty (bki2))
     da(bki,bki2) = a12b;
   endif
 
   da = da(pvi,pvi);
   db = db(pvi,:);
   stname = stname(pvi);
 
   ## construct new system and return
-  dsys = ss(da,db,dc,dd,Ts2,0,nz,stname,inname,outname,find(yd == 1));
+  dsys = ss (da, db, dc, dd, Ts2, 0, nz, stname, inname, outname,
+	     find (yd == 1));
 
 endfunction
diff --git a/scripts/control/system/ss.m b/scripts/control/system/ss.m
--- a/scripts/control/system/ss.m
+++ b/scripts/control/system/ss.m
@@ -186,107 +186,120 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 20, 1996
 
 function retsys = ss (a, b, c, d, tsam, n, nz, stname, inname, outname, outlist)
 
   ## Test for correct number of inputs
-  if ((nargin < 3) | (nargin > 11))
+  if (nargin < 3 || nargin > 11)
     print_usage ();
   endif
 
   ## verify A, B, C, D arguments
   ## If D is not specified, set it to a zero matrix of appriate dimension.
-  if (nargin == 3)          d = zeros(rows(c) , columns(b));
-  elseif (isempty(d))       d = zeros(rows(c) , columns(b));      endif
+  if (nargin == 3)
+    d = zeros (rows (c), columns (b));
+  elseif (isempty (d))
+    d = zeros (rows (c), columns (b));
+  endif
 
   ## Check the dimensions
-  [na,m,p] = abcddim(a,b,c,d);
+  [na, m, p] = abcddim (a, b, c, d);
 
   ## If dimensions are wrong, exit function
   if (m == -1)
-    error("a(%dx%d), b(%dx%d), c(%dx%d), d(%dx%d); incompatible", ...
-      rows(a), columns(a), rows(b), columns(b), rows(c), columns(c), ...
-      rows(d), columns(d));
+    error ("a(%dx%d), b(%dx%d), c(%dx%d), d(%dx%d); incompatible",
+	   rows (a), columns (a), rows (b), columns (b),
+	   rows (c), columns (c), rows (d), columns (d));
   endif
 
   ## check for tsam input
-  if(nargin < 5) tsam = 0;
-  elseif( !( is_sample(tsam) | (tsam == 0) ) )
-    error("tsam must be a nonnegative real scalar");
+  if (nargin < 5) tsam = 0;
+  elseif (! (is_sample (tsam) || tsam == 0)))
+    error ("tsam must be a nonnegative real scalar");
   endif
 
   ## check for continuous states
-  if( (nargin < 6) & (tsam == 0) )               n = na;
-  elseif(nargin < 6)                             n = 0;
-  elseif((!ismatrix(n)) | ischar(n))
-    error("Parameter n is not a numerical value.");
-  elseif( (!isscalar(n)) | (n < 0 ) | (n != round(n)) )
-    if(isscalar(n))     error("invalid value of n=%d,%e",n,n);
-    else                 error("invalid value of n=(%dx%d)", ...
-                           rows(n), columns(n));                endif
+  if (nargin < 6 && tsam == 0)
+    n = na;
+  elseif (nargin < 6)
+    n = 0;
+  elseif (! ismatrix (n) || ischar (n))
+    error ("Parameter n is not a numerical value.");
+  elseif (! isscalar(n) || n < 0 || n != round (n))
+    if (isscalar (n))
+      error ("invalid value of n=%d,%e", n, n);
+    else
+      error ("invalid value of n=(%dx%d)", rows (n), columns (n));
+    endif
   endif
 
   ## check for num discrete states
-  if( (nargin < 7) & (tsam == 0))               nz = 0;
-  elseif(nargin < 7)                            nz = na - n;
-  elseif((!ismatrix(nz)) | ischar(nz))
-    error("Parameter nz is not a numerical value.");
-  elseif( (!isscalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
-    if(isscalar(nz))
-      error(["invalid value of nz=",num2str(nz)]);
+  if (nargin < 7 && tsam == 0)
+    nz = 0;
+  elseif (nargin < 7)
+    nz = na - n;
+  elseif (! ismatrix(nz) || ischar (nz))
+    error ("Parameter nz is not a numerical value.");
+  elseif (! isscalar(nz) || nz < 0 || nz != round(nz))
+    if (isscalar (nz))
+      error ("invalid value of nz=%d", nz);
     else
-      error(["invalid value of nz=(",num2str(rows(nz)),"x", ...
-        num2str(columns(nz)),")"]);
+      error ("invalid value of nz=(%d,%d)", rows (nz), columns (nz));
     endif
   endif
 
   ## check for total number of states
-  if( (n + nz) != na )
-    error(["invalid: a is ",num2str(na),"x",num2str(na),", n=", ...
-        num2str(n),", nz=",num2str(nz)]);
+  if ((n + nz) != na)
+    error ("invalid: a is %dx%d, n=%d, nz=%d", na, na, n, nz);
   endif
 
   ## construct system with default names
   retsys.a = a;
   retsys.b = b;
   retsys.c = c;
   retsys.d = d;
 
   retsys.n = n;
   retsys.nz = nz;
   retsys.tsam = tsam;
-  retsys.yd = zeros(1,p);     # default value entered below
+  retsys.yd = zeros (1, p);     # default value entered below
 
   ## Set the system vector:  active = 2(ss), updated = [0 0 1];
   retsys.sys = [2, 0, 0, 1];
 
   retsys.stname = __sysdefstname__ (n, nz);
   retsys.inname = __sysdefioname__ (m, "u");
   retsys.outname = __sysdefioname__ (p, "y");
 
   ## check for state names
-  if(nargin >= 8)
-    if(!isempty(stname)) retsys = syssetsignals(retsys,"st",stname); endif
+  if (nargin >= 8)
+    if (! isempty (stname))
+      retsys = syssetsignals (retsys, "st", stname);
+    endif
   endif
 
   ## check for input names
-  if(nargin >= 9)
-    if(!isempty(inname)) retsys = syssetsignals(retsys,"in",inname); endif
+  if (nargin >= 9)
+    if (! isempty (inname))
+      retsys = syssetsignals (retsys, "in", inname);
+    endif
   endif
 
   ## check for output names
-  if(nargin >= 10)
-    if(!isempty(outname)) retsys = syssetsignals(retsys,"out",outname); endif
+  if (nargin >= 10)
+    if (! isempty (outname))
+      retsys = syssetsignals (retsys, "out", outname);
+    endif
   endif
 
   ## set up yd
-  if(nargin < 11)
-    retsys = syssetsignals(retsys,"yd",ones(1,p)*(tsam > 0));
+  if (nargin < 11)
+    retsys = syssetsignals (retsys, "yd", ones(1,p)*(tsam > 0));
   else
-    if(!isempty(outlist))
-      retsys = syssetsignals(retsys,"yd",ones(size(outlist)),outlist);
+    if (! isempty (outlist))
+      retsys = syssetsignals (retsys, "yd", ones (size (outlist)), outlist);
     endif
   endif
 
 endfunction
diff --git a/scripts/control/system/ss2sys.m b/scripts/control/system/ss2sys.m
--- a/scripts/control/system/ss2sys.m
+++ b/scripts/control/system/ss2sys.m
@@ -182,12 +182,12 @@
 ## since none were given.
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 20, 1996
 
 function retsys = ss2sys (varargin )
   
-  warning("ss2sys is deprecated.  Use ss() instead.");
-  retsys = ss(varargin{:});
+  warning ("ss2sys is deprecated.  Use ss instead.");
+  retsys = ss (varargin{:});
 
 endfunction
diff --git a/scripts/control/system/sysadd.m b/scripts/control/system/sysadd.m
--- a/scripts/control/system/sysadd.m
+++ b/scripts/control/system/sysadd.m
@@ -41,87 +41,93 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## Updated for variable number of arguments July 1999 A. S. Hodel
 
 function sys = sysadd (varargin)
 
-  if(nargin < 1)
+  if (nargin < 1)
     print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
-  for kk=1:nargin
+  for kk = 1:nargin
     arglist{kk} = varargin{kk};
-    if(!isstruct(arglist{kk}))
-      error("sysadd: argument %d is not a data structure",kk);
+    if (! isstruct (arglist{kk}))
+      error ("sysadd: argument %d is not a data structure", kk);
     endif
   endfor
 
   ## check system dimensions
-  [n,nz,mg,pg,Gyd] = sysdimensions(arglist{1});
-  for kk=2:nargin
-    [n,nz,mh,ph,Hyd] = sysdimensions(arglist{kk});
-    if(mg != mh)
-      error("arg 1 has %d inputs; arg %d has vs %d inputs",mg,kk,mh);
-    elseif(pg != ph)
-      error("arg 1 has %d outputs; arg %d has vs %d outputs",pg,kk,ph);
-    elseif(norm(Gyd - Hyd))
-      warning("cannot add a discrete output to a continuous output");
-      error("Output type mismatch: arguments 1 and %d\n",kk);
+  [n, nz, mg, pg, Gyd] = sysdimensions (arglist{1});
+  for kk = 2:nargin
+    [n, nz, mh, ph, Hyd] = sysdimensions (arglist{kk});
+    if (mg != mh)
+      error ("arg 1 has %d inputs; arg %d has vs %d inputs", mg, kk, mh);
+    elseif (pg != ph)
+      error ("arg 1 has %d outputs; arg %d has vs %d outputs", pg, kk, ph);
+    elseif (norm (Gyd - Hyd))
+      warning ("cannot add a discrete output to a continuous output");
+      error ("Output type mismatch: arguments 1 and %d\n", kk);
     endif
   endfor
 
   ## perform the add
   if (nargin == 2)
     Gsys = arglist{1};
     Hsys = arglist{2};
 
     # check if adding scalar transfer functions with identical denoms
-    [Gn, Gnz, Gm, Gp] = sysdimensions(Gsys);
-    [Hn, Hnz, Hm, Hp] = sysdimensions(Hsys);
-    if ( Gm ==1 & Gp == 1 & Hm == 1 & Hp == 1 & Gn == Hn & Gnz == Hnz )
-      # dimensions are compatible, check if can add
-      [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
-      [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
-      if (length(Hden) == length(Gden) )
-        if( (Hden == Gden) & (HT == GT) )
-          sys = tf(Gnum+Hnum,Gden,GT,Gin,Gout);
-
-          return;   # return prematurely since the add is done.
+    [Gn, Gnz, Gm, Gp] = sysdimensions (Gsys);
+    [Hn, Hnz, Hm, Hp] = sysdimensions (Hsys);
+    if (Gm == 1 & Gp == 1 & Hm == 1 & Hp == 1 & Gn == Hn & Gnz == Hnz)
+      ## dimensions are compatible, check if can add
+      [Gnum, Gden, GT, Gin, Gout] = sys2tf (Gsys);
+      [Hnum, Hden, HT, Hin, Hout] = sys2tf (Hsys);
+      if (length (Hden) == length (Gden) )
+        if ((Hden == Gden) & (HT == GT))
+          sys = tf (Gnum+Hnum, Gden, GT, Gin, Gout);
+          return;
         endif
       endif
     endif
 
     ## make sure in ss form
-    Gsys = sysupdate(Gsys,"ss");
-    Hsys = sysupdate(Hsys,"ss");
-    Gin = sysgetsignals(Gsys,"in");
-    Gout = sysgetsignals(Gsys,"out");
-    Hin = sysgetsignals(Hsys,"in");
-    Hout = sysgetsignals(Hsys,"out");
+    Gsys = sysupdate (Gsys, "ss");
+    Hsys = sysupdate (Hsys, "ss");
+    Gin = sysgetsignals (Gsys, "in");
+    Gout = sysgetsignals (Gsys, "out");
+    Hin = sysgetsignals (Hsys, "in");
+    Hout = sysgetsignals (Hsys, "out");
 
     ## change signal names to avoid warning messages from sysgroup
-    Gsys = syssetsignals(Gsys,"in",__sysdefioname__(length(Gin),"Gin_u"));
-    Gsys = syssetsignals(Gsys,"out",__sysdefioname__(length(Gout),"Gout_u"));
-    Hsys = syssetsignals(Hsys,"in",__sysdefioname__(length(Hin),"Hin_u"));
-    Hsys = syssetsignals(Hsys,"out",__sysdefioname__(length(Hout),"Hout_u"));
+    Gsys = syssetsignals (Gsys, "in",
+			  __sysdefioname__ (length (Gin), "Gin_u"));
+
+    Gsys = syssetsignals (Gsys, "out",
+			  __sysdefioname__ (length (Gout), "Gout_u"));
+
+    Hsys = syssetsignals (Hsys, "in",
+			  __sysdefioname__ (length (Hin), "Hin_u"));
 
-    sys = sysgroup(Gsys,Hsys);
+    Hsys = syssetsignals (Hsys, "out",
+			  __sysdefioname__ (length (Hout), "Hout_u"));
+
+    sys = sysgroup (Gsys, Hsys);
 
-    eyin = eye(mg);
-    eyout = eye(pg);
+    eyin = eye (mg);
+    eyout = eye (pg);
 
-    sys = sysscale(sys,[eyout, eyout],[eyin;eyin],Gout,Gin);
+    sys = sysscale (sys, [eyout, eyout], [eyin; eyin], Gout, Gin);
 
   else
     ## multiple systems (or a single system); combine together one by one
     sys = arglist{1};
-    for kk=2:length(arglist)
-      sys = sysadd(sys,arglist{kk});
+    for kk = 2:length(arglist)
+      sys = sysadd (sys, arglist{kk});
     endfor
   endif
 
 endfunction
 
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -78,116 +78,133 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = sysappend (sys, b, c, d, outname, inname, yd)
 
   ## check input arguments
-  if ( (nargin < 2) | (nargin > 7) | (!isstruct(sys)))
+  if (nargin < 2 || nargin > 7)
     print_usage ();
-  elseif(!isstruct(sys))
-    error("sys must be a system data structure");
+  elseif (! isstruct (sys))
+    error ("sys must be a system data structure");
   endif
 
   ## default system type must be state space form
-  [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
-  [Ann,Anz,Am,Ap] = sysdimensions(sys);
+  [Aa, Ab, Ac, Ad, Ats, Ann, Anz, Ast, Ain, Aout, Ayd] = sys2ss(sys);
+  [Ann, Anz, Am, Ap] = sysdimensions(sys);
 
   ## default c
-  if(nargin < 3)      c = [];                                endif
+  if (nargin < 3)
+    c = [];
+  endif
 
   ## default d
-  if(nargin < 4)     make_d = 1;
-  elseif(isempty(d)) make_d = 1;
-  else               make_d = 0;                             endif
-  if(make_d)         d = zeros(rows(c)+Ap,columns(b) + Am);  endif
+  if (nargin < 4)
+    make_d = 1;
+  elseif (isempty(d))
+    make_d = 1;
+  else
+    make_d = 0;
+  endif
+
+  if (make_d)
+    d = zeros (rows(c)+Ap, columns(b) + Am);
+  endif
 
   ## Append new input(s) if any
-  Bm = max(columns(d),columns(b)+Am);
-  if(Bm != Am)
+  Bm = max (columns(d), columns(b)+Am);
+  if (Bm != Am)
     ## construct new signal names
-    if(nargin >= 6)   # new names were passed
-	if(!ischar(inname))
-	  error("inname must be a string");
-	elseif(rows(inname) != (Bm - Am))
-	  error(sprintf("%d new inputs requested; inname(%dx%d)", ...
-	    (Bm-Am),rows(inname),columns(inname)));
+    if (nargin >= 6)   # new names were passed
+	if (! ischar (inname))
+	  error ("inname must be a string");
+	elseif (rows (inname) != Bm - Am)
+	  error ("%d new inputs requested; inname(%dx%d)",
+		 Bm-Am, rows (inname), columns (inname));
 	endif
     else
-	inname = __sysdefioname__(Bm,"u",(Am+1));
+	inname = __sysdefioname__ (Bm, "u", Am+1);
     endif
 
-    if(Am)
-      Ain = __sysconcat__(Ain,inname);
+    if (Am)
+      Ain = __sysconcat__(Ain, inname);
     else
       Ain = inname;
     endif
 
     ## default b matrix
-    if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));
-    elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
-	  error(sprintf("b(%dx%d); should be (%dx%d)", rows(b), columns(b), ...
-	    (Ann+Anz), (Bm-Am)));
+    if (isempty (b))
+      b = zeros (Ann+Anz, (Bm-Am));
+    elseif (rows (b) != Ann+Anz || columns (b) != Bm-Am)
+      error ("b(%dx%d); should be (%dx%d)", rows(b), columns(b),
+	     Ann+Anz, Bm-Am);
     endif
 
     ## append new b matrix
-    Ab = [Ab,b];
+    Ab = [Ab, b];
   endif
 
   ## Append new output(s) if any
-  Bp = max(rows(d),rows(c)+Ap);
-  if(Bp != Ap)
+  Bp = max (rows(d), rows(c)+Ap);
+  if (Bp != Ap)
 
     ## construct new signal names, output classification
-    if(nargin >= 5)  # new names were passed
-	if(!ischar(outname))
-	  error("outname must be a string");
-	elseif(rows(outname) != (Bp - Ap))
-	  error(sprintf("%d new outputs requested; outname(%dx%d)", ...
-	    (Bp-Ap),rows(outname),columns(outname)));
-	endif
+    if (nargin >= 5)  # new names were passed
+      if (! ischar (outname))
+	error ("outname must be a string");
+      elseif (rows (outname) != Bp-Ap)
+	error ("%d new outputs requested; outname(%dx%d)",
+	       Bp-Ap, rows (outname), columns (outname));
+      endif
     else
-	outname = __sysdefioname__(Bp,"y",(Ap+1));
+	outname = __sysdefioname__ (Bp, "y", (Ap+1));
     endif
-    if(Ap)   Aout = __sysconcat__(Aout,outname);
-    else     Aout = outname;                endif
+    if (Ap)
+      Aout = __sysconcat__ (Aout, outname);
+    else
+      Aout = outname;
+    endif
 
     ## construct new yd entries
-    if(nargin == 7)
-	if(!isvector(yd))
-	  error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
-	elseif(rows(c) != length(yd) & rows(d) != length(yd))
-	  error(sprintf("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch", ...
-	    length(yd), rows(c), columns(c),rows(d),columns(d)));
-	endif
+    if (nargin == 7)
+      if (! isvector (yd))
+	error ("yd(%dx%d) must be a vector", rows (yd), columns (yd));
+      elseif (rows (c) != length (yd) && rows (d) != length (yd))
+	error ("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch",
+	       length (yd), rows (c), columns (c), rows (d), columns (d)));
+      endif
     else
-	## default yd values
-	yd = ones(1,Bp)*( (Ats > 0) & (Ann == 0)  & isempty(find(Ayd == 0)) ) ;
+      ## default yd values
+      yd = ones (1, Bp) * ((Ats > 0) & (Ann == 0) & isempty (find (Ayd == 0)));
     endif
-    Ayd = [vec(Ayd);vec(yd)];
+    Ayd = [vec(Ayd); vec(yd)];
 
     ## default c matrix
-    if(isempty(c))      c = zeros((Bp-Ap),Ann+Anz);
-    elseif(columns(c) != Ann+Anz | rows(c) != (Bp-Ap))
-	  error(sprintf("c(%dx%d); should be (%dx%d)", rows(c), columns(c), ...
-	    (Bp-Ap), (Ann+Anz) ));
+    if (isempty (c))
+      c = zeros (Bp-Ap, Ann+Anz);
+    elseif (columns (c) != Ann+Anz || rows (c) != Bp-Ap)
+      error ("c(%dx%d); should be (%dx%d)", rows (c), columns (c),
+	     Bp-Ap, Ann+Anz); 
     endif
 
     ## append new c matrix
-    Ac = [Ac;c];
+    Ac = [Ac; c];
   endif
 
   ## check d matrix
-  if(isempty(d)) d = zeros(Bp,Bm);
-  elseif(rows(d) != Bp | columns(d) != Bm)
-    error(sprintf("d(%dx%d) should be (%dx%d)",rows(d), columns(d), Bp, Bp));
+  if (isempty (d))
+    d = zeros (Bp, Bm);
+  elseif (rows (d) != Bp || columns (d) != Bm)
+    error ("d(%dx%d) should be (%dx%d)", rows (d), columns (d), Bp, Bp);
   endif
 
   ## Splice in original D matrix
-  if(Am & Ap)          d(1:Ap, 1:Am) = Ad;       endif
+  if (Am & Ap)
+    d(1:Ap, 1:Am) = Ad;
+  endif
   Ad = d;
 
   ## construct return system
-  retsys = ss(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
+  retsys = ss (Aa, Ab, Ac, Ad, Ats, Ann, Anz, Ast, Ain, Aout, find (Ayd == 1));
 
 endfunction
diff --git a/scripts/control/system/sysconnect.m b/scripts/control/system/sysconnect.m
--- a/scripts/control/system/sysconnect.m
+++ b/scripts/control/system/sysconnect.m
@@ -70,221 +70,218 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 
 function sys = sysconnect (sys, output_list, input_list, order, tol)
 
-  if( (nargin < 3) | (nargin > 5) )
+  if (nargin < 3 || nargin > 5)
     print_usage ();
   endif
 
   ## check order
-  if(nargin <= 3)
+  if (nargin < 4)
     order = 0;
-  elseif( (order != 0) & (order != 1) )
-    error("sysconnect: order must be either 0 or 1")
+  elseif (order != 0 && order != 1)
+    error ("sysconnect: order must be either 0 or 1")
   endif
 
-  if (nargin <= 4)
+  if (nargin < 5)
     tol = 200*eps;
-  elseif( !is_sample(tol) )
-    error("sysconnect: tol must be a positive scalar");
-  elseif(tol > 1e2*sqrt(eps))
-    warning(["sysconnect: tol set to large value=",num2str(tol), ...
-        ", eps=",num2str(eps)])
+  elseif (! is_sample (tol))
+    error ("sysconnect: tol must be a positive scalar");
+  elseif (tol > 1e2*sqrt(eps))
+    warning ("sysconnect: tol set to large value=%g, eps=%g", tol, eps);
   endif
 
   ## convert signal names to indices
-  if(is_signal_list(input_list) | ischar(input_list))
-    input_list = sysidx(sys,"in",input_list);
+  if (is_signal_list (input_list) || ischar (input_list))
+    input_list = sysidx (sys, "in", input_list);
   endif
-  if(is_signal_list(output_list) | ischar(output_list))
-    output_list = sysidx(sys,"out",output_list);
+  if (is_signal_list (output_list) || ischar (output_list))
+    output_list = sysidx (sys, "out", output_list);
   endif
 
   ## verify sizes,format of input, output lists
-  if( min(size(output_list))*min(size(input_list)) != 1)
-    error("output_list and input_list must be vectors");
+  if (min (size (output_list)) * min (size (input_list)) != 1)
+    error ("output_list and input_list must be vectors");
   else
-    lo = length(output_list);
-    li = length(input_list);
-    if(lo != li)
-      error("output_list and input_list must be of the same length")
+    lo = length (output_list);
+    li = length (input_list);
+    if (lo != li)
+      error ("output_list and input_list must be of the same length")
     endif
 
-    if(is_duplicate_entry(output_list) | is_duplicate_entry(input_list) )
-      error("duplicate entry in input_list and/or output_list");
+    if (is_duplicate_entry (output_list) || is_duplicate_entry (input_list))
+      error ("duplicate entry in input_list and/or output_list");
     endif
   endif
 
-  [nc,nz,mm,pp] = sysdimensions(sys);
+  [nc, nz, mm, pp] = sysdimensions (sys);
   nn = nc+nz;
 
-  if( !isstruct(sys))
-    error("sys must be in structured system form")
-  elseif(pp < li)
-    error(["length(output_list)=",num2str(li),", sys has only ", ...
-        num2str(pp),"system outputs"])
-  elseif(mm < li)
-    error(["length(input_list)=",num2str(li),", sys has only ", ...
-        num2str(mm),"system inputs"])
+  if (! isstruct (sys))
+    error ("sys must be in structured system form")
+  elseif (pp < lo)
+    error ("length(output_list)=%d, sys has only %d system outputs", lo, pp);
+  elseif (mm < li)
+    error ("length(input_list)=%d, sys has only %d system inputs", li, mm);
   endif
 
   ## check that there are enough inputs/outputs in the system for the lists
-  if(max(input_list) > mm)
-    error("max(input_list) exceeds the number of inputs");
-  elseif(max(output_list) > pp)
-    error("max(output_list) exceeds the number of outputs");
+  if (max (input_list) > mm)
+    error ("max(input_list) exceeds the number of inputs");
+  elseif (max (output_list) > pp)
+    error ("max(output_list) exceeds the number of outputs");
   endif
 
-  output_list = reshape(output_list,1,length(output_list));
+  output_list = reshape (output_list, 1, length (output_list));
 
   ## make sure we're in state space form
   sys = sysupdate (sys, "ss");
 
   ## permute rows and columns of B,C,D matrices into pseudo-dgkf form...
-  all_inputs = sysreorder(mm,input_list);
-  all_outputs = sysreorder(pp,output_list);
+  all_inputs = sysreorder (mm, input_list);
+  all_outputs = sysreorder (pp, output_list);
 
-  [aa,bb,cc,dd] = sys2ss(sys);
+  [aa, bb, cc, dd] = sys2ss (sys);
   bb = bb(:,all_inputs);
   cc = cc(all_outputs,:);
   dd = dd(all_outputs,all_inputs);
 
-  yd = sysgetsignals(sys,"yd");
+  yd = sysgetsignals (sys, "yd");
   yd = yd(all_outputs);
 
   ## m1, p1 = number of inputs, outputs that are not being connected
   m1 = mm-li;
   p1 = pp-li;
 
   ## m2, p2: 1st column, row of B, C that is being connected
   m2 = m1+1;
   p2 = p1+1;
 
   ## partition system into a DGKF-like form; the loop is closed around
   ## B2, C2
-  if(m1 > 0)
+  if (m1 > 0)
     B1 = bb(:,1:m1);
     D21= dd(p2:pp,1:m1);
   endif
   B2 = bb(:,m2:mm);
-  if(p1 > 0)
+  if (p1 > 0)
     C1 = cc(1:p1,:);
     D12= dd(1:p1,m2:mm);
   endif
   C2 = cc(p2:pp,:);
-  if(m1*p1 > 0)
-    D11= dd(1:p1,1:m1);
+  if (m1*p1 > 0)
+    D11 = dd(1:p1,1:m1);
   endif
-  D22= dd(p2:pp,m2:mm);
+  D22 = dd(p2:pp,m2:mm);
 
-  if(norm(D22))
-    warning("sysconnect: possible algebraic loop, D22 non-zero");
-    D22i = (eye(size(D22))-D22);
+  if (norm (D22))
+    warning ("sysconnect: possible algebraic loop, D22 non-zero");
+    D22i = eye (size (D22)) - D22;
     C2h = D22i\C2;
-    if(m1 > 0)
+    if (m1 > 0)
       D21h = D22i\D21;
     endif
     D22h = D22i\D22;
   else
     C2h = C2;
-    if(m1 > 0)
+    if (m1 > 0)
       D21h = D21;
     endif
     D22h = D22;
 
   endif
 
   ## check cont state -> disc output -> cont state
-  dyi = find(yd(p2:pp));
+  dyi = find (yd(p2:pp));
 
   ## disp("sysconnect: dyi=")
   ## dyi
   ## nc
   ## disp("/sysconnect");
 
-  if( (nc > 0) & find(dyi > 0) )
+  if ((nc > 0 & find (dyi > 0))
     B2con = B2(1:nc,dyi);       # connection to cont states
     C2hd = C2h(dyi,1:nc);       # cont states -> outputs
   else
     B2con = C2hd = [];
   endif
 
-  if(max(size(B2con)) & max(size(C2hd)) )
-    if(norm(B2con*C2hd))
-      warning("sysconnect: cont-state -> disc output -> cont state derivative");
-      warning("    connection made; resulting system may not be meaningful");
+  if (max (size (B2con)) & max (size (C2hd)))
+    if (norm (B2con*C2hd))
+      warning ("sysconnect: cont-state -> disc output -> cont state derivative");
+      warning ("connection made; resulting system may not be meaningful");
     endif
   endif
 
   Ac = aa+B2*C2h;
-  if(m1 > 0)
+  if (m1 > 0)
     B1c = B1 + B2*D21h;
   endif
   B2c = B2*(eye(size(D22h)) + D22h);
-  if(p1*m1 > 0)
+  if (p1*m1 > 0)
     D11c = D11 + D12*D21h;
   endif
-  if(p1 > 0)
+  if (p1 > 0)
     C1c  = C1+D12*C2h;
     D12c = D12*(eye(size(D22h))+D22h);
   endif
 
   ## construct system data structure
-  if(m1 > 0)
+  if (m1 > 0)
    Bc = [B1c, B2c];
   else
    Bc = B2c;
   endif
 
-  if(p1 > 0)
+  if (p1 > 0)
     Cc = [C1c;C2h];
   else
     Cc = C2h;
   endif
 
-  if(m1*p1 > 0)
+  if (m1*p1 > 0)
     Dc = [D11c,D12c; D21h,D22h];
-  elseif(m1 > 0)
+  elseif (m1 > 0)
     Dc = [D21h, D22h];
-  elseif(p1 > 0)
+  elseif (p1 > 0)
     Dc = [D12c; D22h];
   else
     Dc = D22h;
   endif
 
   ## permute rows and columns of Bc, Cc, Dc back into original order
-  Im = eye(mm,mm);
+  Im = eye (mm, mm);
   Pi = Im(:,all_inputs);
   back_inputs = Pi*[1:mm]';
 
-  Ip = eye(pp,pp);
+  Ip = eye (pp, pp);
   Po = Ip(:,all_outputs);
   back_outputs = Po*[1:pp]';
 
   Bc = Bc(:,back_inputs);
   Cc = Cc(back_outputs,:);
   Dc = Dc(back_outputs,back_inputs);
   yd = yd(back_outputs);
 
   ## rebuild system
-  Ts = sysgettsam(sys);
-  [stnam,innam,outnam] = sysgetsignals(sys);
-  sys = ss(Ac,Bc,Cc,Dc,Ts,nc,nz,stnam,innam,outnam,find(yd));
+  Ts = sysgettsam (sys);
+  [stnam, innam, outnam] = sysgetsignals (sys);
+  sys = ss (Ac, Bc, Cc, Dc, Ts, nc, nz, stnam, innam, outnam, find (yd));
 
   ## update connected input names
   for ii = 1:length(input_list)
     idx = input_list(ii);
-    tmpval = sysgetsignals(sys,"in",idx);
-    strval = sprintf("%s*",tmpval{1} );
-    sys = syssetsignals(sys,"in",strval,idx);
+    tmpval = sysgetsignals (sys, "in", idx);
+    strval = sprintf ("%s*", tmpval{1} );
+    sys = syssetsignals (sys, "in", strval, idx);
   endfor
 
   ## maintain original system type if it was SISO
   if (strcmp (sysgettype (sys), "tf"))
     sysupdate (sys, "tf");
   elseif (strcmp (sysgettype (sys),"zp"))
     sysupdate (sys, "zp");
   endif
diff --git a/scripts/control/system/sysdup.m b/scripts/control/system/sysdup.m
--- a/scripts/control/system/sysdup.m
+++ b/scripts/control/system/sysdup.m
@@ -56,77 +56,77 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 
 function retsys = sysdup (Asys, output_list, input_list)
 
-  if( nargin != 3)
+  if (nargin != 3)
     print_usage ();
   endif
 
-  if( !isstruct(Asys))
-    error("Asys must be a system data structure (see ss, tf, or zp)")
+  if (! isstruct (Asys))
+    error ("Asys must be a system data structure (see ss, tf, or zp)")
   endif
 
-  Asys = sysupdate(Asys,"ss");
-  [nn,nz,mm,pp] = sysdimensions(Asys);
-  [aa,bb,cc,dd] = sys2ss(Asys);
+  Asys = sysupdate (Asys, "ss");
+  [nn, nz, mm, pp] = sysdimensions (Asys);
+  [aa, bb, cc, dd] = sys2ss (Asys);
 
   ## check for signal names
-  if(is_signal_list(input_list) | ischar(input_list))
-    input_list = sysidx(Asys,"in",input_list);
+  if (is_signal_list (input_list) || ischar (input_list))
+    input_list = sysidx (Asys, "in", input_list);
   endif
-  if(is_signal_list(output_list) | ischar(output_list))
-    output_list = sysidx(Asys,"out",output_list);
+  if (is_signal_list (output_list) || ischar (output_list))
+    output_list = sysidx (Asys, "out", output_list);
   endif
 
   ## first duplicate inputs
-  if(isvector(input_list))
-    for ii=1:length(input_list);
+  if (isvector (input_list))
+    for ii = 1:length(input_list);
       bb(:,mm+ii) = bb(:,input_list(ii));
       dd(:,mm+ii) = dd(:,input_list(ii));
-    end
-  elseif(!isempty(input_list))
-    error("input_list must be a vector or empty");
+    endfor
+  elseif (! isempty (input_list))
+    error ("input_list must be a vector or empty");
   endif
 
 
   ## now duplicate outputs
-  osize = min(size(output_list));
-  if(osize == 1)
-    for ii=1:length(output_list);
+  osize = min (size (output_list));
+  if (osize == 1)
+    for ii = 1:length(output_list);
       cc(pp+ii,:) = cc(output_list(ii),:);
       dd(pp+ii,:) = dd(output_list(ii),:);
-    end
-  elseif(osize != 0)
-    error("output_list must be a vector or empty");
+    endfor
+  elseif (osize != 0)
+    error ("output_list must be a vector or empty");
   endif
 
-  [stnam,innam,outnam,yd] = sysgetsignals(Asys);
-  tsam = sysgettsam(Asys);
+  [stnam, innam, outnam, yd] = sysgetsignals (Asys);
+  tsam = sysgettsam (Asys);
 
   ## pack system and then rename signals
-  retsys = ss(aa,bb,cc,dd,tsam,nn,nz);
-  retsys = syssetsignals(retsys,"in",innam,1:mm);
-  retsys = syssetsignals(retsys,"out",outnam,1:pp);
-  retsys = syssetsignals(retsys,"yd",yd,1:pp);
+  retsys = ss (aa, bb, cc, dd, tsam, nn, nz);
+  retsys = syssetsignals (retsys, "in", innam, 1:mm);
+  retsys = syssetsignals (retsys, "out", outnam, 1:pp);
+  retsys = syssetsignals (retsys, "yd", yd, 1:pp);
 
   ## update added input names
-  for ii=(mm+1):(mm+length(input_list))
+  for ii = (mm+1):(mm+length(input_list))
     onum = input_list(ii-mm);
-    strval = sprintf("%s(dup)",sysgetsignals(retsys,"in",onum,1) );
-    retsys = syssetsignals(retsys,"in",strval,ii);
+    strval = sprintf ("%s(dup)", sysgetsignals (retsys, "in", onum, 1));
+    retsys = syssetsignals (retsys, "in", strval, ii);
   endfor
 
   ## update added output names/discrete flags
   ## give default names to the added outputs
-  for jj=(pp+1):(pp+length(output_list))
+  for jj = (pp+1):(pp+length(output_list))
     onum = output_list(jj-pp);
-    strval = sprintf("%s(dup)",sysgetsignals(retsys,"out",onum,1) );
-    retsys = syssetsignals(retsys,"out",strval,jj);
-    dflg = sysgetsignals(retsys,"yd",onum);
-    retsys = syssetsignals(retsys,"yd",dflg,jj);
+    strval = sprintf ("%s(dup)", sysgetsignals (retsys, "out", onum, 1));
+    retsys = syssetsignals (retsys, "out", strval, jj);
+    dflg = sysgetsignals (retsys, "yd", onum);
+    retsys = syssetsignals (retsys, "yd", dflg, jj);
   endfor
 
 endfunction
diff --git a/scripts/control/system/sysgetsignals.m b/scripts/control/system/sysgetsignals.m
--- a/scripts/control/system/sysgetsignals.m
+++ b/scripts/control/system/sysgetsignals.m
@@ -143,58 +143,63 @@
 ## @end deftypefn
 
 function [stname, inname, outname, yd] = sysgetsignals (sys, sigid, signum, strflg)
 
   ## Adapted from ss
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
-  elseif( ! isstruct(sys) )
-    error("input argument must be a system data structure");
+  elseif (! isstruct (sys))
+    error ("input argument must be a system data structure");
+  endif
+  if (nargin < 4)
+    strflg = 0;
   endif
-  if(nargin < 4)  strflg = 0; endif
-  if(nargin == 1)
-    sys = sysupdate(sys,"ss");          #make sure ss is up to date
-    stname = sysgetsignals(sys,"st");
-    inname = sysgetsignals(sys,"in");
-    outname = sysgetsignals(sys,"out");
-    yd = sysgetsignals(sys,"yd");
-  elseif(!(ischar(sigid) & min(size(sigid)) == 1))
-    error(sprintf("sigid(%dx%d) must be a string)",rows(sigid),columns(sigid)));
+
+  if (nargin == 1)
+    sys = sysupdate (sys, "ss");          #make sure ss is up to date
+    stname = sysgetsignals (sys, "st");
+    inname = sysgetsignals (sys, "in");
+    outname = sysgetsignals (sys, "out");
+    yd = sysgetsignals (sys, "yd");
+  elseif (! (ischar (sigid) && min (size (sigid)) == 1))
+    error ("sigid(%dx%d) must be a string)", rows (sigid), columns (sigid));
   else
-    if(strcmp("st",sigid))         stname = sys.stname;
-    elseif(strcmp("in",sigid))     stname = sys.inname;
-    elseif(strcmp("out",sigid))    stname = sys.outname;
-    elseif(strcmp("yd",sigid))     stname = vec(sys.yd)';
+    if (strcmp ("st", sigid))
+      stname = sys.stname;
+    elseif (strcmp ("in", sigid))
+      stname = sys.inname;
+    elseif (strcmp ("out", sigid))
+      stname = sys.outname;
+    elseif (strcmp ("yd", sigid))
+      stname = vec(sys.yd)';
     else
-      error(sprintf("sigid=%s must be \"st\", \"in\", \"out\", or \"yd\"", ...
-        sigid));
+      error ("sigid=%s must be \"st\", \"in\", \"out\", or \"yd\"", sigid);
     endif
-    if(nargin >= 3)
-      if( is_signal_list(signum) | ischar(signum) )
-        signum = cellidx(stname,signum);
-      end
-      if(max(signum) > length(stname))
-        error(sprintf("sysgetsignals(sys,\"%s\",%d):only %d entries.\n", ...
-          sigid,signum, rows(stname)));
+    if (nargin >= 3)
+      if (is_signal_list (signum) || ischar (signum))
+        signum = cellidx (stname, signum);
+      endif
+      if (max (signum) > length (stname))
+        error ("sysgetsignals(sys,\"%s\",%d):only %d entries",
+               sigid, signum, rows (stname));
       else
-        if(!isscalar(strflg))
-          error("strflg must be a scalar");
+        if (! isscalar (strflg))
+          error ("strflg must be a scalar");
         endif
-        switch(strflg)
-        case(0),
-          stname = stname(signum);
-        case(1),
-          if(length(signum) > 1)
-            error("strflg=1, length(signum) = %d",length(signum));
+        switch (strflg)
+        case 0
+          stname = stname (signum);
+        case 1
+          if (length (signum) > 1)
+            error ("strflg=1, length(signum) = %d", length (signum));
           endif
           stname = stname{signum};
-        otherwise,
+        otherwise
           error ("invalid value of strflg = %e", strflg);
         endswitch
-
       endif
     endif
   endif
 
 endfunction
 
diff --git a/scripts/control/system/sysgroup.m b/scripts/control/system/sysgroup.m
--- a/scripts/control/system/sysgroup.m
+++ b/scripts/control/system/sysgroup.m
@@ -54,142 +54,142 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 ## A. S. Hodel: modified for variable number of arguments 1999
 
 function sys = sysgroup (varargin)
 
-  if(nargin < 1)
+  if (nargin < 1)
     print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
-  for kk=1:nargin
+  for kk = 1:nargin
     arglist(kk) = varargin{kk};
-    if(!isstruct(arglist{kk}))
-	error("sysgroup: argument %d is not a data structure",kk);
+    if (! isstruct (arglist{kk}))
+      error ("sysgroup: argument %d is not a data structure", kk);
     endif
   endfor
 
-  if(nargin == 2)
+  if (nargin == 2)
     ## the usual case; group the two systems together
     Asys = arglist{1};
     Bsys = arglist{2};
 
     ## extract information from Asys, Bsys to consruct sys
-    Asys = sysupdate(Asys,"ss");
-    Bsys = sysupdate(Bsys,"ss");
-    [n1,nz1,m1,p1] = sysdimensions(Asys);
-    [n2,nz2,m2,p2] = sysdimensions(Bsys);
-    [Aa,Ab,Ac,Ad,Atsam,An,Anz,Ast,Ain,Aout,Ayd] = sys2ss(Asys);
-    [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bst,Bin,Bout,Byd] = sys2ss(Bsys);
+    Asys = sysupdate (Asys, "ss");
+    Bsys = sysupdate (Bsys, "ss");
+    [n1, nz1, m1, p1] = sysdimensions (Asys);
+    [n2, nz2, m2, p2] = sysdimensions (Bsys);
+    [Aa, Ab, Ac, Ad, Atsam, An, Anz, Ast, Ain, Aout, Ayd] = sys2ss (Asys);
+    [Ba, Bb, Bc, Bd, Btsam, Bn, Bnz, Bst, Bin, Bout, Byd] = sys2ss (Bsys);
     nA = An + Anz;
     nB = Bn + Bnz;
 
-    if(p1*m1*p2*m2 == 0)
-	error("sysgroup: argument lacks inputs and/or outputs");
+    if (p1*m1*p2*m2 == 0)
+      error ("sysgroup: argument lacks inputs and/or outputs");
 
-    elseif((Atsam + Btsam > 0) & (Atsam * Btsam == 0) )
-	warning("sysgroup: creating combination of continuous and discrete systems")
+    elseif (Atsam + Btsam > 0 && Atsam * Btsam == 0)
+      warning ("sysgroup: creating combination of continuous and discrete systems")
 
-    elseif(Atsam != Btsam)
-	error("sysgroup: Asys.tsam=%e, Bsys.tsam =%e", Atsam, Btsam);
+    elseif (Atsam != Btsam)
+      error ("sysgroup: Asys.tsam=%e, Bsys.tsam =%e", Atsam, Btsam);
     endif
 
-    if(nA*nB > 0)
-      A12 = zeros(nA,nB);
+    if (nA*nB > 0)
+      A12 = zeros (nA, nB);
     else
       A12 = [];
     endif
-    A = [Aa,A12; A12', Ba];
+    A = [Aa, A12; A12', Ba];
 
-    if(nA*m2 > 0)
-      B12 = zeros(nA,m2);
+    if (nA*m2 > 0)
+      B12 = zeros (nA, m2);
     else
       B12 = [];
     endif
-    if(nB*m1 > 0)
-      B21 = zeros(nB,m1);
+    if (nB*m1 > 0)
+      B21 = zeros (nB, m1);
     else
       B21 = [];
     endif
-    if(isempty(Ab))
+    if (isempty(Ab))
       Ab = [];
     endif
-    if(isempty(Bb))
+    if (isempty (Bb))
       Bb = [];
     endif
     B = [Ab, B12; B21, Bb];
 
-    if(p1*nB > 0)
-      C12 = zeros(p1,nB);
+    if (p1*nB > 0)
+      C12 = zeros (p1, nB);
     else
       C12 = [];
     endif
-    if(p2*nA > 0)
-      C21 = zeros(p2,nA);
+    if (p2*nA > 0)
+      C21 = zeros (p2, nA);
     else
       C21 = [];
     endif
-    C = [Ac, C12; C21,Bc];
+    C = [Ac, C12; C21, Bc];
 
-    if(p1*m2 > 0)
-      D12 = zeros(p1,m2);
+    if (p1*m2 > 0)
+      D12 = zeros (p1, m2);
     else
       D12 = [];
     endif
-    if(p2*m1 > 0)
-      D21 = zeros(p2,m1);
+    if (p2*m1 > 0)
+      D21 = zeros (p2, m1);
     else
       D21 = [];
     endif
     D = [Ad, D12; D21, Bd];
-    tsam = max(Atsam,Btsam);
+    tsam = max (Atsam, Btsam);
 
     ## construct combined signal names; stnames must check for pure gain blocks
-    if(isempty(Ast))
-	stname = Bst;
-    elseif(isempty(Bst))
-	stname = Ast;
+    if (isempty (Ast))
+      stname = Bst;
+    elseif (isempty (Bst))
+      stname = Ast;
     else
-      stname= __sysconcat__(Ast,Bst);
+      stname= __sysconcat__ (Ast, Bst);
     endif
-    inname = __sysconcat__(Ain,Bin);
-    outname = __sysconcat__(Aout,Bout);
+    inname = __sysconcat__ (Ain, Bin);
+    outname = __sysconcat__ (Aout, Bout);
 
     ## Sort states into continuous first, then discrete
-    dstates = ones(1,(nA+nB));
-    if(An)
-	dstates(1:(An)) = zeros(1,An);
+    dstates = ones (1, (nA+nB));
+    if (An)
+      dstates(1:(An)) = zeros (1, An);
     endif
-    if(Bn)
-	dstates((nA+1):(nA+Bn)) = zeros(1,Bn);
+    if (Bn)
+      dstates((nA+1):(nA+Bn)) = zeros (1, Bn);
     endif
-    [tmp,pv] = sort(dstates);
+    [tmp, pv] = sort (dstates);
     A = A(pv,pv);
     B = B(pv,:);
     C = C(:,pv);
-    stname = stname(pv);
+    stname = stname (pv);
 
     ## check for duplicate signal names
     inname = __sysgroupn__ (inname, "input");
     stname = __sysgroupn__ (stname, "state");
     outname = __sysgroupn__ (outname, "output");
 
     ## mark discrete outputs
-    outlist = find([Ayd, Byd]);
+    outlist = find ([Ayd, Byd]);
 
     ## build new system
-    sys = ss(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
+    sys = ss (A, B, C, D, tsam, An+Bn, Anz+Bnz, stname, inname, outname);
 
   else
     ## multiple systems (or a single system); combine together one by one
     sys = arglist{1};
-    for kk=2:length(arglist)
-	printf("sysgroup: kk=%d\n",kk);
-	sys = sysgroup(sys,arglist{kk});
+    for kk = 2:length(arglist)
+      printf ("sysgroup: kk=%d\n", kk);
+      sys = sysgroup (sys, arglist{kk});
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/system/sysmin.m b/scripts/control/system/sysmin.m
--- a/scripts/control/system/sysmin.m
+++ b/scripts/control/system/sysmin.m
@@ -46,147 +46,162 @@
 ## @code{is_observable(retsys)}.
 ## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function [retsys, nc, no, cflg, oflg] = sysmin (sys, flg)
 
-  switch(nargin)
-  case(1), flg = 0;
-  case(2), jnk = flg;    # dummy operation
+  switch (nargin)
+  case 1
+    flg = 0;
+  case 2
+    jnk = flg;    # dummy operation
   otherwise,
     print_usage ();
   endswitch
-  dflg = is_digital(sys,2);
-  [n,nz,m,p] = sysdimensions(sys);
-  if(n*nz > 0)
+
+  dflg = is_digital (sys, 2);
+
+  [n, nz, m, p] = sysdimensions (sys);
+
+  if (n*nz > 0)
     # both continuous and discrete states
-    [aa,bb,cc,dd,tsam,n,nz,stnam,innam,outnam,yd] = sys2ss(sys);
+    [aa, bb, cc, dd, tsam, n, nz, stnam, innam, outnam, yd] = sys2ss (sys);
     crng = 1:n;
     drng = n+(1:nz);
 
     # get minimal realization of continuous part
     Ac  = aa(crng,crng);
     Acd = aa(crng,drng);
     Adc = aa(drng,crng);
     Ad  = aa(drng,drng);
     Bc  = bb(crng,:);
     Bd  = bb(drng,:);
     Cc  = cc(:,crng);
     Cd  = cc(:,drng);
 
     cstnam = stnam(crng);
     dstnam = stnam(drng);
-    cinnam = __sysconcat__(innam,stnam(drng));
-    coutnam = __sysconcat__(outnam,stnam(drng));
-    csys = ss(Ac,[Bc,Acd],[Cc;Adc]);
-    csys = syssetsignals(csys,"st",cstnam);
-    csys = syssetsignals(csys,"in",cinnam);
-    csys = syssetsignals(csys,"out",coutnam);
+    cinnam = __sysconcat__ (innam, stnam(drng));
+    coutnam = __sysconcat__ (outnam, stnam(drng));
+    csys = ss (Ac, [Bc, Acd], [Cc; Adc]);
+    csys = syssetsignals (csys, "st", cstnam);
+    csys = syssetsignals (csys, "in", cinnam);
+    csys = syssetsignals (csys, "out", coutnam);
 
     # reduce continuous system, recombine with discrete part
-    csys = sysmin(csys,flg);
-    cn = sysdimensions(csys);
+    csys = sysmin (csys, flg);
+    cn = sysdimensions (csys);
 
-    if(cn == 0)
+    if (cn == 0)
       # continuous states are removed; just reduce the discrete part
-      sys = sysprune(sys,1:p,1:m,drng);
-      retsys = sysmin(sys,flg);
+      sys = sysprune (sys, 1:p, 1:m, drng);
+      retsys = sysmin (sys, flg);
     else
       # extract updated parameters from reduced continuous system
-      [caa,cbb,ccc,cdd,ctsam,cn,cnz,cstnam,cinnam,coutnam] = sys2ss(csys);
+      [caa, cbb, ccc, cdd, ctsam, cn, cnz, cstnam, cinnam, coutnam] ...
+	  = sys2ss (csys);
+
       crng = 1:cn;
       Ac  = caa;
       Bc  = cbb(:,1:m);
       Acd = cbb(:,m+(1:nz));
       Cc  = ccc(1:p,:);
       Adc = ccc(p + (1:nz),:);
 
       # recombine to reduce discrete part of the system
-      dinnam = __sysconcat__(innam,cstnam);
-      doutnam = __sysconcat__(outnam,cstnam);
-      dsys = ss(Ad,[Bd,Adc],[Cd;Acd],[],tsam);
-      dsys = syssetsignals(dsys,"st",dstnam);
-      dsys = syssetsignals(dsys,"in",dinnam);
-      dsys = syssetsignals(dsys,"out",doutnam);
+      dinnam = __sysconcat__ (innam, cstnam);
+      doutnam = __sysconcat__ (outnam, cstnam);
+      dsys = ss (Ad, [Bd, Adc], [Cd; Acd], [], tsam);
+      dsys = syssetsignals (dsys, "st", dstnam);
+      dsys = syssetsignals (dsys, "in", dinnam);
+      dsys = syssetsignals (dsys, "out", doutnam);
 
       # reduce discrete subsystem
-      dsys = sysmin(dsys);
-      [n1,nz] = sysdimensions(dsys);
-      if(nz == 0)
+      dsys = sysmin (dsys);
+      [n1, nz] = sysdimensions (dsys);
+      if (nz == 0)
         # discrete subsystem is not needed
-        retsys = sysprune(csys,1:p,1:m);
+        retsys = sysprune (csys, 1:p, 1:m);
       else
         # combine discrete, continuous subsystems
-        [Ad,dbb,dcc] = sys2ss(dsys);
-        dstnam = sysgetsignals(dsys,"st");
+        [Ad, dbb, dcc] = sys2ss (dsys);
+        dstnam = sysgetsignals (dsys, "st");
         Bd  = dbb(:,1:m);
         Adc = dbb(:,m+(1:cn));
         Cd  = dcc(1:p,:);
         Acd = dcc(p+(1:cn),:);
-        stnam = __sysconcat__(cstnam,dstnam);
+        stnam = __sysconcat__ (cstnam, dstnam);
         aa = [Ac, Acd; Adc, Ad];
         bb = [Bc; Bd];
         cc = [Cc, Cd];
-        retsys = ss([Ac, Acd; Adc, Ad], [Bc ; Bd], [Cc, Cd], dd, tsam, ...
-          cn, nz, stnam, innam, outnam, find(yd == 1));
-      end
+        retsys = ss ([Ac, Acd; Adc, Ad], [Bc ; Bd], [Cc, Cd], dd, tsam,
+		     cn, nz, stnam, innam, outnam, find(yd == 1));
+      endif
     endif
   else
-    Ts = sysgettsam(sys);
-    switch(flg)
-    case(0),
+    Ts = sysgettsam (sys);
+    switch (flg)
+    case 0
       ## reduce to a minimal system
-      [aa,bb,cc,dd] = sys2ss(sys);
-      [cflg,Uc] = is_controllable(aa,bb);
-      if(!cflg)
+      [aa, bb, cc, dd] = sys2ss (sys);
+      [cflg, Uc] = is_controllable (aa, bb);
+      if (! cflg)
         ## reduce to controllable states
-        if(!isempty(Uc))
+        if (! isempty (Uc))
           aa = Uc'*aa*Uc;
           bb = Uc'*bb;
           cc = cc*Uc;
         else
           aa = bb = cc = [];
         endif
       endif
-      if(!isempty(aa))
-        [oflg,Uo] = is_observable(aa,cc);
-        if(!oflg)
-          if(!isempty(Uo))
+      if (! isempty (aa))
+        [oflg, Uo] = is_observable (aa, cc);
+        if (! oflg)
+          if (! isempty (Uo))
             aa = Uo'*aa*Uo;
             bb = Uo'*bb;
             cc = cc*Uo;
           else
             aa = bb = cc = [];
           endif
         endif
       endif
-      switch(dflg)
-      case(0),
-        nc = no = nn = columns(aa);
+      switch (dflg)
+      case 0
+        nc = no = nn = columns (aa);
         nz = 0;
-      case(1),
-        nc = no = nz = columns(aa);
+      case 1
+        nc = no = nz = columns (aa);
         nn = 0;
       endswitch
-      innam = sysgetsignals(sys,"in");
-      outnam= sysgetsignals(sys,"out");
-      retsys = ss(aa,bb,cc,dd,Ts,nn,nz,[],innam,outnam);
-    case(1),
+      innam = sysgetsignals (sys, "in");
+      outnam= sysgetsignals (sys, "out");
+      retsys = ss (aa, bb, cc, dd, Ts, nn, nz, [], innam, outnam);
+    case 1
       ## reduced model with physical states
-      [cflg,Uc] = is_controllable(sys); xc = find(max(abs(Uc')) != 0);
-      [oflg,Uo] = is_observable(sys);   xo = find(max(abs(Uo')) != 0);
-      xx = intersection(xc,xo);
-      if(isempty(xx)) xx = 0;  endif    # signal no states in reduced model
-      retsys = sysprune(sys,[],[],xx);
-    otherwise,
+      [cflg, Uc] = is_controllable (sys);
+      xc = find (max (abs (Uc')) != 0);
+      [oflg, Uo] = is_observable (sys);
+      xo = find (max (abs (Uo')) != 0);
+      xx = intersection (xc, xo);
+      ## signal no states in reduced model
+      if (isempty (xx))
+	xx = 0;
+      endif
+      retsys = sysprune (sys, [], [], xx);
+    otherwise
       error ("invalid value of flg = %d", flg);
     endswitch
-    if(sysdimensions(retsys,"st") > 0)
-      [cflg,Uc] = is_controllable(retsys); nc = columns(Uc);
-      [oflg,Uo] = is_observable(retsys);   no = columns(Uo);
+    if (sysdimensions (retsys, "st") > 0)
+      [cflg, Uc] = is_controllable (retsys);
+      nc = columns (Uc);
+      [oflg, Uo] = is_observable (retsys);
+      no = columns (Uo);
     else
       nc = no = 0;
     endif
   endif
+
 endfunction
diff --git a/scripts/control/system/sysout.m b/scripts/control/system/sysout.m
--- a/scripts/control/system/sysout.m
+++ b/scripts/control/system/sysout.m
@@ -40,113 +40,117 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: 1995-1996
 
 function retsys = sysout (sys, opt)
 
-  if( (nargin < 1) || (nargin > 2) )
+  if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  if(isempty(sys))
+  if (isempty (sys))
     retsys = sys;
-    warning("sysout: empty system")
+    error ("sysout: empty system")
     return;
   endif
 
-  if(! isstruct(sys))
-    disp("sysout: input must be a system structure")
+  if (! isstruct (sys))
+    error ("sysout: input must be a system structure")
   endif
 
   ## set up output type array
-  if( nargin == 1 )
-    opt = sysgettype(sys);
-  else
-    if( ! (strcmp(opt,"ss") + strcmp(opt,"tf") + ...
-      strcmp(opt,"zp") + strcmp(opt,"all") ) )
-      error("opt must be one of [], \"ss\", \"tf\", \"zp\", or \"all\"");
-    endif
+  if (nargin == 1)
+    opt = sysgettype (sys);
+  elseif (! (strcmp (opt, "ss") || strcmp (opt, "tf")
+	     || strcmp (opt, "zp") || strcmp (opt, "all")))
+    error ("opt must be one of [], \"ss\", \"tf\", \"zp\", or \"all\"");
   endif
 
   ## now check output for each form:
-  [nn,nz,mm,pp] = sysdimensions(sys);
-  if( mm > 0)
-    disp("Input(s)")
-    disp(__outlist__(sysgetsignals(sys,"in"),"      "));
+  [nn, nz, mm, pp] = sysdimensions(sys);
+  if (mm > 0)
+    disp ("Input(s)")
+    disp (__outlist__ (sysgetsignals (sys, "in"), "      "));
   else
-    disp("Input(s): none");
+    disp ("Input(s): none");
   endif
   if (pp > 0)
-    disp("Output(s):")
-    disp(__outlist__(sysgetsignals(sys,"out"), ...
-          "     ",sysgetsignals(sys,"yd")) );
+    disp ("Output(s):")
+    disp (__outlist__ (sysgetsignals (sys, "out"),
+		       "     ", sysgetsignals (sys, "yd")) );
   else
-    disp("Output(s): none");
+    disp ("Output(s): none");
   endif
-  if(sysgettsam(sys) > 0)
-    disp(["Sampling interval: ",num2str(sysgettsam(sys))]);
+  if (sysgettsam (sys) > 0)
+    disp ("Sampling interval: %g", sysgettsam (sys));
     str = "z";
   else
     str = "s";
   endif
 
   ## transfer function form
-  if( strcmp(opt,"tf") + strcmp(opt,"all") )
-    sys = sysupdate(sys,"tf");          #make sure tf is up to date
-    disp("transfer function form:")
-    [num,den] = sys2tf(sys);
-    tfout(num,den,str);
+  if (strcmp (opt, "tf") || strcmp (opt, "all"))
+    sys = sysupdate (sys, "tf");          #make sure tf is up to date
+    disp ("transfer function form:")
+    [num, den] = sys2tf (sys);
+    tfout (num, den, str);
   endif
 
-  if( strcmp(opt,"zp") + strcmp(opt,"all") )
-    sys = sysupdate(sys,"zp");          #make sure zp is up to date
+  if (strcmp(opt, "zp") || strcmp(opt, "all"))
+    sys = sysupdate (sys, "zp");          #make sure zp is up to date
     disp("zero-pole form:")
-    [zer,pol,kk] = sys2zp(sys);
-    zpout(zer, pol, kk,str)
+    [zer, pol, kk] = sys2zp (sys);
+    zpout (zer, pol, kk, str)
   endif
 
-  if( strcmp(opt,"ss") + strcmp(opt,"all") )
-    sys = sysupdate(sys,"ss");
-    disp("state-space form:");
-    disp([num2str(nn)," continuous states, ", num2str(nz)," discrete states"]);
-    if( nn+nz > 0)
-      disp("State(s):")
+  if (strcmp(opt, "ss") || strcmp(opt, "all"))
+    sys = sysupdate (sys, "ss");
+    disp ("state-space form:");
+    disp ("%d continuous states, %d discrete states", nn, nz);
+    if (nn+nz > 0)
+      disp ("State(s):")
       xi = (nn+1):(nn+nz);
-      xd = zeros(1,nn+nz);
-      if(!isempty(xi))
+      xd = zeros (1, nn+nz);
+      if (! isempty (xi))
         xd(xi) = 1;
       endif
-      disp(__outlist__(sysgetsignals(sys,"st"),"    ",xd));
+      disp (__outlist__ (sysgetsignals (sys, "st"), "    ", xd));
     else
-      disp("State(s): none");
+      disp ("State(s): none");
     endif
 
     ## display matrix values?
-    dmat = (max( [ (nn+nz), mm, pp ] ) <= 32);
+    dmat = (max ([nn+nz, mm, pp]) <= 32);
 
-    printf("A matrix: %d x %d\n",sysdimensions(sys,"st"),
-           sysdimensions(sys,"st"));
-    [aa,bb,cc,dd] = sys2ss(sys);
-    if(dmat)    disp(aa);       endif
+    printf ("A matrix: %d x %d\n", sysdimensions (sys, "st"),
+            sysdimensions (sys, "st"));
+    [aa, bb, cc, dd] = sys2ss (sys);
+    if (dmat)
+      disp (aa);
+    endif
 
-    printf("B matrix: %d x %d\n",sysdimensions(sys,"st"),
-           sysdimensions(sys,"in"));
-    if(dmat)     disp(bb);              endif
+    printf ("B matrix: %d x %d\n", sysdimensions (sys, "st"),
+            sysdimensions (sys, "in"));
+    if (dmat)
+      disp (bb);
+    endif
 
-    printf("C matrix: %d x %d\n",sysdimensions(sys,"out"),
-           sysdimensions(sys,"st"));
-    if(dmat) disp(cc);          endif
+    printf ("C matrix: %d x %d\n", sysdimensions (sys, "out"),
+            sysdimensions (sys, "st"));
+    if (dmat)
+      disp (cc);
+    endif
 
-    printf("D matrix: %d x %d\n",sysdimensions(sys,"out"),
-           sysdimensions(sys,"in"));
-    if(dmat)       disp(dd);         endif
+    printf("D matrix: %d x %d\n", sysdimensions (sys, "out"),
+           sysdimensions (sys, "in"));
+    if (dmat)
+      disp (dd);
+    endif
   endif
 
   if (nargout >= 1)
     retsys = sys;
   endif
 
-  ## restore global variable
-
 endfunction
diff --git a/scripts/control/system/sysprune.m b/scripts/control/system/sysprune.m
--- a/scripts/control/system/sysprune.m
+++ b/scripts/control/system/sysprune.m
@@ -55,121 +55,132 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Updated by John Ingram 7-15-96
 
 function sys = sysprune (sys, output_idx, input_idx, state_idx)
 
-  if( nargin < 3 | nargin > 4  )
+  if (nargin < 3 || nargin > 4)
     print_usage ();
-  elseif(nargin < 4)
+  elseif (nargin < 4)
     state_idx = [];
   endif
 
   ## default: no action
-  [nn,nz,mm,pp] = sysdimensions(sys);
-  if(isempty(output_idx)) output_idx = 1:pp; endif
-  if(isempty(input_idx)) input_idx = 1:mm; endif
-  if(isempty(state_idx)) state_idx = 1:(nn+nz); endif
+  [nn, nz, mm, pp] = sysdimensions (sys);
+  if (isempty (output_idx))
+    output_idx = 1:pp;
+  endif
+  if (isempty (input_idx))
+    input_idx = 1:mm;
+  endif
+  if (isempty (state_idx))
+    state_idx = 1:(nn+nz);
+  endif
 
   ## check for signal names
-  if(is_signal_list(output_idx) | ischar(output_idx))
-    output_idx = sysidx(sys,"out",output_idx);
+  if (is_signal_list (output_idx) || ischar (output_idx))
+    output_idx = sysidx (sys, "out", output_idx);
   endif
-  if(is_signal_list(input_idx) | ischar(input_idx))
-    input_idx = sysidx(sys,"in",input_idx);
+  if (is_signal_list (input_idx) || ischar (input_idx))
+    input_idx = sysidx (sys, "in", input_idx);
   endif
 
   ## check dimensions
-  if( !(isvector(output_idx) | isempty(output_idx) )  )
-    if(!ismatrix(output_idx))
-      error("sysprune: bad argument passed for output_idx");
+  if (! (isvector (output_idx) || isempty (output_idx)))
+    if (! ismatrix (output_idx))
+      error ("sysprune: bad argument passed for output_idx");
     else
-      error("sysprune: output_idx (%d x %d) must be a vector or empty", ...
-        rows(output_idx),columns(output_idx));
+      error ("sysprune: output_idx (%d x %d) must be a vector or empty",
+             rows (output_idx), columns (output_idx));
     endif
-  elseif(is_duplicate_entry(output_idx))
-     error("sysprune: duplicate entries found in output_idx");
+  elseif (is_duplicate_entry (output_idx))
+     error ("sysprune: duplicate entries found in output_idx");
   endif
 
-  if( !(isvector(input_idx) | isempty(input_idx) )  )
-    if(!ismatrix(input_idx))
-      error("sysprune: bad argument passed for input_idx");
+  if (! (isvector (input_idx) || isempty (input_idx)))
+    if (! ismatrix (input_idx))
+      error ("sysprune: bad argument passed for input_idx");
     else
-      error("sysprune: input_idx (%d x %d) must be a vector or empty", ...
-        rows(input_idx),columns(input_idx));
+      error ("sysprune: input_idx (%d x %d) must be a vector or empty",
+             rows (input_idx), columns(input_idx));
     endif
-  elseif(is_duplicate_entry(input_idx))
-     error("sysprune: duplicate entries found in input_idx");
+  elseif (is_duplicate_entry (input_idx))
+     error ("sysprune: duplicate entries found in input_idx");
   endif
 
-  if( !(isvector(state_idx) | isempty(state_idx) )  )
-    if(!ismatrix(state_idx))
-      error("sysprune: bad argument passed for state_idx");
+  if (! (isvector (state_idx) || isempty (state_idx)))
+    if (! ismatrix (state_idx))
+      error ("sysprune: bad argument passed for state_idx");
     else
-      error("sysprune: state_idx (%d x %d) must be a vector or empty", ...
-        rows(state_idx),columns(state_idx));
+      error ("sysprune: state_idx (%d x %d) must be a vector or empty",
+             rows (state_idx), columns (state_idx));
     endif
-  elseif(nn+nz > 0)
-    if(is_duplicate_entry(state_idx))
-      error("sysprune: duplicate entries found in state_idx");
+  elseif (nn+nz > 0)
+    if (is_duplicate_entry (state_idx))
+      error ("sysprune: duplicate entries found in state_idx");
     endif
   endif
 
-  lo = length(output_idx);
-  li = length(input_idx);
-  lst = length(state_idx);
+  lo = length (output_idx);
+  li = length (input_idx);
+  lst = length (state_idx);
 
-  if( !isstruct(sys))
-    error("Asys must be a system data structure (see ss, tf, or zp)")
-  elseif(pp < lo)
-    error([num2str(lo)," output_idx entries, system has only ", ...
-        num2str(pp)," outputs"]);
-  elseif(mm < li)
-    error([num2str(li)," input_idx entries, system has only ", ...
-        num2str(mm)," inputs"]);
-  elseif(nn+nz < lst)
-    error([num2str(lst)," state_idx entries, system has only ", ...
-        num2str(nn+nz)," states"]);
+  if (! isstruct (sys))
+    error ("Asys must be a system data structure (see ss, tf, or zp)");
+  elseif (pp < lo)
+    error("%d output_idx entries, system has only %d outputs", lo, pp]);
+  elseif (mm < li)
+    error("%d input_idx entries, system has only %d inputs", li, mm);
+  elseif (nn+nz < lst)
+    error("%d state_idx entries, system has only %d states", lst, nn+nz);
   endif
 
-  [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
+  [aa, bb, cc, dd, tsam, nn, nz, stnam, innam, outnam, yd] = sys2ss (sys);
 
   ## check for valid state permutation
-  if(nn & nz)
-    c_idx = find(state_idx <= nn);
-    if(!isempty(c_idx)) max_c = max(c_idx);
-    else                max_c = 0;            endif
-    d_idx = find(state_idx > nn);
-    if(!isempty(d_idx)) min_d = min(d_idx);
-    else                min_d = nn+nz;            endif
-    if(max_c > min_d)
-      warning("sysprune: state_idx(%d)=%d (discrete) preceeds", ...
-        min_d,state_idx(min_d));
-      warning("          state_idx(%d)=%d (continuous)",...
-        max_c,state_idx(max_c));
-      warning("sysprune: sys has %d continuous states, %d discrete states", ...
-        nn,nz);
-      error("continuous/discrete state partition not preserved ; see ss");
+  if (nn & nz)
+    c_idx = find (state_idx <= nn);
+    if (! isempty (c_idx))
+      max_c = max (c_idx);
+    else
+      max_c = 0;
+    endif
+    d_idx = find (state_idx > nn);
+    if (! isempty (d_idx))
+      min_d = min (d_idx);
+    else
+      min_d = nn+nz;
+    endif
+    if (max_c > min_d)
+      warning ("sysprune: state_idx(%d)=%d (discrete) preceeds",
+               min_d, state_idx(min_d));
+      warning("          state_idx(%d)=%d (continuous)",
+              max_c, state_idx(max_c));
+      warning ("sysprune: sys has %d continuous states, %d discrete states",
+               nn, nz);
+      error("continuous/discrete state partition not preserved; see ss");
     endif
   endif
 
   idx = input_idx;
   odx = output_idx;
-  if(isempty(state_idx))
+  if (isempty (state_idx))
     idx = [];
     odx = [];
   endif
   aa = aa(state_idx,state_idx);
   bb = bb(state_idx,idx);
   cc = cc(odx,state_idx);
   dd = dd(output_idx,input_idx);
   yd = yd(output_idx);
 
   innam  = innam(input_idx);
   outnam = outnam(output_idx);
   stnam = stnam(state_idx);
-  nn1 = length(find(state_idx <= nn));
-  nz1 = length(find(state_idx > nn));
-  sys = ss(aa,bb,cc,dd,tsam,nn1,nz1,stnam,innam,outnam,find(yd));
+  nn1 = length (find (state_idx <= nn));
+  nz1 = length (find (state_idx > nn));
+
+  sys = ss (aa, bb, cc, dd, tsam, nn1, nz1, stnam, innam, outnam, find (yd));
+
 endfunction
diff --git a/scripts/control/system/sysscale.m b/scripts/control/system/sysscale.m
--- a/scripts/control/system/sysscale.m
+++ b/scripts/control/system/sysscale.m
@@ -54,98 +54,103 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram 7-15-96
 
 function sys = sysscale (sys, outscale, inscale, outname, inname)
 
-  if( (nargin < 3) || (nargin > 5)  )
+  if (nargin < 3 || nargin > 5)
     print_usage ();
-  elseif (!isstruct(sys))
-    error("sys must be a structured system");
+  elseif (! isstruct (sys))
+    error ("sys must be a structured system");
   endif
 
-  [nn,nz,mm,pp] = sysdimensions(sys);
+  [nn, nz, mm, pp] = sysdimensions (sys);
 
   ## check for omitted scales
-  if(isempty(outscale))    outscale = eye(pp);     endif
-  if(isempty(inscale))     inscale = eye(mm);      endif
+  if (isempty (outscale))
+    outscale = eye (pp);
+  endif
+  if (isempty (inscale))
+    inscale = eye (mm);
+  endif
 
   ## check dimensions of scaling matrices
-  if(mm!=rows(inscale))
-    error("inscale(%dx%d) should have %d rows(# system inputs)", ...
-      rows(inscale),columns(inscale),mm);
-  elseif( pp != columns(outscale) )
-    error("outscale(%dx%d) should have %d columns(# system outputs)", ...
-      rows(outscale), columns(outscale),pp);
+  if (mm != rows (inscale))
+    error ("inscale(%dx%d) should have %d rows(# system inputs)",
+	   rows (inscale), columns (inscale), mm);
+  elseif (pp != columns (outscale) )
+    error ("outscale(%dx%d) should have %d columns(# system outputs)",
+	   rows (outscale), columns (outscale), pp);
   endif
 
-  sysyd = sysgetsignals(sys,"yd");
-  outc = find(sysyd==0);
-  outd = find(sysyd==1);
+  sysyd = sysgetsignals (sys, "yd");
+  outc = find (sysyd == 0);
+  outd = find (sysyd == 1);
 
-  if(length(outc) & length(outd))
+  if (length (outc) > 0 && length (outd) > 0)
     for ii = 1:rows(outscale)
-      nci = norm(outscale(ii,outc));
-      ndi = norm(outscale(ii,outd));
+      nci = norm (outscale (ii, outc));
+      ndi = norm (outscale (ii, outd));
 
-      if( nci & ndi)
-        warning("sysscale: outscale(%d,:) sums continuous and discrete outputs; setting output to cont",ii)
+      if (nci > 0 && ndi > 0)
+        warning ("sysscale: outscale(%d,:) sums continuous and discrete outputs; setting output to cont",
+		 ii)
         sysyd(ii) = 0;
       else
         sysyd(ii) = (ndi != 0);
       endif
     endfor
   else
-    sysyd = ones(1,rows(outscale))*( length(outd) > 0);
+    sysyd = ones (1, rows (outscale)) * (length(outd) > 0);
   endif
 
   ## check for SISO system type
-  if strcmp(sysgettype(sys),"tf")
-    [num,den,tsam,innam,outnam] = sys2tf(sys);
+  if (strcmp (sysgettype (sys), "tf"))
+    [num, den, tsam, innam, outnam] = sys2tf (sys);
     num = num*inscale*outscale;
-    sys = tf(num,den,tsam,innam,outnam);
-    return
-  elseif strcmp(sysgettype(sys),"zp")
-    [zer,pol,kk,tsam,innam,outnam] = sys2zp(sys);
+    sys = tf (num, den, tsam, innam, outnam);
+    return;
+  elseif (strcmp (sysgettype (sys), "zp"))
+    [zer, pol, kk, tsam, innam, outnam] = sys2zp (sys);
     kk = kk*inscale*outscale;
-    sys = zp(zer,pol,k,tsam,innam,outnam);
-    return
+    sys = zp (zer, pol, k, tsam, innam, outnam);
+    return;
   endif
 
   ## it's a state space system...
 
-  [sysa,sysb,sysc,sysd,systsam, ...
-    sysn,sysnz,sysstname,sysinname,sysoutname,oldyd] = sys2ss(sys);
+  [sysa, sysb, sysc, sysd, systsam, ...
+   sysn, sysnz, sysstname, sysinname, sysoutname, oldyd] = sys2ss(sys);
 
   sysb = sysb*inscale;
   sysc = outscale*sysc;
   sysd = outscale*sysd*inscale;
 
-  if( !issquare(outscale) )
+  if (! issquare (outscale))
     ## strip extra output names (if any)
-    sysoutname = sysoutname(1:min(rows(outscale),columns(outscale)));
-    if( nargin < 4)
-      warning("sysscale: outscale not square, outname not specified");
-      warning("sysscale:  using default output names");
-      outname = __sysdefioname__(rows(sysc),"y");
+    sysoutname = sysoutname(1:min(rows(outscale), columns(outscale)));
+    if (nargin < 4)
+      warning ("sysscale: outscale not square, outname not specified");
+      warning ("sysscale:  using default output names");
+      outname = __sysdefioname__ (rows (sysc), "y");
     endif
   else
     outname = sysoutname;
   endif
-  if( !issquare(inscale) )
+  if (! issquare (inscale))
     ## strip extra output names (if any)
-    sysinname = sysinname(1:min(rows(inscale),columns(inscale)));
-    if(nargin < 5)
-      warning("sysscale: inscale not square, inname not specified");
-      warning("sysscale:  using default input names");
-      inname = __sysdefioname__(columns(sysb),"u");
+    sysinname = sysinname(1:min(rows(inscale), columns(inscale)));
+    if (nargin < 5)
+      warning ("sysscale: inscale not square, inname not specified");
+      warning ("sysscale:  using default input names");
+      inname = __sysdefioname__ (columns (sysb), "u");
     endif
   else
-    inname = sysgetsignals(sys,"in");
+    inname = sysgetsignals (sys, "in");
   endif
 
-  sys = ss(sysa,sysb,sysc,sysd,systsam,nn,nz,sysstname, ...
-        inname,outname,find(sysyd==1));
+  sys = ss (sysa, sysb, sysc, sysd, systsam, nn, nz, sysstname,
+	    inname, outname, find (sysyd == 1));
 
 endfunction
diff --git a/scripts/control/system/syssetsignals.m b/scripts/control/system/syssetsignals.m
--- a/scripts/control/system/syssetsignals.m
+++ b/scripts/control/system/syssetsignals.m
@@ -91,156 +91,154 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = syssetsignals (sys, opt, names, sig_idx)
 
-  if (nargin < 3 | nargin > 4)
+  if (nargin < 3 || nargin > 4)
     print_usage ();
-  elseif (!isstruct(sys))
-    error("sys must be a system data structure");
-  elseif (isempty(opt))
+  elseif (! isstruct (sys))
+    error ("sys must be a system data structure");
+  elseif (isempty (opt))
     opt = "out";
-  elseif( ! ischar(opt)  )
-    error("opt must be a string");
-  elseif( ! (strcmp(opt,"out") + strcmp(opt,"yd") + ...
-    strcmp(opt,"in") + strcmp(opt,"st") ) )
-    error("opt must be one of [], ""out"", ""yd"", ""in"", or ""st""");
-  elseif(nargin == 4)
-    if(is_signal_list(sig_idx) | ischar(sig_idx))
+  elseif (! ischar (opt))
+    error ("opt must be a string");
+  elseif (! (strcmp (opt, "out") || strcmp (opt, "yd")
+	     || strcmp (opt, "in") || strcmp (opt, "st")))
+    error ("opt must be one of [], \"out\", \"yd\", \"in\", or \"st\"");
+  elseif (nargin == 4)
+    if (is_signal_list (sig_idx) || ischar (sig_idx))
       ## convert to vector of indices
-      if(opt == "yd")
-        sig_idx = sysidx(sys,"out",sig_idx);
+      if (opt == "yd")
+        sig_idx = sysidx (sys, "out", sig_idx);
       else
-        sig_idx = sysidx(sys,opt,sig_idx);
+        sig_idx = sysidx (sys, opt, sig_idx);
       endif
     endif
 
     ## check index vector
-    if(min(size(sig_idx)) > 1)
-      disp("syssetsignals: sig_idx=")
-      disp(sig_idx);
-      error("sig_idx must be a vector")
+    if (min (size (sig_idx)) > 1)
+      disp ("syssetsignals: sig_idx=")
+      disp (sig_idx);
+      error ("sig_idx must be a vector")
     endif
   endif
 
-  sig_vals = sysgetsignals(sys,opt);
+  sig_vals = sysgetsignals (sys, opt);
 
   ## make sure it's in state space form if state names are given
-  if(strcmp(opt,"st"))
-    sys = sysupdate(sys,"ss");
+  if (strcmp (opt, "st"))
+    sys = sysupdate (sys, "ss");
   endif
 
-  if(strcmp(opt,"yd") == 0)
+  if (strcmp (opt, "yd") == 0)
     ## it's a signal name list we're changing
-    if(!iscell(names))
+    if (! iscell (names))
       names = {names};
     endif
-    if( (!is_signal_list(names)) & (!isempty(names)) )
-      if(ischar(names{1}))
-        warning("syssetsignals(opt=%s): converting string matrix \"names\" to a cell array of strings",opt);
+    if (! is_signal_list (names) && ! isempty (names))
+      if (ischar (names{1}))
         tmpstr = names{1};
         for ii=1:rows(tmpstr)
           names{ii} = deblank(tmpstr(ii,:));
         endfor
       else
-        names
-        error("parameter \"names\" must be a cell array of strings");
+        error ("parameter \"names\" must be a cell array of strings");
       endif
     endif
-    nsigs = length(sig_vals);
+    nsigs = length (sig_vals);
 
-    if(nargin == 3)
+    if (nargin == 3)
       ## replace all signal names
-      if(length(names) != nsigs)
-        error("opt=%s, sig_idx omitted: names(len=%d) should have %d entries ", ...
-          opt,length(names),nsigs);
+      if (length (names) != nsigs)
+        error ("opt=%s, sig_idx omitted: names(len=%d) should have %d entries ",
+               opt, length (names), nsigs);
       endif
       sig_idx = 1:nsigs;
-    elseif(length(names) != length(sig_idx))
+    elseif (length (names) != length (sig_idx))
       ## replace specified signal names
-      error("opt=%s, sig_idx(len=%d), names(len=%d) mismatch",opt, ...
-        length(sig_idx), length(names));
+      error ("opt=%s, sig_idx(len=%d), names(len=%d) mismatch",
+	     opt, length (sig_idx), length (names));
     endif
 
-    for ii=1:length(sig_idx)
+    for ii = 1:length(sig_idx)
       jj = sig_idx(ii);
-      if(jj < 1 | jj > nsigs | jj != floor(jj+0.5))
-        error("opt=%s, sig_idx(%d)=%d, %e: must be an integer between 1 and %d", ...
-          opt, ii, jj, jj, nsigs);
+      if (jj < 1 || jj > nsigs || jj != floor (jj+0.5))
+        error ("opt=%s, sig_idx(%d)=%d, %e: must be an integer between 1 and %d",
+               opt, ii, jj, jj, nsigs);
       endif
       sig_vals{jj} = names{ii};
     endfor
 
   else
     ## update yd
     ## 1st check pathological case: no outputs
-    nout = sysdimensions(sys,"out");
-    if(nout == 0)
-      if(nargin != 3)
-        error("opt=%s, %d outputs, sysgetsignals cannot take 4 arguments", ...
-          yd,nout);
+    nout = sysdimensions (sys, "out");
+    if (nout == 0)
+      if (nargin != 3)
+        error ("opt=%s, %d outputs, sysgetsignals cannot take 4 arguments",
+               opt, nout);
       endif
-      if(!isempty(names))
-        error("opt=%s, %d outputs, names is not empty");
+      if (! isempty (names))
+        error ("opt=%s, %d outputs, names is not empty", opt, nout);
       endif
       sigvals = [];
     else
-      nsigs = length(sig_vals);
-      if(!isvector(names))
-        error("syssetsignals: opt=yd, names(%dx%d) must be a vector", ...
-          rows(names), columns(names));
+      nsigs = length (sig_vals);
+      if (! isvector (names))
+        error ("syssetsignals: opt=%s, names(%dx%d) must be a vector",
+              opt, rows (names), columns (names));
       endif
-      if(nargin == 3)
-        if(length(names) != nsigs)
-          error("opt=yd, sig_idx omitted: names(%d) should be length(%d)", ...
-            length(names), nsigs);
+      if (nargin == 3)
+        if (length (names) != nsigs)
+          error ("opt=%s, sig_idx omitted: names(%d) should be length(%d)",
+		 opt, length (names), nsigs);
         endif
         sig_idx = 1:nsigs;
-      elseif(length(names) != length(sig_idx))
-        error("opt=yd: length(names)=%d, length(sig_idx)=%d",length(names), ...
-          length(sig_idx) );
+      elseif (length(names) != length (sig_idx))
+        error ("opt=%s: length(names)=%d, length(sig_idx)=%d",
+	       opt, length (names), length (sig_idx));
       endif
 
-      badidx = find(names != 0 & names != 1);
-      if(! isempty(badidx) )
-        for ii=1:length(badidx)
-          warning("syssetsignals: opt=yd: names(%d)=%e, must be 0 or 1", ...
-            badidx(ii), names(badidx(ii)) );
+      badidx = find (names != 0 & names != 1);
+      if (! isempty (badidx))
+        for ii = 1:length(badidx)
+          warning ("syssetsignals: opt=%s: names(%d)=%e, must be 0 or 1",
+		   opt, badidx(ii), names(badidx(ii)) );
         endfor
-        error ("opt=yd: invalid values in names");
+        error ("opt=%s: invalid values in names", opt);
       endif
 
-      for ii=1:length(sig_idx)
+      for ii = 1:length(sig_idx)
         jj = sig_idx(ii);
-        if(jj < 1 | jj > nsigs | jj != floor(jj))
-          error("sig_idx(%d)=%d, %e: must be an integer between 1 and %d", ...
-            ii,jj, jj, nsigs);
+        if (jj < 1 || jj > nsigs || jj != floor (jj))
+          error ("sig_idx(%d)=%d, %e: must be an integer between 1 and %d",
+		 ii, jj, jj, nsigs);
         endif
         sig_vals(jj) = names(ii);
       endfor
-      if(any(sig_vals == 1) & sysgettsam(sys) == 0)
-        warning("Setting system sampling time to 1");
-        printf("syssetsignals: original system sampling time=0 but output(s)\n");
-        disp(find(sig_vals==1))
-        printf("are digital\n");
-        sys = syschtsam(sys,1);
+      if (any (sig_vals == 1) && sysgettsam (sys) == 0)
+        warning ("Setting system sampling time to 1");
+        printf ("syssetsignals: original system sampling time=0 but output(s)\n");
+        disp (find (sig_vals == 1))
+        printf ("are digital\n");
+        sys = syschtsam (sys, 1);
       endif
 
     endif
   endif
 
-  if(strcmp(opt,"st"))
+  if (strcmp (opt, "st"))
     sys.stname = sig_vals;
-  elseif(strcmp(opt,"in"))
+  elseif (strcmp (opt, "in"))
     sys.inname = sig_vals;
-  elseif(strcmp(opt,"out"))
+  elseif (strcmp (opt, "out"))
     sys.outname = sig_vals;
-  elseif(strcmp(opt,"yd"))
+  elseif (strcmp (opt, "yd"))
     sys.yd = sig_vals;
   endif
 
   retsys = sys;
 
 endfunction
diff --git a/scripts/control/system/tf.m b/scripts/control/system/tf.m
--- a/scripts/control/system/tf.m
+++ b/scripts/control/system/tf.m
@@ -56,89 +56,94 @@
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 
 function outsys = tf (num, den, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
-  if ((nargin < 2) || (nargin > 5))
+  if (nargin < 2 || nargin > 5)
     print_usage ();
-    return
   endif
 
   ## check input format
-  if( ! ( (isvector(num) || isscalar(num)) && ...
-        (isvector(den) || isscalar(den))) )
-    error(["num (",num2str(rows(num)),"x",num2str(columns(num)), ...
-      ") and den (",num2str(rows(den)),"x",num2str(columns(den)), ...
-      ") must be vectors"])
+  if (! ((isvector (num) || isscalar (num))
+	 && (isvector (den) || isscalar (den))))
+    error ("num (%dx%d) and den (%dx%d) must be vectors",
+	   rows (num), columns (num), rows (den), columns (den));
   endif
 
   ## strip leading zero coefficients
   num = __tfl__ (num);
   den = __tfl__ (den);
 
-  if (length(num) >  length(den))
-    error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
+  if (length (num) > length (den))
+    error ("# of poles (%d) < # of zeros (%d)", length(den)-1, length(num)-1);
   endif
 
   ## check sampling interval (if any)
-  if(nargin <= 2)           tsam = 0;           # default
-  elseif (isempty(tsam))    tsam = 0;           endif
-  if ( (! (isscalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
-    error("tsam must be a positive real scalar")
+  if (nargin <= 2)
+    tsam = 0;           # default
+  elseif (isempty (tsam))
+    tsam = 0;
+  endif
+  if (! (isscalar (tsam) && imag (tsam) == 0) || tsam < 0)
+    error ("tsam must be a positive real scalar")
   endif
 
   outsys.num = num;
   outsys.den = den;
 
   ## Set the system vector:  active = 0(tf), updated = [1 0 0];
   outsys.sys = [0, 1, 0, 0];
 
   ## Set defaults
   outsys.tsam = tsam;
-  outsys.n = length(den)-1;
+  outsys.n = length (den) - 1;
   outsys.nz = 0;
   outsys.yd = 0;        # assume discrete-time
   ## check discrete time
-  if(tsam > 0)
-    [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
+  if (tsam > 0)
+    [outsys.n, outsys.nz] = swap (outsys.n, outsys.nz);
     outsys.yd = 1;
   endif
 
   outsys.inname  = __sysdefioname__ (1, "u");
   outsys.outname = __sysdefioname__ (1, "y");
   outsys.stname  = __sysdefstname__ (outsys.n, outsys.nz);
 
   ## Set name of input
   if (nargin > 3)
     ## make sure it's a cell array of a single string
-    if(!isempty(inname))
-      if(!iscell(inname))  inname = {inname};  endif
-      if( !is_signal_list(inname) )
-        error("inname must be a string or cell array of strings");
+    if (! isempty (inname))
+      if (! iscell (inname))
+	inname = {inname};
       endif
-      if(length(inname) > 1)
-        warning("tf: %d input names provided; first used",length(inname));
+      if (! is_signal_list (inname))
+        error ("inname must be a string or cell array of strings");
+      endif
+      if (length (inname) > 1)
+        warning ("tf: %d input names provided; first used", length (inname));
         inname = inname(1);
       endif
-      outsys = syssetsignals(outsys,"in",inname);
+      outsys = syssetsignals (outsys, "in", inname);
     endif
   endif
 
   ## Set name of output
   if (nargin > 4)
-    if(!isempty(outname))
-      if(!iscell(outname))  outname = {outname};  endif
-      if(!is_signal_list(outname))
-        error("outname must be a string or a cell array of strings");
+    if (! isempty (outname))
+      if (! iscell (outname))
+	outname = {outname};
       endif
-      if(length(outname) > 1)
-        warning("tf: %d output names provided; first used",length(outname));
+      if (! is_signal_list (outname))
+        error ("outname must be a string or a cell array of strings");
+      endif
+      if (length (outname) > 1)
+        warning ("tf: %d output names provided; first used", length(outname));
         outname = outname(1);
       endif
-      outsys = syssetsignals(outsys,"out",outname);
+      outsys = syssetsignals (outsys, "out", outname);
     endif
   endif
 
 endfunction
diff --git a/scripts/control/system/zp2ss.m b/scripts/control/system/zp2ss.m
--- a/scripts/control/system/zp2ss.m
+++ b/scripts/control/system/zp2ss.m
@@ -56,105 +56,103 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
 function [a, b, c, d] = zp2ss (zer, pol, k)
 
-    if(nargin != 3)
-      error("Incorrect number of input arguments");
-    endif
+  if (nargin != 3)
+    print_usage ();
+  endif
+
+  if (! (isvector (zer) || isempty (zer)))
+    error ("zer(%d,%d) should be a vector", rows (zer), columns (zer));
+  elseif (! (isvector (pol) || isempty (pol)))
+    error ("pol(%d,%d) should be a vector", rows (pol), columns (pol));
+  elseif (! isscalar(k))
+    error ("k(%d,%d) should be a scalar", rows (k), columns (k));
+  elseif (k != real (k))
+    warning ("zp2ss: k is complex")
+  endif
+
+  zpsys = ss (zeros (0, 0), zeros (0, 1), zeros (1, 0), k);
+
+  ## Find the number of zeros and the number of poles
+  nzer = length (zer);
+  npol = length (pol);
 
-    if(! (isvector(zer) | isempty(zer)) )
-      error(["zer(",num2str(rows(zer)),",",num2str(columns(zer)), ...
-	  ") should be a vector"]);
-    elseif(! (isvector(pol) | isempty(pol) ) )
-      error(["pol(",num2str(rows(pol)),",",num2str(columns(pol)), ...
-	  ") should be a vector"]);
-    elseif(! isscalar(k))
-      error(["k(",num2str(rows(k)),",",num2str(columns(k)), ...
-	  ") should be a scalar"]);
-    elseif( k != real(k))
-      warning("zp2ss: k is complex")
+  if (nzer > npol)
+    error ("%d zeros, exceeds number of poles=%d", nzer, npol);
+  endif
+
+  ## Sort to place complex conjugate pairs together
+  zer = sortcom (zer);
+  pol = sortcom (pol);
+
+  ## construct the system as a series connection of poles and zeros
+  ## problem: poles and zeros may come in conjugate pairs, and not
+  ## matched up!
+
+  ## approach: remove poles/zeros from the list as they are included in
+  ## the ss system
+
+  while (length (pol))
+
+    ## search for complex poles, zeros
+    cpol = [];
+    czer = [];
+    if (! isempty (pol))
+      cpol = find (imag (pol) != 0);
     endif
-
-    zpsys = ss (zeros (0, 0), zeros (0, 1), zeros (1, 0), k);
-
-    ## Find the number of zeros and the number of poles
-    nzer=length(zer);
-    npol =length(pol);
-
-    if(nzer > npol)
-      error([num2str(nzer)," zeros, exceeds number of poles=",num2str(npol)]);
+    if (! isempty (zer))
+      czer = find (imag (zer) != 0);
     endif
 
-    ## Sort to place complex conjugate pairs together
-    zer=sortcom(zer);
-    pol=sortcom(pol);
-
-    ## construct the system as a series connection of poles and zeros
-    ## problem: poles and zeros may come in conjugate pairs, and not
-    ## matched up!
-
-    ## approach: remove poles/zeros from the list as they are included in
-    ## the ss system
-
-    while(length(pol))
+    if (isempty (cpol) && isempty (czer))
+      pcnt = 1;
+    else
+      pcnt = 2;
+    endif
 
-      ## search for complex poles, zeros
-      cpol=[];    czer = [];
-      if(!isempty(pol))
-	cpol = find(imag(pol) != 0);
-      endif
-      if(!isempty(zer))
-	czer = find(imag(zer) != 0);
-      endif
-
-      if(isempty(cpol) & isempty(czer))
-	pcnt = 1;
-      else
-	pcnt = 2;
-      endif
-
-      num=1;      # assume no zeros left.
-      switch(pcnt)
-      case(1)
+    num = 1;      # assume no zeros left.
+    switch (pcnt)
+      case 1
 	## real pole/zero combination
-	if(length(zer))
+	if (length (zer))
 	  num = [1, -zer(1)];
 	  zer = zer(2:length(zer));
 	endif
 	den = [1, -pol(1)];
 	pol = pol(2:length(pol));
-      case(2)
+      case 2
 	## got a complex pole or zero, need two roots (if available)
-	if(length(zer) > 1)
+	if (length (zer) > 1)
 	  [num, zer] = __zp2ssg2__ (zer);       # get two zeros
-	elseif(length(zer) == 1)
+	elseif (length (zer) == 1)
 	  num = [1, -zer];                # use last zero (better be real!)
 	  zer = [];
 	endif
 	[den, pol] = __zp2ssg2__ (pol);         # get two poles
       otherwise
-	error(["pcnt = ",num2str(pcnt)])
+	error ("pcnt = %d", pcnt);
       endswitch
 
       ## pack tf into system form and put in series with earlier realization
-      zpsys1 = tf(num,den,0,"u","yy");
+      zpsys1 = tf (num, den, 0, "u", "yy");
 
       ## change names to avoid warning messages from sysgroup
       zpsys  = syssetsignals (zpsys, "in", "u1", 1);
       zpsys1 = sysupdate (zpsys1, "ss");
       nn     = sysdimensions (zpsys);        # working with continuous system
       zpsys  = syssetsignals (zpsys, "st", __sysdefioname__ (nn, "x"));
       nn1    = sysdimensions (zpsys1);
       zpsys1 = syssetsignals (zpsys1, "st", __sysdefioname__ (nn1, "xx"));
 
-      zpsys = sysmult(zpsys,zpsys1);
+      zpsys = sysmult (zpsys, zpsys1);
 
     endwhile
 
-    [a,b,c,d] = sys2ss(zpsys);
+    [a, b, c, d] = sys2ss (zpsys);
 
 endfunction
 
