# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1265913042 18000
#      Thu Feb 11 13:30:42 2010 -0500
# Node ID 42d098307c30dacfb499b299067c90fa320f3bf8
# Parent  9966f1f71c32e6d314cb0a49d9fab696daff4033
untabify additional source files

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,14 @@
+2010-02-11  John W. Eaton  <jwe@octave.org>
+
+	* sparse-mk-ops.awk, mk-ops.awk, filemode.c, lo-cieee.c,
+	oct-rl-hist.c, randgamma.c, randmtzig.c, randpoisson.c,
+	tempnam.c, tempname.c: Untabify.
+
 2010-02-11  John W. Eaton  <jwe@octave.org>
 
 	* Array-C.cc, Array-fC.cc, Array-util.cc, Array.cc,
 	CColVector.cc, CDiagMatrix.cc, CMatrix.cc, CNDArray.cc,
 	CRowVector.cc, CSparse.cc, CmplxAEPBAL.cc, CmplxCHOL.cc,
 	CmplxGEPBAL.cc, CmplxHESS.cc, CmplxLU.cc, CmplxQR.cc,
 	CmplxQRP.cc, CmplxSCHUR.cc, CmplxSVD.cc, CollocWt.cc, DASPK.cc,
 	DASRT.cc, DASSL.cc, EIG.cc, LSODE.cc, MSparse.cc, MatrixType.cc,
diff --git a/liboctave/filemode.c b/liboctave/filemode.c
--- a/liboctave/filemode.c
+++ b/liboctave/filemode.c
@@ -94,46 +94,46 @@ static char ftypelet ();
 static void rwx ();
 static void setst ();
 
 /* filemodestring - fill in string STR with an ls-style ASCII
    representation of the st_mode field of file stats block STATP.
    10 characters are stored in STR; no terminating null is added.
    The characters stored in STR are:
 
-   0	File type.  'd' for directory, 'c' for character
-	special, 'b' for block special, 'm' for multiplex,
-	'l' for symbolic link, 's' for socket, 'p' for fifo,
-	'-' for regular, '?' for any other file type
+   0    File type.  'd' for directory, 'c' for character
+        special, 'b' for block special, 'm' for multiplex,
+        'l' for symbolic link, 's' for socket, 'p' for fifo,
+        '-' for regular, '?' for any other file type
 
-   1	'r' if the owner may read, '-' otherwise.
+   1    'r' if the owner may read, '-' otherwise.
 
-   2	'w' if the owner may write, '-' otherwise.
+   2    'w' if the owner may write, '-' otherwise.
 
-   3	'x' if the owner may execute, 's' if the file is
-	set-user-id, '-' otherwise.
-	'S' if the file is set-user-id, but the execute
-	bit isn't set.
+   3    'x' if the owner may execute, 's' if the file is
+        set-user-id, '-' otherwise.
+        'S' if the file is set-user-id, but the execute
+        bit isn't set.
 
-   4	'r' if group members may read, '-' otherwise.
+   4    'r' if group members may read, '-' otherwise.
 
-   5	'w' if group members may write, '-' otherwise.
+   5    'w' if group members may write, '-' otherwise.
 
-   6	'x' if group members may execute, 's' if the file is
-	set-group-id, '-' otherwise.
-	'S' if it is set-group-id but not executable.
+   6    'x' if group members may execute, 's' if the file is
+        set-group-id, '-' otherwise.
+        'S' if it is set-group-id but not executable.
 
-   7	'r' if any user may read, '-' otherwise.
+   7    'r' if any user may read, '-' otherwise.
 
-   8	'w' if any user may write, '-' otherwise.
+   8    'w' if any user may write, '-' otherwise.
 
-   9	'x' if any user may execute, 't' if the file is "sticky"
-	(will be retained in swap space after execution), '-'
-	otherwise.
-	'T' if the file is sticky but not executable.  */
+   9    'x' if any user may execute, 't' if the file is "sticky"
+        (will be retained in swap space after execution), '-'
+        otherwise.
+        'T' if the file is sticky but not executable.  */
 
 void
 filemodestring (statp, str)
      struct stat *statp;
      char *str;
 {
   mode_string (statp->st_mode, str);
 }
@@ -222,35 +222,35 @@ static void
 setst (bits, chars)
      unsigned short bits;
      char *chars;
 {
 #ifdef S_ISUID
   if (bits & S_ISUID)
     {
       if (chars[3] != 'x')
-	/* Set-uid, but not executable by owner.  */
-	chars[3] = 'S';
+        /* Set-uid, but not executable by owner.  */
+        chars[3] = 'S';
       else
-	chars[3] = 's';
+        chars[3] = 's';
     }
 #endif
 #ifdef S_ISGID
   if (bits & S_ISGID)
     {
       if (chars[6] != 'x')
-	/* Set-gid, but not executable by group.  */
-	chars[6] = 'S';
+        /* Set-gid, but not executable by group.  */
+        chars[6] = 'S';
       else
-	chars[6] = 's';
+        chars[6] = 's';
     }
 #endif
 #ifdef S_ISVTX
   if (bits & S_ISVTX)
     {
       if (chars[9] != 'x')
-	/* Sticky, but not executable by others.  */
-	chars[9] = 'T';
+        /* Sticky, but not executable by others.  */
+        chars[9] = 'T';
       else
-	chars[9] = 't';
+        chars[9] = 't';
     }
 #endif
 }
diff --git a/liboctave/lo-cieee.c b/liboctave/lo-cieee.c
--- a/liboctave/lo-cieee.c
+++ b/liboctave/lo-cieee.c
@@ -146,30 +146,30 @@ int
 
 int
 __lo_ieee_is_NA (double x)
 {
 #if defined (HAVE_ISNAN)
   lo_ieee_double t;
   t.value = x;
   return (isnan (x) && t.word[lo_ieee_hw] == LO_IEEE_NA_HW 
-	  && t.word[lo_ieee_lw] == LO_IEEE_NA_LW) ? 1 : 0;
+          && t.word[lo_ieee_lw] == LO_IEEE_NA_LW) ? 1 : 0;
 #else
   return 0;
 #endif
 }
 
 int
 __lo_ieee_is_old_NA (double x)
 {
 #if defined (HAVE_ISNAN)
   lo_ieee_double t;
   t.value = x;
   return (isnan (x) && t.word[lo_ieee_lw] == LO_IEEE_NA_LW_OLD 
-	  && t.word[lo_ieee_hw] == LO_IEEE_NA_HW_OLD) ? 1 : 0;
+          && t.word[lo_ieee_hw] == LO_IEEE_NA_HW_OLD) ? 1 : 0;
 #else
   return 0;
 #endif
 }
 
 double
 __lo_ieee_replace_old_NA (double x)
 {
diff --git a/liboctave/mk-ops.awk b/liboctave/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/mk-ops.awk
@@ -41,18 +41,18 @@ BEGIN {
   next;
 } {
   if (declare_types)
     {
       ntypes++;
 
       if (NF == 6 || NF == 7)
         {
-	  if (NF == 7)
-	    core_type[ntypes] = $7;
+          if (NF == 7)
+            core_type[ntypes] = $7;
 
           scalar_zero_val[ntypes] = $6;
           fwd_decl_ok[ntypes] = $5 == "YES";
           header[ntypes] = $4 == "NONE" ? "" : $4;
           class[ntypes] = $3;
           type[ntypes] = $2;
           tag[ntypes] = $1;
           rev_tag[$1] = ntypes;
@@ -62,177 +62,177 @@ BEGIN {
     }
   else if (generate_ops)
     {
       if (NF >= 4)
         {
           result_tag = $1;
           lhs_tag = $2;
           rhs_tag = $3;
-	  op_type = $4;
+          op_type = $4;
 
-	  bin_ops = index (op_type, "B") != 0;
-	  cmp_ops = index (op_type, "C") != 0;
-	  bool_ops = index (op_type, "L") != 0;
+          bin_ops = index (op_type, "B") != 0;
+          cmp_ops = index (op_type, "C") != 0;
+          bool_ops = index (op_type, "L") != 0;
 
           n = 4;
 
           lhs_conv = cmp_ops ? $(++n) : "";
           rhs_conv = cmp_ops ? $(++n) : "";
 
-	  if (lhs_conv == "NONE")
-	    lhs_conv = "";
+          if (lhs_conv == "NONE")
+            lhs_conv = "";
 
-	  if (rhs_conv == "NONE")
-	    rhs_conv = "";
+          if (rhs_conv == "NONE")
+            rhs_conv = "";
 
-	  k = 0
-	  while (NF > n)
-	    bool_headers[k++] = $(++n);
+          k = 0
+          while (NF > n)
+            bool_headers[k++] = $(++n);
 
-	  cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
-	  h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
+          cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
+          h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
 
-	  if (list_cc_files)
-	    {
-	      print cc_file;
-	      next;
-	    }
+          if (list_cc_files)
+            {
+              print cc_file;
+              next;
+            }
 
-	  if (list_h_files)
-	    {
-	      print h_file;
-	      next;
-	    }
+          if (list_h_files)
+            {
+              print h_file;
+              next;
+            }
 
-	  if (make_inclusive_header)
-	    {
+          if (make_inclusive_header)
+            {
               printf ("#include \"%s\"\n", h_file);
               next;
             }
 
-	  h_guard = sprintf ("octave_%s_%s_%s_h", prefix, lhs_tag, rhs_tag);
+          h_guard = sprintf ("octave_%s_%s_%s_h", prefix, lhs_tag, rhs_tag);
 
-	  result_num = rev_tag[result_tag];
-	  lhs_num = rev_tag[lhs_tag];
-	  rhs_num = rev_tag[rhs_tag];
+          result_num = rev_tag[result_tag];
+          lhs_num = rev_tag[lhs_tag];
+          rhs_num = rev_tag[rhs_tag];
 
-	  result_type = type[result_num];
-	  lhs_type = type[lhs_num];
+          result_type = type[result_num];
+          lhs_type = type[lhs_num];
           rhs_type = type[rhs_num];
 
-	  lhs_core_type = core_type[lhs_num];
-	  rhs_core_type = core_type[rhs_num];
+          lhs_core_type = core_type[lhs_num];
+          rhs_core_type = core_type[rhs_num];
 
-	  result_scalar_zero_val = scalar_zero_val[result_num];
+          result_scalar_zero_val = scalar_zero_val[result_num];
           lhs_scalar_zero_val = scalar_zero_val[lhs_num];
           rhs_scalar_zero_val = scalar_zero_val[rhs_num];
 
-	  result_header = header[result_num];
-	  lhs_header = header[lhs_num];
+          result_header = header[result_num];
+          lhs_header = header[lhs_num];
           rhs_header = header[rhs_num];
 
-	  lhs_class = class[lhs_num];
-	  rhs_class = class[rhs_num];
+          lhs_class = class[lhs_num];
+          rhs_class = class[rhs_num];
 
-	  print "// DO NOT EDIT -- generated by mk-ops" > h_file;
+          print "// DO NOT EDIT -- generated by mk-ops" > h_file;
 
-	  printf ("#if !defined (%s)\n", h_guard) >> h_file;
-	  printf ("#define %s 1\n", h_guard) >> h_file;
+          printf ("#if !defined (%s)\n", h_guard) >> h_file;
+          printf ("#define %s 1\n", h_guard) >> h_file;
 
           if (result_header)
-	    {
-	      if (result_fwd_decl_ok)
-	        printf ("class %s\n", result_type) >> h_file;
-	      else
-	        printf ("#include \"%s\"\n", result_header) >> h_file;
-	    }
+            {
+              if (result_fwd_decl_ok)
+                printf ("class %s\n", result_type) >> h_file;
+              else
+                printf ("#include \"%s\"\n", result_header) >> h_file;
+            }
 
           if (lhs_header && ! (lhs_header == result_header))
-	    {
-	      if (result_fwd_decl_ok)
-	        printf ("class %s\n", lhs_type) >> h_file;
-	      else
-	        printf ("#include \"%s\"\n", lhs_header) >> h_file;
-	    }
+            {
+              if (result_fwd_decl_ok)
+                printf ("class %s\n", lhs_type) >> h_file;
+              else
+                printf ("#include \"%s\"\n", lhs_header) >> h_file;
+            }
 
           if (rhs_header && ! (rhs_header == lhs_header || rhs_header == result_header))
-	    {
-	      if (result_fwd_decl_ok)
-	        printf ("class %s\n", rhs_type) >> h_file;
-	      else
-	        printf ("#include \"%s\"\n", rhs_header) >> h_file;
-	    }
+            {
+              if (result_fwd_decl_ok)
+                printf ("class %s\n", rhs_type) >> h_file;
+              else
+                printf ("#include \"%s\"\n", rhs_header) >> h_file;
+            }
 
           printf ("#include \"mx-op-decl.h\"\n") >> h_file;
 
           if (bin_ops)
             printf ("%s%s_BIN_OP_DECLS (%s, %s, %s, OCTAVE_API)\n", lhs_class,
-		    rhs_class, result_type, lhs_type, rhs_type) >> h_file
+                    rhs_class, result_type, lhs_type, rhs_type) >> h_file
 
           if (cmp_ops)
             printf ("%s%s_CMP_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
-		    rhs_class, lhs_type, rhs_type) >> h_file
+                    rhs_class, lhs_type, rhs_type) >> h_file
 
           if (bool_ops)
             printf ("%s%s_BOOL_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
-		    rhs_class, lhs_type, rhs_type) >> h_file
+                    rhs_class, lhs_type, rhs_type) >> h_file
 
 
           print "#endif" >> h_file;
 
-	  close (h_file);
+          close (h_file);
 
 
-	  print "// DO NOT EDIT -- generated by mk-ops" > cc_file;
+          print "// DO NOT EDIT -- generated by mk-ops" > cc_file;
 
-	  print "#ifdef HAVE_CONFIG_H" >> cc_file;
-	  print "#include <config.h>" >> cc_file;
-	  print "#endif" >> cc_file;
+          print "#ifdef HAVE_CONFIG_H" >> cc_file;
+          print "#include <config.h>" >> cc_file;
+          print "#endif" >> cc_file;
 
-	  print "#include \"Array-util.h\"" >> cc_file;
+          print "#include \"Array-util.h\"" >> cc_file;
 
-	  printf ("#include \"%s\"\n", h_file) >> cc_file;
+          printf ("#include \"%s\"\n", h_file) >> cc_file;
 
           printf ("#include \"mx-op-defs.h\"\n") >> cc_file;
 
-	  for (i in bool_headers)
-	    {
-	      printf ("#include \"%s\"\n", bool_headers[i]) >> cc_file;
-	      delete bool_headers[i];
-	    }
+          for (i in bool_headers)
+            {
+              printf ("#include \"%s\"\n", bool_headers[i]) >> cc_file;
+              delete bool_headers[i];
+            }
 
           if (result_header)
-	    printf ("#include \"%s\"\n", result_header) >> cc_file;
+            printf ("#include \"%s\"\n", result_header) >> cc_file;
 
           if (lhs_header && ! (lhs_header == result_header))
-	    printf ("#include \"%s\"\n", lhs_header) >> cc_file;
+            printf ("#include \"%s\"\n", lhs_header) >> cc_file;
 
           if (rhs_header && ! (rhs_header == lhs_header || rhs_header == result_header))
-	    printf ("#include \"%s\"\n", rhs_header) >> cc_file;
+            printf ("#include \"%s\"\n", rhs_header) >> cc_file;
 
-	  if (bin_ops)
+          if (bin_ops)
             {
               if ((lhs_class == "DM" && rhs_class == "M") || (lhs_class == "M" && rhs_class == "DM"))
                 printf ("%s%s_BIN_OPS (%s, %s, %s, %s)\n",
-		        lhs_class, rhs_class, result_type,
-		        lhs_type, rhs_type, result_scalar_zero_val) >> cc_file
+                        lhs_class, rhs_class, result_type,
+                        lhs_type, rhs_type, result_scalar_zero_val) >> cc_file
               else
                 printf ("%s%s_BIN_OPS (%s, %s, %s)\n",
-		        lhs_class, rhs_class, result_type,
-			lhs_type, rhs_type) >> cc_file
+                        lhs_class, rhs_class, result_type,
+                        lhs_type, rhs_type) >> cc_file
             }
 
           if (cmp_ops)
-	     printf ("%s%s_CMP_OPS (%s, %s)\n",
-		     lhs_class, rhs_class, lhs_type, rhs_type) >> cc_file
+             printf ("%s%s_CMP_OPS (%s, %s)\n",
+                     lhs_class, rhs_class, lhs_type, rhs_type) >> cc_file
 
           if (bool_ops)
             printf ("%s%s_BOOL_OPS (%s, %s)\n", lhs_class, rhs_class,
-	            lhs_type, rhs_type) >> cc_file
+                    lhs_type, rhs_type) >> cc_file
 
 
           close (cc_file);
         }
       else
         printf ("skipping line %d: %s\n", NR, $0); 
     }
 }
diff --git a/liboctave/oct-rl-hist.c b/liboctave/oct-rl-hist.c
--- a/liboctave/oct-rl-hist.c
+++ b/liboctave/oct-rl-hist.c
@@ -125,17 +125,17 @@ octave_history_truncate_file (const char
 void
 octave_remove_history (int n)
 {
   HIST_ENTRY *discard = remove_history (n);
 
   if (discard)
     {
       if (discard->line)
-	free (discard->line);
+        free (discard->line);
 
       free (discard);
     }
 }
 
 char *
 octave_history_goto_mark (int n)
 {
@@ -143,17 +143,17 @@ octave_history_goto_mark (int n)
 
   char *retval = 0;
 
   if (history_set_pos (n))
     {
       h = current_history ();
 
       if (h)
-	retval = h->line;
+        retval = h->line;
     }
 
   return retval;
 }
 
 char *
 octave_history_get (int n)
 {
@@ -174,69 +174,69 @@ octave_history_list (int limit, int numb
 
   HIST_ENTRY **hlist = 0;
 
   if (retval)
     {
       char **p = retval;
 
       while (*p)
-	free (*p++);
+        free (*p++);
 
       free (retval);
 
       retval = 0;
     }
 
   hlist = history_list ();
 
   if (hlist)
     {
       int i, k;
 
       int beg = 0;
       int end = 0;
       while (hlist[end])
-	end++;
+        end++;
 
       beg = (limit < 0 || end < limit) ? 0 : (end - limit);
 
       retval = malloc ((end - beg + 1) * sizeof (char **));
 
       k = 0;
       for (i = beg; i < end; i++)
-	{
-	  char *line = hlist[i]->line;
-	  int len = line ? strlen (line) : 0;
-	  char *tmp = malloc (len + 64);
+        {
+          char *line = hlist[i]->line;
+          int len = line ? strlen (line) : 0;
+          char *tmp = malloc (len + 64);
 
-	  if (number_lines)
-	    sprintf (tmp, "%5d%c%s", i + history_base,
-		     hlist[i]->data ? '*' : ' ',
-		     line ? line : "");
-	  else
-	    sprintf (tmp, "%c%s", hlist[i]->data ? '*' : ' ',
-		     line ? line : "");
+          if (number_lines)
+            sprintf (tmp, "%5d%c%s", i + history_base,
+                     hlist[i]->data ? '*' : ' ',
+                     line ? line : "");
+          else
+            sprintf (tmp, "%c%s", hlist[i]->data ? '*' : ' ',
+                     line ? line : "");
 
-	  retval[k++] = tmp;
-	}
+          retval[k++] = tmp;
+        }
 
       retval[k] = 0;
     }
 
   return retval;
 }
 
 void
 octave_replace_history_entry (int which, const char *line)
 {
   HIST_ENTRY *discard = replace_history_entry (which, line, 0);
 
   if (discard)
     {
       if (discard->line)
-	free (discard->line);
+        free (discard->line);
 
       free (discard);
     }
 }
 
 #endif
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -102,40 +102,40 @@ oct_fill_randg (double a, octave_idx_typ
   /* If a < 1, start by generating gamma(1+a) */
   const double d =  (a < 1. ? 1.+a : a) - 1./3.;
   const double c = 1./sqrt(9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a)) 
     {
       for (i=0; i < n; i++) 
-	r[i] = NAN;
+        r[i] = NAN;
       return;
     }
 
   for (i=0; i < n; i++) 
     {
       double x, xsq, v, u;
     restart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
       if (v <= 0) 
-	goto restart; /* rare, so don't bother moving up */
+        goto restart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
       if (u >= 1.-0.0331*xsq*xsq && log(u) >= 0.5*xsq + d*(1-v+log(v)))
-	goto restart;
+        goto restart;
       r[i] = d*v;
     }
   if (a < 1) 
     { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++) 
-	r[i] *= exp(-REXP/a);
+        r[i] *= exp(-REXP/a);
     }
 }
 
 double 
 oct_randg (double a)
 {
   double ret;
   oct_fill_randg(a,1,&ret);
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -208,39 +208,39 @@ oct_init_by_array (uint32_t *init_key, i
   int i, j, k;
   oct_init_by_int (19650218UL);
   i = 1;
   j = 0;
   k = (MT_N > key_length ? MT_N : key_length);
   for (; k; k--)
     {
       state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525UL))
-	+ init_key[j] + j; /* non linear */
+        + init_key[j] + j; /* non linear */
       state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
       i++;
       j++;
       if (i >= MT_N)
-	{
-	  state[0] = state[MT_N-1];
-	  i = 1;
-	}
+        {
+          state[0] = state[MT_N-1];
+          i = 1;
+        }
       if (j >= key_length)
-	j = 0;
+        j = 0;
     }
   for (k = MT_N - 1; k; k--)
     {
       state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL))
-	- i; /* non linear */
+        - i; /* non linear */
       state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
       i++;
       if (i >= MT_N)
-	{
-	  state[0] = state[MT_N-1];
-	  i = 1;
-	}
+        {
+          state[0] = state[MT_N-1];
+          i = 1;
+        }
     }
 
   state[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
   left = 1;
   initf = 1;
 }
 
 void 
@@ -248,37 +248,37 @@ oct_init_by_entropy (void)
 {
     uint32_t entropy[MT_N];
     int n = 0;
 
     /* Look for entropy in /dev/urandom */
     FILE* urandom =fopen("/dev/urandom", "rb");
     if (urandom) 
       {
-	while (n < MT_N) 
-	  {
-	    unsigned char word[4];
-	    if (fread(word, 4, 1, urandom) != 1) 
-	      break;
-	    entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(word[3]<<24);
-	  }
-	fclose(urandom);
+        while (n < MT_N) 
+          {
+            unsigned char word[4];
+            if (fread(word, 4, 1, urandom) != 1) 
+              break;
+            entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(word[3]<<24);
+          }
+        fclose(urandom);
       }
 
     /* If there isn't enough entropy, gather some from various sources */
     if (n < MT_N) 
       entropy[n++] = time(NULL); /* Current time in seconds */
     if (n < MT_N) 
       entropy[n++] = clock();    /* CPU time used (usec) */
 #ifdef HAVE_GETTIMEOFDAY
     if (n < MT_N) 
       {
-	struct timeval tv;
-	if (gettimeofday(&tv, NULL) != -1)
-	  entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
+        struct timeval tv;
+        if (gettimeofday(&tv, NULL) != -1)
+          entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
       }
 #endif
     /* Send all the entropy into the initial state vector */
     oct_init_by_array(entropy,n);
 }
 
 void 
 oct_set_state (uint32_t *save)
@@ -618,67 +618,67 @@ oct_randn (void)
 #else /* ALLBITS */
       /* 32-bit mantissa */
       const uint32_t r = randi32();
       const uint32_t rabs = r&LMASK;
       const int idx = (int)(r&0xFF);
       const double x = ((int32_t)r) * wi[idx];
       if (rabs < ki[idx])
 #endif /* ALLBITS */
-	return x;        /* 99.3% of the time we return here 1st try */
+        return x;        /* 99.3% of the time we return here 1st try */
       else if (idx == 0)
-	{
-	  /* As stated in Marsaglia and Tsang
-	   * 
-	   * For the normal tail, the method of Marsaglia[5] provides:
-	   * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
-	   * then return r+x. Except that r+x is always in the positive 
-	   * tail!!!! Any thing random might be used to determine the
-	   * sign, but as we already have r we might as well use it
-	   *
-	   * [PAK] but not the bottom 8 bits, since they are all 0 here!
-	   */
-	  double xx, yy;
-	  do
-	    {
-	      xx = - ZIGGURAT_NOR_INV_R * log (RANDU);
-	      yy = - log (RANDU);
-	    } 
-	  while ( yy+yy <= xx*xx);
-	  return (rabs&0x100 ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
-	}
+        {
+          /* As stated in Marsaglia and Tsang
+           * 
+           * For the normal tail, the method of Marsaglia[5] provides:
+           * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
+           * then return r+x. Except that r+x is always in the positive 
+           * tail!!!! Any thing random might be used to determine the
+           * sign, but as we already have r we might as well use it
+           *
+           * [PAK] but not the bottom 8 bits, since they are all 0 here!
+           */
+          double xx, yy;
+          do
+            {
+              xx = - ZIGGURAT_NOR_INV_R * log (RANDU);
+              yy = - log (RANDU);
+            } 
+          while ( yy+yy <= xx*xx);
+          return (rabs&0x100 ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
+        }
       else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp(-0.5*x*x))
-	return x;
+        return x;
     }
 }
 
 double
 oct_rande (void)
 {
   if (initt) 
     create_ziggurat_tables();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const double x = ri * we[idx];
       if (ri < ke[idx])
-	return x;		// 98.9% of the time we return here 1st try
+        return x;               // 98.9% of the time we return here 1st try
       else if (idx == 0)
-	{
-	  /* As stated in Marsaglia and Tsang
-	   * 
-	   * For the exponential tail, the method of Marsaglia[5] provides:
+        {
+          /* As stated in Marsaglia and Tsang
+           * 
+           * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
-	   */
-	  return ZIGGURAT_EXP_R - log(RANDU);
-	}
+           */
+          return ZIGGURAT_EXP_R - log(RANDU);
+        }
       else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp(-x))
-	return x;
+        return x;
     }
 }
 
 /* Array generators */
 void 
 oct_fill_randu (octave_idx_type n, double *p)
 {
   octave_idx_type i;
diff --git a/liboctave/randpoisson.c b/liboctave/randpoisson.c
--- a/liboctave/randpoisson.c
+++ b/liboctave/randpoisson.c
@@ -207,90 +207,90 @@ pprsc (double my)
       p6 = f5 / lr         + p5;                       /* exp. tail right*/
     }
   
   for (;;)
     {
       /* generate uniform number U -- U(0, p6)                           */
       /* case distinction corresponding to U                             */
       if ((U = RUNI * p6) < p2)
-	{                                            /* centre left      */
-	  
-	  /* immediate acceptance region 
-	     R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
-	  if ((V = U - p1) < 0.0)  return(k2 + floor(U/f2));
-	  /* immediate acceptance region 
-	     R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
-	  if ((W = V / dl) < f1 )  return(k1 + floor(V/f1));
-	  
-	  /* computation of candidate X < k2, and its counterpart Y > k2 */
-	  /* either squeeze-acceptance of X or acceptance-rejection of Y */
-	  Dk = floor(dl * RUNI) + 1.0;
-	  if (W <= f2 - Dk * (f2 - f2/r2))
-	    {                                        /* quick accept of  */
-	      return(k2 - Dk);                       /* X = k2 - Dk      */
-	    }
-	  if ((V = f2 + f2 - W) < 1.0)
-	    {                                        /* quick reject of Y*/
-	      Y = k2 + Dk;
-	      if (V <= f2 + Dk * (1.0 - f2)/(dl + 1.0))
-		{                                    /* quick accept of  */
-		  return(Y);                         /* Y = k2 + Dk      */
-		}
-	      if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
-	    }
-	  X = k2 - Dk;
-	}
+        {                                            /* centre left      */
+          
+          /* immediate acceptance region 
+             R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
+          if ((V = U - p1) < 0.0)  return(k2 + floor(U/f2));
+          /* immediate acceptance region 
+             R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
+          if ((W = V / dl) < f1 )  return(k1 + floor(V/f1));
+          
+          /* computation of candidate X < k2, and its counterpart Y > k2 */
+          /* either squeeze-acceptance of X or acceptance-rejection of Y */
+          Dk = floor(dl * RUNI) + 1.0;
+          if (W <= f2 - Dk * (f2 - f2/r2))
+            {                                        /* quick accept of  */
+              return(k2 - Dk);                       /* X = k2 - Dk      */
+            }
+          if ((V = f2 + f2 - W) < 1.0)
+            {                                        /* quick reject of Y*/
+              Y = k2 + Dk;
+              if (V <= f2 + Dk * (1.0 - f2)/(dl + 1.0))
+                {                                    /* quick accept of  */
+                  return(Y);                         /* Y = k2 + Dk      */
+                }
+              if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
+            }
+          X = k2 - Dk;
+        }
       else if (U < p4)
-	{                                            /* centre right     */
-	  /*  immediate acceptance region 
-	      R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
-	  if ((V = U - p3) < 0.0)  return(k4 - floor((U - p2)/f4));
-	  /* immediate acceptance region 
-	     R4 = [k4+1, k5+1)*[0, f5)                */
-	  if ((W = V / dr) < f5 )  return(k5 - floor(V/f5));
-	  
-	  /* computation of candidate X > k4, and its counterpart Y < k4 */
-	  /* either squeeze-acceptance of X or acceptance-rejection of Y */
-	  Dk = floor(dr * RUNI) + 1.0;
-	  if (W <= f4 - Dk * (f4 - f4*r4))
-	    {                                        /* quick accept of  */
-	      return(k4 + Dk);                       /* X = k4 + Dk      */
-	    }
-	  if ((V = f4 + f4 - W) < 1.0)
-	    {                                        /* quick reject of Y*/
-	      Y = k4 - Dk;
-	      if (V <= f4 + Dk * (1.0 - f4)/ dr)
-		{                                    /* quick accept of  */
-		  return(Y);                         /* Y = k4 - Dk      */
-		}
-	      if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
-	    }
-	  X = k4 + Dk;
-	}
+        {                                            /* centre right     */
+          /*  immediate acceptance region 
+              R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
+          if ((V = U - p3) < 0.0)  return(k4 - floor((U - p2)/f4));
+          /* immediate acceptance region 
+             R4 = [k4+1, k5+1)*[0, f5)                */
+          if ((W = V / dr) < f5 )  return(k5 - floor(V/f5));
+          
+          /* computation of candidate X > k4, and its counterpart Y < k4 */
+          /* either squeeze-acceptance of X or acceptance-rejection of Y */
+          Dk = floor(dr * RUNI) + 1.0;
+          if (W <= f4 - Dk * (f4 - f4*r4))
+            {                                        /* quick accept of  */
+              return(k4 + Dk);                       /* X = k4 + Dk      */
+            }
+          if ((V = f4 + f4 - W) < 1.0)
+            {                                        /* quick reject of Y*/
+              Y = k4 - Dk;
+              if (V <= f4 + Dk * (1.0 - f4)/ dr)
+                {                                    /* quick accept of  */
+                  return(Y);                         /* Y = k4 - Dk      */
+                }
+              if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
+            }
+          X = k4 + Dk;
+        }
       else
-	{
-	  W = RUNI;
-	  if (U < p5)
-	    {                                        /* expon. tail left */
-	      Dk = floor(1.0 - log(W)/ll);
-	      if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
-	      W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
-	      if (W <= f1 - Dk * (f1 - f1/r1))  
-		return(X);                           /* quick accept of X*/
-	    }
-	  else
-	    {                                        /* expon. tail right*/
-	      Dk = floor(1.0 - log(W)/lr);
-	      X  = k5 + Dk;                          /* X >= k5 + 1      */
-	      W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
-	      if (W <= f5 - Dk * (f5 - f5*r5))  
-		return(X);                           /* quick accept of X*/
-	    }
-	}
+        {
+          W = RUNI;
+          if (U < p5)
+            {                                        /* expon. tail left */
+              Dk = floor(1.0 - log(W)/ll);
+              if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
+              W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
+              if (W <= f1 - Dk * (f1 - f1/r1))  
+                return(X);                           /* quick accept of X*/
+            }
+          else
+            {                                        /* expon. tail right*/
+              Dk = floor(1.0 - log(W)/lr);
+              X  = k5 + Dk;                          /* X >= k5 + 1      */
+              W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
+              if (W <= f5 - Dk * (f5 - f5*r5))  
+                return(X);                           /* quick accept of X*/
+            }
+        }
       
       /* acceptance-rejection test of candidate X from the original area */
       /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
       /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
       if (log(W) <= X * l_my - flogfak(X) - c_pm)  return(X);
     }
 }
 /* ---- pprsc.c end ------ */
@@ -376,22 +376,22 @@ poisson_rejection (double lambda, double
   double alxm = log(lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
   
   for (i = 0; i < n; i++) 
     {
       double y, em, t;
       do {
-	do {
-	  y = tan(M_PI*RUNI);
-	  em = sq * y + lambda;
-	} while (em < 0.0);
-	em = floor(em);
-	t = 0.9*(1.0+y*y)*exp(em*alxm-flogfak(em)-g);
+        do {
+          y = tan(M_PI*RUNI);
+          em = sq * y + lambda;
+        } while (em < 0.0);
+        em = floor(em);
+        t = 0.9*(1.0+y*y)*exp(em*alxm-flogfak(em)-g);
       } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* The cutoff of L <= 1e8 in the following two functions before using 
  * the normal approximation is based on:
  *   > L=1e8; x=floor(linspace(0,2*L,1000));
@@ -404,37 +404,37 @@ poisson_rejection (double lambda, double
 /* Generate a set of poisson numbers with the same distribution */
 void 
 oct_fill_randp (double L, octave_idx_type n, double *p)
 {
   octave_idx_type i;
   if (L < 0.0 || INFINITE(L)) 
     {
       for (i=0; i<n; i++) 
-	p[i] = NAN;
+        p[i] = NAN;
     } 
   else if (L <= 10.0) 
     {
       poisson_cdf_lookup(L, p, n);
     } 
   else if (L <= 1e8) 
     {
       for (i=0; i<n; i++) 
-	p[i] = pprsc(L);
+        p[i] = pprsc(L);
     } 
   else 
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
       const double sqrtL = sqrt(L);
       for (i = 0; i < n; i++) 
-	{
-	  p[i] = floor(RNOR*sqrtL + L + 0.5);
-	  if (p[i] < 0.0) 
-	    p[i] = 0.0; /* will probably never happen */
-	}
+        {
+          p[i] = floor(RNOR*sqrtL + L + 0.5);
+          if (p[i] < 0.0) 
+            p[i] = 0.0; /* will probably never happen */
+        }
     }
 }
 
 /* Generate one poisson variate */
 double 
 oct_randp (double L)
 {
   double ret;
diff --git a/liboctave/sparse-mk-ops.awk b/liboctave/sparse-mk-ops.awk
--- a/liboctave/sparse-mk-ops.awk
+++ b/liboctave/sparse-mk-ops.awk
@@ -60,194 +60,194 @@ BEGIN {
   else if (generate_ops)
     {
       if (NF >= 5)
         {
           result_tag_1 = $1;
           result_tag_2 = $2;
           lhs_tag = $3;
           rhs_tag = $4;
-	  op_type = $5;
+          op_type = $5;
 
-	  bin_ops = index (op_type, "B") != 0;
-	  cmp_ops = index (op_type, "C") != 0;
-	  eqne_ops = index (op_type, "E") != 0;
-	  bool_ops = index (op_type, "L") != 0;
+          bin_ops = index (op_type, "B") != 0;
+          cmp_ops = index (op_type, "C") != 0;
+          eqne_ops = index (op_type, "E") != 0;
+          bool_ops = index (op_type, "L") != 0;
 
           n = 5;
 
           lhs_conv = cmp_ops ? $(++n) : "";
           rhs_conv = cmp_ops ? $(++n) : "";
 
-	  if (lhs_conv == "NONE")
-	    lhs_conv = "";
+          if (lhs_conv == "NONE")
+            lhs_conv = "";
 
-	  if (rhs_conv == "NONE")
-	    rhs_conv = "";
+          if (rhs_conv == "NONE")
+            rhs_conv = "";
 
-	  k = 0
-	  while (NF > n)
-	    bool_headers[k++] = $(++n);
+          k = 0
+          while (NF > n)
+            bool_headers[k++] = $(++n);
 
-	  cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
-	  h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
+          cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
+          h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
 
-	  if (list_cc_files)
-	    {
-	      print cc_file;
-	      next;
-	    }
+          if (list_cc_files)
+            {
+              print cc_file;
+              next;
+            }
 
-	  if (list_h_files)
-	    {
-	      print h_file;
-	      next;
-	    }
+          if (list_h_files)
+            {
+              print h_file;
+              next;
+            }
 
-	  if (make_inclusive_header)
-	    {
+          if (make_inclusive_header)
+            {
               printf ("#include \"%s\"\n", h_file);
               next;
             }
 
-	  h_guard = sprintf ("octave_%s_%s_%s_h", prefix, lhs_tag, rhs_tag);
+          h_guard = sprintf ("octave_%s_%s_%s_h", prefix, lhs_tag, rhs_tag);
 
-	  result_num_1 = rev_tag[result_tag_1];
-	  result_num_2 = rev_tag[result_tag_2];
-	  lhs_num = rev_tag[lhs_tag];
-	  rhs_num = rev_tag[rhs_tag];
+          result_num_1 = rev_tag[result_tag_1];
+          result_num_2 = rev_tag[result_tag_2];
+          lhs_num = rev_tag[lhs_tag];
+          rhs_num = rev_tag[rhs_tag];
 
-	  result_type_1 = type[result_num_1];
-	  result_type_2 = type[result_num_2];
-	  lhs_type = type[lhs_num];
+          result_type_1 = type[result_num_1];
+          result_type_2 = type[result_num_2];
+          lhs_type = type[lhs_num];
           rhs_type = type[rhs_num];
 
-	  result_scalar_zero_val_1 = scalar_zero_val[result_num_1];
-	  result_scalar_zero_val_2 = scalar_zero_val[result_num_2];
+          result_scalar_zero_val_1 = scalar_zero_val[result_num_1];
+          result_scalar_zero_val_2 = scalar_zero_val[result_num_2];
           lhs_scalar_zero_val = scalar_zero_val[lhs_num];
           rhs_scalar_zero_val = scalar_zero_val[rhs_num];
 
-	  result_header_1 = header[result_num_1];
-	  result_header_2 = header[result_num_2];
-	  lhs_header = header[lhs_num];
+          result_header_1 = header[result_num_1];
+          result_header_2 = header[result_num_2];
+          lhs_header = header[lhs_num];
           rhs_header = header[rhs_num];
 
-	  lhs_class = class[lhs_num];
-	  rhs_class = class[rhs_num];
+          lhs_class = class[lhs_num];
+          rhs_class = class[rhs_num];
 
-	  print "// DO NOT EDIT -- generated by sparse-mk-ops" > h_file;
+          print "// DO NOT EDIT -- generated by sparse-mk-ops" > h_file;
 
-	  printf ("#if !defined (%s)\n", h_guard) >> h_file;
-	  printf ("#define %s 1\n", h_guard) >> h_file;
+          printf ("#if !defined (%s)\n", h_guard) >> h_file;
+          printf ("#define %s 1\n", h_guard) >> h_file;
 
           if (result_header_1)
-	    {
-	      if (result_fwd_decl_ok)
-	        printf ("class %s\n", result_type_1) >> h_file;
-	      else
-	        printf ("#include \"%s\"\n", result_header_1) >> h_file;
-	    }
+            {
+              if (result_fwd_decl_ok)
+                printf ("class %s\n", result_type_1) >> h_file;
+              else
+                printf ("#include \"%s\"\n", result_header_1) >> h_file;
+            }
 
           if (result_header_2 && ! (result_header_2 == result_header_1))
-	    {
-	      if (result_fwd_decl_ok)
-	        printf ("class %s\n", result_type_2) >> h_file;
-	      else
-	        printf ("#include \"%s\"\n", result_header_2) >> h_file;
-	    }
+            {
+              if (result_fwd_decl_ok)
+                printf ("class %s\n", result_type_2) >> h_file;
+              else
+                printf ("#include \"%s\"\n", result_header_2) >> h_file;
+            }
 
           if (lhs_header && ! (lhs_header == result_header_1 || lhs_header == result_header_2))
-	    {
-	      if (result_fwd_decl_ok)
-	        printf ("class %s\n", lhs_type) >> h_file;
-	      else
-	        printf ("#include \"%s\"\n", lhs_header) >> h_file;
-	    }
+            {
+              if (result_fwd_decl_ok)
+                printf ("class %s\n", lhs_type) >> h_file;
+              else
+                printf ("#include \"%s\"\n", lhs_header) >> h_file;
+            }
 
           if (rhs_header && ! (rhs_header == lhs_header || rhs_header == result_header_1 || rhs_header == result_header_2))
-	    {
-	      if (result_fwd_decl_ok)
-	        printf ("class %s\n", rhs_type) >> h_file;
-	      else
-	        printf ("#include \"%s\"\n", rhs_header) >> h_file;
-	    }
+            {
+              if (result_fwd_decl_ok)
+                printf ("class %s\n", rhs_type) >> h_file;
+              else
+                printf ("#include \"%s\"\n", rhs_header) >> h_file;
+            }
 
           printf ("#include \"Sparse-op-defs.h\"\n") >> h_file;
 
           if (bin_ops)
             printf ("SPARSE_%s%s_BIN_OP_DECLS (%s, %s, %s, %s, OCTAVE_API)\n", lhs_class,
-		    rhs_class, result_type_1, result_type_2, lhs_type, 
-		    rhs_type) >> h_file
+                    rhs_class, result_type_1, result_type_2, lhs_type, 
+                    rhs_type) >> h_file
 
           if (cmp_ops)
             printf ("SPARSE_%s%s_CMP_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
-		    rhs_class, lhs_type, rhs_type) >> h_file
+                    rhs_class, lhs_type, rhs_type) >> h_file
 
           if (eqne_ops)
             printf ("SPARSE_%s%s_EQNE_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
-		    rhs_class, lhs_type, rhs_type) >> h_file
+                    rhs_class, lhs_type, rhs_type) >> h_file
 
           if (bool_ops)
             printf ("SPARSE_%s%s_BOOL_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
-		    rhs_class, lhs_type, rhs_type) >> h_file
+                    rhs_class, lhs_type, rhs_type) >> h_file
 
 
           print "#endif" >> h_file;
 
-	  close (h_file);
+          close (h_file);
 
 
-	  print "// DO NOT EDIT -- generated by sparse-mk-ops" > cc_file;
+          print "// DO NOT EDIT -- generated by sparse-mk-ops" > cc_file;
 
-	  ## print "#ifdef HAVE_CONFIG_H" >> cc_file;
-	  print "#include <config.h>" >> cc_file;
-	  ## print "#endif" >> cc_file;
+          ## print "#ifdef HAVE_CONFIG_H" >> cc_file;
+          print "#include <config.h>" >> cc_file;
+          ## print "#endif" >> cc_file;
 
-	  print "#include \"Array-util.h\"" >> cc_file;
-	  print "#include \"quit.h\"" >> cc_file;
+          print "#include \"Array-util.h\"" >> cc_file;
+          print "#include \"quit.h\"" >> cc_file;
 
-	  printf ("#include \"%s\"\n", h_file) >> cc_file;
+          printf ("#include \"%s\"\n", h_file) >> cc_file;
 
-	  for (i in bool_headers)
-	    {
-	      printf ("#include \"%s\"\n", bool_headers[i]) >> cc_file;
-	      delete bool_headers[i];
-	    }
+          for (i in bool_headers)
+            {
+              printf ("#include \"%s\"\n", bool_headers[i]) >> cc_file;
+              delete bool_headers[i];
+            }
 
           if (result_header_1)
-	    printf ("#include \"%s\"\n", result_header_1) >> cc_file;
+            printf ("#include \"%s\"\n", result_header_1) >> cc_file;
 
           if (result_header_2 && ! (result_header_2 == result_header_1))
-	    printf ("#include \"%s\"\n", result_header_2) >> cc_file;
+            printf ("#include \"%s\"\n", result_header_2) >> cc_file;
 
           if (lhs_header && ! (lhs_header == result_header_1 || lhs_header == result_header_2))
-	    printf ("#include \"%s\"\n", lhs_header) >> cc_file;
+            printf ("#include \"%s\"\n", lhs_header) >> cc_file;
 
           if (rhs_header && ! (rhs_header == lhs_header || rhs_header == result_header_1 || rhs_heaer == result_header_2))
-	    printf ("#include \"%s\"\n", rhs_header) >> cc_file;
+            printf ("#include \"%s\"\n", rhs_header) >> cc_file;
 
-	  if (bin_ops)
+          if (bin_ops)
             printf ("SPARSE_%s%s_BIN_OPS (%s, %s, %s, %s)\n", lhs_class, 
-		    rhs_class, result_type_1, result_type_2, lhs_type, 
-		    rhs_type) >> cc_file
+                    rhs_class, result_type_1, result_type_2, lhs_type, 
+                    rhs_type) >> cc_file
 
           if (cmp_ops)
             printf ("SPARSE_%s%s_CMP_OPS (%s, %s, %s, %s, %s, %s)\n", 
-		    lhs_class, rhs_class, lhs_type, lhs_scalar_zero_val,
-		    lhs_conv, rhs_type, rhs_scalar_zero_val, rhs_conv) >> cc_file
+                    lhs_class, rhs_class, lhs_type, lhs_scalar_zero_val,
+                    lhs_conv, rhs_type, rhs_scalar_zero_val, rhs_conv) >> cc_file
 
           if (eqne_ops)
             printf ("SPARSE_%s%s_EQNE_OPS (%s, %s, %s, %s, %s, %s)\n", 
-		    lhs_class, rhs_class, lhs_type, lhs_scalar_zero_val,
-		    lhs_conv, rhs_type, rhs_scalar_zero_val, rhs_conv) >> cc_file
+                    lhs_class, rhs_class, lhs_type, lhs_scalar_zero_val,
+                    lhs_conv, rhs_type, rhs_scalar_zero_val, rhs_conv) >> cc_file
 
           if (bool_ops)
             printf ("SPARSE_%s%s_BOOL_OPS2 (%s, %s, %s, %s)\n", lhs_class, 
-		    rhs_class, lhs_type, rhs_type, lhs_scalar_zero_val,
-	            rhs_scalar_zero_val) >> cc_file
+                    rhs_class, lhs_type, rhs_type, lhs_scalar_zero_val,
+                    rhs_scalar_zero_val) >> cc_file
 
 
           close (cc_file);
         }
       else
         printf ("skipping line %d: %s\n", NR, $0); 
     }
 }
diff --git a/liboctave/tempnam.c b/liboctave/tempnam.c
--- a/liboctave/tempnam.c
+++ b/liboctave/tempnam.c
@@ -23,18 +23,18 @@ Fifth Floor, Boston, MA  02110-1301, USA
 #ifndef HAVE_TEMPNAM
 
 #include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 extern char *__stdio_gen_tempname (const char *dir, const char *pfx,
-				   int dir_search, size_t *lenptr,
-				   FILE **streamptr);
+                                   int dir_search, size_t *lenptr,
+                                   FILE **streamptr);
 
 /* Generate a unique temporary filename using up to five characters of PFX
    if it is not NULL.  The directory to put this file in is searched for
    as follows: First the environment variable "TMPDIR" is checked.
    If it contains the name of a writable directory, that directory is used.
    If not and if DIR is not NULL, that value is checked.  If that fails,
    P_tmpdir is tried and finally "/tmp".  The storage for the filename
    is allocated by `malloc'.  */
diff --git a/liboctave/tempname.c b/liboctave/tempname.c
--- a/liboctave/tempname.c
+++ b/liboctave/tempname.c
@@ -62,20 +62,20 @@ exists (const char *file)
   /* We can stat the file even if we can't read its data.  */
   struct stat st;
   int save = errno;
   if (stat (file, &st) == 0)
     return 1;
   else
     {
       /* We report that the file exists if stat failed for a reason other
-	 than nonexistence.  In this case, it may or may not exist, and we
-	 don't know; but reporting that it does exist will never cause any
-	 trouble, while reporting that it doesn't exist when it does would
-	 violate the interface of __stdio_gen_tempname.  */
+         than nonexistence.  In this case, it may or may not exist, and we
+         don't know; but reporting that it does exist will never cause any
+         trouble, while reporting that it doesn't exist when it does would
+         violate the interface of __stdio_gen_tempname.  */
       int exists = errno != ENOENT;
       errno = save;
       return exists;
     }
 }
 
 
 /* These are the characters used in temporary filenames.  */
@@ -93,115 +93,115 @@ static const char letters[] =
    of the characters in `letters'.  Data for tempnam and tmpnam is kept
    separate, but when tempnam is using P_tmpdir and no prefix (i.e, it is
    identical to tmpnam), the same data is used.  Each potential filename is
    tested for an already-existing file of the same name, and no name of an
    existing file will be returned.  When the cycle reaches its end
    (12345ZZZ), NULL is returned.  */
 char *
 __stdio_gen_tempname (const char *dir, const char *pfx,
-		      int dir_search, size_t *lenptr,
-		      FILE **streamptr)
+                      int dir_search, size_t *lenptr,
+                      FILE **streamptr)
 {
   int saverrno = errno;
   static const char tmpdir[] = P_tmpdir;
   static size_t indices[2];
   size_t *idx;
   static char buf[FILENAME_MAX];
   static pid_t oldpid = (pid_t) 0;
   pid_t pid = getpid();
   register size_t len, plen, dlen;
 
   if (dir_search)
     {
       register const char *d = getenv("TMPDIR");
       if (d != NULL && !diraccess(d))
-	d = NULL;
+        d = NULL;
       if (d == NULL && dir != NULL && diraccess(dir))
-	d = dir;
+        d = dir;
       if (d == NULL && diraccess(tmpdir))
-	d = tmpdir;
+        d = tmpdir;
       if (d == NULL && diraccess("/tmp"))
-	d = "/tmp";
+        d = "/tmp";
       if (d == NULL)
-	{
-	  errno = ENOENT;
-	  return NULL;
-	}
+        {
+          errno = ENOENT;
+          return NULL;
+        }
       dir = d;
     }
   else
     dir = tmpdir;
 
   dlen = strlen (dir);
 
   /* Remove trailing slashes from the directory name.  */
   while (dlen > 1 && dir[dlen - 1] == '/')
     --dlen;
 
   if (pfx != NULL && *pfx != '\0')
     {
       plen = strlen(pfx);
       if (plen > 5)
-	plen = 5;
+        plen = 5;
     }
   else
     plen = 0;
 
   if (dir != tmpdir && !strcmp(dir, tmpdir))
     dir = tmpdir;
   idx = &indices[(plen == 0 && dir == tmpdir) ? 1 : 0];
 
   if (pid != oldpid)
     {
       oldpid = pid;
       indices[0] = indices[1] = 0;
     }
 
   len = dlen + 1 + plen + 5 + 3;
   for (; *idx < ((sizeof (letters) - 1) * (sizeof (letters) - 1) *
-		 (sizeof (letters) - 1));
+                 (sizeof (letters) - 1));
        ++*idx)
     {
       /* Construct a file name and see if it already exists.
 
-	 We use a single counter in *IDX to cycle each of three
-	 character positions through each of 62 possible letters.  */
+         We use a single counter in *IDX to cycle each of three
+         character positions through each of 62 possible letters.  */
 
       if (sizeof (buf) < len)
-	return NULL;
+        return NULL;
 
       sprintf (buf, "%.*s/%.*s%.5d%c%c%c",
-	       (int) dlen, dir, (int) plen,
-	       pfx, pid % 100000,
-	       letters[*idx
-		       % (sizeof (letters) - 1)],
-	       letters[(*idx / (sizeof (letters) - 1))
-		       % (sizeof (letters) - 1)],
-	       letters[(*idx / ((sizeof (letters) - 1) *
-				(sizeof (letters) - 1)))
-		       % (sizeof (letters) - 1)]
-	       );
+               (int) dlen, dir, (int) plen,
+               pfx, pid % 100000,
+               letters[*idx
+                       % (sizeof (letters) - 1)],
+               letters[(*idx / (sizeof (letters) - 1))
+                       % (sizeof (letters) - 1)],
+               letters[(*idx / ((sizeof (letters) - 1) *
+                                (sizeof (letters) - 1)))
+                       % (sizeof (letters) - 1)]
+               );
 
       if (! buf || strlen (buf) != (int) len)
-	return NULL;
+        return NULL;
   
       if (streamptr != NULL)
-	abort ();
+        abort ();
       else if (exists (buf))
-	continue;
+        continue;
 
       /* If the file already existed we have continued the loop above,
-	 so we only get here when we have a winning name to return.  */
+         so we only get here when we have a winning name to return.  */
 
       errno = saverrno;
 
       if (lenptr != NULL)
-	*lenptr = len + 1;
+        *lenptr = len + 1;
       return buf;
     }
 
   /* We got out of the loop because we ran out of combinations to try.  */
-  errno = EEXIST;		/* ? */
+  errno = EEXIST;               /* ? */
   return NULL;
 }
 
 #endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,14 @@
+2010-02-11  John W. Eaton  <jwe@octave.org>
+
+	* DLD-FUNCTIONS/config-module.awk, genprops.awk, graphics.h.in,
+	mkgendoc, mk-pkg-add, mxarray.h.in, zfstream.cc, zfstream.h:
+	Untabify.
+
 2010-02-11  John W. Eaton  <jwe@octave.org>
 
 	* strfns.cc (Fstrcmpi, Fstrncmpi): Use DEFUNX instead of DEFUN.
 	(Fstrncmpi): Report strncmpi in error message, not strncmp.
 
 2010-02-11  John W. Eaton  <jwe@octave.org>
 
 	* Cell.cc, bitfcns.cc, c-file-ptr-stream.cc, comment-list.cc,
diff --git a/src/genprops.awk b/src/genprops.awk
--- a/src/genprops.awk
+++ b/src/genprops.awk
@@ -302,17 +302,17 @@ function emit_declarations ()
         emit_get_accessor(i, "std::string", "string_value");
       else if (type[i] == "string_array_property")
           emit_get_accessor(i, "octave_value", "get");
       else if (type[i] == "double_property")
         emit_get_accessor(i, "double", "double_value");
       else if (type[i] == "double_radio_property")
         emit_get_double_radio(i);
       else if (type[i] == "array_property" \
-	       || type[i] == "row_vector_property")
+               || type[i] == "row_vector_property")
         emit_get_array(i);
       else if (type[i] == "bool_property")
         emit_get_bool(i);
       else if (type[i] == "radio_property")
         emit_get_radio(i);
       else if (type[i] == "color_property")
         emit_get_color(i);
       else if (type[i] == "callback_property")
@@ -336,35 +336,35 @@ function emit_declarations ()
   for (i = 1; i <= idx; i++)
   {
     if (emit_set[i])
     {
       printf ("  void set_%s (const octave_value& val)", name[i], type[i]);
 
       if (emit_set[i] == "definition")
       {
-	if (updaters[i] || limits[i] || mode[i])
-	  has_builtin_listeners = 1;
-	else
-	  has_builtin_listeners = 0;
+        if (updaters[i] || limits[i] || mode[i])
+          has_builtin_listeners = 1;
+        else
+          has_builtin_listeners = 0;
 
         printf ("\n  {\n    if (! error_state)\n      {\n        if (%s.set (val, %s))\n          {\n",
           name[i], (has_builtin_listeners ? "false" : "true"));
         if (mode[i])
           printf ("            set_%smode (\"manual\");\n", name[i]);
         if (updater[i])
           printf ("            update_%s ();\n", name[i]);
         if (limits[i])
           printf ("            update_axis_limits (\"%s\");\n", name[i]);
-	if (has_builtin_listeners)
-	  printf ("            %s.run_listeners (POSTSET);\n", name[i]);
+        if (has_builtin_listeners)
+          printf ("            %s.run_listeners (POSTSET);\n", name[i]);
         printf ("            mark_modified ();\n");
-	printf ("          }\n");
-	if (mode[i])
-	  printf ("        else\n          set_%smode (\"manual\");\n", name[i]);
+        printf ("          }\n");
+        if (mode[i])
+          printf ("        else\n          set_%smode (\"manual\");\n", name[i]);
         printf ("      }\n  }\n\n");
       }
       else
         printf (";\n\n");
     }
 
     if (updater[i] == "extern")
     {
@@ -555,25 +555,25 @@ function emit_source ()
     }
 
     for (i = 1; i <= idx; i++)
     {
       if (factory[i])
       {
         dval = defval[i];
         if (type[i] == "radio_property" || type[i] == "color_property")
-      	{
-      	  k = index (dval, "{");
-	  dval = substr (dval, k+1);
-	  l = index (dval, "}");
-      	  if (k > 0 && l > 0)
-	    dval = "\"" substr (dval, 1, l-1) "\"";
-	  else
-	    dval = "octave_value ()";
-      	}
+        {
+          k = index (dval, "{");
+          dval = substr (dval, k+1);
+          l = index (dval, "}");
+          if (k > 0 && l > 0)
+            dval = "\"" substr (dval, 1, l-1) "\"";
+          else
+            dval = "octave_value ()";
+        }
 
         printf ("  m[\"%s\"] = %s%s;\n", name[i], dval,
                 (type[i] == "handle_property" || type[i] == "graphics_handle" ? ".as_octave_value ()" : ""));
       }
     }
 
     printf ("\n  return m;\n}\n\n");
 
@@ -599,17 +599,17 @@ function emit_source ()
     if (base)
       printf ("base_properties");
     else
       printf ("%s::properties", class_name);
     printf ("::has_core_property (const caseless_str& pname)\n{\n  std::set<std::string> pnames = core_property_names ();\n\n  return pnames.find (pname) != pnames.end ();\n}\n\n", class_name);
 
     printf ("std::set<std::string>\n");
     if (base)
-	printf ("base_properties");
+        printf ("base_properties");
     else
       printf ("%s::properties", class_name);
     printf ("::all_property_names (void) const\n{\n  static std::set<std::string> all_pnames = core_property_names ();\n\n");
     if (base)
       printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> dyn_props = dynamic_property_names ();\n  retval.insert (dyn_props.begin (), dyn_props.end ());\n  for (std::map<caseless_str, property, cmp_caseless_str>::const_iterator p = all_props.begin ();\n       p != all_props.end (); p++)\n    retval.insert (p->first);\n\n  return retval;\n}\n\n");
     else
       printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> base_props = base_properties::all_property_names ();\n  retval.insert (base_props.begin (), base_props.end ());\n\n  return retval;\n}\n\n");
 
@@ -731,35 +731,35 @@ BEGIN {
         if (index (quals, "s"))
           emit_set[idx] = "";
 
         ## There is a custom extern definition for the set function,
         ## but we still emit the declaration.
         if (index (quals, "S"))
           emit_set[idx] = "declaration";
         
-	## The property is hidden
-	if (index (quals, "h"))
-	  hidden[idx] = 1;
+        ## The property is hidden
+        if (index (quals, "h"))
+          hidden[idx] = 1;
 
-	## The property is read-only
-	if (index (quals, "r"))
-	  readonly[idx] = 1;
+        ## The property is read-only
+        if (index (quals, "r"))
+          readonly[idx] = 1;
 
         ## There is an inline updater method that should be called
         ## from the set method
         if (index (quals, "u"))
           updater[idx] = "inline";
         
-	## There is an extern updater method that should be called
+        ## There is an extern updater method that should be called
         ## from the set method
         if (index (quals, "U"))
           updater[idx] = "extern";
 
-	## There is not factory default value
+        ## There is not factory default value
         if (index (quals, "f"))
           factory[idx] = 0;
 
 ##        ## emmit an asignment set function
 ##        if (index (quals, "a"))
 ##          emit_ov_set[idx] = "assignment";
 ##
 ##        if (type[idx] != "octave_value")
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -74,21 +74,21 @@ public:
   {
     const_iterator p1 = begin ();
     const_iterator p2 = s.begin ();
 
     size_t k = 0;
 
     while (p1 != end () && p2 != s.end () && k++ < limit)
       {
-	if (std::tolower (*p1) != std::tolower (*p2))
-	  return false;
-
-	*p1++;
-	*p2++;
+        if (std::tolower (*p1) != std::tolower (*p2))
+          return false;
+
+        *p1++;
+        *p2++;
       }
 
     return (limit == std::string::npos) ? size () == s.size () : k == limit;
   }
 };
 
 // ---------------------------------------------------------------------
 
@@ -277,17 +277,17 @@ public:
 
   base_scaler* clone (void) const
     { return new log_scaler (); }
 
 private:
   void do_scale (const double *src, double *dest, int n) const
     {
       for (int i = 0; i < n; i++)
-	dest[i] = log10(src[i]);
+        dest[i] = log10(src[i]);
     }
 };
 
 class scaler
 {
 public:
   scaler (void) : rep (new base_scaler ()) { }
 
@@ -308,40 +308,40 @@ public:
     { return rep->unscale (d); }
 
   bool is_linear (void) const
     { return rep->is_linear (); }
 
   scaler& operator = (const scaler& s)
     {
       if (rep)
-	{
-	  delete rep;
-	  rep = 0;
-	}
+        {
+          delete rep;
+          rep = 0;
+        }
 
       rep = s.rep->clone ();
 
       return *this;
     }
 
   scaler& operator = (const std::string& s)
     {
       if (rep)
-	{
-	  delete rep;
-	  rep = 0;
-	}
+        {
+          delete rep;
+          rep = 0;
+        }
 
       if (s == "log")
-	rep = new log_scaler ();
+        rep = new log_scaler ();
       else if (s == "linear")
-	rep = new lin_scaler ();
+        rep = new lin_scaler ();
       else
-	rep = new base_scaler ();
+        rep = new base_scaler ();
 
       return *this;
     }
 
 private:
   base_scaler *rep;
 };
 
@@ -403,43 +403,43 @@ public:
 
   void add_listener (const octave_value& v, listener_mode mode = POSTSET)
     {
       octave_value_list& l = listeners[mode];
       l.resize (l.length () + 1, v);
     }
 
   void delete_listener (const octave_value& v = octave_value (), 
-			listener_mode mode = POSTSET)
+                        listener_mode mode = POSTSET)
     {
       octave_value_list& l = listeners[mode];
 
       if (v.is_defined ())
-	{
-	  bool found = false;
-	  int i;
-
-	  for (i = 0; i < l.length (); i++)
-	    {
-	      if (v.internal_rep () == l(i).internal_rep ())
-		{
-		  found = true;
-		  break;
-		}
-	    }
-	  if (found)
-	    {
-	      for (int j = i; j < l.length() - 1; j++)
-		l(j) = l (j + 1);
-
-	      l.resize (l.length () - 1);
-	    }
-	}
+        {
+          bool found = false;
+          int i;
+
+          for (i = 0; i < l.length (); i++)
+            {
+              if (v.internal_rep () == l(i).internal_rep ())
+                {
+                  found = true;
+                  break;
+                }
+            }
+          if (found)
+            {
+              for (int j = i; j < l.length() - 1; j++)
+                l(j) = l (j + 1);
+
+              l.resize (l.length () - 1);
+            }
+        }
       else
-	l.resize (0);
+        l.resize (0);
 
     }
 
   OCTINTERP_API void run_listeners (listener_mode mode = POSTSET);
 
   virtual base_property* clone (void) const
     { return new base_property (*this); }
 
@@ -488,25 +488,25 @@ public:
     }
 
   base_property* clone (void) const { return new string_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
     {
       if (val.is_string ())
-	{
-	  std::string new_str = val.string_value ();
-
-	  if (new_str != str)
-	    {
-	      str = new_str;
-	      return true;
-	    }
-	}
+        {
+          std::string new_str = val.string_value ();
+
+          if (new_str != str)
+            {
+              str = new_str;
+              return true;
+            }
+        }
       else
         error ("set: invalid string property value for \"%s\"",
                get_name ().c_str ());
       return false;
     }
 
 private:
   std::string str;
@@ -515,79 +515,79 @@ private:
 // ---------------------------------------------------------------------
 
 class string_array_property : public base_property
 {
 public:
   enum desired_enum { string_t, cell_t };
 
   string_array_property (const std::string& s, const graphics_handle& h,
-		  const std::string& val = "", const char& sep = '|', 
-		  const desired_enum& typ = string_t)
+                  const std::string& val = "", const char& sep = '|', 
+                  const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep)
     { 
       size_t pos = 0;
 
       while (true)
-	{
-	  size_t new_pos = val.find_first_of (separator, pos);
-
-	  if (new_pos == std::string::npos)
-	    {
-	      str.append (val.substr (pos));
-	      break;
-	    }
-	  else
-	    str.append (val.substr (pos, new_pos - pos));
-
-	  pos = new_pos + 1;
-	}
+        {
+          size_t new_pos = val.find_first_of (separator, pos);
+
+          if (new_pos == std::string::npos)
+            {
+              str.append (val.substr (pos));
+              break;
+            }
+          else
+            str.append (val.substr (pos, new_pos - pos));
+
+          pos = new_pos + 1;
+        }
     }
 
   string_array_property (const std::string& s, const graphics_handle& h, 
-		  const Cell& c, const char& sep = '|', 
-		  const desired_enum& typ = string_t)
+                  const Cell& c, const char& sep = '|', 
+                  const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep)
     { 
       if (c.is_cellstr ())
-	{
-	  string_vector strings (c.numel ());
-
-	  for (octave_idx_type i = 0; i < c.numel (); i++)
-	    strings (i) = c(i).string_value ();
-
-	  str = strings;
-	}
+        {
+          string_vector strings (c.numel ());
+
+          for (octave_idx_type i = 0; i < c.numel (); i++)
+            strings (i) = c(i).string_value ();
+
+          str = strings;
+        }
       else
         error ("set: invalid order property value for \"%s\"",
                get_name ().c_str ());
     }
 
   string_array_property (const string_array_property& p)
     : base_property (p), desired_type (p.desired_type),
       separator (p.separator), str (p.str) { }
 
   octave_value get (void) const
     { 
       if (desired_type == string_t)
-	return octave_value (string_value ());
+        return octave_value (string_value ());
       else
-	return octave_value (cell_value ());
+        return octave_value (cell_value ());
     }
 
   std::string string_value (void) const 
     { 
       std::string _str;
 
       for (octave_idx_type i = 0; i < str.length (); i++)
-	{
-	  _str += str(i);
-	  if (i != str.length() - 1)
-	    _str += separator;
-	}
+        {
+          _str += str(i);
+          if (i != str.length() - 1)
+            _str += separator;
+        }
 
       return _str;
     }
 
   Cell cell_value (void) const {return Cell (str);}
 
   string_array_property& operator = (const octave_value& val)
     {
@@ -596,75 +596,75 @@ public:
     }
 
   base_property* clone (void) const { return new string_array_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
     {
       if (val.is_string ())
-	{
-	  bool replace = false;
-	  std::string new_str = val.string_value ();
-	  string_vector strings;
-	  size_t pos = 0;
-
-	  while (pos != std::string::npos)
-	    {
-	      size_t new_pos = new_str.find_first_of (separator, pos);
-
-	      if (new_pos == std::string::npos)
-		{
-		  strings.append (new_str.substr (pos));
-		  break;
-		}
-	      else
-		strings.append (new_str.substr (pos, new_pos - pos));
-
-	      pos = new_pos + 1;
-	    }
-
-	  if (str.numel () == strings.numel ())
-	    {
-	      for (octave_idx_type i = 0; i < str.numel (); i++)
-		if (strings (i) != str(i))
-		  {
-		    replace = true;
-		    break;
-		  }
-	    }
-	  else
-	    replace = true;
-
-	  if (replace)
-	    {
-	      str = strings;
-	      return true;
-	    }
-	}
+        {
+          bool replace = false;
+          std::string new_str = val.string_value ();
+          string_vector strings;
+          size_t pos = 0;
+
+          while (pos != std::string::npos)
+            {
+              size_t new_pos = new_str.find_first_of (separator, pos);
+
+              if (new_pos == std::string::npos)
+                {
+                  strings.append (new_str.substr (pos));
+                  break;
+                }
+              else
+                strings.append (new_str.substr (pos, new_pos - pos));
+
+              pos = new_pos + 1;
+            }
+
+          if (str.numel () == strings.numel ())
+            {
+              for (octave_idx_type i = 0; i < str.numel (); i++)
+                if (strings (i) != str(i))
+                  {
+                    replace = true;
+                    break;
+                  }
+            }
+          else
+            replace = true;
+
+          if (replace)
+            {
+              str = strings;
+              return true;
+            }
+        }
       else if (val.is_cellstr ())
-	{
-	  bool replace = false;
-	  Cell new_cell = val.cell_value ();
-
-	  string_vector strings (new_cell.numel ());
-
-	  for (octave_idx_type i = 0; i < new_cell.numel (); i++)
-	    {
-	      strings (i) = new_cell(i).string_value ();
-	      if (strings (i) != str (i))
-		replace = true;
-	    }
-
-	  if (replace)
-	    {
-	      str = strings;
-	      return true;
-	    }
-	}
+        {
+          bool replace = false;
+          Cell new_cell = val.cell_value ();
+
+          string_vector strings (new_cell.numel ());
+
+          for (octave_idx_type i = 0; i < new_cell.numel (); i++)
+            {
+              strings (i) = new_cell(i).string_value ();
+              if (strings (i) != str (i))
+                replace = true;
+            }
+
+          if (replace)
+            {
+              str = strings;
+              return true;
+            }
+        }
       else
         error ("set: invalid string property value for \"%s\"",
                get_name ().c_str ());
       return false;
     }
 
 private:
   desired_enum desired_type;
@@ -681,33 +681,33 @@ public:
 
   radio_values (const radio_values& a)
     : default_val (a.default_val), possible_vals (a.possible_vals) { }
 
   radio_values& operator = (const radio_values& a)
   {
     if (&a != this)
       {
-	default_val = a.default_val;
-	possible_vals = a.possible_vals;
+        default_val = a.default_val;
+        possible_vals = a.possible_vals;
       }
 
     return *this;
   }
 
   std::string default_value (void) const { return default_val; }
 
   bool validate (const std::string& val)
   {
     bool retval = true;
 
     if (! contains (val))
       {
-	error ("invalid value = %s", val.c_str ());
-	retval = false;
+        error ("invalid value = %s", val.c_str ());
+        retval = false;
       }
 
     return retval;
   }
   
   bool contains (const std::string& val)
   {
     return (possible_vals.find (val) != possible_vals.end ());
@@ -757,28 +757,28 @@ public:
 
 protected:
   bool do_set (const octave_value& newval) 
   {
     if (newval.is_string ())
       {
         std::string s = newval.string_value ();
         if (vals.validate (s))
-	  {
-	    if (s != current_val)
-	      {
-		current_val = s;
-		return true;
-	      }
-	  }
+          {
+            if (s != current_val)
+              {
+                current_val = s;
+                return true;
+              }
+          }
         else
           error ("set: invalid value for radio property \"%s\" (value = %s)",
               get_name ().c_str (), s.c_str ());
       }
-    else	
+    else        
       error ("set: invalid value for radio property \"%s\"",
           get_name ().c_str ());
     return false;
   }
 
 private:
   radio_values vals;
   std::string current_val;
@@ -816,36 +816,36 @@ public:
       xrgb = c.xrgb;
 
     return *this;
   }
 
   bool operator == (const color_values& c) const
     {
       return (xrgb(0) == c.xrgb(0)
-	      && xrgb(1) == c.xrgb(1)
-	      && xrgb(2) == c.xrgb(2));
+              && xrgb(1) == c.xrgb(1)
+              && xrgb(2) == c.xrgb(2));
     }
 
   bool operator != (const color_values& c) const
     { return ! (*this == c); }
 
   Matrix rgb (void) const { return xrgb; }
 
   operator octave_value (void) const { return xrgb; }
 
   void validate (void) const
   {
     for (int i = 0; i < 3; i++)
       {
-	if (xrgb(i) < 0 ||  xrgb(i) > 1)
-	  {
-	    error ("invalid RGB color specification");
-	    break;
-	  }
+        if (xrgb(i) < 0 ||  xrgb(i) > 1)
+          {
+            error ("invalid RGB color specification");
+            break;
+          }
       }
   }
 
 private:
   Matrix xrgb;
 
   OCTINTERP_API bool str2rgb (std::string str);
 };
@@ -968,25 +968,25 @@ public:
     }
 
   base_property* clone (void) const { return new double_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
     {
       if (v.is_scalar_type () && v.is_real_type ())
-	{
-	  double new_val = v.double_value ();
-
-	  if (new_val != current_val)
-	    {
-	      current_val = new_val;
-	      return true;
-	    }
-	}
+        {
+          double new_val = v.double_value ();
+
+          if (new_val != current_val)
+            {
+              current_val = new_val;
+              return true;
+            }
+        }
       else
         error ("set: invalid value for double property \"%s\"",
                get_name ().c_str ());
       return false;
     }
 
 private:
   double current_val;
@@ -995,31 +995,31 @@ private:
 // ---------------------------------------------------------------------
 
 class double_radio_property : public base_property
 {
 public:
   double_radio_property (double d, const radio_values& v)
       : base_property ("", graphics_handle ()),
         current_type (double_t), dval (d), radio_val (v),
-	current_val (v.default_value ())
+        current_val (v.default_value ())
   { }
 
   double_radio_property (const std::string& nm, const graphics_handle& h,
-			 const std::string& v)
+                         const std::string& v)
       : base_property (nm, h),
         current_type (radio_t), dval (0), radio_val (v),
-	current_val (radio_val.default_value ())
+        current_val (radio_val.default_value ())
   { }
 
   double_radio_property (const std::string& nm, const graphics_handle& h,
-			 const double_radio_property& v)
+                         const double_radio_property& v)
       : base_property (nm, h),
         current_type (v.current_type), dval (v.dval),
-	radio_val (v.radio_val), current_val (v.current_val)
+        radio_val (v.radio_val), current_val (v.current_val)
   { }
 
   double_radio_property (const double_radio_property& p)
     : base_property (p), current_type (p.current_type),
       dval (p.dval), radio_val (p.radio_val),
       current_val (p.current_val) { }
 
   octave_value get (void) const
@@ -1137,27 +1137,27 @@ public:
       
       return p;
     }
 
 protected:
   bool do_set (const octave_value& v)
     {
       if (validate (v))
-	{
-	  // FIXME -- should we check for actual data change?
-	  if (! is_equal (v))
-	    {
-	      data = v;
-
-	      get_data_limits ();
-
-	      return true;
-	    }
-	}
+        {
+          // FIXME -- should we check for actual data change?
+          if (! is_equal (v))
+            {
+              data = v;
+
+              get_data_limits ();
+
+              return true;
+            }
+        }
       else
         error ("invalid value for array property \"%s\"",
                get_name ().c_str ());
       
       return false;
     }
 
 private:
@@ -1175,17 +1175,17 @@ protected:
   std::list<std::string> type_constraints;
   std::list<dim_vector> size_constraints;
 };
 
 class row_vector_property : public array_property
 {
 public:
   row_vector_property (const std::string& nm, const graphics_handle& h,
-		       const octave_value& m)
+                       const octave_value& m)
     : array_property (nm, h, m)
   {
     add_constraint (dim_vector (-1, 1));
     add_constraint (dim_vector (1, -1));
   }
 
   row_vector_property (const row_vector_property& p)
     : array_property (p)
@@ -1231,28 +1231,28 @@ public:
 
 protected:
   bool do_set (const octave_value& v)
   {
     bool retval = array_property::do_set (v);
 
     if (! error_state)
       {
-	dim_vector dv = data.dims ();
-
-	if (dv(0) > 1 && dv(1) == 1)
-	  {
-	    int tmp = dv(0);
-	    dv(0) = dv(1);
-	    dv(1) = tmp;
-
-	    data = data.reshape (dv);
-	  }
-
-	return retval;
+        dim_vector dv = data.dims ();
+
+        if (dv(0) > 1 && dv(1) == 1)
+          {
+            int tmp = dv(0);
+            dv(0) = dv(1);
+            dv(1) = tmp;
+
+            data = data.reshape (dv);
+          }
+
+        return retval;
       }
 
     return false;
   }
 
 private:
   OCTINTERP_API bool validate (const octave_value& v);
 };
@@ -1389,20 +1389,20 @@ public:
     }
 
   base_property* clone (void) const { return new callback_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
     {
       if (validate (v))
-	{
-	  callback = v;
-	  return true;
-	}
+        {
+          callback = v;
+          return true;
+        }
       else
         error ("invalid value for callback property \"%s\"",
                get_name ().c_str ());
       return false;
     }
 
 private:
   OCTINTERP_API bool validate (const octave_value& v) const;
@@ -1483,26 +1483,26 @@ public:
 
       return *this;
     }
 
   void add_listener (const octave_value& v, listener_mode mode = POSTSET)
     { rep->add_listener (v, mode); }
 
   void delete_listener (const octave_value& v = octave_value (), 
-			listener_mode mode = POSTSET)
+                        listener_mode mode = POSTSET)
   { rep->delete_listener (v, mode); }
 
   void run_listeners (listener_mode mode = POSTSET)
     { rep->run_listeners (mode); }
 
   OCTINTERP_API static
       property create (const std::string& name, const graphics_handle& parent,
-		       const caseless_str& type,
-		       const octave_value_list& args);
+                       const caseless_str& type,
+                       const octave_value_list& args);
 
   property clone (void) const
     { return property (rep->clone ()); }
 
   /*
   const string_property& as_string_property (void) const
     { return *(dynamic_cast<string_property*> (rep)); }
 
@@ -1590,18 +1590,18 @@ public:
   std::string get_name (void) const { return name; }
 
   virtual bool is_valid (void) const { return false; }
 
   virtual void redraw_figure (const graphics_object&) const
     { gripe_invalid ("redraw_figure"); }
 
   virtual void print_figure (const graphics_object&, const std::string&,
-			     const std::string&, bool,
-			     const std::string& = "") const
+                             const std::string&, bool,
+                             const std::string& = "") const
     { gripe_invalid ("print_figure"); }
 
   virtual Matrix get_canvas_size (const graphics_handle&) const
     {
       gripe_invalid ("get_canvas_size");
       return Matrix (1, 2, 0.0);
     }
 
@@ -1638,17 +1638,17 @@ public:
 private:
   std::string name;
   int count;
 
 private:
   void gripe_invalid (const std::string& fname) const
     {
       if (! is_valid ())
-	error ("%s: invalid graphics backend", fname.c_str ());
+        error ("%s: invalid graphics backend", fname.c_str ());
     }
 };
 
 class graphics_backend
 {
 public:
   graphics_backend (void)
       : rep (new base_graphics_backend ("unknown"))
@@ -1666,43 +1666,43 @@ public:
       : rep (b.rep)
     {
       rep->count++;
     }
 
   ~graphics_backend (void)
     {
       if (--rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
   graphics_backend& operator = (const graphics_backend& b)
     {
       if (rep != b.rep)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
-
-	  rep = b.rep;
-	  rep->count++;
-	}
+        {
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = b.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
   operator bool (void) const { return rep->is_valid (); }
 
   std::string get_name (void) const { return rep->get_name (); }
 
   void redraw_figure (const graphics_object& go) const
     { rep->redraw_figure (go); }
   
   void print_figure (const graphics_object& go, const std::string& term,
-		     const std::string& file, bool mono,
-		     const std::string& debug_file = "") const
+                     const std::string& file, bool mono,
+                     const std::string& debug_file = "") const
     { rep->print_figure (go, term, file, mono, debug_file); }
 
   Matrix get_canvas_size (const graphics_handle& fh) const
     { return rep->get_canvas_size (fh); }
 
   double get_screen_resolution (void) const
     { return rep->get_screen_resolution (); }
 
@@ -1843,20 +1843,20 @@ public:
   virtual graphics_backend get_backend (void) const;
 
   virtual Matrix get_boundingbox (bool /*internal*/ = false) const
     { return Matrix (1, 4, 0.0); }
 
   virtual void update_boundingbox (void);
 
   virtual void add_listener (const caseless_str&, const octave_value&,
-			     listener_mode = POSTSET);
+                             listener_mode = POSTSET);
 
   virtual void delete_listener (const caseless_str&, const octave_value&,
-				listener_mode = POSTSET);
+                                listener_mode = POSTSET);
 
   void set_tag (const octave_value& val) { tag = val; }
 
   void set_parent (const octave_value& val);
 
   Matrix get_all_children (void) const { return children; }
 
   Matrix get_hidden_children (void) const;
@@ -1942,20 +1942,20 @@ protected:
     handle_property uicontextmenu , graphics_handle ()
   END_PROPERTIES
 
 protected:
   struct cmp_caseless_str 
     {
       bool operator () (const caseless_str &a, const caseless_str &b) const
         {
-	  std::string a1 = a;
-	  std::transform (a1.begin (), a1.end (), a1.begin (), tolower);
-	  std::string b1 = b;
-	  std::transform (b1.begin (), b1.end (), b1.begin (), tolower);
+          std::string a1 = a;
+          std::transform (a1.begin (), a1.end (), a1.begin (), tolower);
+          std::string b1 = b;
+          std::transform (b1.begin (), b1.end (), b1.begin (), tolower);
 
           return a1 < b1;
         }
     };
 
   std::map<caseless_str, property, cmp_caseless_str> all_props;
 
 protected:
@@ -2141,35 +2141,35 @@ public:
   }
 
   virtual graphics_backend get_backend (void) const
   {
     if (valid_object ())
       return get_properties ().get_backend ();
     else
       {
-	error ("base_graphics_object::get_backend: invalid graphics object");
-	return graphics_backend ();
+        error ("base_graphics_object::get_backend: invalid graphics object");
+        return graphics_backend ();
       }
   }
 
   virtual void add_property_listener (const std::string& nm,
-				      const octave_value& v,
-				      listener_mode mode = POSTSET)
+                                      const octave_value& v,
+                                      listener_mode mode = POSTSET)
     {
       if (valid_object ())
-	get_properties ().add_listener (nm, v, mode);
+        get_properties ().add_listener (nm, v, mode);
     }
 
   virtual void delete_property_listener (const std::string& nm,
-					 const octave_value& v,
-					 listener_mode mode = POSTSET)
+                                         const octave_value& v,
+                                         listener_mode mode = POSTSET)
     {
       if (valid_object ())
-	get_properties ().delete_listener (nm, v, mode);
+        get_properties ().delete_listener (nm, v, mode);
     }
 
   virtual void remove_all_listeners (void);
 
 protected:
   // A reference count.
   int count;
 };
@@ -2187,21 +2187,21 @@ public:
     rep = obj.rep;
     rep->count++;
   }
 
   graphics_object& operator = (const graphics_object& obj)
   {
     if (rep != obj.rep)
       {
-	if (--rep->count == 0)
-	  delete rep;
-
-	rep = obj.rep;
-	rep->count++;
+        if (--rep->count == 0)
+          delete rep;
+
+        rep = obj.rep;
+        rep->count++;
       }
 
     return *this;
   }
 
   ~graphics_object (void)
   {
     if (--rep->count == 0)
@@ -2236,17 +2236,17 @@ public:
 
   octave_value get (bool all = false) const { return rep->get (all); }
 
   octave_value get (const caseless_str& name) const
   {
     return name.compare ("default")
       ? get_defaults ()
       : (name.compare ("factory")
-	 ? get_factory_defaults () : rep->get (name));
+         ? get_factory_defaults () : rep->get (name));
   }
 
   octave_value get (const std::string& name) const
   {
     return get (caseless_str (name));
   }
 
   octave_value get (const char *name) const
@@ -2339,21 +2339,21 @@ public:
   { return get_properties ().is_aliminclude (); }
 
   bool is_handle_visible (void) const
   { return get_properties ().is_handle_visible (); }
   
   graphics_backend get_backend (void) const { return rep->get_backend (); }
 
   void add_property_listener (const std::string& nm, const octave_value& v,
-			      listener_mode mode = POSTSET)
+                              listener_mode mode = POSTSET)
     { rep->add_property_listener (nm, v, mode); }
 
   void delete_property_listener (const std::string& nm, const octave_value& v,
-				 listener_mode mode = POSTSET)
+                                 listener_mode mode = POSTSET)
     { rep->delete_property_listener (nm, v, mode); }
 
 private:
   base_graphics_object *rep;
 };
 
 // ---------------------------------------------------------------------
 
@@ -2449,21 +2449,21 @@ public:
   }
 
   octave_value get_default (const caseless_str& name) const
   {
     octave_value retval = default_properties.lookup (name);
 
     if (retval.is_undefined ())
       {
-	// no default property found, use factory default
-	retval = factory_properties.lookup (name);
-
-	if (retval.is_undefined ())
-	  error ("get: invalid default property `%s'", name.c_str ());
+        // no default property found, use factory default
+        retval = factory_properties.lookup (name);
+
+        if (retval.is_undefined ())
+          error ("get: invalid default property `%s'", name.c_str ());
       }
 
     return retval;
   }
 
   octave_value get_factory_default (const caseless_str& name) const
   {
     octave_value retval = factory_properties.lookup (name);
@@ -2507,53 +2507,53 @@ public:
   {
   public:
     void remove_child (const graphics_handle& h);
 
     void set_visible (const octave_value& val);
 
     graphics_backend get_backend (void) const
       {
-	if (! backend)
-	  backend = graphics_backend::default_backend ();
-
-	return backend;
+        if (! backend)
+          backend = graphics_backend::default_backend ();
+
+        return backend;
       }
 
     void set_backend (const graphics_backend& b) 
     { 
       if (backend)
-	backend.object_destroyed (__myhandle__);
+        backend.object_destroyed (__myhandle__);
       backend = b; 
       __backend__ = b.get_name ();
       __plot_stream__ = Matrix ();
       mark_modified ();
     }
 
     void set___backend__ (const octave_value& val)
     {
       if (! error_state)
-	{
-	  if (val.is_string ())
-	    {
-	      std::string nm = val.string_value ();
-	      graphics_backend b = graphics_backend::find_backend (nm);
-	      if (b.get_name () != nm)
-		{
-		  error ("set___backend__: invalid backend");
-		}
-	      else
-		{
-		  set_backend (b);
-		  mark_modified ();
-		}
-	    }
-	  else
-	    error ("set___backend__ must be a string");
-	}
+        {
+          if (val.is_string ())
+            {
+              std::string nm = val.string_value ();
+              graphics_backend b = graphics_backend::find_backend (nm);
+              if (b.get_name () != nm)
+                {
+                  error ("set___backend__: invalid backend");
+                }
+              else
+                {
+                  set_backend (b);
+                  mark_modified ();
+                }
+            }
+          else
+            error ("set___backend__ must be a string");
+        }
     }
 
     Matrix get_boundingbox (bool internal = false) const;
 
     void set_boundingbox (const Matrix& bb);
 
     std::string get_title (void) const;
 
@@ -2613,21 +2613,21 @@ public:
       callback_property buttondownfcn , Matrix ()
       string_property __backend__ s , "gnuplot"
     END_PROPERTIES
     
   protected:
     void init (void)
       {
         colormap.add_constraint (dim_vector (-1, 3));
-	alphamap.add_constraint (dim_vector (-1, 1));
-	paperposition.add_constraint (dim_vector (1, 4));
-	pointershapecdata.add_constraint (dim_vector (16, 16));
-	pointershapehotspot.add_constraint (dim_vector (1, 2));
-	position.add_constraint (dim_vector (1, 4));
+        alphamap.add_constraint (dim_vector (-1, 1));
+        paperposition.add_constraint (dim_vector (1, 4));
+        pointershapecdata.add_constraint (dim_vector (16, 16));
+        pointershapehotspot.add_constraint (dim_vector (1, 2));
+        position.add_constraint (dim_vector (1, 4));
       }
 
   private:
     mutable graphics_backend backend;
   };
 
 private:
   properties xproperties;
@@ -2705,17 +2705,17 @@ class OCTINTERP_API graphics_xform
 public:
   graphics_xform (void)
       : xform (xform_eye ()), xform_inv (xform_eye ())
     {
       sx = sy = sz = "linear";
     }
 
   graphics_xform (const Matrix& xm, const Matrix& xim,
-		  const scaler& x, const scaler& y, const scaler& z)
+                  const scaler& x, const scaler& y, const scaler& z)
       : xform (xm), xform_inv (xim), sx (x), sy (y), sz (z) { }
 
   graphics_xform (const graphics_xform& g)
       : xform (g.xform), xform_inv (g.xform_inv), sx (g.sx),
         sy (g.sy), sz (g.sz) { }
 
   ~graphics_xform (void) { }
 
@@ -2730,44 +2730,44 @@ public:
       return *this;
     }
 
   static ColumnVector xform_vector (double x, double y, double z);
 
   static Matrix xform_eye (void);
 
   ColumnVector transform (double x, double y, double z,
-			  bool scale = true) const;
+                          bool scale = true) const;
   
   ColumnVector untransform (double x, double y, double z,
-			    bool scale = true) const;
+                            bool scale = true) const;
 
   Matrix xscale (const Matrix& m) const { return sx.scale (m); }
   Matrix yscale (const Matrix& m) const { return sy.scale (m); }
   Matrix zscale (const Matrix& m) const { return sz.scale (m); }
 
   Matrix scale (const Matrix& m) const
     {
       bool has_z = (m.columns () > 2);
 
       if (sx.is_linear () && sy.is_linear ()
-	  && (! has_z || sz.is_linear ()))
-	return m;
+          && (! has_z || sz.is_linear ()))
+        return m;
 
       Matrix retval (m.dims ());
 
       int r = m.rows ();
 
       for (int i = 0; i < r; i++)
-	{
-	  retval(i,0) = sx.scale (m(i,0));
-	  retval(i,1) = sy.scale (m(i,1));
-	  if (has_z)
-	    retval(i,2) = sz.scale (m(i,2));
-	}
+        {
+          retval(i,0) = sx.scale (m(i,0));
+          retval(i,1) = sy.scale (m(i,1));
+          if (has_z)
+            retval(i,2) = sz.scale (m(i,2));
+        }
 
       return retval;
     }
 
 private:
   Matrix xform;
   Matrix xform_inv;
   scaler sx, sy, sz;
@@ -2786,29 +2786,29 @@ public:
     const scaler& get_x_scaler (void) const { return sx; }
     const scaler& get_y_scaler (void) const { return sy; }
     const scaler& get_z_scaler (void) const { return sz; }
 
     Matrix get_boundingbox (bool internal = false) const;
 
     void update_boundingbox (void)
       {
-	if (units_is ("normalized"))
-	  {
-	    update_transform ();
-	    base_properties::update_boundingbox ();
-	  }
+        if (units_is ("normalized"))
+          {
+            update_transform ();
+            base_properties::update_boundingbox ();
+          }
       }
 
     void update_camera (void);
     void update_aspectratios (void);
     void update_transform (void)
       {
-	update_aspectratios ();
-	update_camera ();
+        update_aspectratios ();
+        update_camera ();
       }
 
     graphics_xform get_transform (void) const
       { return graphics_xform (x_render, x_render_inv, sx, sy, sz); }
 
     Matrix get_transform_matrix (void) const { return x_render; }
     Matrix get_inverse_transform_matrix (void) const { return x_render_inv; }
     Matrix get_opengl_matrix_1 (void) const { return x_gl_mat1; }
@@ -2831,17 +2831,17 @@ public:
   private:
     scaler sx, sy, sz;
     Matrix x_render, x_render_inv;
     Matrix x_gl_mat1, x_gl_mat2;
     Matrix x_zlim;
     std::list<octave_value> zoom_stack;
 
     void set_text_child (handle_property& h, const std::string& who,
-			 const octave_value& v);
+                         const octave_value& v);
 
     void delete_text_child (handle_property& h);
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     // properties which are not in matlab: interpreter
 
@@ -2957,108 +2957,108 @@ public:
     void update_view (void) { update_camera (); }
 
     void update_xdir (void) { update_camera (); }
     void update_ydir (void) { update_camera (); }
     void update_zdir (void) { update_camera (); }
 
     void update_xtick (void)
       {
-	if (xticklabelmode.is ("auto"))
-	  calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
+        if (xticklabelmode.is ("auto"))
+          calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
       }
     void update_ytick (void)
       {
-	if (yticklabelmode.is ("auto"))
-	  calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
+        if (yticklabelmode.is ("auto"))
+          calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
       }
     void update_ztick (void)
       {
-	if (zticklabelmode.is ("auto"))
-	  calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
+        if (zticklabelmode.is ("auto"))
+          calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
       }
 
     void update_xticklabelmode (void)
       {
-	if (xticklabelmode.is ("auto"))
-	  calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
+        if (xticklabelmode.is ("auto"))
+          calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
       }
     void update_yticklabelmode (void)
       {
-	if (yticklabelmode.is ("auto"))
-	  calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
+        if (yticklabelmode.is ("auto"))
+          calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
       }
     void update_zticklabelmode (void)
       {
-	if (zticklabelmode.is ("auto"))
-	  calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
+        if (zticklabelmode.is ("auto"))
+          calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
       }
 
     void sync_positions (void);
     void update_outerposition (void) { sync_positions ();}
     void update_position (void) { sync_positions (); }
 
     double calc_tick_sep (double minval, double maxval);
     void calc_ticks_and_lims (array_property& lims, array_property& ticks, bool limmode_is_auto, bool is_logscale);
     void calc_ticklabels (const array_property& ticks, any_property& labels, bool is_logscale);
     void fix_limits (array_property& lims)
     {
       if (lims.get ().is_empty ()) 
-	return;
+        return;
 
       Matrix l = lims.get ().matrix_value ();
       if (l(0) > l(1))
-	{
-	  l(0) = 0;
-	  l(1) = 1;
-	  lims = l;
-	}
+        {
+          l(0) = 0;
+          l(1) = 1;
+          lims = l;
+        }
       else if (l(0) == l(1))
-	{
-	  l(0) -= 0.5;
-	  l(1) += 0.5;
-	  lims = l;
-	}
+        {
+          l(0) -= 0.5;
+          l(1) += 0.5;
+          lims = l;
+        }
     }      
 
   public:
     Matrix get_axis_limits (double xmin, double xmax, double min_pos, bool logscale);
     
     void update_xlim (bool do_clr_zoom = true)
     {
       if (xtickmode.is ("auto"))
-	calc_ticks_and_lims (xlim, xtick, xlimmode.is ("auto"), xscale.is ("log"));
+        calc_ticks_and_lims (xlim, xtick, xlimmode.is ("auto"), xscale.is ("log"));
       if (xticklabelmode.is ("auto"))
-	calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
+        calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
 
       fix_limits (xlim);
 
       if (do_clr_zoom)
-	zoom_stack.clear ();
+        zoom_stack.clear ();
     }
 
     void update_ylim (bool do_clr_zoom = true)
     {
       if (ytickmode.is ("auto"))
-	calc_ticks_and_lims (ylim, ytick, ylimmode.is ("auto"), yscale.is ("log"));
+        calc_ticks_and_lims (ylim, ytick, ylimmode.is ("auto"), yscale.is ("log"));
       if (yticklabelmode.is ("auto"))
-	calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
+        calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
 
       fix_limits (ylim);
 
       if (do_clr_zoom)
-	zoom_stack.clear ();
+        zoom_stack.clear ();
     }
 
     void update_zlim (void)
     {
       if (ztickmode.is ("auto"))
-	calc_ticks_and_lims (zlim, ztick, zlimmode.is ("auto"), zscale.is ("log"));
+        calc_ticks_and_lims (zlim, ztick, zlimmode.is ("auto"), zscale.is ("log"));
       if (zticklabelmode.is ("auto"))
-	calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
+        calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
 
       fix_limits (zlim);
 
       zoom_stack.clear ();
     }
     
   };
 
@@ -3192,18 +3192,18 @@ public:
     void update_xudata (void) { set_xlim (compute_xlim ()); }
     
     void update_ydata (void) { set_ylim (compute_ylim ()); }
     void update_ldata (void) { set_ylim (compute_ylim ()); }
     void update_udata (void) { set_ylim (compute_ylim ()); }
 
     void update_zdata (void)
       {
-	set_zlim (zdata.get_limits ());
-	set_zliminclude (get_zdata ().numel () > 0);
+        set_zlim (zdata.get_limits ());
+        set_zliminclude (get_zdata ().numel () > 0);
       }
   };
 
 private:
   properties xproperties;
 
 public:
   line (const graphics_handle& mh, const graphics_handle& p)
@@ -3267,36 +3267,36 @@ public:
     void init (void)
       {
         position.add_constraint (dim_vector (1, 3));
       }
 
   private:
     void update_position (void)
       {
-	Matrix pos = get_position ().matrix_value ();
-	Matrix lim;
-
-	lim = Matrix (1, 3, pos(0));
-	lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
-	set_xlim (lim);
-
-	lim = Matrix (1, 3, pos(1));
-	lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
-	set_ylim (lim);
-
-	if (pos.numel () == 3)
-	  {
-	    lim = Matrix (1, 3, pos(2));
-	    lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
-	    set_zliminclude ("on");
-	    set_zlim (lim);
-	  }
-	else
-	  set_zliminclude ("off");
+        Matrix pos = get_position ().matrix_value ();
+        Matrix lim;
+
+        lim = Matrix (1, 3, pos(0));
+        lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
+        set_xlim (lim);
+
+        lim = Matrix (1, 3, pos(1));
+        lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
+        set_ylim (lim);
+
+        if (pos.numel () == 3)
+          {
+            lim = Matrix (1, 3, pos(2));
+            lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
+            set_zliminclude ("on");
+            set_zlim (lim);
+          }
+        else
+          set_zliminclude ("off");
       }
   };
 
 private:
   properties xproperties;
 
 public:
   text (const graphics_handle& mh, const graphics_handle& p)
@@ -3344,26 +3344,26 @@ public:
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property climinclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
-	xdata.add_constraint (2);
-	ydata.add_constraint (2);
-	cdata.add_constraint ("double");
-	cdata.add_constraint ("single");
-	cdata.add_constraint ("logical");
-	cdata.add_constraint ("uint8");
-	cdata.add_constraint ("uint16");
-	cdata.add_constraint ("int16");
-	cdata.add_constraint (dim_vector (-1, -1));
-	cdata.add_constraint (dim_vector (-1, -1, 3));
+        xdata.add_constraint (2);
+        ydata.add_constraint (2);
+        cdata.add_constraint ("double");
+        cdata.add_constraint ("single");
+        cdata.add_constraint ("logical");
+        cdata.add_constraint ("uint8");
+        cdata.add_constraint ("uint16");
+        cdata.add_constraint ("int16");
+        cdata.add_constraint (dim_vector (-1, -1));
+        cdata.add_constraint (dim_vector (-1, -1, 3));
       }
 
   private:
     void update_xdata (void)
     { 
       octave_idx_type iw = (get_cdata ().dims ())(1) - 1;
       Matrix limits = xdata.get_limits ();
       float dp = (limits(1) - limits(0))/(2*iw);
@@ -3381,20 +3381,20 @@ public:
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
       set_ylim (limits); 
     }
 
     void update_cdata (void)
       {
-	if (cdatamapping_is ("scaled"))
-	  set_clim (cdata.get_limits ());
-	else
-	  clim = cdata.get_limits ();
+        if (cdatamapping_is ("scaled"))
+          set_clim (cdata.get_limits ());
+        else
+          clim = cdata.get_limits ();
       }
   };
 
 private:
   properties xproperties;
 
 public:
   image (const graphics_handle& mh, const graphics_handle& p)
@@ -3480,39 +3480,39 @@ public:
       bool_property zliminclude hl , "on"
       bool_property climinclude hlg , "on"
       bool_property aliminclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
-	xdata.add_constraint (dim_vector (-1, -1));
-	ydata.add_constraint (dim_vector (-1, -1));
-	zdata.add_constraint (dim_vector (-1, -1));
+        xdata.add_constraint (dim_vector (-1, -1));
+        ydata.add_constraint (dim_vector (-1, -1));
+        zdata.add_constraint (dim_vector (-1, -1));
         vertices.add_constraint (dim_vector (-1, 2));
         vertices.add_constraint (dim_vector (-1, 3));
-	cdata.add_constraint (dim_vector (-1, -1));
-	cdata.add_constraint (dim_vector (-1, -1, 3));
-	facevertexcdata.add_constraint (dim_vector (-1, 1));
-	facevertexcdata.add_constraint (dim_vector (-1, 3));
-	facevertexalphadata.add_constraint (dim_vector (-1, 1));
+        cdata.add_constraint (dim_vector (-1, -1));
+        cdata.add_constraint (dim_vector (-1, -1, 3));
+        facevertexcdata.add_constraint (dim_vector (-1, 1));
+        facevertexcdata.add_constraint (dim_vector (-1, 3));
+        facevertexalphadata.add_constraint (dim_vector (-1, 1));
       }
 
   private:
     void update_xdata (void) { set_xlim (xdata.get_limits ()); }
     void update_ydata (void) { set_ylim (ydata.get_limits ()); }
     void update_zdata (void) { set_zlim (zdata.get_limits ()); }
     
     void update_cdata (void)
       {
-	if (cdatamapping_is ("scaled"))
-	  set_clim (cdata.get_limits ());
-	else
-	  clim = cdata.get_limits ();
+        if (cdatamapping_is ("scaled"))
+          set_clim (cdata.get_limits ());
+        else
+          clim = cdata.get_limits ();
       }
   };
 
 private:
   properties xproperties;
 
 public:
   patch (const graphics_handle& mh, const graphics_handle& p)
@@ -3600,64 +3600,64 @@ public:
       bool_property zliminclude hl , "on"
       bool_property climinclude hlg , "on"
       bool_property aliminclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
-	xdata.add_constraint (dim_vector (-1, -1));
-	ydata.add_constraint (dim_vector (-1, -1));
-	zdata.add_constraint (dim_vector (-1, -1));
-	alphadata.add_constraint ("double");
-	alphadata.add_constraint ("uint8");
-	alphadata.add_constraint (dim_vector (-1, -1));
-	vertexnormals.add_constraint (dim_vector (-1, -1, 3));
-	cdata.add_constraint ("double");
-	cdata.add_constraint ("uint8");
-	cdata.add_constraint (dim_vector (-1, -1));
-	cdata.add_constraint (dim_vector (-1, -1, 3));
+        xdata.add_constraint (dim_vector (-1, -1));
+        ydata.add_constraint (dim_vector (-1, -1));
+        zdata.add_constraint (dim_vector (-1, -1));
+        alphadata.add_constraint ("double");
+        alphadata.add_constraint ("uint8");
+        alphadata.add_constraint (dim_vector (-1, -1));
+        vertexnormals.add_constraint (dim_vector (-1, -1, 3));
+        cdata.add_constraint ("double");
+        cdata.add_constraint ("uint8");
+        cdata.add_constraint (dim_vector (-1, -1));
+        cdata.add_constraint (dim_vector (-1, -1, 3));
       }
 
   private:
     void update_normals (void);
 
     void update_xdata (void)
       {
-	update_normals ();
-	set_xlim (xdata.get_limits ());
+        update_normals ();
+        set_xlim (xdata.get_limits ());
       }
  
     void update_ydata (void)
       {
-	update_normals ();
-	set_ylim (ydata.get_limits ());
+        update_normals ();
+        set_ylim (ydata.get_limits ());
       }
 
     void update_zdata (void)
       {
-	update_normals ();
-	set_zlim (zdata.get_limits ());
+        update_normals ();
+        set_zlim (zdata.get_limits ());
       }
 
     void update_cdata (void)
       {
-	if (cdatamapping_is ("scaled"))
-	  set_clim (cdata.get_limits ());
-	else
-	  clim = cdata.get_limits ();
+        if (cdatamapping_is ("scaled"))
+          set_clim (cdata.get_limits ());
+        else
+          clim = cdata.get_limits ();
       }
 
     void update_alphadata (void)
       {
-	if (alphadatamapping_is ("scaled"))
-	  set_alim (alphadata.get_limits ());
-	else
-	  alim = alphadata.get_limits ();
+        if (alphadatamapping_is ("scaled"))
+          set_alim (alphadata.get_limits ());
+        else
+          alim = alphadata.get_limits ();
       }
 
     void update_normalmode (void)
       { update_normals (); }
 
     void update_vertexnormals (void)
       { set_normalmode ("manual"); }
   };
@@ -3686,24 +3686,24 @@ public:
 class OCTINTERP_API hggroup : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     void remove_child (const graphics_handle& h)
       {
-	base_properties::remove_child (h);
-	update_limits ();
+        base_properties::remove_child (h);
+        update_limits ();
       }
 
     void adopt (const graphics_handle& h)
       {
-	base_properties::adopt (h);
-	update_limits ();
+        base_properties::adopt (h);
+        update_limits ();
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (hggroup)
       // hidden properties for limit computation
       row_vector_property xlim hr , Matrix()
@@ -3716,21 +3716,21 @@ public:
       bool_property zliminclude h , "on"
       bool_property climinclude h , "on"
       bool_property aliminclude h , "on"
     END_PROPERTIES
 
   private:
     void update_limits (void)
       {
-	update_axis_limits ("xlim");
-	update_axis_limits ("ylim");
-	update_axis_limits ("zlim");
-	update_axis_limits ("clim");
-	update_axis_limits ("alim");
+        update_axis_limits ("xlim");
+        update_axis_limits ("ylim");
+        update_axis_limits ("zlim");
+        update_axis_limits ("clim");
+        update_axis_limits ("alim");
       }
 
   protected:
     void init (void)
       { }
   };
 
 private:
@@ -3753,20 +3753,20 @@ public:
   
   void update_axis_limits (const std::string& axis_type);
 };
 
 // ---------------------------------------------------------------------
 
 octave_value
 get_property_from_handle (double handle, const std::string &property,
-			  const std::string &func);
+                          const std::string &func);
 bool
 set_property_in_handle (double handle, const std::string &property,
-			const octave_value &arg, const std::string &func);
+                        const octave_value &arg, const std::string &func);
 
 // ---------------------------------------------------------------------
 
 class graphics_event;
 
 class
 base_graphics_event
 {
@@ -3795,52 +3795,52 @@ public:
     {
       rep = e.rep;
       rep->count++;
     }
 
   ~graphics_event (void)
     {
       if (rep && --rep->count == 0)
-	delete rep;
+        delete rep;
     }
 
   graphics_event& operator = (const graphics_event& e)
     {
       if (rep != e.rep)
-	{
-	  if (rep && --rep->count == 0)
-	    delete rep;
-
-	  rep = e.rep;
-	  if (rep)
-	    rep->count++;
-	}
+        {
+          if (rep && --rep->count == 0)
+            delete rep;
+
+          rep = e.rep;
+          if (rep)
+            rep->count++;
+        }
 
       return *this;
     }
 
   void execute (void)
     { if (rep) rep->execute (); }
 
   bool ok (void) const
     { return (rep != 0); }
 
   static graphics_event
       create_callback_event (const graphics_handle& h,
-			     const std::string& name,
-			     const octave_value& data = Matrix ());
+                             const std::string& name,
+                             const octave_value& data = Matrix ());
 
   static graphics_event
       create_function_event (event_fcn fcn, void *data = 0);
 
   static graphics_event
       create_set_event (const graphics_handle& h,
-			const std::string& name,
-			const octave_value& value);
+                        const std::string& name,
+                        const octave_value& value);
 private:
   base_graphics_event *rep;
 };
 
 class OCTINTERP_API gh_manager
 {
 protected:
 
@@ -3852,19 +3852,19 @@ public:
   {
     bool retval = true;
 
     if (! instance)
       instance = new gh_manager ();
 
     if (! instance)
       {
-	::error ("unable to create gh_manager!");
-
-	retval = false;
+        ::error ("unable to create gh_manager!");
+
+        retval = false;
       }
 
     return retval;
   }
 
   static void free (const graphics_handle& h)
   {
     if (instance_ok ())
@@ -3884,17 +3884,17 @@ public:
 
   static graphics_object get_object (const graphics_handle& h)
   {
     return instance_ok () ? instance->do_get_object (h) : graphics_object ();
   }
 
   static graphics_handle
   make_graphics_handle (const std::string& go_name,
-			const graphics_handle& parent, bool do_createfcn = true)
+                        const graphics_handle& parent, bool do_createfcn = true)
   {
     return instance_ok ()
       ? instance->do_make_graphics_handle (go_name, parent, do_createfcn)
       : graphics_handle ();
   }
 
   static graphics_handle make_figure_handle (double val)
   {
@@ -3938,55 +3938,55 @@ public:
   }
 
   static Matrix figure_handle_list (void)
   {
     return instance_ok () ? instance->do_figure_handle_list () : Matrix ();
   }
 
   static void execute_callback (const graphics_handle& h,
-				const std::string& name,
-				const octave_value& data = Matrix ())
+                                const std::string& name,
+                                const octave_value& data = Matrix ())
   {
     graphics_object go = get_object (h);
 
     if (go.valid_object ())
       {
-	octave_value cb = go.get (name);
-
-	if (! error_state)
-	  execute_callback (h, cb, data);
+        octave_value cb = go.get (name);
+
+        if (! error_state)
+          execute_callback (h, cb, data);
       }
   }
 
   static void execute_callback (const graphics_handle& h,
-				const octave_value& cb,
-				const octave_value& data = Matrix ())
+                                const octave_value& cb,
+                                const octave_value& data = Matrix ())
   {
     if (instance_ok ())
       instance->do_execute_callback (h, cb, data);
   }
 
   static void post_callback (const graphics_handle& h,
-			     const std::string& name,
-			     const octave_value& data = Matrix ())
+                             const std::string& name,
+                             const octave_value& data = Matrix ())
   {
     if (instance_ok ())
       instance->do_post_callback (h, name, data);
   }
 
   static void post_function (graphics_event::event_fcn fcn, void* data = 0)
   {
     if (instance_ok ())
       instance->do_post_function (fcn, data);
   }
 
   static void post_set (const graphics_handle& h,
-			const std::string& name,
-			const octave_value& value)
+                        const std::string& name,
+                        const octave_value& value)
   {
     if (instance_ok ())
       instance->do_post_set (h, name, value);
   }
 
   static int process_events (void)
   {
     return (instance_ok () ?  instance->do_process_events () : 0);
@@ -4073,42 +4073,42 @@ private:
   graphics_object do_get_object (const graphics_handle& h)
   {
     iterator p = (h.ok () ? handle_map.find (h) : handle_map.end ());
 
     return (p != handle_map.end ()) ? p->second : graphics_object ();
   }
 
   graphics_handle do_make_graphics_handle (const std::string& go_name,
-					   const graphics_handle& p, bool do_createfcn);
+                                           const graphics_handle& p, bool do_createfcn);
 
   graphics_handle do_make_figure_handle (double val);
 
   Matrix do_handle_list (void)
   {
     Matrix retval (1, handle_map.size ());
     octave_idx_type i = 0;
     for (const_iterator p = handle_map.begin (); p != handle_map.end (); p++)
       {
-	graphics_handle h = p->first;
-	retval(i++) = h.value ();
+        graphics_handle h = p->first;
+        retval(i++) = h.value ();
       }
     return retval;
   }
 
   Matrix do_figure_handle_list (void)
   {
     Matrix retval (1, figure_list.size ());
     octave_idx_type i = 0;
     for (const_figure_list_iterator p = figure_list.begin ();
-	 p != figure_list.end ();
-	 p++)
+         p != figure_list.end ();
+         p++)
       {
-	graphics_handle h = *p;
-	retval(i++) = h.value ();
+        graphics_handle h = *p;
+        retval(i++) = h.value ();
       }
     return retval;
   }
 
   void do_push_figure (const graphics_handle& h);
 
   void do_pop_figure (const graphics_handle& h);
 
@@ -4117,25 +4117,25 @@ private:
     return figure_list.empty () ? graphics_handle () : figure_list.front ();
   }
 
   void do_lock (void) { graphics_lock.lock (); }
   
   void do_unlock (void) { graphics_lock.unlock (); }
 
   void do_execute_callback (const graphics_handle& h, const octave_value& cb,
-			    const octave_value& data);
+                            const octave_value& data);
 
   void do_post_callback (const graphics_handle& h, const std::string name,
-			 const octave_value& data);
+                         const octave_value& data);
 
   void do_post_function (graphics_event::event_fcn fcn, void* fcn_data);
 
   void do_post_set (const graphics_handle& h, const std::string name,
-		    const octave_value& value);
+                    const octave_value& value);
 
   int do_process_events (bool force = false);
 
   static void restore_gcbo (void)
   {
     if (instance_ok ())
       instance->do_restore_gcbo ();
   }
diff --git a/src/mk-pkg-add b/src/mk-pkg-add
--- a/src/mk-pkg-add
+++ b/src/mk-pkg-add
@@ -23,24 +23,24 @@ SED=${SED:-'sed'}
 for f in "$@"; do
   if [ -f $f ]; then
 
     ## Compute and print the autoloads.
   
     base=`basename $f | $SED 's/\.df$//'`
     fcns=`$SED -n -e 's/^ *XDEFUN_DLD_INTERNAL *( *\([^, ]*\)[, ].*$/\1/p' \
                   -e 's/^ *XDEFUNX_DLD_INTERNAL *( *"\([^"]*\)".*$/\1/p' $f | \
-	  sort -u`
+          sort -u`
     if [ -n "$fcns" ]; then
       for n in $fcns; do
-	if [ "$n" = "$base" ]; then
-	  true
-	else
+        if [ "$n" = "$base" ]; then
+          true
+        else
           echo "autoload (\"$n\", \"$base.oct\");"
-	fi
+        fi
       done
     fi
 
     ## Process PKG_ADD directives after autoloads so that all
     ## necessary functions can be found before they are used.
 
     $SED -n -e 's,^//* *PKG_ADD: *,,p' \
             -e 's,^/\* *PKG_ADD: *\(.*\) *\*/ *$,\1,p' $f
diff --git a/src/mkgendoc b/src/mkgendoc
--- a/src/mkgendoc
+++ b/src/mkgendoc
@@ -66,29 +66,29 @@ cat << \EOF
 #define XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
   print_doc_string (#name, file_name, doc);
 
 #define XDEFCONST_INTERNAL(name, defn, doc) \
   print_doc_string (#name, file_name, doc);
 
 static void
 print_doc_string (const std::string& name, const std::string& file_name,
-		  const std::string& doc)
+                  const std::string& doc)
 {
   std::cout << "";
 
   size_t len = name.length ();
 
   if (name[0] == '"' && name[len-1] == '"')
     std::cout << name.substr (1, len-2) << "\n";
   else
     std::cout << name << "\n";
 
   std::cout << "@c " << file_name << "\n"
-	    << doc << "\n";
+            << doc << "\n";
 }
 
 EOF
 
 for file in $DOC_FILES; do
   fcn=`echo $file | $SED 's,.*/,,; s/\.df//; s/-/_/g;'`
   echo "static void"
   echo "print_${fcn}_doc_strings (void)"
diff --git a/src/mxarray.h.in b/src/mxarray.h.in
--- a/src/mxarray.h.in
+++ b/src/mxarray.h.in
@@ -129,32 +129,32 @@ xmxArray
 
 class mxArray
 {
 public:
 
   mxArray (const octave_value& ov);
 
   mxArray (mxClassID id, mwSize ndims, const mwSize *dims,
-	   mxComplexity flag = mxREAL);
+           mxComplexity flag = mxREAL);
 
   mxArray (mxClassID id, const dim_vector& dv, mxComplexity flag = mxREAL);
 
   mxArray (mxClassID id, mwSize m, mwSize n, mxComplexity flag = mxREAL);
 
   mxArray (mxClassID id, double val);
 
   mxArray (mxClassID id, mxLogical val);
 
   mxArray (const char *str);
 
   mxArray (mwSize m, const char **str);
 
   mxArray (mxClassID id, mwSize m, mwSize n, mwSize nzmax,
-	   mxComplexity flag = mxREAL);
+           mxComplexity flag = mxREAL);
 
   mxArray (mwSize ndims, const mwSize *dims, int num_keys, const char **keys);
 
   mxArray (const dim_vector& dv, int num_keys, const char **keys);
 
   mxArray (mwSize m, mwSize n, int num_keys, const char **keys);
 
   mxArray (mwSize ndims, const mwSize *dims);
@@ -299,19 +299,19 @@ public:
   static void *calloc (size_t n, size_t t);
 
   static char *strsave (const char *str)
   {
     char *retval = 0;
 
     if (str)
       {
-	mwSize sz =  sizeof (mxChar) * (strlen (str) + 1);
-	retval = static_cast<char *> (mxArray::malloc (sz));
-	strcpy (retval, str);
+        mwSize sz =  sizeof (mxChar) * (strlen (str) + 1);
+        retval = static_cast<char *> (mxArray::malloc (sz));
+        strcpy (retval, str);
       }
 
     return retval;
   }
 
   static octave_value as_octave_value (mxArray *ptr);
 
 protected:
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -219,42 +219,42 @@ gzfilebuf::showmanyc()
 // differs from the one in the file. We can only support the first case 
 // with gzipped files.
 gzfilebuf::int_type
 gzfilebuf::pbackfail (gzfilebuf::int_type c)
 {
   if (this->is_open())
     {
       if (gzseek (file, this->gptr() - this->egptr() - 1, SEEK_CUR) < 0)
-	return traits_type::eof();
+        return traits_type::eof();
   
       // Invalidates contents of the buffer
       enable_buffer ();
 
       // Attempt to fill internal buffer from gzipped file
       // (buffer must be guaranteed to exist...)
       int bytes_read = gzread(file, buffer, buffer_size);
       // Indicates error or EOF
       if (bytes_read <= 0)
-	{
-	  // Reset get area
-	  this->setg(buffer, buffer, buffer);
-	  return traits_type::eof();
-	}
+        {
+          // Reset get area
+          this->setg(buffer, buffer, buffer);
+          return traits_type::eof();
+        }
 
       // Make all bytes read from file available as get area
       this->setg(buffer, buffer, buffer + bytes_read);
 
       // If next character in get area differs from putback character
       // flag a failure
       gzfilebuf::int_type ret = traits_type::to_int_type(*(this->gptr()));
       if (ret != c)
-	return traits_type::eof();
+        return traits_type::eof();
       else
-	return ret;
+        return ret;
     }
   else
     return traits_type::eof();
 }
 
 // Fill get area from gzipped file
 gzfilebuf::int_type
 gzfilebuf::underflow()
@@ -271,18 +271,18 @@ gzfilebuf::underflow()
 
   // Copy the final characters to the front of the buffer
   int stash = 0;
   if (this->eback() && buffer && buffer_size > STASHED_CHARACTERS)
     {
       char_type *ptr1 = buffer;
       char_type *ptr2 = this->egptr() - STASHED_CHARACTERS + 1;
       if (ptr2 > this->eback())
-	while (stash++ <= STASHED_CHARACTERS)
-	  *ptr1++ = *ptr2++;
+        while (stash++ <= STASHED_CHARACTERS)
+          *ptr1++ = *ptr2++;
     }
 
   // Attempt to fill internal buffer from gzipped file
   // (buffer must be guaranteed to exist...)
   int bytes_read = gzread(file, buffer + stash, buffer_size - stash);
 
   // Indicates error or EOF
   if (bytes_read <= 0)
@@ -457,61 +457,61 @@ gzfilebuf::disable_buffer()
   }
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Seek functions
 gzfilebuf::pos_type
 gzfilebuf::seekoff(off_type off, std::ios_base::seekdir way, 
-		   std::ios_base::openmode)
+                   std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
   if (this->is_open())
     {
       off_type computed_off = off;
 
       if ((io_mode & std::ios_base::in) && way == std::ios_base::cur)
-	computed_off += this->gptr() - this->egptr();
+        computed_off += this->gptr() - this->egptr();
 
       if (way == std::ios_base::beg)
-	ret = pos_type (gzseek (file, computed_off, SEEK_SET));
+        ret = pos_type (gzseek (file, computed_off, SEEK_SET));
       else if (way == std::ios_base::cur)
-	ret = pos_type (gzseek (file, computed_off, SEEK_CUR));
+        ret = pos_type (gzseek (file, computed_off, SEEK_CUR));
       else
-	// Can't seek from end of a gzipped file, so this will give -1
-	ret = pos_type (gzseek (file, computed_off, SEEK_END));
+        // Can't seek from end of a gzipped file, so this will give -1
+        ret = pos_type (gzseek (file, computed_off, SEEK_END));
   
       if (io_mode & std::ios_base::in)
-	// Invalidates contents of the buffer
-	enable_buffer ();
+        // Invalidates contents of the buffer
+        enable_buffer ();
       else
-	// flush contents of buffer to file
-	overflow ();
+        // flush contents of buffer to file
+        overflow ();
     }
 
   return ret;
 }
 
 gzfilebuf::pos_type
 gzfilebuf::seekpos(pos_type sp, std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
   if (this->is_open ())
     {
       ret = pos_type (gzseek (file, sp, SEEK_SET));
 
       if (io_mode & std::ios_base::in)
-	// Invalidates contents of the buffer
-	enable_buffer ();
+        // Invalidates contents of the buffer
+        enable_buffer ();
       else
-	// flush contents of buffer to file
-	overflow ();
+        // flush contents of buffer to file
+        overflow ();
     }
 
   return ret;
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -172,27 +172,27 @@ protected:
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
   seekoff(off_type off, std::ios_base::seekdir way,
-	  std::ios_base::openmode mode = 
-	  std::ios_base::in|std::ios_base::out);
+          std::ios_base::openmode mode = 
+          std::ios_base::in|std::ios_base::out);
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
   seekpos(pos_type sp, std::ios_base::openmode mode = 
-	  std::ios_base::in|std::ios_base::out);
+          std::ios_base::in|std::ios_base::out);
 
   virtual int_type
   pbackfail (int_type c = traits_type::eof());
 
 //
 // Some future enhancements
 //
 //  virtual int_type uflow();
