# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1361864432 18000
#      Tue Feb 26 02:40:32 2013 -0500
# Node ID 7c5e5e97a3bc741b40b513c032e7201a3746d091
# Parent  ea5d92f574e02da946e13b48a911ef64b547dd39
move static lexer helper functions to lexical_feedback class

* lex.ll, lex.h oct-parse.yy (do_comma_insert_check, text_yyinput,
xunput, fixup_column_count, inside_any_object_index, is_keyword_token,
is_variable, grab_block_comment, grab_comment_block, process_comment,
next_token_is_sep_op, next_token_is_postfix_unary_op,
next_token_is_bin_op, scan_for_comments, eat_whitespace,
handle_number, have_continuation, have_ellipsis_continuation,
eat_continuation, handle_string, next_token_is_assign_op,
next_token_is_index_op, handle_close_bracket, maybe_unput_comma,
next_token_can_follow_bin_op, looks_like_command_arg,
handle_superclass_identifier, handle_meta_identifier,
handle_identifier, maybe_warn_separator_insert,
gripe_single_quote_string, gripe_matlab_incompatible,
maybe_gripe_matlab_incompatible_comment,
gripe_matlab_incompatible_continuation,
gripe_matlab_incompatible_operator): Declare as members of
lexical_feedback class.  Change all callers.

diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -49,16 +49,33 @@ extern OCTINTERP_API void clear_all_buff
 extern OCTINTERP_API void cleanup_parser (void);
 
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
 extern void prep_lexer_for_script_file (void);
 extern void prep_lexer_for_function_file (void);
 
+class
+stream_reader
+{
+public:
+  virtual int getc (void) = 0;
+  virtual int ungetc (int c) = 0;
+
+protected:
+  stream_reader (void) { }
+  ~stream_reader (void) { }
+
+private:
+
+  // No copying!
+  stream_reader (const stream_reader&);
+  stream_reader& operator = (const stream_reader&);
+};
 
 // Forward decl for lexical_feedback::token_stack.
 class token;
 
 // For communication between the lexer and parser.
 
 class
 lexical_feedback
@@ -183,16 +200,87 @@ public:
 
   void init (void)
   {
     // The closest paren, brace, or bracket nesting is not an object
     // index.
     looking_at_object_index.push_front (false);
   }
 
+  void do_comma_insert_check (void);
+
+  int text_yyinput (void);
+
+  void xunput (char c, char *buf);
+
+  void fixup_column_count (char *s);
+
+  bool inside_any_object_index (void);
+
+  int is_keyword_token (const std::string& s);
+
+  bool is_variable (const std::string& name);
+
+  std::string grab_block_comment (stream_reader& reader, bool& eof);
+
+  std::string grab_comment_block (stream_reader& reader, bool at_bol,
+                                  bool& eof);
+
+  int process_comment (bool start_in_block, bool& eof);
+
+  bool next_token_is_sep_op (void);
+
+  bool next_token_is_postfix_unary_op (bool spc_prev);
+
+  bool next_token_is_bin_op (bool spc_prev);
+
+  void scan_for_comments (const char *text);
+
+  int eat_whitespace (void);
+
+  void handle_number (void);
+
+  bool have_continuation (bool trailing_comments_ok = true);
+
+  bool have_ellipsis_continuation (bool trailing_comments_ok = true);
+
+  int eat_continuation (void);
+
+  int handle_string (char delim);
+
+  bool next_token_is_assign_op (void);
+
+  bool next_token_is_index_op (void);
+
+  int handle_close_bracket (bool spc_gobbled, int bracket_type);
+
+  void maybe_unput_comma (int spc_gobbled);
+
+  bool next_token_can_follow_bin_op (void);
+
+  bool looks_like_command_arg (void);
+
+  int handle_superclass_identifier (void);
+
+  int handle_meta_identifier (void);
+
+  int handle_identifier (void);
+
+  void maybe_warn_separator_insert (char sep);
+
+  void gripe_single_quote_string (void);
+
+  void gripe_matlab_incompatible (const std::string& msg);
+
+  void maybe_gripe_matlab_incompatible_comment (char c);
+
+  void gripe_matlab_incompatible_continuation (void);
+
+  void gripe_matlab_incompatible_operator (const std::string& op);
+
   // TRUE means that we should convert spaces to a comma inside a
   // matrix definition.
   bool convert_spaces_to_comma;
 
   // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
   bool do_comma_insert;
 
   // TRUE means we are at the beginning of a statement, where a
@@ -293,33 +381,12 @@ private:
 
   // No copying!
 
   lexical_feedback (const lexical_feedback&);
 
   lexical_feedback& operator = (const lexical_feedback&);
 };
 
-class
-stream_reader
-{
-public:
-  virtual int getc (void) = 0;
-  virtual int ungetc (int c) = 0;
-
-protected:
-  stream_reader (void) { }
-  ~stream_reader (void) { }
-
-private:
-
-  // No copying!
-  stream_reader (const stream_reader&);
-  stream_reader& operator = (const stream_reader&);
-};
-
-extern std::string
-grab_comment_block (stream_reader& reader, bool at_bol, bool& eof);
-
 // The current state of the lexer.
 extern lexical_feedback *curr_lexer;
 
 #endif
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -178,32 +178,32 @@ along with Octave; see the file COPYING.
       curr_lexer->at_beginning_of_statement = bos; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define XBIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
   do \
     { \
-      gripe_matlab_incompatible_operator (yytext); \
+      curr_lexer->gripe_matlab_incompatible_operator (yytext); \
       BIN_OP_RETURN_INTERNAL (tok, convert, bos, qit); \
     } \
   while (0)
 
 #define BIN_OP_RETURN(tok, convert, bos) \
   do \
     { \
       BIN_OP_RETURN_INTERNAL (tok, convert, bos, false); \
     } \
   while (0)
 
 #define XBIN_OP_RETURN(tok, convert, bos) \
   do \
     { \
-      gripe_matlab_incompatible_operator (yytext); \
+      curr_lexer->gripe_matlab_incompatible_operator (yytext); \
       BIN_OP_RETURN (tok, convert, bos); \
     } \
   while (0)
 
 #define LEXER_DEBUG(pattern) \
   do \
     { \
       if (lexer_debug_flag) \
@@ -219,45 +219,19 @@ static bool Vdisplay_tokens = false;
 static unsigned int Vtoken_count = 0;
 
 // Internal variable for lexer debugging state.
 static bool lexer_debug_flag = false;
 
 // Forward declarations for functions defined at the bottom of this
 // file.
 
-static int text_yyinput (void);
-static void xunput (char c, char *buf);
-static void fixup_column_count (char *s);
-static void do_comma_insert_check (void);
-static int is_keyword_token (const std::string& s);
-static int process_comment (bool start_in_block, bool& eof);
 static bool match_any (char c, const char *s);
-static bool next_token_is_sep_op (void);
-static bool next_token_is_bin_op (bool spc_prev);
-static bool next_token_is_postfix_unary_op (bool spc_prev);
 static std::string strip_trailing_whitespace (char *s);
-static void handle_number (void);
-static int handle_string (char delim);
-static int handle_close_bracket (bool spc_gobbled, int bracket_type);
-static int handle_superclass_identifier (void);
-static int handle_meta_identifier (void);
-static int handle_identifier (void);
-static bool have_continuation (bool trailing_comments_ok = true);
-static bool have_ellipsis_continuation (bool trailing_comments_ok = true);
-static void scan_for_comments (const char *);
-static int eat_whitespace (void);
-static int eat_continuation (void);
 static int octave_read (char *buf, unsigned int max_size);
-static void maybe_warn_separator_insert (char sep);
-static void gripe_single_quote_string (void);
-static void gripe_matlab_incompatible (const std::string& msg);
-static void maybe_gripe_matlab_incompatible_comment (char c);
-static void gripe_matlab_incompatible_continuation (void);
-static void gripe_matlab_incompatible_operator (const std::string& op);
 static void display_token (int tok);
 static void lexer_debug (const char *pattern, const char *text);
 
 %}
 
 D       [0-9]
 S       [ \t]
 NL      ((\n)|(\r)|(\r\n))
@@ -281,25 +255,25 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Make script and function files start with a bogus token. This makes
 // the parser go down a special path.
 %}
 
 <SCRIPT_FILE_BEGIN>. {
     LEXER_DEBUG ("<SCRIPT_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
-    xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0], yytext);
     COUNT_TOK_AND_RETURN (SCRIPT_FILE);
   }
 
 <FUNCTION_FILE_BEGIN>. {
     LEXER_DEBUG ("<FUNCTION_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
-    xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0], yytext);
     COUNT_TOK_AND_RETURN (FUNCTION_FILE);
   }
 
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
@@ -332,17 +306,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
   }
 
 <COMMAND_START>[\"\'] {
     LEXER_DEBUG ("<COMMAND_START>[\\\"\\']");
 
     curr_lexer->at_beginning_of_statement = false;
 
     curr_lexer->current_input_column++;
-    int tok = handle_string (yytext[0]);
+    int tok = curr_lexer->handle_string (yytext[0]);
 
     COUNT_TOK_AND_RETURN (tok);
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
     LEXER_DEBUG ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
 
     std::string tok = strip_trailing_whitespace (yytext);
@@ -365,86 +339,86 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // after seeing a ']' character...
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*\]{S}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\]{S}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
-    bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
+    bool cont_is_spc = (curr_lexer->eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
-    int tok_to_return = handle_close_bracket (spc_gobbled, ']');
+    int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, ']');
 
     if (spc_gobbled)
-      xunput (' ', yytext);
+      curr_lexer->xunput (' ', yytext);
 
     COUNT_TOK_AND_RETURN (tok_to_return);
   }
 
 %{
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*\}{S}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\}{S}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
-    bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
+    bool cont_is_spc = (curr_lexer->eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
-    int tok_to_return = handle_close_bracket (spc_gobbled, '}');
+    int tok_to_return = curr_lexer->handle_close_bracket (spc_gobbled, '}');
 
     if (spc_gobbled)
-      xunput (' ', yytext);
+      curr_lexer->xunput (' ', yytext);
 
     COUNT_TOK_AND_RETURN (tok_to_return);
   }
 
 %{
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
 <MATRIX_START>{S}*\,{S}* {
     LEXER_DEBUG ("<MATRIX_START>{S}*\\,{S}*");
 
     curr_lexer->current_input_column += yyleng;
 
-    int tmp = eat_continuation ();
+    int tmp = curr_lexer->eat_continuation ();
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
     if (! curr_lexer->looking_at_object_index.front ())
       {
         if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
           {
-            maybe_warn_separator_insert (';');
-
-            xunput (';', yytext);
+            curr_lexer->maybe_warn_separator_insert (';');
+
+            curr_lexer->xunput (';', yytext);
           }
       }
 
     COUNT_TOK_AND_RETURN (',');
   }
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
@@ -455,40 +429,40 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 <MATRIX_START>{S}+ {
     LEXER_DEBUG ("<MATRIX_START>{S}+");
 
     curr_lexer->current_input_column += yyleng;
 
     curr_lexer->at_beginning_of_statement = false;
 
-    int tmp = eat_continuation ();
+    int tmp = curr_lexer->eat_continuation ();
 
     if (! curr_lexer->looking_at_object_index.front ())
       {
-        bool bin_op = next_token_is_bin_op (true);
-        bool postfix_un_op = next_token_is_postfix_unary_op (true);
-        bool sep_op = next_token_is_sep_op ();
+        bool bin_op = curr_lexer->next_token_is_bin_op (true);
+        bool postfix_un_op = curr_lexer->next_token_is_postfix_unary_op (true);
+        bool sep_op = curr_lexer->next_token_is_sep_op ();
 
         if (! (postfix_un_op || bin_op || sep_op)
             && curr_lexer->nesting_level.is_bracket_or_brace ()
             && curr_lexer->convert_spaces_to_comma)
           {
             if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
               {
-                maybe_warn_separator_insert (';');
-
-                xunput (';', yytext);
+                curr_lexer->maybe_warn_separator_insert (';');
+
+                curr_lexer->xunput (';', yytext);
               }
 
             curr_lexer->quote_is_transpose = false;
             curr_lexer->convert_spaces_to_comma = true;
             curr_lexer->looking_for_object_index = false;
 
-            maybe_warn_separator_insert (',');
+            curr_lexer->maybe_warn_separator_insert (',');
 
             COUNT_TOK_AND_RETURN (',');
           }
       }
   }
 
 %{
 // Semicolons are handled as row seprators in matrix constants.  If we
@@ -496,19 +470,19 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // semicolons.
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{SNLCMT}*;{SNLCMT}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*;{SNLCMT}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
-    eat_whitespace ();
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
+    curr_lexer->eat_whitespace ();
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN (';');
   }
@@ -520,31 +494,31 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 // FIXME -- we need to handle block comments here.
 %}
 
 <MATRIX_START>{S}*{COMMENT}{SNLCMT}* |
 <MATRIX_START>{S}*{NL}{SNLCMT}* {
     LEXER_DEBUG ("<MATRIX_START>{S}*{COMMENT}{SNLCMT}*|<MATRIX_START>{S}*{NL}{SNLCMT}*");
 
-    scan_for_comments (yytext);
-    fixup_column_count (yytext);
-    eat_whitespace ();
+    curr_lexer->scan_for_comments (yytext);
+    curr_lexer->fixup_column_count (yytext);
+    curr_lexer->eat_whitespace ();
 
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->at_beginning_of_statement = false;
 
     if (curr_lexer->nesting_level.none ())
       return LEXICAL_ERROR;
 
     if (! curr_lexer->looking_at_object_index.front ()
         && curr_lexer->nesting_level.is_bracket_or_brace ())
       {
-        maybe_warn_separator_insert (';');
+        curr_lexer->maybe_warn_separator_insert (';');
 
         COUNT_TOK_AND_RETURN (';');
       }
   }
 
 \[{S}* {
     LEXER_DEBUG ("\\[{S}*");
 
@@ -560,17 +534,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
     if (curr_lexer->defining_func
         && ! curr_lexer->parsed_function_name.top ())
       curr_lexer->looking_at_return_list = true;
     else
       curr_lexer->looking_at_matrix_or_assign_lhs = true;
 
     promptflag--;
-    eat_whitespace ();
+    curr_lexer->eat_whitespace ();
 
     curr_lexer->bracketflag++;
     BEGIN (MATRIX_START);
     COUNT_TOK_AND_RETURN ('[');
   }
 
 \] {
     LEXER_DEBUG ("\\]");
@@ -587,29 +561,29 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 %{
 // Imaginary numbers.
 %}
 
 {NUMBER}{Im} {
     LEXER_DEBUG ("{NUMBER}{Im}");
 
-    handle_number ();
+    curr_lexer->handle_number ();
     COUNT_TOK_AND_RETURN (IMAG_NUM);
   }
 
 %{
 // Real numbers.  Don't grab the '.' part of a dot operator as part of
 // the constant.
 %}
 
 {D}+/\.[\*/\\^\'] |
 {NUMBER} {
     LEXER_DEBUG ("{D}+/\\.[\\*/\\^\\']|{NUMBER}");
-    handle_number ();
+    curr_lexer->handle_number ();
     COUNT_TOK_AND_RETURN (NUM);
   }
 
 %{
 // Eat whitespace.  Whitespace inside matrix constants is handled by
 // the <MATRIX_START> start state code above.
 %}
 
@@ -621,18 +595,18 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Continuation lines.  Allow comments after continuations.
 %}
 
 {CONT}{S}*{NL} |
 {CONT}{S}*{COMMENT} {
     LEXER_DEBUG ("{CONT}{S}*{NL}|{CONT}{S}*{COMMENT}");
 
     if (yytext[0] == '\\')
-      gripe_matlab_incompatible_continuation ();
-    scan_for_comments (yytext);
+      curr_lexer->gripe_matlab_incompatible_continuation ();
+    curr_lexer->scan_for_comments (yytext);
     promptflag--;
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
   }
 
 %{
 // End of file.
 %}
@@ -656,31 +630,31 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %{
 // Identifiers.  Truncate the token at the first space or tab but
 // don't write directly on yytext.
 %}
 
 {IDENT}{S}* {
     LEXER_DEBUG ("{IDENT}{S}*");
 
-    int id_tok = handle_identifier ();
+    int id_tok = curr_lexer->handle_identifier ();
 
     if (id_tok >= 0)
       COUNT_TOK_AND_RETURN (id_tok);
   }
 
 %{
 // Superclass method identifiers.
 %}
 
 {IDENT}@{IDENT}{S}* |
 {IDENT}@{IDENT}.{IDENT}{S}* {
     LEXER_DEBUG ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
 
-    int id_tok = handle_superclass_identifier ();
+    int id_tok = curr_lexer->handle_superclass_identifier ();
 
     if (id_tok >= 0)
       {
         curr_lexer->looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (SUPERCLASSREF);
       }
   }
@@ -688,17 +662,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %{
 // Metaclass query
 %}
 
 \?{IDENT}{S}* |
 \?{IDENT}\.{IDENT}{S}* {
     LEXER_DEBUG ("\\?{IDENT}{S}*|\\?{IDENT}\\.{IDENT}{S}*");
 
-    int id_tok = handle_meta_identifier ();
+    int id_tok = curr_lexer->handle_meta_identifier ();
 
     if (id_tok >= 0)
       {
         curr_lexer->looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (METAQUERY);
       }
   }
@@ -740,17 +714,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     if (curr_lexer->nesting_level.none ())
       {
         curr_lexer->at_beginning_of_statement = true;
         COUNT_TOK_AND_RETURN ('\n');
       }
     else if (curr_lexer->nesting_level.is_paren ())
       {
         curr_lexer->at_beginning_of_statement = false;
-        gripe_matlab_incompatible ("bare newline inside parentheses");
+        curr_lexer->gripe_matlab_incompatible ("bare newline inside parentheses");
       }
     else if (curr_lexer->nesting_level.is_bracket_or_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator.
@@ -759,52 +733,52 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 "'" {
     LEXER_DEBUG ("'");
 
     curr_lexer->current_input_column++;
     curr_lexer->convert_spaces_to_comma = true;
 
     if (curr_lexer->quote_is_transpose)
       {
-        do_comma_insert_check ();
+        curr_lexer->do_comma_insert_check ();
         COUNT_TOK_AND_RETURN (QUOTE);
       }
     else
       {
-        int tok = handle_string ('\'');
+        int tok = curr_lexer->handle_string ('\'');
         COUNT_TOK_AND_RETURN (tok);
       }
   }
 
 %{
 // Double quotes always begin strings.
 %}
 
 \" {
     LEXER_DEBUG ("\"");
 
     curr_lexer->current_input_column++;
-    int tok = handle_string ('"');
+    int tok = curr_lexer->handle_string ('"');
 
     COUNT_TOK_AND_RETURN (tok);
 }
 
 %{
 // Gobble comments.
 %}
 
 {CCHAR} {
     LEXER_DEBUG ("{CCHAR}");
 
     curr_lexer->looking_for_object_index = false;
 
-    xunput (yytext[0], yytext);
+    curr_lexer->xunput (yytext[0], yytext);
 
     bool eof = false;
-    int tok = process_comment (false, eof);
+    int tok = curr_lexer->process_comment (false, eof);
 
     if (eof)
       TOK_RETURN (END_OF_INPUT);
     else if (tok > 0)
       COUNT_TOK_AND_RETURN (tok);
   }
 
 %{
@@ -817,35 +791,35 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     curr_lexer->looking_for_object_index = false;
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
     curr_lexer->block_comment_nesting_level++;
     promptflag--;
 
     bool eof = false;
-    process_comment (true, eof);
+    curr_lexer->process_comment (true, eof);
   }
 
 %{
 // Other operators.
 %}
 
 ":"     { LEXER_DEBUG (":"); BIN_OP_RETURN (':', false, false); }
 
 ".+"    { LEXER_DEBUG (".+"); XBIN_OP_RETURN (EPLUS, false, false); }
 ".-"    { LEXER_DEBUG (".-"); XBIN_OP_RETURN (EMINUS, false, false); }
 ".*"    { LEXER_DEBUG (".*"); BIN_OP_RETURN (EMUL, false, false); }
 "./"    { LEXER_DEBUG ("./"); BIN_OP_RETURN (EDIV, false, false); }
 ".\\"   { LEXER_DEBUG (".\\"); BIN_OP_RETURN (ELEFTDIV, false, false); }
 ".^"    { LEXER_DEBUG (".^"); BIN_OP_RETURN (EPOW, false, false); }
 ".**"   { LEXER_DEBUG (".**"); XBIN_OP_RETURN (EPOW, false, false); }
-".'"    { LEXER_DEBUG (".'"); do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
-"++"    { LEXER_DEBUG ("++"); do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (PLUS_PLUS, true, false, true); }
-"--"    { LEXER_DEBUG ("--"); do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (MINUS_MINUS, true, false, true); }
+".'"    { LEXER_DEBUG (".'"); curr_lexer->do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
+"++"    { LEXER_DEBUG ("++"); curr_lexer->do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (PLUS_PLUS, true, false, true); }
+"--"    { LEXER_DEBUG ("--"); curr_lexer->do_comma_insert_check (); XBIN_OP_RETURN_INTERNAL (MINUS_MINUS, true, false, true); }
 "<="    { LEXER_DEBUG ("<="); BIN_OP_RETURN (EXPR_LE, false, false); }
 "=="    { LEXER_DEBUG ("=="); BIN_OP_RETURN (EXPR_EQ, false, false); }
 "~="    { LEXER_DEBUG ("~="); BIN_OP_RETURN (EXPR_NE, false, false); }
 "!="    { LEXER_DEBUG ("!="); XBIN_OP_RETURN (EXPR_NE, false, false); }
 ">="    { LEXER_DEBUG (">="); BIN_OP_RETURN (EXPR_GE, false, false); }
 "&"     { LEXER_DEBUG ("&"); BIN_OP_RETURN (EXPR_AND, false, false); }
 "|"     { LEXER_DEBUG ("|"); BIN_OP_RETURN (EXPR_OR, false, false); }
 "<"     { LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false, false); }
@@ -908,17 +882,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
       = (curr_lexer->nesting_level.is_bracket_or_brace ()
          && ! curr_lexer->looking_at_anon_fcn_args);
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
 
     if (curr_lexer->looking_at_anon_fcn_args)
       curr_lexer->looking_at_anon_fcn_args = false;
 
-    do_comma_insert_check ();
+    curr_lexer->do_comma_insert_check ();
 
     COUNT_TOK_AND_RETURN (')');
   }
 
 "." {
     LEXER_DEBUG (".");
 
     curr_lexer->looking_for_object_index = false;
@@ -954,17 +928,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
     curr_lexer->current_input_column += yyleng;
     curr_lexer->quote_is_transpose = false;
     curr_lexer->convert_spaces_to_comma = true;
     curr_lexer->looking_for_object_index = false;
     curr_lexer->at_beginning_of_statement = false;
 
     promptflag--;
-    eat_whitespace ();
+    curr_lexer->eat_whitespace ();
 
     curr_lexer->braceflag++;
     BEGIN (MATRIX_START);
     COUNT_TOK_AND_RETURN ('{');
   }
 
 "}" {
     LEXER_DEBUG ("}");
@@ -981,19 +955,19 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 %{
 // Unrecognized input is a lexical error.
 %}
 
 . {
     LEXER_DEBUG (".");
 
-    xunput (yytext[0], yytext);
-
-    int c = text_yyinput ();
+    curr_lexer->xunput (yytext[0], yytext);
+
+    int c = curr_lexer->text_yyinput ();
 
     if (c != EOF)
       {
         curr_lexer->current_input_column++;
 
         error ("invalid character '%s' (ASCII %d) near line %d, column %d",
                undo_string_escape (static_cast<char> (c)), c,
                curr_lexer->input_line_number, curr_lexer->current_input_column);
@@ -1007,29 +981,29 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %%
 
 // GAG.
 //
 // If we're reading a matrix and the next character is '[', make sure
 // that we insert a comma ahead of it.
 
 void
-do_comma_insert_check (void)
+lexical_feedback::do_comma_insert_check (void)
 {
   bool spc_gobbled = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
 
   int c = text_yyinput ();
 
   xunput (c, yytext);
 
   if (spc_gobbled)
     xunput (' ', yytext);
 
-  curr_lexer->do_comma_insert = (! curr_lexer->looking_at_object_index.front ()
-                                 && curr_lexer->bracketflag && c == '[');
+  do_comma_insert = (! looking_at_object_index.front ()
+                     && bracketflag && c == '[');
 }
 
 // Fix things up for errors or interrupts.  The parser is never called
 // recursively, so it is always safe to reinitialize its state before
 // doing any parsing.
 
 void
 reset_parser (void)
@@ -1212,18 +1186,18 @@ lexical_feedback::~lexical_feedback (voi
 
   while (! token_stack.empty ())
     {
       delete token_stack.top ();
       token_stack.pop ();
     }
 }
 
-static int
-text_yyinput (void)
+int
+lexical_feedback::text_yyinput (void)
 {
   int c = yyinput ();
 
   if (lexer_debug_flag)
     {
       std::cerr << "I: ";
       display_character (c);
       std::cerr << std::endl;
@@ -1245,53 +1219,53 @@ text_yyinput (void)
       if (c != '\n')
         {
           xunput (c, yytext);
           c = '\n';
         }
     }
 
   if (c == '\n')
-    curr_lexer->input_line_number++;
+    input_line_number++;
 
   return c;
 }
 
-static void
-xunput (char c, char *buf)
+void
+lexical_feedback::xunput (char c, char *buf)
 {
   if (lexer_debug_flag)
     {
       std::cerr << "U: ";
       display_character (c);
       std::cerr << std::endl;
     }
 
   if (c == '\n')
-    curr_lexer->input_line_number--;
+    input_line_number--;
 
   yyunput (c, buf);
 }
 
 // If we read some newlines, we need figure out what column we're
 // really looking at.
 
-static void
-fixup_column_count (char *s)
+void
+lexical_feedback::fixup_column_count (char *s)
 {
   char c;
   while ((c = *s++) != '\0')
     {
       if (c == '\n')
         {
-          curr_lexer->input_line_number++;
-          curr_lexer->current_input_column = 1;
+          input_line_number++;
+          current_input_column = 1;
         }
       else
-        curr_lexer->current_input_column++;
+        current_input_column++;
     }
 }
 
 // Include these so that we don't have to link to libfl.a.
 
 int
 yywrap (void)
 {
@@ -1361,41 +1335,41 @@ restore_input_buffer (void *buf)
 // Delete a buffer (for unwind-prot).
 
 void
 delete_input_buffer (void *buf)
 {
   delete_buffer (static_cast<YY_BUFFER_STATE> (buf));
 }
 
-static bool
-inside_any_object_index (void)
+bool
+lexical_feedback::inside_any_object_index (void)
 {
   bool retval = false;
 
-  for (std::list<bool>::const_iterator i = curr_lexer->looking_at_object_index.begin ();
-       i != curr_lexer->looking_at_object_index.end (); i++)
+  for (std::list<bool>::const_iterator i = looking_at_object_index.begin ();
+       i != looking_at_object_index.end (); i++)
     {
       if (*i)
         {
           retval = true;
           break;
         }
     }
 
   return retval;
 }
 
 // Handle keywords.  Return -1 if the keyword should be ignored.
 
-static int
-is_keyword_token (const std::string& s)
+int
+lexical_feedback::is_keyword_token (const std::string& s)
 {
-  int l = curr_lexer->input_line_number;
-  int c = curr_lexer->current_input_column;
+  int l = input_line_number;
+  int c = current_input_column;
 
   int len = s.length ();
 
   const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
   if (kw)
     {
       yylval.tok_val = 0;
@@ -1404,176 +1378,176 @@ is_keyword_token (const std::string& s)
         {
         case break_kw:
         case catch_kw:
         case continue_kw:
         case else_kw:
         case otherwise_kw:
         case return_kw:
         case unwind_protect_cleanup_kw:
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case static_kw:
           if ((reading_fcn_file || reading_script_file
                || reading_classdef_file)
               && ! curr_fcn_file_full_name.empty ())
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d of file '%s'",
-                             curr_lexer->input_line_number,
+                             input_line_number,
                              curr_fcn_file_full_name.c_str ());
           else
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d",
-                             curr_lexer->input_line_number);
+                             input_line_number);
           // fall through ...
 
         case persistent_kw:
           break;
 
         case case_kw:
         case elseif_kw:
         case global_kw:
         case until_kw:
           break;
 
         case end_kw:
           if (inside_any_object_index ()
               || (! reading_classdef_file
-                  && (curr_lexer->defining_func
-                      && ! (curr_lexer->looking_at_return_list
-                            || curr_lexer->parsed_function_name.top ()))))
+                  && (defining_func
+                      && ! (looking_at_return_list
+                            || parsed_function_name.top ()))))
             return 0;
 
           yylval.tok_val = new token (token::simple_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case end_try_catch_kw:
           yylval.tok_val = new token (token::try_catch_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case end_unwind_protect_kw:
           yylval.tok_val = new token (token::unwind_protect_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endfor_kw:
           yylval.tok_val = new token (token::for_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endfunction_kw:
           yylval.tok_val = new token (token::function_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endif_kw:
           yylval.tok_val = new token (token::if_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endparfor_kw:
           yylval.tok_val = new token (token::parfor_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endswitch_kw:
           yylval.tok_val = new token (token::switch_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endwhile_kw:
           yylval.tok_val = new token (token::while_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endclassdef_kw:
           yylval.tok_val = new token (token::classdef_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endenumeration_kw:
           yylval.tok_val = new token (token::enumeration_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endevents_kw:
           yylval.tok_val = new token (token::events_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endmethods_kw:
           yylval.tok_val = new token (token::methods_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
         case endproperties_kw:
           yylval.tok_val = new token (token::properties_end, l, c);
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           break;
 
 
         case for_kw:
         case parfor_kw:
         case while_kw:
           promptflag--;
-          curr_lexer->looping++;
+          looping++;
           break;
 
         case do_kw:
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           promptflag--;
-          curr_lexer->looping++;
+          looping++;
           break;
 
         case try_kw:
         case unwind_protect_kw:
-          curr_lexer->at_beginning_of_statement = true;
+          at_beginning_of_statement = true;
           promptflag--;
           break;
 
         case if_kw:
         case switch_kw:
           promptflag--;
           break;
 
         case get_kw:
         case set_kw:
           // 'get' and 'set' are keywords in classdef method
           // declarations.
-          if (! curr_lexer->maybe_classdef_get_set_method)
+          if (! maybe_classdef_get_set_method)
             return 0;
           break;
 
         case enumeration_kw:
         case events_kw:
         case methods_kw:
         case properties_kw:
           // 'properties', 'methods' and 'events' are keywords for
           // classdef blocks.
-          if (! curr_lexer->parsing_classdef)
+          if (! parsing_classdef)
             return 0;
           // fall through ...
 
         case classdef_kw:
           // 'classdef' is always a keyword.
           promptflag--;
           break;
 
         case function_kw:
           promptflag--;
 
-          curr_lexer->defining_func++;
-          curr_lexer->parsed_function_name.push (false);
+          defining_func++;
+          parsed_function_name.push (false);
 
           if (! (reading_fcn_file || reading_script_file
                  || reading_classdef_file))
-            curr_lexer->input_line_number = 1;
+            input_line_number = 1;
           break;
 
         case magic_file_kw:
           {
             if ((reading_fcn_file || reading_script_file
                  || reading_classdef_file)
                 && ! curr_fcn_file_full_name.empty ())
               yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
@@ -1588,89 +1562,89 @@ is_keyword_token (const std::string& s)
 
         default:
           panic_impossible ();
         }
 
       if (! yylval.tok_val)
         yylval.tok_val = new token (l, c);
 
-      curr_lexer->token_stack.push (yylval.tok_val);
+      token_stack.push (yylval.tok_val);
 
       return kw->tok;
     }
 
   return 0;
 }
 
-static bool
-is_variable (const std::string& name)
+bool
+lexical_feedback::is_variable (const std::string& name)
 {
   return (symbol_table::is_variable (name)
-          || (curr_lexer->pending_local_variables.find (name)
-              != curr_lexer->pending_local_variables.end ()));
+          || (pending_local_variables.find (name)
+              != pending_local_variables.end ()));
 }
 
-static std::string
-grab_block_comment (stream_reader& reader, bool& eof)
+std::string
+lexical_feedback::grab_block_comment (stream_reader& reader, bool& eof)
 {
   std::string buf;
 
   bool at_bol = true;
   bool look_for_marker = false;
 
   bool warned_incompatible = false;
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
-      curr_lexer->current_input_column++;
+      current_input_column++;
 
       if (look_for_marker)
         {
           at_bol = false;
           look_for_marker = false;
 
           if (c == '{' || c == '}')
             {
               std::string tmp_buf (1, static_cast<char> (c));
 
               int type = c;
 
               bool done = false;
 
               while ((c = reader.getc ()) != EOF && ! done)
                 {
-                  curr_lexer->current_input_column++;
+                  current_input_column++;
 
                   switch (c)
                     {
                     case ' ':
                     case '\t':
                       tmp_buf += static_cast<char> (c);
                       break;
 
                     case '\n':
                       {
-                        curr_lexer->current_input_column = 0;
+                        current_input_column = 0;
                         at_bol = true;
                         done = true;
 
                         if (type == '{')
                           {
-                            curr_lexer->block_comment_nesting_level++;
+                            block_comment_nesting_level++;
                             promptflag--;
                           }
                         else
                           {
-                            curr_lexer->block_comment_nesting_level--;
+                            block_comment_nesting_level--;
                             promptflag++;
 
-                            if (curr_lexer->block_comment_nesting_level == 0)
+                            if (block_comment_nesting_level == 0)
                               {
                                 buf += grab_comment_block (reader, true, eof);
 
                                 return buf;
                               }
                           }
                       }
                       break;
@@ -1698,79 +1672,79 @@ grab_block_comment (stream_reader& reade
           look_for_marker = true;
         }
       else
         {
           buf += static_cast<char> (c);
 
           if (c == '\n')
             {
-              curr_lexer->current_input_column = 0;
+              current_input_column = 0;
               at_bol = true;
             }
         }
     }
 
   if (c == EOF)
     eof = true;
 
   return buf;
 }
 
 std::string
-grab_comment_block (stream_reader& reader, bool at_bol,
-                    bool& eof)
+lexical_feedback::grab_comment_block (stream_reader& reader, bool at_bol,
+                                      bool& eof)
 {
   std::string buf;
 
   // TRUE means we are at the beginning of a comment block.
   bool begin_comment = false;
 
   // TRUE means we are currently reading a comment block.
   bool in_comment = false;
 
   bool warned_incompatible = false;
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
-      curr_lexer->current_input_column++;
+      current_input_column++;
 
       if (begin_comment)
         {
           if (c == '%' || c == '#')
             {
               at_bol = false;
               continue;
             }
           else if (at_bol && c == '{')
             {
               std::string tmp_buf (1, static_cast<char> (c));
 
               bool done = false;
 
               while ((c = reader.getc ()) != EOF && ! done)
                 {
-                  curr_lexer->current_input_column++;
+                  current_input_column++;
 
                   switch (c)
                     {
                     case ' ':
                     case '\t':
                       tmp_buf += static_cast<char> (c);
                       break;
 
                     case '\n':
                       {
-                        curr_lexer->current_input_column = 0;
+                        current_input_column = 0;
                         at_bol = true;
                         done = true;
 
-                        curr_lexer->block_comment_nesting_level++;
+                        block_comment_nesting_level++;
                         promptflag--;
 
                         buf += grab_block_comment (reader, eof);
 
                         in_comment = false;
 
                         if (eof)
                           goto done;
@@ -1795,17 +1769,17 @@ grab_comment_block (stream_reader& reade
 
       if (in_comment)
         {
           buf += static_cast<char> (c);
 
           if (c == '\n')
             {
               at_bol = true;
-              curr_lexer->current_input_column = 0;
+              current_input_column = 0;
               in_comment = false;
 
               // FIXME -- bailing out here prevents things like
               //
               //    octave> # comment
               //    octave> x = 1
               //
               // from failing at the command line, while still
@@ -1835,17 +1809,17 @@ grab_comment_block (stream_reader& reade
               // fall through...
 
             case '%':
               in_comment = true;
               begin_comment = true;
               break;
 
             default:
-              curr_lexer->current_input_column--;
+              current_input_column--;
               reader.ungetc (c);
               goto done;
             }
         }
     }
 
  done:
 
@@ -1856,32 +1830,32 @@ grab_comment_block (stream_reader& reade
 }
 
 class
 flex_stream_reader : public stream_reader
 {
 public:
   flex_stream_reader (char *buf_arg) : stream_reader (), buf (buf_arg) { }
 
-  int getc (void) { return ::text_yyinput (); }
-  int ungetc (int c) { ::xunput (c, buf); return 0; }
+  int getc (void) { return curr_lexer->text_yyinput (); }
+  int ungetc (int c) { curr_lexer->xunput (c, buf); return 0; }
 
 private:
 
   // No copying!
 
   flex_stream_reader (const flex_stream_reader&);
 
   flex_stream_reader& operator = (const flex_stream_reader&);
 
   char *buf;
 };
 
-static int
-process_comment (bool start_in_block, bool& eof)
+int
+lexical_feedback::process_comment (bool start_in_block, bool& eof)
 {
   eof = false;
 
   std::string help_txt;
 
   if (! help_buf.empty ())
     help_txt = help_buf.top ();
 
@@ -1892,37 +1866,37 @@ process_comment (bool start_in_block, bo
 
   std::string txt = start_in_block
     ? grab_block_comment (flex_reader, eof)
     : grab_comment_block (flex_reader, false, eof);
 
   if (lexer_debug_flag)
     std::cerr << "C: " << txt << std::endl;
 
-  if (help_txt.empty () && curr_lexer->nesting_level.none ())
+  if (help_txt.empty () && nesting_level.none ())
     {
       if (! help_buf.empty ())
         help_buf.pop ();
 
       help_buf.push (txt);
     }
 
   octave_comment_buffer::append (txt);
 
-  curr_lexer->current_input_column = 1;
-  curr_lexer->quote_is_transpose = false;
-  curr_lexer->convert_spaces_to_comma = true;
-  curr_lexer->at_beginning_of_statement = true;
+  current_input_column = 1;
+  quote_is_transpose = false;
+  convert_spaces_to_comma = true;
+  at_beginning_of_statement = true;
 
   if (YY_START == COMMAND_START)
     BEGIN (INITIAL);
 
-  if (curr_lexer->nesting_level.none ())
+  if (nesting_level.none ())
     return '\n';
-  else if (curr_lexer->nesting_level.is_bracket_or_brace ())
+  else if (nesting_level.is_bracket_or_brace ())
     return ';';
   else
     return 0;
 }
 
 // Return 1 if the given character matches any character in the given
 // string.
 
@@ -1952,35 +1926,35 @@ looks_like_bin_op (bool spc_prev, int ne
   bool spc_next = (next_char == ' ' || next_char == '\t');
 
   return ((spc_prev && spc_next) || ! spc_prev);
 }
 
 // Recognize separators.  If the separator is a CRLF pair, it is
 // replaced by a single LF.
 
-static bool
-next_token_is_sep_op (void)
+bool
+lexical_feedback::next_token_is_sep_op (void)
 {
   bool retval = false;
 
   int c = text_yyinput ();
 
   retval = match_any (c, ",;\n]");
 
   xunput (c, yytext);
 
   return retval;
 }
 
 // Try to determine if the next token should be treated as a postfix
 // unary operator.  This is ugly, but it seems to do the right thing.
 
-static bool
-next_token_is_postfix_unary_op (bool spc_prev)
+bool
+lexical_feedback::next_token_is_postfix_unary_op (bool spc_prev)
 {
   bool un_op = false;
 
   int c0 = text_yyinput ();
 
   if (c0 == '\'' && ! spc_prev)
     {
       un_op = true;
@@ -2016,18 +1990,18 @@ next_token_is_postfix_unary_op (bool spc
 // the square brackets that are used to create matrix objects (though
 // spacing only really matters in the cases that can be interpreted
 // either as binary ops or prefix unary ops: currently just +, -).
 //
 // Note that a line continuation directly following a + or - operator
 // (e.g., the characters '[' 'a' ' ' '+' '\' LFD 'b' ']') will be
 // parsed as a binary operator.
 
-static bool
-next_token_is_bin_op (bool spc_prev)
+bool
+lexical_feedback::next_token_is_bin_op (bool spc_prev)
 {
   bool bin_op = false;
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     case '+':
@@ -2132,18 +2106,18 @@ strip_trailing_whitespace (char *s)
   if (pos != std::string::npos)
     retval.resize (pos);
 
   return retval;
 }
 
 // FIXME -- we need to handle block comments here.
 
-static void
-scan_for_comments (const char *text)
+void
+lexical_feedback::scan_for_comments (const char *text)
 {
   std::string comment_buf;
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
   int len = strlen (text);
   int i = 0;
@@ -2193,31 +2167,31 @@ scan_for_comments (const char *text)
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 }
 
 // Discard whitespace, including comments and continuations.
 
 // FIXME -- we need to handle block comments here.
 
-static int
-eat_whitespace (void)
+int
+lexical_feedback::eat_whitespace (void)
 {
   int retval = lexical_feedback::NO_WHITESPACE;
 
   std::string comment_buf;
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
   int c = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
-      curr_lexer->current_input_column++;
+      current_input_column++;
 
       switch (c)
         {
         case ' ':
         case '\t':
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
@@ -2231,17 +2205,17 @@ eat_whitespace (void)
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               octave_comment_buffer::append (comment_buf);
               comment_buf.resize (0);
               in_comment = false;
               beginning_of_comment = false;
             }
-          curr_lexer->current_input_column = 0;
+          current_input_column = 0;
           break;
 
         case '#':
         case '%':
           if (in_comment)
             {
               if (! beginning_of_comment)
                 comment_buf += static_cast<char> (c);
@@ -2296,28 +2270,28 @@ eat_whitespace (void)
         }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 
  done:
   xunput (c, yytext);
-  curr_lexer->current_input_column--;
+  current_input_column--;
   return retval;
 }
 
 static inline bool
 looks_like_hex (const char *s, int len)
 {
   return (len > 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));
 }
 
-static void
-handle_number (void)
+void
+lexical_feedback::handle_number (void)
 {
   double value = 0.0;
   int nread = 0;
 
   if (looks_like_hex (yytext, strlen (yytext)))
     {
       unsigned long ival;
 
@@ -2338,44 +2312,44 @@ handle_number (void)
 
       delete [] tmp;
     }
 
   // If yytext doesn't contain a valid number, we are in deep doo doo.
 
   assert (nread == 1);
 
-  curr_lexer->quote_is_transpose = true;
-  curr_lexer->convert_spaces_to_comma = true;
-  curr_lexer->looking_for_object_index = false;
-  curr_lexer->at_beginning_of_statement = false;
-
-  yylval.tok_val = new token (value, yytext, curr_lexer->input_line_number,
-                              curr_lexer->current_input_column);
-
-  curr_lexer->token_stack.push (yylval.tok_val);
-
-  curr_lexer->current_input_column += yyleng;
+  quote_is_transpose = true;
+  convert_spaces_to_comma = true;
+  looking_for_object_index = false;
+  at_beginning_of_statement = false;
+
+  yylval.tok_val = new token (value, yytext, input_line_number,
+                              current_input_column);
+
+  token_stack.push (yylval.tok_val);
+
+  current_input_column += yyleng;
 
   do_comma_insert_check ();
 }
 
 // We have seen a backslash and need to find out if it should be
 // treated as a continuation character.  If so, this eats it, up to
 // and including the new line character.
 //
 // Match whitespace only, followed by a comment character or newline.
 // Once a comment character is found, discard all input until newline.
 // If non-whitespace characters are found before comment
 // characters, return 0.  Otherwise, return 1.
 
 // FIXME -- we need to handle block comments here.
 
-static bool
-have_continuation (bool trailing_comments_ok)
+bool
+lexical_feedback::have_continuation (bool trailing_comments_ok)
 {
   std::ostringstream buf;
 
   std::string comment_buf;
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
@@ -2417,17 +2391,17 @@ have_continuation (bool trailing_comment
           break;
 
         case '\n':
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               octave_comment_buffer::append (comment_buf);
             }
-          curr_lexer->current_input_column = 0;
+          current_input_column = 0;
           promptflag--;
           gripe_matlab_incompatible_continuation ();
           return true;
 
         default:
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
@@ -2452,18 +2426,18 @@ cleanup:
 
   return false;
 }
 
 // We have seen a '.' and need to see if it is the start of a
 // continuation.  If so, this eats it, up to and including the new
 // line character.
 
-static bool
-have_ellipsis_continuation (bool trailing_comments_ok)
+bool
+lexical_feedback::have_ellipsis_continuation (bool trailing_comments_ok)
 {
   char c1 = text_yyinput ();
   if (c1 == '.')
     {
       char c2 = text_yyinput ();
       if (c2 == '.' && have_continuation (trailing_comments_ok))
         return true;
       else
@@ -2476,46 +2450,46 @@ have_ellipsis_continuation (bool trailin
     xunput (c1, yytext);
 
   return false;
 }
 
 // See if we have a continuation line.  If so, eat it and the leading
 // whitespace on the next line.
 
-static int
-eat_continuation (void)
+int
+lexical_feedback::eat_continuation (void)
 {
   int retval = lexical_feedback::NO_WHITESPACE;
 
   int c = text_yyinput ();
 
   if ((c == '.' && have_ellipsis_continuation ())
       || (c == '\\' && have_continuation ()))
     retval = eat_whitespace ();
   else
     xunput (c, yytext);
 
   return retval;
 }
 
-static int
-handle_string (char delim)
+int
+lexical_feedback::handle_string (char delim)
 {
   std::ostringstream buf;
 
-  int bos_line = curr_lexer->input_line_number;
-  int bos_col = curr_lexer->current_input_column;
+  int bos_line = input_line_number;
+  int bos_col = current_input_column;
 
   int c;
   int escape_pending = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
-      curr_lexer->current_input_column++;
+      current_input_column++;
 
       if (c == '\\')
         {
           if (delim == '\'' || escape_pending)
             {
               buf << static_cast<char> (c);
               escape_pending = 0;
             }
@@ -2557,47 +2531,47 @@ handle_string (char delim)
                   std::string s;
                   xunput (c, yytext);
 
                   if (delim == '\'')
                     s = buf.str ();
                   else
                     s = do_string_escapes (buf.str ());
 
-                  curr_lexer->quote_is_transpose = true;
-                  curr_lexer->convert_spaces_to_comma = true;
+                  quote_is_transpose = true;
+                  convert_spaces_to_comma = true;
 
                   yylval.tok_val = new token (s, bos_line, bos_col);
-                  curr_lexer->token_stack.push (yylval.tok_val);
+                  token_stack.push (yylval.tok_val);
 
                   if (delim == '"')
                     gripe_matlab_incompatible ("\" used as string delimiter");
                   else if (delim == '\'')
                     gripe_single_quote_string ();
 
-                  curr_lexer->looking_for_object_index = true;
-                  curr_lexer->at_beginning_of_statement = false;
+                  looking_for_object_index = true;
+                  at_beginning_of_statement = false;
 
                   return delim == '"' ? DQ_STRING : SQ_STRING;
                 }
             }
         }
       else
         {
           buf << static_cast<char> (c);
         }
 
       escape_pending = 0;
     }
 
   return LEXICAL_ERROR;
 }
 
-static bool
-next_token_is_assign_op (void)
+bool
+lexical_feedback::next_token_is_assign_op (void)
 {
   bool retval = false;
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     case '=':
@@ -2670,55 +2644,55 @@ next_token_is_assign_op (void)
       break;
     }
 
   xunput (c0, yytext);
 
   return retval;
 }
 
-static bool
-next_token_is_index_op (void)
+bool
+lexical_feedback::next_token_is_index_op (void)
 {
   int c = text_yyinput ();
   xunput (c, yytext);
   return c == '(' || c == '{';
 }
 
-static int
-handle_close_bracket (bool spc_gobbled, int bracket_type)
+int
+lexical_feedback::handle_close_bracket (bool spc_gobbled, int bracket_type)
 {
   int retval = bracket_type;
 
-  if (! curr_lexer->nesting_level.none ())
+  if (! nesting_level.none ())
     {
-      curr_lexer->nesting_level.remove ();
+      nesting_level.remove ();
 
       if (bracket_type == ']')
-        curr_lexer->bracketflag--;
+        bracketflag--;
       else if (bracket_type == '}')
-        curr_lexer->braceflag--;
+        braceflag--;
       else
         panic_impossible ();
     }
 
-  if (curr_lexer->bracketflag == 0 && curr_lexer->braceflag == 0)
+  if (bracketflag == 0 && braceflag == 0)
     BEGIN (INITIAL);
 
   if (bracket_type == ']'
       && next_token_is_assign_op ()
-      && ! curr_lexer->looking_at_return_list)
+      && ! looking_at_return_list)
     {
       retval = CLOSE_BRACE;
     }
-  else if ((curr_lexer->bracketflag || curr_lexer->braceflag)
-           && curr_lexer->convert_spaces_to_comma
-           && (curr_lexer->nesting_level.is_bracket ()
-               || (curr_lexer->nesting_level.is_brace ()
-                   && ! curr_lexer->looking_at_object_index.front ())))
+  else if ((bracketflag || braceflag)
+           && convert_spaces_to_comma
+           && (nesting_level.is_bracket ()
+               || (nesting_level.is_brace ()
+                   && ! looking_at_object_index.front ())))
     {
       bool index_op = next_token_is_index_op ();
 
       // Don't insert comma if we are looking at something like
       //
       //   [x{i}{j}] or [x{i}(j)]
       //
       // but do if we are looking at
@@ -2738,28 +2712,28 @@ handle_close_bracket (bool spc_gobbled, 
               maybe_warn_separator_insert (',');
 
               xunput (',', yytext);
               return retval;
             }
         }
     }
 
-  curr_lexer->quote_is_transpose = true;
-  curr_lexer->convert_spaces_to_comma = true;
+  quote_is_transpose = true;
+  convert_spaces_to_comma = true;
 
   return retval;
 }
 
-static void
-maybe_unput_comma (int spc_gobbled)
+void
+lexical_feedback::maybe_unput_comma (int spc_gobbled)
 {
-  if (curr_lexer->nesting_level.is_bracket ()
-      || (curr_lexer->nesting_level.is_brace ()
-          && ! curr_lexer->looking_at_object_index.front ()))
+  if (nesting_level.is_bracket ()
+      || (nesting_level.is_brace ()
+          && ! looking_at_object_index.front ()))
     {
       int bin_op = next_token_is_bin_op (spc_gobbled);
 
       int postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
 
       int c1 = text_yyinput ();
       int c2 = text_yyinput ();
 
@@ -2783,18 +2757,18 @@ maybe_unput_comma (int spc_gobbled)
         return;
 
       maybe_warn_separator_insert (',');
 
       xunput (',', yytext);
     }
 }
 
-static bool
-next_token_can_follow_bin_op (void)
+bool
+lexical_feedback::next_token_can_follow_bin_op (void)
 {
   std::stack<char> buf;
 
   int c = EOF;
 
   // Skip whitespace in current statement on current line
   while (true)
     {
@@ -2825,18 +2799,18 @@ can_be_command (const std::string& tok)
 
   return ! (tok == "e"
             || tok == "I" || tok == "i"
             || tok == "J" || tok == "j"
             || tok == "Inf" || tok == "inf"
             || tok == "NaN" || tok == "nan");
 }
 
-static bool
-looks_like_command_arg (void)
+bool
+lexical_feedback::looks_like_command_arg (void)
 {
   bool retval = true;
 
   int c0 = text_yyinput ();
 
   switch (c0)
     {
     // = ==
@@ -3047,18 +3021,18 @@ looks_like_command_arg (void)
       break;
     }
 
   xunput (c0, yytext);
 
   return retval;
 }
 
-static int
-handle_superclass_identifier (void)
+int
+lexical_feedback::handle_superclass_identifier (void)
 {
   eat_continuation ();
 
   std::string pkg;
   std::string meth = strip_trailing_whitespace (yytext);
   size_t pos = meth.find ("@");
   std::string cls = meth.substr (pos).substr (1);
   meth = meth.substr (0, pos - 1);
@@ -3077,28 +3051,28 @@ handle_superclass_identifier (void)
       error ("method, class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
   yylval.tok_val
     = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
                  cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 curr_lexer->input_line_number,
-                 curr_lexer->current_input_column);
-  curr_lexer->token_stack.push (yylval.tok_val);
-
-  curr_lexer->convert_spaces_to_comma = true;
-  curr_lexer->current_input_column += yyleng;
+                 input_line_number,
+                 current_input_column);
+  token_stack.push (yylval.tok_val);
+
+  convert_spaces_to_comma = true;
+  current_input_column += yyleng;
 
   return SUPERCLASSREF;
 }
 
-static int
-handle_meta_identifier (void)
+int
+lexical_feedback::handle_meta_identifier (void)
 {
   eat_continuation ();
 
   std::string pkg;
   std::string cls = strip_trailing_whitespace (yytext).substr (1);
   size_t pos = cls.find (".");
 
   if (pos != std::string::npos)
@@ -3112,117 +3086,117 @@ handle_meta_identifier (void)
     {
        error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
   yylval.tok_val
     = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 curr_lexer->input_line_number,
-                 curr_lexer->current_input_column);
-
-  curr_lexer->token_stack.push (yylval.tok_val);
-
-  curr_lexer->convert_spaces_to_comma = true;
-  curr_lexer->current_input_column += yyleng;
+                 input_line_number,
+                 current_input_column);
+
+  token_stack.push (yylval.tok_val);
+
+  convert_spaces_to_comma = true;
+  current_input_column += yyleng;
 
   return METAQUERY;
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
-static int
-handle_identifier (void)
+int
+lexical_feedback::handle_identifier (void)
 {
-  bool at_bos = curr_lexer->at_beginning_of_statement;
+  bool at_bos = at_beginning_of_statement;
 
   std::string tok = strip_trailing_whitespace (yytext);
 
   int c = yytext[yyleng-1];
 
   bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
 
   int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
   // If we are expecting a structure element, avoid recognizing
   // keywords and other special names and return STRUCT_ELT, which is
   // a string that is also a valid identifier.  But first, we have to
   // decide whether to insert a comma.
 
-  if (curr_lexer->looking_at_indirect_ref)
+  if (looking_at_indirect_ref)
     {
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
 
-      yylval.tok_val = new token (tok, curr_lexer->input_line_number,
-                                  curr_lexer->current_input_column);
-
-      curr_lexer->token_stack.push (yylval.tok_val);
-
-      curr_lexer->quote_is_transpose = true;
-      curr_lexer->convert_spaces_to_comma = true;
-      curr_lexer->looking_for_object_index = true;
-
-      curr_lexer->current_input_column += yyleng;
+      yylval.tok_val = new token (tok, input_line_number,
+                                  current_input_column);
+
+      token_stack.push (yylval.tok_val);
+
+      quote_is_transpose = true;
+      convert_spaces_to_comma = true;
+      looking_for_object_index = true;
+
+      current_input_column += yyleng;
 
       return STRUCT_ELT;
     }
 
-  curr_lexer->at_beginning_of_statement = false;
+  at_beginning_of_statement = false;
 
   // The is_keyword_token may reset
-  // curr_lexer->at_beginning_of_statement.  For example, if it sees
+  // at_beginning_of_statement.  For example, if it sees
   // an else token, then the next token is at the beginning of a
   // statement.
 
   int kw_token = is_keyword_token (tok);
 
   // If we found a keyword token, then the beginning_of_statement flag
   // is already set.  Otherwise, we won't be at the beginning of a
   // statement.
 
-  if (curr_lexer->looking_at_function_handle)
+  if (looking_at_function_handle)
     {
       if (kw_token)
         {
           error ("function handles may not refer to keywords");
 
           return LEXICAL_ERROR;
         }
       else
         {
-          yylval.tok_val = new token (tok, curr_lexer->input_line_number,
-                                      curr_lexer->current_input_column);
-
-          curr_lexer->token_stack.push (yylval.tok_val);
-
-          curr_lexer->current_input_column += yyleng;
-          curr_lexer->quote_is_transpose = false;
-          curr_lexer->convert_spaces_to_comma = true;
-          curr_lexer->looking_for_object_index = true;
+          yylval.tok_val = new token (tok, input_line_number,
+                                      current_input_column);
+
+          token_stack.push (yylval.tok_val);
+
+          current_input_column += yyleng;
+          quote_is_transpose = false;
+          convert_spaces_to_comma = true;
+          looking_for_object_index = true;
 
           return FCN_HANDLE;
         }
     }
 
   // If we have a regular keyword, return it.
   // Keywords can be followed by identifiers.
 
   if (kw_token)
     {
       if (kw_token >= 0)
         {
-          curr_lexer->current_input_column += yyleng;
-          curr_lexer->quote_is_transpose = false;
-          curr_lexer->convert_spaces_to_comma = true;
-          curr_lexer->looking_for_object_index = false;
+          current_input_column += yyleng;
+          quote_is_transpose = false;
+          convert_spaces_to_comma = true;
+          looking_for_object_index = false;
         }
 
       return kw_token;
     }
 
   // See if we have a plot keyword (title, using, with, or clear).
 
   int c1 = text_yyinput ();
@@ -3252,59 +3226,59 @@ handle_identifier (void)
   if (! is_variable (tok))
     {
       if (at_bos && spc_gobbled && can_be_command (tok)
           && looks_like_command_arg ())
         {
           BEGIN (COMMAND_START);
         }
       else if (next_tok_is_eq
-               || curr_lexer->looking_at_decl_list
-               || curr_lexer->looking_at_return_list
-               || (curr_lexer->looking_at_parameter_list
-                   && ! curr_lexer->looking_at_initializer_expression))
+               || looking_at_decl_list
+               || looking_at_return_list
+               || (looking_at_parameter_list
+                   && ! looking_at_initializer_expression))
         {
           symbol_table::force_variable (tok);
         }
-      else if (curr_lexer->looking_at_matrix_or_assign_lhs)
+      else if (looking_at_matrix_or_assign_lhs)
         {
-          curr_lexer->pending_local_variables.insert (tok);
+          pending_local_variables.insert (tok);
         }
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";
 
   yylval.tok_val = new token (&(symbol_table::insert (tok)),
-                              curr_lexer->input_line_number,
-                              curr_lexer->current_input_column);
-
-  curr_lexer->token_stack.push (yylval.tok_val);
+                              input_line_number,
+                              current_input_column);
+
+  token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
-  curr_lexer->convert_spaces_to_comma = true;
+  convert_spaces_to_comma = true;
 
   if (! (next_tok_is_eq || YY_START == COMMAND_START))
     {
-      curr_lexer->quote_is_transpose = true;
+      quote_is_transpose = true;
 
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
     }
 
-  curr_lexer->current_input_column += yyleng;
+  current_input_column += yyleng;
 
   if (tok != "__end__")
-    curr_lexer->looking_for_object_index = true;
+    looking_for_object_index = true;
 
   return NAME;
 }
 
 bool
 is_keyword (const std::string& s)
 {
   // Parsing function names like "set.property_name" inside
@@ -3445,76 +3419,76 @@ octave_read (char *buf, unsigned max_siz
 
       if (! eof)
         YY_FATAL_ERROR ("octave_read () in flex scanner failed");
     }
 
   return status;
 }
 
-static void
-maybe_warn_separator_insert (char sep)
+void
+lexical_feedback::maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d",
-                     sep, curr_lexer->input_line_number);
+                     sep, input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d of file %s",
-                     sep, curr_lexer->input_line_number, nm.c_str ());
+                     sep, input_line_number, nm.c_str ());
 }
 
-static void
-gripe_single_quote_string (void)
+void
+lexical_feedback::gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d",
-                     curr_lexer->input_line_number);
+                     input_line_number);
   else
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d of file %s",
-                     curr_lexer->input_line_number, nm.c_str ());
+                     input_line_number, nm.c_str ());
 }
 
-static void
-gripe_matlab_incompatible (const std::string& msg)
+void
+lexical_feedback::gripe_matlab_incompatible (const std::string& msg)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s",
                      msg.c_str ());
   else
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s near line %d offile %s",
-                     msg.c_str (), curr_lexer->input_line_number, nm.c_str ());
+                     msg.c_str (), input_line_number, nm.c_str ());
 }
 
-static void
-maybe_gripe_matlab_incompatible_comment (char c)
+void
+lexical_feedback::maybe_gripe_matlab_incompatible_comment (char c)
 {
   if (c == '#')
     gripe_matlab_incompatible ("# used as comment character");
 }
 
-static void
-gripe_matlab_incompatible_continuation (void)
+void
+lexical_feedback::gripe_matlab_incompatible_continuation (void)
 {
   gripe_matlab_incompatible ("\\ used as line continuation marker");
 }
 
-static void
-gripe_matlab_incompatible_operator (const std::string& op)
+void
+lexical_feedback::gripe_matlab_incompatible_operator (const std::string& op)
 {
   std::string t = op;
   int n = t.length ();
   if (t[n-1] == '\n')
     t.resize (n-1);
   gripe_matlab_incompatible (t + " used as operator");
 }
 
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -3407,17 +3407,17 @@ gobble_leading_white_space (FILE *ffile,
 
   while (true)
     {
       eof = skip_white_space (stdio_reader);
 
       if (eof)
         break;
 
-      txt = grab_comment_block (stdio_reader, true, eof);
+      txt = curr_lexer->grab_comment_block (stdio_reader, true, eof);
 
       if (txt.empty ())
         break;
 
       if (! (have_help_text || looks_like_copyright (txt)))
         {
           help_txt = txt;
           have_help_text = true;
