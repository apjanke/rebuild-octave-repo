# HG changeset patch
# User Rik <rik@octave.org>
# Date 1456071036 28800
#      Sun Feb 21 08:10:36 2016 -0800
# Node ID a4faec57f4c819895e746b4d87daad8d836c05a4
# Parent  6cc091426e524edcc574151c448229e8b7698381
maint: remove semicolon after %!assert tests to follow Octave conventions.

* testfun.txi: Remove semicolons from examples in manual and update remaider
of text to reflect changes.

* bsxfun.cc, cellfun.cc, data.cc, hash.cc, lu.cc, nproc.cc,
rcond.cc, regexp.cc, sparse-xpow.cc, strfns.cc, symtab.cc, time.cc,
variables.cc, ov-class.cc, ov-cx-diag.cc, ov-struct.cc, ov.cc, oct-parse.in.yy,
pt-mat.cc, CMatrix.cc, oct-inttypes.cc, md5sum.m, blkdiag.m, cell2mat.m,
interp1.m, interp2.m, interpft.m, num2str.m, repmat.m, ntsc2rgb.m, expm.m,
inputname.m, polyvalm.m, blackman.m, hamming.m, hanning.m, eigs.m, median.m,
binopdf.m, strsplit.m, strtok.m, assert.m, example.m, datevec.m, bug-38565.tst,
build-sparse-tests.sh, classdef.tst, classes.tst, diag-perm.tst, index.tst,
io.tst, logical-index.tst, nest.tst, parser.tst, prefer.tst, struct.tst:
maint: remove semicolon after %!assert tests to follow Octave conventions.

diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -170,53 +170,53 @@ with other blocks.  If you do want to sh
 must declare them as @code{shared} before you use them.  For example, the
 following declares the variable @var{a}, gives it an initial value (default
 is empty), and then uses it in several subsequent tests.
 
 @example
 @group
 %!shared @var{a}
 %! @var{a} = [1, 2, 3; 4, 5, 6];
-%!assert (kron ([1; 2], @var{a}), [ @var{a}; 2*@var{a} ]);
-%!assert (kron ([1, 2], @var{a}), [ @var{a}, 2*@var{a} ]);
-%!assert (kron ([1,2; 3,4], @var{a}), [ @var{a},2*@var{a}; 3*@var{a},4*@var{a} ]);
+%!assert (kron ([1; 2], @var{a}), [ @var{a}; 2*@var{a} ])
+%!assert (kron ([1, 2], @var{a}), [ @var{a}, 2*@var{a} ])
+%!assert (kron ([1,2; 3,4], @var{a}), [ @var{a},2*@var{a}; 3*@var{a},4*@var{a} ])
 @end group
 @end example
 
 You can share several variables at the same time:
 
 @example
 %!shared @var{a}, @var{b}
 @end example
 
 You can also share test functions:
 
 @example
 @group
 %!function @var{a} = fn (@var{b})
 %!  @var{a} = 2*@var{b};
 %!endfunction
-%!assert (fn(2), 4);
+%!assert (fn(2), 4)
 @end group
 @end example
 
 Note that all previous variables and values are lost when a new
 shared block is declared.
 
 Remember that @code{%!function} begins a new block and that
 @code{%!endfunction} ends this block.  Be aware that until a new block
 is started, lines starting with @samp{%!<space>} will be discarded as comments.
 The following is nearly identical to the example above, but does nothing.
 
 @example
 @group
 %!function @var{a} = fn (@var{b})
 %!  @var{a} = 2*@var{b};
 %!endfunction
-%! assert (fn(2), 4);
+%!assert (fn(2), 4)
 @end group
 @end example
 
 @noindent
 Because there is a space after @samp{%!} the @code{assert} statement does
 not begin a new block and this line is treated as a comment.
 
 Error and warning blocks are like test blocks, but they only succeed
@@ -297,39 +297,39 @@ fail, assert, error and xtest:
 @group
 function output = must_be_zero (@var{input})
   if (@var{input} != 0)
     error ("Nonzero input!")
   endif
   output = input;
 endfunction
 
-%!fail ("must_be_zero (1)");
-%!assert (must_be_zero (0), 0);
-%!error <Nonzero> must_be_zero (1);
-%!xtest error ("This code generates an error");
+%!fail ("must_be_zero (1)")
+%!assert (must_be_zero (0), 0)
+%!error <Nonzero> must_be_zero (1)
+%!xtest error ("This code generates an error")
 @end group
 @end example
 
 @noindent
-When putting this a file @file{must_be_zero.m}, and running the test, we see
+When putting this in a file @file{must_be_zero.m}, and running the test, we see
 
 @example
 @group
 test must_be_zero verbose
 
 @result{}
 >>>>> /path/to/must_be_zero.m
-  ***** fail ("must_be_zero (1)");
-  ***** assert (must_be_zero (0), 0);
-  ***** error <Nonzero> must_be_zero (1);
-  ***** xtest error ("This code generates an error");
+***** fail ("must_be_zero (1)")
+***** assert (must_be_zero (0), 0)
+***** error <Nonzero> must_be_zero (1)
+***** xtest error ("This code generates an error")
 !!!!! known failure
 This code generates an error
-PASSES 4 out of 4 tests (1 expected failures)
+PASSES 3 out of 4 tests (1 expected failure)
 @end group
 @end example
 
 @subsubheading Block type summary:
 
 @table @code
 @item %!test
 check that entire block is correct
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -736,17 +736,17 @@ dimensionality as the other array.\n\
 %!assert (bsxfun (f, ones ([4, 1, 4]), ones ([1, 4, 4])), zeros ([4, 4, 4]))
 %!assert (bsxfun (f, ones ([4, 1, 4]), ones ([1, 4, 1])), zeros ([4, 4, 4]))
 %!assert (bsxfun (f, a, b), a - repmat (b, [4, 1, 1]))
 %!assert (bsxfun (f, a, c), a - repmat (c, [1, 4, 1]))
 %!assert (bsxfun (f, a, d), a - repmat (d, [1, 1, 4]))
 %!assert (bsxfun ("minus", ones ([4, 0, 4]), ones ([4, 1, 4])), zeros ([4, 0, 4]))
 
 %% The test below is a very hard case to treat
-%!assert (bsxfun (f, ones ([4, 1, 4, 1]), ones ([1, 4, 1, 4])), zeros ([4, 4, 4, 4]));
+%!assert (bsxfun (f, ones ([4, 1, 4, 1]), ones ([1, 4, 1, 4])), zeros ([4, 4, 4, 4]))
 
 %!shared a, b, aa, bb
 %! a = randn (3, 1, 3);
 %! aa = a(:, ones (1, 3), :, ones (1, 3));
 %! b = randn (1, 3, 3, 3);
 %! bb = b(ones (1, 3), :, :, :);
 %!assert (bsxfun (@plus, a, b), aa + bb)
 %!assert (bsxfun (@minus, a, b), aa - bb)
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -975,20 +975,20 @@ v = cellfun (@@det, a); # faster\n\
 %!assert (cellfun (@(x) x(2),{[1],[1,2]},"ErrorHandler",@(x,y) NaN), [NaN,2])
 %!test
 %! [a,b,c] = cellfun (@fileparts, {fullfile("a","b","c.d"), fullfile("e","f","g.h")}, "UniformOutput", false);
 %! assert (a, {fullfile("a","b"), fullfile("e","f")});
 %! assert (b, {"c", "g"});
 %! assert (c, {".d", ".h"});
 
 ## Tests for bug #40467
-%!assert (cellfun (@isreal, {1 inf nan []}), [true, true, true, true]);
-%!assert (cellfun (@isreal, {1 inf nan []}, "UniformOutput", false), {true, true, true, true});
-%!assert (cellfun (@iscomplex, {1 inf nan []}), [false, false, false, false]);
-%!assert (cellfun (@iscomplex, {1 inf nan []}, "UniformOutput", false), {false, false, false, false});
+%!assert (cellfun (@isreal, {1 inf nan []}), [true, true, true, true])
+%!assert (cellfun (@isreal, {1 inf nan []}, "UniformOutput", false), {true, true, true, true})
+%!assert (cellfun (@iscomplex, {1 inf nan []}), [false, false, false, false])
+%!assert (cellfun (@iscomplex, {1 inf nan []}, "UniformOutput", false), {false, false, false, false})
 
 %!error cellfun (1)
 %!error cellfun ("isclass", 1)
 %!error cellfun ("size", 1)
 %!error cellfun (@sin, {[]}, "BadParam", false)
 %!error cellfun (@sin, {[]}, "UniformOuput")
 %!error cellfun (@sin, {[]}, "ErrorHandler")
 */
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -697,20 +697,20 @@ periodic, @code{mod} is a better choice.
 %!assert (size (rem (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (rem (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (rem (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (rem (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (rem (1, 2)), [1, 1])
 
 %!assert (rem ([1, 2, 3; -1, -2, -3], 2), [1, 0, 1; -1, 0, -1])
 %!assert (rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3)),[1, 0, 1; -1, 0, -1])
-%!assert (rem ([0, 1, 2], [0, 0, 1]), [NaN, NaN, 0]);
+%!assert (rem ([0, 1, 2], [0, 0, 1]), [NaN, NaN, 0])
 %!assert (rem (uint8 ([1, 2, 3; -1, -2, -3]), uint8 (2)), uint8 ([1, 0, 1; -1, 0, -1]))
 %!assert (uint8 (rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3))),uint8 ([1, 0, 1; -1, 0, -1]))
-%!assert (rem (uint8 ([0, 1, 2]), [0, 0, 1]), uint8 ([0, 0, 0]));
+%!assert (rem (uint8 ([0, 1, 2]), [0, 0, 1]), uint8 ([0, 0, 0]))
 
 ## Test sparse implementations
 %!shared xs
 %! xs = sparse (0:3);
 %!test
 %! y = rem (11, xs);
 %! assert (isnan (y(1)));
 %! assert (y, sparse (rem (11, 0:3)));
@@ -1436,19 +1436,19 @@ Given a matrix argument, instead of a ve
 
 ## bug #37411
 %!assert (diag (diag ([5, 2, 3])(:,1)), diag([5 0 0 ]))
 %!assert (diag (diag ([5, 2, 3])(:,1), 2),  [0 0 5 0 0; zeros(4, 5)])
 %!assert (diag (diag ([5, 2, 3])(:,1), -2), [[0 0 5 0 0]', zeros(5, 4)])
 
 ## Test non-square size
 %!assert (diag ([1,2,3], 6, 3), [1 0 0; 0 2 0; 0 0 3; 0 0 0; 0 0 0; 0 0 0])
-%!assert (diag (1, 2, 3), [1,0,0; 0,0,0]);
-%!assert (diag ({1}, 2, 3), {1,[],[]; [],[],[]});
-%!assert (diag ({1,2}, 3, 4), {1,[],[],[]; [],2,[],[]; [],[],[],[]});
+%!assert (diag (1, 2, 3), [1,0,0; 0,0,0])
+%!assert (diag ({1}, 2, 3), {1,[],[]; [],[],[]})
+%!assert (diag ({1,2}, 3, 4), {1,[],[],[]; [],2,[],[]; [],[],[],[]})
 
 ## Test out-of-range diagonals
 %!assert (diag (ones (3,3), 4), zeros (0, 1))
 %!assert (diag (cell (3,3), 4), cell (0, 1))
 %!assert (diag (sparse (ones (3,3)), 4), sparse (zeros (0, 1)))
 
 %% Test input validation
 %!error <Invalid call to diag> diag ()
@@ -2141,18 +2141,18 @@ new matrices.  For example:\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -2, "horzcat");
 }
 
 /*
 ## Test concatenation with all zero matrices
-%!assert (horzcat ("", 65*ones (1,10)), "AAAAAAAAAA");
-%!assert (horzcat (65*ones (1,10), ""), "AAAAAAAAAA");
+%!assert (horzcat ("", 65*ones (1,10)), "AAAAAAAAAA")
+%!assert (horzcat (65*ones (1,10), ""), "AAAAAAAAAA")
 
 %!assert (class (horzcat (int64 (1), int64 (1))), "int64")
 %!assert (class (horzcat (int64 (1), int32 (1))), "int64")
 %!assert (class (horzcat (int64 (1), int16 (1))), "int64")
 %!assert (class (horzcat (int64 (1), int8 (1))), "int64")
 %!assert (class (horzcat (int64 (1), uint64 (1))), "int64")
 %!assert (class (horzcat (int64 (1), uint32 (1))), "int64")
 %!assert (class (horzcat (int64 (1), uint16 (1))), "int64")
@@ -5708,25 +5708,25 @@ compute the norms of each column and ret
 %! m2 = single ([1,2;3,4]);
 %! flo = single (1e-300);
 %! fhi = single (1e+300);
 %!assert (norm (flo*m2,"fro"), single (sqrt (30)*flo), -eps ("single"))
 %!assert (norm (fhi*m2,"fro"), single (sqrt (30)*fhi), -eps ("single"))
 
 %!shared q
 %! q = rand (1e3, 3);
-%!assert (norm (q, 3, "rows"), sum (q.^3, 2).^(1/3), sqrt (eps));
-%!assert (norm (q, "fro", "rows"), sum (q.^2, 2).^(1/2), sqrt (eps));
-%!assert (norm (q, "fro", "rows"), sqrt (sumsq (q, 2)), sqrt (eps));
-%!assert (norm (q, "fro", "cols"), sqrt (sumsq (q, 1)), sqrt (eps));
-%!assert (norm (q, 3, "cols"), sum (q.^3, 1).^(1/3), sqrt (eps));
-%!assert (norm (q, "inf", "rows"), norm (q, Inf, "rows"));
-%!assert (norm (q, "inf", "cols"), norm (q, Inf, "cols"));
-%!assert (norm (q, [], "rows"), norm (q, 2, "rows"));
-%!assert (norm (q, [], "cols"), norm (q, 2, "cols"));
+%!assert (norm (q, 3, "rows"), sum (q.^3, 2).^(1/3), sqrt (eps))
+%!assert (norm (q, "fro", "rows"), sum (q.^2, 2).^(1/2), sqrt (eps))
+%!assert (norm (q, "fro", "rows"), sqrt (sumsq (q, 2)), sqrt (eps))
+%!assert (norm (q, "fro", "cols"), sqrt (sumsq (q, 1)), sqrt (eps))
+%!assert (norm (q, 3, "cols"), sum (q.^3, 1).^(1/3), sqrt (eps))
+%!assert (norm (q, "inf", "rows"), norm (q, Inf, "rows"))
+%!assert (norm (q, "inf", "cols"), norm (q, Inf, "cols"))
+%!assert (norm (q, [], "rows"), norm (q, 2, "rows"))
+%!assert (norm (q, [], "cols"), norm (q, 2, "cols"))
 
 %!test
 %! ## Test for norm returning NaN on sparse matrix (bug #30631)
 %! A = sparse (2,2);
 %! A(2,1) = 1;
 %! assert (norm (A), 1);
 */
 
diff --git a/libinterp/corefcn/hash.cc b/libinterp/corefcn/hash.cc
--- a/libinterp/corefcn/hash.cc
+++ b/libinterp/corefcn/hash.cc
@@ -179,61 +179,61 @@ hash (\"md5\", fileread (file));\n\
          << (static_cast<int> (result_buffer[i]) & 0xFF);
     }
 
   return ovl (os.str ());
 }
 
 /*
 ## MD2 test suite (RFC 1319)
-%!assert (hash ("md2", ""), "8350e5a3e24c153df2275c9f80692773");
-%!assert (hash ("md2", "a"), "32ec01ec4a6dac72c0ab96fb34c0b5d1");
-%!assert (hash ("md2", "abc"), "da853b0d3f88d99b30283a69e6ded6bb");
-%!assert (hash ("md2", "message digest"), "ab4f496bfb2a530b219ff33031fe06b0");
+%!assert (hash ("md2", ""), "8350e5a3e24c153df2275c9f80692773")
+%!assert (hash ("md2", "a"), "32ec01ec4a6dac72c0ab96fb34c0b5d1")
+%!assert (hash ("md2", "abc"), "da853b0d3f88d99b30283a69e6ded6bb")
+%!assert (hash ("md2", "message digest"), "ab4f496bfb2a530b219ff33031fe06b0")
 %!assert (hash ("md2", "abcdefghijklmnopqrstuvwxyz"),
 %!        "4e8ddff3650292ab5a4108c3aa47940b");
 %!assert (hash ("md2", ["ABCDEFGHIJKLMNOPQRSTUVWXYZ", ...
 %!              "abcdefghijklmnopqrstuvwxyz0123456789"]),
 %!        "da33def2a42df13975352846c30338cd");
 %!assert (hash ("md2", ["123456789012345678901234567890123456789", ...
 %!              "01234567890123456789012345678901234567890"]),
 %!        "d5976f79d83d3a0dc9806c3c66f3efd8");
 
 ## MD4 test suite (RFC 1320)
-%!assert (hash ("md4", ""), "31d6cfe0d16ae931b73c59d7e0c089c0");
-%!assert (hash ("md4", "a"), "bde52cb31de33e46245e05fbdbd6fb24");
-%!assert (hash ("md4", "abc"), "a448017aaf21d8525fc10ae87aa6729d");
-%!assert (hash ("md4", "message digest"), "d9130a8164549fe818874806e1c7014b");
+%!assert (hash ("md4", ""), "31d6cfe0d16ae931b73c59d7e0c089c0")
+%!assert (hash ("md4", "a"), "bde52cb31de33e46245e05fbdbd6fb24")
+%!assert (hash ("md4", "abc"), "a448017aaf21d8525fc10ae87aa6729d")
+%!assert (hash ("md4", "message digest"), "d9130a8164549fe818874806e1c7014b")
 %!assert (hash ("md4", "abcdefghijklmnopqrstuvwxyz"),
 %!        "d79e1c308aa5bbcdeea8ed63df412da9");
 %!assert (hash ("md4", ["ABCDEFGHIJKLMNOPQRSTUVWXYZ", ...
 %!              "abcdefghijklmnopqrstuvwxyz0123456789"]),
 %!        "043f8582f241db351ce627e153e7f0e4");
 %!assert (hash ("md4", ["123456789012345678901234567890123456789", ...
 %!              "01234567890123456789012345678901234567890"]),
 %!        "e33b4ddc9c38f2199c3e7b164fcc0536");
 
 ## MD5 test suite (RFC 1321)
-%!assert (hash ("md5", ""), "d41d8cd98f00b204e9800998ecf8427e");
-%!assert (hash ("md5", "a"), "0cc175b9c0f1b6a831c399e269772661");
-%!assert (hash ("md5", "abc"), "900150983cd24fb0d6963f7d28e17f72");
-%!assert (hash ("md5", "message digest"), "f96b697d7cb7938d525a2f31aaf161d0");
+%!assert (hash ("md5", ""), "d41d8cd98f00b204e9800998ecf8427e")
+%!assert (hash ("md5", "a"), "0cc175b9c0f1b6a831c399e269772661")
+%!assert (hash ("md5", "abc"), "900150983cd24fb0d6963f7d28e17f72")
+%!assert (hash ("md5", "message digest"), "f96b697d7cb7938d525a2f31aaf161d0")
 %!assert (hash ("md5", "abcdefghijklmnopqrstuvwxyz"),
 %!        "c3fcd3d76192e4007dfb496cca67e13b");
 %!assert (hash ("md5", ["ABCDEFGHIJKLMNOPQRSTUVWXYZ", ...
 %!              "abcdefghijklmnopqrstuvwxyz0123456789"]),
 %!        "d174ab98d277d9f5a5611c2c9f419d9f");
 %!assert (hash ("md5", ["123456789012345678901234567890123456789", ...
 %!              "01234567890123456789012345678901234567890"]),
 %!        "57edf4a22be3c955ac49da2e2107b67a");
 
 ## SHA1 test suite (RFC 3174) and more
-%!assert (hash ("sha1", ""), "da39a3ee5e6b4b0d3255bfef95601890afd80709");
-%!assert (hash ("sha1", "a"), "86f7e437faa5a7fce15d1ddcb9eaeaea377667b8");
-%!assert (hash ("sha1", "abc"), "a9993e364706816aba3e25717850c26c9cd0d89d");
+%!assert (hash ("sha1", ""), "da39a3ee5e6b4b0d3255bfef95601890afd80709")
+%!assert (hash ("sha1", "a"), "86f7e437faa5a7fce15d1ddcb9eaeaea377667b8")
+%!assert (hash ("sha1", "abc"), "a9993e364706816aba3e25717850c26c9cd0d89d")
 %!assert (hash ("sha1", ["abcdbcdecdefdefgefghfghighijhi", ...
 %!              "jkijkljklmklmnlmnomnopnopq"]),
 %!        "84983e441c3bd26ebaae4aa1f95129e5e54670f1");
 %!assert (hash ("sha1", ["01234567012345670123456701234567", ...
 %!              "01234567012345670123456701234567"]),
 %!        "e0c094e867ef46c350ef54a7f59dd60bed92ae83");
 %!assert (hash ("sha1", "The quick brown fox jumps over the lazy dog"),
 %!        "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12");
@@ -256,20 +256,20 @@ hash (\"md5\", fileread (file));\n\
 %!        ["38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc", ...
 %!         "7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"]);
 %!assert (hash ("sha512", ""),
 %!        ["cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a", ...
 %!         "921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47", ...
 %!         "417a81a538327af927da3e"]);
 
 ## Test special character behavior (bug #31689)
-%!assert (hash ("md2", "abc\0"), "5a636d615002a7874ac1c9e9a43361f7");
-%!assert (hash ("md4", "abc\0"), "0ee5201897ecb206c4eaba1d2da5224d");
-%!assert (hash ("md5", "abc\0"), "147a664a2ca9410911e61986d3f0d52a");
-%!assert (hash ("sha1", "abc\0"), "686483805ac47ca14e03514f7481a7973b401762");
+%!assert (hash ("md2", "abc\0"), "5a636d615002a7874ac1c9e9a43361f7")
+%!assert (hash ("md4", "abc\0"), "0ee5201897ecb206c4eaba1d2da5224d")
+%!assert (hash ("md5", "abc\0"), "147a664a2ca9410911e61986d3f0d52a")
+%!assert (hash ("sha1", "abc\0"), "686483805ac47ca14e03514f7481a7973b401762")
 %!assert (hash ("sha224", "abc\0"),
 %!        "fbc8e47920e108bb1d0b631d18b36ae9b1549d28362aa15ebe960cfb");
 %!assert (hash ("sha256", "abc\0"),
 %!        "dc1114cd074914bd872cc1f9a23ec910ea2203bc79779ab2e17da25782a624fc");
 %!assert (hash ("sha384", "abc\0"),
 %!        ["eba81f2dfba4ec60d3f786c89d91b08e6c0b63d55986874378e385", ...
 %!         "e6fac587cce7a520ca9437290fe626cbf75c855e17"]);
 %!assert (hash ("sha512", "abc\0"),
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -480,17 +480,17 @@ information.\n\
       else
         err_wrong_type_arg ("lu", arg);
     }
 
   return retval;
 }
 
 /*
-%!assert(lu ([1, 2; 3, 4]), [3, 4; 1/3, 2/3], eps);
+%!assert(lu ([1, 2; 3, 4]), [3, 4; 1/3, 2/3], eps)
 
 %!test
 %! [l, u] = lu ([1, 2; 3, 4]);
 %! assert (l, [1/3, 1; 1, 0], sqrt (eps));
 %! assert (u, [3, 4; 0, 2/3], sqrt (eps));
 
 %!test
 %! [l, u, p] = lu ([1, 2; 3, 4]);
diff --git a/libinterp/corefcn/nproc.cc b/libinterp/corefcn/nproc.cc
--- a/libinterp/corefcn/nproc.cc
+++ b/libinterp/corefcn/nproc.cc
@@ -71,19 +71,19 @@ environment variable.\n\
         error ("nproc: invalid value for QUERY");
     }
 
   return ovl (num_processors (query));
 }
 
 /*
 ## Must always report at least 1 cpu available
-%!assert (nproc () >= 1);
-%!assert (nproc ("all") >= 1);
-%!assert (nproc ("current") >= 1);
+%!assert (nproc () >= 1)
+%!assert (nproc ("all") >= 1)
+%!assert (nproc ("current") >= 1)
 
 %!test
 %! c = nproc ("current");
 %! unwind_protect
 %!   old_val = getenv ("OMP_NUM_THREADS");
 %!   new_val = c + 1;
 %!   setenv ("OMP_NUM_THREADS", num2str (new_val));
 %!   assert (nproc ("overridable"), new_val);
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -92,14 +92,14 @@ instead.\n\
 %!assert (rcond (eye (2)), 1)
 %!assert (rcond (ones (2)), 0)
 %!assert (rcond ([1 1; 2 1]), 1/9)
 %!assert (rcond (magic (4)), 0, eps)
 
 %!shared x, sx
 %! x = [-5.25, -2.25; -2.25, 1] * eps () + ones (2) / 2;
 %! sx = [-5.25, -2.25; -2.25, 1] * eps ("single") + ones (2) / 2;
-%!assert (rcond (x) < eps ());
-%!assert (rcond (sx) < eps ('single'));
-%!assert (rcond (x*i) < eps ());
-%!assert (rcond (sx*i) < eps ('single'));
+%!assert (rcond (x) < eps ())
+%!assert (rcond (sx) < eps ('single'))
+%!assert (rcond (x*i) < eps ())
+%!assert (rcond (sx*i) < eps ('single'))
 
 */
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -1116,18 +1116,18 @@ are zero or more @qcode{'b'} characters 
 %! [a, b] = regexp (str, "x", "match", "split");
 %! assert (a, cell (1, 0));
 %! assert (b, {"foo bar"});
 %!test
 %! [a, b] = regexp (str, "[o]+", "match", "split");
 %! assert (a, {"oo"});
 %! assert (b, {"f", " bar"});
 
-%!assert (regexp ("\n", '\n'), 1);
-%!assert (regexp ("\n", "\n"), 1);
+%!assert (regexp ("\n", '\n'), 1)
+%!assert (regexp ("\n", "\n"), 1)
 
 %!test  # Bug #45407, escape sequences are silently converted
 %! assert (regexprep ('s', 's', 'x\.y'), 'x.y');
 %! assert (regexprep ('s', '(s)', 'x\$1y'), 'x$1y');
 %! assert (regexprep ('s', '(s)', 'x\\$1y'), 'x\sy');
 
 */
 
@@ -1278,18 +1278,18 @@ for details on the syntax of the search 
 %!error regexpi ('string', 'tri', 'BadArg')
 %!error regexpi ('string')
 
 %!assert (regexpi ({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'}, '-'), {6;[1,5,9];zeros(1, 0)})
 %!assert (regexpi ({'asdfg-dfd', '-dfd-dfd-', 'qasfdfdaq'}, '-'), {6, [1,5,9], zeros(1,0)})
 %!assert (regexpi ({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'}, {'-';'f';'q'}), {6;[3,7];[1,9]})
 %!assert (regexpi ('Strings', {'t', 's'}), {2, [1, 7]})
 
-%!assert (regexpi ("\n", '\n'), 1);
-%!assert (regexpi ("\n", "\n"), 1);
+%!assert (regexpi ("\n", '\n'), 1)
+%!assert (regexpi ("\n", "\n"), 1)
 */
 
 static octave_value
 octregexprep (const octave_value_list &args, const std::string &who)
 {
   int nargin = args.length ();
 
   // Make sure we have string, pattern, replacement
@@ -1479,24 +1479,24 @@ function.\n\
 ## Options
 %!assert (regexprep ("a[b]c{d}e-f=g", "[^A-Za-z0-9_]", "_", "once"), "a_b]c{d}e-f=g")
 %!assert (regexprep ("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "ignorecase"), "a_b_c_d_e_f_g")
 
 ## Option combinations
 %!assert (regexprep ("a[b]c{d}e-f=g", "[^A-Z0-9_]", "_", "once", "ignorecase"), "a_b]c{d}e-f=g")
 
 ## End conditions on replacement
-%!assert (regexprep ("abc", "(b)", ".$1"), "a.bc");
-%!assert (regexprep ("abc", "(b)", "$1"), "abc");
-%!assert (regexprep ("abc", "(b)", "$1."), "ab.c");
-%!assert (regexprep ("abc", "(b)", "$1.."), "ab..c");
+%!assert (regexprep ("abc", "(b)", ".$1"), "a.bc")
+%!assert (regexprep ("abc", "(b)", "$1"), "abc")
+%!assert (regexprep ("abc", "(b)", "$1."), "ab.c")
+%!assert (regexprep ("abc", "(b)", "$1.."), "ab..c")
 
 ## Test cell array arguments
 %!assert (regexprep ("abc", {"b","a"}, "?"), "??c")
 %!assert (regexprep ({"abc","cba"}, "b", "?"), {"a?c","c?a"})
 %!assert (regexprep ({"abc","cba"}, {"b","a"}, {"?","!"}), {"!?c","c?!"})
 
 # Nasty lookbehind expression
 %!assert (regexprep ('x^(-1)+y(-1)+z(-1)=0', '(?<=[a-z]+)\(\-[1-9]*\)', '_minus1'),'x^(-1)+y_minus1+z_minus1=0')
 
-%!assert (regexprep ("\n", '\n', "X"), "X");
-%!assert (regexprep ("\n", "\n", "X"), "X");
+%!assert (regexprep ("\n", '\n', "X"), "X")
+%!assert (regexprep ("\n", "\n", "X"), "X")
 */
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -236,18 +236,18 @@ scalar_xpow (const S& a, const SM& b)
 
   if (val.is_complex_type ())
     return SparseComplexMatrix (val.complex_matrix_value ());
   else
     return SparseMatrix (val.matrix_value ());
 }
 
 /*
-%!assert (sparse (2) .^ [3, 4], sparse ([8, 16]));
-%!assert (sparse (2i) .^ [3, 4], sparse ([-0-8i, 16]));
+%!assert (sparse (2) .^ [3, 4], sparse ([8, 16]))
+%!assert (sparse (2i) .^ [3, 4], sparse ([-0-8i, 16]))
 */
 
 // -*- 1 -*-
 octave_value
 elem_xpow (double a, const SparseMatrix& b)
 {
   octave_value retval;
 
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -140,18 +140,18 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
 
       retval = octave_value (result, '\'');
     }
 
   return retval;
 }
 
 /*
-%!assert (char (), '');
-%!assert (char (100), "d");
+%!assert (char (), '')
+%!assert (char (100), "d")
 %!assert (char (100,100), ["d";"d"])
 %!assert (char ({100,100}), ["d";"d"])
 %!assert (char ([100,100]), ["dd"])
 %!assert (char ({100,{100}}), ["d";"d"])
 %!assert (char (100, [], 100), ["d";" ";"d"])
 %!assert (char ({100, [], 100}), ["d";" ";"d"])
 %!assert (char ({100,{100, {""}}}), ["d";"d";" "])
 %!assert (char (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
@@ -259,18 +259,18 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
         }
     }
 
   // Cannot use ovl.  Relies on overloaded octave_value call.
   return octave_value (result, '\'');
 }
 
 /*
-%!assert (strvcat (""), "");
-%!assert (strvcat (100) == "d");
+%!assert (strvcat (""), "")
+%!assert (strvcat (100) == "d")
 %!assert (strvcat (100,100), ["d";"d"])
 %!assert (strvcat ({100,100}), ["d";"d"])
 %!assert (strvcat ([100,100]), ["dd"])
 %!assert (strvcat ({100,{100}}), ["d";"d"])
 %!assert (strvcat (100, [], 100), ["d";"d"])
 %!assert (strvcat ({100, [], 100}), ["d";"d"])
 %!assert (strvcat ({100,{100, {""}}}), ["d";"d"])
 %!assert (strvcat (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1909,17 +1909,17 @@ DEFUN (variable_value, args, , "VALUE = 
 
 /*
 bug #34497: 'clear -f' does not work for command line functions
 
 This test relies on bar being a core function that is implemented in an m-file.
 If the first assert fails, this is no longer the case and the tests need to be
 updated to use some other function.
 
-%!assert (! strcmp (which ("bar"), ""));
+%!assert (! strcmp (which ("bar"), ""))
 
 %!function x = bar ()
 %!  x = 5;
 %!endfunction
 %!test
 %! assert (bar == 5);
 %! assert (strcmp (which ("bar"), ""));
 %! clear -f bar;
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -448,21 +448,21 @@ Year (1970-).\n\
   octave_scalar_map map = args(1).xscalar_map_value ("strftime: TM_STRUCT must be a structure");
 
   octave_base_tm tm = extract_tm (map, "strftime");
 
   return ovl (tm.strftime (fmt));
 }
 
 /*
-%!assert (ischar (strftime ("%%%n%t%H%I%k%l", localtime (time ()))));
-%!assert (ischar (strftime ("%M%p%r%R%s%S%T", localtime (time ()))));
-%!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))));
-%!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))));
-%!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))));
+%!assert (ischar (strftime ("%%%n%t%H%I%k%l", localtime (time ()))))
+%!assert (ischar (strftime ("%M%p%r%R%s%S%T", localtime (time ()))))
+%!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))))
+%!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))))
+%!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))))
 
 %!error strftime ()
 %!error strftime ("foo", 1)
 %!error strftime ("foo", struct ("year", "foo"))
 %!error strftime ("foo", localtime (time ()), 1)
 */
 
 DEFUN (strptime, args, ,
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -624,20 +624,20 @@ them.\n\
 %! endif
 
 %!assert (exist ("print_usage"), 2)
 %!assert (exist ("print_usage.m"), 2)
 %!assert (exist ("print_usage", "file"), 2)
 %!assert (exist ("print_usage", "dir"), 0)
 
 ## Don't search path for rooted relative filenames
-%!assert (exist ("plot.m", "file"), 2);
-%!assert (exist ("./plot.m", "file"), 0);
-%!assert (exist ("./%nonexistentfile%", "file"), 0);
-%!assert (exist ("%nonexistentfile%", "file"), 0);
+%!assert (exist ("plot.m", "file"), 2)
+%!assert (exist ("./plot.m", "file"), 0)
+%!assert (exist ("./%nonexistentfile%", "file"), 0)
+%!assert (exist ("%nonexistentfile%", "file"), 0)
 
 ## Don't search path for absolute filenames
 %!test
 %! tname = tempname (pwd ());
 %! unwind_protect
 %!   ## open/close file to create it, equivalent of touch
 %!   fid = fopen (tname, "w");
 %!   fclose (fid);
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1744,19 +1744,19 @@ is derived.\n\
         error ("class: object of class '%s' does not match previously constructed objects",
                id.c_str ());
     }
 
   return retval;
 }
 
 /*
-%!assert (class (1.1), "double");
-%!assert (class (single (1.1)), "single");
-%!assert (class (uint8 (1)), "uint8");
+%!assert (class (1.1), "double")
+%!assert (class (single (1.1)), "single")
+%!assert (class (uint8 (1)), "uint8")
 %!testif HAVE_JAVA
 %! jobj = javaObject ("java.lang.StringBuffer");
 %! assert (class (jobj), "java.lang.StringBuffer");
 
 %% Test Input Validation
 %!error class ()
 */
 
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -235,11 +235,11 @@ octave_complex_diag_matrix::chk_valid_sc
   if (retval)
     x = val.complex_value ();
   return retval;
 }
 
 /*
 
 %% bug #36368
-%!assert (diag ([1+i, 1-i])^2 , diag ([2i, -2i]), 4*eps);
+%!assert (diag ([1+i, 1-i])^2 , diag ([2i, -2i]), 4*eps)
 
 */
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -2009,19 +2009,19 @@ A(1)\n\
 %! keys = cellstr (char (floor (rand (100,10)*24+65)))';
 %! vals = mat2cell (rand (100,1), ones (100,1), 1)';
 %! s = struct ([keys; vals]{:});
 %! t = cell2struct (vals, keys, 2);
 %! assert (s, t);
 %! assert (struct2cell (s), vals');
 %! assert (fieldnames (s), keys');
 
-%!assert (cell2struct ({1; 2}, {"a"; "b"}), struct ("a", 1, "b", 2));
-
-%!assert (cell2struct ({}, {"f"}, 3), struct ("f", {}));
+%!assert (cell2struct ({1; 2}, {"a"; "b"}), struct ("a", 1, "b", 2))
+
+%!assert (cell2struct ({}, {"f"}, 3), struct ("f", {}))
 */
 
 // FIXME: we should be including builtin-defun-decls.h but doing that
 // currently exposes a problem with dependencies in the the build system.
 extern OCTINTERP_API octave_value_list
 Fcellstr (const octave_value_list& = octave_value_list (), int = 0);
 
 DEFUN (rmfield, args, ,
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -3029,18 +3029,18 @@ The original variable value is restored 
 }
 
 /*
 %!function p = __test_dpm__ (dpm)
 %!  disable_permutation_matrix (dpm, "local");
 %!  [~, ~, p] = lu ([1,2;3,4]);
 %!endfunction
 
-%!assert (typeinfo (__test_dpm__ (false)), "permutation matrix");
-%!assert (typeinfo (__test_dpm__ (true)), "matrix");
+%!assert (typeinfo (__test_dpm__ (false)), "permutation matrix")
+%!assert (typeinfo (__test_dpm__ (true)), "matrix")
 */
 
 DEFUN (disable_diagonal_matrix, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} disable_diagonal_matrix ()\n\
 @deftypefnx {} {@var{old_val} =} disable_diagonal_matrix (@var{new_val})\n\
 @deftypefnx {} {} disable_diagonal_matrix (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether diagonal\n\
@@ -3064,27 +3064,27 @@ The original variable value is restored 
 %!  x = eye (2);
 %!  xi = x*i;
 %!  fx = single (x);
 %!  fxi = single (xi);
 %!endfunction
 
 %!shared x, xi, fx, fxi
 %!  [x, xi, fx, fxi] = __test_ddm__ (false);
-%!assert (typeinfo (x), "diagonal matrix");
-%!assert (typeinfo (xi), "complex diagonal matrix");
-%!assert (typeinfo (fx), "float diagonal matrix");
-%!assert (typeinfo (fxi), "float complex diagonal matrix");
+%!assert (typeinfo (x), "diagonal matrix")
+%!assert (typeinfo (xi), "complex diagonal matrix")
+%!assert (typeinfo (fx), "float diagonal matrix")
+%!assert (typeinfo (fxi), "float complex diagonal matrix")
 
 %!shared x, xi, fx, fxi
 %!  [x, xi, fx, fxi] = __test_ddm__ (true);
-%!assert (typeinfo (x), "matrix");
-%!assert (typeinfo (xi), "complex matrix");
-%!assert (typeinfo (fx), "float matrix");
-%!assert (typeinfo (fxi), "float complex matrix");
+%!assert (typeinfo (x), "matrix")
+%!assert (typeinfo (xi), "complex matrix")
+%!assert (typeinfo (fx), "float matrix")
+%!assert (typeinfo (fxi), "float complex matrix")
 */
 
 DEFUN (disable_range, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} disable_range ()\n\
 @deftypefnx {} {@var{old_val} =} disable_range (@var{new_val})\n\
 @deftypefnx {} {} disable_range (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether ranges are stored\n\
@@ -3106,12 +3106,12 @@ The original variable value is restored 
 %!function r = __test_dr__ (dr)
 %!  disable_range (dr, "local");
 %!  ## Constant folding will produce range for 1:13.
 %!  base = 1;
 %!  limit = 13;
 %!  r = base:limit;
 %!endfunction
 
-%!assert (typeinfo (__test_dr__ (false)), "range");
-%!assert (typeinfo (__test_dr__ (true)), "matrix");
+%!assert (typeinfo (__test_dr__ (false)), "range")
+%!assert (typeinfo (__test_dr__ (true)), "matrix")
 */
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -5047,17 +5047,17 @@ the security considerations that the eva
 
 /*
 
 %!shared x
 %! x = 1;
 
 %!assert (eval ("x"), 1)
 %!assert (eval ("x;"))
-%!assert (eval ("x;"), 1);
+%!assert (eval ("x;"), 1)
 
 %!test
 %! y = eval ("x");
 %! assert (y, 1);
 
 %!test
 %! y = eval ("x;");
 %! assert (y, 1);
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -1118,18 +1118,18 @@ tree_matrix::dup (symbol_table::scope_id
 void
 tree_matrix::accept (tree_walker& tw)
 {
   tw.visit_matrix (*this);
 }
 
 /*
 ## test concatenation with all zero matrices
-%!assert ([ "" 65*ones(1,10) ], "AAAAAAAAAA");
-%!assert ([ 65*ones(1,10) "" ], "AAAAAAAAAA");
+%!assert ([ "" 65*ones(1,10) ], "AAAAAAAAAA")
+%!assert ([ 65*ones(1,10) "" ], "AAAAAAAAAA")
 
 %!test
 %! c = {"foo"; "bar"; "bazoloa"};
 %! assert ([c; "a"; "bc"; "def"], {"foo"; "bar"; "bazoloa"; "a"; "bc"; "def"});
 
 %!assert (class ([int64(1), int64(1)]), "int64")
 %!assert (class ([int64(1), int32(1)]), "int64")
 %!assert (class ([int64(1), int16(1)]), "int64")
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -3545,17 +3545,17 @@ operator * (const Matrix& m, const Compl
 }
 
 /*
 
 ## Simple Dot Product, Matrix-Vector, and Matrix-Matrix Unit tests
 %!assert ([1+i 2+i 3+i] * [ 4+i ; 5+i ; 6+i], 29+21i, 1e-14)
 %!assert ([1+i 2+i ; 3+i 4+i ] * [5+i ; 6+i], [15 + 14i ; 37 + 18i], 1e-14)
 %!assert ([1+i 2+i ; 3+i 4+i ] * [5+i 6+i ; 7+i 8+i], [17 + 15i 20 + 17i; 41 + 19i 48 + 21i], 1e-14)
-%!assert ([1 i]*[i 0]', -i);
+%!assert ([1 i]*[i 0]', -i)
 
 ## Test some simple identities
 %!shared M, cv, rv
 %! M = randn (10,10) + i*rand (10,10);
 %! cv = randn (10,1) + i*rand (10,1);
 %! rv = randn (1,10) + i*rand (1,10);
 %!assert ([M*cv,M*cv], M*[cv,cv], 1e-14)
 %!assert ([M.'*cv,M.'*cv], M.'*[cv,cv], 1e-14)
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -787,28 +787,28 @@ INSTANTIATE_INTTYPE (uint64_t);
 %! a = int64 (-2**60) + 2; assert (1.25*a == (5*a)/4);
 %!test
 %! a = uint64 (2**61) + 2; assert (1.25*a == (5*a)/4);
 %!assert (int32 (2**31+0.5), intmax ("int32"))
 %!assert (int32 (-2**31-0.5), intmin ("int32"))
 %!assert ((int64 (2**62)+1)**1, int64 (2**62)+1)
 %!assert ((int64 (2**30)+1)**2, int64 (2**60+2**31) + 1)
 
-%!assert (uint8 (char (128)), uint8 (128));
-%!assert (uint8 (char (255)), uint8 (255));
-%!assert (int8 (char (128)), int8 (128));
-%!assert (int8 (char (255)), int8 (255));
+%!assert (uint8 (char (128)), uint8 (128))
+%!assert (uint8 (char (255)), uint8 (255))
+%!assert (int8 (char (128)), int8 (128))
+%!assert (int8 (char (255)), int8 (255))
 
-%!assert (uint16 (char (128)), uint16 (128));
-%!assert (uint16 (char (255)), uint16 (255));
-%!assert (int16 (char (128)), int16 (128));
-%!assert (int16 (char (255)), int16 (255));
+%!assert (uint16 (char (128)), uint16 (128))
+%!assert (uint16 (char (255)), uint16 (255))
+%!assert (int16 (char (128)), int16 (128))
+%!assert (int16 (char (255)), int16 (255))
 
-%!assert (uint32 (char (128)), uint32 (128));
-%!assert (uint32 (char (255)), uint32 (255));
-%!assert (int32 (char (128)), int32 (128));
-%!assert (int32 (char (255)), int32 (255));
+%!assert (uint32 (char (128)), uint32 (128))
+%!assert (uint32 (char (255)), uint32 (255))
+%!assert (int32 (char (128)), int32 (128))
+%!assert (int32 (char (255)), int32 (255))
 
-%!assert (uint64 (char (128)), uint64 (128));
-%!assert (uint64 (char (255)), uint64 (255));
-%!assert (int64 (char (128)), int64 (128));
-%!assert (int64 (char (255)), int64 (255));
+%!assert (uint64 (char (128)), uint64 (128))
+%!assert (uint64 (char (255)), uint64 (255))
+%!assert (int64 (char (128)), int64 (128))
+%!assert (int64 (char (255)), int64 (255))
 */
diff --git a/scripts/deprecated/md5sum.m b/scripts/deprecated/md5sum.m
--- a/scripts/deprecated/md5sum.m
+++ b/scripts/deprecated/md5sum.m
@@ -56,17 +56,17 @@ function r = md5sum (str, opt)
   elseif ((nargin == 2) && isbool (opt) && isscalar (opt) && (opt == true))
     r = hash ("md5", str);
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert (md5sum ("abc\0", true), "147a664a2ca9410911e61986d3f0d52a");
+%!assert (md5sum ("abc\0", true), "147a664a2ca9410911e61986d3f0d52a")
 
 %!test
 %! tfile = tempname ();
 %! fid = fopen (tfile, "wb");
 %! fwrite (fid, "abc\0");
 %! fclose (fid);
 %! assert (md5sum (tfile), "147a664a2ca9410911e61986d3f0d52a");
 %! unlink (tfile);
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -67,17 +67,17 @@ endfunction
 ## regular tests
 %!assert (blkdiag (1,ones (2),1), [1,0,0,0;0,1,1,0;0,1,1,0;0,0,0,1])
 %!assert (blkdiag ([1,2],[3,4],[5,6]), [1,2,0,0,0,0;0,0,3,4,0,0;0,0,0,0,5,6])
 %!assert (blkdiag ([1,2],[3;4],[5,6]), [1,2,0,0,0;0,0,3,0,0;0,0,4,0,0;0,0,0,5,6])
 %!assert (blkdiag ([1,2;3,4],[5,6,7]), [1,2,0,0,0;3,4,0,0,0;0,0,5,6,7])
 ## tests involving empty matrices
 %!assert (blkdiag ([],[],[]), [])
 %!assert (blkdiag ([],[1,2;3,4],[],5,[]), [1,2,0;3,4,0;0,0,5])
-%!assert (blkdiag (zeros (1,0,1),[1,2,3],1,0,5,zeros (0,1,1)), [0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0]);
+%!assert (blkdiag (zeros (1,0,1),[1,2,3],1,0,5,zeros (0,1,1)), [0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0])
 ## tests involving sparse matrices
 %!assert (blkdiag (sparse ([1,2;3,4]),[5,6;7,8]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6;0,0,7,8]))
 %!assert (blkdiag (sparse ([1,2;3,4]),[5,6]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6]))
 ## sanity checks
 %!test
 %! A = rand (round (rand (1, 2) * 10));
 %! assert (blkdiag (A), A);
 
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -88,18 +88,18 @@ function m = cell2mat (c)
 
 endfunction
 
 
 %!demo
 %! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
 %! cell2mat (C)
 
-%!assert (cell2mat ({}), []);
-%!assert (cell2mat ([]), []);
+%!assert (cell2mat ({}), [])
+%!assert (cell2mat ([]), [])
 %!test
 %! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
 %! D = C; D(:,:,2) = C;
 %! E = [1 2 3 4; 5 6 7 8; 9 10 11 12];
 %! F = E; F(:,:,2) = E;
 %! assert (cell2mat (C), E);
 %! assert (cell2mat (D), F);
 %!test
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -629,18 +629,18 @@ endfunction
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
 %!assert (interp1 (xp,yp,xi,style),...
 %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
-%!assert (interp1 ([1 2 2 3], [1 2 3 4], 2), 3);
-%!assert (interp1 ([3 2 2 1], [4 3 2 1], 2), 2);
+%!assert (interp1 ([1 2 2 3], [1 2 3 4], 2), 3)
+%!assert (interp1 ([3 2 2 1], [4 3 2 1], 2), 2)
 %!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
 %!test style = "cubic";
 ## BLOCK
 %!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
 %!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
 %!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -535,18 +535,18 @@ endfunction
 %! assert (interp2 (x,y,A,x,y,"linear"), A);
 %! assert (interp2 (x,y,A,x,y,"nearest"), A);
 
 %!test  # for Matlab-compatible rounding for 'nearest'
 %! X = meshgrid (1:4);
 %! assert (interp2 (X, 2.5, 2.5, "nearest"), 3);
 
 ## re-order monotonically decreasing (bug #41838).
-%!assert (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5);
-%!assert (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5);
+%!assert (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5)
+%!assert (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5)
 
 %!shared z, zout, tol
 %! z = [1 3 5; 3 5 7; 5 7 9];
 %! zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
 %! tol = 2 * eps;
 %!
 %!assert (interp2 (z), zout, tol)
 %!assert (interp2 (z, "linear"), zout, tol)
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -113,31 +113,31 @@ endfunction
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 %! yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
 %! plot (ti, yp, 'g', ti, interp1(t, y, ti, "spline"), 'b', ...
 %!       ti, interpft (y, k), 'c', t, y, "r+");
 %! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
 %! x = [0:10]';  y = sin(x);  n = length (x);
-%!assert (interpft (y, n), y, 20*eps);
-%!assert (interpft (y', n), y', 20*eps);
-%!assert (interpft ([y,y],n), [y,y], 20*eps);
+%!assert (interpft (y, n), y, 20*eps)
+%!assert (interpft (y', n), y', 20*eps)
+%!assert (interpft ([y,y],n), [y,y], 20*eps)
 
 ## Test case with complex input from bug #39566
 %!test
 %! x = (1 + j) * [1:4]';
 %! y = ifft ([15 + 15*j; -6; -1.5 - 1.5*j; 0; -1.5 - 1.5*j; -6*j]);
 %! assert (interpft (x, 6), y, 10*eps);
 
 ## Test for correct spectral symmetry with even/odd lengths
-%!assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps);
-%!assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps);
-%!assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps);
-%!assert (max (abs (imag (interpft ([1:9], 21)))), 0, 21*eps);
+%!assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps)
+%!assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps)
+%!assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps)
+%!assert (max (abs (imag (interpft ([1:9], 21)))), 0, 21*eps)
 
 ## Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
 %!error <N must be a scalar integer> interpft (1,[2,2])
 %!error <N must be a scalar integer> interpft (1,2.1)
 %!error <invalid dimension DIM> interpft (1,2,0)
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -190,17 +190,17 @@ function retval = num2str (x, arg)
 endfunction
 
 
 %!assert (num2str (123), "123")
 %!assert (num2str (1.23), "1.23")
 %!assert (num2str (123.456, 4), "123.5")
 %!assert (num2str ([1, 1.34; 3, 3.56], "%5.1f"),  ["1.0  1.3"; "3.0  3.6"])
 %!assert (num2str (1.234 + 27.3i), "1.234+27.3i")
-%!assert (num2str ([true false true]), "1  0  1");
+%!assert (num2str ([true false true]), "1  0  1")
 
 %!assert (num2str (19440606), "19440606")
 %!assert (num2str (2^33), "8589934592")
 %!assert (num2str (-2^33), "-8589934592")
 %!assert (num2str (2^33+1i), "8589934592+1i")
 %!assert (num2str (-2^33+1i), "-8589934592+1i")
 %!assert (num2str ([0 0 0]), "0  0  0")
 %!assert (num2str (inf), "Inf")
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -146,18 +146,18 @@ endfunction
 %!assert (repmat (x, [3, 1]), repmat (x, [], 3))
 %!assert (repmat (x, [1, 3]), repmat (x, [], [1, 3]))
 %!assert (repmat (x, [1, 3]), repmat (x, [1, 3], []))
 %!assert (repmat (x, [1 3]), repmat (x, [1 3; 3 3]))
 %!assert (repmat (x, [1 1 2]), repmat (x, [1 1; 1 3; 2 1]))
 %!assert (repmat (x, [1 3; 1 3], [1; 3]), repmat (x, [1 1 3]))
 %!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1; 4]))
 %!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1 2; 3 4]))
-%!assert (repmat (x, [1 1], 4), repmat (x, [1 1 4]));
-%!assert (repmat (x, [1 1], 4), repmat (x, 1, [1 4]));
+%!assert (repmat (x, [1 1], 4), repmat (x, [1 1 4]))
+%!assert (repmat (x, [1 1], 4), repmat (x, 1, [1 4]))
 
 ## Test various methods of providing size parameters
 %!shared x
 %! x = [1 2;3 4];
 %!assert (repmat (x, [1 1]), repmat (x, 1))
 %!assert (repmat (x, [3 3]), repmat (x, 3))
 %!assert (repmat (x, [1 1]), repmat (x, 1, 1))
 %!assert (repmat (x, [1 3]), repmat (x, 1, 3))
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -99,17 +99,17 @@ endfunction
 %! rgb_map = rand (64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_map)), rgb_map, 1e-3);
 
 %!test
 %! rgb_img = rand (64, 64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_img)), rgb_img, 1e-3);
 
 ## test cropping of rgb output
-%!assert (ntsc2rgb ([1.5 0 0]), [1   1   1]);
+%!assert (ntsc2rgb ([1.5 0 0]), [1   1   1])
 
 ## Test scaling of output.  After conversion, cut of negative values
 ## and scaling of all the others relative to the maximum above 1.
 %!test
 %! ntsc = [0.4229  0.0336  0.7184];
 %! rgb = ntsc * trans;    # [0.9014  -0.0509  1.6075]
 %! rgb(1) /= rgb(3); # scaled based on the maximum
 %! rgb(2) = 0; # cut to 0
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -138,18 +138,18 @@ function r = expm (A)
   ## Inverse trace reduction.
   if (trshift >0)
     r *= exp (trshift);
   endif
 
 endfunction
 
 
-%!assert (norm (expm ([1 -1;0 1]) - [e -e; 0 e]) < 1e-5);
-%!assert (expm ([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5);
+%!assert (norm (expm ([1 -1;0 1]) - [e -e; 0 e]) < 1e-5)
+%!assert (expm ([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5)
 
 %!assert (expm (10), expm (10))
 %!assert (full (expm (eye (3))), expm (full (eye (3))))
 %!assert (full (expm (10*eye (3))), expm (full (10*eye (3))), 8*eps)
 
 ## Test input validation
 %!error expm ()
 %!error expm (1, 2)
diff --git a/scripts/miscellaneous/inputname.m b/scripts/miscellaneous/inputname.m
--- a/scripts/miscellaneous/inputname.m
+++ b/scripts/miscellaneous/inputname.m
@@ -75,14 +75,14 @@ endfunction
 ## Clear parameter list so that testfn is created with zero inputs/outputs
 %!shared
 %!assert (inputname (-1), "")
 %!assert (inputname (1), "")
 
 %!function r = __foo__ (x, y)
 %!  r = inputname (2);
 %!endfunction
-%!assert (__foo__ (pi, e), "e");
-%!assert (feval (@__foo__, pi, e), "e");
+%!assert (__foo__ (pi, e), "e")
+%!assert (feval (@__foo__, pi, e), "e")
 
 %!error inputname ()
 %!error inputname (1,2)
 
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -56,13 +56,13 @@ function y = polyvalm (c, x)
     for i = 2:n
       y = y * x + c(i) * id;
     endfor
   endif
 
 endfunction
 
 
-%!assert (! any (polyvalm ([], [1, 2; 3, 4]))(:));
+%!assert (! any (polyvalm ([], [1, 2; 3, 4]))(:))
 %!assert (polyvalm ([1, 2, 3, 4], [3, -4, 1; -2, 0, 2; -1, 4, -3]), [117, -124, 11; -70, 36, 38; -43, 92, -45])
 
 %!error <must be a square matrix> polyvalm ([1, 1, 1], [1, 2; 3, 4; 5, 6])
 
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -73,18 +73,18 @@ endfunction
 %!assert (blackman (15), flip (blackman (15)), 5*eps)
 %!assert (blackman (16), flip (blackman (16)), 5*eps)
 %!test
 %! N = 9;
 %! A = blackman (N);
 %! assert (A(ceil (N/2)), 1, 1e-6);
 %! assert ([A(1), A(length (A))], zeros (1,2), 1e-6);
 
-%!assert (blackman (15), blackman (15, "symmetric"));
-%!assert (blackman (16)(1:15), blackman (15, "periodic"));
+%!assert (blackman (15), blackman (15, "symmetric"))
+%!assert (blackman (16)(1:15), blackman (15, "periodic"))
 %!test
 %! N = 16;
 %! A = blackman (N, "periodic");
 %! assert (A(N/2 + 1), 1, 1e-6);
 
 %!error blackman ()
 %!error blackman (0.5)
 %!error blackman (-1)
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -71,18 +71,18 @@ endfunction
 %!assert (hamming (2), (0.54 - 0.46)*ones (2,1))
 %!assert (hamming (15), flip (hamming (15)), 5*eps)
 %!assert (hamming (16), flip (hamming (16)), 5*eps)
 %!test
 %! N = 15;
 %! A = hamming (N);
 %! assert (A(ceil (N/2)), 1);
 
-%!assert (hamming (15), hamming (15, "symmetric"));
-%!assert (hamming (16)(1:15), hamming (15, "periodic"));
+%!assert (hamming (15), hamming (15, "symmetric"))
+%!assert (hamming (16)(1:15), hamming (15, "periodic"))
 %!test
 %! N = 16;
 %! A = hamming (N, "periodic");
 %! assert (A(N/2 + 1), 1);
 
 %!error hamming ()
 %!error hamming (0.5)
 %!error hamming (-1)
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -62,27 +62,27 @@ function c = hanning (m, opt)
   else
     m -= 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / N);
   endif
 
 endfunction
 
 
-%!assert (hanning (1), 1);
-%!assert (hanning (2), zeros (2,1));
-%!assert (hanning (15), flip (hanning (15)), 5*eps);
-%!assert (hanning (16), flip (hanning (16)), 5*eps);
+%!assert (hanning (1), 1)
+%!assert (hanning (2), zeros (2,1))
+%!assert (hanning (15), flip (hanning (15)), 5*eps)
+%!assert (hanning (16), flip (hanning (16)), 5*eps)
 %!test
 %! N = 15;
 %! A = hanning (N);
 %! assert (A(ceil (N/2)), 1);
 
-%!assert (hanning (15), hanning (15, "symmetric"));
-%!assert (hanning (16)(1:15), hanning (15, "periodic"));
+%!assert (hanning (15), hanning (15, "symmetric"))
+%!assert (hanning (16)(1:15), hanning (15, "periodic"))
 %!test
 %! N = 16;
 %! A = hanning (N, "periodic");
 %! assert (A(N/2 + 1), 1);
 
 %!error hanning ()
 %!error hanning (0.5)
 %!error hanning (-1)
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -1132,11 +1132,11 @@ endfunction
 %! Z = X * X';
 %! r = rank (Z);
 %! assert (r, 8);
 %! [V, D] = eigs (Z, r, "lm");
 %! ZZ = V * D * V';
 %! tmp = abs (Z - ZZ);
 %! assert (max (tmp(:)) < 5e-11);
 
-%!assert (eigs (diag (1:5), 5, "sa"), [1;2;3;4;5]);
-%!assert (eigs (diag (1:5), 5, "la"), [5;4;3;2;1]);
-%!assert (eigs (diag (1:5), 3, "be"), [1;4;5]);
+%!assert (eigs (diag (1:5), 5, "sa"), [1;2;3;4;5])
+%!assert (eigs (diag (1:5), 5, "la"), [5;4;3;2;1])
+%!assert (eigs (diag (1:5), 3, "be"), [1;4;5])
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -105,18 +105,18 @@ endfunction
 
 ## Test multidimensional arrays (bug #35679)
 %!shared a, b, x, y
 %! rand ("seed", 2);
 %! a = rand (2,3,4,5);
 %! b = rand (3,4,6,5);
 %! x = sort (a, 4);
 %! y = sort (b, 3);
-%!assert (median (a, 4), x(:, :, :, 3));
-%!assert (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2);
+%!assert (median (a, 4), x(:, :, :, 3))
+%!assert (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)
 
 ## Test input validation
 %!error median ()
 %!error median (1, 2, 3)
 %!error <X must be a numeric> median ({1:5})
 %!error <X cannot be an empty matrix> median ([])
 %!error <DIM must be an integer> median (1, ones (2,2))
 %!error <DIM must be an integer> median (1, 1.5)
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -84,19 +84,19 @@ endfunction
 %!assert (binopdf (x, 2*ones (1,5), 0.5*ones (1,5)), y, tol)
 %!assert (binopdf (x, 2, 0.5*ones (1,5)), y, tol)
 %!assert (binopdf (x, 2*ones (1,5), 0.5), y, tol)
 %!assert (binopdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 0])
 %!assert (binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0])
 %!assert (binopdf ([x, NaN], 2, 0.5), [y, NaN], tol)
 
 ## Test Special input values
-%!assert (binopdf (0, 3, 0), 1);
-%!assert (binopdf (2, 2, 1), 1);
-%!assert (binopdf (1, 2, 1), 0);
+%!assert (binopdf (0, 3, 0), 1)
+%!assert (binopdf (2, 2, 1), 1)
+%!assert (binopdf (1, 2, 1), 0)
 
 ## Test class of input preserved
 %!assert (binopdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
 %!assert (binopdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
 %!assert (binopdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
 ## Test input validation
 %!error binopdf ()
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -258,17 +258,17 @@ endfunction
 %!assert (strsplit ("road to hell", " ", "delimitertype", "r"), {"road", "to", "hell"})
 %!assert (strsplit ("road to^hell", '\^| ', "delimitertype", "r"), {"road", "to", "hell"})
 %!assert (strsplit ("road to^hell", "[ ^]", "delimitertype", "r"), {"road", "to", "hell"})
 %!assert (strsplit ("road   to--hell", "[ -]", false, "delimitertype", "r"), {"road", "", "", "to", "", "hell"})
 %!assert (strsplit (["a,bc,de"], ",", "delimitertype", "r"), {"a", "bc", "de"})
 %!assert (strsplit (["a,bc,,de"], ",", false, "delimitertype", "r"), {"a", "bc", "", "de"})
 %!assert (strsplit (["a,bc,de"], ",", true, "delimitertype", "r"), {"a", "bc", "de"})
 %!assert (strsplit (["a,bc,de"], "[, ]", true, "delimitertype", "r"), {"a", "bc", "de"})
-%!assert (strsplit ("hello \t world", true, "delimitertype", "r"), {"hello", "world"});
+%!assert (strsplit ("hello \t world", true, "delimitertype", "r"), {"hello", "world"})
 
 %!assert (strsplit ("foo\tbar", '\t', "delimitertype", "r"), {"foo", "bar"})
 %!assert (strsplit ("foo\tbar", '\t', "delimitertype", "s"), {"foo", "bar"})
 
 ## Test "match" for consecutive delmiters
 %!test
 %! [a, m] = strsplit ("a\t \nb", '\s', "delimitertype", "regularexpression",
 %!   "collapsedelimiters", false);
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -206,17 +206,17 @@ endfunction
 %!assert (strtok ("this ","jklmnop "), "this")
 %!assert (strtok ("this is","jklmnop "), "this")
 %!assert (strtok (" this","jklmnop "), "this")
 %!assert (strtok (" this ","jklmnop "), "this")
 %!assert (strtok (" ","jklmnop "), ""(1:0))
 
 ## Test 'bad' string orientations
 %!assert (strtok (" this ".'), "this".');   # delimiter at start and end
-%!assert (strtok (" this ".',"jkl "), "this".');
+%!assert (strtok (" this ".',"jkl "), "this".')
 
 ## Test with TAB, LF, VT, FF, and CR
 %!test
 %! for ch = "\t\n\v\f\r"
 %!   [t, r] = strtok (["beg", ch, "end"]);
 %!   assert (t, "beg");
 %!   assert (r, [ch, "end"]);
 %! endfor
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -442,30 +442,30 @@ endfunction
 %!assert (3, 3)
 %!error <Abs err 1 exceeds tol> assert (3, 4)
 %!assert (3+eps, 3, eps)
 %!assert (3, 3+eps, eps)
 %!error <Abs err 4.4409e-0?16 exceeds tol> assert (3+2*eps, 3, eps)
 %!error <Abs err 4.4409e-0?16 exceeds tol> assert (3, 3+2*eps, eps)
 
 ## vectors
-%!assert ([1,2,3],[1,2,3]);
-%!assert ([1;2;3],[1;2;3]);
+%!assert ([1,2,3],[1,2,3])
+%!assert ([1;2;3],[1;2;3])
 %!error <Abs err 1 exceeds tol 0> assert ([2,2,3,3],[1,2,3,4]);
 %!error <Abs err 1 exceeds tol 0.5> assert ([2,2,3,3],[1,2,3,4],0.5);
 %!error <Rel err 1 exceeds tol 0.1> assert ([2,2,3,5],[1,2,3,4],-0.1);
 %!error <Abs err 1 exceeds tol 0> assert ([6;6;7;7],[5;6;7;8]);
 %!error <Abs err 1 exceeds tol 0.5> assert ([6;6;7;7],[5;6;7;8],0.5);
 %!error <Rel err .* exceeds tol 0.1> assert ([6;6;7;7],[5;6;7;8],-0.1);
 %!error <Dimensions don't match> assert ([1,2,3],[1;2;3]);
 %!error <Dimensions don't match> assert ([1,2],[1,2,3]);
 %!error <Dimensions don't match> assert ([1;2;3],[1;2]);
 
 ## matrices
-%!assert ([1,2;3,4],[1,2;3,4]);
+%!assert ([1,2;3,4],[1,2;3,4])
 %!error <\(1,2\)\s+4\s+2> assert ([1,4;3,4],[1,2;3,4])
 %!error <Dimensions don't match> assert ([1,3;2,4;3,5],[1,2;3,4])
 %!test  # 2-D matrix
 %! A = [1 2 3]'*[1,2];
 %! assert (A, A);
 %! fail ("assert (A.*(A!=2),A)");
 %!test  # N-D matrix
 %! X = zeros (2,2,3);
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -98,17 +98,17 @@ endfunction
 %! example ("example");
 
 %!demo
 %! clf;
 %! t = 0:0.01:2*pi;
 %! x = sin (t);
 %! plot (t,x)
 
-%!assert (example ("example", 1), "\n example (\"example\");");
+%!assert (example ("example", 1), "\n example (\"example\");")
 
 %!test
 %! [code, idx] = example ("example");
 %! assert (code, ...
 %!         "\n example (\"example\");\n clf;\n t = 0:0.01:2*pi;\n x = sin (t);\n plot (t,x)");
 %! assert (idx, [1, 23, 73]);
 
 ## Test input validation
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -362,17 +362,17 @@ endfunction
 %!        [2015,6,1,15,7,12.12])
 
 ## Test structure of return value (bug #42334)
 %!test
 %! [~, ~, d] = datevec ([1 2; 3 4]);
 %! assert (d, [1 2; 3 4]);
 
 ## Other tests
-%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]');
+%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]')
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
 %!assert (double (datevec (int64 (datenum ([2014 6 1])))), datevec (datenum ([2014 6 1])))
 %!assert (double (datevec (int64 (datenum ([2014 6 18])))), datevec (datenum ([2014 6 18])))
 
 ## Test input validation
 %!error datevec ()
diff --git a/test/bug-38565.tst b/test/bug-38565.tst
--- a/test/bug-38565.tst
+++ b/test/bug-38565.tst
@@ -1,9 +1,9 @@
 %!function r = f (x)
 %!  if (ischar (x))
 %!    r = x;
 %!  else
 %!    error ("expecting character string");
 %!  endif
 %!endfunction
 
-%!assert (eval ("f 10;"), "10");
+%!assert (eval ("f 10;"), "10")
diff --git a/test/build-sparse-tests.sh b/test/build-sparse-tests.sh
--- a/test/build-sparse-tests.sh
+++ b/test/build-sparse-tests.sh
@@ -566,20 +566,20 @@ gen_unaryop_tests() {
 %! [ii,jj,vv,nr,nc] = find (as);
 %! assert (af, full (sparse (ii,jj,vv,nr,nc)));
 %!assert (nnz (as), sum (af(:)!=0))
 %!assert (nnz (as), nnz (af))
 %!assert (issparse (as.'))
 %!assert (issparse (as'))
 %!assert (issparse (-as))
 %!assert (!as, sparse (!af))
-%!assert (as.', sparse (af.'));
-%!assert (as',  sparse (af'));
-%!assert (-as, sparse (-af));
-%!assert (!as, sparse (!af));
+%!assert (as.', sparse (af.'))
+%!assert (as',  sparse (af'))
+%!assert (-as, sparse (-af))
+%!assert (!as, sparse (!af))
 %!error [i,j] = size (af);as(i-1,j+1);
 %!error [i,j] = size (af);as(i+1,j-1);
 %!test
 %! [Is,Js,Vs] = find (as);
 %! [If,Jf,Vf] = find (af);
 %! assert (Is, If);
 %! assert (Js, Jf);
 %! assert (Vs, Vf);
@@ -590,38 +590,38 @@ gen_unaryop_tests() {
 %! [i,j,v] = find (as);
 %! [m,n] = size (as);
 %! x = sparse (i,j,v,m,n);
 %! assert (x, as);
 %!test
 %! [i,j,v,m,n] = find (as);
 %! x = sparse (i,j,v,m,n);
 %! assert (x, as);
-%!assert (issparse (horzcat (as,as)));
-%!assert (issparse (vertcat (as,as)));
-%!assert (issparse (cat (1,as,as)));
-%!assert (issparse (cat (2,as,as)));
-%!assert (issparse ([as,as]));
-%!assert (issparse ([as;as]));
-%!assert (horzcat (as,as), sparse ([af,af]));
-%!assert (vertcat (as,as), sparse ([af;af]));
-%!assert (horzcat (as,as,as), sparse ([af,af,af]));
-%!assert (vertcat (as,as,as), sparse ([af;af;af]));
-%!assert ([as,as], sparse ([af,af]));
-%!assert ([as;as], sparse ([af;af]));
-%!assert ([as,as,as], sparse ([af,af,af]));
-%!assert ([as;as;as], sparse ([af;af;af]));
-%!assert (cat (2,as,as), sparse ([af,af]));
-%!assert (cat (1,as,as), sparse ([af;af]));
-%!assert (cat (2,as,as,as), sparse ([af,af,af]));
-%!assert (cat (1,as,as,as), sparse ([af;af;af]));
-%!assert (issparse ([as,af]));
-%!assert (issparse ([af,as]));
-%!assert ([as,af], sparse ([af,af]));
-%!assert ([as;af], sparse ([af;af]));
+%!assert (issparse (horzcat (as,as)))
+%!assert (issparse (vertcat (as,as)))
+%!assert (issparse (cat (1,as,as)))
+%!assert (issparse (cat (2,as,as)))
+%!assert (issparse ([as,as]))
+%!assert (issparse ([as;as]))
+%!assert (horzcat (as,as), sparse ([af,af]))
+%!assert (vertcat (as,as), sparse ([af;af]))
+%!assert (horzcat (as,as,as), sparse ([af,af,af]))
+%!assert (vertcat (as,as,as), sparse ([af;af;af]))
+%!assert ([as,as], sparse ([af,af]))
+%!assert ([as;as], sparse ([af;af]))
+%!assert ([as,as,as], sparse ([af,af,af]))
+%!assert ([as;as;as], sparse ([af;af;af]))
+%!assert (cat (2,as,as), sparse ([af,af]))
+%!assert (cat (1,as,as), sparse ([af;af]))
+%!assert (cat (2,as,as,as), sparse ([af,af,af]))
+%!assert (cat (1,as,as,as), sparse ([af;af;af]))
+%!assert (issparse ([as,af]))
+%!assert (issparse ([af,as]))
+%!assert ([as,af], sparse ([af,af]))
+%!assert ([as;af], sparse ([af;af]))
 
 EOF
 }
 
 # operations which require square matrices.
 gen_square_tests() {
 # The \ and / operator tests on square matrices
     gen_square_divop_tests
@@ -677,19 +677,19 @@ gen_square_tests() {
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # inverse
 %! assert (inv (bs)*bs, sparse (eye (rows (bs))), 1e-10);
 
-%!assert (bf\as', bf\af', 100*eps);
-%!assert (bs\af', bf\af', 100*eps);
-%!assert (bs\as', sparse (bf\af'), 100*eps);
+%!assert (bf\as', bf\af', 100*eps)
+%!assert (bs\af', bf\af', 100*eps)
+%!assert (bs\as', sparse (bf\af'), 100*eps)
 
 EOF
 }
 
 # Cholesky tests
 gen_cholesky_tests() {
     cat <<EOF
 %!testif HAVE_CHOLMOD
@@ -840,18 +840,18 @@ EOF
 
 gen_select_tests() {
     cat <<EOF
 %!test as = sparse (af);
 
 %% Point tests
 %!test idx = ridx(:) + rows (as) * (cidx (:)-1);
 %!assert (sparse (as(idx)), sparse (af(idx)))
-%!assert (as(idx), sparse (af(idx)));
-%!assert (as(idx'), sparse (af(idx')));
+%!assert (as(idx), sparse (af(idx)))
+%!assert (as(idx'), sparse (af(idx')))
 %!assert (as(flipud (idx(:))), sparse (af(flipud (idx(:)))))
 %!assert (as([idx,idx]), sparse (af([idx,idx])))
 %!assert (as(reshape ([idx;idx], [1,length(idx),2])), sparse(af(reshape ([idx;idx], [1,length(idx),2]))))
 
 %% Slice tests
 %!assert (as(ridx,cidx), sparse (af(ridx,cidx)))
 %!assert (as(ridx,:), sparse (af(ridx,:)))
 %!assert (as(:,cidx), sparse (af(:,cidx)))
@@ -976,46 +976,46 @@ cat <<EOF
 %! pus = sparse (puf);
 %! bs = spdiags (repmat ([1:n]',1,4),-2:1,n,n).*alpha;
 %! bf = full (bs);
 %! cf = lf + lf'; cs = sparse (cf);
 %! bcf = bf + bf'; bcs = sparse (bcf);
 %! tcf = tf + tf'; tcs = sparse (tcf);
 %! xf = diag (1:n) + fliplr (diag (1:n)).*beta;
 %! xs = sparse (xf);
-%!assert (ds\xf, df\xf, 1e-10);
-%!assert (ds\xs, sparse (df\xf), 1e-10);
-%!assert (pds\xf, pdf\xf, 1e-10);
-%!assert (pds\xs, sparse (pdf\xf), 1e-10);
-%!assert (ls\xf, lf\xf, 1e-10);
-%!assert (sparse (ls\xs), sparse (lf\xf), 1e-10);
+%!assert (ds\xf, df\xf, 1e-10)
+%!assert (ds\xs, sparse (df\xf), 1e-10)
+%!assert (pds\xf, pdf\xf, 1e-10)
+%!assert (pds\xs, sparse (pdf\xf), 1e-10)
+%!assert (ls\xf, lf\xf, 1e-10)
+%!assert (sparse (ls\xs), sparse (lf\xf), 1e-10)
 %!testif HAVE_UMFPACK
 %! assert (pls\xf, plf\xf, 1e-10);
 %!testif HAVE_UMFPACK
 %! assert (sparse (pls\xs), sparse (plf\xf), 1e-10);
-%!assert (us\xf, uf\xf, 1e-10);
-%!assert (sparse (us\xs), sparse (uf\xf), 1e-10);
+%!assert (us\xf, uf\xf, 1e-10)
+%!assert (sparse (us\xs), sparse (uf\xf), 1e-10)
 %!testif HAVE_UMFPACK
 %! assert (pus\xf, puf\xf, 1e-10);
 %!testif HAVE_UMFPACK
 %! assert (sparse (pus\xs), sparse (puf\xf), 1e-10);
-%!assert (bs\xf, bf\xf, 1e-10);
-%!assert (sparse (bs\xs), sparse (bf\xf), 1e-10);
+%!assert (bs\xf, bf\xf, 1e-10)
+%!assert (sparse (bs\xs), sparse (bf\xf), 1e-10)
 %!testif HAVE_UMFPACK
 %! assert (cs\xf, cf\xf, 1e-10);
 %!testif HAVE_UMFPACK
 %! assert (sparse (cs\xs), sparse (cf\xf), 1e-10);
 %!testif HAVE_UMFPACK
 %! assert (bcs\xf, bcf\xf, 1e-10);
 %!testif HAVE_UMFPACK
 %! assert (sparse (bcs\xs), sparse (bcf\xf), 1e-10);
-%!assert (ts\xf, tf\xf, 1e-10);
-%!assert (sparse (ts\xs), sparse (tf\xf), 1e-10);
-%!assert (tcs\xf, tcf\xf, 1e-10);
-%!assert (sparse (tcs\xs), sparse (tcf\xf), 1e-10);
+%!assert (ts\xf, tf\xf, 1e-10)
+%!assert (sparse (ts\xs), sparse (tf\xf), 1e-10)
+%!assert (tcs\xf, tcf\xf, 1e-10)
+%!assert (sparse (tcs\xs), sparse (tcf\xf), 1e-10)
 
 EOF
 
 cat <<EOF
 %% QR solver tests
 
 %!function f (a, sz, feps)
 %! b = randn (sz);
diff --git a/test/classdef/classdef.tst b/test/classdef/classdef.tst
--- a/test/classdef/classdef.tst
+++ b/test/classdef/classdef.tst
@@ -34,36 +34,36 @@
 %%  kind of the same, that create a hierarchy.
 
 %%  Basic classdef tests for value class
 %!shared p, q, i, amt
 %! q = foo_value_class ();
 %! p = foo_value_class (4, 4*12, 50e3);
 %! i = p.rate / (12 * 100);
 %! amt = (p.principle * i) / (1 - (1 + i)^(-p.term));
-%!assert (isempty (q.rate));
-%!assert (isempty (q.principle));
-%!assert (isempty (q.term));
-%!assert (class (p), "foo_value_class");
-%!assert (p.term, 48);
-%!assert (p.rate, 4.0);
-%!assert (p.principle, 50e3);
+%!assert (isempty (q.rate))
+%!assert (isempty (q.principle))
+%!assert (isempty (q.term))
+%!assert (class (p), "foo_value_class")
+%!assert (p.term, 48)
+%!assert (p.rate, 4.0)
+%!assert (p.principle, 50e3)
 %!assert (p.amount, amt, eps ())
 %!assert (amount (p), amt, eps ())
 %!xtest
 %! assert (properties (p), {'rate'; 'term'; 'principle'})
 %!xtest
 %! assert (methods (p), {'amount'; 'foo_value_class'})
 %!assert (isempty (foo_value_class().rate))
 %!error <property `rate' is not constant> foo_value_class.rate
 
 %%  Static method and Constant Property
-%!assert (foo_static_method_constant_property.radians_per_cycle, 2*pi);
-%!assert (foo_static_method_constant_property().radians_per_cycle, 2*pi);
-%!assert (foo_static_method_constant_property().pie, pi);
+%!assert (foo_static_method_constant_property.radians_per_cycle, 2*pi)
+%!assert (foo_static_method_constant_property().radians_per_cycle, 2*pi)
+%!assert (foo_static_method_constant_property().pie, pi)
 %!error <property `frequency' is not constant> foo_static_method_constant_property.frequency
 %!error <method `cosine' is not static> foo_static_method_constant_property.cosine
 %!test
 %! obj = foo_static_method_constant_property;
 %! obj.frequency = 10;
 %! assert (obj.cosine (0.1), cos (2 * pi * 10 * 0.1), eps ())
 %! assert (obj.sine (0.1), sin (2 * pi * 10 * 0.1), eps ())
 
diff --git a/test/classes/classes.tst b/test/classes/classes.tst
--- a/test/classes/classes.tst
+++ b/test/classes/classes.tst
@@ -319,23 +319,23 @@
 %!test   s = [s1 s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
 %!xtest  s = [s1 x2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
 %!xtest  s = [x1 s2];  assert (isa (s, 'Snork') && isequal (s.gick, [x1 x2]));
 
 %% Test with the Blork class, where neither vertcat() nor horzcat() is overloaded
 %!shared x1, x2, x3
 %!test x1 = Blork ();
 %!test x2 = [x1 x1];
-%!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]));
+%!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]))
 %!test x2 = [x1 51];
-%!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]));
+%!assert (isa (x2, 'Blork') && isequal (size (x2), [1 2]))
 %!test x3 = [x2; x2];
-%!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]));
+%!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]))
 %!test x3 = [x2; [51 x1]];
-%!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]));
+%!assert (isa (x3, 'Blork') && isequal (size (x3), [2 2]))
 %!error <dimension mismatch> x4 = [x1  x3];
 %!error <dimension mismatch> x4 = [x1; x3];
 
 %%%%%%%%%%%%%%%%%%%%%%%%
 %% Testing precedence %%
 %%%%%%%%%%%%%%%%%%%%%%%%
 
 %% default: leftmost object wins
diff --git a/test/diag-perm.tst b/test/diag-perm.tst
--- a/test/diag-perm.tst
+++ b/test/diag-perm.tst
@@ -176,25 +176,25 @@
 %! n = 6;
 %! mn = min (m, n);
 %! d = rand (mn, 1);
 %! D = diag (d, m, n);
 %! Dslice = D (1:(m-3), 1:(n-2));
 %! assert (typeinfo (Dslice), "diagonal matrix");
 
 ## preserve dense matrix structure when scaling
-%!assert (typeinfo (rand (8) * (3 * eye (8))), "matrix");
-%!assert (typeinfo ((3 * eye (8)) * rand (8)), "matrix");
+%!assert (typeinfo (rand (8) * (3 * eye (8))), "matrix")
+%!assert (typeinfo ((3 * eye (8)) * rand (8)), "matrix")
 
 ## preserve sparse matrix structure when scaling
-%!assert (typeinfo (sprand (8, 8, .5) * (3 * eye (8))), "sparse matrix");
-%!assert (typeinfo (sprand (8, 8, .5) * (3 * eye (8))'), "sparse matrix");
-%!assert (typeinfo (((3 + 2 * I ()) * eye (8)) * sprand (8, 8, .5)), "sparse complex matrix");
-%!assert (typeinfo (((3 + 2 * I ()) * eye (8))' * sprand (8, 8, .5)), "sparse complex matrix");
-%!assert (typeinfo (sprand (8, 8, .5) * ((3 + 2 * I ()) * eye (8)).'), "sparse complex matrix");
+%!assert (typeinfo (sprand (8, 8, .5) * (3 * eye (8))), "sparse matrix")
+%!assert (typeinfo (sprand (8, 8, .5) * (3 * eye (8))'), "sparse matrix")
+%!assert (typeinfo (((3 + 2 * I ()) * eye (8)) * sprand (8, 8, .5)), "sparse complex matrix")
+%!assert (typeinfo (((3 + 2 * I ()) * eye (8))' * sprand (8, 8, .5)), "sparse complex matrix")
+%!assert (typeinfo (sprand (8, 8, .5) * ((3 + 2 * I ()) * eye (8)).'), "sparse complex matrix")
 
 ## scaling a matrix with exceptional values does not introduce new ones.
 %!test
 %! n = 6;
 %! dr = rand (n, 1);
 %! Dr = diag (dr);
 %! dc = rand (1, n);
 %! Dc = diag (dc);
diff --git a/test/index.tst b/test/index.tst
--- a/test/index.tst
+++ b/test/index.tst
@@ -204,23 +204,23 @@
 %! assert (a, reshape (1:4,[1,1,1,4]));
 
 %!error (a(1:2,1:2) = 1:4)
 
 ## bug #38357
 %!shared d, dd
 %! d = diag ([1, 2, 3]);
 %! dd = diag ([1, 2, 3], 6, 3);
-%!assert (d(1), 1);
-%!assert (dd(1), 1);
-%!assert (d(3, 3), 3);
-%!assert (dd(3, 3), 3);
-%!assert (d(2), 0);
-%!assert (dd(2), 0);
-%!assert (dd(6,1), 0);
+%!assert (d(1), 1)
+%!assert (dd(1), 1)
+%!assert (d(3, 3), 3)
+%!assert (dd(3, 3), 3)
+%!assert (d(2), 0)
+%!assert (dd(2), 0)
+%!assert (dd(6,1), 0)
 %!error d(6,6);
 %!error dd(6,6);
 %!error d(3,6);
 %!error dd(3,6);
 
 ## bug 31287
 %!test
 %! y = ones (2, 2, 2);
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -643,37 +643,37 @@
 %! id = tmpfile ();
 %! fwrite (id, "abcd");
 %! frewind (id);
 %! [data, count] = fread (id, [2, 3], "char");
 %! assert (data, [97, 99; 98, 100]);
 %! assert (count, 4);
 %! fclose (id);
 
-%!assert (sprintf ("%1s", "foo"), "foo");
-%!assert (sprintf ("%.s", "foo"), char (zeros (1, 0)));
-%!assert (sprintf ("%1.s", "foo"), " ");
-%!assert (sprintf ("%.1s", "foo"), "f");
-%!assert (sprintf ("%1.1s", "foo"), "f");
-%!assert (sprintf ("|%4s|", "foo"), "| foo|");
-%!assert (sprintf ("|%-4s|", "foo"), "|foo |");
-%!assert (sprintf ("|%4.1s|", "foo"), "|   f|");
-%!assert (sprintf ("|%-4.1s|", "foo"), "|f   |");
+%!assert (sprintf ("%1s", "foo"), "foo")
+%!assert (sprintf ("%.s", "foo"), char (zeros (1, 0)))
+%!assert (sprintf ("%1.s", "foo"), " ")
+%!assert (sprintf ("%.1s", "foo"), "f")
+%!assert (sprintf ("%1.1s", "foo"), "f")
+%!assert (sprintf ("|%4s|", "foo"), "| foo|")
+%!assert (sprintf ("|%-4s|", "foo"), "|foo |")
+%!assert (sprintf ("|%4.1s|", "foo"), "|   f|")
+%!assert (sprintf ("|%-4.1s|", "foo"), "|f   |")
 
-%!assert (sprintf ("%c ", "foo"), "f o o ");
-%!assert (sprintf ("%s ", "foo"), "foo ");
+%!assert (sprintf ("%c ", "foo"), "f o o ")
+%!assert (sprintf ("%s ", "foo"), "foo ")
 
-%!assert (sprintf ("|%d|", "foo"), "|102||111||111|");
-%!assert (sprintf ("|%s|", [102, 111, 111]), "|foo|");
+%!assert (sprintf ("|%d|", "foo"), "|102||111||111|")
+%!assert (sprintf ("|%s|", [102, 111, 111]), "|foo|")
 
-%!assert (sprintf ("%s %d ", [102, 1e5, 111, 1e5, 111]), "f 100000 o 100000 o ");
+%!assert (sprintf ("%s %d ", [102, 1e5, 111, 1e5, 111]), "f 100000 o 100000 o ")
 
-%!assert (sprintf ("%c,%c,%c,%c", "abcd"), "a,b,c,d");
-%!assert (sprintf ("%s,%s,%s,%s", "abcd"), "abcd,");
+%!assert (sprintf ("%c,%c,%c,%c", "abcd"), "a,b,c,d")
+%!assert (sprintf ("%s,%s,%s,%s", "abcd"), "abcd,")
 
-%!assert (sprintf ("|%x|", "Octave"), "|4f||63||74||61||76||65|");
-%!assert (sprintf ("|%X|", "Octave"), "|4F||63||74||61||76||65|");
-%!assert (sprintf ("|%o|", "Octave"), "|117||143||164||141||166||145|");
+%!assert (sprintf ("|%x|", "Octave"), "|4f||63||74||61||76||65|")
+%!assert (sprintf ("|%X|", "Octave"), "|4F||63||74||61||76||65|")
+%!assert (sprintf ("|%o|", "Octave"), "|117||143||164||141||166||145|")
 
 ## bug #47192
 %!assert (sprintf ("%s", repmat ("blah", 2, 1)), "bbllaahh")
 %!assert (sprintf ("%c", repmat ("blah", 2, 1)), "bbllaahh")
 %!assert (sprintf ("%c %c %s", repmat ("blah", 2, 1)), "b b llaahh")
diff --git a/test/logical-index.tst b/test/logical-index.tst
--- a/test/logical-index.tst
+++ b/test/logical-index.tst
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 %!test
 %! a = [];
 %! fail ("a(0);");
 
 %!shared a
 %! a = 2;
-%!assert (a(1), 2);
+%!assert (a(1), 2)
 %!error id=Octave:index-out-of-bounds a(logical ([1,1]))
 
 %!shared a
 %! a = [9,8,7,6];
 %!assert (isempty (a(logical ([0,0,0,0]))))
 %!assert (a(logical ([1,1,1,1])), [9,8,7,6])
 %!assert (a(logical ([0,1,1,0])), [8,7])
 %!assert (a(logical ([1,1])), [9,8])
diff --git a/test/nest/nest.tst b/test/nest/nest.tst
--- a/test/nest/nest.tst
+++ b/test/nest/nest.tst
@@ -42,17 +42,17 @@
 %! scope0;
 
 %!test
 %! scope1 (1);
 
 %!test
 %! scope3;
 
-%!assert (nest_eval ("x = 5;", "x = 6;"), 6);
-%!assert (nest_eval ("x = 5;", "y = 6;"), 5);
-%!assert (nest_eval ("x = -5; x = abs (x);", "y = 6;"), 5);
+%!assert (nest_eval ("x = 5;", "x = 6;"), 6)
+%!assert (nest_eval ("x = 5;", "y = 6;"), 5)
+%!assert (nest_eval ("x = -5; x = abs (x);", "y = 6;"), 5)
 
 %!error <D' undefined near line 7> scope2
 %!error <handles to nested functions are not yet supported> no_closure (0)
 %!error <handles to nested functions are not yet supported> no_closure (1)
 %!error <can not add variable "y" to a static workspace> nest_eval ("y = 5;", "")
 %!error <can not add variable "y" to a static workspace> nest_eval ("y;", "")
diff --git a/test/parser.tst b/test/parser.tst
--- a/test/parser.tst
+++ b/test/parser.tst
@@ -275,17 +275,17 @@
 %! assert (a += b *= c += 1, 42);
 %! assert (b == 40 && c == 8);
 
 ## Test extended number format which allows '_' as NOP character
 %!assert (123_456, 123456)
 %!assert (.123_456, .123456)
 %!assert (123_456.123_456, 123456.123456)
 %!assert (0xAB_CD, 43981)
-%!assert (2e0_1, 20);
+%!assert (2e0_1, 20)
 
 ## Test binary constants
 %!assert (0b101, 5)
 %!assert (0B1100_0001, 0xC1)
 %!assert (class (0b1), "double")
 
 ## Test creation of anonymous functions
 
diff --git a/test/prefer.tst b/test/prefer.tst
--- a/test/prefer.tst
+++ b/test/prefer.tst
@@ -28,19 +28,19 @@
 %!test
 %! a = 2;
 %! assert ([a - 1], 1);
 
 %!test
 %! m = [3,2];
 %! fail ("[m ']");
 
-%!assert (all ([3 2] == (3:-1:2)));
+%!assert (all ([3 2] == (3:-1:2)))
 
-%!assert (all ([3, 2] == (3:-1:2)));
+%!assert (all ([3, 2] == (3:-1:2)))
 
 %!test
 %! m = [3,2];
 %! assert (all ([m (1)] == (3:-1:1)));
 
 %!test
 %! m = [3,2];
 %! assert ([m(1)],3);
@@ -102,19 +102,19 @@
 %!test
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (1);
 %! a = cell (1, 1);
 %! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[](0x0)")));
 %! print_empty_dimensions (ped);
 
-%!assert (all (size (inv ([])) == [0, 0]));
+%!assert (all (size (inv ([])) == [0, 0]))
 
-%!assert (all (svd ([]) == zeros (0, 1)));
+%!assert (all (svd ([]) == zeros (0, 1)))
 
 %!test
 %! sp = save_precision ();
 %! save_precision (1);
 %! x = pi;
 %! nm = tempname ();
 %! save ("-text", nm, "x");
 %! clear x;
diff --git a/test/struct.tst b/test/struct.tst
--- a/test/struct.tst
+++ b/test/struct.tst
@@ -46,17 +46,17 @@
 
 %!error <Invalid call to isfield> isfield ();
 
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
 %! fail ("isfield (s, 'a', 3);", "Invalid call to isfield");
 
-%!assert (isfield (1, "m") == 0);
+%!assert (isfield (1, "m") == 0)
 
 %!test
 %! s.a = 2;
 %! assert (isfield (s, 2) == 0);
 
 %!assert (isstruct (1), false)
 %!assert (isstruct ([1, 2]), false)
 %!assert (isstruct ([]), false)
