# HG changeset patch
# User jwe
# Date 1177019261 0
#      Thu Apr 19 21:47:41 2007 +0000
# Node ID 4fb053f24fd6a78b831b7e1101664bf18609d94e
# Parent  44a4f68fbd76e94bfa87019a3d23814410eaf1ff
[project @ 2007-04-19 21:47:40 by jwe]

diff --git a/doc/interpreter/bugs.txi b/doc/interpreter/bugs.txi
--- a/doc/interpreter/bugs.txi
+++ b/doc/interpreter/bugs.txi
@@ -65,72 +65,16 @@ fflush (stdout)
 Another possible workaround is to use the command
 
 @example
 page_screen_output = "false"
 @end example
 
 @noindent
 to turn the pager off.
-
-@item
-If you get messages like
-
-@example
-Input line too long
-@end example
-
-when trying to plot many lines on one graph, you have probably generated
-a plot command that is too large for @code{gnuplot}'s fixed-length
-buffer for commands.  Splitting up the plot command doesn't help because
-replot is implemented in gnuplot by simply appending the new plotting
-commands to the old command line and then evaluating it again.
-
-You can demonstrate this `feature' by running gnuplot and doing
-something like
-
-@example
-  plot sin (x), sin (x), sin (x), ... lots more ..., sin (x)
-@end example
-
-@noindent
-and then
-
-@example
-  replot sin (x), sin (x), sin (x), ... lots more ..., sin (x)
-@end example
-
-@noindent
-after repeating the replot command a few times, gnuplot will give you
-an error.
-
-Also, it doesn't help to use backslashes to enter a plot command over
-several lines, because the limit is on the overall command line
-length, once the backslashed lines are all pasted together.
-
-Because of this, Octave tries to use as little of the command-line
-length as possible by using the shortest possible abbreviations for
-all the plot commands and options.  Unfortunately, the length of the
-temporary file names is probably what is taking up the most space on
-the command line.
-
-You can buy a little bit of command line space by setting the
-environment variable @code{TMPDIR} to be "." before starting Octave, or
-you can increase the maximum command line length in gnuplot by changing
-the following limits in the file plot.h in the gnuplot distribution and
-recompiling gnuplot.
-
-@example
-#define MAX_LINE_LEN 32768  /* originally 1024 */
-#define MAX_TOKENS 8192     /* originally 400 */
-@end example  
-
-Of course, this doesn't really fix the problem, but it does make it
-much less likely that you will run into trouble unless you are putting
-a very large number of lines on a given plot.
 @end itemize
 
 A list of ideas for future enhancements is distributed with Octave.  See
 the file @file{PROJECTS} in the top level directory in the source
 distribution.
 
 @node Reporting Bugs
 @appendixsec Reporting Bugs
diff --git a/doc/interpreter/grammar.txi b/doc/interpreter/grammar.txi
--- a/doc/interpreter/grammar.txi
+++ b/doc/interpreter/grammar.txi
@@ -2,57 +2,35 @@
 @c This is part of the Octave manual.
 @c For copying conditions, see the file gpl.texi.
 
 @node Grammar
 @appendix Grammar
 @cindex grammar rules
 @cindex language definition
 
-Someday I hope to expand this to include a semi-formal description of
+This appendix should eventually contain a semi-formal description of
 Octave's language.
 
 @menu
 * Keywords::                    
 @end menu
 
 @node Keywords
 @section Keywords
 @cindex keywords
 
 The following identifiers are keywords, and may not be used as variable
 or function names:
 
-@example
-@group
-break                   for
-case                    function
-catch                   global
-continue                gplot
-else                    gsplot
-elseif                  if
-end                     otherwise
-end_try_catch           return
-end_unwind_protect      switch
-endfor                  try
-endfunction             unwind_protect
-endif                   unwind_protect_cleanup
-endswitch               while
-endwhile                
-@end group
-@end example
-
-The following command-like functions are also speical.  They may be used
-as simple variable names, but not as formal parameters for functions, or
-as the names of structure variables.  Failed assignments leave them
-undefined (you can recover the orginal definition as a function using
-clear).
-
-@example
-@group
-casesen       echo          load          show
-cd            edit_history  ls            type
-chdir         format        more          which
-clear         help          run_history   who
-diary         history       save          whos
-dir           hold          set
-@end group
-@end example
+@multitable @columnfractions .33 .33 .33
+@item @code{break} @tab @code{case} @tab @code{catch}
+@item @code{continue} @tab @code{do} @tab @code{else}
+@item @code{elseif} @tab @code{end} @tab @code{end_try_catch}
+@item @code{end_unwind_protect} @tab @code{endfor} @tab @code{endfunction}
+@item @code{endif} @tab @code{endswitch} @tab @code{endwhile}
+@item @code{for} @tab @code{function} @tab @code{global}
+@item @code{if} @tab @code{otherwise} @tab @code{persistent}
+@item @code{return} @tab @code{static} @tab @code{switch}
+@item @code{try} @tab @code{until} @tab @code{unwind_protect}
+@item @code{unwind_protect_cleanup} @tab @code{varargin} @tab @code{varargout}
+@item @code{while} @tab @code{__FILE__} @tab @code{__LINE__}
+@end multitable
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -13,32 +13,32 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y}} = wavread (@var{filename})
+## @deftypefn {Function File} {@var{y} =} wavread (@var{filename})
 ## Load the RIFF/WAVE sound file @var{filename}, and return the samples
 ## in vector @var{y}.  If the file contains multichannel data, then
 ## @var{y} is a matrix with the channels represented as columns.
 ##
-## @deftypefnx {Function File} {[@var{y}, @var{Fs}, @var{bits}]} = wavread (@var{filename})
+## @deftypefnx {Function File} {[@var{y}, @var{Fs}, @var{bits}] =} wavread (@var{filename})
 ## Additionally return the sample rate (@var{fs}) in Hz and the number of bits 
 ## per sample (@var{bits}).
 ##
-## @deftypefnx {Function File} {[@dots{}]} = wavread (@var{filename}, @var{n})
+## @deftypefnx {Function File} {[@dots{}] =} wavread (@var{filename}, @var{n})
 ## Read only the first @var{n} samples from each channel.
 ##
-## @deftypefnx {Function File} {[@dots{}]} = wavread(@var{filename},[@var{n1} @var{n2}])
+## @deftypefnx {Function File} {[@dots{}] =} wavread(@var{filename},[@var{n1} @var{n2}])
 ## Read only samples @var{n1} through @var{n2} from each channel.
 ##
-## @deftypefnx {Function File} {[@var{samples}, @var{channels}]} = wavread (@var{filename}, "size")
+## @deftypefnx {Function File} {[@var{samples}, @var{channels}] =} wavread (@var{filename}, "size")
 ## Return the number of samples (@var{n}) and channels (@var{ch})
 ## instead of the audio data.
 ## @seealso{wavwrite}
 ## @end deftypefn
 
 ## Author: Michael Zeising <michael.zeising@stud.uni-erlangen.de>
 ## Created: 06 December 2005
 
diff --git a/scripts/control/system/dmr2d.m b/scripts/control/system/dmr2d.m
--- a/scripts/control/system/dmr2d.m
+++ b/scripts/control/system/dmr2d.m
@@ -50,19 +50,19 @@
 ## @strong{Outputs}
 ## @table @var
 ## @item   dsys
 ## equivalent discrete time system with sampling time @var{ts2}.
 ##
 ## The sampling time of sys is updated to @var{ts2}.
 ##
 ## if @var{cuflg}=0 then a set of additional inputs is added to
-## the system with suffixes _d1, ..., _dn to indicate their
+## the system with suffixes _d1, @dots{}, _dn to indicate their
 ## delay from the starting time k @var{ts2}, i.e.
-## u = [u_1; u_1_d1; ..., u_1_dn] where u_1_dk is the input
+## u = [u_1; u_1_d1; @dots{}, u_1_dn] where u_1_dk is the input
 ## k*ts1 units of time after u_1 is sampled. (@var{ts1} is
 ## the original sampling time of the discrete time system and
 ## @var{ts2} = (n+1)*ts1)
 ##
 ## @item   fidx
 ## indices of "formerly fast" states specified by @var{idx} and @var{sprefix};
 ## these states are updated to the new (slower) sampling interval @var{ts2}.
 ## @end table
diff --git a/scripts/control/system/fir2sys.m b/scripts/control/system/fir2sys.m
--- a/scripts/control/system/fir2sys.m
+++ b/scripts/control/system/fir2sys.m
@@ -21,26 +21,26 @@
 ## @deftypefn {Function File} {} fir2sys (@var{num}, @var{tsam}, @var{inname}, @var{outname})
 ## construct a system data structure from @acronym{FIR} description
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item num
 ## vector of coefficients 
 ## @ifinfo
-## [c0, c1, ..., cn]
+## [c0, c1, @dots{}, cn]
 ## @end ifinfo
 ## @iftex
 ## @tex
 ## $ [c_0, c_1, \ldots, c_n ]$
 ## @end tex
 ## @end iftex
 ## of the @acronym{SISO} @acronym{FIR} transfer function
 ## @ifinfo
-## C(z) = c0 + c1*z^(-1) + c2*z^(-2) + ... + cn*z^(-n)
+## C(z) = c0 + c1*z^(-1) + c2*z^(-2) + @dots{} + cn*z^(-n)
 ## @end ifinfo
 ## @iftex
 ## @tex
 ## $$ C(z) = c_0 + c_1z^{-1} + c_2z^{-2} + \ldots + c_nz^{-n} $$
 ## @end tex
 ## @end iftex
 ##
 ## @item tsam
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Mapping Function} {} lcm (@var{x}, @code{...})
+## @deftypefn {Mapping Function} {} lcm (@var{x}, @dots{})
 ## Compute the least common multiple of the elements elements of @var{x}, or
 ## the list of all the arguments.  For example,
 ##
 ## @example
 ## lcm (a1, ..., ak)
 ## @end example
 ##
 ## @noindent
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y}} = circshift (@var{x}, @var{n})
+## @deftypefn {Function File} {@var{y} =} circshift (@var{x}, @var{n})
 ## Circularly shifts the values of the array @var{x}. @var{n} must be
 ## a vector of integers no longer than the number of dimensions in 
 ## @var{x}. The values of @var{n} can be either positive or negative,
 ## which determines the direction in which the values or @var{x} are
 ## shifted. If an element of @var{n} is zero, then the corresponding
 ## dimension of @var{x} will not be shifted. For example
 ##
 ## @example
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{err}, @var{y1}, ...] =} common_size (@var{x1}, ...)
+## @deftypefn {Function File} {[@var{err}, @var{y1}, @dots{}] =} common_size (@var{x1}, @dots{})
 ## Determine if all input arguments are either scalar or of common
 ## size.  If so, @var{err} is zero, and @var{yi} is a matrix of the
 ## common size with all entries equal to @var{xi} if this is a scalar or
 ## @var{xi} otherwise.  If the inputs cannot be brought to a common size,
 ## errorcode is 1, and @var{yi} is @var{xi}.  For example,
 ##
 ## @example
 ## @group
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y}} = shiftdim (@var{x}, @var{n})
-## @deftypefnx {Function File} {[@var{y}, @var{ns}]} = shiftdim (@var{x})
+## @deftypefn {Function File} {@var{y} =} shiftdim (@var{x}, @var{n})
+## @deftypefnx {Function File} {[@var{y}, @var{ns}] =} shiftdim (@var{x})
 ## Shifts the dimension of @var{x} by @var{n}, where @var{n} must be
 ## an integer scalar. When @var{n} is positive, the dimensions of
 ## @var{x} are shifted to the left, with the leading dimensions
 ## circulated to the end. If @var{n} is negative, then the dimensions
 ## of @var{x} are shifted to the right, with @var{n} leading singleton
 ## dimensions added.
 ##
 ## Called with a single argument, @code{shiftdim}, removes the leading
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} @var{rgb_map} = hsv2rgb (@var{hsv_map})
+## @deftypefn {Function File} {@var{rgb_map} =} hsv2rgb (@var{hsv_map})
 ## Transform a colormap from the hsv space to the rgb space. 
 ## @seealso{rgb2hsv}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function rgb_map = hsv2rgb (hsv_map)
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} @var{hsv_map} = rgb2hsv (@var{rgb_map})
+## @deftypefn {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb_map})
 ## Transform a colormap from the rgb space to the hsv space.
 ##
 ## A color n the RGB space consists of the red, green and blue intensities.
 ##
 ## In the HSV space each color is represented by their hue, saturation
 ## and value (brightness).  Value gives the amount of light in the color.
 ## Hue describes the dominant wavelegth. 
 ## Saturation is the amount of Hue mixed into the color.
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -13,33 +13,33 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Built-in Function} {} [@var{v1},...] =
-## @code{getfield (@var{s}, 'k1',...)} extract fields from a structure.
+## @deftypefn {Built-in Function} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{}) extract fields from a structure.
 ## For example
 ##
 ## @example
 ## @group
 ## ss(1,2).fd(3).b=5;
-## getfield(ss,@{1,2@},'fd',@{3@},'b')
+## getfield (ss, @{1,2@}, "fd", @{3@}, "b")
 ## @result{} ans = 5
 ## @end group
 ## @end example
 ##
-## Note that this function could be written as
+## Note that the function call in the previous example is equivalent to
+## the expression
 ##
 ## @example
-##          i1= @{1,2@}; i2= 'fd'; i3= @{3@}; i4= 'b';
-##          ss( i1@{:@} ).( i2 )( i3@{:@} ).( i4 )
+##          i1= @{1,2@}; i2= "fd"; i3= @{3@}; i4= "b";
+##          ss(i1@{:@}).(i2)(i3@{:@}).(i4)
 ## @end example
 ## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
 function s = getfield (s, varargin)
 
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -19,37 +19,37 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} license
 ## Display the license of Octave.
 ##
 ## @deftypefnx {Function File} {} license ("inuse")
 ## Display a list of packages currently being used.
 ##
-## @deftypefnx {Function File} {@var{retval}} = license ("inuse")
+## @deftypefnx {Function File} {@var{retval} =} license ("inuse")
 ## Return a structure containing the fields @code{feature} and @code{user}.
 ##
-## @deftypefnx {Function File} {@var{retval}} = license ("test", @var{feature})
+## @deftypefnx {Function File} {@var{retval} =} license ("test", @var{feature})
 ## Return 1 if a license exists for the product identified by the string
 ## @var{feature} and 0 otherwise.  The argument @var{feature} is case
 ## insensitive and only the first 27 characters are checked.
 ##
 ## @deftypefnx {Function File} {} license ("test", @var{feature}, @var{toggle})
 ## Enable or disable license testing for @var{feature}, depending on
 ## @var{toggle}, which may be one of:
 ##
 ## @table @samp
 ## @item "enable"
 ## Future tests for the specified license of @var{feature} are conducted
 ## as usual.
 ## @item "disable"
 ## Future tests for the specified license of @var{feature} return 0.
 ## @end table
 ##
-## @deftypefnx {Function File} {@var{retval}} = license ("checkout", @var{feature})
+## @deftypefnx {Function File} {@var{retval} =} license ("checkout", @var{feature})
 ## Check out a license for @var{feature}, returning 1 on success and 0
 ## on failure.
 ##
 ## This function is provided for compatibility with @sc{Matlab}.
 ## @seealso{ver, version}
 ## @end deftypefn
 
 ## Author: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
diff --git a/scripts/miscellaneous/mex.m b/scripts/miscellaneous/mex.m
--- a/scripts/miscellaneous/mex.m
+++ b/scripts/miscellaneous/mex.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} mex [options] file ...
+## @deftypefn {Function File} {} mex [options] file @dots{}
 ## Compile source code written in C, C++, or Fortran, to a MEX file.
 ## This is equivalent to @code{mkoctfile --mex [options] file}.
 ## @seealso{mkoctfile}
 ## @end deftypefn
 
 ## PKG_ADD: mark_as_command mex
 
 function mex (varargin)
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} mkoctfile [-options] file ...
+## @deftypefn {Function File} {} mkoctfile [-options] file @dots{}
 ## 
 ## The @code{mkoctfile} function compiles source code written in C,
 ## C++, or Fortran.  Depending on the options used with @code{mkoctfile}, the
 ## compiled code can be called within Octave or can be used as a stand-alone
 ## application.
 ##
 ## @code{mkoctfile} can be called from the shell prompt or from the Octave
 ## prompt.
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{k1},..., @var{v1}] =} setfield (@var{s}, @var{k1}, @var{v1}, @dots{})
+## @deftypefn {Function File} {[@var{k1}, @dots{}, @var{v1}] =} setfield (@var{s}, @var{k1}, @var{v1}, @dots{})
 ## Set field members in a structure.
 ##
 ## @example
 ## @group
 ## oo(1,1).f0= 1;
 ## oo = setfield(oo,@{1,2@},'fd',@{3@},'b', 6);
 ## oo(1,2).fd(3).b == 6
 ## @result{} ans = 1
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -13,42 +13,43 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} {@var{c}} = contour (@var{x},@var{y},@var{z},@var{vv})
+## @deftypefn {Function File} {} {@var{c} =} contour (@var{x}, @var{y}, @var{z}, @var{vv})
 ## Compute isolines (countour lines) of the matrix @var{z}. 
 ## parameters @var{x}, @var{y} and @var{vn} are optional.
 ##
 ## The return value @var{c} is a 2 by @var{n} matrix containing the
 ## contour lines in the following format
 ##
 ## @example
-## @var{c} = [lev1 , x1 , x2 , ... , levn , x1 , x2 , ... 
-##      len1   , y1 , y2 , ... , lenn   , y1 , y2 , ...  ]
+## @var{c} = [lev1, x1, x2, ..., levn, x1, x2, ... 
+##      len1, y1, y2, ..., lenn, y1, y2, ...]
 ## @end example
 ##
 ## @noindent
 ## in which contour line @var{n} has a level (height) of @var{levn} and
 ## length of @var{lenn}.
 ## 
 ## If @var{x} and @var{y} are omitted they are taken as the row/column 
 ## index of @var{z}.  @var{vn} is either a scalar denoting the number of
 ## lines to compute or a vector containing the values of the lines.  If
 ## only one value is wanted, set @code{@var{vn} = [val, val]}.  If
 ## @var{vn} is omitted it defaults to 10.
 ##
 ## @example
-## @var{c}=contourc (@var{x}, @var{y}, @var{z}, linspace(0,2*pi,10))
+## levels = linspace (0, 2*pi, 10);
+## @var{c} = contourc (@var{x}, @var{y}, @var{z}, levels);
 ## @end example
-## @seealso{contourc,line,plot}
+## @seealso{contourc, line, plot}
 ## @end deftypefn
 
 ## Author: shaia
 
 function retval = contour (varargin)
 
   [c, lev] = contourc (varargin{:});
 
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -22,18 +22,18 @@
 ## Compute isolines (countour lines) of the matrix @var{z}. 
 ## Parameters @var{x}, @var{y} and @var{vn} are optional.
 ##
 ## The return value @var{lev} is a vector of the contour levels.
 ## The return value @var{c} is a 2 by @var{n} matrix containing the
 ## contour lines in the following format
 ##
 ## @example
-## @var{c} = [lev1 , x1 , x2 , ... , levn , x1 , x2 , ... 
-##      len1   , y1 , y2 , ... , lenn   , y1 , y2 , ...  ]
+## @var{c} = [lev1, x1, x2, ..., levn, x1, x2, ... 
+##      len1, y1, y2, ..., lenn, y1, y2, ...]
 ## @end example
 ##
 ## @noindent
 ## in which contour line @var{n} has a level (height) of @var{levn} and
 ## length of @var{lenn}.
 ## 
 ## If @var{x} and @var{y} are omitted they are taken as the row/column 
 ## index of @var{z}.  @var{vn} is either a scalar denoting the number of lines 
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -30,17 +30,17 @@
 ## where the first argument is taken as the set of @var{y} coordinates
 ## and the second argument @var{ey} is taken as the errors of the
 ## @var{y} values. @var{x} coordinates are taken to be the indices
 ## of the elements, starting with 1.
 ##
 ## If more than two arguments are given, they are interpreted as
 ##
 ## @example
-## errorbar (@var{x}, @var{y}, ..., @var{fmt} ...)
+## errorbar (@var{x}, @var{y}, ..., @var{fmt}, ...)
 ## @end example
 ##
 ## @noindent
 ## where after @var{x} and @var{y} there can be up to four error
 ## parameters such as @var{ey}, @var{ex}, @var{ly}, @var{uy} etc.,
 ## depending on the plot type. Any number of argument sets may appear,
 ## as long as they are separated with a format string @var{fmt}.
 ##
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/ndgrid.m
@@ -13,25 +13,25 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{y1}, @var{y2}, ...,  @var{y}n]} = ndgrid (@var{x1}, @var{x2}, ..., @var{x}n)
-## @deftypefnx {Function File} {[@var{y1}, @var{y2}, ...,  @var{y}n]} = ndgrid (@var{x})
-## Given n vectors @var{x1}, ... @var{x}n, ndgrid returns n arrays of dimension n. 
+## @deftypefn {Function File} {[@var{y1}, @var{y2}, @dots{},  @var{y}n] =} ndgrid (@var{x1}, @var{x2}, @dots{}, @var{x}n)
+## @deftypefnx {Function File} {[@var{y1}, @var{y2}, @dots{},  @var{y}n] =} ndgrid (@var{x})
+## Given n vectors @var{x1}, @dots{} @var{x}n, ndgrid returns n arrays of dimension n. 
 ## The elements of the ith output argument contains the elements of the vector 
 ## @var{x}i repeated over all dimensions different from the ith dimension.
 ## Calling ndgrid with only one input argument @var{x} is equivalent of calling ndgrid with 
 ## all n input arguments equal to @var{x}:
 ##
-## [@var{y1}, @var{y2}, ...,  @var{y}n] = ndgrid (@var{x}, ..., @var{x})
+## [@var{y1}, @var{y2}, @dots{},  @var{y}n] = ndgrid (@var{x}, @dots{}, @var{x})
 ## @seealso{meshgrid}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth@marine.usf.edu>
 
 function varargout = ndgrid (varargin)
 
   if (nargin == 1)
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -17,17 +17,17 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} autoreg_matrix (@var{y}, @var{k})
 ## Given a time series (vector) @var{y}, return a matrix with ones in the
 ## first column and the first @var{k} lagged values of @var{y} in the
 ## other columns.  I.e., for @var{t} > @var{k}, @code{[1,
-## @var{y}(@var{t}-1), ..., @var{y}(@var{t}-@var{k})]} is the t-th row
+## @var{y}(@var{t}-1), @dots{}, @var{y}(@var{t}-@var{k})]} is the t-th row
 ## of the result.  The resulting matrix may be used as a regressor matrix
 ## in autoregressions.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Design matrix for autoregressions
 
 function X = autoreg_matrix (y, k)
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{d}, @var{dd}]} = diffpara (@var{x}, @var{a}, @var{b})
+## @deftypefn {Function File} {[@var{d}, @var{dd}] =} diffpara (@var{x}, @var{a}, @var{b})
 ## Return the estimator @var{d} for the differencing parameter of an
 ## integrated time series.
 ##
 ## The frequencies from @math{[2*pi*a/t, 2*pi*b/T]} are used for the
 ## estimation.  If @var{b} is omitted, the interval
 ## @math{[2*pi/T, 2*pi*a/T]} is used.  If both @var{b} and @var{a} are
 ## omitted then @math{a = 0.5 * sqrt (T)} and @math{b = 1.5 * sqrt (T)}
 ## is used, where @math{T} is the sample size.  If @var{x} is a matrix,
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} durbinlevinson (@var{c}, @var{oldphi}, @var{oldv})
 ## Perform one step of the Durbin-Levinson algorithm.
 ##
-## The vector @var{c} specifies the autocovariances @code{[gamma_0, ...,
+## The vector @var{c} specifies the autocovariances @code{[gamma_0, @dots{},
 ## gamma_t]} from lag 0 to @var{t}, @var{oldphi} specifies the
 ## coefficients based on @var{c}(@var{t}-1) and @var{oldv} specifies the
 ## corresponding error.
 ##
 ## If @var{oldphi} and @var{oldv} are omitted, all steps from 1 to
 ## @var{t} of the algorithm are performed.
 ## @end deftypefn
 
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{y}, @var{c}]} = stft (@var{x}, @var{win_size}, @var{inc}, @var{num_coef}, @var{w_type})
+## @deftypefn {Function File} {[@var{y}, @var{c}] =} stft (@var{x}, @var{win_size}, @var{inc}, @var{num_coef}, @var{w_type})
 ## Compute the short-term Fourier transform of the vector @var{x} with
 ## @var{num_coef} coefficients by applying a window of @var{win_size} data
 ## points and an increment of @var{inc} points.
 ##
 ## Before computing the Fourier transform, one of the following windows
 ## is applied:
 ##
 ## @table @asis
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -89,17 +89,18 @@
 ## @item
 ## @var{iter} is the actual number of iterations performed.
 ##
 ## @item 
 ## @var{resvec} describes the convergence history of the method.
 ## @code{@var{resvec} (i,1)} is the Euclidean norm of the residual, and
 ## @code{@var{resvec} (i,2)} is the preconditioned residual norm,
 ## after the (@var{i}-1)-th iteration, @code{@var{i} =
-## 1,2,...@var{iter}+1}. The preconditioned residual norm is defined as
+## 1, 2, @dots{}, @var{iter}+1}. The preconditioned residual norm
+## is defined as
 ## @code{norm (@var{r}) ^ 2 = @var{r}' * (@var{m} \ @var{r})} where
 ## @code{@var{r} = @var{b} - @var{a} * @var{x}}, see also the
 ## description of @var{m}. If @var{eigest} is not required, only
 ## @code{@var{resvec} (:,1)} is returned.
 ## 
 ## @item
 ## @var{eigest} returns the estimate for the smallest @code{@var{eigest}
 ## (1)} and largest @code{@var{eigest} (2)} eigenvalues of the
@@ -116,69 +117,70 @@
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
 ## 	N = 10; 
-## 	A = diag([1:N]); A = sparse(A);  
-## 	b = rand(N,1);
+## 	A = spdiag ([1:N]);
+## 	b = rand (N, 1);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 1:} Simplest use of @code{pcg}
 ## 
 ## @example
 ##   x = pcg(A,b)
 ## @end example
 ## 
 ## @sc{Example 2:} @code{pcg} with a function which computes
 ## @code{@var{a} * @var{x}}
 ## 
 ## @example
 ## @group
-##   function y = applyA(x) 
+##   function y = applyA (x)
 ##     y = [1:N]'.*x; 
 ##   endfunction
 ##
-##   x = pcg('applyA',b)
+##   x = pcg ("applyA", b)
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 3:} Preconditioned iteration, with full diagnostics. The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{a} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
-##   function y = applyM(x)		
-##     K = floor(length(x)-2); 
-##     y = x; 
-##     y(1:K) = x(1:K)./[1:K]';	
+##   function y = applyM(x)
+##     K = floor (length (x) - 2);
+##     y = x;
+##     y(1:K) = x(1:K)./[1:K]';
 ##   endfunction
 ## 
-##   [x, flag, relres, iter, resvec, eigest] = pcg(A,b,[],[],'applyM')
-##   semilogy([1:iter+1], resvec);
+##   [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], "applyM");
+##   semilogy (1:iter+1, resvec);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 4:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ## 
 ## @example
 ## @group
-##   function y = applyM(x, varargin)
+##   function y = applyM (x, varargin)
 ##   K = varargin@{1@}; 
-##   y = x; y(1:K) = x(1:K)./[1:K]';	 
+##   y = x;
+##   y(1:K) = x(1:K)./[1:K]';
 ##   endfuntion
 ## 
 ##   [x, flag, relres, iter, resvec, eigest] = ...
-##        pcg(A,b,[],[],'applyM',[],3)
+##        pcg (A, b, [], [], "applyM", [], 3)
 ## @end group
 ## @end example
 ## 
 ## @sc{References}
 ## 
 ## 	[1] C.T.Kelley, 'Iterative methods for linear and nonlinear equations',
 ## 	SIAM, 1995 (the base PCG algorithm) 
 ## 	
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -11,20 +11,20 @@
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301  USA
 
 ## -*- texinfo -*-
-## @deftypefn {function File} {[@var{b}, @var{c}]} = spdiags (@var{a})
-## @deftypefnx {function File} {@var{b}} = spdiags (@var{a}, @var{c})
-## @deftypefnx {function File} {@var{b}} = spdiags (@var{v}, @var{c}, @var{a})
-## @deftypefnx {function File} {@var{b}} = spdiags (@var{v}, @var{c}, @var{m}, @var{n})
+## @deftypefn {function File} {[@var{b}, @var{c}] =} spdiags (@var{a})
+## @deftypefnx {function File} {@var{b} =} spdiags (@var{a}, @var{c})
+## @deftypefnx {function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{a})
+## @deftypefnx {function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{m}, @var{n})
 ## A generalization of the function @code{spdiag}. Called with a single
 ## input argument, the non-zero diagonals @var{c} of @var{A} are extracted.
 ## With two arguments the diagonals to extract are given by the vector 
 ## @var{c}.
 ##
 ## The other two forms of @code{spdiags} modify the input matrix by
 ## replacing the diagonals. They use the columns of @var{v} to replace
 ## the columns represented by the vector @var{c}. If the sparse matrix
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -1,15 +1,15 @@
 ## Copyright (C) 2004 Paul Kienzle
 ##
 ## This program is free software and is in the public domain
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{count}, @var{mean}, @var{var}]} = spstats (@var{s})
-## @deftypefnx {Function File} {[@var{count}, @var{mean}, @var{var}]} = spstats (@var{s}, @var{j})
+## @deftypefn {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{s})
+## @deftypefnx {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{s}, @var{j})
 ## Return the stats for the non-zero elements of the sparse matrix @var{s}.
 ## @var{count} is the number of non-zeros in each column, @var{mean}
 ## is the mean of the non-zeros in each column, and @var{var} is the  
 ## variance of the non-zeros in each column.
 ##
 ## Called with two input arguments, if @var{s} is the data and @var{j}
 ## is the bin number for the data, compute the stats for each bin.  In 
 ## this case, bins can contain data values of zero, whereas with 
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} run_count (@var{x}, @var{n})
 ## Count the upward runs along the first non-singleton dimension of
-## @var{x} of length 1, 2, ..., @var{n}-1 and greater than or equal 
+## @var{x} of length 1, 2, @dots{}, @var{n}-1 and greater than or equal 
 ## to @var{n}. If the optional argument @var{dim} is given operate
 ## along this dimension
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Count upward runs
 
 function retval = run_count (x, n, dim)
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,13 @@
+2007-04-19  John W. Eaton  <jwe@octave.org>
+
+	* lex.l (is_keyword_token): Delete all_va_args_kw switch case.
+	* octave.gperf: Remove all_va_args_kw from the list.
+
 2007-04-19  Daniel J. Sebald  <daniel.sebald@ieee.org>
 
 	* syscalls.cc: Fix popen2 test to stop trying after 100 times
 	throught the loop.
 
 2007-04-16  Geordie McBain  <geordie.mcbain@aeromech.usyd.edu.au>
 
 	* ov-fcn-inline.cc (Fargnames): Doc fix.
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -44,17 +44,17 @@ Flasterr (const octave_value_list& args_
 
 DEFUN_DLD (cellfun, args, nargout,
   " -*- texinfo -*-\n\
 @deftypefn {Lodable Function} {} cellfun (@var{name}, @var{c})\n\
 @deftypefnx {Lodable Function} {} cellfun (\"size\", @var{c}, @var{k})\n\
 @deftypefnx {Lodable Function} {} cellfun (\"isclass\", @var{c}, @var{class})\n\
 @deftypefnx {Lodable Function} {} cellfun (@var{func}, @var{c})\n\
 @deftypefnx {Lodable Function} {} cellfun (@var{func}, @var{c}, @var{d})\n\
-@deftypefnx {Lodable Function} {[@var{a}, @var{b}]} = cellfun (@dots{})\n\
+@deftypefnx {Lodable Function} {[@var{a}, @var{b}] =} cellfun (@dots{})\n\
 @deftypefnx {Lodable Function} {} cellfun (@dots{}, 'ErrorHandler',@var{errfunc})\n\
 @deftypefnx {Lodable Function} {} cellfun (@dots{}, 'UniformOutput',@var{val})\n\
 \n\
 Evaluate the function named @var{name} on the elements of the cell array\n\
 @var{c}.  Elements in @var{c} are passed on to the named function\n\
 individually.  The function @var{name} can be one of the functions\n\
 \n\
 @table @code\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -36,18 +36,18 @@ 02110-1301, USA.
 static inline bool
 is_integer_value (double x)
 {
   return x == std::floor (x);
 }
 
 DEFUN_DLD (gcd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{g} =} gcd (@var{a1}, @code{...})\n\
-@deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @var{...}] =} gcd (@var{a1}, @code{...})\n\
+@deftypefn {Loadable Function} {@var{g} =} gcd (@var{a1}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @dots{})\n\
 \n\
 If a single argument is given then compute the greatest common divisor of\n\
 the elements of this argument. Otherwise if more than one argument is\n\
 given all arguments must be the same size or scalar. In this case the\n\
 greatest common divisor is calculated for element individually. All\n\
 elements must be integers. For example,\n\
 \n\
 @example\n\
@@ -67,28 +67,28 @@ gcd ([15, 9], [20 18])\n\
 @end group\n\
 @end example\n\
 \n\
 Optional return arguments @var{v1}, etc, contain integer vectors such\n\
 that,\n\
 \n\
 @ifinfo\n\
 @example\n\
-@var{g} = @var{v1} .* @var{a1} + @var{v2} .* @var{a2} + @var{...}\n\
+@var{g} = @var{v1} .* @var{a1} + @var{v2} .* @var{a2} + @dots{}\n\
 @end example\n\
 @end ifinfo\n\
 @iftex\n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
 @end tex\n\
 @end iftex\n\
 \n\
 For backward compatiability with previous versions of this function, when\n\
 all arguments are scalr, a single return argument @var{v1} containing\n\
-all of the values of @var{v1}, @var{...} is acceptable.\n\
+all of the values of @var{v1}, @dots{} is acceptable.\n\
 @seealso{lcm, min, max, ceil, floor}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -341,19 +341,19 @@ By default, the generator is initialized
 available, otherwise from cpu time, wall clock time and the current\n\
 fraction of a second.\n\
 \n\
 @code{rand} uses the Mersenne Twister with a period of 2^19937-1\n\
 (See M. Matsumoto and T. Nishimura, ``Mersenne Twister: A 623-dimensionally\n\
 equidistributed uniform pseudorandom number generator'', ACM Trans. on\n\
 Modeling and Computer Simulation Vol. 8, No. 1, Januray pp.3-30 1998,\n\
 @url{http://www.math.keio.ac.jp/~matumoto/emt.html}).\n\
-Do NOT use for CRYPTOGRAPHY without securely hashing several returned\n\
-values together, otherwise the generator state can be learned after\n\
-reading 624 consecutive values.\n\
+Do @strong{not} use for cryptography without securely hashing\n\
+several returned values together, otherwise the generator state\n\
+can be learned after reading 624 consecutive values.\n\
 \n\
 @code{rand} includes a second random number generator, that was the\n\
 previous generator used in Octave. The new generator is used by default\n\
 as it is significantly faster than the old generator, and produces\n\
 random numbers with a significantly longer cycle time. However, in\n\
 some circumstances it might be desirable to obtain the same random\n\
 sequences as used by the old generators. To do this the keyword\n\
 \"seed\" is used to specify that the old generators should be use,\n\
@@ -474,17 +474,17 @@ Return a matrix with normally distribute
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses a Marsaglia and Tsang Ziggurat technique to\n\
 transform from a uniform to a normal distribution. (G. Marsaglia and\n\
 W.W. Tsang, 'Ziggurat method for generating random variables',\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
-@seealso{rand,rande,randg,randp}\n\
+@seealso{rand, rande, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   unwind_protect::begin_frame ("randn");
 
@@ -547,17 +547,17 @@ DEFUN_DLD (rande, args, ,
 Return a matrix with exponentially distributed random elements. The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses a Marsaglia and Tsang Ziggurat technique to\n\
 transform from a uniform to a exponential distribution. (G. Marsaglia and\n\
 W.W. Tsang, 'Ziggurat method for generating random variables',\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
-@seealso{rand,randn,randg,randp}\n\
+@seealso{rand, randn, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   unwind_protect::begin_frame ("rande");
 
@@ -621,61 +621,61 @@ DEFUN_DLD (randg, args, ,
 @deftypefnx {Loadable Function} {} randg (\"seed\", @var{x})\n\
 Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
-@item @code{gamma (a,b)} for @code{a > -1}, @code{b > 0}\n\
+@item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
 @example\n\
-r = b*randg(a)\n\
+r = b * randg (a)\n\
 @end example\n\
-@item @code{beta(a,b)} for @code{a > -1}, @code{b > -1}\n\
+@item @code{beta (a, b)} for @code{a > -1}, @code{b > -1}\n\
 @example\n\
-r1 = randg(a,1)\n\
-r = r1 / (r1 + randg(b,1))\n\
+r1 = randg (a, 1)\n\
+r = r1 / (r1 + randg (b, 1))\n\
 @end example\n\
-@item @code{Erlang(a, n)}\n\
+@item @code{Erlang (a, n)}\n\
 @example\n\
-r = a*randg(n)\n\
+r = a * randg (n)\n\
 @end example\n\
-@item @code{chisq(df)} for @code{df > 0}\n\
+@item @code{chisq (df)} for @code{df > 0}\n\
 @example\n\
-r = 2*randg(df/2)\n\
+r = 2 * randg (df / 2)\n\
 @end example\n\
 @item @code{t(df)} for @code{0 < df < inf} (use randn if df is infinite)\n\
 @example\n\
-r = randn() / sqrt(2*randg(df/2)/df)\n\
+r = randn () / sqrt (2 * randg (df / 2) / df)\n\
 @end example\n\
-@item @code{F(n1,n2)} for @code{0 < n1}, @code{0 < n2}\n\
+@item @code{F (n1, n2)} for @code{0 < n1}, @code{0 < n2}\n\
 @example\n\
-r1 = 2*randg(n1/2)/n1 or 1 if n1 is infinite\n\
-r2 = 2*randg(n2/2)/n2 or 1 if n2 is infinite\n\
+r1 = 2 * randg (n1 / 2) / n1 or 1 if n1 is infinite\n\
+r2 = 2 * randg (n2 / 2) / n2 or 1 if n2 is infinite\n\
 r = r1 / r2\n\n\
 @end example\n\
 @item negative @code{binomial (n, p)} for @code{n > 0}, @code{0 < p <= 1}\n\
 @example\n\
-r = randp((1-p)/p * randg(n))\n\
+r = randp ((1 - p) / p * randg (n))\n\
 @end example\n\
-@item non-central @code{chisq(df,L)}, for @code{df >= 0} and @code{L > 0}\n\
+@item non-central @code{chisq (df, L)}, for @code{df >= 0} and @code{L > 0}\n\
 (use chisq if @code{L = 0})\n\
 @example\n\
-r = randp(L/2)\n\
-r(r > 0) = 2*randg(r(r > 0))\n\
-r(df > 0) += 2*randg(df(df > 0)/2)\n\
+r = randp (L / 2)\n\
+r(r > 0) = 2 * randg (r(r > 0))\n\
+r(df > 0) += 2 * randg (df(df > 0)/2)\n\
 @end example\n\
-@item @code{Dirichlet(a1,...,ak)}\n\
+@item @code{Dirichlet (a1, ..., ak)}\n\
 @example\n\
-r = (randg(a1),...,randg(ak))\n\
-r = r / sum(r)\n\
+r = (randg (a1), ..., randg (ak))\n\
+r = r / sum (r)\n\
 @end example\n\
 @end table\n\
-@seealso{rand,randn,rande,randp}\n\
+@seealso{rand, randn, rande, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     error ("randg: insufficient arguments");
@@ -879,17 +879,17 @@ Stadlober E., et al., WinRand source cod
 Stadlober E., et al., WinRand source code, available via FTP, or\n\
 H. Zechner, 'Efficient sampling from continuous and discrete\n\
 unimodal distributions', Doctoral Dissertaion, 156pp., Technical\n\
 University Graz, Austria, 1994.\n\
 @item For @var{l} > 1e8, use normal approximation.\n\
 L. Montanet, et al., 'Review of Particle Properties', Physical Review\n\
 D 50 p1284, 1994\n\
 @end table\n\
-@seealso{rand,randn,rande,randg}\n\
+@seealso{rand, randn, rande, randg}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     error ("randp: insufficient arguments");
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -1385,17 +1385,17 @@ octregexprep (const octave_value_list &a
     }
   
   retval = rep;
   return retval;
 }
 
 DEFUN_DLD(regexprep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Function File}  @var{string} = regexprep(@var{string}, @var{pat}, @var{repstr}, @var{options})\n\
+@deftypefn {Function File}  {@var{string} =} regexprep(@var{string}, @var{pat}, @var{repstr}, @var{options})\n\
 Replace matches of @var{pat} in  @var{string} with @var{repstr}.\n\
 \n\
 \n\
 The replacement can contain @code{$i}, which subsubstitutes\n\
 for the ith set of parentheses in the match string.  E.g.,\n\
 @example\n\
 \n\
    regexprep(\"Bill Dunn\",'(\\w+) (\\w+)','$2, $1')\n\
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -56,17 +56,17 @@ Return 1 if the value of the expression 
        return octave_value ();
      }
    else 
      return octave_value (is_sparse (args(0)));
 }
 
 DEFUN_DLD (sparse, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{sparse_val} =} sparse (...)\n\
+@deftypefn {Loadable Function} {@var{sparse_val} =} sparse (@dots{})\n\
 SPARSE: create a sparse matrix\n\
 \n\
 sparse can be called in the following ways:\n\
 \n\
 @enumerate\n\
 @item @var{S} = sparse(@var{A})  where @var{A} is a full matrix\n\
 \n\
 @item @var{S} = sparse(@var{A},1)  where @var{A} is a full matrix, result\n\
diff --git a/src/DLD-FUNCTIONS/spchol.cc b/src/DLD-FUNCTIONS/spchol.cc
--- a/src/DLD-FUNCTIONS/spchol.cc
+++ b/src/DLD-FUNCTIONS/spchol.cc
@@ -328,17 +328,17 @@ it is much faster than using @code{inv}.
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (symbfact, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}]} = symbfact (@var{s}, @var{typ}, @var{mode})\n\
+@deftypefn {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{s}, @var{typ}, @var{mode})\n\
 \n\
 Performs a symbolic factorization analysis on the sparse matrix @var{s}.\n\
 Where\n\
 \n\
 @table @asis\n\
 @item @var{s}\n\
 @var{s} is a complex or real sparse matrix.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -325,17 +325,17 @@ urlwrite ('http://www.google.com/search'
   return retval;
 }
 
 DEFUN_DLD (urlread, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} urlread(@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}, @var{message}] =} urlread(@var{url})\n\
-@deftypefnx {Loadable Function} {[...] =} urlread (@var{url}, @var{method}, @var{param})\n\
+@deftypefnx {Loadable Function} {[@dots{}] =} urlread (@var{url}, @var{method}, @var{param})\n\
 Download a remote file specified by its @var{URL} and return its content\n\
 in string @var{s}.  For example,\n\
 \n\
 @example\n\
 s = urlread ('ftp://ftp.octave.org/pub/octave/README');\n\
 @end example\n\
 \n\
 The variable @var{success} is 1 if the download was successful,\n\
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -998,17 +998,16 @@ is_keyword_token (const std::string& s)
   const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
   if (kw)
     {
       yylval.tok_val = 0;
 
       switch (kw->kw_id)
 	{
-	case all_va_args_kw:
 	case break_kw:
 	case case_kw:
 	case catch_kw:
 	case continue_kw:
 	case else_kw:
 	case elseif_kw:
 	case global_kw:
 	case otherwise_kw:
diff --git a/src/octave.gperf b/src/octave.gperf
--- a/src/octave.gperf
+++ b/src/octave.gperf
@@ -1,13 +1,12 @@
 %{
 
 enum octave_kw_id
 {
-  all_va_args_kw,
   break_kw,
   case_kw,
   catch_kw,
   continue_kw,
   do_kw,
   else_kw,
   elseif_kw,
   end_kw,
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -556,17 +556,17 @@ octave_value
 octave_fcn_inline::convert_to_str_internal (bool, bool, char type) const
 {
   return octave_value (fcn_text (), type);
 }
 
 DEFUN (inline, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} inline (@var{str})\n\
-@deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, ...)\n\
+@deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
 If called with a single argument, the arguments of the generated\n\
 function are extracted from the function itself. The generated\n\
 function arguments will then be in alphabetical order. It should\n\
 be noted that i, and j are ignored as arguments due to the\n\
 ambiguity between their use as a variable or their use as an inbuilt\n\
 constant. All arguments followed by a parentheses are considered\n\
