# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1268683043 14400
#      Mon Mar 15 15:57:23 2010 -0400
# Node ID 479cc8a0a8466bff77c6cc53aa19eb2c14387683
# Parent  b3ec24dc305ae97dfcdd6ed765bd6f05555e7dfc
use gnulib namespace

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2010-03-15  John W. Eaton  <jwe@octave.org>
+
+	* configure.ac (AH_BOTTOM): Define GNULIB_NAMESPACE.
+
 2010-03-09  Jaroslav Hajek  <highegg@gmail.com>
 
 	* NEWS: Update.
 
 2010-03-01  John W. Eaton  <jwe@octave.org>
 
 	* acinclude.m4 (OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS,
 	OCTAVE_CXX_COMPLEX_SETTERS): New macros.
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -1864,16 +1864,20 @@ AC_SUBST(WARN_CXXFLAGS)
 
 export CC
 export CXX
 export F77
 
 ### Some things to add to the bottom of config.h.
 
 AH_BOTTOM([
+#if !defined (GNULIB_NAMESPACE)
+#define GNULIB_NAMESPACE gnulib
+#endif
+
 #if defined (__GNUC__)
 #define GCC_ATTR_DEPRECATED __attribute__ ((__deprecated__))
 #define GCC_ATTR_NORETURN __attribute__ ((__noreturn__))
 #define GCC_ATTR_UNUSED __attribute__ ((__unused__))
 #else
 #define GCC_ATTR_DEPRECATED
 #define GCC_ATTR_NORETURN
 #define GCC_ATTR_UNUSED
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,84 @@
+2010-03-15  John W. Eaton  <jwe@octave.org>
+
+	* oct-glob.cc (octave_glob): Tag calls to glob and globfree with
+	gnulib::.
+
+	* kpse.cc (DEBUG_START, DEBUGF, FATAL_PERROR, FATAL, KPSE_DEBUG,
+	log_search, find_first_of): Tag calls to
+	fputs with gnulib::.
+	(DEBUGF1, DEBUGF2, DEBUGF3, DEBUGF4, log_search, find_first_of,
+	kpse_element_dirs): Tag calls to fprintf with gnulib::.
+	(hash_lookup, search, find_first_of, kpse_element_dirs):
+	Tag calls to putc with gnulib::.
+	(do_subdir): Tag call to opendir with gnulib::.
+	(xclosedir): Tag call to closedir with gnulib::.  Assume closedir
+	returns int value.
+
+	* cmd-hist.cc (gnu_history::do_append): Tag calls to open and
+	close with gnulib::.
+	(command_history::error): Tag call to strerror with gnulib::.
+
+	* cmd-edit.cc (gnu_readline::command_generator,
+	gnu_readline::command_quoter, gnu_readline::command_dequoter):
+	Tag call to malloc with gnulib::.
+	(default_command_editor::do_readline): Tag call to fputs with gnulib::.
+	(command_editor::error): Tag call to strerror with gnulib::.
+
+	* sparse-util.cc (SparseCholPrint): Tag call to vfprintf with gnulib::.
+
+	* oct-uname.cc (octave_uname::init): Tag call to strerror with gnulib::.
+
+	* oct-time.cc (octave_time::stamp): Tag call to gettimeofday
+	with gnulib::.
+	(octave_strptime::init): Tag call to strptime with gnulib::.
+
+	* oct-syscalls.cc (octave_syscalls::dup2,
+	octave_syscalls::execvp, octave_syscalls::fork,
+	octave_syscalls::vfork, octave_syscalls::getpgrp,
+	octave_syscalls::pipe, octave_syscalls::waitpid,
+	octave_syscalls::kill, octave_fcntl):
+	Tag call to strerror with gnulib::.
+	(octave_syscalls::dup2): Tag call to dup2 with gnulib::.
+	(octave_syscalls::popen2): Tag calls to close with gnulib::.
+	(octave_fcntl): Tag call to fcntl with gnulib::.
+
+	* oct-env.cc (octave_env::error): Tag call to strerror with gnulib::.
+
+	* lo-utils.cc (octave_putenv): Tag call to malloc with gnulib::.
+	(octave_fgets): Tag calls to malloc and realloc with gnulib::.
+
+	* lo-sysdep.cc (octave_getcwd): Tag call to getcwd with gnulib::.
+
+	* lo-mappers.cc (xround): Tag call to round with gnulib::.
+
+	* file-stat.cc (file_stat::update_internal): Tag calls to lstat
+	and strerror with gnulib::.
+	(file_fstat::update_internal): Tag calls to fstat and strerror
+	with gnulib::.
+
+	* file-ops.cc (octave_mkdir): Tag call to mkdir with gnulib::.
+	(octave_mkfifo): Tag call to mkfifo with gnulib::.
+	(octave_link): Tag call to link with gnulib::.
+	(octave_symlink): Tag call to symlink with gnulib::.
+	(octave_readlink): Tag call to readlink with gnulib::.
+	(octave_rename): Tag call to rename with gnulib::.
+	(octave_rmdir): Tag call to rmdir with gnulib::.
+	(octave_unlink): Tag call to unlink with gnulib::.
+	(octave_canonicalize_file_name): Tag call to
+	canonicalize_file_name with gnulib::.
+	(octave_mkdir, octave_mkfifo, octave_link, octave_symlink,
+	octave_readlink, octave_rename, octave_rmdir, octave_unlink,
+	octave_tempnam, octave_canonicalize_file_name): Tag calls to
+	strerror with gnulib::.
+
+	* dir-ops.cc (dir_entry::close): Tag closedir call with gnulib::.
+	(dir_entry::open): Tag opendir and strerror calls with gnulib::.
+
 2010-03-09  Jaroslav Hajek  <highegg@gmail.com>
 
 	* oct-inttypes.h (octave_int_base::ftrunc, octave_int_base::fnon_int,
 	octave_int_base::fnan, octave_int_base::get_trunc_flag,
 	octave_int_base::get_nan_flag,
 	octave_int_base::get_non_int_flag,
 	octave_int_base::get_math_trunc_flag,
 	octave_int_base::clear_conv_flags): Remove.
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -632,17 +632,17 @@ gnu_readline::command_generator (const c
   completion_fcn f = command_editor::get_completion_function ();
 
   std::string tmp = f (text, state);
 
   size_t len = tmp.length ();
 
   if (len > 0)
     {
-      retval = static_cast<char *> (malloc (len+1));
+      retval = static_cast<char *> (gnulib::malloc (len+1));
 
       strcpy (retval, tmp.c_str ());
     }
 
   return retval;
 }
 
 char *
@@ -653,17 +653,17 @@ gnu_readline::command_quoter (char *text
   quoting_fcn f = command_editor::get_quoting_function ();
 
   std::string tmp = f (text, matches, *qcp);
 
   size_t len = tmp.length ();
 
   if (len > 0)
     {
-      retval = static_cast<char *> (malloc (len+1));
+      retval = static_cast<char *> (gnulib::malloc (len+1));
 
       strcpy (retval, tmp.c_str ());
     }
 
   return retval;
 }
 
 char *
@@ -674,17 +674,17 @@ gnu_readline::command_dequoter (char *te
   dequoting_fcn f = command_editor::get_dequoting_function ();
 
   std::string tmp = f (text, quote);
 
   size_t len = tmp.length ();
 
   if (len > 0)
     {
-      retval = static_cast<char *> (malloc (len+1));
+      retval = static_cast<char *> (gnulib::malloc (len+1));
 
       strcpy (retval, tmp.c_str ());
     }
 
   return retval;
 }
 
 int
@@ -754,17 +754,17 @@ private:
   FILE *input_stream;
 
   FILE *output_stream;
 };
 
 std::string
 default_command_editor::do_readline (const std::string& prompt, bool& eof)
 {
-  fputs (prompt.c_str (), output_stream);
+  gnulib::fputs (prompt.c_str (), output_stream);
   fflush (output_stream);
 
   return octave_fgetl (input_stream, eof);
 }
 
 void
 default_command_editor::do_set_input_stream (FILE *f)
 {
@@ -1535,16 +1535,16 @@ command_editor::read_octal (const std::s
     result = -1;
 
   return result;
 }
 
 void
 command_editor::error (int err_num)
 {
-  current_liboctave_error_handler ("%s", strerror (err_num));
+  current_liboctave_error_handler ("%s", gnulib::strerror (err_num));
 }
 
 void
 command_editor::error (const std::string& s)
 {
   current_liboctave_error_handler ("%s", s.c_str ());
 }
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -286,18 +286,18 @@ gnu_history::do_append (const std::strin
           if (! f.empty ())
             {
               file_stat fs (f);
 
               if (! fs)
                 {
                   int tem;
 
-                  tem = open (f.c_str (), O_CREAT, 0666);
-                  close (tem);
+                  tem = gnulib::open (f.c_str (), O_CREAT, 0666);
+                  gnulib::close (tem);
                 }
 
               int status
                 = ::octave_append_history (lines_this_session, f.c_str ());
 
               if (status != 0)
                 error (status);
               else
@@ -802,16 +802,16 @@ command_history::do_clean_up_and_save (c
 
   if (f.empty ())
     error ("command_history::clean_up_and_save: missing file name");
 }
 
 void
 command_history::error (int err_num)
 {
-  (*current_liboctave_error_handler) ("%s", strerror (err_num));
+  (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
 }
 
 void
 command_history::error (const std::string& s)
 {
   (*current_liboctave_error_handler) ("%s", s.c_str ());
 }
diff --git a/liboctave/dir-ops.cc b/liboctave/dir-ops.cc
--- a/liboctave/dir-ops.cc
+++ b/liboctave/dir-ops.cc
@@ -48,25 +48,22 @@ dir_entry::open (const std::string& n)
     name = n;
 
   if (! name.empty ())
     {
       close ();
       
       std::string fullname = file_ops::tilde_expand (name);
 
-      dir = static_cast<void *> (opendir (fullname.c_str ()));
+      dir = static_cast<void *> (gnulib::opendir (fullname.c_str ()));
 
       if (dir)
         fail = false;
       else
-        {
-          using namespace std;
-          errmsg = strerror (errno);
-        }
+        errmsg = gnulib::strerror (errno);
     }
   else
     errmsg = "dir_entry::open: empty file name";
 
   return ! fail;
 }
 
 string_vector
@@ -93,17 +90,17 @@ dir_entry::read (void)
 
   return retval;
 }
 
 void
 dir_entry::close (void)
 {
   if (dir)
-    closedir (static_cast<DIR *> (dir));
+    gnulib::closedir (static_cast<DIR *> (dir));
 
   dir = 0;
 }
 
 void
 dir_entry::copy (const dir_entry& de)
 {
   name = de.name;
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -368,23 +368,20 @@ octave_mkdir (const std::string& nm, mod
 
 int
 octave_mkdir (const std::string& name, mode_t mode, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  status = mkdir (name.c_str (), mode);
+  status = gnulib::mkdir (name.c_str (), mode);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
 
 int
 octave_mkfifo (const std::string& nm, mode_t md)
 {
   std::string msg;
@@ -397,23 +394,20 @@ octave_mkfifo (const std::string& name, 
   msg = std::string ();
 
   int status = -1;
 
   // With gnulib we will always have mkfifo, but some systems like MinGW
   // don't have working mkfifo functions.  On those systems, mkfifo will
   // always return -1 and set errno.
 
-  status = mkfifo (name.c_str (), mode);
+  status = gnulib::mkfifo (name.c_str (), mode);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
 
 int
 octave_link (const std::string& old_name, const std::string& new_name)
 {
   std::string msg;
@@ -423,23 +417,20 @@ octave_link (const std::string& old_name
 int
 octave_link (const std::string& old_name,
                 const std::string& new_name, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  status = link (old_name.c_str (), new_name.c_str ());
+  status = gnulib::link (old_name.c_str (), new_name.c_str ());
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
 
 int
 octave_symlink (const std::string& old_name, const std::string& new_name)
 {
   std::string msg;
@@ -449,23 +440,20 @@ octave_symlink (const std::string& old_n
 int
 octave_symlink (const std::string& old_name,
                    const std::string& new_name, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  status = symlink (old_name.c_str (), new_name.c_str ());
+  status = gnulib::symlink (old_name.c_str (), new_name.c_str ());
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
 
 int
 octave_readlink (const std::string& path, std::string& result)
 {
   std::string msg;
@@ -477,23 +465,20 @@ octave_readlink (const std::string& path
                     std::string& msg)
 {
   int status = -1;
 
   msg = std::string ();
 
   char buf[MAXPATHLEN+1];
 
-  status = readlink (path.c_str (), buf, MAXPATHLEN);
+  status = gnulib::readlink (path.c_str (), buf, MAXPATHLEN);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
   else
     {
       buf[status] = '\0';
       result = std::string (buf);
       status = 0;
     }
 
   return status;
@@ -509,23 +494,20 @@ octave_rename (const std::string& from, 
 int
 octave_rename (const std::string& from, const std::string& to,
                   std::string& msg)
 {
   int status = -1;
 
   msg = std::string ();
 
-  status = rename (from.c_str (), to.c_str ());
+  status = gnulib::rename (from.c_str (), to.c_str ());
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
 
 int
 octave_rmdir (const std::string& name)
 {
   std::string msg;
@@ -534,23 +516,20 @@ octave_rmdir (const std::string& name)
 
 int
 octave_rmdir (const std::string& name, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  status = rmdir (name.c_str ());
+  status = gnulib::rmdir (name.c_str ());
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
 
 // And a version that works recursively.
 
 int
 octave_recursive_rmdir (const std::string& name)
@@ -646,23 +625,20 @@ octave_unlink (const std::string& name)
 
 int
 octave_unlink (const std::string& name, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  status = unlink (name.c_str ());
+  status = gnulib::unlink (name.c_str ());
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
 
 std::string
 octave_tempnam (const std::string& dir, const std::string& pfx)
 {
   std::string msg;
@@ -685,20 +661,17 @@ octave_tempnam (const std::string& dir, 
 
   if (tmp)
     {
       retval = tmp;
 
       free (tmp);
     }
   else
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return retval;
 }
 
 std::string
 octave_canonicalize_file_name (const std::string& name)
 {
   std::string msg;
@@ -709,17 +682,17 @@ std::string
 octave_canonicalize_file_name (const std::string& name, std::string& msg)
 {
   msg = std::string ();
 
   std::string retval;
 
 #if defined (HAVE_CANONICALIZE_FILE_NAME)
 
-  char *tmp = ::canonicalize_file_name (name.c_str ());
+  char *tmp = gnulib::canonicalize_file_name (name.c_str ());
 
   if (tmp)
     {
       retval = tmp;
       free (tmp);
     }
 
 #elif defined (HAVE_RESOLVEPATH)
@@ -810,16 +783,13 @@ extern int errno;
 #else
 
   // FIXME -- provide replacement here...
   retval = name;
 
 #endif
 
   if (retval.empty ())
-    {
-      using namespace std;
-      msg = strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return retval;
 }
 
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -195,24 +195,23 @@ file_stat::update_internal (bool force)
           && ! (full_file_name.length() == 3 && full_file_name[1] == ':'))
         full_file_name.resize (full_file_name.length () - 1);
 #endif
 
       const char *cname = full_file_name.c_str ();
 
       struct stat buf;
 
-      int status = follow_links ? stat (cname, &buf) : lstat (cname, &buf);
+      int status = follow_links
+        ? stat (cname, &buf) : gnulib::lstat (cname, &buf);
 
       if (status < 0)
         {
-          using namespace std;
-
           fail = true;
-          errmsg = strerror (errno);
+          errmsg = gnulib::strerror (errno);
         }
       else
         {
           fs_mode = buf.st_mode;
           fs_ino = buf.st_ino;
           fs_dev = buf.st_dev;
           fs_nlink = buf.st_nlink;
           fs_uid = buf.st_uid;
@@ -244,24 +243,22 @@ file_fstat::update_internal (bool force)
 {
   if (! initialized || force)
     {
       initialized = false;
       fail = false;
 
       struct stat buf;
 
-      int status = fstat (fid, &buf);
+      int status = gnulib::fstat (fid, &buf);
 
       if (status < 0)
         {
-          using namespace std;
-
           fail = true;
-          errmsg = strerror (errno);
+          errmsg = gnulib::strerror (errno);
         }
       else
         {
           fs_mode = buf.st_mode;
           fs_ino = buf.st_ino;
           fs_dev = buf.st_dev;
           fs_nlink = buf.st_nlink;
           fs_uid = buf.st_uid;
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -178,29 +178,29 @@ extern "C" {
 #define KPSE_DEBUG_FOPEN 2              /* fopen/fclose calls */
 #define KPSE_DEBUG_PATHS 3              /* search path initializations */
 #define KPSE_DEBUG_EXPAND 4             /* path element expansion */
 #define KPSE_DEBUG_SEARCH 5             /* searches */
 #define KPSE_DEBUG_VARS 6               /* variable values */
 #define KPSE_LAST_DEBUG KPSE_DEBUG_VARS
 
 /* A printf for the debugging.  */
-#define DEBUGF_START() do { fputs ("kdebug:", stderr)
+#define DEBUGF_START() do { gnulib::fputs ("kdebug:", stderr)
 #define DEBUGF_END()        fflush (stderr); } while (0)
 
 #define DEBUGF(str)                                                     \
-  DEBUGF_START (); fputs (str, stderr); DEBUGF_END ()
+  DEBUGF_START (); gnulib::fputs (str, stderr); DEBUGF_END ()
 #define DEBUGF1(str, e1)                                                \
-  DEBUGF_START (); fprintf (stderr, str, e1); DEBUGF_END ()
+  DEBUGF_START (); gnulib::fprintf (stderr, str, e1); DEBUGF_END ()
 #define DEBUGF2(str, e1, e2)                                            \
-  DEBUGF_START (); fprintf (stderr, str, e1, e2); DEBUGF_END ()
+  DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2); DEBUGF_END ()
 #define DEBUGF3(str, e1, e2, e3)                                        \
-  DEBUGF_START (); fprintf (stderr, str, e1, e2, e3); DEBUGF_END ()
+  DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2, e3); DEBUGF_END ()
 #define DEBUGF4(str, e1, e2, e3, e4)                                    \
-  DEBUGF_START (); fprintf (stderr, str, e1, e2, e3, e4); DEBUGF_END ()
+  DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2, e3, e4); DEBUGF_END ()
 
 #undef fopen
 #define fopen kpse_fopen_trace
 static FILE *fopen (const char *filename, const char *mode);
 
 #endif /* not NO_DEBUG */
 
 #ifdef KPSE_DEBUG
@@ -253,27 +253,27 @@ static unsigned int kpathsea_debug = 0;
 /* Define common sorts of messages.  */
 
 /* This should be called only after a system call fails.  Don't exit
    with status `errno', because that might be 256, which would mean
    success (exit statuses are truncated to eight bits).  */
 #define FATAL_PERROR(str) \
   do \
     { \
-      fputs ("pathsearch: ", stderr); \
+      gnulib::fputs ("pathsearch: ", stderr); \
       perror (str); exit (EXIT_FAILURE); \
     } \
   while (0)
 
 #define FATAL(str) \
   do \
     { \
-      fputs ("pathsearch: fatal: ", stderr); \
-      fputs (str, stderr); \
-      fputs (".\n", stderr); \
+      gnulib::fputs ("pathsearch: fatal: ", stderr); \
+      gnulib::fputs (str, stderr); \
+      gnulib::fputs (".\n", stderr); \
       exit (1); \
     } \
   while (0)
 
 #ifndef WIN32
 static void xclosedir (DIR *d);
 #endif
 
@@ -384,26 +384,26 @@ hash_lookup (hash_table_type table, cons
     if (key == p->key)
       ret.append (p->value);
 
 #ifdef KPSE_DEBUG
   if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
     {
       DEBUGF1 ("hash_lookup (%s) =>", key.c_str ());
       if (ret.empty ())
-        fputs (" (nil)\n", stderr);
+        gnulib::fputs (" (nil)\n", stderr);
       else
         {
           int len = ret.length ();
           for (int i = 0; i < len; i++)
             {
-              putc (' ', stderr);
-              fputs (ret[i].c_str (), stderr);
+              gnulib::putc (' ', stderr);
+              gnulib::fputs (ret[i].c_str (), stderr);
             }
-          putc ('\n', stderr);
+          gnulib::putc ('\n', stderr);
         }
       fflush (stderr);
     }
 #endif
 
   return ret;
 }
 
@@ -670,25 +670,25 @@ log_search (const string_vector& filenam
     {
       /* FILENAMES should never be null, but safety doesn't hurt.  */
       for (int e = 0; e < filenames.length () && ! filenames[e].empty (); e++)
         {
           std::string filename = filenames[e];
 
           /* Only record absolute filenames, for privacy.  */
           if (log_file && kpse_absolute_p (filename.c_str (), false))
-            fprintf (log_file, "%lu %s\n",
+            gnulib::fprintf (log_file, "%lu %s\n",
                      static_cast<unsigned long> (time (0)),
                      filename.c_str ());
 
           /* And show them online, if debugging.  We've already started
              the debugging line in `search', where this is called, so
              just print the filename here, don't use DEBUGF.  */
           if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-            fputs (filename.c_str (), stderr);
+            gnulib::fputs (filename.c_str (), stderr);
         }
     }
 }
 
 /* Concatenate each element in DIRS with NAME (assume each ends with a
    /, to save time).  If SEARCH_ALL is false, return the first readable
    regular file.  Else continue to search for more.  In any case, if
    none, return a list containing just NULL.
@@ -868,17 +868,17 @@ search (const std::string& path, const s
          debugging line if we're doing that.  */
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
         DEBUGF1 ("search (%s) =>", original_name.c_str ());
 
       log_search (ret_list);
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-        putc ('\n', stderr);
+        gnulib::putc ('\n', stderr);
     }
 
   return ret_list;
 }
 
 /* Search PATH for the first NAME.  */
 
 /* Call `kpse_expand' on NAME.  If the result is an absolute or
@@ -1035,30 +1035,30 @@ path_find_first_of (const std::string& p
 static string_vector
 find_first_of (const std::string& path, const string_vector& names,
                bool must_exist, bool all)
 {
   string_vector ret_list;
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
     {
-      fputs ("start find_first_of ((", stderr);
+      gnulib::fputs ("start find_first_of ((", stderr);
 
       int len = names.length ();
 
       for (int i = 0; i < len; i++)
         {
           if (i == 0)
-            fputs (names[i].c_str (), stderr);
+            gnulib::fputs (names[i].c_str (), stderr);
           else
-            fprintf (stderr, ", %s", names[i].c_str ());
+            gnulib::fprintf (stderr, ", %s", names[i].c_str ());
         }
 
-      fprintf (stderr, "), path=%s, must_exist=%d).\n",
-               path.c_str (), must_exist);
+      gnulib::fprintf (stderr, "), path=%s, must_exist=%d).\n",
+                       path.c_str (), must_exist);
     }
 
   for (int i = 0; i < names.length (); i++)
     {
       std::string name = names[i];
 
       if (kpse_absolute_p (name, true))
         {
@@ -1084,34 +1084,35 @@ find_first_of (const std::string& path, 
     }
   else
     {
       /* Record the filenames we found, if desired.  And wrap them in a
          debugging line if we're doing that.  */
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
         {
-          fputs ("find_first_of (", stderr);
+          gnulib::fputs ("find_first_of (", stderr);
 
           int len = names.length ();
 
           for (int i = 0; i < len; i++)
             {
               if (i == 0)
-                fputs (names[i].c_str (), stderr);
+                gnulib::fputs (names[i].c_str (), stderr);
               else
-                fprintf (stderr, ", %s", names[i].c_str ());
+                gnulib::fprintf (stderr, ", %s", names[i].c_str ());
             }
-          fputs (") =>", stderr);
+
+          gnulib::fputs (") =>", stderr);
         }
 
       log_search (ret_list);
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-        putc ('\n', stderr);
+        gnulib::putc ('\n', stderr);
     }
 
   return ret_list;
 }
 
 /* Search each element of PATH for each element of NAMES.  Return the
    first one found.  */
 
@@ -2215,17 +2216,17 @@ do_subdir (str_llist_type *str_list_ptr,
       proceed = FindNextFile (hnd, &find_file_data);
     }
 
   FindClose (hnd);
 
 #else /* not WIN32 */
 
   /* If we can't open it, quit.  */
-  dir = opendir (name.c_str ());
+  dir = gnulib::opendir (name.c_str ());
 
   if (! dir)
     return;
 
   /* Include top level before subdirectories, if nothing to match.  */
   if (post.empty ())
     dir_list_add (str_list_ptr, name);
   else
@@ -2376,38 +2377,34 @@ kpse_element_dirs (const std::string& el
 #ifdef KPSE_DEBUG
   if (KPSE_DEBUG_P (KPSE_DEBUG_EXPAND))
     {
       DEBUGF1 ("path element %s =>", elt.c_str ());
       if (ret)
         {
           str_llist_elt_type *e;
           for (e = *ret; e; e = STR_LLIST_NEXT (*e))
-            fprintf (stderr, " %s", (STR_LLIST (*e)).c_str ());
+            gnulib::fprintf (stderr, " %s", (STR_LLIST (*e)).c_str ());
         }
-      putc ('\n', stderr);
+      gnulib::putc ('\n', stderr);
       fflush (stderr);
     }
 #endif /* KPSE_DEBUG */
 
   return ret;
 }
 
 #ifndef WIN32
 void
 xclosedir (DIR *d)
 {
-#ifdef CLOSEDIR_VOID
-  closedir (d);
-#else
-  int ret = closedir (d);
+  int ret = gnulib::closedir (d);
 
   if (ret != 0)
     FATAL ("closedir failed");
-#endif
 }
 #endif
 
 /* Help the user discover what's going on.  */
 
 #ifdef KPSE_DEBUG
 
 /* If the real definitions of fopen or fclose are macros, we lose -- the
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -68,17 +68,17 @@ real (double x)
 {
   return x;
 }
 
 double
 xround (double x)
 {
 #if defined (HAVE_ROUND)
-  return round (x);
+  return gnulib::round (x);
 #else
   if (x >= 0)
     {
       double y = floor (x);
 
       if ((x - y) >= 0.5)
         y += 1.0;
 
@@ -372,17 +372,17 @@ real (float x)
 {
   return x;
 }
 
 float
 xround (float x)
 {
 #if defined (HAVE_ROUND)
-  return round (x);
+  return gnulib::round (x);
 #else
   if (x >= 0)
     {
       float y = floor (x);
 
       if ((x - y) >= 0.5)
         y += 1.0;
 
diff --git a/liboctave/lo-sysdep.cc b/liboctave/lo-sysdep.cc
--- a/liboctave/lo-sysdep.cc
+++ b/liboctave/lo-sysdep.cc
@@ -49,17 +49,17 @@ std::string
 octave_getcwd (void)
 {
   std::string retval;
 
   // Using the gnulib getcwd module ensures that we have a getcwd that
   // will allocate a buffer as large as necessary if buf and size are
   // both 0.
 
-  char *tmp = getcwd (0, 0);
+  char *tmp = gnulib::getcwd (0, 0);
 
   if (tmp)
     {
       retval = tmp;
       free (tmp);
     }
   else
     (*current_liboctave_error_handler) ("unable to find current directory");
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -131,17 +131,17 @@ strsave (const char *s)
 // FIXME -- make this do the right thing if we don't have a
 // SMART_PUTENV.
 
 void
 octave_putenv (const std::string& name, const std::string& value)
 {
   int new_len = name.length () + value.length () + 2;
 
-  char *new_item = static_cast<char*> (malloc (new_len));
+  char *new_item = static_cast<char*> (gnulib::malloc (new_len));
 
   sprintf (new_item, "%s=%s", name.c_str (), value.c_str ());
 
   // As far as I can see there's no way to distinguish between the
   // various errors; putenv doesn't have errno values.
 
   if (putenv (new_item) < 0)
     (*current_liboctave_error_handler) ("putenv (%s) failed", new_item);
@@ -159,32 +159,32 @@ octave_fgets (FILE *f, bool& eof)
 {
   eof = false;
 
   std::string retval;
 
   int grow_size = 1024;
   int max_size = grow_size;
 
-  char *buf = static_cast<char *> (malloc (max_size));
+  char *buf = static_cast<char *> (gnulib::malloc (max_size));
   char *bufptr = buf;
   int len = 0;
 
   do
     {
       if (fgets (bufptr, grow_size, f))
         {
           len = strlen (bufptr);
 
           if (len == grow_size - 1)
             {
               int tmp = bufptr - buf + grow_size - 1;
               grow_size *= 2;
               max_size += grow_size;
-              buf = static_cast<char *> (realloc (buf, max_size));
+              buf = static_cast<char *> (gnulib::realloc (buf, max_size));
               bufptr = buf + tmp;
 
               if (*(bufptr-1) == '\n')
                 {
                   *bufptr = '\0';
                   retval = buf;
                 }
             }
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -532,16 +532,16 @@ octave_env::pathname_backup (std::string
     }
 
   path.resize (i);
 }
 
 void
 octave_env::error (int err_num) const
 {
-  (*current_liboctave_error_handler) ("%s", strerror (err_num));
+  (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
 }
 
 void
 octave_env::error (const std::string& s) const
 {
   (*current_liboctave_error_handler) ("%s", s.c_str ());
 }
diff --git a/liboctave/oct-glob.cc b/liboctave/oct-glob.cc
--- a/liboctave/oct-glob.cc
+++ b/liboctave/oct-glob.cc
@@ -81,17 +81,17 @@ octave_glob (const string_vector& pat)
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) \
           && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM) 
               std::replace_if (xpat.begin (), xpat.end (), 
                                std::bind2nd (std::equal_to<char> (), '\\'), 
                                '/'); 
 #endif 
 
-          int err = ::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
+          int err = gnulib::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
 
           if (! err)
             {
               int n = glob_info.gl_pathc;
 
               const char * const *matches = glob_info.gl_pathv;
 
               // FIXME -- we shouldn't have to check to see if
@@ -116,15 +116,15 @@ octave_glob (const string_vector& pat)
                                                          '/'), 
                                            '\\'); 
 #endif 
 
                       retval[k++] = tmp; 
                     } 
                 }
 
-              globfree (&glob_info);
+              gnulib::globfree (&glob_info);
             }
         }
     }
 
   return retval.sort ();
 }
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -58,23 +58,20 @@ octave_syscalls::dup2 (int old_fd, int n
 int
 octave_syscalls::dup2 (int old_fd, int new_fd, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_DUP2)
-  status = ::dup2 (old_fd, new_fd);
+  status = gnulib::dup2 (old_fd, new_fd);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("dup2");
 #endif
 
   return status;
 }
 
 int
@@ -95,40 +92,34 @@ octave_syscalls::execvp (const std::stri
 #if defined (HAVE_EXECVP)
   char **argv = args.c_str_vec ();
 
   status = ::execvp (file.c_str (), argv);
 
   string_vector::delete_c_str_vec (argv);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("execvp");
 #endif
 
   return status;
 }
 
 pid_t
 octave_syscalls::fork (std::string& msg)
 {
   pid_t status = -1;
 
 #if defined (HAVE_FORK)
   status = ::fork ();
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("fork");
 #endif
 
   return status;
 }
 
 pid_t
@@ -139,40 +130,34 @@ octave_syscalls::vfork (std::string& msg
 #if defined (HAVE_VFORK) || defined (HAVE_FORK)
 #if defined (HAVE_VFORK)
   status = ::vfork ();
 #else
   status = ::fork ();
 #endif
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("vfork");
 #endif
 
   return status;
 }
 
 pid_t
 octave_syscalls::getpgrp (std::string& msg)
 {
   pid_t status = -1;
 
 #if defined (HAVE_GETPGRP)
   status = ::getpgrp ();
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("getpgrp");
 #endif
 
   return status;
 }
 
 pid_t
@@ -248,20 +233,17 @@ octave_syscalls::pipe (int *fildes, std:
   msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_PIPE)
   status = ::pipe (fildes);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("pipe");
 #endif
 
   return status;
 }
 
 pid_t
@@ -277,20 +259,17 @@ octave_syscalls::waitpid (pid_t pid, int
 {
   pid_t retval = -1;
   msg = std::string ();
 
 #if defined (HAVE_WAITPID)
   retval = ::octave_waitpid (pid, status, options);
 
   if (retval < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("waitpid");
 #endif
 
   return retval;
 }
 
 int
@@ -306,20 +285,17 @@ octave_syscalls::kill (pid_t pid, int si
   msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_KILL)
   status = ::kill (pid, sig);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("kill");
 #endif
 
   return status;
 }
 
 pid_t
@@ -358,61 +334,63 @@ octave_syscalls::popen2 (const std::stri
             msg = "popen2: process creation failed -- " + msg;
           else if (pid == 0)
             {
               std::string child_msg;
 
               interactive = false;
 
               // Child process
-              ::close (child_stdin[1]);
-              ::close (child_stdout[0]);
+              gnulib::close (child_stdin[1]);
+              gnulib::close (child_stdout[0]);
 
               if (dup2 (child_stdin[0], STDIN_FILENO) >= 0)
                 {
-                  ::close (child_stdin[0]);
+                  gnulib::close (child_stdin[0]);
                   if (dup2 (child_stdout[1], STDOUT_FILENO) >= 0)
                     {
-                      ::close (child_stdout[1]);
+                      gnulib::close (child_stdout[1]);
                       if (execvp (cmd, args, child_msg) < 0)
                         child_msg = "popen2 (child): unable to start process -- " + child_msg;
                     }
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
               
               (*current_liboctave_error_handler)(child_msg.c_str());
               
               exit(0);
             }
           else
             {
               // Parent process
-              ::close (child_stdin[0]);
-              ::close (child_stdout[1]);
+              gnulib::close (child_stdin[0]);
+              gnulib::close (child_stdout[1]);
+
 #if defined (F_SETFL) && defined (O_NONBLOCK)
               if (! sync_mode && octave_fcntl (child_stdout[0], F_SETFL, O_NONBLOCK, msg) < 0)
                 msg = "popen2: error setting file mode -- " + msg;
               else
 #endif
                 {
                   fildes[0] = child_stdin [1];
                   fildes[1] = child_stdout [0];
                   return pid;
                 }
             }
-          ::close (child_stdout[0]);
-          ::close (child_stdout[1]);
+          gnulib::close (child_stdout[0]);
+          gnulib::close (child_stdout[1]);
         }
       else
         msg = "popen2: pipe creation failed -- " + msg;
-      ::close (child_stdin[0]);
-      ::close (child_stdin[1]);
+
+      gnulib::close (child_stdin[0]);
+      gnulib::close (child_stdin[1]);
     }
   else
     msg = "popen2: pipe creation failed -- " + msg;
 
   return -1;
 #endif
 }
 
@@ -425,18 +403,15 @@ octave_fcntl (int fd, int cmd, long arg)
 
 int
 octave_fcntl (int fd, int cmd, long arg, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
-  status = ::fcntl (fd, cmd, arg);
+  status = gnulib::fcntl (fd, cmd, arg);
 
   if (status < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
 
   return status;
 }
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -73,17 +73,17 @@ octave_time::ctime (void) const
   return octave_localtime (*this) . asctime ();
 }
 
 void
 octave_time::stamp (void)
 {
   struct timeval tp;
 
-  gettimeofday (&tp, 0);
+  gnulib::gettimeofday (&tp, 0);
 
   ot_unix_time = tp.tv_sec;
   ot_usec = tp.tv_usec;
 }
 
 // From the mktime() manual page:
 //
 //     The  mktime()  function converts a broken-down time structure,
@@ -260,17 +260,17 @@ octave_strptime::init (const std::string
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
   char *ps = strsave ("");
   t.tm_zone = ps;
 #endif
 
   char *p = strsave (str.c_str ());
 
-  char *q = strptime (p, fmt.c_str (), &t);
+  char *q = gnulib::strptime (p, fmt.c_str (), &t);
 
   // Fill in wday and yday, but only if mday is valid and the mon and year
   // are filled in, avoiding issues with mktime and invalid dates.
   if (t.tm_mday != 0 && t.tm_mon >= 0 && t.tm_year != INT_MIN)
     {
       t.tm_isdst = -1;
       mktime (&t);
     }
diff --git a/liboctave/oct-uname.cc b/liboctave/oct-uname.cc
--- a/liboctave/oct-uname.cc
+++ b/liboctave/oct-uname.cc
@@ -37,20 +37,17 @@ void
 octave_uname::init (void)
 {
 #if defined (HAVE_UNAME) && defined (HAVE_SYS_UTSNAME_H)
   struct utsname unm;
 
   err = ::uname (&unm);
 
   if (err < 0)
-    {
-      using namespace std;
-      msg = ::strerror (errno);
-    }
+    msg = gnulib::strerror (errno);
   else
     {
       utsname_sysname = unm.sysname;
       utsname_nodename = unm.nodename;
       utsname_release = unm.release;
       utsname_version = unm.version;
       utsname_machine = unm.machine;
     }
diff --git a/liboctave/sparse-util.cc b/liboctave/sparse-util.cc
--- a/liboctave/sparse-util.cc
+++ b/liboctave/sparse-util.cc
@@ -46,17 +46,17 @@ SparseCholError (int status, const char 
   (*current_liboctave_warning_handler)(message);
 }
 
 int
 SparseCholPrint (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
-  int ret = vfprintf (stderr, fmt, args);
+  int ret = gnulib::vfprintf (stderr, fmt, args);
   fflush (stderr);
   va_end (args);
   return ret;
 }
 
 
 bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,49 @@
+2010-03-15  John W. Eaton  <jwe@octave.org>
+
+	* oct-parse.yy, lex.ll: Undefine GNULIB_NAMESPACE immediately
+	after including <config.h>.
+
+	* toplev.cc (wait_for_input): Tag call to select with gnulib::.
+
+	* sighandlers.h (BLOCK_SIGNAL): Tag calls to sigemptyset,
+	sigaddset, and sigprocmask with gnulib::.
+	(UNBLOCK_CHILD): Tag call to sigprocmask with gnulib::.
+	* sighandlers.cc (octave_set_signal_handler): Tag calls to
+	sigemptyset with gnulib::.
+	(octave_set_signal_handler): Tag call to sigaction with gnulib::.
+
+	* oct-procbuf.cc (octave_procbuf::open): Tag calls to close, dup2,
+	and fclose with gnulib::.
+	(octave_procbuf::close): Tag call to fclose with gnulib::.
+
+	* oct-hist.cc (unlink_cleanup): Tag call to unlink with gnulib::.
+
+	* oct-fstrm.cc (octave_fstream::octave_fstream): Tag call to
+	strerror with gnulib::.
+
+	* mex.cc (mex::malloc_unmarked, mex::realloc, mxArray::malloc,
+	mxMalloc, mxRealloc): Tag call to malloc with gnulib::.
+
+	* input.cc (gnu_readline): Tag call to fputs with gnulib::.
+
+	* file-io.cc (cleanup_tmp_files): Tag call to unlink with gnulib::.
+	(do_stream_open, Ftmpfile, Fmkstemp): Tag call to strerror with
+	gnulib::.
+
+	* dirfns.cc (octave_change_to_directory): Tag call to strerror
+	with gnulib::.
+
+	* c-file-ptr-stream.cc (c_file_ptr_buf::overflow): Tag calls to
+	fputc with gnulib::.
+	(c_file_ptr_buf::xsputn): Tag call to fwrite with gnulib::.
+	(c_file_ptr_buf::file_close): Move here from
+	c-file-ptr-stream.h.  Tag call to fclose with gnulib::.
+
 2010-03-12  Ben Abbott <bpabbott@mac.com>
 
 	* /DLD-FUNCTIONS/chol.cc: Increase tolerance for single precision test.
 
 2010-03-09  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/lookup.cc (Flookup): Fix deprecated array constructor.
 
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -48,22 +48,22 @@ c_file_ptr_buf::~c_file_ptr_buf (void)
 
 // FIXME -- I'm sure there is room for improvement here...
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::overflow (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
   if (f)
-    return (c != traits_type::eof ()) ? fputc (c, f) : flush ();
+    return (c != traits_type::eof ()) ? gnulib::fputc (c, f) : flush ();
   else
     return traits_type::not_eof (c);
 #else
   if (f)
-    return (c != EOF) ? fputc (c, f) : flush ();
+    return (c != EOF) ? gnulib::fputc (c, f) : flush ();
   else
     return EOF;
 #endif
 }
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::underflow_common (bool bump)
 {
@@ -99,17 +99,17 @@ c_file_ptr_buf::pbackfail (int_type c)
   return (c != EOF && f) ? ungetc (c, f) : EOF;
 #endif
 }
 
 std::streamsize
 c_file_ptr_buf::xsputn (const char* s, std::streamsize n)
 {
   if (f)
-    return fwrite (s, 1, n, f);
+    return gnulib::fwrite (s, 1, n, f);
   else
     return 0;
 }
 
 std::streamsize
 c_file_ptr_buf::xsgetn (char *s, std::streamsize n)
 {
   if (f)
@@ -188,16 +188,22 @@ c_file_ptr_buf::buf_close (void)
     {
       retval = cf (f);
       f = 0;
     }
 
   return retval;
 }
 
+int
+c_file_ptr_buf::file_close (FILE *f)
+{
+  return gnulib::fclose (f);
+}
+
 #ifdef HAVE_ZLIB
 
 c_zfile_ptr_buf::~c_zfile_ptr_buf (void)
 {
   buf_close ();
 }
 
 // FIXME -- I'm sure there is room for improvement here...
diff --git a/src/c-file-ptr-stream.h b/src/c-file-ptr-stream.h
--- a/src/c-file-ptr-stream.h
+++ b/src/c-file-ptr-stream.h
@@ -77,17 +77,17 @@ public:
 
   int seek (long offset, int origin)
     { return f ? fseek (f, offset, origin) : -1; }
 
   long tell (void) { return f ? ftell (f) : -1; }
 
   void clear (void) { if (f) clearerr (f); }
 
-  static int file_close (FILE *f) { return ::fclose (f); }
+  static int file_close (FILE *f);
 
 protected:
 
   FILE *f;
 
   close_fcn cf;
 
 private:
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -78,21 +78,17 @@ octave_change_to_directory (const std::s
       Vlast_chdir_time.stamp ();
 
       // FIXME -- should this be handled as a list of functions
       // to call so users can add their own chdir handlers?
 
       load_path::update ();
     }
   else
-    {
-      using namespace std;
-
-      error ("%s: %s", newdir.c_str (), strerror (errno));
-    }
+    error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
 
   return cd_ok;
 }
 
 DEFUN (cd, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} cd dir\n\
 @deffnx {Command} chdir dir\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -121,17 +121,17 @@ mark_for_deletion (const std::string& fi
 
 void
 cleanup_tmp_files (void)
 {
   while (! tmp_files.empty ())
     {
       std::string filename = tmp_files.top ();
       tmp_files.pop ();
-      unlink (filename.c_str ());
+      gnulib::unlink (filename.c_str ());
     }
 }
 
 static std::ios::openmode
 fopen_mode_to_ios_mode (const std::string& mode_arg)
 {
   std::ios::openmode retval = std::ios::in;
 
@@ -492,33 +492,27 @@ do_stream_open (const std::string& name,
                 {
                   tmode.erase (pos, 1);
 
                   gzFile fptr = ::gzopen (fname.c_str (), tmode.c_str ());
 
                   if (fptr)
                     retval = octave_zstdiostream::create (fname, fptr, md, flt_fmt);
                   else
-                    {
-                      using namespace std;
-                      retval.error (::strerror (errno));
-                    }
+                    retval.error (gnulib::strerror (errno));
                 }
               else
 #endif
                 {
                   FILE *fptr = ::fopen (fname.c_str (), tmode.c_str ());
 
                   retval = octave_stdiostream::create (fname, fptr, md, flt_fmt);
 
                   if (! fptr)
-                    {
-                      using namespace std;
-                      retval.error (::strerror (errno));
-                    }
+                    retval.error (gnulib::strerror (errno));
                 }
 
             }
         }
     }
 
   return retval;
 }
@@ -1931,18 +1925,17 @@ system-dependent error message.\n\
           if (s)
             retval(0) = octave_stream_list::insert (s);
           else
             error ("tmpfile: failed to create octave_stdiostream object");
 
         }
       else
         {
-          using namespace std;
-          retval(1) = ::strerror (errno);
+          retval(1) = gnulib::strerror (errno);
           retval(0) = -1;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -2010,18 +2003,17 @@ error message.\n\
 #if defined (HAVE_MKSTEMP)
           int fd = mkstemp (tmp);
 #else
           int fd = mkstemps (tmp, 0);
 #endif
 
           if (fd < 0)
             {
-              using namespace std;
-              retval(2) = ::strerror (errno);
+              retval(2) = gnulib::strerror (errno);
               retval(0) = fd;
             }
           else
             {
               const char *fopen_mode = "w+";
 
               FILE *fid = fdopen (fd, fopen_mode);
 
@@ -2041,18 +2033,17 @@ error message.\n\
                       if (nargin == 2 && args(1).is_true ())
                         mark_for_deletion (nm);
                     }
                   else
                     error ("mkstemp: failed to create octave_stdiostream object");
                 }
               else
                 {
-                  using namespace std;
-                  retval(2) = ::strerror (errno);
+                  retval(2) = gnulib::strerror (errno);
                   retval(0) = -1;
                 }
             }
         }
       else
         error ("mkstemp: expecting string as first argument");
     }
   else
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -208,17 +208,17 @@ gnu_readline (const std::string& s, bool
         retval = "\n";
     }
   else
     {
       if (! s.empty () && (interactive || forced_interactive))
         {
           FILE *stream = command_editor::get_output_stream ();
 
-          fputs (s.c_str (), stream);
+          gnulib::fputs (s.c_str (), stream);
           fflush (stream);
         }
 
       FILE *curr_stream = command_editor::get_input_stream ();
 
       if (reading_fcn_file || reading_script_file || reading_classdef_file)
         curr_stream = ff_instream;
 
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -23,16 +23,20 @@ along with Octave; see the file COPYING.
 */
 
 %option prefix = "octave_"
 
 %top {
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
+
+#if defined (GNULIB_NAMESPACE)
+#undef GNULIB_NAMESPACE
+#endif
 }
 
 %s COMMAND_START
 %s MATRIX_START
 
 %x SCRIPT_FILE_BEGIN
 %x FUNCTION_FILE_BEGIN
 
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -2102,17 +2102,17 @@ public:
       delete *p;
 
     context->arraylist.clear ();
   }
 
   // Allocate memory.
   void *malloc_unmarked (size_t n)
   {
-    void *ptr = ::malloc (n);
+    void *ptr = gnulib::malloc (n);
 
     if (! ptr)
       {
         // FIXME -- could use "octave_new_handler();" instead
 
         error ("%s: failed to allocate %d bytes of memory",
                function_name (), n);
 
@@ -2158,17 +2158,17 @@ public:
   // pointer is NULL, allocate using malloc.  We don't need an
   // "unmarked" version of this.
   void *realloc (void *ptr, size_t n)
   {
     void *v;
 
     if (ptr)
       {
-        v = ::realloc (ptr, n);
+        v = gnulib::realloc (ptr, n);
         
         std::set<void *>::iterator p = memlist.find (ptr);
         
         if (v && p != memlist.end ())
           {
             memlist.erase (p);
             memlist.insert (v);
           }
@@ -2371,17 +2371,17 @@ private:
 std::set<void *> mex::global_memlist;
 
 // Current context.
 mex *mex_context = 0;
 
 void *
 mxArray::malloc (size_t n)
 {
-  return mex_context ? mex_context->malloc_unmarked (n) : ::malloc (n);
+  return mex_context ? mex_context->malloc_unmarked (n) : gnulib::malloc (n);
 }
 
 void *
 mxArray::calloc (size_t n, size_t t)
 {
   return mex_context ? mex_context->calloc_unmarked (n, t) : ::calloc (n, t);
 }
 
@@ -2473,23 +2473,23 @@ void *
 mxCalloc (size_t n, size_t size)
 {
   return mex_context ? mex_context->calloc (n, size) : calloc (n, size);
 }
 
 void *
 mxMalloc (size_t n)
 {
-  return mex_context ? mex_context->malloc (n) : malloc (n);
+  return mex_context ? mex_context->malloc (n) : gnulib::malloc (n);
 }
 
 void *
 mxRealloc (void *ptr, size_t size)
 {
-  return mex_context ? mex_context->realloc (ptr, size) : realloc (ptr, size);
+  return mex_context ? mex_context->realloc (ptr, size) : gnulib::realloc (ptr, size);
 }
 
 void
 mxFree (void *ptr)
 {
   if (mex_context)
     mex_context->free (ptr);
   else
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -52,21 +52,17 @@ octave_fstream::octave_fstream (const st
   // Override default protection of 0664 so that umask will appear to
   // do the right thing.
 
   fs.open (nm.c_str (), arg_md, 0666);
 
 #endif
 
   if (! fs)
-    {
-      using namespace std;
-
-      error (strerror (errno));
-    }
+    error (gnulib::strerror (errno));
 }
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_fstream::seek (long, int)
 {
   error ("fseek: invalid_operation");
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -415,19 +415,20 @@ mk_tmp_hist_file (int argc, const string
         file << hlist[i] << "\n";
     }
 
   file.close ();
 
   return name;
 }
 
-static void unlink_cleanup (const char *file)
+static void
+unlink_cleanup (const char *file)
 {
-  unlink (file);
+  gnulib::unlink (file);
 }
 
 static void
 do_edit_history (int argc, const string_vector& argv)
 {
   std::string name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
 
   if (name.empty ())
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -28,16 +28,20 @@ along with Octave; see the file COPYING.
 
 %{
 #define YYDEBUG 1
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#if defined (GNULIB_NAMESPACE)
+#undef GNULIB_NAMESPACE
+#endif
+
 #include <cassert>
 #include <cstdio>
 
 #ifdef YYBYACC
 #include <cstdlib>
 #endif
 
 #include <iostream>
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -100,47 +100,47 @@ octave_procbuf::open (const char *comman
       parent_end = pipe_fds[1];
       child_end = pipe_fds[0];
     }
 
   proc_pid = ::fork ();
 
   if (proc_pid == 0)
     {
-      ::close (parent_end);
+      gnulib::close (parent_end);
 
       if (child_end != child_std_end)
         {
-          ::dup2 (child_end, child_std_end);
-          ::close (child_end);
+          gnulib::dup2 (child_end, child_std_end);
+          gnulib::close (child_end);
         }
 
       while (octave_procbuf_list)
         {
           FILE *fp = octave_procbuf_list->f;
 
           if (fp)
             {
-              ::fclose (fp);
+              gnulib::fclose (fp);
               fp = 0;
             }
 
           octave_procbuf_list = octave_procbuf_list->next;
         }
 
       execl ("/bin/sh", "sh", "-c", command, static_cast<void *> (0));
 
       exit (127);
     }
 
-  ::close (child_end);
+  gnulib::close (child_end);
 
   if (proc_pid < 0)
     {
-      ::close (parent_end);
+      gnulib::close (parent_end);
       return 0;
     }
 
   f = ::fdopen (parent_end, (mode & std::ios::in) ? "r" : "w");
 
   if (mode & std::ios::out)
     ::setvbuf (f, 0, _IOLBF, BUFSIZ);
 
@@ -188,17 +188,17 @@ octave_procbuf::close (void)
           if (*ptr == this)
             {
               *ptr = (*ptr)->next;
               status = 0;
               break;
             }
         }
 
-      if (status == 0 && ::fclose (f) == 0)
+      if (status == 0 && gnulib::fclose (f) == 0)
         {
           using namespace std;
 
           do
             {
               wait_pid = octave_syscalls::waitpid (proc_pid, &wstatus, 0);
             }
           while (wait_pid == -1 && errno == EINTR);
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -190,20 +190,20 @@ octave_set_signal_handler (int sig, sig_
 #if defined (SIGALRM)
   else
 #endif
   // FIXME -- Do we also need to explicitly disable SA_RESTART?
   if (restart_syscalls)
     act.sa_flags |= SA_RESTART;
 #endif
 
-  sigemptyset (&act.sa_mask);
-  sigemptyset (&oact.sa_mask);
+  gnulib::sigemptyset (&act.sa_mask);
+  gnulib::sigemptyset (&oact.sa_mask);
 
-  sigaction (sig, &act, &oact);
+  gnulib::sigaction (sig, &act, &oact);
 
   return oact.sa_handler;
 }
 
 static void
 generic_sig_handler (int sig)
 {
   my_friendly_exit (strsignal (sig), sig);
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -47,29 +47,29 @@ Free Software Foundation, Inc.
 // Signal handler return type.
 #ifndef BADSIG
 #define BADSIG (void (*)(int))-1
 #endif
 
 #define BLOCK_SIGNAL(sig, nvar, ovar) \
   do \
     { \
-      sigemptyset (&nvar); \
-      sigaddset (&nvar, sig); \
-      sigemptyset (&ovar); \
-      sigprocmask (SIG_BLOCK, &nvar, &ovar); \
+      gnulib::sigemptyset (&nvar); \
+      gnulib::sigaddset (&nvar, sig); \
+      gnulib::sigemptyset (&ovar); \
+      gnulib::sigprocmask (SIG_BLOCK, &nvar, &ovar); \
     } \
   while (0)
 
 #if !defined (SIGCHLD) && defined (SIGCLD)
 #define SIGCHLD SIGCLD
 #endif
 
 #define BLOCK_CHILD(nvar, ovar) BLOCK_SIGNAL (SIGCHLD, nvar, ovar)
-#define UNBLOCK_CHILD(ovar) sigprocmask (SIG_SETMASK, &ovar, 0)
+#define UNBLOCK_CHILD(ovar) gnulib::sigprocmask (SIG_SETMASK, &ovar, 0)
 
 typedef void sig_handler (int);
 
 // FIXME -- the data should probably be private...
 
 struct
 octave_interrupt_handler
 {
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -761,17 +761,17 @@ wait_for_input (int fid)
 #if defined (HAVE_SELECT)
   if (fid >= 0)
     {
       fd_set set;
 
       FD_ZERO (&set);
       FD_SET (fid, &set);
 
-      retval = select (FD_SETSIZE, &set, 0, 0, 0);
+      retval = gnulib::select (FD_SETSIZE, &set, 0, 0, 0);
     }
 #else
   retval = 1;
 #endif
 
   return retval;
 }
 
