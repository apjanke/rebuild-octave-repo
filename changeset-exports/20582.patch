# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444399599 14400
#      Fri Oct 09 10:06:39 2015 -0400
# Node ID ba2b07c13913e9dfe7cce172987ab268f46bea24
# Parent  fd0efcdb37188ecf35870f4751129c334a926f10
use new string_value method to handle value extraction errors

* __dispatch__.cc, balance.cc, colloc.cc, conv2.cc, data.cc, debug.cc,
graphics.cc, input.cc, matrix_type.cc, oct-hist.cc, schur.cc,
spparms.cc, symtab.cc, sysdep.cc, toplev.cc, utils.cc:
Use new string_value method.

diff --git a/libinterp/corefcn/__dispatch__.cc b/libinterp/corefcn/__dispatch__.cc
--- a/libinterp/corefcn/__dispatch__.cc
+++ b/libinterp/corefcn/__dispatch__.cc
@@ -41,49 +41,27 @@ along with Octave; see the file COPYING.
 
 DEFUN (__dispatch__, args, nargout,
        "Undocumented internal function")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  std::string f, r, t;
-
   if (nargin > 0 && nargin < 4)
     {
-      f = args(0).string_value ();
+      std::string f, r, t;
 
-      if (error_state)
-        {
-          error ("__dispatch__: first argument must be a function name");
-          return retval;
-        }
+      f = args(0).string_value ("__dispatch__: first argument must be a function name");
 
       if (nargin > 1)
-        {
-          r = args(1).string_value ();
-
-          if (error_state)
-            {
-              error ("__dispatch__: second argument must be a function name");
-              return retval;
-            }
-        }
+        r = args(1).string_value ("__dispatch__: second argument must be a function name");
 
       if (nargin > 2)
-        {
-          t = args(2).string_value ();
-
-          if (error_state)
-            {
-              error ("__dispatch__: third argument must be a type name");
-              return retval;
-            }
-        }
+        t = args(2).string_value ("__dispatch__: third argument must be a type name");
 
       if (nargin == 1)
         {
           if (nargout > 0)
             {
               symbol_table::fcn_info::dispatch_map_type dm
                 = symbol_table::get_dispatch (f);
 
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -238,23 +238,18 @@ Generalized eigenvalue problem balancing
     {
       std::string bal_job;
       if (nargout == 1)
         warning ("balance: used GEP, should have two output arguments");
 
       // Generalized eigenvalue problem.
       if (nargin == 2)
         bal_job = "B";
-      else if (args(2).is_string ())
-        bal_job = args(2).string_value ();
       else
-        {
-          error ("balance: OPT argument must be a string");
-          return retval;
-        }
+        bal_job = args(2).string_value ("balance: OPT argument must be a string");
 
       if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
         {
           gripe_nonconformant ();
           return retval;
         }
 
       Matrix bb;
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -75,45 +75,31 @@ Reference: @nospell{J. Villadsen}, @nosp
     }
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
-      if (args(i).is_defined ())
-        {
-          if (! args(i).is_string ())
-            {
-              error ("colloc: expecting string argument \"left\" or \"right\"");
-              return retval;
-            }
-
-          std::string s = args(i).string_value ();
+      std::string s = args(i).string_value ("colloc: expecting string argument \"left\" or \"right\"");
 
-          if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
-              || s == "right")
-            {
-              right = 1;
-            }
-          else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
-                   || s == "left")
-            {
-              left = 1;
-            }
-          else
-            {
-              error ("colloc: unrecognized argument");
-              return retval;
-            }
+      if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
+          || s == "right")
+        {
+          right = 1;
+        }
+      else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
+               || s == "left")
+        {
+          left = 1;
         }
       else
         {
-          error ("colloc: unexpected empty argument");
+          error ("colloc: unrecognized argument");
           return retval;
         }
     }
 
   ntot += left + right;
   if (ntot < 1)
     {
       error ("colloc: the total number of roots must be positive");
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -324,25 +324,17 @@ The size of the result is @code{max (siz
   convn_type ct;
 
   if (nargin < 2 || nargin > 3)
     {
       print_usage ();
       return retval;
     }
   else if (nargin == 3)
-    {
-      if (args(2).is_string ())
-        shape = args(2).string_value ();
-      else
-        {
-          error ("convn: SHAPE must be a string");
-          return retval;
-        }
-    }
+    shape = args(2).string_value ("convn: SHAPE must be a string");
 
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -6636,22 +6636,18 @@ ordered lists.\n\
   if (nargin > 2)
     {
       if (args(1).is_string ())
         {
           print_usage ();
           return retval;
         }
 
-      if (! args(2).is_string ())
-        {
-          error ("sort: MODE must be a string");
-          return retval;
-        }
-      std::string mode = args(2).string_value ();
+      std::string mode = args(2).string_value ("sort: MODE must be a string");
+
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
           error ("sort: MODE must be either \"ascend\" or \"descend\"");
           return retval;
@@ -6919,30 +6915,26 @@ Undocumented internal function.\n\
 static sortmode
 get_sort_mode_option (const octave_value& arg, const char *argn)
 {
   // FIXME: we initialize to UNSORTED here to avoid a GCC warning
   // about possibly using sortmode uninitialized.
   // FIXME: shouldn't these modes be scoped inside a class?
   sortmode smode = UNSORTED;
 
-  if (arg.is_string ())
-    {
-      std::string mode = arg.string_value ();
-      if (mode == "ascending")
-        smode = ASCENDING;
-      else if (mode == "descending")
-        smode = DESCENDING;
-      else if (mode == "either")
-        smode = UNSORTED;
-      else
-        error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
-    }
+  std::string mode = arg.string_value ("issorted: expecting %s argument to be a string", argn);
+
+  if (mode == "ascending")
+    smode = ASCENDING;
+  else if (mode == "descending")
+    smode = DESCENDING;
+  else if (mode == "either")
+    smode = UNSORTED;
   else
-    error ("issorted: expecting %s argument to be a string", argn);
+    error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} issorted (@var{a})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
@@ -6978,26 +6970,21 @@ This function does not support sparse ma
 
   if (nargin > 1)
     {
       octave_value mode_arg;
 
       if (nargin == 3)
         smode = get_sort_mode_option (args(2), "third");
 
-      if (args(1).is_string ())
-        {
-          std::string tmp = args(1).string_value ();
-          if (tmp == "rows")
-            by_rows = true;
-          else
-            smode = get_sort_mode_option (args(1), "second");
-        }
+      std::string tmp = args(1).string_value ("issorted: second argument must be a string");
+      if (tmp == "rows")
+        by_rows = true;
       else
-        error ("issorted: second argument must be a string");
+        smode = get_sort_mode_option (args(1), "second");
     }
 
   octave_value arg = args(0);
 
   if (by_rows)
     {
       if (arg.is_sparse_type ())
         error ("issorted: sparse matrices not yet supported");
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1412,48 +1412,43 @@ function returns.\n\
   if (Vdebugging)
     {
       int nargin = args.length ();
 
       if (nargin > 1)
         print_usage ();
       else if (nargin == 1)
         {
-          if (args(0).is_string ())
+          std::string arg = args(0).string_value ("dbstep: input argument must be a string");
+
+          if (arg == "in")
             {
-              std::string arg = args(0).string_value ();
+              Vdebugging = false;
 
-              if (arg == "in")
-                {
-                  Vdebugging = false;
+              tree_evaluator::dbstep_flag = -1;
+            }
+          else if (arg == "out")
+            {
+              Vdebugging = false;
 
-                  tree_evaluator::dbstep_flag = -1;
-                }
-              else if (arg == "out")
+              tree_evaluator::dbstep_flag = -2;
+            }
+          else
+            {
+              int n = atoi (arg.c_str ());
+
+              if (n > 0)
                 {
                   Vdebugging = false;
 
-                  tree_evaluator::dbstep_flag = -2;
+                  tree_evaluator::dbstep_flag = n;
                 }
               else
-                {
-                  int n = atoi (arg.c_str ());
-
-                  if (n > 0)
-                    {
-                      Vdebugging = false;
-
-                      tree_evaluator::dbstep_flag = n;
-                    }
-                  else
-                    error ("dbstep: invalid argument");
-                }
+                error ("dbstep: invalid argument");
             }
-          else
-            error ("dbstep: input argument must be a string");
         }
       else
         {
           Vdebugging = false;
 
           tree_evaluator::dbstep_flag = 1;
         }
     }
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1668,27 +1668,22 @@ property::create (const std::string& nam
       retval = property (new any_property (name, h, ov));
     }
   else if (type.compare ("radio"))
     {
       if (args.length () < 1)
         error ("addproperty: missing possible values for radio property");
       else
         {
-          std::string sv = args(0).string_value ();
-
-          if (! error_state)
-            {
-              retval = property (new radio_property (name, h, sv));
-
-              if (args.length () > 1)
-                retval.set (args(1));
-            }
-          else
-            error ("addproperty: invalid argument for radio property, expected a string value");
+          std::string sv = args(0).string_value ("addproperty: invalid argument for radio property, expected a string value");
+
+          retval = property (new radio_property (name, h, sv));
+
+          if (args.length () > 1)
+            retval.set (args(1));
         }
     }
   else if (type.compare ("double"))
     {
       double dv = (args.length () > 0 ? args(0).double_value () : 0.0);
 
       retval = property (new double_property (name, h, dv));
     }
@@ -10689,27 +10684,22 @@ Undocumented internal function.\n\
       double val = args(0).double_value ();
 
       if (! error_state)
         {
           graphics_handle h = gh_manager::lookup (val);
 
           if (h.ok ())
             {
-              std::string name = args(1).string_value ();
-
-              if (! error_state)
-                {
-                  if (nargin == 2)
-                    gh_manager::execute_callback (h, name);
-                  else
-                    gh_manager::execute_callback (h, name, args(2));
-                }
+              std::string name = args(1).string_value ("__go_execute_callback__: invalid callback name");
+
+              if (nargin == 2)
+                gh_manager::execute_callback (h, name);
               else
-                error ("__go_execute_callback__: invalid callback name");
+                gh_manager::execute_callback (h, name, args(2));
             }
           else
             error ("__go_execute_callback__: invalid graphics object (= %g)",
                    val);
         }
       else
         error ("__go_execute_callback__: invalid graphics object");
     }
@@ -10868,23 +10858,19 @@ List @var{toolkit} as an available graph
 @end deftypefn")
 {
   octave_value retval;
 
   gh_manager::auto_lock guard;
 
   if (args.length () == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string name = args(0).string_value ();
-          gtk_manager::register_toolkit (name);
-        }
-      else
-        error ("register_graphics_toolkit: TOOLKIT must be a string");
+      std::string name = args(0).string_value ("register_graphics_toolkit: TOOLKIT must be a string");
+
+      gtk_manager::register_toolkit (name);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (loaded_graphics_toolkits, , ,
@@ -10986,107 +10972,96 @@ undocumented.\n\
               gh_manager::lock ();
             }
         }
       else if (args.length () >= 2 && args.length () <= 4)
         {
           std::string term, file, debug_file;
           bool mono;
 
-          term = args(0).string_value ();
-
-          if (! error_state)
-            {
-              file = args(1).string_value ();
-
-              if (! error_state)
+          term = args(0).string_value ("drawnow: invalid terminal TERM, expected a string value");
+
+          file = args(1).string_value ("drawnow: invalid FILE, expected a string value");
+
+          size_t pos_p = file.find_first_of ("|");
+          size_t pos_c = file.find_first_not_of ("| ");
+
+          if (pos_p == std::string::npos &&
+              pos_c == std::string::npos)
+            {
+              error ("drawnow: empty output ''");
+
+              gh_manager::unlock ();
+
+              return retval;
+            }
+          else if (pos_c == std::string::npos)
+            {
+              error ("drawnow: empty pipe '|'");
+
+              gh_manager::unlock ();
+
+              return retval;
+            }
+          else if (pos_p != std::string::npos && pos_p < pos_c)
+            {
+              // Strip leading pipe character
+              file = file.substr (pos_c);
+            }
+          else
+            {
+              size_t pos = file.find_last_of (file_ops::dir_sep_chars ());
+
+              if (pos != std::string::npos)
                 {
-                  size_t pos_p = file.find_first_of ("|");
-                  size_t pos_c = file.find_first_not_of ("| ");
-
-                  if (pos_p == std::string::npos &&
-                      pos_c == std::string::npos)
+                  std::string dirname = file.substr (pos_c, pos+1);
+
+                  file_stat fs (dirname);
+
+                  if (! (fs && fs.is_dir ()))
                     {
-                      error ("drawnow: empty output ''");
-
-                      gh_manager::unlock ();
-
-                      return retval;
-                    }
-                  else if (pos_c == std::string::npos)
-                    {
-                      error ("drawnow: empty pipe '|'");
+                      error ("drawnow: nonexistent directory '%s'",
+                             dirname.c_str ());
 
                       gh_manager::unlock ();
 
                       return retval;
                     }
-                  else if (pos_p != std::string::npos && pos_p < pos_c)
+                }
+            }
+
+          mono = (args.length () >= 3 ? args(2).bool_value () : false);
+
+          if (! error_state)
+            {
+              debug_file = (args.length () > 3 ? args(3).string_value () : "");
+
+              if (! error_state)
+                {
+                  graphics_handle h = gcf ();
+
+                  if (h.ok ())
                     {
-                      // Strip leading pipe character
-                      file = file.substr (pos_c);
+                      graphics_object go = gh_manager::get_object (h);
+
+                      gh_manager::unlock ();
+
+                      go.get_toolkit ().print_figure (go, term, file,
+                                                      mono, debug_file);
+
+                      gh_manager::lock ();
                     }
                   else
-                    {
-                      size_t pos = file.find_last_of (file_ops::dir_sep_chars ());
-
-                      if (pos != std::string::npos)
-                        {
-                          std::string dirname = file.substr (pos_c, pos+1);
-
-                          file_stat fs (dirname);
-
-                          if (! (fs && fs.is_dir ()))
-                            {
-                              error ("drawnow: nonexistent directory '%s'",
-                                     dirname.c_str ());
-
-                              gh_manager::unlock ();
-
-                              return retval;
-                            }
-                        }
-                    }
-
-                  mono = (args.length () >= 3 ? args(2).bool_value () : false);
-
-                  if (! error_state)
-                    {
-                      debug_file = (args.length () > 3 ? args(3).string_value ()
-                                    : "");
-
-                      if (! error_state)
-                        {
-                          graphics_handle h = gcf ();
-
-                          if (h.ok ())
-                            {
-                              graphics_object go = gh_manager::get_object (h);
-
-                              gh_manager::unlock ();
-
-                              go.get_toolkit ().print_figure (go, term, file,
-                                                              mono, debug_file);
-
-                              gh_manager::lock ();
-                            }
-                          else
-                            error ("drawnow: nothing to draw");
-                        }
-                      else
-                        error ("drawnow: invalid DEBUG_FILE, expected a string value");
-                    }
-                  else
-                    error ("drawnow: invalid colormode MONO, expected a boolean value");
+                    error ("drawnow: nothing to draw");
                 }
               else
-                error ("drawnow: invalid FILE, expected a string value");
+                error ("drawnow: invalid DEBUG_FILE, expected a string value");
             }
           else
-            error ("drawnow: invalid terminal TERM, expected a string value");
+            error ("drawnow: invalid colormode MONO, expected a boolean value");
         }
       else
         print_usage ();
     }
 
   gh_manager::unlock ();
 
   return retval;
@@ -11132,41 +11107,35 @@ addlistener (gcf, \"position\", @{@@my_l
   octave_value retval;
 
   if (args.length () >= 3 && args.length () <= 4)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
         {
-          std::string pname = args(1).string_value ();
-
-          if (! error_state)
-            {
-              graphics_handle gh = gh_manager::lookup (h);
-
-              if (gh.ok ())
+          std::string pname = args(1).string_value ("addlistener: invalid property name, expected a string value");
+
+          graphics_handle gh = gh_manager::lookup (h);
+
+          if (gh.ok ())
+            {
+              graphics_object go = gh_manager::get_object (gh);
+
+              go.add_property_listener (pname, args(2), POSTSET);
+
+              if (args.length () == 4)
                 {
-                  graphics_object go = gh_manager::get_object (gh);
-
-                  go.add_property_listener (pname, args(2), POSTSET);
-
-                  if (args.length () == 4)
-                    {
-                      caseless_str persistent = args(3).string_value ();
-                      if (persistent.compare ("persistent"))
-                        go.add_property_listener (pname, args(2), PERSISTENT);
-                    }
+                  caseless_str persistent = args(3).string_value ();
+                  if (persistent.compare ("persistent"))
+                    go.add_property_listener (pname, args(2), PERSISTENT);
                 }
-              else
-                error ("addlistener: invalid graphics object (= %g)",
-                       h);
             }
           else
-            error ("addlistener: invalid property name, expected a string value");
+            error ("addlistener: invalid graphics object (= %g)", h);
         }
       else
         error ("addlistener: invalid handle");
     }
   else
     print_usage ();
 
   return retval;
@@ -11205,49 +11174,42 @@ dellistener (gcf, \"position\", c);\n\
   octave_value retval;
 
   if (args.length () == 3 || args.length () == 2)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
         {
-          std::string pname = args(1).string_value ();
-
-          if (! error_state)
-            {
-              graphics_handle gh = gh_manager::lookup (h);
-
-              if (gh.ok ())
+          std::string pname = args(1).string_value ("dellistener: invalid property name, expected a string value");
+
+          graphics_handle gh = gh_manager::lookup (h);
+
+          if (gh.ok ())
+            {
+              graphics_object go = gh_manager::get_object (gh);
+
+              if (args.length () == 2)
+                go.delete_property_listener (pname, octave_value (), POSTSET);
+              else
                 {
-                  graphics_object go = gh_manager::get_object (gh);
-
-                  if (args.length () == 2)
-                    go.delete_property_listener (pname, octave_value (),
-                                                 POSTSET);
-                  else
+                  if (args(2).is_string ()
+                      && args(2).string_value () == "persistent")
                     {
-                      if (args(2).is_string ()
-                          && args(2).string_value () == "persistent")
-                        {
-                          go.delete_property_listener (pname, octave_value (),
-                                                       PERSISTENT);
-                          go.delete_property_listener (pname, octave_value (),
-                                                       POSTSET);
-                        }
-                      else
-                        go.delete_property_listener (pname, args(2), POSTSET);
+                      go.delete_property_listener (pname, octave_value (),
+                                                   PERSISTENT);
+                      go.delete_property_listener (pname, octave_value (),
+                                                   POSTSET);
                     }
+                  else
+                    go.delete_property_listener (pname, args(2), POSTSET);
                 }
-              else
-                error ("dellistener: invalid graphics object (= %g)",
-                       h);
             }
           else
-            error ("dellistener: invalid property name, expected a string value");
+            error ("dellistener: invalid graphics object (= %g)", h);
         }
       else
         error ("dellistener: invalid handle");
     }
   else
     print_usage ();
 
   return retval;
@@ -11326,56 +11288,46 @@ addproperty (\"my_style\", gcf, \"lineli
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3)
     {
-      std::string name = args(0).string_value ();
+      std::string name = args(0).string_value ("addproperty: invalid property NAME, expected a string value");
+
+      double h = args(1).double_value ();
 
       if (! error_state)
         {
-          double h = args(1).double_value ();
-
-          if (! error_state)
-            {
-              graphics_handle gh = gh_manager::lookup (h);
-
-              if (gh.ok ())
+          graphics_handle gh = gh_manager::lookup (h);
+
+          if (gh.ok ())
+            {
+              graphics_object go = gh_manager::get_object (gh);
+
+              std::string type = args(2).string_value ("addproperty: invalid property TYPE, expected a string value");
+
+              if (! go.get_properties ().has_property (name))
                 {
-                  graphics_object go = gh_manager::get_object (gh);
-
-                  std::string type = args(2).string_value ();
-
-                  if (! error_state)
-                    {
-                      if (! go.get_properties ().has_property (name))
-                        {
-                          property p = property::create (name, gh, type,
-                                                         args.splice (0, 3));
-
-                          go.get_properties ().insert_property (name, p);
-                        }
-                      else
-                        error ("addproperty: a '%s' property already exists in the graphics object",
-                               name.c_str ());
-                    }
-                  else
-                    error ("addproperty: invalid property TYPE, expected a string value");
+                  property p = property::create (name, gh, type,
+                                                 args.splice (0, 3));
+
+                  go.get_properties ().insert_property (name, p);
                 }
               else
-                error ("addproperty: invalid graphics object (= %g)", h);
+                error ("addproperty: a '%s' property already exists in the graphics object",
+                       name.c_str ());
             }
           else
-            error ("addproperty: invalid handle value");
+            error ("addproperty: invalid graphics object (= %g)", h);
         }
       else
-        error ("addproperty: invalid property NAME, expected a string value");
+        error ("addproperty: invalid handle value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 octave_value
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -683,23 +683,17 @@ get_user_input (const octave_value_list&
 
   int nargin = args.length ();
 
   int read_as_string = 0;
 
   if (nargin == 2)
     read_as_string++;
 
-  std::string prompt = args(0).string_value ();
-
-  if (error_state)
-    {
-      error ("input: unrecognized argument");
-      return retval;
-    }
+  std::string prompt = args(0).string_value ("input: unrecognized argument");
 
   flush_octave_stdout ();
 
   octave_pager_stream::reset ();
   octave_diary_stream::reset ();
 
   octave_diary << prompt;
 
@@ -832,25 +826,17 @@ string @samp{(yes or no) } to it.  The u
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
       std::string prompt;
 
       if (nargin == 1)
-        {
-          if (args(0).is_string ())
-            prompt = args(0).string_value ();
-          else
-            {
-              error ("yes_or_no: PROMPT must be a string");
-              return retval;
-            }
-        }
+        prompt = args(0).string_value ("yes_or_no: PROMPT must be a string");
 
       retval = octave_yes_or_no (prompt);
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -209,119 +209,113 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
-              if (! args(1).is_string ())
-                error ("matrix_type: TYPE must be a string");
-              else
-                {
-                  std::string str_typ = args(1).string_value ();
+
+              std::string str_typ = args(1).string_value ("matrix_type: TYPE must be a string");
+
+              // FIXME: why do I have to explicitly call the constructor?
+              MatrixType mattyp = MatrixType ();
 
-                  // FIXME: why do I have to explicitly call the constructor?
-                  MatrixType mattyp = MatrixType ();
+              octave_idx_type nl = 0;
+              octave_idx_type nu = 0;
 
-                  octave_idx_type nl = 0;
-                  octave_idx_type nu = 0;
+              // Use STL function to convert to lower case
+              std::transform (str_typ.begin (), str_typ.end (),
+                              str_typ.begin (), tolower);
 
-                  // Use STL function to convert to lower case
-                  std::transform (str_typ.begin (), str_typ.end (),
-                                  str_typ.begin (), tolower);
+              if (str_typ == "diagonal")
+                mattyp.mark_as_diagonal ();
+              if (str_typ == "permuted diagonal")
+                mattyp.mark_as_permuted_diagonal ();
+              else if (str_typ == "upper")
+                mattyp.mark_as_upper_triangular ();
+              else if (str_typ == "lower")
+                mattyp.mark_as_lower_triangular ();
+              else if (str_typ == "banded"
+                       || str_typ == "banded positive definite")
+                {
+                  if (nargin != 4)
+                    error ("matrix_type: banded matrix type requires 4 arguments");
+                  else
+                    {
+                      nl = args(2).nint_value ();
+                      nu = args(3).nint_value ();
 
-                  if (str_typ == "diagonal")
-                    mattyp.mark_as_diagonal ();
-                  if (str_typ == "permuted diagonal")
-                    mattyp.mark_as_permuted_diagonal ();
-                  else if (str_typ == "upper")
-                    mattyp.mark_as_upper_triangular ();
-                  else if (str_typ == "lower")
-                    mattyp.mark_as_lower_triangular ();
-                  else if (str_typ == "banded"
-                           || str_typ == "banded positive definite")
-                    {
-                      if (nargin != 4)
-                        error ("matrix_type: banded matrix type requires 4 arguments");
+                      if (error_state)
+                        error ("matrix_type: band size NL, NU must be integers");
                       else
                         {
-                          nl = args(2).nint_value ();
-                          nu = args(3).nint_value ();
-
-                          if (error_state)
-                            error ("matrix_type: band size NL, NU must be integers");
+                          if (nl == 1 && nu == 1)
+                            mattyp.mark_as_tridiagonal ();
                           else
-                            {
-                              if (nl == 1 && nu == 1)
-                                mattyp.mark_as_tridiagonal ();
-                              else
-                                mattyp.mark_as_banded (nu, nl);
+                            mattyp.mark_as_banded (nu, nl);
 
-                              if (str_typ == "banded positive definite")
-                                mattyp.mark_as_symmetric ();
-                            }
+                          if (str_typ == "banded positive definite")
+                            mattyp.mark_as_symmetric ();
                         }
                     }
-                  else if (str_typ == "positive definite")
+                }
+              else if (str_typ == "positive definite")
+                {
+                  mattyp.mark_as_full ();
+                  mattyp.mark_as_symmetric ();
+                }
+              else if (str_typ == "singular")
+                mattyp.mark_as_rectangular ();
+              else if (str_typ == "full")
+                mattyp.mark_as_full ();
+              else if (str_typ == "unknown")
+                mattyp.invalidate_type ();
+              else
+                error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
+
+              if (nargin == 3
+                  && (str_typ == "upper" || str_typ == "lower"))
+                {
+                  const ColumnVector perm =
+                    ColumnVector (args(2).vector_value ());
+
+                  if (error_state)
+                    error ("matrix_type: Invalid permutation vector PERM");
+                  else
                     {
-                      mattyp.mark_as_full ();
-                      mattyp.mark_as_symmetric ();
-                    }
-                  else if (str_typ == "singular")
-                    mattyp.mark_as_rectangular ();
-                  else if (str_typ == "full")
-                    mattyp.mark_as_full ();
-                  else if (str_typ == "unknown")
-                    mattyp.invalidate_type ();
-                  else
-                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
+                      octave_idx_type len = perm.numel ();
+                      dim_vector dv = args(0).dims ();
 
-                  if (nargin == 3
-                      && (str_typ == "upper" || str_typ == "lower"))
-                    {
-                      const ColumnVector perm =
-                        ColumnVector (args(2).vector_value ());
-
-                      if (error_state)
+                      if (len != dv(0))
                         error ("matrix_type: Invalid permutation vector PERM");
                       else
                         {
-                          octave_idx_type len = perm.numel ();
-                          dim_vector dv = args(0).dims ();
+                          OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                          if (len != dv(0))
-                            error ("matrix_type: Invalid permutation vector PERM");
-                          else
-                            {
-                              OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                          for (octave_idx_type i = 0; i < len; i++)
+                            p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
-                              for (octave_idx_type i = 0; i < len; i++)
-                                p[i] = static_cast<octave_idx_type>
-                                  (perm (i))
-                                  - 1;
-
-                              mattyp.mark_as_permuted (len, p);
-                            }
+                          mattyp.mark_as_permuted (len, p);
                         }
                     }
-                  else if (nargin != 2
-                           && str_typ != "banded positive definite"
-                           && str_typ != "banded")
-                    error ("matrix_type: Invalid number of arguments");
+                }
+              else if (nargin != 2
+                       && str_typ != "banded positive definite"
+                       && str_typ != "banded")
+                error ("matrix_type: Invalid number of arguments");
 
-                  // Set the matrix type
-                  if (args(0).is_complex_type ())
-                    retval = octave_value (args(0).sparse_complex_matrix_value (),
-                                           mattyp);
-                  else
-                    retval = octave_value (args(0).sparse_matrix_value (),
-                                           mattyp);
-                }
+              // Set the matrix type
+              if (args(0).is_complex_type ())
+                retval = octave_value (args(0).sparse_complex_matrix_value (),
+                                       mattyp);
+              else
+                retval = octave_value (args(0).sparse_matrix_value (),
+                                       mattyp);
             }
         }
       else
         {
           if (nargin == 1)
             {
               MatrixType mattyp;
 
@@ -393,98 +387,89 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
-              if (! args(1).is_string ())
-                error ("matrix_type: TYPE must be a string");
-              else
-                {
-                  std::string str_typ = args(1).string_value ();
+
+              std::string str_typ = args(1).string_value ("matrix_type: TYPE must be a string");
 
-                  // FIXME: why do I have to explicitly call the constructor?
-                  MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
+              // FIXME: why do I have to explicitly call the constructor?
+              MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
+
+              // Use STL function to convert to lower case
+              std::transform (str_typ.begin (), str_typ.end (),
+                              str_typ.begin (), tolower);
 
-                  // Use STL function to convert to lower case
-                  std::transform (str_typ.begin (), str_typ.end (),
-                                  str_typ.begin (), tolower);
+              if (str_typ == "upper")
+                mattyp.mark_as_upper_triangular ();
+              else if (str_typ == "lower")
+                mattyp.mark_as_lower_triangular ();
+              else if (str_typ == "positive definite")
+                {
+                  mattyp.mark_as_full ();
+                  mattyp.mark_as_symmetric ();
+                }
+              else if (str_typ == "singular")
+                mattyp.mark_as_rectangular ();
+              else if (str_typ == "full")
+                mattyp.mark_as_full ();
+              else if (str_typ == "unknown")
+                mattyp.invalidate_type ();
+              else
+                error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
-                  if (str_typ == "upper")
-                    mattyp.mark_as_upper_triangular ();
-                  else if (str_typ == "lower")
-                    mattyp.mark_as_lower_triangular ();
-                  else if (str_typ == "positive definite")
+              if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
+                {
+                  const ColumnVector perm =
+                    ColumnVector (args(2).vector_value ());
+
+                  if (error_state)
+                    error ("matrix_type: Invalid permutation vector PERM");
+                  else
                     {
-                      mattyp.mark_as_full ();
-                      mattyp.mark_as_symmetric ();
-                    }
-                  else if (str_typ == "singular")
-                    mattyp.mark_as_rectangular ();
-                  else if (str_typ == "full")
-                    mattyp.mark_as_full ();
-                  else if (str_typ == "unknown")
-                    mattyp.invalidate_type ();
-                  else
-                    error ("matrix_type: Unknown matrix type %s",
-                           str_typ.c_str ());
+                      octave_idx_type len = perm.numel ();
+                      dim_vector dv = args(0).dims ();
 
-                  if (nargin == 3 && (str_typ == "upper"
-                                      || str_typ == "lower"))
-                    {
-                      const ColumnVector perm =
-                        ColumnVector (args(2).vector_value ());
-
-                      if (error_state)
+                      if (len != dv(0))
                         error ("matrix_type: Invalid permutation vector PERM");
                       else
                         {
-                          octave_idx_type len = perm.numel ();
-                          dim_vector dv = args(0).dims ();
+                          OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                          if (len != dv(0))
-                            error ("matrix_type: Invalid permutation vector PERM");
-                          else
-                            {
-                              OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                          for (octave_idx_type i = 0; i < len; i++)
+                            p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
-                              for (octave_idx_type i = 0; i < len; i++)
-                                p[i] = static_cast<octave_idx_type>
-                                  (perm (i))
-                                  - 1;
-
-                              mattyp.mark_as_permuted (len, p);
-                            }
+                          mattyp.mark_as_permuted (len, p);
                         }
                     }
-                  else if (nargin != 2)
-                    error ("matrix_type: Invalid number of arguments");
+                }
+              else if (nargin != 2)
+                error ("matrix_type: Invalid number of arguments");
 
-                  // Set the matrix type
-                  if (args(0).is_single_type ())
-                    {
-                      if (args(0).is_complex_type ())
-                        retval = octave_value (args(0).float_complex_matrix_value (),
-                                               mattyp);
-                      else
-                        retval = octave_value (args(0).float_matrix_value (),
-                                               mattyp);
-                    }
+              // Set the matrix type
+              if (args(0).is_single_type ())
+                {
+                  if (args(0).is_complex_type ())
+                    retval = octave_value (args(0).float_complex_matrix_value (),
+                                           mattyp);
                   else
-                    {
-                      if (args(0).is_complex_type ())
-                        retval = octave_value (args(0).complex_matrix_value (),
-                                               mattyp);
-                      else
-                        retval = octave_value (args(0).matrix_value (),
-                                               mattyp);
-                    }
+                    retval = octave_value (args(0).float_matrix_value (),
+                                           mattyp);
+                }
+              else
+                {
+                  if (args(0).is_complex_type ())
+                    retval = octave_value (args(0).complex_matrix_value (),
+                                           mattyp);
+                  else
+                    retval = octave_value (args(0).matrix_value (), mattyp);
                 }
             }
         }
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -166,24 +166,21 @@ do_history (const octave_value_list& arg
           return hlist;
         }
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < nargin - 1)
             {
-              if (args(i+1).is_string ())
-                command_history::set_file (args(++i).string_value ());
-              else
-                {
-                  error ("history: expecting file name for %s option",
-                         option.c_str ());
-                  return hlist;
-                }
+              std::string fname
+                = args(++i).string_value ("history: expecting file name for %s option",
+                                          option.c_str ());
+
+              command_history::set_file (fname);
             }
           else
             command_history::set_file (default_history_file ());
 
           if (option == "-a")
             // Append 'new' lines to file.
             command_history::append ();
 
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -138,25 +138,17 @@ in control (see @code{are} and @code{dar
       return retval;
     }
 
   octave_value arg = args(0);
 
   std::string ord;
 
   if (nargin == 2)
-    {
-      if (args(1).is_string ())
-        ord = args(1).string_value ();
-      else
-        {
-          error ("schur: second argument must be a string");
-          return retval;
-        }
-    }
+    ord = args(1).string_value ("schur: second argument must be a string");
 
   bool force_complex = false;
 
   if (ord == "real")
     {
       ord = std::string ();
     }
   else if (ord == "complex")
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -162,31 +162,26 @@ longer running time.\n\
           else if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
             error ("spparms: too many elements in vector VALS");
           else
             octave_sparse_params::set_vals (vals);
         }
     }
   else if (nargin == 2)
     {
-      if (args(0).is_string ())
-        {
-          std::string str = args(0).string_value ();
+      std::string str = args(0).string_value ("spparms: first argument must be a string");
 
-          double val = args(1).double_value ();
+      double val = args(1).double_value ();
 
-          if (error_state)
-            error ("spparms: second argument must be a real scalar");
-          else if (str == "umfpack")
-            warning ("spparms: request to disable umfpack solvers ignored");
-          else if (!octave_sparse_params::set_key (str, val))
-            error ("spparms: KEY not found");
-        }
-      else
-        error ("spparms: first argument must be a string");
+      if (error_state)
+        error ("spparms: second argument must be a real scalar");
+      else if (str == "umfpack")
+        warning ("spparms: request to disable umfpack solvers ignored");
+      else if (!octave_sparse_params::set_key (str, val))
+        error ("spparms: KEY not found");
     }
   else
     error ("spparms: too many input arguments");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1683,30 +1683,26 @@ determine whether functions defined in f
         default:
           retval = "none";
           break;
         }
     }
 
   if (nargin == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string sval = args(0).string_value ();
-          if (sval == "all")
-            Vignore_function_time_stamp = 2;
-          else if (sval == "system")
-            Vignore_function_time_stamp = 1;
-          else if (sval == "none")
-            Vignore_function_time_stamp = 0;
-          else
-            error ("ignore_function_time_stamp: argument must be \"all\", \"system\", or \"none\"");
-        }
+      std::string sval = args(0).string_value ("ignore_function_time_stamp: expecting argument to be a string");
+
+      if (sval == "all")
+        Vignore_function_time_stamp = 2;
+      else if (sval == "system")
+        Vignore_function_time_stamp = 1;
+      else if (sval == "none")
+        Vignore_function_time_stamp = 0;
       else
-        error ("ignore_function_time_stamp: expecting argument to be character string");
+        error ("ignore_function_time_stamp: argument must be \"all\", \"system\", or \"none\"");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1818,37 +1814,32 @@ DEFUN (__get_cmdline_fcn_txt__, args, ,
 @deftypefn  {Built-in Function} {} __get_cmdline_fcn_txt__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ();
+      std::string name = args(0).string_value ("__get_cmd_line_function_text__: expecting function name");
 
-      if (! error_state)
-        {
-          octave_value ov = symbol_table::find_cmdline_function (name);
+      octave_value ov = symbol_table::find_cmdline_function (name);
 
-          octave_user_function *f = ov.user_function_value ();
+      octave_user_function *f = ov.user_function_value ();
 
-          if (f)
-            {
-              std::ostringstream buf;
-
-              tree_print_code tpc (buf);
+      if (f)
+        {
+          std::ostringstream buf;
 
-              f->accept (tpc);
+          tree_print_code tpc (buf);
 
-              retval = buf.str ();
-            }
+          f->accept (tpc);
+
+          retval = buf.str ();
         }
-      else
-        error ("__get_cmd_line_function_text__: expecting function name");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #if 0
@@ -1856,47 +1847,39 @@ Undocumented internal function.\n\
 // FIXME: should we have functions like this in Octave?
 
 DEFUN (set_variable, args, , "set_variable (NAME, VALUE)")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
-      std::string name = args(0).string_value ();
+      std::string name = args(0).string_value ("set_variable: expecting variable name as first argument");
 
-      if (! error_state)
-        symbol_table::assign (name, args(1));
-      else
-        error ("set_variable: expecting variable name as first argument");
+      symbol_table::assign (name, args(1));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (variable_value, args, , "VALUE = variable_value (NAME)")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string name = args(0).string_value ();
+      std::string name = args(0).string_value ("variable_value: expecting variable name as first argument");
 
-      if (! error_state)
-        {
-          retval = symbol_table::varval (name);
+      retval = symbol_table::varval (name);
 
-          if (retval.is_undefined ())
-            error ("variable_value: '%s' is not a variable in the current scope",
-                   name.c_str ());
-        }
-      else
-        error ("variable_value: expecting variable name as first argument");
+      if (retval.is_undefined ())
+        error ("variable_value: '%s' is not a variable in the current scope",
+               name.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 #endif
 
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -190,37 +190,32 @@ DEFUN (__open_with_system_app__, args, ,
 @deftypefn {Loadable Function} {} __open_with_system_app__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string file = args(0).string_value ();
+      std::string file = args(0).string_value ("__open_with_system_app__: argument must be a file name");
 
-      if (! error_state)
-        {
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
-          HINSTANCE status = ShellExecute (0, 0, file.c_str (), 0, 0,
-                                           SW_SHOWNORMAL);
+      HINSTANCE status = ShellExecute (0, 0, file.c_str (), 0, 0,
+                                       SW_SHOWNORMAL);
 
-          // ShellExecute returns a value greater than 32 if successful.
-          retval = (reinterpret_cast<ptrdiff_t> (status) > 32);
+      // ShellExecute returns a value greater than 32 if successful.
+      retval = (reinterpret_cast<ptrdiff_t> (status) > 32);
 #else
-          octave_value_list tmp
-            = Fsystem (ovl ("xdg-open " + file + " 2> /dev/null",
-                            false, "async"),
-                       1);
+      octave_value_list tmp
+        = Fsystem (ovl ("xdg-open " + file + " 2> /dev/null",
+                        false, "async"),
+                   1);
 
-          retval = (tmp(0).double_value () == 0);
+      retval = (tmp(0).double_value () == 0);
 #endif
-        }
-      else
-        error ("__open_with_system_app__: argument must be a file name");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #if defined (__MINGW32__)
@@ -645,30 +640,23 @@ string.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 1)
     {
-      if (args(0).is_string ())
-        {
-          std::string var = args(0).string_value ();
-
-          std::string val = (nargin == 2
-                             ? args(1).string_value () : std::string ());
+      std::string var = args(0).string_value ("setenv: VAR must be a string");
 
-          if (! error_state)
-            octave_env::putenv (var, val);
-          else
-            error ("setenv: VALUE must be a string");
-        }
-      else
-        error ("setenv: VAR must be a string");
+      std::string val = (nargin == 2
+                         ? args(1).string_value ("setenv: VALUE must be a string")
+                         : std::string ());
+
+      octave_env::putenv (var, val);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (putenv, setenv);
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1032,33 +1032,25 @@ command shell that is started to run the
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargin == 1 && nargout > 1);
 
       system_exec_type type = et_sync;
 
       if (nargin == 3)
         {
-          if (args(2).is_string ())
-            {
-              std::string type_str = args(2).string_value ();
+          std::string type_str = args(2).string_value ("system: TYPE must be a string");
 
-              if (type_str == "sync")
-                type = et_sync;
-              else if (type_str == "async")
-                type = et_async;
-              else
-                {
-                  error ("system: TYPE must be \"sync\" or \"async\"");
-                  return retval;
-                }
-            }
+          if (type_str == "sync")
+            type = et_sync;
+          else if (type_str == "async")
+            type = et_async;
           else
             {
-              error ("system: TYPE must be a string");
+              error ("system: TYPE must be \"sync\" or \"async\"");
               return retval;
             }
         }
 
       if (nargin > 1)
         {
           return_output = args(1).is_true ();
 
@@ -1070,85 +1062,80 @@ command shell that is started to run the
         }
 
       if (return_output && type == et_async)
         {
           error ("system: can't return output from commands run asynchronously");
           return retval;
         }
 
-      std::string cmd_str = args(0).string_value ();
+      std::string cmd_str = args(0).string_value ("system: expecting string as first argument");
 
-      if (! error_state)
-        {
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
-          // Work around weird double-quote handling on Windows systems.
-          if (type == et_sync)
-            cmd_str = "\"" + cmd_str + "\"";
+      // Work around weird double-quote handling on Windows systems.
+      if (type == et_sync)
+        cmd_str = "\"" + cmd_str + "\"";
 #endif
 
-          if (type == et_async)
-            {
-              // FIXME: maybe this should go in sysdep.cc?
+      if (type == et_async)
+        {
+          // FIXME: maybe this should go in sysdep.cc?
 #ifdef HAVE_FORK
-              pid_t pid = fork ();
+          pid_t pid = fork ();
 
-              if (pid < 0)
-                error ("system: fork failed -- can't create child process");
-              else if (pid == 0)
-                {
-                  // FIXME: should probably replace this
-                  // call with something portable.
+          if (pid < 0)
+            error ("system: fork failed -- can't create child process");
+          else if (pid == 0)
+            {
+              // FIXME: should probably replace this
+              // call with something portable.
 
-                  execl (SHELL_PATH, "sh", "-c", cmd_str.c_str (),
-                         static_cast<void *> (0));
+              execl (SHELL_PATH, "sh", "-c", cmd_str.c_str (),
+                     static_cast<void *> (0));
 
-                  panic_impossible ();
-                }
-              else
-                retval(0) = pid;
+              panic_impossible ();
+            }
+          else
+            retval(0) = pid;
 #elif defined (__WIN32__)
-              STARTUPINFO si;
-              PROCESS_INFORMATION pi;
-              ZeroMemory (&si, sizeof (si));
-              ZeroMemory (&pi, sizeof (pi));
-              OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length ()+1);
-              strcpy (xcmd_str, cmd_str.c_str ());
+          STARTUPINFO si;
+          PROCESS_INFORMATION pi;
+          ZeroMemory (&si, sizeof (si));
+          ZeroMemory (&pi, sizeof (pi));
+          OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length ()+1);
+          strcpy (xcmd_str, cmd_str.c_str ());
 
-              if (! CreateProcess (0, xcmd_str, 0, 0, FALSE, 0, 0, 0, &si, &pi))
-                error ("system: CreateProcess failed -- can't create child process");
-              else
-                {
-                  retval(0) = pi.dwProcessId;
-                  CloseHandle (pi.hProcess);
-                  CloseHandle (pi.hThread);
-                }
-#else
-              error ("asynchronous system calls are not supported");
-#endif
-            }
-          else if (return_output)
-            retval = run_command_and_return_output (cmd_str);
+          if (! CreateProcess (0, xcmd_str, 0, 0, FALSE, 0, 0, 0, &si, &pi))
+            error ("system: CreateProcess failed -- can't create child process");
           else
             {
-              int status = system (cmd_str.c_str ());
-
-              // The value in status is as returned by waitpid.  If
-              // the process exited normally, extract the actual exit
-              // status of the command.  Otherwise, return 127 as a
-              // failure code.
+              retval(0) = pi.dwProcessId;
+              CloseHandle (pi.hProcess);
+              CloseHandle (pi.hThread);
+            }
+#else
+          error ("asynchronous system calls are not supported");
+#endif
+        }
+      else if (return_output)
+        retval = run_command_and_return_output (cmd_str);
+      else
+        {
+          int status = system (cmd_str.c_str ());
 
-              if (octave_wait::ifexited (status))
-                status = octave_wait::exitstatus (status);
+          // The value in status is as returned by waitpid.  If
+          // the process exited normally, extract the actual exit
+          // status of the command.  Otherwise, return 127 as a
+          // failure code.
 
-              retval(0) = status;
-            }
+          if (octave_wait::ifexited (status))
+            status = octave_wait::exitstatus (status);
+
+          retval(0) = status;
         }
-      else
-        error ("system: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1230,42 +1217,37 @@ from the list, so if a function was plac
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      if (args(0).is_string ())
-        {
-          std::string arg = args(0).string_value ();
+      std::string arg = args(0).string_value ("atexit: FCN argument must be a string");
+
+      bool add_mode = true;
 
-          bool add_mode = true;
-
-          if (nargin == 2)
-            {
-              add_mode = args(1).bool_value ();
+      if (nargin == 2)
+        {
+          add_mode = args(1).bool_value ();
 
-              if (error_state)
-                error ("atexit: FLAG argument must be a logical value");
-            }
+          if (error_state)
+            error ("atexit: FLAG argument must be a logical value");
+        }
 
-          if (add_mode)
-            octave_add_atexit_function (arg);
-          else
-            {
-              bool found = octave_remove_atexit_function (arg);
+      if (add_mode)
+        octave_add_atexit_function (arg);
+      else
+        {
+          bool found = octave_remove_atexit_function (arg);
 
-              if (nargout > 0)
-                retval(0) = found;
-            }
+          if (nargout > 0)
+            retval(0) = found;
         }
-      else
-        error ("atexit: FCN argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (octave_config_info, args, ,
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -388,42 +388,37 @@ If no files are found, return an empty c
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
-      if (args(0).is_string ())
-        {
-          std::string path = args(0).string_value ();
+      std::string path = args(0).string_value ("file_in_path: PATH must be a string");
+
+      string_vector names = args(1).all_strings ();
 
-          string_vector names = args(1).all_strings ();
-
-          if (! error_state && names.numel () > 0)
+      if (! error_state && names.numel () > 0)
+        {
+          if (nargin == 2)
+            retval = search_path_for_file (path, names);
+          else if (nargin == 3)
             {
-              if (nargin == 2)
-                retval = search_path_for_file (path, names);
-              else if (nargin == 3)
-                {
-                  std::string opt = args(2).string_value ();
+              std::string opt = args(2).string_value ();
 
-                  if (! error_state && opt == "all")
-                    retval = Cell (make_absolute
-                                   (search_path_for_all_files (path, names)));
-                  else
-                    error ("file_in_path: invalid option");
-                }
+              if (! error_state && opt == "all")
+                retval = Cell (make_absolute
+                               (search_path_for_all_files (path, names)));
+              else
+                error ("file_in_path: invalid option");
             }
-          else
-            error ("file_in_path: all arguments must be strings");
         }
       else
-        error ("file_in_path: PATH must be a string");
+        error ("file_in_path: all arguments must be strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -756,20 +751,19 @@ Escape sequences begin with a leading ba
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      if (args(0).is_string ())
-        retval = do_string_escapes (args(0).string_value ());
-      else
-        error ("do_string_escapes: STRING argument must be of type string");
+      std::string str = args(0).string_value ("do_string_escapes: STRING argument must be of type string");
+
+      retval = do_string_escapes (str);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -900,20 +894,19 @@ replaces the unprintable alert character
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      if (args(0).is_string ())
-        retval = undo_string_escapes (args(0).string_value ());
-      else
-        error ("undo_string_escapes: S argument must be a string");
+      std::string str = args(0).string_value ("undo_string_escapes: S argument must be a string");
+
+      retval = undo_string_escapes (str);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -997,22 +990,19 @@ system.\n\
 No check is done for the existence of @var{file}.\n\
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = std::string ();
 
   if (args.length () == 1)
     {
-      std::string nm = args(0).string_value ();
+      std::string nm = args(0).string_value ("make_absolute_filename: FILE argument must be a file name");
 
-      if (! error_state)
-        retval = octave_env::make_absolute (nm);
-      else
-        error ("make_absolute_filename: FILE argument must be a file name");
+      retval = octave_env::make_absolute (nm);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1042,27 +1032,22 @@ all name matches rather than just the fi
   octave_value retval = std::string ();
 
   int nargin = args.length ();
 
   std::string dir;
 
   if (nargin == 1 || nargin == 2)
     {
-      dir = args(0).string_value ();
+      dir = args(0).string_value ("dir_in_loadpath: DIR must be a directory name");
 
-      if (! error_state)
-        {
-          if (nargin == 1)
-            retval = load_path::find_dir (dir);
-          else if (nargin == 2)
-            retval = Cell (load_path::find_matching_dirs (dir));
-        }
-      else
-        error ("dir_in_loadpath: DIR must be a directory name");
+      if (nargin == 1)
+        retval = load_path::find_dir (dir);
+      else if (nargin == 2)
+        retval = Cell (load_path::find_matching_dirs (dir));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
