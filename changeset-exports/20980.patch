# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1450983351 18000
#      Thu Dec 24 13:55:51 2015 -0500
# Node ID 81c2b14c209fbde336b857e5c05b3895b61d88cc
# Parent  0963ed3890122e4ced86b8cc44102007121bd02b
maint: invert if/else/error instances.

* Cell.cc, __ilu__.cc, bitfcns.cc, cellfun.cc data.cc, debug.cc,
error.cc: Invert if/else/error instances.

diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -285,30 +285,28 @@ Cell::nnz (void) const
 %!error <wrong type argument 'cell array'> nnz ({"foo", "bar"})
 */
 
 Cell
 Cell::column (octave_idx_type i) const
 {
   Cell retval;
 
-  if (ndims () < 3)
-    {
-      if (i < 0 || i >= cols ())
-        error ("invalid column selection");
+  if (ndims () > 2)
+    error ("Cell::column: requires 2-D cell array");
 
-      octave_idx_type nr = rows ();
+  if (i < 0 || i >= cols ())
+    error ("invalid column selection");
 
-      retval.resize (dim_vector (nr, 1));
+  octave_idx_type nr = rows ();
 
-      for (octave_idx_type j = 0; j < nr; j++)
-        retval.xelem (j) = elem (j, i);
-    }
-  else
-    error ("Cell::column: requires 2-D cell array");
+  retval.resize (dim_vector (nr, 1));
+
+  for (octave_idx_type j = 0; j < nr; j++)
+    retval.xelem (j) = elem (j, i);
 
   return retval;
 }
 
 Cell
 Cell::concat (const Cell& rb, const Array<octave_idx_type>& ra_idx)
 {
   return insert (rb, ra_idx);
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -100,24 +100,27 @@ void ilu_0 (octave_matrix_t& sm, const s
                   r += data[j] * data[jj];
             }
           j++;
           jrow = ridx[j];
         }
       uptr[k] = j;
       if (opt != OFF)
         data[uptr[k]] -= r;
+
       if (opt != ROW)
         for (jj = uptr[k] + 1; jj < cidx[k+1]; jj++)
           data[jj] /=  data[uptr[k]];
+
       if (k != jrow)
         error ("ilu: A has a zero on the diagonal");
 
       if (data[j] == T(0))
         error ("ilu: encountered a pivot equal to 0");
+
       for (i = j1; i <= j2; i++)
         iw[ridx[i]] = -1;
     }
   if (opt == ROW)
     sm = sm.transpose ();
 }
 
 DEFUN (__ilu0__, args, ,
@@ -753,23 +756,21 @@ void ilu_tp (octave_matrix_t& sm, octave
 
 
 
       // Check if the pivot is zero and if udiag is active.
       // NOTE: If the pivot == 0 and udiag is active, then if milu = [col|row]
       //       will not preserve the row sum for that column/row.
       if (w_data[k] == zero)
         {
-          if (udiag == 1)
-            {
-              w_data[k] = droptol;
-              iw_u.insert (k);
-            }
-          else
+          if (udiag != 1)
             error ("ilu: encountered a pivot equal to 0");
+
+          w_data[k] = droptol;
+          iw_u.insert (k);
         }
 
       // Scale the elements on the L part for IKJ version (milu = [col|off])
       if (opt != ROW)
         for (it = iw_l.begin (); it != iw_l.end (); ++it)
           {
             p_perm = iperm[*it];
             w_data[p_perm] = w_data[p_perm] / w_data[k];
@@ -820,18 +821,20 @@ void ilu_tp (octave_matrix_t& sm, octave
           w_data[p_perm] = 0;
         }
       total_len_u += w_len_u;
       total_len_l += w_len_l;
       // Check if there are too many elements to be indexed with
       // octave_idx_type type due to fill-in during the process.
       if (total_len_l < 0 || total_len_u < 0)
         error ("ilu: Integer overflow.  Too many fill-in elements in L or U");
+
       if (opt == ROW)
         uptr[k] = total_len_u - 1;
+
       cidx_u[k+1] = cidx_u[k] - cidx_u[0] + w_len_u;
       cidx_l[k+1] = cidx_l[k] - cidx_l[0] + w_len_l;
 
       iw_l.clear ();
       iw_u.clear ();
     }
 
   octave_matrix_t *L_ptr;
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -83,40 +83,35 @@ bitopxx (const OP& op, const std::string
 
   bool is_scalar_op = (nelx == 1 || nely == 1);
 
   dim_vector dvx = x.dims ();
   dim_vector dvy = y.dims ();
 
   bool is_array_op = (dvx == dvy);
 
-  octave_value retval;
-  if (is_array_op || is_scalar_op)
-    {
-      Array<T> result;
-
-      if (nelx != 1)
-        result.resize (dvx);
-      else
-        result.resize (dvy);
-
-      for (int i = 0; i < nelx; i++)
-        if (is_scalar_op)
-          for (int k = 0; k < nely; k++)
-            result(i+k) = op (x(i), y(k));
-        else
-          result(i) = op (x(i), y(i));
-
-      retval = result;
-    }
-  else
+  if (! is_array_op && ! is_scalar_op)
     error ("%s: size of X and Y must match, or one operand must be a scalar",
            fname.c_str ());
 
-  return retval;
+  Array<T> result;
+
+  if (nelx != 1)
+    result.resize (dvx);
+  else
+    result.resize (dvy);
+
+  for (int i = 0; i < nelx; i++)
+    if (is_scalar_op)
+      for (int k = 0; k < nely; k++)
+        result(i+k) = op (x(i), y(k));
+    else
+      result(i) = op (x(i), y(i));
+
+  return result;
 }
 
 // Trampoline function, instantiates the proper template above, with
 // reflective information hardwired. We can't hardwire this information
 // in Fbitxxx DEFUNs below, because at that moment, we still don't have
 // information about which integer types we need to instantiate.
 template<typename T>
 octave_value
@@ -461,57 +456,53 @@ bitshift (float a, int n, int64_t mask)
 
 // Note that the bitshift operators are undefined if shifted by more
 // bits than in the type, so we need to test for the size of the
 // shift.
 
 #define DO_BITSHIFT(T) \
   double d1, d2; \
  \
-  if (n.all_integers (d1, d2)) \
-    { \
-      int m_nel = m.numel (); \
-      int n_nel = n.numel (); \
+  if (! n.all_integers (d1, d2)) \
+    error ("bitshift: K must be a scalar or array of integers"); \
  \
-      bool is_scalar_op = (m_nel == 1 || n_nel == 1); \
+  int m_nel = m.numel (); \
+  int n_nel = n.numel (); \
  \
-      dim_vector m_dv = m.dims (); \
-      dim_vector n_dv = n.dims (); \
+  bool is_scalar_op = (m_nel == 1 || n_nel == 1); \
  \
-      bool is_array_op = (m_dv == n_dv); \
+  dim_vector m_dv = m.dims (); \
+  dim_vector n_dv = n.dims (); \
+ \
+  bool is_array_op = (m_dv == n_dv); \
  \
-      if (is_array_op || is_scalar_op) \
-        { \
-          T ## NDArray result; \
+  if (! is_array_op && ! is_scalar_op) \
+    error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
  \
-          if (m_nel != 1) \
-            result.resize (m_dv); \
-          else \
-            result.resize (n_dv); \
+  T ## NDArray result; \
  \
-          for (int i = 0; i < m_nel; i++) \
-            if (is_scalar_op) \
-              for (int k = 0; k < n_nel; k++) \
-                if (static_cast<int> (n(k)) >= bits_in_type) \
-                  result(i+k) = 0; \
-                else \
-                  result(i+k) = bitshift (m(i), static_cast<int> (n(k)), mask); \
-            else \
-              if (static_cast<int> (n(i)) >= bits_in_type) \
-                result(i) = 0; \
-              else \
-                result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
+  if (m_nel != 1) \
+    result.resize (m_dv); \
+  else \
+    result.resize (n_dv); \
  \
-          retval = result; \
-        } \
+  for (int i = 0; i < m_nel; i++) \
+    if (is_scalar_op) \
+      for (int k = 0; k < n_nel; k++) \
+        if (static_cast<int> (n(k)) >= bits_in_type) \
+          result(i+k) = 0; \
+        else \
+          result(i+k) = bitshift (m(i), static_cast<int> (n(k)), mask); \
+    else \
+      if (static_cast<int> (n(i)) >= bits_in_type) \
+        result(i) = 0; \
       else \
-        error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
-    } \
-  else \
-    error ("bitshift: K must be a scalar or array of integers"); \
+        result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
+ \
+  retval = result;
 
 #define DO_UBITSHIFT(T, N) \
   do \
     { \
       int bits_in_type = octave_ ## T :: nbits (); \
       T ## NDArray m = m_arg.T ## _array_value (); \
         octave_ ## T mask = octave_ ## T::max (); \
       if ((N) < bits_in_type) \
@@ -580,23 +571,21 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
   int nbits = 64;
 
   if (nargin == 3)
     {
       // FIXME: for compatibility, we should accept an array or a scalar
       //        as the third argument.
       if (args(2).numel () > 1)
         error ("bitshift: N must be a scalar integer");
-      else
-        {
-          nbits = args(2).xint_value ("bitshift: N must be an integer");
+
+      nbits = args(2).xint_value ("bitshift: N must be an integer");
 
-          if (nbits < 0)
-            error ("bitshift: N must be positive");
-        }
+      if (nbits < 0)
+        error ("bitshift: N must be positive");
     }
 
   octave_value retval;
 
   octave_value m_arg = args(0);
   std::string cname = m_arg.class_name ();
 
   if (cname == "double")
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -176,52 +176,48 @@ try_cellfun_internal_ops (const octave_v
     {
       NDA result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
         result(count) = static_cast<double> (f_args.elem (count).numel ());
       retval(0) = result;
     }
   else if (name == "size")
     {
-      if (nargin == 3)
-        {
-          int d = args(2).nint_value () - 1;
+      if (nargin != 3)
+        error ("cellfun: not enough arguments for \"size\"");
+
+      int d = args(2).nint_value () - 1;
 
-          if (d < 0)
-            error ("cellfun: K must be a positive integer");
+      if (d < 0)
+        error ("cellfun: K must be a positive integer");
 
-          NDA result (f_args.dims ());
+      NDA result (f_args.dims ());
 
-          for (octave_idx_type count = 0; count < k; count++)
-            {
-              dim_vector dv = f_args.elem (count).dims ();
-              if (d < dv.length ())
-                result(count) = static_cast<double> (dv(d));
-              else
-                result(count) = 1.0;
-            }
+      for (octave_idx_type count = 0; count < k; count++)
+        {
+          dim_vector dv = f_args.elem (count).dims ();
+          if (d < dv.length ())
+            result(count) = static_cast<double> (dv(d));
+          else
+            result(count) = 1.0;
+        }
 
-          retval(0) = result;
-        }
-      else
-        error ("cellfun: not enough arguments for \"size\"");
+      retval(0) = result;
     }
   else if (name == "isclass")
     {
-      if (nargin == 3)
-        {
-          std::string class_name = args(2).string_value ();
-          BNDA result (f_args.dims ());
-          for (octave_idx_type count = 0; count < k; count++)
-            result(count) = (f_args.elem (count).class_name () == class_name);
+      if (nargin != 3)
+        error ("cellfun: not enough arguments for \"isclass\"");
 
-          retval(0) = result;
-        }
-      else
-        error ("cellfun: not enough arguments for \"isclass\"");
+      std::string class_name = args(2).string_value ();
+      BNDA result (f_args.dims ());
+      for (octave_idx_type count = 0; count < k; count++)
+        result(count) = (f_args.elem (count).class_name () == class_name);
+
+      retval(0) = result;
     }
 
   return retval;
 }
 
 static void
 get_mapper_fun_options (const octave_value_list& args, int& nargin,
                         bool& uniform_output, octave_value& error_handler)
@@ -441,254 +437,251 @@ v = cellfun (@@det, a); # faster\n\
         {
           func = symbol_table::find_function (name);
 
           if (func.is_undefined ())
             error ("cellfun: invalid function NAME: %s", name.c_str ());
         }
     }
 
-  if (func.is_function_handle () || func.is_inline_function ()
-      || func.is_function ())
-    {
-
-      bool uniform_output = true;
-      octave_value error_handler;
-
-      get_mapper_fun_options (args, nargin, uniform_output, error_handler);
+  if (! func.is_function_handle () && ! func.is_inline_function ()
+      && ! func.is_function ())
+    error ("cellfun: argument NAME must be a string or function handle");
 
-      // The following is an optimization because the symbol table can give a
-      // more specific function class, so this can result in fewer polymorphic
-      // function calls as the function gets called for each value of the array.
-      {
-        if (func.is_function_handle ())
-          {
-            octave_fcn_handle* f = func.fcn_handle_value ();
+  bool uniform_output = true;
+  octave_value error_handler;
 
-            // Overloaded function handles need to check the type of the
-            // arguments for each element of the array, so they cannot be
-            // optimized this way.
-            if (f -> is_overloaded ())
-              goto nevermind;
-          }
+  get_mapper_fun_options (args, nargin, uniform_output, error_handler);
 
-        std::string name = func.function_value () -> name ();
-        octave_value f = symbol_table::find_function (name);
-
-        if (f.is_defined ())
-          {
-            // Except for these two which are special cases...
-            if (name != "size" && name != "class")
-              {
-                // Try first the optimized code path for built-in functions
-                octave_value_list tmp_args = args;
-                tmp_args(0) = name;
+  // The following is an optimization because the symbol table can give a
+  // more specific function class, so this can result in fewer polymorphic
+  // function calls as the function gets called for each value of the array.
+  {
+    if (func.is_function_handle ())
+      {
+        octave_fcn_handle* f = func.fcn_handle_value ();
 
-                if (uniform_output)
-                  retval =
-                    try_cellfun_internal_ops<boolNDArray, NDArray> (tmp_args,
-                                                                    nargin);
-                else
-                  retval =
-                    try_cellfun_internal_ops<Cell, Cell> (tmp_args, nargin);
-
-                if (! retval.empty ())
-                  return retval;
-              }
-
-            // Okay, we tried, doesn't work, let's do the best we can instead
-            // and avoid polymorphic calls for each element of the array.
-            func = f;
-          }
+        // Overloaded function handles need to check the type of the
+        // arguments for each element of the array, so they cannot be
+        // optimized this way.
+        if (f -> is_overloaded ())
+          goto nevermind;
       }
 
-    nevermind:
-
-      // Extract cell arguments.
+    std::string name = func.function_value () -> name ();
+    octave_value f = symbol_table::find_function (name);
 
-      octave_value_list inputlist (nargin, octave_value ());
-
-      OCTAVE_LOCAL_BUFFER (Cell, inputs, nargin);
-      OCTAVE_LOCAL_BUFFER (bool, mask, nargin);
+    if (f.is_defined ())
+      {
+        // Except for these two which are special cases...
+        if (name != "size" && name != "class")
+          {
+            // Try first the optimized code path for built-in functions
+            octave_value_list tmp_args = args;
+            tmp_args(0) = name;
 
-      // This is to prevent copy-on-write.
-      const Cell *cinputs = inputs;
+            if (uniform_output)
+              retval =
+                try_cellfun_internal_ops<boolNDArray, NDArray> (tmp_args,
+                                                                nargin);
+            else
+              retval =
+                try_cellfun_internal_ops<Cell, Cell> (tmp_args, nargin);
 
-      octave_idx_type k = 1;
-
-      dim_vector fdims (1, 1);
-
-      // Collect arguments.  Pre-fill scalar elements of inputlist array.
+            if (! retval.empty ())
+              return retval;
+          }
 
-      for (int j = 0; j < nargin; j++)
-        {
-          if (! args(j+1).is_cell ())
-            error ("cellfun: arguments must be cells");
+        // Okay, we tried, doesn't work, let's do the best we can instead
+        // and avoid polymorphic calls for each element of the array.
+        func = f;
+      }
+  }
 
-          inputs[j] = args(j+1).cell_value ();
-          mask[j] = inputs[j].numel () != 1;
-          if (! mask[j])
-            inputlist(j) = cinputs[j](0);
-        }
+ nevermind:
+
+  // Extract cell arguments.
+
+  octave_value_list inputlist (nargin, octave_value ());
+
+  OCTAVE_LOCAL_BUFFER (Cell, inputs, nargin);
+  OCTAVE_LOCAL_BUFFER (bool, mask, nargin);
 
-      for (int j = 0; j < nargin; j++)
-        {
-          if (mask[j])
-            {
-              fdims = inputs[j].dims ();
-              k = inputs[j].numel ();
-              for (int i = j+1; i < nargin; i++)
-                {
-                  if (mask[i] && inputs[i].dims () != fdims)
-                    error ("cellfun: dimensions mismatch");
-                }
-              break;
-            }
-        }
+  // This is to prevent copy-on-write.
+  const Cell *cinputs = inputs;
+
+  octave_idx_type k = 1;
+
+  dim_vector fdims (1, 1);
+
+  // Collect arguments.  Pre-fill scalar elements of inputlist array.
+
+  for (int j = 0; j < nargin; j++)
+    {
+      if (! args(j+1).is_cell ())
+        error ("cellfun: arguments must be cells");
+
+      inputs[j] = args(j+1).cell_value ();
+      mask[j] = inputs[j].numel () != 1;
+      if (! mask[j])
+        inputlist(j) = cinputs[j](0);
+    }
 
-      unwind_protect frame;
-      frame.protect_var (buffer_error_messages);
-
-      if (error_handler.is_defined ())
-        buffer_error_messages++;
-
-      // Apply functions.
-
-      if (uniform_output)
+  for (int j = 0; j < nargin; j++)
+    {
+      if (mask[j])
         {
-          std::list<octave_value_list> idx_list (1);
-          idx_list.front ().resize (1);
-          std::string idx_type = "(";
+          fdims = inputs[j].dims ();
+          k = inputs[j].numel ();
+          for (int i = j+1; i < nargin; i++)
+            {
+              if (mask[i] && inputs[i].dims () != fdims)
+                error ("cellfun: dimensions mismatch");
+            }
+          break;
+        }
+    }
 
-          OCTAVE_LOCAL_BUFFER (octave_value, retv, nargout1);
+  unwind_protect frame;
+  frame.protect_var (buffer_error_messages);
+
+  if (error_handler.is_defined ())
+    buffer_error_messages++;
 
-          for (octave_idx_type count = 0; count < k; count++)
+  // Apply functions.
+
+  if (uniform_output)
+    {
+      std::list<octave_value_list> idx_list (1);
+      idx_list.front ().resize (1);
+      std::string idx_type = "(";
+
+      OCTAVE_LOCAL_BUFFER (octave_value, retv, nargout1);
+
+      for (octave_idx_type count = 0; count < k; count++)
+        {
+          for (int j = 0; j < nargin; j++)
             {
-              for (int j = 0; j < nargin; j++)
-                {
-                  if (mask[j])
-                    inputlist.xelem (j) = cinputs[j](count);
-                }
+              if (mask[j])
+                inputlist.xelem (j) = cinputs[j](count);
+            }
 
-              const octave_value_list tmp
-                = get_output_list (count, nargout, inputlist, func,
-                                   error_handler);
+          const octave_value_list tmp
+            = get_output_list (count, nargout, inputlist, func,
+                               error_handler);
+
+          if (nargout > 0 && tmp.length () < nargout)
+            error ("cellfun: function returned fewer than nargout values");
 
-              if (nargout > 0 && tmp.length () < nargout)
-                error ("cellfun: function returned fewer than nargout values");
+          if  (nargout > 0
+               || (nargout == 0
+                   && tmp.length () > 0 && tmp(0).is_defined ()))
+            {
+              int num_to_copy = tmp.length ();
 
-              if  (nargout > 0
-                   || (nargout == 0
-                       && tmp.length () > 0 && tmp(0).is_defined ()))
+              if (num_to_copy > nargout1)
+                num_to_copy = nargout1;
+
+              if (count == 0)
                 {
-                  int num_to_copy = tmp.length ();
-
-                  if (num_to_copy > nargout1)
-                    num_to_copy = nargout1;
-
-                  if (count == 0)
+                  for (int j = 0; j < num_to_copy; j++)
                     {
-                      for (int j = 0; j < num_to_copy; j++)
+                      if (tmp(j).is_defined ())
                         {
-                          if (tmp(j).is_defined ())
+                          octave_value val = tmp(j);
+
+                          if (val.numel () != 1)
+                            error ("cellfun: all values must be scalars when UniformOutput = true");
+
+                          retv[j] = val.resize (fdims);
+                        }
+                    }
+                }
+              else
+                {
+                  for (int j = 0; j < num_to_copy; j++)
+                    {
+                      if (tmp(j).is_defined ())
+                        {
+                          octave_value val = tmp(j);
+
+                          if (! retv[j].fast_elem_insert (count, val))
                             {
-                              octave_value val = tmp(j);
-
                               if (val.numel () != 1)
                                 error ("cellfun: all values must be scalars when UniformOutput = true");
 
-                              retv[j] = val.resize (fdims);
-                            }
-                        }
-                    }
-                  else
-                    {
-                      for (int j = 0; j < num_to_copy; j++)
-                        {
-                          if (tmp(j).is_defined ())
-                            {
-                              octave_value val = tmp(j);
-
-                              if (! retv[j].fast_elem_insert (count, val))
-                                {
-                                  if (val.numel () != 1)
-                                    error ("cellfun: all values must be scalars when UniformOutput = true");
-
-                                  idx_list.front ()(0) = count + 1.0;
-                                  retv[j].assign (octave_value::op_asn_eq,
-                                                  idx_type, idx_list, val);
-                                }
+                              idx_list.front ()(0) = count + 1.0;
+                              retv[j].assign (octave_value::op_asn_eq,
+                                              idx_type, idx_list, val);
                             }
                         }
                     }
                 }
             }
+        }
 
+      retval.resize (nargout1);
+
+      for (int j = 0; j < nargout1; j++)
+        {
+          if (nargout > 0 && retv[j].is_undefined ())
+            retval(j) = NDArray (fdims);
+          else
+            retval(j) = retv[j];
+        }
+    }
+  else
+    {
+      OCTAVE_LOCAL_BUFFER (Cell, results, nargout1);
+
+      for (int j = 0; j < nargout1; j++)
+        results[j].resize (fdims, Matrix ());
+
+      bool have_some_output = false;
+
+      for (octave_idx_type count = 0; count < k; count++)
+        {
+          for (int j = 0; j < nargin; j++)
+            {
+              if (mask[j])
+                inputlist.xelem (j) = cinputs[j](count);
+            }
+
+          const octave_value_list tmp
+            = get_output_list (count, nargout, inputlist, func,
+                               error_handler);
+
+          if (nargout > 0 && tmp.length () < nargout)
+            error ("cellfun: function returned fewer than nargout values");
+
+          if  (nargout > 0
+               || (nargout == 0
+                   && tmp.length () > 0 && tmp(0).is_defined ()))
+            {
+              int num_to_copy = tmp.length ();
+
+              if (num_to_copy > nargout1)
+                num_to_copy = nargout1;
+
+              if (num_to_copy > 0)
+                have_some_output = true;
+
+              for (int j = 0; j < num_to_copy; j++)
+                results[j](count) = tmp(j);
+            }
+        }
+
+      if (have_some_output || fdims.any_zero ())
+        {
           retval.resize (nargout1);
 
           for (int j = 0; j < nargout1; j++)
-            {
-              if (nargout > 0 && retv[j].is_undefined ())
-                retval(j) = NDArray (fdims);
-              else
-                retval(j) = retv[j];
-            }
-        }
-      else
-        {
-          OCTAVE_LOCAL_BUFFER (Cell, results, nargout1);
-
-          for (int j = 0; j < nargout1; j++)
-            results[j].resize (fdims, Matrix ());
-
-          bool have_some_output = false;
-
-          for (octave_idx_type count = 0; count < k; count++)
-            {
-              for (int j = 0; j < nargin; j++)
-                {
-                  if (mask[j])
-                    inputlist.xelem (j) = cinputs[j](count);
-                }
-
-              const octave_value_list tmp
-                = get_output_list (count, nargout, inputlist, func,
-                                   error_handler);
-
-              if (nargout > 0 && tmp.length () < nargout)
-                error ("cellfun: function returned fewer than nargout values");
-
-              if  (nargout > 0
-                   || (nargout == 0
-                       && tmp.length () > 0 && tmp(0).is_defined ()))
-                {
-                  int num_to_copy = tmp.length ();
-
-                  if (num_to_copy > nargout1)
-                    num_to_copy = nargout1;
-
-                  if (num_to_copy > 0)
-                    have_some_output = true;
-
-                  for (int j = 0; j < num_to_copy; j++)
-                    results[j](count) = tmp(j);
-                }
-            }
-
-          if (have_some_output || fdims.any_zero ())
-            {
-              retval.resize (nargout1);
-
-              for (int j = 0; j < nargout1; j++)
-                retval(j) = results[j];
-            }
+            retval(j) = results[j];
         }
     }
-  else
-    error ("cellfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 
 %!function r = __f11 (x)
 %!  global __cellfun_test_num_outputs__;
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -225,21 +225,24 @@ and @var{x}.\n\
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("atan2", args(0));
-  else if (! args(1).is_numeric_type ())
+
+  if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("atan2", args(1));
-  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+
+  if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("atan2: not defined for complex numbers");
-  else if (args(0).is_single_type () || args(1).is_single_type ())
+
+  if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = atan2f (args(0).float_value (), args(1).float_value ());
       else
         {
           FloatNDArray a0 = args(0).float_array_value ();
           FloatNDArray a1 = args(1).float_array_value ();
           retval = binmap<float> (a0, a1, ::atan2f, "atan2");
@@ -608,61 +611,62 @@ periodic, @code{mod} is a better choice.
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("rem", args(0));
-  else if (! args(1).is_numeric_type ())
+
+  if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("rem", args(1));
-  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+
+  if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rem: not defined for complex numbers");
-  else if (args(0).is_integer_type () || args(1).is_integer_type ())
+
+  if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
       builtin_type_t btyp1 = args(1).builtin_type ();
       if (btyp0 == btyp_double || btyp0 == btyp_float)
         btyp0 = btyp1;
       if (btyp1 == btyp_double || btyp1 == btyp_float)
         btyp1 = btyp0;
 
-      if (btyp0 == btyp1)
+      if (btyp0 != btyp1)
+        error ("rem: cannot combine %s and %d",
+               args(0).class_name ().c_str (),
+               args(1).class_name ().c_str ());
+
+      switch (btyp0)
         {
-          switch (btyp0)
-            {
 #define MAKE_INT_BRANCH(X) \
   case btyp_ ## X: \
     { \
       X##NDArray a0 = args(0).X##_array_value (); \
       X##NDArray a1 = args(1).X##_array_value (); \
       retval = binmap<octave_##X,octave_##X,octave_##X> (a0, a1, rem, "rem"); \
     } \
-    break;
-
-              MAKE_INT_BRANCH (int8);
-              MAKE_INT_BRANCH (int16);
-              MAKE_INT_BRANCH (int32);
-              MAKE_INT_BRANCH (int64);
-              MAKE_INT_BRANCH (uint8);
-              MAKE_INT_BRANCH (uint16);
-              MAKE_INT_BRANCH (uint32);
-              MAKE_INT_BRANCH (uint64);
+    break
+
+          MAKE_INT_BRANCH (int8);
+          MAKE_INT_BRANCH (int16);
+          MAKE_INT_BRANCH (int32);
+          MAKE_INT_BRANCH (int64);
+          MAKE_INT_BRANCH (uint8);
+          MAKE_INT_BRANCH (uint16);
+          MAKE_INT_BRANCH (uint32);
+          MAKE_INT_BRANCH (uint64);
 
 #undef MAKE_INT_BRANCH
 
-            default:
-              panic_impossible ();
-            }
+        default:
+          panic_impossible ();
         }
-      else
-        error ("rem: cannot combine %s and %d",
-               args(0).class_name ().c_str (),
-               args(1).class_name ().c_str ());
     }
   else if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = xrem (args(0).float_value (), args(1).float_value ());
       else
         {
           FloatNDArray a0 = args(0).float_array_value ();
@@ -788,61 +792,62 @@ negative numbers or when the values are 
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("mod", args(0));
-  else if (! args(1).is_numeric_type ())
+
+  if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("mod", args(1));
-  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+
+  if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("mod: not defined for complex numbers");
-  else if (args(0).is_integer_type () || args(1).is_integer_type ())
+
+  if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
       builtin_type_t btyp1 = args(1).builtin_type ();
       if (btyp0 == btyp_double || btyp0 == btyp_float)
         btyp0 = btyp1;
       if (btyp1 == btyp_double || btyp1 == btyp_float)
         btyp1 = btyp0;
 
-      if (btyp0 == btyp1)
+      if (btyp0 != btyp1)
+        error ("mod: cannot combine %s and %d",
+               args(0).class_name ().c_str (),
+               args(1).class_name ().c_str ());
+
+      switch (btyp0)
         {
-          switch (btyp0)
-            {
 #define MAKE_INT_BRANCH(X) \
   case btyp_ ## X: \
     { \
       X##NDArray a0 = args(0).X##_array_value (); \
       X##NDArray a1 = args(1).X##_array_value (); \
       retval = binmap<octave_##X,octave_##X,octave_##X> (a0, a1, mod, "mod"); \
     } \
-    break;
-
-              MAKE_INT_BRANCH (int8);
-              MAKE_INT_BRANCH (int16);
-              MAKE_INT_BRANCH (int32);
-              MAKE_INT_BRANCH (int64);
-              MAKE_INT_BRANCH (uint8);
-              MAKE_INT_BRANCH (uint16);
-              MAKE_INT_BRANCH (uint32);
-              MAKE_INT_BRANCH (uint64);
+    break
+
+          MAKE_INT_BRANCH (int8);
+          MAKE_INT_BRANCH (int16);
+          MAKE_INT_BRANCH (int32);
+          MAKE_INT_BRANCH (int64);
+          MAKE_INT_BRANCH (uint8);
+          MAKE_INT_BRANCH (uint16);
+          MAKE_INT_BRANCH (uint32);
+          MAKE_INT_BRANCH (uint64);
 
 #undef MAKE_INT_BRANCH
 
-            default:
-              panic_impossible ();
-            }
+        default:
+          panic_impossible ();
         }
-      else
-        error ("mod: cannot combine %s and %d",
-               args(0).class_name ().c_str (),
-               args(1).class_name ().c_str ());
     }
   else if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = xmod (args(0).float_value (), args(1).float_value ());
       else
         {
           FloatNDArray a0 = args(0).float_array_value ();
@@ -1365,25 +1370,23 @@ Given a matrix argument, instead of a ve
       octave_idx_type k = args(1).xint_value ("diag: invalid argument K");
 
       retval = args(0).diag (k);
     }
   else
     {
       octave_value arg0 = args(0);
 
-      if (arg0.ndims () == 2 && (arg0.rows () == 1 || arg0.columns () == 1))
-        {
-          octave_idx_type m = args(1).xint_value ("diag: invalid dimensions");
-          octave_idx_type n = args(2).xint_value ("diag: invalid dimensions");
-
-          retval = arg0.diag (m, n);
-        }
-      else
+      if (arg0.ndims () != 2 || (arg0.rows () != 1 && arg0.columns () != 1))
         error ("diag: V must be a vector");
+
+      octave_idx_type m = args(1).xint_value ("diag: invalid dimensions");
+      octave_idx_type n = args(2).xint_value ("diag: invalid dimensions");
+
+      retval = arg0.diag (m, n);
     }
 
   return retval;
 }
 
 /*
 
 %!assert (full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3])
@@ -1793,21 +1796,21 @@ attempt_type_conversion (const octave_va
           result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
         }
       catch (octave_execution_exception& e)
         {
           error (e, "conversion from %s to %s failed", dtype.c_str (),
                  cname.c_str ());
         }
 
-      if (result.length () > 0)
-        retval = result(0);
-      else
+      if (result.length () == 0)
         error ("conversion from %s to %s failed", dtype.c_str (),
                cname.c_str ());
+
+      retval = result(0);
     }
   else
     {
       // No conversion function available.  Try the constructor for the
       // dispatch type.
 
       fcn = symbol_table::find_method (dtype, dtype);
 
@@ -1821,21 +1824,21 @@ attempt_type_conversion (const octave_va
           result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
         }
       catch (octave_execution_exception& e)
         {
           error (e, "%s constructor failed for %s argument", dtype.c_str (),
                  cname.c_str ());
         }
 
-      if (result.length () > 0)
-        retval = result(0);
-      else
+      if (result.length () == 0)
         error ("%s constructor failed for %s argument", dtype.c_str (),
                cname.c_str ());
+
+      retval = result(0);
     }
 
   return retval;
 }
 
 octave_value
 do_class_concat (const octave_value_list& ovl, std::string cattype, int dim)
 {
@@ -1857,21 +1860,21 @@ do_class_concat (const octave_value_list
         {
           tmp2 = fcn.do_multi_index_op (1, ovl);
         }
       catch (octave_execution_exception& e)
         {
           error (e, "%s/%s method failed", dtype.c_str (), cattype.c_str ());
         }
 
-      if (tmp2.length () > 0)
-        retval = tmp2(0);
-      else
+      if (tmp2.length () == 0)
         error ("%s/%s method did not return a value", dtype.c_str (),
                cattype.c_str ());
+
+      retval = tmp2(0);
     }
   else
     {
       // No method for dominant type, so attempt type conversions for
       // all elements that are not of the dominant type, then do the
       // default operation for octave_class values.
 
       octave_idx_type j = 0;
@@ -5330,36 +5333,34 @@ the unspecified dimension.\n\
         error ("reshape: SIZE must have 2 or more dimensions");
 
       new_dims = dim_vector::alloc (new_size.numel ());
 
       for (octave_idx_type i = 0; i < new_size.numel (); i++)
         {
           if (new_size(i) < 0)
             error ("reshape: SIZE must be non-negative");
-          else
-            new_dims(i) = new_size(i);
+
+          new_dims(i) = new_size(i);
         }
     }
   else
     {
       new_dims = dim_vector::alloc (nargin-1);
       int empty_dim = -1;
 
       for (int i = 1; i < nargin; i++)
         {
           if (args(i).is_empty ())
             {
               if (empty_dim > 0)
                 error ("reshape: only a single dimension can be unknown");
-              else
-                {
-                  empty_dim = i;
-                  new_dims(i-1) = 1;
-                }
+
+              empty_dim = i;
+              new_dims(i-1) = 1;
             }
           else
             {
               new_dims(i-1) = args(i).idx_type_value ();
 
               if (new_dims(i-1) < 0)
                 error ("reshape: SIZE must be non-negative");
             }
@@ -5374,18 +5375,18 @@ the unspecified dimension.\n\
           else
             {
               octave_idx_type a_nel = args(0).numel ();
               octave_idx_type size_empty_dim = a_nel / nel;
 
               if (a_nel != size_empty_dim * nel)
                 error ("reshape: SIZE is not divisible by the product of known dimensions (= %d)",
                        nel);
-              else
-                new_dims(empty_dim-1) = size_empty_dim;
+
+              new_dims(empty_dim-1) = size_empty_dim;
             }
         }
     }
 
   retval = args(0).reshape (new_dims);
 
   return retval;
 }
@@ -5600,29 +5601,28 @@ compute the norms of each column and ret
 
   octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
 
   if (p_arg.is_empty ())
     p_arg = octave_value (2);
   else if (p_arg.is_string ())
     {
       std::string str = p_arg.string_value ();
-      if ((strflag == sfcols || strflag == sfrows))
-        {
-          if (str == "cols" || str == "columns" || str == "rows")
-            error ("norm: invalid combination of options");
-          else if (str == "fro")
-            p_arg = octave_value (2);
-          else if (str == "inf")
-            p_arg = octave_Inf;
-          else
-            error ("norm: unrecognized option: %s", str.c_str ());
-        }
+      if (strflag != sfcols && strflag != sfrows)
+        error ("norm: invalid combination of options");
+
+      if (str == "cols" || str == "columns" || str == "rows")
+        error ("norm: invalid combination of options");
+
+      if (str == "fro")
+        p_arg = octave_value (2);
+      else if (str == "inf")
+        p_arg = octave_Inf;
       else
-        error ("norm: invalid combination of options");
+        error ("norm: unrecognized option: %s", str.c_str ());
     }
   else if (! p_arg.is_scalar_type ())
     gripe_wrong_type_arg ("norm", p_arg, true);
 
   octave_value retval;
 
   switch (strflag)
     {
@@ -6766,16 +6766,17 @@ This function does not support sparse ma
   octave_value retval;
 
   octave_value arg = args(0);
 
   if (by_rows)
     {
       if (arg.is_sparse_type ())
         error ("issorted: sparse matrices not yet supported");
+
       if (arg.ndims () != 2)
         error ("issorted: A must be a 2-dimensional object");
 
       retval = arg.is_sorted_rows (smode) != UNSORTED;
     }
   else
     {
       if (! arg.dims ().is_vector ())
@@ -7579,18 +7580,18 @@ an empty matrix is returned.\n\
         error ("diff: order K must be non-negative");
     }
 
   if (nargin > 2)
     {
       dim = args(2).int_value (true, false);
       if (dim < 1 || dim > args(0).ndims ())
         error ("diff: DIM must be a valid dimension");
-      else
-        dim -= 1;
+
+      dim -= 1;
     }
 
   return do_diff (args(0), order, dim);
 }
 
 /*
 %!assert (diff ([1, 2, 3, 4]), [1, 1, 1])
 %!assert (diff ([1, 3, 7, 19], 2), [2, 8])
@@ -7727,17 +7728,18 @@ Encode a double matrix or array @var{x} 
 @seealso{base64_decode}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     error ("base64_encode: encoding is supported only for numeric arrays");
-  else if (args(0).is_complex_type () || args(0).is_sparse_type ())
+
+  if (args(0).is_complex_type () || args(0).is_sparse_type ())
     error ("base64_encode: encoding complex or sparse data is not supported");
 
   octave_value_list retval;
 
   if (args(0).is_integer_type ())
     {
 #define MAKE_INT_BRANCH(X) \
       if (args(0).is_ ## X ## _type ()) \
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -897,22 +897,22 @@ numbers.\n\
 
   string_vector argv = args.make_argv ("dbtype");
 
   switch (args.length ())
     {
     case 0: // dbtype
       dbg_fcn = get_user_code ();
 
-      if (dbg_fcn)
-        do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                   0, std::numeric_limits<int>::max ());
-      else
+      if (! dbg_fcn)
         error ("dbtype: must be inside a user function to give no arguments to dbtype\n");
 
+      do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                 0, std::numeric_limits<int>::max ());
+
       break;
 
     case 1: // (dbtype start:end) || (dbtype func) || (dbtype lineno)
       {
         std::string arg = argv[1];
 
         size_t ind = arg.find (':');
 
@@ -930,36 +930,36 @@ numbers.\n\
                 if (end_str == "end")
                   end = std::numeric_limits<int>::max ();
                 else
                   end = atoi (end_str.c_str ());
 
                 if (std::min (start, end) <= 0)
                   error ("dbtype: start and end lines must be >= 1\n");
 
-                if (start <= end)
-                  do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                             start, end);
-                else
+                if (start > end)
                   error ("dbtype: start line must be less than end line\n");
+
+                do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                           start, end);
               }
           }
         else  // (dbtype func) || (dbtype lineno)
           {
             int line = atoi (arg.c_str ());
 
             if (line == 0)  // (dbtype func)
               {
                 dbg_fcn = get_user_code (arg);
 
-                if (dbg_fcn)
-                  do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                             0, std::numeric_limits<int>::max ());
-                else
+                if (! dbg_fcn)
                   error ("dbtype: function <%s> not found\n", arg.c_str ());
+
+                do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                           0, std::numeric_limits<int>::max ());
               }
             else  // (dbtype lineno)
               {
                 if (line <= 0)
                   error ("dbtype: start and end lines must be >= 1\n");
 
                 dbg_fcn = get_user_code ();
 
@@ -996,17 +996,18 @@ numbers.\n\
         else
           {
             start = atoi (arg.c_str ());
             end = start;
           }
 
         if (std::min (start, end) <= 0)
           error ("dbtype: start and end lines must be >= 1\n");
-        else if (start > end)
+
+        if (start > end)
           error ("dbtype: start line must be less than end line\n");
 
         do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (), start, end);
       }
       break;
 
     default:
       error ("dbtype: expecting zero, one, or two arguments\n");
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1847,25 +1847,23 @@ fields are set to their default values.\
   err.assign ("identifier", Vlast_error_id);
 
   err.assign ("stack", octave_value (Vlast_error_stack));
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
-          if (args(0).string_value () == "reset")
-            {
-              Vlast_error_message = std::string ();
-              Vlast_error_id = std::string ();
+          if (args(0).string_value () != "reset")
+            error ("lasterror: unrecognized string argument");
 
-              Vlast_error_stack = initialize_last_error_stack ();
-            }
-          else
-            error ("lasterror: unrecognized string argument");
+          Vlast_error_message = std::string ();
+          Vlast_error_id = std::string ();
+
+          Vlast_error_stack = initialize_last_error_stack ();
         }
       else if (args(0).is_map ())
         {
           octave_scalar_map new_err = args(0).scalar_map_value ();
           octave_scalar_map new_err_stack;
           std::string new_error_message;
           std::string new_error_id;
           std::string new_error_file;
