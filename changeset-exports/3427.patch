# HG changeset patch
# User jwe
# Date 947755559 0
#      Thu Jan 13 09:25:59 2000 +0000
# Node ID e098ebb770239cf52f7b13cb4522eeeaa5f9f623
# Parent  f8dde1807dee9796b72785c6cdbad93b020d2b43
[project @ 2000-01-13 09:25:53 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,13 @@
+2000-01-13  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* gethelp.cc (extract_help_text): Discard first space character
+	after consecutive comment characters.
+
 Thu Jan 13 00:56:57 2000  John W. Eaton  <jwe@bahaha.che.wisc.edu>
 
 	* control/obsolete: New directory
 	* control/obsolete/swaprows.m: Move here from control directory.
 	* control/obsolete/swapcols.m: Likewise.
 	* control/obsolete/dlqg.m: Likewise.
 	* control/obsolete/minfo.m: Likewise.
 	* control/obsolete/packsys.m: Likewise.
diff --git a/scripts/control/bddemo.m b/scripts/control/bddemo.m
--- a/scripts/control/bddemo.m
+++ b/scripts/control/bddemo.m
@@ -594,17 +594,17 @@ function bddemo ()
       run_cmd
       sysout(PKcl)
       prompt
       disp("The transfer function form of PKcl is:")
       sysout(PKcl,"tf");
       disp("You can check this: PKcl = PK / (1 + PK), as expected")
       prompt
       elseif(meth != 5)
-        disp("Illegal selection")
+        disp("invalid selection")
      endif
     endwhile
 
     elseif (k == 14)
       return
     endif
   endwhile
   implict_str_to_num_ok = str_sav;
diff --git a/scripts/control/buildssic.m b/scripts/control/buildssic.m
--- a/scripts/control/buildssic.m
+++ b/scripts/control/buildssic.m
@@ -215,26 +215,26 @@ function sys = buildssic (Clst, Ulst, Ol
 
   ## build the feedback "K" from the interconnection data Clst
   K = zeros(m, p);
   inp_used = zeros(m,1);
   for ii = 1:nx
     xx = Clst(ii,:);
     iu = xx(1);
     if ((iu < 1) || (iu > m))
-      error("---> Illegal value in first col of Clst.");
+      error("---> invalid value in first col of Clst.");
     endif
     if (inp_used(iu))
       error("---> Input specified more than once.");
     endif
     inp_used(iu) = 1;
     for kk = 2:mx
       it = xx(kk);
       if (abs(it) > p)
-        error("---> Illegal row value in Clst.");
+        error("---> invalid row value in Clst.");
       elseif (it)
         K(iu,abs(it)) = sign(it);
       endif
     endfor
   endfor
 
   ## form the "closed loop", i.e replace u in
   ## .
@@ -257,44 +257,44 @@ function sys = buildssic (Clst, Ulst, Ol
   D = R*D;
 
   ## append old inputs u to the outputs (if lul > 0)
   kc = K*C;
   kdi = eye(m) + K*D;
   for ii = 1:lul
     it = Ulst(ii);
     if ((it < 1) || (it > m))
-      error("---> Illegal value in Ulst.");
+      error("---> invalid value in Ulst.");
     endif
     C = [C; kc(it,:)];
     D = [D; kdi(it,:)];
   endfor
 
   ## select and rearrange outputs
   nn = length(A);
   lol = length(Olst);
   Cnew = zeros(lol,nn);
   Dnew = zeros(lol,m);
   for ii = 1:lol
     iu = Olst(ii);
     if (!iu || (abs(iu) > p+lul))
-      error("---> Illegal value in Olst.");
+      error("---> invalid value in Olst.");
     endif
     Cnew(ii,:) = sign(iu)*C(abs(iu),:);
     Dnew(ii,:) = sign(iu)*D(abs(iu),:);
   endfor
   C = Cnew;
   D = Dnew;
   lil = length(Ilst);
   Bnew = zeros(nn,lil);
   Dnew = zeros(lol,lil);
   for ii = 1:lil
     iu = Ilst(ii);
     if (!iu || (abs(iu) > m))
-      error("---> Illegal value in Ilst.");
+      error("---> invalid value in Ilst.");
     endif
     Bnew(:,ii) = sign(iu)*B(:,abs(iu));
     Dnew(:,ii) = sign(iu)*D(:,abs(iu));
   endfor
 
   sys = ss2sys(A, Bnew, C, Dnew, tsam, n, nz);
 
 endfunction
diff --git a/scripts/control/c2d.m b/scripts/control/c2d.m
--- a/scripts/control/c2d.m
+++ b/scripts/control/c2d.m
@@ -95,17 +95,17 @@ function dsys = c2d (sys, opt, T)
     warning(["c2d: T=",num2str(T),", system tsam==",num2str(Ts), ...
       ": using T=", num2str(min(T,Ts))]);
     T = min(T,Ts);
   endif
 
   if (!is_sample(T))
     error("sampling period T must be a postive, real scalar");
   elseif( ! (strcmp(opt,"ex") | strcmp(opt,"bi") ) )
-    error(["illegal option passed: ",opt])
+    error(["invalid option passed: ",opt])
   endif
 
   sys = sysupdate(sys,"ss");
   [n,nz,m,p] = sysdimensions(sys);
   if(n == 0)
     dsys = syssetsignals(sys,"yd",ones(1:p));
   elseif(strcmp(opt,"ex"));
     [aa,bb,cc,dd] = sys2ss(sys);
diff --git a/scripts/control/com2str.m b/scripts/control/com2str.m
--- a/scripts/control/com2str.m
+++ b/scripts/control/com2str.m
@@ -40,17 +40,17 @@ function retval = com2str (zz, flg)
     flg = 0;
   endif
 
   if( !(is_scalar(zz) & is_scalar(flg) ) )
     error("com2str: arguments must be a scalar.");
   endif
 
   if(flg != 0 & flg != 1)
-    error(["Illegal flg value: ",num2str(flg)]);
+    error(["invalid flg value: ",num2str(flg)]);
   endif
 
   sgns = "+-";
   rz = real(zz);
   iz = imag(zz);
   az = abs(zz);
   if(iz == 0)
     ## strictly a real number
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -67,17 +67,17 @@ function csys = d2c (sys, opt)
   elseif (!is_struct(sys))
     error("sys must be in system data structure");
   elseif(nargin == 1)
     opt = "log";
     tol = 1e-12;
   elseif(isstr(opt))   # all remaining cases are for nargin == 2
     tol = 1e-12;
     if( !(strcmp(opt,"log") | strcmp(opt,"bi") ) )
-      error(["d2c: illegal opt passed=",opt]);
+      error(["d2c: invalid opt passed=",opt]);
     endif
   elseif(!is_sample(opt))
     error("tol must be a postive scalar")
   elseif(opt > 1e-2)
     warning(["d2c: ridiculous error tolerance passed=",num2str(opt); ...
         ", intended c2d call?"])
   else
     tol = opt;
diff --git a/scripts/control/is_digital.m b/scripts/control/is_digital.m
--- a/scripts/control/is_digital.m
+++ b/scripts/control/is_digital.m
@@ -36,17 +36,17 @@
 ## Created: July 1996
 
 function DIGITAL = is_digital (sys, eflg)
 
   switch(nargin)
   case(1),  eflg = 0;
   case(2),
     if( isempty(find(eflg == [0, 1, 2])) )
-      error("Illegal value of eflg=%d (%e)",eflg,eflg);
+      error("invalid value of eflg=%d (%e)",eflg,eflg);
     endif
   otherwise,
     usage("DIGITAL = is_digital(sys{,eflg})");
   endswitch
 
   ## checked for sampled data system (mixed)
   ## discrete system
   sysyd = sysgetsignals(sys,"yd");
diff --git a/scripts/control/is_sample.m b/scripts/control/is_sample.m
--- a/scripts/control/is_sample.m
+++ b/scripts/control/is_sample.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{retval} =} is_sample (@var{Ts})
-## return true if @var{Ts} is a legal sampling time
+## return true if @var{Ts} is a valid sampling time
 ## (real,scalar, > 0)
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function out = is_sample (Ts)
 
diff --git a/scripts/control/is_signal_list.m b/scripts/control/is_signal_list.m
--- a/scripts/control/is_signal_list.m
+++ b/scripts/control/is_signal_list.m
@@ -1,32 +1,34 @@
-# Copyright (C) 1996,1998,2000 Auburn University.  All rights reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+## Copyright (C) 1996, 1998, 2000 Auburn University.  All rights reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+
+## function flg = is_signal_list (mylist)
+## returns true if mylist is a list of individual strings.
 
 function flg = is_signal_list(mylist)
-# function flg = is_signal_list(mylist)
-# returns true if mylist is a list of individual strings.
-#
-flg = is_list(mylist);
-if(flg)
-  for ii=1:length(mylist)
-    if(!(isstr(nth(mylist,ii)) & rows(nth(mylist,ii)) ==1) )
-      flg = 0;
-    endif
-  endfor
-endif
+
+  flg = is_list(mylist);
+
+  if (flg)
+    for ii = 1:length (mylist)
+      if (! (isstr (nth (mylist,ii)) & rows (nth (mylist,ii)) == 1))
+	flg = 0;
+      endif
+    endfor
+  endif
 
 endfunction
diff --git a/scripts/control/obsolete/dlqg.m b/scripts/control/obsolete/dlqg.m
--- a/scripts/control/obsolete/dlqg.m
+++ b/scripts/control/obsolete/dlqg.m
@@ -98,17 +98,17 @@ function [K, Q, P, Ee, Er] = dlqg (A, B,
     if( (n == -1) || (n1 == -1))
       error("dlqg: A,B,C,G incompatibly dimensioned");
     elseif(p != columns(Sigv))
       error("dlqg: C, Sigv incompatibly dimensioned");
     elseif(m1 != columns(Sigw))
       error("dlqg: G, Sigw incompatibly dimensioned");
     endif
   else
-    error("dlqg: illegal number of arguments")
+    error ("dlqg: invalid number of arguments")
   endif
 
   if (! (is_square(Sigw) && is_square(Sigv) ) )
     error("dlqg: Sigw, Sigv must be square");
   endif
 
   ## now we can just do the design; call dlqr and dlqe, since all matrices
   ## are not given in Cholesky factor form (as in h2syn case)
diff --git a/scripts/control/sortcom.m b/scripts/control/sortcom.m
--- a/scripts/control/sortcom.m
+++ b/scripts/control/sortcom.m
@@ -52,17 +52,17 @@ function [yy, idx] = sortcom (xx, opt)
   endif
 
   if(isempty(xx))
     yy = idx = [];
   else
     if(strcmp(opt,"re"))        datavec = real(xx);
     elseif(strcmp(opt,"im"))    datavec = imag(xx);
     elseif(strcmp(opt,"mag"))   datavec = abs(xx);
-    else                        error(["sortcom: illegal option = ", opt])
+    else                        error(["sortcom: invalid option = ", opt])
     endif
 
     [datavec,idx] = sort(datavec);
     yy= xx(idx);
 
     if(strcmp(opt,"re") | strcmp(opt,"mag"))
       ## sort so that complex conjugate pairs appear together
 
diff --git a/scripts/control/ss2sys.m b/scripts/control/ss2sys.m
--- a/scripts/control/ss2sys.m
+++ b/scripts/control/ss2sys.m
@@ -212,38 +212,38 @@ function retsys = ss2sys (a, b, c, d, ts
   endif
 
   ## check for continuous states
   if( (nargin < 6) & (tsam == 0) )               n = na;
   elseif(nargin < 6)                             n = 0;
   elseif((!is_matrix(n)) | isstr(n))
     error("Parameter n is not a numerical value.");
   elseif( (!is_scalar(n)) | (n < 0 ) | (n != round(n)) )
-    if(is_scalar(n))     error("illegal value of n=%d,%e",n,n);
-    else                 error("illegal value of n=(%dx%d)", ...
+    if(is_scalar(n))     error("invalid value of n=%d,%e",n,n);
+    else                 error("invalid value of n=(%dx%d)", ...
                            rows(n), columns(n));                endif
   endif
 
   ## check for num discrete states
   if( (nargin < 7) & (tsam == 0))               nz = 0;
   elseif(nargin < 7)                            nz = na - n;
   elseif((!is_matrix(nz)) | isstr(nz))
     error("Parameter nz is not a numerical value.");
   elseif( (!is_scalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
     if(is_scalar(nz))
-      error(["illegal value of nz=",num2str(nz)]);
+      error(["invalid value of nz=",num2str(nz)]);
     else
-      error(["illegal value of nz=(",num2str(rows(nz)),"x", ...
+      error(["invalid value of nz=(",num2str(rows(nz)),"x", ...
         num2str(columns(nz)),")"]);
     endif
   endif
 
   ## check for total number of states
   if( (n + nz) != na )
-    error(["Illegal: a is ",num2str(na),"x",num2str(na),", n=", ...
+    error(["invalid: a is ",num2str(na),"x",num2str(na),", n=", ...
         num2str(n),", nz=",num2str(nz)]);
   endif
 
   ## construct system with default names
   retsys.a = a;
   retsys.b = b;
   retsys.c = c;
   retsys.d = d;
diff --git a/scripts/control/stepimp.m b/scripts/control/stepimp.m
--- a/scripts/control/stepimp.m
+++ b/scripts/control/stepimp.m
@@ -33,17 +33,17 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = stepimp (sitype, sys, inp, tstop, n)
 
   if (sitype == 1)         IMPULSE = 0;
   elseif (sitype == 2)     IMPULSE = 1;
-  else                     error("stepimp: illegal sitype argument.")
+  else                     error("stepimp: invalid sitype argument.")
   endif
   sys = sysupdate(sys,"ss");
 
   USE_DEF = 0;   # default tstop and n if we have to give up
   N_MIN = 50;    # minimum number of points
   N_MAX = 2000;  # maximum number of points
   T_DEF = 10.0;  # default simulation time
 
diff --git a/scripts/control/sysdimensions.m b/scripts/control/sysdimensions.m
--- a/scripts/control/sysdimensions.m
+++ b/scripts/control/sysdimensions.m
@@ -75,26 +75,27 @@ function [n, nz, m, p, yd] = sysdimensio
     opt = "all";
   endif
 
   n = sys.n;
   nz = sys.nz;
   m = length(sysgetsignals(sys,"in"));
   p = length(sysgetsignals(sys,"out"));
   yd = sys.yd;
-  legal_options = list("all","cst","dst","st","in","out");
-  legal_values = list(n,n,nz,n+nz,m,p);
+  valid_options = list("all","cst","dst","st","in","out");
+  valid_values = list(n,n,nz,n+nz,m,p);
 
-  legal_opt = 0;
-  for ii=1:length(legal_options)
-    if(strcmp(nth(legal_options,ii),opt))
-      n = nth(legal_values,ii);
-      legal_opt = 1;
+  valid_opt = 0;
+  for ii=1:length(valid_options)
+    if(strcmp(nth(valid_options,ii),opt))
+      n = nth(valid_values,ii);
+      valid_opt = 1;
       if(ii > 1 & nargout > 1)
         warning("opt=%s, %d output arguments requested",opt,nargout);
       endif
     endif
   endfor
-  if(!legal_opt)
-    error("illegal option passed = %s",opt);
+
+  if (! valid_opt)
+    error ("invalid option passed = %s", opt);
   endif
 
 endfunction
diff --git a/scripts/control/sysgetsignals.m b/scripts/control/sysgetsignals.m
--- a/scripts/control/sysgetsignals.m
+++ b/scripts/control/sysgetsignals.m
@@ -177,17 +177,17 @@ function [stname, inname, outname, yd] =
         case(0),
           stname = stname(signum);
         case(1),
           if(length(signum) > 1)
             error("strflg=1, length(signum) = %d",length(signum));
           endif
           stname = nth(stname,signum);
         otherwise,
-          error("Illegal value of strflg=%e",strflg);
+          error ("invalid value of strflg = %e", strflg);
         endswitch
 
       endif
     endif
   endif
 
 endfunction
 
diff --git a/scripts/control/sysidx.m b/scripts/control/sysidx.m
--- a/scripts/control/sysidx.m
+++ b/scripts/control/sysidx.m
@@ -1,34 +1,54 @@
-function idxvec = sysidx(sys,sigtype,signamelist)
-# idxvec = sysidx(sys,sigtype,signamelist)
-# return indices of signals with specified signal names
-# inputs:
-#   sys:         OCST system data structure
-#   sigtype:     signal type to be selected: "in", "out", "st"
-#   signamelist: list of desired signal names
-# outputs:
-#   idxvec: vector of signal indices (appropriate for use with sysprune)
+## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-if(nargin != 3)
-  usage("idxvec = sysidx(sys,sigtype,signamelist)");
-elseif(!is_struct(sys))
-  error("sys must be a system data structure");
-elseif(!isstr(sigtype))
-  error("sigtype must be a string");
-elseif(rows(sigtype) != 1)
-  error("sigtype (%d x %d) must be a single string", ...
-    rows(sigtype),columns(sigtype));
-end
+## idxvec = sysidx (sys, sigtype, signamelist)
+## return indices of signals with specified signal names
+## inputs:
+##   sys:         OCST system data structure
+##   sigtype:     signal type to be selected: "in", "out", "st"
+##   signamelist: list of desired signal names
+## outputs:
+##   idxvec: vector of signal indices (appropriate for use with sysprune)
+
+function idxvec = sysidx (sys, sigtype, signamelist)
 
-# extract correct set of signal names values
-[idxvec,msg] = listidx( list("in","out","st","yd"), sigtype);
-if(msg)
-  error("Illegal sigtype=%s",sigtype);
-endif
+  if (nargin != 3)
+    usage ("idxvec = sysidx (sys, sigtype, signamelist)");
+  elseif (! is_struct (sys))
+    error ("sys must be a system data structure");
+  elseif (! isstr (sigtype))
+    error ("sigtype must be a string");
+  elseif (rows (sigtype) != 1)
+    [nr, nc] = size (sigtype);
+    error ("sigtype (%d x %d) must be a single string", nr, nc);
+  endif
 
-syssiglist = sysgetsignals(sys,sigtype);
-[idxvec,msg] = listidx(syssiglist,signamelist);
-if(length(msg))
-  error("sysidx(sigtype=%s): %s",sigtype, strrep(msg,"strlist","signamelist"));
-end
+  ## extract correct set of signal names values
+  [idxvec, msg] = listidx (list ("in", "out", "st", "yd"), sigtype);
+  if (msg)
+    error ("invalid sigtype = %s", sigtype);
+  endif
+
+  syssiglist = sysgetsignals (sys, sigtype);
+  [idxvec, msg] = listidx (syssiglist, signamelist);
+  if (length (msg))
+    error ("sysidx (sigtype = %s): %s", sigtype,
+	   strrep (msg, "strlist", "signamelist"));
+  endif
 
 endfunction
diff --git a/scripts/control/sysmin.m b/scripts/control/sysmin.m
--- a/scripts/control/sysmin.m
+++ b/scripts/control/sysmin.m
@@ -160,17 +160,17 @@ function [retsys, nc, no, cflg, oflg] = 
     case(1),
       ## reduced model with physical states
       [cflg,Uc] = is_controllable(sys); xc = find(max(abs(Uc')) != 0);
       [oflg,Uo] = is_observable(sys);   xo = find(max(abs(Uo')) != 0);
       xx = intersection(xc,xo);
       if(isempty(xx)) xx = 0;  endif    # signal no states in reduced model
       retsys = sysprune(sys,[],[],xx);
     otherwise,
-      error("illegal value of flg=%d",flg);
+      error ("invalid value of flg = %d", flg);
     endswitch
     if(sysdimensions(retsys,"st") > 0)
       [cflg,Uc] = is_controllable(retsys); nc = columns(Uc);
       [oflg,Uo] = is_observable(retsys);   no = columns(Uo);
     else
       nc = no = 0;
     endif
   endif
diff --git a/scripts/control/sysprune.m b/scripts/control/sysprune.m
--- a/scripts/control/sysprune.m
+++ b/scripts/control/sysprune.m
@@ -112,17 +112,17 @@ function sys = sysprune (sys, output_idx
         num2str(mm)," inputs"]);
   elseif(nn+nz < lst)
     error([num2str(lst)," state_idx entries, system has only ", ...
         num2str(nn+nz)," states"]);
   endif
 
   [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
 
-  ## check for legal state permutation
+  ## check for valid state permutation
   if(nn & nz)
     c_idx = find(state_idx <= nn);
     if(!isempty(c_idx)) max_c = max(c_idx);
     else                max_c = 0;            endif
     d_idx = find(state_idx > nn);
     if(!isempty(d_idx)) min_d = min(d_idx);
     else                min_d = nn+nz;            endif
     if(max_c > min_d)
diff --git a/scripts/control/syssetsignals.m b/scripts/control/syssetsignals.m
--- a/scripts/control/syssetsignals.m
+++ b/scripts/control/syssetsignals.m
@@ -185,17 +185,17 @@ function retsys = syssetsignals (sys, op
       endif
 
       badidx = find(names != 0 & names != 1);
       if(! isempty(badidx) )
         for ii=1:length(badidx)
           warning("syssetsignals: opt=yd: names(%d)=%e, must be 0 or 1", ...
             badidx(ii), names(badidx(ii)) );
         endfor
-        error("opt=yd: illegal values in names");
+        error ("opt=yd: invalid values in names");
       endif
 
       for ii=1:length(sig_idx)
         jj = sig_idx(ii);
         if(jj < 1 | jj > nsigs | jj != floor(jj))
           error("sig_idx(%d)=%d, %e: must be an integer between 1 and %d", ...
             ii,jj, jj, nsigs);
         endif
diff --git a/scripts/control/tzero2.m b/scripts/control/tzero2.m
--- a/scripts/control/tzero2.m
+++ b/scripts/control/tzero2.m
@@ -29,17 +29,17 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function zr = tzero2 (a, b, c, d, bal)
 
   if (nargin == 4)
     bal = "B";
   elseif (nargin != 5)
-    error ("tzero: illegal number of arguments");
+    error ("tzero: invalid number of arguments");
   endif
 
   [n, m, p] = abcddim (a, b, c, d);
 
   if (n > 0 && m > 0 && p > 0)
     if (m != p)
       fprintf (stderr, "tzero: number of inputs,outputs differ.  squaring up");
       if (p > m)
diff --git a/scripts/gethelp.cc b/scripts/gethelp.cc
--- a/scripts/gethelp.cc
+++ b/scripts/gethelp.cc
@@ -5,34 +5,34 @@
 #define NPOS string::npos
 #endif
 
 static bool
 looks_like_octave_copyright (const string& s)
 {
   bool retval = false;
 
-  string t = s.substr (0, 15);
+  string t = s.substr (0, 14);
 
-  if (t == " Copyright (C) ")
+  if (t == "Copyright (C) ")
     {
       size_t pos = s.find ('\n');
 
       if (pos != NPOS)
 	{
 	  pos = s.find ('\n', pos + 1);
 
 	  if (pos != NPOS)
 	    {
 	      pos++;
 
-	      t = s.substr (pos, 29);
+	      t = s.substr (pos, 28);
 
-	      if (t == " This file is part of Octave."
-		  || t == " This program is free softwar")
+	      if (t == "This file is part of Octave."
+		  || t == "This program is free softwar")
 		retval = true;
 	    }
 	}
     }
 
   return retval;
 }
 
@@ -43,39 +43,46 @@ static string
 extract_help_text (void)
 {
   string help_txt;
 
   bool first_comments_seen = false;
   bool begin_comment = false;
   bool have_help_text = false;
   bool in_comment = false;
+  bool discard_space = true;
   int c;
 
   while ((c = cin.get ()) != EOF)
     {
       if (begin_comment)
 	{
 	  if (c == '%' || c == '#')
 	    continue;
+	  else if (discard_space && c == ' ')
+	    {
+	      discard_space = false;
+	      continue;
+	    }
 	  else
 	    begin_comment = false;
 	}
 
       if (in_comment)
 	{
 	  if (! have_help_text)
 	    {
 	      first_comments_seen = true;
 	      help_txt += (char) c;
 	    }
 
 	  if (c == '\n')
 	    {
 	      in_comment = false;
+	      discard_space = true;
 
 	      if ((c = cin.get ()) != EOF)
 		{
 		  if (c == '\n')
 		    break;
 		}
 	      else
 		break;
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -1,64 +1,64 @@
-# Copyright (C) 1995, 1998 A. Scottedward Hodel
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1995, 1998 A. Scottedward Hodel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-function [housv,beta,zer] = housh(x,j,z)
-  # function [housv,beta,zer] = housh(x,j,z)
-  # computes householder reflection vector housv to reflect x to be
-  # jth column of identity, i.e., (I - beta*housv*housv')x =e(j)
-  # inputs
-  #   x: vector
-  #   j: index into vector
-  #   z: threshold for zero  (usually should be the number 0)
-  # outputs: (see Golub and Van Loan)
-  #   beta: If beta = 0, then no reflection need be applied (zer set to 0)
-  #   housv: householder vector
-  # mar 6,1987 : rev dec 17,1988
-  #             rev sep 19,1991 (blas)
-  # translated from FORTRAN Aug 1995
-  # A. S. Hodel
+## function [housv,beta,zer] = housh(x,j,z)
+## computes householder reflection vector housv to reflect x to be
+## jth column of identity, i.e., (I - beta*housv*housv')x =e(j)
+## inputs
+##   x: vector
+##   j: index into vector
+##   z: threshold for zero  (usually should be the number 0)
+## outputs: (see Golub and Van Loan)
+##   beta: If beta = 0, then no reflection need be applied (zer set to 0)
+##   housv: householder vector
+## mar 6,1987 : rev dec 17,1988
+##             rev sep 19,1991 (blas)
+## translated from FORTRAN Aug 1995
 
-  # $Revision: 1.1.1.1 $
-  # $Log$
+## Author: A. S. Hodel
+
+function [housv, beta, zer] = housh (x, j, z)
 
-  # check for legal inputs
-  if( !is_vector(x) && !is_scalar(x))
-    error("housh: first input must be a vector")
-  elseif( !is_scalar(j) )
-    error("housh: second argment must be an integer scalar")
+  ## check for valid inputs
+  if (!is_vector (x) && ! is_scalar (x))
+    error ("housh: first input must be a vector")
+  elseif (! is_scalar(j))
+    error ("housh: second argment must be an integer scalar")
   else
     housv = x;
-    m = max(abs(housv));
-    if (m ~= 0.0)
-      housv = housv/m;
-      alpha = norm(housv);
+    m = max (abs (housv));
+    if (m != 0.0)
+      housv = housv / m;
+      alpha = norm (housv);
       if (alpha > z)
-        beta = 1.0/(alpha*(alpha+abs(housv(j))));
-        sg = sign(housv(j));
-        if( sg == 0)
+        beta = 1.0 / (alpha * (alpha + abs (housv(j))));
+        sg = sign (housv(j));
+        if (sg == 0)
           sg = 1;
         endif
         housv(j) = housv(j) + alpha*sg;
       else
         beta = 0.0;
       endif
     else
       beta = 0.0;
     endif
     zer = (beta == 0);
   endif
+
 endfunction
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -1,50 +1,51 @@
-# Copyright (C) 1993, 1998, 1999 Auburn University.  All rights reserved.
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1998, 1999 Auburn University.  All rights reserved.
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
+## function [U,H,nu] = krylov(A,V,k{,eps1,pflg});
+## construct orthogonal basis U of block Krylov subspace;
+##  [V AV A^2*V ... A^(k+1)*V];
+## method used: householder reflections to guard against loss of
+## orthogonality
+## eps1: threshhold for 0 (default: 1e-12)
+## pflg: flag to use row pivoting  (improves numerical behavior)
+##   0 [default]: no pivoting; prints a warning message if trivial
+##                null space is corrupted
+##   1          : pivoting performed
+##
+## outputs:
+##   Uret: orthogonal basis of block krylov subspace
+##   H: Hessenberg matrix; if V is a vector then A U = U H
+##      otherwise H is meaningless
+## nu: dimension of span of krylov subspace (based on eps1)
+## if B is a vector and k > m-1, krylov returns H = the Hessenberg
+## decompostion of A.
+##
+## Reference: Hodel and Misra, "Partial Pivoting in the Computation of
+##     Krylov Subspaces", to be submitted to Linear Algebra and its
+##     Applications
+## written by A. Scottedward Hodel a.s.hodel@eng.auburn.edu
 
 function [Uret,H,nu] = krylov(A,V,k,eps1,pflg);
-  # function [U,H,nu] = krylov(A,V,k{,eps1,pflg});
-  # construct orthogonal basis U of block Krylov subspace;
-  #  [V AV A^2*V ... A^(k+1)*V];
-  # method used: householder reflections to guard against loss of
-  # orthogonality
-  # eps1: threshhold for 0 (default: 1e-12)
-  # pflg: flag to use row pivoting  (improves numerical behavior)
-  #   0 [default]: no pivoting; prints a warning message if trivial
-  #                null space is corrupted
-  #   1          : pivoting performed
-  #
-  # outputs:
-  #   Uret: orthogonal basis of block krylov subspace
-  #   H: Hessenberg matrix; if V is a vector then A U = U H
-  #      otherwise H is meaningless
-  # nu: dimension of span of krylov subspace (based on eps1)
-  # if B is a vector and k > m-1, krylov returns H = the Hessenberg
-  # decompostion of A.
-  #
-  # Reference: Hodel and Misra, "Partial Pivoting in the Computation of
-  #     Krylov Subspaces", to be submitted to Linear Algebra and its
-  #     Applications
-  # written by A. Scottedward Hodel a.s.hodel@eng.auburn.edu
 
   defeps = 1e-12;
   if(nargin < 3 | nargin > 5)
     usage("[U,nu] = krylov(A,V,k{,eps1,pflg})")
   elseif(nargin < 5)
     pflg = 0;        # default permutation flag
   endif
   if(nargin < 4)
diff --git a/scripts/linear-algebra/krylovb.m b/scripts/linear-algebra/krylovb.m
--- a/scripts/linear-algebra/krylovb.m
+++ b/scripts/linear-algebra/krylovb.m
@@ -1,47 +1,47 @@
-# Copyright (C) 1993, 1998, 1999 A. Scottedward Hodel
-#
-# This file is part of Octave.
-#
-# Octave is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2, or (at your option) any
-# later version.
-#
-# Octave is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Octave; see the file COPYING.  If not, write to the Free
-# Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+## Copyright (C) 1993, 1998, 1999 A. Scottedward Hodel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-function [Uret,Ucols] = krylovb(A,V,k,eps1,pflg);
-  # function [U,Ucols] = krylovb(A,V,k{,eps1,pflg});
-  # construct orthogonal basis U of block Krylov subspace;
-  #     [V AV A^2*V ... A^(k+1)*V];
-  # method used: householder reflections to guard against loss of
-  # orthogonality
-  # eps1: threshhold for 0 (default: 1e-12)
-  # pflg: permutation flag
-  # outputs:
-  #   returned basis U is orthogonal matrix; due to "zeroed"
-  #   columns of product, may not satisfy A U = U H identity
-  # Ucols: dimension of span of krylov subspace (based on eps1)
-  # if k > m-1, krylov returns the Hessenberg decompostion of A.
-  #
-  # Note: krylovb directly calls and is superseded by krylov.
+## function [U, Ucols] = krylovb (A, V, k ,eps1, pflg);
+## construct orthogonal basis U of block Krylov subspace;
+## [V AV A^2*V ... A^(k+1)*V];
+## method used: householder reflections to guard against loss of
+## orthogonality
+## eps1: threshhold for 0 (optional, default: 1e-12)
+## pflg: permutation flag (optional)
+## outputs:
+## returned basis U is orthogonal matrix; due to "zeroed"
+## columns of product, may not satisfy A U = U H identity
+## Ucols: dimension of span of krylov subspace (based on eps1)
+## if k > m-1, krylov returns the Hessenberg decompostion of A.
+##
+## Note: krylovb directly calls and is superseded by krylov.
 
-  switch(nargin)
-  case(3),
-    [Uret,H,Ucols] = krylov(A,V,k);
-  case(4),
-    [Uret,H,Ucols] = krylov(A,V,k,eps1);
-  case(5),
-    [Uret,H,Ucols] = krylov(A,V,k,eps1,pflg);
-  otherwise,
-    usage("[Uret,Ucols] = krylovb(A,V,k{,eps1,pflg}); %d arguments passed", ...
-      nargin);
+function [Uret, Ucols] = krylovb (A, V, k, eps1, pflg)
+
+  switch (nargin)
+    case (3)
+      [Uret, H, Ucols] = krylov (A, V, k);
+    case (4)
+      [Uret, H, Ucols] = krylov (A, V, k, eps1);
+    case (5)
+      [Uret, H, Ucols] = krylov (A, V, k, eps1, pflg);
+    otherwise
+      usage ("[Uret, Ucols] = krylovb (A, V, k ,eps1, pflg));
   endswitch
 
 endfunction
diff --git a/scripts/quaternion/demoquat.m b/scripts/quaternion/demoquat.m
--- a/scripts/quaternion/demoquat.m
+++ b/scripts/quaternion/demoquat.m
@@ -222,12 +222,12 @@ while(opt != quitopt)
       #eval(sprintf("gset output 'fig%d.eps'",kk));
       #replot
       #gset terminal x11
       #prompt
     endfor
   case(quitopt),
     printf("Exiting quaternion demo\n");
   otherwise,
-    error(sprintf("Illegal option %f",opt));
+    error ("invalid option %f", opt);
   endswitch    
 endwhile
 endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,14 @@
+2000-01-13  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* parse.y (gobble_leading_whitespace): Discard first space character
+	after consecutive comment characters.
+	* lex.l (grab_help_text): Ditto.
+
 2000-01-11  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* ov.h, ov.cc (octave_value::column_vector_value,
 	octave_value::row_vector_value,
 	octave_value::complex_column_vector_value,
 	octave_value::complex_row_vector_value): New functions.
 	(octave_value::vector_value): Now returns Array<double>.
 	(octave_value::complex_vector_value): Now returns Array<Complex>.
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -245,17 +245,17 @@ See also: balance, dare, eig, schur\n\
 
   if (nargin < 2 || nargin > 3 || nargout > 7)
     {
       print_usage ("qz");
       return retval;
     }
   else if (nargin == 3 && (nargout < 3 || nargout > 4))
     {
-      error ("qz: Illegal number of output arguments for form [3] call");
+      error ("qz: invalid number of output arguments for form [3] call");
       return retval;
     }
 
 #ifdef DEBUG
   cout << "qz: determine ordering option" << endl;
 #endif
 
   // Determine ordering option
@@ -274,17 +274,17 @@ See also: balance, dare, eig, schur\n\
       ord_job = args(2).string_value ();
 
       if (ord_job[0] != 'N'
 	  && ord_job[0] != 'S'
 	  && ord_job[0] != 'B'
 	  && ord_job[0] != '+'
 	  && ord_job[0] != '-')
 	{
-	  error ("qz: illegal order option");
+	  error ("qz: invalid order option");
 	  return retval;
 	}
 
       // overflow constant required by dlag2
       F77_FCN (xdlamch, XDLAMCH) ("S", safmin, 1L);
 
 #ifdef DEBUG_EIG
       cout << "qz: initial value of safmin=" << setiosflags (ios::scientific)
@@ -595,17 +595,17 @@ See also: balance, dare, eig, schur\n\
 	      sort_test = &fcrhp;
 	      break;
 
 	    case '-':
 	      sort_test = &folhp;
 	      break;
 
 	    default:
-	      // illegal order option (should never happen, since we
+	      // invalid order option (should never happen, since we
 	      // checked the options at the top).
 	      panic_impossible ();
 	      break;
       }
 
 	  int ndim, fail, ind[nn];
 	  double inf_norm;
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -1168,44 +1168,53 @@ force_local_variable (const string& name
 
   if (sr)
     sr->define (octave_value ());
 }
 
 // Grab the help text from an function file.  Always overwrites the
 // current contents of help_buf.
 
-// XXX FIXME XXX -- gobble_leading_white_space() in variables.cc
+// XXX FIXME XXX -- gobble_leading_white_space() in parse.y
 // duplicates some of this code!
 
 static void
 grab_help_text (void)
 {
   help_buf.resize (0);
 
   bool begin_comment = true;
   bool in_comment = true;
+  bool discard_space = true;
   int c = 0;
 
   while ((c = yyinput ()) != EOF)
     {
       if (begin_comment)
 	{
 	  if (c == '%' || c == '#')
 	    continue;
+	  else if (discard_space && c == ' ')
+	    {
+	      discard_space = false;
+	      continue;
+	    }
 	  else
 	    begin_comment = false;
 	}	
 
       if (in_comment)
 	{
 	  help_buf += (char) c;
 
 	  if (c == '\n')
-	    in_comment = false;
+	    {
+	      in_comment = false;
+	      discard_space = true;
+	    }
 	}
       else
 	{
 	  switch (c)
 	    {
 	    case '%':
 	    case '#':
 	      in_comment = true;
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -2713,34 +2713,34 @@ parse_and_execute (const string& s, bool
   unwind_protect::run_frame ("parse_and_execute_2");
 }
 
 static bool
 looks_like_octave_copyright (const string& s)
 {
   bool retval = false;
 
-  string t = s.substr (0, 15);
-
-  if (t == " Copyright (C) ")
+  string t = s.substr (0, 14);
+
+  if (t == "Copyright (C) ")
     {
       size_t pos = s.find ('\n');
 
       if (pos != NPOS)
 	{
 	  pos = s.find ('\n', pos + 1);
 
 	  if (pos != NPOS)
 	    {
 	      pos++;
 
-	      t = s.substr (pos, 29);
-
-	      if (t == " This file is part of Octave."
-		  || t == " This program is free softwar")
+	      t = s.substr (pos, 28);
+
+	      if (t == "This file is part of Octave."
+		  || t == "This program is free softwar")
 		retval = true;
 	    }
 	}
     }
 
   return retval;
 }
 
@@ -2757,27 +2757,33 @@ static string
 gobble_leading_white_space (FILE *ffile, bool in_parts, bool update_pos)
 {
   string help_txt;
 
   bool first_comments_seen = false;
   bool begin_comment = false;
   bool have_help_text = false;
   bool in_comment = false;
+  bool discard_space = true;
   int c;
 
   while ((c = getc (ffile)) != EOF)
     {
       if (update_pos)
 	current_input_column++;
 
       if (begin_comment)
 	{
 	  if (c == '%' || c == '#')
 	    continue;
+	  else if (discard_space && c == ' ')
+	    {
+	      discard_space = false;
+	      continue;
+	    }
 	  else
 	    begin_comment = false;
 	}
 
       if (in_comment)
 	{
 	  if (! have_help_text)
 	    {
@@ -2787,17 +2793,19 @@ gobble_leading_white_space (FILE *ffile,
 
 	  if (c == '\n')
 	    {
 	      if (update_pos)
 		{
 		  input_line_number++;
 		  current_input_column = 0;
 		}
+
 	      in_comment = false;
+	      discard_space = true;
 
 	      if (in_parts)
 		{
 		  if ((c = getc (ffile)) != EOF)
 		    {
 		      if (update_pos)
 			current_input_column--;
 		      ungetc (c, ffile);
