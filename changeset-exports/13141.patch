# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1316105470 14400
#      Thu Sep 15 12:51:10 2011 -0400
# Node ID e81ddf9cacd5f2122005ede1f3672736db8867b8
# Parent  98d23b0f16e1ec799fab9cd51cca14bab1a33390
maint: untabify and remove trailing whitespace from source files

* bicg.m, gmres.m, pkg.m: Untabify and remove trailing whitespace.

* libcruft/Makefile.am, libcruft/blas-xtra/cdotc3.f,
libcruft/blas-xtra/cmatm3.f, libcruft/blas-xtra/ddot3.f,
libcruft/blas-xtra/dmatm3.f, libcruft/blas-xtra/sdot3.f,
libcruft/blas-xtra/smatm3.f, libcruft/blas-xtra/zdotc3.f,
libcruft/blas-xtra/zmatm3.f, libcruft/lapack-xtra/crsf2csf.f,
libcruft/lapack-xtra/zrsf2csf.f, liboctave/Array.cc,
liboctave/DASPK-opts.in, liboctave/DASRT-opts.in,
liboctave/DASSL-opts.in, liboctave/LSODE-opts.in,
liboctave/Makefile.a,mliboctave/Quad-opts.in,
liboctave/Sparse-perm-op-defs.h,
scripts/Makefile.a,mscripts/deprecated/glpkmex.m,
scripts/general/blkdiag.m, scripts/general/interp1.m,
scripts/general/profshow.m, scripts/general/quadl.m,
scripts/general/triplequad.m, scripts/help/__makeinfo__.m,
scripts/io/strread.m, scripts/io/textread.m, scripts/io/textscan.m,
scripts/linear-algebra/rank.m, scripts/miscellaneous/gzip.m,
scripts/miscellaneous/private/__xzip__.m,
scripts/miscellaneous/tempdir.m, scripts/miscellaneous/unpack.m,
scripts/pkg/pkg.m, scripts/plot/allchild.m, scripts/plot/ancestor.m,
scripts/plot/cla.m, scripts/plot/clf.m, scripts/plot/findall.m,
scripts/plot/findobj.m, scripts/plot/gca.m, scripts/plot/gcf.m,
scripts/plot/hggroup.m, scripts/plot/isfigure.m,
scripts/plot/ishghandle.m, scripts/plot/legend.m,
scripts/plot/line.m, scripts/plot/loglog.m, scripts/plot/patch.m,
scripts/plot/print.m, scripts/plot/private/__quiver__.m,
scripts/plot/private/__scatter__.m, scripts/plot/rectangle.m,
scripts/plot/semilogx.m, scripts/plot/semilogy.m,
scripts/plot/surface.m, scripts/plot/text.m, scripts/plot/title.m,
scripts/plot/trisurf.m, scripts/plot/view.m, scripts/plot/whitebg.m,
scripts/plot/xlabel.m, scripts/plot/xlim.m, scripts/plot/ylabel.m,
scripts/plot/ylim.m, scripts/plot/zlabel.m, scripts/plot/zlim.m,
scripts/polynomial/mkpp.m, scripts/polynomial/polygcd.m,
scripts/polynomial/ppint.m, scripts/polynomial/ppjumps.m,
scripts/polynomial/ppval.m, scripts/set/setxor.m,
scripts/sparse/bicgstab.m, scripts/sparse/cgs.m,
scripts/sparse/spconvert.m, scripts/specfun/nthroot.m,
scripts/strings/strmatch.m, scripts/strings/untabify.m,
scripts/testfun/demo.m, scripts/testfun/example.m,
src/DLD-FUNCTIONS/filter.cc, src/DLD-FUNCTIONS/mgorth.cc,
src/DLD-FUNCTIONS/quadcc.cc, src/DLD-FUNCTIONS/str2double.cc,
src/Makefile.a,msrc/gl-render.cc, src/gl2ps-renderer.cc,
src/graphics.cc, src/octave-config.cc.in, src/octave-config.in,
src/ov-class.h, src/ov-fcn.h, src/profiler.cc, src/profiler.h,
src/pt-binop.cc, src/pt-unop.cc, src/symtab.cc, src/txt-eng-ft.cc:
Remove trailing whitespace.

diff --git a/libcruft/Makefile.am b/libcruft/Makefile.am
--- a/libcruft/Makefile.am
+++ b/libcruft/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for octave's libcruft directory
 #
 # Copyright (C) 1993-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 AM_CPPFLAGS = @CPPFLAGS@ -I../libgnu -I$(top_srcdir)/libgnu
 
diff --git a/libcruft/blas-xtra/cdotc3.f b/libcruft/blas-xtra/cdotc3.f
--- a/libcruft/blas-xtra/cdotc3.f
+++ b/libcruft/blas-xtra/cdotc3.f
@@ -14,17 +14,17 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine cdotc3(m,n,k,a,b,c)
-c purpose:      a 3-dimensional dot product. 
+c purpose:      a 3-dimensional dot product.
 c               c = sum (conj (a) .* b, 2), where a and b are 3d arrays.
 c arguments:
 c m,n,k (in)    the dimensions of a and b
 c a,b (in)      complex input arrays of size (m,k,n)
 c c (out)       complex output array, size (m,n)
       integer m,n,k,i,j,l
       complex a(m,k,n),b(m,k,n)
       complex c(m,n)
diff --git a/libcruft/blas-xtra/cmatm3.f b/libcruft/blas-xtra/cmatm3.f
--- a/libcruft/blas-xtra/cmatm3.f
+++ b/libcruft/blas-xtra/cmatm3.f
@@ -14,27 +14,27 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine cmatm3(m,n,k,np,a,b,c)
-c purpose:      a 3-dimensional matrix product. 
+c purpose:      a 3-dimensional matrix product.
 c               given a (m,k,np) array a and (k,n,np) array b,
 c               calculates a (m,n,np) array c such that
 c                 for i = 1:np
 c                 c(:,:,i) = a(:,:,i) * b(:,:,i)
 c
 c arguments:
 c m,n,k (in)    the dimensions
 c np (in)       number of multiplications
-c a (in)        a complex input array, size (m,k,np) 
-c b (in)        a complex input array, size (k,n,np) 
+c a (in)        a complex input array, size (m,k,np)
+c b (in)        a complex input array, size (k,n,np)
 c c (out)       a complex output array, size (m,n,np)
       integer m,n,k,np
       complex a(m*k,np),b(k*n,np)
       complex c(m*n,np)
 
       complex cdotu,one,zero
       parameter (one = 1e0, zero = 0e0)
       external cdotu,cgemv,cgemm
diff --git a/libcruft/blas-xtra/ddot3.f b/libcruft/blas-xtra/ddot3.f
--- a/libcruft/blas-xtra/ddot3.f
+++ b/libcruft/blas-xtra/ddot3.f
@@ -14,17 +14,17 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine ddot3(m,n,k,a,b,c)
-c purpose:      a 3-dimensional dot product. 
+c purpose:      a 3-dimensional dot product.
 c               c = sum (a .* b, 2), where a and b are 3d arrays.
 c arguments:
 c m,n,k (in)    the dimensions of a and b
 c a,b (in)      double prec. input arrays of size (m,k,n)
 c c (out)       double prec. output array, size (m,n)
       integer m,n,k,i,j,l
       double precision a(m,k,n),b(m,k,n)
       double precision c(m,n)
diff --git a/libcruft/blas-xtra/dmatm3.f b/libcruft/blas-xtra/dmatm3.f
--- a/libcruft/blas-xtra/dmatm3.f
+++ b/libcruft/blas-xtra/dmatm3.f
@@ -14,27 +14,27 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine dmatm3(m,n,k,np,a,b,c)
-c purpose:      a 3-dimensional matrix product. 
+c purpose:      a 3-dimensional matrix product.
 c               given a (m,k,np) array a and (k,n,np) array b,
 c               calculates a (m,n,np) array c such that
 c                 for i = 1:np
 c                 c(:,:,i) = a(:,:,i) * b(:,:,i)
 c
 c arguments:
 c m,n,k (in)    the dimensions
 c np (in)       number of multiplications
-c a (in)        a double prec. input array, size (m,k,np) 
-c b (in)        a double prec. input array, size (k,n,np) 
+c a (in)        a double prec. input array, size (m,k,np)
+c b (in)        a double prec. input array, size (k,n,np)
 c c (out)       a double prec. output array, size (m,n,np)
       integer m,n,k,np
       double precision a(m*k,np),b(k*n,np)
       double precision c(m*n,np)
 
       double precision ddot,one,zero
       parameter (one = 1d0, zero = 0d0)
       external ddot,dgemv,dgemm
diff --git a/libcruft/blas-xtra/sdot3.f b/libcruft/blas-xtra/sdot3.f
--- a/libcruft/blas-xtra/sdot3.f
+++ b/libcruft/blas-xtra/sdot3.f
@@ -14,17 +14,17 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine sdot3(m,n,k,a,b,c)
-c purpose:      a 3-dimensional dot product. 
+c purpose:      a 3-dimensional dot product.
 c               c = sum (a .* b, 2), where a and b are 3d arrays.
 c arguments:
 c m,n,k (in)    the dimensions of a and b
 c a,b (in)      real input arrays of size (m,k,n)
 c c (out)       real output array, size (m,n)
       integer m,n,k,i,j,l
       real a(m,k,n),b(m,k,n)
       real c(m,n)
diff --git a/libcruft/blas-xtra/smatm3.f b/libcruft/blas-xtra/smatm3.f
--- a/libcruft/blas-xtra/smatm3.f
+++ b/libcruft/blas-xtra/smatm3.f
@@ -14,27 +14,27 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine smatm3(m,n,k,np,a,b,c)
-c purpose:      a 3-dimensional matrix product. 
+c purpose:      a 3-dimensional matrix product.
 c               given a (m,k,np) array a and (k,n,np) array b,
 c               calculates a (m,n,np) array c such that
 c                 for i = 1:np
 c                 c(:,:,i) = a(:,:,i) * b(:,:,i)
 c
 c arguments:
 c m,n,k (in)    the dimensions
 c np (in)       number of multiplications
-c a (in)        a real input array, size (m,k,np) 
-c b (in)        a real input array, size (k,n,np) 
+c a (in)        a real input array, size (m,k,np)
+c b (in)        a real input array, size (k,n,np)
 c c (out)       a real output array, size (m,n,np)
       integer m,n,k,np
       real a(m*k,np),b(k*n,np)
       real c(m*n,np)
 
       real sdot,one,zero
       parameter (one = 1e0, zero = 0e0)
       external sdot,sgemv,sgemm
diff --git a/libcruft/blas-xtra/zdotc3.f b/libcruft/blas-xtra/zdotc3.f
--- a/libcruft/blas-xtra/zdotc3.f
+++ b/libcruft/blas-xtra/zdotc3.f
@@ -14,17 +14,17 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine zdotc3(m,n,k,a,b,c)
-c purpose:      a 3-dimensional dot product. 
+c purpose:      a 3-dimensional dot product.
 c               c = sum (conj (a) .* b, 2), where a and b are 3d arrays.
 c arguments:
 c m,n,k (in)    the dimensions of a and b
 c a,b (in)      double complex input arrays of size (m,k,n)
 c c (out)       double complex output array, size (m,n)
       integer m,n,k,i,j,l
       double complex a(m,k,n),b(m,k,n)
       double complex c(m,n)
diff --git a/libcruft/blas-xtra/zmatm3.f b/libcruft/blas-xtra/zmatm3.f
--- a/libcruft/blas-xtra/zmatm3.f
+++ b/libcruft/blas-xtra/zmatm3.f
@@ -14,27 +14,27 @@ c but WITHOUT ANY WARRANTY; without even
 c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 c GNU General Public License for more details.
 c
 c You should have received a copy of the GNU General Public License
 c along with this software; see the file COPYING.  If not, see
 c <http://www.gnu.org/licenses/>.
 c
       subroutine zmatm3(m,n,k,np,a,b,c)
-c purpose:      a 3-dimensional matrix product. 
+c purpose:      a 3-dimensional matrix product.
 c               given a (m,k,np) array a and (k,n,np) array b,
 c               calculates a (m,n,np) array c such that
 c                 for i = 1:np
 c                 c(:,:,i) = a(:,:,i) * b(:,:,i)
 c
 c arguments:
 c m,n,k (in)    the dimensions
 c np (in)       number of multiplications
-c a (in)        a double complex input array, size (m,k,np) 
-c b (in)        a double complex input array, size (k,n,np) 
+c a (in)        a double complex input array, size (m,k,np)
+c b (in)        a double complex input array, size (k,n,np)
 c c (out)       a double complex output array, size (m,n,np)
       integer m,n,k,np
       double complex a(m*k,np),b(k*n,np)
       double complex c(m*n,np)
 
       double complex zdotu,one,zero
       parameter (one = 1d0, zero = 0d0)
       external zdotu,zgemv,zgemm
diff --git a/libcruft/lapack-xtra/crsf2csf.f b/libcruft/lapack-xtra/crsf2csf.f
--- a/libcruft/lapack-xtra/crsf2csf.f
+++ b/libcruft/lapack-xtra/crsf2csf.f
@@ -27,27 +27,27 @@ c
        integer j
        j = 1
        do while (j < n)
 c apply previous rotations to rows
          call crcrot1(j,t(1,j),c,s)
 
          y = t(j+1,j)
          if (y /= 0) then
-c 2x2 block, form Givens rotation [c, i*s; i*s, c] 
+c 2x2 block, form Givens rotation [c, i*s; i*s, c]
            x = t(j,j)
            z = t(j,j+1)
            c(j) = sqrt(z/(z-y))
            s(j) = sign(sqrt(-y/(z-y)),z)
 c apply new rotation to t(j:j+1,j)
            call crcrot1(2,t(j,j),c(j),s(j))
 c apply all rotations to t(1:j+1,j+1)
            call crcrot1(j+1,t(1,j+1),c,s)
 c apply new rotation to columns j,j+1
-           call crcrot2(j+1,t(1,j),t(1,j+1),c(j),s(j))           
+           call crcrot2(j+1,t(1,j),t(1,j+1),c(j),s(j))
 c zero subdiagonal entry, skip next row
            t(j+1,j) = 0
            c(j+1) = 1
            j = j + 2
          else
            c(j) = 1
            j = j + 1
          end if
diff --git a/libcruft/lapack-xtra/zrsf2csf.f b/libcruft/lapack-xtra/zrsf2csf.f
--- a/libcruft/lapack-xtra/zrsf2csf.f
+++ b/libcruft/lapack-xtra/zrsf2csf.f
@@ -27,27 +27,27 @@ c
        integer j
        j = 1
        do while (j < n)
 c apply previous rotations to rows
          call zrcrot1(j,t(1,j),c,s)
 
          y = t(j+1,j)
          if (y /= 0) then
-c 2x2 block, form Givens rotation [c, i*s; i*s, c] 
+c 2x2 block, form Givens rotation [c, i*s; i*s, c]
            x = t(j,j)
            z = t(j,j+1)
            c(j) = sqrt(z/(z-y))
            s(j) = sign(sqrt(-y/(z-y)),z)
 c apply new rotation to t(j:j+1,j)
            call zrcrot1(2,t(j,j),c(j),s(j))
 c apply all rotations to t(1:j+1,j+1)
            call zrcrot1(j+1,t(1,j+1),c,s)
 c apply new rotation to columns j,j+1
-           call zrcrot2(j+1,t(1,j),t(1,j+1),c(j),s(j))           
+           call zrcrot2(j+1,t(1,j),t(1,j+1),c(j),s(j))
 c zero subdiagonal entry, skip next row
            t(j+1,j) = 0
            c(j+1) = 1
            j = j + 2
          else
            c(j) = 1
            j = j + 1
          end if
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -2480,17 +2480,17 @@ Array<T>::diag (octave_idx_type k) const
                 }
             }
           else
             (*current_liboctave_error_handler)
               ("diag: requested diagonal out of range");
         }
       else
         {
-          // Create diag matrix from vector  
+          // Create diag matrix from vector
           octave_idx_type roff = 0;
           octave_idx_type coff = 0;
           if (k > 0)
             {
               roff = 0;
               coff = k;
             }
           else if (k < 0)
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -1,22 +1,22 @@
 # Copyright (C) 2002-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 CLASS = "DASPK"
 
 INCLUDE = "DAE.h"
 
@@ -257,17 +257,17 @@ option (default is 0).
 END_OPTION
 
 OPTION
   NAME = "inequality constraint types"
   DOC_ITEM
 A vector of the same length as the state specifying the type of
 inequality constraint.  Each element of the vector corresponds to an
 element of the state and should be assigned one of the following
-codes 
+codes
 
 @table @asis
 @item -2
 Less than zero.
 
 @item -1
 Less than or equal to zero.
 
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -1,22 +1,22 @@
 # Copyright (C) 2002-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 CLASS = "DASRT"
 
 INCLUDE = "DAERT.h"
 
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -1,22 +1,22 @@
 # Copyright (C) 2002-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 CLASS = "DASSL"
 
 INCLUDE = "DAE.h"
 
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -1,22 +1,22 @@
 # Copyright (C) 2002-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 CLASS = "LSODE"
 
 INCLUDE = "ODE.h"
 
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for octave's liboctave directory
 #
 # Copyright (C) 1993-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 AM_CPPFLAGS = \
   @CPPFLAGS@ -I../libgnu -I$(top_srcdir)/libgnu \
diff --git a/liboctave/Quad-opts.in b/liboctave/Quad-opts.in
--- a/liboctave/Quad-opts.in
+++ b/liboctave/Quad-opts.in
@@ -1,22 +1,22 @@
 # Copyright (C) 2002-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 CLASS = "Quad"
 
 OPTION
   NAME = "absolute tolerance"
@@ -28,40 +28,40 @@ Absolute tolerance; may be zero for pure
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "relative tolerance"
   DOC_ITEM
 Non-negative relative tolerance.  If the absolute tolerance is zero,
-the relative tolerance must be greater than or equal to 
+the relative tolerance must be greater than or equal to
 @w{@code{max (50*eps, 0.5e-28)}}.
 
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "single precision absolute tolerance"
   DOC_ITEM
-Absolute tolerance for single precision; may be zero for pure relative 
+Absolute tolerance for single precision; may be zero for pure relative
 error test.
 
   END_DOC_ITEM
   TYPE = "float"
   INIT_VALUE = "::sqrt (FLT_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "single precision relative tolerance"
   DOC_ITEM
 Non-negative relative tolerance for single precision.  If the absolute
-tolerance is zero, the relative tolerance must be greater than or equal to 
+tolerance is zero, the relative tolerance must be greater than or equal to
 @w{@code{max (50*eps, 0.5e-28)}}.
   END_DOC_ITEM
   TYPE = "float"
   INIT_VALUE = "::sqrt (FLT_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -37,24 +37,24 @@ SM octinternal_do_mul_colpm_sm (const oc
   octave_sort<octave_idx_type> sort;
 
   for (octave_idx_type j = 0; j <= nc; ++j)
     r.xcidx (j) = a.cidx (j);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_quit ();
-      
+
       OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, r.xcidx(j+1) - r.xcidx(j));
       for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
         {
           sidx[ii++]=i;
           r.xridx (i) = pcol[a.ridx (i)];
         }
-      sort.sort (r.xridx() + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j)); 
+      sort.sort (r.xridx() + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j));
       for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
         r.xdata(i) = a.data (sidx[ii++]);
     }
 
   return r;
 }
 
 template <typename SM>
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for octave's scripts directory
 #
 # Copyright (C) 1993-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 AUTOMAKE_OPTIONS = subdir-objects
 
diff --git a/scripts/deprecated/glpkmex.m b/scripts/deprecated/glpkmex.m
--- a/scripts/deprecated/glpkmex.m
+++ b/scripts/deprecated/glpkmex.m
@@ -27,17 +27,17 @@
 function [xopt, fopt, status, extra] = glpkmex (varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "glpkmex is obsolete and will be removed from a future version of Octave; please use glpk instead");
   endif
-  
+
   ## If there is no input output the version and syntax
   if (nargin < 4 || nargin > 11)
     print_usage ();
     return;
   endif
 
   ## reorder args:
   ##
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blkdiag (@var{A}, @var{B}, @var{C}, @dots{})
 ## Build a block diagonal matrix from @var{A}, @var{B}, @var{C}, @dots{}
 ## All the arguments must be numeric and are two-dimensional matrices or
-## scalars. If any argument is of type sparse, the output will also be 
+## scalars. If any argument is of type sparse, the output will also be
 ## sparse.
 ## @seealso{diag, horzcat, vertcat, sparse}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo
 ## Modified by: William Poetra Yoga Hadisoeseno
 
 function retval = blkdiag (varargin)
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -146,17 +146,17 @@ function yi = interp1 (x, y, varargin)
 
   ## reshape matrices for convenience
   x = x(:);
   nx = rows (x);
   szx = size (xi);
   if (isvector (y))
     y = y(:);
   endif
-  
+
   szy = size (y);
   y = y(:,:);
   [ny, nc] = size (y);
   xi = xi(:);
 
   ## determine sizes
   if (nx < 2 || ny < 2)
     error ("interp1: table too short");
@@ -187,33 +187,33 @@ function yi = interp1 (x, y, varargin)
   endif
 
   ## Proceed with interpolating by all methods.
 
   switch (method)
   case "nearest"
     pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)], shiftdim (y, 1), szy(2:end));
     pp.orient = "first";
-    
+
     if (ispp)
       yi = pp;
     else
       yi = ppval (pp, reshape (xi, szx));
     endif
   case "*nearest"
     pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)], shiftdim (y, 1), szy(2:end));
     pp.orient = "first";
     if (ispp)
       yi = pp;
     else
       yi = ppval(pp, reshape (xi, szx));
     endif
   case "linear"
     dy = diff (y);
-    dx = diff (x);    
+    dx = diff (x);
     dx = repmat (dx, [1 size(dy)(2:end)]);
     coefs = [(dy./dx).'(:), y(1:nx-1, :).'(:)];
     xx = x;
 
     if (have_jumps)
       ## Omit zero-size intervals.
       coefs(jumps, :) = [];
       xx(jumps) = [];
@@ -239,29 +239,29 @@ function yi = interp1 (x, y, varargin)
     else
       yi = ppval(pp, reshape (xi, szx));
     endif
 
   case {"pchip", "*pchip", "cubic", "*cubic"}
     if (nx == 2 || starmethod)
       x = linspace (x(1), x(nx), ny);
     endif
-    
+
     if (ispp)
       y = shiftdim (reshape (y, szy), 1);
       yi = pchip (x, y);
     else
       y = shiftdim (y, 1);
       yi = pchip (x, y, reshape (xi, szx));
     endif
   case {"spline", "*spline"}
     if (nx == 2 || starmethod)
       x = linspace(x(1), x(nx), ny);
     endif
-    
+
     if (ispp)
       y = shiftdim (reshape (y, szy), 1);
       yi = spline (x, y);
     else
       y = shiftdim (y, 1);
       yi = spline (x, y, reshape (xi, szx));
     endif
   otherwise
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -38,17 +38,17 @@
 function profshow (data, n = 20)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   n = fix (n);
   if (! isscalar (n) || ! isreal (n) || ! (n > 0))
-    error ("profile: N must be a positive integer"); 
+    error ("profile: N must be a positive integer");
   endif
 
   m = length (data.FunctionTable);
   n = min (n, m);
 
   ## We want to sort by times in descending order.  For this, extract the
   ## times to an array, then sort this, and use the resulting index permutation
   ## to print out our table.
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -204,14 +204,14 @@ endfunction
 ## the values here are very high so it may be unavoidable that this fails
 %!assert (quadl (@(x) sin (3*x).*cosh (x).*sinh (x),10,15),
 %!         2.588424538641647e+10, -9e-15)
 
 ## extra parameters
 %!assert (quadl (@(x,a,b) sin (a + b*x), 0, 1, [], [], 2, 3),
 %!        cos(2)/3 - cos(5)/3, - 3e-16)
 
-## test different tolerances. 
+## test different tolerances.
 %!assert (quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.3, []),
 %!        (60 + sin(4) - sin(64))/12, -0.3)
 %!assert (quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.1, []),
 %!        (60 + sin(4) - sin(64))/12, -0.1)
 
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -45,17 +45,17 @@
 ## @end deftypefn
 
 function q = triplequad (f, xa, xb, ya, yb, za, zb, tol = 1e-6, quadf = @quadcc, varargin)
 
   if (nargin < 7)
     print_usage ();
   endif
 
-  ## Allow use of empty matrix ([]) to indicate default 
+  ## Allow use of empty matrix ([]) to indicate default
   if (isempty (tol))
     tol = 1e-6;
   endif
   if (isempty (quadf))
     quadf = @quadcc;
   endif
 
   inner = @__triplequad_inner__;
@@ -70,16 +70,16 @@ endfunction
 
 function q = __triplequad_inner__ (y, z, f, xa, xb, tol, quadf, varargin)
   q = zeros (size(y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f (x, y(i), z, varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
- 
+
 %!assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadcc), pi ^ (3/2) * erf(1).^3, 1e-6)
 
 %% These tests are too expensive to run normally (~30 sec each).  Disable them
 #%!assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadgk), pi ^ (3/2) * erf(1).^3, 1e-6)
 #%!#assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadl), pi ^ (3/2) * erf(1).^3, 1e-6)
 #%!#assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadv), pi ^ (3/2) * erf(1).^3, 1e-6)
 
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -67,35 +67,35 @@ function [retval, status] = __makeinfo__
   if (! ischar (text))
     error ("__makeinfo__: first input argument must be a string");
   endif
 
   if (! ischar (output_type))
     error ("__makeinfo__: second input argument must be a string");
   endif
 
-  if (nargin < 3)  
+  if (nargin < 3)
     if (strcmpi (output_type, "plain text"))
       fsee_also = @(T) strcat ...
           ("\nSee also:", sprintf (" %s,", T{:})(1:end-1), "\n");
-    else    
+    else
       fsee_also = @(T) strcat ...
           ("\nSee also:", sprintf (" @ref{%s},", T{:})(1:end-1), "\n");
     endif
   endif
 
   if (! isa (fsee_also, "function_handle"))
     error (["__makeinfo__: third input argument must ", ...
             "be the empty matrix, or a function handle"]);
   endif
-  
+
 
   ## It seems like makeinfo sometimes gets angry if the first character
   ## on a line is a space, so we remove these.
-  text = strrep (text, "\n ", "\n"); 
+  text = strrep (text, "\n ", "\n");
 
   ## Handle @seealso macro
   see_also_pat = '@seealso *\{([^}]*)\}';
   args = regexp (text, see_also_pat, 'tokens');
   for ii = 1:numel (args)
     expanded = fsee_also (strtrim (strsplit (args{ii}{:}, ',', true)));
     text = regexprep (text, see_also_pat, expanded, 'once');
   endfor
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -115,41 +115,41 @@
 ##
 ## @item user-supplied.  Two options:
 ## (1) One string, or 1x1 cell string: Skip everything to the right of it;
 ## (2) 2x1 cell string array: Everything between the left and right strings
 ## is skipped.
 ## @end itemize
 ##
 ## @item "delimiter"
-## Any character in @var{value} will be used to split @var{str} into words 
+## Any character in @var{value} will be used to split @var{str} into words
 ## (default value = any whitespace).
 ##
 ## @item "emptyvalue"
 ## Parts of the output where no word is available is filled with @var{value}.
 ##
 ## @item "multipledelimsasone"
 ## Treat a series of consecutive delimiters, without whitespace in between,
-## as a single delimiter.  Consecutive delimiter series need not be vertically 
+## as a single delimiter.  Consecutive delimiter series need not be vertically
 ## "aligned".
 ##
 ## @item "treatasempty"
 ## Treat single occurrences (surrounded by delimiters or whitespace) of the
 ## string(s) in @var{value} as missing values.
 ##
 ## @item "returnonerror"
 ## If @var{value} true (1, default), ignore read errors and return normally.
 ## If false (0), return an error.
 ##
 ## @item "whitespace"
 ## Any character in @var{value} will be interpreted as whitespace and
 ## trimmed; the string defining whitespace must be enclosed in double
 ## quotes for proper processing of special characters like \t.
 ## The default value for whitespace = " \b\r\n\t" (note the space).
-## 
+##
 ## @end table
 ##
 ## @seealso{textscan, textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
 
   ## Check input
@@ -215,17 +215,17 @@ function varargout = strread (str, forma
             if (ischar (varargin{n+1}) ||
                (numel (varargin{n+1}) == 1 && iscellstr (varargin{n+1})))
               [comment_start, comment_end] = deal (char (varargin{n+1}), "eol_char");
             elseif (iscellstr (varargin{n+1}) && numel (varargin{n+1}) == 2)
               [comment_start, comment_end] = deal (varargin{n+1}{:});
             else
               ## FIXME - a user may have numeric values specified: {'//', 7}
               ##         this will lead to an error in the warning message
-              error ("strread: unknown or unrecognized comment style '%s'", 
+              error ("strread: unknown or unrecognized comment style '%s'",
                       varargin{n+1});
             endif
         endswitch
       case "delimiter"
         delimiter_str = varargin{n+1};
       case "emptyvalue"
         numeric_fill_value = varargin{n+1};
       case "expchars"
@@ -285,17 +285,17 @@ function varargout = strread (str, forma
     str = strrep (str, "\r\n", "\n");
     ## CR serves no further purpose in function
     eol_char = "\n";
   endif
 
   ## Remove comments in str
   if (comment_flag)
     ## Expand 'eol_char' here, after option processing which may have set value
-    comment_end = regexprep (comment_end, 'eol_char', eol_char); 
+    comment_end = regexprep (comment_end, 'eol_char', eol_char);
     cstart = strfind (str, comment_start);
     cstop  = strfind (str, comment_end);
     ## Treat end of string as additional comment stop
     if (isempty (cstop) || cstop(end) != length (str))
       cstop(end+1) = length (str);
     endif
     if (! isempty (cstart))
       ## Ignore nested openers.
@@ -334,17 +334,17 @@ function varargout = strread (str, forma
   endif
 
   pad_out = 0;
   ## Trim whitespace if needed
   ## FIXME: This is very complicated.  Can this be simplified with regexprep?
   if (! isempty (white_spaces))
     ## Check if trailing "\n" might signal padding output arrays to equal size
     ## before it is trimmed away below
-    if ((str(end) == 10) && (nargout > 1)) 
+    if ((str(end) == 10) && (nargout > 1))
       pad_out = 1;
     endif
     ## Remove repeated white_space chars.  First find white_space positions
     idx = strchr (str, white_spaces);
     ## Find repeated white_spaces
     idx2 = ! (idx(2:end) - idx(1:end-1) - 1);
     ## Set all whitespace chars to spaces
     ## FIXME: this implies real spaces are always part of white_spaces
@@ -379,35 +379,35 @@ function varargout = strread (str, forma
 
   ## Replace TreatAsEmpty char sequences by empty strings
   if (! isempty (empty_str))
     for ii = 1:numel (empty_str)
       idz = strmatch (empty_str{ii}, words, "exact");
       words(idz) = {""};
     endfor
   endif
-  
+
   ## We now may have to cope with 3 cases:
   ## A: Trailing literals (%f<literal>) w/o delimiter in between.
   ## B: Leading literals (<literal>%f) w/o delimiter in between.
   ## C. Skipping leftover parts of specified skip fields (%*N )
   ## fmt_words has been split properly now, but words{} has only been split on
   ## delimiter positions.  Some words columns may have to be split further.
   ## We also don't know the number of lines (as EndOfLine may have been set to
   ## "" (empty) by the caller).
 
   ## Find indices and pointers to possible literals in fmt_words
   idf = cellfun ("isempty", strfind (fmt_words, "%"));
   ## Find indices and pointers to conversion specifiers with fixed width
   idg = ! cellfun ("isempty", regexp (fmt_words, '%\*?\d'));
-  idy = find (idf | idg); 
+  idy = find (idf | idg);
 
   ## If needed, split up columns in three steps:
   if (! isempty (idy))
-    ## Try-catch because complexity of strings to read can be infinite    
+    ## Try-catch because complexity of strings to read can be infinite
     #try
 
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
       ## Alternative below goes by simply parsing a first grab of words
       ## and counting words until the fmt_words array is exhausted:
       iwrd = 1; iwrdp = 0; iwrdl = length (words{iwrd});
       for ii = 1:numel (fmt_words)
@@ -441,49 +441,49 @@ function varargout = strread (str, forma
              (str2double (fmt_words{ii}(regexp(fmt_words{ii}, '\d') : end-1)));
             if (iwrdp > iwrdl)
               ## Error. Field extends beyond word boundary.
               error ("strread: Field width '%s' (fmt spec # %d) extends beyond word limit", fmt_words{ii}, ii);
             elseif (iwrdp == iwrdl)
               ## Word completely "used up".  Next word
               ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
             endif
-   
+
         else
           ## A simple format conv. specifier. Either (1) uses rest of word, or
           ## (2) is squeezed between current iwrdp and next literal, or (3) uses
           ## next word. (3) is already taken care of.  So just check (1) & (2)
           if (ii < numel (fmt_words) && idf(ii+1))
             ## Next fmt_word is a literal...
             if (! index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}))
               ## ...but not found in current word => field uses rest of word
               ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
             else
               ## ..or it IS found.  Add inferred width of current conversion field
               iwrdp += index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}) - 1;
             endif
           elseif (iwrdp < iwrdl)
             ## No bordering literal to the right => field occupies (rest of) word
-            ++iwrd; iwrdp = 0; 
+            ++iwrd; iwrdp = 0;
             if (ii < numel (fmt_words))
               iwrdl = length (words{iwrd});
             endif
           endif
 
         endif
       endfor
       ## Done
       words_period = max (iwrd - 1, 1);
       num_lines = ceil (num_words / words_period);
 
       ## 2. Pad words array so that it can be reshaped
       tmp_lines = ceil (num_words / words_period);
       num_words_padded = tmp_lines * words_period - num_words;
       if (num_words_padded)
-        words = [words'; cell(num_words_padded, 1)]; 
+        words = [words'; cell(num_words_padded, 1)];
       endif
       words = reshape (words, words_period, tmp_lines);
 
       ## 3. Do the column splitting on rectangular words array
       icol = 1; ii = 1;    # icol = current column, ii = current fmt_word
       while (ii <= num_words_per_line)
 
         ## Check if fmt_words(ii) contains a literal or fixed-width
@@ -493,17 +493,17 @@ function varargout = strread (str, forma
             if (isempty (s{:}))
               error ("strread: Literal '%s' not found in column %d", fmt_words{ii}, icol);
             endif
             s = s{:}(1);
             e = s(1) + length (fmt_words{ii}) - 1;
           endif
           if (! strcmp (fmt_words{ii}, words{icol, 1}))
             ## Column doesn't exactly match literal => split needed.  Insert a column
-            words(icol+1:end+1, :) = words(icol:end, :); 
+            words(icol+1:end+1, :) = words(icol:end, :);
             ## Watch out for empty cells
             jptr = find (! cellfun ("isempty", words(icol, :)));
 
             ## Distinguish leading or trailing literals
             if (! idg(ii) && ! isempty (s) && s(1) == 1)
               ## Leading literal.  Assign literal to icol, paste rest in icol + 1
               ## Apply only to those cells that do have something beyond literal
               jptr = find (cellfun("length", words(icol+1, jptr), ...
@@ -518,17 +518,17 @@ function varargout = strread (str, forma
               if (! idg(ii) && ! isempty (strfind (fmt_words{ii-1}, "%s")))
                 ## Trailing literal.  If preceding format == '%s' this is an error
                 warning ("Ambiguous '%s' specifier next to literal in column %d", icol);
               elseif (idg(ii))
                 ## Current field = fixed width. Strip into icol, rest in icol+1
                 wdth = floor (str2double (fmt_words{ii}(regexp(fmt_words{ii}, ...
                               '\d') : end-1)));
                 words(icol+1, jptr) = cellfun (@(x) x(wdth+1:end),
-                     words(icol,jptr), "UniformOutput", false);                 
+                     words(icol,jptr), "UniformOutput", false);
                 words(icol, jptr) = strtrunc (words(icol, jptr), wdth);
               else
                 ## FIXME: this assumes char(254)/char(255) won't occur in input!
                 clear wrds;
                 wrds(1:2:2*numel (words(icol, jptr))) = ...
                      strrep (words(icol, jptr), fmt_words{ii}, ...
                      [char(255) char(254)]);
                 wrds(2:2:2*numel (words(icol, jptr))-1) = char(255);
@@ -561,17 +561,17 @@ function varargout = strread (str, forma
       words = reshape (words, 1, numel (words))(1 : end-num_words_padded);
 
     #catch
     #  warning ("strread: unable to parse text or file with given format string");
     #  return;
 
     #end_try_catch
   endif
-  
+
   ## For each specifier, process corresponding column
   k = 1;
   for m = 1:num_words_per_line
     try
       if (format_repeat_count < 0)
         data = words(m:num_words_per_line:end);
       elseif (format_repeat_count == 0)
         data = {};
@@ -582,26 +582,26 @@ function varargout = strread (str, forma
       endif
 
       ## Map to format
       ## FIXME - add support for formats like "<%s>", "%[a-zA-Z]"
       ##         Someone with regexp experience is needed.
       switch fmt_words{m}(1:min (2, length (fmt_words{m})))
         case "%s"
           if (pad_out)
-            data(end+1:num_lines) = {""}; 
+            data(end+1:num_lines) = {""};
           endif
           varargout{k} = data';
           k++;
         case {"%d", "%u", "%f", "%n"}
           n = cellfun ("isempty", data);
           ### FIXME - erroneously formatted data lead to NaN, not an error
           data = str2double (data);
           if (! isempty (regexp (fmt_words{m}, "%[du]")))
-            ## Cast to integer 
+            ## Cast to integer
             ## FIXME: NaNs will be transformed into zeros
             data = int32 (data);
           end
           data(n) = numeric_fill_value;
           if (pad_out)
             data(end+1:num_lines) = numeric_fill_value;
           endif
           varargout{k} = data.';
@@ -618,17 +618,17 @@ function varargout = strread (str, forma
               data(n) = numeric_fill_value;
               if (pad_out)
                 data(end+1:num_lines) = numeric_fill_value;
               endif
               if (numel (nfmt) > 1)
                 sprec = str2double (nfmt{2});
                 data = 10^-sprec * round (10^sprec * data);
               elseif (! isempty (regexp (fmt_words{m}, "[du]")))
-                ## Cast to integer 
+                ## Cast to integer
                 ## FIXME: NaNs will be transformed into zeros
                 data = int32 (data);
               end
               varargout{k} = data.';
               k++;
             case "s"
               if (pad_out)
                 data(end+1:num_lines) = {""}
@@ -677,17 +677,17 @@ function out = split_by (text, sep, mult
   endif
 
   ## Split text string along delimiters
   out = strsplit (text, sep, mult_dlms_s1);
   ## In case of trailing delimiter, strip stray last empty word
   if (!isempty (out) && any (sep == text(end)))
     out(end) = [];
   endif
-  
+
   ## Empty cells converted to empty cellstrings.
   out(cellfun ("isempty", out)) = {""};
 
 endfunction
 
 
 %!test
 %! [a, b] = strread ("1 2", "%f%f");
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -36,17 +36,17 @@
 ## The first @var{value} number of lines of @var{filename} are skipped.
 ##
 ## @item "endofline":
 ## Specify a single character or "\r\n".  If no value is given, it will be
 ## inferred from the file.  If set to "" (empty string) EOLs are ignored as
 ## delimiters.
 ## @end itemize
 ##
-## The optional input @var{n} specifes the number of times to use 
+## The optional input @var{n} specifes the number of times to use
 ## @var{format} when parsing, i.e., the format repeat count.
 ##
 ## @seealso{strread, load, dlmread, fscanf, textscan}
 ## @end deftypefn
 
 function varargout = textread (filename, format = "%f", varargin)
 
   ## Check input
@@ -93,19 +93,19 @@ function varargout = textread (filename,
 
   if (isempty (str))
     warning ("textread: empty file");
     return;
   endif
 
   endofline = find (strcmpi (varargin, "endofline"), 1);
   if (! isempty (endofline))
-    ## 'endofline' option set by user.  
-    if (! ischar (varargin{endofline + 1})); 
-      error ("textread: character value required for EndOfLine"); 
+    ## 'endofline' option set by user.
+    if (! ischar (varargin{endofline + 1}));
+      error ("textread: character value required for EndOfLine");
     endif
   else
     ## Determine EOL from file.  Search for EOL candidates in first 3000 chars
     eol_srch_len = min (length (str), 3000);
     ## First try DOS (CRLF)
     if (! isempty (findstr ("\r\n", str(1 : eol_srch_len))))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @var{n}, @var{param}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{str}, @dots{})
 ## @deftypefnx {Function File} {[@var{C}, @var{position}] =} textscan (@var{fid}, @dots{})
 ## Read data from a text file or string.
 ##
 ## The file associated with @var{fid} is read and parsed according to
 ## @var{format}.  The function behaves like @code{strread} except it works by
 ## parsing a file instead of a string.  See the documentation of
-## @code{strread} for details.  
+## @code{strread} for details.
 ##
 ## In addition to the options supported by
 ## @code{strread}, this function supports a few more:
 ##
 ## @itemize
 ## @item "collectoutput":
 ## A value of 1 or true instructs textscan to concatenate consecutive columns
 ## of the same class in the output cell array.  A value of 0 or false (default)
@@ -47,17 +47,17 @@
 ## @item "headerlines":
 ## The first @var{value} number of lines of @var{fid} are skipped.
 ##
 ## @item "returnonerror":
 ## If set to numerical 1 or true (default), return normally when read errors
 ## have been encountered.  If set to 0 or false, return an error and no data.
 ## @end itemize
 ##
-## The optional input @var{n} specifes the number of times to use 
+## The optional input @var{n} specifes the number of times to use
 ## @var{format} when parsing, i.e., the format repeat count.
 ##
 ## The output @var{C} is a cell array whose length is given by the number
 ## of format specifiers.
 ##
 ## The second output, @var{position}, provides the position, in characters,
 ## from the beginning of the file.
 ##
@@ -103,25 +103,25 @@ function [C, position] = textscan (fid, 
     args(end+1:end+2) = {'whitespace', " \b\t"};
     whitespace = " \b\t";
   else
     ## Check if there's at least one string format specifier
     fmt = strrep (format, "%", " %");
     fmt = regexp (fmt, '[^ ]+', 'match');
     fmt = strtrim (fmt(strmatch ("%", fmt)))
     has_str_fmt = all (cellfun ("isempty", strfind (strtrim (fmt(strmatch ("%", fmt))), 's')));
-    ## If there is a format, AND whitespace value = empty, 
+    ## If there is a format, AND whitespace value = empty,
     ## don't add a space (char(32)) to whitespace
     if (! (isempty (args{ipos+1}) &&  has_str_fmt))
       args{ipos+1} = unique ([" ", whitespace]);
     endif
   endif
 
   if (! any (strcmpi (args, "delimiter")))
-    ## Matlab says default delimiter = whitespace.  
+    ## Matlab says default delimiter = whitespace.
     ## strread() will pick this up further
     args(end+1:end+2) = {'delimiter', ""};
   endif
 
   collop = false;
   ipos = find (strcmpi (args, "collectoutput"));
   if (! isempty (ipos))
     ## Search & concatenate consecutive columns of same class requested
@@ -151,17 +151,17 @@ function [C, position] = textscan (fid, 
     endif
     str = fid;
   else
     ## Skip header lines if requested
     headerlines = find (strcmpi (args, "headerlines"), 1);
     ## Beware of zero valued headerline, fskipl would skip to EOF
     if (! isempty (headerlines) && (args{headerlines + 1} > 0))
       fskipl (fid, varargin{headerlines + 1});
-      args(headerlines:headerlines+1) = []; 
+      args(headerlines:headerlines+1) = [];
     endif
     if (isfinite (nlines) && (nlines >= 0))
       str = tmp_str = "";
       n = 0;
       ## FIXME: Can this be done without slow loop?
       while (ischar (tmp_str) && n++ < nlines)
         tmp_str = fgets (fid);
         if (ischar (tmp_str))
@@ -178,23 +178,23 @@ function [C, position] = textscan (fid, 
     warning ("textscan: no data read");
     C = [];
     return;
   endif
 
   ## Check value of 'endofline'.  String or file doesn't seem to matter
   endofline = find (strcmpi (args, "endofline"), 1);
   if (! isempty (endofline))
-    if (ischar (args{endofline + 1})) 
+    if (ischar (args{endofline + 1}))
       eol_char = args{endofline + 1};
       if (isempty (strmatch (eol_char, {"", "\n", "\r", "\r\n"}, 'exact')))
         error ("textscan: illegal EndOfLine character value specified");
       endif
     else
-      error ("textscan: character value required for EndOfLine"); 
+      error ("textscan: character value required for EndOfLine");
     endif
   else
     ## Determine EOL from file.  Search for EOL candidates in first 3000 chars
     eol_srch_len = min (length (str), 3000);
     ## First try DOS (CRLF)
     if (! isempty (findstr ("\r\n", str(1 : eol_srch_len))))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
@@ -214,17 +214,17 @@ function [C, position] = textscan (fid, 
   ## Strip trailing EOL to avoid returning stray missing values (f. strread)
   if (strcmp (str(end-length (eol_char) + 1 : end), eol_char));
     str(end-length (eol_char) + 1 : end) = "";
   endif
 
   ## Call strread to make it do the real work
   C = cell (1, num_fields);
   [C{:}] = strread (str, format, args{:});
-  
+
   ## If requested, collect output columns of same class
   if (collop)
     C = colloutp (C);
   endif
 
   if (nargout == 2)
     position = ftell (fid);
   endif
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -55,52 +55,52 @@ function retval = rank (A, tol)
     print_usage ();
   endif
 
   retval = sum (sigma > tolerance);
 
 endfunction
 
 %!test
-%! A = [1 2 3 4 5 6 7; 
-%!      4 5 6 7 8 9 12; 
-%!      1 2 3.1 4 5 6 7; 
-%!      2 3 4 5 6 7 8; 
-%!      3 4 5 6 7 8 9; 
-%!      4 5 6 7 8 9 10; 
+%! A = [1 2 3 4 5 6 7;
+%!      4 5 6 7 8 9 12;
+%!      1 2 3.1 4 5 6 7;
+%!      2 3 4 5 6 7 8;
+%!      3 4 5 6 7 8 9;
+%!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
 %! assert(rank(A),4);
 
 %!test
-%! A = [1 2 3 4 5 6 7; 
-%!      4 5 6 7 8 9 12; 
-%!      1 2 3.0000001 4 5 6 7; 
-%!      4 5 6 7 8 9 12.00001; 
-%!      3 4 5 6 7 8 9; 
-%!      4 5 6 7 8 9 10; 
+%! A = [1 2 3 4 5 6 7;
+%!      4 5 6 7 8 9 12;
+%!      1 2 3.0000001 4 5 6 7;
+%!      4 5 6 7 8 9 12.00001;
+%!      3 4 5 6 7 8 9;
+%!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
 %! assert(rank(A),4);
 
 %!test
-%! A = [1 2 3 4 5 6 7; 
-%!      4 5 6 7 8 9 12; 
-%!      1 2 3 4 5 6 7; 
-%!      4 5 6 7 8 9 12.00001; 
+%! A = [1 2 3 4 5 6 7;
+%!      4 5 6 7 8 9 12;
+%!      1 2 3 4 5 6 7;
+%!      4 5 6 7 8 9 12.00001;
 %!      3 4 5 6 7 8 9;
-%!      4 5 6 7 8 9 10; 
+%!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
 %! assert(rank(A),3);
 
 %!test
-%! A = [1 2 3 4 5 6 7; 
+%! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3 4 5 6 7;
-%!      4 5 6 7 8 9 12; 
-%!      3 4 5 6 7 8 9; 
-%!      4 5 6 7 8 9 10; 
+%!      4 5 6 7 8 9 12;
+%!      3 4 5 6 7 8 9;
+%!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
 %! assert(rank(A),3);
 
 %!test
 %! A = eye(100);
 %! assert(rank(A),100);
 
 %!test
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -26,17 +26,17 @@
 ## files are placed in this directory.
 ## @seealso{gunzip, bzip2, zip, tar}
 ## @end deftypefn
 
 function entries = gzip (varargin)
   if (nargin != 1 && nargin != 2) || (nargout > 1)
     print_usage ();
   endif
-     
+
   if (nargout == 0)
     __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   else
     entries = __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -31,17 +31,17 @@
 ## This is an internal function. Do not use directly.
 
 function entries = __xzip__ (commandname, extension,
                              commandtemplate, files, outdir)
 
   if (nargin != 4 && nargin != 5)
     print_usage ();
   endif
-  
+
   if (! ischar (extension) || length (extension) == 0)
     error ("__xzip__: EXTENSION must be a string with finite length");
   endif
 
   if (nargin == 5 && ! exist (outdir, "dir"))
     error ("__xzip__: OUTDIR output directory does not exist");
   endif
 
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -42,14 +42,14 @@ endfunction
 %!assert (ischar (tempdir ()))
 
 %!test
 %! old_wstate = warning ("query");
 %! warning ("off");
 %! old_tmpdir = getenv ("TMPDIR");
 %! unwind_protect
 %!   setenv ("TMPDIR", "__MY_TMP_DIR__");
-%!   assert (tempdir (), ["__MY_TMP_DIR__" filesep()]); 
+%!   assert (tempdir (), ["__MY_TMP_DIR__" filesep()]);
 %! unwind_protect_cleanup
 %!   setenv ("TMPDIR", old_tmpdir);
 %!   warning (old_wstate);
-%! end_unwind_protect 
+%! end_unwind_protect
 
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -33,22 +33,22 @@
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
 function filelist = unpack (file, dir = ".", filetype = "")
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (! ischar (file) && ! iscellstr (file)) 
+  if (! ischar (file) && ! iscellstr (file))
     error ("unpack: invalid input file class, %s", class(file));
   endif
 
   ## character arrays of more than one string must be treated as cell strings
-  if (ischar (file) && ! isvector (file)) 
+  if (ischar (file) && ! isvector (file))
     file = cellstr (file);
   endif
 
   ## Recursively unpack cellstr arrays one file at a time
   if (iscellstr (file))
     files = {};
     for i = 1:numel (file)
       tmpfiles = unpack (file{i}, dir);
@@ -217,17 +217,17 @@ function filelist = unpack (file, dir = 
   endif
 
 endfunction
 
 function files = __parse_zip__ (output)
   ## Parse the output from zip and unzip.
 
   ## Skip first line which is Archive header
-  output(1) = []; 
+  output(1) = [];
   for i = 1:length (output)
     files{i} = output{i}(14:length(output{i}));
   endfor
 endfunction
 
 function output = __parse_tar__ (output)
   ## This is a noop, but it makes things simpler for other cases.
 endfunction
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} pkg @var{command} @var{pkg_name}
 ## @deftypefnx {Command} {} pkg @var{command} @var{option} @var{pkg_name}
 ## Manage packages (groups of add-on functions) for Octave.  Different actions
-## are available depending on the value of @var{command}.  
+## are available depending on the value of @var{command}.
 ##
 ## Available commands:
 ##
 ## @table @samp
 ##
 ## @item install
 ## Install named packages.  For example,
 ##
@@ -50,17 +50,17 @@
 ## The package manager will not automatically load the installed package
 ## when starting Octave.  This overrides any setting within the package.
 ##
 ## @item -auto
 ## The package manager will automatically load the installed package when
 ## starting Octave.  This overrides any setting within the package.
 ##
 ## @item -local
-## A local installation (package available only to current user) is forced, 
+## A local installation (package available only to current user) is forced,
 ## even if the user has system privileges.
 ##
 ## @item -global
 ## A global installation (package available to all users) is forced, even if
 ## the user doesn't normally have system privileges.
 ##
 ## @item -forge
 ## Install a package directly from the Octave-Forge repository.  This
@@ -126,17 +126,17 @@
 ## @end example
 ##
 ## @noindent
 ## returns a cell array containing a structure for each installed package.
 ##
 ## If two output arguments are requested @code{pkg} splits the list of
 ## installed packages into those which were installed by the current user,
 ## and those which were installed by the system administrator.
-## 
+##
 ## @example
 ## [user_packages, system_packages] = pkg ("list")
 ## @end example
 ##
 ## The option '-forge' lists packages available at the Octave-Forge repository.
 ## This requires an internet connection and the cURL library.  For example:
 ##
 ## @example
@@ -1350,17 +1350,17 @@ function configure_make (desc, packdir, 
       endif
       if (isempty (getenv ("AR")))
         flags = cstrcat (flags, " AR=\"", octave_config_info ("AR"), "\"");
       endif
       if (isempty (getenv ("RANLIB")))
         flags = cstrcat (flags, " RANLIB=\"", octave_config_info ("RANLIB"), "\"");
       endif
       [status, output] = shell (cstrcat ("cd '", src, "'; ", scenv,
-					 "./configure --prefix=\"",
+                                         "./configure --prefix=\"",
                                          desc.dir, "\"", flags));
       if (status != 0)
         rm_rf (desc.dir);
         error ("the configure script returned the following error: %s", output);
       elseif (verbose)
         printf("%s", output);
       endif
 
diff --git a/scripts/plot/allchild.m b/scripts/plot/allchild.m
--- a/scripts/plot/allchild.m
+++ b/scripts/plot/allchild.m
@@ -46,14 +46,14 @@ function h = allchild (handles)
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   l = line;
 %!   assert(get(allchild(hf),'type'),{'axes'; 'uimenu'; 'uimenu'; 'uimenu'})
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -72,15 +72,15 @@ function p = ancestor (h, type, toplevel
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   l = line;
 %!   assert (ancestor (l, "axes"), gca);
 %!   assert (ancestor (l, "figure"), hf);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -86,17 +86,17 @@ function cla (varargin)
 
   ## Set the current axis back to where it was upon entry.
   axes (oldhax);
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect 
+%! unwind_protect
 %!   plot (1:10)
 %!   cla ()
 %!   kids = get (gca, "children");
 %!   cla ()
 %! unwind_protect_cleanup
 %!   close (hf)
 %! end_unwind_protect
 %! assert (numel (kids), 0)
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -73,23 +73,23 @@ function clf (varargin)
 
   ## Delete the children.
   delete (hc);
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   l = line;
 %!   assert (!isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   clf;
 %!   assert (isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/findall.m b/scripts/plot/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/findall.m
@@ -40,15 +40,15 @@ function h = findall (varargin)
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   h = findall (hf);
 %!   all_handles = {"uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "figure"};
 %!   assert (get (h, 'type'), all_handles)
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -240,17 +240,17 @@ function h = findobj (varargin)
   endif
 
   h = h (keepers != 0);
   h = reshape (h, [numel(h), 1]);
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   l = line;
 %!   obj = findobj (hf, "type", "line");
 %!   assert (l, obj);
 %!   assert (gca, findobj (hf, "type", "axes"));
 %!   assert (hf, findobj (hf, "type", "figure"));
 %!   assert (isempty (findobj (hf, "type", "xyzxyz")));
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/scripts/plot/gca.m b/scripts/plot/gca.m
--- a/scripts/plot/gca.m
+++ b/scripts/plot/gca.m
@@ -48,13 +48,13 @@ function h = gca ()
     print_usage ();
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
 %! ax = axes;
-%! unwind_protect  
+%! unwind_protect
 %!   assert (gca, ax);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/gcf.m b/scripts/plot/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/gcf.m
@@ -51,13 +51,13 @@ function h = gcf ()
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   assert (gcf, hf);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/hggroup.m b/scripts/plot/hggroup.m
--- a/scripts/plot/hggroup.m
+++ b/scripts/plot/hggroup.m
@@ -39,15 +39,15 @@ function h = hggroup (varargin)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   h = hggroup;
 %!   assert (findobj (hf, "type", "hggroup"), h);
 %!   assert (get (h, "type"), "hggroup");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/isfigure.m b/scripts/plot/isfigure.m
--- a/scripts/plot/isfigure.m
+++ b/scripts/plot/isfigure.m
@@ -32,14 +32,14 @@ function retval = isfigure (h)
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   assert (isfigure (hf));
 %!   assert (!isfigure (-hf));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/ishghandle.m
--- a/scripts/plot/ishghandle.m
+++ b/scripts/plot/ishghandle.m
@@ -24,17 +24,17 @@
 function retval = ishghandle (h)
   ## This function is just included for compatibility as Octave has
   ## no simulink equivalent.
   retval = ishandle (h);
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   assert (ishghandle (hf));
 %!   assert (!ishghandle (-hf));
 %!   l = line;
 %!   ax = gca();
 %!   assert (ishghandle (ax));
 %!   assert (!ishghandle (-ax));
 %!   assert (ishghandle (l));
 %!   assert (!ishghandle (-l));
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -283,34 +283,34 @@ function [hlegend2, hobjects2, hplot2, t
   elseif (strcmp (box, "on"))
     if (! isempty (hlegend))
       set (hlegend, "visible", "on", "box", "on");
     endif
   elseif (strcmp (box, "off"))
     if (! isempty (hlegend))
       set (hlegend, "box", "off", "visible", "off");
     endif
-  elseif (nargs == 0 && !(strcmp (position, "default") && 
+  elseif (nargs == 0 && !(strcmp (position, "default") &&
                           strcmp (orientation, "default")))
     if (! isempty (hlegend))
       hax = getfield (get (hlegend, "userdata"), "handle");
       [hplots, text_strings] = __getlegenddata__ (hlegend);
 
       if  (strcmp (position, "default"))
         h = legend (hax, hplots, text_strings, "orientation", orientation);
       elseif (strcmp (orientation, "default"))
         if (outside)
-          h = legend (hax, hplots, text_strings, "location", 
+          h = legend (hax, hplots, text_strings, "location",
                       strcat (position, "outside"));
         else
           h = legend (hax, hplots, text_strings, "location", position);
         endif
       else
         if (outside)
-          h = legend (hax, hplots, text_strings, "location", 
+          h = legend (hax, hplots, text_strings, "location",
                       strcat (position, "outside"), "orientation", orientation);
         else
           h = legend (hax, hplots, text_strings, "location", position,
                       "orientation", orientation);
         endif
       endif
     endif
   else
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -40,17 +40,17 @@ function h = line (varargin)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   h = line;
 %!   assert (findobj (hf, "type", "line"), h);
 %!   assert (get (h, "xdata"), [0 1], eps);
 %!   assert (get (h, "ydata"), [0 1], eps);
 %!   assert (get (h, "type"), "line");
 %!   assert (get (h, "color"), get (0, "defaultlinecolor"));
 %!   assert (get (h, "linestyle"), get (0, "defaultlinelinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultlinelinewidth"), eps);
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -66,41 +66,41 @@ endfunction
 %! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
 %! y = ((t .* (1 + rand (size (t)))) .^ 2);
 %! loglog (x, y);
 
 %!demo
 %! clf ();
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
-%! 
+%!
 %! subplot (1, 2, 1)
 %! loglog (a, b)
 %! xlabel ('loglog (a, b)')
-%! 
+%!
 %! subplot (1, 2, 2)
 %! loglog (a, abs (b))
 %! set (gca, 'ydir', 'reverse')
 %! xlabel ('loglog (a, abs (b))')
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   loglog (a, b)
 %!   assert (get (gca, "yscale"), "log");
 %!   assert (get (gca, "xscale"), "log");
 %! unwind_protect_cleanup
 %! close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
 %!   loglog (a, b)
 %!   axis tight
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
 %! close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -149,17 +149,17 @@ endfunction
 %!          3, 4, 5;
 %!          4, 1, 5];
 %! patch('Vertices', vertices, 'Faces', faces, ...
 %!       'FaceVertexCData', jet(5), 'FaceColor', 'interp')
 %! view (-37.5, 30)
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   h = patch;
 %!   assert (findobj (hf, "type", "patch"), h);
 %!   assert (get (h, "xdata"), [0; 1; 1], eps);
 %!   assert (get (h, "ydata"), [0; 0; 1], eps);
 %!   assert (isempty(get (h, "zdata")));
 %!   assert (isempty(get (h, "cdata")));
 %!   assert (get (h, "faces"), [1, 2, 3], eps);
 %!   assert (get (h, "vertices"), [0 0; 1 0; 1 1], eps);
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -606,17 +606,17 @@ function latex_standalone (opts)
   if (fid >= 0)
     latex = fscanf (fid, "%c", Inf);
     status = fclose (fid);
     if (status != 0)
       error ("print:errorclosingfile",
              "print.m: error closing file '%s'", latexfile);
     endif
     ## TODO - should this be fixed in GL2PS?
-    latex = strrep (latex, "\\includegraphics{}", 
+    latex = strrep (latex, "\\includegraphics{}",
                     sprintf ("\\includegraphics{%s}", graphicsfile));
   else
     error ("print:erroropeningfile",
            "print.m: error opening file '%s'", latexfile);
   endif
   fid = fopen (latexfile, "w");
   if (fid >= 0)
     fprintf (fid, "%s\n", prepend{:});
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -120,18 +120,18 @@ function hg = __quiver__ (varargin)
     else
       dz = 0;
       len = max (sqrt (u(:).^2 + v(:).^2));
     endif
     if (len > 0)
       sd = sqrt (dx.^2 + dy.^2 + dz.^2) / len;
       if (sd != 0)
         s = sqrt(2) * autoscale * sd;
-      else # special case of identical points with multiple vectors 
-        s = autoscale; 
+      else # special case of identical points with multiple vectors
+        s = autoscale;
       endif
       uu = s * u;
       vv = s * v;
       if (is3d)
         ww = s*w;
       endif
     endif
   else
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -363,22 +363,22 @@ function update_data (h, d)
         set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", c1,
              "markersize", size1(i));
       endfor
     endif
   else
     if (isempty (z1))
       for i = 1 : length (hlist)
         set (hlist(i), "vertices", [x1(i), y1(i)], "cdata",
-             reshape(c1(i,:),[1, size(c1)(2:end)]), 
+             reshape(c1(i,:),[1, size(c1)(2:end)]),
              "facevertexcdata", c1(i,:),
              "markersize", size1(i));
       endfor
     else
       for i = 1 : length (hlist)
         set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata",
-             reshape(c1(i,:),[1, size(c1)(2:end)]), 
+             reshape(c1(i,:),[1, size(c1)(2:end)]),
              "facevertexcdata", c1(i,:),
              "markersize", size1(i));
       endfor
     endif
   endif
 endfunction
diff --git a/scripts/plot/rectangle.m b/scripts/plot/rectangle.m
--- a/scripts/plot/rectangle.m
+++ b/scripts/plot/rectangle.m
@@ -28,29 +28,29 @@
 ## @code{@var{pos}(1:2)} defines the lower left-hand corner of the patch
 ## and @code{@var{pos}(3:4)} defines its width and height.  By default, the
 ## value of @var{pos} is @code{[0, 0, 1, 1]}.
 ##
 ## The variable @var{curv} defines the curvature of the sides of the rectangle
 ## and may be a scalar or two-element vector with values between 0 and 1.
 ## A value of 0 represents no curvature of the side, whereas a value of 1
 ## means that the side is entirely curved into the arc of a circle.
-## If @var{curv} is a two-element vector, then the first element is the 
+## If @var{curv} is a two-element vector, then the first element is the
 ## curvature along the x-axis of the patch and the second along y-axis.
 ##
 ## If @var{curv} is a scalar, it represents the curvature of the shorter of the
 ## two sides of the rectangle and the curvature of the other side is defined
 ## by
 ##
 ## @example
 ## min (pos (1:2)) / max (pos (1:2)) * curv
 ## @end example
 ##
-## Other properties are passed to the underlying patch command.  If called 
-## with an output argument, @code{rectangle} returns the handle to the 
+## Other properties are passed to the underlying patch command.  If called
+## with an output argument, @code{rectangle} returns the handle to the
 ## rectangle.
 ## @end deftypefn
 ## @seealso{patch}
 
 function h = rectangle (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("rectangle", varargin{:});
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -64,41 +64,41 @@ endfunction
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
 
 %!demo
 %! clf ();
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
-%! 
+%!
 %! subplot (1, 2, 1)
 %! semilogx (b, a)
 %! xlabel ('semilogx (a, b)')
-%! 
+%!
 %! subplot (1, 2, 2)
 %! semilogx (abs (b), a)
 %! set (gca, 'ydir', 'reverse')
 %! xlabel ('semilogx (a, abs (b))')
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   semilogx (a, b)
 %!   assert (get (gca, "xscale"), "log");
 %!   assert (get (gca, "yscale"), "linear");
 %! unwind_protect_cleanup
 %! close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
 %!   semilogx (a, b)
 %!   axis tight
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
 %! close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -65,41 +65,41 @@ endfunction
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
 %! clf ();
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
-%! 
+%!
 %! subplot (1, 2, 1)
 %! semilogy (a, b)
 %! xlabel ('semilogy (a, b)')
-%! 
+%!
 %! subplot (1, 2, 2)
 %! semilogy (a, abs (b))
 %! set (gca, 'ydir', 'reverse')
 %! xlabel ('semilogy (a, abs (b))')
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   semilogy (a, b)
 %!   assert (get (gca, "yscale"), "log");
 %!   assert (get (gca, "xscale"), "linear");
 %! unwind_protect_cleanup
 %! close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
 %!   semilogy (a, b)
 %!   axis tight
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
 %! close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -160,17 +160,17 @@ function [h, bad_usage] = __surface__ (a
 
 endfunction
 
 ## Mark file as being tested.  Tests for surface are in
 ## surf.m, surfc.m, surfl.m, and pcolor.m
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   h = surface;
 %!   assert (findobj (hf, "type", "surface"), h);
 %!   assert (get (h, "xdata"), 1:3, eps);
 %!   assert (get (h, "ydata"), (1:3)', eps);
 %!   assert (get (h, "zdata"), eye(3));
 %!   assert (get (h, "cdata"), eye(3));
 %!   assert (get (h, "type"), "surface");
 %!   assert (get (h, "linestyle"), get (0, "defaultsurfacelinestyle"));
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -215,17 +215,17 @@ endfunction
 %! h = text (0.7, 0.5, {"single cell-string"});
 %! assert ("cell", class (get (h, "string")))
 %! xlabel (1:2)
 %! ylabel (1:2)
 %! title (1:2)
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   h = text (0.5, 0.3, "char");
 %!   assert ("char", class (get (h, "string")))
 %!   h = text (0.5, 0.4, ["char row 1"; "char row 2"]);
 %!   assert ("char", class (get (h, "string")))
 %!   h = text (0.5, 0.6, {"cell2str (1,1)", "cell2str (1,2)"; "cell2str (2,1)", "cell2str (2,2)"});
 %!   assert ("cell", class (get (h, "string")))
 %!   h = text (0.5, 0.8, "foobar");
 %!   set (h, "string", 1:3)
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -49,27 +49,27 @@ endfunction
 %! clf ();
 %! plot3 ([0,1], [0,1], [0,1]);
 %! xl = get(gca (), "title");
 %! title("Testing title")
 %! assert(get(xl,"string"),"Testing title")
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   ax=axes();
 %!   xl = get(ax,"title");
 %!   title("Testing title")
 %!   assert(get(xl,"string"),"Testing title")
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   xl = get(gca (), "title");
 %!   title("Testing title")
 %!   assert(get(xl,"string"),"Testing title")
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -76,27 +76,27 @@ endfunction
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
 %! trisurf (tri, x(:), y(:), z(:));
 
 %!demo
 %! x = rand (100, 1);
 %! y = rand (100, 1);
-%! z = x.^2 + y.^2; 
-%! tri = delaunay (x, y); 
+%! z = x.^2 + y.^2;
+%! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z)
 
 %!demo
 %! x = rand (100, 1);
 %! y = rand (100, 1);
-%! z = x.^2 + y.^2; 
-%! tri = delaunay (x, y); 
+%! z = x.^2 + y.^2;
+%! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, "facecolor", "interp")
 
 %!demo
 %! x = rand (100, 1);
 %! y = rand (100, 1);
-%! z = x.^2 + y.^2; 
-%! tri = delaunay (x, y); 
+%! z = x.^2 + y.^2;
+%! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, "facecolor", "interp", "edgecolor", "k")
 
 
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -91,33 +91,33 @@ function [azimuth, elevation] = view (va
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   [az, el] = view;
 %!   assert ([az, el], [-37.5, 30], eps);
 %!   view (2);
 %!   [az, el] = view;
 %!   assert ([az, el], [0, 90], eps);
 %!   view ([1 1 0]);
 %!   [az, el] = view;
 %!   assert ([az, el], [135, 0], eps);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   line;
 %!   [az, el] = view;
 %!   assert ([az, el], [0, 90], eps);
 %!   view (3);
 %!   [az, el] = view;
 %!   assert ([az, el], [-37.5, 30], eps);
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -143,17 +143,17 @@ function whitebg (varargin)
     endif
   endif
 endfunction
 
 %!test
 %! dac = get (0, "defaultaxescolor");
 %! dfc = get (0, "defaultfigurecolor");
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   l = line;
 %!   assert (get (hf, "color"), dfc);
 %!   assert (get (gca, "color"), dac);
 %!   whitebg (hf);
 %!   assert (get (hf, "color"), 1 - dfc);
 %!   assert (get (gca, "color"), 1 - dac);
 %!   c = [0.2 0.2 0.2];
 %!   whitebg (hf, c);
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -51,17 +51,17 @@ function retval = xlabel (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   x = xlabel ("xlabel_string");
 %!   assert (get(gca, "xlabel"), x);
 %!   assert (get(x, "type"), "text");
 %!   assert (get(x, "visible"), "on");
 %!   assert (get(x, "string"), "xlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -71,26 +71,26 @@ endfunction
 %! plot3 ([0,1], [0,1], [0,1]);
 %! xlim ('auto');
 %! title ("xlim is auto");
 %! assert (xlim ("mode"), "auto");
 
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   xlim ([0, 1.1]);
 %!   assert (get (gca, "xlim"), [0, 1.1], eps);
 %!   assert (xlim ("mode"), "manual");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   h = plot3 ([0,1.1], [0,1], [0, 1]);
 %!   assert (get (gca, "xlim"), [0, 1.4], eps);
 %!   assert (xlim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -45,17 +45,17 @@ function retval = ylabel (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   y = ylabel ("ylabel_string");
 %!   assert (get(gca, "ylabel"), y);
 %!   assert (get(y, "type"), "text");
 %!   assert (get(y, "visible"), "on");
 %!   assert (get(y, "string"), "ylabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -70,27 +70,27 @@ endfunction
 %! clf ();
 %! plot3 ([0,1], [0,1], [0,1]);
 %! ylim ('auto');
 %! title ("ylim is auto");
 %! assert (ylim ("mode"), "auto");
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   limy = [0, 1.1];
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   ylim (limy);
 %!   assert (get (gca, "ylim"), limy, eps);
 %!   assert (ylim ("mode"), "manual");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   plot3 ([0,1], [0,1.1], [0, 1]);
 %!   assert (get (gca, "ylim"), [0, 1.4], eps);
 %!   assert (ylim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -45,30 +45,30 @@ function retval = zlabel (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   z = zlabel ("zlabel_string");
 %!   assert (get(gca, "zlabel"), z);
 %!   assert (get(z, "type"), "text");
 %!   assert (get(z, "visible"), "off");
 %!   assert (get(z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! plot3 (0, 0, 0);
-%! unwind_protect  
+%! unwind_protect
 %!   z = zlabel ("zlabel_string");
 %!   assert (get(gca, "zlabel"), z);
 %!   assert (get(z, "type"), "text");
 %!   assert (get(z, "visible"), "off");
 %!   assert (get(z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -70,27 +70,27 @@ endfunction
 %! clf ();
 %! plot3 ([0,1], [0,1], [0,1]);
 %! zlim ('auto');
 %! title ("zlim is auto");
 %! assert (zlim ("mode"), "auto");
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   limz = [0, 1.1];
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   zlim (limz);
 %!   assert (get (gca, "zlim"), limz, eps);
 %!   assert (zlim ("mode"), "manual");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! unwind_protect  
+%! unwind_protect
 %!   plot3 ([0,1], [0,1], [0, 1.1]);
 %!   assert (get (gca, "zlim"), [0, 1.4], eps);
 %!   assert (zlim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -17,31 +17,31 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs})
 ## @deftypefnx {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs}, @var{d})
 ##
 ## Construct a piece-wise polynomial (pp) structure from sample points
 ## @var{breaks} and coefficients @var{coefs}.  @var{breaks} must be a vector of
-## strictly increasing values. The number of intervals is given by 
+## strictly increasing values. The number of intervals is given by
 ## @code{@var{ni} = length (@var{breaks}) - 1}.
-## When @var{m} is the polynomial order @var{coefs} must be of 
+## When @var{m} is the polynomial order @var{coefs} must be of
 ## size: @var{ni} x @var{m} + 1.
 ##
 ## The i-th row of @var{coefs},
 ## @code{@var{coefs} (@var{i},:)}, contains the coefficients for the polynomial
-## over the @var{i}-th interval, ordered from highest (@var{m}) to 
+## over the @var{i}-th interval, ordered from highest (@var{m}) to
 ## lowest (@var{0}).
 ##
 ## @var{coefs} may also be a multi-dimensional array, specifying a vector-valued
 ## or array-valued polynomial. In that case the polynomial order is defined
 ## by the length of the last dimension of @var{coefs}.
 ## The size of first dimension(s) are given by the scalar or
-## vector @var{d}. If @var{d} is not given it is set to @code{1}. 
+## vector @var{d}. If @var{d} is not given it is set to @code{1}.
 ## In any case @var{coefs} is reshaped to a 2d matrix of
 ## size @code{[@var{ni}*prod(@var{d} @var{m})] }
 ##
 ## @seealso{unmkpp, ppval, spline}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
 
@@ -67,17 +67,17 @@ function pp = mkpp (x, P, d)
                "coefs", [],
                "pieces", len,
                "order", prod (size (P)) / len,
                "dim", 1);
 
   if (nargin == 3)
     pp.dim = d;
     pp.order /= prod (d);
-  endif 
+  endif
 
   dim_vec = [pp.pieces * prod(pp.dim), pp.order];
   pp.coefs = reshape (P, dim_vec);
 
 endfunction
 
 %!demo # linear interpolation
 %! x=linspace(0,pi,5)';
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -90,15 +90,15 @@ endfunction
 %! assert (poly3, poly2, sqrt (eps))
 
 %!test
 %! assert (polygcd (poly(1:8), poly(3:12)), poly(3:8), sqrt (eps))
 
 %!test
 %! assert (deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))), poly(1:2), sqrt (eps))
 
-%!test 
+%!test
 %! for ii=1:10
 %!   p  = (unique (randn (10, 1)) * 10).';
 %!   p1 = p(3:end);
 %!   p2 = p(1:end-2);
 %!   assert (polygcd (poly (-p1), poly (-p2)), poly (- intersect (p1, p2)), sqrt (eps))
 %! endfor
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -43,16 +43,16 @@ function ppi = ppint (pp, c)
   else
     pi(:, k) = repmat (c(:), n, 1);
   endif
 
   ppi = mkpp (x, pi, d);
 
   tmp = -cumsum (ppjumps (ppi), length (d) + 1);
   ppi.coefs(prod(d)+1:end, k) = tmp(:);
-  
+
 endfunction
 
 %!shared x,y,pp,ppi
 %! x=0:8;y=[ones(size(x));x+1];pp=spline(x,y);
 %! ppi=ppint(pp);
 %!assert(ppval(ppi,x),[x;0.5*x.^2+x],1e-14)
 %!assert(ppi.order,5)
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -23,17 +23,17 @@
 ## @math{d}, the resulting array has dimensions @code{[d, n-1]}.
 ## @seealso{mkpp}
 ## @end deftypefn
 
 function jumps = ppjumps (pp)
   if (nargin != 1)
     print_usage ();
   endif
-  
+
   if (! isstruct (pp) && strcmp (pp.form, "pp"))
     error ("ppjumps: PP must be a structure");
   endif
 
   ## Extract info.
   [x, P, n, k, d] = unmkpp(pp);
   nd = length (d) + 1;
 
@@ -47,17 +47,17 @@ function jumps = ppjumps (pp)
   if (k>1)
     llim = shiftdim (reshape (P(1:(n-1) * prod(d), 1), [d, n-1]), nd - 1);
   endif
 
   for i = 2 : k;
     llim .*= dx;
     llim += shiftdim (reshape (P(1:(n-1) * prod (d), i), [d, n-1]), nd - 1);
   endfor
-  
+
   rlim = shiftdim (ppval (pp, x(2:end-1)), nd - 1);
   jumps = shiftdim (rlim - llim, 1);
 endfunction
 
 
 %!test
 %! p = [1 6 11 6];
 %! x = linspace (5, 6, 4);
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -13,22 +13,22 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} ppval (@var{pp}, @var{xi})
-## Evaluate piece-wise polynomial structure @var{pp} at the points @var{xi}.  
+## Evaluate piece-wise polynomial structure @var{pp} at the points @var{xi}.
 ## If @var{pp} describes a scalar polynomial function, the result is an
 ## array of the same shape as @var{xi}.
 ## Otherwise, the size of the result is @code{[pp.dim, length(@var{xi})]} if
 ## @var{xi} is a vector, or @code{[pp.dim, size(@var{xi})]} if it is a
-## multi-dimensional array.  
+## multi-dimensional array.
 ##
 ##, the dimensions are permuted as
 ## in interp1, to
 ## @code{[pp.d, length(@var{xi})]} and @code{[pp.d, size(@var{xi})]}
 ## respectively.
 ## @seealso{mkpp, unmkpp, spline, pchip, interp1}
 ## @end deftypefn
 
@@ -38,34 +38,34 @@ function yi = ppval (pp, xi)
     print_usage ();
   endif
   if (! isstruct (pp) && strcmp (pp.form, "pp"))
     error ("ppval: expects a pp-form structure");
   endif
 
   ## Extract info.
   [x, P, n, k, d] = unmkpp (pp);
-  
+
   ## dimension checks
   sxi = size (xi);
   if (isvector (xi))
     xi = xi(:).';
   endif
-  
+
   nd = length (d);
 
   ## Determine intervals.
   xn = numel (xi);
   idx = lookup (x, xi, "lr");
 
   P = reshape (P, [d, n * k]);
   P = shiftdim (P, nd);
   P = reshape (P, [n, k, d]);
   Pidx = P(idx(:), :);#2d matrix size x: coefs*prod(d) y: prod(sxi)
-  
+
   if (isvector(xi))
     Pidx = reshape (Pidx, [xn, k, d]);
     Pidx = shiftdim (Pidx, 1);
     dimvec = [d, xn];
   else
     Pidx = reshape (Pidx, [sxi, k, d]);
     Pidx = shiftdim (Pidx, length (sxi));
     dimvec = [d, sxi];
@@ -78,38 +78,38 @@ function yi = ppval (pp, xi)
   dx = reshape (dx, dimvec);
   dx = shiftdim (dx, ndv - 1);
 
   ## Use Horner scheme.
   yi = Pidx;
   if (k > 1)
     yi = shiftdim (reshape (Pidx(1,:), dimvec), ndv - 1);
   endif
-  
+
   for i = 2 : k;
     yi .*= dx;
     yi += shiftdim (reshape (Pidx(i,:), dimvec), ndv - 1);
   endfor
-  
+
   ## Adjust shape.
   if ((numel (xi) > 1) || (length (d) == 1))
     yi = reshape (shiftdim (yi, 1), dimvec);
   endif
 
   if (isvector (xi) && (d == 1))
     yi = reshape (yi, sxi);
   elseif (isfield (pp, "orient") && strcmp (pp.orient, "first"))
     yi = shiftdim(yi, nd);
   endif
 
   ##
   #if (d == 1)
   #  yi = reshape (yi, sxi);
   #endif
-  
+
 endfunction
 
 %!shared b,c,pp,pp2,xi,abserr
 %! b = 1:3; c = ones(2); pp=mkpp(b,c);abserr = 1e-14;pp2=mkpp(b,[c;c],2);
 %! xi = [1.1 1.3 1.9 2.1];
 %!assert (ppval(pp,1.1), 1.1, abserr);
 %!assert (ppval(pp,2.1), 1.1, abserr);
 %!assert (ppval(pp,xi), [1.1 1.3 1.9 1.1], abserr);
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek 
+## Copyright (C) 2008-2011 Jaroslav Hajek
 ## Copyright (C) 2000, 2006-2007 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -10,66 +10,66 @@
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##  
+##
 ## @deftypefn {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, ...)
 ## Solve @code{A x = b} using the Bi-conjugate gradient iterative method.
 ##
 ## @itemize @minus
-## @item @var{rtol} is the relative tolerance, if not given 
+## @item @var{rtol} is the relative tolerance, if not given
 ## or set to [] the default value 1e-6 is used.
-## @item @var{maxit} the maximum number of outer iterations, 
-## if not given or set to [] the default value 
+## @item @var{maxit} the maximum number of outer iterations,
+## if not given or set to [] the default value
 ## @code{min (20, numel (b))} is used.
-## @item @var{x0} the initial guess, if not given or set to [] 
-## the default value @code{zeros (size (b))} is used. 
+## @item @var{x0} the initial guess, if not given or set to []
+## the default value @code{zeros (size (b))} is used.
 ## @end itemize
 ##
-## @var{A} can be passed as a matrix or as a function handle or 
+## @var{A} can be passed as a matrix or as a function handle or
 ## inline function @code{f} such that @code{f(x, "notransp") = A*x}
 ## and @code{f(x, "transp") = A'*x}.
 ##
-## The preconditioner @var{P} is given as @code{P = M1 * M2}. 
-## Both @var{M1} and @var{M2} can be passed as a matrix or as 
-## a function handle or inline function @code{g} such that 
-## @code{g(x, 'notransp') = M1 \ x} or @code{g(x, 'notransp') = M2 \ x} and 
+## The preconditioner @var{P} is given as @code{P = M1 * M2}.
+## Both @var{M1} and @var{M2} can be passed as a matrix or as
+## a function handle or inline function @code{g} such that
+## @code{g(x, 'notransp') = M1 \ x} or @code{g(x, 'notransp') = M2 \ x} and
 ## @code{g(x, 'transp') = M1' \ x} or @code{g(x, 'transp') = M2' \ x}.
 ##
 ## If colled with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ## @item 1: the maximum number of iterations was reached before convergence
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
 ## @item @var{relres} is the final value of the relative residual.
-## @item @var{iter} is the number of iterations performed. 
+## @item @var{iter} is the number of iterations performed.
 ## @item @var{resvec} is a vector containing the relative residual at each iteration.
 ## @end itemize
 ##
 ## @seealso{bicgstab,cgs,gmres,pcg}
 ##
 ## @end deftypefn
 
 
 function [x, flag, res1, k, resvec] = bicg (A, b, tol, maxit, M1, M2, x0)
 
   if (nargin >= 2 && isvector (full (b)))
-    
+
     if (ischar (A))
       fun = str2func (A);
       Ax  = @(x) feval (fun, x, "notransp");
       Atx = @(x) feval (fun, x, "transp");
     elseif (ismatrix (A))
       Ax  = @(x) A  * x;
       Atx = @(x) A' * x;
     elseif (isa (A, "function_handle"))
@@ -100,17 +100,17 @@ function [x, flag, res1, k, resvec] = bi
       M1tm1x = @(x) M1' \ x;
     elseif (isa (M1, "function_handle"))
       M1m1x  = @(x) feval (M1, x, "notransp");
       M1tm1x = @(x) feval (M1, x, "transp");
     else
       error (["bicg: preconditioner is expected to " ...
               "be a function or matrix"]);
     endif
-    
+
     if (nargin < 6 || isempty (M2))
       M2m1x = @(x, ignore) x;
       M2tm1x = M2m1x;
     elseif (ischar (M2))
       fun = str2func (M2);
       M2m1x  = @(x) feval (fun, x, "notransp");
       M2tm1x = @(x) feval (fun, x, "transp");
     elseif (ismatrix (M2))
@@ -139,116 +139,116 @@ function [x, flag, res1, k, resvec] = bi
 
     d = Pm1x (r0);
     f = Ptm1x (s0);
 
     bnorm = norm (b);
     res0  = Inf;
 
     if (any (r0 != 0))
-      
+
       for k = 1:maxit
 
-	a  = (s0' * Pm1x (r0)) ./ (f' * Ax (d));
+        a  = (s0' * Pm1x (r0)) ./ (f' * Ax (d));
 
-	x += a * d;
-	y += conj (a) * f;
+        x += a * d;
+        y += conj (a) * f;
 
-	r1 = r0 - a * Ax (d);
-	s1 = s0 - conj (a) * Atx (f);
+        r1 = r0 - a * Ax (d);
+        s1 = s0 - conj (a) * Atx (f);
 
-	beta = (s1' * Pm1x (r1)) ./ (s0' * Pm1x (r0));
+        beta = (s1' * Pm1x (r1)) ./ (s0' * Pm1x (r0));
 
-	d = Pm1x (r1) + beta * d;
-	f = Ptm1x (s1) + conj (beta) * f;
+        d = Pm1x (r1) + beta * d;
+        f = Ptm1x (s1) + conj (beta) * f;
 
-	r0 = r1;
-	s0 = s1;
+        r0 = r1;
+        s0 = s1;
 
-	res1 = norm (b - Ax (x)) / bnorm;
-	if (res1 < tol)
+        res1 = norm (b - Ax (x)) / bnorm;
+        if (res1 < tol)
           flag = 0;
           if (nargout < 2)
-	    printf ("bicg converged at iteration %i ", k);
+            printf ("bicg converged at iteration %i ", k);
             printf ("to a solution with relative residual %e\n", res1);
           endif
-	  break;
-	endif
-	
-	if (res0 <= res1)
+          break;
+        endif
+
+        if (res0 <= res1)
           flag = 3;
-	  printf ("bicg stopped at iteration %i ", k);
+          printf ("bicg stopped at iteration %i ", k);
           printf ("without converging to the desired tolerance %e\n", tol);
           printf ("because the method stagnated.\n");
           printf ("The iterate returned (number %i) ", k-1);
           printf ("has relative residual %e\n", res0);
-	  break
-	endif
+          break
+        endif
         res0 = res1;
         if (nargout > 4)
           resvec(k) = res0;
         endif
       endfor
 
       if (k == maxit)
         flag = 1;
-	printf ("bicg stopped at iteration %i ", maxit);
+        printf ("bicg stopped at iteration %i ", maxit);
         printf ("without converging to the desired tolerance %e\n", tol);
         printf ("because the maximum number of iterations was reached. ");
         printf ("The iterate returned (number %i) has ", maxit);
         printf ("relative residual %e\n", res1);
       endif
 
     else
       flag = 0;
       if (nargout < 2)
         printf ("bicg converged after 0 interations\n");
       endif
     endif
-  
+
   else
     print_usage ();
   endif
-  
+
 endfunction;
 
 
 %!test
-%! n = 100; 
+%! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
-%! b = sum (A, 2); 
-%! tol = 1e-8; 
+%! b = sum (A, 2);
+%! tol = 1e-8;
 %! maxit = 15;
-%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n); 
-%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n); 
+%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
+%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 %!
 %!test
-%! n = 100; 
+%! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
-%! b = sum (A, 2); 
-%! tol = 1e-8; 
+%! b = sum (A, 2);
+%! tol = 1e-8;
 %! maxit = 15;
-%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n); 
-%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n); 
+%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
+%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %!
 %! function y = afun (x, t, a)
 %!  switch t
 %!   case "notransp"
 %!     y = a * x;
 %!   case "transp"
 %!     y = a' * x;
 %!  endswitch
 %! endfunction
 %!
-%! [x, flag, relres, iter, resvec] = bicg (@(x, t) afun (x, t, A), 
+%! [x, flag, relres, iter, resvec] = bicg (@(x, t) afun (x, t, A),
 %!                                         b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
-%! n = 100; 
-%! tol = 1e-8; 
+%! n = 100;
+%! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a' * a + 100 * eye (n);
-%! b = sum (A, 2); 
+%! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -13,74 +13,74 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##  
+##
 ## @deftypefn {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicgstab (@var{A}, @var{b}, ...)
 ## Solve @code{A x = b} using the stabilizied Bi-conjugate gradient iterative method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given or set to
 ## [] the default value 1e-6 is used.
 ## @item @var{maxit} the maximum number of outer iterations, if not
 ## given or set to [] the default value @code{min (20, numel (b))} is
 ## used.
 ## @item @var{x0} the initial guess, if not given or set to [] the
 ## default value @code{zeros (size (b))} is used.
 ## @end itemize
 ##
-## @var{A} can be passed as a matrix or as a function handle or 
+## @var{A} can be passed as a matrix or as a function handle or
 ## inline function @code{f} such that @code{f(x) = A*x}.
 ##
-## The preconditioner @var{P} is given as @code{P = M1 * M2}. 
-## Both @var{M1} and @var{M2} can be passed as a matrix or as a function handle or 
+## The preconditioner @var{P} is given as @code{P = M1 * M2}.
+## Both @var{M1} and @var{M2} can be passed as a matrix or as a function handle or
 ## inline function @code{g} such that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ## @item 1: the maximum number of iterations was reached before convergence
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
 ## @item @var{relres} is the final value of the relative residual.
-## @item @var{iter} is the number of iterations performed. 
+## @item @var{iter} is the number of iterations performed.
 ## @item @var{resvec} is a vector containing the relative residual at each iteration.
 ## @end itemize
 ##
 ## @seealso{bicg,cgs,gmres,pcg}
 ##
 ## @end deftypefn
 
-function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, 
+function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit,
                                                      M1, M2, x0)
 
   if (nargin >= 2 && nargin <= 7 && isvector (full (b)))
-    
+
     if (ischar (A))
       A = str2func (A);
     elseif (ismatrix (A))
       Ax  = @(x) A  * x;
     elseif (isa (A, "function_handle"))
       Ax  = @(x) feval (A, x);
     else
       error (["bicgstab: first argument is expected " ...
               "to be a function or a square matrix"]);
     endif
-    
+
     if (nargin < 3 || isempty (tol))
       tol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
     endif
 
@@ -91,17 +91,17 @@ function [x, flag, relres, iter, resvec]
     elseif (ismatrix (M1))
       M1m1x = @(x) M1  \ x;
     elseif (isa (M1, "function_handle"))
       M1m1x = @(x) feval (M1, x);
     else
       error (["bicgstab: preconditioner is " ...
               "expected to be a function or matrix"]);
     endif
-    
+
     if (nargin < 6 || isempty (M2))
       M2m1x = @(x) x;
     elseif (ischar (M2))
       M2m1x = str2func (M2);
     elseif (ismatrix (M2))
       M2m1x = @(x) M2  \ x;
     elseif (isa (M2, "function_handle"))
       M2m1x = @(x) feval (M2, x);
@@ -110,17 +110,17 @@ function [x, flag, relres, iter, resvec]
               "expected to be a function or matrix"]);
     endif
 
     precon = @(x) M2m1x (M1m1x (x));
 
     if (nargin < 7 || isempty (x0))
       x0 = zeros (size (b));
     endif
-    
+
     ## specifies initial estimate x0
     if (nargin < 7)
       x = zeros (rows (b), 1);
     else
       x = x0;
     endif
 
     norm_b = norm (b);
@@ -201,38 +201,38 @@ endfunction
 %! % Solve system of A*x=b
 %! A = [5 -1 3;-1 2 -2;3 -2 3]
 %! b = [7;-1;4]
 %! [x, flag, relres, iter, resvec] = bicgstab(A, b)
 
 %!shared A, b, n, M1, M2
 %!
 %!test
-%! n = 100; 
+%! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
-%! b = sum (A, 2); 
-%! tol = 1e-8; 
+%! b = sum (A, 2);
+%! tol = 1e-8;
 %! maxit = 15;
-%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n); 
-%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n); 
+%! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
+%! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 %!
 %!test
-%! tol = 1e-8; 
+%! tol = 1e-8;
 %! maxit = 15;
 %!
 %! function y = afun (x, a)
 %!     y = a * x;
 %! endfunction
 %!
-%! [x, flag, relres, iter, resvec] = bicgstab (@(x) afun (x, A), b, 
+%! [x, flag, relres, iter, resvec] = bicgstab (@(x) afun (x, A), b,
 %!                                             tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
-%! n = 100; 
-%! tol = 1e-8; 
+%! n = 100;
+%! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
-%! b = sum (A, 2); 
+%! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -13,95 +13,95 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##  
+##
 ## @deftypefn {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} cgs (@var{A}, @var{b}, ...)
 ## Solve @code{A x = b}, where @var{A} is a square matrix, using the
 ## Conjugate Gradients Squared method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given or set to []
 ## the default value 1e-6 is used.
 ## @item @var{maxit} the maximum number of outer iterations, if not
 ## given or set to [] the default value @code{min (20, numel (b))} is
 ## used.
 ## @item @var{x0} the initial guess, if not given or set to [] the
 ## default value @code{zeros (size (b))} is used.
 ## @end itemize
 ##
-## @var{A} can be passed as a matrix or as a function handle or 
+## @var{A} can be passed as a matrix or as a function handle or
 ## inline function @code{f} such that @code{f(x) = A*x}.
 ##
-## The preconditioner @var{P} is given as @code{P = M1 * M2}. 
+## The preconditioner @var{P} is given as @code{P = M1 * M2}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
 ## @code{g(x) = M2 \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ## @item 1: the maximum number of iterations was reached before convergence
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
 ## @item @var{relres} is the final value of the relative residual.
-## @item @var{iter} is the number of iterations performed. 
+## @item @var{iter} is the number of iterations performed.
 ## @item @var{resvec} is a vector containing the relative residual at
 ## each iteration.
 ## @end itemize
 ##
 ## @seealso{pcg,bicgstab,bicg,gmres}
 ## @end deftypefn
 
 function [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M1, M2, x0)
 
   if (nargin >= 2 && nargin <= 7 && isvector (full (b)))
-    
+
     if (ischar (A))
       A = str2func (A);
     elseif (ismatrix (A))
       Ax = @(x) A * x;
     elseif (isa (A, "function_handle"))
       Ax = @(x) feval (A, x);
     else
-      error (["cgs: first argument is expected to "... 
+      error (["cgs: first argument is expected to "...
               "be a function or a square matrix"]);
     endif
-    
+
     if (nargin < 3 || isempty (tol))
       tol = 1e-6;
     endif
-    
+
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
     endif
-    
+
     if (nargin < 5 || isempty (M1))
       M1m1x = @(x) x;
     elseif (ischar (M1))
       M1m1x = str2func (M1);
     elseif (ismatrix (M1))
       M1m1x = @(x) M1 \ x;
     elseif (isa (M1, "function_handle"))
       M1m1x = @(x) feval (M1, x);
     else
       error ("cgs: preconditioner is expected to be a function or matrix");
     endif
-    
+
     if (nargin < 6 || isempty (M2))
       M2m1x = @(x) x;
     elseif (ischar (M2))
       M2m1x = str2func (M2);
     elseif (ismatrix (M2))
       M2m1x = @(x) M2 \ x;
     elseif (isa (M2, "function_handle"))
       M2m1x = @(x) feval (M2, x);
@@ -110,19 +110,19 @@ function [x, flag, relres, iter, resvec]
     endif
 
     precon = @(x) M2m1x (M1m1x (x));
 
     if (nargin < 7 || isempty (x0))
       x0 = zeros (size (b));
     endif
 
-    
+
     x = x0;
-    
+
     res = b - Ax (x);
     norm_b = norm (b);
     ## Vector of the residual norms for each iteration.
     resvec = norm (res) / norm_b;
     ro = 0;
     ## Default behavior we don't reach tolerance tol within maxit iterations.
     flag = 1;
     for iter = 1:maxit
@@ -187,32 +187,32 @@ endfunction
 %! % Solve system of A*x=b
 %! A=[5 -1 3;-1 2 -2;3 -2 3]
 %! b=[7;-1;4]
 %! [a,b,c,d,e]=cgs(A,b)
 
 %!shared A, b, n, M
 %!
 %!test
-%! n = 100; 
+%! n = 100;
 %! A = spdiags ([-ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
-%! b = sum (A, 2); 
-%! tol = 1e-8; 
+%! b = sum (A, 2);
+%! tol = 1e-8;
 %! maxit = 1000;
-%! M = 4*eye (n);  
+%! M = 4*eye (n);
 %! [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M);
 %! assert (x, ones (size (b)), 1e-7);
 %!
 %!test
-%! tol = 1e-8; 
+%! tol = 1e-8;
 %! maxit = 15;
 %!
 %! [x, flag, relres, iter, resvec] = cgs (@(x) A * x, b, tol, maxit, M);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
-%! n = 100; 
-%! tol = 1e-8; 
+%! n = 100;
+%! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
-%! b = sum (A, 2); 
+%! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = cgs (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 2009-2011 Carlo de Falco
-##  
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at your
 ## option) any later version.
-## 
+##
 ## Octave is distributed in the hope that it will be useful, but WITHOUT
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} gmres (@var{A}, @var{b}, @var{m}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} gmres (@var{A}, @var{b}, @var{m}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} gmres (@dots{})
@@ -63,19 +63,19 @@
 ## @end itemize
 ##
 ## @seealso{bicg, bicgstab, cgs, pcg}
 ## @end deftypefn
 
 function [x, flag, presn, it] = gmres (A, b, restart, rtol, maxit, M1, M2, x0)
 
   if (nargin < 2 || nargin > 8)
-    print_usage ();    
+    print_usage ();
   end
-      
+
   if (ischar (A))
     Ax = str2func (A);
   elseif (ismatrix (A))
     Ax = @(x) A*x;
   elseif (isa (A, "function_handle"))
     Ax = A;
   else
     error ("gmres: A must be a function or matrix");
@@ -99,17 +99,17 @@ function [x, flag, presn, it] = gmres (A
     M1m1x = str2func (M1);
   elseif (ismatrix (M1))
     M1m1x = @(x) M1 \ x;
   elseif (isa (M1, "function_handle"))
     M1m1x = M1;
   else
     error ("gmres: preconditioner M1 must be a function or matrix");
   endif
-  
+
   if (nargin < 7 || isempty (M2))
     M2m1x = @(x) x;
   elseif (ischar (M2))
     M2m1x = str2func (M2);
   elseif (ismatrix (M2))
     M2m1x = @(x) M2 \ x;
   elseif (isa (M2, "function_handle"))
     M2m1x = M2;
@@ -118,67 +118,67 @@ function [x, flag, presn, it] = gmres (A
   endif
 
   Pm1x = @(x) M2m1x (M1m1x (x));
 
   if (nargin < 8 || isempty (x0))
     x0 = zeros (size (b));
   endif
 
-  x_old = x0; 
+  x_old = x0;
   x = x_old;
   prec_res = Pm1x (b - Ax (x_old));
   presn = norm (prec_res, 2);
-  
+
   B = zeros (restart + 1, 1);
   V = zeros (rows (x), restart);
   H = zeros (restart + 1, restart);
 
   ## begin loop
   iter = 1;
-  restart_it  = restart + 1; 
+  restart_it  = restart + 1;
   resids      = zeros (maxit, 1);
   resids(1)   = presn;
   prec_b_norm = norm (Pm1x (b), 2);
   flag        = 1;
 
   while (iter <= maxit * restart && presn > rtol * prec_b_norm)
-  
+
     ## restart
     if (restart_it > restart)
       restart_it = 1;
-      x_old = x;	      
+      x_old = x;
       prec_res = Pm1x (b - Ax (x_old));
       presn = norm (prec_res, 2);
       B(1) = presn;
       H(:) = 0;
       V(:, 1) = prec_res / presn;
-    endif  
-    
+    endif
+
     ## basic iteration
     tmp = Pm1x (Ax (V(:, restart_it)));
     [V(:,restart_it+1), H(1:restart_it+1, restart_it)] = ...
         mgorth (tmp, V(:,1:restart_it));
-    
+
     Y = (H(1:restart_it+1, 1:restart_it) \ B (1:restart_it+1));
-	      
+
     little_res = B(1:restart_it+1) - ...
         H(1:restart_it+1, 1:restart_it) * Y(1:restart_it);
 
     presn = norm (little_res, 2);
-	      
+
     x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
-    
+
     resids(iter) = presn;
     if (norm (x - x_old, inf) <= eps)
       flag = 3;
       break
     endif
 
-    restart_it++ ; 
+    restart_it++ ;
     iter++;
   endwhile
 
   if (presn > rtol * prec_b_norm)
     flag = 0;
   endif
 
   resids = resids(1:iter-1);
@@ -186,22 +186,22 @@ function [x, flag, presn, it] = gmres (A
 
 endfunction
 
 
 %!shared A, b, dim
 %! dim = 100;
 %!test
 %! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
-%! b = ones(dim, 1); 
+%! b = ones(dim, 1);
 %! x = gmres (A, b, 10, 1e-10, dim, @(x) x./diag(A), [],  b);
 %! assert(x, A\b, 1e-9*norm(x,inf));
 %!
 %!test
-%! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag(diag(A))\x, [],  b);  
+%! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag(diag(A))\x, [],  b);
 %! assert(x, A\b, 1e-7*norm(x,inf));
 %!
 %!test
 %! A = spdiags ([[1./(2:2:2*(dim-1)) 0]; 1./(1:2:2*dim-1); [0 1./(2:2:2*(dim-1))]]', -1:1, dim, dim);
 %! A = A'*A;
 %! b = rand (dim, 1);
 %! [x, resids] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag(A), [],  []);
 %! assert(x, A\b, 1e-9*norm(x,inf))
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -44,17 +44,17 @@ function s = spconvert (m)
 
 endfunction
 
 
 %!test
 %! i = [1; 3; 5];
 %! j = [2; 4; 6];
 %! v = [7; 8; 9];
-%! s = spconvert ([i, j, v]); 
+%! s = spconvert ([i, j, v]);
 %! assert (issparse (s));
 %! [fi, fj, fv] = find (s);
 %! assert (isequal (i, fi) && isequal (j, fj) && isequal (v, fv));
 %! s = spconvert ([i, j, v, j]);
 %! [fi, fj, fv] = find (s);
 %! assert (isequal (i, fi) && isequal (j, fj) && isequal (complex (v, j), fv));
 %! assert (size (spconvert ([1, 1, 3; 5, 15, 0])), [5, 15]);
 
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -30,17 +30,17 @@
 ## @group
 ## nthroot (-1, 3)
 ## @result{} -1
 ## (-1) ^ (1 / 3)
 ## @result{} 0.50000 - 0.86603i
 ## @end group
 ## @end example
 ##
-## @var{x} must have all real entries.  @var{n} must be a scalar. 
+## @var{x} must have all real entries.  @var{n} must be a scalar.
 ## If @var{n} is an even integer and @var{X} has negative entries, an
 ## error is produced.
 ## @seealso{realsqrt, sqrt, cbrt}
 ## @end deftypefn
 
 function y = nthroot (x, n)
 
   if (nargin != 2)
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -22,17 +22,17 @@
 ## @deftypefn  {Function File} {} strmatch (@var{s}, @var{A})
 ## @deftypefnx {Function File} {} strmatch (@var{s}, @var{A}, "exact")
 ## Return indices of entries of @var{A} which begin with the string @var{s}.
 ## The second argument @var{A} must be a string, character matrix, or a cell
 ## array of strings.  If the third argument @code{"exact"} is not given, then
 ## @var{s} only needs to match @var{A} up to the length of @var{s}.
 ## Trailing spaces and nulls in @var{s} and @var{A} are ignored when matching.
 ## option.
-## 
+##
 ## For example:
 ##
 ## @example
 ## @group
 ## strmatch ("apple", "apple juice")
 ##      @result{} 1
 ##
 ## strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -52,23 +52,23 @@
 
 function s = untabify (t, tw = 8, dblank = false)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   elseif (! (ischar (t) || iscellstr (t)))
     error ("untabify: T must be a string or cellstring");
   endif
- 
+
   if (ischar (t))
     s = replace_tabs (t, tw);
   else
     s = cellfun (@(str) replace_tabs (str, tw), t, "uniformoutput", false);
   endif
- 
+
   if (dblank)
     s = deblank (s);
   endif
 
 endfunction
 
 function s = replace_tabs (t, tw)
 
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -92,17 +92,17 @@ function demo (name, n)
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin < 2)
     n = 0;
   elseif (ischar (n))
     n = str2double (n);
-  endif 
+  endif
 
   [code, idx] = test (name, "grabdemo");
   if (isempty (idx))
     warning ("no demo available for %s", name);
     return;
   elseif (n >= length (idx))
     warning ("only %d demos available for %s", length (idx) - 1, name);
     return;
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -40,17 +40,17 @@ function [code_r, idx_r] = example (name
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin < 2)
     n = 0;
   elseif (ischar (n))
     n = str2double (n);
-  endif 
+  endif
 
   [code, idx] = test (name, "grabdemo");
   if (nargout > 0)
     if (n > 0)
       if (n <= length (idx))
         code_r = code(idx(n):idx(n+1)-1);
         idx_r = [1, length(code_r)+1];
       else
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -722,12 +722,12 @@ filter (MArray<FloatComplex>&, MArray<Fl
 %!error (filter([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'));
 %!assert(filter([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21]);
 %% Test of DIM parameter
 %!test
 %! x = ones (2, 1, 3, 4);
 %! x(1,1,:,:) = [1 2 3 4; 5 6 7 8; 9 10 11 12];
 %! y0 = [1 1 6 2 15 3 2 1 8 2 18 3 3 1 10 2 21 3 4 1 12 2 24 3];
 %! y0 = reshape (y0, size (x));
-%! y = filter([1 1 1], 1, x, [], 3); 
+%! y = filter([1 1 1], 1, x, [], 3);
 %! assert (y, y0);
 
 */
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/DLD-FUNCTIONS/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/DLD-FUNCTIONS/mgorth.cc
@@ -26,18 +26,18 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "oct-norm.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 
 template <class ColumnVector, class Matrix, class RowVector>
-static void 
-do_mgorth (ColumnVector& x, const Matrix& V, RowVector& h) 
+static void
+do_mgorth (ColumnVector& x, const Matrix& V, RowVector& h)
 {
   octave_idx_type Vc = V.columns ();
   h = RowVector (Vc + 1);
   for (octave_idx_type j = 0; j < Vc; j++)
     {
       ColumnVector Vcj = V.column (j);
       h(j) = RowVector (Vcj.hermitian ()) * x;
       x -= h(j) * Vcj;
@@ -66,17 +66,17 @@ On exit, @var{y} is a unit vector such t
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length();
 
   if (nargin != 2 || nargout > 2)
   {
-    print_usage (); 
+    print_usage ();
     return retval;
   }
 
   octave_value arg_x = args(0);
   octave_value arg_v = args(1);
 
   if (arg_v.ndims () != 2 || arg_x.ndims () != 2 || arg_x.columns () != 1
       || arg_v.rows () != arg_x.rows ())
@@ -85,17 +85,17 @@ On exit, @var{y} is a unit vector such t
              " the same number of rows as V.");
       return retval;
     }
 
   if (! arg_x.is_numeric_type () && ! arg_v.is_numeric_type ())
     {
       error ("mgorth: X and V must be numeric");
     }
- 
+
   bool iscomplex = (arg_x.is_complex_type () || arg_v.is_complex_type ());
   if (arg_x.is_single_type () || arg_v.is_single_type ())
     {
       if (iscomplex)
         {
           FloatComplexColumnVector x = arg_x.float_complex_column_vector_value ();
           FloatComplexMatrix V = arg_v.float_complex_matrix_value ();
           FloatComplexRowVector h;
@@ -134,17 +134,17 @@ On exit, @var{y} is a unit vector such t
           retval(0) = x;
         }
     }
 
   return retval;
 }
 
 /*
-  
+
 %!test
 %! for ii=1:100; assert (abs (mgorth (randn (5, 1), eye (5, 4))), [0 0 0 0 1]', eps); endfor
 
 %!test
 %! a = hilb (5);
 %! a(:, 1) /= norm (a(:, 1));
 %! for ii = 1:5
 %!   a(:, ii) = mgorth (a(:, ii), a(:, 1:ii-1));
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1631,17 +1631,17 @@ Mathematical Software, Vol. 37, Issue 3,
   else if (!(args(4).is_real_scalar () || args(4).is_real_matrix ()))
     {
       error ("quadcc: list of singularities (SING) must be a vector of real values");
       return retval;
     }
   else
     {
       nivals = 1 + args(4).length ();
-      if (nivals > cquad_heapsize) 
+      if (nivals > cquad_heapsize)
         {
           error ("quadcc: maximum number of singular points is limited to %i",
                  cquad_heapsize-1);
           return retval;
         }
       sing = args(4).array_value ().fortran_vec ();
       iivals[0] = a;
       for (i = 0; i < nivals - 2; i++)
@@ -2238,17 +2238,17 @@ Mathematical Software, Vol. 37, Issue 3,
   if (nargout > 1)
     retval(1) = err;
   retval(0) = igral;
   /* All is well that ends well. */
   return retval;
 }
 
 
-/* 
+/*
 
 %!assert (quadcc(@sin,-pi,pi), 0, 1e-6)
 %!assert (quadcc(inline('sin'),-pi,pi), 0, 1e-6)
 %!assert (quadcc('sin',-pi,pi), 0, 1e-6)
 
 %!assert (quadcc(@sin,-pi,0), -2, 1e-6)
 %!assert (quadcc(@sin,0,pi), 2, 1e-6)
 %!assert (quadcc(@(x) 1./sqrt(x), 0, 1), 2, 1e-6)
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -266,32 +266,32 @@ risk of using @code{eval} on unknown dat
         {
           const string_vector sv = args(0).all_strings ();
           if (! error_state)
             retval = sv.map<Complex> (str2double1);
         }
     }
   else if (args(0).is_cell ())
     {
-      const Cell cell = args(0).cell_value (); 
+      const Cell cell = args(0).cell_value ();
 
       if (! error_state)
       {
         ComplexNDArray output (cell.dims (), octave_NaN);
         for (octave_idx_type i = 0; i < cell.numel (); i++)
         {
           if (cell(i).is_string ())
             output(i) = str2double1 (cell(i).string_value ());
         }
         retval = output;
       }
     }
   else
     retval = NDArray (args(0).dims (), octave_NaN);
-  
+
 
   return retval;
 }
 
 /*
 
 %!assert (str2double ("1"), 1)
 %!assert (str2double ("-.1e-5"), -1e-6)
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,35 +1,35 @@
 # Makefile for octave's src directory
 #
 # Copyright (C) 1993-2011 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 AM_CPPFLAGS = \
   @CPPFLAGS@ -I../libgnu -I$(top_srcdir)/libgnu \
   -I$(top_srcdir)/libcruft/misc \
   -I../liboctave -I$(top_srcdir)/liboctave \
-  -I. -I$(srcdir) 
+  -I. -I$(srcdir)
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 octlib_LTLIBRARIES = liboctinterp.la
 
 if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
 bin_PROGRAMS = \
   mkoctfile \
@@ -51,17 +51,17 @@ else
 bin_PROGRAMS = \
   octave
 
 bin_SCRIPTS = \
   mkoctfile \
   octave-config
 endif
 
-## Order matters here.  Leave builtins.cc last, because it depends on 
+## Order matters here.  Leave builtins.cc last, because it depends on
 ## $(DEF_FILES), and building those requires all the sources
 ## (except builtins.cc) to be available.
 BUILT_SOURCES = \
   $(BUILT_SOURCES_EXTRA) \
   defaults.h \
   graphics.h \
   graphics-props.cc \
   lex.cc \
@@ -563,17 +563,17 @@ DLL_CXXDEFS = @OCTINTERP_DLL_DEFS@
 
 ## Rule to build a DEF file from a .cc file
 %.df: %.cc
 	$(CXXCPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	  $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) \
 	  -DMAKE_BUILTINS $< | $(srcdir)/mkdefs $(srcdir) $< > $@-t
 	mv $@-t $@
 
-## Special rules:  
+## Special rules:
 ## Mostly for sources which must be built before rest of compilation.
 
 ## defaults.h and oct-conf.h must depend on Makefile.  Calling configure
 ## may change default/config values.  However, calling configure will also
 ## regenerate the Makefiles from Makefile.am and trigger the rules below.
 defaults.h: defaults.h.in Makefile
 	@$(do_subst_default_vals)
 
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -1265,17 +1265,17 @@ opengl_renderer::draw_axes_z_grid (const
                                   yPlaneN, yPlane, 0.,
                                   signum(yPlaneN-yPlane)*fy*zticklen/2,
                                   0., 2, mirror);
               else
                 render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                   yPlaneN, yPlaneN,
                                   signum(xPlane-xPlaneN)*fx*zticklen/2,
                                   0., 0., 2, false);
-            }            
+            }
         }
 
       gh_manager::get_object (props.get_zlabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_zlabel ()).set ("visible", "off");
 }
 
@@ -2369,17 +2369,17 @@ opengl_renderer::draw_patch (const patch
               if (mecolor.numel () == 0
                    && ! props.markeredgecolor_is ("none"))
                 mecolor = mc;
             }
           else
             {
               if (c.numel () == 0)
                 c = props.get_color_data ().matrix_value ();
-              has_markerfacecolor = ((c.numel () > 0) 
+              has_markerfacecolor = ((c.numel () > 0)
                                     && (c.rows () == f.rows ()));
             }
         }
 
 
       init_marker (props.get_marker (), props.get_markersize (),
                    props.get_linewidth ());
 
diff --git a/src/gl2ps-renderer.cc b/src/gl2ps-renderer.cc
--- a/src/gl2ps-renderer.cc
+++ b/src/gl2ps-renderer.cc
@@ -225,13 +225,13 @@ glps_renderer::draw_text (const text::pr
   glRasterPos3d (pos(0), pos(1), pos(2));
 
   octave_value string_prop = props.get_string ();
 
   string_vector sv = string_prop.all_strings ();
 
   std::string s = sv.join ("\n");
 
-  gl2psTextOpt (s.c_str (), fontname.c_str (), fontsize, 
+  gl2psTextOpt (s.c_str (), fontname.c_str (), fontsize,
                 alignment_to_mode (halign, valign), props.get_rotation ());
 }
 
 #endif
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -3391,17 +3391,17 @@ axes::properties::sync_positions (const 
       position = pos;
       update_transform ();
       Matrix tightpos = calc_tightbox (pos);
 
       double thrshldx = 0.005*outpos(2);
       double thrshldy = 0.005*outpos(3);
       double minsizex = 0.2*outpos(2);
       double minsizey = 0.2*outpos(3);
-      bool updatex = true, updatey = true; 
+      bool updatex = true, updatey = true;
       for (int i = 0; i < 10; i++)
         {
           double dt;
           bool modified = false;
           dt = outpos(0)+outpos(2)-tightpos(0)-tightpos(2);
           if (dt < -thrshldx && updatex)
             {
               pos(2) += dt;
@@ -3464,17 +3464,17 @@ axes::properties::sync_positions (const 
       outerposition = calc_tightbox (outpos);
     }
 
   Matrix inset (1, 4, 1.0);
   inset(0) = pos(0)-outpos(0);
   inset(1) = pos(1)-outpos(1);
   inset(2) = outpos(0)+outpos(2)-pos(0)-pos(2);
   inset(3) = outpos(1)+outpos(3)-pos(1)-pos(3);
-  
+
   tightinset = inset;
 }
 
 void
 axes::properties::set_text_child (handle_property& hp,
                                   const std::string& who,
                                   const octave_value& v)
 {
@@ -4934,17 +4934,17 @@ axes::properties::get_extent (bool with_
                   ext(3) = std::max (ext(3), text_pos(1)-text_ext(1));
                 }
             }
         }
     }
 
   ext(2) = ext(2)-ext(0);
   ext(3) = ext(3)-ext(1);
-  
+
   return ext;
 }
 
 void
 axes::properties::set_units (const octave_value& v)
 {
   if (! error_state)
     {
@@ -5132,18 +5132,18 @@ magform (double x, double& a, int& b)
 {
   if (x == 0)
     {
       a = 0;
       b = 0;
     }
   else
     {
-      b = static_cast<int> (gnulib::floor (std::log10 (std::abs (x)))); 
-      a = x / std::pow (10.0, b); 
+      b = static_cast<int> (gnulib::floor (std::log10 (std::abs (x))));
+      a = x / std::pow (10.0, b);
     }
 }
 
 // A translation from Tom Holoryd's python code at
 // http://kurage.nimh.nih.gov/tomh/tics.py
 // FIXME -- add log ticks
 
 double
diff --git a/src/octave-config.cc.in b/src/octave-config.cc.in
--- a/src/octave-config.cc.in
+++ b/src/octave-config.cc.in
@@ -214,11 +214,11 @@ main (int argc, char **argv)
 	    }
 	}
       else
 	{
 	  std::cerr << "octave-config: unrecognized argument " << arg << std::endl;
 	  return 1;
 	}
     }
-  
+
   return 0;
 }
diff --git a/src/octave-config.in b/src/octave-config.in
--- a/src/octave-config.in
+++ b/src/octave-config.in
@@ -14,17 +14,17 @@
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
-## 
+##
 ## Original version by Rafael Laboissiere <rafael@laboissiere.net>
 ## distributed as free software in the public domain.
 
 API_VERSION=%OCTAVE_API_VERSION%
 CANONICAL_HOST_TYPE=%OCTAVE_CANONICAL_HOST_TYPE%
 DEFAULT_PAGER=%OCTAVE_DEFAULT_PAGER%
 ARCHLIBDIR=%OCTAVE_ARCHLIBDIR%
 BINDIR=%OCTAVE_BINDIR%
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -122,24 +122,24 @@ public:
     return dv.numel ();
   }
 
   octave_idx_type nfields (void) const { return map.nfields (); }
 
   size_t nparents (void) const { return parent_list.size (); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { 
+    {
       octave_class retval = octave_class (*this);
       retval.map = retval.map_value().reshape (new_dims);
       return octave_value (new octave_class (retval));
     }
 
   octave_value resize (const dim_vector& dv, bool = false) const
-    { 
+    {
       octave_class retval = octave_class (*this);
       retval.map.resize (dv);
       return octave_value (new octave_class (retval));
     }
 
   bool is_defined (void) const { return true; }
 
   bool is_map (void) const { return false; }
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -55,17 +55,17 @@ public:
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
 
   virtual std::string fcn_file_name (void) const { return std::string (); }
-  
+
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return std::string (); }
 
   virtual symbol_table::scope_id parent_fcn_scope (void) const { return -1; }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
diff --git a/src/profiler.cc b/src/profiler.cc
--- a/src/profiler.cc
+++ b/src/profiler.cc
@@ -113,17 +113,17 @@ profile_data_accumulator::tree_node::exi
 
 void
 profile_data_accumulator::tree_node::build_flat (flat_profile& data) const
 {
   // If this is not the top-level node, update profile entry for this function.
   if (fcn_id != 0)
     {
       stats& entry = data[fcn_id - 1];
-      
+
       entry.time += time;
       entry.calls += calls;
 
       assert (parent);
       if (parent->fcn_id != 0)
         {
           entry.parents.insert (parent->fcn_id);
           data[parent->fcn_id - 1].children.insert (fcn_id);
diff --git a/src/profiler.h b/src/profiler.h
--- a/src/profiler.h
+++ b/src/profiler.h
@@ -86,17 +86,17 @@ private:
     function_set parents;
     function_set children;
 
     // Convert a function_set list to an Octave array of indices.
     static octave_value function_set_value (const function_set&);
   };
 
   typedef std::vector<stats> flat_profile;
-  
+
   // Store data for one node in the call-tree of the hierarchical profiler
   // data we collect.
   class tree_node
   {
   public:
 
     tree_node (tree_node*, octave_idx_type);
     virtual ~tree_node ();
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -296,18 +296,18 @@ you should always use the @samp{&&} and 
   return SET_INTERNAL_VARIABLE (do_braindead_shortcircuit_evaluation);
 }
 
 /*
 
 %!test
 %! x = 0;
 %! do_braindead_shortcircuit_evaluation (0);
-%! if (1 | (x = 1)) 
+%! if (1 | (x = 1))
 %! endif
 %! assert (x, 1);
 %! do_braindead_shortcircuit_evaluation (1);
-%! if (1 | (x = 0)) 
+%! if (1 | (x = 0))
 %! endif
 %! assert (x, 1);
 
 */
 
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -69,17 +69,17 @@ tree_prefix_expression::rvalue1 (int)
     {
       if (etype == octave_value::op_incr || etype == octave_value::op_decr)
         {
           octave_lvalue ref = op->lvalue ();
 
           if (! error_state)
             {
               BEGIN_PROFILER_BLOCK ("prefix " + oper ())
-              
+
               ref.do_unary_op (etype);
 
               if (! error_state)
                 retval = ref.value ();
 
               END_PROFILER_BLOCK
             }
         }
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1506,20 +1506,20 @@ need to recompiled.\n\
 
   return retval;
 }
 
 /*
 %!shared old_state
 %! old_state = ignore_function_time_stamp ();
 %!test
-%! state = ignore_function_time_stamp ("all");  
+%! state = ignore_function_time_stamp ("all");
 %! assert (state, old_state);
 %! assert (ignore_function_time_stamp (), "all");
-%! state = ignore_function_time_stamp ("system");  
+%! state = ignore_function_time_stamp ("system");
 %! assert (state, "all");
 %! assert (ignore_function_time_stamp (), "system");
 %! ignore_function_time_stamp (old_state);
 
 %% Test input validation
 %!error (ignore_function_time_stamp ("all", "all"))
 %!error (ignore_function_time_stamp ("UNKNOWN_VALUE"))
 %!error (ignore_function_time_stamp (42))
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -197,17 +197,17 @@ private:
 };
 
 ft_manager* ft_manager::instance = 0;
 
 // ---------------------------------------------------------------------------
 
 ft_render::ft_render (void)
     : text_processor (), face (0), bbox (1, 4, 0.0),
-      xoffset (0), yoffset (0), multiline_halign (0), 
+      xoffset (0), yoffset (0), multiline_halign (0),
       multiline_align_xoffsets(), mode (MODE_BBOX),
       red (0), green (0), blue (0)
 {
 }
 
 ft_render::~ft_render (void)
 {
   if (face)
@@ -280,40 +280,40 @@ ft_render::visit (text_element_string& e
         multiline_align_xoffsets.clear();
       else if (mode == MODE_RENDER)
         xoffset += multiline_align_xoffsets[line_index];
 
       for (size_t i = 0; i < str.length (); i++)
         {
           glyph_index = FT_Get_Char_Index (face, str[i]);
 
-          if (str[i] != '\n' 
+          if (str[i] != '\n'
               && (! glyph_index
               || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT)))
             ::warning ("ft_render: skipping missing glyph for character `%c'",
                        str[i]);
           else
             {
               switch (mode)
                 {
                 case MODE_RENDER:
                   if (str[i] == '\n')
                     {
                     glyph_index = FT_Get_Char_Index(face, ' ');
                     if (!glyph_index || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                       {
                         ::warning ("ft_render: skipping missing glyph for character ` '");
-                      } 
-                    else 
+                      }
+                    else
                       {
                         line_index++;
                         xoffset = multiline_align_xoffsets[line_index];
                         yoffset -= (face->size->metrics.height >> 6);
                       }
-                  } 
+                  }
                   else if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
                     ::warning ("ft_render: unable to render glyph for character `%c'",
                                str[i]);
                   else
                     {
                       FT_Bitmap& bitmap = face->glyph->bitmap;
                       int x0, y0;
 
@@ -367,21 +367,21 @@ ft_render::visit (text_element_string& e
                         ::warning ("ft_render: skipping missing glyph for character ` '");
                       }
                     else
                       {
                         multiline_align_xoffsets.push_back(box_line_width);
                         // Reset the pixel width for this newline, so we don't
                         // allocate a bounding box larger than the horizontal
                         // width of the multi-line
-                        box_line_width = 0; 
+                        box_line_width = 0;
                         bbox(1) -= (face->size->metrics.height >> 6);
                       }
-                    } 
-                  else 
+                    }
+                  else
                     {
                     // width
                     if (previous)
                       {
                         FT_Vector delta;
 
                         FT_Get_Kerning (face, previous, glyph_index,
                                         FT_KERNING_DEFAULT, &delta);
@@ -422,29 +422,29 @@ ft_render::visit (text_element_string& e
                 if (str[i] == '\n')
                   previous = 0;
                 else
                   previous = glyph_index;
             }
         }
       if (mode == MODE_BBOX)
         {
-          /* Push last the width associated with the last line */ 
+          /* Push last the width associated with the last line */
           multiline_align_xoffsets.push_back(box_line_width);
 
           for (unsigned int i = 0; i < multiline_align_xoffsets.size(); i++)
             {
             /* Center align */
-            if (multiline_halign == 1) 
+            if (multiline_halign == 1)
               multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i])/2;
             /* Right align */
             else if (multiline_halign == 2)
               multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i]);
             /* Left align */
-            else 
+            else
               multiline_align_xoffsets[i] = 0;
             }
         }
     }
 }
 
 void
 ft_render::reset (void)
@@ -552,17 +552,17 @@ ft_render::get_extent (text_element *elt
 }
 
 Matrix
 ft_render::get_extent (const std::string& txt, double rotation)
 {
   text_element *elt = text_parser_none ().parse (txt);
   Matrix extent = get_extent (elt, rotation);
   delete elt;
-  
+
   return extent;
 }
 
 int
 ft_render::rotation_to_mode (double rotation) const
 {
   if (rotation == 0.0)
     return ROTATION_0;
@@ -578,17 +578,17 @@ ft_render::rotation_to_mode (double rota
 
 void
 ft_render::text_to_pixels (const std::string& txt,
                            uint8NDArray& pixels_, Matrix& box,
                            int halign, int valign, double rotation)
 {
   // FIXME: clip "rotation" between 0 and 360
   int rot_mode = rotation_to_mode (rotation);
-  
+
   multiline_halign = halign;
 
   text_element *elt = text_parser_none ().parse (txt);
   pixels_ = render (elt, box, rot_mode);
   delete elt;
 
   if (pixels_.numel () == 0)
     {
