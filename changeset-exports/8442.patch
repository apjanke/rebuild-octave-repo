# HG changeset patch
# User Thorsten Meyer <thorsten.meyier@gmx.de>
# Date 1231139463 -3600
#      Mon Jan 05 08:11:03 2009 +0100
# Node ID 502e58a0d44fb7b8ccdff0f2af7d88f5219eccda
# Parent  cc3ac5eb6be3fd6a39b64d4e9dd6a2d1bc9d9264
Fix docstrings, add examples, references and tests to string functions

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,12 @@
+2008-12-26  Thorsten Meyer  <thorsten.meyier@gmx.de>
+
+	* interpreter/strings.txi: Add space to ischar example.
+	
 2008-12-26  Francesco Potort√¨  <pot@gnu.org>
 
 	* interpreter/matrix.txi (Rearranging Matrices): Add reference
 	to resize function.
 
 	* interpreter/plot.txi (Plot Annotations): Add cross reference to
 	Text Properties.
 	(Two-Dimensional Plots): Update introduction to the axis function.
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -179,18 +179,20 @@ matrix.
 To test if an object is a string (i.e., a character vector and not a character
 matrix) you can use the @code{ischar} function in combination with the
 @code{isvector} function as in the following example:
 
 @example
 @group
 ischar(collection)
      @result{} ans = 1
+
 ischar(collection) && isvector(collection)
      @result{} ans = 0
+
 ischar("my string") && isvector("my string")
      @result{} ans = 1
 @end group
 @end example
 
 One relevant question is, what happens when a character matrix is
 created from strings of different length.  The answer is that Octave
 puts blank characters at the end of strings shorter than the longest
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,23 @@
+2008-12-26  Thorsten Meyer  <thorsten.meyier@gmx.de>
+
+	* general/int2str.m, general/num2str.m, strings/base2dec.m,
+	strings/blanks.m, strings/cstrcat.m, strings/findstr.m,
+	strings/isstrprop.m, strings/mat2str.m, strings/regexptranslate.m,
+	strings/split.m, strings/str2double.m, strings/str2num.m,
+	strings/strcat.m, strings/strcmpi.m, strings/strfind.m,
+	strings/strjust.m, strings/strmatch.m, strings/strncmpi.m,
+	strings/strrep.m, strings/strtok.m, strings/strtrim.m,
+	strings/strtrunc.m, strings/strvcat.m, strings/substr.m: 
+	Fix documentation strings, add examples, references and tests.
+	* scripts/general/int2str.m: Add missing semicolon.
+	* scripts/strings/regexptranslate.m: add nargin check.
+	* scripts/strings/str2double.m: fix nargin check.
+	
 2008-12-29  David Bateman  <dbateman@free.fr>
 
 	* goemetry/voronoi.m: Speed up and handle dense grids.
 
 2008-12-28  Jaroslav Hajek <highegg@gmail.com>
 
 	* miscellaneous/delete.m: Allow filename globs. Display warnings if
 	operation fails.
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -14,20 +14,41 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} int2str (@var{n})
-## Convert an integer to a string.  This function is not very flexible.
-## For better control over the results, use @code{sprintf}
-## (@pxref{Formatted Output}). 
-## @seealso{sprintf, num2str}
+## Convert an integer (or array of integers) to a string (or a character
+## array).
+##
+## @example
+## @group
+##
+## int2str (123)
+##      @result{} "123"
+##
+## s = int2str ([1, 2, 3; 4, 5, 6])
+##      @result{} s = 
+##         1  2  3
+##         4  5  6
+## 
+## whos s
+##      @result{} s = 
+##       Attr Name        Size                     Bytes  Class
+##       ==== ====        ====                     =====  ===== 
+##            s           2x7                         14  char
+## @end group
+## @end example
+##
+## This function is not very flexible.  For better control over the
+## results, use @code{sprintf} (@pxref{Formatted Output}). 
+## @seealso{sprintf, num2str, mat2str}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = int2str (x)
 
   if (nargin == 1)
     x = round (real(x));
@@ -38,17 +59,17 @@ function retval = int2str (x)
       idx = cell ();
       for i = 1:nd
 	idx{i} = 1:sz(i);
       endfor
       idx(2) = 1;
       ifmt = get_fmt (x(idx{:}), 0);
       idx(2) = 2:sz(2);
       rfmt = get_fmt (x(idx{:}), 2);
-      fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n")
+      fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
     else
       fmt = cstrcat (get_fmt (x, 0), "\n");
     endif
     tmp = sprintf (fmt, permute (x, [2, 1, 3 : nd]));
     tmp(end) = "";
     retval = split (tmp, "\n");
   else
     print_usage ();
@@ -88,13 +109,12 @@ function fmt = get_fmt (x, sep)
       endif
       fmt = sprintf ("%%%dd", max (fw, min_fw));
     endif
   endif
 
 endfunction
 
 %!assert(strcmp (int2str (-123), "-123") && strcmp (int2str (1.2), "1"));
-
+%!assert (all (int2str ([1, 2, 3; 4, 5, 6]) == ["1  2  3";"4  5  6"]));
 %!error int2str ();
-
 %!error int2str (1, 2);
 
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -13,23 +13,55 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} num2str (@var{n})
+## @deftypefn {Function File} {} num2str (@var{x})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{precision})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{format})
-## Convert a number to a string.  This function is not very flexible.
-## For better control over the results, use @code{sprintf}
-## (@pxref{Formatted Output}).
-## @seealso{sprintf, int2str}
+## Convert a number (or array) to a string (or a character array).  The
+## optional second argument may either give the number of significant
+## digits (@var{precision}) to be used in the output or a format
+## template string (@var{format}) as in @code{sprintf} (@pxref{Formatted
+## Output}).  @code{num2str} can also handle complex numbers.  For
+## example: 
+##
+## @example
+## @group
+## num2str (123.456)
+##      @result{} "123.46"
+##
+## num2str (123.456, 4)
+##      @result{} "123.5"
+##
+## s = num2str ([1, 1.34; 3, 3.56], "%5.1f")
+##      @result{} s =
+##         1.0  1.3
+##         3.0  3.6
+## whos s
+##      @result{}
+##       Attr Name        Size                     Bytes  Class
+##       ==== ====        ====                     =====  ===== 
+##            s           2x8                         16  char
+##
+## num2str (1.234 + 27.3i)
+##      @result{} "1.234+27.3i"
+## @end group
+## @end example
+##
+## The @code{num2str} function is not very flexible.  For better control
+## over the results, use @code{sprintf} (@pxref{Formatted Output}). 
+## Note that for complex @var{x}, the format string may only contain one
+## output conversion specification and nothing else.  Otherwise, you
+## will get unpredictable results.  
+## @seealso{sprintf, int2str, mat2str}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = num2str (x, arg)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
@@ -144,14 +176,15 @@ function retval = num2str (x, arg)
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
     tmp(length (tmp)) = "";
     retval = strtrim (split (tmp, "\n"));
   endif
 
 endfunction
 
-%!assert((strcmp (num2str (123), "123") && strcmp (num2str (1.23), "1.23")));
-
+%!assert ((strcmp (num2str (123), "123") && strcmp (num2str (1.23), "1.23")));
+%!assert (num2str (123.456, 4), "123.5");
+%!assert (all (num2str ([1, 1.34; 3, 3.56], "%5.1f") == ["1.0  1.3"; "3.0  3.6"]));
+%!assert (num2str (1.234 + 27.3i), "1.234+27.3i");
 %!error num2str ();
-
 %!error num2str (1, 2, 3);
 
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -76,8 +76,14 @@ function out = base2dec (d, base)
   table (toascii (" ")) = 0;
   d = reshape (table (toascii (d)), size (d));
 
   ## Multiply the resulting digits by the appropriate power and
   ## sum the rows.
   out = d * (base .^ (columns(d)-1 : -1 : 0)');
 
 endfunction
+
+%!error <Invalid call to base2dec.*> base2dec();
+%!error <Invalid call to base2dec.*> base2dec("11120");
+%!error <Invalid call to base2dec.*> base2dec("11120", 3, 4);
+%!assert(base2dec ("11120", 3), 123);
+%!assert(base2dec ("yyyzx", "xyz"), 123);
\ No newline at end of file
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -14,17 +14,28 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blanks (@var{n})
-## Return a string of @var{n} blanks.
+## Return a string of @var{n} blanks, for example:
+##
+## @example
+## @group
+## blanks(10);
+## whos ans;
+##      @result{}
+##       Attr Name        Size                     Bytes  Class
+##       ==== ====        ====                     =====  ===== 
+##            ans         1x10                        10  char
+## @end group
+## @end example
 ## @seealso{repmat}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function s = blanks (n)
 
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -14,26 +14,36 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cstrcat (@var{s1}, @var{s2}, @dots{})
-## Return a string containing all the arguments concatenated.  For example,
+## Return a string containing all the arguments concatenated
+## horizontally. Trailing white space is preserved. For example,
+##
+## @example
+## @group
+## cstrcat ("ab   ", "cd")
+##      @result{} "ab   cd"
+## @end group
+## @end example
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## cstrcat (s, s, s)
-##      @result{} "ab ab ab "
+##      @result{} ans =
+##         "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
+## @seealso{strcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
 
 function st = cstrcat (varargin)
 
   if (nargin > 0)
 
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -20,21 +20,24 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} findstr (@var{s}, @var{t}, @var{overlap})
 ## Return the vector of all positions in the longer of the two strings
 ## @var{s} and @var{t} where an occurrence of the shorter of the two starts.
 ## If the optional argument @var{overlap} is nonzero, the returned vector
 ## can include overlapping positions (this is the default).  For example,
 ##
 ## @example
+## @group
 ## findstr ("ababab", "a")
-##      @result{} [ 1, 3, 5 ]
+##      @result{} [1, 3, 5]
 ## findstr ("abababa", "aba", 0)
-##      @result{} [ 1, 5 ]
+##      @result{} [1, 5]
+## @end group
 ## @end example
+## @seealso{strfind, strmatch, strcmp, strncmp, strcmpi, strncmpi, find}
 ## @end deftypefn
 
 ## Note that this implementation swaps the strings if second one is longer
 ## than the first, so try to put the longer one first.
 ##
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
@@ -124,16 +127,16 @@ function v = findstr (s, t, overlap)
 
   ## Always return a column vector, because that's what the old one did
   if (rows (v) > 1) 
     v = v.';
   endif
 
 endfunction
 
-%!assert((findstr ("abababa", "a") == [1, 3, 5, 7]
+%!assert ((findstr ("abababa", "a") == [1, 3, 5, 7]
 %! && findstr ("abababa", "aba") == [1, 3, 5]
 %! && findstr ("abababa", "aba", 0) == [1, 5]));
 
 %!error findstr ();
 
 %!error findstr ("foo", "bar", 3, 4);
 
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -13,23 +13,26 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isletter (@var{s})
-## Returns true if @var{s} is a letter false otherwise.
+## Returns true if @var{s} is a letter, false otherwise.
 ## @seealso{isalpha}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = isletter (s)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   retval = isalpha (s);
 
 endfunction
+
+%!error isletter();
+%!error isletter("a", "b");
diff --git a/scripts/strings/isstrprop.m b/scripts/strings/isstrprop.m
--- a/scripts/strings/isstrprop.m
+++ b/scripts/strings/isstrprop.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isstrprop (@var{str}, @var{pred})
 ## Test character string properties.  For example,
 ##
 ## @example
 ## @group
-## isstrprop ("abc123", "isalpha")
+## isstrprop ("abc123", "alpha")
 ## @result{} [1, 1, 1, 0, 0, 0]
 ## @end group
 ## @end example
 ## 
 ## If @var{str} is a cell array, @code{isstrpop} is applied recursively
 ## to each element of the cell array.
 ##
 ## Numeric arrays are converted to character strings.
@@ -111,8 +111,11 @@ function retval = isstrprop (str, pred)
       otherwise
 	error ("isstrprop: invalid predicate");
     endswitch
   else
     print_usage ();
   endif
 
 endfunction
+
+%!error <invalid predicate> isstrprop ("abc123", "foo");
+%!assert (isstrprop ("abc123", "alpha"), logical ([1, 1, 1, 0, 0, 0]));
\ No newline at end of file
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -31,26 +31,28 @@
 ## precision of the imaginary part. The default for @var{n} is 17.
 ##
 ## If the argument 'class' is given, then the class of @var{x} is
 ## included in the string in such a way that the eval will result in the
 ## construction of a matrix of the same class.
 ##
 ## @example
 ## @group
-##    mat2str( [ -1/3 + i/7; 1/3 - i/7 ], [4 2] )
-##    @result{} '[-0.3333+0.14i;0.3333-0.14i]'
-##    mat2str( [ -1/3 +i/7; 1/3 -i/7 ], [4 2] )
-##    @result{} '[-0.3333+0i,0+0.14i;0.3333+0i,-0-0.14i]'
-##    mat2str( int16([1 -1]), 'class')
-##    @result{} 'int16([1,-1])'
+## mat2str( [ -1/3 + i/7; 1/3 - i/7 ], [4 2] )
+##      @result{} "[-0.3333+0.14i;0.3333-0.14i]"
+##
+## mat2str( [ -1/3 +i/7; 1/3 -i/7 ], [4 2] )
+##      @result{} "[-0.3333+0i,0+0.14i;0.3333+0i,-0-0.14i]"
+##
+## mat2str( int16([1 -1]), 'class')
+##      @result{} "int16([1,-1])"
 ## @end group
 ## @end example
 ##
-## @seealso{sprintf, int2str}
+## @seealso{sprintf, num2str, int2str}
 ## @end deftypefn
 
 ## Author: Rolf Fabian <fabian@tu-cottbus.de>
 
 function s = mat2str (x, n, cls)
 
   if (nargin < 2 || isempty (n))
     ## Default precision
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -21,26 +21,43 @@
 ## Translate a string for use in a regular expression. This might
 ## include either wildcard replacement or special character escaping.
 ## The behavior can be controlled by the @var{op} that can have the
 ## values
 ##
 ## @table @asis
 ## @item "wildcard"
 ## The wildcard characters @code{.}, @code{*} and @code{?} are replaced
-## with wildcards that are appropriate for a regular expression.
-##
+## with wildcards that are appropriate for a regular expression. For example:
+## @example
+## @group
+## regexptranslate ("wildcard", "*.m")
+##      @result{} ".*\.m"
+## @end group
+## @end example
+## 
 ## @item "escape"
 ## The characters @code{$.?[]}, that have special meaning for regular
-## expressions are escaped so that they are treated literally.
+## expressions are escaped so that they are treated literally. For example:
+## @example
+## @group
+## regexptranslate ("escape", "12.5")
+##      @result{} "12\.5"
+## @end group
+## @end example
 ## @end table
+## @seealso{regexp, regexpi, regexprep}
 ## @end deftypefn
 
 function y = regexptranslate (op, x)
   
+  if nargin != 2
+    print_usage ();
+  endif 
+  
   if (ischar (op))
     op = tolower (op);
     if (strcmp ("wildcard", op))
       y = regexprep (regexprep (regexprep (x, "\\.", "\\."), "\\*",
 				".*"), "\\?", ".");
     elseif (strcmp ("escape", op))
       ch = {'\$', '\.', '\?', '\[', '\]'};
       y = x;
@@ -50,10 +67,15 @@ function y = regexptranslate (op, x)
     else
       error ("regexptranslate: unexpected operation");
     endif
   else
     error ("regexptranslate: expecting operation to be a string");
   endif
 endfunction
 
+%!error <Invalid call to regexptranslate> regexptranslate ();
+%!error <Invalid call to regexptranslate> regexptranslate ("wildcard");
+%!error <Invalid call to regexptranslate> regexptranslate ("a", "b", "c");
+%!error <unexpected operation> regexptranslate ("foo", "abc");
+%!error <expecting operation to be a string> regexptranslate (10, "abc");
 %!assert (regexptranslate ("wildcard", "/a*b?c."), "/a.*b.c\\.")
 %!assert (regexptranslate ("escape", '$.?[]'), '\$\.\?\[\]')
diff --git a/scripts/strings/split.m b/scripts/strings/split.m
--- a/scripts/strings/split.m
+++ b/scripts/strings/split.m
@@ -22,26 +22,29 @@
 ## the result in a string array (padded with blanks to form a valid
 ## matrix).  If the optional input @var{n} is supplied, split @var{s}
 ## into at most @var{n} different pieces.
 ##
 ## For example,
 ##
 ## @example
 ## split ("Test string", "t")
-##      @result{} "Tes "
+##      @result{}
+##         "Tes "
 ##         " s  "
 ##         "ring"
 ## @end example
 ##
 ## @example
-## split ("Test string", "t", 2)
-##      @result{} "Tes    "
-##         " string"
+## split ("Test string", "t s", 2)
+##      @result{}
+##         "Tes  "
+##         "tring"
 ## @end example
+## @seealso{strtok, index}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function m = split (s, t, n)
 
   if (nargin == 2 || nargin == 3)
diff --git a/scripts/strings/str2double.m b/scripts/strings/str2double.m
--- a/scripts/strings/str2double.m
+++ b/scripts/strings/str2double.m
@@ -54,46 +54,49 @@
 ## @var{cdelim}, @var{rdelim}, and @var{ddelim} must contain only nul,
 ## newline, carriage return, semicolon, colon, slash, tab, space, comma,
 ## or @samp{()[]@{@}} (ASCII 0, 9, 10, 11, 12, 13, 14, 32, 33, 34, 40,
 ## 41, 44, 47, 58, 59, 91, 93, 123, 124, 125).
 ##
 ## Examples:
 ##
 ## @example
+## @group
 ## str2double ("-.1e-5")
 ## @result{} -1.0000e-006
 ##
 ## str2double (".314e1, 44.44e-1, .7; -1e+1")
 ## @result{}
 ##    3.1400    4.4440    0.7000
 ##  -10.0000       NaN       NaN
 ##
 ## line = "200, 300, NaN, -inf, yes, no, 999, maybe, NaN";
 ## [x, status] = str2double (line)
 ## @result{} x =
 ##     200   300   NaN  -Inf   NaN   NaN   999   NaN   NaN
 ## @result{} status =
 ##       0     0     0     0    -1    -1     0    -1     0
+## @end group
 ## @end example
+## @seealso{str2num}
 ## @end deftypefn
 
 ## Author: Alois Schloegl <a.schloegl@ieee.org>
 ## Adapted-by: jwe
 
 function [num, status, strarray] = str2double (s, cdelim, rdelim, ddelim)
 
   ## digits, sign, exponent,NaN,Inf
   ## valid_char = '0123456789eE+-.nNaAiIfF';
 
   ## valid delimiters
   valid_delim = char (sort ([0, 9:14, 32:34, abs("()[]{},;:\"|/")]));
 
-  if (nargin < 1)
-    error ("missing input argument");
+  if (nargin < 1 || nargin > 4)
+    print_usage ();
   endif
 
   if (nargin < 2)
     ## column delimiter
     cdelim = char ([9, 32, abs(",")]);
   else
     ## make unique cdelim
     cdelim = char (sort (cdelim(:)));
@@ -272,8 +275,19 @@ function [num, status, strarray] = str2d
 	    status(k1,k2) = -1;
 	  endif
 	endif
       endif
     endfor
   endfor
 
 endfunction
+
+%!error <Invalid call to str2double> str2double();
+%!error <Invalid call to str2double> str2double("1e10", " ", "\n", ".", "x");
+%!assert (str2double ("-.1e-5"), -1.0000e-006);
+%!assert (str2double (".314e1, 44.44e-1, .7; -1e+1"),
+%!  [3.1400, 4.4440, 0.7000; -10.0000, NaN, NaN]);
+%!test
+%!  line = "200, 300, NaN, -inf, yes, no, 999, maybe, NaN";
+%!  [x, status] = str2double (line);
+%!  assert (x, [200, 300, NaN, -Inf, NaN, NaN, 999, NaN, NaN]);
+%!  assert (status, [0, 0, 0, 0, -1, -1, 0, -1, 0]);
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -13,17 +13,36 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} str2num (@var{s})
-## Convert the string @var{s} to a number.
+## Convert the string (or character array) @var{s} to a number (or an
+## array). Examples:  
+##
+## @example
+## @group
+## str2num("3.141596")
+##      @result{} 3.141596
+## 
+## str2num(["1, 2, 3"; "4, 5, 6"]);
+##      @result{} ans =
+##         1  2  3
+##         4  5  6
+## @end group
+## @end example
+## 
+## @strong{Caution:} As @code{str2num} uses the @code{eval} function
+## to do the conversion, @code{str2num} will execute any code contained
+## in the string @var{s}.  Use @code{str2double} instead if you want to
+## avoid the use of @code{eval}. 
+## @seealso{str2double, eval}
 ## @end deftypefn
 
 ## Author: jwe
 
 function m = str2num (s)
 
   if (nargin == 1 && ischar (s))
     [nr, nc] = size (s);
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -14,26 +14,46 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcat (@var{s1}, @var{s2}, @dots{})
-## Return a string containing all the arguments concatenated.  For example,
+## Return a string containing all the arguments concatenated
+## horizontally.  If the arguments are cells strings,  @code{strcat}
+## returns a cell string with the individual cells concatenated.
+## For numerical input, each element is converted to the
+## corresponding ASCII character. Trailing white space is eliminated.
+## For example,
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## strcat (s, s, s)
-##      @result{} "ab ab ab "
+##      @result{} ans =
+##         "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
+##
+## @example
+## @group
+## s = @{ "ab"; "cde" @};
+## strcat (s, s, s)
+##      @result{} ans =
+##         @{
+##           [1,1] = ababab
+##           [2,1] = cdecdecde
+##         @}
+## @end group
+## @end example
+##
+## @seealso{cstrcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
 
 function st = strcat (varargin)
 
   if (nargin > 0)
     if (nargin == 1)
diff --git a/scripts/strings/strcmpi.m b/scripts/strings/strcmpi.m
--- a/scripts/strings/strcmpi.m
+++ b/scripts/strings/strcmpi.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcmpi (@var{s1}, @var{s2})
-## Ignoring case, return 1 if the character strings @var{s1} and @var{s2}
-## are the same, and 0 otherwise.
+## Ignoring case, return 1 if the character strings (or character
+## arrays) @var{s1} and @var{s2} are the same, and 0 otherwise.
 ##
 ## If either @var{s1} or @var{s2} is a cell array of strings, then an array
 ## of the same size is returned, containing the values described above for
 ## every member of the cell array. The other argument may also be a cell
 ## array of strings (of the same size or with only one element), char matrix
 ## or character string.
 ##
 ## @strong{Caution:} For compatibility with @sc{Matlab}, Octave's strcmpi
@@ -46,8 +46,10 @@ function retval = strcmpi (s1, s2)
     else
       retval = false;
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+%!assert (strcmpi("abc123", "ABC123"), logical(1));
diff --git a/scripts/strings/strfind.m b/scripts/strings/strfind.m
--- a/scripts/strings/strfind.m
+++ b/scripts/strings/strfind.m
@@ -21,18 +21,36 @@
 ## @deftypefnx {Function File} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})
 ## Search for @var{pattern} in the string @var{str} and return the
 ## starting index of every such occurrence in the vector @var{idx}.
 ## If there is no such occurrence, or if @var{pattern} is longer
 ## than @var{str}, then @var{idx} is the empty array @code{[]}.
 ##
 ## If the cell array of strings @var{cellstr} is specified instead of the
 ## string @var{str}, then @var{idx} is a cell array of vectors, as specified
-## above.
-## @seealso{findstr, strmatch, strcmp, strncmp, strcmpi, strncmpi}
+## above. Examples:
+##
+## @example
+## @group
+## strfind ("abababa", "aba")
+##      @result{} [1, 3, 5]
+##
+## strfind (@{"abababa", "bebebe", "ab"@}, "aba")
+##      @result{} ans =
+##         @{
+##           [1,1] =
+##
+##              1   3   5
+##
+##           [1,2] = [](1x0)
+##           [1,3] = [](1x0)
+##         @}
+## @end group
+## @end example
+## @seealso{findstr, strmatch, strcmp, strncmp, strcmpi, strncmpi, find}
 ## @end deftypefn
 
 ## Author: alois schloegl <a.schloegl@ieee.org>
 ## Created: 1 November 2004
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function idx = strfind (text, pattern)
 
@@ -61,8 +79,16 @@ function idx = __strfind_string__ (text,
 
   idx = 1:(length (text) - lp + 1);
   k = 0;
   while (k < lp && ! isempty (idx))
     idx = idx(text(idx + k) == pattern(++k));
   endwhile
 
 ### endfunction
+
+%!error <Invalid call to strfind> strfind ();
+%!error <Invalid call to strfind> strfind ("foo", "bar", 1);
+%!error <pattern must be a string value> strfind ("foo", 100);
+%!error <text must be a string or cell array of string> strfind (100, "foo");
+
+%!assert (strfind ("abababa", "aba"), [1, 3, 5]);
+%!assert (strfind ({"abababa", "bla", "bla"}, "a"), {[1, 3, 5, 7], 3, 3});
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -16,17 +16,28 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strjust (@var{s}, ["left"|"right"|"center"])
 ## Shift the non-blank text of @var{s} to the left, right or center of
 ## the string.  If @var{s} is a string array, justify each string in the
 ## array.  Null characters are replaced by blanks.  If no justification
-## is specified, then all rows are right-justified.
+## is specified, then all rows are right-justified. For example:
+##
+## @example
+## @group
+## strjust (["a"; "ab"; "abc"; "abcd"])
+##      @result{} ans =
+##            a
+##           ab
+##          abc
+##         abcd
+## @end group
+## @end example
 ## @end deftypefn
 
 function x = strjust (x, just)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
@@ -58,8 +69,15 @@ function x = strjust (x, just)
     [N, hi] = max (cumsum (idx));
     [N, lo] = max (cumsum (flipud (idx)));
     shift = ceil (nc - (lo-hi)/2);
   endif
   idx = rem (ones(nr,1)*[0:nc-1] + shift'*ones(1,nc), nc);
   x = x (idx*nr + [1:nr]'*ones(1,nc));
 
 endfunction
+
+%!error <Invalid call to strjust> strjust();
+%!error <Invalid call to strjust> strjust(["a";"ab"], "center", 1);
+%!assert (strjust (["a"; "ab"; "abc"; "abcd"]),
+%!        ["   a";"  ab"; " abc"; "abcd"]);
+%!assert (strjust (["a"; "ab"; "abc"; "abcd"], "center"),
+%!        [" a  "; " ab"; "abc "; "abcd"]);
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -18,17 +18,32 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strmatch (@var{s}, @var{a}, "exact")
 ## Return indices of entries of @var{a} that match the string @var{s}.
 ## The second argument @var{a} may be a string matrix or a cell array of
 ## strings.  If the third argument @code{"exact"} is not given, then
 ## @var{s} only needs to match @var{a} up to the length of @var{s}.  Nul
-## characters match blanks.  Results are returned as a column vector.
+## characters match blanks.  Results are returned as a column vector. 
+## For example:
+##
+## @example
+## @group
+## strmatch ("apple", "apple juice")
+##      @result{} 1
+##
+## strmatch ("apple", ["apple pie"; "apple juice"; "an apple"])
+##      @result{} [1; 2]
+##
+## strmatch ("apple", @{"apple pie"; "apple juice"; "tomato"@})
+##      @result{} [1; 2]
+## @end group
+## @end example
+## @seealso{strfind, findstr, strcmp, strncmp, strcmpi, strncmpi, find}
 ## @end deftypefn
 
 ## Author: Paul Kienzle, Alois Schloegl
 ## Adapted-by: jwe
 
 function idx = strmatch (s, A, exact)
 
   if (nargin < 2 || nargin > 3)
@@ -61,8 +76,18 @@ function idx = strmatch (s, A, exact)
     if (length (s) == 1)
       idx = find (match);
     else
       idx = find (all (match')');
     endif
   endif
     
 endfunction 
+
+%!error <Invalid call to strmatch> strmatch();
+%!error <Invalid call to strmatch> strmatch("a", "aaa", "exact", 1);
+%!assert (strmatch("a", {"aaa", "bab", "bbb"}), 1);
+%!assert (strmatch ("apple", "apple juice"), 1);
+%!assert (strmatch ("apple", ["apple pie"; "apple juice"; "an apple"]),
+%!        [1; 2]);
+%!assert (strmatch ("apple", {"apple pie"; "apple juice"; "tomato"}),
+%!        [1; 2]);
+%!assert (strmatch ("apple pie", "apple"), []);
diff --git a/scripts/strings/strncmpi.m b/scripts/strings/strncmpi.m
--- a/scripts/strings/strncmpi.m
+++ b/scripts/strings/strncmpi.m
@@ -14,21 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strncmpi (@var{s1}, @var{s2}, @var{n})
 ## Ignoring case, return 1 if the first @var{n} characters of character
-## strings @var{s1} and @var{s2} are the same, and 0 otherwise.
+## strings (or character arrays) @var{s1} and @var{s2} are the same, and
+## 0 otherwise.
 ##
 ## If either @var{s1} or @var{s2} is a cell array of strings, then an array
 ## of the same size is returned, containing the values described above for
-## every member of the cell array. The other argument may also be a cell
+## every member of the cell array.  The other argument may also be a cell
 ## array of strings (of the same size or with only one element), char matrix
 ## or character string.
 ##
 ## @strong{Caution:} For compatibility with @sc{Matlab}, Octave's strncmpi
 ## function returns 1 if the character strings are equal, and 0 otherwise.
 ## This is just the opposite of the corresponding C library function.
 ## @seealso{strcmp, strcmpi, strncmp}
 ## @end deftypefn
@@ -39,8 +40,10 @@ function retval = strncmpi (s1, s2, n)
     ## Note that we don't use tolower here because we need to be able to
     ## handle cell arrays of strings.
     retval = strncmp (lower (s1), lower (s2), n);
   else
     print_usage ();
   endif
 
 endfunction
+
+%!assert (strncmpi("abc123", "ABC456", 3), logical(1));
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -21,16 +21,17 @@
 ## @deftypefn {Function File} {} strrep (@var{s}, @var{x}, @var{y})
 ## Replaces all occurrences of the substring @var{x} of the string @var{s}
 ## with the string @var{y} and returns the result.  For example,
 ##
 ## @example
 ## strrep ("This is a test string", "is", "&%$")
 ##      @result{} "Th&%$ &%$ a test string"
 ## @end example
+## @seealso{regexprep, strfind, findstr}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 11 November 1994
 ## Adapted-By: jwe
 
 function t = strrep (s, x, y)
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -17,18 +17,31 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str}, @var{delim})
 ## 
 ## Find all characters up to but not including the first character which
 ## is in the string delim.  If @var{rem} is requested, it contains the
 ## remainder of the string, starting at the first deliminator. Leading
-## delimiters are ignored.  If @var{delim} is not specified, space is assumed.
+## delimiters are ignored.  If @var{delim} is not specified, space is
+## assumed.  For example: 
+##
+## @example
+## @group
+## strtok ("this is the life")
+##      @result{} "this"
 ##
+## [tok, rem] = strtok ("14*27+31", "+-*/")
+##      @result{}
+##         tok = 14
+##         rem = *27+31
+## @end group
+## @end example
+## @seealso{index, split}
 ## @end deftypefn
 
 ## FIXME: check what to do for a null delimiter
 
 function [tok, rem] = strtok (str, delim)
 
   if (nargin<1 || nargin > 2)
     print_usage ();
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -16,17 +16,27 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strtrim (@var{s})
 ## Remove leading and trailing blanks and nulls from @var{s}.  If
 ## @var{s} is a matrix, @var{strtrim} trims each row to the length of
 ## longest string.  If @var{s} is a cell array, operate recursively on
-## each element of the cell array. 
+## each element of the cell array. For example:
+##
+## @example
+## @group
+## strtrim ("    abc  ")
+##      @result{} "abc"
+##
+## strtrim ([" abc   "; "   def   "])
+##      @result{} ["abc  "; "  def"]
+## @end group
+## @end example
 ## @end deftypefn
 
 ## Author: John Swensen <jpswensen@jhu.edu>
 
 ## This function was derived from deblank.
 
 function s = strtrim (s)
 
@@ -47,8 +57,13 @@ function s = strtrim (s)
 
     s = cellfun (@strtrim, s, "UniformOutput", false);
 
   else
     error ("strtrim: expecting string argument");
   endif
 
 endfunction
+
+%!error <Invalid call to strtrim> strtrim();
+%!error <Invalid call to strtrim> strtrim("abc", "def");
+%!assert (strtrim ("    abc  "), "abc");
+%!assert (strtrim ([" abc   "; "   def   "]), ["abc  "; "  def"]);
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strtrunc (@var{s}, @var{n})
 ## Truncate the character string @var{s} to length @var{n}. If @var{s}
-## is a char matrix, then the number of columns are adjusted.
+## is a char matrix, then the number of columns is adjusted.
 ##
 ## If @var{s} is a cell array of strings, then the operation is performed
 ## on its members and the new cell array is returned.
 ## @end deftypefn
 
 function s = strtrunc (s, n)
 
   if (nargin != 2)
@@ -46,8 +46,14 @@ function s = strtrunc (s, n)
     error ("strtrunc: s must be a character string or a cell array of strings");
   endif
 
   if (s_was_char)
     s = s{:};
   endif
 
 endfunction
+
+%!error <Invalid call to strtrunc> strtrunc ();
+%!error <s must be a character string or a cell array of strings> strtrunc (1, 1)
+%!assert (strtrunc("abcdefg", 4), "abcd");
+%!assert (strtrunc("abcdefg", 10), "abcdefg");
+%!assert (strtrunc({"abcdef", "fedcba"}, 3), {"abc", "fed"});
diff --git a/scripts/strings/strvcat.m b/scripts/strings/strvcat.m
--- a/scripts/strings/strvcat.m
+++ b/scripts/strings/strvcat.m
@@ -13,21 +13,36 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strvcat (@var{s_1}, @dots{}, @var{s_n})
-## Return a matrix containing the strings (and cell-strings) 
+## Return a character array containing the strings (or cell-strings) 
 ## @var{s_1}, @dots{}, @var{s_n} as
 ## its rows.  Each string is padded with blanks in order to form a valid
-## matrix.  Unlike @var{char}, empty strings are ignored.
-## @seealso{cstrcat, char}
+## matrix.  For numerical input, each element is converted to the
+## corresponding ASCII character.  Unlike @var{char}, empty strings are
+## removed. For example:
+##
+## @example
+## @group
+## strvcat ([97, 98, 99], "", @{"98", "99", 100@}, ["num", "bers"])
+##     @result{} ans = 
+##        ["abc    "
+##         "98     "
+##         "99     "
+##         "d      "
+##         "numbers"]
+## @end group
+## @end example
+##
+## @seealso{char, cstrcat, strcat}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 ## Modified: Paul Kienzle <pkienzle@kienzle.powernet.co.uk> converted
 ##           str2mat to strvcat.  Same function except that strvcat
 ##           ignores empty strings.
 ## Modified by Alois Schloegl <a.schloegl@ieee.org> Mar 2005
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -28,17 +28,17 @@
 ## For example,
 ##
 ## @example
 ## substr ("This is a test string", 6, 9)
 ##      @result{} "is a test"
 ## @end example
 ##
 ## This function is patterned after AWK.  You can get the same result by
-## @code{@var{s} (@var{offset} : (@var{offset} + @var{len} - 1))}.
+## @code{@var{s}(@var{offset} : (@var{offset} + @var{len} - 1))}.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function t = substr (s, offset, len)
 
   if (nargin < 2 || nargin > 3)
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,15 @@
+2008-12-26  Thorsten Meyer  <thorsten.meyier@gmx.de>
+
+	* mappers.cc (Ftoascii), mappers.cc (Ftolower), mappers.cc
+	(Ftoupper), DLD-FUNCTIONS/regexp.cc (Fregexp),
+	DLD-FUNCTIONS/regexp.cc	(Fregexpi), DLD-FUNCTIONS/regexp.cc
+	(Fregexprep): Add references.
+	
 2008-12-27  Jaroslav Hajek <highegg@gmail.com>
 
 	* oct-obj.h, oct-obj.cc (octave_value_list::valid_scalar_indices): Remove.
 	* ov-base-diag.cc, ov-base-diag.h, ov-base-scalar.cc, ov-base.h,
 	ov-bool-mat.cc, ov-bool-mat.h, ov-bool-sparse.cc, ov-bool-sparse.h,
 	ov-bool.cc, ov-bool.h, ov-ch-mat.cc, ov-ch-mat.h, ov-colon.h,
 	ov-complex.cc, ov-complex.h, ov-cx-mat.cc, ov-cx-mat.h,
 	ov-cx-sparse.cc, ov-cx-sparse.h, ov-float.cc, ov-float.h,
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -989,16 +989,17 @@ The character @code{.} matches the newli
 @item dotexceptnewline\n\
 The character @code{.} matches all but the newline character.\n\
 @item freespacing\n\
 The pattern can include arbitrary whitespace and comments starting with\n\
 @code{#}.\n\
 @item literalspacing\n\
 The pattern is taken literally.\n\
 @end table\n\
+@seealso{regexpi, regexprep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length();
 
   if (nargin < 2)
     print_usage ();
   else if (args(0).is_cell() || args(1).is_cell())
@@ -1181,17 +1182,17 @@ The pattern is taken literally.\n\
 
 DEFUN_DLD (regexpi, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexpi (@var{str}, @var{pat})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, @var{opts}, @dots{})\n\
 \n\
 Case insensitive regular expression string matching. Matches @var{pat} in\n\
 @var{str} and returns the position and matching substrings or empty values\n\
-if there are none. See @code{regexp} for more details\n\
+if there are none.  @xref{doc-regexp,,regexp}, for more details\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length();
 
   if (nargin < 2)
     print_usage ();
   else if (args(0).is_cell() || args(1).is_cell())
@@ -1564,17 +1565,17 @@ Alternatively, use (?m) or (?-m) in the 
 Whether . matches newlines in the string.\n\
 Alternatively, use (?s) or (?-s) in the pattern.\n\
 \n\
 @item freespacing or literalspacing\n\
 Whether whitespace and # comments can be used to make the regular expression more readable.\n\
 Alternatively, use (?x) or (?-x) in the pattern.\n\
 \n\
 @end table\n\
-@seealso{regexp,regexpi}\n\
+@seealso{regexp,regexpi,strrep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length();
 
   if (nargin < 3)
     {
       print_usage ();
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -1550,16 +1550,17 @@ Return ASCII representation of @var{s} i
 \n\
 @example\n\
 @group\n\
 toascii (\"ASCII\")\n\
      @result{} [ 65, 83, 67, 73, 73 ]\n\
 @end group\n\
 \n\
 @end example\n\
+@seealso{char}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtoascii ();
   else
     print_usage ();
 
@@ -1573,16 +1574,17 @@ DEFUNX ("tolower", Ftolower, args, ,
 Return a copy of the string or cell string @var{s}, with each upper-case\n\
 character replaced by the corresponding lower-case one; nonalphabetic\n\
 characters are left unchanged.  For example,\n\
 \n\
 @example\n\
 tolower (\"MiXeD cAsE 123\")\n\
      @result{} \"mixed case 123\"\n\
 @end example\n\
+@seealso{toupper}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtolower ();
   else
     print_usage ();
 
@@ -1618,16 +1620,17 @@ character replaced by the corresponding 
 characters are left unchanged.  For example,\n\
 \n\
 @example\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
+@seealso{tolower}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtoupper ();
   else
     print_usage ();
 
