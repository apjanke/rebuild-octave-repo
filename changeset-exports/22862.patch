# HG changeset patch
# User Rik <rik@octave.org>
# Date 1480971852 28800
#      Mon Dec 05 13:04:12 2016 -0800
# Node ID e365e87371a36c83bd1773c302e4353343ab0572
# Parent  0ab9c3548b1f068179efd1a3c8b71c377c617e4c
maint: Use C++ range feature to simplify some for loops in libinterp/corefcn.

* symtab.cc, call-stack.cc, comment-list.cc, defun.cc, dynamic-ld.cc,
error.cc, ft-text-renderer.cc, gl2ps-print.cc, graphics.cc, help.cc,
interpreter.cc, load-path.cc, load-save.cc, ls-mat5.cc, oct-errno.in.cc,
oct-map.cc, oct-stream.cc, octave-link.cc, profiler.cc, regexp.cc, strfind.cc,
symtab.h, txt-eng.h, urlwrite.cc, variables.cc:
maint: Use C++ range feature to simplify some for loops in libinterp/corefcn.

diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -414,27 +414,24 @@ octave_call_stack::do_backtrace (size_t 
   Cell& name = retval.contents (1);
   Cell& line = retval.contents (2);
   Cell& column = retval.contents (3);
   Cell& scope = retval.contents (4);
   Cell& context = retval.contents (5);
 
   octave_idx_type k = 0;
 
-  for (std::list<octave_call_stack::stack_frame>::const_iterator p = frames.begin ();
-       p != frames.end (); p++)
+  for (const auto& frm : frames)
     {
-      const stack_frame& elt = *p;
-
-      scope(k) = elt.m_scope;
-      context(k) = elt.m_context;
-      file(k) = elt.fcn_file_name ();
-      name(k) = elt.fcn_name (print_subfn);
-      line(k) = elt.m_line;
-      column(k) = elt.m_column;
+      scope(k)   = frm.m_scope;
+      context(k) = frm.m_context;
+      file(k)    = frm.fcn_file_name ();
+      name(k)    = frm.fcn_name (print_subfn);
+      line(k)    = frm.m_line;
+      column(k)  = frm.m_column;
 
       k++;
     }
 
   return retval;
 }
 
 bool
diff --git a/libinterp/corefcn/comment-list.cc b/libinterp/corefcn/comment-list.cc
--- a/libinterp/corefcn/comment-list.cc
+++ b/libinterp/corefcn/comment-list.cc
@@ -29,18 +29,14 @@ along with Octave; see the file COPYING.
 #include "comment-list.h"
 #include "error.h"
 
 octave_comment_list *
 octave_comment_list::dup (void) const
 {
   octave_comment_list *new_cl = new octave_comment_list ();
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const octave_comment_elt elt = *p;
-
-      new_cl->append (elt);
-    }
+  for (const auto& elt : *this)
+    new_cl->append (elt);
 
   return new_cl;
 }
 
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -148,27 +148,27 @@ get_current_shlib (void)
 
   return retval;
 }
 
 bool defun_isargout (int nargout, int iout)
 {
   const std::list<octave_lvalue> *lvalue_list
     = octave_builtin::curr_lvalue_list;
+
   if (iout >= std::max (nargout, 1))
     return false;
   else if (lvalue_list)
     {
       int k = 0;
-      for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
-           p != lvalue_list->end (); p++)
+      for (const auto& lval : *lvalue_list)
         {
           if (k == iout)
-            return ! p->is_black_hole ();
-          k += p->numel ();
+            return ! lval.is_black_hole ();
+          k += lval.numel ();
           if (k > iout)
             break;
         }
 
       return true;
     }
   else
     return true;
@@ -177,24 +177,23 @@ bool defun_isargout (int nargout, int io
 void defun_isargout (int nargout, int nout, bool *isargout)
 {
   const std::list<octave_lvalue> *lvalue_list
     = octave_builtin::curr_lvalue_list;
 
   if (lvalue_list)
     {
       int k = 0;
-      for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
-           p != lvalue_list->end () && k < nout; p++)
+      for (const auto& lval : *lvalue_list)
         {
-          if (p->is_black_hole ())
+          if (lval.is_black_hole ())
             isargout[k++] = false;
           else
             {
-              int l = std::min (k + p->numel (),
+              int l = std::min (k + lval.numel (),
                                 static_cast<octave_idx_type> (nout));
               while (k < l)
                 isargout[k++] = true;
             }
         }
     }
   else
     for (int i = 0; i < nout; i++)
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -122,34 +122,34 @@ octave_shlib_list::do_remove (octave::dy
     }
 }
 
 octave::dynamic_library
 octave_shlib_list::do_find_file (const std::string& file_name) const
 {
   octave::dynamic_library retval;
 
-  for (const_iterator p = lib_list.begin (); p != lib_list.end (); p++)
+  for (const auto& lib : lib_list)
     {
-      if (p->file_name () == file_name)
+      if (lib.file_name () == file_name)
         {
-          retval = *p;
+          retval = lib;
           break;
         }
     }
 
   return retval;
 }
 
 void
 octave_shlib_list::do_display (void) const
 {
   std::cerr << "current shared libraries:" << std::endl;
-  for (const_iterator p = lib_list.begin (); p != lib_list.end (); p++)
-    std::cerr << "  " << p->file_name () << std::endl;
+  for (const auto& lib : lib_list)
+    std::cerr << "  " << lib.file_name () << std::endl;
 }
 
 bool
 octave_shlib_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -280,24 +280,21 @@ static void
 pr_where (std::ostream& os, const char *who,
           const std::list<error_stack_frame>& frames)
 {
   size_t nframes = frames.size ();
 
   if (nframes > 0)
     pr_where_1 (os, "%s: called from\n", who);
 
-  for (std::list<error_stack_frame>::const_iterator p = frames.begin ();
-       p != frames.end (); p++)
+  for (const auto& frm : frames)
     {
-      const error_stack_frame& elt = *p;
-
-      std::string fcn_name = elt.name;
-      int line = elt.line;
-      int column = elt.column;
+      std::string fcn_name = frm.name;
+      int line = frm.line;
+      int column = frm.column;
 
       if (line > 0)
         {
           if (column > 0)
             pr_where_1 (os, "    %s at line %d column %d\n",
                         fcn_name.c_str (), line, column);
           else
             pr_where_1 (os, "    %s at line %d\n", fcn_name.c_str (), line);
@@ -313,26 +310,23 @@ pr_where (std::ostream& os, const char *
   std::list<octave_call_stack::stack_frame> call_stack_frames
     = octave_call_stack::backtrace_frames ();
 
   // Print the error message only if it is different from the previous one;
   // Makes the output more concise and readable.
   call_stack_frames.unique ();
 
   std::list<error_stack_frame> frames;
-  for (std::list<octave_call_stack::stack_frame>::const_iterator p = call_stack_frames.begin ();
-       p != call_stack_frames.end (); p++)
+  for (const auto& frm : call_stack_frames)
     {
-      const octave_call_stack::stack_frame& elt = *p;
-
       error_stack_frame frame;
 
-      frame.name = elt.fcn_name ();
-      frame.line = elt.line ();
-      frame.column = elt.column ();
+      frame.name = frm.fcn_name ();
+      frame.line = frm.line ();
+      frame.column = frm.column ();
 
       frames.push_back (frame);
     }
 
     pr_where (os, who, frames);
 }
 
 static octave::execution_exception
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -596,26 +596,25 @@ namespace octave
       case 0:
         break;
 
       case 1:
         bbox = line_bbox.front ().extract (0, 0, 0, 3);
         break;
 
       default:
-        for (std::list<Matrix>::const_iterator it = line_bbox.begin ();
-             it != line_bbox.end (); ++it)
+        for (const auto& lbox : line_bbox)
           {
             if (bbox.is_empty ())
-              bbox = it->extract (0, 0, 0, 3);
+              bbox = lbox.extract (0, 0, 0, 3);
             else
               {
-                bbox(1) -= (*it)(3);
-                bbox(3) += (*it)(3);
-                bbox(2) = octave::math::max (bbox(2), (*it)(2));
+                bbox(1) -= lbox(3);
+                bbox(3) += lbox(3);
+                bbox(2) = octave::math::max (bbox(2), lbox(2));
               }
           }
         break;
       }
   }
 
   void
   ft_text_renderer::update_line_bbox (void)
@@ -1070,20 +1069,20 @@ namespace octave
   }
 
   void
   ft_text_renderer::visit (text_element_combined& e)
   {
     int saved_xoffset = xoffset;
     int max_xoffset = xoffset;
 
-    for (text_element_combined::iterator it = e.begin (); it != e.end (); ++it)
+    for (auto *txt_elt : e)
       {
         xoffset = saved_xoffset;
-        (*it)->accept (*this);
+        txt_elt->accept (*this);
         max_xoffset = octave::math::max (xoffset, max_xoffset);
       }
 
     xoffset = max_xoffset;
   }
 
   void
   ft_text_renderer::reset (void)
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -369,36 +369,36 @@ namespace octave
     return gl2psa;
   }
 
   void
   gl2ps_renderer::fix_strlist_position (double x, double y, double z,
                                         Matrix box, double rotation,
                                         std::list<octave::text_renderer::string>& lst)
   {
-    for (std::list<octave::text_renderer::string>::iterator p = lst.begin ();
-         p != lst.end (); p++)
+    for (auto& txtobj : lst)
       {
         // Get pixel coordinates
         ColumnVector coord_pix = get_transform ().transform (x, y, z, false);
 
         // Translate and rotate
         double rot = rotation * 4.0 * atan (1.0) / 180;
-        coord_pix(0) += ((*p).get_x () + box(0))*cos (rot)
-                        - ((*p).get_y () + box(1))*sin (rot);
-        coord_pix(1) -= ((*p).get_y () + box(1))*cos (rot)
-                        + ((*p).get_x () + box(0))*sin (rot);;
+        coord_pix(0) += (txtobj.get_x () + box(0))*cos (rot)
+                        - (txtobj.get_y () + box(1))*sin (rot);
+        coord_pix(1) -= (txtobj.get_y () + box(1))*cos (rot)
+                        + (txtobj.get_x () + box(0))*sin (rot);
 
         // Turn coordinates back into current gl coordinates
-        ColumnVector coord =
-          get_transform ().untransform (coord_pix(0), coord_pix(1),
-                                        coord_pix(2), false);
-        (*p).set_x (coord(0));
-        (*p).set_y (coord(1));
-        (*p).set_z (coord(2));
+        ColumnVector coord = get_transform ().untransform (coord_pix(0),
+                                                           coord_pix(1),
+                                                           coord_pix(2),
+                                                           false);
+        txtobj.set_x (coord(0));
+        txtobj.set_y (coord(1));
+        txtobj.set_z (coord(2));
       }
   }
 }
 
 static std::string
 code_to_symbol (uint32_t code)
 {
   std::string retval;
@@ -642,69 +642,68 @@ namespace octave
                                 s.get_angle () == "italic");
             set_color (s.get_color ());
             str = s.get_string ();
             sz = s.get_size ();
           }
 
         glRasterPos3d (x, y, z);
 
-        // Escape parenthesis until gl2ps does it (see bug ##45301).
+        // Escape parentheses until gl2ps does it (see bug #45301).
         if (term.find ("svg") == std::string::npos
             && term.find ("tex") == std::string::npos)
           {
             escape_character ("(", str);
             escape_character (")", str);
           }
 
         gl2psTextOpt (str.c_str (), name.c_str (), sz,
                       alignment_to_mode (ha, va), rotation);
         return bbox;
       }
 
     // Translate and rotate coordinates in order to use bottom-left alignment
     fix_strlist_position (x, y, z, bbox, rotation, lst);
 
-    for (std::list<octave::text_renderer::string>::iterator p = lst.begin ();
-         p != lst.end (); p++)
+    for (const auto& txtobj : lst)
       {
-        fontname = select_font ((*p).get_name (),
-                                (*p).get_weight () == "bold",
-                                (*p).get_angle () == "italic");
-        if ((*p).get_code ())
+        fontname = select_font (txtobj.get_name (),
+                                txtobj.get_weight () == "bold",
+                                txtobj.get_angle () == "italic");
+        if (txtobj.get_code ())
           {
             // This is only one character represented by a uint32 (utf8) code.
             // We replace it by the corresponding character in the
             // "Symbol" font except for svg which has built-in utf8 support.
             if (term.find ("svg") == std::string::npos)
               {
                 fontname = "Symbol";
-                str = code_to_symbol ((*p).get_code ());
+                str = code_to_symbol (txtobj.get_code ());
               }
             else
               {
                 std::stringstream ss;
-                ss << (*p).get_code ();
+                ss << txtobj.get_code ();
                 str = "&#" + ss.str () + ";";
               }
           }
         else
           {
-            str = (*p).get_string ();
+            str = txtobj.get_string ();
             // Escape parenthesis until gl2ps does it (see bug ##45301).
             if (term.find ("svg") == std::string::npos)
               {
                 escape_character ("(", str);
                 escape_character (")", str);
               }
           }
 
-        set_color ((*p).get_color ());
-        glRasterPos3d ((*p).get_x (), (*p).get_y (), (*p).get_z ());
-        gl2psTextOpt (str.c_str (), fontname.c_str (), (*p).get_size (),
+        set_color (txtobj.get_color ());
+        glRasterPos3d (txtobj.get_x (), txtobj.get_y (), txtobj.get_z ());
+        gl2psTextOpt (str.c_str (), fontname.c_str (), txtobj.get_size (),
                       GL2PS_TEXT_BL, rotation);
       }
 
     fontname = saved_font;
     return bbox;
   }
 
   void
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1209,49 +1209,50 @@ radio_values::radio_values (const std::s
       beg = end + 1;
     }
 }
 
 std::string
 radio_values::values_as_string (void) const
 {
   std::string retval;
-  for (std::set<caseless_str>::const_iterator it = possible_vals.begin ();
-       it != possible_vals.end (); it++)
+
+  for (const auto& val : possible_vals)
     {
       if (retval.empty ())
         {
-          if (*it == default_value ())
-            retval = "{" + *it + "}";
+          if (val == default_value ())
+            retval = "{" + val + "}";
           else
-            retval = *it;
+            retval = val;
         }
       else
         {
-          if (*it == default_value ())
-            retval += " | {" + *it + "}";
+          if (val == default_value ())
+            retval += " | {" + val + "}";
           else
-            retval += " | " + *it;
+            retval += " | " + val;
         }
     }
 
   if (! retval.empty ())
     retval = "[ " + retval + " ]";
 
   return retval;
 }
 
 Cell
 radio_values::values_as_cell (void) const
 {
   octave_idx_type i = 0;
   Cell retval (nelem (), 1);
-  for (std::set<caseless_str>::const_iterator it = possible_vals.begin ();
-       it != possible_vals.end (); it++)
-    retval(i++) = std::string (*it);
+
+  for (const auto& val : possible_vals)
+    retval(i++) = std::string (val);
+
   return retval;
 }
 
 bool
 color_values::str2rgb (const std::string& str_arg)
 {
   bool retval = true;
 
@@ -2210,20 +2211,18 @@ octave_scalar_map
 property_list::as_struct (const std::string& prefix_arg) const
 {
   octave_scalar_map m;
 
   for (plist_map_const_iterator p = begin (); p != end (); p++)
     {
       std::string prefix = prefix_arg + p->first;
 
-      const pval_map_type pval_map = p->second;
-
-      for (const auto& prop_val_p : pval_map)
-        m.assign (prefix + prop_val_p.first, prop_val_p.second);
+      for (const auto& prop_val : p->second)
+        m.assign (prefix + prop_val.first, prop_val.second);
     }
 
   return m;
 }
 
 // Set properties given as a cs-list of name, value pairs.
 
 void
@@ -2899,68 +2898,63 @@ xreset_default_properties (graphics_hand
 {
   graphics_object go = gh_manager::get_object (h);
 
   // Replace factory defaults by user defined ones
   std::string go_name = go.get_properties ().graphics_object_name ();
   property_list::pval_map_type pval;
   go.build_user_defaults_map (pval, go_name);
 
-  for (property_list::pval_map_const_iterator p = pval.begin ();
-       p != pval.end (); p++)
-    {
-      factory_pval[p->first] = p->second;
-    }
+  for (const auto& p : pval)
+    factory_pval[p.first] = p.second;
 
   // Reset defaults
-  for (property_list::pval_map_const_iterator it = factory_pval.begin ();
-       it != factory_pval.end (); it++)
-    {
-      std::string pname = it->first;
+  for (const auto& p : factory_pval)
+    {
+      std::string pname = p.first;
 
       // Don't reset internal properties and handle_properties
       if (! go.has_readonly_property (pname)
           && pname.find ("__") != 0 && pname.find ("current") != 0
           && pname != "uicontextmenu" && pname != "parent")
         {
           // Store *mode prop/val in order to set them last
           if (pname.find ("mode") == (pname.length () - 4))
-            pval[pname] = it->second;
+            pval[pname] = p.second;
           else
-            go.set (pname, it->second);
+            go.set (pname, p.second);
         }
     }
 
   // set *mode properties
-  for (property_list::pval_map_const_iterator it = pval.begin ();
-       it != pval.end (); it++)
-    go.set (it->first, it->second);
+  for (const auto& p : pval)
+    go.set (p.first, p.second);
 }
 
 // ---------------------------------------------------------------------
 
 void
 base_properties::set_from_list (base_graphics_object& bgo,
                                 property_list& defaults)
 {
   std::string go_name = graphics_object_name ();
 
   property_list::plist_map_const_iterator plist = defaults.find (go_name);
 
   if (plist != defaults.end ())
     {
       const property_list::pval_map_type pval_map = plist->second;
 
-      for (const auto& prop_val_p : pval_map)
-        {
-          std::string pname = prop_val_p.first;
+      for (const auto& prop_val : pval_map)
+        {
+          std::string pname = prop_val.first;
 
           try
             {
-              bgo.set (pname, prop_val_p.second);
+              bgo.set (pname, prop_val.second);
             }
           catch (octave::execution_exception& e)
             {
               error (e, "error setting default property %s", pname.c_str ());
             }
         }
     }
 }
@@ -3246,17 +3240,17 @@ base_graphics_object::update_axis_limits
     parent_go.update_axis_limits (axis_type, h);
 }
 
 void
 base_graphics_object::remove_all_listeners (void)
 {
   octave_map m = get (true).map_value ();
 
-  for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
+  for (const auto& pm : m)
     {
       // FIXME: there has to be a better way.  I think we want to
       // ask whether it is OK to delete the listener for the given
       // property.  How can we know in advance that it will be OK?
 
       octave::unwind_protect frame;
 
       frame.protect_var (discard_error_messages);
@@ -3264,17 +3258,17 @@ base_graphics_object::remove_all_listene
       frame.protect_var (Vdebug_on_warning);
 
       discard_error_messages = true;
       Vdebug_on_error = false;
       Vdebug_on_warning = false;
 
       try
         {
-          property p = get_properties ().get_property (pa->first);
+          property p = get_properties ().get_property (pm.first);
 
           if (p.ok ())
             p.delete_listener ();
         }
       catch (const octave::execution_exception&)
         {
           recover_from_exception ();
         }
@@ -3284,22 +3278,22 @@ base_graphics_object::remove_all_listene
 void
 base_graphics_object::build_user_defaults_map (property_list::pval_map_type &def, const std::string go_name) const
 {
   property_list local_defaults = get_defaults_list ();
   const auto it = local_defaults.find (go_name);
 
   if (it != local_defaults.end ())
     {
-      property_list::pval_map_type pval = it->second;
-      for (const auto& prop_val_p : pval)
-        {
-          std::string pname = prop_val_p.first;
+      property_list::pval_map_type pval_lst = it->second;
+      for (const auto& prop_val : pval_lst)
+        {
+          std::string pname = prop_val.first;
           if (def.find (pname) == def.end ())
-            def[pname] = prop_val_p.second;
+            def[pname] = prop_val.second;
         }
     }
 
   graphics_object parent_go = gh_manager::get_object (get_parent ());
 
   if (parent_go)
     parent_go.build_user_defaults_map (def, go_name);
 }
@@ -3326,33 +3320,33 @@ base_graphics_object::reset_default_prop
         set_warning_state ("Octave:deprecated-property", "error");
 
     }
 }
 
 std::string
 base_graphics_object::values_as_string (void)
 {
-  std::string retval;
-
   if (! valid_object ())
     error ("base_graphics_object::values_as_string: invalid graphics object");
 
+  std::string retval;
   octave_map m = get ().map_value ();
   graphics_object go = gh_manager::get_object (get_handle ());
 
-  for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
-    {
-      if (pa->first != "children" && ! go.has_readonly_property (pa->first))
-        {
-          property p = get_properties ().get_property (pa->first);
+  for (const auto& pm : m)
+    {
+      const auto& pname = pm.first;
+      if (pname != "children" && ! go.has_readonly_property (pname))
+        {
+          property p = get_properties ().get_property (pname);
 
           if (p.ok () && ! p.is_hidden ())
             {
-              retval += "\n\t" + std::string (pa->first) + ":  ";
+              retval += "\n\t" + std::string (pname) + ":  ";
               if (p.is_radio ())
                 retval += p.values_as_string ();
             }
         }
     }
 
   if (! retval.empty ())
     retval += "\n";
@@ -3393,23 +3387,22 @@ base_graphics_object::values_as_struct (
   octave_scalar_map retval;
 
   if (! valid_object ())
     error ("base_graphics_object::values_as_struct: invalid graphics object");
 
   octave_scalar_map m = get ().scalar_map_value ();
   graphics_object go = gh_manager::get_object (get_handle ());
 
-  for (octave_scalar_map::const_iterator pa = m.begin ();
-       pa != m.end (); pa++)
-    {
-      if (pa->first != "children"
-          && ! go.has_readonly_property (pa->first))
-        {
-          property p = get_properties ().get_property (pa->first);
+  for (const auto& pm : m)
+    {
+      const auto& pname = pm.first;
+      if (pname != "children" && ! go.has_readonly_property (pname))
+        {
+          property p = get_properties ().get_property (pname);
 
           if (p.ok () && ! p.is_hidden ())
             {
               if (p.is_radio ())
                 retval.assign (p.get_name (), p.values_as_cell ());
               else
                 retval.assign (p.get_name (), Cell ());
             }
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -203,21 +203,19 @@ local_functions (void)
   // Get subfunctions.
   const std::list<std::string> names = curr_fcn->subfunction_names ();
 
   size_t sz = names.size ();
   retval.resize (sz);
 
   // Loop over them.
   size_t i = 0;
-  for (std::list<std::string>::const_iterator p = names.begin ();
-       p != names.end (); p++)
-    retval(i++) = *p;
+  for (const auto& nm : names)
+    retval(i++) = nm;
 
-  retval.resize (i);
   return retval;
 }
 
 // FIXME: It's not likely that this does the right thing now.
 
 string_vector
 make_name_list (void)
 {
@@ -701,23 +699,22 @@ included in the list.  This is a known i
   const std::list<std::string> names = parent_fcn->subfunction_names ();
   const std::map<std::string, octave_value> h = parent_fcn->subfunctions ();
 
   size_t sz = names.size ();
   retval.resize (dim_vector (sz, 1));
 
   // loop over them.
   size_t i = 0;
-  for (std::list<std::string>::const_iterator p = names.begin ();
-       p != names.end (); p++)
+  for (const auto& nm : names)
     {
-      std::map<std::string, octave_value>::const_iterator q = h.find (*p);
-      if (q != h.end () &&
-          ! q->second.user_function_value ()->is_nested_function ())
-        retval(i++) = octave_value (new octave_fcn_handle (q->second, *p));
+      std::map<std::string, octave_value>::const_iterator nm_fcn = h.find (nm);
+      if (nm_fcn != h.end () &&
+          ! nm_fcn->second.user_function_value ()->is_nested_function ())
+        retval(i++) = octave_value (new octave_fcn_handle (nm_fcn->second, nm));
     }
 
   // remove pre-allocation for nested functions
   retval.resize (dim_vector (i, 1));
 
   return ovl (retval);
 }
 
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -262,22 +262,22 @@ octave_add_atexit_function (const std::s
   octave_atexit_functions.push_front (fname);
 }
 
 bool
 octave_remove_atexit_function (const std::string& fname)
 {
   bool found = false;
 
-  for (std::list<std::string>::iterator p = octave_atexit_functions.begin ();
-       p != octave_atexit_functions.end (); p++)
+  for (auto it = octave_atexit_functions.begin ();
+       it != octave_atexit_functions.end (); it++)
     {
-      if (*p == fname)
+      if (*it == fname)
         {
-          octave_atexit_functions.erase (p);
+          octave_atexit_functions.erase (it);
           found = true;
           break;
         }
     }
 
   return found;
 }
 
@@ -578,19 +578,18 @@ namespace octave
     install_ops ();
 
     install_builtins ();
 
     install_classdef ();
 
     std::list<std::string> command_line_path = options.command_line_path ();
 
-    for (std::list<std::string>::const_iterator it = command_line_path.begin ();
-         it != command_line_path.end (); it++)
-      load_path::set_command_line_path (*it);
+    for (const auto& pth : command_line_path)
+      load_path::set_command_line_path (pth);
 
     std::string exec_path = options.exec_path ();
     if (! exec_path.empty ())
       set_exec_path (exec_path);
 
     std::string image_path = options.image_path ();
     if (! image_path.empty ())
       set_image_path (image_path);
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -390,21 +390,19 @@ load_path::contains (const std::string& 
   return find_dir_info (dir) != dir_info_list.end ();
 }
 
 bool
 load_path::do_contains_canonical (const std::string& dir) const
 {
   bool retval = false;
 
-  for (const_dir_info_list_iterator i = dir_info_list.begin ();
-       i != dir_info_list.end ();
-       i++)
+  for (const auto& d : dir_info_list)
     {
-      if (same_file (dir, i->dir_name))
+      if (same_file (dir, d.dir_name))
         {
           retval = true;
           break;
         }
     }
 
   return retval;
 }
@@ -431,73 +429,71 @@ load_path::loader::move_fcn_map (const s
         }
 
       file_info_list_type& file_info_list = fcn_map[base];
 
       if (file_info_list.size () == 1)
         continue;
       else
         {
-          for (file_info_list_iterator p = file_info_list.begin ();
-               p != file_info_list.end ();
-               p++)
+          for (auto fi_it = file_info_list.begin ();
+               fi_it != file_info_list.end ();
+               fi_it++)
             {
-              if (p->dir_name == dir_name)
+              if (fi_it->dir_name == dir_name)
                 {
-                  file_info fi = *p;
-
-                  file_info_list.erase (p);
+                  file_info fi_tmp = *fi_it;
+
+                  file_info_list.erase (fi_it);
 
                   if (at_end)
-                    file_info_list.push_back (fi);
+                    file_info_list.push_back (fi_tmp);
                   else
-                    file_info_list.push_front (fi);
+                    file_info_list.push_front (fi_tmp);
 
                   break;
                 }
             }
         }
     }
 }
 
 void
 load_path::loader::move_method_map (const std::string& dir_name, bool at_end)
 {
-  for (method_map_iterator i = method_map.begin ();
-       i != method_map.end ();
-       i++)
+  for (auto& cls_fnmap : method_map)
     {
-      std::string class_name = i->first;
-
-      fcn_map_type& fm = i->second;
+      std::string class_name = cls_fnmap.first;
+
+      fcn_map_type& fn_map = cls_fnmap.second;
 
       std::string full_dir_name
         = octave::sys::file_ops::concat (dir_name, "@" + class_name);
 
-      for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
+      for (auto& nm_filst : fn_map)
         {
-          file_info_list_type& file_info_list = q->second;
+          file_info_list_type& file_info_list = nm_filst.second;
 
           if (file_info_list.size () == 1)
             continue;
           else
             {
-              for (file_info_list_iterator p = file_info_list.begin ();
-                   p != file_info_list.end (); p++)
+              for (auto fi_it = file_info_list.begin ();
+                   fi_it != file_info_list.end (); fi_it++)
                 {
-                  if (p->dir_name == full_dir_name)
+                  if (fi_it->dir_name == full_dir_name)
                     {
-                      file_info fi = *p;
-
-                      file_info_list.erase (p);
+                      file_info fi_tmp = *fi_it;
+
+                      file_info_list.erase (fi_it);
 
                       if (at_end)
-                        file_info_list.push_back (fi);
+                        file_info_list.push_back (fi_tmp);
                       else
-                        file_info_list.push_front (fi);
+                        file_info_list.push_front (fi_tmp);
 
                       break;
                     }
                 }
             }
         }
     }
 }
@@ -524,25 +520,24 @@ void
 load_path::move (const dir_info& di, bool at_end, const std::string& pname)
 {
   loader& l = get_loader (pname);
 
   l.move (di, at_end);
 
   dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
 
-  for (dir_info::const_package_dir_map_iterator p = package_dir_map.begin ();
-       p != package_dir_map.end (); ++p)
+  for (const auto& pkg_di : package_dir_map)
     {
-      std::string full_name = p->first;
+      std::string full_name = pkg_di.first;
 
       if (! pname.empty ())
         full_name = pname + "." + full_name;
 
-      move (p->second, at_end, full_name);
+      move (pkg_di.second, at_end, full_name);
     }
 }
 
 void
 load_path::loader::move (const dir_info& di, bool at_end)
 {
   std::string dir_name = di.dir_name;
 
@@ -669,20 +664,19 @@ load_path::do_set (const std::string& p,
 
   // Use a set when we need to search and order is not important.
   std::set<std::string> elts_set (elts.begin (), elts.end ());
 
   if (is_init)
     init_dirs = elts_set;
   else
     {
-      for (std::set<std::string>::const_iterator it = init_dirs.begin ();
-           it != init_dirs.end (); it++)
+      for (const auto& init_dir : init_dirs)
         {
-          if (elts_set.find (*it) == elts_set.end ())
+          if (elts_set.find (init_dir) == elts_set.end ())
             {
               warning_with_id ("Octave:remove-init-dir",
                                "default load path altered.  Some built-in functions may not be found.  Try restoredefaultpath() to recover it.");
               break;
             }
         }
     }
 
@@ -690,29 +684,28 @@ load_path::do_set (const std::string& p,
 
   octave::unwind_protect frame;
   frame.protect_var (add_hook);
 
   add_hook = 0;
 
   do_clear ();
 
-  for (std::list<std::string>::const_iterator i = elts.begin ();
-       i != elts.end (); i++)
-    do_append (*i, warn);
+  for (const auto& elt : elts)
+    do_append (elt, warn);
 
   // Restore add hook and execute for all newly added directories.
   frame.run_first ();
 
-  for (dir_info_list_iterator i = dir_info_list.begin ();
-       i != dir_info_list.end ();
-       i++)
+  // FIXME: Shouldn't the test for add_hook be outside the for loop?
+  //        Why not use const here?  Does add_hook change dir_info_list?
+  for (auto& di : dir_info_list)
     {
       if (add_hook)
-        add_hook (i->dir_name);
+        add_hook (di.dir_name);
     }
 
   // Always prepend current directory.
   do_prepend (".", warn);
 }
 
 void
 load_path::do_append (const std::string& dir, bool warn)
@@ -819,23 +812,23 @@ load_path::loader::remove_fcn_map (const
       if (pos != std::string::npos)
         {
           base = fname.substr (0, pos);
           ext = fname.substr (pos);
         }
 
       file_info_list_type& file_info_list = fcn_map[base];
 
-      for (file_info_list_iterator p = file_info_list.begin ();
-           p != file_info_list.end ();
-           p++)
+      for (auto fi_it = file_info_list.begin ();
+           fi_it != file_info_list.end ();
+           fi_it++)
         {
-          if (p->dir_name == dir)
+          if (fi_it->dir_name == dir)
             {
-              file_info_list.erase (p);
+              file_info_list.erase (fi_it);
 
               if (file_info_list.empty ())
                 fcn_map.erase (fname);
 
               break;
             }
         }
     }
@@ -848,45 +841,42 @@ load_path::loader::remove_private_fcn_ma
 
   if (p != private_fcn_map.end ())
     private_fcn_map.erase (p);
 }
 
 void
 load_path::loader::remove_method_map (const std::string& dir)
 {
-  for (method_map_iterator i = method_map.begin ();
-       i != method_map.end ();
-       i++)
+  for (auto& cls_fnmap : method_map)
     {
-      std::string class_name = i->first;
-
-      fcn_map_type& fm = i->second;
+      std::string class_name = cls_fnmap.first;
+
+      fcn_map_type& fn_map = cls_fnmap.second;
 
       std::string full_dir_name
         = octave::sys::file_ops::concat (dir, "@" + class_name);
 
-      for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
+      for (auto& nm_filst : fn_map)
         {
-          file_info_list_type& file_info_list = q->second;
+          file_info_list_type& file_info_list = nm_filst.second;
 
           if (file_info_list.size () == 1)
             continue;
           else
             {
-              for (file_info_list_iterator p = file_info_list.begin ();
-                   p != file_info_list.end (); p++)
+              for (auto fi_it = file_info_list.begin ();
+                   fi_it != file_info_list.end (); fi_it++)
                 {
-                  if (p->dir_name == full_dir_name)
+                  if (fi_it->dir_name == full_dir_name)
                     {
-                      file_info_list.erase (p);
-
+                      file_info_list.erase (fi_it);
                       // FIXME: if there are no other elements, we
-                      // should remove this element of fm but calling
-                      // erase here would invalidate the iterator q.
+                      // should remove this element of fn_map but calling
+                      // erase here would invalidate the iterator fi_it.
 
                       break;
                     }
                 }
             }
         }
     }
 }
@@ -936,25 +926,24 @@ void
 load_path::remove (const dir_info& di, const std::string& pname)
 {
   loader& l = get_loader (pname);
 
   l.remove (di);
 
   dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
 
-  for (dir_info::const_package_dir_map_iterator p = package_dir_map.begin ();
-       p != package_dir_map.end (); ++p)
+  for (const auto& pkg_di : package_dir_map)
     {
-      std::string full_name = p->first;
+      std::string full_name = pkg_di.first;
 
       if (! pname.empty ())
         full_name = pname + "." + full_name;
 
-      remove (p->second, full_name);
+      remove (pkg_di.second, full_name);
     }
 }
 
 void
 load_path::loader::remove (const dir_info& di)
 {
   std::string dir = di.dir_name;
 
@@ -975,22 +964,18 @@ load_path::do_update (void) const
   // I don't see a better way to do this because we need to
   // preserve the correct directory ordering for new files that
   // have appeared.
 
   default_loader.clear ();
 
   loader_map.clear ();
 
-  for (dir_info_list_iterator p = dir_info_list.begin ();
-       p != dir_info_list.end ();
-       p++)
+  for (auto& di : dir_info_list)
     {
-      dir_info& di = *p;
-
       di.update ();
 
       add (di, true, "", true);
     }
 }
 
 bool
 load_path::check_file_type (std::string& fname, int type, int possible_types,
@@ -1113,22 +1098,18 @@ load_path::loader::find_fcn (const std::
       dir_name = "";
 
       const_fcn_map_iterator p = fcn_map.find (fcn);
 
       if (p != fcn_map.end ())
         {
           const file_info_list_type& file_info_list = p->second;
 
-          for (const_file_info_list_iterator i = file_info_list.begin ();
-               i != file_info_list.end ();
-               i++)
+          for (const auto& fi : file_info_list)
             {
-              const file_info& fi = *i;
-
               retval = octave::sys::file_ops::concat (fi.dir_name, fcn);
 
               if (check_file_type (retval, type, fi.types,
                                    fcn, "load_path::do_find_fcn"))
                 {
                   dir_name = fi.dir_name;
                   break;
                 }
@@ -1189,22 +1170,18 @@ load_path::loader::find_method (const st
       const fcn_map_type& m = q->second;
 
       const_fcn_map_iterator p = m.find (meth);
 
       if (p != m.end ())
         {
           const file_info_list_type& file_info_list = p->second;
 
-          for (const_file_info_list_iterator i = file_info_list.begin ();
-               i != file_info_list.end ();
-               i++)
+          for (const auto& fi : file_info_list)
             {
-              const file_info& fi = *i;
-
               retval = octave::sys::file_ops::concat (fi.dir_name, meth);
 
               bool found = check_file_type (retval, type, fi.types,
                                             meth, "load_path::do_find_method");
 
               if (found)
                 {
                   dir_name = fi.dir_name;
@@ -1221,74 +1198,68 @@ load_path::loader::find_method (const st
 
 std::list<std::string>
 load_path::loader::methods (const std::string& class_name) const
 {
   std::list<std::string> retval;
 
   //  update ();
 
-  const_method_map_iterator q = method_map.find (class_name);
-
-  if (q != method_map.end ())
+  const_method_map_iterator mtd_map_it = method_map.find (class_name);
+
+  if (mtd_map_it != method_map.end ())
     {
-      const fcn_map_type& m = q->second;
-
-      for (const_fcn_map_iterator p = m.begin (); p != m.end (); p++)
-        retval.push_back (p->first);
+      for (const auto& nm_filst : mtd_map_it->second)
+        retval.push_back (nm_filst.first);
     }
 
   if (! retval.empty ())
     retval.sort ();
 
   return retval;
 }
 
 bool
 load_path::is_package (const std::string& name) const
 {
-  for (const_dir_info_list_iterator p = dir_info_list.begin ();
-       p != dir_info_list.end ();
-       p++)
+  for (const auto& di : dir_info_list)
     {
-      if (p->is_package (name))
+      if (di.is_package (name))
         return true;
     }
 
   return false;
 }
 
 std::list<std::string>
 load_path::do_overloads (const std::string& meth) const
 {
   std::list<std::string> retval;
 
   //  update ();
 
   default_loader.overloads (meth, retval);
 
-  for (const_loader_map_iterator l = loader_map.begin ();
-       l != loader_map.end (); ++l)
-    l->second.overloads (meth, retval);
+  for (const auto& nm_ldr : loader_map)
+    nm_ldr.second.overloads (meth, retval);
 
   return retval;
 }
 
 void
 load_path::loader::overloads (const std::string& meth,
                               std::list<std::string>& l) const
 {
-  for (const_method_map_iterator q = method_map.begin ();
-       q != method_map.end (); q++)
+  for (const auto& cls_fnmap : method_map)
     {
-      const fcn_map_type& m = q->second;
+      const fcn_map_type& m = cls_fnmap.second;
 
       if (m.find (meth) != m.end ())
         {
-          std::string class_name = q->first;
+          std::string class_name = cls_fnmap.first;
 
           if (! prefix.empty ())
             class_name = prefix + "." + class_name;
 
           l.push_back (class_name);
         }
     }
 }
@@ -1349,45 +1320,39 @@ load_path::do_find_file (const std::stri
         return tfile;
     }
 
   if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
       != std::string::npos)
     {
       // Given name has a directory separator, so append it to each
       // element of the load path in turn.
-
-      for (const_dir_info_list_iterator p = dir_info_list.begin ();
-           p != dir_info_list.end ();
-           p++)
+      for (const auto& di : dir_info_list)
         {
-          std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
+          std::string tfile = octave::sys::file_ops::concat (di.dir_name, file);
 
           octave::sys::file_stat fs (tfile);
 
           if (fs.exists ())
             return tfile;
         }
     }
   else
     {
       // Look in cache.
-
-      for (const_dir_info_list_iterator p = dir_info_list.begin ();
-           p != dir_info_list.end ();
-           p++)
+      for (const auto & di : dir_info_list)
         {
-          string_vector all_files = p->all_files;
+          string_vector all_files = di.all_files;
 
           octave_idx_type len = all_files.numel ();
 
           for (octave_idx_type i = 0; i < len; i++)
             {
               if (all_files[i] == file)
-                return octave::sys::file_ops::concat (p->dir_name, file);
+                return octave::sys::file_ops::concat (di.dir_name, file);
             }
         }
     }
 
   return retval;
 }
 
 std::string
@@ -1401,40 +1366,39 @@ load_path::do_find_dir (const std::strin
     {
       octave::sys::file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         return dir;
     }
   else
     {
-      for (const_dir_info_list_iterator p = dir_info_list.begin ();
-           p != dir_info_list.end ();
-           p++)
+      for (const auto& di : dir_info_list)
         {
-          std::string dname = octave::sys::env::make_absolute (p->dir_name);
+          std::string dname = octave::sys::env::make_absolute (di.dir_name);
 
           size_t dname_len = dname.length ();
 
-          if (dname.substr (dname_len - 1) == octave::sys::file_ops::dir_sep_str ())
+          if (dname.substr (dname_len - 1)
+              == octave::sys::file_ops::dir_sep_str ())
             {
               dname = dname.substr (0, dname_len - 1);
               dname_len--;
             }
 
           size_t dir_len = dir.length ();
 
           if (dname_len > dir_len
               && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
               && dir == dname.substr (dname_len - dir_len))
             {
-              octave::sys::file_stat fs (p->dir_name);
+              octave::sys::file_stat fs (di.dir_name);
 
               if (fs.exists () && fs.is_dir ())
-                return p->dir_name;
+                return di.dir_name;
             }
         }
     }
 
   return retval;
 }
 
 string_vector
@@ -1448,40 +1412,39 @@ load_path::do_find_matching_dirs (const 
     {
       octave::sys::file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         retlist.push_back (dir);
     }
   else
     {
-      for (const_dir_info_list_iterator p = dir_info_list.begin ();
-           p != dir_info_list.end ();
-           p++)
+      for (const auto& di : dir_info_list)
         {
-          std::string dname = octave::sys::env::make_absolute (p->dir_name);
+          std::string dname = octave::sys::env::make_absolute (di.dir_name);
 
           size_t dname_len = dname.length ();
 
-          if (dname.substr (dname_len - 1) == octave::sys::file_ops::dir_sep_str ())
+          if (dname.substr (dname_len - 1)
+              == octave::sys::file_ops::dir_sep_str ())
             {
               dname = dname.substr (0, dname_len - 1);
               dname_len--;
             }
 
           size_t dir_len = dir.length ();
 
           if (dname_len > dir_len
               && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
               && dir == dname.substr (dname_len - dir_len))
             {
-              octave::sys::file_stat fs (p->dir_name);
+              octave::sys::file_stat fs (di.dir_name);
 
               if (fs.exists () && fs.is_dir ())
-                retlist.push_back (p->dir_name);
+                retlist.push_back (di.dir_name);
             }
         }
     }
 
   return retlist;
 }
 
 std::string
@@ -1509,50 +1472,47 @@ load_path::do_find_first_of (const strin
             {
               octave::sys::file_stat fs (file);
 
               if (fs.exists ())
                 return file;
             }
           else
             {
-              for (const_dir_info_list_iterator p = dir_info_list.begin ();
-                   p != dir_info_list.end ();
-                   p++)
+              for (const auto& di : dir_info_list)
                 {
-                  std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
+                  std::string tfile;
+                  tfile = octave::sys::file_ops::concat (di.dir_name, file);
 
                   octave::sys::file_stat fs (tfile);
 
                   if (fs.exists ())
                     return tfile;
                 }
             }
         }
       else
         rel_flist[rel_flen++] = file;
     }
 
   rel_flist.resize (rel_flen);
 
-  for (const_dir_info_list_iterator p = dir_info_list.begin ();
-       p != dir_info_list.end ();
-       p++)
+  for (const auto& di : dir_info_list)
     {
-      string_vector all_files = p->all_files;
+      string_vector all_files = di.all_files;
 
       octave_idx_type len = all_files.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           for (octave_idx_type j = 0; j < rel_flen; j++)
             {
               if (all_files[i] == rel_flist[j])
                 {
-                  dir_name = p->dir_name;
+                  dir_name = di.dir_name;
                   file_name = rel_flist[j];
 
                   goto done;
                 }
             }
         }
     }
 
@@ -1589,82 +1549,76 @@ load_path::do_find_all_first_of (const s
             {
               octave::sys::file_stat fs (file);
 
               if (fs.exists ())
                 retlist.push_back (file);
             }
           else
             {
-              for (const_dir_info_list_iterator p = dir_info_list.begin ();
-                   p != dir_info_list.end ();
-                   p++)
+              for (const auto& di : dir_info_list)
                 {
-                  std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
+                  std::string tfile;
+                  tfile = octave::sys::file_ops::concat (di.dir_name, file);
 
                   octave::sys::file_stat fs (tfile);
 
                   if (fs.exists ())
                     retlist.push_back (tfile);
                 }
             }
         }
       else
         rel_flist[rel_flen++] = file;
     }
 
   rel_flist.resize (rel_flen);
 
-  for (const_dir_info_list_iterator p = dir_info_list.begin ();
-       p != dir_info_list.end (); p++)
+  for (const auto& di : dir_info_list)
     {
-      string_vector all_files = p->all_files;
+      string_vector all_files = di.all_files;
 
       octave_idx_type len = all_files.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           for (octave_idx_type j = 0; j < rel_flen; j++)
             {
               if (all_files[i] == rel_flist[j])
-                retlist.push_back (octave::sys::file_ops::concat (p->dir_name,
-                                                     rel_flist[j]));
+                retlist.push_back (octave::sys::file_ops::concat (di.dir_name,
+                                                                  rel_flist[j]));
             }
         }
     }
 
   return retlist;
 }
 
 string_vector
 load_path::do_dirs (void) const
 {
   size_t len = dir_info_list.size ();
 
   string_vector retval (len);
 
   octave_idx_type k = 0;
 
-  for (const_dir_info_list_iterator i = dir_info_list.begin ();
-       i != dir_info_list.end ();
-       i++)
-    retval[k++] = i->dir_name;
+  for (const auto& di : dir_info_list)
+    retval[k++] = di.dir_name;
 
   return retval;
 }
 
 std::list<std::string>
 load_path::do_dir_list (void) const
 {
   std::list<std::string> retval;
 
-  for (const_dir_info_list_iterator i = dir_info_list.begin ();
-       i != dir_info_list.end ();
-       i++)
-    retval.push_back (i->dir_name);
+  for (const auto& di : dir_info_list)
+    retval.push_back (di.dir_name);
 
   return retval;
 }
 
 string_vector
 load_path::do_files (const std::string& dir, bool omit_exts) const
 {
   string_vector retval;
@@ -1702,20 +1656,18 @@ string_vector
 load_path::loader::fcn_names (void) const
 {
   size_t len = fcn_map.size ();
 
   string_vector retval (len);
 
   octave_idx_type count = 0;
 
-  for (const_fcn_map_iterator p = fcn_map.begin ();
-       p != fcn_map.end ();
-       p++)
-    retval[count++] = p->first;
+  for (const auto& nm_filst : fcn_map)
+    retval[count++] = nm_filst.first;
 
   return retval;
 }
 
 std::string
 load_path::do_path (void) const
 {
   std::string xpath;
@@ -1760,44 +1712,40 @@ print_types (std::ostream& os, int types
       printed_type = true;
     }
 }
 
 void
 print_fcn_list (std::ostream& os,
                 const load_path::dir_info::fcn_file_map_type& lst)
 {
-  for (load_path::dir_info::const_fcn_file_map_iterator p = lst.begin ();
-       p != lst.end ();
-       p++)
+  for (const auto& nm_typ : lst)
     {
-      os << "  " << p->first << " (";
-
-      print_types (os, p->second);
+      os << "  " << nm_typ.first << " (";
+
+      print_types (os, nm_typ.second);
 
       os << ")\n";
     }
 }
 
 string_vector
 get_file_list (const load_path::dir_info::fcn_file_map_type& lst)
 {
   octave_idx_type n = lst.size ();
 
   string_vector retval (n);
 
   octave_idx_type count = 0;
 
-  for (load_path::dir_info::const_fcn_file_map_iterator p = lst.begin ();
-       p != lst.end ();
-       p++)
+  for (const auto& nm_typ : lst)
     {
-      std::string nm = p->first;
-
-      int types = p->second;
+      std::string nm = nm_typ.first;
+
+      int types = nm_typ.second;
 
       if (types & load_path::OCT_FILE)
         nm += ".oct";
       else if (types & load_path::MEX_FILE)
         nm += ".mex";
       else
         nm += ".m";
 
@@ -1805,54 +1753,50 @@ get_file_list (const load_path::dir_info
     }
 
   return retval;
 }
 
 void
 load_path::do_display (std::ostream& os) const
 {
-  for (const_dir_info_list_iterator i = dir_info_list.begin ();
-       i != dir_info_list.end ();
-       i++)
+  for (const auto& di : dir_info_list)
     {
-      string_vector fcn_files = i->fcn_files;
+      string_vector fcn_files = di.fcn_files;
 
       if (! fcn_files.empty ())
         {
-          os << "\n*** function files in " << i->dir_name << ":\n\n";
+          os << "\n*** function files in " << di.dir_name << ":\n\n";
 
           fcn_files.list_in_columns (os);
         }
 
       const dir_info::method_file_map_type& method_file_map
-        = i->method_file_map;
+        = di.method_file_map;
 
       if (! method_file_map.empty ())
         {
-          for (dir_info::const_method_file_map_iterator
-               p = method_file_map.begin (); p != method_file_map.end (); p++)
+          for (const auto& cls_ci : method_file_map)
             {
-              os << "\n*** methods in " << i->dir_name
-                 << "/@" << p->first << ":\n\n";
-
-              const dir_info::class_info& ci = p->second;
+              os << "\n*** methods in " << di.dir_name
+                 << "/@" << cls_ci.first << ":\n\n";
+
+              const dir_info::class_info& ci = cls_ci.second;
 
               string_vector method_files = get_file_list (ci.method_file_map);
 
               method_files.list_in_columns (os);
             }
         }
     }
 
   default_loader.display (os);
 
-  for (const_loader_map_iterator l = loader_map.begin ();
-       l != loader_map.end (); ++l)
-    l->second.display (os);
+  for (const auto& nm_ldr : loader_map)
+    nm_ldr.second.display (os);
 }
 
 // True if a path is contained in a path list separated by path_sep_char
 static bool
 in_path_list (const std::string& path_list, const std::string& path)
 {
   size_t ps = path.size ();
   size_t pls = path_list.size ();
@@ -1875,25 +1819,24 @@ load_path::add (const dir_info& di, bool
                 const std::string& pname, bool updating) const
 {
   loader& l = get_loader (pname);
 
   l.add (di, at_end, updating);
 
   dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
 
-  for (dir_info::const_package_dir_map_iterator p = package_dir_map.begin ();
-       p != package_dir_map.end (); ++p)
+  for (const auto& pkg_di : package_dir_map)
     {
-      std::string full_name = p->first;
+      std::string full_name = pkg_di.first;
 
       if (! pname.empty ())
         full_name = pname + "." + full_name;
 
-      add (p->second, at_end, full_name);
+      add (pkg_di.second, at_end, full_name);
     }
 }
 
 void
 load_path::loader::add_to_fcn_map (const dir_info& di, bool at_end,
                                    bool updating)
 {
   std::string dir_name = di.dir_name;
@@ -2007,44 +1950,38 @@ load_path::loader::add_to_private_fcn_ma
 void
 load_path::loader::add_to_method_map (const dir_info& di, bool at_end)
 {
   std::string dir_name = di.dir_name;
 
   // <CLASS_NAME, CLASS_INFO>
   dir_info::method_file_map_type method_file_map = di.method_file_map;
 
-  for (dir_info::const_method_file_map_iterator q = method_file_map.begin ();
-       q != method_file_map.end ();
-       q++)
+  for (const auto& cls_ci : method_file_map)
     {
-      std::string class_name = q->first;
+      std::string class_name = cls_ci.first;
 
       fcn_map_type& fm = method_map[class_name];
 
       std::string full_dir_name
         = octave::sys::file_ops::concat (dir_name, "@" + class_name);
 
-      const dir_info::class_info& ci = q->second;
+      const dir_info::class_info& ci = cls_ci.second;
 
       // <FCN_NAME, TYPES>
       const dir_info::fcn_file_map_type& m = ci.method_file_map;
 
-      for (dir_info::const_fcn_file_map_iterator p = m.begin ();
-           p != m.end ();
-           p++)
+      for (const auto& nm_typ : m)
         {
-          std::string base = p->first;
-
-          int types = p->second;
+          std::string base = nm_typ.first;
+          int types = nm_typ.second;
 
           file_info_list_type& file_info_list = fm[base];
 
           file_info_list_iterator p2 = file_info_list.begin ();
-
           while (p2 != file_info_list.end ())
             {
               if (p2->dir_name == full_dir_name)
                 break;
 
               p2++;
             }
 
@@ -2055,17 +1992,16 @@ load_path::loader::add_to_method_map (co
               if (at_end)
                 file_info_list.push_back (fi);
               else
                 file_info_list.push_front (fi);
             }
           else
             {
               // FIXME: is this possible?
-
               file_info& fi = *p2;
 
               fi.types = types;
             }
         }
 
       // <FCN_NAME, TYPES>
       dir_info::fcn_file_map_type private_file_map = ci.private_file_map;
@@ -2075,75 +2011,63 @@ load_path::loader::add_to_method_map (co
     }
 }
 
 void
 load_path::loader::display (std::ostream& os) const
 {
   os << "*** loader: " << (prefix.empty () ? "<top-level>" : prefix) << "\n\n";
 
-  for (std::list<std::string>::const_iterator s = dir_list.begin ();
-       s != dir_list.end (); ++s)
-    os << *s << "\n";
+  for (const auto& dir : dir_list)
+    os << dir << "\n";
   os << "\n";
 
-  for (const_private_fcn_map_iterator i = private_fcn_map.begin ();
-       i != private_fcn_map.end (); i++)
+  for (const auto& dir_fnlst : private_fcn_map)
     {
       os << "\n*** private functions in "
-         << octave::sys::file_ops::concat (i->first, "private") << ":\n\n";
-
-      print_fcn_list (os, i->second);
+         << octave::sys::file_ops::concat (dir_fnlst.first, "private") << ":\n\n";
+
+      print_fcn_list (os, dir_fnlst.second);
     }
 
 #if defined (DEBUG_LOAD_PATH)
 
-  for (const_fcn_map_iterator i = fcn_map.begin ();
-       i != fcn_map.end ();
-       i++)
+  for (const auto& nm_filst : fcn_map)
     {
-      os << i->first << ":\n";
-
-      const file_info_list_type& file_info_list = i->second;
-
-      for (const_file_info_list_iterator p = file_info_list.begin ();
-           p != file_info_list.end ();
-           p++)
+      os << nm_filst.first << ":\n";
+
+      const file_info_list_type& file_info_list = nm_filst.second;
+
+      for (const auto& finfo : file_info_list)
         {
-          os << "  " << p->dir_name << " (";
-
-          print_types (os, p->types);
+          os << "  " << finfo.dir_name << " (";
+
+          print_types (os, finfo.types);
 
           os << ")\n";
         }
     }
 
-  for (const_method_map_iterator i = method_map.begin ();
-       i != method_map.end ();
-       i++)
+  for (const auto& cls_fnmap : method_map)
     {
-      os << "CLASS " << i->first << ":\n";
-
-      const fcn_map_type& fm = i->second;
-
-      for (const_fcn_map_iterator q = fm.begin ();
-           q != fm.end ();
-           q++)
+      os << "CLASS " << cls_fnmap.first << ":\n";
+
+      const fcn_map_type& fm = cls_fnmap.second;
+
+      for (const auto& nm_fnlst : fcn_map)
         {
-          os << "  " << q->first << ":\n";
-
-          const file_info_list_type& file_info_list = q->second;
-
-          for (const_file_info_list_iterator p = file_info_list.begin ();
-               p != file_info_list.end ();
-               p++)
+          os << "  " << nm_fnlst.first << ":\n";
+
+          const file_info_list_type& file_info_list = nm_fnlst.second;
+
+          for (const auto& finfo : file_info_list)
             {
-              os << "  " << p->dir_name << " (";
-
-              print_types (os, p->types);
+              os << "  " << finfo.dir_name << " (";
+
+              print_types (os, finfo.types);
 
               os << ")\n";
             }
         }
     }
 
   os << "\n";
 
@@ -2197,21 +2121,20 @@ genpath (const std::string& dirname, con
   return retval;
 }
 
 std::list<std::string>
 load_path::do_get_all_package_names (bool only_top_level) const
 {
   std::list<std::string> retval;
 
-  for (const_loader_map_iterator l = loader_map.begin ();
-       l != loader_map.end (); ++l)
+  for (const auto& dir_ldr : loader_map)
     {
-      if (! only_top_level || l->first.find ('.') == std::string::npos)
-        retval.push_back (l->first);
+      if (! only_top_level || dir_ldr.first.find ('.') == std::string::npos)
+        retval.push_back (dir_ldr.first);
     }
 
   return retval;
 }
 
 static void
 execute_pkg_add_or_del (const std::string& dir,
                         const std::string& script_file)
@@ -2473,20 +2396,18 @@ For each directory that is added, and th
     {
       std::string arg = arglist(i).xstring_value ("addpath: all arguments must be strings");
 
       std::list<std::string> dir_elts = split_path (arg);
 
       if (! append)
         std::reverse (dir_elts.begin (), dir_elts.end ());
 
-      for (const auto& p : dir_elts)
+      for (auto dir : dir_elts)
         {
-          std::string dir = p;
-
           // Remove duplicate directory separators
           dir.erase (std::unique (dir.begin (), dir.end (),
                                   [](char l, char r)
                                   {
                                     return l == r &&
                                            octave::sys::file_ops::is_dir_sep (l);
                                   }),
                      dir.end ());
@@ -2540,22 +2461,18 @@ and runs it if it exists.
 
   bool need_to_update = false;
 
   for (int i = 0; i < nargin; i++)
     {
       std::string arg = args(i).xstring_value ("rmpath: all arguments must be strings");
       std::list<std::string> dir_elts = split_path (arg);
 
-      for (std::list<std::string>::const_iterator p = dir_elts.begin ();
-           p != dir_elts.end ();
-           p++)
+      for (const auto& dir : dir_elts)
         {
-          std::string dir = *p;
-
           //dir = regexprep (dir_elts{j}, '//+', "/");
           //dir = regexprep (dir, '/$', "");
 
           if (! load_path::remove (dir))
             warning ("rmpath: %s: not found", dir.c_str ());
           else
             need_to_update = true;
         }
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -973,23 +973,23 @@ static size_t
 save_fields (std::ostream& os, const octave_scalar_map& m,
              const std::string& pattern,
              load_save_format fmt, bool save_as_floats)
 {
   glob_match pat (pattern);
 
   size_t saved = 0;
 
-  for (octave_scalar_map::const_iterator p = m.begin (); p != m.end (); p++)
+  for (octave_scalar_map::const_iterator it = m.begin (); it != m.end (); it++)
     {
       std::string empty_str;
 
-      if (pat.match (m.key (p)))
+      if (pat.match (m.key (it)))
         {
-          do_save (os, m.contents (p), m.key (p), empty_str,
+          do_save (os, m.contents (it), m.key (it), empty_str,
                    0, fmt, save_as_floats);
 
           saved++;
         }
     }
 
   return saved;
 }
@@ -1000,22 +1000,19 @@ save_fields (std::ostream& os, const oct
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
            load_save_format fmt, bool save_as_floats)
 {
   std::list<symbol_table::symbol_record> vars = symbol_table::glob (pattern);
 
   size_t saved = 0;
 
-  typedef std::list<symbol_table::symbol_record>::const_iterator
-    const_vars_iterator;
-
-  for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
+  for (const auto& var : vars)
     {
-      do_save (os, *p, fmt, save_as_floats);
+      do_save (os, var, fmt, save_as_floats);
 
       saved++;
     }
 
   return saved;
 }
 
 static string_vector
@@ -1316,28 +1313,25 @@ dump_octave_core (std::ostream& os, cons
 {
   write_header (os, fmt);
 
   std::list<symbol_table::symbol_record> vars
     = symbol_table::all_variables (symbol_table::top_scope (), 0);
 
   double save_mem_size = 0;
 
-  typedef std::list<symbol_table::symbol_record>::const_iterator
-    const_vars_iterator;
-
-  for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
+  for (const auto& var : vars)
     {
-      octave_value val = p->varval ();
+      octave_value val = var.varval ();
 
       if (val.is_defined ())
         {
-          std::string name = p->name ();
+          std::string name = var.name ();
           std::string help;
-          bool global = p->is_global ();
+          bool global = var.is_global ();
 
           double val_size = val.byte_size () / 1024;
 
           // FIXME: maybe we should try to throw out the largest first...
 
           if (Voctave_core_file_limit < 0
               || save_mem_size + val_size < Voctave_core_file_limit)
             {
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2185,18 +2185,18 @@ save_mat5_element_length (const octave_v
 
       for (octave_idx_type j = 0; j < nel; j++)
         {
 
           for (octave_map::const_iterator i = m.begin (); i != m.end (); i++)
             {
               const Cell elts = m.contents (i);
 
-              ret += 8 + save_mat5_element_length (elts(j), "",
-                                               save_as_floats, mat7_format);
+              ret += 8 + save_mat5_element_length (elts(j), "", save_as_floats,
+                                                   mat7_format);
             }
         }
     }
   else
     ret = -1;
 
   return ret;
 }
diff --git a/libinterp/corefcn/oct-errno.in.cc b/libinterp/corefcn/oct-errno.in.cc
--- a/libinterp/corefcn/oct-errno.in.cc
+++ b/libinterp/corefcn/oct-errno.in.cc
@@ -325,18 +325,16 @@ octave_errno::do_lookup (const std::stri
   return (errno_tbl.find (name) != errno_tbl.end ()) ? errno_tbl[name] : -1;
 }
 
 octave_scalar_map
 octave_errno::do_list (void)
 {
   octave_scalar_map retval;
 
-  for (std::map<std::string, int>::const_iterator p = errno_tbl.begin ();
-       p != errno_tbl.end ();
-       p++)
+  for (const auto& p : errno_tbl)
     {
-      retval.assign (p->first, p->second);
+      retval.assign (p.first, p.second);
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -89,38 +89,38 @@ octave_fields::rmfield (const std::strin
   fields_rep::iterator p = rep->find (field);
   if (p == rep->end ())
     return -1;
   else
     {
       octave_idx_type n = p->second;
       make_unique ();
       rep->erase (field);
-      for (fields_rep::iterator q = rep->begin (); q != rep->end (); q++)
+      for (auto& fld_idx : *rep)
         {
-          if (q->second >= n)
-            q->second--;
+          if (fld_idx.second >= n)
+            fld_idx.second--;
         }
 
       return n;
     }
 }
 
 void
 octave_fields::orderfields (Array<octave_idx_type>& perm)
 {
   octave_idx_type n = rep->size ();
   perm.clear (n, 1);
 
   make_unique ();
   octave_idx_type i = 0;
-  for (fields_rep::iterator q = rep->begin (); q != rep->end (); q++)
+  for (auto& fld_idx : *rep)
     {
-      octave_idx_type j = q->second;
-      q->second = i;
+      octave_idx_type j = fld_idx.second;
+      fld_idx.second = i;
       perm(i++) = j;
     }
 }
 
 bool
 octave_fields::equal_up_to_order (const octave_fields& other,
                                   octave_idx_type* perm) const
 {
@@ -156,18 +156,18 @@ octave_fields::equal_up_to_order (const 
 }
 
 string_vector
 octave_fields::fieldnames (void) const
 {
   octave_idx_type n = nfields ();
   string_vector retval(n);
 
-  for (iterator p = begin (); p != end (); p++)
-    retval.xelem (p->second) = p->first;
+  for (auto& fld_idx : *this)
+    retval.xelem (fld_idx.second) = fld_idx.first;
 
   return retval;
 }
 
 octave_value
 octave_scalar_map::getfield (const std::string& k) const
 {
   octave_idx_type idx = xkeys.getfield (k);
@@ -1289,17 +1289,17 @@ octave_map::delete_elements (const octav
 
 octave_map
 octave_map::concat (const octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (nfields () == rb.nfields ())
     {
       for (const_iterator pa = begin (); pa != end (); pa++)
         {
-          const_iterator pb = rb.seek (key(pa));
+          const_iterator pb = rb.seek (key (pa));
 
           if (pb == rb.end ())
             error ("field name mismatch in structure concatenation");
 
           contents(pa).insert (rb.contents (pb), ra_idx);
         }
     }
   else
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2641,45 +2641,43 @@ namespace octave
     // after reading in data.
     // If the format was "", that conversion may already have happened,
     // so force all to be merged (as all are %f).
     bool merge_with_prev[fmt_list.numel ()];
     int conv = 0;
     if (collect_output)
       {
         int prev_type = -1;
-        for (std::list<octave_value>::iterator col = out.begin ();
-             col != out.end (); col++)
+        for (const auto& col : out)
           {
-            if (col->type_id () == prev_type
+            if (col.type_id () == prev_type
                 || (fmt_list.set_from_first && prev_type != -1))
-              merge_with_prev [conv++] = true;
+              merge_with_prev[conv++] = true;
             else
-              merge_with_prev [conv++] = false;
-
-            prev_type = col->type_id ();
+              merge_with_prev[conv++] = false;
+
+            prev_type = col.type_id ();
           }
       }
 
     // This should be caught by earlier code, but this avoids a possible
     // infinite loop below.
     if (fmt_list.num_conversions () == 0)
       error ("%s: No conversions specified", who.c_str ());
 
     // Read the data.  This is the main loop.
     if (! err)
       {
         for (/* row set ~30 lines above */; row < ntimes || ntimes == -1; row++)
           {
             if (row == 0 || row >= size)
               {
                 size += size+1;
-                for (std::list<octave_value>::iterator col = out.begin ();
-                     col != out.end (); col++)
-                  *col = (*col).resize (dim_vector (size, 1), 0);
+                for (auto& col : out)
+                  col = col.resize (dim_vector (size, 1), 0);
               }
 
             row_idx(0) = row;
             err = read_format_once (is, fmt_list, out, row_idx, done_after);
 
             if ((err & ~1) > 0 || ! is || (lines >= ntimes && ntimes > -1))
               break;
           }
@@ -2714,55 +2712,54 @@ namespace octave
                                      : (((err & 1) && (err & 8)) ? row : row+1);
     dim_vector dv (valid_rows, 1);
 
     ra_idx(0) = 0;
     int i = 0;
     if (! collect_output)
       {
         retval = Cell (dim_vector (1, out.size ()));
-        for (std::list<octave_value>::iterator col = out.begin ();
-             col != out.end (); col++, i++)
+        for (auto& col : out)
           {
             // trim last columns if that was requested
             if (i == done_after && uneven_columns)
               dv = dim_vector (std::max (valid_rows - 1, 0), 1);
 
             ra_idx(1) = i;
-            retval = do_cat_op (retval, octave_value (Cell (col->resize (dv,0))),
+            retval = do_cat_op (retval, octave_value (Cell (col.resize (dv,0))),
                                 ra_idx);
+            i++;
           }
       }
     else  // group adjacent cells of the same type into a single cell
       {
         octave_value cur;                // current cell, accumulating columns
         octave_idx_type group_size = 0;  // columns in this cell
         int prev_type = -1;
 
         conv = 0;
         retval = Cell ();
-        for (std::list<octave_value>::iterator col = out.begin ();
-             col != out.end (); col++)
+        for (auto& col : out)
           {
-            if (! merge_with_prev [conv++])  // including first time
+            if (! merge_with_prev[conv++])  // including first time
               {
                 if (prev_type != -1)
                   {
                     ra_idx(1) = i++;
                     retval = do_cat_op (retval, octave_value (Cell (cur)),
                                         ra_idx);
                   }
-                cur = octave_value (col->resize (dv,0));
+                cur = octave_value (col.resize (dv,0));
                 group_size = 1;
-                prev_type = col->type_id ();
+                prev_type = col.type_id ();
               }
             else
               {
                 ra_idx(1) = group_size++;
-                cur = do_cat_op (cur, octave_value (col->resize (dv,0)),
+                cur = do_cat_op (cur, octave_value (col.resize (dv,0)),
                                  ra_idx);
               }
           }
         ra_idx(1) = i;
         retval = do_cat_op (retval, octave_value (Cell (cur)), ra_idx);
       }
 
     return retval;
@@ -7523,23 +7520,23 @@ std::string
 octave_stream_list::do_list_open_files (void) const
 {
   std::ostringstream buf;
 
   buf << "\n"
       << "  number  mode  arch       name\n"
       << "  ------  ----  ----       ----\n";
 
-  for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
+  for (const auto& fid_strm : list)
     {
-      octave_stream os = p->second;
+      octave_stream os = fid_strm.second;
 
       buf << "  "
           << std::setiosflags (std::ios::right)
-          << std::setw (4) << p->first << "     "
+          << std::setw (4) << fid_strm.first << "     "
           // reset necessary in addition to setiosflags since this is one stmt.
           << std::resetiosflags (std::ios::adjustfield)
           << std::setiosflags (std::ios::left)
           << std::setw (3)
           << octave_stream::mode_as_string (os.mode ())
           << "  "
           << std::setw (9)
           << octave::mach_info::float_format_as_string (os.float_format ())
@@ -7554,47 +7551,47 @@ octave_stream_list::do_list_open_files (
 
 octave_value
 octave_stream_list::do_open_file_numbers (void) const
 {
   Matrix retval (1, list.size (), 0.0);
 
   int num_open = 0;
 
-  for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
+  for (const auto& fid_strm : list)
     {
       // Skip stdin, stdout, and stderr.
-      if (p->first > 2 && p->second)
-        retval(0,num_open++) = p->first;
+      if (fid_strm.first > 2 && fid_strm.second)
+        retval(0, num_open++) = fid_strm.first;
     }
 
   retval.resize ((num_open > 0), num_open);
 
   return retval;
 }
 
 int
 octave_stream_list::do_get_file_number (const octave_value& fid) const
 {
   int retval = -1;
 
   if (fid.is_string ())
     {
       std::string nm = fid.string_value ();
 
-      for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
+      for (const auto& fid_strm : list)
         {
           // stdin, stdout, and stderr are unnamed.
-          if (p->first > 2)
+          if (fid_strm.first > 2)
             {
-              octave_stream os = p->second;
+              octave_stream os = fid_strm.second;
 
               if (os && os.name () == nm)
                 {
-                  retval = p->first;
+                  retval = fid_strm.first;
                   break;
                 }
             }
         }
     }
   else
     {
       int conv_err = 0;
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -230,23 +230,22 @@ Undocumented internal function.
   // If 3, then retval is filename, directory, and selected index.
   if (nel <= 3)
     {
       if (items_lst.front ().empty ())
         retval = ovl (octave_value (0.), octave_value (0.), octave_value (0.));
       else
         {
           int idx = 0;
-          for (std::list<std::string>::iterator it = items_lst.begin ();
-               it != items_lst.end (); it++)
+          for (auto& str : items_lst)
             {
               if (idx != 2)
-                retval(idx++) = *it;
+                retval(idx++) = str;
               else
-                retval(idx++) = atoi (it->c_str ());
+                retval(idx++) = atoi (str.c_str ());
             }
         }
     }
   else
     {
       // Multiple files.
       nel -= 2;
       Cell items (dim_vector (1, nel));
@@ -306,21 +305,18 @@ Undocumented internal function.
     = octave_link::list_dialog (list_lst, mode, width, height,
                                 initial_lst, name, prompt_lst,
                                 ok_string, cancel_string);
 
   std::list<int> items_lst = result.first;
   nel = items_lst.size ();
   Matrix items (dim_vector (1, nel));
   octave_idx_type i = 0;
-  for (std::list<int>::iterator it = items_lst.begin ();
-       it != items_lst.end (); it++)
-    {
-      items.xelem(i++) = *it;
-    }
+  for (const auto& int_el : items_lst)
+    items.xelem(i++) = int_el;
 
   return ovl (items, result.second);
 }
 
 DEFUN (__octave_link_input_dialog__, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} __octave_link_input_dialog__ (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})
 Undocumented internal function.
@@ -359,21 +355,18 @@ Undocumented internal function.
 
   std::list<std::string> items_lst
     = octave_link::input_dialog (prompt_lst, title, nr, nc,
                                  defaults_lst);
 
   nel = items_lst.size ();
   Cell items (dim_vector (nel, 1));
   octave_idx_type i = 0;
-  for (std::list<std::string>::iterator it = items_lst.begin ();
-       it != items_lst.end (); it++)
-    {
-      items.xelem(i++) = *it;
-    }
+  for (const auto& str_el : items_lst)
+    items.xelem(i++) = str_el;
 
   return ovl (items);
 }
 
 DEFUN (__octave_link_show_preferences__, , ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} __octave_link_show_preferences__ ()
 Undocumented internal function.
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -40,34 +40,32 @@ profile_data_accumulator::stats::stats (
 
 octave_value
 profile_data_accumulator::stats::function_set_value (const function_set& list)
 {
   const octave_idx_type n = list.size ();
 
   RowVector retval (n);
   octave_idx_type i = 0;
-  for (function_set::const_iterator p = list.begin (); p != list.end (); ++p)
-    {
-      retval(i) = *p;
-      ++i;
-    }
+  for (const auto& nm : list)
+    retval(i++) = nm;
+
   assert (i == n);
 
   return retval;
 }
 
 profile_data_accumulator::tree_node::tree_node (tree_node* p, octave_idx_type f)
   : parent (p), fcn_id (f), children (), time (0.0), calls (0)
 { }
 
 profile_data_accumulator::tree_node::~tree_node ()
 {
-  for (child_map::iterator i = children.begin (); i != children.end (); ++i)
-    delete i->second;
+  for (auto& idx_tnode : children)
+    delete idx_tnode.second;
 }
 
 profile_data_accumulator::tree_node*
 profile_data_accumulator::tree_node::enter (octave_idx_type fcn)
 {
   tree_node* retval;
 
   child_map::iterator pos = children.find (fcn);
@@ -117,19 +115,18 @@ profile_data_accumulator::tree_node::bui
           if (i->fcn_id == fcn_id)
             {
               entry.recursive = true;
               break;
             }
     }
 
   // Recurse on children.
-  for (child_map::const_iterator i = children.begin ();
-       i != children.end (); ++i)
-    i->second->build_flat (data);
+  for (const auto& idx_tnode : children)
+    idx_tnode.second->build_flat (data);
 }
 
 octave_value
 profile_data_accumulator::tree_node::get_hierarchical (double* total) const
 {
   // Note that we don't generate the entry just for this node, but
   // rather a struct-array with entries for all children.  This way, the
   // top-node (for which we don't want a real entry) generates already
@@ -139,23 +136,22 @@ profile_data_accumulator::tree_node::get
 
   Cell rv_indices (n, 1);
   Cell rv_times (n, 1);
   Cell rv_totals (n, 1);
   Cell rv_calls (n, 1);
   Cell rv_children (n, 1);
 
   octave_idx_type i = 0;
-  for (child_map::const_iterator p = children.begin ();
-       p != children.end (); ++p)
+  for (const auto& idx_tnode : children)
     {
-      const tree_node& entry = *p->second;
+      const tree_node& entry = *idx_tnode.second;
       double child_total = entry.time;
 
-      rv_indices(i) = octave_value (p->first);
+      rv_indices(i) = octave_value (idx_tnode.first);
       rv_times(i) = octave_value (entry.time);
       rv_calls(i) = octave_value (entry.calls);
       rv_children(i) = entry.get_hierarchical (&child_total);
       rv_totals(i) = octave_value (child_total);
 
       if (total)
         *total += child_total;
 
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -375,20 +375,19 @@ octregexp (const octave_value_list &args
     }
   else
     {
       for (int j = 0; j < named_pats.numel (); j++)
         {
           Cell tmp (dim_vector (1, sz));
 
           i = 0;
-          for (octave::regexp::match_data::const_iterator p = rx_lst.begin ();
-               p != rx_lst.end (); p++)
+          for (const auto& match_data : rx_lst)
             {
-              string_vector named_tokens = p->named_tokens ();
+              string_vector named_tokens = match_data.named_tokens ();
 
               tmp(i++) = named_tokens(j);
             }
 
           nmap.assign (named_pats(j), octave_value (tmp));
         }
 
       retval(5) = nmap;
@@ -428,26 +427,25 @@ octregexp (const octave_value_list &args
       Cell match_string (dim_vector (1, sz));
       Cell token_extents (dim_vector (1, sz));
       NDArray end (dim_vector (1, sz));
       NDArray start (dim_vector (1, sz));
       Cell split (dim_vector (1, sz+1));
       size_t sp_start = 0;
 
       i = 0;
-      for (octave::regexp::match_data::const_iterator p = rx_lst.begin ();
-           p != rx_lst.end (); p++)
+      for (const auto& match_data : rx_lst)
         {
-          double s = p->start ();
-          double e = p->end ();
+          double s = match_data.start ();
+          double e = match_data.end ();
 
-          string_vector tmp = p->tokens ();
+          string_vector tmp = match_data.tokens ();
           tokens(i) = Cell (dim_vector (1, tmp.numel ()), tmp);
-          match_string(i) = p->match_string ();
-          token_extents(i) = p->token_extents ();
+          match_string(i) = match_data.match_string ();
+          token_extents(i) = match_data.token_extents ();
           end(i) = e;
           start(i) = s;
           split(i) = buffer.substr (sp_start, s-sp_start-1);
           sp_start = e;
           i++;
         }
 
       split(i) = buffer.substr (sp_start);
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -133,21 +133,18 @@ qs_search (const Array<char>& needle,
       if (j == n - m && std::equal (x, x + m, y + j))
         accum.push_back (j);
     }
 
   octave_idx_type nmatch = accum.size ();
   octave_idx_type one = 1;
   Array<octave_idx_type> result (dim_vector (std::min (one, nmatch), nmatch));
   octave_idx_type k = 0;
-  for (std::deque<octave_idx_type>::const_iterator iter = accum.begin ();
-       iter != accum.end (); iter++)
-    {
-      result.xelem (k++) = *iter;
-    }
+  for (const auto& idx : accum)
+    result.xelem (k++) = idx;
 
   return result;
 }
 
 DEFUN (strfind, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{idx} =} strfind (@var{str}, @var{pattern})
 @deftypefnx {} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1128,44 +1128,40 @@ symbol_table::fcn_info::fcn_info_rep::du
        << fcn_file_name (autoload_function) << "\n";
 
   if (function_on_path.is_defined ())
     os << tprefix << "function from path: "
        << fcn_file_name (function_on_path) << "\n";
 
   if (! subfunctions.empty ())
     {
-      for (scope_val_const_iterator p = subfunctions.begin ();
-           p != subfunctions.end (); p++)
-        os << tprefix << "subfunction: " << fcn_file_name (p->second)
-           << " [" << p->first << "]\n";
+      for (const auto& scope_val : subfunctions)
+        os << tprefix << "subfunction: " << fcn_file_name (scope_val.second)
+           << " [" << scope_val.first << "]\n";
     }
 
   if (! private_functions.empty ())
     {
-      for (str_val_const_iterator p = private_functions.begin ();
-           p != private_functions.end (); p++)
-        os << tprefix << "private: " << fcn_file_name (p->second)
-           << " [" << p->first << "]\n";
+      for (const auto& str_val : private_functions)
+        os << tprefix << "private: " << fcn_file_name (str_val.second)
+           << " [" << str_val.first << "]\n";
     }
 
   if (! class_constructors.empty ())
     {
-      for (str_val_const_iterator p = class_constructors.begin ();
-           p != class_constructors.end (); p++)
-        os << tprefix << "constructor: " << fcn_file_name (p->second)
-           << " [" << p->first << "]\n";
+      for (const auto& str_val : class_constructors)
+        os << tprefix << "constructor: " << fcn_file_name (str_val.second)
+           << " [" << str_val.first << "]\n";
     }
 
   if (! class_methods.empty ())
     {
-      for (str_val_const_iterator p = class_methods.begin ();
-           p != class_methods.end (); p++)
-        os << tprefix << "method: " << fcn_file_name (p->second)
-           << " [" << p->first << "]\n";
+      for (const auto& str_val : class_methods)
+        os << tprefix << "method: " << fcn_file_name (str_val.second)
+           << " [" << str_val.first << "]\n";
     }
 }
 
 void
 symbol_table::install_nestfunction (const std::string& name,
                                     const octave_value& fcn,
                                     scope_id parent_scope)
 {
@@ -1330,58 +1326,55 @@ symbol_table::dump (std::ostream& os, sc
 
 void
 symbol_table::dump_global (std::ostream& os)
 {
   if (! global_table.empty ())
     {
       os << "*** dumping global symbol table\n\n";
 
-      for (global_table_const_iterator p = global_table.begin ();
-           p != global_table.end (); p++)
+      for (const auto& str_val : global_table)
         {
-          std::string nm = p->first;
-          octave_value val = p->second;
+          std::string nm = str_val.first;
+          octave_value val = str_val.second;
 
           os << "  " << nm << " ";
           val.dump (os);
           os << "\n";
         }
     }
 }
 
 void
 symbol_table::dump_functions (std::ostream& os)
 {
   if (! fcn_table.empty ())
     {
       os << "*** dumping globally visible functions from symbol table\n"
          << "    (c=commandline, b=built-in)\n\n";
 
-      for (fcn_table_const_iterator p = fcn_table.begin ();
-           p != fcn_table.end (); p++)
-        p->second.dump (os, "  ");
+      for (const auto& nm_fi : fcn_table)
+        nm_fi.second.dump (os, "  ");
 
       os << "\n";
     }
 }
 
 void
 symbol_table::stash_dir_name_for_subfunctions (scope_id scope,
                                                const std::string& dir_name)
 {
   // FIXME: is this the best way to do this?  Maybe it would be
   // better if we had a map from scope to list of subfunctions
   // stored with the function.  Do we?
 
-  for (fcn_table_const_iterator p = fcn_table.begin ();
-       p != fcn_table.end (); p++)
+  for (const auto& nm_fi : fcn_table)
     {
       std::pair<std::string, octave_value> tmp
-        = p->second.subfunction_defined_in_scope (scope);
+        = nm_fi.second.subfunction_defined_in_scope (scope);
 
       std::string nm = tmp.first;
 
       if (! nm.empty ())
         {
           octave_value& fcn = tmp.second;
 
           octave_user_function *f = fcn.user_function_value ();
@@ -1465,20 +1458,20 @@ symbol_table::do_builtin_find (const std
   return retval;
 }
 
 std::list<workspace_element>
 symbol_table::do_workspace_info (void) const
 {
   std::list<workspace_element> retval;
 
-  for (table_const_iterator p = table.begin (); p != table.end (); p++)
+  for (const auto& nm_sr : table)
     {
-      std::string nm = p->first;
-      symbol_record sr = p->second;
+      std::string nm = nm_sr.first;
+      symbol_record sr = nm_sr.second;
 
       if (! sr.is_hidden ())
         {
           octave_value val = sr.varval ();
 
           if (val.is_defined ())
             {
               // FIXME: fix size for objects, see kluge in variables.cc
@@ -1521,56 +1514,54 @@ symbol_table::do_workspace_info (void) c
 
 void
 symbol_table::do_dump (std::ostream& os)
 {
   if (! persistent_table.empty ())
     {
       os << "  persistent variables in this scope:\n\n";
 
-      for (persistent_table_const_iterator p = persistent_table.begin ();
-           p != persistent_table.end (); p++)
+      for (const auto& nm_val : persistent_table)
         {
-          std::string nm = p->first;
-          octave_value val = p->second;
+          std::string nm = nm_val.first;
+          octave_value val = nm_val.second;
 
           os << "    " << nm << " ";
           val.dump (os);
           os << "\n";
         }
 
       os << "\n";
     }
 
   if (! table.empty ())
     {
       os << "  other symbols in this scope (l=local; a=auto; f=formal\n"
          << "    h=hidden; i=inherited; g=global; p=persistent)\n\n";
 
-      for (table_const_iterator p = table.begin (); p != table.end (); p++)
-        p->second.dump (os, "    ");
+      for (const auto& nm_sr : table)
+        nm_sr.second.dump (os, "    ");
 
       os << "\n";
     }
 }
 
 void symbol_table::cleanup (void)
 {
   clear_all (true);
 
   // Delete all possibly remaining scopes.
-  for (all_instances_iterator iter = all_instances.begin ();
-       iter != all_instances.end (); iter++)
+  for (auto& scope_stp : all_instances)
     {
       // First zero the table entry to avoid possible duplicate delete.
-      symbol_table *inst = iter->second;
-      iter->second = 0;
+      symbol_table *inst = scope_stp.second;
+      scope_stp.second = 0;
 
-      // Now delete the scope.  Note that there may be side effects, such as
-      // deleting other scopes.
+      // Now delete the scope.
+      // Note that there may be side effects, such as deleting other scopes.
       delete inst;
     }
 
   global_table.clear ();
   fcn_table.clear ();
   class_precedence_table.clear ();
   parent_map.clear ();
   all_instances.clear ();
@@ -1580,46 +1571,45 @@ void
 symbol_table::do_update_nest (void)
 {
   if (nest_parent || nest_children.size ())
     curr_fcn->mark_as_nested_function ();
 
   if (nest_parent)
     {
       // fix bad symbol_records
-      for (table_iterator ti = table.begin (); ti != table.end (); ++ti)
+      for (auto& nm_sr : table)
         {
-          symbol_record &ours = ti->second;
+          symbol_record &ours = nm_sr.second;
           symbol_record parents;
           if (! ours.is_formal ()
-              && nest_parent->look_nonlocal (ti->first, parents))
+              && nest_parent->look_nonlocal (nm_sr.first, parents))
             {
               if (ours.is_global () || ours.is_persistent ())
                 error ("global and persistent may only be used in the topmost level in which a nested variable is used");
 
               if (! ours.is_formal ())
                 {
                   ours.invalidate ();
-                  ti->second = parents;
+                  nm_sr.second = parents;
                 }
             }
           else
             ours.set_curr_fcn (curr_fcn);
         }
     }
   else if (nest_children.size ())
     {
       static_workspace = true;
-      for (table_iterator ti = table.begin (); ti != table.end (); ++ti)
-        ti->second.set_curr_fcn (curr_fcn);
+      for (auto& nm_sr : table)
+        nm_sr.second.set_curr_fcn (curr_fcn);
     }
 
-  for (std::vector<symbol_table*>::iterator iter = nest_children.begin ();
-       iter != nest_children.end (); ++iter)
-    (*iter)->do_update_nest ();
+  for (auto& symtab_p : nest_children)
+    symtab_p->do_update_nest ();
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} ignore_function_time_stamp ()
 @deftypefnx {} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})
 Query or set the internal variable that controls whether Octave checks
 the time stamp on files each time it looks up functions defined in
@@ -1726,19 +1716,18 @@ Undocumented internal function.
   if (nargin == 0)
     {
       symbol_table::dump_functions (octave_stdout);
 
       symbol_table::dump_global (octave_stdout);
 
       std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
 
-      for (std::list<symbol_table::scope_id>::const_iterator p = lst.begin ();
-           p != lst.end (); p++)
-        symbol_table::dump (octave_stdout, *p);
+      for (const auto& scope_id : lst)
+        symbol_table::dump (octave_stdout, scope_id);
     }
   else
     {
       octave_value arg = args(0);
 
       if (arg.is_string ())
         {
           std::string s_arg = arg.string_value ();
@@ -1746,19 +1735,18 @@ Undocumented internal function.
           if (s_arg == "scopes")
             {
               std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
 
               RowVector v (lst.size ());
 
               octave_idx_type k = 0;
 
-              for (std::list<symbol_table::scope_id>::const_iterator
-                   p = lst.begin (); p != lst.end (); p++)
-                v.xelem (k++) = *p;
+              for (const auto& scope_id : lst)
+                v.xelem (k++) = scope_id;
 
               retval = v;
             }
           else if (s_arg == "functions")
             {
               symbol_table::dump_functions (octave_stdout);
             }
           else
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -152,18 +152,18 @@ public:
       in_use.erase (p);
       free_list.insert (scope);
     }
 
     std::list<scope_id> do_scopes (void) const
     {
       std::list<scope_id> retval;
 
-      for (set_const_iterator p = in_use.begin (); p != in_use.end (); p++)
-        retval.push_back (*p);
+      for (const auto& scope_id : in_use)
+        retval.push_back (scope_id);
 
       retval.sort ();
 
       return retval;
     }
   };
 
   class fcn_info;
@@ -1177,26 +1177,26 @@ public:
         all_instances.erase (p);
 
         free_scope (scope);
       }
   }
 
   static void erase_subfunctions_in_scope (scope_id scope)
   {
-    for (fcn_table_iterator q = fcn_table.begin (); q != fcn_table.end (); q++)
-      q->second.erase_subfunction (scope);
+    for (auto& nm_finfo : fcn_table)
+      nm_finfo.second.erase_subfunction (scope);
   }
 
   static void
   mark_subfunctions_in_scope_as_private (scope_id scope,
                                          const std::string& class_name)
   {
-    for (fcn_table_iterator q = fcn_table.begin (); q != fcn_table.end (); q++)
-      q->second.mark_subfunction_in_scope_as_private (scope, class_name);
+    for (auto& nm_finfo : fcn_table)
+      nm_finfo.second.mark_subfunction_in_scope_as_private (scope, class_name);
   }
 
   static scope_id dup_scope (scope_id scope)
   {
     scope_id retval = -1;
 
     symbol_table *inst = get_instance (scope);
 
@@ -1648,18 +1648,18 @@ public:
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       inst->do_clear_objects ();
   }
 
   static void clear_functions (bool force = false)
   {
-    for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
-      p->second.clear (force);
+    for (auto& nm_finfo : fcn_table)
+      nm_finfo.second.clear (force);
   }
 
   static void clear_function (const std::string& name)
   {
     clear_user_function (name);
   }
 
   static void clear_global (const std::string& name,
@@ -1687,20 +1687,20 @@ public:
     clear_variable (name);
     clear_function (name);
   }
 
   static void clear_function_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
-    for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
+    for (auto& nm_finfo : fcn_table)
       {
-        if (pattern.match (p->first))
-          p->second.clear_user_function ();
+        if (pattern.match (nm_finfo.first))
+          nm_finfo.second.clear_user_function ();
       }
   }
 
   static void clear_global_pattern (const std::string& pat,
                                     scope_id scope = xcurrent_scope)
   {
     symbol_table *inst = get_instance (scope);
 
@@ -1760,22 +1760,18 @@ public:
 
         finfo.clear_autoload_function ();
         finfo.clear_user_function ();
       }
   }
 
   static void clear_mex_functions (void)
   {
-    for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.clear_mex_function ();
-      }
+    for (auto& nm_finfo : fcn_table)
+      nm_finfo.second.clear_mex_function ();
   }
 
   static bool set_class_relationship (const std::string& sup_class,
                                       const std::string& inf_class);
 
   static bool is_superiorto (const std::string& a, const std::string& b);
 
   static void alias_built_in_function (const std::string& alias,
@@ -1902,49 +1898,45 @@ public:
 
   static std::list<symbol_record>
   glob_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
-    for (global_table_const_iterator p = global_table.begin ();
-         p != global_table.end (); p++)
+    for (const auto& nm_val : global_table)
       {
-        // We generate a list of symbol_record objects so that
-        // the results from glob_variables and glob_global_variables
-        // may be handled the same way.
-
-        if (pat.match (p->first))
+        // We generate a list of symbol_record objects so that the results from
+        // glob_variables and glob_global_variables may be handled the same
+        // way.
+        if (pat.match (nm_val.first))
           retval.push_back (symbol_record (xglobal_scope,
-                                           p->first, p->second,
+                                           nm_val.first, nm_val.second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
   static std::list<symbol_record>
   regexp_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     octave::regexp pat (pattern);
 
-    for (global_table_const_iterator p = global_table.begin ();
-         p != global_table.end (); p++)
+    for (const auto& nm_val : global_table)
       {
-        // We generate a list of symbol_record objects so that
-        // the results from regexp_variables and regexp_global_variables
-        // may be handled the same way.
-
-        if (pat.is_match (p->first))
+        // We generate a list of symbol_record objects so that the results from
+        // regexp_variables and regexp_global_variables may be handled the same
+        // way.
+        if (pat.is_match (nm_val.first))
           retval.push_back (symbol_record (xglobal_scope,
-                                           p->first, p->second,
+                                           nm_val.first, nm_val.second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
   static std::list<symbol_record> glob_variables (const string_vector& patterns)
   {
@@ -1978,36 +1970,34 @@ public:
 
     return retval;
   }
 
   static std::list<std::string> user_function_names (void)
   {
     std::list<std::string> retval;
 
-    for (fcn_table_iterator p = fcn_table.begin ();
-         p != fcn_table.end (); p++)
+    for (const auto& nm_finfo : fcn_table)
       {
-        if (p->second.is_user_function_defined ())
-          retval.push_back (p->first);
+        if (nm_finfo.second.is_user_function_defined ())
+          retval.push_back (nm_finfo.first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
   static std::list<std::string> global_variable_names (void)
   {
     std::list<std::string> retval;
 
-    for (global_table_const_iterator p = global_table.begin ();
-         p != global_table.end (); p++)
-      retval.push_back (p->first);
+    for (const auto& nm_val : global_table)
+      retval.push_back (nm_val.first);
 
     retval.sort ();
 
     return retval;
   }
 
   static std::list<std::string> top_level_variable_names (void)
   {
@@ -2022,42 +2012,40 @@ public:
 
     return inst ? inst->do_variable_names () : std::list<std::string> ();
   }
 
   static std::list<std::string> built_in_function_names (void)
   {
     std::list<std::string> retval;
 
-    for (fcn_table_const_iterator p = fcn_table.begin ();
-         p != fcn_table.end (); p++)
+    for (const auto& nm_finfo : fcn_table)
       {
-        octave_value fcn = p->second.find_built_in_function ();
+        octave_value fcn = nm_finfo.second.find_built_in_function ();
 
         if (fcn.is_defined ())
-          retval.push_back (p->first);
+          retval.push_back (nm_finfo.first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
   static std::list<std::string> cmdline_function_names (void)
   {
     std::list<std::string> retval;
 
-    for (fcn_table_const_iterator p = fcn_table.begin ();
-         p != fcn_table.end (); p++)
+    for (const auto& nm_finfo : fcn_table)
       {
-        octave_value fcn = p->second.find_cmdline_function ();
+        octave_value fcn = nm_finfo.second.find_cmdline_function ();
 
         if (fcn.is_defined ())
-          retval.push_back (p->first);
+          retval.push_back (nm_finfo.first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
@@ -2106,38 +2094,35 @@ public:
     symbol_table *inst = get_instance (scope, false);
 
     if (inst)
       inst->do_cache_name (name);
   }
 
   static void lock_subfunctions (scope_id scope = xcurrent_scope)
   {
-    for (fcn_table_iterator p = fcn_table.begin ();
-         p != fcn_table.end (); p++)
-      p->second.lock_subfunction (scope);
+    for (auto& nm_finfo : fcn_table)
+      nm_finfo.second.lock_subfunction (scope);
   }
 
   static void unlock_subfunctions (scope_id scope = xcurrent_scope)
   {
-    for (fcn_table_iterator p = fcn_table.begin ();
-         p != fcn_table.end (); p++)
-      p->second.unlock_subfunction (scope);
+    for (auto& nm_finfo : fcn_table)
+      nm_finfo.second.unlock_subfunction (scope);
   }
 
   static std::map<std::string, octave_value>
   subfunctions_defined_in_scope (scope_id scope = xcurrent_scope)
   {
     std::map<std::string, octave_value> retval;
 
-    for (fcn_table_const_iterator p = fcn_table.begin ();
-         p != fcn_table.end (); p++)
+    for (const auto& nm_finfo : fcn_table)
       {
         std::pair<std::string, octave_value> tmp
-          = p->second.subfunction_defined_in_scope (scope);
+          = nm_finfo.second.subfunction_defined_in_scope (scope);
 
         std::string nm = tmp.first;
 
         if (! nm.empty ())
           retval[nm] = tmp.second;
       }
 
     return retval;
@@ -2165,24 +2150,23 @@ public:
   {
     std::list<std::string> retval;
 
     const_parent_map_iterator it = parent_map.find (dispatch_type);
 
     if (it != parent_map.end ())
       retval = it->second;
 
-    for (std::list<std::string>::const_iterator lit = retval.begin ();
-         lit != retval.end (); lit++)
+    for (const auto& nm : retval)
       {
         // Search for parents of parents and append them to the list.
 
         // FIXME: should we worry about a circular inheritance graph?
 
-        std::list<std::string> parents = parent_classes (*lit);
+        std::list<std::string> parents = parent_classes (nm);
 
         if (! parents.empty ())
           retval.insert (retval.end (), parents.begin (), parents.end ());
       }
 
     return retval;
   }
 
@@ -2379,36 +2363,36 @@ private:
   void insert_symbol_record (const symbol_record& sr)
   {
     table[sr.name ()] = sr;
   }
 
   void
   do_dup_scope (symbol_table& new_symbol_table) const
   {
-    for (table_const_iterator p = table.begin (); p != table.end (); p++)
-      new_symbol_table.insert_symbol_record (p->second.dup (new_symbol_table
-                                                            .my_scope));
+    for (const auto& nm_sr : table)
+      new_symbol_table.insert_symbol_record (nm_sr.second.dup (new_symbol_table
+                                                               .my_scope));
   }
 
   symbol_record do_find_symbol (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       return do_insert (name);
     else
       return p->second;
   }
 
   void do_inherit (symbol_table& donor_table, context_id donor_context)
   {
-    for (table_iterator p = table.begin (); p != table.end (); p++)
+    for (auto& nm_sr : table)
       {
-        symbol_record& sr = p->second;
+        symbol_record& sr = nm_sr.second;
 
         if (! (sr.is_automatic () || sr.is_formal ()))
           {
             std::string nm = sr.name ();
 
             if (nm != "__retval__")
               {
                 octave_value val = donor_table.do_varval (nm, donor_context);
@@ -2561,47 +2545,47 @@ private:
         retval = sr.is_variable ();
       }
 
     return retval;
   }
 
   void do_push_context (void)
   {
-    for (table_iterator p = table.begin (); p != table.end (); p++)
-      p->second.push_context (my_scope);
+    for (auto& nm_sr : table)
+      nm_sr.second.push_context (my_scope);
   }
 
   void do_pop_context (void)
   {
-    table_iterator p = table.begin ();
-
-    while (p != table.end ())
+    table_iterator tbl_it = table.begin ();
+
+    while (tbl_it != table.end ())
       {
-        if (p->second.pop_context (my_scope) == 0)
-          table.erase (p++);
+        if (tbl_it->second.pop_context (my_scope) == 0)
+          table.erase (tbl_it++);
         else
-          p++;
+          tbl_it++;
       }
   }
 
   void do_clear_variables (void)
   {
-    for (table_iterator p = table.begin (); p != table.end (); p++)
-      p->second.clear (my_scope);
+    for (auto& nm_sr : table)
+      nm_sr.second.clear (my_scope);
   }
 
   void do_clear_objects (void)
   {
-    for (table_iterator p = table.begin (); p != table.end (); p++)
+    for (auto& nm_sr : table)
       {
-        symbol_record& sr = p->second;
+        symbol_record& sr = nm_sr.second;
         octave_value val = sr.varval ();
         if (val.is_object ())
-          p->second.clear (my_scope);
+          nm_sr.second.clear (my_scope);
       }
   }
 
   void do_clear_global (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     if (p != table.end ())
@@ -2626,19 +2610,19 @@ private:
     if (p != table.end ())
       p->second.clear (my_scope);
   }
 
   void do_clear_global_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
-    for (table_iterator p = table.begin (); p != table.end (); p++)
+    for (auto& nm_sr : table)
       {
-        symbol_record& sr = p->second;
+        symbol_record& sr = nm_sr.second;
 
         if (sr.is_global () && pattern.match (sr.name ()))
           sr.unmark_global ();
       }
 
     global_table_iterator q = global_table.begin ();
 
     while (q != global_table.end ())
@@ -2649,35 +2633,35 @@ private:
           q++;
       }
   }
 
   void do_clear_variable_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
-    for (table_iterator p = table.begin (); p != table.end (); p++)
+    for (auto& nm_sr : table)
       {
-        symbol_record& sr = p->second;
+        symbol_record& sr = nm_sr.second;
 
         if (sr.is_defined () || sr.is_global ())
           {
             if (pattern.match (sr.name ()))
               sr.clear (my_scope);
           }
       }
   }
 
   void do_clear_variable_regexp (const std::string& pat)
   {
     octave::regexp pattern (pat);
 
-    for (table_iterator p = table.begin (); p != table.end (); p++)
+    for (auto& nm_sr : table)
       {
-        symbol_record& sr = p->second;
+        symbol_record& sr = nm_sr.second;
 
         if (sr.is_defined () || sr.is_global ())
           {
             if (pattern.is_match (sr.name ()))
               sr.clear (my_scope);
           }
       }
   }
@@ -2698,19 +2682,19 @@ private:
   }
 
   std::list<symbol_record>
   do_all_variables (context_id context, bool defined_only,
                     unsigned int exclude) const
   {
     std::list<symbol_record> retval;
 
-    for (table_const_iterator p = table.begin (); p != table.end (); p++)
+    for (const auto& nm_sr : table)
       {
-        const symbol_record& sr = p->second;
+        const symbol_record& sr = nm_sr.second;
 
         if ((defined_only && ! sr.is_defined (context))
             || (sr.xstorage_class () & exclude))
           continue;
 
         retval.push_back (sr);
       }
 
@@ -2719,21 +2703,21 @@ private:
 
   std::list<symbol_record> do_glob (const std::string& pattern,
                                     bool vars_only = false) const
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
-    for (table_const_iterator p = table.begin (); p != table.end (); p++)
+    for (const auto& nm_sr : table)
       {
-        if (pat.match (p->first))
+        if (pat.match (nm_sr.first))
           {
-            const symbol_record& sr = p->second;
+            const symbol_record& sr = nm_sr.second;
 
             if (vars_only && ! sr.is_variable ())
               continue;
 
             retval.push_back (sr);
           }
       }
 
@@ -2742,40 +2726,40 @@ private:
 
   std::list<symbol_record> do_regexp (const std::string& pattern,
                                       bool vars_only = false) const
   {
     std::list<symbol_record> retval;
 
     octave::regexp pat (pattern);
 
-    for (table_const_iterator p = table.begin (); p != table.end (); p++)
+    for (const auto& nm_sr : table)
       {
-        if (pat.is_match (p->first))
+        if (pat.is_match (nm_sr.first))
           {
-            const symbol_record& sr = p->second;
+            const symbol_record& sr = nm_sr.second;
 
             if (vars_only && ! sr.is_variable ())
               continue;
 
             retval.push_back (sr);
           }
       }
 
     return retval;
   }
 
   std::list<std::string> do_variable_names (void)
   {
     std::list<std::string> retval;
 
-    for (table_const_iterator p = table.begin (); p != table.end (); p++)
+    for (const auto& nm_sr : table)
       {
-        if (p->second.is_variable ())
-          retval.push_back (p->first);
+        if (nm_sr.second.is_variable ())
+          retval.push_back (nm_sr.first);
       }
 
     retval.sort ();
 
     return retval;
   }
 
   bool do_is_local_variable (const std::string& name) const
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -316,20 +316,19 @@ text_processor
 {
 public:
   virtual void visit (text_element_string& e) = 0;
 
   virtual void visit (text_element_symbol&) { }
 
   virtual void visit (text_element_list& e)
   {
-    for (text_element_list::iterator it = e.begin ();
-         it != e.end (); ++it)
+    for (auto& el_p : e)
       {
-        (*it)->accept (*this);
+        el_p->accept (*this);
       }
   }
 
   virtual void visit (text_element_subscript& e)
   { e.get_element ()->accept (*this); }
 
   virtual void visit (text_element_superscript& e)
   { e.get_element ()->accept (*this); }
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -193,19 +193,19 @@ private:
     return h;
   }
 
   Matrix do_handle_list (void)
   {
     Matrix retval (1, handle_map.size ());
 
     octave_idx_type i = 0;
-    for (const_iterator p = handle_map.begin (); p != handle_map.end (); p++)
+    for (const auto& h_obj : handle_map)
       {
-        curl_handle h = p->first;
+        curl_handle h = h_obj.first;
 
         retval(i++) = h.value ();
       }
 
     return retval;
   }
 };
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1385,22 +1385,21 @@ public:
         size_t elements = 0;
 
         std::list<whos_parameter> params = parse_whos_line_format ();
 
         print_descriptor (os, params);
 
         octave_stdout << "\n";
 
-        for (std::list<symbol_info>::const_iterator p = lst.begin ();
-             p != lst.end (); p++)
+        for (const auto& syminfo : lst)
           {
-            p->display_line (os, params);
-
-            octave_value val = p->varval;
+            syminfo.display_line (os, params);
+
+            octave_value val = syminfo.varval;
 
             elements += val.numel ();
             bytes += val.byte_size ();
           }
 
         os << "\nTotal is " << elements
            << (elements == 1 ? " element" : " elements")
            << " using " << bytes << (bytes == 1 ? " byte" : " bytes")
@@ -1446,28 +1445,27 @@ public:
       param_length(i) = param_names(i).length ();
 
     // The attribute column needs size 5.
     param_length(pos_a) = 5;
 
     // Calculating necessary spacing for name column,
     // bytes column, elements column and class column
 
-    for (std::list<symbol_info>::const_iterator p = lst.begin ();
-         p != lst.end (); p++)
+    for (const auto& syminfo : lst)
       {
         std::stringstream ss1, ss2;
         std::string str;
 
-        str = p->name;
+        str = syminfo.name;
         param_length(pos_n) = ((str.length ()
                                 > static_cast<size_t> (param_length(pos_n)))
                                ? str.length () : param_length(pos_n));
 
-        octave_value val = p->varval;
+        octave_value val = syminfo.varval;
 
         str = val.type_name ();
         param_length(pos_t) = ((str.length ()
                                 > static_cast<size_t> (param_length(pos_t)))
                                ? str.length () : param_length(pos_t));
 
         elements1 = val.numel ();
         ss1 << elements1;
@@ -1548,20 +1546,19 @@ public:
                 // hard to determine in prior, because it depends on
                 // dimensions to be shown.  That is why it is
                 // recalculated for each Size-command int first,
                 // rest = 0, total;
                 int rest = 0;
                 int first = param.first_parameter_length;
                 int total = param.parameter_length;
 
-                for (std::list<symbol_info>::const_iterator p = lst.begin ();
-                     p != lst.end (); p++)
+                for (const auto& syminfo : lst)
                   {
-                    octave_value val = p->varval;
+                    octave_value val = syminfo.varval;
                     std::string dims_str = get_dims_str (val);
                     int first1 = dims_str.find ('x');
                     int total1 = dims_str.length ();
                     int rest1 = total1 - first1;
                     rest = (rest1 > rest ? rest1 : rest);
                     first = (first1 > first ? first1 : first);
                     total = (total1 > total ? total1 : total);
                   }
@@ -1712,25 +1709,24 @@ do_who (int argc, const string_vector& a
       std::string pat = pats[j];
 
       if (have_regexp)
         {
           std::list<symbol_table::symbol_record> tmp = global_only
             ? symbol_table::regexp_global_variables (pat)
             : symbol_table::regexp_variables (pat);
 
-          for (std::list<symbol_table::symbol_record>::const_iterator
-               p = tmp.begin (); p != tmp.end (); p++)
+          for (const auto& symrec : tmp)
             {
-              if (p->is_variable ())
+              if (symrec.is_variable ())
                 {
                   if (verbose)
-                    symbol_stats.append (*p);
+                    symbol_stats.append (symrec);
                   else
-                    symbol_names.push_back (p->name ());
+                    symbol_names.push_back (symrec.name ());
                 }
             }
         }
       else
         {
           size_t pos = pat.find_first_of (".({");
 
           if (pos != std::string::npos && pos > 0)
@@ -1764,25 +1760,24 @@ do_who (int argc, const string_vector& a
                 }
             }
           else
             {
               std::list<symbol_table::symbol_record> tmp = global_only
                 ? symbol_table::glob_global_variables (pat)
                 : symbol_table::glob_variables (pat);
 
-              for (std::list<symbol_table::symbol_record>::const_iterator
-                   p = tmp.begin (); p != tmp.end (); p++)
+              for (const auto& symrec : tmp)
                 {
-                  if (p->is_variable ())
+                  if (symrec.is_variable ())
                     {
                       if (verbose)
-                        symbol_stats.append (*p);
+                        symbol_stats.append (symrec);
                       else
-                        symbol_names.push_back (p->name ());
+                        symbol_names.push_back (symrec.name ());
                     }
                 }
             }
         }
     }
 
   if (return_list)
     {
