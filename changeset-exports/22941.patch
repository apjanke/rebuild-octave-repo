# HG changeset patch
# User Rik <rik@octave.org>
# Date 1482794444 28800
#      Mon Dec 26 15:20:44 2016 -0800
# Node ID d92ec2901770f4024e08d6afd177bc092348110f
# Parent  2d7eb612d043d153d6b1b20413b51a0f9b9607b3
Make ode15i,ode15s doc consistent with other ode functions.

* ode15i.m, ode15s.m: Make doc consistent with other ode functions.
Add missing closing ']' to error() function calls.

diff --git a/scripts/ode/ode15i.m b/scripts/ode/ode15i.m
--- a/scripts/ode/ode15i.m
+++ b/scripts/ode/ode15i.m
@@ -16,81 +16,79 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {[@var{t}, @var{y}] =} ode15i (@var{fun}, @var{trange}, @var{y0}, @var{yp0})
 ## @deftypefnx {} {[@var{t}, @var{y}] =} ode15i (@var{fun}, @var{trange}, @var{y0}, @var{yp0}, @var{ode_opt})
 ## @deftypefnx {} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode15i (@dots{})
 ## @deftypefnx {} {@var{solution} =} ode15i (@dots{})
+## @deftypefnx {} {} ode15i (@dots{})
 ##
 ## Solve a set of full-implicit Ordinary Differential Equations and
 ## Differential Algebraic Equations (DAEs) of index 1, with the variable-step,
 ## variable order BDF (Backward Differentiation Formula) method, which
 ## ranges from order 1 to 5.
 ##
 ## @var{fun} is a function handle, inline function, or string containing the
-## name of the function that defines the ODE:
-## @code{f(@var{t},@var{y},@var{yp})}.
-## The function must accept three inputs where the first is time @var{t}, the
-## second is a column vector of unknowns @var{y} and the third is a column
+## name of the function that defines the ODE: @code{y' = f(t,y,yp)}.  The
+## function must accept three inputs where the first is time @var{t}, the
+## second is a column vector of unknowns @var{y}, and the third is a column
 ## vector of unknowns @var{yp}.
 ##
 ## @var{trange} specifies the time interval over which the ODE will be
 ## evaluated.  Typically, it is a two-element vector specifying the initial and
 ## final times (@code{[tinit, tfinal]}).  If there are more than two elements
-## then the solution will also be evaluated at these intermediate time.
+## then the solution will also be evaluated at these intermediate time
+## instances.
 ##
 ## @var{y0} and @var{yp0} contain the initial values for the unknowns @var{y}
 ## and @var{yp}.  If they are row vectors then the solution @var{y} will be a
 ## matrix in which each column is the solution for the corresponding initial
 ## value in @var{y0} and @var{yp0}.
 ##
 ## @var{y0} and @var{yp0} must be consistent initial conditions, meaning that
-## @code{f(@var{t},@var{y0},@var{yp0})=0} is satisfied. You can use function
-## decic to compute consistent initial conditions, given initial guesses.
+## @code{f(t,y0,yp0) = 0} is satisfied.  You can use function @code{decic} to
+## compute consistent initial conditions, given initial guesses.
 ##
 ## The optional fifth argument @var{ode_opt} specifies non-default options to
 ## the ODE solver.  It is a structure generated by @code{odeset}.
 ##
 ## The function typically returns two outputs.  Variable @var{t} is a
 ## column vector and contains the times where the solution was found.  The
 ## output @var{y} is a matrix in which each column refers to a different
 ## unknown of the problem and each row corresponds to a time in @var{t}.
 ##
 ## The output can also be returned as a structure @var{solution} which
-## has field @var{x} containing the time where the solution was evaluated and
-## field @var{y} containing the solution matrix for the times in @var{x}.
+## has a field @var{x} containing a row vector of times where the solution
+## was evaluated and a field @var{y} containing the solution matrix such
+## that each column corresponds to a time in @var{x}.
 ## Use @code{fieldnames (@var{solution})} to see the other fields and
 ## additional information returned.
 ##
+## If no output arguments are requested, and no @code{OutputFcn} is
+## specified in @var{ode_opt}, then the @code{OutputFcn} is set to
+## @code{odeplot} and the results of the solver are plotted immediately.
+##
 ## If using the @qcode{"Events"} option then three additional outputs may
 ## be returned.  @var{te} holds the time when an Event function returned a
 ## zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
 ## contains an index indicating which Event function was triggered in the case
 ## of multiple Event functions.
 ##
-## This function can be called with two output arguments: @var{t} and @var{y}.
-## Variable @var{t} is a column vector and contains the time stamps, instead
-## @var{y} is a matrix in which each column refers to a different unknown of
-## the problem and the rows number is the same of @var{t} rows number so
-## that each row of @var{y} contains the values of all unknowns at the time
-## value contained in the corresponding row in @var{t}.
-##
-## Example: Solve the @nospell{Robetson}'s equations:
+## Example: Solve the @nospell{Robetson's} equations:
 ##
 ## @example
 ## @group
-## function res = robertsidae(@var{t}, @var{y}, @var{yp})
-## res = [-(@var{yp}(1) + 0.04*@var{y}(1) - 1e4*@var{y}(2)*@var{y}(3));
-##        -(@var{yp}(2) - 0.04*@var{y}(1) + 1e4*@var{y}(2)*@var{y}(3) +
-##        3e7*@var{y}(2)^2);
+## function r = robertsidae (@var{t}, @var{y}, @var{yp})
+##   r = [-(@var{yp}(1) + 0.04*@var{y}(1) - 1e4*@var{y}(2)*@var{y}(3));
+##        -(@var{yp}(2) - 0.04*@var{y}(1) + 1e4*@var{y}(2)*@var{y}(3) + 3e7*@var{y}(2)^2);
 ##        @var{y}(1) + @var{y}(2) + @var{y}(3) - 1];
 ## endfunction
-## [@var{t},@var{y}] = ode15i (@@robertsidae, [0 1e3], [1; 0; 0], [-1e-4; 1e-4; 0]);
+## [@var{t},@var{y}] = ode15i (@@robertsidae, [0, 1e3], [1; 0; 0], [-1e-4; 1e-4; 0]);
 ## @end group
 ## @end example
 ## @seealso{decic, odeset, odeget}
 ## @end deftypefn
 
 function varargout = ode15i (fun, trange, y0, yp0, varargin)
 
   solver = "ode15i";
@@ -128,32 +126,32 @@ function varargout = ode15i (fun, trange
     if (ischar (options.OutputFcn))
       try
         options.OutputFcn = str2func (options.OutputFcn);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.OutputFcn, "function_handle"))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'OutputFcn'");
+               [solver ": invalid value assigned to field 'OutputFcn'"]);
       endif
     endif
   endif
 
   if (! isempty (options.Events))
     if (ischar (options.Events))
       try
         options.Events = str2func (options.Events);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.Events, "function_handle")
           && ! ismatrix (options.Events))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Events'");
+               [solver ": invalid value assigned to field 'Events'"]);
       endif
     endif
   endif
 
   [defaults, classes, attributes] = odedefaults (n, trange(1), trange(end));
 
   persistent ignorefields = {"NonNegative", "Mass", ...
                              "MStateDependence", "MvPattern", ...
@@ -184,53 +182,53 @@ function varargout = ode15i (fun, trange
 
         if (any (size (options.Jacobian{1}) != [n n])
             || any (size (options.Jacobian{2}) != [n n])
             || ! isnumeric (options.Jacobian{1})
             || ! isnumeric (options.Jacobian{2})
             || ! isreal (options.Jacobian{1})
             || ! isreal (options.Jacobian{2}))
           error ("Octave:invalid-input-arg",
-                 [solver ": invalid value assigned to field 'Jacobian'");
+                 [solver ": invalid value assigned to field 'Jacobian'"]);
         endif
       else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Jacobian'");
+               [solver ": invalid value assigned to field 'Jacobian'"]);
       endif
 
     elseif (isa (options.Jacobian, "function_handle"))
       options.havejacfun = true;
       if (nargin (options.Jacobian) == 3)
         [A, B] = options.Jacobian (trange(1), y0, yp0);
         if (issparse (A) && issparse (B))
           options.havejacsparse = true;  # Jac is sparse fun
         endif
 
         if (any (size (A) != [n n]) || any (size (B) != [n n])
             || ! isnumeric (A) || ! isnumeric (B) || ! isreal (A)
             || ! isreal (B))
           error ("Octave:invalid-input-arg",
-                 [solver ": invalid value assigned to field 'Jacobian'");
+                 [solver ": invalid value assigned to field 'Jacobian'"]);
         endif
       else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Jacobian'");
+               [solver ": invalid value assigned to field 'Jacobian'"]);
       endif
     else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Jacobian'");
+               [solver ": invalid value assigned to field 'Jacobian'"]);
     endif
   endif
 
   ## Abstol and Reltol
   options.haveabstolvec = false;
 
   if (numel (options.AbsTol) != 1 && numel (options.AbsTol) != n)
     error ("Octave:invalid-input-arg",
-           [solver ": invalid value assigned to field 'AbsTol'");
+           [solver ": invalid value assigned to field 'AbsTol'"]);
 
   elseif (numel (options.AbsTol) == n)
     options.haveabstolvec = true;
   endif
 
   ## Stats
   options.havestats = strcmpi (options.Stats, "on");
 
diff --git a/scripts/ode/ode15s.m b/scripts/ode/ode15s.m
--- a/scripts/ode/ode15s.m
+++ b/scripts/ode/ode15s.m
@@ -16,73 +16,74 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {[@var{t}, @var{y}] =} ode15s (@var{fun}, @var{trange}, @var{y0})
 ## @deftypefnx {} {[@var{t}, @var{y}] =} ode15s (@var{fun}, @var{trange}, @var{y0}, @var{ode_opt})
 ## @deftypefnx {} {[@var{t}, @var{y}, @var{te}, @var{ye}, @var{ie}] =} ode15s (@dots{})
 ## @deftypefnx {} {@var{solution} =} ode15s (@dots{})
+## @deftypefnx {} {} ode15s (@dots{})
 ##
 ## Solve a set of stiff Ordinary Differential Equations and stiff semi-explicit
 ## Differential Algebraic Equations (DAEs) of index 1, with the variable-step,
-## variable order BDF (Backward Differentiation Formula) method, which
-## ranges from order 1 to 5.
+## variable order BDF (Backward Differentiation Formula) method, which ranges
+## from order 1 to 5.
 ##
 ## @var{fun} is a function handle, inline function, or string containing the
-## name of the function that defines the ODE: @code{f(@var{t},@var{y})}.
-## The function must accept two inputs where the first is time @var{t} and the
-## second is a column vector of unknowns @var{y}.
+## name of the function that defines the ODE: @code{y' = f(t,y)}.  The function
+## must accept two inputs where the first is time @var{t} and the second is a
+## column vector of unknowns @var{y}.
 ##
 ## @var{trange} specifies the time interval over which the ODE will be
 ## evaluated.  Typically, it is a two-element vector specifying the initial and
 ## final times (@code{[tinit, tfinal]}).  If there are more than two elements
-## then the solution will also be evaluated at these intermediate time.
+## then the solution will also be evaluated at these intermediate time
+## instances.
 ##
 ## @var{init} contains the initial value for the unknowns.  If it is a row
 ## vector then the solution @var{y} will be a matrix in which each column is
 ## the solution for the corresponding initial value in @var{init}.
 ##
 ## The optional fourth argument @var{ode_opt} specifies non-default options to
 ## the ODE solver.  It is a structure generated by @code{odeset}.
 ##
 ## The function typically returns two outputs.  Variable @var{t} is a
 ## column vector and contains the times where the solution was found.  The
 ## output @var{y} is a matrix in which each column refers to a different
 ## unknown of the problem and each row corresponds to a time in @var{t}.
 ##
 ## The output can also be returned as a structure @var{solution} which
-## has field @var{x} containing the time where the solution was evaluated and
-## field @var{y} containing the solution matrix for the times in @var{x}.
+## has a field @var{x} containing a row vector of times where the solution
+## was evaluated and a field @var{y} containing the solution matrix such
+## that each column corresponds to a time in @var{x}.
 ## Use @code{fieldnames (@var{solution})} to see the other fields and
 ## additional information returned.
 ##
+## If no output arguments are requested, and no @code{OutputFcn} is
+## specified in @var{ode_opt}, then the @code{OutputFcn} is set to
+## @code{odeplot} and the results of the solver are plotted immediately.
+##
 ## If using the @qcode{"Events"} option then three additional outputs may
 ## be returned.  @var{te} holds the time when an Event function returned a
 ## zero.  @var{ye} holds the value of the solution at time @var{te}.  @var{ie}
 ## contains an index indicating which Event function was triggered in the case
 ## of multiple Event functions.
 ##
-## This function can be called with two output arguments: @var{t} and @var{y}.
-## Variable @var{t} is a column vector and contains the time stamps, instead
-## @var{y} is a matrix in which each column refers to a different unknown of
-## the problem and the rows number is the same of @var{t} rows number so
-## that each row of @var{y} contains the values of all unknowns at the time
-## value contained in the corresponding row in @var{t}.
+## Example: Solve the @nospell{Robetson's} equations:
 ##
-## Example: Solve the @nospell{Robetson}'s equations:
 ## @example
 ## @group
-## function res = robertsidae(@var{t}, @var{y})
-## res = [-0.04*@var{y}(1) + 1e4*@var{y}(2)*@var{y}(3);
+## function r = robertsidae (@var{t}, @var{y})
+##   r = [-0.04*@var{y}(1) + 1e4*@var{y}(2)*@var{y}(3);
 ##         0.04*@var{y}(1) - 1e4*@var{y}(2)*@var{y}(3) - 3e7*@var{y}(2)^2;
 ##         @var{y}(1) + @var{y}(2) + @var{y}(3) - 1];
 ## endfunction
 ## opt = odeset ("Mass", [1 0 0; 0 1 0; 0 0 0], "MStateDependence", "none");
-## [@var{t},@var{y}] = ode15s (@@robertsidae, [0 1e3], [1; 0; 0], opt);
+## [@var{t},@var{y}] = ode15s (@@robertsidae, [0, 1e3], [1; 0; 0], opt);
 ## @end group
 ## @end example
 ## @seealso{decic, odeset, odeget}
 ## @end deftypefn
 
 function varargout = ode15s (fun, trange, y0, varargin)
 
   solver = "ode15s";
@@ -176,40 +177,40 @@ function varargout = ode15s (fun, trange
     if (isa (options.Mass, "function_handle"))
       options.havemassfun = true;
       if (nargin (options.Mass) == 2)
         options.havestatedep = true;
         M = options.Mass (trange(1), y0);
         options.havemasssparse = issparse (M);
         if (any (size (M) != [n n]) || ! isnumeric (M) || ! isreal (M))
           error ("Octave:invalid-input-arg",
-                 [solver ": invalid value assigned to field 'Mass'");
+                 [solver ": invalid value assigned to field 'Mass'"]);
         endif
       elseif (nargin (options.Mass) == 1)
         options.havetimedep = true;
         M = options.Mass (trange(1));
         options.havemasssparse = issparse (M);
         if (any (size (M) != [n n]) || ! isnumeric (M) || ! isreal (M))
           error ("Octave:invalid-input-arg",
-                 [solver ": invalid value assigned to field 'Mass'");
+                 [solver ": invalid value assigned to field 'Mass'"]);
         endif
       else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Mass'");
+               [solver ": invalid value assigned to field 'Mass'"]);
       endif
     elseif (ismatrix (options.Mass))
       options.havemasssparse = issparse (options.Mass);
       if (any (size (options.Mass) != [n n]) ||
           ! isnumeric (options.Mass) || ! isreal (options.Mass))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Mass'");
+               [solver ": invalid value assigned to field 'Mass'"]);
       endif
     else
       error ("Octave:invalid-input-arg",
-             [solver ": invalid value assigned to field 'Mass'");
+             [solver ": invalid value assigned to field 'Mass'"]);
     endif
   endif
 
   ## Jacobian
   options.havejac       = false;
   options.havejacsparse = false;
   options.havejacfun    = false;
 
@@ -219,33 +220,33 @@ function varargout = ode15s (fun, trange
       options.havejacfun = true;
       if (nargin (options.Jacobian) == 2)
         [A] = options.Jacobian (trange(1), y0);
         if (issparse (A))
           options.havejacsparse = true;  # Jac is sparse fun
         endif
         if (any (size (A) != [n n]) || ! isnumeric (A) || ! isreal (A))
           error ("Octave:invalid-input-arg",
-                 [solver ": invalid value assigned to field 'Jacobian'");
+                 [solver ": invalid value assigned to field 'Jacobian'"]);
         endif
       else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Jacobian'");
+               [solver ": invalid value assigned to field 'Jacobian'"]);
       endif
     elseif (ismatrix (options.Jacobian))
       if (issparse (options.Jacobian))
         options.havejacsparse = true;    # Jac is sparse matrix
       endif
       if (! issquare (options.Jacobian))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field 'Jacobian'");
+               [solver ": invalid value assigned to field 'Jacobian'"]);
       endif
     else
       error ("Octave:invalid-input-arg",
-             [solver ": invalid value assigned to field 'Jacobian'");
+             [solver ": invalid value assigned to field 'Jacobian'"]);
     endif
   endif
 
   ## Derivative of M(t,y) for implicit problem not implemented yet
   if (! isempty (options.Mass) && ! isempty (options.Jacobian))
     if (options.MStateDependence != "none" || options.havestatedep == true)
       options.havejac = false;
       options.Jacobian = [];
@@ -277,17 +278,17 @@ function varargout = ode15s (fun, trange
     endif
   endif
 
   ## Abstol and Reltol
   options.haveabstolvec = false;
 
   if (numel (options.AbsTol) != 1 && numel (options.AbsTol) != n)
     error ("Octave:invalid-input-arg",
-           [solver ": invalid value assigned to field 'AbsTol'");
+           [solver ": invalid value assigned to field 'AbsTol'"]);
   elseif (numel (options.AbsTol) == n)
     options.haveabstolvec = true;
   endif
 
   ## Stats
   options.havestats = strcmpi (options.Stats, "on");
 
   ## Don't use Refine when the output is a structure
