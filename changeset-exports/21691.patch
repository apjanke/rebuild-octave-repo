# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463146574 14400
#      Fri May 13 09:36:14 2016 -0400
# Node ID 263d18409fdfae0832057ecf9c5ca922db3d16b7
# Parent  b6a686543080163dcc5b62c7b897aa05049b044e
Eliminate unused variable warnings for conditionally compiled code.

We had more or less decided not to bother trying to eliminate all
these warnings for cases in which external dependencies are missing.
But then we get people trying to fix these in various ways, so we
might as well do it for all cases and use a consistent method.

* oct-conf-post.in.h (octave_unused_parameter): New function for C++
code and new macro for C code.
* mk-octave-config-h.sh: Emit octave_unused_parameter function and
macro for octave-config.h.

* CSparse.cc, __delaunayn__.cc, __eigs__.cc, __fltk_uigetfile__.cc,
__glpk__.cc, __magick_read__.cc, __osmesa_print__.cc, __voronoi__.cc,
amd.cc, audiodevinfo.cc, audioread.cc, ccolamd.cc, cdisplay.c,
colamd.cc, convhulln.cc, dSparse.cc, dmperm.cc, fftw.cc, gl-render.cc,
lo-error.c, load-save.cc, ls-hdf5.cc, ls-mat5.cc, oct-hdf5-types.cc,
ov-base-int.cc, ov-bool-mat.cc, ov-bool-sparse.cc, ov-bool.cc,
ov-cell.cc, ov-class.cc, ov-complex.cc, ov-cx-mat.cc, ov-cx-sparse.cc,
ov-fcn-handle.cc, ov-fcn-inline.cc, ov-float.cc, ov-flt-complex.cc,
ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-java.cc, ov-range.cc,
ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc, ov-str-mat.cc,
ov-struct.cc, sparse-chol.cc, sparse-dmsolve.cc, sparse-lu.cc,
sparse-qr.cc, sparse-util.cc, symbfact.cc:  Use octave_unused_parameter
to eliminate warnings for conditionally compiled code.

diff --git a/build-aux/mk-octave-config-h.sh b/build-aux/mk-octave-config-h.sh
--- a/build-aux/mk-octave-config-h.sh
+++ b/build-aux/mk-octave-config-h.sh
@@ -111,16 +111,25 @@ since all of Octave's header files alrea
 #  define OCTAVE_NORETURN
 #  define OCTAVE_UNUSED
 
 /* #  undef HAVE_OCTAVE_DEPRECATED_ATTR */
 /* #  undef HAVE_OCTAVE_NORETURN_ATTR */
 /* #  undef HAVE_OCTAVE_UNUSED_ATTR */
 #endif
 
+#if defined (__cplusplus)
+template <typename T>
+static inline void
+octave_unused_parameter (const T&)
+{ }
+#else
+#  define octave_unused_parameter(param) (void) param;
+#endif
+
 #if defined (_MSC_VER)
 #  define OCTAVE_EXPORT __declspec(dllexport)
 #  define OCTAVE_IMPORT __declspec(dllimport)
 #else
    /* All other compilers, at least for now. */
 #  define OCTAVE_EXPORT
 #  define OCTAVE_IMPORT
 #endif
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -735,30 +735,32 @@ maybe_initialize_magick (void)
       if (QuantumDepth < 16)
         warning_with_id ("Octave:GraphicsMagic-Quantum-Depth",
                          "your version of %s limits images to %d bits per pixel\n",
                          MagickPackageName, QuantumDepth);
 
       initialized = true;
     }
 }
+
 #endif
 
 DEFUN (__magick_read__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{img}, @var{map}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{options})\n\
 Read image with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imread} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
 #ifdef HAVE_MAGICK
+
   if (args.length () != 2 || ! args(0).is_string ())
     print_usage ();
 
   maybe_initialize_magick ();
 
   const octave_scalar_map options = args(1).xscalar_map_value ("__magick_read__: OPTIONS must be a struct");
 
   octave_value_list output;
@@ -844,17 +846,22 @@ Use @code{imread} instead.\n\
       else
         error ("imread: reading of images with %i-bit depth is not supported",
                depth);
     }
 
   return output;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("imread", "Image IO");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
@@ -1386,16 +1393,17 @@ Write image with GraphicsMagick or Image
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imwrite} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
 #ifdef HAVE_MAGICK
+
   if (args.length () != 5 || ! args(0).is_string () || ! args(1).is_string ())
     print_usage ();
 
   maybe_initialize_magick ();
 
   const std::string filename = args(0).string_value ();
   const std::string ext = args(1).string_value ();
 
@@ -1535,17 +1543,21 @@ Use @code{imwrite} instead.\n\
 
 #undef COMPRESS_MAGICK_IMAGE_VECTOR
 
   write_file (filename, ext, imvec);
 
   return ovl ();
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("imwrite", "Image IO");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
@@ -1559,16 +1571,17 @@ DEFUN (__magick_ping__, args, ,
 Ping image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 \n\
 @seealso{imfinfo}\n\
 @end deftypefn")
 {
 #ifdef HAVE_MAGICK
+
   if (args.length () < 1 || ! args(0).is_string ())
     print_usage ();
 
   maybe_initialize_magick ();
 
   const std::string filename = args(0).string_value ();
 
   int idx;
@@ -1597,21 +1610,26 @@ This is a private internal function not 
   octave_scalar_map ping = octave_scalar_map (string_vector (fields));
   ping.setfield ("rows",    octave_value (img.rows ()));
   ping.setfield ("columns", octave_value (img.columns ()));
   ping.setfield ("format",  octave_value (img.magick ()));
 
   return ovl (ping);
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("imfinfo", "Image IO");
+
 #endif
 }
 
 #ifdef HAVE_MAGICK
+
 static octave_value
 magick_to_octave_value (const Magick::CompressionType& magick)
 {
   switch (magick)
     {
     case Magick::NoCompression:
       return octave_value ("none");
     case Magick::BZipCompression:
@@ -1779,16 +1797,17 @@ Read image information with GraphicsMagi
 \n\
 This is a private internal function not intended for direct use.\n\
 Use @code{imfinfo} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
 #ifdef HAVE_MAGICK
+
   if (args.length () < 1 || ! args(0).is_string ())
     print_usage ();
 
   maybe_initialize_magick ();
 
   const std::string filename = args(0).string_value ();
 
   std::vector<Magick::Image> imvec;
@@ -2204,17 +2223,21 @@ Use @code{imfinfo} instead.\n\
     }
   else
     info.setfield ("DisposalMethod",
                    Cell (dim_vector (nFrames, 1), octave_value ("")));
 
   return ovl (info);
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("imfinfo", "Image IO");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
@@ -2227,16 +2250,17 @@ Fill formats info with GraphicsMagick Co
 @end deftypefn")
 {
   if (args.length () != 1 || ! args(0).is_map ())
     print_usage ();
 
   octave_map formats = args(0).map_value ();
 
 #ifdef HAVE_MAGICK
+
   maybe_initialize_magick ();
 
   for (octave_idx_type idx = 0; idx < formats.numel (); idx++)
     {
       try
         {
           octave_scalar_map fmt = formats.checkelem (idx);
           Magick::CoderInfo coder (fmt.getfield ("coder").string_value ());
@@ -2256,17 +2280,19 @@ Fill formats info with GraphicsMagick Co
           // Exception here are missing formats. So we remove the format
           // from the structure and reduce idx.
           formats.delete_elements (idx);
           idx--;
         }
     }
 
 #else
+
   formats = octave_map (dim_vector (1, 0), formats.fieldnames ());
+
 #endif
 
   return ovl (formats);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
diff --git a/libinterp/corefcn/cdisplay.c b/libinterp/corefcn/cdisplay.c
--- a/libinterp/corefcn/cdisplay.c
+++ b/libinterp/corefcn/cdisplay.c
@@ -16,17 +16,17 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+#  include "config.h"
 #endif
 
 #include <stdlib.h>
 
 #if defined (OCTAVE_USE_WINDOWS_API)
 #include <windows.h>
 #elif defined (HAVE_FRAMEWORK_CARBON)
 #include <Carbon/Carbon.h>
@@ -162,14 +162,20 @@ octave_get_display_info (int *ht, int *w
       else
         msg = "unable to open X11 DISPLAY";
     }
   else
     msg = "X11 DISPLAY environment variable not set";
 
 #else
 
+  octave_unused_parameter (ht);
+  octave_unused_parameter (wd);
+  octave_unused_parameter (dp);
+  octave_unused_parameter (rx);
+  octave_unused_parameter (ry);
+
   msg = "no graphical display found";
 
 #endif
 
   return msg;
 }
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -642,41 +642,45 @@ opengl_renderer::draw (const graphics_ob
   else
     {
       warning ("opengl_renderer: cannot render object of type '%s'",
                props.graphics_object_name ().c_str ());
     }
 }
 
 #if defined (HAVE_OPENGL)
+
 static std::string
 gl_get_string (GLenum id)
 {
   // This is kind of ugly, but glGetString returns a pointer to GLubyte
   // and there is no std::string constructor that matches.  Is there a
   // better way?
 
   std::ostringstream buf;
   buf << glGetString (id);
   return std::string (buf.str ());
 }
+
 #endif
 
 void
 opengl_renderer::draw_figure (const figure::properties& props)
 {
   // Initialize OpenGL context
 
   init_gl_context (props.is___enhanced__ (), props.get_color_rgb ());
 
 #if defined (HAVE_OPENGL)
+
   props.set___gl_extensions__ (gl_get_string (GL_EXTENSIONS));
   props.set___gl_renderer__ (gl_get_string (GL_RENDERER));
   props.set___gl_vendor__ (gl_get_string (GL_VENDOR));
   props.set___gl_version__ (gl_get_string (GL_VERSION));
+
 #endif
 
   // Draw children
 
   draw (props.get_all_children (), false);
 }
 
 void
@@ -735,20 +739,25 @@ opengl_renderer::init_gl_context (bool e
 
   if (c.numel () >= 3)
     {
       glClearColor (c(0), c(1), c(2), 1);
       glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     }
 
 #else
+
+  octave_unused_parameter (enhanced);
+  octave_unused_parameter (c);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::render_grid (const std::string& gridstyle,
                               const Matrix& ticks, double lim1, double lim2,
                               double p1, double p1N, double p2, double p2N,
                               int xyz, bool is_3D)
@@ -790,20 +799,33 @@ opengl_renderer::render_grid (const std:
               glVertex3d (p1, p2, val);
             }
         }
     }
   glEnd ();
   set_linestyle ("-", true);
 
 #else
+
+  octave_unused_parameter (gridstyle);
+  octave_unused_parameter (ticks);
+  octave_unused_parameter (lim1);
+  octave_unused_parameter (lim2);
+  octave_unused_parameter (p1);
+  octave_unused_parameter (p1N);
+  octave_unused_parameter (p2);
+  octave_unused_parameter (p2N);
+  octave_unused_parameter (xyz);
+  octave_unused_parameter (is_3D);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::render_tickmarks (const Matrix& ticks,
                                    double lim1, double lim2,
                                    double p1, double p1N,
                                    double p2, double p2N,
@@ -851,20 +873,35 @@ opengl_renderer::render_tickmarks (const
                 }
             }
         }
     }
 
   glEnd ();
 
 #else
+
+  octave_unused_parameter (ticks);
+  octave_unused_parameter (lim1);
+  octave_unused_parameter (lim2);
+  octave_unused_parameter (p1);
+  octave_unused_parameter (p1N);
+  octave_unused_parameter (p2);
+  octave_unused_parameter (p2N);
+  octave_unused_parameter (dx);
+  octave_unused_parameter (dy);
+  octave_unused_parameter (dz);
+  octave_unused_parameter (xyz);
+  octave_unused_parameter (mirror);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::render_ticktexts (const Matrix& ticks,
                                    const string_vector& ticklabels,
                                    double lim1, double lim2,
                                    double p1, double p2,
@@ -907,35 +944,51 @@ opengl_renderer::render_ticktexts (const
             }
 
           wmax = std::max (wmax, static_cast<int> (b(2)));
           hmax = std::max (hmax, static_cast<int> (b(3)));
         }
     }
 
 #else
+
+  octave_unused_parameter (ticks);
+  octave_unused_parameter (ticklabels);
+  octave_unused_parameter (lim1);
+  octave_unused_parameter (lim2);
+  octave_unused_parameter (p1);
+  octave_unused_parameter (p2);
+  octave_unused_parameter (xyz);
+  octave_unused_parameter (ha);
+  octave_unused_parameter (va);
+  octave_unused_parameter (wmax);
+  octave_unused_parameter (hmax);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::finish (void)
 {
 #if defined (HAVE_OPENGL)
 
   glFinish ();
 
 #else
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::setup_opengl_transformation (const axes::properties& props)
 {
 #if defined (HAVE_OPENGL)
 
@@ -969,20 +1022,24 @@ opengl_renderer::setup_opengl_transforma
 
   glClear (GL_DEPTH_BUFFER_BIT);
 
   // store axes transformation data
 
   xform = props.get_transform ();
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_axes_planes (const axes::properties& props)
 {
 #if defined (HAVE_OPENGL)
 
@@ -1025,20 +1082,24 @@ opengl_renderer::draw_axes_planes (const
   glVertex3d (xPlane, yPlane, zPlane);
   glVertex3d (xPlaneN, yPlane, zPlane);
 
   glEnd ();
 
   set_polygon_offset (false);
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_axes_boxes (const axes::properties& props)
 {
 #if defined (HAVE_OPENGL)
 
@@ -1145,20 +1206,24 @@ opengl_renderer::draw_axes_boxes (const 
           glVertex3d (xPlaneN, yPlaneN, zPlaneN);
           glVertex3d (xPlaneN, yPlaneN, zPlane);
         }
     }
 
   glEnd ();
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_axes_x_grid (const axes::properties& props)
 {
   int xstate = props.get_xstate ();
 
@@ -1585,20 +1650,24 @@ opengl_renderer::draw_axes_children (con
   glEnable (GL_DEPTH_TEST);
 
   set_clipping (false);
 
   // FIXME: finalize rendering (transparency processing)
   // FIXME: draw zoom box, if needed
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_axes (const axes::properties& props)
 {
 #if defined (HAVE_OPENGL)
 
@@ -1644,20 +1713,24 @@ opengl_renderer::draw_axes (const axes::
 
   // Re-enable line smoothing for children
   if (antialias == GL_TRUE)
     glEnable (GL_LINE_SMOOTH);
 
   draw_axes_children (props);
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_line (const line::properties& props)
 {
 #if defined (HAVE_OPENGL)
 
@@ -1777,20 +1850,24 @@ opengl_renderer::draw_line (const line::
         }
 
       end_marker ();
     }
 
   set_clipping (props.is_clipping ());
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_surface (const surface::properties& props)
 {
 #if defined (HAVE_OPENGL)
 
@@ -2383,20 +2460,24 @@ opengl_renderer::draw_surface (const sur
               draw_marker (x(j1,i), y(j,i1), z(j,i), lc, fc);
             }
         }
 
       end_marker ();
     }
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 // FIXME: global optimization (rendering, data structures...),
 // there is probably a smarter/faster/less-memory-consuming way to do this.
 void
 opengl_renderer::draw_patch (const patch::properties &props)
 {
@@ -2826,20 +2907,24 @@ opengl_renderer::draw_patch (const patch
 
             draw_marker (v(idx,0), v(idx,1), (has_z ? v(idx,2) : 0), lc, fc);
           }
 
       end_marker ();
     }
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_hggroup (const hggroup::properties &props)
 {
   draw (props.get_children ());
 }
@@ -2866,20 +2951,24 @@ opengl_renderer::draw_text (const text::
   glBitmap (0, 0, 0, 0, bbox(0), bbox(1), 0);
   glDrawPixels (bbox(2), bbox(3),
                 GL_RGBA, GL_UNSIGNED_BYTE, props.get_pixels ().data ());
   glDisable (GL_ALPHA_TEST);
   if (! blend)
     glDisable (GL_BLEND);
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_image (const image::properties& props)
 {
 #if defined (HAVE_OPENGL)
 
@@ -3062,97 +3151,128 @@ opengl_renderer::draw_image (const image
         warning ("opengl_renderer: invalid image data type (expected double, single, uint8, or uint16)");
     }
   else
     warning ("opengl_renderer: invalid image size (expected MxNx3 or MxN)");
 
   glPixelZoom (1, 1);
 
 #else
+
+  octave_unused_parameter (props);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::set_viewport (int w, int h)
 {
 #if defined (HAVE_OPENGL)
 
   glViewport (0, 0, w, h);
 
 #else
+
+  octave_unused_parameter (w);
+  octave_unused_parameter (h);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_pixels (int width, int height, const float *data)
 {
 #if defined (HAVE_OPENGL)
 
   glDrawPixels (width, height, GL_RGB, GL_FLOAT, data);
 
 #else
+
+  octave_unused_parameter (width);
+  octave_unused_parameter (height);
+  octave_unused_parameter (data);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_pixels (int width, int height, const uint8_t *data)
 {
 #if defined (HAVE_OPENGL)
 
   glDrawPixels (width, height, GL_RGB, GL_UNSIGNED_BYTE, data);
 
 #else
+
+  octave_unused_parameter (width);
+  octave_unused_parameter (height);
+  octave_unused_parameter (data);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_pixels (int width, int height, const uint16_t *data)
 {
 #if defined (HAVE_OPENGL)
 
   glDrawPixels (width, height, GL_RGB, GL_UNSIGNED_SHORT, data);
 
 #else
+
+  octave_unused_parameter (width);
+  octave_unused_parameter (height);
+  octave_unused_parameter (data);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::set_color (const Matrix& c)
 {
 #if defined (HAVE_OPENGL)
 
   glColor3dv (c.data ());
 
   txt_renderer.set_color (c);
 
 #else
+
+  octave_unused_parameter (c);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::set_font (const base_properties& props)
 {
   txt_renderer.set_font (props.get ("fontname").string_value (),
                          props.get ("fontweight").string_value (),
@@ -3173,35 +3293,44 @@ opengl_renderer::set_polygon_offset (boo
     }
   else
     {
       glDisable (GL_POLYGON_OFFSET_FILL);
       glDisable (GL_POLYGON_OFFSET_LINE);
     }
 
 #else
+
+  octave_unused_parameter (on);
+  octave_unused_parameter (offset);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::set_linewidth (float w)
 {
 #if defined (HAVE_OPENGL)
 
   glLineWidth (w);
 
 #else
+
+  octave_unused_parameter (w);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::set_linestyle (const std::string& s, bool use_stipple)
 {
 #if defined (HAVE_OPENGL)
 
@@ -3222,20 +3351,25 @@ opengl_renderer::set_linestyle (const st
     glLineStipple (1, static_cast<unsigned short> (0x0000));
 
   if (solid && ! use_stipple)
     glDisable (GL_LINE_STIPPLE);
   else
     glEnable (GL_LINE_STIPPLE);
 
 #else
+
+  octave_unused_parameter (s);
+  octave_unused_parameter (use_stipple);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::set_clipbox (double x1, double x2, double y1, double y2,
                               double z1, double z2)
 {
 #if defined (HAVE_OPENGL)
@@ -3263,20 +3397,29 @@ opengl_renderer::set_clipbox (double x1,
   p(2) = 1; p(3) = -z1;
   glClipPlane (GL_CLIP_PLANE5, p.data ());
 
   xmin = x1; xmax = x2;
   ymin = y1; ymax = y2;
   zmin = z1; zmax = z2;
 
 #else
+
+  octave_unused_parameter (x1);
+  octave_unused_parameter (x2);
+  octave_unused_parameter (y1);
+  octave_unused_parameter (y2);
+  octave_unused_parameter (z1);
+  octave_unused_parameter (z2);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::set_clipping (bool enable)
 {
 #if defined (HAVE_OPENGL)
 
@@ -3288,33 +3431,37 @@ opengl_renderer::set_clipping (bool enab
         for (int i = 0; i < 6; i++)
           glEnable (GL_CLIP_PLANE0+i);
       else
         for (int i = 0; i < 6; i++)
           glDisable (GL_CLIP_PLANE0+i);
     }
 
 #else
+
+  octave_unused_parameter (enable);
+  
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::init_marker (const std::string& m, double size, float width)
 {
 #if defined (HAVE_OPENGL)
 
-#if defined (HAVE_FRAMEWORK_OPENGL)
+#  if defined (HAVE_FRAMEWORK_OPENGL)
   GLint vw[4];
-#else
+#  else
   int vw[4];
-#endif
+#  endif
 
   glGetIntegerv (GL_VIEWPORT, vw);
 
   glMatrixMode (GL_PROJECTION);
   glPushMatrix ();
   glLoadIdentity ();
   glOrtho (0, vw[2], vw[3], 0, xZ1, xZ2);
   glMatrixMode (GL_MODELVIEW);
@@ -3322,20 +3469,26 @@ opengl_renderer::init_marker (const std:
 
   set_clipping (false);
   set_linewidth (width);
 
   marker_id = make_marker_list (m, size, false);
   filled_marker_id = make_marker_list (m, size, true);
 
 #else
+
+  octave_unused_parameter (m);
+  octave_unused_parameter (size);
+  octave_unused_parameter (width);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::end_marker (void)
 {
 #if defined (HAVE_OPENGL)
 
@@ -3344,20 +3497,22 @@ opengl_renderer::end_marker (void)
 
   glMatrixMode (GL_MODELVIEW);
   glPopMatrix ();
   glMatrixMode (GL_PROJECTION);
   glPopMatrix ();
   set_linewidth (0.5f);
 
 #else
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::draw_marker (double x, double y, double z,
                               const Matrix& lc, const Matrix& fc)
 {
 #if defined (HAVE_OPENGL)
@@ -3385,20 +3540,28 @@ opengl_renderer::draw_marker (double x, 
     }
   else if (marker_id > 0 && lc.numel () > 0)
     {
       glColor3dv (lc.data ());
       glCallList (marker_id);
     }
 
 #else
+
+  octave_unused_parameter (x);
+  octave_unused_parameter (y);
+  octave_unused_parameter (z);
+  octave_unused_parameter (lc);
+  octave_unused_parameter (fc);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 unsigned int
 opengl_renderer::make_marker_list (const std::string& marker, double size,
                                    bool filled) const
 {
 #if defined (HAVE_OPENGL)
@@ -3548,20 +3711,26 @@ opengl_renderer::make_marker_list (const
       break;
     }
 
   glEndList ();
 
   return ID;
 
 #else
+
+  octave_unused_parameter (marker);
+  octave_unused_parameter (size);
+  octave_unused_parameter (filled);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 opengl_renderer::text_to_pixels (const std::string& txt,
                                  uint8NDArray& pixels,
                                  Matrix& bbox,
                                  int halign, int valign, double rotation)
@@ -3609,14 +3778,24 @@ opengl_renderer::render_text (const std:
 
       if (! blend)
         glDisable (GL_BLEND);
     }
 
   return bbox;
 
 #else
+
+  octave_unused_parameter (txt);
+  octave_unused_parameter (x);
+  octave_unused_parameter (y);
+  octave_unused_parameter (z);
+  octave_unused_parameter (halign);
+  octave_unused_parameter (valign);
+  octave_unused_parameter (rotation);
+
   // This shouldn't happen because construction of opengl_renderer
   // objects is supposed to be impossible if OpenGL is not available.
 
   panic_impossible ();
+
 #endif
 }
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1018,16 +1018,20 @@ save_vars (std::ostream& os, const std::
   return saved;
 }
 
 static string_vector
 parse_save_options (const string_vector &argv,
                     load_save_format &format, bool &append,
                     bool &save_as_floats, bool &use_zlib)
 {
+#if ! defined (HAVE_ZLIB)
+  octave_unused_parameter (use_zlib);
+#endif
+
   string_vector retval;
   int argc = argv.numel ();
 
   bool do_double = false;
   bool do_tabs = false;
 
   for (int i = 0; i < argc; i++)
     {
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -982,21 +982,29 @@ save_type_to_hdf5 (save_type st)
       return H5T_NATIVE_FLOAT;
 
     case LS_DOUBLE:
     default:
       return H5T_NATIVE_DOUBLE;
     }
 
 #  else
-  (void) st; //silence compiler warning
+
+  octave_unused_parameter (st);
+
   return -1;
+
 #  endif
+
 #else
+
+  octave_unused_parameter (st);
+
   err_disabled_feature ("save_type_to_hdf5", "HDF5");
+
 #endif
 }
 
 // Add the data from TC to the HDF5 location loc_id, which could
 // be either a file or a group within a file.  Return true if
 // successful.  This function calls itself recursively for lists
 // (stored as HDF5 groups).
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -586,16 +586,17 @@ read_mat5_binary_element (std::istream& 
       else
         {
           std::istringstream gz_is (outbuf);
           retval = read_mat5_binary_element (gz_is, filename,
                                              swap, global, tc);
         }
 
       return retval;
+
 #else
       err_disabled_feature ("load", "compressed data elements (zlib)");
 #endif
     }
 
   std::streampos pos;
 
   if (type != miMATRIX)
@@ -2281,16 +2282,17 @@ save_mat5_binary_element (std::ostream& 
     }
   else if (dv.numel () > max_dim_val)
     {
       warn_dim_too_large (name);
       return true;  // skip to next
     }
 
 #ifdef HAVE_ZLIB
+
   if (mat7_format && ! compressing)
     {
       bool ret = false;
 
       std::ostringstream buf;
 
       // The code seeks backwards in the stream to fix the header. Can't
       // do this with zlib, so use a stringstream.
@@ -2315,16 +2317,21 @@ save_mat5_binary_element (std::ostream& 
           write_mat5_tag (os, miCOMPRESSED,
                           static_cast<octave_idx_type> (destLen));
 
           os.write (out_buf, destLen);
         }
 
       return ret;
     }
+
+#else
+
+  octave_unused_parameter (compressing);
+
 #endif
 
   write_mat5_tag (os, miMATRIX, save_mat5_element_length
                   (tc, name, save_as_floats, mat7_format));
 
   // array flags subelement
   write_mat5_tag (os, miUINT32, 8);
 
diff --git a/libinterp/corefcn/oct-hdf5-types.cc b/libinterp/corefcn/oct-hdf5-types.cc
--- a/libinterp/corefcn/oct-hdf5-types.cc
+++ b/libinterp/corefcn/oct-hdf5-types.cc
@@ -32,30 +32,35 @@ bool
 check_hdf5_types (bool warn)
 {
   static bool checked = false;
   static bool ok = false;
 
   if (! checked)
     {
 #if defined (HAVE_HDF5)
+
       ok = sizeof (octave_hdf5_id) >= sizeof (hid_t);
 
       if (warn && ! ok)
         warning_with_id
           ("Octave:internal",
            "the size of octave_hdf5_id is smaller than the size of HDF5 hid_t");
 
       ok = sizeof (octave_hdf5_err) >= sizeof (herr_t);
 
       if (warn && ! ok)
         warning_with_id
           ("Octave:internal",
            "the size of octave_hdf5_err is smaller than the size of HDF5 herr_t");
 #else
+
+      octave_unused_parameter (warn);
+
       warn_disabled_feature ("check_hdf5_id_type", "HDF5");
+
 #endif
 
       checked = true;
     }
 
   return ok;
 }
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -50,21 +50,22 @@ along with Octave; see the file COPYING.
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "unwind-prot.h"
 
 #if defined (HAVE_QHULL)
+
 #  include "oct-qhull.h"
+
 #  if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__delaunayn__.oct 2007-08-21";
 #  endif
-#endif
 
 static void
 close_fcn (FILE *f)
 {
   gnulib::fclose (f);
 }
 
 static bool
@@ -76,16 +77,18 @@ octave_qhull_dims_ok (octave_idx_type di
 
       if (dim > maxval || n > maxval)
         error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
+#endif
+
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{T} =} __delaunayn__ (@var{pts})\n\
 @deftypefnx {} {@var{T} =} __delaunayn__ (@var{pts}, @var{options})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
@@ -221,16 +224,20 @@ Undocumented internal function.\n\
         vec(i) = i + 1.0;
 
       retval(0) = vec;
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__delaunayn__", "Qhull");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -32,16 +32,18 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 #include "ov-re-sparse.h"
 #include "ov.h"
 #include "pager.h"
 #include "quit.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
+#if defined (HAVE_ARPACK)
+
 // Global pointer for user defined function.
 static octave_function *eigs_fcn = 0;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
@@ -115,16 +117,18 @@ eigs_complex_func (const ComplexColumnVe
           eigs_error = 1;
           err_user_supplied_eval ("eigs");
         }
     }
 
   return retval;
 }
 
+#endif
+
 DEFUN_DLD (__eigs__, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{d} =} __eigs__ (@var{A})\n\
 @deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{k})\n\
 @deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma})\n\
 @deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma}, @var{opts})\n\
 @deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{B})\n\
 @deftypefnx {} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k})\n\
@@ -141,16 +145,17 @@ DEFUN_DLD (__eigs__, args, nargout,
 @deftypefnx {} {[@var{V}, @var{d}] =} __eigs__ (@var{A}, @dots{})\n\
 @deftypefnx {} {[@var{V}, @var{d}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
 @deftypefnx {} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{A}, @dots{})\n\
 @deftypefnx {} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_ARPACK
+
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
   octave_value_list retval;
 
   std::string fcn_name;
@@ -553,16 +558,21 @@ Undocumented internal function.\n\
              nconv, k);
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("eigs", "ARPACK");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -47,16 +47,17 @@ along with Octave; see the file COPYING.
 
 DEFUN_DLD (__fltk_uigetfile__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __fltk_uigetfile__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_FLTK
+
   // Expected argument list:
   //
   //   args(0) ... FileFilter in fltk format
   //   args(1) ... Title
   //   args(2) ... Default Filename
   //   args(3) ... PositionValue [x,y]
   //   args(4) ... SelectValue "on"/"off"/"dir"/"create"
 
@@ -134,17 +135,21 @@ Undocumented internal function.\n\
     }
 
   fc.hide ();
   Fl::flush ();
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__fltk_uigetfile__", "OpenGL and FLTK");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -614,16 +614,20 @@ Undocumented internal function.\n\
     }
 
   extra.assign ("time", time);
   extra.assign ("status", status);
 
   return ovl (xmin, fmin, errnum, extra);
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("glpk", "GNU Linear Programming Kit");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -192,16 +192,18 @@ instead.\n\
     }
 
   OSMesaDestroyContext (ctx);
 
   return retval;
 
 #else
 
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__osmesa_print__", "offscreen rendering with OSMesa");
 
 #endif
 }
 
 /*
 ## FIXME: osmesa does not work correctly on Windows platforms.
 ##        This is not critical, since this facility will mostly be used in
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -44,21 +44,22 @@ qhull command
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "unwind-prot.h"
 
 #if defined (HAVE_QHULL)
+
 #  include "oct-qhull.h"
+
 #  if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__voronoi__.oct 2007-07-24";
 #  endif
-#endif
 
 static void
 close_fcn (FILE *f)
 {
   gnulib::fclose (f);
 }
 
 static bool
@@ -70,25 +71,28 @@ octave_qhull_dims_ok (octave_idx_type di
 
       if (dim > maxval || n > maxval)
         error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
+#endif
+
 DEFUN_DLD (__voronoi__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
 @deftypefnx {} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #if defined (HAVE_QHULL)
+
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   std::string caller = args(0).xstring_value ("__voronoi__: CALLER must be a string");
 
   octave_value_list retval;
@@ -323,21 +327,25 @@ Undocumented internal function.\n\
 
   if (curlong || totlong)
     warning ("%s: qhull did not free %d bytes of long memory (%d pieces)",
              caller.c_str (), totlong, curlong);
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  
   std::string caller
     = (args.length () > 0
        ? args(0).xstring_value ("__voronoi__: CALLER must be a string")
        : std::string ("__voronoi__"));
 
   err_disabled_feature (caller, "Qhull");
+
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -81,16 +81,17 @@ absorption.  The default is not to perfo
 \n\
 The author of the code itself is Timothy A. Davis\n\
 @email{davis@@cise.ufl.edu}, University of Florida\n\
 (see @url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
 @seealso{symamd, colamd}\n\
 @end deftypefn")
 {
 #ifdef HAVE_AMD
+
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_idx_type n_row, n_col;
   const octave_idx_type *ridx, *cidx;
   SparseMatrix sm;
@@ -173,17 +174,22 @@ The author of the code itself is Timothy
     Pout.xelem (i) = P[i] + 1;
 
   if (nargout > 1)
     return ovl (Pout, xinfo);
   else
     return ovl (Pout);
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("amd", "AMD");
+
 #endif
 }
 
 /*
 %!shared A, A2, opts
 %! A = ones (20, 30);
 %! A2 = ones (30, 30);
 %!
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -401,16 +401,18 @@ recording using those parameters.\n\
         error ("audiodevinfo: please specify 0 for output and 1 for input devices");
 
       retval = 0;
     }
 
   return retval;
 
 #else
+  octave_unused_parameter (args);
+
   err_disabled_feature ("audiodevinfo",
                         "audio playback and recording through PortAudio");
 #endif
 }
 
 /*
 %!testif HAVE_PORTAUDIO
 %! devinfo = audiodevinfo;
@@ -1806,16 +1808,18 @@ DEFUN_DLD (__recorder_audiorecorder__, a
 @deftypefnx {} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels}, @var{id})\n\
 @deftypefnx {} {@var{recorder} =} __recorder_audiorecorder__ (@var{fcn}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_audiorecorder__",
                         "audio playback and recording through PortAudio");
 #else
 
   int nargin = args.length ();
 
   audiorecorder* recorder = new audiorecorder ();
 
@@ -1869,190 +1873,214 @@ get_recorder (const octave_value& ov)
 DEFUN_DLD (__recorder_getaudiodata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{data}} __recorder_getaudiodata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_getaudiodata__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->getaudiodata ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_channels__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __recorder_get_channels__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_channels__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_channels ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{fs} =} __recorder_get_fs__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_fs__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_fs ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_id__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{id} =} __recorder_get_id__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_id__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_id ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_nbits__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{nbits} =} __recorder_get_nbits__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_nbits__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_nbits ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_sample_number__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __recorder_get_sample_number__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_sample_number__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_sample_number ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{tag} =} __recorder_get_tag__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_tag__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_tag ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_total_samples__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __recorder_get_total_samples__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_total_samples__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_total_samples ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{data} =} __recorder_get_userdata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_get_userdata__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->get_userdata ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_isrecording__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_isrecording__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_isrecording__",
                         "audio playback and recording through PortAudio");
 #else
   retval = get_recorder (args(0))->isrecording ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_pause__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_pause__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_pause__",
                         "audio playback and recording through PortAudio");
 #else
   get_recorder (args(0))->pause ();
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__recorder_recordblocking__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_recordblocking__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_recordblocking__",
                         "audio playback and recording through PortAudio");
 #else
   float seconds = args(1).float_value ();
   get_recorder (args(0))->recordblocking (seconds);
   return ovl ();
 #endif
 }
@@ -2060,16 +2088,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__recorder_record__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {} __recorder_record__ (@var{recorder})\n\
 @deftypefnx {} {} __recorder_record__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_record__",
                         "audio playback and recording through PortAudio");
 #else
   audiorecorder *recorder = get_recorder (args(0));
 
   if (args.length () == 2)
     recorder->set_end_sample (args(1).int_value () * recorder->get_fs ());
 
@@ -2080,80 +2110,90 @@ Undocumented internal function.\n\
 
 DEFUN_DLD (__recorder_resume__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_resume__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_resume__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     get_recorder (args(0))->resume ();
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__recorder_set_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_set_fs__ (@var{recorder}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_set_fs__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 2)
     get_recorder (args(0))->set_fs (args(1).int_value ());
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__recorder_set_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_set_tag__ (@var{recorder}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_set_tag__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 2)
     get_recorder (args(0))->set_tag (args(1).char_matrix_value ());
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__recorder_set_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_set_userdata__ (@var{recorder}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_set_userdata__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 2)
     get_recorder (args(0))->set_userdata (args(1));
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__recorder_stop__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_stop__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__recorder_stop__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     get_recorder (args(0))->stop ();
   return ovl ();
 #endif
 }
@@ -2163,16 +2203,18 @@ DEFUN_DLD (__player_audioplayer__, args,
 @deftypefn  {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs})\n\
 @deftypefnx {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits})\n\
 @deftypefnx {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits}, @var{id})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_audioplayer__",
                         "audio playback and recording through PortAudio");
 #else
 
   int nargin = args.length ();
 
   audioplayer* recorder = new audioplayer ();
 
@@ -2231,16 +2273,18 @@ get_player (const octave_value& ov)
 DEFUN_DLD (__player_get_channels__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __player_get_channels__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_channels__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_channels ();
 #endif
   return retval;
 }
@@ -2248,16 +2292,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_get_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{fs} =} __player_get_fs__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_fs__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_fs ();
 #endif
   return retval;
 }
@@ -2265,16 +2311,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_get_id__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{id} =} __player_get_id__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_id__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_id ();
 #endif
   return retval;
 }
@@ -2282,16 +2330,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_get_nbits__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{nbits} =} __player_get_nbits__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_nbits__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_nbits ();
 #endif
   return retval;
 }
@@ -2299,16 +2349,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_get_sample_number__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __player_get_sample_number__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_sample_number__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_sample_number ();
 #endif
   return retval;
 }
@@ -2316,16 +2368,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_get_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{tag} =} __player_get_tag__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_tag__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_tag ();
 #endif
   return retval;
 }
@@ -2333,16 +2387,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_get_total_samples__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __player_get_total_samples__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_total_samples__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_total_samples ();
 #endif
   return retval;
 }
@@ -2350,16 +2406,18 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_get_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{data} =} __player_get_userdata__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_get_userdata__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_userdata ();
 #endif
   return retval;
 }
@@ -2367,32 +2425,36 @@ Undocumented internal function.\n\
 DEFUN_DLD (__player_isplaying__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_isplaying__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_isplaying__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->isplaying ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_pause__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_pause__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_pause__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     get_player (args(0))->pause ();
   return ovl ();
 #endif
 }
@@ -2401,16 +2463,18 @@ DEFUN_DLD (__player_playblocking__, args
            "-*- texinfo -*-\n\
 @deftypefn  {} {} __player_playblocking__ (@var{player})\n\
 @deftypefnx {} {} __player_playblocking__ (@var{player}, @var{start})\n\
 @deftypefnx {} {} __player_playblocking__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_playblocking__",
                         "audio playback and recording through PortAudio");
 #else
 
   audioplayer *player = get_player (args(0));
 
   if (args.length () == 1)
     {
@@ -2453,16 +2517,18 @@ DEFUN_DLD (__player_play__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {} __player_play__ (@var{player})\n\
 @deftypefnx {} {} __player_play__ (@var{player}, @var{start})\n\
 @deftypefnx {} {} __player_play__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_play__",
                         "audio playback and recording through PortAudio");
 #else
 
   if (args.length () == 1)
     {
       get_player (args(0))->play ();
     }
@@ -2503,80 +2569,90 @@ Undocumented internal function.\n\
 
 DEFUN_DLD (__player_resume__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_resume__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_resume__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     get_player (args(0))->resume ();
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__player_set_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_set_fs__ (@var{player}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_set_fs__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 2)
     get_player (args(0))->set_fs (args(1).int_value ());
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__player_set_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_set_tag__ (@var{player}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_set_tag__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 2)
     get_player (args(0))->set_tag (args(1).char_matrix_value ());
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__player_set_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_set_userdata__ (@var{player}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_set_userdata__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 2)
     get_player (args(0))->set_userdata (args(1));
   return ovl ();
 #endif
 }
 
 DEFUN_DLD (__player_stop__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_stop__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__player_stop__",
                         "audio playback and recording through PortAudio");
 #else
   if (args.length () == 1)
     get_player (args(0))->stop ();
   return ovl ();
 #endif
 }
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -37,21 +37,23 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-struct.h"
 
 #ifdef HAVE_SNDFILE
 #  include <sndfile.h>
 #endif
 
 #ifdef HAVE_SNDFILE
+
 static void
 safe_close (SNDFILE *file)
 {
   sf_close (file);
 }
+
 #endif
 
 DEFUN_DLD (audioread, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{y}, @var{fs}] =} audioread (@var{filename})\n\
 @deftypefnx {} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples})\n\
 \n\
 @deftypefnx {} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{datatype})\n\
@@ -167,18 +169,22 @@ is stored in the audio file.\n\
         ret_audio = audio;
     }
   else
     ret_audio = audio;
 
   return ovl (ret_audio, info.samplerate);
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("audioread",
                         "reading and writing sound files through libsndfile");
+
 #endif
 }
 
 #ifdef HAVE_SNDFILE
 
 static int
 extension_to_format (const std::string& ext)
 {
@@ -412,28 +418,33 @@ Comment.\n\
       offset += chunk_size;
     }
 
   // FIXME: shouldn't we return something to indicate whether the file
   // was written successfully?
   return ovl ();
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("audiowrite",
                         "reading and writing sound files through libsndfile");
+
 #endif
 }
 
 DEFUN_DLD (audioinfo, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{info} =} audioinfo (@var{filename})\n\
 Return information about an audio file specified by @var{filename}.\n\
 @end deftypefn")
 {
 #ifdef HAVE_SNDFILE
+
   if (args.length () != 1)
     print_usage ();
 
   std::string filename = args(0).xstring_value ("audioinfo: FILENAME must be a string");
 
   SF_INFO info;
   info.format = 0;
   SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
@@ -484,12 +495,16 @@ Return information about an audio file s
   result.assign ("BitRate", -1);
   result.assign ("Title", sf_get_string (file, SF_STR_TITLE));
   result.assign ("Artist", sf_get_string (file, SF_STR_ARTIST));
   result.assign ("Comment", sf_get_string (file, SF_STR_COMMENT));
 
   return ovl (result);
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("audioinfo",
                         "reading and writing sound files through libsndfile");
+
 #endif
 }
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -325,17 +325,22 @@ ccolamd, csymamd, amd, colamd, symamd, a
       // occur if symamd returns FALSE
       out_stats(CCOLAMD_INFO1)++;
       out_stats(CCOLAMD_INFO2)++;
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("ccolamd", "CCOLAMD");
+
 #endif
 }
 
 DEFUN_DLD (csymamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} csymamd (@var{S})\n\
 @deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
 @deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
@@ -556,11 +561,16 @@ ccolamd, csymamd, amd, colamd, symamd, a
       // occur if symamd returns FALSE
       out_stats(CCOLAMD_INFO1)++;
       out_stats(CCOLAMD_INFO2)++;
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("csymamd", "CCOLAMD");
+
 #endif
 }
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -274,16 +274,17 @@ The ordering is followed by a column eli
 The authors of the code itself are @nospell{Stefan I. Larimore} and\n\
 @nospell{Timothy A. Davis @email{davis@@cise.ufl.edu}}, University of Florida.  The algorithm was developed in collaboration with @nospell{John Gilbert},\n\
 Xerox PARC, and @nospell{Esmond Ng}, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, symamd, ccolamd}\n\
 @end deftypefn")
 {
 #ifdef HAVE_COLAMD
+
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value_list retval (nargout == 2 ? 2 : 1);
   int spumoni = 0;
 
@@ -436,17 +437,22 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       // occur if symamd returns FALSE
       out_stats(COLAMD_INFO1)++;
       out_stats(COLAMD_INFO2)++;
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("colamd", "COLAMD");
+
 #endif
 }
 
 DEFUN_DLD (symamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} symamd (@var{S})\n\
 @deftypefnx {} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
 @deftypefnx {} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
@@ -624,17 +630,22 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       // occur if symamd returns FALSE
       out_stats(COLAMD_INFO1)++;
       out_stats(COLAMD_INFO2)++;
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("symamd", "COLAMD");
+
 #endif
 }
 
 DEFUN_DLD (etree, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -39,21 +39,22 @@ 2006-05-01 Tom Holroyd
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "parse.h"
 #include "unwind-prot.h"
 
 #if defined (HAVE_QHULL)
+
 #  include "oct-qhull.h"
+
 #  if defined (NEED_QHULL_VERSION)
 char qh_version[] = "convhulln.oct 2007-07-24";
 #  endif
-#endif
 
 static void
 close_fcn (FILE *f)
 {
   gnulib::fclose (f);
 }
 
 static bool
@@ -65,16 +66,18 @@ octave_qhull_dims_ok (octave_idx_type di
 
       if (dim > maxval || n > maxval)
         error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
+#endif
+
 DEFUN_DLD (convhulln, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{h} =} convhulln (@var{pts})\n\
 @deftypefnx {} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
 @deftypefnx {} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Compute the convex hull of the set of points @var{pts}.\n\
 \n\
 @var{pts} is a matrix of size [n, dim] containing n points in a space of\n\
@@ -285,17 +288,22 @@ convex hull is calculated.\n\n\
 
   if (curlong || totlong)
     warning ("convhulln: did not free %d bytes of long memory (%d pieces)",
              totlong, curlong);
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("convhulln", "Qhull");
+
 #endif
 }
 
 /*
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "Qt");
 %! assert (size (h), [12 3]);
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -37,26 +37,27 @@ along with Octave; see the file COPYING.
 #include "sparse-qr.h"
 
 #if defined (OCTAVE_ENABLE_64)
 #  define CXSPARSE_NAME(name) cs_dl ## name
 #else
 #  define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
+#if defined (HAVE_CXSPARSE)
+
 static RowVector
 put_int (octave_idx_type *p, octave_idx_type n)
 {
   RowVector ret (n);
   for (octave_idx_type i = 0; i < n; i++)
     ret.xelem (i) = p[i] + 1;
   return ret;
 }
 
-#if defined (HAVE_CXSPARSE)
 static octave_value_list
 dmperm_internal (bool rank, const octave_value arg, int nargout)
 {
   octave_value_list retval;
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
   SparseMatrix m;
   SparseComplexMatrix cm;
@@ -105,16 +106,17 @@ dmperm_internal (bool rank, const octave
       retval = ovl (put_int (dm->p, nr), put_int (dm->q, nc),
                     put_int (dm->r, dm->nb+1), put_int (dm->s, dm->nb+1));
 
       CXSPARSE_NAME (_dfree) (dm);
     }
 
   return retval;
 }
+
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} dmperm (@var{S})\n\
 @deftypefnx {} {[@var{p}, @var{q}, @var{r}, @var{S}] =} dmperm (@var{S})\n\
 \n\
 @cindex @nospell{Dulmage-Mendelsohn} decomposition\n\
@@ -139,17 +141,22 @@ ACM Trans. Math. Software, 16(4):303-324
 #if defined (HAVE_CXSPARSE)
 
   if (args.length () != 1)
     print_usage ();
 
   return ovl (dmperm_internal (false, args(0), nargout));
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("dmperm", "CXSparse");
+
 #endif
 }
 
 /*
 %!testif HAVE_CXSPARSE
 %! n = 20;
 %! a = speye (n,n);
 %! a = a(randperm (n),:);
@@ -182,17 +189,22 @@ such the numerical rank of the matrix @v
 #if defined (HAVE_CXSPARSE)
 
   if (args.length () != 1)
     print_usage ();
 
   return ovl (dmperm_internal (true, args(0), nargout));
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("sprank", "CXSparse");
+
 #endif
 }
 
 /*
 %!testif HAVE_CXSPARSE
 %! assert (sprank (speye (20)), 20);
 %!testif HAVE_CXSPARSE
 %! assert (sprank ([1,0,2,0;2,0,4,0]), 2);
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -310,17 +310,21 @@ used per default.\n\
 #endif
     }
   else
     error ("fftw: unrecognized argument");
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+
   err_disabled_feature ("fftw", "the FFTW3 planner");
+
 #endif
 }
 
 /*
 %!testif HAVE_FFTW
 %! def_method = fftw ("planner");
 %! unwind_protect
 %!   method = "estimate";
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -372,17 +372,22 @@ cleanup:
   CHOLMOD_NAME(finish) (cm);
 
   if (! err_msg.empty ())
     error (err_msg.c_str ());
 
   return retval;
 
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+  
   err_disabled_feature ("symbfact", "CHOLMOD");
+
 #endif
 }
 
 /*
 %!testif HAVE_CHOLMOD
 %! A = sparse (magic (3));
 %! [count, h, parent, post, r] = symbfact (A);
 %! assert (count, [3; 2; 1]);
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -364,16 +364,19 @@ octave_base_int_matrix<T>::save_hdf5 (oc
 
   retval = H5Dwrite (data_hid, save_type_hid, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, this->matrix.data ()) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   this->warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 template <typename T>
 bool
@@ -433,16 +436,19 @@ octave_base_int_matrix<T>::load_hdf5 (oc
       retval = true;
       this->matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   this->warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 template <typename T>
 void
@@ -571,16 +577,19 @@ octave_base_int_scalar<T>::save_hdf5 (oc
 
   retval = H5Dwrite (data_hid, save_type_hid, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &(this->scalar)) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   this->warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 template <typename T>
 bool
@@ -614,13 +623,17 @@ octave_base_int_scalar<T>::load_hdf5 (oc
 
   this->scalar = tmp;
 
   H5Dclose (data_hid);
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   this->warn_load ("hdf5");
+
   return false;
 #endif
 }
 
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -417,16 +417,19 @@ octave_bool_matrix::save_hdf5 (octave_hd
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, htmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_bool_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -488,16 +491,19 @@ octave_bool_matrix::load_hdf5 (octave_hd
         btmp.elem (i) = htmp[i];
 
       matrix = btmp;
     }
 
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_bool_matrix::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -537,16 +537,19 @@ octave_sparse_bool_matrix::save_hdf5 (oc
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_sparse_bool_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -776,16 +779,19 @@ octave_sparse_bool_matrix::load_hdf5 (oc
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_sparse_bool_matrix::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -191,16 +191,19 @@ octave_bool::save_hdf5 (octave_hdf5_id l
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_bool::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -230,16 +233,19 @@ octave_bool::load_hdf5 (octave_hdf5_id l
       return false;
     }
 
   scalar = (dtmp != 0.);
 
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return true;
 }
 
 mxArray *
 octave_bool::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1050,17 +1050,22 @@ octave_cell::save_hdf5 (octave_hdf5_id l
         }
     }
 
   H5Gclose (data_hid);
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
+
   return false;
 #endif
 }
 
 bool
 octave_cell::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -1160,16 +1165,19 @@ octave_cell::load_hdf5 (octave_hdf5_id l
 
   if (retval2 >= 0)
     {
       matrix = m;
       retval = true;
     }
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 DEFUN (iscell, args, ,
        "-*- texinfo -*-\n\
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1463,17 +1463,22 @@ error_cleanup:
     H5Tclose (type_hid);
 
   if (group_hid > 0)
     H5Gclose (group_hid);
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
+
   return false;
 #endif
 }
 
 bool
 octave_class::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -1598,16 +1603,19 @@ octave_class::load_hdf5 (octave_hdf5_id 
 error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
     H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_class::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -387,16 +387,19 @@ octave_complex::save_hdf5 (octave_hdf5_i
   retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -441,16 +444,19 @@ octave_complex::load_hdf5 (octave_hdf5_i
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_complex::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -611,17 +611,22 @@ octave_complex_matrix::save_hdf5 (octave
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
+
   return false;
 #endif
 }
 
 bool
 octave_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -691,16 +696,19 @@ octave_complex_matrix::load_hdf5 (octave
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_complex_matrix::print_raw (std::ostream& os,
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -606,16 +606,20 @@ octave_sparse_complex_matrix::save_hdf5 
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_sparse_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -854,16 +858,19 @@ octave_sparse_complex_matrix::load_hdf5 
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_sparse_complex_matrix::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -911,17 +911,22 @@ octave_fcn_handle::save_hdf5 (octave_hdf
 
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
+
   return false;
 #endif
 }
 
 bool
 octave_fcn_handle::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
@@ -1268,17 +1273,21 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
   H5Tclose (type_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return success;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
+
   return false;
 #endif
 }
 
 /*
 %!test
 %! a = 2;
 %! f = @(x) a + x;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -408,16 +408,19 @@ octave_fcn_inline::save_hdf5 (octave_hdf
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_fcn_inline::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -600,17 +603,21 @@ octave_fcn_inline::load_hdf5 (octave_hdf
   iftext = iftext_tmp;
 
   octave_fcn_inline ftmp (iftext, ifargs, nm);
   fcn = ftmp.fcn;
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
+
   return false;
 #endif
 }
 
 void
 octave_fcn_inline::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -210,16 +210,19 @@ octave_float_scalar::save_hdf5 (octave_h
   float tmp = float_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -251,17 +254,21 @@ octave_float_scalar::load_hdf5 (octave_h
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
+
   return false;
 #endif
 }
 
 mxArray *
 octave_float_scalar::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxSINGLE_CLASS, 1, 1, mxREAL);
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -337,16 +337,19 @@ octave_float_complex::save_hdf5 (octave_
   retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -391,16 +394,19 @@ octave_float_complex::load_hdf5 (octave_
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_float_complex::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -562,16 +562,19 @@ octave_float_complex_matrix::save_hdf5 (
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -643,16 +646,19 @@ octave_float_complex_matrix::load_hdf5 (
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_float_complex_matrix::print_raw (std::ostream& os,
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -564,16 +564,19 @@ octave_float_matrix::save_hdf5 (octave_h
   float *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -632,16 +635,19 @@ octave_float_matrix::load_hdf5 (octave_h
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_float_matrix::print_raw (std::ostream& os,
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -788,20 +788,22 @@ octave_java::is_java_string (void) const
     {
       jclass_ref cls (current_env, current_env->FindClass ("java/lang/String"));
       return current_env->IsInstanceOf (TO_JOBJECT (java_object), cls);
     }
 
   return false;
 
 #else
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 bool
 octave_java::is_instance_of (const std::string& cls_name) const
 {
 #if defined (HAVE_JAVA)
 
@@ -816,20 +818,24 @@ octave_java::is_instance_of (const std::
       if (current_env->ExceptionCheck ())
         current_env->ExceptionClear ();
       else
         return current_env->IsInstanceOf (TO_JOBJECT (java_object), cls);
     }
   return false;
 
 #else
+
+  octave_unused_parameter (cls_name);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 #if defined (HAVE_JAVA)
 
 static octave_value
 check_exception (JNIEnv *jni_env)
 {
@@ -1813,16 +1819,19 @@ octave_java::octave_java (const voidptr&
   : octave_base_value (), java_object (0), java_class (0)
 {
 #if defined (HAVE_JAVA)
 
   init (jobj, jcls);
 
 #else
 
+  octave_unused_parameter (jobj);
+  octave_unused_parameter (jcls);
+
   err_disabled_feature ("Java Objects", "Java");
 
 #endif
 }
 
 int octave_java::t_id (-1);
 
 const std::string octave_java::t_name ("octave_java");
@@ -1846,20 +1855,22 @@ octave_java::dims (void) const
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env && java_object)
     return compute_array_dimensions (current_env, TO_JOBJECT (java_object));
   else
     return dim_vector (1, 1);
 
 #else
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value_list
 octave_java::subsref (const std::string& type,
                       const std::list<octave_value_list>& idx, int nargout)
 {
 #if defined (HAVE_JAVA)
@@ -1904,20 +1915,26 @@ octave_java::subsref (const std::string&
     }
 
   if (idx.size () > 1 && type.length () > 1)
     retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
 
 #else
+
+  octave_unused_parameter (type);
+  octave_unused_parameter (idx);
+  octave_unused_parameter (nargout);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::subsasgn (const std::string& type,
                        const std::list<octave_value_list>& idx,
                        const octave_value& rhs)
 {
@@ -1987,60 +2004,73 @@ octave_java::subsasgn (const std::string
     default:
       error ("Java object cannot be indexed with %c", type[0]);
       break;
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (type);
+  octave_unused_parameter (idx);
+  octave_unused_parameter (rhs);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 string_vector
 octave_java::map_keys (void) const
 {
 #if defined (HAVE_JAVA)
 
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
     return get_invoke_list (current_env, to_java ());
   else
     return string_vector ();
 
 #else
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::convert_to_str_internal (bool, bool force, char type) const
 {
 #if defined (HAVE_JAVA)
 
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env)
     return convert_to_string (current_env, TO_JOBJECT (to_java ()), force, type);
   else
     return octave_value ("");
 
 #else
+
+  octave_unused_parameter (force);
+  octave_unused_parameter (type);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 octave_java::print (std::ostream& os, bool)
 {
   print_raw (os);
   newline (os);
@@ -2130,35 +2160,46 @@ octave_java::do_javaMethod (void *jni_en
         }
 
       restore_fpu_state ();
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (jni_env_arg);
+  octave_unused_parameter (name);
+  octave_unused_parameter (args);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_javaMethod (const std::string& name, const octave_value_list& args)
 {
 #if defined (HAVE_JAVA)
 
   return do_javaMethod (thread_jni_env (), name, args);
 
 #else
+
+  octave_unused_parameter (name);
+  octave_unused_parameter (args);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java:: do_javaMethod (void *jni_env_arg,
                              const std::string& class_name,
                              const std::string& name,
                              const octave_value_list& args)
@@ -2188,36 +2229,50 @@ octave_java:: do_javaMethod (void *jni_e
         }
 
       restore_fpu_state ();
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (jni_env_arg);
+  octave_unused_parameter (class_name);
+  octave_unused_parameter (name);
+  octave_unused_parameter (args);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
-octave_java::do_javaMethod (const std::string& class_name, const std::string& name,
+octave_java::do_javaMethod (const std::string& class_name,
+                            const std::string& name,
                             const octave_value_list& args)
 {
 #if defined (HAVE_JAVA)
 
   return do_javaMethod (thread_jni_env (), class_name, name, args);
 
 #else
+
+  octave_unused_parameter (class_name);
+  octave_unused_parameter (name);
+  octave_unused_parameter (args);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_javaObject (void *jni_env_arg, const std::string& name,
                             const octave_value_list& args)
 {
 #if defined (HAVE_JAVA)
@@ -2246,35 +2301,46 @@ octave_java::do_javaObject (void *jni_en
         }
 
       restore_fpu_state ();
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (jni_env_arg);
+  octave_unused_parameter (name);
+  octave_unused_parameter (args);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_javaObject (const std::string& name, const octave_value_list& args)
 {
 #if defined (HAVE_JAVA)
 
   return do_javaObject (thread_jni_env (), name, args);
 
 #else
+
+  octave_unused_parameter (name);
+  octave_unused_parameter (args);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_get (void *jni_env_arg, const std::string& name)
 {
 #if defined (HAVE_JAVA)
 
@@ -2297,35 +2363,44 @@ octave_java::do_java_get (void *jni_env_
         retval = check_exception (jni_env);
 
       restore_fpu_state ();
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (jni_env_arg);
+  octave_unused_parameter (name);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_get (const std::string& name)
 {
 #if defined (HAVE_JAVA)
 
   return do_java_get (thread_jni_env (), name);
 
 #else
+
+  octave_unused_parameter (name);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_get (void *jni_env_arg, const std::string& class_name,
                           const std::string& name)
 {
 #if defined (HAVE_JAVA)
@@ -2349,35 +2424,46 @@ octave_java::do_java_get (void *jni_env_
         retval = check_exception (jni_env);
 
       restore_fpu_state ();
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (jni_env_arg);
+  octave_unused_parameter (class_name);
+  octave_unused_parameter (name);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_get (const std::string& class_name, const std::string& name)
 {
 #if defined (HAVE_JAVA)
 
   return do_java_get (thread_jni_env (), class_name, name);
 
 #else
+
+  octave_unused_parameter (class_name);
+  octave_unused_parameter (name);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_set (void *jni_env_arg, const std::string& name,
                           const octave_value& val)
 {
 #if defined (HAVE_JAVA)
@@ -2402,35 +2488,46 @@ octave_java::do_java_set (void *jni_env_
         }
 
       restore_fpu_state ();
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (jni_env_arg);
+  octave_unused_parameter (name);
+  octave_unused_parameter (val);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_set (const std::string& name, const octave_value& val)
 {
 #if defined (HAVE_JAVA)
 
   return do_java_set (thread_jni_env (), name, val);
 
 #else
+
+  octave_unused_parameter (name);
+  octave_unused_parameter (val);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_set (void *jni_env_arg, const std::string& class_name,
                           const std::string& name, const octave_value& val)
 {
 #if defined (HAVE_JAVA)
@@ -2456,36 +2553,49 @@ octave_java::do_java_set (void *jni_env_
         }
 
       restore_fpu_state ();
     }
 
   return retval;
 
 #else
+
+  octave_unused_parameter (jni_env_arg);
+  octave_unused_parameter (class_name);
+  octave_unused_parameter (name);
+  octave_unused_parameter (val);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 octave_value
 octave_java::do_java_set (const std::string& class_name, const std::string& name,
                           const octave_value& val)
 {
 #if defined (HAVE_JAVA)
 
   return do_java_set (thread_jni_env (), class_name, name, val);
 
 #else
+
+  octave_unused_parameter (class_name);
+  octave_unused_parameter (name);
+  octave_unused_parameter (val);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 octave_java::init (void *jobj_arg, void *jcls_arg)
 {
 #if defined (HAVE_JAVA)
 
@@ -2512,20 +2622,25 @@ octave_java::init (void *jobj_arg, void 
           jclass_ref clsCls (current_env, current_env->GetObjectClass (TO_JCLASS (java_class)));
           jmethodID mID = current_env->GetMethodID (clsCls, "getCanonicalName", "()Ljava/lang/String;");
           jobject_ref resObj (current_env, current_env->CallObjectMethod (TO_JCLASS (java_class), mID));
           java_classname = jstring_to_string (current_env, resObj);
         }
     }
 
 #else
+
+  octave_unused_parameter (jobj_arg);
+  octave_unused_parameter (jcls_arg);
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 void
 octave_java::release (void)
 {
 #if defined (HAVE_JAVA)
 
@@ -2539,65 +2654,74 @@ octave_java::release (void)
       if (java_class)
         current_env->DeleteGlobalRef (TO_JCLASS (java_class));
 
       java_object = 0;
       java_class = 0;
     }
 
 #else
+
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
+
 #endif
 }
 
 // DEFUN blocks below must be outside of HAVE_JAVA block so that
 // documentation strings are always available, even when functions are not.
 
 DEFUN (__java_init__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __java_init__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 \n\
 Function will directly call initialize_java to create an instance of a JVM.\n\
 @end deftypefn")
 {
 #if defined (HAVE_JAVA)
+
   octave_value retval;
 
   retval = 0;
 
   initialize_java ();
 
   retval = 1;
 
   return retval;
+
 #else
+
   err_disabled_feature ("__java_init__", "Java");
+
 #endif
 }
 
 DEFUN (__java_exit__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __java_exit__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 \n\
 Function will directly call terminate_jvm to destroy the current JVM\n\
 instance.\n\
 @end deftypefn")
 {
 #if defined (HAVE_JAVA)
+
   terminate_jvm ();
 
   return ovl ();
 
 #else
-  error ("__java_init__", "Java");
+
+  err_disabled_feature ("__java_exit__", "Java");
+
 #endif
 }
 
 DEFUN (javaObject, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{jobj} =} javaObject (@var{classname})\n\
 @deftypefnx {} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
 Create a Java object of class @var{classsname}, by calling the class\n\
@@ -2630,16 +2754,18 @@ x = javaObject (\"java.lang.StringBuffer
   octave_value_list tmp;
   for (int i=1; i<args.length (); i++)
     tmp(i-1) = args(i);
 
   return ovl (octave_java::do_javaObject (current_env, classname, tmp));
 
 #else
 
+  octave_unused_parameter (args);
+
   err_disabled_feature ("javaObject", "Java");
 
 #endif
 }
 
 /*
 ## The tests below merely check if javaObject works at all.  Whether
 ## it works properly, i.e., creates the right values, is a matter of
@@ -2704,16 +2830,18 @@ equivalent\n\
     }
   else
     error ("javaMethod: OBJ must be a Java object or a string");
 
   return retval;
 
 #else
 
+  octave_unused_parameter (args);
+
   err_disabled_feature ("javaMethod", "Java");
 
 #endif
 }
 
 /*
 %!testif HAVE_JAVA
 %! ## Check for valid first two Java version numbers
@@ -2768,16 +2896,18 @@ equivalent\n\
     }
   else
     error ("__java_get__: OBJ must be a Java object or a string");
 
   return retval;
 
 #else
 
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__java_get__", "Java");
 
 #endif
 }
 
 DEFUN (__java_set__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
@@ -2826,16 +2956,18 @@ equivalent\n\
     }
   else
     error ("__java_set__: OBJ must be a Java object or a string");
 
   return retval;
 
 #else
 
+  octave_unused_parameter (args);
+
   err_disabled_feature ("__java_set__", "Java");
 
 #endif
 }
 
 DEFUN (java2mat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} java2mat (@var{javaobj})\n\
@@ -2860,16 +2992,18 @@ Undocumented internal function.\n\
     }
   else
     retval = ovl (args(0));
 
   return retval;
 
 #else
 
+  octave_unused_parameter (args);
+
   err_disabled_feature ("java2mat", "Java");
 
 #endif
 }
 
 DEFUN (java_matrix_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} java_matrix_autoconversion ()\n\
@@ -2882,19 +3016,26 @@ The default value is false.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_unsigned_autoconversion, debug_java}\n\
 @end deftypefn")
 {
 #if defined (HAVE_JAVA)
+
   return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
+
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("java_matrix_autoconversion", "Java");
+
 #endif
 }
 
 DEFUN (java_unsigned_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} java_unsigned_autoconversion ()\n\
 @deftypefnx {} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
 @deftypefnx {} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
@@ -2906,19 +3047,26 @@ of class uint8 or uint32 respectively.  
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, debug_java}\n\
 @end deftypefn")
 {
 #if defined (HAVE_JAVA)
+
   return SET_INTERNAL_VARIABLE (java_unsigned_autoconversion);
+
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("java_unsigned_autoconversion", "Java");
+
 #endif
 }
 
 DEFUN (debug_java, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} debug_java ()\n\
 @deftypefnx {} {@var{old_val} =} debug_java (@var{new_val})\n\
 @deftypefnx {} {} debug_java (@var{new_val}, \"local\")\n\
@@ -2928,19 +3076,26 @@ is printed.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, java_unsigned_autoconversion}\n\
 @end deftypefn")
 {
 #if defined (HAVE_JAVA)
+
   return SET_INTERNAL_VARIABLE (debug_java);
+
 #else
+
+  octave_unused_parameter (args);
+  octave_unused_parameter (nargout);
+
   err_disabled_feature ("debug_java", "Java");
+
 #endif
 }
 
 // Outside of #if defined (HAVE_JAVA) because it is desirable to be able
 // to test for the presence of a Java object without having Java
 // installed.
 
 DEFUN (isjava, args, ,
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -594,16 +594,19 @@ octave_range::save_hdf5 (octave_hdf5_id 
   else
     retval = false;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_range::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -658,16 +661,19 @@ octave_range::load_hdf5 (octave_hdf5_id 
         }
     }
 
   H5Tclose (range_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_range::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -688,16 +688,20 @@ octave_matrix::save_hdf5 (octave_hdf5_id
   double *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -756,16 +760,19 @@ octave_matrix::load_hdf5 (octave_hdf5_id
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_matrix::print_raw (std::ostream& os,
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -610,16 +610,20 @@ octave_sparse_matrix::save_hdf5 (octave_
   double * dtmp = m.xdata ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, dtmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_sparse_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -843,16 +847,19 @@ octave_sparse_matrix::load_hdf5 (octave_
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -233,16 +233,19 @@ octave_scalar::save_hdf5 (octave_hdf5_id
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -274,17 +277,21 @@ octave_scalar::load_hdf5 (octave_hdf5_id
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
+
   return false;
 #endif
 }
 
 mxArray *
 octave_scalar::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, 1, 1, mxREAL);
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -574,16 +574,19 @@ octave_char_matrix_str::save_hdf5 (octav
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, s) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_char_matrix_str::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -749,13 +752,16 @@ octave_char_matrix_str::load_hdf5 (octav
           H5Tclose (type_hid);
           H5Sclose (space_hid);
           H5Dclose (data_hid);
           return false;
         }
     }
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -906,17 +906,22 @@ octave_struct::save_hdf5 (octave_hdf5_id
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
+
   return false;
 #endif
 }
 
 bool
 octave_struct::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -954,16 +959,19 @@ octave_struct::load_hdf5 (octave_hdf5_id
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_struct::as_mxArray (void) const
@@ -1503,17 +1511,22 @@ octave_scalar_struct::save_hdf5 (octave_
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+  octave_unused_parameter (save_as_floats);
+
   warn_save ("hdf5");
+
   return false;
 #endif
 }
 
 bool
 octave_scalar_struct::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -1549,16 +1562,19 @@ octave_scalar_struct::load_hdf5 (octave_
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
 
 #else
+  octave_unused_parameter (loc_id);
+  octave_unused_parameter (name);
+
   warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_scalar_struct::as_mxArray (void) const
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1136,16 +1136,17 @@ SparseComplexMatrix::determinant (octave
   return determinant (info, rcond, 0);
 }
 
 ComplexDET
 SparseComplexMatrix::determinant (octave_idx_type& err, double& rcond,
                                   int) const
 {
   ComplexDET retval;
+
 #ifdef HAVE_UMFPACK
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       retval = ComplexDET (1.0);
@@ -1247,22 +1248,28 @@ SparseComplexMatrix::determinant (octave
                 }
               else
                 retval = ComplexDET (Complex (c10[0], c10[1]), e10, 10);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
         }
     }
-  return retval;
 
 #else
+
+  octave_unused_parameter (err);
+  octave_unused_parameter (rcond);
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
+
 #endif
+
+  return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const Matrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
@@ -5426,16 +5433,17 @@ SparseComplexMatrix::factorize (octave_i
                                 solve_singularity_handler sing_handler,
                                 bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #ifdef HAVE_UMFPACK
+
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (! xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
@@ -5524,22 +5532,30 @@ SparseComplexMatrix::factorize (octave_i
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
         }
     }
 
   if (err != 0)
     UMFPACK_ZNAME (free_numeric) (&Numeric);
 
-  return Numeric;
-
 #else
+
+  octave_unused_parameter (rcond);
+  octave_unused_parameter (Control);
+  octave_unused_parameter (Info);
+  octave_unused_parameter (sing_handler);
+  octave_unused_parameter (calc_cond);
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
+
 #endif
+
+  return Numeric;
 }
 
 ComplexMatrix
 SparseComplexMatrix::fsolve (MatrixType &mattype, const Matrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
@@ -5766,16 +5782,20 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -6060,16 +6080,20 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -6285,16 +6309,20 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -6571,16 +6599,20 @@ SparseComplexMatrix::fsolve (MatrixType 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1224,16 +1224,17 @@ SparseMatrix::determinant (octave_idx_ty
 }
 
 DET
 SparseMatrix::determinant (octave_idx_type& err, double& rcond, int) const
 {
   DET retval;
 
 #ifdef HAVE_UMFPACK
+
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     {
       retval = DET (1.0);
     }
   else
@@ -1328,23 +1329,28 @@ SparseMatrix::determinant (octave_idx_ty
               else
                 retval = DET (c10, e10, 10);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
         }
     }
 
-  return retval;
-
 #else
+
+  octave_unused_parameter (err);
+  octave_unused_parameter (rcond);
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled "
      "when liboctave was built");
+
 #endif
+
+  return retval;
 }
 
 Matrix
 SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b,
                       octave_idx_type& err,
                       double& rcond, solve_singularity_handler,
                       bool calc_cond) const
 {
@@ -5622,16 +5628,17 @@ SparseMatrix::factorize (octave_idx_type
                          Matrix &Info, solve_singularity_handler sing_handler,
                          bool calc_cond) const
 {
   // The return values
   void *Numeric = 0;
   err = 0;
 
 #ifdef HAVE_UMFPACK
+
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (! xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
@@ -5716,23 +5723,31 @@ SparseMatrix::factorize (octave_idx_type
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
         }
     }
 
   if (err != 0)
     UMFPACK_DNAME (free_numeric) (&Numeric);
 
-  return Numeric;
-
 #else
+
+  octave_unused_parameter (rcond);
+  octave_unused_parameter (Control);
+  octave_unused_parameter (Info);
+  octave_unused_parameter (sing_handler);
+  octave_unused_parameter (calc_cond);
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled "
      "when liboctave was built");
+
 #endif
+
+  return Numeric;
 }
 
 Matrix
 SparseMatrix::fsolve (MatrixType &mattype, const Matrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
@@ -5933,16 +5948,20 @@ SparseMatrix::fsolve (MatrixType &mattyp
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -6198,16 +6217,20 @@ SparseMatrix::fsolve (MatrixType &mattyp
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -6435,16 +6458,20 @@ SparseMatrix::fsolve (MatrixType &mattyp
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -6710,16 +6737,20 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 #else
+          octave_unused_parameter (rcond);
+          octave_unused_parameter (sing_handler);
+          octave_unused_parameter (calc_cond);
+
           (*current_liboctave_error_handler)
             ("support for UMFPACK was unavailable or disabled "
              "when liboctave was built");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
diff --git a/liboctave/cruft/misc/lo-error.c b/liboctave/cruft/misc/lo-error.c
--- a/liboctave/cruft/misc/lo-error.c
+++ b/liboctave/cruft/misc/lo-error.c
@@ -105,18 +105,19 @@ liboctave_fatal (const char *fmt, ...)
   va_end (args);
 
   exit (1);
 }
 
 void
 liboctave_fatal_with_id (const char *id, const char *fmt, ...)
 {
+  octave_unused_parameter (id);
+
   va_list args;
-  (void) id; /*unused*/
   va_start (args, fmt);
   verror ("fatal", fmt, args);
   va_end (args);
 
   exit (1);
 }
 
 void
@@ -126,14 +127,15 @@ liboctave_warning (const char *fmt, ...)
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
 
 void
 liboctave_warning_with_id (const char *id, const char *fmt, ...)
 {
+  octave_unused_parameter (id);
+
   va_list args;
-  (void) id; /*unused*/
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -328,18 +328,26 @@ sparse_chol<chol_type>::sparse_chol_rep:
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CHOLMOD_NAME(print_common) (blank_name, cm);
   CHOLMOD_NAME(free_factor) (&Lfactor, cm);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   return info;
 
 #else
+
+  octave_unused_parameter (a);
+  octave_unused_parameter (natural);
+  octave_unused_parameter (force);
+
   (*current_liboctave_error_handler)
     ("support for CHOLMOD was unavailable or disabled when liboctave was built");
+
+  return info;
+
 #endif
 }
 
 template <typename chol_type>
 SparseMatrix
 sparse_chol<chol_type>::sparse_chol_rep::Q (void) const
 {
 #ifdef HAVE_CHOLMOD
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -339,37 +339,41 @@ dmsolve_permute (MSparse<RT> &a, const M
           octave_quit ();
           a.xdata (i) = X[a.xridx (i)];
         }
 
       a.xcidx (j+1) = nz;
     }
 }
 
+#ifdef HAVE_CXSPARSE
+
 static void
 solve_singularity_warning (double)
 {
   // Dummy singularity handler so that LU solver doesn't flag
   // an error for numerically rank defficient matrices
 }
 
+#endif
+
 template <typename RT, typename ST, typename T>
 RT
 dmsolve (const ST &a, const T &b, octave_idx_type &info)
 {
+  RT retval;
+
 #ifdef HAVE_CXSPARSE
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
-  RT retval;
-
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = RT (nc, b_nc, 0.0);
   else
     {
@@ -461,24 +465,28 @@ dmsolve (const ST &a, const T &b, octave
           RT mtmp = qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1],
                                                  0, b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
 
-  return retval;
+#else
 
-#else
+  octave_unused_parameter (a);
+  octave_unused_parameter (b);
+  octave_unused_parameter (info);
 
   (*current_liboctave_error_handler)
     ("support for CXSparse was unavailable or disabled when liboctave was built");
 
 #endif
+
+  return retval;
 }
 
 // Instantiations we need.
 
 template ComplexMatrix
 dmsolve<ComplexMatrix, SparseComplexMatrix, Matrix>
   (const SparseComplexMatrix&, const Matrix&, octave_idx_type&);
 
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -548,16 +548,20 @@ sparse_lu<lu_type>::sparse_lu (const lu_
 
               umfpack_report_info<lu_elt_type> (control, info);
             }
         }
     }
 
 #else
 
+  octave_unused_parameter (a);
+  octave_unused_parameter (piv_thres);
+  octave_unused_parameter (scale);
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
 
 #endif
 }
 
 template <typename lu_type>
 sparse_lu<lu_type>::sparse_lu (const lu_type& a,
@@ -765,16 +769,25 @@ sparse_lu<lu_type>::sparse_lu (const lu_
     }
 
   if (udiag)
     (*current_liboctave_error_handler)
       ("Option udiag of incomplete LU not implemented");
 
 #else
 
+  octave_unused_parameter (a);
+  octave_unused_parameter (Qinit);
+  octave_unused_parameter (piv_thres);
+  octave_unused_parameter (scale);
+  octave_unused_parameter (FixedQ);
+  octave_unused_parameter (droptol);
+  octave_unused_parameter (milu);
+  octave_unused_parameter (udiag);
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
 
 #endif
 }
 
 template <typename lu_type>
 lu_type
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -195,16 +195,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
   if (! N)
     (*current_liboctave_error_handler)
       ("sparse_qr: sparse matrix QR factorization filled");
 
   count = 1;
 
 #else
 
+  octave_unused_parameter (order);
+
   (*current_liboctave_error_handler)
     ("sparse_qr: support for CXSparse was unavailable or disabled when liboctave was built");
 
 #endif
 }
 
 template <>
 sparse_qr<SparseMatrix>::sparse_qr_rep::~sparse_qr_rep (void)
@@ -284,16 +286,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
       ret.xridx (j) = N->U->i[j];
       ret.xdata (j) = N->U->x[j];
     }
 
   return ret;
 
 #else
 
+  octave_unused_parameter (econ);
+
   return SparseMatrix ();
 
 #endif
 }
 
 template <>
 Matrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::C (const Matrix& b) const
@@ -346,16 +350,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
             vec[i+idx] = buf[i];
         }
     }
 
   return ret;
 
 #else
 
+  octave_unused_parameter (b);
+
   return Matrix ();
 
 #endif
 }
 
 template <>
 Matrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::Q (void) const
@@ -470,16 +476,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return Matrix ();
 
 #endif
 }
 
 template <>
 template <>
 Matrix
@@ -536,16 +544,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return Matrix ();
 
 #endif
 }
 
 template <>
 template <>
 SparseMatrix
@@ -623,16 +633,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 SparseMatrix
@@ -716,16 +728,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
   info = 0;
 
   x.maybe_compress ();
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 ComplexMatrix
@@ -805,16 +819,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return ComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 ComplexMatrix
@@ -901,16 +917,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return ComplexMatrix ();
 
 #endif
 }
 
 // Complex-valued matrices.
 
 template <>
@@ -943,16 +961,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
   if (! N)
     (*current_liboctave_error_handler)
       ("sparse_qr: sparse matrix QR factorization filled");
 
   count = 1;
 
 #else
 
+  octave_unused_parameter (order);
+
   (*current_liboctave_error_handler)
     ("sparse_qr: support for CXSparse was unavailable or disabled when liboctave was built");
 
 #endif
 }
 
 template <>
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::~sparse_qr_rep (void)
@@ -1031,16 +1051,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
       ret.xridx (j) = N->U->i[j];
       ret.xdata (j) = reinterpret_cast<Complex *>(N->U->x)[j];
     }
 
   return ret;
 
 #else
 
+  octave_unused_parameter (econ);
+
   return SparseComplexMatrix ();
 
 #endif
 }
 
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::C (const ComplexMatrix& b) const
@@ -1087,16 +1109,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
             vec[i+idx] = buf[i];
         }
     }
 
   return ret;
 
 #else
 
+  octave_unused_parameter (b);
+
   return ComplexMatrix ();
 
 #endif
 }
 
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::Q (void) const
@@ -1261,16 +1285,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 SparseComplexMatrix
@@ -1380,16 +1406,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
   info = 0;
 
   x.maybe_compress ();
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 ComplexMatrix
@@ -1442,16 +1470,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return ComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 ComplexMatrix
@@ -1513,16 +1543,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return ComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 SparseComplexMatrix
@@ -1602,16 +1634,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
   info = 0;
 
   x.maybe_compress ();
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 SparseComplexMatrix
@@ -1699,16 +1733,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
   info = 0;
 
   x.maybe_compress ();
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 ComplexMatrix
@@ -1761,16 +1797,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return ComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 ComplexMatrix
@@ -1831,16 +1869,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
     }
 
   info = 0;
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return ComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 SparseComplexMatrix
@@ -1920,16 +1960,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
   info = 0;
 
   x.maybe_compress ();
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseComplexMatrix ();
 
 #endif
 }
 
 template <>
 template <>
 SparseComplexMatrix
@@ -2017,16 +2059,18 @@ sparse_qr<SparseComplexMatrix>::sparse_q
   info = 0;
 
   x.maybe_compress ();
 
   return x;
 
 #else
 
+  octave_unused_parameter (b);
+
   return SparseComplexMatrix ();
 
 #endif
 }
 
 template <typename SPARSE_T>
 sparse_qr<SPARSE_T>::sparse_qr (void)
   : rep (new sparse_qr_rep (SPARSE_T (), 0))
diff --git a/liboctave/util/sparse-util.cc b/liboctave/util/sparse-util.cc
--- a/liboctave/util/sparse-util.cc
+++ b/liboctave/util/sparse-util.cc
@@ -31,22 +31,31 @@ along with Octave; see the file COPYING.
 #include "oct-sparse.h"
 #include "sparse-util.h"
 
 static inline void
 sparse_chol_error_internal (int status, const char *file,
                             int line, const char *message)
 {
 #ifdef HAVE_CHOLMOD
+
   // Ignore CHOLMOD_NOT_POSDEF, since we handle that in Fchol as an
   // error or exit status.
   if (status != CHOLMOD_NOT_POSDEF)
     (*current_liboctave_warning_with_id_handler)
       ("Octave:cholmod-message", "warning %i, at line %i in file %s: %s",
        status, line, file, message);
+
+#else
+
+  octave_unused_parameter (status);
+  octave_unused_parameter (file);
+  octave_unused_parameter (line);
+  octave_unused_parameter (message);
+
 #endif
 }
 
 // FIXME: this overload is here due to API change in SuiteSparse (3.1 -> 3.2)
 
 void
 SparseCholError (int status, char *file, int line, char *message)
 {
diff --git a/oct-conf-post.in.h b/oct-conf-post.in.h
--- a/oct-conf-post.in.h
+++ b/oct-conf-post.in.h
@@ -49,16 +49,25 @@ along with Octave; see the file COPYING.
 #  define OCTAVE_UNUSED __attribute__ ((__unused__))
 #  define HAVE_OCTAVE_UNUSED_ATTR 1
 #else
 #  define OCTAVE_DEPRECATED(msg)
 #  define OCTAVE_NORETURN
 #  define OCTAVE_UNUSED
 #endif
 
+#if defined (__cplusplus)
+template <typename T>
+static inline void
+octave_unused_parameter (const T&)
+{ }
+#else
+#  define octave_unused_parameter(param) (void) param;
+#endif
+
 #if ! defined (HAVE_DEV_T)
 typedef short dev_t;
 #endif
 
 #if ! defined (HAVE_INO_T)
 typedef unsigned long ino_t;
 #endif
 
