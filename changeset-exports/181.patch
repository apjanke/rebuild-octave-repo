# HG changeset patch
# User jwe
# Date 751416351 0
#      Sat Oct 23 22:45:51 1993 +0000
# Node ID 91ec95436dca088cf0b641af9d6103f1444c10ef
# Parent  de63a156b36e8547361f2ab91ed4092fe7cfdf25
[project @ 1993-10-23 22:45:17 by jwe]

diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -10,17 +10,17 @@ TOPDIR = ..
 
 include $(TOPDIR)/Makeconf
 
 srcdir = @srcdir@
 VPATH = @srcdir@:@srcdir@/../bsd-math
 
 # Can this be fixed?
 
-INCFLAGS = -I. -I$(srcdir)/../liboctave -I$(srcdir)/../dld -I$(srcdir)/.. -I$(srcdir) -I$(TOPDIR)/liboctave -I$(TOPDIR)/dld -I$(TOPDIR)
+INCFLAGS = -I. -I$(srcdir)/../liboctave -I$(srcdir)/../dld -I$(srcdir)/../info -I$(srcdir)/.. -I$(srcdir) -I$(TOPDIR)/liboctave -I$(TOPDIR)/dld -I$(TOPDIR)/info  -I$(TOPDIR)
 
 LIBOBJS = @LIBOBJS@
 
 # Cancel default rule for .c from .y and make .cc from .y instead.
 
 %.c : %.y
 
 %.cc : %.y
@@ -58,29 +58,29 @@ LIBOBJS = @LIBOBJS@
 	    mv $@.tmp $@ ; \
 	else \
 	  $(CC) -MM $(CPPFLAGS) $(ALL_CFLAGS) $< | \
 	    sed -e 's/$*\.o/& $@/g' -e 's,$(srcdir)/,,g' > $@.tmp && \
 	    mv $@.tmp $@ ; \
 	fi
 
 INCLUDES = arith-ops.h builtins.h dynamic-ld.h defaults.h.in \
-	defaults.h error.h f-balance.h f-colloc.h f-dassl.h f-det.h \
-	f-eig.h f-expm.h f-fft.h f-fsolve.h f-fsqp.h f-givens.h \
+	defaults.h error.h f-balance.h f-chol.h f-colloc.h f-dassl.h \
+	f-det.h f-eig.h f-expm.h f-fft.h f-fsolve.h f-fsqp.h f-givens.h \
 	f-hess.h f-ifft.h f-inv.h f-lpsolve.h f-lsode.h f-lu.h \
 	f-npsol.h f-qpsol.h f-qr.h f-quad.h f-qzval.h f-rand.h \
 	f-schur.h f-svd.h f-syl.h file-io.h g-builtins.h getopt.h \
 	gripes.h help.h idx-vector.h input.h lex.h mappers.h \
 	missing-math.h octave.h octave-hist.h pager.h parse.h \
 	pr-output.h procstream.h sighandlers.h statdefs.h symtab.h \
 	sysdep.h t-builtins.h token.h tree-base.h tree-const.h tree.h \
 	unwind-prot.h user-prefs.h utils.h variables.h version.h \
 	xdiv.h xpow.h SLStack.h Stack.h
 
-SOURCES = arith-ops.cc builtins.cc dynamic-ld.cc error.cc \
+SOURCES = arith-ops.cc builtins.cc dynamic-ld.cc error.cc f-chol.cc \
 	f-colloc.cc f-balance.cc f-dassl.cc f-det.cc f-eig.cc \
 	f-expm.cc f-fft.cc f-fsolve.cc f-fsqp.cc f-givens.cc \
 	f-hess.cc f-ifft.cc f-inv.cc f-lpsolve.cc f-lsode.cc f-lu.cc \
 	f-npsol.cc f-qpsol.cc f-qr.cc f-quad.cc f-qzval.cc f-rand.cc \
 	f-schur.cc f-svd.cc f-syl.cc file-io.cc	g-builtins.cc \
 	getopt.c getopt1.c gripes.cc help.cc idx-vector.cc input.cc \
 	lex.l mappers.cc octave.cc octave-hist.cc pager.cc parse.y \
 	pr-output.cc procstream.cc sighandlers.cc symtab.cc \
@@ -89,32 +89,33 @@ SOURCES = arith-ops.cc builtins.cc dynam
 	tree-plot.cc unwind-prot.cc user-prefs.cc utils.cc \
 	variables.cc xdiv.cc xpow.cc
 
 DEP_SOURCES_2 = $(patsubst %.l, %.cc, $(SOURCES))
 DEP_SOURCES_1 = $(patsubst %.y, %.cc, $(DEP_SOURCES_2))
 DEP_SOURCES = $(patsubst %.c, %.d, $(DEP_SOURCES_1))
 MAKEDEPS = $(patsubst %.cc, %.d, $(DEP_SOURCES))
 
-DLD_OBJECTS = f-balance.o f-colloc.o f-dassl.o f-det.o f-eig.o \
-	f-expm.o f-fft.o f-fsolve.o f-fsqp.o f-givens.o f-hess.o \
-	f-ifft.o f-inv.o f-lpsolve.o f-lsode.o f-lu.o f-npsol.o \
-	f-qpsol.o f-qr.o f-quad.o f-qzval.o f-rand.o f-schur.o \
-	f-svd.o f-syl.o 
+DLD_OBJECTS = f-balance.o f-chol.o f-colloc.o f-dassl.o f-det.o \
+	f-eig.o f-expm.o f-fft.o f-fsolve.o f-fsqp.o f-givens.o \
+	f-hess.o f-ifft.o f-inv.o f-lpsolve.o f-lsode.o f-lu.o \
+	f-npsol.o f-qpsol.o f-qr.o f-quad.o f-qzval.o f-rand.o \
+	f-schur.o f-svd.o f-syl.o 
 
 OBJECTS = arith-ops.o builtins.o error.o file-io.o g-builtins.o \
 	getopt.o getopt1.o gripes.o help.o idx-vector.o input.o \
 	lex.o mappers.o octave.o octave-hist.o pager.o parse.o \
 	pr-output.o procstream.o sighandlers.o symtab.o sysdep.o \
 	t-builtins.o tc-assign.o tc-extras.o tc-index.o token.o \
 	tree.o tree-const.o tree-plot.o unwind-prot.o user-prefs.o \
 	utils.o variables.o xdiv.o xpow.o \
 	@DYNAMIC_LD_OBJ@
 
-OCTAVE_LIBS = ../liboctave.a ../libcruft.a ../libreadline.a @LIBDLD@
+OCTAVE_LIBS = ../liboctave.a ../libcruft.a ../libinfo.a \
+	../libreadline.a @LIBDLD@
 
 DISTFILES = Makefile.in move-if-change parse.cc lex.cc y.tab.h \
 	$(INCLUDES) $(SOURCES)
 
 all: defaults.h octave
 .PHONY: all
 
 octave: $(DLD_OBJECTS) $(OBJECTS) $(OCTAVE_LIBS) $(LIBOBJS)
@@ -171,12 +172,13 @@ dist: parse.cc lex.cc
 .PHONY: dist
 
 # Special rules -- these files need special things to be defined.
 
 defaults.h: ../Makeconf defaults.h.in
 	@echo "Making defaults.h from defaults.h.in..."
 	@(sed < $(srcdir)/defaults.h.in > defaults.h.tmp \
 	-e 's;%DEFAULT_PAGER%;\"${DEFAULT_PAGER}\";' \
+	-e 's;%DEFAULT_INFO_FILE%;\"${DEFAULT_INFO_FILE}\";' \
 	-e 's;%OCTAVE_HOME%;\"${prefix}\";')
 	@$(srcdir)/move-if-change defaults.h.tmp defaults.h
 
 include $(MAKEDEPS)
diff --git a/src/builtins.cc b/src/builtins.cc
--- a/src/builtins.cc
+++ b/src/builtins.cc
@@ -21,653 +21,693 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <iostream.h>
+#include <strstream.h>
 #include <math.h>
 #include <float.h>
 
 #include "tree-const.h"
 #include "symtab.h"
 #include "t-builtins.h"
 #include "g-builtins.h"
 #include "builtins.h"
 #include "octave.h"
 #include "utils.h"
 #include "tree.h"
 #include "help.h"
+#include "pager.h"
 #include "mappers.h"
 #include "user-prefs.h"
 #include "variables.h"
 
 // NOTE: nargin == 1 means that the function takes no arguments (just
 // like C, the first argument is (or should be, anyway) the function
 // name).  Also, -1 is shorthand for infinity.
 
 // The following initializations may eventually need to be reworked
 // like the builtin functions in bash were around version 1.12...
 
 static builtin_mapper_functions mapper_functions[] =
 {
   { "abs", 2, 1, 0, fabs, abs, NULL,
-    "compute abs(X) for each element of X\n", },
+    "abs (X): compute abs (X) for each element of X", },
 
   { "acos", 2, 1, 0, acos, NULL, acos,
-    "compute acos(X) for each element of X\n", },
+    "acos (X): compute acos (X) for each element of X", },
 
   { "acosh", 2, 1, 0, acosh, NULL, acosh,
-    "compute acosh(X) for each element of X\n", },
+    "acosh (X): compute acosh (X) for each element of X", },
 
   { "angle", 2, 1, 0, arg, arg, NULL,
-    "compute arg(X) for each element of X\n", },
+    "angle (X): compute arg (X) for each element of X", },
 
   { "arg", 2, 1, 0, arg, arg, NULL,
-    "compute arg(X) for each element of X\n", },
+    "arg (X): compute arg (X) for each element of X", },
 
   { "asin", 2, 1, 0, asin, NULL, asin,
-    "compute asin(X) for each element of X\n", },
+    "asin (X): compute asin (X) for each element of X", },
 
   { "asinh", 2, 1, 0, asinh, NULL, asinh,
-    "compute asinh(X) for each element of X\n", },
+    "asinh (X): compute asinh (X) for each element of X", },
 
   { "atan", 2, 1, 0, atan, NULL, atan,
-    "compute atan(X) for each element of X\n", },
+    "atan (X): compute atan (X) for each element of X", },
 
   { "atanh", 2, 1, 0, atanh, NULL, atanh,
-    "compute atanh(X) for each element of X\n", },
+    "atanh (X): compute atanh (X) for each element of X", },
 
   { "ceil", 2, 1, 0, ceil, NULL, ceil,
-    "ceil(X): round elements of X toward +Inf\n", },
+    "ceil (X): round elements of X toward +Inf", },
 
   { "conj", 2, 1, 0, conj, NULL, conj,
-    "compute complex conjugate for each element of X\n", },
+    "conj (X): compute complex conjugate for each element of X", },
 
   { "cos", 2, 1, 0, cos, NULL, cos,
-    "compute cos(X) for each element of X\n", },
+    "cos (X): compute cos (X) for each element of X", },
 
   { "cosh", 2, 1, 0, cosh, NULL, cosh,
-    "compute cosh(X) for each element of X\n", },
+    "cosh (X): compute cosh (X) for each element of X", },
 
   { "exp", 2, 1, 0, exp, NULL, exp,
-    "compute exp(X) for each element of X\n", },
+    "exp (X): compute exp (X) for each element of X", },
 
   { "finite", 2, 1, 0, xfinite, xfinite, NULL,
-    "finite(X): return 1 for finite elements of X\n", },
+    "finite (X): return 1 for finite elements of X", },
 
   { "fix", 2, 1, 0, fix, NULL, fix,
-    "fix(X): round elements of X toward zero\n", },
+    "fix (X): round elements of X toward zero", },
 
   { "floor", 2, 1, 0, floor, NULL, floor,
-    "floor(X): round elements of X toward -Inf\n", },
+    "floor (X): round elements of X toward -Inf", },
 
   { "isinf", 2, 1, 0, xisinf, xisinf, NULL,
-    "isinf(X): return 1 for elements of X infinite\n", },
+    "isinf (X): return 1 for elements of X infinite", },
 
   { "imag", 2, 1, 0, imag, imag, NULL,
-    "return imaginary part for each elements of X\n", },
+    "imag (X): return imaginary part for each elements of X", },
 
 #ifdef HAVE_ISNAN
   { "isnan", 2, 1, 0, xisnan, xisnan, NULL,
-    "isnan(X): return 1 where elements of X are NaNs\n", },
+    "isnan (X): return 1 where elements of X are NaNs", },
 #endif
 
   { "log", 2, 1, 1, log, NULL, log,
-    "compute log(X) for each element of X\n", },
+    "log (X): compute log (X) for each element of X", },
 
   { "log10", 2, 1, 1, log10, NULL, log10,
-    "compute log10(X) for each element of X\n", },
+    "log10 (X): compute log10 (X) for each element of X", },
 
   { "real", 2, 1, 0, real, real, NULL,
-    "return real part for each element of X\n", },
+    "real (X): return real part for each element of X", },
 
   { "round", 2, 1, 0, round, NULL, round,
-    "round(X): round elements of X to nearest integer\n", },
+    "round (X): round elements of X to nearest integer", },
 
   { "sign", 2, 1, 0, signum, NULL, signum,
-    "sign(X): apply signum function to elements of X\n", },
+    "sign (X): apply signum function to elements of X", },
 
   { "sin", 2, 1, 0, sin, NULL, sin,
-    "compute sin(X) for each element of X\n", },
+    "sin (X): compute sin (X) for each element of X", },
 
   { "sinh", 2, 1, 0, sinh, NULL, sinh,
-    "compute sinh(X) for each element of X\n", },
+    "sinh (X): compute sinh (X) for each element of X", },
 
   { "sqrt", 2, 1, 1, sqrt, NULL, sqrt,
-    "compute sqrt(X) for each element of X\n", },
+    "sqrt (X): compute sqrt (X) for each element of X", },
 
   { "tan", 2, 1, 0, tan, NULL, tan,
-    "compute tan(X) for each element of X\n", },
+    "tan (X): compute tan (X) for each element of X", },
 
   { "tanh", 2, 1, 0, tanh, NULL, tanh,
-    "compute tanh(X) for each element of X\n", },
+    "tanh (X): compute tanh (X) for each element of X", },
 
   { NULL, -1, -1, -1, NULL, NULL, NULL, NULL, },
 };
 
 static builtin_text_functions text_functions[] =
 {
   { "casesen", 2, builtin_casesen,
-    "print warning if user tries to change case sensitivity\n", },
+    "casesen [on|off]", },
 
   { "cd", 2, builtin_cd,
-    "change current working directory\n", },
+    "cd [dir]\n\n\
+change current working directory\n\
+if no arguments are given, the current directory is changed to the\n\
+users home directory", },
 
   { "clear", -1, builtin_clear,
-    "clear symbol(s) matching a list of regular expressions\n", },
+    "clear [name ...]\n\n\
+clear symbol(s) matching a list of regular expressions\n\
+if no arguments are given, clear all user-defined variables and functions", },
 
   { "dir", -1, builtin_ls,
-    "print a directory listing\n", },
+    "dir [options]\n\nprint a directory listing", },
 
   { "document", -1, builtin_document,
-    "define help string for symbol\n", },
+    "document symbol string ...\n\n", },
 
   { "edit_history", -1, builtin_edit_history,
-    "usage: edit_history [first] [last]\n", },
+    "edit_history [first] [last]\n\nedit commands from the history list", },
 
   { "format", -1, builtin_format,
-    "set output formatting style\n", },
+    "format [style]\n\nset output formatting style", },
 
   { "help", -1, builtin_help,
-    "print cryptic yet witty messages\n", },
+    "help [-i] [topic ...]\n\nprint cryptic yet witty messages", },
 
   { "history", -1, builtin_history,
-    "print/save/load command history\n", },
+    "history [N] [-w file] [-r file] [-q]\n\n\
+display, save, or load command history", },
 
   { "load", -1, builtin_load,
-    "load variables from a file\n", },
+    "load [-force] file\n\nload variables from a file", },
 
   { "ls", -1, builtin_ls,
-    "print a directory listing\n", },
+    "ls [options]\n\nprint a directory listing", },
 
   { "run_history", -1, builtin_run_history,
-    "usage: run_history [first] [last]\n", },
+    "run_history [first] [last]\n\nrun commands from the history list", },
 
   { "save", -1, builtin_save,
-    "save variables to a file\n", },
+    "save file [var ...]\n\nsave variables in a file", },
 
   { "set", -1, builtin_set,
-    "set plotting options\n", },
+    "set [options]\n\nset plotting options", },
 
   { "show", -1, builtin_show,
-    "show plotting options\n", },
+    "show [options]\n\nshow plotting options", },
 
   { "who", -1, builtin_who,
-    "list symbols\n", },
+    "who [-global] [-top] [-local] [-all] [-fcn] [name ...]\n\n\
+list symbol(s) matching a list of regular expressions\n\
+if no arguments are given, the list of local symbols is printed", },
 
   { NULL, -1, NULL, NULL, },
 };
 
 static builtin_general_functions general_functions[] =
 {
   { "all", 2, 1, builtin_all,
-    "all(X): are all elements of X nonzero?\n", },
+    "all (X): are all elements of X nonzero?", },
 
   { "any", 2, 1, builtin_any,
-    "any(X): are any elements of X nonzero?\n", },
+    "any (X): are any elements of X nonzero?", },
 
   { "balance", 4, 4, builtin_balance,
-    "balancing for algebraic and generalized eigenvalue prblems\n\
-Usage: \n\
-  algebraic eigenvalues problem:\n\
-    aa = balance(a{,opt}) or [{dd,}aa] =  balance(a{,opt})\n\
+    "aa = balance (a [, opt]) or [[dd,] aa] =  balance (a [, opt])\n\
   generalized eigenvalue problem:\n\
-    [cc, dd, aa, bb] = balance (a, b {,opt})\n\
-where 'opt' is an optional single character argument as follows: \n\
-  'N' or 'n': no balancing; arguments copied, transformation(s) \n\
+    [cc, dd, aa, bb] = balance (a, b [, opt])\n\
+where \"opt\" is an optional single character argument as follows: \n\
+  \"N\" or \"n\": no balancing; arguments copied, transformation(s) \n\
               set to identity\n\
-  'P' or 'p': permute argument(s) to isolate eigenvalues where possible\n\
-  'S' or 's': scale to improve accuracy of computed eigenvalues\n\
-  'B' or 'b': (default) permute and scale, in that order. Rows/columns of a \n\
+  \"P\" or \"p\": permute argument(s) to isolate eigenvalues where possible\n\
+  \"S\" or \"s\": scale to improve accuracy of computed eigenvalues\n\
+  \"B\" or \"b\": (default) permute and scale, in that order. Rows/columns of a \n\
               (and b) that are isolated by permutation are not scaled\n\
 [dd, aa] = balance (a, opt) returns aa = dd\a*dd,\n\
-[cc, dd, aa, bb] = balance (a, b, opt) returns aa (bb) = cc*a*dd (cc*b*dd)\n", },
+[cc, dd, aa, bb] = balance (a, b, opt) returns aa (bb) = cc*a*dd (cc*b*dd)", },
+
+  { "chol", 2, 1, builtin_chol,
+    "chol (X): cholesky factorization", },
 
   { "clc", 1, 0, builtin_clc,
-    "clear screen\n", },
+    "clc (): clear screen", },
 
   { "clock", 1, 0, builtin_clock,
-    "return current date and time in vector\n", },
+    "clock (): return current date and time in vector", },
 
   { "closeplot", 1, 0, builtin_closeplot,
-    "close the stream to plotter\n", },
+    "closeplot (): close the stream to plotter", },
 
   { "colloc", 7, 4, builtin_colloc,
-    "[r, A, B, q] = colloc (n [, 'left'] [, 'right']): collocation weights\n", },
+    "[r, A, B, q] = colloc (n [, \"left\"] [, \"right\"]): collocation weights", },
 
   { "cumprod", 2, 1, builtin_cumprod,
-    "cumprod (X): cumulative products\n", },
+    "cumprod (X): cumulative products", },
 
   { "cumsum", 2, 1, builtin_cumsum,
-    "cumsum (X): cumulative sums\n", },
+    "cumsum (X): cumulative sums", },
 
   { "dassl", 5, 1, builtin_dassl,
-    "solve DAEs using Petzold's DASSL.  Usage:\n\
-\n\
-  dassl ('function_name', x_0, xdot_0, t_out)\n\
-  dassl ('function_name', x_0, xdot_0, t_out, t_crit)\n\
+    "dassl (\"function_name\", x_0, xdot_0, t_out)\n\
+  dassl (\"function_name\", x_0, xdot_0, t_out, t_crit)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of residuals.  It must have the form\n\
 \n\
   res = f (x, xdot, t)\n\
 \n\
-where x, xdot, and res are vectors, and t is a scalar.\n\n", },
+where x, xdot, and res are vectors, and t is a scalar.", },
 
   { "date", 1, 0, builtin_date,
-    "return current date in a string\n", },
+    "date (): return current date in a string", },
 
   { "det", 2, 1, builtin_det,
-    "det(X): determinant of a square matrix\n", },
+    "det (X): determinant of a square matrix", },
 
   { "diag", 3, 1, builtin_diag,
-    "diag(X [,k]): form/extract diagonals\n", },
+    "diag (X [,k]): form/extract diagonals", },
 
   { "disp", 3, 1, builtin_disp,
-    "disp(X): display value\n", },
+    "disp (X): display value", },
 
   { "eig", 2, 1, builtin_eig,
-    "eig (x): compute eigenvalues and eigenvectors of x\n", },
+    "eig (x) or [v, d] = eig (x): compute eigenvalues and eigenvectors of x", },
 
   { "error", 2, 1, builtin_error,
-    "print message and jump to top level\n", },
+    "error (\"message\"): print message and jump to top level", },
 
   { "eval", 2, 1, builtin_eval,
-    "evaluate text as octave source\n", },
+    "eval (\"string\"): evaluate text as octave source", },
 
   { "exist", 2, 1, builtin_exist,
-    "check if variable or file exists\n", },
+    "exist (\"name\"): check if variable or file exists", },
 
   { "exit", 1, 0, builtin_quit,
-    "exit Octave gracefully\n", },
+    "exit (): exit Octave gracefully", },
 
   { "expm", 2, 1, builtin_expm,
-    "Matrix exponential, e^A\n", },
+    "expm (X): matrix exponential, e^A", },
 
   { "eye", 3, 1, builtin_eye,
-    "create an identity matrix\n", },
+    "eye (n), eye (n, m), eye (X): create an identity matrix", },
 
   { "fclose", 2, 1, builtin_fclose,
-    "fclose('filename' or filenum): close a file\n", },
+    "fclose (\"filename\" or filenum): close a file", },
 
   { "feval", -1, 1, builtin_feval,
-    "evaluate argument as function\n", },
+    "feval (\"name\", args, ...): evaluate first argument as function", },
 
   { "fflush", 2, 1, builtin_fflush,
-    "fflush('filename' or filenum): flush buffered data to output file\n", },
+    "fflush (\"filename\" or filenum): flush buffered data to output file", },
 
   { "fft", 2, 1, builtin_fft,
-    "fft(X): fast fourier transform of a vector\n", },
+    "fft (X): fast fourier transform of a vector", },
 
   { "fgets",3, 2, builtin_fgets,
-    "[string, length] = fgets('filename' or filenum, length): read a string from a file\n", },
+    "[string, length] = fgets (\"filename\" or filenum, length): read a string from a file", },
 
   { "find", -1, 1, builtin_find,
-    "find (x): return vector of indices of nonzero elements\n", },
+    "find (x): return vector of indices of nonzero elements", },
 
   { "flops", 2, 1, builtin_flops,
-    "count floating point operations\n", },
+    "flops (): count floating point operations", },
 
   { "fopen", 3, 1, builtin_fopen,
-    "filenum = fopen('filename','mode'): open a file\n", },
+    "filenum = fopen (\"filename\", \"mode\"): open a file\n\n\
+ Legal values for mode include:\n\n\
+   r  : open text file for reading\n\
+   w  : open text file for writing; discard previous contents if any\n\
+   a  : append; open or create text file for writing at end of file\n\
+   r+ : open text file for update (i.e., reading and writing)\n\
+   w+ : create text file for update; discard previous contents if any\n\
+   a+ : append; open or create text file for update, writing at end\n\n\
+ Update mode permits reading from and writing to the same file.\n", },
 
   { "fprintf", -1, 1, builtin_fprintf,
-    "fprintf ('file', 'fmt', ...)\n", },
+    "fprintf (\"file\", \"fmt\", ...)", },
 
   { "freport", 1, 1, builtin_freport,
-    "freport: list open files and their status\n", },
+    "freport (): list open files and their status", },
 
   { "frewind", 2, 1, builtin_frewind,
-    "frewind('filename' or filenum): set file position at beginning of file\n", },
+    "frewind (\"filename\" or filenum): set file position at beginning of file", },
 
   { "fscanf", 3, -1, builtin_fscanf,
-    "[a,b,c...] = fscanf ('file', 'fmt')\n", },
+    "[a, b, c, ...] = fscanf (\"file\", \"fmt\")", },
 
   { "fseek", 4, 1, builtin_fseek,
-    "fseek('filename' or filenum): set file position for reading or writing\n", },
+    "fseek (\"filename\" or filenum, offset [, origin]): set file position for reading or writing", },
 
   { "fsolve", 5, 1, builtin_fsolve,
     "Solve nonlinear equations using Minpack.  Usage:\n\
 \n\
-  [x, info] = fsolve ('f', x0)\n\
+  [x, info] = fsolve (\"f\", x0)\n\
 \n\
 Where the first argument is the name of the  function to call to\n\
 compute the vector of function values.  It must have the form\n\
 \n\
   y = f (x)
 \n\
-where y and x are vectors.\n\n", },
+where y and x are vectors.", },
 
   { "fsqp", 11, 3, builtin_fsqp,
-    "solve NLPs\n", },
+#if defined (FSQP_MISSING)
+    "This function requires FSQP, which is not freely\n\
+       redistributable.  For more information, read the file\n\
+       libcruft/fsqp/README.MISSING in the source distribution.", },
+#else
+  "[x, phi] = fsqp (x, \"phi\" [, lb, ub] [, lb, A, ub] [, lb, \"g\", ub])\n\n\
+  Groups of arguments surrounded in `[]' are optional, but\n\
+  must appear in the same relative order shown above.", },
+#endif
 
   { "ftell", 2, 1, builtin_ftell,
-    "position = ftell ('filename' or filenum): returns the current file position\n", },
+    "position = ftell (\"filename\" or filenum): returns the current file position", },
 
   { "getenv", 2, 1, builtin_getenv,
-    "get environment variable values\n", },
+    "getenv (\"string\"): get environment variable values", },
 
   { "givens", 3, 2, builtin_givens,
-    "Givens rotation:\n\
-  G = givens(x,y) returns an orthogonal matrix G = [c s; -conj(s) c] such\n\
-    that G[x;y] = [*;0]  (x,y scalars)\n\
-  [c,s] = givens(x,y) returns the (c,s) values themselves.",},
+    "G = givens (x, y): compute orthogonal matrix G = [c s; -conj (s) c]\n\
+      such that G [x; y] = [*; 0]  (x, y scalars)\n\n\
+      [c, s] = givens (x, y) returns the (c, s) values themselves.", },
   
 
   { "hess", 2, 2, builtin_hess,
-    "Hessenberg decomposition\n",},
+    "[P, H] = hess (A) or H = hess (A): Hessenberg decomposition", },
 
   { "home", 1, 0, builtin_clc,
-    "clear screen\n", },
+    "home (): clear screen", },
 
   { "input", 3, 1, builtin_input,
-    "input('prompt' [,'s']): prompt user for [string] input\n", },
+    "input (\"prompt\" [, \"s\"]): prompt user for [string] input", },
 
   { "ifft", 2, 1, builtin_ifft,
-    "ifft(X): inverse fast fourier transform of a vector\n", },
+    "ifft (X): inverse fast fourier transform of a vector", },
 
   { "inv", 2, 1, builtin_inv,
-    "inv(X): inverse of a square matrix\n", },
+    "inv (X): inverse of a square matrix", },
 
   { "inverse", 2, 1, builtin_inv,
-    "inverse(X): inverse of a square matrix\n", },
+    "inverse (X): inverse of a square matrix", },
 
   { "isstr", 2, 1, builtin_isstr,
-    "isstr(X): return 1 if X is a string\n", },
+    "isstr (X): return 1 if X is a string", },
 
   { "keyboard", 2, 1, builtin_keyboard,
-    "maybe help in debugging M-files\n", },
+    "keyboard (\"prompt\"): maybe help in debugging M-files", },
 
   { "logm", 2, 1, builtin_logm,
-    "Matrix logarithm, log (A)\n", },
+    "logm (x): matrix logarithm", },
 
-  { "lpsolve", 11, 3, builtin_lpsolve,
-    "Solve linear programs using lp_solve.\n", },
+  { "lp_solve", 11, 3, builtin_lpsolve,
+    "lp_solve (): solve linear programs using lp_solve.", },
 
   { "lsode", 6, 1, builtin_lsode,
-    "solve ODEs using Hindmarsh's LSODE.  Usage:\n\
-\n\
-  lsode ('function_name', x0, t_out\n\
-  lsode ('function_name', x0, t_out, t_crit)\n\
+    "lsode (\"function_name\", x0, t_out, t_crit)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of right hand sides.  It must have the form\n\
 \n\
   xdot = f (x, t)\n\
 \n\
-where xdot and x are vectors and t is a scalar.\n\n", },
+where xdot and x are vectors and t is a scalar.\n", },
 
   { "lu", 2, 3, builtin_lu,
-    "[L, U, P] = lu (A) -- LU factorization\n", },
+    "[L, U, P] = lu (A): LU factorization", },
 
   { "max", 3, 2, builtin_max,
-    "maximum value(s) of a vector (matrix)\n", },
+    "max (x): maximum value(s) of a vector (matrix)", },
 
   { "min", 3, 2, builtin_min,
-    "minimum value(s) of a vector (matrix)\n", },
+    "min (x): minimum value(s) of a vector (matrix)", },
 
   { "npsol", 11, 3, builtin_npsol,
-    "Solve nonlinear programs using Gill and Murray's NPSOL.  Usage:\n\
-\n\
-  [x, obj, info, lambda] = npsol (x, 'phi' [, lb, ub] [, lb, A, ub] [, lb, 'g', ub])\n\n\
-Groups of arguments surrounded in `[]' are optional, but\n\
-must appear in the same relative order shown above.\n\
+#if defined (NPSOL_MISSING)
+    "This function requires NPSOL, which is not freely\n\
+       redistributable.  For more information, read the file\n\
+       libcruft/npsol/README.MISSING in the source distribution.", },
+#else
+    "[x, obj, info, lambda] = npsol (x, \"phi\" [, lb, ub] [, lb, A, ub] [, lb, \"g\", ub])\n\n\
+  Groups of arguments surrounded in `[]' are optional, but\n\
+  must appear in the same relative order shown above.\n\
 \n\
-The second argument is a string containing the name of the objective\n\
-function to call.  The objective function must be of the form\n\
+  The second argument is a string containing the name of the objective\n\
+  function to call.  The objective function must be of the form\n\
 \n\
-  y = phi (x)\n\
+    y = phi (x)\n\
 \n\
-where x is a vector and y is a scalar.\n\n", },
+  where x is a vector and y is a scalar.", },
+#endif
 
   { "ones", 3, 1, builtin_ones,
-    "create a matrix of all ones\n", },
+    "ones (n), ones (n, m), ones (x): create a matrix of all ones", },
 
   { "pause", 1, 0, builtin_pause,
-    "suspend program execution\n", },
+    "pause (seconds): suspend program execution", },
 
   { "purge_tmp_files", 5, 1, builtin_purge_tmp_files,
-    "delete temporary data files used for plotting\n", },
+    "delete temporary data files used for plotting", },
 
   { "printf", -1, 1, builtin_printf,
-    "printf ('fmt', ...)\n", },
+    "printf (\"fmt\", ...)", },
 
   { "prod", 2, 1, builtin_prod,
-    "prod (X): products\n", },
+    "prod (X): products", },
 
   { "pwd", 1, 0, builtin_pwd,
-    "print current working directory\n", },
+    "pwd (): print current working directory", },
 
   { "qpsol", 9, 3, builtin_qpsol,
-    "Solve nonlinear programs using Gill and Murray's QPSOL.  Usage:\n\
-\n\
-  [x, obj, info, lambda] = qpsol (x, H, c [, lb, ub] [, lb, A, ub])\n\
+#if defined (QPSOL_MISSING)
+    "This function requires QPSOL, which is not freely\n\
+       redistributable.  For more information, read the file\n\
+       libcruft/qpsol/README.MISSING in the source distribution.", },
+#else
+    "[x, obj, info, lambda] = qpsol (x, H, c [, lb, ub] [, lb, A, ub])\n\
 \n\
   Groups of arguments surrounded in `[]' are optional, but\n\
   must appear in the same relative order shown above.", },
+#endif
 
   { "qr", 2, 2, builtin_qr,
-    "[q, r] = qr (X): form QR factorization of X\n", },
+    "[q, r] = qr (X): form QR factorization of X", },
 
   { "quad", 6, 3, builtin_quad,
-    "Integrate a nonlinear function of one variable using Quadpack.\n\
-Usage:\n\
-\n\
-  [v, ier, nfun] = quad ('f', a, b [, tol] [, sing])\n\
+    "[v, ier, nfun] = quad (\"f\", a, b [, tol] [, sing])\n\
 \n\
 Where the first argument is the name of the  function to call to\n\
 compute the value of the integrand.  It must have the form\n\
 \n\
   y = f (x)
 \n\
 where y and x are scalars.\n\
 \n\
 The second and third arguments are limits of integration.  Either or\n\
 both may be infinite.  The optional argument tol specifies the desired\n\
 accuracy of the result.  The optional argument sing is a vector of\n\
-at which the integrand is singular.\n\n", },
+at which the integrand is singular.\n", },
 
   { "quit", 1, 0, builtin_quit,
-    "exit Octave gracefully\n", },
+    "quit (): exit Octave gracefully", },
 
   { "qzval", 3, 1, builtin_qzval,
-    "x = qzval(a,b): compute generalized eigenvalues\n", },
+    "x = qzval (A,B): compute generalized eigenvalues of \n\
+  the matrix pencil (A - lambda B).  A and B must be real matrices.", },
 
   { "rand", 2, 1, builtin_rand,
-    "matrices with random elements\n", },
+    "rand                  -- generate a random value\n\
+       rand (n)              -- generate N x N matrix\n\
+       rand (A)              -- generate matrix the size of A\n\
+       rand (n, m)           -- generate N x M matrix\n\
+       rand (\"dist\")         -- get current distribution\n\
+       rand (\"distribution\") -- set distribution\n\
+       rand (\"seed\")         -- get current seed\n\
+       rand (\"seed\", n)      -- set seed", },
 
   { "replot", 1, 0, builtin_replot,
-    "redisplay current plot\n", },
+    "replot (): redisplay current plot", },
 
   { "scanf", 2, -1, builtin_scanf,
-    "[a,b,c...] = scanf ('fmt')\n", },
+    "[a, b, c, ...] = scanf (\"fmt\")", },
 
   { "setstr", 2, 1, builtin_setstr,
-    "setstr (v): convert a vector to a string\n", },
+    "setstr (v): convert a vector to a string", },
 
   { "shell_cmd", 2, 1, builtin_shell_command,
-    "shell_cmd (string [, return_output]): execute shell commands\n", },
+    "shell_cmd (string [, return_output]): execute shell commands", },
 
   { "schur", 3, 2, builtin_schur,
-    "returns the Schur (straight or ordered) decomposition of matrix\n", },
+    "[U, S] = schur (A) or S = schur (A)\n\n\
+ or, for ordered Schur:\n\n\
+       [U, S] = schur (A, \"A, D, or U\") or S = schur (A, \"A, D, or U\")\n\
+ where:\n\n\
+   A = continuous time poles\n\
+   D = discrete time poles\n\
+   U = unordered schur (default)", },
+
 
   { "size", 2, 1, builtin_size,
-    "size(X): return rows and columns of X\n", },
+    "[m, n] = size (x): return rows and columns of X", },
 
   { "sort", 2, 2, builtin_sort,
-    "[s,i] = sort(x): sort the columns of x, optionally return sort index\n", },
+    "[s, i] = sort (x): sort the columns of x, optionally return sort index", },
 
   { "sqrtm", 2, 1, builtin_sqrtm,
-    "Matrix sqrt, sqrt (A)\n", },
+    "sqrtm (x): matrix sqrt", },
 
   { "sprintf", -1, 1, builtin_sprintf,
-    "s = sprintf ('fmt', ...)\n", },
+    "s = sprintf (\"fmt\", ...)", },
 
   { "sscanf", 3, -1, builtin_sscanf,
-    "[a,b,c...] = sscanf (string, 'fmt')\n", },
+    "[a, b, c, ...] = sscanf (string, \"fmt\")", },
 
   { "sum", 2, 1, builtin_sum,
-    "sum (X): sum of elements\n", },
+    "sum (X): sum of elements", },
 
   { "sumsq", 2, 1, builtin_sumsq,
-    "sumsq (X): sum of squares of elements\n", },
+    "sumsq (X): sum of squares of elements", },
 
   { "svd", 2, 3, builtin_svd,
-    "[U,S,V] = svd(X): return SVD of X\n", },
+    "s = svd (x) or [u, s, v] = svd (x): return SVD of x", },
 
   { "syl", 4, 1, builtin_syl,
-    "X = syl (A, B, C): solve the Sylvester equation A X + X B + C = 0\n", },
+    "X = syl (A, B, C): solve the Sylvester equation A X + X B + C = 0", },
 
   { "warranty", 1, 0, builtin_warranty,
-    "describe copying conditions\n", },
+    "warranty (): describe copying conditions", },
 
   { "zeros", 3, 1, builtin_zeros,
-    "create a matrix of all zeros\n", },
+    "zeros (n), zeros (n, m), zeros (x): create a matrix of all zeros", },
 
   { NULL, -1, -1, NULL, NULL, },
 };
 
 // This is a lie.  Some of these get reassigned to be numeric
 // variables.  See below.
 
 static builtin_string_variables string_variables[] =
 {
   { "I", "??", NULL,
-    "sqrt (-1)\n", },
+    "sqrt (-1)", },
 
   { "Inf", "??", NULL,
-    "infinity\n", },
+    "infinity", },
 
   { "J", "??", NULL,
-    "sqrt (-1)\n", },
+    "sqrt (-1)", },
 
 #if defined (HAVE_ISNAN)
   { "NaN", "??", NULL,
-    "not a number\n", },
+    "not a number", },
 #endif
 
   { "LOADPATH", "??", sv_loadpath,
-    "colon separated list of directories to search for scripts\n", },
+    "colon separated list of directories to search for scripts", },
 
   { "PAGER", "??", sv_pager_binary,
-    "path to pager binary\n", },
+    "path to pager binary", },
 
   { "PS1", "\\s:\\#> ", sv_ps1,
-    "primary prompt string\n", },
+    "primary prompt string", },
 
   { "PS2", "> ", sv_ps2,
-    "secondary prompt string\n", },
+    "secondary prompt string", },
 
   { "PWD", "??PWD??", sv_pwd,
-    "current working directory\n", },
+    "current working directory", },
 
   { "SEEK_SET", "??", NULL,
-    "used with fseek to position file relative to the beginning\n", },
+    "used with fseek to position file relative to the beginning", },
 
   { "SEEK_CUR", "??", NULL,
-    "used with fseek to position file relative to the current position\n", },
+    "used with fseek to position file relative to the current position", },
 
   { "SEEK_END", "??", NULL,
-    "used with fseek to position file relative to the end\n", },
+    "used with fseek to position file relative to the end", },
 
   { "do_fortran_indexing", "false", do_fortran_indexing,
-    "allow single indices for matrices\n", },
+    "allow single indices for matrices", },
 
   { "empty_list_elements_ok", "warn", empty_list_elements_ok,
-    "ignore the empty element in expressions like `a = [[], 1]'\n", },
+    "ignore the empty element in expressions like `a = [[], 1]'", },
 
   { "eps", "??", NULL,
-      "machine precision\n", },
+    "machine precision", },
 
   { "gnuplot_binary", "gnuplot", sv_gnuplot_binary,
-    "path to gnuplot binary\n", },
+    "path to gnuplot binary", },
 
   { "i", "??", NULL,
-    "sqrt (-1)\n", },
+    "sqrt (-1)", },
 
   { "implicit_str_to_num_ok", "false", implicit_str_to_num_ok,
-    "allow implicit string to number conversion\n", },
+    "allow implicit string to number conversion", },
 
   { "inf", "??", NULL,
-    "infinity\n", },
+    "infinity", },
 
   { "j", "??", NULL,
-    "sqrt (-1)\n", },
+    "sqrt (-1)", },
 
 #if defined (HAVE_ISNAN)
   { "nan", "??", NULL,
-    "not a number\n", },
+    "not a number", },
 #endif
 
   { "ok_to_lose_imaginary_part", "warn", ok_to_lose_imaginary_part,
-    "silently convert from complex to real by dropping imaginary part\n", },
+    "silently convert from complex to real by dropping imaginary part", },
 
   { "output_max_field_width", "??", set_output_max_field_width,
-    "maximum width of an output field for numeric output\n", },
+    "maximum width of an output field for numeric output", },
 
   { "output_precision", "??", set_output_precision,
-    "number of significant figures to display for numeric output\n", },
+    "number of significant figures to display for numeric output", },
 
   { "page_screen_output", "true", page_screen_output,
-    "if possible, send output intended for the screen through the pager\n", },
+    "if possible, send output intended for the screen through the pager", },
 
   { "pi", "??", NULL,
-    "ratio of the circumference of a circle to its diameter\n", },
+    "ratio of the circumference of a circle to its diameter", },
 
   { "prefer_column_vectors", "true", prefer_column_vectors,
-    "prefer column/row vectors\n", },
+    "prefer column/row vectors", },
 
   { "prefer_zero_one_indexing", "false", prefer_zero_one_indexing,
-    "when there is a conflict, prefer zero-one style indexing\n", },
+    "when there is a conflict, prefer zero-one style indexing", },
 
   { "print_answer_id_name", "true", print_answer_id_name,
-    "set output style to print `var_name = ...'\n", },
+    "set output style to print `var_name = ...'", },
 
   { "print_empty_dimensions", "true", print_empty_dimensions,
-    "also print dimensions of empty matrices\n", },
+    "also print dimensions of empty matrices", },
 
   { "propagate_empty_matrices", "true", propagate_empty_matrices,
-    "operations on empty matrices return an empty matrix, not an error\n", },
+    "operations on empty matrices return an empty matrix, not an error", },
 
   { "resize_on_range_error", "true", resize_on_range_error,
-    "enlarge matrices on assignment\n", },
+    "enlarge matrices on assignment", },
 
   { "return_last_computed_value", "false", return_last_computed_value,
     "if a function does not return any values explicitly, return the\n\
-last computed value\n", },
+last computed value", },
 
   { "silent_functions", "false", silent_functions,
-    "suppress printing results in called functions\n", },
+    "suppress printing results in called functions", },
 
   { "split_long_rows", "true", split_long_rows,
-    "split long matrix rows instead of wrapping\n", },
+    "split long matrix rows instead of wrapping", },
 
   { "stdin", "??", NULL,
-    "file number of the standard input stream\n", },
+    "file number of the standard input stream", },
 
   { "stdout", "??", NULL,
-    "file number of the standard output stream\n", },
+    "file number of the standard output stream", },
 
   { "stderr", "??", NULL,
-    "file number of the standard error stream\n", },
+    "file number of the standard error stream", },
 
   { "treat_neg_dim_as_zero", "false", treat_neg_dim_as_zero,
-    "convert negative dimensions to zero\n", },
+    "convert negative dimensions to zero", },
 
   { "warn_assign_as_truth_value", "true", warn_assign_as_truth_value,
-    "produce warning for assignments used as truth values\n", },
+    "produce warning for assignments used as truth values", },
 
   { "warn_comma_in_global_decl", "true", warn_comma_in_global_decl,
-    "produce warning for commas in global declarations\n", },
+    "produce warning for commas in global declarations", },
 
   { "warn_divide_by_zero", "true", warn_divide_by_zero,
-    "on IEEE machines, allow divide by zero errors to be suppressed\n", },
+    "on IEEE machines, allow divide by zero errors to be suppressed", },
 
   { NULL, NULL, NULL, NULL, },
 };
 
 static void
 make_eternal (const char *s)
 {
   symbol_record *sym_rec = curr_sym_tab->lookup (s, 0, 0);
@@ -1048,14 +1088,69 @@ builtin_variables_help (void)
     }
 
   hl[count].name = (char *) NULL;
   hl[count].help = (char *) NULL;
 
   return hl;
 }
 
+int
+help_from_list (ostrstream& output_buf, const help_list *list,
+		const char *string, int usage)
+{
+  char *name;
+  while ((name = list->name) != (char *) NULL)
+    {
+      if (strcmp (name, string) == 0)
+	{
+	  if (usage)
+	    output_buf << "\nusage: ";
+	  else
+	    {
+	      output_buf << "\n*** " << string << ":\n\n";
+	    }
+
+	  output_buf << list->help << "\n";
+
+	  return 1;
+	}
+      list++;
+    }
+  return 0;
+}
+
+void
+additional_help_message (ostrstream& output_buf)
+{
+  output_buf
+    << "\n"
+    << "Additional help for builtin functions, operators, and variables\n"
+    << "is available in the on-line version of the manual.\n"
+    << "\n"
+    << "Use the command `help -i <topic>' to search the manual index.\n";
+}
+
+void
+print_usage (const char *string)
+{
+  ostrstream output_buf;
+
+  help_list *gf_help_list = builtin_general_functions_help ();
+  help_list *tf_help_list = builtin_text_functions_help ();
+  help_list *mf_help_list = builtin_mapper_functions_help ();
+
+  if (help_from_list (output_buf, gf_help_list, string, 1)
+      || help_from_list (output_buf, tf_help_list, string, 1)
+      || help_from_list (output_buf, mf_help_list, string, 1))
+    {
+      additional_help_message (output_buf);
+      output_buf << ends;
+      maybe_page_output (output_buf);
+    }
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/builtins.h b/src/builtins.h
--- a/src/builtins.h
+++ b/src/builtins.h
@@ -23,16 +23,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_builtins_h)
 #define _builtins_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
+class ostrstream;
 class Complex;
 struct help_list;
 
 #ifndef MAPPER_FCN_TYPEDEFS
 #define MAPPER_FCN_TYPEDEFS 1
 
 typedef double (*d_d_Mapper)(double);
 typedef double (*d_c_Mapper)(const Complex&);
@@ -78,16 +79,24 @@ struct builtin_string_variables
 extern void install_builtins (void);
 extern int is_text_function_name (const char *s);
 
 extern help_list *builtin_mapper_functions_help (void);
 extern help_list *builtin_general_functions_help (void);
 extern help_list *builtin_text_functions_help (void);
 extern help_list *builtin_variables_help (void);
 
+extern int help_from_list (ostrstream& output_buf,
+			   const help_list *list, const char *string,
+			   int usage);
+
+extern void additional_help_message (ostrstream& output_buf);
+
+extern void print_usage (const char *s);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/g-builtins.cc b/src/g-builtins.cc
--- a/src/g-builtins.cc
+++ b/src/g-builtins.cc
@@ -42,16 +42,17 @@ Software Foundation, Inc.
 #include <fstream.h>
 #include <stdio.h>
 #include <sys/wait.h>
 #include <sys/param.h>
 #include <signal.h>
 #include <math.h>
 
 #include "f-balance.h"
+#include "f-chol.h"
 #include "f-colloc.h"
 #include "f-dassl.h"
 #include "f-det.h"
 #include "f-eig.h"
 #include "f-expm.h"
 #include "f-fft.h"
 #include "f-fsolve.h"
 #include "f-fsqp.h"
@@ -125,64 +126,86 @@ typedef RETSIGTYPE sig_handler (...);
 
 /*
  * Are all elements of a constant nonzero?
  */
 tree_constant *
 builtin_all (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("all (M)");
+    print_usage ("all");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].all ();
 	}
     }
+
   return retval;
 }
 
 /*
  * Are any elements of a constant nonzero?
  */
 tree_constant *
 builtin_any (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("any (M)");
+    print_usage ("any");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].any ();
 	}
     }
+
   return retval;
 }
 
 /*
  * Balancing for eigenvalue problems
  */
 tree_constant *
 builtin_balance (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin <= 1 || nargin > 4 || nargout < 1 || nargout > 4)
-    usage ("[{dd,} aa] = balance (a, {opt}) or \n\
-[{cc, dd,} aa, bb] = balance (a, b {,opt}), opt = 'P' or 'S'");
+    print_usage ("balance");
   else
     {
       DLD_BUILTIN (args, nargin, nargout, balance,
 		   retval = balance (args, nargin, nargout));
     }
+
+  return retval;
+}
+
+/*
+ * Cholesky factorization.
+ */
+tree_constant *
+builtin_chol (const tree_constant *args, int nargin, int nargout)
+{
+  tree_constant *retval = NULL_TREE_CONST;
+
+  if (nargin == 2 && nargout == 1)
+    DLD_BUILTIN (args, nargin, nargout, chol,
+                retval = chol (args, nargin, nargout);)
+  else
+    usage ("R = chol(A) \n");
+
   return retval;
 }
 
 /*
  * Clear the screen?
  */
 tree_constant *
 builtin_clc (const tree_constant *args, int nargin, int nargout)
@@ -236,88 +259,78 @@ builtin_closeplot (const tree_constant *
  * Collocation roots and weights.
  */
 tree_constant *
 builtin_colloc (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin < 2 || nargin > 4)
-    usage ("[r, A, B, q] = colloc (n [, \"left\"] [, \"right\"])");
+    print_usage ("colloc");
   else
     DLD_BUILTIN (args, nargin, nargout, colloc,
 		 retval = collocation_weights (args, nargin);)
 
   return retval;
 }
 
 /*
  * Cumulative sums and products.
  */
 tree_constant *
 builtin_cumprod (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("cumprod (M)");
+    print_usage ("cumprod");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].cumprod ();
 	}
     }
+
   return retval;
 }
 
 tree_constant *
 builtin_cumsum (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("cumsum (M)");
+    print_usage ("cumsum");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].cumsum ();
 	}
     }
+
   return retval;
 }
 
 /*
  * DAEs.
  */
-static void
-dassl_usage (void)
-{
-  usage ("dassl (\"function_name\", x_0, xdot_0, t_out\n\
-       dassl (\"function_name\", x_0, xdot_0, t_out, t_crit)\n\
-\n\
-       The first argument is the name of the function to call to\n\
-       compute the vector of residuals.  It must have the form\n\
-\n\
-         res = f (x, xdot, t)\n\
-\n\
-       where x, xdot, and res are vectors, and t is a scalar.");
-}
-
 tree_constant *
 builtin_dassl (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = new tree_constant [2];
 
   if ((nargin == 5 || nargin == 6) && nargout > 0)
     DLD_BUILTIN (args, nargin, nargout, dassl,
 		 retval = dassl (args, nargin, nargout);)
   else
-    dassl_usage ();
+    print_usage ("dassl");
 
   return retval;
 }
 
 /*
  * Time in a string.
  */
 tree_constant *
@@ -351,17 +364,17 @@ builtin_det (const tree_constant *args, 
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, det,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = determinant (args[1]);
 		 })
   else
-    usage ("det (a)");
+    print_usage ("det");
 
   return retval;
 }
 
 /*
  * Diagonal elements of a matrix.
  */
 tree_constant *
@@ -375,51 +388,50 @@ builtin_diag (const tree_constant *args,
       retval[0] = args[1].diag ();
     }
   else if (nargin == 3)
     {
       retval = new tree_constant [2];
       retval[0] = args[1].diag (args[2]);
     }
   else
-    usage ("diag (X [, k])");
+    print_usage ("diag");
 
   return retval;
 }
 
 /*
  * Display value without trimmings.
  */
 tree_constant *
 builtin_disp (tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     args[1].eval (1);
   else
-    usage ("disp (X)");
+    print_usage ("disp");
 
   return retval;
 }
 
 /*
  * Compute eigenvalues and eigenvectors.
  */
 tree_constant *
 builtin_eig (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && (nargout == 1 || nargout == 2))
     DLD_BUILTIN (args, nargin, nargout, eig,
 		 retval = eig (args, nargin, nargout);)
   else
-    usage ("lambda = eig (A)\n\
-       [v, d] = eig (A); d == diag (lambda)");
+    print_usage ("eig");
 
   return retval;
 }
 
 /*
  * Print error message and jump to top level.
  */
 tree_constant *
@@ -439,42 +451,46 @@ builtin_error (tree_constant *args, int 
 
 /*
  * Evaluate text argument as octave source.
  */
 tree_constant *
 builtin_eval (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin == 2)
     {
       int parse_status = 0;
       retval = new tree_constant [2];
       retval[0] = eval_string (args[1], parse_status);
     }
   else
-    usage ("eval (\"string\")");
+    print_usage ("eval");
+
   return retval;
 }
 
 /*
  * Check if variable or file exists.
  */
 tree_constant *
 builtin_exist (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin == 2 && args[1].is_string_type ())
     {
       int status = identifier_exists (args[1].string_value ());
       retval = new tree_constant [2];
       retval[0] = tree_constant ((double) status);
     }
   else
-    usage ("exist (\"string\")");
+    print_usage ("exist");
+
   return retval;
 }
 
 /*
  * Matrix exponential.
  */
 tree_constant *
 builtin_expm (const tree_constant *args, int nargin, int nargout)
@@ -483,17 +499,17 @@ builtin_expm (const tree_constant *args,
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, matrix_exp,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = matrix_exp (args[1]);
 		 })
   else
-    usage ("expm (A)");
+    print_usage ("expm");
 
   return retval;
 }
 
 /*
  * Identity matrix.
  */
 tree_constant *
@@ -507,62 +523,68 @@ builtin_eye (const tree_constant *args, 
       retval = new tree_constant [2];
       retval[0] = identity_matrix (args[1]);
       break;
     case 3:
       retval = new tree_constant [2];
       retval[0] = identity_matrix (args[1], args[2]);
       break;
     default:
-      usage ("eye (n)\n       eye (A)\n       eye (n, m)");
+      print_usage ("eye");
       break;
     }
+
   return retval;
 }
 
-
 /*
  * Closing a file
  */
 tree_constant *
 builtin_fclose (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("success = fclose (\"filename\" or filenum)");
+    print_usage ("fclose");
   else
     retval = fclose_internal (args);
+
   return retval;
 }
 
 /*
  * Evaluate first argument as a function.
  */
 tree_constant *
 builtin_feval (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin > 1)
     retval = feval (args, nargin, nargout);
   else
-    usage ("feval (\"function_name\" [, ...])");
+    print_usage ("feval");
+
   return retval;
 }
 
 /*
  * Flushing output to a file
  */
 tree_constant *
 builtin_fflush (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("success = fflush (\"filename\" or filenum)");
+    print_usage ("fflush");
   else
     retval = fflush_internal (args);
+
   return retval;
 }
 
 /*
  * Fast Fourier Transform
  */
 tree_constant *
 builtin_fft (const tree_constant *args, int nargin, int nargout)
@@ -571,256 +593,248 @@ builtin_fft (const tree_constant *args, 
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, fft,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = fft (args[1]);
 		 })
   else
-    usage ("fft (a)");
+    print_usage ("fft");
 
   return retval;
 }
 
 /*
  * get a string from a file
  */
 tree_constant *
 builtin_fgets (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 3  && nargout < 3)
-    usage ("string = fgets (\"filename\" or filenum, length)");
+    print_usage ("fgets");
   else
     retval = fgets_internal (args, nargout);
+
   return retval;
 }
 
 /*
  * Find nonzero elements.  This should probably only work if
  * do_fortran_indexing is true...
  */
 tree_constant *
 builtin_find (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin == 2)
     {
       retval = new tree_constant [2];
       retval[0] = find_nonzero_elem_idx (args[1]);
     }
   else
-    usage ("find (x)");
+    print_usage ("find");
+
   return retval;
 }
 
 /*
  * Don\'t really count floating point operations.
  */
 tree_constant *
 builtin_flops (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin > 2)
-    usage ("flops\n       flops (0)");
+    print_usage ("flops");
 
   warning ("flops always returns zero");
+
   retval = new tree_constant [2];
   retval[0] = tree_constant (0.0);
+
   return retval;
 }
 
 /*
  * Opening a file.
  */
 tree_constant *
 builtin_fopen (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 3)
-    {
-      usage ("filenum = fopen (\"file\", \"mode\")\n\n\
- Legal values for mode include:\n\n\
-   r  : open text file for reading\n\
-   w  : open text file for writing; discard previous contents if any\n\
-   a  : append; open or create text file for writing at end of file\n\
-   r+ : open text file for update (i.e., reading and writing)\n\
-   w+ : create text file for update; discard previous contents if any\n\
-   a+ : append; open or create text file for update, writing at end\n\n\
- Update mode permits reading from and writing to the same file.\n");
-      }
+    print_usage ("fopen");
   else
     retval = fopen_internal (args);
+
   return retval;
 }
 
 /*
  * Formatted printing to a file.
  */
 tree_constant *
 builtin_fprintf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin < 3)
-    usage ("fprintf (\"filename\" or filenum, \"fmt\" [, ...])");
+    print_usage ("fprintf");
   else
     retval = do_printf ("fprintf", args, nargin, nargout);
+
   return retval;
 }
 
 /*
  * rewind a file
  */
 tree_constant *
 builtin_frewind (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("success = frewind (\"filename\" or filenum)");
+    print_usage ("frewind");
   else
     retval = frewind_internal (args);
+
   return retval;
 }
 
 /*
  * report on open files
  */
 tree_constant *
 builtin_freport (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin > 1)
-    warning ("replot: ignoring extra arguments");
+    warning ("freport: ignoring extra arguments");
+
   retval = freport_internal ();
+
   return retval;
 }
 
 /*
  * Formatted reading from a file.
  */
 tree_constant *
 builtin_fscanf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2 && nargin != 3)
-    usage ("[...] = fscanf (\"file\", \"fmt\")");
+    print_usage ("fscanf");
   else
     retval = do_scanf ("fscanf", args, nargin, nargout);
+
   return retval;
 }
 
 /*
  * seek a point in a file for reading and/or writing 
  */
 tree_constant *
 builtin_fseek (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 3 && nargin != 4)
-    usage ("success = fseek (\"filename\" or filenum, offset [,origin])");
+    print_usage ("fseek");
   else
     retval = fseek_internal (args, nargin);
+
   return retval;
 }
 
 /*
  * Nonlinear algebraic equations.
  */
-static void
-fsolve_usage (void)
-{
-//  usage ("[x, status, path] = fsolve (\"f\", x0 [, opts] [, par] [, \"jac\"] [, scale])");
-
-  usage ("[x, info] = fsolve (\"f\", x0)");
-}
-
 tree_constant *
 builtin_fsolve (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin >= 3 && nargin <= 7 && nargout >= 1 && nargout <= 3)
     DLD_BUILTIN (args, nargin, nargout, fsolve,
 		 retval = fsolve (args, nargin, nargout);)
   else
-    fsolve_usage ();
+    print_usage ("fsolve");
 
   return retval;
 }
 
 /*
  * NLPs.
  */
-static void
-fsqp_usage (void)
-{
-#if defined (FSQP_MISSING)
-  message ("fsqp", "this function requires FSQP, which is not freely\n\
-      redistributable.  For more information, read the file\n\
-      libcruft/fsqp/README.MISSING in the source distribution.");
-#else
-  usage ("[x, phi] = fsqp (x, \"phi\" [, lb, ub] [, lb, A, ub] [, lb, \"g\", ub])\n\n\
-  Groups of arguments surrounded in `[]' are optional, but\n\
-  must appear in the same relative order shown above.");
-#endif
-}
-
 tree_constant *
 builtin_fsqp (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 #if defined (FSQP_MISSING)
-  fsqp_usage ();
+  print_usage ("fsolve");
 #else
   if ((nargin == 3 || nargin == 5 || nargin == 6 || nargin == 8
        || nargin == 9 || nargin == 11)
       && (nargout >= 1 && nargout <= 3))
     DLD_BUILTIN (args, nargin, nargout, fsqp,
 		 retval = fsqp (args, nargin, nargout);)
   else
-    fsqp_usage ();
+    print_usage ("fsolve");
 #endif
 
   return retval;
 }
 
 /*
  * tell current position of file
  */
 tree_constant *
 builtin_ftell (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("position = ftell (\"filename\" or filenumber)");
+    print_usage ("ftell");
   else
     retval = ftell_internal (args);
+
   return retval;
 }
 
 /*
  * Get the value of an environment variable.
  */
 tree_constant *
 builtin_getenv (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin == 2 && args[1].is_string_type ())
     {
       retval = new tree_constant [2];
       char *value = getenv (args[1].string_value ());
       if (value != (char *) NULL)
 	retval[0] = tree_constant (value);
       else
 	retval[0] = tree_constant ("");
     }
   else
-    usage ("getenv (\"string\")");
+    print_usage ("getenv");
+
   return retval;
 }
 
 /*
  * Inverse Fast Fourier Transform
  */
 tree_constant *
 builtin_ifft (const tree_constant *args, int nargin, int nargout)
@@ -829,17 +843,17 @@ builtin_ifft (const tree_constant *args,
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, ifft,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = ifft (args[1]);
 		 })
   else
-    usage ("ifft (a)");
+    print_usage ("ifft");
 
   return retval;
 }
 
 /*
  * Inverse of a square matrix.
  */
 tree_constant *
@@ -849,17 +863,17 @@ builtin_inv (const tree_constant *args, 
 
   if (nargin == 2)
     DLD_BUILTIN (args, nargin, nargout, inv,
 		 {
 		   retval = new tree_constant [2];
 		   retval[0] = inverse (args[1]);
 		 })
   else
-    usage ("inv (A)");
+    print_usage ("inv");
 
   return retval;
 }
 
 /*
  * Prompt user for input.
  */
 tree_constant *
@@ -868,38 +882,40 @@ builtin_input (const tree_constant *args
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 || nargin == 3)
     {
       retval = new tree_constant [2];
       retval[0] = get_user_input (args, nargin, nargout);
     }
   else
-    usage ("input (\"prompt\" [, \"s\"])");
+    print_usage ("input");
 
   return retval;
 }
 
 /*
  * Is the argument a string?
  */
 tree_constant *
 builtin_isstr (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("isstr (value)");
+    print_usage ("isstr");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].isstr ();
 	}
     }
+
   return retval;
 }
 
 /*
  * Maybe help in debugging.
  */
 tree_constant *
 builtin_keyboard (const tree_constant *args, int nargin, int nargout)
@@ -907,196 +923,154 @@ builtin_keyboard (const tree_constant *a
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 1 || nargin == 2)
     {
       retval = new tree_constant [2];
       retval[0] = get_user_input (args, nargin, nargout, 1);
     }
   else
-    usage ("keyboard (\"prompt\")");
+    print_usage ("keyboard");
 
   return retval;
 }
 
 /*
  * Matrix logarithm.
  */
 tree_constant *
 builtin_logm (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     retval = matrix_log (args[1]);
   else
-    usage ("logm (A)");
+    print_usage ("logm");
 
   return retval;
 }
 
 /*
  * LPs.
  */
-static void
-lpsolve_usage (void)
-{
-  usage ("[x, obj, info] = lpsolve (XXX FIXME XXX)");
-}
-
 tree_constant *
 builtin_lpsolve (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 // Force a bad value of inform, and empty matrices for x and phi.
   retval = new tree_constant [4];
   Matrix m;
   retval[0] = tree_constant (m);
   retval[1] = tree_constant (m);
   retval[2] = tree_constant (-1.0);
 
   if (nargin == 0)
     DLD_BUILTIN (args, nargin, nargout, lpsolve,
 		 retval = lpsolve (args, nargin, nargout);)
   else
-    lpsolve_usage ();
+    print_usage ("lp_solve");
 
   return retval;
 }
 
 /*
  * ODEs.
  */
-static void
-lsode_usage (void)
-{
-  usage ("lsode (\"function_name\", x0, t_out\n\
-       lsode (\"function_name\", x0, t_out, t_crit)\n\
-\n\
-       The first argument is the name of the function to call to\n\
-       compute the vector of right hand sides.  It must have the form\n\
-\n\
-         xdot = f (x, t)\n\
-\n\
-       where xdot and x are vectors and t is a scalar.");
-}
-
 tree_constant *
 builtin_lsode (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 4 || nargin == 5) && nargout == 1)
     DLD_BUILTIN (args, nargin, nargout, lsode,
 		 retval = lsode (args, nargin, nargout);)
   else
-    lsode_usage ();
+    print_usage ("lsode");
 
   return retval;
 }
 
 /*
  * LU factorization.
  */
 tree_constant *
 builtin_lu (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && nargout < 4)
     DLD_BUILTIN (args, nargin, nargout, lu,
 		 retval = lu (args[1], nargout);)
   else
-    usage ("[L, U, P] = lu (A)");
+    print_usage ("lu");
 
   return retval;
 }
 
 /*
  * Max values.
  */
 tree_constant *
 builtin_max (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 2 && (nargout == 1 || nargout == 2))
       || (nargin == 3 && nargout == 1))
     retval = column_max (args, nargin, nargout);
   else
-    usage ("[X, I] = max (A)\n        X = max (A)\n        X = max (A, B)");
+    print_usage ("max");
 
   return retval;
 }
 
 /*
  * Min values.
  */
 tree_constant *
 builtin_min (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 2 && (nargout == 1 || nargout == 2))
       || (nargin == 3 && nargout == 1))
     retval = column_min (args, nargin, nargout);
   else
-    usage ("[X, I] = min (A)\n        X = min (A)\n        X = min (A, B)");
+    print_usage ("min");
 
   return retval;
 }
 
 /*
  * NLPs.
  */
-static void
-npsol_usage (void)
-{
-#if defined (NPSOL_MISSING)
-  message ("npsol", "this function requires NPSOL, which is not freely\n\
-       redistributable.  For more information, read the file\n\
-       libcruft/npsol/README.MISSING in the source distribution.");
-#else
-  usage ("\n\n\
-  [x, obj, info, lambda] = npsol (x, \"phi\" [, lb, ub] [, lb, A, ub] [, lb, \"g\", ub])\n\n\
-  Groups of arguments surrounded in `[]' are optional, but\n\
-  must appear in the same relative order shown above.\n\
-\n\
-  The second argument is a string containing the name of the objective\n\
-  function to call.  The objective function must be of the form\n\
-\n\
-    y = phi (x)\n\
-\n\
-  where x is a vector and y is a scalar.");
-#endif
-}
-
 tree_constant *
 builtin_npsol (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 #if defined (NPSOL_MISSING)
 // Force a bad value of inform, and empty matrices for x, phi, and lambda.
   retval = new tree_constant [4];
   Matrix m;
   retval[0] = tree_constant (m);
   retval[1] = tree_constant (m);
   retval[2] = tree_constant (-1.0);
   retval[3] = tree_constant (m);
-  npsol_usage ();
+  print_usage ("npsol");
 #else
   if ((nargin == 3 || nargin == 5 || nargin == 6 || nargin == 8
        || nargin == 9 || nargin == 11)
       && (nargout >= 1 && nargout <= 4))
     DLD_BUILTIN (args, nargin, nargout, npsol,
 		 retval = npsol (args, nargin, nargout);)
   else
-    npsol_usage ();
+    print_usage ("npsol");
 #endif
 
   return retval;
 }
 
 /*
  * A matrix of ones.
  */
@@ -1111,41 +1085,43 @@ builtin_ones (const tree_constant *args,
       retval = new tree_constant [2];
       retval[0] = fill_matrix (args[1], 1.0, "ones");
       break;
     case 3:
       retval = new tree_constant [2];
       retval[0] = fill_matrix (args[1], args[2], 1.0, "ones");
       break;
     default:
-      usage ("ones (n)\n       ones (A)\n       ones (n, m)");
+      print_usage ("ones");
       break;
     }
+
   return retval;
 }
 
 /*
  * You guessed it.
  */
 tree_constant *
 builtin_pause (const tree_constant *args, int nargin, int nargout)
 {
   if (! (nargin == 1 || nargin == 2))
     {
-      usage ("pause ([delay])");
+      print_usage ("pause");
       return NULL_TREE_CONST;
     }
 
   if (interactive)
     {
       if (nargin == 2)
 	sleep (NINT (args[1].double_value ()));
       else if (kbhit () == EOF)
 	clean_up_and_exit (0);
     }
+
   return NULL_TREE_CONST;
 }
 
 /*
  * Delete turds from /tmp.
  */
 tree_constant *
 builtin_purge_tmp_files (const tree_constant *, int, int)
@@ -1156,40 +1132,44 @@ builtin_purge_tmp_files (const tree_cons
 
 /*
  * Formatted printing.
  */
 tree_constant *
 builtin_printf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin < 2)
-    usage ("printf (\"fmt\" [, ...])");
+    print_usage ("printf");
   else
     retval = do_printf ("printf", args, nargin, nargout);
+
   return retval;
 }
 
 /*
  * Product.
  */
 tree_constant *
 builtin_prod (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("prod (M)");
+    print_usage ("prod");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].prod ();
 	}
     }
+
   return retval;
 }
 
 /*
  * Print name of current working directory.
  */
 tree_constant *
 builtin_pwd (const tree_constant *args, int nargin, int nargout)
@@ -1221,52 +1201,37 @@ builtin_pwd (const tree_constant *args, 
       delete [] s;
     }
   return retval;
 }
 
 /*
  * QPs.
  */
-static void
-qpsol_usage (void)
-{
-#if defined (QPSOL_MISSING)
-  message ("qpsol", "this function requires QPSOL, which is not freely\n\
-       redistributable.  For more information, read the file\n\
-       libcruft/qpsol/README.MISSING in the source distribution.");
-#else
-  usage ("[x, obj, info, lambda] = qpsol (x, H, c [, lb, ub] [, lb, A, ub])\n\
-\n\
-  Groups of arguments surrounded in `[]' are optional, but\n\
-  must appear in the same relative order shown above.");
-#endif
-}
-
 tree_constant *
 builtin_qpsol (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
 #if defined (QPSOL_MISSING)
 // Force a bad value of inform, and empty matrices for x, phi, and lambda.
   retval = new tree_constant [5];
   Matrix m;
   retval[0] = tree_constant (m);
   retval[1] = tree_constant (m);
   retval[2] = tree_constant (-1.0);
   retval[3] = tree_constant (m);
-  qpsol_usage ();
+  print_usage ("qpsol");
 #else
   if ((nargin == 4 || nargin == 6 || nargin == 7 || nargin == 9)
       && (nargout >= 1 && nargout <= 4))
     DLD_BUILTIN (args, nargin, nargout, qpsol,
 		 retval = qpsol (args, nargin, nargout);)
   else
-    qpsol_usage ();
+    print_usage ("qpsol");
 #endif
 
   return retval;
 }
 
 /*
  * QR factorization.
  */
@@ -1274,54 +1239,51 @@ tree_constant *
 builtin_qr (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && nargout < 3)
     DLD_BUILTIN (args, nargin, nargout, qr,
 		 retval = qr (args[1], nargout);)
   else
-    usage ("[Q, R] = qr (A)");
+    print_usage ("qr");
 
   return retval;
 }
 
 /*
  * generalized eigenvalues via qz
  */
 tree_constant *
 builtin_qzval (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 3 && nargout < 2)
     DLD_BUILTIN (args, nargin, nargout, qzvalue,
 		 retval = qzvalue (args, nargin, nargout);)
   else
-    usage ("x = qzval (A,B): compute generalized eigenvalues of \n\
-  the matrix pencil (A - lambda B).  A and B must be real matrices.\n");
+    print_usage ("qzval");
 
   return retval;
 }
 
 /*
  * Random numbers.
  */
 tree_constant *
 builtin_quad (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin > 3 && nargin < 7) && (nargout > 0 && nargout < 5))
     DLD_BUILTIN (args, nargin, nargout, quad,
 		 retval = do_quad (args, nargin, nargout);)
   else
-    usage ("[v, ier, nfun, err] = quad (\"f\", a, b)\n\
-                           = quad (\"f\", a, b, tol)\n\
-                           = quad (\"f\", a, b, tol, sing)");
+    print_usage ("quad");
 
   return retval;
 }
 
 /*
  * I'm outta here.
  */
 tree_constant *
@@ -1339,24 +1301,17 @@ tree_constant *
 builtin_rand (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin > 0 && nargin < 4) && nargout == 1)
     DLD_BUILTIN (args, nargin, nargout, rand,
 		 retval = rand_internal (args, nargin, nargout);)
   else
-    usage ("rand                  -- generate a random value\n\
-       rand (n)              -- generate N x N matrix\n\
-       rand (A)              -- generate matrix the size of A\n\
-       rand (n, m)           -- generate N x M matrix\n\
-       rand (\"dist\")         -- get current distribution\n\
-       rand (\"distribution\") -- set distribution\n\
-       rand (\"seed\")         -- get current seed\n\
-       rand (\"seed\", n)      -- set seed");
+    print_usage ("rand");
 
   return retval;
 }
 
 /*
  * Replot current plot.
  */
 tree_constant *
@@ -1374,20 +1329,22 @@ builtin_replot (const tree_constant *arg
 
 /*
  * Formatted reading.
  */
 tree_constant *
 builtin_scanf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("[...] = scanf (\"fmt\")");
+    print_usage ("scanf");
   else
     retval = do_scanf ("scanf", args, nargin, nargout);
+
   return retval;
 }
 
 /*
  * Convert a vector to a string.
  */
 tree_constant *
 builtin_setstr (tree_constant *args, int nargin, int nargout)
@@ -1395,17 +1352,17 @@ builtin_setstr (tree_constant *args, int
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     {
       retval = new tree_constant [2];
       retval[0] = args[1].convert_to_str ();
     }
   else
-    usage ("setstr (v)");
+    print_usage ("setstr");
 
   return retval;
 }
 
 /*
  * Execute a shell command.
  */
 tree_constant *
@@ -1433,31 +1390,31 @@ builtin_shell_command (const tree_consta
 	      retval = new tree_constant [2];
 	      retval[0] = tree_constant (output_buf.str ());
 	    }
 	}
       else
 	error ("shell_cmd: first argument must be a string");
     }
   else
-    usage ("shell_cmd (string [, return_output])");
+    print_usage ("shell_cmd");
 
   return retval;
 }
 
 /*
  * Report rows and columns.
  */
 tree_constant *
 builtin_size (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin != 2)
-    usage ("size (x)");
+    print_usage ("size");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  int nr = args[1].rows ();
 	  int nc = args[1].columns ();
 	  if (nargout == 1)
 	    {
@@ -1469,210 +1426,211 @@ builtin_size (const tree_constant *args,
 	    }
 	  else if (nargout == 2)
 	    {
 	      retval = new tree_constant [3];
 	      retval[0] = tree_constant ((double) nr);
 	      retval[1] = tree_constant ((double) nc);
 	    }
 	  else
-	    usage ("[n, m] = size (A)\n                size (A)");
+	    print_usage ("size");
 	}
     }
+
   return retval;
 }
 
 /*
  * Sort columns.
  */
 tree_constant *
 builtin_sort (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     retval = sort (args, nargin, nargout);
   else
-    usage ("[s, i] = sort (x)");
+    print_usage ("sort");
 
   return retval;
 }
 
 /*
  * Formatted printing to a string.
  */
 tree_constant *
 builtin_sprintf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin < 2)
-    usage ("string = sprintf (\"fmt\" [, ...])");
+    print_usage ("sprintf");
   else
     retval = do_printf ("sprintf", args, nargin, nargout);
+
   return retval;
 }
 
 /*
  * Matrix sqrt.
  */
 tree_constant *
 builtin_sqrtm (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2)
     retval = matrix_sqrt (args[1]);
   else
-    usage ("sqrtm (A)");
+    print_usage ("sqrtm");
 
   return retval;
 }
 
 /*
  * Formatted reading from a string.
  */
 tree_constant *
 builtin_sscanf (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 3)
-    usage ("[...] = sscanf (string, \"fmt\")");
+    print_usage ("sscanf");
   else
     retval = do_scanf ("sscanf", args, nargin, nargout);
+
   return retval;
 }
 
 /*
  * Sum.
  */
 tree_constant *
 builtin_sum (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("sum (M)");
+    print_usage ("sum");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].sum ();
 	}
     }
+
   return retval;
 }
 
 /*
  * Sum of squares.
  */
 tree_constant *
 builtin_sumsq (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
+
   if (nargin != 2)
-    usage ("sumsq (M)");
+    print_usage ("sumsq");
   else
     {
       if (args != NULL_TREE_CONST && args[1].is_defined ())
 	{
 	  retval = new tree_constant [2];
 	  retval[0] = args[1].sumsq ();
 	}
     }
+
   return retval;
 }
 
 /*
  * Singluar value decomposition.
  */
 tree_constant *
 builtin_svd (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && (nargout == 1 || nargout == 3))
     DLD_BUILTIN (args, nargin, nargout, svd,
 		 retval = svd (args, nargin, nargout);)
   else
-    usage ("[U, S, V] = svd (A)\n               S = svd (A)");
+    print_usage ("svd");
 
   return retval;
 }
 
 /*
  * Sylvester equation solver.
  */
 tree_constant *
 builtin_syl (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 4) && (nargout == 1))
     DLD_BUILTIN (args, nargin, nargout, syl,
 		 retval = syl (args, nargin, nargout);)
   else
-    usage ("X = syl (A,B,C)");
+    print_usage ("syl");
 
   return retval;
 }
 
 /*
  * Schur Decomposition
  */
 tree_constant *
 builtin_schur (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if ((nargin == 3 || nargin == 2) && (nargout == 1 || nargout == 2))
-    DLD_BUILTIN (args, nargin, nargout, hess,
+    DLD_BUILTIN (args, nargin, nargout, schur,
 		 retval = schur (args, nargin, nargout);)
   else
-    usage ("[U, S] = schur (A)\n\
-            S = schur (A)\n\n\
- or, for ordered Schur:\n\n\
-       [U, S] = schur (A, \"A, D, or U\")\n\
-            S = schur (A, \"A, D, or U\")\n\
- where:\n\n\
-   A = continuous time poles\n\
-   D = discrete time poles\n\
-   U = unordered schur (default)");
+    print_usage ("schur");
 
   return retval;
 }
 
 /*
  * Givens rotation
  */
 tree_constant *
 builtin_givens (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 3 && (nargout == 1 || nargout == 2 ))
     retval = givens (args, nargin, nargout);
   else
-    usage ("[c, s] = givens (x,y)\n            G = givens (x,y)");
+    print_usage ("givens");
 
   return retval;
 }
 
 /*
  * Hessenberg Decomposition
  */
 tree_constant *
 builtin_hess (const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   if (nargin == 2 && (nargout == 1 || nargout == 2))
     DLD_BUILTIN (args, nargin, nargout, hess,
 		 retval = hess (args, nargin, nargout);)
   else
-    usage ("[P, H] = hess (A)\n            H = hess (A)");
+    print_usage ("hess");
 
   return retval;
 }
 
 /*
  * Copying information.
  */
 tree_constant *
@@ -1714,19 +1672,20 @@ builtin_zeros (const tree_constant *args
       retval = new tree_constant [2];
       retval[0] = fill_matrix (args[1], 0.0, "zeros");
       break;
     case 3:
       retval = new tree_constant [2];
       retval[0] = fill_matrix (args[1], args[2], 0.0, "zeros");
       break;
     default:
-      usage ("zeros (n)\n       zeros (A)\n       zeros (n, m)");
+      print_usage ("zeros");
       break;
     }
+
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/g-builtins.h b/src/g-builtins.h
--- a/src/g-builtins.h
+++ b/src/g-builtins.h
@@ -37,16 +37,17 @@ struct builtin_general_functions
   int nargout_max;
   General_fcn general_fcn;
   char *help_string;
 };
 
 extern tree_constant *builtin_all (const tree_constant *, int, int);
 extern tree_constant *builtin_any (const tree_constant *, int, int);
 extern tree_constant *builtin_balance (const tree_constant *, int, int);
+extern tree_constant *builtin_chol (const tree_constant *, int, int);
 extern tree_constant *builtin_clc (const tree_constant *, int, int);
 extern tree_constant *builtin_clock (const tree_constant *, int, int);
 extern tree_constant *builtin_closeplot (const tree_constant *, int, int);
 extern tree_constant *builtin_colloc (const tree_constant *, int, int);
 extern tree_constant *builtin_cumprod (const tree_constant *, int, int);
 extern tree_constant *builtin_cumsum (const tree_constant *, int, int);
 extern tree_constant *builtin_dassl (const tree_constant *, int, int);
 extern tree_constant *builtin_date (const tree_constant *, int, int);
diff --git a/src/t-builtins.cc b/src/t-builtins.cc
--- a/src/t-builtins.cc
+++ b/src/t-builtins.cc
@@ -166,21 +166,21 @@ list_in_columns (ostrstream& os, char **
 }
 
 tree_constant
 builtin_casesen (int argc, char **argv)
 {
   tree_constant retval;
 
   if (argc == 1 || (argc > 1 && strcmp (argv[1], "off") == 0))
-    message ("casesen", "sorry, octave is always case sensitive");
+    warning ("casesen: sorry, Octave is always case sensitive");
   else if (argc > 1 && strcmp (argv[1], "on") == 0)
     ; // ok.
   else
-    usage ("casesen [on|off]");
+    print_usage ("casesen");
 
   return retval;
 }
 
 /*
  * Change current working directory.
  */
 tree_constant
@@ -324,17 +324,17 @@ builtin_document (int argc, char **argv)
 	    {
 	      error ("document: no such symbol `%s'", argv[1]);
 	      return retval;
 	    }
 	}
       sym_rec->document (argv[2]);
     }
   else
-    usage ("document symbol string ...");
+    print_usage ("document");
 
   return retval;
 }
 
 /*
  * Edit commands with your favorite editor.
  */
 tree_constant
@@ -408,22 +408,23 @@ simple_help (void)
 		     << ":\n\n";
 	  if (names != (char **) NULL && count > 0)
 	    list_in_columns (output_buf, names);
 	  delete [] names;
 	  ptr++;
 	}
     }
 
+  additional_help_message (output_buf);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 static int
-try_info (const char *string)
+try_info (const char *string, int force = 0)
 {
   int status = 0;
 
   char *directory_name = strsave (DEFAULT_INFO_FILE);
   char *temp = filename_non_directory (directory_name);
 
   if (temp != directory_name)
     {
@@ -438,27 +439,28 @@ try_info (const char *string)
   if (! initial_node)
     {
       warning ("can't find info file!\n");
       return status;
     }
 
   initialize_info_session (initial_node, 0);
 
-  if (index_entry_exists (windows, string))
+  if (force || index_entry_exists (windows, string))
     {
       terminal_clear_screen ();
 
       terminal_prep_terminal ();
 
       display_update_display (windows);
 
       info_last_executed_command = (VFunction *)NULL;
 
-      do_info_index_search (windows, 0, string);
+      if (! force)
+	do_info_index_search (windows, 0, string);
 
       char *format = replace_in_documentation
 	("Type \"\\[quit]\" to quit, \"\\[get-help-window]\" for help.");
 
       window_message_in_echo_area (format);
 
       info_read_and_dispatch ();
 
@@ -471,125 +473,146 @@ try_info (const char *string)
       status = 1;
     }
 
   finish_info_session (initial_node, 0);
 
   return status;
 }
 
-static int
-help_from_list (ostrstream& output_buf, const help_list *list,
-		const char *string)
-{
-  char *name;
-  while ((name = list->name) != (char *) NULL)
-    {
-      if (strcmp (name, string) == 0)
-	{
-	  output_buf << "\n" << list->help << "\n";
-	  return 1;
-	}
-      list++;
-    }
-  return 0;
-}
-
 /*
  * Print cryptic yet witty messages.
  */
 tree_constant
 builtin_help (int argc, char **argv)
 {
   tree_constant retval;
 
   if (argc == 1)
     {
       simple_help ();
     }
   else
     {
-      ostrstream output_buf;
-
-      char *m_file_name = (char *) NULL;
-      symbol_record *sym_rec;
-      help_list *op_help_list = operator_help ();
-      help_list *kw_help_list = keyword_help ();
-
-      for (int i = 1; i < argc; i++)
+      if (argv[1] != (char *) NULL && strcmp (argv[1], "-i") == 0)
 	{
-	  if (argv[i] == (char *) NULL || argv[i][0] == '\0')
-	    continue;
+	  argc--;
+	  argv++;
 
-	  volatile sig_handler *old_sigint_handler = signal (SIGINT, SIG_IGN);
+	  if (argc == 1)
+	    {
+	      volatile sig_handler *old_sigint_handler;
+	      old_sigint_handler = signal (SIGINT, SIG_IGN);
 
-	  int help_found = try_info (argv[i]);
-
-	  signal (SIGINT, old_sigint_handler);
+	      try_info ((char *) NULL, 1);
 
-	  if (help_found)
-	    continue;
+	      signal (SIGINT, old_sigint_handler);
+	    }
+	  else
+	    {
+	      while (--argc > 0)
+		{
+		  argv++;
 
-
-	  if (help_from_list (output_buf, op_help_list, argv[i]))
-	    continue;
+		  if (*argv == (char *) NULL || **argv == '\0')
+		    continue;
 
-	  if (help_from_list (output_buf, kw_help_list, argv[i]))
-	    continue;
+		  volatile sig_handler *old_sigint_handler;
+		  old_sigint_handler = signal (SIGINT, SIG_IGN);
 
-	  sym_rec = curr_sym_tab->lookup (argv[i], 0, 0);
-	  if (sym_rec != (symbol_record *) NULL)
-	    {
-	      char *h = sym_rec->help ();
-	      if (h != (char *) NULL && *h != '\0')
-		{
-		  output_buf << "\n" << h << "\n";
-		  continue;
+		  if (! try_info (*argv))
+		    {
+		      message ("help",
+			       "sorry, `%s' is not indexed in the manual",
+			       *argv); 
+		      sleep (2);
+		    }
+
+		  signal (SIGINT, old_sigint_handler);
 		}
 	    }
+	}
+      else
+	{
+	  ostrstream output_buf;
 
-	  sym_rec = global_sym_tab->lookup (argv[i], 0, 0);
-	  if (sym_rec != (symbol_record *) NULL
-	      && ! symbol_out_of_date (sym_rec))
+	  char *m_file_name = (char *) NULL;
+	  symbol_record *sym_rec;
+	  help_list *op_help_list = operator_help ();
+	  help_list *kw_help_list = keyword_help ();
+
+	  while (--argc > 0)
 	    {
-	      char *h = sym_rec->help ();
-	      if (h != (char *) NULL && *h != '\0')
+	      argv++;
+
+	      if (*argv == (char *) NULL || **argv == '\0')
+		continue;
+
+	      if (help_from_list (output_buf, op_help_list, *argv, 0))
+		continue;
+
+	      if (help_from_list (output_buf, kw_help_list, *argv, 0))
+		continue;
+
+	      sym_rec = curr_sym_tab->lookup (*argv, 0, 0);
+	      if (sym_rec != (symbol_record *) NULL)
 		{
-		  output_buf << "\n" << h << "\n";
-		  continue;
+		  char *h = sym_rec->help ();
+		  if (h != (char *) NULL && *h != '\0')
+		    {
+		      output_buf << "\n*** " << *argv << ":\n\n"
+				 << h << "\n";
+		      continue;
+		    }
 		}
-	    }
+
+	      sym_rec = global_sym_tab->lookup (*argv, 0, 0);
+	      if (sym_rec != (symbol_record *) NULL
+		  && ! symbol_out_of_date (sym_rec))
+		{
+		  char *h = sym_rec->help ();
+		  if (h != (char *) NULL && *h != '\0')
+		    {
+		      output_buf << "\n*** " << *argv << ":\n\n"
+				 << h << "\n";
+		      continue;
+		    }
+		}
 
 // Try harder to find M-files that might not be defined yet, or that
 // appear to be out of date.  Don\'t execute commands from the file if
 // it turns out to be a script file.
 
-	  m_file_name = m_file_in_path (argv[i]);
-	  if (m_file_name != (char *) NULL)
-	    {
-	      sym_rec = global_sym_tab->lookup (argv[i], 1, 0);
-	      if (sym_rec != (symbol_record *) NULL)
+	      m_file_name = m_file_in_path (*argv);
+	      if (m_file_name != (char *) NULL)
 		{
-		  tree_identifier tmp (sym_rec);
-		  tmp.parse_m_file (0);
-		  char *h = sym_rec->help ();
-		  if (h != (char *) NULL && *h != '\0')
+		  sym_rec = global_sym_tab->lookup (*argv, 1, 0);
+		  if (sym_rec != (symbol_record *) NULL)
 		    {
-		      output_buf << "\n" << h << "\n";
-		      continue;
+		      tree_identifier tmp (sym_rec);
+		      tmp.parse_m_file (0);
+		      char *h = sym_rec->help ();
+		      if (h != (char *) NULL && *h != '\0')
+			{
+			  output_buf << "\n*** " << *argv << ":\n\n"
+				     << h << "\n"; 
+			  continue;
+			}
 		    }
 		}
-	    }
-	  delete [] m_file_name;
+	      delete [] m_file_name;
 
-	  output_buf << "Sorry, `" << argv[i] << "' is not documented\n";
-	}
+	      output_buf << "\nhelp: sorry, `" << *argv
+			 << "' is not documented\n"; 
+	    }
 
-      output_buf << ends;
-      maybe_page_output (output_buf);
+	  additional_help_message (output_buf);
+	  output_buf << ends;
+	  maybe_page_output (output_buf);
+	}
     }
 
   return retval;
 }
 
 /*
  * Display, save, or load history.
  */
@@ -608,18 +631,18 @@ load_variable (char *nm, int force, istr
 {
   symbol_record *gsr = global_sym_tab->lookup (nm, 0, 0);
   symbol_record *lsr = curr_sym_tab->lookup (nm, 0, 0);
 
   if (! force
       && ((gsr != (symbol_record *) NULL && gsr->is_variable ())
 	  || lsr != (symbol_record *) NULL))
     {
-      message ("load",
-        "variable name `%s' exists -- use `load -force' to overwrite", nm);
+      warning ("load: variable name `%s' exists.  Use `load -force'\
+ to overwrite", nm);
       return -1;
     }
 
 // We found it.  Read data for this entry, and if that succeeds,
 // insert it into symbol table.
 
   tree_constant tc;
   int global = tc.load (is);
@@ -680,17 +703,17 @@ builtin_load (int argc, char **argv)
     {
       force++;
       argc--;
       argv++;
     }
 
   if (argc < 1)
     {
-      message ("load", "you must specify a single file to read");
+      error ("load: you must specify a single file to read");
       return retval;
     }
 
   static istream stream;
   static ifstream file;
   if (strcmp (*argv, "-") == 0)
     {
       stream = cin;
@@ -710,27 +733,27 @@ builtin_load (int argc, char **argv)
   char nm [128]; // XXX FIXME XXX
   int count = 0;
   for (;;)
     {
 // Read name for this entry or break on EOF.
       if (extract_keyword (stream, "name", nm) == 0 || nm == (char *) NULL)
 	{
 	  if (count == 0)
-	    message ("load",
-         "no name keywords found.  Are you sure this is an octave data file?");
+	    error ("load: no name keywords found in file.\
+  Are you sure this is an octave data file?");
 	  break;
 	}
 
       if (*nm == '\0')
 	continue;
 
       if (! valid_identifier (nm))
 	{
-	  message ("load", "skipping bogus identifier `%s'", nm);
+	  warning ("load: skipping bogus identifier `%s'");
 	  continue;
 	}
 
       if (load_variable (nm, force, stream))
 	count++;
     }
 
   if (file);
@@ -789,18 +812,17 @@ builtin_run_history (int argc, char **ar
  */
 tree_constant
 builtin_save (int argc, char **argv)
 {
   tree_constant retval;
 
   if (argc < 2)
     {
-      usage ("save file         -- save all variables in named file\n\
-       save file var ... -- saved named variables");
+      print_usage ("save");
       return retval;
     }
 
   argc--;
   argv++;
 
   static ostream stream;
   static ofstream file;
@@ -830,17 +852,17 @@ builtin_save (int argc, char **argv)
   else
     {
       while (--argc > 0)
 	{
 	  argv++;
 	  if (! curr_sym_tab->save (stream, *argv))
 	    if (! global_sym_tab->save (stream, *argv, 1))
 	      {
-		message ("save", "no such variable `%s'", *argv);
+		warning ("save: no such variable `%s'", *argv);
 		continue;
 	      }
 	}
     }
 
   if (file);
     file.close ();
 
@@ -933,17 +955,17 @@ builtin_who (int argc, char **argv)
       else if (strcmp (*argv, "-top") == 0)
 	show_top++;
       else if (strcmp (*argv, "-fcn") == 0
 	       || strcmp (*argv, "-fcns") == 0
 	       || strcmp (*argv, "-functions") == 0)
 	show_fcns++;
       else
 	{
-	  message ("who", "unrecognized option `%s'", *argv);
+	  warning ("who: unrecognized option `%s'", *argv);
 	  if (argc == 2)
 	    show_local = 1;
 	}
     }
 
   ostrstream output_buf;
   int pad_after = 0;
   if (show_global)
