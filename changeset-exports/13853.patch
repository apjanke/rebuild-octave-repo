# HG changeset patch
# User Jordi Gutiérrez Hermoso <jordigh@octave.org>
# Date 1320891700 18000
#      Wed Nov 09 21:21:40 2011 -0500
# Node ID ef7bf5af9faf00fba90dad4f11bfb6bb1d85f460
# Parent  e36817e2ee6092aeb1031586efd960a67b529996
# Parent  372869056e0f06e6f6514c0720b83b729765c767
Merge in Carnë's changes

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -31,47 +31,67 @@ Summary of important user-visible change
     They now support nearly all Matlab functionality including:
 
     * ML-compatible whitespace and delimiter defaults
 
     * ML-compatible options: 'whitespace', treatasempty',
     format string repeat count, user-specified comment style, uneven-length
     output arrays, %n and %u conversion specifiers (provisionally)
 
- ** Certain string functions have been modified for greater Matlab compatibility
-    and for 15X greater performance when operating on cell array of strings.
+ ** All .m string functions have been modified for better performance or greater
+    Matlab compatibility.  Performance gains of 15X-30X have been demonstrated.
+    Operations on cell array of strings no longer pay quite as high a penalty
+    as those on 2-D character arrays.
 
     deblank:  Now requires character or cellstr input.
     strtrim:  Now requires character or cellstr input.
               No longer trims nulls ("\0") from string for ML compatibility.
     strmatch: Follows documentation precisely and ignores trailing spaces
               in pattern and in string.  Note that Matlab documents this 
               behavior but the implementation does *not* always follow it.
+    substr:   Now possible to specify a negative LEN option which extracts
+              to within LEN of the end of the string.
+    strtok:   Now accepts cellstr input.
+    base2dec, bin2dec, hex2dec: Now accept cellstr inputs.
+    dec2base, dec2bin, dec2hex: Now accept cellstr inputs.
+    index, rindex: Now accept 2-D character array input.
+    strsplit: Now accepts 2-D character array input.
 
  ** Geometry functions derived from Qhull (convhull, delaunay, voronoi)
     have been revamped.  The options passed to the underlying qhull command
     have been changed for better results or for Matlab compatibility.
 
     convhull : Default options are "Qt" for 2D, 3D, 4D inputs
                Default options are "Qt Qx" for 5D and higher
     delaunay : Default options are "Qt Qbb Qc Qz" for 2D and 3D inputs
                Default options are "Qt Qbb Qc Qx" for 4D and higher
     voronoi  : No default arguments
 
- ** Matlab-compatible preference functions:
+ ** Date/Time functions updated.
+    Millisecond support with FFF format string now supported.
 
-      addpref  getpref  ispref  rmpref  setpref
-
- ** Other miscellaneous new functions:
+    datestr : Numerical formats 21, 22, 29 changed to match Matlab.
+              Now accepts cellstr inputs.
 
-      nthargout
-      iscolumn
-      issrow
-      zscore
+ ** Octave warning IDs updated
+    "empty-list-elements" : removed
+    "fortran-indexing"    : removed
+    "complex-cmp-ops"     : removed
+    "string-concat"       : renamed to "mixed-string-concat"
+
+ ** Matlab-compatible preference functions added:
 
+    addpref  getpref  ispref  rmpref  setpref
+
+ ** Other new functions added in 3.6.0:
+
+    is_dq_string      python      zscore
+    is_sq_string      usejava 
+    nthargout         waitbar
+                      
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.2 and have been
     removed from Octave 3.6.
                                            
       create_set          spcholinv    splu   
       dmult               spcumprod    spmax
       iscommand           spcumsum     spmin
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -162,16 +162,25 @@ BOUNDS_CHECKING=false
 AC_ARG_ENABLE(bounds-check,
   [AS_HELP_STRING([--enable-bounds-check],
      [bounds checking for indexing in internal array classes (default is no)])],
   [if test "$enableval" = yes; then BOUNDS_CHECKING=true; fi], [])
 if $BOUNDS_CHECKING; then
   AC_DEFINE(BOUNDS_CHECKING, 1, [Define to use internal bounds checking.])
 fi
 
+USE_OCTAVE_ALLOCATOR=false
+AC_ARG_ENABLE(octave-allocator,
+  [AS_HELP_STRING([--enable-octave-allocator],
+     [use the obsolete octave_allocator class for many of Octave's objects (mostly octave_value types).  You probably do NOT want to enable this feature.  (default is no)])],
+  [if test "$enableval" = yes; then USE_ALLOCATOR=true; fi], [])
+if $USE_OCTAVE_ALLOCATOR; then
+  AC_DEFINE(USE_OCTAVE_ALLOCATOR, 1, [Define to use octave_allocator class.])
+fi
+
 ### Make it possible to disable running Make in the doc directory.
 ### Useful for building on systems without TeX, for example.
 DOCDIR=doc
 AC_ARG_ENABLE(docs,
   [AS_HELP_STRING([--enable-docs], [build documentation (default is yes)])],
   [if test "$enableval" = no; then
      DOCDIR=
      warn_docs="building documentation disabled; make dist will fail"
@@ -2183,16 +2192,17 @@ Octave is now configured for $canonical_
   Z CPPFLAGS:                  $Z_CPPFLAGS
   Z LDFLAGS:                   $Z_LDFLAGS
   Z libraries:                 $Z_LIBS
 
   Default pager:               $DEFAULT_PAGER
   gnuplot:                     $GNUPLOT
 
   Do internal array bounds checking:  $BOUNDS_CHECKING
+  Use octave_allocator:               $USE_OCTAVE_ALLOCATOR
   Build static libraries:             $STATIC_LIBS
   Build shared libraries:             $SHARED_LIBS
   Dynamic Linking:                    $ENABLE_DYNAMIC_LINKING $DL_API_MSG
   Include support for GNU readline:   $USE_READLINE
   64-bit array dims and indexing:     $USE_64_BIT_IDX_T
 ])
 
 warn_msg_printed=false
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -420,17 +420,17 @@ the recursion depth and prevents Octave 
 @cindex transpose
 @cindex Hermitian operator
 @cindex transpose, complex-conjugate
 @cindex complex-conjugate transpose
 
 The following arithmetic operators are available, and work on scalars
 and matrices.
 
-@table @code
+@table @asis
 @item @var{x} + @var{y}
 @opindex +
 Addition.  If both operands are matrices, the number of rows and columns
 must both agree.  If one operand is a scalar, its value is added to
 all the elements of the other operand.
 
 @item @var{x} .+ @var{y}
 @opindex .+
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -25,107 +25,95 @@ docstrings_files = args(2:end);
 
 ## Special character used as break between DOCSTRINGS
 doc_delim = char (31);
 
 ## Read the contents of all the DOCSTRINGS files into TEXT.
 ## It is more efficient to fork to shell for makeinfo only once on large data
 
 nfiles = numel (docstrings_files);
-text = cell (1, nfiles+1);
+text = cell (1, nfiles);
 for i = 1:nfiles
   file = docstrings_files{i};
   fid = fopen (file, "r");
   if (fid < 0)
     error ("unable to open %s for reading", file);
   else
     tmp = fread (fid, Inf, "*char")';
     ## Strip off header lines
-    [null, text{i}] = strtok (tmp, doc_delim);
+    [~, text{i}] = strtok (tmp, doc_delim);
   endif
 endfor
 text = [text{:}, doc_delim];
 
 ## Modify Octave-specific macros before passing to makeinfo
+text = regexprep (text, "-\\*- texinfo -\\*-[ \t]*[\r\n]*", "");
 text = regexprep (text, '@seealso *\{([^}]*)\}', "See also: $1.");
 text = regexprep (text, '@nospell *\{([^}]*)\}', "$1");
-text = regexprep (text, "-\\*- texinfo -\\*-[ \t]*[\r\n]*", "");
-text = regexprep (text, '@', "@@");
+text = regexprep (text, '@xcode *\{([^}]*)\}', "$1");
+text = strrep (text, '@', "@@");
 
 ## Write data to temporary file for input to makeinfo
 [fid, name, msg] = mkstemp ("octave_doc_XXXXXX", true);
 if (fid < 0)
   error ("%s: %s\n", name, msg);
 endif
 fwrite (fid, text, "char");
 fclose (fid);
 
-cmd = sprintf ("%s --no-headers --no-warn --force --no-validate --fill-column=1024 %s",
-               makeinfo_program (), name);
+cmd = [makeinfo_program() " --no-headers --no-warn --force --no-validate --fill-column=1024 " name];
 
 [status, formatted_text] = system (cmd);
 
 ## Did we get the help text?
 if (status != 0)
   error ("makeinfo failed with exit status %d!", status);
-endif
-
-if (isempty (formatted_text))
+elseif (isempty (formatted_text))
   error ("makeinfo produced no output!");
 endif
 
 ## Break apart output and store in cache variable
 delim_idx = find (formatted_text == doc_delim);
 n = length (delim_idx);
 
 cache = cell (3, n);    # pre-allocate storage for efficiency
 k = 1;
 
 for i = 2:n
 
   block = formatted_text(delim_idx(i-1)+1:delim_idx(i)-1);
 
   [symbol, doc] = strtok (block, "\r\n");
 
-  doc = regexprep (doc, "^[\r\n]+", '');
-
   ## Skip internal functions that start with __ as these aren't
   ## indexed by lookfor.
   if (length (symbol) > 2 && regexp (symbol, '^__.+__$'))
     continue;
   endif
 
+  doc = regexprep (doc, "^[\r\n]+", '', 'once');
+
   if (isempty (doc))
     continue;
   endif
 
-  tmp = doc;
-  found = 0;
-  do
-    [s, e] = regexp (tmp, "^ -- [^\r\n]*[\r\n]");
-    if (! isempty(s))
-      found = 1;
-      tmp = tmp(e+1:end);
-    endif
-  until (isempty (s))
+  tmp = regexprep (doc, "^ -- .*$[\r\n]", '', 'lineanchors', 'dotexceptnewline');
 
-  if (! found)
+  if (isempty (tmp))
     continue;
   endif
 
   end_of_first_sentence = regexp (tmp, "(\\.|[\r\n][\r\n])", "once");
   if (isempty (end_of_first_sentence))
     end_of_first_sentence = length (tmp);
-  else
-    end_of_first_sentence = end_of_first_sentence;
   endif
 
   first_sentence = tmp(1:end_of_first_sentence);
   first_sentence = regexprep (first_sentence, "([\r\n]| {2,})", " ");
-  first_sentence = regexprep (first_sentence, '^ +', "");
+  first_sentence = regexprep (first_sentence, '^ +', "", 'once');
 
   cache{1,k} = symbol;
   cache{2,k} = doc;
   cache{3,k} = first_sentence;
   k++;
 endfor
 
 cache(:,k:end) = [];    # delete unused pre-allocated entries
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -41,16 +41,30 @@
 @c The following macro marks words that aspell should ignore during
 @c spellchecking.  Within Texinfo it has no effect as it merely replaces
 @c the macro call with the argument itself.
 
 @macro nospell {arg}
 \arg\
 @end macro
 
+@c The following macro works around a situation where the Info/plain text
+@c expansion of the @code{XXX} macro is `XXX'.  The use of the apostrophe
+@c can be confusing if the code segment itself ends with a transpose operator.
+@ifinfo
+@macro xcode{arg}
+\arg\
+@end macro
+@end ifinfo
+@ifnotinfo
+@macro xcode{arg}
+@code{\arg\}
+@end macro
+@end ifnotinfo
+
 @ifinfo
 @format
 START-INFO-DIR-ENTRY
 * Octave: (octave).           Interactive language for numerical computations.
 
 END-INFO-DIR-ENTRY
 @end format
 @end ifinfo
diff --git a/doc/interpreter/system.txi b/doc/interpreter/system.txi
--- a/doc/interpreter/system.txi
+++ b/doc/interpreter/system.txi
@@ -225,16 +225,18 @@ status information on files; and for man
 @DOCSTRING(is_rooted_relative_filename)
 
 @DOCSTRING(P_tmpdir)
 
 @DOCSTRING(tempdir)
 
 @DOCSTRING(tempname)
 
+@DOCSTRING(recycle)
+
 @node File Archiving Utilities
 @section File Archiving Utilities
 
 @DOCSTRING(bunzip2)
 
 @DOCSTRING(gzip)
 
 @DOCSTRING(gunzip)
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1566,16 +1566,19 @@ ComplexMatrix::determinant (octave_idx_t
 
 ComplexDET
 ComplexMatrix::determinant (MatrixType& mattype,
                             octave_idx_type& info, double& rcon,
                             int calc_cond) const
 {
   ComplexDET retval (1.0);
 
+  info = 0;
+  rcon = 0.0;
+
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
   else
     {
       volatile int typ = mattype.type ();
@@ -1594,17 +1597,16 @@ ComplexMatrix::determinant (MatrixType& 
           for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
-          info = 0;
           double anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
@@ -3790,17 +3792,17 @@ xgemm (const ComplexMatrix& a, const Com
             }
 
         }
       else
         {
           octave_idx_type lda = a.rows (), tda = a.cols ();
           octave_idx_type ldb = b.rows (), tdb = b.cols ();
 
-          retval = ComplexMatrix (a_nr, b_nc);
+          retval = ComplexMatrix (a_nr, b_nc, 0.0);
           Complex *c = retval.fortran_vec ();
 
           if (b_nc == 1 && a_nr == 1)
             {
               if (cja == cjb)
                 {
                   F77_FUNC (xzdotu, XZDOTU) (a_nc, a.data (), 1, b.data (), 1, *c);
                   if (cja) *c = std::conj (*c);
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -1481,19 +1481,16 @@ Sparse<T>::index (const idx_vector& idx,
         {
           // Sparse row vectors occupy O(nr) storage anyway, so let's just
           // convert the matrix to full, index, and sparsify the result.
           retval = Sparse<T> (array_value ().index (idx));
         }
     }
   else
     {
-      (*current_liboctave_warning_with_id_handler)
-        ("Octave:fortran-indexing", "single index used for sparse matrix");
-
       if (nr != 0 && idx.is_scalar ())
         retval = Sparse<T> (1, 1, elem (idx(0) % nr, idx(0) / nr));
       else
         {
           // Indexing a non-vector sparse matrix by linear indexing.
           // I suppose this is rare (and it may easily overflow), so let's take the easy way,
           // and reshape first to column vector, which is already handled above.
           retval = index (idx_vector::colon).index (idx);
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1234,16 +1234,19 @@ Matrix::determinant (octave_idx_type& in
 }
 
 DET
 Matrix::determinant (MatrixType& mattype,
                      octave_idx_type& info, double& rcon, int calc_cond) const
 {
   DET retval (1.0);
 
+  info = 0;
+  rcon = 0.0;
+
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
   else
     {
       volatile int typ = mattype.type ();
@@ -1262,17 +1265,16 @@ Matrix::determinant (MatrixType& mattype
           for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
-          info = 0;
           double anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1562,16 +1562,19 @@ FloatComplexMatrix::determinant (octave_
 }
 
 FloatComplexDET
 FloatComplexMatrix::determinant (MatrixType& mattype,
                                  octave_idx_type& info, float& rcon, int calc_cond) const
 {
   FloatComplexDET retval (1.0);
 
+  info = 0;
+  rcon = 0.0;
+
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
   else
     {
       volatile int typ = mattype.type ();
@@ -1590,17 +1593,16 @@ FloatComplexMatrix::determinant (MatrixT
           for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
-          info = 0;
           float anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
@@ -3786,17 +3788,17 @@ xgemm (const FloatComplexMatrix& a, cons
             }
 
         }
       else
         {
           octave_idx_type lda = a.rows (), tda = a.cols ();
           octave_idx_type ldb = b.rows (), tdb = b.cols ();
 
-          retval = FloatComplexMatrix (a_nr, b_nc);
+          retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
           FloatComplex *c = retval.fortran_vec ();
 
           if (b_nc == 1 && a_nr == 1)
             {
               if (cja == cjb)
                 {
                   F77_FUNC (xcdotu, XCDOTU) (a_nc, a.data (), 1, b.data (), 1, *c);
                   if (cja) *c = std::conj (*c);
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -1234,16 +1234,19 @@ FloatMatrix::determinant (octave_idx_typ
 }
 
 FloatDET
 FloatMatrix::determinant (MatrixType& mattype,
                           octave_idx_type& info, float& rcon, int calc_cond) const
 {
   FloatDET retval (1.0);
 
+  info = 0;
+  rcon = 0.0;
+
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
   else
     {
       volatile int typ = mattype.type ();
@@ -1262,17 +1265,16 @@ FloatMatrix::determinant (MatrixType& ma
           for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
-          info = 0;
           float anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
diff --git a/liboctave/oct-alloc.h b/liboctave/oct-alloc.h
--- a/liboctave/oct-alloc.h
+++ b/liboctave/oct-alloc.h
@@ -67,25 +67,35 @@ private:
     void operator delete (void *p, void *) \
       { ::operator delete (p, static_cast<void*> (0)); }
 #else
 #define DECLARE_OCTAVE_ALLOCATOR_PLACEMENT_DELETE \
     void operator delete (void *p, void *) \
       { ::operator delete (p); }
 #endif
 
+#if defined (USE_OCTAVE_ALLOCATOR)
+
 #define DECLARE_OCTAVE_ALLOCATOR \
   public: \
     void *operator new (size_t size, void *p) \
       { return ::operator new (size, p); } \
     DECLARE_OCTAVE_ALLOCATOR_PLACEMENT_DELETE \
     void *operator new (size_t size) { return allocator.alloc (size); } \
     void operator delete (void *p, size_t size) { allocator.free (p, size); } \
   private: \
     static octave_allocator allocator;
 
 #define DEFINE_OCTAVE_ALLOCATOR(t) \
   octave_allocator t::allocator (sizeof (t))
 
 #define DEFINE_OCTAVE_ALLOCATOR2(t, s) \
   octave_allocator t::allocator (sizeof (t), s)
 
+#else
+
+#define DECLARE_OCTAVE_ALLOCATOR
+#define DEFINE_OCTAVE_ALLOCATOR(t)
+#define DEFINE_OCTAVE_ALLOCATOR2(t, s)
+
 #endif
+
+#endif
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -25,60 +25,64 @@
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
 
-  if (nargin == 1 && isvector (name) && ! ischar (name))
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
+  if (nargin == 1 && isnumeric (name))
     ## play a vector
-    [nr, nc] = size (name);
-    if (nc != 1)
-      if (nr == 1)
-        name = name';
-        nr = nc;
-      else
-        error ("playaudio: X must be a vector");
-      endif
+    if (! isvector (name))
+      error ("playaudio: X must be a vector");
     endif
-    X = name + 127;
+    X = name(:) + 127;
     unwind_protect
       file = tmpnam ();
-      num = fopen (file, "wb");
-      c = fwrite (num, X, "uchar");
-      fclose (num);
-      [status, out] = system (sprintf ("cat \"%s\" > /dev/dsp", file));
+      fid = fopen (file, "wb");
+      fwrite (fid, X, "uchar");
+      fclose (fid);
+      [status, out] = system (sprintf ('cat "%s" > /dev/dsp', file));
       if (status != 0)
         system (sprintf ("paplay --raw \"%s\"", file))
       endif
     unwind_protect_cleanup
       unlink (file);
     end_unwind_protect
   elseif (nargin >= 1 && ischar (name))
     ## play a file
     if (nargin == 1)
-      name = [name, ".lin"];
+      name = [name ".lin"];
     elseif (nargin == 2)
-      name = [name, ".", ext];
-    else
-      print_usage ();
+      name = [name "." ext];
     endif
-    if (strcmp (ext, "lin") || strcmp (ext, "raw"))
-      [status, out] = system (sprintf ("cat \"%s\" > /dev/dsp", name));
+    if (any (strcmp (ext, {"lin", "raw"})))
+      [status, out] = system (sprintf ('cat "%s" > /dev/dsp', name));
       if (status != 0)
-        system (sprintf ("paplay --raw \"%s\"", name))
+        system (sprintf ('paplay --raw "%s"', name))
       endif
-    elseif (strcmp (ext, "mu") || strcmp (ext, "au")
-            || strcmp (ext, "snd") || strcmp (ext, "ul"))
-      [status, out] = system (sprintf ("cat \"%s\" > /dev/audio", name));
+    elseif (any (strcmp (ext, {"mu", "au" "snd", "ul"})))
+      [status, out] = system (sprintf ('cat "%s" > /dev/audio', name));
       if (status != 0)
-        system (sprintf ("paplay \"%s\"", name))
+        system (sprintf ('paplay "%s"', name))
       endif
     else
-      error ("playaudio: unsupported extension");
+      error ("playaudio: unsupported extension '%s'", ext);
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+
+%% Test input validation
+%!error playaudio ()
+%!error playaudio (1,2,3)
+%!error <X must be a vector> playaudio (magic (3))
+%!error <unsupported extension> playaudio ("file", "abc")
+%!error playaudio ({"abc"})
+
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -26,27 +26,35 @@
 ## the rows of the matrix @var{subs} and the values by @var{vals}.  Each
 ## row of @var{subs} corresponds to one of the values in @var{vals}. If
 ## @var{vals} is a scalar, it will be used for each of the row of
 ## @var{subs}.
 ##
 ## The size of the matrix will be determined by the subscripts
 ## themselves. However, if @var{sz} is defined it determines the matrix
 ## size. The length of @var{sz} must correspond to the number of columns
-## in @var{subs}.
+## in @var{subs}. An exception is if @var{subs} has only one column, in
+## which case @var{sz} may be the dimensions of a vector and the subscripts
+## of @var{subs} are taken as the indices into it.
 ##
 ## The default action of @code{accumarray} is to sum the elements with
 ## the same subscripts.  This behavior can be modified by defining the
 ## @var{func} function.  This should be a function or function handle
 ## that accepts a column vector and returns a scalar.  The result of the
 ## function should not depend on the order of the subscripts.
 ##
 ## The elements of the returned array that have no subscripts associated
-## with them are set to zero.  Defining @var{fillval} to some other
-## value allows these values to be defined.
+## with them are set to zero. Defining @var{fillval} to some other value
+## allows these values to be defined. This behaviour changes, however,
+## for certain values of @var{func}. If @var{func} is @code{min}
+## (respectively, @code{max}) then the result will be filled with the
+## minimum (respectively, maximum) integer if @var{vals} is of integral
+## type, logical false (respectively, logical true) if @var{vals} is of
+## logical type, zero if @var{fillval} is zero and all values are
+## nonpositive (respectively, nonnegative), and NaN otherwise.
 ##
 ## By default @code{accumarray} returns a full matrix.  If
 ## @var{issparse} is logically true, then a sparse matrix is returned
 ## instead.
 ##
 ## The following @code{accumarray} example constructs a frequency table
 ## that in the first column counts how many occurrences each number in
 ## the second column has, taken from the vector @var{x}. Note the usage
@@ -161,17 +169,24 @@ function A = accumarray (subs, vals, sz 
     else
       mode = "sum";
     endif
 
     ## Form the sparse matrix.
     if (isempty (sz))
       A = sparse (subs(:,1), subs(:,2), vals, mode);
     elseif (length (sz) == 2)
-      A = sparse (subs(:,1), subs(:,2), vals, sz(1), sz(2), mode);
+
+      ## Row vector case
+      if (sz(1) == 1)
+        [i, j] = deal (subs(:,2), subs(:,1));
+      else
+        [i, j] = deal (subs(:,1), subs(:,2));
+      endif
+      A = sparse (i, j, vals, sz(1), sz(2), mode);
     else
       error ("accumarray: dimensions mismatch");
     endif
 
   else
 
     ## Linearize subscripts.
     if (ndims > 1)
@@ -243,16 +258,19 @@ function A = accumarray (subs, vals, sz 
       endif
     elseif (func == @min)
       ## Fast minimization.
 
       if (isinteger (vals))
         zero = intmax (class (vals));
       elseif (islogical (vals))
         zero = true;
+      elseif (fillval == 0 && all (vals(:) <= 0))
+        ## This is a common case - fillval is zero, all numbers nonpositive.
+        zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
         A = __accumarray_min__ (subs, vals, zero);
       else
         A = __accumarray_min__ (subs, vals, zero, prod (sz));
@@ -308,16 +326,20 @@ endfunction
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105),cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))),sin(cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
 %!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112),cat(3,[0,0,207,0;0,108,0,0;0,109,0,317],[0,0,111,0;104,0,0,219;0,103,0,0]))
 %!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN),[101,NaN,NaN,NaN;104,NaN,105,NaN])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true),sparse([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1),[false,false,false,false;true,false,true,false])
+%!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
+%!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
+%!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
+%!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))
 %!test
 %! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x){x});
 %! assert (A{2},[102;104])
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subs, vals, [], @max), accumarray (subs, vals, [], @(x) max (x)));
 %!test
diff --git a/scripts/general/display.m b/scripts/general/display.m
--- a/scripts/general/display.m
+++ b/scripts/general/display.m
@@ -28,14 +28,23 @@
 ## @noindent
 ## where Octave is required to display the contents of a variable of the
 ## type "myclass".
 ##
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function idx = display (a)
-  if (nargin == 1)
-    error ("display: not defined for class \"%s\"", class(a));
-  else
+
+  if (nargin != 1)
     print_usage ();
   endif
+ 
+  ## Only reason we got here is that there was no overloaded display()
+  ## function for object a.  This may mean it is a built-in.
+  str = disp (a);
+  if (isempty (strfind (str, "<class ")))
+    disp (str);   
+  else
+    error ('display: not defined for class "%s"', class (a));
+  endif
+
 endfunction
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -85,23 +85,16 @@ endfunction
 %! profile ("on");
 %! A = rand (100);
 %! B = expm (A);
 %! profile ("off");
 %! T = profile ("info");
 %! profshow (T, 10);
 
 %!demo
-%! function f = myfib (n)
-%!   if (n <= 2)
-%!     f = 1;
-%!   else
-%!     f = myfib (n - 1) + myfib (n - 2);
-%!   endif
-%! endfunction
 %! profile ("on");
-%! myfib (20);
+%! expm (rand (500) + eye (500));
 %! profile ("off");
 %! profshow (profile ("info"), 5);
 
 %!error profshow ();
 %!error profshow (1, 2, 3);
 %!error profshow (struct (), 1.2);
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2011 Alexander Klein
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -53,16 +54,18 @@
 ##
 ## Note: @code{quadv} is written in Octave's scripting language and can be
 ## used recursively in @code{dblquad} and @code{triplequad}, unlike the
 ## similar @code{quad} function.
 ## @seealso{quad, quadl, quadgk, quadcc, trapz, dblquad, triplequad}
 ## @end deftypefn
 
 function [q, nfun] = quadv (f, a, b, tol, trace, varargin)
+  ## TODO: Make norm for convergence testing configurable
+
   if (nargin < 3)
     print_usage ();
   endif
   if (nargin < 4)
     tol = [];
   endif
   if (nargin < 5)
     trace = [];
@@ -83,32 +86,32 @@ function [q, nfun] = quadv (f, a, b, tol
   c = (a + b) / 2;
   fa = feval (f, a, varargin{:});
   fc = feval (f, c, varargin{:});
   fb = feval (f, b, varargin{:});
   nfun = 3;
 
   ## If have edge singularities, move edge point by eps*(b-a) as
   ## discussed in Shampine paper used to implement quadgk
-  if (isinf (fa))
+  if (any (isinf (fa(:))))
     fa = feval (f, a + myeps * (b-a), varargin{:});
   endif
-  if (isinf (fb))
+  if (any (isinf (fb(:))))
     fb = feval (f, b - myeps * (b-a), varargin{:});
   endif
 
   h = (b - a);
   q = (b - a) / 6 * (fa + 4 * fc + fb);
 
   [q, nfun, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q, nfun, abs (h),
                                 tol, trace, varargin{:});
 
   if (nfun > 10000)
     warning ("maximum iteration count reached");
-  elseif (isnan (q) || isinf (q))
+  elseif (any (isnan (q)(:) | isinf (q)(:)))
     warning ("infinite or NaN function evaluations were returned");
   elseif (hmin < (b - a) * myeps)
     warning ("minimum step size reached -- possibly singular integral");
   endif
 endfunction
 
 function [q, nfun, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0,
                                        nfun, hmin, tol, trace, varargin)
@@ -128,17 +131,19 @@ function [q, nfun, hmin] = simpsonstp (f
       hmin = abs (a - c);
     endif
 
     if (trace)
       disp ([nfun, a, b-a, q]);
     endif
 
     ## Force at least one adpative step.
-    if (nfun == 5 || abs (q - q0) > tol)
+    ## Not vectorizing q-q0 in the norm provides a more rigid criterion for
+    ## matrix-valued functions.
+    if (nfun == 5 || norm (q - q0, Inf) > tol)
       [q1, nfun, hmin] = simpsonstp (f, a, c, d, fa, fc, fd, q1, nfun, hmin,
                                     tol, trace, varargin{:});
       [q2, nfun, hmin] = simpsonstp (f, c, b, e, fc, fb, fe, q2, nfun, hmin,
                                      tol, trace, varargin{:});
       q = q1 + q2;
     endif
   endif
 endfunction
@@ -147,8 +152,10 @@ endfunction
 %!assert (quadv (@sin, 0, pi), 2, 1e-5)
 
 %% Handles weak singularities at the edge
 %!assert (quadv (@(x) 1 ./ sqrt(x), 0, 1), 2, 1e-5)
 
 %% Handles vector-valued functions
 %!assert (quadv (@(x) [(sin (x)), (sin (2 * x))], 0, pi), [2, 0], 1e-5)
 
+%% Handles matrix-valued functions
+%!assert (quadv (@(x) [ x, x, x; x, 1./sqrt(x), x; x, x, x ], 0, 1 ), [0.5, 0.5, 0.5; 0.5, 2, 0.5; 0.5, 0.5, 0.5], 1e-5)
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -87,25 +87,27 @@ function [retval, status] = __makeinfo__
   endif
 
 
   ## It seems like makeinfo sometimes gets angry if the first character
   ## on a line is a space, so we remove these.
   text = strrep (text, "\n ", "\n");
 
   ## Handle @seealso macro
-  see_also_pat = '@seealso *\{([^}]*)\}';
+  see_also_pat = '@seealso *\{(.*)\}';
   args = regexp (text, see_also_pat, 'tokens');
   for ii = 1:numel (args)
     expanded = fsee_also (strtrim (strsplit (args{ii}{:}, ',', true)));
     text = regexprep (text, see_also_pat, expanded, 'once');
   endfor
 
   ## Handle @nospell macro
   text = regexprep (text, '@nospell *\{([^}]*)\}', "$1");
+  ## Handle @xcode macro
+  text = regexprep (text, '@xcode *\{([^}]*)\}', "$1");
 
   if (strcmpi (output_type, "texinfo"))
     status = 0;
     retval = text;
     return;
   endif
 
   ## Create the final TeXinfo input string
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -37,27 +37,28 @@
 ## function's help.  All Octave core functions are correctly
 ## formatted, but the same can not be guaranteed for external packages and
 ## user-supplied functions.  Therefore, the use of the '-all' argument may
 ## be necessary to find related functions that are not a part of Octave.
 ## @seealso{help, doc, which}
 ## @end deftypefn
 
 function [out_fun, out_help_text] = lookfor (str, arg2)
+
   if (strcmpi (str, "-all"))
     ## The difference between using '-all' and not, is which part of the caches
-    ## we search. The cache is organised such that its first column contains
-    ## the function name, its second column contains the full help text, and its
-    ## third column contains the first sentence of the help text.
+    ## we search.  The cache is organized such that the first column contains
+    ## the function name, the second column contains the full help text, and
+    ## the third column contains the first sentence of the help text.
     str = arg2;
-    search_type = 2; # when using caches, search its second column
+    search_type = 2; # when using caches, search the second column
   else
-    search_type = 3; # when using caches, search its third column
+    search_type = 3; # when using caches, search the third column
   endif
-  str = lower (str);
+  str = lower (str);   # Compare is case insensitive
 
   ## Search functions, operators, and keywords that come with Octave
   cache_file = doc_cache_file ();
   if (exist (cache_file, "file"))
     [fun, help_text] = search_cache (str, cache_file, search_type);
     had_core_cache = true;
   else
     fun = help_text = {};
@@ -76,35 +77,35 @@ function [out_fun, out_help_text] = look
   endif
 
   for n = 1:numel (new_path)
     elt = new_path{n};
     cache_file = fullfile (elt, "doc-cache");
     if (exist (cache_file, "file"))
       ## We have a cache in the directory, then read it and search it!
       [funs, hts] = search_cache (str, cache_file, search_type);
-      fun (end+1:end+length (funs)) = funs;
-      help_text (end+1:end+length (hts)) = hts;
+      fun(end+1:end+length (funs)) = funs;
+      help_text(end+1:end+length (hts)) = hts;
     else
     ## We don't have a cache. Search files
       funs_in_f = __list_functions__ (elt);
       for m = 1:length (funs_in_f)
-        fn = funs_in_f {m};
+        fn = funs_in_f{m};
 
         ## Skip files that start with __
-        if (length (fn) > 2 && strcmp (fn (1:2), "__"))
+        if (length (fn) > 2 && strcmp (fn(1:2), "__"))
           continue;
         endif
 
         ## Extract first sentence
         try
           warn_state = warning ();
           unwind_protect
             warning ("off");
-            first_sentence = get_first_help_sentence (fn);
+            first_sentence = get_first_help_sentence (fn, 1024);
             status = 0;
           unwind_protect_cleanup
             warning (warn_state);
           end_unwind_protect
         catch
           status = 1;
         end_try_catch
 
@@ -134,54 +135,57 @@ function [out_fun, out_help_text] = look
               status = 1;
           endswitch
 
         elseif (status == 0) # only search the first sentence of the help text
           text = first_sentence;
         endif
 
         ## Search the help text, if we can
-        if (status == 0 && !isempty (strfind (text, str)))
-          fun (end+1) = fn;
-          help_text (end+1) = first_sentence;
+        if (status == 0 && ! isempty (strfind (lower (text), str)))
+          fun(end+1) = fn;
+          help_text(end+1) = first_sentence;
         endif
       endfor
     endif
   endfor
 
   if (nargout == 0)
-    ## Print the results (FIXME: improve this to make it look better.
+    ## Print the results (FIXME: it would be nice to break at word boundaries)
     indent = 20;
-    term_width = terminal_size() (2);
+    term_width = (terminal_size ())(2);
     desc_width = term_width - indent - 2;
-    indent_space = repmat (" ", 1, indent);
+    indent_space = blanks (indent);
     for k = 1:length (fun)
-      f = fun {k};
-      f (end+1:indent) = " ";
-      printf (f);
-      desc = strtrim (strrep (help_text {k}, "\n", " "));
+      f = fun{k};
+      f(end+1:indent-1) = " ";
+      puts ([f " "]);
+      lf = length (f);
+      desc = strtrim (strrep (help_text{k}, "\n", " "));
       ldesc = length (desc);
-      printf ("%s\n", desc (1:min (desc_width, ldesc)));
-      for start = desc_width+1:desc_width:ldesc
+      printf ("%s\n", desc(1:min (ldesc, desc_width - (lf - indent))));
+      for start = (desc_width - (lf - indent) + 1):desc_width:ldesc
         stop = min (start + desc_width, ldesc);
         printf ("%s%s\n", indent_space, strtrim (desc (start:stop)));
       endfor
     endfor
 
   else
     ## Return the results instead of displaying them
     out_fun = fun;
     out_help_text = help_text;
   endif
+
 endfunction
 
 function [funs, help_texts] = search_cache (str, cache_file, search_type)
   load (cache_file);
   if (! isempty (cache))
-    t1 = strfind (cache (1, :), str);
-    t2 = strfind (cache (search_type, :), str);
+    t1 = strfind (lower (cache (1, :)), str);
+    t2 = strfind (lower (cache (search_type, :)), str);
     cache_idx = find (! (cellfun ("isempty", t1) & cellfun ("isempty", t2)));
-    funs = cache (1, cache_idx);
-    help_texts = cache (3, cache_idx);
+    funs = cache(1, cache_idx);
+    help_texts = cache(3, cache_idx);
   else
     funs = help_texts = {};
   endif
 endfunction
+
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -24,22 +24,27 @@
 
 function txt = unimplemented (fcn)
 
   is_matlab_function = true;
 
   ## Some smarter cases, add more as needed.
   switch (fcn)
 
+  case "importdata"
+    txt = ["importdata is not implemented.  Similar functionality is ",...
+    "available through @code{load}, @code{dlmread}, @code{csvread}, ",...
+    "or @code{textscan}."];  
+
   case "quad2d"
     txt = ["quad2d is not implemented.  Consider using dblquad."];
 
   case "gsvd"
-    txt = ["gsvd is not currently part of Octave.  See the linear-algebra",...
-    "package at @url{http://octave.sf.net/linear-algebra/}."];
+    txt = ["gsvd is not currently part of core Octave.  See the ",
+    "linear-algebra package at @url{http://octave.sf.net/linear-algebra/}."];
 
   case "linprog"
     txt = ["Octave does not currently provide linprog.  ",...
     "Linear programming problems may be solved using @code{glpk}.  ",...
     "Try @code{help glpk} for more info."];
 
   case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", "ode45", "odeget", "odeset"}
     txt = ["Octave provides lsode for solving differential equations.  ",...
@@ -71,17 +76,16 @@ endfunction
 
 function list = missing_functions ()
   persistent list = {
   "DelaunayTri",
   "MException",
   "RandStream",
   "TriRep",
   "TriScatteredInterp",
-  "addpref",
   "align",
   "alim",
   "alpha",
   "alphamap",
   "annotation",
   "audiodevinfo",
   "audioplayer",
   "audiorecorder",
@@ -90,17 +94,16 @@ function list = missing_functions ()
   "auwrite",
   "avifile",
   "aviinfo",
   "aviread",
   "bar3",
   "bar3h",
   "bench",
   "betaincinv",
-  "bicg",
   "bicgstabl",
   "brush",
   "builddocsearchdb",
   "bvp4c",
   "bvp5c",
   "bvpget",
   "bvpinit",
   "bvpset",
@@ -183,17 +186,16 @@ function list = missing_functions ()
   "frame2im",
   "freqspace",
   "funm",
   "gallery",
   "gammaincinv",
   "gco",
   "getframe",
   "getpixelposition",
-  "getpref",
   "gmres",
   "grabcode",
   "graymon",
   "gsvd",
   "guidata",
   "guide",
   "guihandles",
   "handle",
@@ -228,17 +230,16 @@ function list = missing_functions ()
   "inspect",
   "instrfind",
   "instrfindall",
   "interpstreamspeed",
   "iscom",
   "isinterface",
   "isjava",
   "isocaps",
-  "ispref",
   "isstudent",
   "javaArray",
   "javaMethod",
   "javaMethodEDT",
   "javaObject",
   "javaObjectEDT",
   "javaaddpath",
   "javachk",
@@ -329,25 +330,23 @@ function list = missing_functions ()
   "quad2d",
   "questdlg",
   "rbbox",
   "recycle",
   "reducepatch",
   "reducevolume",
   "resample",
   "rgbplot",
-  "rmpref",
   "root",
   "rotate",
   "rotate3d",
   "selectmoveresize",
   "sendmail",
   "serial",
   "setpixelposition",
-  "setpref",
   "showplottool",
   "shrinkfaces",
   "smooth3",
   "snapnow",
   "sound",
   "soundsc",
   "ss2tf",
   "stream2",
@@ -392,24 +391,22 @@ function list = missing_functions ()
   "uitable",
   "uitoggletool",
   "uitoolbar",
   "uiwait",
   "undocheckout",
   "unicode2native",
   "unloadlibrary",
   "unmesh",
-  "usejava",
   "userpath",
   "validateattributes",
   "verLessThan",
   "viewmtx",
   "visdiff",
   "volumebounds",
-  "waitbar",
   "waitfor",
   "warndlg",
   "waterfall",
   "wavfinfo",
   "wavplay",
   "wavrecord",
   "web",
   "whatsnew",
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -23,18 +23,18 @@
 ## @example
 ## [v a*v a^2*v @dots{} a^(k+1)*v]
 ## @end example
 ##
 ## @noindent
 ## Using Householder reflections to guard against loss of orthogonality.
 ##
 ## If @var{V} is a vector, then @var{h} contains the Hessenberg matrix
-## such that @code{a*u == u*h+rk*ek'}, in which @code{rk =
-## a*u(:,k)-u*h(:,k)}, and @code{ek'} is the vector
+## such that @xcode{a*u == u*h+rk*ek'}, in which @code{rk =
+## a*u(:,k)-u*h(:,k)}, and @xcode{ek'} is the vector
 ## @code{[0, 0, @dots{}, 1]} of length @code{k}.  Otherwise, @var{h} is
 ## meaningless.
 ##
 ## If @var{V} is a vector and @var{k} is greater than
 ## @code{length(A)-1}, then @var{h} contains the Hessenberg matrix such
 ## that @code{a*u == u*h}.
 ##
 ## The value of @var{nu} is the dimension of the span of the Krylov
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -18,39 +18,46 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} delete (@var{file})
 ## @deftypefnx {Function File} {} delete (@var{handle})
 ## Delete the named file or graphics handle.
 ##
 ## Deleting graphics objects is the proper way to remove
 ## features from a plot without clearing the entire figure.
-## @seealso{clf, cla}
+## @seealso{clf, cla, unlink}
 ## @end deftypefn
 
 ## Author: jwe
 
 function delete (arg)
 
-  if (nargin == 1)
-    if (ischar (arg))
-      files = glob (arg).';
-      if (isempty (files))
-        warning ("delete: no such file: %s", arg);
-      endif
-      for i = 1:length (files)
-        file = files{i};
-        [err, msg] = unlink (file);
-        if (err)
-          warning ("delete: %s: %s", file, msg);
-        endif
-      endfor
-    elseif (all (ishandle (arg(:))))
-      ## Delete a graphics object.
-      __go_delete__ (arg);
-    else
-      error ("delete: first argument must be a filename or graphics handle");
-    endif
-  else
+  if (nargin != 1)
     print_usage ();
   endif
 
+  if (ischar (arg))
+    files = glob (arg);
+    if (isempty (files))
+      warning ("delete: no such file: %s", arg);
+    endif
+    for i = 1:length (files)
+      file = files{i};
+      [err, msg] = unlink (file);
+      if (err)
+        warning ("delete: %s: %s", file, msg);
+      endif
+    endfor
+  elseif (all (ishandle (arg(:))))
+    ## Delete a graphics object.
+    __go_delete__ (arg);
+  else
+    error ("delete: first argument must be a filename or graphics handle");
+  endif
+
 endfunction
+
+
+%% Test input validation
+%!error delete ()
+%!error delete (1, 2)
+%!error <first argument must be a filename> delete (struct ())
+
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -70,121 +70,118 @@ function retval = license (varargin)
     endif
   endif
 
   nout = nargout;
   nin = nargin;
   nr_licenses = rows (__octave_licenses__);
 
   if (nout > 1 || nin > 3)
-    error ("type `help license' for usage info");
+    print_usage ();
   endif
 
-  if (nin == 0)
+  if (nin == 0)  
 
-    found = false;
-    for p = 1:nr_licenses
-      if (strcmp (__octave_licenses__{p,1}, "Octave"))
-        found = true;
-        break;
-      endif
-    endfor
+    found = find (strcmp (__octave_licenses__(:,1), "Octave"), 1);
 
-    if (found)
-      result = __octave_licenses__{p,2};
+    if (! isempty (found))
+      result = __octave_licenses__{found,2};
     else
       result = "unknown";
     endif
 
     if (nout == 0)
       printf ("%s\n", result);
     else
       retval = result;
     endif
 
   elseif (nin == 1)
 
     if (nout == 0)
 
       if (! strcmp (varargin{1}, "inuse"))
-        usage ("license (\"inuse\")");
+        usage ('license ("inuse")');
       endif
 
-      for p = 1:nr_licenses
-        printf ("%s\n", __octave_licenses__{p,1});
-      endfor
+      printf ("%s\n", __octave_licenses__{:,1});
 
     else
 
       if (! strcmp (varargin{1}, "inuse"))
-        usage ("retval = license (\"inuse\")");
+        usage ('retval = license ("inuse")');
       endif
 
       pw = getpwuid (getuid ());
       if (isstruct (pw))
         username = pw.name;
       else
         username = "octave_user";
       endif
 
-      retval(1:nr_licenses) = struct ("feature", "", "user", "");
-      for p = 1:nr_licenses
-        retval(p).feature = __octave_licenses__{p,1};
-        retval(p).user = username;
-      endfor
+      retval = struct ("feature", __octave_licenses__(:,1), "user", username);
 
     endif
 
   else
 
     feature = varargin{2}(1:(min ([(length (varargin{2})), 27])));
 
     if (strcmp (varargin{1}, "test"))
 
-      found = false;
-      for p = 1:nr_licenses
-        if (strcmpi (feature, __octave_licenses__{p,1}))
-          found = true;
-          break;
-        endif
-      endfor
+      found = find (strcmpi (__octave_licenses__(:,1), feature), 1);
 
       if (nin == 2)
-        retval = found && __octave_licenses__{p,3};
+        retval = ! isempty (found) && __octave_licenses__{found,3};
       else
-        if (found)
+        if (! isempty (found))
           if (strcmp (varargin{3}, "enable"))
-            __octave_licenses__{p,3} = true;
+            __octave_licenses__{found,3} = true;
           elseif (strcmp (varargin{3}, "disable"))
-            __octave_licenses__{p,3} = false;
+            __octave_licenses__{found,3} = false;
           else
-            error ("TOGGLE must be either `enable' of `disable'");
+            error ("license: TOGGLE must be either `enable' or `disable'");
           endif
         else
-          error ("FEATURE `%s' not found", feature);
+          error ("license: FEATURE `%s' not found", feature);
         endif
       endif
 
     elseif (strcmp (varargin{1}, "checkout"))
 
       if (nin != 2)
-        usage ("retval = license (\"checkout\", feature)");
+        usage ('retval = license ("checkout", feature)');
       endif
 
-      found = false;
-      for p = 1:nr_licenses
-        if (strcmpi (feature, __octave_licenses__{p,1}))
-          found = true;
-          break;
-        endif
-      endfor
+      found = find (strcmpi (__octave_licenses__(:,1), feature), 1);
 
-      retval = found && __octave_licenses__{p,3};
+      retval = ! isempty (found) && __octave_licenses__{found,3};
 
     else
-
-      error ("type `help license' for usage info");
-
+      print_usage ();
     endif
 
   endif
 
 endfunction
+
+
+%!assert (license(), "GNU General Public License")
+%!assert ((license ("inuse")).feature, "Octave")
+
+%!test
+%! lstate = license ("test", "Octave");
+%! license ("test", "Octave", "disable");
+%! assert (license ("test", "Octave"), false);
+%! license ("test", "Octave", "enable");
+%! assert (license ("test", "Octave"), true);
+%! if (lstate == false)
+%!   license ("test", "Octave", "disable");
+%! endif
+
+%!assert (license ("checkout", "Octave"), true)
+
+%% Test input validation
+%!error license ("not_inuse")
+%!error <TOGGLE must be either> license ("test", "Octave", "not_enable")
+%!error <FEATURE `INVALID' not found> license ("test", "INVALID", "enable")
+%!error license ("not_test", "Octave", "enable")
+
diff --git a/scripts/miscellaneous/mexext.m b/scripts/miscellaneous/mexext.m
--- a/scripts/miscellaneous/mexext.m
+++ b/scripts/miscellaneous/mexext.m
@@ -14,13 +14,16 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mexext ()
 ## Return the filename extension used for MEX files.
+## @seealso{mex}
 ## @end deftypefn
 
 function retval = mexext ()
   retval = "mex";
 endfunction
+
+%!assert (mexext (), "mex")
diff --git a/scripts/miscellaneous/module.mk b/scripts/miscellaneous/module.mk
--- a/scripts/miscellaneous/module.mk
+++ b/scripts/miscellaneous/module.mk
@@ -46,16 +46,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/namelengthmax.m \
   miscellaneous/news.m \
   miscellaneous/orderfields.m \
   miscellaneous/pack.m \
   miscellaneous/paren.m \
   miscellaneous/parseparams.m \
   miscellaneous/perl.m \
   miscellaneous/python.m \
+  miscellaneous/recycle.m \
   miscellaneous/rmappdata.m \
   miscellaneous/run.m \
   miscellaneous/semicolon.m \
   miscellaneous/setappdata.m \
   miscellaneous/setfield.m \
   miscellaneous/substruct.m \
   miscellaneous/swapbytes.m \
   miscellaneous/symvar.m \
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/recycle.m
@@ -0,0 +1,66 @@
+## Copyright (C) 2011 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{current_state}} recycle ()
+## @deftypefnx  {Function File} {@var{old_state}} recycle (@var{new_state})
+## Display or set the preference for recycling deleted files.
+##
+## Recycling files instead of permanently deleting them is currently not
+## implemented in Octave.  To help avoid accidental data loss it
+## is an error to attempt enable file recycling.
+## @seealso{delete}
+## @end deftypefn
+
+## Author: jwe
+
+function retval = recycle (state)
+
+  persistent current_state = "off";
+
+  if (nargin > 1)
+    print_usage ();
+  endif
+
+  if (nargin == 0 || nargout > 0)
+    retval = current_state;
+  endif
+
+  if (nargin == 1)
+    if (ischar (state))
+      if (strcmpi (state, "on"))
+        error ("recycle: recycling files is not implemented");
+      elseif (strcmpi (state, "off"))
+        current_state = "off";
+      else
+        error ("recycle: invalid value of STATE = `%s'", state);
+      endif
+    else
+      erroor ("recycle: expecting STATE to be a character string");
+    endif
+  endif
+
+endfunction
+
+%!error recycle ("on");
+%!error recycle ("on", "and I mean it");
+%!error recycle (1);
+
+%!test
+%! recycle ("off");
+%! assert (recycle ("off"), "off");
diff --git a/scripts/miscellaneous/usejava.m b/scripts/miscellaneous/usejava.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/usejava.m
@@ -0,0 +1,67 @@
+## Copyright (C) 2011 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} usejava (@var{feature})
+## Return true if the specific Sun Java element @var{feature} is available.
+##
+## Possible features are:
+##
+## @table @asis
+## @item "awt"
+## Abstract Window Toolkit for GUIs.
+##
+## @item "desktop"
+## Interactive desktop is running.
+##
+## @item "jvm"
+## Java Virtual Machine.
+##
+## @item "swing"
+## Swing components for lightweight GUIs.
+## @end table
+##
+## This function is provided for compatability with @sc{matlab} scripts which
+## may alter their behavior based on the availability of Java.  Octave does
+## not implement an interface to Java and this function always returns
+## @code{false}.
+## @end deftypefn
+
+function retval = usejava (feature)
+
+  if (nargin != 1 || ! ischar (feature))
+    print_usage ();
+  endif
+
+  if (! any (strcmp (feature, {"awt", "desktop", "jvm", "swing"})))
+    error ("usejava: unrecognized feature '%s'", feature);
+  endif
+
+  retval = false;
+
+endfunction
+
+
+%!assert (usejava ("awt"), false)
+
+%% Test input validation
+%!error usejava ()
+%!error usejava (1, 2)
+%!error usejava (1)
+%!error <unrecognized feature> usejava ("abc")
+
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -13,27 +13,30 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @table @code
+## @item Octave:abbreviated-property-match
+## By default, the @code{Octave:abbreviated-property-match} warning is enabled.
+##
 ## @item Octave:array-to-scalar
 ## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a scalar value is
-## attempted.  By default, the @code{Octave:array-to-scalar} warning is
-## disabled.
+## attempted.
+## By default, the @code{Octave:array-to-scalar} warning is disabled.
 ##
 ## @item Octave:array-to-vector
 ## If the @code{Octave:array-to-vector} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a vector value is
-## attempted.  By default, the @code{Octave:array-to-vector} warning is
-## disabled.
+## attempted.
+## By default, the @code{Octave:array-to-vector} warning is disabled.
 ##
 ## @item Octave:assign-as-truth-value
 ## If the @code{Octave:assign-as-truth-value} warning is
 ## enabled, a warning is issued for statements like
 ##
 ## @example
 ## @group
 ## if (s = t)
@@ -101,90 +104,105 @@
 ##
 ## By default, the @code{Octave:assign-as-truth-value} warning is enabled.
 ##
 ## @item Octave:associativity-change
 ## If the @code{Octave:associativity-change} warning is
 ## enabled, Octave will warn about possible changes in the meaning of
 ## some code due to changes in associativity for some operators.
 ## Associativity changes have typically been made for @sc{matlab}
-## compatibility.  By default, the @code{Octave:associativity-change}
-## warning is enabled.
+## compatibility.
+## By default, the @code{Octave:associativity-change} warning is enabled.
 ##
 ## @item Octave:autoload-relative-file-name
 ## If the @code{Octave:autoload-relative-file-name} is enabled,
 ## Octave will warn when parsing autoload() function calls with relative
 ## paths to function files.  This usually happens when using autoload()
 ## calls in PKG_ADD files, when the PKG_ADD file is not in the same
 ## directory as the .oct file referred to by the autoload() command.
-## By default, the @code{Octave:autoload-relative-file-name}
-## warning is enabled.
+## By default, the @code{Octave:autoload-relative-file-name} warning is enabled.
+##
+## @item Octave:built-in-variable-assignment
+## By default, the @code{Octave:built-in-variable-assignment} warning is
+## enabled.
 ##
 ## @item Octave:divide-by-zero
 ## If the @code{Octave:divide-by-zero} warning is enabled, a
-## warning is issued when Octave encounters a division by zero.  By
-## default, the @code{Octave:divide-by-zero} warning is enabled.
-##
-## @item Octave:empty-list-elements
-## If the @code{Octave:empty-list-elements} warning is enabled, a
-## warning is issued when an empty matrix is found in a matrix list.
-## For example:
+## warning is issued when Octave encounters a division by zero.
+## By default, the @code{Octave:divide-by-zero} warning is enabled.
 ##
-## @example
-## a = [1, [], 3, [], 5]
-## @end example
-##
-## @noindent
-## By default, the @code{Octave:empty-list-elements} warning is enabled.
-##
-## @item Octave:fortran-indexing
-## If the @code{Octave:fortran-indexing} warning is enabled, a warning is
-## printed for expressions which select elements of a two-dimensional matrix
-## using a single index.  By default, the @code{Octave:fortran-indexing}
-## warning is disabled.
+## @item Octave:fopen-file-in-path
+## By default, the @code{Octave:fopen-file-in-path} warning is enabled.
 ##
 ## @item Octave:function-name-clash
 ## If the @code{Octave:function-name-clash} warning is enabled, a
 ## warning is issued when Octave finds that the name of a function
 ## defined in a function file differs from the name of the file.  (If
 ## the names disagree, the name declared inside the file is ignored.)
 ## By default, the @code{Octave:function-name-clash} warning is enabled.
 ##
 ## @item Octave:future-time-stamp
 ## If the @code{Octave:future-time-stamp} warning is enabled, Octave
 ## will print a warning if it finds a function file with a time stamp
-## that is in the future.  By default, the
-## @code{Octave:future-time-stamp} warning is enabled.
+## that is in the future.
+## By default, the @code{Octave:future-time-stamp} warning is enabled.
+##
+## @item Octave:glyph-render
+## By default, the @code{Octave:glyph-render} warning is enabled.
 ##
 ## @item Octave:imag-to-real
 ## If the @code{Octave:imag-to-real} warning is enabled, a warning is
 ## printed for implicit conversions of complex numbers to real numbers.
 ## By default, the @code{Octave:imag-to-real} warning is disabled.
 ##
+## @item Octave:load-file-in-path
+## By default, the @code{Octave:load-file-in-path} warning is enabled.
+##
+## @item Octave:logical-conversion
+## By default, the @code{Octave:logical-conversion} warning is enabled.
+##
 ## @item Octave:matlab-incompatible
 ## Print warnings for Octave language features that may cause
 ## compatibility problems with @sc{matlab}.
+## By default, the @code{Octave:matlab-incompatible} warning is disabled.
+##
+## @item Octave:md5sum-file-in-path
+## By default, the @code{Octave:md5sum-file-in-path} warning is enabled.
+##
+## @item Octave:missing-glyph
+## By default, the @code{Octave:missing-glyph} warning is enabled.
 ##
 ## @item Octave:missing-semicolon
 ## If the @code{Octave:missing-semicolon} warning is enabled, Octave
 ## will warn when statements in function definitions don't end in
-## semicolons.  By default the @code{Octave:missing-semicolon} warning
-## is disabled.
+## semicolons.
+## By default the @code{Octave:missing-semicolon} warning is disabled.
+##
+## @item Octave:mixed-string-concat
+## If the @code{Octave:mixed-string-concat} warning is enabled, print a
+## warning when concatenating a mixture of double and single quoted strings.
+## By default, the @code{Octave:mixed-string-concat} warning is disabled.
 ##
 ## @item Octave:neg-dim-as-zero
 ## If the @code{Octave:neg-dim-as-zero} warning is enabled, print a warning
 ## for expressions like
 ##
 ## @example
 ## eye (-1)
 ## @end example
 ##
 ## @noindent
 ## By default, the @code{Octave:neg-dim-as-zero} warning is disabled.
 ##
+## @item Octave:nested-functions-coerced
+## By default, the @code{Octave:nested-functions-coerced} warning is enabled.
+##
+## @item Octave:noninteger-range-as-index
+## By default, the @code{Octave:noninteger-range-as-index} warning is enabled.
+##
 ## @item Octave:num-to-str
 ## If the @code{Octave:num-to-str} warning is enable, a warning is
 ## printed for implicit conversions of numbers to their ASCII character
 ## equivalents when strings are constructed using a mixture of strings and
 ## numbers in matrix notation.  For example,
 ##
 ## @example
 ## @group
@@ -212,45 +230,61 @@
 ## @end example
 ##
 ## @noindent
 ## if you would like to enable this short-circuit evaluation in
 ## Octave.  Note that the @code{&&} and @code{||} operators always short
 ## circuit in both Octave and @sc{matlab}, so it's only necessary to
 ## enable @sc{matlab}-style short-circuiting it's too arduous to modify
 ## existing code that relies on this behavior.
+## By default, the @code{Octave:possible-matlab-short-circuit-operator} warning
+## is enabled.
 ##
 ## @item Octave:precedence-change
 ## If the @code{Octave:precedence-change} warning is enabled, Octave
 ## will warn about possible changes in the meaning of some code due to
 ## changes in precedence for some operators.  Precedence changes have
-## typically been made for @sc{matlab} compatibility.  By default, the
-## @code{Octave:precedence-change} warning is enabled.
+## typically been made for @sc{matlab} compatibility.
+## By default, the @code{Octave:precedence-change} warning is enabled.
+##
+## @item Octave:recursive-path-search
+## By default, the @code{Octave:recursive-path-search} warning is enabled.
 ##
 ## @item Octave:reload-forces-clear
 ## If several functions have been loaded from the same file, Octave must
 ## clear all the functions before any one of them can be reloaded.  If
 ## the @code{Octave:reload-forces-clear} warning is enabled, Octave will
 ## warn you when this happens, and print a list of the additional
-## functions that it is forced to clear.  By default, the
-## @code{Octave:reload-forces-clear} warning is enabled.
+## functions that it is forced to clear.
+## By default, the @code{Octave:reload-forces-clear} warning is enabled.
 ##
 ## @item Octave:resize-on-range-error
 ## If the @code{Octave:resize-on-range-error} warning is enabled, print a
 ## warning when a matrix is resized by an indexed assignment with
-## indices outside the current bounds.  By default, the
-## @code{Octave:resize-on-range-error} warning is disabled.
+## indices outside the current bounds.
+## By default, the ## @code{Octave:resize-on-range-error} warning is disabled.
 ##
 ## @item Octave:separator-insert
 ## Print warning if commas or semicolons might be inserted
 ## automatically in literal matrices.
+## By default, the @code{Octave:separator-insert} warning is disabled.
+##
+## @item Octave:shadowed-function
+## By default, the @code{Octave:shadowed-function} warning is enabled.
 ##
 ## @item Octave:single-quote-string
 ## Print warning if a single quote character is used to introduce a
 ## string constant.
+## By default, the @code{Octave:single-quote-string} warning is disabled.
+##
+## @item Octave:singular-matrix-div
+## By default, the @code{Octave:singular-matrix-div} warning is enabled.
+##
+## @item Octave:sqrtm:SingularMatrix
+## By default, the @code{Octave:sqrtm:SingularMatrix} warning is enabled.
 ##
 ## @item Octave:str-to-num
 ## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
 ## for implicit conversions of strings to their numeric ASCII equivalents.
 ## For example,
 ##
 ## @example
 ## @group
@@ -258,32 +292,27 @@
 ##      @result{} 97 98 99
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## elicits a warning if the @code{Octave:str-to-num} warning is enabled.
 ## By default, the @code{Octave:str-to-num} warning is disabled.
 ##
-## @item Octave:string-concat
-## If the @code{Octave:string-concat} warning is enabled, print a
-## warning when concatenating a mixture of double and single quoted strings.
-## By default, the @code{Octave:string-concat} warning is disabled.
-##
 ## @item Octave:undefined-return-values
 ## If the @code{Octave:undefined-return-values} warning is disabled,
 ## print a warning if a function does not define all the values in
-## the return list which are expected.  By default, the
-## @code{Octave:undefined-return-values} warning is enabled.
+## the return list which are expected.
+## By default, the @code{Octave:undefined-return-values} warning is enabled.
 ##
 ## @item Octave:variable-switch-label
 ## If the @code{Octave:variable-switch-label} warning is enabled, Octave
 ## will print a warning if a switch label is not a constant or constant
-## expression.  By default, the @code{Octave:variable-switch-label}
-## warning is disabled.
+## expression.
+## By default, the @code{Octave:variable-switch-label} warning is disabled.
 ## @end table
 
 function warning_ids ()
   help ("warning_ids");
 endfunction
 
 ## Remove from test statistics.  No real tests possible
 %!assert (1)
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -18,16 +18,67 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} optimset ()
 ## @deftypefnx {Function File} {} optimset (@var{par}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} optimset (@var{old}, @var{par}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} optimset (@var{old}, @var{new})
 ## Create options struct for optimization functions.
+##
+## Valid parameters are:
+## @itemize @bullet
+## @item AutoScaling
+##
+## @item ComplexEqn
+##
+## @item FinDiffType
+##
+## @item FunValCheck
+## When enabled, display an error if the objective function returns a complex
+## value or NaN@.  Must be set to "on" or "off" [default].
+##
+## @item GradObj
+## When set to "on", the function to be minimized must return a second argument
+## which is the gradient, or first derivative, of the function at the point
+## @var{x}.  If set to "off" [default], the gradient is computed via finite
+## differences.
+##
+## @item Jacobian
+## When set to "on", the function to be minimized must return a second argument
+## which is the Jacobian, or first derivative, of the function at the point
+## @var{x}.  If set to "off" [default], the Jacobian is computed via finite
+## differences.
+##
+## @item MaxFunEvals
+## Maximum number of function evaluations before optimization stops.
+## Must be a positive integer.
+##
+## @item MaxIter
+## Maximum number of algorithm iterations before optimization stops.
+## Must be a positive integer.
+##
+## @item OutputFcn
+## A user-defined function executed once per algorithm iteration.
+##
+## @item TolFun
+## Termination criterion for the function output.  If the difference in the
+## calculated objective function between one algorithm iteration and the next
+## is less than @code{TolFun} the optimization stops.  Must be a positive
+## scalar.
+##
+## @item TolX
+## Termination criterion for the function input.  If the difference in @var{x},
+## the current search point, between one algorithm iteration and the next is
+## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+##
+## @item TypicalX
+##
+## @item Updating
+## @end itemize
 ## @end deftypefn
 
 function retval = optimset (varargin)
 
   nargs = nargin ();
 
   ## Add more as needed.
   opts = __all_opts__ ();
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -38,27 +38,21 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = patch (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
 
-  oldh = gca ();
+  [tmp, failed] = __patch__ (h, varargin{:});
 
-  unwind_protect
-    axes (h);
-    [tmp, failed] = __patch__ (h, varargin{:});
-    if (failed)
-      print_usage ();
-    endif
-  unwind_protect_cleanup
-    axes (oldh);
-  end_unwind_protect
+  if (failed)
+    print_usage ();
+  endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!demo
@@ -202,24 +196,24 @@ endfunction
 %! p = patch (x, y, [1 32]);
 %! title ("Autoscaling of colors: Red UL and Blue LR triangles")
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = patch;
 %!   assert (findobj (hf, "type", "patch"), h);
-%!   assert (get (h, "xdata"), [0; 1; 1], eps);
-%!   assert (get (h, "ydata"), [0; 0; 1], eps);
+%!   assert (get (h, "xdata"), [0; 1; 0], eps);
+%!   assert (get (h, "ydata"), [1; 1; 0], eps);
 %!   assert (isempty(get (h, "zdata")));
 %!   assert (isempty(get (h, "cdata")));
 %!   assert (get (h, "faces"), [1, 2, 3], eps);
-%!   assert (get (h, "vertices"), [0 0; 1 0; 1 1], eps);
+%!   assert (get (h, "vertices"), [0 1; 1 1; 0 0], eps);
 %!   assert (get (h, "type"), "patch");
-%!   assert (get (h, "facecolor"), [0 0 1]);
+%!   assert (get (h, "facecolor"), [0 0 0]);
 %!   assert (get (h, "linestyle"), get (0, "defaultpatchlinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultpatchlinewidth"), eps);
 %!   assert (get (h, "marker"), get (0, "defaultpatchmarker"));
 %!   assert (get (h, "markersize"), get (0, "defaultpatchmarkersize"));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/private/__axis_label__.m
@@ -12,33 +12,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} __axis_label__ (@var{caller}, @var{txt}, @dots{})
+## @deftypefn {Function File} {} __axis_label__ (@var{caller}, @var{h}, @var{txt}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = __axis_label__ (caller, txt, varargin)
+function retval = __axis_label__ (ah, caller, txt, varargin)
 
-  ca = gca ();
-
-  h = get (gca (), caller);
+  h = get (ah, caller);
 
-  set (h, "fontangle", get (ca, "fontangle"),
-       "fontname", get (ca, "fontname"),
-       "fontsize", get (ca, "fontsize"),
-       "fontunits", get (ca, "fontunits"),
-       "fontweight", get (ca, "fontweight"),
+  set (h, "fontangle", get (ah, "fontangle"),
+       "fontname", get (ah, "fontname"),
+       "fontsize", get (ah, "fontsize"),
+       "fontunits", get (ah, "fontunits"),
+       "fontweight", get (ah, "fontweight"),
        "string", txt,
        varargin{:});
 
   if (nargout > 0)
     retval = h;
   endif
 
 endfunction
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -342,38 +342,44 @@ function __go_draw_axes__ (h, plot_strea
     ylogscale = strcmpi (axis_obj.yscale, "log");
     zlogscale = strcmpi (axis_obj.zscale, "log");
 
     ## Detect logscale and negative lims
     if (xlogscale && all (axis_obj.xlim < 0))
       axis_obj.xsgn = -1;
       if (strcmp (axis_obj.xdir, "reverse"))
         axis_obj.xdir = "normal";
+      elseif (strcmp (axis_obj.xdir, "normal"))
+        axis_obj.xdir = "reverse";
       endif
       axis_obj.xtick = -flip (axis_obj.xtick);
       axis_obj.xticklabel = flip (axis_obj.xticklabel);
       axis_obj.xlim = -flip (axis_obj.xlim);
     else
       axis_obj.xsgn = 1;
     endif
     if (ylogscale && all (axis_obj.ylim < 0))
       axis_obj.ysgn = -1;
       if (strcmp (axis_obj.ydir, "reverse"))
         axis_obj.ydir = "normal";
+      elseif (strcmp (axis_obj.ydir, "normal"))
+        axis_obj.ydir = "reverse";
       endif
       axis_obj.ytick = -flip (axis_obj.ytick);
       axis_obj.yticklabel = flip (axis_obj.yticklabel);
       axis_obj.ylim = -flip (axis_obj.ylim);
     else
       axis_obj.ysgn = 1;
     endif
     if (zlogscale && all (axis_obj.zlim < 0))
       axis_obj.zsgn = -1;
       if (strcmp (axis_obj.zdir, "reverse"))
         axis_obj.zdir = "normal";
+      elseif (strcmp (axis_obj.zdir, "normal"))
+        axis_obj.zdir = "reverse";
       endif
       axis_obj.ztick = -flip (axis_obj.ztick);
       axis_obj.zticklabel = flip (axis_obj.zticklabel);
       axis_obj.zlim = -flip (axis_obj.zlim);
     else
       axis_obj.zsgn = 1;
     endif
 
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -29,17 +29,17 @@
 
 function [h, failed] = __patch__ (p, varargin)
 
   failed = false;
 
   is_numeric_arg = cellfun (@isnumeric, varargin);
 
   if (isempty (varargin))
-    args = {"xdata", [0; 1; 1], "ydata", [0; 0; 1], "facecolor", "blue"};
+    args = {"xdata", [0; 1; 0], "ydata", [1; 1; 0], "facecolor", [0, 0, 0]};
     args = setvertexdata (args);
   elseif (isstruct (varargin{1}))
     if (isfield (varargin{1}, "vertices") && isfield (varargin{1}, "faces"))
       args{1} = "faces";
       args{2} = getfield(varargin{1}, "faces");
       args{3} = "vertices";
       args{4} = getfield(varargin{1}, "vertices");
       args{5} = "facevertexcdata";
@@ -125,19 +125,19 @@ function [h, failed] = __patch__ (p, var
             args{8} = "flat";
             args{9} = "cdata";
             args{10} = c;
           else
             error ("patch: color value not valid");
           endif
         elseif (size (c, ndims (c)) == 3)
           args{7} = "facecolor";
-          args{8} = "flat";
+          args{8} = c;
           args{9} = "cdata";
-          args{10} = c;
+          args{10} = [];
         else
           ## Color Vectors
           if (isempty (c))
             args{7} = "facecolor";
             args{8} = "interp";
             args{9} = "cdata";
             args{10} = [];
           elseif (isequal (size (c), size (x)) && isequal (size (c), size (y)))
@@ -234,22 +234,20 @@ function args = setdata (args)
   else
     fc = args {idx};
   endif
 
   nr = size (faces, 2);
   nc = size (faces, 1);
   idx = faces .';
   t1 = isnan (idx);
-  if (any (t1(:)))
-    t2 = find (t1 != t1([2:end,end],:));
-    idx (t1) = idx (t2 (cell2mat (cellfun (@(x) x(1)*ones(1,x(2)),
-                mat2cell ([1 : nc; sum(t1)], 2, ones(1,nc)),
-                                           "uniformoutput", false))));
-  endif
+  for i = find (any (t1))
+    first_idx_in_column = find (t1(:,i), 1);
+    idx(first_idx_in_column:end,i) = idx(first_idx_in_column-1,i);
+  endfor
   x = reshape (vert(:,1)(idx), size (idx));
   y = reshape (vert(:,2)(idx), size (idx));
   if (size(vert,2) > 2)
     z = reshape (vert(:,3)(idx), size (idx));
   else
     z = [];
   endif
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -62,27 +62,41 @@ endfunction
 
 %!demo
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
 
 %!demo
 %! clf ();
-%! a = logspace (-5, 1, 10);
-%! b =-logspace (-5, 1, 10);
+%! x = logspace (-5, 1, 10);
+%! y = logspace (-5, 1, 10);
 %!
 %! subplot (1, 2, 1)
-%! semilogx (b, a)
-%! xlabel ('semilogx (a, b)')
+%! semilogx (x, y)
+%! xlabel ('semilogx (x, y)')
 %!
 %! subplot (1, 2, 2)
-%! semilogx (abs (b), a)
-%! set (gca, 'ydir', 'reverse')
-%! xlabel ('semilogx (a, abs (b))')
+%! semilogx (-x, y)
+%! xlabel ('semilogx (-x, y)')
+
+%!demo
+%! clf ();
+%! x = logspace (-5, 1, 10);
+%! y = logspace (-5, 1, 10);
+%!
+%! subplot (1, 2, 1)
+%! semilogx (x, y)
+%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition")
+%! xlabel ({"semilogx (x, y)", "xdir = reversed"})
+%!
+%! subplot (1, 2, 2)
+%! semilogx (-x, y)
+%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition")
+%! xlabel ({"semilogx (-x, y)","xdir = reversed"})
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   semilogx (a, b)
 %!   assert (get (gca, "xscale"), "log");
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -63,27 +63,41 @@ endfunction
 
 %!demo
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
 %! clf ();
-%! a = logspace (-5, 1, 10);
-%! b =-logspace (-5, 1, 10);
+%! x = logspace (-5, 1, 10);
+%! y = logspace (-5, 1, 10);
+%!
+%! subplot (2, 1, 1)
+%! semilogy (x, y)
+%! ylabel ('semilogy (x, y)')
 %!
-%! subplot (1, 2, 1)
-%! semilogy (a, b)
-%! xlabel ('semilogy (a, b)')
+%! subplot (2, 1, 2)
+%! semilogy (x, -y)
+%! ylabel ('semilogy (x, -y)')
+
+%!demo
+%! clf ();
+%! x = logspace (-5, 1, 10);
+%! y = logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 2)
-%! semilogy (a, abs (b))
-%! set (gca, 'ydir', 'reverse')
-%! xlabel ('semilogy (a, abs (b))')
+%! subplot (2, 1, 1)
+%! semilogy (x, y)
+%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition")
+%! ylabel ({"semilogy (x, y)", "ydir = reversed"})
+%!
+%! subplot (2, 1, 2)
+%! semilogy (x, -y)
+%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition")
+%! ylabel ({"semilogy (x, -y)", "ydir = reversed"})
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   semilogy (a, b)
 %!   assert (get (gca, "yscale"), "log");
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -61,66 +61,106 @@
 ##
 ## @end ifnottex
 ## @seealso{axes, plot}
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
-function h = subplot (rows, cols, index, varargin)
+function h = subplot (varargin)
 
   align_axes = false;
   replace_axes = false;
+  have_position = false;
+  initial_args_decoded = false;
 
-  if (! (nargin >= 3) && nargin != 1)
-    print_usage ();
-  elseif (nargin > 3)
-    for n = 1:numel(varargin)
-      switch lower(varargin{n})
-      case "align"
-        align_axes = true;
-      case "replace"
-        replace_axes = true;
-      otherwise
-        print_usage ();
-      endswitch
-    endfor
+  if (nargin > 2)
+    ## R, C, N?
+    arg1 = varargin{1};
+    arg2 = varargin{2};
+    arg3 = varargin{3};
+    if (isnumeric (arg1) && isscalar (arg1) && isnumeric (arg2)
+        && isscalar (arg2) && isnumeric (arg3))
+      rows = arg1;
+      cols = arg2;
+      index = arg3;
+      varargin(1:3)= [];
+      initial_args_decoded = true;
+    endif
   endif
 
-  if (nargin == 1)
+  if (! initial_args_decoded && nargin > 1)
+    ## check for 'position', pos, ...
+    if (strcmpi (varargin{1}, "position"))
+      arg = varargin{2};
+      if (isnumeric (arg) && numel (arg) == 4)
+        pos = arg;
+        varargin(1:2) = [];
+        have_position = true;
+        initial_args_decoded = true;
+      else
+        error ("expecting position to be a 4-element numeric array");
+      endif
+    endif
+  endif
+    
+  if (! initial_args_decoded && nargin > 0)
+    arg = varargin{1};
+    if (nargin == 1 && ishandle (arg))
+      ## Axes handle?
+      axes (arg);
+      cf = get (0, "currentfigure");
+      set (cf, "nextplot", "add");
+      return;
+    elseif (isscalar (arg) && arg >= 0)
+      ## RCN?
+      index = rem (arg, 10);
+      arg = (arg - index) / 10;
+      cols = rem (arg, 10);
+      arg = (arg - cols) / 10;
+      rows = rem (arg, 10);
+      varargin(1) = [];
+      initial_args_decoded = true;
+    else
+      error ("subplot: expecting axes handle or RCN argument");
+    endif
+  endif
 
-    if (! (isscalar (rows) && rows >= 0))
-      error ("subplot: input RCN has to be a positive scalar");
+  if (! initial_args_decoded)
+    print_usage ();
+  endif
+
+  if (! have_position)
+    cols = round (cols);
+    rows = round (rows);
+    index = round (index);
+
+    if (any (index < 1) || any (index > rows*cols))
+      error ("subplot: INDEX value must be greater than 1 and less than ROWS*COLS");
     endif
 
-    tmp = rows;
-    index = rem (tmp, 10);
-    tmp = (tmp - index) / 10;
-    cols = rem (tmp, 10);
-    tmp = (tmp - cols) / 10;
-    rows = rem (tmp, 10);
-
-  elseif (! (isscalar (cols) && isscalar (rows)))
-    error ("subplot: COLS, and ROWS must be scalars");
-  elseif (any (index < 1) || any (index > rows*cols))
-    error ("subplot: INDEX value must be greater than 1 and less than ROWS*COLS");
+    if (cols < 1 || rows < 1 || index < 1)
+      error ("subplot: COLS, ROWS, and INDEX must be be positive");
+    endif
   endif
 
-  cols = round (cols);
-  rows = round (rows);
-  index = round (index);
-
-  if (index > cols*rows)
-    error ("subplot: INDEX must be less than COLS*ROWS");
-  endif
-
-  if (cols < 1 || rows < 1 || index < 1)
-    error ("subplot: COLS,ROWS,INDEX must be be positive");
-  endif
+  nargs = numel (varargin);
+  while (nargs > 0)
+    arg = varargin{1};
+    if (strcmpi (arg, "align"))
+      align_axes = true;
+    elseif (strcmpi (arg, "replace"))
+      replace_axes = true;
+    else
+      break;
+    endif
+    varargin(1) = [];
+    nargs--;
+  endwhile
 
   axesunits = get (0, "defaultaxesunits");
   cf = gcf ();
   figureunits = get (cf, "units");
   unwind_protect
     units = "normalized";
     set (0, "defaultaxesunits", units);
     set (cf, "units", "pixels");
@@ -128,22 +168,24 @@ function h = subplot (rows, cols, index,
     ## FIXME: At the moment we force gnuplot to use the aligned mode
     ##        which will set "activepositionproperty" to "position".
     ##        Τhis can yield to text overlap between labels and titles
     ##        see bug #31610
     if (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
       align_axes = true;
     endif
 
-    if (align_axes)
-      pos = subplot_position (rows, cols, index, "position");
-    elseif (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
-      pos = subplot_position (rows, cols, index, "outerpositiontight");
-    else
-      pos = subplot_position (rows, cols, index, "outerposition");
+    if (! have_position)
+      if (align_axes)
+        pos = subplot_position (rows, cols, index, "position");
+      elseif (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
+        pos = subplot_position (rows, cols, index, "outerpositiontight");
+      else
+        pos = subplot_position (rows, cols, index, "outerposition");
+      endif
     endif
 
     set (cf, "nextplot", "add");
 
     found = false;
     kids = get (cf, "children");
     for child = reshape (kids, 1, numel (kids))
       ## Check whether this child is still valid; this might not be the
@@ -185,22 +227,22 @@ function h = subplot (rows, cols, index,
           endif
         endif
       endif
     endfor
 
     if (found)
       set (cf, "currentaxes", tmp);
     elseif (align_axes)
-      tmp = axes ("box", "off", "position", pos);
+      tmp = axes ("box", "off", "position", pos, varargin{:});
     elseif (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
-      tmp = axes ("box", "off", "outerposition", pos);
+      tmp = axes ("box", "off", "outerposition", pos, varargin{:});
     else
       tmp = axes ("looseinset", [0 0 0 0], "box", "off", "outerposition", pos,
-                  "autopos_tag", "subplot");
+                  "autopos_tag", "subplot", varargin{:});
     endif
 
   unwind_protect_cleanup
     set (0, "defaultaxesunits", axesunits);
     set (cf, "units", figureunits);
   end_unwind_protect
 
   if (nargout > 0)
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -14,33 +14,37 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} title (@var{string})
 ## @deftypefnx {Function File} {} title (@var{string}, @var{p1}, @var{v1}, @dots{})
+## @deftypefnx {Function File} {} title (@var{h}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} title (@dots{})
 ## Create a title object and return a handle to it.
 ## @end deftypefn
 
 ## Author: jwe
 
-function h = title (string, varargin)
+function retval = title (varargin)
+
+  [h, varargin, nargin] = __plt_get_axis_arg__ ("title", varargin{:});
 
-  if (rem (nargin, 2) == 1)
-    if (nargout > 0)
-      h = __axis_label__ ("title", string, varargin{:});
-    else
-      __axis_label__ ("title", string, varargin{:});
-    endif
-  else
+  if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
+  tmp = __axis_label__ (h, "title", varargin{:});
+
+  if (nargout > 0)
+    retval = tmp;
+  endif
+
 endfunction
 
 %!demo
 %! clf ();
 %! ax=axes();
 %! xl = get(ax,"title");
 %! title("Testing title")
 %! assert(get(xl,"string"),"Testing title")
diff --git a/scripts/plot/waitbar.m b/scripts/plot/waitbar.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/waitbar.m
@@ -0,0 +1,184 @@
+## Copyright (C) 2011 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{h} =} waitbar (@var{frac})
+## @deftypefnx {Function File} {@var{h} =} waitbar (@var{frac}, @var{msg})
+## @deftypefnx {Function File} {@var{h} =} waitbar (@dots{}, "FigureProperty", "Value", @dots{})
+## @deftypefnx {Function File} {} waitbar (@var{frac})
+## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar})
+## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar}, @var{msg})
+## Return a handle @var{h} to a new waitbar object.  The waitbar is
+## filled to fraction @var{frac} which must be in the range [0, 1].  The
+## optional message @var{msg} is centered and displayed above the waitbar.
+## The appearance of the waitbar figure window can be configured by passing 
+## property/value pairs to the function.
+## 
+## When called with a single input the current waitbar, if it exists, is
+## updated to the new value @var{frac}.  If there are multiple outstanding
+## waitbars they can be updated individually by passing the handle @var{hwbar}
+## of the specific waitbar to modify.
+## @end deftypefn
+
+## Author: jwe
+
+function retval = waitbar (varargin)
+
+  persistent curr_waitbar;
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  frac = varargin{1};
+  varargin(1) = [];
+
+  if (! (isnumeric (frac) && isscalar (frac) && frac >= 0 && frac <= 1))
+    error ("waitbar: FRAC must be between 0 and 1");
+  endif
+
+  ## Use existing waitbar if it still points to a valid graphics handle.
+  if (nargin == 1 && ishandle (curr_waitbar))
+    h = curr_waitbar;
+  else
+    h = false;
+  endif
+
+  if (! isempty (varargin) && isnumeric (varargin{1}))
+    if (! ishandle (varargin{1}))
+      error ("waitbar: H must be a handle to a waitbar object");
+    else
+      h = varargin{1};
+      varargin(1) = [];
+      if (! isfigure (h) || ! strcmp (get (h, "tag"), "waitbar"))
+        error ("waitbar: H must be a handle to a waitbar object");
+      endif
+    endif
+  endif
+
+  msg = false;
+
+  if (! isempty (varargin))
+    msg = varargin{1};
+    varargin(1) = [];
+    if (! (ischar (msg) || iscellstr (msg)))
+      error ("waitbar: MSG must be a character string or cell array of strings");
+    endif
+  endif
+
+  if (rem (numel (varargin), 2) != 0)
+    error ("waitbar: invalid number of property-value pairs");
+  endif
+
+  if (h)
+    p = findobj (h, "type", "patch");
+    set (p, "xdata", [0; frac; frac; 0]);
+    ax = findobj (h, "type", "axes");
+    if (ischar (msg) || iscellstr (msg))
+      th = get (ax, "title");
+      curr_msg = get (th, "string");
+      cmp = strcmp (msg, curr_msg);
+      if (all (cmp(:)))
+        set (th, "string", msg);
+      endif
+    endif
+  else
+    h = __go_figure__ (NaN, "position", [250, 500, 400, 100],
+                       "numbertitle", "off",
+                       "toolbar", "none", "menubar", "none",
+                       "integerhandle", "off",
+                       "handlevisibility", "callback",
+                       "tag", "waitbar",
+                       varargin{:});
+
+    ax = axes ("parent", h, "xtick", [], "ytick", [],
+               "xlim", [0, 1], "ylim", [0, 1],
+               "xlimmode", "manual", "ylimmode", "manual",
+               "position", [0.1, 0.3, 0.8, 0.2]);
+
+    patch (ax, [0; frac; frac; 0], [0; 0; 1; 1], [0, 0.35, 0.75]);
+
+    if (! (ischar (msg) || iscellstr (msg)))
+      msg = "Please wait...";
+    endif
+    title (ax, msg);
+  endif
+
+  drawnow ();
+
+  if (nargout > 0)
+    retval = h;
+  endif
+
+  ## If there were no errors, update current waitbar.
+  curr_waitbar = h;
+
+endfunction
+
+
+%!demo
+%! h = waitbar (0, "0.00%");
+%! for i = 0:0.01:1
+%!   waitbar (i, h, sprintf ("%.2f%%", 100*i));
+%! endfor
+%! close (h);
+
+%!demo
+%! h = waitbar (0, "please wait...");
+%! for i = 0:0.01:0.6
+%!   waitbar (i);
+%! endfor
+%! i = 0.3
+%! waitbar (i, h, "don't you hate taking a step backward?")
+%! pause (0.5);
+%! for i = i:0.005:0.7
+%!   waitbar (i, h);
+%! endfor
+%! waitbar (i, h, "or stalling?")
+%! pause (1);
+%! for i = i:0.003:0.8
+%!   waitbar (i, h, "just a little longer now")
+%! endfor
+%! for i = i:0.001:1
+%!   waitbar (i, h, "please don't be impatient")
+%! endfor
+%! close (h);
+
+%!demo
+%! h1 = waitbar (0, "Waitbar #1");
+%! h2 = waitbar (0, "Waitbar #2");
+%! h2pos = get (h2, "position");
+%! h2pos(1) += h2pos(3) + 50;
+%! set (h2, "position", h2pos);
+%! pause (0.5);
+%! for i = 1:4
+%!   waitbar (i/4, h1);
+%!   pause (0.5);
+%!   waitbar (i/4, h2);
+%!   pause (0.5);
+%! endfor
+%! pause (0.5);
+%! close (h1);
+%! close (h2);
+
+%% Test input validation
+%!error <FRAC must be between 0 and 1> waitbar (-0.5)
+%!error <FRAC must be between 0 and 1> waitbar (1.5)
+%!error <MSG must be a character string> waitbar (0.5, struct ())
+%!error <invalid number of property-value pairs> waitbar (0.5, "msg", "Name")
+
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -34,24 +34,18 @@
 function retval = xlabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
 
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
-  oldh = gca ();
-  unwind_protect
-    axes (h);
-    tmp = __axis_label__ ("xlabel", varargin{:},
-                          "color", get (h, "xcolor"));
-  unwind_protect_cleanup
-    axes (oldh);
-  end_unwind_protect
+  tmp = __axis_label__ (h, "xlabel", varargin{:},
+                        "color", get (h, "xcolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -28,24 +28,18 @@
 function retval = ylabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("ylabel", varargin{:});
 
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
-  oldh = gca ();
-  unwind_protect
-    axes (h);
-    tmp = __axis_label__ ("ylabel", varargin{:},
-                          "color", get (h, "ycolor"));
-  unwind_protect_cleanup
-    axes (oldh);
-  end_unwind_protect
+  tmp = __axis_label__ (h, "ylabel", varargin{:},
+                        "color", get (h, "ycolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -28,24 +28,18 @@
 function retval = zlabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("zlabel", varargin{:});
 
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
-  oldh = gca ();
-  unwind_protect
-    axes (h);
-    tmp = __axis_label__ ("zlabel", varargin{:},
-                          "color", get (h, "zcolor"));
-  unwind_protect_cleanup
-    axes (oldh);
-  end_unwind_protect
+  tmp = __axis_label__ (h, "zlabel", varargin{:},
+                        "color", get (h, "zcolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -42,21 +42,42 @@
 ## @item @var{d}
 ## Number of polynomials defined for each interval.
 ## @end table
 ##
 ## @seealso{mkpp, ppval, spline}
 ## @end deftypefn
 
 function [x, P, n, k, d] = unmkpp (pp)
-  if (nargin == 0)
+
+  if (nargin != 1)
     print_usage ();
   endif
-  if (! (isstruct (pp) && strcmp (pp.form, "pp")))
-    error ("unmkpp: expecting piecewise polynomial structure");
+  if (! (isstruct (pp) && isfield (pp, "form") && strcmp (pp.form, "pp")))
+    error ("unmkpp: PP must be a piecewise polynomial structure");
   endif
   x = pp.breaks;
   P = pp.coefs;
   n = pp.pieces;
   k = pp.order;
   d = pp.dim;
 
 endfunction
+
+
+%!test
+%! b = 1:3;
+%! c = 1:24;
+%! pp = mkpp (b,c);
+%! [x, P, n, k, d] = unmkpp (pp);
+%! assert (x, b);
+%! assert (P, reshape (c, [2 12]));
+%! assert (n, 2);
+%! assert (k, 12);
+%! assert (d, 1);
+
+%% Test input validation
+%!error unmkpp ()
+%!error unmkpp (1,2)
+%!error <piecewise polynomial structure> unmkpp (1)
+%!error <piecewise polynomial structure> unmkpp (struct ("field1", "pp"))
+%!error <piecewise polynomial structure> unmkpp (struct ("form", "not_a_pp"))
+
diff --git a/scripts/prefs/ispref.m b/scripts/prefs/ispref.m
--- a/scripts/prefs/ispref.m
+++ b/scripts/prefs/ispref.m
@@ -33,16 +33,17 @@
 
 ## Author: jwe
 
 function retval = ispref (group, pref)
 
   if (nargin == 1)
     retval = isfield (loadprefs (), group);
   elseif (nargin == 2)
+    prefs = loadprefs ();
     if (isfield (prefs, group))
       grp = prefs.(group);
       if (ischar (pref) || iscellstr (pref))
         retval = isfield (grp, pref);
       else
         retval = false;
       endif
     else
diff --git a/scripts/prefs/private/prefsfile.m b/scripts/prefs/private/prefsfile.m
--- a/scripts/prefs/private/prefsfile.m
+++ b/scripts/prefs/private/prefsfile.m
@@ -20,15 +20,34 @@
 ## @deftypefn  {Function File} {} prefsfile ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = prefsfile ()
 
-  retval = "~/.octave-prefs";
+  retval = "~/.octave_prefs";
+
+  ## Transition users to new filename if necessary
+  ## FIXME: Delete before 3.6.0 release
+  oldname = tilde_expand ("~/.octave-prefs");
+  if (exist (oldname, "file"))
+    newname = tilde_expand (retval); 
+    if (exist (newname, "file"))
+      error (["Octave uses the file ~/.octave_prefs to store preferences.\n",...
+              "       The old file name was ~/.octave-prefs.\n",...
+              "       Both files exist."...
+              "  User must manually delete one of the files.\n"]);
+    endif
+    status = movefile (oldname, newname);
+    if (! status)
+      error (["Octave uses the file ~/.octave_prefs to store preferences.\n",
+             "        The old file name was ~/.octave-prefs.\n",
+             "        User must manually rename the old file to the new name.\n"]);
+    endif
+  endif
 
 endfunction
 
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -217,34 +217,35 @@ endfunction;
 %! b = sum (A, 2);
 %! tol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 %!
+
+%!function y = afun (x, t, a)
+%!  switch t
+%!   case "notransp"
+%!     y = a * x;
+%!   case "transp"
+%!     y = a' * x;
+%!  endswitch
+%!endfunction
+%!
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %!
-%! function y = afun (x, t, a)
-%!  switch t
-%!   case "notransp"
-%!     y = a * x;
-%!   case "transp"
-%!     y = a' * x;
-%!  endswitch
-%! endfunction
-%!
 %! [x, flag, relres, iter, resvec] = bicg (@(x, t) afun (x, t, A),
 %!                                         b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -212,23 +212,23 @@ endfunction
 %! tol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 %!
 %!test
+%!function y = afun (x, a)
+%!  y = a * x;
+%!endfunction
+%!
 %! tol = 1e-8;
 %! maxit = 15;
 %!
-%! function y = afun (x, a)
-%!     y = a * x;
-%! endfunction
-%!
 %! [x, flag, relres, iter, resvec] = bicgstab (@(x) afun (x, A), b,
 %!                                             tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} etreeplot (@var{A})
 ## @deftypefnx {Function File} {} etreeplot (@var{A}, @var{node_style}, @var{edge_style})
 ## Plot the elimination tree of the matrix @var{A} or
-## @code{@var{A}+@var{A}'} if @var{A} in not symmetric.  The optional
+## @xcode{@var{A}+@var{A}'} if @var{A} in not symmetric.  The optional
 ## parameters @var{node_style} and @var{edge_style} define the output
 ## style.
 ## @seealso{treeplot, gplot}
 ## @end deftypefn
 
 function etreeplot (A, varargin)
 
   if (nargin < 1)
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -104,22 +104,22 @@ function [beta, sigma, r] = ols (y, x)
     x = double (x);
   endif
   if (isinteger (y))
     y = double (y);
   endif
 
   ## Start of algorithm
   z = x' * x;
-  rnk = rank (z);
+  [u, p] = chol (z);
 
-  if (rnk == nc)
-    beta = inv (z) * x' * y;
+  if (p)
+    beta = pinv (x) * y;
   else
-    beta = pinv (x) * y;
+    beta = u \ (u' \ (x' * y));
   endif
 
   if (isargout (2) || isargout (3))
     r = y - x * beta;
   endif
   if (isargout (2))
     sigma = r' * r / (nr - rnk);
   endif
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -18,25 +18,25 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} var (@var{x})
 ## @deftypefnx {Function File} {} var (@var{x}, @var{opt})
 ## @deftypefnx {Function File} {} var (@var{x}, @var{opt}, @var{dim})
 ## Compute the variance of the elements of the vector @var{x}.
 ## @tex
 ## $$
-## {\rm std} (x) = \sigma^2 = {\sum_{i=1}^N (x_i - \bar{x})^2 \over N - 1}
+## {\rm var} (x) = \sigma^2 = {\sum_{i=1}^N (x_i - \bar{x})^2 \over N - 1}
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-## std (x) = 1/(N-1) SUM_i (x(i) - mean(x))^2
+## var (x) = 1/(N-1) SUM_i (x(i) - mean(x))^2
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the variance for each column
 ## and return them in a row vector.
 ##
 ## The argument @var{opt} determines the type of normalization to use.
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -39,41 +39,32 @@
 ## @end example
 ## @seealso{strcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
 
 function st = cstrcat (varargin)
 
-  if (nargin > 0)
+  if (nargin < 1)
+    print_usage ();
+  elseif (! iscellstr (varargin))
+    error ("cstrcat: expecting arguments to character strings");
+  endif
 
-    if (iscellstr (varargin))
-      ## All arguments are character strings.
-      unwind_protect
-        tmp = warning ("query", "Octave:empty-list-elements");
-        warning ("off", "Octave:empty-list-elements");
-        st = [varargin{:}];
-      unwind_protect_cleanup
-        warning (tmp.state, "Octave:empty-list-elements");
-      end_unwind_protect
-    else
-      error ("cstrcat: expecting arguments to character strings");
-    endif
-  else
-    print_usage ();
-  endif
+  st = [varargin{:}];
 
 endfunction
 
-## test the dimensionality
-## 1d
-%!assert(cstrcat("ab ", "ab "), "ab ab ")
-## 2d
-%!assert(cstrcat(["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
 
-%!assert((strcmp (cstrcat ("foo", "bar"), "foobar")
-%! && strcmp (cstrcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])));
+## Test the dimensionality
+## 1d
+%!assert (cstrcat ("ab ", "ab "), "ab ab ")
+## 2d
+%!assert (cstrcat (["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
 
+%!assert (cstrcat ("foo", "bar"), "foobar")
+%!assert (cstrcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])
+
+%% Test input validation
 %!error cstrcat ();
-
 %!error cstrcat (1, 2);
 
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -12,23 +12,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{cstr}] =} strsplit (@var{p}, @var{sep}, @var{strip_empty})
-## Split a string using one or more delimiters and return a cell
-## array of strings.  Consecutive delimiters and delimiters at
+## @deftypefn  {Function File} {[@var{cstr}] =} strsplit (@var{s}, @var{sep})
+## @deftypefnx {Function File} {[@var{cstr}] =} strsplit (@var{s}, @var{sep}, @var{strip_empty})
+## Split the string @var{s} using one or more separators @var{sep} and return
+## a cell array of strings.  Consecutive separators and separators at
 ## boundaries result in empty strings, unless @var{strip_empty} is true.
 ## The default value of @var{strip_empty} is false.
 ##
-## 2-D character arrays are split at delimiters and at the original column
+## 2-D character arrays are split at separators and at the original column
 ## boundaries.
 ##
 ## Example:
 ## @example
 ## strsplit ("a,b,c", ",")
 ##        @result{}
 ##           @{
 ##             [1,1] = a
@@ -44,73 +45,73 @@
 ##             [1,3] = cde
 ##           @}
 ## @group
 ## @end group
 ## @end example
 ## @seealso{strtok}
 ## @end deftypefn
 
-function s = strsplit (p, sep, strip_empty = false)
+function cstr = strsplit (s, sep, strip_empty = false)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
-  elseif (! ischar (p) || ! ischar (sep))
-    error ("strsplit: P and SEP must be string values");
+  elseif (! ischar (s) || ! ischar (sep))
+    error ("strsplit: S and SEP must be string values");
   elseif (! isscalar (strip_empty))
     error ("strsplit: STRIP_EMPTY must be a scalar value");
   endif
 
-  if (isempty (p))
-    s = cell (size (p));
+  if (isempty (s))
+    cstr = cell (size (s));
   else
-    if (rows (p) > 1)
+    if (rows (s) > 1)
       ## For 2-D arrays, add separator character at line boundaries
       ## and transform to single string
-      p(:, end+1) = sep(1);
-      p = reshape (p.', 1, numel (p));
-      p(end) = []; 
+      s(:, end+1) = sep(1);
+      s = reshape (s.', 1, numel (s));
+      s(end) = []; 
     endif
 
-    ## Split p according to delimiter
+    ## Split s according to delimiter
     if (isscalar (sep))
       ## Single separator
-      idx = find (p == sep);
+      idx = find (s == sep);
     else
       ## Multiple separators
-      idx = strchr (p, sep);
+      idx = strchr (s, sep);
     endif
 
     ## Get substring lengths.
     if (isempty (idx))
-      strlens = length (p);
+      strlens = length (s);
     else
-      strlens = [idx(1)-1, diff(idx)-1, numel(p)-idx(end)];
+      strlens = [idx(1)-1, diff(idx)-1, numel(s)-idx(end)];
     endif
     ## Remove separators.
-    p(idx) = [];
+    s(idx) = [];
     if (strip_empty)
       ## Omit zero lengths.
       strlens = strlens(strlens != 0);
     endif
 
     ## Convert!
-    s = mat2cell (p, 1, strlens);
+    cstr = mat2cell (s, 1, strlens);
   endif
 
 endfunction
 
 
 %!assert (strsplit ("road to hell", " "), {"road", "to", "hell"})
 %!assert (strsplit ("road to^hell", " ^"), {"road", "to", "hell"})
 %!assert (strsplit ("road   to--hell", " -", true), {"road", "to", "hell"})
 %!assert (strsplit (["a,bc";",de"], ","), {"a", "bc", ones(1,0), "de "})
 %!assert (strsplit (["a,bc";",de"], ",", true), {"a", "bc", "de "})
 %!assert (strsplit (["a,bc";",de"], ", ", true), {"a", "bc", "de"})
 
 %% Test input validation
 %!error strsplit ()
 %!error strsplit ("abc")
 %!error strsplit ("abc", "b", true, 4)
-%!error <P and SEP must be string values> strsplit (123, "b")
-%!error <P and SEP must be string values> strsplit ("abc", 1)
+%!error <S and SEP must be string values> strsplit (123, "b")
+%!error <S and SEP must be string values> strsplit ("abc", 1)
 %!error <STRIP_EMPTY must be a scalar value> strsplit ("abc", "def", ones(3,3))
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -12,150 +12,213 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str}, @var{delim})
+## @deftypefn  {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str})
+## @deftypefnx {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str}, @var{delim})
 ##
-## Find all characters up to but not including the first character which
-## is in the string delim.  If @var{rem} is requested, it contains the
-## remainder of the string, starting at the first delimiter.  Leading
-## delimiters are ignored.  If @var{delim} is not specified, space is
-## assumed.  For example:
+## Find all characters in the string @var{str} up to, but not including, the 
+## first character which is in the string @var{delim}.  If @var{rem} is
+## requested, it contains the remainder of the string, starting at the first
+## delimiter.  Leading delimiters are ignored.  If @var{delim} is not
+## specified, whitespace is assumed.  @var{str} may also be a cell array of
+## strings in which case the function executes on every individual string
+## and returns a cell array of tokens and remainders.
+##
+## Examples:
 ##
 ## @example
 ## @group
 ## strtok ("this is the life")
 ##      @result{} "this"
 ##
 ## [tok, rem] = strtok ("14*27+31", "+-*/")
 ##      @result{}
 ##         tok = 14
 ##         rem = *27+31
 ## @end group
 ## @end example
-## @seealso{index, strsplit}
+## @seealso{index, strsplit, strchr, isspace}
 ## @end deftypefn
 
-## FIXME: check what to do for a null delimiter
-
 function [tok, rem] = strtok (str, delim)
 
-  if (nargin<1 || nargin > 2)
+  if (nargin < 1 || nargin > 2)
     print_usage ();
+  elseif (! (ischar (str) || iscellstr (str)))
+    error ("strtok: STR must be a string or cell array of strings.");
+  elseif (ischar (str) && ! isvector (str) &&! isempty (str))
+    error ("strtok: STR cannot be a 2-D character array.");
   endif
 
   if (nargin < 2 || isempty (delim))
-    delim = "\t\n\v\f\r ";
+    ws_delim = true;
+  else
+    ws_delim = false;
   endif
 
   if (isempty (str))
     tok = rem = "";
-  elseif (length (delim) > 3)
-    start = 1;
-    len = length (str);
-    while (start <= len)
-      if (all (str(start) != delim))
-        break;
-      endif
-      start++;
-    endwhile
-    stop = start;
-    while (stop <= len)
-      if (any (str(stop) == delim))
-        break;
-      endif
-      stop++;
-    endwhile
-    tok = str(start:stop-1);
-    rem = str(stop:len);
-  else
-    if (length (delim) == 1)
-      idx = find (str == delim);
-    elseif (length (delim) == 2)
-      idx = find (str == delim(1) | str == delim(2));
+  elseif (ischar (str))
+    if (ws_delim)
+      idx = isspace (str);
+    elseif (length (delim) <= 7)
+      ## Build index of delimiters incrementally for low N.
+      idx = str == delim(1);
+      for i = 2:length (delim) 
+        idx |= str == delim(i);
+      endfor
     else
-      idx = find (str == delim(1) | str == delim(2) | str == delim(3));
+      ## Index the str into a mask of valid values.  Faster for large N.
+      f = false (256, 1);
+      ## This is slower than it could be because of the +1 issue.
+      f(uint8(delim)+1) = true;
+      ## Default goes via double -- unnecessarily long.
+      si = uint32 (str);
+      ## in-place is faster than str+1
+      ++si;
+      idx = f(si);
     endif
-    if (isempty (idx))
+
+    idx_dlim = find (idx, 1);
+    idx_nodlim = find (! idx, 1);
+    if (isempty (idx_dlim))
+      ## No delimiter.  Return whole string.
       tok = str;
       rem = "";
+    elseif (idx_dlim > idx_nodlim)
+      ## Normal case.  No leading delimiters and at least 1 delimiter in STR. 
+      tok = str(1:idx_dlim-1);
+      rem = str(idx_dlim:end);
     else
-      ## Find first non-leading delimiter.
-      skip = find (idx(:)' != 1:length(idx));
-      if (isempty (skip))
-        tok = str(idx(length(idx))+1:length(str));
+      ## Leading delimiter found.
+      idx_dlim = find (idx(idx_nodlim+1:end), 1); 
+      if (isempty (idx_dlim))
+        ## No further delimiters.  Return STR stripped of delimiter prefix.
+        tok = str(idx_nodlim:end);
         rem = "";
       else
-        tok = str(skip(1):idx(skip(1))-1);
-        rem = str(idx(skip(1)):length(str));
+        ## Strip delimiter prefix.  Return STR up to 1st delimiter
+        tok = str(idx_nodlim:(idx_dlim + idx_nodlim -1));
+        rem = str((idx_dlim + idx_nodlim):end);
       endif
     endif
+  else    # Cell array of strings
+    if (ws_delim)
+      delim = '\s';
+    endif
+    ptn = [ '^[' delim ']*','([^' delim ']+)','([' delim '].*)$' ];
+    matches = regexp (str, ptn, "tokens");
+    eidx = cellfun ("isempty", matches);
+    midx = ! eidx;
+    tok = cell (size (str));
+    tok(eidx) = regexprep (str(eidx), [ '^[' delim ']+' ], '');
+    ## Unwrap doubly nested cell array from regexp
+    tmp = [matches{midx}];
+    if (! isempty (tmp))
+      tmp = [tmp{:}];
+    endif
+    tok(midx) = tmp(1:2:end);
+    if (isargout (2))
+      rem = cell (size (str));
+      rem(eidx) = {""};
+      rem(midx) = tmp(2:2:end);
+    endif
   endif
 
 endfunction
 
+
 %!demo
 %! strtok("this is the life")
 %! % split at the first space, returning "this"
 
 %!demo
 %! s = "14*27+31"
-%! while 1
-%!   [t,s] = strtok(s, "+-*/");
-%!   printf("<%s>", t);
-%!   if isempty(s), break; endif
-%!   printf("<%s>", s(1));
+%! while (1)
+%!   [t, s] = strtok (s, "+-*/");
+%!   printf ("<%s>", t);
+%!   if (isempty (s))
+%!     break;
+%!   endif
+%!   printf ("<%s>", s(1));
 %! endwhile
 %! printf("\n");
 %! % ----------------------------------------------------
 %! % Demonstrates processing of an entire string split on
-%! % a variety of delimiters. Tokens and delimiters are
-%! % printed one after another in angle brackets.  The
-%! % string is:
+%! % a variety of delimiters.  Tokens and delimiters are
+%! % printed one after another in angle brackets.
 
-%!# test the tokens for all cases
-%!assert(strtok(""), "");             # no string
-%!assert(strtok("this"), "this");     # no delimiter in string
-%!assert(strtok("this "), "this");    # delimiter at end
-%!assert(strtok("this is"), "this");  # delimiter in middle
-%!assert(strtok(" this"), "this");    # delimiter at start
-%!assert(strtok(" this "), "this");   # delimiter at start and end
-%!assert(strtok(" "), ""(1:0));            # delimiter only
+%% Test the tokens for all cases
+%!assert (strtok (""), "");             # no string
+%!assert (strtok ("this"), "this");     # no delimiter in string
+%!assert (strtok ("this "), "this");    # delimiter at end
+%!assert (strtok ("this is"), "this");  # delimiter in middle
+%!assert (strtok (" this"), "this");    # delimiter at start
+%!assert (strtok (" this "), "this");   # delimiter at start and end
+%!assert (strtok (" "), ""(1:0));       # delimiter only
+
+%% Test the remainder for all cases
+%!test [t,r] = strtok (""); assert (r, "");
+%!test [t,r] = strtok ("this"); assert (r, "");
+%!test [t,r] = strtok ("this "); assert (r, " ");
+%!test [t,r] = strtok ("this is"); assert (r, " is");
+%!test [t,r] = strtok (" this"); assert (r, "");
+%!test [t,r] = strtok (" this "); assert (r, " ");
+%!test [t,r] = strtok (" "); assert (r, "");
 
-%!# test the remainder for all cases
-%!test [t,r] = strtok(""); assert(r, "");
-%!test [t,r] = strtok("this"); assert(r, char (zeros (1, 0)));
-%!test [t,r] = strtok("this "); assert(r, " ");
-%!test [t,r] = strtok("this is"); assert(r, " is");
-%!test [t,r] = strtok(" this"); assert(r, char (zeros (1, 0)));
-%!test [t,r] = strtok(" this "); assert(r, " ");
-%!test [t,r] = strtok(" "); assert(r, char (zeros (1, 0)));
-
-%!# simple check with 2 and 3 delimeters
-%!assert(strtok("this is", "i "), "th");
-%!assert(strtok("this is", "ij "), "th");
+%% Test all tokens and remainders with cell array input
+%!test
+%! str = {"", "this", "this ", "this is", " this", " this ", " "};
+%! [t, r] = strtok (str);
+%! assert (t{1}, "");
+%! assert (r{1}, "");
+%! assert (t{2}, "this");
+%! assert (r{2}, "");
+%! assert (t{3}, "this");
+%! assert (r{3}, " ");
+%! assert (t{4}, "this");
+%! assert (r{4}, " is");
+%! assert (t{5}, "this");
+%! assert (r{5}, "");
+%! assert (t{6}, "this");
+%! assert (r{6}, " ");
+%! assert (t{7}, "");
+%! assert (r{7}, "");
 
-%!# test all cases for 4 delimiters since a different
-%!# algorithm is used when more than 3 delimiters
-%!assert(strtok("","jkl "), "");
-%!assert(strtok("this","jkl "), "this");
-%!assert(strtok("this ","jkl "), "this");
-%!assert(strtok("this is","jkl "), "this");
-%!assert(strtok(" this","jkl "), "this");
-%!assert(strtok(" this ","jkl "), "this");
-%!assert(strtok(" ","jkl "), ""(1:0));
+%% Simple check for 2, 3, and 4 delimeters
+%!assert(strtok ("this is", "i "), "th");
+%!assert(strtok ("this is", "ij "), "th");
+%!assert(strtok ("this is", "ijk "), "th");
 
-%!# test 'bad' string orientations
-%!assert(strtok(" this "'), "this"');   # delimiter at start and end
-%!assert(strtok(" this "',"jkl "), "this"');
+%% Test all cases for 8 delimiters since a different
+%!# algorithm is used when more than 7 delimiters
+%!assert (strtok ("","jklmnop "), "");
+%!assert (strtok ("this","jklmnop "), "this");
+%!assert (strtok ("this ","jklmnop "), "this");
+%!assert (strtok ("this is","jklmnop "), "this");
+%!assert (strtok (" this","jklmnop "), "this");
+%!assert (strtok (" this ","jklmnop "), "this");
+%!assert (strtok (" ","jklmnop "), ""(1:0));
 
-%!# test with TAB, LF, VT, FF, and CR
+%% Test 'bad' string orientations
+%!assert (strtok (" this ".'), "this".');   # delimiter at start and end
+%!assert (strtok (" this ".',"jkl "), "this".');
+
+%% Test with TAB, LF, VT, FF, and CR
 %!test
 %! for ch = "\t\n\v\f\r"
 %!   [t, r] = strtok (cstrcat ("beg", ch, "end"));
 %!   assert (t, "beg");
 %!   assert (r, cstrcat (ch, "end"))
 %! endfor
+
+%% Test input validation
+%!error strtok ()
+%!error strtok ("a", "b", "c")
+%!error <STR must be a string> strtok (1, "b")
+%!error <STR cannot be a 2-D> strtok (char ("hello", "world"), "l")
+
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -12,26 +12,35 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} datenum (@var{year}, @var{month}, @var{day})
-## @deftypefnx {Function File} {} datenum (@var{year}, @var{month}, @var{day}, @var{hour})
-## @deftypefnx {Function File} {} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute})
-## @deftypefnx {Function File} {} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute}, @var{second})
-## @deftypefnx {Function File} {} datenum ("date")
-## @deftypefnx {Function File} {} datenum ("date", @var{p})
-## Return the specified local time as a day number, with Jan 1, 0000
-## being day 1.  By this reckoning, Jan 1, 1970 is day number 719529.
-## The fractional portion, @var{p}, corresponds to the portion of the
-## specified day.
+## @deftypefn  {Function File} {@var{days} =} datenum (@var{datevec})
+## @deftypefnx {Function File} {@var{days} =} datenum (@var{year}, @var{month}, @var{day})
+## @deftypefnx {Function File} {@var{days} =} datenum (@var{year}, @var{month}, @var{day}, @var{hour})
+## @deftypefnx {Function File} {@var{days} =} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute})
+## @deftypefnx {Function File} {@var{days} =} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute}, @var{second})
+## @deftypefnx {Function File} {@var{days} =} datenum ("datestr")
+## @deftypefnx {Function File} {@var{days} =} datenum ("datestr", @var{p})
+## @deftypefnx {Function File} {[@var{days}, @var{secs}] =} datenum (@dots{})
+## Return the date/time input as a serial day number, with Jan 1, 0000
+## being day 1.  The fractional portion of @var{days} corresponds to the time
+## on the given day.  The input may be a date vector (see @code{datevec}), 
+## datestr (see @code{datestr}), or directly specified as input.
+##
+## When processing datestrings, @var{p} is the year at the start of the century
+## to which two-digit years will be referenced.  If not specified, it defaults
+## to the current year minus 50.
+##
+## The optional output @var{secs} holds the time on the specified day with greater
+## precision than @var{days}.
 ##
 ## Notes:
 ##
 ## @itemize
 ## @item
 ## Years can be negative and/or fractional.
 ##
 ## @item
@@ -47,58 +56,53 @@
 ## Days before the beginning of the month go to the previous month.
 ##
 ## @item
 ## Days can be fractional.
 ## @end itemize
 ##
 ## @strong{Caution:} this function does not attempt to handle Julian
 ## calendars so dates before Octave 15, 1582 are wrong by as much
-## as eleven days.  Also be aware that only Roman Catholic countries
+## as eleven days.  Also, be aware that only Roman Catholic countries
 ## adopted the calendar in 1582.  It took until 1924 for it to be
 ## adopted everywhere.  See the Wikipedia entry on the Gregorian
 ## calendar for more details.
 ##
 ## @strong{Warning:} leap seconds are ignored.  A table of leap seconds
 ## is available on the Wikipedia entry for leap seconds.
-## @seealso{date, clock, now, datestr, datevec, calendar, weekday}
+## @seealso{datestr, datevec, date, clock, now, calendar, weekday}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
 ## Author: pkienzle <pkienzle@users.sf.net>
 
-function [days, secs] = datenum (year, month, day, hour, minute, second)
+function [days, secs] = datenum (year, month = [], day = [], hour = 0, minute = 0, second = 0)
 
   ## Days until start of month assuming year starts March 1.
   persistent monthstart = [306; 337; 0; 31; 61; 92; 122; 153; 184; 214; 245; 275];
 
-  if (nargin == 0 || (nargin > 2  && ischar (year)) || nargin > 6)
+  if (nargin == 0 || nargin > 6 || 
+     (nargin > 2 && (ischar (year) || iscellstr (year))))
     print_usage ();
   endif
-  if (ischar (year))
-    if (nargin < 2)
-      month = [];
-    endif
+
+  if (ischar (year) || iscellstr (year))
     [year, month, day, hour, minute, second] = datevec (year, month);
   else
-    if (nargin < 6) second = 0; endif
-    if (nargin < 5) minute = 0; endif
-    if (nargin < 4) hour = 0; endif
     if (nargin == 1)
       nc = columns (year);
       if (nc > 6 || nc < 3)
         error ("datenum: expected date vector containing [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND]");
       endif
-      second = minute = hour = 0;
       if (nc >= 6) second = year(:,6); endif
       if (nc >= 5) minute = year(:,5); endif
-      if (nc >= 4) hour = year(:,4); endif
-      day = year(:,3);
+      if (nc >= 4) hour   = year(:,4); endif
+      day   = year(:,3);
       month = year(:,2);
-      year = year(:,1);
+      year  = year(:,1);
     endif
   endif
 
   month(month<1) = 1; ## For compatibility.  Otherwise allow negative months.
 
   ## Set start of year to March by moving Jan. and Feb. to previous year.
   ## Correct for months > 12 by moving to subsequent years.
   year += fix ((month-14)/12);
@@ -115,47 +119,60 @@ function [days, secs] = datenum (year, m
     day += reshape (monthstart (mod (month-1,12) + 1), size (day)) + 60;
   endif
 
   ## Add number of days to the start of the current year. Correct
   ## for leap year every 4 years except centuries not divisible by 400.
   day += 365*year + floor (year/4) - floor (year/100) + floor (year/400);
 
   ## Add fraction representing current second of the day.
-  days = day + (hour+(minute+second/60)/60)/24;
+  days = day + (hour + (minute + second/60)/60)/24;
 
   ## Output seconds if asked so that etime can be more accurate
-  secs = 86400*day + hour*3600 + minute*60 + second;
+  if (isargout (2))
+    secs = day*86400 + hour*3600 + minute*60 + second;
+  endif
 
 endfunction
 
+
 %!shared part
 %! part = 0.514623842592593;
-%!assert(datenum(2001,5,19), 730990)
-%!assert(datenum([1417,6,12]), 517712)
-%!assert(datenum([2001,5,19;1417,6,12]), [730990;517712])
-%!assert(datenum(2001,5,19,12,21,3.5), 730990+part, eps)
-%!assert(datenum([1417,6,12,12,21,3.5]), 517712+part, eps)
+%!assert (datenum (2001,5,19), 730990)
+%!assert (datenum ([1417,6,12]), 517712)
+%!assert (datenum ([2001,5,19;1417,6,12]), [730990;517712])
+%!assert (datenum (2001,5,19,12,21,3.5), 730990+part, eps)
+%!assert (datenum ([1417,6,12,12,21,3.5]), 517712+part, eps)
 ## Test vector inputs
 %!test
 %! t = [2001,5,19,12,21,3.5; 1417,6,12,12,21,3.5];
 %! n = [730990; 517712] + part;
-%! assert(datenum(t), n, 2*eps);
-## Make sure that the vectors can have either orientation
-%!test
-%! t = [2001,5,19,12,21,3.5; 1417,6,12,12,21,3.5]';
-%! n = [730990 517712] + part;
-%! assert(datenum(t(1,:), t(2,:), t(3,:), t(4,:), t(5,:), t(6,:)), n, 2*eps);
+%! assert (datenum (t), n, 2*eps);
+%! ## Check that vectors can have either orientation
+%! t = t';
+%! n = n';
+%! assert (datenum (t(1,:), t(2,:), t(3,:), t(4,:), t(5,:), t(6,:)), n, 2*eps);
 
 ## Test mixed vectors and scalars
 %!assert (datenum([2008;2009], 1, 1), [datenum(2008, 1, 1);datenum(2009, 1, 1)]);
 %!assert (datenum(2008, [1;2], 1), [datenum(2008, 1, 1);datenum(2008, 2, 1)]);
 %!assert (datenum(2008, 1, [1;2]), [datenum(2008, 1, 1);datenum(2008, 1, 2)]);
 %!assert (datenum([2008;2009], [1;2], 1), [datenum(2008, 1, 1);datenum(2009, 2, 1)]);
 %!assert (datenum([2008;2009], 1, [1;2]), [datenum(2008, 1, 1);datenum(2009, 1, 2)]);
 %!assert (datenum(2008, [1;2], [1;2]), [datenum(2008, 1, 1);datenum(2008, 2, 2)]);
 ## And the other orientation
 %!assert (datenum([2008 2009], 1, 1), [datenum(2008, 1, 1) datenum(2009, 1, 1)]);
 %!assert (datenum(2008, [1 2], 1), [datenum(2008, 1, 1) datenum(2008, 2, 1)]);
 %!assert (datenum(2008, 1, [1 2]), [datenum(2008, 1, 1) datenum(2008, 1, 2)]);
 %!assert (datenum([2008 2009], [1 2], 1), [datenum(2008, 1, 1) datenum(2009, 2, 1)]);
 %!assert (datenum([2008 2009], 1, [1 2]), [datenum(2008, 1, 1) datenum(2009, 1, 2)]);
 %!assert (datenum(2008, [1 2], [1 2]), [datenum(2008, 1, 1) datenum(2008, 2, 2)]);
+## Test string and cellstr inputs
+%!assert (datenum ("5/19/2001"), 730990)
+%!assert (datenum ({"5/19/2001"}), 730990)
+%!assert (datenum (char ("5/19/2001", "6/6/1944")), [730990; 710189])
+%!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])
+
+%% Test input validation
+%!error datenum ()
+%!error datenum (1,2,3,4,5,6,7)
+%!error datenum ([1, 2])
+%!error datenum ([1,2,3,4,5,6,7])
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -84,29 +84,31 @@
 ## @item dddd @tab Full weekday name                            @tab Sunday
 ## @item ddd  @tab Abbreviated weekday name                     @tab Sun
 ## @item dd   @tab Numeric day of month (padded with zeros)     @tab 11
 ## @item d    @tab First letter of weekday name (capitalized)   @tab S
 ## @item HH   @tab Hour of day, padded with zeros if PM is set  @tab 09:00
 ## @item      @tab and not padded with zeros otherwise          @tab 9:00 AM
 ## @item MM   @tab Minute of hour (padded with zeros)           @tab 10:05
 ## @item SS   @tab Second of minute (padded with zeros)         @tab 10:05:03
+## @item FFF  @tab Milliseconds of second (padded with zeros)   @tab 10:05:03.012
+## @item AM   @tab Use 12-hour time format                      @tab 11:30 AM
 ## @item PM   @tab Use 12-hour time format                      @tab 11:30 PM
 ## @end multitable
 ##
 ## If @var{f} is not specified or is @code{-1}, then use 0, 1 or 16,
 ## depending on whether the date portion or the time portion of
 ## @var{date} is empty.
 ##
 ## If @var{p} is nor specified, it defaults to the current year minus 50.
 ##
-## If a matrix or cell array of dates is given, a vector of date strings is
-## returned.
+## If a matrix or cell array of dates is given, a column vector of date strings
+## is returned.
 ##
-## @seealso{datenum, datevec, date, clock, now, datetick}
+## @seealso{datenum, datevec, date, clock, now}
 ## @end deftypefn
 
 ## FIXME: parse arbitrary code strings.
 ## e.g., for  Wednesday 2001-03-05 09:04:06 AM, use
 ##     yy    01
 ##     yyyy  2001
 ##     m     M
 ##     mm    03
@@ -121,121 +123,103 @@
 ## FIXME: Vectorize.  It is particularly easy since all the codes are
 ##    fixed width.  Just generate the parts in separate arrays and
 ##    concatenate.
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Created: 10 October 2001 (CVS)
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
-function retval = datestr (date, f, p)
+function retval = datestr (date, f = [], p = [])
 
-  persistent dateform names_mmmm names_mmm names_m names_dddd names_ddd names_d;
+  persistent dateform names_mmmm names_m names_d;
 
   if (isempty (dateform))
-
     dateform = cell (32, 1);
-    dateform{1} = "dd-mmm-yyyy HH:MM:SS";
-    dateform{2} = "dd-mmm-yyyy";
-    dateform{3} = "mm/dd/yy";
-    dateform{4} = "mmm";
-    dateform{5} = "m";
-    dateform{6} = "mm";
-    dateform{7} = "mm/dd";
-    dateform{8} = "dd";
-    dateform{9} = "ddd";
+    dateform{1}  = "dd-mmm-yyyy HH:MM:SS";
+    dateform{2}  = "dd-mmm-yyyy";
+    dateform{3}  = "mm/dd/yy";
+    dateform{4}  = "mmm";
+    dateform{5}  = "m";
+    dateform{6}  = "mm";
+    dateform{7}  = "mm/dd";
+    dateform{8}  = "dd";
+    dateform{9}  = "ddd";
     dateform{10} = "d";
     dateform{11} = "yyyy";
     dateform{12} = "yy";
     dateform{13} = "mmmyy";
     dateform{14} = "HH:MM:SS";
     dateform{15} = "HH:MM:SS PM";
     dateform{16} = "HH:MM";
     dateform{17} = "HH:MM PM";
     dateform{18} = "QQ-YY";
     dateform{19} = "QQ";
     dateform{20} = "dd/mm";
     dateform{21} = "dd/mm/yy";
-    dateform{22} = "mmm.dd.yyyy HH:MM:SS";
-    dateform{23} = "mmm.dd.yyyy";
+    dateform{22} = "mmm.dd,yyyy HH:MM:SS";
+    dateform{23} = "mmm.dd,yyyy";
     dateform{24} = "mm/dd/yyyy";
     dateform{25} = "dd/mm/yyyy";
     dateform{26} = "yy/mm/dd";
     dateform{27} = "yyyy/mm/dd";
     dateform{28} = "QQ-YYYY";
     dateform{29} = "mmmyyyy";
-    dateform{30} = "yyyymmdd";
+    dateform{30} = "yyyy-mm-dd";
     dateform{31} = "yyyymmddTHHMMSS";
     dateform{32} = "yyyy-mm-dd HH:MM:SS";
 
-    names_m = {"J"; "F"; "M"; "A"; "M"; "J"; "J"; "A"; "S"; "O"; "N"; "D"};
-
-    names_d = {"S"; "M"; "T"; "W"; "T"; "F"; "S"};
-
+    names_m = {"J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"};
+    names_d = {"S", "M", "T", "W", "T", "F", "S"};
   endif
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (nargin < 2)
-    f = [];
-  endif
-  if (nargin < 3)
-    p = [];
-  endif
-
-  if (ischar (date))
-    t = date;
-    date = cell (1);
-    date{1} = t;
-  endif
-
-  ## Guess, so we might be wrong.
-  if (iscell (date) || columns (date) != 6)
+  ## Guess input type.  We might be wrong.
+  if (ischar (date) || iscellstr (date) || columns (date) != 6)
     v = datevec (date, p);
   else
     v = [];
     if (columns (date) == 6)
       ## Make sure that the input really is a datevec.
       maxdatevec = [Inf, 12, 31, 23, 59, 60];
-      for i = 1:numel (maxdatevec)
-        if (any (date(:,i) > maxdatevec(i))
-            || (i != 6 && any (floor (date(:,i)) != date(:,i))))
-          v = datevec (date, p);
-          break;
-        endif
-      endfor
+      if (any (max (date, 1) > maxdatevec) ||
+          any (date(:,1:5) != floor (date(:,1:5))))
+        v = datevec (date, p);
+      endif
     endif
     if (isempty (v))
       v = date;
     endif
   endif
 
-  for i = 1:(rows (v))
+  retval = [];
+  for i = 1 : rows (v)
 
-    if (isempty (f) || f == -1)
+    if (isempty (f))
       if (v(i,4:6) == 0)
         f = 1;
-        ## elseif (v(i,1:3) == [0, 1, 1])
       elseif (v(i,1:3) == [-1, 12, 31])
         f = 16;
       else
         f = 0;
       endif
     endif
 
     if (isnumeric (f))
       df = dateform{f + 1};
     else
       df = f;
     endif
 
     df_orig = df;
-    df = regexprep (df, '[AP]M', "%p");
+    df = strrep (df, 'AM', "%p");
+    df = strrep (df, 'PM', "%p");
     if (strcmp (df, df_orig))
       ## PM not set.
       df = strrep (df, "HH", "%H");
     else
       df = strrep (df, "HH", sprintf ("%2d", v(i,4)));
     endif
 
     df = regexprep (df, '[Yy][Yy][Yy][Yy]', "%Y");
@@ -261,88 +245,93 @@ function retval = datestr (date, f, p)
 
     tmp = names_m{v(i,2)};
     pos = regexp (df, '[^%]m') + 1;
     df(pos) = tmp;
     df = regexprep (df, '^m', tmp);
 
     df = strrep (df, "MM", "%M");
 
-    df = strrep (df, "SS", "%S");
+    df = regexprep (df, '[Ss][Ss]', "%S");
 
-    df = regexprep (df, '[Qq][Qq]', sprintf ("Q%d", fix ((v(i,2) + 2) / 3)));
+    df = strrep (df, "FFF", sprintf ("%03d", 1000 * (v(i,6) - fix (v(i,6)))));
+
+    df = strrep (df, 'QQ', sprintf ("Q%d", fix ((v(i,2) + 2) / 3)));
 
     vi = v(i,:);
     tm.year = vi(1) - 1900;
     tm.mon = vi(2) - 1;
     tm.mday = vi(3);
     tm.hour = vi(4);
     tm.min = vi(5);
     sec = vi(6);
     tm.sec = fix (sec);
-    tm.usec = fix (rem (sec, 1) * 1e6);
+    tm.usec = fix ((sec - tm.sec) * 1e6);
     tm.wday = wday - 1;
     ## FIXME -- Do we need YDAY and DST?  How should they be computed?
     ## We don't want to use "localtime (mktime (tm))" because that
     ## doesn't correctly handle dates before 1970-01-01 on some systems.
     ## tm.yday = ?;
     ## tm.isdst = ?;
 
     str = strftime (df, tm);
 
-    if (i == 1)
-      retval = str;
-    else
-      retval = [retval; str];
-    endif
+    retval = [retval; str];
 
   endfor
 
 endfunction
 
-# simple tests
+
+## demos
+%!demo
+%! ## Current date and time in default format
+%! datestr (now ())
+%!demo
+%! ## Current date (integer portion of datenum)
+%! datestr (fix (now ()))
+%!demo
+%! ## Current time (fractional portion of datenum)
+%! datestr (rem (now (), 1))
+
 %!shared testtime
 %! testtime = [2005.0000, 12.0000, 18.0000, 2.0000, 33.0000, 17.3822];
-%!assert(datestr(testtime,0),"18-Dec-2005 02:33:17");
-%!assert(datestr(testtime,1),"18-Dec-2005");
-%!assert(datestr(testtime,2),"12/18/05");
-%!assert(datestr(testtime,3),"Dec");
-%!assert(datestr(testtime,4),"D");
-%!assert(datestr(testtime,5),"12");
-%!assert(datestr(testtime,6),"12/18");
-%!assert(datestr(testtime,7),"18");
-%!assert(datestr(testtime,8),"Sun");
-%!assert(datestr(testtime,9),"S");
-%!assert(datestr(testtime,10),"2005");
-%!assert(datestr(testtime,11),"05");
-%!assert(datestr(testtime,12),"Dec05");
-%!assert(datestr(testtime,13),"02:33:17");
-%!assert(datestr(testtime,14)," 2:33:17 AM");
-%!assert(datestr(testtime,15),"02:33");
-%!assert(datestr(testtime,16)," 2:33 AM");
-%!assert(datestr(testtime,17),"Q4-05");
-%!assert(datestr(testtime,18),"Q4");
-%!assert(datestr(testtime,19),"18/12");
-%!assert(datestr(testtime,20),"18/12/05");
-%!assert(datestr(testtime,21),"Dec.18.2005 02:33:17");
-%!assert(datestr(testtime,22),"Dec.18.2005");
-%!assert(datestr(testtime,23),"12/18/2005");
-%!assert(datestr(testtime,24),"18/12/2005");
-%!assert(datestr(testtime,25),"05/12/18");
-%!assert(datestr(testtime,26),"2005/12/18");
-%!assert(datestr(testtime,27),"Q4-2005");
-%!assert(datestr(testtime,28),"Dec2005");
-%!assert(datestr(testtime,29),"20051218");
-%!assert(datestr(testtime,30),"20051218T023317");
-%!assert(datestr(testtime,31),"2005-12-18 02:33:17");
-%!assert(datestr(testtime+[0 0 3 0 0 0],"dddd"),"Wednesday")
-## avoid the bug where someone happens to give a vector of datenums that
-## happens to be 6 wide
-%!assert(datestr(733452.933:733457.933), ["14-Feb-2008 22:23:31";"15-Feb-2008 22:23:31";"16-Feb-2008 22:23:31";"17-Feb-2008 22:23:31";"18-Feb-2008 22:23:31";"19-Feb-2008 22:23:31"])
-%!assert (datestr ([1944, 6, 6, 6, 30, 0], 0), "06-Jun-1944 06:30:00");
+%!assert (datestr (testtime,0), "18-Dec-2005 02:33:17")
+%!assert (datestr (testtime,1), "18-Dec-2005")
+%!assert (datestr (testtime,2), "12/18/05")
+%!assert (datestr (testtime,3), "Dec")
+%!assert (datestr (testtime,4), "D")
+%!assert (datestr (testtime,5), "12")
+%!assert (datestr (testtime,6), "12/18")
+%!assert (datestr (testtime,7), "18")
+%!assert (datestr (testtime,8), "Sun")
+%!assert (datestr (testtime,9), "S")
+%!assert (datestr (testtime,10), "2005")
+%!assert (datestr (testtime,11), "05")
+%!assert (datestr (testtime,12), "Dec05")
+%!assert (datestr (testtime,13), "02:33:17")
+%!assert (datestr (testtime,14), " 2:33:17 AM")
+%!assert (datestr (testtime,15), "02:33")
+%!assert (datestr (testtime,16), " 2:33 AM")
+%!assert (datestr (testtime,17), "Q4-05")
+%!assert (datestr (testtime,18), "Q4")
+%!assert (datestr (testtime,19), "18/12")
+%!assert (datestr (testtime,20), "18/12/05")
+%!assert (datestr (testtime,21), "Dec.18,2005 02:33:17")
+%!assert (datestr (testtime,22), "Dec.18,2005")
+%!assert (datestr (testtime,23), "12/18/2005")
+%!assert (datestr (testtime,24), "18/12/2005")
+%!assert (datestr (testtime,25), "05/12/18")
+%!assert (datestr (testtime,26), "2005/12/18")
+%!assert (datestr (testtime,27), "Q4-2005")
+%!assert (datestr (testtime,28), "Dec2005")
+%!assert (datestr (testtime,29), "2005-12-18")
+%!assert (datestr (testtime,30), "20051218T023317")
+%!assert (datestr (testtime,31), "2005-12-18 02:33:17")
+%!assert (datestr (testtime+[0 0 3 0 0 0], "dddd"), "Wednesday")
+## Test possible bug where input is a vector of datenums that is exactly 6 wide
+%!assert (datestr ([1944, 6, 6, 6, 30, 0], 0), "06-Jun-1944 06:30:00")
+## Test fractional millisecond time extension
+%!assert (datestr (testtime, "HH:MM:SS:FFF"), "02:33:17:382")
 
-# demos
-%!demo
-%! datestr (now ())
-%!demo
-%! datestr (rem (now (), 1))
-%!demo
-%! datestr (floor (now ()))
+%% Test input validation
+%!error datestr ()
+%!error datestr (1, 2, 3, 4)
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -26,96 +26,86 @@
 ## @code{datestr}) into a date vector.
 ##
 ## A date vector is a row vector with six members, representing the year,
 ## month, day, hour, minute, and seconds respectively.
 ##
 ## @var{f} is the format string used to interpret date strings
 ## (see @code{datestr}).
 ##
-## @var{p} is the year at the start of the century in which two-digit years
-## are to be interpreted in.  If not specified, it defaults to the current
-## year minus 50.
+## @var{p} is the year at the start of the century to which two-digit years
+## will be referenced.  If not specified, it defaults to the current year
+## minus 50.
 ## @seealso{datenum, datestr, date, clock, now}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Modified: bdenney <bill@givebillmoney.com>
 ## Created: 10 October 2001 (CVS)
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 ## The function __date_str2vec__ is based on datesplit by Bill Denney.
 
-function [y, m, d, h, mi, s] = datevec (date, varargin)
+function [y, m, d, h, mi, s] = datevec (date, f = [], p = [])
 
   persistent std_formats nfmt;
 
   if (isempty (std_formats))
     std_formats = cell ();
     nfmt = 0;
+    ## These formats are specified by Matlab to be parsed
+    ## The '# XX' refers to the datestr numerical format code
     std_formats{++nfmt} = "dd-mmm-yyyy HH:MM:SS";   # 0
     std_formats{++nfmt} = "dd-mmm-yyyy";            # 1
     std_formats{++nfmt} = "mm/dd/yy";               # 2
     std_formats{++nfmt} = "mm/dd";                  # 6
     std_formats{++nfmt} = "HH:MM:SS";               # 13
     std_formats{++nfmt} = "HH:MM:SS PM";            # 14
     std_formats{++nfmt} = "HH:MM";                  # 15
     std_formats{++nfmt} = "HH:MM PM";               # 16
     std_formats{++nfmt} = "mm/dd/yyyy";             # 23
+
+    ## These are other formats that Octave tries
     std_formats{++nfmt} = "mmm-dd-yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm-dd-yyyy";
     std_formats{++nfmt} = "dd mmm yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd mmm yyyy";
     std_formats{++nfmt} = "mmm dd yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm dd yyyy";
     std_formats{++nfmt} = "dd.mmm.yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd.mmm.yyyy";
     std_formats{++nfmt} = "mmm.dd.yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm.dd.yyyy";
-
-    ## Custom formats.
     std_formats{++nfmt} = "mmmyy";                  # 12
     std_formats{++nfmt} = "mm/dd/yyyy HH:MM";
   endif
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  switch (nargin)
-  case 1
+  if (ischar (date))
+    date = cellstr (date);
+  endif
+
+  if (isnumeric (f))
+    p = f;
     f = [];
-    p = [];
-  case 2
-    if (ischar (varargin{1}))
-      f = varargin{1};
-      p = [];
-    else
-      f = [];
-      p = varargin{1};
-    endif
-  case 3
-      f = varargin{1};
-      p = varargin{2};
-  endswitch
+  endif
 
   if (isempty (f))
     f = -1;
   endif
 
   if (isempty (p))
     p = (localtime (time ())).year + 1900 - 50;
   endif
 
-  if (ischar (date))
-    date = cellstr (date);
-  endif
-
   if (iscell (date))
 
     nd = numel (date);
 
     y = m = d = h = mi = s = zeros (nd, 1);
 
     if (f == -1)
       for k = 1:nd
@@ -127,27 +117,27 @@ function [y, m, d, h, mi, s] = datevec (
             break;
           endif
         endfor
         if (! found)
           error ("datevec: none of the standard formats match the DATE string");
         endif
       endfor
     else
-      ## Decipher the format string just once for sake of speed.
+      ## Decipher the format string just once for speed.
       [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (f);
       for k = 1:nd
         [found y(k) m(k) d(k) h(k) mi(k) s(k)] = __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
         if (! found)
           error ("datevec: DATE not parsed correctly with given format");
         endif
       endfor
     endif
 
-  else
+  else   # datenum input
 
     date = date(:);
 
     ## Move day 0 from midnight -0001-12-31 to midnight 0000-3-1
     z = floor (date) - 60;
     ## Calculate number of centuries; K1 = 0.25 is to avoid rounding problems.
     a = floor ((z - 0.25) / 36524.25);
     ## Days within century; K2 = 0.25 is to avoid rounding problems.
@@ -182,75 +172,44 @@ function [y, m, d, h, mi, s] = datevec (
     y = [y, m, d, h, mi, s];
   endif
 
 endfunction
 
 function [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (f)
 
   ## Play safe with percent signs.
-  f = strrep(f, "%", "%%");
-
-  ## Dates to lowercase (note: we cannot convert MM to mm).
-  f = strrep (f, "YYYY", "yyyy");
-  f = strrep (f, "YY", "yy");
-  f = strrep (f, "QQ", "qq");
-  f = strrep (f, "MMMM", "mmmm");
-  f = strrep (f, "MMM", "mmm");
-  f = strrep (f, "DDDD", "dddd");
-  f = strrep (f, "DDD", "ddd");
-  f = strrep (f, "DD", "dd");
-  ## Times to uppercase (also cannot convert mm to MM).
-  f = strrep (f, "hh", "HH");
-  f = strrep (f, "ss", "SS");
-  f = strrep (f, "pm", "PM");
-  f = strrep (f, "am", "AM");
-
-  ## Right now, the format string may only contain these tokens:
-  ##
-  ## yyyy   4 digit year
-  ## yy     2 digit year
-  ## mmmm   month name, full
-  ## mmm    month name, abbreviated
-  ## mm     month number
-  ## dddd   weekday name, full
-  ## ddd    weekday name, abbreviated
-  ## dd     date
-  ## HH     hour
-  ## MM     minutes
-  ## SS     seconds
-  ## PM     AM/PM
-  ## AM     AM/PM
+  f = strrep (f, "%", "%%");
 
   if (! isempty (strfind (f, "PM")) || ! isempty (strfind (f, "AM")))
     ampm = true;
   else
     ampm = false;
   endif
 
   ## Date part.
-  f = strrep (f, "yyyy", "%Y");
-  f = strrep (f, "yy", "%y");
+  f = regexprep (f, '[Yy][Yy][Yy][Yy]', "%Y");
+  f = regexprep (f, '[Yy][Yy]', "%y");
   f = strrep (f, "mmmm", "%B");
   f = strrep (f, "mmm", "%b");
   f = strrep (f, "mm", "%m");
-  f = strrep (f, "dddd", "%A");
-  f = strrep (f, "ddd", "%a");
-  f = strrep (f, "dd", "%d");
+  f = regexprep (f, '[Dd][Dd][Dd][Dd]', "%A");
+  f = regexprep (f, '[Dd][Dd][Dd]', "%a");
+  f = regexprep (f, '[Dd][Dd]', "%d");
 
   ## Time part.
   if (ampm)
     f = strrep (f, "HH", "%I");
     f = strrep (f, "PM", "%p");
     f = strrep (f, "AM", "%p");
   else
     f = strrep (f, "HH", "%H");
   endif
   f = strrep (f, "MM", "%M");
-  f = strrep (f, "SS", "%S");
+  f = regexprep (f, '[Ss][Ss]', "%S");
 
   rY = rindex (f, "%Y");
   ry = rindex (f, "%y");
 
   ## Check whether we need to give default values.
   ## Possible error when string contains "%%".
   fy = rY || ry;
   fm = index (f, "%m") || index (f, "%b") || index (f, "%B");
@@ -258,22 +217,35 @@ function [f, rY, ry, fy, fm, fd, fh, fmi
   fh = index (f, "%H") || index (f, "%I");
   fmi = index (f, "%M");
   fs = index (f, "%S");
 
 endfunction
 
 function [found, y, m, d, h, mi, s] = __date_str2vec__ (ds, p, f, rY, ry, fy, fm, fd, fh, fmi, fs)
 
-  [tm, nc] = strptime (ds, f);
-
-  if (nc == size (ds, 2) + 1)
+  idx = strfind (f, "FFF");
+  if (! isempty (idx)) 
+    ## Kludge to handle FFF millisecond format since strptime does not
+    f(idx:idx+2) = []; 
+    [~, nc] = strptime (ds, f);
+    if (nc > 0)
+      msec = ds(nc:min(nc+2, end)); 
+      f = [f(1:idx-1) msec f(idx:end)]; 
+      [tm, nc] = strptime (ds, f);
+      tm.usec = 1000 * str2double (msec);
+    endif
+  else
+    [tm, nc] = strptime (ds, f);
+  endif
+  
+  if (nc == columns (ds) + 1)
+    found = true;
     y = tm.year + 1900; m = tm.mon + 1; d = tm.mday;
     h = tm.hour; mi = tm.min; s = tm.sec + tm.usec / 1e6;
-    found = true;
     if (rY < ry)
       if (y > 1999)
         y -= 2000;
       else
         y -= 1900;
       endif
       y += p - mod (p, 100);
       if (y < p)
@@ -284,43 +256,49 @@ function [found, y, m, d, h, mi, s] = __
       tmp = localtime (time ());
       y = tmp.year + 1900;
       m = tmp.mon + 1;
       d = tmp.mday;
     elseif (! fy && fm && fd)
       tmp = localtime (time ());
       y = tmp.year + 1900;
     elseif (fy && fm && ! fd)
-      tmp = localtime (time ());
       d = 1;
     endif
     if (! fh && ! fmi && ! fs)
       h = mi = s = 0;
     elseif (fh && fmi && ! fs)
       s = 0;
     endif
   else
     y = m = d = h = mi = s = 0;
     found = false;
   endif
 
 endfunction
 
+
+%!demo
+%! ## Current date and time
+%! datevec (now ())
+
 %!shared nowvec
 %! nowvec = datevec (now); # Some tests could fail around midnight!
-# tests for standard formats: 0, 1, 2, 6, 13, 14, 15, 16, 23
-%!assert(datevec("07-Sep-2000 15:38:09"),[2000,9,7,15,38,9]);
-%!assert(datevec("07-Sep-2000"),[2000,9,7,0,0,0]);
-%!assert(datevec("09/07/00"),[2000,9,7,0,0,0]);
-%!assert(datevec("09/13"),[nowvec(1),9,13,0,0,0]);
-%!assert(datevec("15:38:09"),[nowvec(1:3),15,38,9]);
-%!assert(datevec("3:38:09 PM"),[nowvec(1:3),15,38,9]);
-%!assert(datevec("15:38"),[nowvec(1:3),15,38,0]);
-%!assert(datevec("03:38 PM"),[nowvec(1:3),15,38,0]);
-%!assert(datevec("03/13/1962"),[1962,3,13,0,0,0]);
-# other tests
-%!assert(all(datenum(datevec([-1e4:1e4]))==[-1e4:1e4]'))
+%!# tests for standard formats: 0, 1, 2, 6, 13, 14, 15, 16, 23
+%!assert (datevec ("07-Sep-2000 15:38:09"), [2000,9,7,15,38,9])
+%!assert (datevec ("07-Sep-2000"), [2000,9,7,0,0,0])
+%!assert (datevec ("09/07/00"), [2000,9,7,0,0,0])
+%!assert (datevec ("09/13"), [nowvec(1),9,13,0,0,0])
+%!assert (datevec ("15:38:09"), [nowvec(1:3),15,38,9])
+%!assert (datevec ("3:38:09 PM"), [nowvec(1:3),15,38,9])
+%!assert (datevec ("15:38"), [nowvec(1:3),15,38,0])
+%!assert (datevec ("03:38 PM"), [nowvec(1:3),15,38,0])
+%!assert (datevec ("03/13/1962"), [1962,3,13,0,0,0])
+
+%% Test millisecond format FFF
+%!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [nowvec(1:3),15,38,21.025])
+
+# Other tests
+%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]')
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
-# demos
-%!demo
-%! datevec (now ())
+
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -129,16 +129,29 @@ public:
 
   void resize (int xx, int yy, int ww, int hh)
   {
     Fl_Gl_Window::resize (xx, yy, ww, hh);
     setup_viewport (ww, hh);
     redraw ();
   }
 
+  bool renumber (double new_number)
+  {
+    bool retval = false;
+
+    if (number != new_number)
+      {
+        number = new_number;
+        retval = true;
+      }
+
+    return retval;
+  }
+
 private:
   double number;
   opengl_renderer renderer;
   bool in_zoom;
   // (x1,y1,x2,y2)
   Matrix zoom_box;
 
   bool print_mode;
@@ -258,17 +271,17 @@ public:
 
   int items_to_show (void)
     {
       //returns the number of visible menu items
       int len = menubar->size ();
       int n = 0;
       for (int t = 0; t < len; t++ )
         {
-          const Fl_Menu_Item *m = static_cast<const Fl_Menu_Item*>(&(menubar->menu ()[t]));
+          const Fl_Menu_Item *m = static_cast<const Fl_Menu_Item*> (&(menubar->menu ()[t]));
           if ((m->label () != NULL) && m->visible ())
             n++;
         }
 
       return n;
     }
 
   void show (void)
@@ -281,28 +294,28 @@ public:
       menubar->hide ();
     }
 
    bool is_visible (void)
     {
       return menubar->visible ();
     }
 
-  int find_index_by_name (std::string findname)
+  int find_index_by_name (const std::string& findname)
     {
       // This function is derived from Greg Ercolano's function
       // int GetIndexByName(...), see:
       // http://seriss.com/people/erco/fltk/#Menu_ChangeLabel
       // He agreed via PM that it can be included in octave using GPLv3
       // Kai Habel (14.10.2010)
 
       std::string menupath;
       for (int t = 0; t < menubar->size (); t++ )
         {
-          Fl_Menu_Item *m = const_cast<Fl_Menu_Item*>(&(menubar->menu ()[t]));
+          Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(menubar->menu ()[t]));
           if (m->submenu ())
             {
               // item has submenu
               if (!menupath.empty ())
                 menupath += "/";
               menupath += m->label ();
 
               if (menupath.compare (findname) == 0 )
@@ -353,17 +366,17 @@ public:
 
 
       Matrix pos = Matrix (uimenu_childs.numel (), 1);
 
       for (octave_idx_type ii = 0; ii < uimenu_childs.numel (); ii++)
       {
         graphics_object kidgo = gh_manager::get_object (uimenu_childs (ii));
 
-        if (kidgo.valid_object() && kidgo.isa ("uimenu"))
+        if (kidgo.valid_object () && kidgo.isa ("uimenu"))
           {
             uimenu_childs(k) = uimenu_childs(ii);
             pos(k++) =
               dynamic_cast<uimenu::properties&> (kidgo.get_properties ()).get_position ();
           }
       }
 
       uimenu_childs.resize (k, 1);
@@ -373,31 +386,31 @@ public:
       // Can we avoid the for loop?
       Array<octave_idx_type> sidx = pos.sort_rows_idx (DESCENDING);
       for (octave_idx_type ii = 0; ii < k; ii++)
         retval(ii) = uimenu_childs (sidx(ii));
 
       return retval;
     }
 
-  void delete_entry(uimenu::properties& uimenup)
+  void delete_entry (uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       int idx = find_index_by_name (fltk_label.c_str ());
 
       if (idx >= 0)
         menubar->remove (idx);
     }
 
   void update_accelerator (uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
           if (item != NULL)
             {
               std::string acc = uimenup.get_accelerator ();
               if (acc.length () > 0)
                 {
                   int key = FL_CTRL + acc[0];
                   item->shortcut (key);
                 }
@@ -405,83 +418,83 @@ public:
         }
     }
 
   void update_callback (uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
           if (item != NULL)
             {
               if (!uimenup.get_callback ().is_empty ())
-                item->callback(static_cast<Fl_Callback*>(script_cb), //callback
-                              static_cast<void*>(&uimenup));        //callback data
+                item->callback (static_cast<Fl_Callback*> (script_cb),
+                                static_cast<void*> (&uimenup));
               else
-                item->callback(NULL, static_cast<void*>(0));
+                item->callback (NULL, static_cast<void*> (0));
             }
         }
     }
 
   void update_enable (uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
           if (item != NULL)
             {
               if (uimenup.is_enable ())
                 item->activate ();
               else
                 item->deactivate ();
             }
         }
     }
 
   void update_foregroundcolor (uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
           if (item != NULL)
             {
               Matrix rgb = uimenup.get_foregroundcolor_rgb ();
 
               uchar r = static_cast<uchar> (gnulib::floor (rgb (0) * 255));
               uchar g = static_cast<uchar> (gnulib::floor (rgb (1) * 255));
               uchar b = static_cast<uchar> (gnulib::floor (rgb (2) * 255));
 
               item->labelcolor (fl_rgb_color (r, g, b));
             }
         }
     }
 
-  void update_seperator (uimenu::properties& uimenup)
+  void update_seperator (const uimenu::properties& uimenup)
     {
       // Matlab places the separator before the current
       // menu entry, while fltk places it after. So we need to find
       // the previous item in this menu/submenu. (Kai)
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
           int itemflags = 0, idx;
-          int curr_idx = find_index_by_name(fltk_label.c_str ());
+          int curr_idx = find_index_by_name (fltk_label.c_str ());
 
           for (idx = curr_idx - 1; idx >= 0; idx--)
             {
-              Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(&menubar->menu () [idx]);
+              Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (&menubar->menu () [idx]);
               itemflags = item->flags;
               if (item->label () != NULL)
                 break;
             }
 
-          if ((idx >= 0) && (idx < menubar->size ()))
+          if (idx >= 0 && idx < menubar->size ())
             {
               if (uimenup.is_separator ())
                 {
                   if (idx >= 0 && !(itemflags & FL_SUBMENU))
                     menubar->mode (idx, itemflags | FL_MENU_DIVIDER);
                 }
               else
                 menubar->mode (idx, itemflags & (~FL_MENU_DIVIDER));
@@ -489,17 +502,18 @@ public:
         }
     }
 
   void update_visible (uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          Fl_Menu_Item* item
+            = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
           if (item != NULL)
             {
               if (uimenup.is_visible ())
                 item->show ();
               else
                 item->hide ();
             }
         }
@@ -510,43 +524,44 @@ public:
 
       std::string fltk_label = uimenup.get_fltk_label ();
 
       if (!fltk_label.empty ())
         {
           bool item_added = false;
           do
             {
-              const Fl_Menu_Item* item = menubar->find_item(fltk_label.c_str ());
+              const Fl_Menu_Item* item
+                = menubar->find_item (fltk_label.c_str ());
 
               if (item == NULL)
                 {
                   Matrix uimenu_ch = find_uimenu_children (uimenup);
                   int len = uimenu_ch.numel ();
                   int flags = 0;
                   if (len > 0)
                     flags = FL_SUBMENU;
-                  if ((len == 0) && (uimenup.is_checked ()))
+                  if (len == 0 && uimenup.is_checked ())
                     flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
-                  menubar->add(fltk_label.c_str (), 0, 0, 0, flags);
+                  menubar->add (fltk_label.c_str (), 0, 0, 0, flags);
                   item_added = true;
                 }
               else
                 {
                   //avoid duplicate menulabels
                   std::size_t idx1 = fltk_label.find_last_of ("(");
                   std::size_t idx2 = fltk_label.find_last_of (")");
                   int len = idx2 - idx1;
                   int val = 1;
                   if (len > 0)
                     {
                       std::string valstr = fltk_label.substr (idx1 + 1, len - 1);
-                      fltk_label.erase(idx1, len + 1);
+                      fltk_label.erase (idx1, len + 1);
                       val = atoi (valstr.c_str ());
-                      if ((val > 0) && (val < 99))
+                      if (val > 0 && val < 99)
                         val++;
                     }
                   std::ostringstream valstream;
                   valstream << val;
                   fltk_label += "(" + valstream.str () + ")";
                 }
             }
           while (!item_added);
@@ -568,34 +583,34 @@ public:
       update_visible (uimenup);
       update_seperator (uimenup);
 
       for (octave_idx_type ii = 0; ii < len; ii++)
         {
           graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
           if (kgo.valid_object ())
             {
-              uimenu::properties& kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
+              uimenu::properties& kprop = dynamic_cast<uimenu::properties&> (kgo.get_properties ());
               add_to_menu (kprop);
             }
         }
     }
 
   void add_to_menu (figure::properties& figp)
     {
       Matrix kids = find_uimenu_children (figp);
       int len = kids.length ();
       menubar->clear ();
       for (octave_idx_type ii = 0; ii < len; ii++)
         {
           graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
           if (kgo.valid_object ())
             {
-              uimenu::properties& kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
+              uimenu::properties& kprop = dynamic_cast<uimenu::properties&> (kgo.get_properties ());
               add_to_menu (kprop);
             }
         }
     }
 
   template <class T_prop>
   void remove_from_menu (T_prop& prop)
     {
@@ -605,28 +620,28 @@ public:
       int len = kids.length ();
 
       for (octave_idx_type ii = 0; ii < len; ii++)
         {
           graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
           if (kgo.valid_object ())
             {
-              uimenu::properties kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
+              uimenu::properties kprop = dynamic_cast<uimenu::properties&> (kgo.get_properties ());
               remove_from_menu (kprop);
             }
         }
 
-      if (type.compare("uimenu") == 0)
-        delete_entry(dynamic_cast<uimenu::properties&>(prop));
-      else if (type.compare("figure") == 0)
+      if (type.compare ("uimenu") == 0)
+        delete_entry (dynamic_cast<uimenu::properties&> (prop));
+      else if (type.compare ("figure") == 0)
         menubar->clear ();
     }
 
-  ~fltk_uimenu()
+  ~fltk_uimenu (void)
     {
       delete menubar;
     }
 
 private:
 
   // No copying!
 
@@ -647,85 +662,56 @@ public:
       panzoom (0), rotate (0), help (0), status (0)
   {
     callback (window_close, static_cast<void*> (this));
     size_range (4*status_h, 2*status_h);
 
     begin ();
     {
 
-      canvas = new
-        OpenGL_fltk (0, 0, ww , hh - status_h, number ());
+      canvas = new OpenGL_fltk (0, 0, ww, hh - status_h, number ());
 
-      uimenu = new
-        fltk_uimenu(0, 0, ww, menu_h);
+      uimenu = new fltk_uimenu (0, 0, ww, menu_h);
       uimenu->hide ();
 
-      bottom = new
-        Fl_Box (0,
-                hh - status_h,
-                ww,
-                status_h);
+      bottom = new Fl_Box (0, hh - status_h, ww, status_h);
       bottom->box(FL_FLAT_BOX);
 
       ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
-      autoscale = new
-        Fl_Button (0,
-                   hh - status_h,
-                   status_h,
-                   status_h,
-                   "A");
+      autoscale = new Fl_Button (0, hh - status_h, status_h, status_h, "A");
       autoscale->callback (button_callback, static_cast<void*> (this));
       autoscale->tooltip ("Autoscale");
 
-      togglegrid = new
-        Fl_Button (status_h,
-                   hh - status_h,
-                   status_h,
-                   status_h,
-                   "G");
+      togglegrid = new Fl_Button (status_h, hh - status_h, status_h,
+                                  status_h, "G");
       togglegrid->callback (button_callback, static_cast<void*> (this));
       togglegrid->tooltip ("Toggle Grid");
 
-      panzoom = new
-        Fl_Button (2 * status_h,
-                   hh - status_h,
-                   status_h,
-                   status_h,
-                   "P");
+      panzoom = new Fl_Button (2 * status_h, hh - status_h, status_h,
+                               status_h, "P");
       panzoom->callback (button_callback, static_cast<void*> (this));
       panzoom->tooltip ("Mouse Pan/Zoom");
 
-      rotate = new
-        Fl_Button (3 * status_h,
-                   hh - status_h,
-                   status_h,
-                   status_h,
-                   "R");
+      rotate = new Fl_Button (3 * status_h, hh - status_h, status_h,
+                              status_h, "R");
       rotate->callback (button_callback, static_cast<void*> (this));
       rotate->tooltip ("Mouse Rotate");
 
       if (ndim == 2)
         rotate->deactivate ();
 
-      help = new
-        Fl_Button (4 * status_h,
-                   hh - status_h,
-                   status_h,
-                   status_h,
-                   "?");
+      help = new Fl_Button (4 * status_h, hh - status_h, status_h,
+                            status_h, "?");
       help->callback (button_callback, static_cast<void*> (this));
       help->tooltip ("Help");
 
-      status = new
-        Fl_Output (5 * status_h,
-                   hh - status_h,
-                   ww > 2*status_h ? ww - status_h : 0,
-                   status_h, "");
+      status = new Fl_Output (5 * status_h, hh - status_h,
+                              ww > 2*status_h ? ww - status_h : 0,
+                              status_h, "");
 
       status->textcolor (FL_BLACK);
       status->color (FL_GRAY);
       status->textfont (FL_COURIER);
       status->textsize (10);
       status->box (FL_ENGRAVED_BOX);
 
       // This allows us to have a valid OpenGL context right away.
@@ -763,19 +749,29 @@ public:
     status->hide ();
     uimenu->hide ();
     this->hide ();
     delete canvas;
     delete status;
     delete uimenu;
   }
 
-  // FIXME -- this could change.
   double number (void) { return fp.get___myhandle__ ().value (); }
 
+  void renumber (double new_number)
+  {
+    if (canvas)
+      {
+        if (canvas->renumber (new_number))
+          mark_modified ();
+      }
+    else
+      error ("unable to renumber figure");
+  }
+
   void print (const std::string& cmd, const std::string& term)
   {
     canvas->print (cmd, term);
 
     // Print immediately so the output file will exist when the drawnow
     // command is done.
     mark_modified ();
     Fl::wait (fltk_maxtime);
@@ -802,69 +798,78 @@ public:
                         canvas->y () - menu_h,
                         canvas->w (),
                         canvas->h () + menu_h);
         uimenu->hide ();
         mark_modified ();
       }
   }
 
-  void uimenu_update(graphics_handle gh, int id)
+  void uimenu_update (const graphics_handle& gh, int id)
   {
     graphics_object uimenu_obj = gh_manager::get_object (gh);
 
     if (uimenu_obj.valid_object () && uimenu_obj.isa ("uimenu"))
       {
         uimenu::properties& uimenup =
           dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
-        std::string fltk_label = uimenup.get_fltk_label();
-        graphics_object fig = uimenu_obj.get_ancestor("figure");
+        std::string fltk_label = uimenup.get_fltk_label ();
+        graphics_object fig = uimenu_obj.get_ancestor ("figure");
         figure::properties& figp =
           dynamic_cast<figure::properties&> (fig.get_properties ());
 
-        switch(id)
+        switch (id)
           {
-            case base_properties::ID_BEINGDELETED:
-              uimenu->remove_from_menu (uimenup);
-              break;
-            case base_properties::ID_VISIBLE:
-              uimenu->update_visible (uimenup);
-              break;
-            case uimenu::properties::ID_ACCELERATOR:
-              uimenu->update_accelerator (uimenup);
-              break;
-            case uimenu::properties::ID_CALLBACK:
-              uimenu->update_callback (uimenup);
-              break;
-            case uimenu::properties::ID_CHECKED:
-              uimenu->add_to_menu (figp);//rebuilding entire menu
-              break;
-            case uimenu::properties::ID_ENABLE:
-              uimenu->update_enable (uimenup);
-              break;
-            case uimenu::properties::ID_FOREGROUNDCOLOR:
-              uimenu->update_foregroundcolor (uimenup);
-              break;
-            case uimenu::properties::ID_LABEL:
-              uimenu->add_to_menu (figp);//rebuilding entire menu
-              break;
-            case uimenu::properties::ID_POSITION:
-              uimenu->add_to_menu (figp);//rebuilding entire menu
-              break;
-            case uimenu::properties::ID_SEPARATOR:
-              uimenu->update_seperator (uimenup);
-              break;
+          case base_properties::ID_BEINGDELETED:
+            uimenu->remove_from_menu (uimenup);
+            break;
+
+          case base_properties::ID_VISIBLE:
+            uimenu->update_visible (uimenup);
+            break;
+
+          case uimenu::properties::ID_ACCELERATOR:
+            uimenu->update_accelerator (uimenup);
+            break;
+
+          case uimenu::properties::ID_CALLBACK:
+            uimenu->update_callback (uimenup);
+            break;
+
+          case uimenu::properties::ID_CHECKED:
+            uimenu->add_to_menu (figp);//rebuilding entire menu
+            break;
+
+          case uimenu::properties::ID_ENABLE:
+            uimenu->update_enable (uimenup);
+            break;
+
+          case uimenu::properties::ID_FOREGROUNDCOLOR:
+            uimenu->update_foregroundcolor (uimenup);
+            break;
+
+          case uimenu::properties::ID_LABEL:
+            uimenu->add_to_menu (figp);//rebuilding entire menu
+            break;
+
+          case uimenu::properties::ID_POSITION:
+            uimenu->add_to_menu (figp);//rebuilding entire menu
+            break;
+
+          case uimenu::properties::ID_SEPARATOR:
+            uimenu->update_seperator (uimenup);
+            break;
           }
 
-          if (uimenu->items_to_show ())
-            show_menubar ();
-          else
-            hide_menubar ();
+        if (uimenu->items_to_show ())
+          show_menubar ();
+        else
+          hide_menubar ();
 
-          mark_modified();
+        mark_modified();
       }
   }
 
   void show_canvas (void)
   {
     if (fp.is_visible ())
       {
         canvas->show ();
@@ -880,17 +885,17 @@ public:
   void mark_modified (void)
   {
     damage (FL_DAMAGE_ALL);
     canvas->damage (FL_DAMAGE_ALL);
     ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
     if (ndim == 3)
       rotate->activate ();
-    else if ((ndim == 2) &&  (gui_mode == rotate_zoom))
+    else if (ndim == 2 && gui_mode == rotate_zoom)
       {
         rotate->deactivate ();
         gui_mode = pan_zoom;
       }
   }
 
   void set_name (void)
   {
@@ -981,24 +986,24 @@ private:
     octave_value_list args;
     if (fp.get_currentaxes ().ok ())
       args(0) = fp.get_currentaxes ().as_octave_value ();
 
     feval ("grid", args);
     mark_modified ();
   }
 
-  void pixel2pos
-  (graphics_handle ax, int px, int py, double& xx, double& yy) const
+  void pixel2pos (const graphics_handle& ax, int px, int py, double& xx,
+                  double& yy) const
   {
     pixel2pos ( gh_manager::get_object (ax), px, py, xx, yy);
   }
 
-  void pixel2pos
-  (graphics_object ax, int px, int py, double& xx, double& yy) const
+  void pixel2pos (graphics_object ax, int px, int py, double& xx,
+                  double& yy) const
   {
     if (ax && ax.isa ("axes"))
       {
         axes::properties& ap =
           dynamic_cast<axes::properties&> (ax.get_properties ());
         ColumnVector pp = ap.pixel2coord (px, py);
         xx = pp(0);
         yy = pp(1);
@@ -1028,17 +1033,17 @@ private:
                     return hnd;
                   }
               }
           }
       }
     return fp.get_currentaxes ();
   }
 
-  void pixel2status (graphics_handle ax, int px0, int py0,
+  void pixel2status (const graphics_handle& ax, int px0, int py0,
                      int px1 = -1, int py1 = -1)
   {
     pixel2status (gh_manager::get_object (ax), px0, py0, px1, py1);
   }
 
   void pixel2status (graphics_object ax, int px0, int py0,
                      int px1 = -1, int py1 = -1)
   {
@@ -1063,17 +1068,17 @@ private:
      if (ax && ax.isa ("axes"))
        {
          axes::properties& ap =
            dynamic_cast<axes::properties&> (ax.get_properties ());
          std::stringstream cbuf;
          cbuf.precision (4);
          cbuf.width (6);
          Matrix v (1,2,0);
-         v = ap.get("view").matrix_value();
+         v = ap.get ("view").matrix_value ();
          cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << "]";
 
          status->value (cbuf.str ().c_str ());
          status->redraw ();
        }
   }
 
   void set_currentpoint (int px, int py)
@@ -1160,33 +1165,33 @@ private:
     pos(3) = hh - status_h - menu_h;
 
     fp.set_position (pos);
   }
 
   void draw (void)
   {
     Matrix pos = fp.get_position ().matrix_value ();
-    Fl_Window::resize (pos(0), pos(1) , pos(2), pos(3) + status_h + menu_h);
+    Fl_Window::resize (pos(0), pos(1), pos(2), pos(3) + status_h + menu_h);
 
     return Fl_Window::draw ();
   }
 
   int handle (int event)
   {
     static int px0,py0;
     static graphics_object ax0;
 
     graphics_handle gh;
 
     graphics_object fig = gh_manager::get_object (fp.get___myhandle__ ());
     int retval = Fl_Window::handle (event);
 
     // We only handle events which are in the canvas area.
-    if (!Fl::event_inside(canvas))
+    if (!Fl::event_inside (canvas))
       return retval;
 
     if (!fp.is_beingdeleted ())
       {
         switch (event)
           {
           case FL_KEYDOWN:
             {
@@ -1358,19 +1363,19 @@ private:
             if (Fl::event_button () == 1)
               {
                 if ( Fl::event_clicks () == 1)
                   {
                     if (ax0 && ax0.isa ("axes"))
                       {
                         axes::properties& ap =
                           dynamic_cast<axes::properties&> (ax0.get_properties ());
-                        ap.set_xlimmode("auto");
-                        ap.set_ylimmode("auto");
-                        ap.set_zlimmode("auto");
+                        ap.set_xlimmode ("auto");
+                        ap.set_ylimmode ("auto");
+                        ap.set_zlimmode ("auto");
                         mark_modified ();
                       }
                   }
               }
             if (Fl::event_button () == 3)
               {
                 // End of drag -- zoom.
                 if (canvas->zoom ())
@@ -1457,28 +1462,35 @@ public:
   }
 
   static void delete_window (int idx)
   {
     if (instance_ok ())
       instance->do_delete_window (idx);
   }
 
-  static void delete_window (std::string idx_str)
+  static void delete_window (const std::string& idx_str)
   {
     delete_window (str2idx (idx_str));
   }
 
+  static void renumber_figure (const std::string& idx_str, double new_number)
+  {
+    if (instance_ok ())
+      instance->do_renumber_figure (str2idx (idx_str), new_number);
+  }
+
   static void toggle_window_visibility (int idx, bool is_visible)
   {
     if (instance_ok ())
       instance->do_toggle_window_visibility (idx, is_visible);
   }
 
-  static void toggle_window_visibility (std::string idx_str, bool is_visible)
+  static void toggle_window_visibility (const std::string& idx_str,
+                                        bool is_visible)
   {
     toggle_window_visibility (str2idx (idx_str), is_visible);
   }
 
   static void mark_modified (int idx)
   {
     if (instance_ok ())
       instance->do_mark_modified (idx);
@@ -1490,56 +1502,60 @@ public:
   }
 
   static void set_name (int idx)
   {
     if (instance_ok ())
       instance->do_set_name (idx);
   }
 
-  static void set_name (std::string idx_str)
+  static void set_name (const std::string& idx_str)
   {
     set_name (str2idx (idx_str));
   }
 
   static Matrix get_size (int idx)
   {
     return instance_ok () ? instance->do_get_size (idx) : Matrix ();
   }
 
   static Matrix get_size (const graphics_handle& gh)
   {
     return get_size (hnd2idx (gh));
   }
 
-  static void print (const graphics_handle& gh , const std::string& cmd, const std::string& term)
+  static void print (const graphics_handle& gh, const std::string& cmd,
+                     const std::string& term)
   {
     if (instance_ok ())
-      instance->do_print (hnd2idx(gh), cmd, term);
+      instance->do_print (hnd2idx (gh), cmd, term);
   }
 
-  static void uimenu_update (const graphics_handle& figh, const graphics_handle& uimenuh, const int id)
+  static void uimenu_update (const graphics_handle& figh,
+                             const graphics_handle& uimenuh, int id)
   {
     if (instance_ok ())
-      instance->do_uimenu_update (hnd2idx(figh), uimenuh, id);
+      instance->do_uimenu_update (hnd2idx (figh), uimenuh, id);
   }
 
-  static void update_canvas (const graphics_handle& gh, const graphics_handle& ca)
+  static void update_canvas (const graphics_handle& gh,
+                             const graphics_handle& ca)
   {
     if (instance_ok ())
-      instance->do_update_canvas (hnd2idx(gh), ca);
+      instance->do_update_canvas (hnd2idx (gh), ca);
   }
 
   static void toggle_menubar_visibility (int fig_idx, bool menubar_is_figure)
   {
     if (instance_ok ())
       instance->do_toggle_menubar_visibility (fig_idx, menubar_is_figure);
   }
 
-  static void toggle_menubar_visibility (std::string fig_idx_str, bool menubar_is_figure)
+  static void toggle_menubar_visibility (const std::string& fig_idx_str,
+                                         bool menubar_is_figure)
   {
     toggle_menubar_visibility (str2idx (fig_idx_str), menubar_is_figure);
   }
 
 private:
 
   static figure_manager *instance;
 
@@ -1563,138 +1579,143 @@ private:
     wm_iterator win;
     for (win = windows.begin (); win != windows.end (); win++)
       delete win->second;
     windows.clear ();
   }
 
   void do_new_window (figure::properties& fp)
   {
-    int x, y, w, h;
+    int idx = figprops2idx (fp);
 
-    int idx = figprops2idx (fp);
     if (idx >= 0 && windows.find (idx) == windows.end ())
       {
-        default_size (x, y, w, h);
-        idx2figprops (curr_index , fp);
+        Matrix pos = fp.get_boundingbox (true);
+
+        int x = pos(0);
+        int y = pos(1);
+        int w = pos(2);
+        int h = pos(3);
+
+        idx2figprops (curr_index, fp);
+
         windows[curr_index++] = new plot_window (x, y, w, h, fp);
       }
   }
 
   void do_delete_window (int idx)
   {
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
       {
         delete win->second;
         windows.erase (win);
       }
   }
 
+  void do_renumber_figure (int idx, double new_number)
+  {
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
+      win->second->renumber (new_number);
+  }
+
   void do_toggle_window_visibility (int idx, bool is_visible)
   {
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
       {
         if (is_visible)
           win->second->show ();
         else
           win->second->hide ();
 
         win->second->redraw ();
       }
   }
 
   void do_toggle_menubar_visibility (int fig_idx, bool menubar_is_figure)
   {
-    wm_iterator win;
-    if ((win = windows.find (fig_idx)) != windows.end ())
+    wm_iterator win = windows.find (fig_idx);
+
+    if (win != windows.end ())
       {
         if (menubar_is_figure)
           win->second->show_menubar ();
         else
           win->second->hide_menubar ();
 
         win->second->redraw ();
       }
   }
 
   void do_mark_modified (int idx)
   {
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
-      {
-        win->second->mark_modified ();
-      }
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
+      win->second->mark_modified ();
   }
 
   void do_set_name (int idx)
   {
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
-      {
-        win->second->set_name ();
-      }
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
+      win->second->set_name ();
   }
 
   Matrix do_get_size (int idx)
   {
     Matrix sz (1, 2, 0.0);
 
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
       {
         sz(0) = win->second->w ();
         sz(1) = win->second->h ();
       }
 
     return sz;
   }
 
   void do_print (int idx, const std::string& cmd, const std::string& term)
   {
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
-      {
-        win->second->print (cmd, term);
-      }
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
+      win->second->print (cmd, term);
   }
 
-  void do_uimenu_update (int idx, graphics_handle gh, int id)
+  void do_uimenu_update (int idx, const graphics_handle& gh, int id)
   {
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
-      {
-        win->second->uimenu_update (gh, id);
-      }
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
+      win->second->uimenu_update (gh, id);
   }
 
-  void do_update_canvas (int idx, graphics_handle ca)
+  void do_update_canvas (int idx, const graphics_handle& ca)
   {
-    wm_iterator win;
-    if ((win = windows.find (idx)) != windows.end ())
+    wm_iterator win = windows.find (idx);
+
+    if (win != windows.end ())
       {
         if (ca.ok ())
           win->second->show_canvas ();
         else
           win->second->hide_canvas ();
       }
   }
 
-
-  // FIXME -- default size should be configurable.
-  void default_size (int& x, int& y, int& w, int& h)
-  {
-    x = 0;
-    y = 0;
-    w = 640;
-    h = 480;
-  }
-
-  static int str2idx (const caseless_str clstr)
+  static int str2idx (const caseless_str& clstr)
   {
     int ind;
     if (clstr.find (fltk_idx_header,0) == 0)
       {
         std::istringstream istr (clstr.substr (fltk_idx_header.size ()));
         if (istr >> ind)
           return ind;
       }
@@ -1718,26 +1739,26 @@ private:
           return str2idx (ps.string_value ());
         else
           return 0;
       }
     error ("figure_manager: figure is not fltk");
     return -1;
   }
 
-  static int hnd2idx (const double h)
+  static int hnd2idx (double h)
   {
     graphics_object fobj = gh_manager::get_object (h);
     if (fobj &&  fobj.isa ("figure"))
       {
         figure::properties& fp =
           dynamic_cast<figure::properties&> (fobj.get_properties ());
         return figprops2idx (fp);
       }
-    error ("figure_manager: H is not a figure");
+    error ("figure_manager: H (= %g) is not a figure", h);
     return -1;
   }
 
   static int hnd2idx (const graphics_handle& fh)
   {
     return hnd2idx (fh.value ());
   }
 };
@@ -1802,63 +1823,78 @@ public:
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
 
         if (! ov.is_empty ())
           figure_manager::delete_window (ov.string_value ());
       }
   }
 
-  void uimenu_set_fltk_label(graphics_object uimenu_obj)
+  void uimenu_set_fltk_label (graphics_object uimenu_obj)
   {
     if (uimenu_obj.valid_object ())
       {
         uimenu::properties& uimenup =
           dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
         std::string fltk_label = uimenup.get_label ();
         graphics_object go = gh_manager::get_object (uimenu_obj.get_parent ());
         if (go.isa ("uimenu"))
           fltk_label = dynamic_cast<const uimenu::properties&> (go.get_properties ()).get_fltk_label ()
-                     + "/"
-                     + fltk_label;
+            + "/"
+            + fltk_label;
         else if (go.isa ("figure"))
           ;
         else
-          error("unexpected parent object\n");
+          error ("unexpected parent object\n");
 
-        uimenup.set_fltk_label(fltk_label);
+        uimenup.set_fltk_label (fltk_label);
       }
   }
 
   void update (const graphics_object& go, int id)
   {
     if (go.isa ("figure"))
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
 
         if (! ov.is_empty ())
           {
             const figure::properties& fp =
               dynamic_cast<const figure::properties&> (go.get_properties ());
 
             switch (id)
               {
-                case base_properties::ID_VISIBLE:
-                  figure_manager::toggle_window_visibility (ov.string_value (), fp.is_visible ());
-                  break;
-                case figure::properties::ID_MENUBAR:
-                  figure_manager::toggle_menubar_visibility (ov.string_value (), fp.menubar_is("figure"));
-                  break;
-                case figure::properties::ID_CURRENTAXES:
-                  figure_manager::update_canvas (go.get_handle (), fp.get_currentaxes ());
-                  break;
-                case figure::properties::ID_NAME:
-                case figure::properties::ID_NUMBERTITLE:
-                  figure_manager::set_name (ov.string_value ());
-                  break;
+              case base_properties::ID_VISIBLE:
+                figure_manager::toggle_window_visibility
+                  (ov.string_value (), fp.is_visible ());
+                break;
+
+              case figure::properties::ID_MENUBAR:
+                figure_manager::toggle_menubar_visibility
+                  (ov.string_value (), fp.menubar_is ("figure"));
+                break;
+
+              case figure::properties::ID_CURRENTAXES:
+                figure_manager::update_canvas
+                  (go.get_handle (), fp.get_currentaxes ());
+                break;
+
+              case figure::properties::ID_NAME:
+              case figure::properties::ID_NUMBERTITLE:
+                figure_manager::set_name (ov.string_value ());
+                break;
+
+              case figure::properties::ID_INTEGERHANDLE:
+                {
+                  std::string tmp = ov.string_value ();
+                  graphics_handle gh = fp.get___myhandle__ ();
+                  figure_manager::renumber_figure (tmp, gh.value ());
+                  figure_manager::set_name (tmp);
+                }
+                break;
               }
           }
       }
     else if (go.isa ("uimenu"))
       {
         if (id == uimenu::properties::ID_LABEL)
           uimenu_set_fltk_label (go);
 
@@ -1954,18 +1990,17 @@ DEFUN_DLD (__remove_fltk__, , , "")
       octave_value_list args;
       args(0) = "__fltk_redraw__";
       feval ("remove_input_event_hook", args, 0);
 
       // FIXME ???
       Fl::wait (fltk_maxtime);
     }
 
-  octave_value retval;
-  return retval;
+  return octave_value ();
 }
 
 DEFUN_DLD (__fltk_maxtime__, args, ,"")
 {
   octave_value retval = fltk_maxtime;
 
   if (args.length () == 1)
     {
@@ -1973,23 +2008,22 @@ DEFUN_DLD (__fltk_maxtime__, args, ,"")
         fltk_maxtime = args(0).double_value ();
       else
         error ("argument must be a real scalar");
     }
 
   return retval;
 }
 
-/* FIXME: This function should be abstracted and made potentially available
-          to all graphics toolkits.  This suggests putting it in graphics.cc
-          as is done for drawnow() and having the master mouse_wheel_zoom
-          function call fltk_mouse_wheel_zoom.  The same should be done for
-          gui_mode and fltk_gui_mode.  For now (2011.01.30), just
-          changing function names and docstrings.
-*/
+// FIXME -- This function should be abstracted and made potentially
+// available to all graphics toolkits.  This suggests putting it in
+// graphics.cc as is done for drawnow() and having the master
+// mouse_wheel_zoom function call fltk_mouse_wheel_zoom.  The same
+// should be done for gui_mode and fltk_gui_mode.  For now (2011.01.30),
+// just changing function names and docstrings.
 
 DEFUN_DLD (mouse_wheel_zoom, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{speed} =} mouse_wheel_zoom ()\n\
 @deftypefnx {Built-in Function} {} mouse_wheel_zoom (@var{speed})\n\
 Query or set the mouse wheel zoom factor.\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
@@ -2034,17 +2068,16 @@ This function is currently implemented o
 
   if (gui_mode == pan_zoom)
     mode_str = "2d";
   else if (gui_mode == rotate_zoom)
     mode_str = "3d";
   else
     mode_str = "none";
 
-
   bool failed = false;
 
   if (args.length () == 1)
     {
       if (args(0).is_string ())
         {
           mode_str = args(0).string_value ();
 
@@ -2059,14 +2092,12 @@ This function is currently implemented o
         }
       else
         failed = true;
     }
 
   if (failed)
     error ("MODE must be one of the strings: \"2D\", \"3D\", or \"none\"");
 
-
-  return octave_value(mode_str);
+  return octave_value (mode_str);
 }
 
-
 #endif
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -611,17 +611,17 @@ in that case, an updated permutation mat
 Note that if @var{L}, @var{U}, @var{P} is a pivoted LU@tie{}factorization\n\
 as obtained by @code{lu}:\n\
 \n\
 @example\n\
   [@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
 @end example\n\
 \n\
 @noindent\n\
-then a factorization of @code{@var{A}+@var{x}*@var{y}.'} can be obtained\n\
+then a factorization of @xcode{@var{A}+@var{x}*@var{y}.'} can be obtained\n\
 either as\n\
 \n\
 @example\n\
   [@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
 @end example\n\
 \n\
 @noindent\n\
 or\n\
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -304,21 +304,23 @@ do_minmax_body (const octave_value_list&
 
   return retval;
 }
 
 DEFUN_DLD (min, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} min (@var{x})\n\
 @deftypefnx {Loadable Function} {} min (@var{x}, @var{y})\n\
+@deftypefnx {Loadable Function} {} min (@var{x}, [], @var{dim})\n\
 @deftypefnx {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
 For a vector argument, return the minimum value.  For a matrix\n\
 argument, return the minimum value from each column, as a row\n\
-vector, or over the dimension @var{dim} if defined.  For two matrices\n\
+vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
+should be set to the empty matrix (it's ignored otherwise).  For two matrices\n\
 (or a matrix and scalar), return the pair-wise minimum.\n\
 Thus,\n\
 \n\
 @example\n\
 min (min (@var{x}))\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -381,21 +383,23 @@ minimum value(s).  Thus,\n\
 %! assert (ndims(i), 2);
 
 */
 
 DEFUN_DLD (max, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} max (@var{x})\n\
 @deftypefnx {Loadable Function} {} max (@var{x}, @var{y})\n\
+@deftypefnx {Loadable Function} {} max (@var{x}, [], @var{dim})\n\
 @deftypefnx {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
 For a vector argument, return the maximum value.  For a matrix\n\
 argument, return the maximum value from each column, as a row\n\
-vector, or over the dimension @var{dim} if defined.  For two matrices\n\
+vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
+should be set to the empty matrix (it's ignored otherwise).  For two matrices\n\
 (or a matrix and scalar), return the pair-wise maximum.\n\
 Thus,\n\
 \n\
 @example\n\
 max (max (@var{x}))\n\
 @end example\n\
 \n\
 @noindent\n\
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -302,17 +302,17 @@ upper triangular Schur@tie{}form @var{T}
 \n\
 Note that the following relations hold:\n\
 \n\
 @tex\n\
 $UR \\cdot TR \\cdot {UR}^T = U T U^{\\dagger}$ and\n\
 $U^{\\dagger} U$ is the identity matrix I.\n\
 @end tex\n\
 @ifnottex\n\
-@code{@var{UR} * @var{TR} * @var{UR}' = @var{U} * @var{T} * @var{U}'} and\n\
+@xcode{@var{UR} * @var{TR} * @var{UR}' = @var{U} * @var{T} * @var{U}'} and\n\
 @code{@var{U}' * @var{U}} is the identity matrix I.\n\
 @end ifnottex\n\
 \n\
 Note also that @var{U} and @var{T} are not unique.\n\
 @seealso{schur}\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -58,20 +58,20 @@ Is the type of the factorization and can
 @table @samp\n\
 @item sym\n\
 Factorize @var{S}.  This is the default.\n\
 \n\
 @item col\n\
 Factorize @code{@var{S}' * @var{S}}.\n\
 \n\
 @item row\n\
-Factorize @code{@var{S} * @var{S}'}.\n\
+Factorize @xcode{@var{S} * @var{S}'}.\n\
 \n\
 @item lo\n\
-Factorize @code{@var{S}'}\n\
+Factorize @xcode{@var{S}'}\n\
 @end table\n\
 \n\
 @item mode\n\
 The default is to return the Cholesky@tie{}factorization for @var{r}, and if\n\
 @var{mode} is 'L', the conjugate transpose of the Cholesky@tie{}factorization\n\
 is returned.  The conjugate transpose version is faster and uses less\n\
 memory, but returns the same values for @var{count}, @var{h}, @var{parent}\n\
 and @var{post} outputs.\n\
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -377,17 +377,17 @@ do_bitunpack (const ArrayType& array)
       bits += CHAR_BIT;
     }
 
   return retval;
 }
 
 DEFUN_DLD (bitunpack, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x})\n\
+@deftypefn {Loadable Function} {@var{y} =} bitunpack (@var{x})\n\
 Return an array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -5283,41 +5283,36 @@ Return the logical NOT of @var{x}.  This
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_not, args);
 }
 
 DEFUN (uplus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uplus (@var{x})\n\
-This function is equivalent to @w{@code{+ x}}.\n\
+This function and @w{@xcode{+ x}} are equivalent.\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uplus, args);
 }
 
 DEFUN (uminus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uminus (@var{x})\n\
-This function is equivalent to @w{@code{- x}}.\n\
+This function and @w{@xcode{- x}} are equivalent.\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uminus, args);
 }
 
 DEFUN (transpose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} transpose (@var{x})\n\
-Return the transpose of @var{x}.  This function is equivalent to\n\
-@tex\n\
-@code{x.'}.\n\
-@end tex\n\
-@ifnottex\n\
-x.'.\n\
-@end ifnottex\n\
+Return the transpose of @var{x}.\n\
+This function and @xcode{x.'} are equivalent.\n\
 @seealso{ctranspose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_transpose, args);
 }
 
 /*
 
@@ -5339,24 +5334,18 @@ x.'.\n\
 
 %!assert (transpose (single([1,2;3,4])),single([1,3;2,4]));
 
 */
 
 DEFUN (ctranspose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ctranspose (@var{x})\n\
-Return the complex conjugate transpose of @var{x}.  This function is\n\
-equivalent to\n\
-@tex\n\
-@code{x'}.\n\
-@end tex\n\
-@ifnottex\n\
-x'.\n\
-@end ifnottex\n\
+Return the complex conjugate transpose of @var{x}.\n\
+This function and @xcode{x'} are equivalent.\n\
 @seealso{transpose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_hermitian, args);
 }
 
 /*
 
@@ -5422,17 +5411,17 @@ binary_assoc_op_defun_body (octave_value
 
   return retval;
 }
 
 DEFUN (plus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} plus (@var{x1}, @var{x2}, @dots{})\n\
-This function is equivalent to @w{@code{x + y}}.\n\
+This function and @w{@xcode{x + y}} are equivalent.\n\
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 + x2) + x3) + @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
@@ -5441,29 +5430,29 @@ At least one argument is required.\n\
 {
   return binary_assoc_op_defun_body (octave_value::op_add,
                                      octave_value::op_add_eq, args);
 }
 
 DEFUN (minus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} minus (@var{x}, @var{y})\n\
-This function is equivalent to @w{@code{x - y}}.\n\
+This function and @w{@xcode{x - y}} are equivalent.\n\
 @seealso{plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_sub, args);
 }
 
 DEFUN (mtimes, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
 Return the matrix multiplication product of inputs.\n\
-This function is equivalent to @w{@code{x * y}}.\n\
+This function and @w{@xcode{x * y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 * x2) * x3) * @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
@@ -5473,39 +5462,39 @@ At least one argument is required.\n\
   return binary_assoc_op_defun_body (octave_value::op_mul,
                                      octave_value::op_mul_eq, args);
 }
 
 DEFUN (mrdivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mrdivide (@var{x}, @var{y})\n\
 Return the matrix right division of @var{x} and @var{y}.\n\
-This function is equivalent to @w{@code{x / y}}.\n\
+This function and @w{@xcode{x / y}} are equivalent.\n\
 @seealso{mldivide, rdivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_div, args);
 }
 
 DEFUN (mpower, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mpower (@var{x}, @var{y})\n\
 Return the matrix power operation of @var{x} raised to the @var{y} power.\n\
-This function is equivalent to @w{@code{x ^ y}}.\n\
+This function and @w{@xcode{x ^ y}} are equivalent.\n\
 @seealso{power}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_pow, args);
 }
 
 DEFUN (mldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mldivide (@var{x}, @var{y})\n\
 Return the matrix left division of @var{x} and @var{y}.\n\
-This function is equivalent to @w{@code{x \\ y}}.\n\
+This function and @w{@xcode{x \\ y}} are equivalent.\n\
 @seealso{mrdivide, ldivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ldiv, args);
 }
 
 DEFUN (lt, args, ,
   "-*- texinfo -*-\n\
@@ -5565,17 +5554,17 @@ This function is equivalent to @w{@code{
   return binary_op_defun_body (octave_value::op_ne, args);
 }
 
 DEFUN (times, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} times (@var{x1}, @var{x2}, @dots{})\n\
 Return the element-by-element multiplication product of inputs.\n\
-This function is equivalent to @w{@code{x .* y}}.\n\
+This function and @w{@xcode{x .* y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
   (@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
@@ -5585,40 +5574,40 @@ At least one argument is required.\n\
   return binary_assoc_op_defun_body (octave_value::op_el_mul,
                                      octave_value::op_el_mul_eq, args);
 }
 
 DEFUN (rdivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rdivide (@var{x}, @var{y})\n\
 Return the element-by-element right division of @var{x} and @var{y}.\n\
-This function is equivalent to @w{@code{x ./ y}}.\n\
+This function and @w{@xcode{x ./ y}} are equivalent.\n\
 @seealso{ldivide, mrdivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
 Return the element-by-element operation of @var{x} raised to the\n\
 @var{y} power.\n\
-This function is equivalent to @w{@code{x .^ y}}.\n\
+This function and @w{@xcode{x .^ y}} are equivalent.\n\
 @seealso{mpower}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
 Return the element-by-element left division of @var{x} and @var{y}.\n\
-This function is equivalent to @w{@code{x .\\ y}}.\n\
+This function and @w{@xcode{x .\\ y}} are equivalent.\n\
 @seealso{rdivide, mldivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -924,17 +924,17 @@ do_dbstack (const octave_value_list& arg
   return retval;
 }
 
 // A function that can be easily called from a debugger print the Octave
 // stack.  This can be useful for finding what line of code the
 // interpreter is currently executing when the debugger is stopped in
 // some C++ function, for example.
 
-static void
+void
 show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{stack}, @var{idx}]} dbstack (@var{n})\n\
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1459,33 +1459,34 @@ void
 initialize_default_warning_state (void)
 {
   initialize_warning_options ("on");
 
   // Most people will want to have the following disabled.
 
   disable_warning ("Octave:array-to-scalar");
   disable_warning ("Octave:array-to-vector");
-  disable_warning ("Octave:empty-list-elements");
-  disable_warning ("Octave:fortran-indexing");
   disable_warning ("Octave:imag-to-real");
   disable_warning ("Octave:matlab-incompatible");
   disable_warning ("Octave:missing-semicolon");
   disable_warning ("Octave:neg-dim-as-zero");
   disable_warning ("Octave:resize-on-range-error");
   disable_warning ("Octave:separator-insert");
   disable_warning ("Octave:single-quote-string");
   disable_warning ("Octave:str-to-num");
-  disable_warning ("Octave:string-concat");
+  disable_warning ("Octave:mixed-string-concat");
   disable_warning ("Octave:variable-switch-label");
-  disable_warning ("Octave:complex-cmp-ops");
 
   // This should be an error unless we are in maximum braindamage mode.
+  // FIXME: Not quite right.  This sets the error state even for braindamage
+  // mode.  Also, this error is not triggered in normal mode because another
+  // error handler catches it first and gives:
+  // error: subscript indices must be either positive integers or logicals
+  set_warning_state ("Octave:noninteger-range-as-index", "error");
 
-  set_warning_state ("Octave:allow-noninteger-ranges-as-indices", "error");
 }
 
 DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
 @deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror ('reset')\n\
 Query or set the last error message structure.  When called without arguments\n\
diff --git a/src/find-defun-files.sh b/src/find-defun-files.sh
--- a/src/find-defun-files.sh
+++ b/src/find-defun-files.sh
@@ -16,11 +16,11 @@ shift
 for arg
 do
   if [ -f "$arg" ]; then
     file="$arg"
   else
     file="$srcdir/$arg"
   fi
   if [ "`$EGREP -l "$DEFUN_PATTERN" $file`" ]; then
-    echo "$file" | $SED 's,.*/,,; s/\.\(cc\|yy\|ll\)$/.df/';
+    echo "$file" | $SED 's,.*/,,; s/\.cc$/.df/; s/\.ll$/.df/; s/\.yy$/.df/';
   fi
 done
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -408,18 +408,17 @@ convert_font_size (double font_size, con
         }
     }
 
   return new_font_size;
 }
 
 static Matrix
 convert_position (const Matrix& pos, const caseless_str& from_units,
-                  const caseless_str& to_units,
-                  const Matrix& parent_dim = Matrix (1, 2, 0.0))
+                  const caseless_str& to_units, const Matrix& parent_dim)
 {
   Matrix retval (1, pos.numel ());
   double res = 0;
   bool is_rectangle = (pos.numel () == 4);
   bool is_2d = (pos.numel () == 2);
 
   if (from_units.compare ("pixels"))
     retval = pos;
@@ -2104,21 +2103,21 @@ static double
 make_handle_fraction (void)
 {
   static double maxrand = RAND_MAX + 2.0;
 
   return (rand () + 1.0) / maxrand;
 }
 
 graphics_handle
-gh_manager::get_handle (const std::string& go_name)
+gh_manager::do_get_handle (bool integer_figure_handle)
 {
   graphics_handle retval;
 
-  if (go_name == "figure")
+  if (integer_figure_handle)
     {
       // Figure handles are positive integers corresponding to the
       // figure number.
 
       // We always want the lowest unused figure number.
 
       retval = 1;
 
@@ -2191,16 +2190,48 @@ gh_manager::do_free (const graphics_hand
           else
             error ("graphics_handle::free: invalid object %g", h.value ());
         }
       else
         error ("graphics_handle::free: can't delete root figure");
     }
 }
 
+void
+gh_manager::do_renumber_figure (const graphics_handle& old_gh,
+                                const graphics_handle& new_gh)
+{
+  iterator p = handle_map.find (old_gh);
+
+  if (p != handle_map.end ())
+    {
+      graphics_object go = p->second;
+
+      handle_map.erase (p);
+
+      handle_map[new_gh] = go;
+
+      if (old_gh.value () < 0)
+        handle_free_list.insert (std::ceil (old_gh.value ())
+                                 - make_handle_fraction ());
+    }
+  else
+    error ("graphics_handle::free: invalid object %g", old_gh.value ());
+
+  for (figure_list_iterator q = figure_list.begin ();
+       q != figure_list.end (); q++)
+    {
+      if (*q == old_gh)
+        {
+          *q = new_gh;
+          break;
+        }
+    }
+}
+
 gh_manager *gh_manager::instance = 0;
 
 static void
 xset (const graphics_handle& h, const caseless_str& name,
       const octave_value& val)
 {
   graphics_object obj = gh_manager::get_object (h);
   obj.set (name, val);
@@ -2775,20 +2806,24 @@ base_graphics_object::remove_all_listene
   for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
     {
       // FIXME -- there has to be a better way.  I think we want to
       // ask whether it is OK to delete the listener for the given
       // property.  How can we know in advance that it will be OK?
 
       unwind_protect frame;
 
+      frame.protect_var (error_state);
       frame.protect_var (discard_error_messages);
-      frame.protect_var (error_state);
+      frame.protect_var (Vdebug_on_error);
+      frame.protect_var (Vdebug_on_warning);
 
       discard_error_messages = true;
+      Vdebug_on_error = false;
+      Vdebug_on_warning = false;
 
       property p = get_properties ().get_property (pa->first);
 
       if (! error_state && p.ok ())
         p.delete_listener ();
     }
 }
 
@@ -2919,16 +2954,60 @@ root_figure::properties::set_callbackobj
         cbo_stack.push_front (get_callbackobject ());
 
       callbackobject = val;
     }
   else
     gripe_set_invalid ("callbackobject");
 }
 
+void
+figure::properties::set_integerhandle (const octave_value& val)
+{
+  if (! error_state)
+    {
+      if (integerhandle.set (val, true))
+        {
+          bool int_fig_handle = integerhandle.is_on ();
+
+          graphics_object this_go = gh_manager::get_object (__myhandle__);
+
+          graphics_handle old_myhandle = __myhandle__;
+
+          __myhandle__ = gh_manager::get_handle (int_fig_handle);
+
+          gh_manager::renumber_figure (old_myhandle, __myhandle__);
+
+          graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+          base_properties& props = parent_go.get_properties ();
+
+          props.renumber_child (old_myhandle, __myhandle__);
+
+          Matrix kids = get_children ();
+
+          for (octave_idx_type i = 0; i < kids.numel (); i++)
+            {
+              graphics_object kid = gh_manager::get_object (kids(i));
+
+              kid.get_properties ().renumber_parent (__myhandle__);
+            }
+
+          graphics_handle cf = gh_manager::current_figure ();
+
+          if (__myhandle__ == cf)
+            xset (0, "currentfigure", __myhandle__.value ());
+
+          this_go.update (integerhandle.get_id ());
+
+          mark_modified ();
+        }
+    }
+}
+
 // FIXME This should update monitorpositions and pointerlocation, but
 // as these properties are yet used, and so it doesn't matter that they
 // aren't set yet.
 void
 root_figure::properties::update_units (void)
 {
   caseless_str xunits = get_units ();
 
@@ -3845,17 +3924,18 @@ void
 axes::properties::set_text_child (handle_property& hp,
                                   const std::string& who,
                                   const octave_value& v)
 {
   graphics_handle val;
 
   if (v.is_string ())
     {
-      val = gh_manager::make_graphics_handle ("text", __myhandle__, false);
+      val = gh_manager::make_graphics_handle ("text", __myhandle__,
+                                              false, false);
 
       xset (val, "string", v);
     }
   else
     {
       graphics_object go = gh_manager::get_object (gh_manager::lookup (v));
 
       if (go.isa ("text"))
@@ -4045,20 +4125,27 @@ axes::properties::set_defaults (base_gra
       tlooseinset(3) = 1-tlooseinset(1)-tlooseinset(3);
       looseinset = tlooseinset;
 
       activepositionproperty = "outerposition";
     }
 
   delete_children (true);
 
-  xlabel = gh_manager::make_graphics_handle ("text", __myhandle__, false);
-  ylabel = gh_manager::make_graphics_handle ("text", __myhandle__, false);
-  zlabel = gh_manager::make_graphics_handle ("text", __myhandle__, false);
-  title = gh_manager::make_graphics_handle ("text", __myhandle__, false);
+  xlabel = gh_manager::make_graphics_handle ("text", __myhandle__,
+                                             false, false);
+
+  ylabel = gh_manager::make_graphics_handle ("text", __myhandle__,
+                                             false, false);
+
+  zlabel = gh_manager::make_graphics_handle ("text", __myhandle__,
+                                             false, false);
+
+  title = gh_manager::make_graphics_handle ("text", __myhandle__,
+                                            false, false);
 
   xset (xlabel.handle_value (), "handlevisibility", "off");
   xset (ylabel.handle_value (), "handlevisibility", "off");
   xset (zlabel.handle_value (), "handlevisibility", "off");
   xset (title.handle_value (), "handlevisibility", "off");
 
   xset (xlabel.handle_value (), "horizontalalignment", "center");
   xset (xlabel.handle_value (), "horizontalalignmentmode", "auto");
@@ -4118,17 +4205,18 @@ axes::properties::delete_text_child (han
 
   // FIXME -- is it necessary to check whether the axes object is
   // being deleted now?  I think this function is only called when an
   // individual child object is delete and not when the parent axes
   // object is deleted.
 
   if (! is_beingdeleted ())
     {
-      hp = gh_manager::make_graphics_handle ("text", __myhandle__, false);
+      hp = gh_manager::make_graphics_handle ("text", __myhandle__,
+                                             false, false);
 
       xset (hp.handle_value (), "handlevisibility", "off");
 
       adopt (hp.handle_value ());
     }
 }
 
 void
@@ -4613,18 +4701,16 @@ axes::properties::update_axes_layout (vo
 
   zPlaneN = (zPlane == z_min ? z_max : z_min);
   fz = (z_max-z_min)/sqrt(dir(0)*dir(0)+dir(1)*dir(1));
 
   unwind_protect frame;
   frame.protect_var (updating_axes_layout);
   updating_axes_layout = true;
 
-  update_ticklengths ();
-
   xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   zSign = (zd*(zPlane-zPlaneN) <= 0);
   xyzSym = zSign ? xySym : !xySym;
   xpTick = (zSign ? xPlaneN : xPlane);
   ypTick = (zSign ? yPlaneN : yPlane);
   zpTick = (zSign ? zPlane : zPlaneN);
   xpTickN = (zSign ? xPlane : xPlaneN);
   ypTickN = (zSign ? yPlane : yPlaneN);
@@ -4660,16 +4746,18 @@ axes::properties::update_axes_layout (vo
         layer2Dtop = true;
       }
     else
       zpTick = zPlane;
   }
 
   Matrix viewmat = get_view ().matrix_value ();
   nearhoriz = std::abs(viewmat(1)) <= 5;
+
+  update_ticklengths ();
 }
 
 void
 axes::properties::update_ticklengths (void)
 {
   bool mode2d = (((xstate > AXE_DEPTH_DIR ? 1 : 0) +
                   (ystate > AXE_DEPTH_DIR ? 1 : 0) +
                   (zstate > AXE_DEPTH_DIR ? 1 : 0)) == 2);
@@ -7277,20 +7365,22 @@ gh_manager::gh_manager (void)
   handle_map[0] = graphics_object (new root_figure ());
 
   // Make sure the default graphics toolkit is registered.
   graphics_toolkit::default_toolkit ();
 }
 
 graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
-                                     const graphics_handle& p, bool do_createfcn,
+                                     const graphics_handle& p,
+                                     bool integer_figure_handle,
+                                     bool do_createfcn,
                                      bool do_notify_toolkit)
 {
-  graphics_handle h = get_handle (go_name);
+  graphics_handle h = get_handle (integer_figure_handle);
 
   base_graphics_object *go = 0;
 
   go = make_graphics_object_from_type (go_name, h, p);
 
   if (go)
     {
       graphics_object obj (go);
@@ -8202,16 +8292,17 @@ Undocumented internal function.\n\
         retval = vals(0);
     }
 
   return retval;
 }
 
 static octave_value
 make_graphics_object (const std::string& go_name,
+                      bool integer_figure_handle,
                       const octave_value_list& args)
 {
   octave_value retval;
 
   double val = octave_NaN;
 
   octave_value_list xargs = args.splice (0, 1);
 
@@ -8241,17 +8332,19 @@ make_graphics_object (const std::string&
 
   if (! error_state)
     {
       graphics_handle parent = gh_manager::lookup (val);
 
       if (parent.ok ())
         {
           graphics_handle h
-            = gh_manager::make_graphics_handle (go_name, parent, false, false);
+            = gh_manager::make_graphics_handle (go_name, parent,
+                                                integer_figure_handle,
+                                                false, false);
 
           if (! error_state)
             {
               adopt (parent, h);
 
               xset (h, xargs);
               xcreatefcn (h);
               xinitialize (h);
@@ -8295,31 +8388,71 @@ Undocumented internal function.\n\
               graphics_handle h = gh_manager::lookup (val);
 
               xset (h, args.splice (0, 1));
 
               retval = h.value ();
             }
           else
             {
+              bool int_fig_handle = true;
+
+              octave_value_list xargs = args.splice (0, 1);
+
               graphics_handle h = octave_NaN;
 
               if (xisnan (val))
-                h = gh_manager::make_graphics_handle ("figure", 0, false,
-                                                      false);
+                {
+                  caseless_str p ("integerhandle");
+
+                  for (int i = 0; i < xargs.length (); i++)
+                    {
+                      if (xargs(i).is_string ()
+                          && p.compare (xargs(i).string_value ()))
+                        {
+                          if (i < (xargs.length () - 1))
+                            {
+                              std::string pval = xargs(i+1).string_value ();
+
+                              if (! error_state)
+                                {
+                                  caseless_str on ("on");
+                                  int_fig_handle = on.compare (pval);
+                                  xargs = xargs.splice (i, 2);
+                                  break;
+                                }
+                            }
+                        }
+                    }
+
+                  h = gh_manager::make_graphics_handle ("figure", 0,
+                                                        int_fig_handle,
+                                                        false, false);
+
+                  if (! int_fig_handle)
+                    {
+                      // We need to intiailize the integerhandle
+                      // property without calling the set_integerhandle
+                      // method, because doing that will generate a new
+                      // handle value...
+
+                      graphics_object go = gh_manager::get_object (h);
+                      go.get_properties ().init_integerhandle ("off");
+                    }
+                }
               else if (val > 0 && D_NINT (val) == val)
                 h = gh_manager::make_figure_handle (val, false);
-              else
-                error ("__go_figure__: invalid figure number");
 
               if (! error_state && h.ok ())
                 {
                   adopt (0, h);
 
-                  xset (h, args.splice (0, 1));
+                  gh_manager::push_figure (h);
+
+                  xset (h, xargs);
                   xcreatefcn (h);
                   xinitialize (h);
 
                   retval = h.value ();
                 }
               else
                 error ("__go_figure__: failed to create figure handle");
             }
@@ -8334,17 +8467,17 @@ Undocumented internal function.\n\
 }
 
 #define GO_BODY(TYPE) \
   gh_manager::auto_lock guard; \
  \
   octave_value retval; \
  \
   if (args.length () > 0) \
-    retval = make_graphics_object (#TYPE, args); \
+    retval = make_graphics_object (#TYPE, false, args);  \
   else \
     print_usage (); \
  \
   return retval
 
 int
 calc_dimensions (const graphics_object& go)
 {
@@ -8659,36 +8792,46 @@ Undocumented internal function.\n\
         error ("__go_axes_init__: invalid graphics object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN (__go_handles__, , ,
+DEFUN (__go_handles__, args, ,
    "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_handles__ ()\n\
+@deftypefn {Built-in Function} {} __go_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  return octave_value (gh_manager::handle_list ());
-}
-
-DEFUN (__go_figure_handles__, , ,
+  bool show_hidden = false;
+
+  if (args.length () > 0)
+    show_hidden = args(0).bool_value ();
+
+  return octave_value (gh_manager::handle_list (show_hidden));
+}
+
+DEFUN (__go_figure_handles__, args, ,
    "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __go_figure_handles__ ()\n\
+@deftypefn {Built-in Function} {} __go_figure_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  return octave_value (gh_manager::figure_handle_list ());
+  bool show_hidden = false;
+
+  if (args.length () > 0)
+    show_hidden = args(0).bool_value ();
+
+  return octave_value (gh_manager::figure_handle_list (show_hidden));
 }
 
 DEFUN (__go_execute_callback__, args, ,
    "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name})\n\
 @deftypefnx {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
 Undocumented internal function.\n\
 @end deftypefn")
@@ -8813,17 +8956,17 @@ undocumented.\n\
         {
           octave_add_atexit_function ("__go_close_all__");
 
           __go_close_all_registered__ = true;
         }
 
       if (args.length () == 0 || args.length () == 1)
         {
-          Matrix hlist = gh_manager::figure_handle_list ();
+          Matrix hlist = gh_manager::figure_handle_list (true);
 
           for (int i = 0; ! error_state && i < hlist.length (); i++)
             {
               graphics_handle h = gh_manager::lookup (hlist(i));
 
               if (h.ok () && h != 0)
                 {
                   graphics_object go = gh_manager::get_object (h);
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -1706,16 +1706,31 @@ public:
       return octave_value (get_children ());
     }
 
   void delete_children (bool clear = false)
     {
       do_delete_children (clear);
     }
 
+  void renumber (graphics_handle old_gh, graphics_handle new_gh)
+    {
+      for (children_list_iterator p = children_list.begin ();
+           p != children_list.end (); p++)
+        {
+          if (*p == old_gh)
+            {
+              *p = new_gh.value ();
+              return;
+            }
+        }
+
+      error ("children_list::renumber: child not found!");
+    }
+
 private:
   typedef std::list<double>::iterator children_list_iterator;
   typedef std::list<double>::const_iterator const_children_list_iterator;
   std::list<double> children_list;
 
 protected:
   bool do_set (const octave_value& val)
     {
@@ -2268,16 +2283,21 @@ public:
   virtual ~base_properties (void) { }
 
   virtual std::string graphics_object_name (void) const { return "unknonwn"; }
 
   void mark_modified (void);
 
   void override_defaults (base_graphics_object& obj);
 
+  virtual void init_integerhandle (const octave_value&)
+    {
+      panic_impossible ();
+    }
+
   // Look through DEFAULTS for properties with given CLASS_NAME, and
   // apply them to the current object with set (virtual method).
 
   void set_from_list (base_graphics_object& obj, property_list& defaults);
 
   void insert_property (const std::string& name, property p)
     {
       p.set_name (name);
@@ -2372,16 +2392,26 @@ public:
   virtual void update_axis_limits (const std::string& axis_type,
                                    const graphics_handle& h) const;
 
   virtual void delete_children (bool clear = false)
     {
       children.delete_children (clear);
     }
 
+  void renumber_child (graphics_handle old_gh, graphics_handle new_gh)
+    {
+      children.renumber (old_gh, new_gh);
+    }
+
+  void renumber_parent (graphics_handle new_gh)
+    {
+      parent = new_gh;
+    }
+
   static property_list::pval_map_type factory_defaults (void);
 
   // FIXME -- these functions should be generated automatically by the
   // genprops.awk script.
   //
   // EMIT_BASE_PROPERTIES_GET_FUNCTIONS
 
   virtual octave_value get_xlim (void) const { return octave_value (); }
@@ -3070,16 +3100,21 @@ private:
 // ---------------------------------------------------------------------
 
 class OCTINTERP_API figure : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
+    void init_integerhandle (const octave_value& val)
+      {
+        integerhandle = val;
+      }
+
     void remove_child (const graphics_handle& h);
 
     void set_visible (const octave_value& val);
 
     graphics_toolkit get_toolkit (void) const
       {
         if (! toolkit)
           toolkit = graphics_toolkit::default_toolkit ();
@@ -3148,17 +3183,17 @@ public:
       color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
       array_property alphamap , Matrix (64, 1, 1)
       string_property currentcharacter r , ""
       handle_property currentobject r , graphics_handle ()
       array_property currentpoint r , Matrix (2, 1, 0)
       bool_property dockcontrols , "off"
       bool_property doublebuffer , "on"
       string_property filename , ""
-      bool_property integerhandle , "on"
+      bool_property integerhandle S , "on"
       bool_property inverthardcopy , "off"
       callback_property keypressfcn , Matrix ()
       callback_property keyreleasefcn , Matrix ()
       radio_property menubar , "none|{figure}"
       double_property mincolormap , 64
       string_property name , ""
       bool_property numbertitle , "on"
       array_property outerposition s , Matrix (1, 4, -1.0)
@@ -3523,20 +3558,20 @@ public:
       row_vector_property zlim mu , default_lim ()
       row_vector_property clim m , default_lim ()
       row_vector_property alim m , default_lim ()
       radio_property xlimmode al , "{auto}|manual"
       radio_property ylimmode al , "{auto}|manual"
       radio_property zlimmode al , "{auto}|manual"
       radio_property climmode al , "{auto}|manual"
       radio_property alimmode    , "{auto}|manual"
-      handle_property xlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
-      handle_property ylabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
-      handle_property zlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
-      handle_property title SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
+      handle_property xlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
+      handle_property ylabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
+      handle_property zlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
+      handle_property title SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
       bool_property xgrid , "off"
       bool_property ygrid , "off"
       bool_property zgrid , "off"
       bool_property xminorgrid , "off"
       bool_property yminorgrid , "off"
       bool_property zminorgrid , "off"
       row_vector_property xtick mu , default_axes_tick ()
       row_vector_property ytick mu , default_axes_tick ()
@@ -4263,17 +4298,17 @@ public:
       array_property cdata u , Matrix ()
       radio_property cdatamapping l , "{scaled}|direct"
       array_property faces , Matrix ()
       array_property facevertexalphadata , Matrix ()
       array_property facevertexcdata , Matrix ()
       array_property vertices , Matrix ()
       array_property vertexnormals , Matrix ()
       radio_property normalmode , "{auto}|manual"
-      color_property facecolor , "{flat}|none|interp"
+      color_property facecolor , color_property (color_values (0, 0, 0), radio_values ("flat|none|interp"))
       double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp"))
       radio_property facelighting , "flat|{none}|gouraud|phong"
       color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("flat|none|interp"))
       double_radio_property edgealpha , double_radio_property (1.0, radio_values ("flat|interp"))
       radio_property edgelighting , "{none}|flat|gouraud|phong"
       radio_property backfacelighting , "{reverselit}|unlit|lit"
       double_property ambientstrength , 0.3
       double_property diffusestrength , 0.6
@@ -4379,17 +4414,17 @@ public:
       array_property ydata u , Matrix ()
       array_property zdata u , Matrix ()
       array_property cdata u , Matrix ()
       radio_property cdatamapping al , "{scaled}|direct"
       string_property xdatasource , ""
       string_property ydatasource , ""
       string_property zdatasource , ""
       string_property cdatasource , ""
-      color_property facecolor , "{flat}|none|interp|texturemap"
+      color_property facecolor , "{flat}|none|interp"
       double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp"))
       color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("flat|none|interp"))
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
       radio_property marker , "{none}|s|o|x|+|.|*|<|>|v|^|d|p|h|@"
       color_property markeredgecolor , "{auto}|none"
       color_property markerfacecolor , "auto|{none}"
       double_property markersize , 6
@@ -5142,22 +5177,35 @@ public:
         ::error ("unable to create gh_manager!");
 
         retval = false;
       }
 
     return retval;
   }
 
+  static graphics_handle get_handle (bool integer_figure_handle)
+  {
+    return instance_ok ()
+      ? instance->do_get_handle (integer_figure_handle) : graphics_handle ();
+  }
+
   static void free (const graphics_handle& h)
   {
     if (instance_ok ())
       instance->do_free (h);
   }
 
+  static void renumber_figure (const graphics_handle& old_gh,
+                               const graphics_handle& new_gh)
+  {
+    if (instance_ok ())
+      instance->do_renumber_figure (old_gh, new_gh);
+  }
+
   static graphics_handle lookup (double val)
   {
     return instance_ok () ? instance->do_lookup (val) : graphics_handle ();
   }
 
   static graphics_handle lookup (const octave_value& val)
   {
     return val.is_real_scalar ()
@@ -5171,22 +5219,25 @@ public:
 
   static graphics_object get_object (const graphics_handle& h)
   {
     return instance_ok () ? instance->do_get_object (h) : graphics_object ();
   }
 
   static graphics_handle
   make_graphics_handle (const std::string& go_name,
-                        const graphics_handle& parent, bool do_createfcn = true,
+                        const graphics_handle& parent,
+                        bool integer_figure_handle = false,
+                        bool do_createfcn = true,
                         bool do_notify_toolkit = true)
   {
     return instance_ok ()
-      ? instance->do_make_graphics_handle (go_name, parent, do_createfcn,
-                                           do_notify_toolkit)
+      ? instance->do_make_graphics_handle (go_name, parent,
+                                           integer_figure_handle,
+                                           do_createfcn, do_notify_toolkit)
       : graphics_handle ();
   }
 
   static graphics_handle make_figure_handle (double val,
                                              bool do_notify_toolkit = true)
   {
     return instance_ok ()
       ? instance->do_make_figure_handle (val, do_notify_toolkit)
@@ -5206,19 +5257,20 @@ public:
   }
 
   static graphics_handle current_figure (void)
   {
     return instance_ok ()
       ? instance->do_current_figure () : graphics_handle ();
   }
 
-  static Matrix handle_list (void)
+  static Matrix handle_list (bool show_hidden = false)
   {
-    return instance_ok () ? instance->do_handle_list () : Matrix ();
+    return instance_ok ()
+      ? instance->do_handle_list (show_hidden) : Matrix ();
   }
 
   static void lock (void)
   {
     if (instance_ok ())
       instance->do_lock ();
   }
 
@@ -5231,19 +5283,20 @@ public:
   }
 
   static void unlock (void)
   {
     if (instance_ok ())
       instance->do_unlock ();
   }
   
-  static Matrix figure_handle_list (void)
+  static Matrix figure_handle_list (bool show_hidden = false)
   {
-    return instance_ok () ? instance->do_figure_handle_list () : Matrix ();
+    return instance_ok ()
+      ? instance->do_figure_handle_list (show_hidden) : Matrix ();
   }
 
   static void execute_listener (const graphics_handle& h,
                                 const octave_value& l)
   {
     if (instance_ok ())
       instance->do_execute_listener (h, l);
   }
@@ -5376,73 +5429,102 @@ private:
   std::list<graphics_event> event_queue;
 
   // The stack of callback objects.
   std::list<graphics_object> callback_objects;
 
   // A flag telling whether event processing must be constantly on.
   int event_processing;
 
-  graphics_handle get_handle (const std::string& go_name);
+  graphics_handle do_get_handle (bool integer_figure_handle);
 
   void do_free (const graphics_handle& h);
 
+  void do_renumber_figure (const graphics_handle& old_gh,
+                           const graphics_handle& new_gh);
+
   graphics_handle do_lookup (double val)
   {
     iterator p = (xisnan (val) ? handle_map.end () : handle_map.find (val));
 
     return (p != handle_map.end ()) ? p->first : graphics_handle ();
   }
 
   graphics_object do_get_object (const graphics_handle& h)
   {
     iterator p = (h.ok () ? handle_map.find (h) : handle_map.end ());
 
     return (p != handle_map.end ()) ? p->second : graphics_object ();
   }
 
   graphics_handle do_make_graphics_handle (const std::string& go_name,
-                                           const graphics_handle& p, bool do_createfcn,
+                                           const graphics_handle& p,
+                                           bool integer_figure_handle,
+                                           bool do_createfcn,
                                            bool do_notify_toolkit);
 
   graphics_handle do_make_figure_handle (double val, bool do_notify_toolkit);
 
-  Matrix do_handle_list (void)
+  Matrix do_handle_list (bool show_hidden)
   {
     Matrix retval (1, handle_map.size ());
+
     octave_idx_type i = 0;
     for (const_iterator p = handle_map.begin (); p != handle_map.end (); p++)
       {
         graphics_handle h = p->first;
-        retval(i++) = h.value ();
+
+        if (show_hidden || is_handle_visible (h))
+          retval(i++) = h.value ();
       }
+
+    retval.resize (1, i);
+
     return retval;
   }
 
-  Matrix do_figure_handle_list (void)
+  Matrix do_figure_handle_list (bool show_hidden)
   {
     Matrix retval (1, figure_list.size ());
+
     octave_idx_type i = 0;
     for (const_figure_list_iterator p = figure_list.begin ();
          p != figure_list.end ();
          p++)
       {
         graphics_handle h = *p;
-        retval(i++) = h.value ();
+
+        if (show_hidden || is_handle_visible (h))
+          retval(i++) = h.value ();
       }
+
+    retval.resize (1, i);
+
     return retval;
   }
 
   void do_push_figure (const graphics_handle& h);
 
   void do_pop_figure (const graphics_handle& h);
 
   graphics_handle do_current_figure (void) const
   {
-    return figure_list.empty () ? graphics_handle () : figure_list.front ();
+    graphics_handle retval;
+
+    for (const_figure_list_iterator p = figure_list.begin ();
+         p != figure_list.end ();
+         p++)
+      {
+        graphics_handle h = *p;
+
+        if (is_handle_visible (h))
+          retval = h;
+      }
+
+    return retval;
   }
 
   void do_lock (void) { graphics_lock.lock (); }
 
   bool do_try_lock (void) { return graphics_lock.try_lock (); }
 
   void do_unlock (void) { graphics_lock.unlock (); }
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -147,53 +147,53 @@ Begin comment character.\n\
 @deftypefn {Operator} {} %\n\
 Begin comment character.\n\
 @seealso{#, %@{}\n\
 @end deftypefn"),
 
   pair_type ("#{",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@{\n\
-Begin block comment. There must be nothing else other than\n\
-whitespace in the line, both before and after @code{#@{}. Also,\n\
-it is possible to nest block comments.\n\
-@seealso{#, #@}, %@{}\n\
+Begin block comment.  There must be nothing else, other than\n\
+whitespace, in the line both before and after @code{#@{}.\n\
+It is possible to nest block comments.\n\
+@seealso{%@{, #@}, #}\n\
 @end deftypefn"),
 
   pair_type ("%{",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@{\n\
-Begin block comment. There must be nothing else other than\n\
-whitespace in the line, both before and after @code{%@{}. Also,\n\
-it is possible to nest block comments.\n\
-@seealso{%, %@}, #@{}\n\
+Begin block comment.  There must be nothing else, other than\n\
+whitespace, in the line both before and after @code{%@{}.\n\
+It is possible to nest block comments.\n\
+@seealso{#@{, %@}, %}\n\
 @end deftypefn"),
 
   pair_type ("#}",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@}\n\
-Close block comment. There must be nothing else other than\n\
-whitespace in the line, both before and after @code{#@}}. Also,\n\
-it is possible to nest block comments.\n\
-@seealso{#, #@{, %@}}\n\
+Close block comment.  There must be nothing else, other than\n\
+whitespace, in the line both before and after @code{#@}}.\n\
+It is possible to nest block comments.\n\
+@seealso{%@}, #@{, #}\n\
 @end deftypefn"),
 
   pair_type ("%}",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@}\n\
-Close block comment. There must be nothing else other than\n\
-whitespace in the line, both before and after @code{%@}}. Also,\n\
-it is possible to nest block comments.\n\
-@seealso{%, %@{, #@}}\n\
+Close block comment.  There must be nothing else, other than\n\
+whitespace, in the line both before and after @code{%@}}.\n\
+It is possible to nest block comments.\n\
+@seealso{#@}, %@{, %}\n\
 @end deftypefn"),
 
   pair_type ("...",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ...\n\
-Continuation marker. Joins current line with following line.\n\
+Continuation marker.  Joins current line with following line.\n\
 @end deftypefn"),
 
   pair_type ("&",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} &\n\
 Element by element logical 'and' operator.\n\
 @seealso{&&, and}\n\
 @end deftypefn"),
@@ -203,22 +203,22 @@ Element by element logical 'and' operato
 @deftypefn {Operator} {} &&\n\
 Logical 'and' operator (with short-circuit evaluation).\n\
 @seealso{&, and}\n\
 @end deftypefn"),
 
   pair_type ("'",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} '\n\
-Matrix transpose operator. For complex matrices, computes the\n\
+Matrix transpose operator.  For complex matrices, computes the\n\
 complex conjugate (Hermitian) transpose.\n\
 \n\
 The single quote character may also be used to delimit strings, but\n\
 it is better to use the double quote character, since that is never\n\
-ambiguous\n\
+ambiguous.\n\
 @seealso{.', transpose}\n\
 @end deftypefn"),
 
   pair_type ("(",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} (\n\
 Array index or function argument delimiter.\n\
 @end deftypefn"),
@@ -255,17 +255,17 @@ Power operator.\n\
 @deftypefn {Operator} {} +\n\
 Addition operator.\n\
 @seealso{plus}\n\
 @end deftypefn"),
 
   pair_type ("++",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ++\n\
-Increment operator. As in C, may be applied as a prefix or postfix\n\
+Increment operator.  As in C, may be applied as a prefix or postfix\n\
 operator.\n\
 @seealso{--}\n\
 @end deftypefn"),
 
   pair_type (",",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ,\n\
 Array index, function argument, or command separator.\n\
@@ -276,25 +276,25 @@ Array index, function argument, or comma
 @deftypefn {Operator} {} -\n\
 Subtraction or unary negation operator.\n\
 @seealso{minus}\n\
 @end deftypefn"),
 
   pair_type ("--",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} --\n\
-Decrement operator. As in C, may be applied as a prefix or postfix\n\
+Decrement operator.  As in C, may be applied as a prefix or postfix\n\
 operator.\n\
 @seealso{++}\n\
 @end deftypefn"),
 
   pair_type (".'",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .'\n\
-Matrix transpose operator. For complex matrices, computes the\n\
+Matrix transpose operator.  For complex matrices, computes the\n\
 transpose, @emph{not} the complex conjugate transpose.\n\
 @seealso{', transpose}\n\
 @end deftypefn"),
 
   pair_type (".*",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .*\n\
 Element by element multiplication operator.\n\
@@ -623,17 +623,17 @@ Begin a for loop that may execute in par
 \n\
 @example\n\
 @group\n\
 parfor i = 1:10\n\
   i\n\
 endparfor\n\
 @end group\n\
 @end example\n\
-@seealso{do, for, while}\n\
+@seealso{for, do, while}\n\
 @end deftypefn"),
 
   pair_type ("persistent",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} persistent @var{var}\n\
 Declare variables as persistent.  A variable that has been declared\n\
 persistent within a function will retain its contents in memory between\n\
 subsequent calls to the same function.  The difference between persistent\n\
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -1896,21 +1896,17 @@ fold (tree_binary_expression *e)
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *op1 = e->lhs ();
   tree_expression *op2 = e->rhs ();
 
   octave_value::binary_op op_type = e->op_type ();
 
-  if (op1->is_constant () && op2->is_constant ()
-      && (! ((warning_enabled ("Octave:associativity-change")
-              && (op_type == POW || op_type == EPOW))
-             || (warning_enabled ("Octave:precedence-change")
-                 && (op_type == EXPR_OR || op_type == EXPR_OR_OR)))))
+  if (op1->is_constant () && op2->is_constant ())
     {
       octave_value tmp = e->rvalue1 ();
 
       if (! (error_state || warning_state))
         {
           tree_constant *tc_retval
             = new tree_constant (tmp, op1->line (), op1->column ());
 
@@ -2145,64 +2141,32 @@ make_anon_fcn_handle (tree_parameter_lis
     = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_scope, l, c);
   // FIXME: Stash the filename.  This does not work and produces
   // errors when executed.
   //retval->stash_file_name (curr_fcn_file_name);
 
   return retval;
 }
 
-static void
-maybe_warn_associativity_change (tree_expression *op)
-{
-  if (op->paren_count () == 0 && op->is_binary_expression ())
-    {
-      tree_binary_expression *e
-        = dynamic_cast<tree_binary_expression *> (op);
-
-      octave_value::binary_op op_type = e->op_type ();
-
-      if (op_type == octave_value::op_pow
-          || op_type == octave_value::op_el_pow)
-        {
-          std::string op_str = octave_value::binary_op_as_string (op_type);
-
-          if (curr_fcn_file_full_name.empty ())
-            warning_with_id
-              ("Octave:associativity-change",
-               "meaning may have changed due to change in associativity for %s operator",
-               op_str.c_str ());
-          else
-            warning_with_id
-              ("Octave:associativity-change",
-               "meaning may have changed due to change in associativity for %s operator near line %d, column %d in file `%s'",
-               op_str.c_str (), op->line (), op->column (),
-               curr_fcn_file_full_name.c_str ());
-        }
-    }
-}
-
 // Build a binary expression.
 
 static tree_expression *
 make_binary_op (int op, tree_expression *op1, token *tok_val,
                 tree_expression *op2)
 {
   octave_value::binary_op t = octave_value::unknown_binary_op;
 
   switch (op)
     {
     case POW:
       t = octave_value::op_pow;
-      maybe_warn_associativity_change (op1);
       break;
 
     case EPOW:
       t = octave_value::op_el_pow;
-      maybe_warn_associativity_change (op1);
       break;
 
     case '+':
       t = octave_value::op_add;
       break;
 
     case '-':
       t = octave_value::op_sub;
@@ -2265,35 +2229,16 @@ make_binary_op (int op, tree_expression 
       break;
 
     case EXPR_AND:
       t = octave_value::op_el_and;
       break;
 
     case EXPR_OR:
       t = octave_value::op_el_or;
-      if (op2->paren_count () == 0 && op2->is_binary_expression ())
-        {
-          tree_binary_expression *e
-            = dynamic_cast<tree_binary_expression *> (op2);
-
-          if (e->op_type () == octave_value::op_el_and)
-            {
-              if (curr_fcn_file_full_name.empty ())
-                warning_with_id
-                  ("Octave:precedence-change",
-                   "meaning may have changed due to change in precedence for & and | operators");
-              else
-                warning_with_id
-                  ("Octave:precedence-change",
-                   "meaning may have changed due to change in precedence for & and | operators near line %d, column %d in file `%s'",
-                   op2->line (), op2->column (),
-                   curr_fcn_file_full_name.c_str ());
-            }
-        }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   int l = tok_val->line ();
@@ -2316,26 +2261,16 @@ make_boolean_op (int op, tree_expression
   switch (op)
     {
     case EXPR_AND_AND:
       t = tree_boolean_expression::bool_and;
       break;
 
     case EXPR_OR_OR:
       t = tree_boolean_expression::bool_or;
-      if (op2->paren_count () == 0 && op2->is_boolean_expression ())
-        {
-          tree_boolean_expression *e
-            = dynamic_cast<tree_boolean_expression *> (op2);
-
-          if (e->op_type () == tree_boolean_expression::bool_and)
-            warning_with_id
-              ("Octave:precedence-change",
-               "meaning may have changed due to change in precedence for && and || operators");
-        }
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   int l = tok_val->line ();
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -75,33 +75,130 @@ octave_class::octave_class (const octave
   for (octave_idx_type idx = 0; idx < n; idx++)
     {
       octave_value parent = parents(idx);
 
       if (! parent.is_object ())
         error ("parents must be objects");
       else
         {
-          std::string cnm = parent.class_name ();
+          std::string pcnm = parent.class_name ();
 
-          if (find_parent_class (cnm))
+          if (find_parent_class (pcnm))
             error ("duplicate class in parent tree");
           else
             {
-              parent_list.push_back (cnm);
+              parent_list.push_back (pcnm);
 
-              if (map.numel () > 1)
+              octave_idx_type nel = map.numel ();
+              octave_idx_type p_nel = parent.numel ();
+
+              if (nel == 0)
                 {
-                  // If MAP has more than one element, put the parent
-                  // class object in each element.
+                  if (p_nel == 0)
+                    {
+                      // No elements in MAP or the parent class object,
+                      // so just add the field name.
+
+                      map.assign (pcnm, Cell (map.dims ()));
+                    }
+                  else if (p_nel == 1)
+                    {
+                      if (map.nfields () == 0)
+                        {
+                          // No elements or fields in MAP, but the
+                          // parent is class object with one element.
+                          // Resize to match size of parent class and
+                          // make the parent a field in MAP.
+
+                          map.resize (parent.dims ());
+
+                          map.assign (pcnm, parent);
+                        }
+                      else
+                        {
+                          // No elements in MAP, but we have at least
+                          // one field.  So don't resize, just add the
+                          // field name.
 
-                  map.assign (cnm, Cell (map.dims (), parent));
+                          map.assign (pcnm, Cell (map.dims ()));
+                        }
+                    }
+                  else if (map.nfields () == 0)
+                    {
+                      // No elements or fields in MAP and more than one
+                      // element in the parent class object, so we can
+                      // resize MAP to match parent dimsenions, then
+                      // distribute the elements of the parent object to
+                      // the elements of MAP.
+
+                      dim_vector parent_dims = parent.dims ();
+
+                      map.resize (parent_dims);
+
+                      Cell c (parent_dims);
+
+                      octave_map pmap = parent.map_value ();
+
+                      std::list<std::string> plist
+                        = parent.parent_class_name_list ();
+
+                      for (octave_idx_type i = 0; i < p_nel; i++)
+                        c(i) = octave_value (pmap.index(i), pcnm, plist);
+
+                      map.assign (pcnm, c);
+                    }
+                  else
+                    error ("class: parent class dimension mismatch");
+                }
+              else if (nel == 1 && p_nel == 1)
+                {
+                  // Simple assignment.
+
+                  map.assign (pcnm, parent);
                 }
               else
-                map.assign (cnm, parent);
+                {
+                  if (p_nel == 1)
+                    {
+                      // Broadcast the scalar parent class object to
+                      // each element of MAP.
+
+                      Cell pcell (map.dims (), parent);
+
+                      map.assign (pcnm, pcell);
+                    }
+
+                  else if (nel == p_nel)
+                    {
+                      // FIXME -- is there a better way to do this?
+
+                      // The parent class object has the same number of
+                      // elements as the map we are using to create the
+                      // new object, so distribute those elements to
+                      // each element of the new object by first
+                      // splitting the elements of the parent class
+                      // object into a cell array with one element per
+                      // cell.  Then do the assignment all at once.
+
+                      Cell c (parent.dims ());
+
+                      octave_map pmap = parent.map_value ();
+
+                      std::list<std::string> plist
+                        = parent.parent_class_name_list ();
+
+                      for (octave_idx_type i = 0; i < p_nel; i++)
+                        c(i) = octave_value (pmap.index(i), pcnm, plist);
+
+                      map.assign (pcnm, c);
+                    }
+                  else
+                    error ("class: parent class dimension mismatch");
+                }
             }
         }
     }
 
   if (! error_state)
     symbol_table::add_to_parent_map (id, parent_list);
 }
 
@@ -329,21 +426,21 @@ octave_class::size (void)
         retval = lv(0).matrix_value ();
       else
         error ("@%s/size: invalid return value", class_name ().c_str ());
     }
   else
     {
       dim_vector dv = dims ();
 
-      int nel = dv.numel ();
+      int nd = dv.length ();
 
-      retval.resize (1, nel);
+      retval.resize (1, nd);
 
-      for (int i = 0; i < nel; i++)
+      for (int i = 0; i < nd; i++)
         retval(i) = dv(i);
     }
 
   return retval;
 }
 
 octave_idx_type
 octave_class::numel (const octave_value_list& idx)
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -656,17 +656,24 @@ compatibility; however, it is still not 
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (allow_noninteger_range_as_index);
 }
 
 /*
 %!test
 %! x = 0:10;
-%! save = allow_noninteger_range_as_index (0);
-%! fail ('x(2.1:5)');
-%! assert (x(2:5), 1:4);
-%! allow_noninteger_range_as_index (1);
-%! assert (x(2.49:5), 1:3);
-%! assert (x(2.5:5), 2:4);
-%! assert (x(2.51:5), 2:4);
-%! allow_noninteger_range_as_index (save);
+%! save = allow_noninteger_range_as_index ();
+%! warn_state = warning ("query", "Octave:noninteger-range-as-index");
+%! unwind_protect
+%!   save = allow_noninteger_range_as_index (false);
+%!   fail ('x(2.1:5)');
+%!   assert (x(2:5), 1:4);
+%!   allow_noninteger_range_as_index (true);
+%!   warning ("off", "Octave:noninteger-range-as-index");
+%!   assert (x(2.49:5), 1:3);
+%!   assert (x(2.5:5), 2:4);
+%!   assert (x(2.51:5), 2:4);
+%! unwind_protect_cleanup
+%!   allow_noninteger_range_as_index (save);
+%!   warning (warn_state.state, warn_state.identifier);
+%! end_unwind_protect
 */
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -643,33 +643,43 @@ function accepts a variable number of ar
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string fname = args(0).string_value ();
 
       if (! error_state)
         {
-          octave_value fcn_val = symbol_table::find_user_function (fname);
+          octave_value fcn_val = symbol_table::find_function (fname);
 
-          octave_user_function *fcn = fcn_val.user_function_value (true);
-
-          if (fcn)
+          if (fcn_val.is_user_function ())
             {
-              if (fcn->takes_varargs ())
-                retval = -1;
-              else
+              octave_user_function *fcn = fcn_val.user_function_value (true);
+
+              if (fcn)
                 {
-                  tree_parameter_list *param_list = fcn->parameter_list ();
+                  if (fcn->takes_varargs ())
+                    retval = -1;
+                  else
+                    {
+                      tree_parameter_list *param_list = fcn->parameter_list ();
 
-                  retval = param_list ? param_list->length () : 0;
+                      retval = param_list ? param_list->length () : 0;
+                    }
                 }
+              else
+                error ("nargin: loading user-defined function failed");
             }
           else
-            error ("nargin: invalid function");
+            {
+              // FIXME -- what about built-in functions or functions
+              // defined in .oct files or .mex files?
+
+              error ("nargin: FCN_NAME must be a user-defined function");
+            }
         }
       else
         error ("nargin: FCN_NAME must be a string");
     }
   else if (nargin == 0)
     {
       retval = symbol_table::varval (".nargin.");
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2879,18 +2879,19 @@ Note that this is the same as writing @c
 %! t.b = "There";
 %! t.c = 163;
 %! assert (s, t)
 
 */
 
 DEFUN (is_sq_string, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} is_sq_string (@var{val})\n\
-Return true if @var{val} is a single-quoted character string\n\
+@deftypefn {Built-in Function} {} is_sq_string (@var{x})\n\
+Return true if @var{x} is a single-quoted character string.\n\
+@seealso{is_dq_string, ischar}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_sq_string ();
   else
     print_usage ();
@@ -2904,18 +2905,19 @@ Return true if @var{val} is a single-quo
 %!assert (is_sq_string (1.0), false);
 %!assert (is_sq_string ({2.0}), false);
 %!error is_sq_string ()
 %!error is_sq_string ('foo', 2)
 */
 
 DEFUN (is_dq_string, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} is_dq_string (@var{val})\n\
-Return true if @var{val} is a double-quoted character string\n\
+@deftypefn {Built-in Function} {} is_dq_string (@var{x})\n\
+Return true if @var{x} is a double-quoted character string.\n\
+@seealso{is_sq_string, ischar}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_dq_string ();
   else
     print_usage ();
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -112,17 +112,16 @@ private:
     void cellify (void);
 
   private:
 
     tm_row_const_rep (const tm_row_const_rep&);
 
     tm_row_const_rep& operator = (const tm_row_const_rep&);
 
-    void eval_warning (const char *msg, int l, int c) const;
   };
 
 public:
 
   typedef tm_row_const_rep::iterator iterator;
   typedef tm_row_const_rep::const_iterator const_iterator;
 
   tm_row_const (void)
@@ -455,27 +454,16 @@ tm_row_const::tm_row_const_rep::cellify 
                   eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
                   break;
                 }
             }
         }
     }
 }
 
-void
-tm_row_const::tm_row_const_rep::eval_warning (const char *msg, int l,
-                                              int c) const
-{
-  if (l == -1 && c == -1)
-    warning_with_id ("Octave:empty-list-elements", "%s", msg);
-  else
-    warning_with_id ("Octave:empty-list-elements",
-                     "%s near line %d, column %d", msg, l, c);
-}
-
 class
 tm_const : public octave_base_list<tm_row_const>
 {
 public:
 
   tm_const (const tree_matrix& tm)
     : dv (0, 0), all_str (false), all_sq_str (false), all_dq_str (false),
       some_str (false), all_real (false), all_cmplx (false),
@@ -721,17 +709,17 @@ tree_matrix::rvalue (int nargout)
 
   return retval;
 }
 
 void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
 {
   if (! (all_dq_strings_p || all_sq_strings_p))
-    warning_with_id ("Octave:string-concat",
+    warning_with_id ("Octave:mixed-string-concat",
                      "concatenation of different character string types may have unintended consequences");
 }
 
 template<class TYPE, class T>
 static void
 single_type_concat (Array<T>& result,
                     tm_const& tmp)
 {
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -96,41 +96,53 @@ BSD_init (void)
 #define FP_X_DNML 0
 #endif
   fpsetmask (~(FP_X_OFL|FP_X_INV|FP_X_DZ|FP_X_DNML|FP_X_UFL|FP_X_IMP));
 #endif
 }
 #endif
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
+
+#define WIN32_LEAN_AND_MEAN
+#include <tlhelp32.h>
+
 static void
 w32_set_octave_home (void)
 {
-  int n = 1024;
+  std::string bin_dir;
 
-  std::string bin_dir (n, '\0');
+  HANDLE h = CreateToolhelp32Snapshot (TH32CS_SNAPMODULE |
+				       TH32CS_SNAPMODULE32, 0);
 
-  while (true)
+  if (h != INVALID_HANDLE_VALUE)
     {
-      HMODULE hMod = GetModuleHandle ("octinterp");
-      if (! hMod)
-        hMod = GetModuleHandle ("liboctinterp-0");
+      MODULEENTRY32 mod_info;
+
+      ZeroMemory (&mod_info, sizeof (mod_info));
+      mod_info.dwSize = sizeof (mod_info);
 
-      int status = GetModuleFileName (hMod, &bin_dir[0], n);
+      if (Module32First (h, &mod_info))
+	{
+	  do
+	    {
+	      std::string mod_name (mod_info.szModule);
 
-      if (status < n)
-        {
-          bin_dir.resize (status);
-          break;
-        }
-      else
-        {
-          n *= 2;
-          bin_dir.resize (n);
-        }
+	      if (mod_name.find ("octinterp") != std::string::npos)
+		{
+		  bin_dir = mod_info.szExePath;
+		  if (bin_dir[bin_dir.length () - 1] != '\\')
+		    bin_dir.append (1, '\\');
+		  break;
+		}
+	    }
+	  while (Module32Next (h, &mod_info));
+	}
+
+      CloseHandle (h);
     }
 
   if (! bin_dir.empty ())
     {
       size_t pos = bin_dir.rfind ("\\bin\\");
 
       if (pos != std::string::npos)
         octave_env::putenv ("OCTAVE_HOME", bin_dir.substr (0, pos));
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -47,16 +47,17 @@ FCN_FILES = \
   test_switch.m \
   test_system.m \
   test_transpose.m \
   test_try.m \
   test_unwind.m \
   test_while.m
 
 include classes/module.mk
+include class-concat/module.mk
 include ctor-vs-method/module.mk
 include fcn-handle-derived-resolution/module.mk
 
 check: test_sparse.m test_bc_overloads.m
 	$(top_builddir)/run-octave --norc --silent --no-history $(srcdir)/fntests.m $(srcdir)
 
 test_sparse.m: build_sparse_tests.sh
 	$(srcdir)/build_sparse_tests.sh
diff --git a/test/class-concat/@foo/foo.m b/test/class-concat/@foo/foo.m
new file mode 100644
--- /dev/null
+++ b/test/class-concat/@foo/foo.m
@@ -0,0 +1,3 @@
+function r = foo ()
+  r = class (struct (), 'foo');
+endfunction
diff --git a/test/class-concat/module.mk b/test/class-concat/module.mk
new file mode 100644
--- /dev/null
+++ b/test/class-concat/module.mk
@@ -0,0 +1,5 @@
+class_concat_FCN_FILES = \
+  class-concat/@foo/foo.m \
+  class-concat/test_class_concat.m
+
+FCN_FILES += $(class_concat_FCN_FILES)
diff --git a/test/class-concat/test_class_concat.m b/test/class-concat/test_class_concat.m
new file mode 100644
--- /dev/null
+++ b/test/class-concat/test_class_concat.m
@@ -0,0 +1,14 @@
+%!test
+%! f = foo ();
+%! x = [f,f];
+%! assert (size (x), [1, 2])
+%! assert (class (x), "foo")
+
+%!test
+%! f = foo ();
+%! x = [f,f];
+%! tmp = num2cell (x);
+%! assert (iscell (tmp))
+%! assert (size (tmp), [1, 2])
+%! assert (class (tmp{1}), "foo")
+%! assert (class (tmp{2}), "foo")
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -114,17 +114,17 @@ function [dp, dn, dxf, dsk] = run_test_d
   lst = dir (d);
   dp = dn = dxf = dsk = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
     if (lst(i).isdir
         && ! strcmp (nm, ".") && ! strcmp (nm, "..")
         && ! strcmp (nm, "private") && nm(1) != "@"
         && ! strcmp (nm, "CVS"))
-      [p, n, xf, sk] = run_test_dir (fid, [d, "/", nm]);
+      [p, n, xf, sk] = run_test_dir (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dsk += sk;
     endif
   endfor
   saved_dir = pwd ();
   unwind_protect
@@ -162,17 +162,17 @@ function [dp, dn, dxf, dsk] = run_test_s
   global topsrcdir;
   global topbuilddir;
   lst = dir (d);
   dp = dn = dxf = dsk = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
     if (lst(i).isdir && ! strcmp (nm, ".") && ! strcmp (nm, "..")
         && ! strcmp (nm, "CVS"))
-      [p, n, xf, sk] = run_test_script (fid, [d, "/", nm]);
+      [p, n, xf, sk] = run_test_script (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dsk += sk;
     endif
   endfor
   for i = 1:length (lst)
     nm = lst(i).name;
@@ -181,18 +181,18 @@ function [dp, dn, dxf, dsk] = run_test_s
       continue
     endif
     f = fullfile (d, nm);
     if ((length (nm) > 2 && strcmp (nm((end-1):end), ".m")) || 
         (length (nm) > 3 && strcmp (nm((end-2):end), ".cc")))
       p = n = xf = 0;
       ## Only run if it contains %!test, %!assert %!error or %!warning
       if (has_tests (f))
-        tmp = strrep (f, [topsrcdir, "/"], "");
-        tmp = strrep (tmp, [topbuilddir, "/"], "../");
+        tmp = strrep (f, [topsrcdir, filesep], "");
+        tmp = strrep (tmp, [topbuilddir, filesep], ["..", filesep]);
         print_test_file_name (tmp);
         [p, n, xf, sk] = test (f, "quiet", fid);
         print_pass_fail (n, p);
         dp += p;
         dn += n;
         dxf += xf;
         dsk += sk;
         files_with_tests(end+1) = f;
diff --git a/test/test_index-wfi-f.m b/test/test_index-wfi-f.m
--- a/test/test_index-wfi-f.m
+++ b/test/test_index-wfi-f.m
@@ -13,375 +13,258 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/index-wfi-f/s-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [];
 %! assert(isempty (a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,:),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-5.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1,:),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-6.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,1),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-7.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(isempty (a(logical (0))));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-8.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1)");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-9.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-10.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2,:);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-11.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,2);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-12.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1,:);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-13.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,-1);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-14.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2,3]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-15.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1;2;3]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-16.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2;3,4]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-17.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0,1]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-18.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0;1]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-19.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1,0]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/s-20.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1;0]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(1),4);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(2),3);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:) == a_prime));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(1,:) == a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-5.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(:,3),2);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-6.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:,:) == a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-7.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(logical ([0,1,1,0])) == mid_a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-8.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-9.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(5);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-10.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0,1);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-11.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(logical (0),:)));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-12.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(:,0);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-13.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([])));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-14.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([],:)));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/v-15.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(:,[])));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (all (a(:,:) == a)));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (a(:) == a_fvec));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! fail("a(0);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-f/m-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(a(2),3);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% Additional tests
 %!shared a, b
 %! a = [1,2;3,4];
 %! b = a;
 %! b(:,:,2) = [5,6;7,8];
 
 %!assert (a(:), [1;3;2;4]);
diff --git a/test/test_index-wfi-t.m b/test/test_index-wfi-t.m
--- a/test/test_index-wfi-t.m
+++ b/test/test_index-wfi-t.m
@@ -13,367 +13,250 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/index-wfi-t/s-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [];
 %! assert(isempty (a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,:),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-5.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(1,:),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-6.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(a(:,1),1);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-7.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! assert(isempty (a(logical (0))));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-8.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-9.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-10.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(2,:);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-11.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,2);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-12.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(-1,:);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-13.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a(:,-1);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-14.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2,3]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-15.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1;2;3]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-16.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([1,2;3,4]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-17.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0,1]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-18.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([0;1]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-19.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1,0]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/s-20.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 1;
 %! fail("a([-1;0]);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(1),4);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(2),3);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:) == a_prime));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(1,:) == a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-5.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(a(:,3),2);
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-6.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(:,:) == a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-7.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(all (a(logical ([0,1,1,0])) == mid_a));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-8.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-9.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(5);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-10.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(0,1);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-11.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(logical (0),:)));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-12.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! fail("a(:,0);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-13.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([])));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-14.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a([],:)));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/v-15.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
 %! assert(isempty (a(:,[])));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (all (a(:,:) == a)));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! assert(all (a(:) == a_fvec));
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! fail("a(0);");
-%! warning (wfi.state, "Octave:fortran-indexing");
 
 %% test/octave.test/index-wfi-t/m-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
 %! fail("a(2);","warning");
-%! warning (wfi.state, "Octave:fortran-indexing");
diff --git a/test/test_logical-wfi-f.m b/test/test_logical-wfi-f.m
--- a/test/test_logical-wfi-f.m
+++ b/test/test_logical-wfi-f.m
@@ -13,359 +13,227 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/logical-wfi-f/s-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [];
 %! fail("a(0);");
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/s-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/s-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/s-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %!shared a
 %!  a = 2;
 %!error id=Octave:index-out-of-bounds a(logical ([1,1]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/v-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1])) == [9,8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9,7,8,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [7,8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical (0:1)) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-5.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-6.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical ([0,1])) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-7.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-8.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),:) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-9.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),1) == 7);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-10.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-11.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-12.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-13.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-14.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical (0:1)) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-15.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-16.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-17.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-18.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),:) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-19.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),1) == 7);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-20.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-21.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical (0:1)) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-22.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-23.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-24.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical (0:1)) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-25.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical ([0,1])) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-26.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-27.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical (0:1)) == 8);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-28.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical ([0,1])) == 8);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-29.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(1,logical ([1,1])) == [9,8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-30.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-31.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-32.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-33.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-34.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-35.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),1) == [9;7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-f/m-36.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("off", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
diff --git a/test/test_logical-wfi-t.m b/test/test_logical-wfi-t.m
--- a/test/test_logical-wfi-t.m
+++ b/test/test_logical-wfi-t.m
@@ -13,359 +13,227 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/logical-wfi-t/s-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [];
 %! fail("a(0);");
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/s-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/s-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = 2;
 %! assert(a(1) == 2);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/s-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %!shared a
 %! a = 2;
 %!error id=Octave:index-out-of-bounds a(logical ([1,1]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(isempty (a(logical ([0,0,0,0]))));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/v-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8,7,6];
 %! assert(all (a(logical ([1,1])) == [9,8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-1.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! isempty (a(logical ([0,0,0,0])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-2.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! all (a(logical ([1,1,1,1])) == [9,7,8,6]);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-3.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! all (a(logical ([0,1,1,0])) == [7,8]);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-4.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical (0:1)) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-5.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-6.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),logical ([0,1])) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-7.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-8.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),:) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-9.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical (0:1),1) == 7);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-10.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-11.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-12.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-13.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-14.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical (0:1)) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-15.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-16.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-17.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-18.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),:) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-19.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(logical ([0,1]),1) == 7);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-20.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-21.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical (0:1)) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-22.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-23.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-24.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical (0:1)) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-25.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(:,logical ([0,1])) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-26.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-27.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical (0:1)) == 8);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-28.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(a(1,logical ([0,1])) == 8);
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-29.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(1,logical ([1,1])) == [9,8]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-30.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-31.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-32.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-33.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-34.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-35.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (a(logical ([1,1]),1) == [9;7]));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
 %% test/octave.test/logical-wfi-t/m-36.m
 %!test
-%! wfi = warning ("query", "Octave:fortran-indexing");
-%! warning ("on", "Octave:fortran-indexing");
 %! a = [9,8;7,6];
 %! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-%! warning ("wfi.state", "Octave:fortran-indexing");
 
