# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453585923 28800
#      Sat Jan 23 13:52:03 2016 -0800
# Node ID 7cac4e7458f24d52969b231c179d5558480aa62d
# Parent  95da3bc8a281962c480640391cbc8581066f7cd9
maint: clean up code around calls to current_liboctave_error_handler.
Remove statements after call to handler that are no longer reachable.
Place input validation first and immediately call handler if necessary.
Change if/error_handler/else to if/error_handler and re-indent code.

* Array-util.cc, Array.cc, CColVector.cc, CDiagMatrix.cc, CMatrix.cc,
CNDArray.cc, CRowVector.cc, CSparse.cc, DiagArray2.cc, MArray.cc,
PermMatrix.cc, Sparse.cc, Sparse.h, chMatrix.cc, chNDArray.cc, dColVector.cc,
dDiagMatrix.cc, dMatrix.cc, dNDArray.cc, dRowVector.cc, dSparse.cc,
fCColVector.cc, fCDiagMatrix.cc, fCMatrix.cc, fCNDArray.cc, fCRowVector.cc,
fColVector.cc, fDiagMatrix.cc, fMatrix.cc, fNDArray.cc, fRowVector.cc,
idx-vector.cc, CmplxAEPBAL.cc, CmplxCHOL.cc, CmplxGEPBAL.cc, CmplxHESS.cc,
CmplxLU.cc, CmplxQR.cc, CmplxSCHUR.cc, CmplxSVD.cc, DASPK.cc, EIG.cc, LSODE.cc,
Quad.cc, SparseCmplxCHOL.cc, SparseCmplxLU.cc, SparseCmplxQR.cc, SparseQR.cc,
SparsedbleCHOL.cc, SparsedbleLU.cc, base-lu.cc, bsxfun-defs.cc, dbleAEPBAL.cc,
dbleCHOL.cc, dbleGEPBAL.cc, dbleHESS.cc, dbleLU.cc, dbleQR.cc, dbleSCHUR.cc,
dbleSVD.cc, eigs-base.cc, fCmplxAEPBAL.cc, fCmplxCHOL.cc, fCmplxLU.cc,
fCmplxQR.cc, fCmplxSCHUR.cc, fEIG.cc, floatAEPBAL.cc, floatCHOL.cc,
floatGEPBAL.cc, floatHESS.cc, floatLU.cc, floatQR.cc, floatSCHUR.cc,
floatSVD.cc, lo-specfun.cc, oct-fftw.cc, oct-rand.cc, oct-spparms.cc,
sparse-base-chol.cc, sparse-dmsolve.cc, file-ops.cc, lo-sysdep.cc,
mach-info.cc, oct-env.cc, oct-syscalls.cc, cmd-edit.cc, cmd-hist.cc,
data-conv.cc, lo-ieee.cc, lo-regexp.cc, oct-base64.cc, oct-shlib.cc,
pathsearch.cc, singleton-cleanup.cc, sparse-util.cc, unwind-prot.cc:
Remove statements after call to handler that are no longer reachable.
Place input validation first and immediately call handler if necessary.
Change if/error_handler/else to if/error_handler and re-indent code.

diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -533,142 +533,138 @@ struct sub2ind_helper
 };
 
 idx_vector
 sub2ind (const dim_vector& dv, const Array<idx_vector>& idxa)
 {
   idx_vector retval;
   octave_idx_type len = idxa.numel ();
 
-  if (len >= 1)
-    {
-      const dim_vector dvx = dv.redim (len);
-      bool all_ranges = true;
-      octave_idx_type clen = -1;
+  if (len == 0)
+    (*current_liboctave_error_handler) ("sub2ind: needs at least 2 indices");
+
+  const dim_vector dvx = dv.redim (len);
+  bool all_ranges = true;
+  octave_idx_type clen = -1;
 
-      for (octave_idx_type i = 0; i < len; i++)
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      try
         {
-          try
-            {
-              idx_vector idx = idxa(i);
-              octave_idx_type n = dvx(i);
+          idx_vector idx = idxa(i);
+          octave_idx_type n = dvx(i);
 
-              all_ranges = all_ranges && idx.is_range ();
-              if (clen < 0)
-                clen = idx.length (n);
-              else if (clen != idx.length (n))
-                (*current_liboctave_error_handler)
-                  ("sub2ind: lengths of indices must match");
+          all_ranges = all_ranges && idx.is_range ();
+          if (clen < 0)
+            clen = idx.length (n);
+          else if (clen != idx.length (n))
+            (*current_liboctave_error_handler)
+              ("sub2ind: lengths of indices must match");
 
-              if (idx.extent (n) > n)
-                  err_index_out_of_range (len, i+1, idx.extent (n), n);
-            }
-          catch (index_exception& e)
-            {
-              e.set_pos_if_unset (len, i+1);
-              e.set_var ();
-              std::string msg = e.message ();
-              (*current_liboctave_error_with_id_handler)
-                (e.err_id (), msg.c_str ());
-            }
+          if (idx.extent (n) > n)
+              err_index_out_of_range (len, i+1, idx.extent (n), n);
         }
-      // idxa known to be valid. Shouldn't need to catch index_exception below here.
+      catch (index_exception& e)
+        {
+          e.set_pos_if_unset (len, i+1);
+          e.set_var ();
+          std::string msg = e.message ();
+          (*current_liboctave_error_with_id_handler)
+            (e.err_id (), msg.c_str ());
+        }
+    }
+  // idxa known to be valid. Shouldn't need to catch index_exception below here.
 
 
-      if (len == 1)
-        retval = idxa(0);
-      else if (clen == 1)
-        {
-          // All scalars case - the result is a scalar.
-          octave_idx_type idx = idxa(len-1)(0);
-          for (octave_idx_type i = len - 2; i >= 0; i--)
-            idx = dvx(i) * idx + idxa(i)(0);
-          retval = idx_vector (idx);
-        }
-      else if (all_ranges && clen != 0)
+  if (len == 1)
+    retval = idxa(0);
+  else if (clen == 1)
+    {
+      // All scalars case - the result is a scalar.
+      octave_idx_type idx = idxa(len-1)(0);
+      for (octave_idx_type i = len - 2; i >= 0; i--)
+        idx = dvx(i) * idx + idxa(i)(0);
+      retval = idx_vector (idx);
+    }
+  else if (all_ranges && clen != 0)
+    {
+      // All ranges case - the result is a range.
+      octave_idx_type start = 0;
+      octave_idx_type step = 0;
+      for (octave_idx_type i = len - 1; i >= 0; i--)
         {
-          // All ranges case - the result is a range.
-          octave_idx_type start = 0;
-          octave_idx_type step = 0;
-          for (octave_idx_type i = len - 1; i >= 0; i--)
-            {
-              octave_idx_type xstart = idxa(i)(0);
-              octave_idx_type xstep = idxa(i)(1) - xstart;
-              start = dvx(i) * start + xstart;
-              step = dvx(i) * step + xstep;
-            }
-          retval = idx_vector::make_range (start, step, clen);
+          octave_idx_type xstart = idxa(i)(0);
+          octave_idx_type xstep = idxa(i)(1) - xstart;
+          start = dvx(i) * start + xstart;
+          step = dvx(i) * step + xstep;
         }
-      else
-        {
-          Array<octave_idx_type> idx (idxa(0).orig_dimensions ());
-          octave_idx_type *idx_vec = idx.fortran_vec ();
-
-          for (octave_idx_type i = len - 1; i >= 0; i--)
-            {
-              if (i < len - 1)
-                idxa(i).loop (clen, sub2ind_helper (idx_vec, dvx(i)));
-              else
-                idxa(i).copy_data (idx_vec);
-            }
-
-          retval = idx_vector (idx);
-        }
+      retval = idx_vector::make_range (start, step, clen);
     }
   else
-    (*current_liboctave_error_handler) ("sub2ind: needs at least 2 indices");
+    {
+      Array<octave_idx_type> idx (idxa(0).orig_dimensions ());
+      octave_idx_type *idx_vec = idx.fortran_vec ();
+
+      for (octave_idx_type i = len - 1; i >= 0; i--)
+        {
+          if (i < len - 1)
+            idxa(i).loop (clen, sub2ind_helper (idx_vec, dvx(i)));
+          else
+            idxa(i).copy_data (idx_vec);
+        }
+
+      retval = idx_vector (idx);
+    }
 
   return retval;
 }
 
 Array<idx_vector>
 ind2sub (const dim_vector& dv, const idx_vector& idx)
 {
   octave_idx_type len = idx.length (0);
   octave_idx_type n = dv.length ();
   Array<idx_vector> retval (dim_vector (n, 1));
   octave_idx_type numel = dv.numel ();
 
   if (idx.extent (numel) > numel)
     (*current_liboctave_error_handler) ("ind2sub: index out of range");
+
+  if (idx.is_scalar ())
+    {
+      octave_idx_type k = idx(0);
+      for (octave_idx_type j = 0; j < n; j++)
+        {
+          retval(j) = k % dv(j);
+          k /= dv(j);
+        }
+    }
   else
     {
-      if (idx.is_scalar ())
+      OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, rdata, n);
+
+      dim_vector odv = idx.orig_dimensions ();
+      for (octave_idx_type j = 0; j < n; j++)
+        rdata[j] = Array<octave_idx_type> (odv);
+
+      for (octave_idx_type i = 0; i < len; i++)
         {
-          octave_idx_type k = idx(0);
+          octave_idx_type k = idx(i);
           for (octave_idx_type j = 0; j < n; j++)
             {
-              retval(j) = k % dv(j);
+              rdata[j](i) = k % dv(j);
               k /= dv(j);
             }
         }
-      else
-        {
-          OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, rdata, n);
 
-          dim_vector odv = idx.orig_dimensions ();
-          for (octave_idx_type j = 0; j < n; j++)
-            rdata[j] = Array<octave_idx_type> (odv);
-
-          for (octave_idx_type i = 0; i < len; i++)
-            {
-              octave_idx_type k = idx(i);
-              for (octave_idx_type j = 0; j < n; j++)
-                {
-                  rdata[j](i) = k % dv(j);
-                  k /= dv(j);
-                }
-            }
-
-          for (octave_idx_type j = 0; j < n; j++)
-            retval(j) = rdata[j];
-        }
+      for (octave_idx_type j = 0; j < n; j++)
+        retval(j) = rdata[j];
+    }
 
 
-    }
 
   return retval;
 }
 
 int
 permute_vector_compare (const void *a, const void *b)
 {
   const permute_vector *pva = static_cast<const permute_vector *> (a);
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -462,32 +462,24 @@ Array<T>::permute (const Array<octave_id
 
   bool identity = true;
 
   // Find dimension vector of permuted array.
   for (int i = 0; i < perm_vec_len; i++)
     {
       octave_idx_type perm_elt = perm_vec.elem (i);
       if (perm_elt >= perm_vec_len || perm_elt < 0)
-        {
-          (*current_liboctave_error_handler)
-            ("%s: permutation vector contains an invalid element",
-             inv ? "ipermute" : "permute");
-
-          return retval;
-        }
+        (*current_liboctave_error_handler)
+          ("%s: permutation vector contains an invalid element",
+           inv ? "ipermute" : "permute");
 
       if (checked[perm_elt])
-        {
-          (*current_liboctave_error_handler)
-            ("%s: permutation vector cannot contain identical elements",
-             inv ? "ipermute" : "permute");
-
-          return retval;
-        }
+        (*current_liboctave_error_handler)
+          ("%s: permutation vector cannot contain identical elements",
+           inv ? "ipermute" : "permute");
       else
         {
           checked[perm_elt] = true;
           identity = identity && perm_elt == i;
         }
     }
 
   if (identity)
@@ -1441,21 +1433,17 @@ Array<T>::delete_elements (const idx_vec
     }
 }
 
 template <class T>
 void
 Array<T>::delete_elements (int dim, const idx_vector& i)
 {
   if (dim < 0 || dim >= ndims ())
-    {
-      (*current_liboctave_error_handler)
-        ("invalid dimension in delete_elements");
-      return;
-    }
+    (*current_liboctave_error_handler) ("invalid dimension in delete_elements");
 
   octave_idx_type n = dimensions(dim);
   if (i.is_colon ())
     {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
@@ -1774,21 +1762,17 @@ sort_isnan (typename ref_param<T>::type)
   return false;
 }
 
 template <class T>
 Array<T>
 Array<T>::sort (int dim, sortmode mode) const
 {
   if (dim < 0)
-    {
-      (*current_liboctave_error_handler)
-        ("sort: invalid dimension");
-      return Array<T> ();
-    }
+    (*current_liboctave_error_handler) ("sort: invalid dimension");
 
   Array<T> m (dims ());
 
   dim_vector dv = m.dims ();
 
   if (m.numel () < 1)
     return m;
 
@@ -1895,21 +1879,17 @@ Array<T>::sort (int dim, sortmode mode) 
 }
 
 template <class T>
 Array<T>
 Array<T>::sort (Array<octave_idx_type> &sidx, int dim,
                 sortmode mode) const
 {
   if (dim < 0 || dim >= ndims ())
-    {
-      (*current_liboctave_error_handler)
-        ("sort: invalid dimension");
-      return Array<T> ();
-    }
+    (*current_liboctave_error_handler) ("sort: invalid dimension");
 
   Array<T> m (dims ());
 
   dim_vector dv = m.dims ();
 
   if (m.numel () < 1)
     {
       sidx = Array<octave_idx_type> (dv);
@@ -2335,21 +2315,17 @@ Array<T>::find (octave_idx_type n, bool 
   return retval;
 }
 
 template <class T>
 Array<T>
 Array<T>::nth_element (const idx_vector& n, int dim) const
 {
   if (dim < 0)
-    {
-      (*current_liboctave_error_handler)
-        ("nth_element: invalid dimension");
-      return Array<T> ();
-    }
+    (*current_liboctave_error_handler) ("nth_element: invalid dimension");
 
   dim_vector dv = dims ();
   if (dim >= dv.length ())
     dv.resize (dim+1, 1);
 
   octave_idx_type ns = dv(dim);
 
   octave_idx_type nn = n.length (ns);
@@ -2386,30 +2362,23 @@ Array<T>::nth_element (const idx_vector&
             lo = ns - 1 - n(0);
           }
       }
     default:
       break;
     }
 
   if (mode == UNSORTED)
-    {
-      (*current_liboctave_error_handler)
-        ("nth_element: n must be a scalar or a contiguous range");
-      return Array<T> ();
-    }
+    (*current_liboctave_error_handler)
+      ("nth_element: n must be a scalar or a contiguous range");
 
   octave_idx_type up = lo + nn;
 
   if (lo < 0 || up > ns)
-    {
-      (*current_liboctave_error_handler)
-        ("nth_element: invalid element index");
-      return Array<T> ();
-    }
+    (*current_liboctave_error_handler) ("nth_element: invalid element index");
 
   octave_idx_type iter = numel () / ns;
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   T *v = m.fortran_vec ();
@@ -2539,110 +2508,103 @@ Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
   octave_idx_type nd = dv.length ();
   Array<T> d;
 
   if (nd > 2)
     (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");
+
+  octave_idx_type nnr = dv(0);
+  octave_idx_type nnc = dv(1);
+
+  if (nnr == 0 && nnc == 0)
+    ; // do nothing for empty matrix
+  else if (nnr != 1 && nnc != 1)
+    {
+      // Extract diag from matrix
+      if (k > 0)
+        nnc -= k;
+      else if (k < 0)
+        nnr += k;
+
+      if (nnr > 0 && nnc > 0)
+        {
+          octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+          d.resize (dim_vector (ndiag, 1));
+
+          if (k > 0)
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                d.xelem (i) = elem (i, i+k);
+            }
+          else if (k < 0)
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                d.xelem (i) = elem (i-k, i);
+            }
+          else
+            {
+              for (octave_idx_type i = 0; i < ndiag; i++)
+                d.xelem (i) = elem (i, i);
+            }
+        }
+      else  // Matlab returns [] 0x1 for out-of-range diagonal
+        d.resize (dim_vector (0, 1));
+    }
   else
     {
-      octave_idx_type nnr = dv(0);
-      octave_idx_type nnc = dv(1);
-
-      if (nnr == 0 && nnc == 0)
-        ; // do nothing for empty matrix
-      else if (nnr != 1 && nnc != 1)
+      // Create diag matrix from vector
+      octave_idx_type roff = 0;
+      octave_idx_type coff = 0;
+      if (k > 0)
+        {
+          roff = 0;
+          coff = k;
+        }
+      else if (k < 0)
         {
-          // Extract diag from matrix
-          if (k > 0)
-            nnc -= k;
-          else if (k < 0)
-            nnr += k;
-
-          if (nnr > 0 && nnc > 0)
-            {
-              octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-              d.resize (dim_vector (ndiag, 1));
-
-              if (k > 0)
-                {
-                  for (octave_idx_type i = 0; i < ndiag; i++)
-                    d.xelem (i) = elem (i, i+k);
-                }
-              else if (k < 0)
-                {
-                  for (octave_idx_type i = 0; i < ndiag; i++)
-                    d.xelem (i) = elem (i-k, i);
-                }
-              else
-                {
-                  for (octave_idx_type i = 0; i < ndiag; i++)
-                    d.xelem (i) = elem (i, i);
-                }
-            }
-          else  // Matlab returns [] 0x1 for out-of-range diagonal
-            d.resize (dim_vector (0, 1));
+          roff = -k;
+          coff = 0;
+        }
+
+      if (nnr == 1)
+        {
+          octave_idx_type n = nnc + std::abs (k);
+          d = Array<T> (dim_vector (n, n), resize_fill_value ());
+
+          for (octave_idx_type i = 0; i < nnc; i++)
+            d.xelem (i+roff, i+coff) = elem (0, i);
         }
       else
         {
-          // Create diag matrix from vector
-          octave_idx_type roff = 0;
-          octave_idx_type coff = 0;
-          if (k > 0)
-            {
-              roff = 0;
-              coff = k;
-            }
-          else if (k < 0)
-            {
-              roff = -k;
-              coff = 0;
-            }
-
-          if (nnr == 1)
-            {
-              octave_idx_type n = nnc + std::abs (k);
-              d = Array<T> (dim_vector (n, n), resize_fill_value ());
-
-              for (octave_idx_type i = 0; i < nnc; i++)
-                d.xelem (i+roff, i+coff) = elem (0, i);
-            }
-          else
-            {
-              octave_idx_type n = nnr + std::abs (k);
-              d = Array<T> (dim_vector (n, n), resize_fill_value ());
-
-              for (octave_idx_type i = 0; i < nnr; i++)
-                d.xelem (i+roff, i+coff) = elem (i, 0);
-            }
+          octave_idx_type n = nnr + std::abs (k);
+          d = Array<T> (dim_vector (n, n), resize_fill_value ());
+
+          for (octave_idx_type i = 0; i < nnr; i++)
+            d.xelem (i+roff, i+coff) = elem (i, 0);
         }
     }
 
   return d;
 }
 
 template <class T>
 Array<T>
 Array<T>::diag (octave_idx_type m, octave_idx_type n) const
 {
-  Array<T> retval;
-
-  if (ndims () == 2 && (rows () == 1 || cols () == 1))
-    {
-      retval.resize (dim_vector (m, n), resize_fill_value ());
-
-      for (octave_idx_type i = 0; i < numel (); i++)
-        retval.xelem (i, i) = xelem (i);
-    }
-  else
-    (*current_liboctave_error_handler)
-      ("cat: invalid dimension");
+  if (ndims () != 2 || (rows () != 1 && cols () != 1))
+    (*current_liboctave_error_handler) ("cat: invalid dimension");
+
+  Array<T> retval (dim_vector (m, n), resize_fill_value ());
+
+  for (octave_idx_type i = 0; i < numel (); i++)
+    retval.xelem (i, i) = xelem (i);
 
   return retval;
 }
 
 template <class T>
 Array<T>
 Array<T>::cat (int dim, octave_idx_type n, const Array<T> *array_list)
 {
@@ -2650,18 +2612,17 @@ Array<T>::cat (int dim, octave_idx_type 
   bool (dim_vector::*concat_rule) (const dim_vector&, int) = &dim_vector::concat;
 
   if (dim == -1 || dim == -2)
     {
       concat_rule = &dim_vector::hvcat;
       dim = -dim - 1;
     }
   else if (dim < 0)
-    (*current_liboctave_error_handler)
-      ("cat: invalid dimension");
+    (*current_liboctave_error_handler) ("cat: invalid dimension");
 
   if (n == 1)
     return array_list[0];
   else if (n == 0)
     return Array<T> ();
 
   // Special case:
   //
@@ -2702,18 +2663,17 @@ Array<T>::cat (int dim, octave_idx_type 
       if (istart >= n)
         istart = 0;
     }
 
   dim_vector dv = array_list[istart++].dims ();
 
   for (octave_idx_type i = istart; i < n; i++)
     if (! (dv.*concat_rule) (array_list[i].dims (), dim))
-      (*current_liboctave_error_handler)
-        ("cat: dimension mismatch");
+      (*current_liboctave_error_handler) ("cat: dimension mismatch");
 
   Array<T> retval (dv);
 
   if (retval.is_empty ())
     return retval;
 
   int nidx = std::max (dv.length (), dim + 1);
   Array<idx_vector> idxa (dim_vector (nidx, 1), idx_vector::colon);
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -75,20 +75,17 @@ ComplexColumnVector::operator != (const 
 // destructive insert/delete/reorder operations
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ColumnVector& a, octave_idx_type r)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i) = a.elem (i);
     }
@@ -97,20 +94,17 @@ ComplexColumnVector::insert (const Colum
 }
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ComplexColumnVector& a, octave_idx_type r)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i) = a.elem (i);
     }
@@ -152,20 +146,17 @@ ComplexColumnVector::fill (const Complex
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
@@ -177,20 +168,17 @@ ComplexColumnVector::fill (double val, o
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val,
                            octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -74,164 +74,134 @@ ComplexDiagMatrix::fill (const Complex& 
     elem (i, i) = val;
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (double val, octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const Complex& val,
                          octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix
@@ -270,105 +240,84 @@ ComplexDiagMatrix::extract (octave_idx_t
 // extract row or column i.
 
 ComplexRowVector
 ComplexDiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return ComplexRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   ComplexRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexRowVector
 ComplexDiagMatrix::row (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return ComplexRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return ComplexRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return ComplexColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   ComplexColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return ComplexColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return ComplexColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (octave_idx_type& info) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (r != c)
-    {
-      (*current_liboctave_error_handler) ("inverse requires square matrix");
-      return ComplexDiagMatrix ();
-    }
+    (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   ComplexDiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < length (); i++)
     {
       if (elem (i, i) == 0.0)
         {
@@ -519,26 +468,21 @@ operator * (const ComplexDiagMatrix& a, 
 
 // other operations
 
 ComplexDET
 ComplexDiagMatrix::determinant (void) const
 {
   ComplexDET det (1.0);
   if (rows () != cols ())
-    {
-      (*current_liboctave_error_handler) ("determinant requires square matrix");
-      det = ComplexDET (0.0);
-    }
-  else
-    {
-      octave_idx_type len = length ();
-      for (octave_idx_type i = 0; i < len; i++)
-        det *= elem (i, i);
-    }
+    (*current_liboctave_error_handler) ("determinant requires square matrix");
+
+  octave_idx_type len = length ();
+  for (octave_idx_type i = 0; i < len; i++)
+    det *= elem (i, i);
 
   return det;
 }
 
 double
 ComplexDiagMatrix::rcond (void) const
 {
   ColumnVector av = extract_diag (0).map<double> (std::abs);
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -398,20 +398,17 @@ ComplexMatrix::is_hermitian (void) const
 
 ComplexMatrix&
 ComplexMatrix::insert (const Matrix& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_nr >0 && a_nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < a_nc; j++)
         for (octave_idx_type i = 0; i < a_nr; i++)
           xelem (r+i, c+j) = a.elem (i, j);
@@ -421,20 +418,17 @@ ComplexMatrix::insert (const Matrix& a, 
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r, c+i) = a.elem (i);
     }
@@ -444,20 +438,17 @@ ComplexMatrix::insert (const RowVector& 
 
 ComplexMatrix&
 ComplexMatrix::insert (const ColumnVector& a,
                        octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
@@ -468,20 +459,17 @@ ComplexMatrix::insert (const ColumnVecto
 ComplexMatrix&
 ComplexMatrix::insert (const DiagMatrix& a,
                        octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
@@ -502,38 +490,32 @@ ComplexMatrix::insert (const ComplexMatr
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexRowVector& a,
                        octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexColumnVector& a,
                        octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
@@ -544,20 +526,17 @@ ComplexMatrix::insert (const ComplexColu
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexDiagMatrix& a,
                        octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
@@ -609,20 +588,17 @@ ComplexMatrix&
 ComplexMatrix::fill (double val, octave_idx_type r1, octave_idx_type c1,
                      octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
@@ -638,20 +614,17 @@ ComplexMatrix&
 ComplexMatrix::fill (const Complex& val, octave_idx_type r1, octave_idx_type c1,
                      octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (r2 >= r1 && c2 >=c1)
     {
       make_unique ();
 
@@ -664,298 +637,242 @@ ComplexMatrix::fill (const Complex& val,
 }
 
 ComplexMatrix
 ComplexMatrix::append (const Matrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != 1)
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.numel ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const DiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != 1)
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.numel ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const Matrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.numel ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const DiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.numel ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   ComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
@@ -1044,144 +961,140 @@ ComplexMatrix::tinverse (MatrixType &mat
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
-  else
+
+  int typ = mattype.type ();
+  char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
+  char udiag = 'N';
+  retval = *this;
+  Complex *tmp_data = retval.fortran_vec ();
+
+  F77_XFCN (ztrtri, ZTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                             F77_CONST_CHAR_ARG2 (&udiag, 1),
+                             nr, tmp_data, nr, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
     {
-      int typ = mattype.type ();
-      char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
-      char udiag = 'N';
-      retval = *this;
-      Complex *tmp_data = retval.fortran_vec ();
-
-      F77_XFCN (ztrtri, ZTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+      octave_idx_type ztrcon_info = 0;
+      char job = '1';
+
+      OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
+      OCTAVE_LOCAL_BUFFER (double, rwork, nr);
+
+      F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info
+                                 nr, tmp_data, nr, rcon,
+                                 cwork, rwork, ztrcon_info
+                                 F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+      if (ztrcon_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          octave_idx_type ztrcon_info = 0;
-          char job = '1';
-
-          OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
-          OCTAVE_LOCAL_BUFFER (double, rwork, nr);
-
-          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     cwork, rwork, ztrcon_info
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (ztrcon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this; // Restore matrix contents.
     }
 
+  if (info == -1 && ! force)
+    retval = *this; // Restore matrix contents.
+
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
                          double& rcon, int force, int calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
+
+  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+  octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+  retval = *this;
+  Complex *tmp_data = retval.fortran_vec ();
+
+  Array<Complex> z (dim_vector (1, 1));
+  octave_idx_type lwork = -1;
+
+  // Query the optimum work array size.
+
+  F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
+                             z.fortran_vec (), lwork, info));
+
+  lwork = static_cast<octave_idx_type> (std::real (z(0)));
+  lwork = (lwork <  2 *nc ? 2*nc : lwork);
+  z.resize (dim_vector (lwork, 1));
+  Complex *pz = z.fortran_vec ();
+
+  info = 0;
+
+  // Calculate the norm of the matrix, for later use.
+  double anorm;
+  //if (calc_cond)   // Must always calculate anorm for bug #45577
+  anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+
+  // Work around bug #45577, LAPACK crashes Octave if norm is NaN
+  if (xisnan (anorm))
+    info = -1;
+  else
+    F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
+    {
+      // Now calculate the condition number for non-singular matrix.
+      octave_idx_type zgecon_info = 0;
+      char job = '1';
+      Array<double> rz (dim_vector (2 * nc, 1));
+      double *prz = rz.fortran_vec ();
+      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nc, tmp_data, nr, anorm,
+                                 rcon, pz, prz, zgecon_info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (zgecon_info != 0)
+        info = -1;
+    }
+
+  if (info == -1 && ! force)
+    retval = *this;  // Restore contents.
   else
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      retval = *this;
-      Complex *tmp_data = retval.fortran_vec ();
-
-      Array<Complex> z (dim_vector (1, 1));
-      octave_idx_type lwork = -1;
-
-      // Query the optimum work array size.
+      octave_idx_type zgetri_info = 0;
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
-                                 z.fortran_vec (), lwork, info));
-
-      lwork = static_cast<octave_idx_type> (std::real (z(0)));
-      lwork = (lwork <  2 *nc ? 2*nc : lwork);
-      z.resize (dim_vector (lwork, 1));
-      Complex *pz = z.fortran_vec ();
-
-      info = 0;
-
-      // Calculate the norm of the matrix, for later use.
-      double anorm;
-      //if (calc_cond)   // Must always calculate anorm for bug #45577
-      anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
-
-      // Work around bug #45577, LAPACK crashes Octave if norm is NaN
-      if (xisnan (anorm))
-        info = -1;
-      else
-        F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
-
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+                                 pz, lwork, zgetri_info));
+
+      if (zgetri_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          // Now calculate the condition number for non-singular matrix.
-          octave_idx_type zgecon_info = 0;
-          char job = '1';
-          Array<double> rz (dim_vector (2 * nc, 1));
-          double *prz = rz.fortran_vec ();
-          F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm,
-                                     rcon, pz, prz, zgecon_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (zgecon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this;  // Restore contents.
-      else
-        {
-          octave_idx_type zgetri_info = 0;
-
-          F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
-                                     pz, lwork, zgetri_info));
-
-          if (zgetri_info != 0)
-            info = -1;
-        }
-
-      if (info != 0)
-        mattype.mark_as_rectangular ();
     }
 
+  if (info != 0)
+    mattype.mark_as_rectangular ();
+
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                         double& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1622,135 +1535,133 @@ ComplexMatrix::determinant (MatrixType& 
   info = 0;
   rcon = 0.0;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else
+
+  volatile int typ = mattype.type ();
+
+  // Even though the matrix is marked as singular (Rectangular), we may
+  // still get a useful number from the LU factorization, because it always
+  // completes.
+
+  if (typ == MatrixType::Unknown)
+    typ = mattype.type (*this);
+  else if (typ == MatrixType::Rectangular)
+    typ = MatrixType::Full;
+
+  if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      volatile int typ = mattype.type ();
-
-      // Even though the matrix is marked as singular (Rectangular), we may
-      // still get a useful number from the LU factorization, because it always
-      // completes.
-
-      if (typ == MatrixType::Unknown)
-        typ = mattype.type (*this);
-      else if (typ == MatrixType::Rectangular)
-        typ = MatrixType::Full;
-
-      if (typ == MatrixType::Lower || typ == MatrixType::Upper)
+      for (octave_idx_type i = 0; i < nc; i++)
+        retval *= elem (i,i);
+    }
+  else if (typ == MatrixType::Hermitian)
+    {
+      ComplexMatrix atmp = *this;
+      Complex *tmp_data = atmp.fortran_vec ();
+
+      double anorm = 0;
+      if (calc_cond) anorm = xnorm (*this, 1);
+
+
+      char job = 'L';
+      F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
+                                 tmp_data, nr, info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (info != 0)
         {
-          for (octave_idx_type i = 0; i < nc; i++)
-            retval *= elem (i,i);
+          rcon = 0.0;
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
         }
-      else if (typ == MatrixType::Hermitian)
+      else
         {
-          ComplexMatrix atmp = *this;
-          Complex *tmp_data = atmp.fortran_vec ();
-
-          double anorm = 0;
-          if (calc_cond) anorm = xnorm (*this, 1);
-
-
-          char job = 'L';
-          F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+          Array<Complex> z (dim_vector (2 * nc, 1));
+          Complex *pz = z.fortran_vec ();
+          Array<double> rz (dim_vector (nc, 1));
+          double *prz = rz.fortran_vec ();
+
+          F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, tmp_data, nr, anorm,
+                                     rcon, pz, prz, info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
+            rcon = 0.0;
+
+          for (octave_idx_type i = 0; i < nc; i++)
+            retval *= atmp (i,i);
+
+          retval = retval.square ();
+        }
+    }
+  else if (typ != MatrixType::Full)
+    (*current_liboctave_error_handler) ("det: invalid dense matrix type");
+
+  if (typ == MatrixType::Full)
+    {
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+      ComplexMatrix atmp = *this;
+      Complex *tmp_data = atmp.fortran_vec ();
+
+      info = 0;
+
+      // Calculate the norm of the matrix, for later use.
+      double anorm = 0;
+      //if (calc_cond)   // Must always calculate anorm for bug #45577
+      anorm = xnorm (*this, 1);
+
+      // Work around bug #45577, LAPACK crashes Octave if norm is NaN
+      if (xisnan (anorm))
+        info = -1;
+      else
+        F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcon = 0.0;
+      if (info != 0)
+        {
+          info = -1;
+          retval = ComplexDET ();
+        }
+      else
+        {
+          if (calc_cond)
             {
-              rcon = 0.0;
-              mattype.mark_as_unsymmetric ();
-              typ = MatrixType::Full;
-            }
-          else
-            {
+              // Now calc the condition number for non-singular matrix.
+              char job = '1';
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
-              Array<double> rz (dim_vector (nc, 1));
+              Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
-              F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                         nr, tmp_data, nr, anorm,
+              F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nc, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
-
-              if (info != 0)
-                rcon = 0.0;
-
-              for (octave_idx_type i = 0; i < nc; i++)
-                retval *= atmp (i,i);
-
-              retval = retval.square ();
             }
-        }
-      else if (typ != MatrixType::Full)
-        (*current_liboctave_error_handler) ("det: invalid dense matrix type");
-
-      if (typ == MatrixType::Full)
-        {
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          ComplexMatrix atmp = *this;
-          Complex *tmp_data = atmp.fortran_vec ();
-
-          info = 0;
-
-          // Calculate the norm of the matrix, for later use.
-          double anorm = 0;
-          //if (calc_cond)   // Must always calculate anorm for bug #45577
-          anorm = xnorm (*this, 1);
-
-          // Work around bug #45577, LAPACK crashes Octave if norm is NaN
-          if (xisnan (anorm))
-            info = -1;
-          else
-            F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-          // Throw-away extra info LAPACK gives so as to not change output.
-          rcon = 0.0;
+
           if (info != 0)
             {
               info = -1;
               retval = ComplexDET ();
             }
           else
             {
-              if (calc_cond)
+              for (octave_idx_type i = 0; i < nc; i++)
                 {
-                  // Now calc the condition number for non-singular matrix.
-                  char job = '1';
-                  Array<Complex> z (dim_vector (2 * nc, 1));
-                  Complex *pz = z.fortran_vec ();
-                  Array<double> rz (dim_vector (2 * nc, 1));
-                  double *prz = rz.fortran_vec ();
-
-                  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
-                                             F77_CHAR_ARG_LEN (1)));
-                }
-
-              if (info != 0)
-                {
-                  info = -1;
-                  retval = ComplexDET ();
-                }
-              else
-                {
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    {
-                      Complex c = atmp(i,i);
-                      retval *= (ipvt(i) != (i+1)) ? -c : c;
-                    }
+                  Complex c = atmp(i,i);
+                  retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
   return retval;
 }
 
@@ -1765,17 +1676,18 @@ double
 ComplexMatrix::rcond (MatrixType &mattype) const
 {
   double rcon = octave_NaN;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else if (nr == 0 || nc == 0)
+
+  if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
@@ -1939,92 +1851,87 @@ ComplexMatrix::utsolve (MatrixType &matt
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      rcon = 1.;
+      info = 0;
+
+      if (typ == MatrixType::Permuted_Upper)
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
+
+      const Complex *tmp_data = fortran_vec ();
+
+      retval = b;
+      Complex *result = retval.fortran_vec ();
+
+      char uplo = 'U';
+      char trans = get_blas_char (transt);
+      char dia = 'N';
+
+      F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                 F77_CONST_CHAR_ARG2 (&trans, 1),
+                                 F77_CONST_CHAR_ARG2 (&dia, 1),
+                                 nr, b_nc, tmp_data, nr,
+                                 result, nr, info
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (calc_cond)
         {
-          octave_idx_type b_nc = b.cols ();
-          rcon = 1.;
-          info = 0;
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
-          else
+          char norm = '1';
+          uplo = 'U';
+          dia = 'N';
+
+          Array<Complex> z (dim_vector (2 * nc, 1));
+          Complex *pz = z.fortran_vec ();
+          Array<double> rz (dim_vector (nc, 1));
+          double *prz = rz.fortran_vec ();
+
+          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
+                                     nr, tmp_data, nr, rcon,
+                                     pz, prz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0)
+            info = -2;
+
+          volatile double rcond_plus_one = rcon + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcon))
             {
-              const Complex *tmp_data = fortran_vec ();
-
-              retval = b;
-              Complex *result = retval.fortran_vec ();
-
-              char uplo = 'U';
-              char trans = get_blas_char (transt);
-              char dia = 'N';
-
-              F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                         F77_CONST_CHAR_ARG2 (&trans, 1),
-                                         F77_CONST_CHAR_ARG2 (&dia, 1),
-                                         nr, b_nc, tmp_data, nr,
-                                         result, nr, info
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)));
-
-              if (calc_cond)
-                {
-                  char norm = '1';
-                  uplo = 'U';
-                  dia = 'N';
-
-                  Array<Complex> z (dim_vector (2 * nc, 1));
-                  Complex *pz = z.fortran_vec ();
-                  Array<double> rz (dim_vector (nc, 1));
-                  double *prz = rz.fortran_vec ();
-
-                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                             F77_CONST_CHAR_ARG2 (&dia, 1),
-                                             nr, tmp_data, nr, rcon,
-                                             pz, prz, info
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)));
-
-                  if (info != 0)
-                    info = -2;
-
-                  volatile double rcond_plus_one = rcon + 1.0;
-
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
-                    {
-                      info = -2;
-
-                      if (sing_handler)
-                        sing_handler (rcon);
-                      else
-                        warn_singular_matrix (rcon);
-                    }
-                }
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                warn_singular_matrix (rcon);
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
@@ -2034,92 +1941,87 @@ ComplexMatrix::ltsolve (MatrixType &matt
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      rcon = 1.;
+      info = 0;
+
+      if (typ == MatrixType::Permuted_Lower)
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
+
+      const Complex *tmp_data = fortran_vec ();
+
+      retval = b;
+      Complex *result = retval.fortran_vec ();
+
+      char uplo = 'L';
+      char trans = get_blas_char (transt);
+      char dia = 'N';
+
+      F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                 F77_CONST_CHAR_ARG2 (&trans, 1),
+                                 F77_CONST_CHAR_ARG2 (&dia, 1),
+                                 nr, b_nc, tmp_data, nr,
+                                 result, nr, info
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (calc_cond)
         {
-          octave_idx_type b_nc = b.cols ();
-          rcon = 1.;
-          info = 0;
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
-          else
+          char norm = '1';
+          uplo = 'L';
+          dia = 'N';
+
+          Array<Complex> z (dim_vector (2 * nc, 1));
+          Complex *pz = z.fortran_vec ();
+          Array<double> rz (dim_vector (nc, 1));
+          double *prz = rz.fortran_vec ();
+
+          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
+                                     nr, tmp_data, nr, rcon,
+                                     pz, prz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0)
+            info = -2;
+
+          volatile double rcond_plus_one = rcon + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcon))
             {
-              const Complex *tmp_data = fortran_vec ();
-
-              retval = b;
-              Complex *result = retval.fortran_vec ();
-
-              char uplo = 'L';
-              char trans = get_blas_char (transt);
-              char dia = 'N';
-
-              F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                         F77_CONST_CHAR_ARG2 (&trans, 1),
-                                         F77_CONST_CHAR_ARG2 (&dia, 1),
-                                         nr, b_nc, tmp_data, nr,
-                                         result, nr, info
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)));
-
-              if (calc_cond)
-                {
-                  char norm = '1';
-                  uplo = 'L';
-                  dia = 'N';
-
-                  Array<Complex> z (dim_vector (2 * nc, 1));
-                  Complex *pz = z.fortran_vec ();
-                  Array<double> rz (dim_vector (nc, 1));
-                  double *prz = rz.fortran_vec ();
-
-                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                             F77_CONST_CHAR_ARG2 (&dia, 1),
-                                             nr, tmp_data, nr, rcon,
-                                             pz, prz, info
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)));
-
-                  if (info != 0)
-                    info = -2;
-
-                  volatile double rcond_plus_one = rcon + 1.0;
-
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
-                    {
-                      info = -2;
-
-                      if (sing_handler)
-                        sing_handler (rcon);
-                      else
-                        warn_singular_matrix (rcon);
-                    }
-                }
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                warn_singular_matrix (rcon);
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
@@ -2130,17 +2032,18 @@ ComplexMatrix::fsolve (MatrixType &matty
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
@@ -2382,20 +2285,17 @@ ComplexMatrix::solve (MatrixType &mattyp
     return transpose ().solve (mattype, b, info, rcon, sing_handler,
                                singular_fallback);
   else if (transt == blas_conj_trans)
     retval = hermitian ().solve (mattype, b, info, rcon, sing_handler,
                                  singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return ComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
@@ -2661,17 +2561,18 @@ ComplexMatrix::lssolve (const ComplexMat
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m== 0 || n == 0 || b.cols () == 0)
+
+  if (m== 0 || n == 0 || b.cols () == 0)
     retval = ComplexMatrix (n, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
@@ -2858,17 +2759,18 @@ ComplexMatrix::lssolve (const ComplexCol
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m == 0 || n == 0 || b.cols () == 0)
+
+  if (m == 0 || n == 0 || b.cols () == 0)
     retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
@@ -3165,28 +3067,23 @@ ComplexMatrix
 ComplexMatrix::diag (octave_idx_type k) const
 {
   return ComplexNDArray::diag (k);
 }
 
 ComplexDiagMatrix
 ComplexMatrix::diag (octave_idx_type m, octave_idx_type n) const
 {
-  ComplexDiagMatrix retval;
-
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (nr == 1 || nc == 1)
-    retval = ComplexDiagMatrix (*this, m, n);
-  else
-    (*current_liboctave_error_handler)
-      ("diag: expecting vector argument");
-
-  return retval;
+  if (nr != 1 && nc != 1)
+    (*current_liboctave_error_handler) ("diag: expecting vector argument");
+
+  return ComplexDiagMatrix (*this, m, n);
 }
 
 bool
 ComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
@@ -3853,21 +3750,18 @@ min (const ComplexMatrix& m, const Compl
 
 ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg min requires same size arguments");
-      return ComplexMatrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg min requires same size arguments");
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
@@ -3941,21 +3835,18 @@ max (const ComplexMatrix& m, const Compl
 
 ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg max requires same size arguments");
-      return ComplexMatrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg max requires same size arguments");
 
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -750,56 +750,51 @@ conj (const ComplexNDArray& a)
 
 ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
 
   int n = a_dv.length ();
 
-  if (n == dimensions.length ())
-    {
-      Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
-
-      a_ra_idx.elem (0) = r;
-      a_ra_idx.elem (1) = c;
-
-      for (int i = 0; i < n; i++)
-        {
-          if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dimensions(i))
-            {
-              (*current_liboctave_error_handler)
-                ("Array<T>::insert: range error for insert");
-              return *this;
-            }
-        }
-
-      a_ra_idx.elem (0) = 0;
-      a_ra_idx.elem (1) = 0;
-
-      octave_idx_type n_elt = a.numel ();
-
-      // IS make_unique () NECESSARY HERE?
-
-      for (octave_idx_type i = 0; i < n_elt; i++)
-        {
-          Array<octave_idx_type> ra_idx = a_ra_idx;
-
-          ra_idx.elem (0) = a_ra_idx(0) + r;
-          ra_idx.elem (1) = a_ra_idx(1) + c;
-
-          elem (ra_idx) = a.elem (a_ra_idx);
-
-          increment_index (a_ra_idx, a_dv);
-        }
-    }
-  else
+  if (n != dimensions.length ())
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
+  Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
+
+  a_ra_idx.elem (0) = r;
+  a_ra_idx.elem (1) = c;
+
+  for (int i = 0; i < n; i++)
+    {
+      if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dimensions(i))
+        (*current_liboctave_error_handler)
+          ("Array<T>::insert: range error for insert");
+    }
+
+  a_ra_idx.elem (0) = 0;
+  a_ra_idx.elem (1) = 0;
+
+  octave_idx_type n_elt = a.numel ();
+
+  // IS make_unique () NECESSARY HERE?
+
+  for (octave_idx_type i = 0; i < n_elt; i++)
+    {
+      Array<octave_idx_type> ra_idx = a_ra_idx;
+
+      ra_idx.elem (0) = a_ra_idx(0) + r;
+      ra_idx.elem (1) = a_ra_idx(1) + c;
+
+      elem (ra_idx) = a.elem (a_ra_idx);
+
+      increment_index (a_ra_idx, a_dv);
+    }
+
   return *this;
 }
 
 ComplexNDArray&
 ComplexNDArray::insert (const ComplexNDArray& a,
                         octave_idx_type r, octave_idx_type c)
 {
   Array<Complex>::insert (a, r, c);
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -74,20 +74,17 @@ ComplexRowVector::operator != (const Com
 // destructive insert/delete/reorder operations
 
 ComplexRowVector&
 ComplexRowVector::insert (const RowVector& a, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (c < 0 || c + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (c+i) = a.elem (i);
     }
@@ -96,20 +93,17 @@ ComplexRowVector::insert (const RowVecto
 }
 
 ComplexRowVector&
 ComplexRowVector::insert (const ComplexRowVector& a, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (c < 0 || c + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (c+i) = a.elem (i);
     }
@@ -150,20 +144,17 @@ ComplexRowVector::fill (const Complex& v
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
@@ -175,20 +166,17 @@ ComplexRowVector::fill (double val, octa
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val,
                         octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -761,333 +761,303 @@ SparseComplexMatrix::dinverse (MatrixTyp
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
+
+  // Print spparms("spumoni") info if requested
+  int typ = mattyp.type ();
+  mattyp.info ();
+
+  if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+    (*current_liboctave_error_handler) ("incorrect matrix type");
+
+  if (typ == MatrixType::Permuted_Diagonal)
+    retval = transpose ();
   else
+    retval = *this;
+
+  // Force make_unique to be called
+  Complex *v = retval.data ();
+
+  if (calccond)
     {
-      // Print spparms("spumoni") info if requested
-      int typ = mattyp.type ();
-      mattyp.info ();
-
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+      double dmax = 0.;
+      double dmin = octave_Inf;
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          if (typ == MatrixType::Permuted_Diagonal)
-            retval = transpose ();
-          else
-            retval = *this;
-
-          // Force make_unique to be called
-          Complex *v = retval.data ();
-
-          if (calccond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nr; i++)
-                {
-                  double tmp = std::abs (v[i]);
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
-                }
-              rcond = dmin / dmax;
-            }
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            v[i] = 1.0 / v[i];
+          double tmp = std::abs (v[i]);
+          if (tmp > dmax)
+            dmax = tmp;
+          if (tmp < dmin)
+            dmin = tmp;
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+      rcond = dmin / dmax;
     }
 
+  for (octave_idx_type i = 0; i < nr; i++)
+    v[i] = 1.0 / v[i];
+
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info,
                                double& rcond, const bool,
                                const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
-  else
+
+  // Print spparms("spumoni") info if requested
+  int typ = mattyp.type ();
+  mattyp.info ();
+
+  if (typ != MatrixType::Upper && typ != MatrixType::Permuted_Upper
+      && typ != MatrixType::Lower && typ != MatrixType::Permuted_Lower)
+    (*current_liboctave_error_handler) ("incorrect matrix type");
+
+  double anorm = 0.;
+  double ainvnorm = 0.;
+
+  if (calccond)
     {
-      // Print spparms("spumoni") info if requested
-      int typ = mattyp.type ();
-      mattyp.info ();
-
-      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper
-          || typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+      // Calculate the 1-norm of matrix for rcond calculation
+      for (octave_idx_type j = 0; j < nr; j++)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-
-          if (calccond)
-            {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nr; j++)
-                {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-            {
-              octave_idx_type nz = nnz ();
-              octave_idx_type cx = 0;
-              octave_idx_type nz2 = nz;
-              retval = SparseComplexMatrix (nr, nc, nz2);
-
-              for (octave_idx_type i = 0; i < nr; i++)
+          double atmp = 0.;
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            atmp += std::abs (data (i));
+          if (atmp > anorm)
+            anorm = atmp;
+        }
+    }
+
+  if (typ == MatrixType::Upper || typ == MatrixType::Lower)
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type cx = 0;
+      octave_idx_type nz2 = nz;
+      retval = SparseComplexMatrix (nr, nc, nz2);
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          octave_quit ();
+          // place the 1 in the identity position
+          octave_idx_type cx_colstart = cx;
+
+          if (cx == nz2)
+            {
+              nz2 *= 2;
+              retval.change_capacity (nz2);
+            }
+
+          retval.xcidx (i) = cx;
+          retval.xridx (cx) = i;
+          retval.xdata (cx) = 1.0;
+          cx++;
+
+          // iterate accross columns of input matrix
+          for (octave_idx_type j = i+1; j < nr; j++)
+            {
+              Complex v = 0.;
+              // iterate to calculate sum
+              octave_idx_type colXp = retval.xcidx (i);
+              octave_idx_type colUp = cidx (j);
+              octave_idx_type rpX, rpU;
+
+              if (cidx (j) == cidx (j+1))
+                (*current_liboctave_error_handler) ("division by zero");
+
+              do
                 {
                   octave_quit ();
-                  // place the 1 in the identity position
-                  octave_idx_type cx_colstart = cx;
-
+                  rpX = retval.xridx (colXp);
+                  rpU = ridx (colUp);
+
+                  if (rpX < rpU)
+                    colXp++;
+                  else if (rpX > rpU)
+                    colUp++;
+                  else
+                    {
+                      v -= retval.xdata (colXp) * data (colUp);
+                      colXp++;
+                      colUp++;
+                    }
+                }
+              while (rpX < j && rpU < j && colXp < cx && colUp < nz);
+
+
+              // get A(m,m)
+              if (typ == MatrixType::Upper)
+                colUp = cidx (j+1) - 1;
+              else
+                colUp = cidx (j);
+              Complex pivot = data (colUp);
+              if (pivot == 0. || ridx (colUp) != j)
+                (*current_liboctave_error_handler) ("division by zero");
+
+              if (v != 0.)
+                {
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx (i) = cx;
-                  retval.xridx (cx) = i;
-                  retval.xdata (cx) = 1.0;
+                  retval.xridx (cx) = j;
+                  retval.xdata (cx) = v / pivot;
                   cx++;
-
-                  // iterate accross columns of input matrix
-                  for (octave_idx_type j = i+1; j < nr; j++)
-                    {
-                      Complex v = 0.;
-                      // iterate to calculate sum
-                      octave_idx_type colXp = retval.xcidx (i);
-                      octave_idx_type colUp = cidx (j);
-                      octave_idx_type rpX, rpU;
-
-                      if (cidx (j) == cidx (j+1))
-                        {
-                          (*current_liboctave_error_handler)
-                            ("division by zero");
-                          goto inverse_singular;
-                        }
-
-                      do
-                        {
-                          octave_quit ();
-                          rpX = retval.xridx (colXp);
-                          rpU = ridx (colUp);
-
-                          if (rpX < rpU)
-                            colXp++;
-                          else if (rpX > rpU)
-                            colUp++;
-                          else
-                            {
-                              v -= retval.xdata (colXp) * data (colUp);
-                              colXp++;
-                              colUp++;
-                            }
-                        }
-                      while (rpX < j && rpU < j && colXp < cx && colUp < nz);
-
-
-                      // get A(m,m)
-                      if (typ == MatrixType::Upper)
-                        colUp = cidx (j+1) - 1;
-                      else
-                        colUp = cidx (j);
-                      Complex pivot = data (colUp);
-                      if (pivot == 0. || ridx (colUp) != j)
-                        {
-                          (*current_liboctave_error_handler)
-                            ("division by zero");
-                          goto inverse_singular;
-                        }
-
-                      if (v != 0.)
-                        {
-                          if (cx == nz2)
-                            {
-                              nz2 *= 2;
-                              retval.change_capacity (nz2);
-                            }
-
-                          retval.xridx (cx) = j;
-                          retval.xdata (cx) = v / pivot;
-                          cx++;
-                        }
-                    }
-
-                  // get A(m,m)
-                  octave_idx_type colUp;
-                  if (typ == MatrixType::Upper)
-                    colUp = cidx (i+1) - 1;
-                  else
-                    colUp = cidx (i);
-                  Complex pivot = data (colUp);
-                  if (pivot == 0. || ridx (colUp) != i)
-                    {
-                      (*current_liboctave_error_handler) ("division by zero");
-                      goto inverse_singular;
-                    }
-
-                  if (pivot != 1.0)
-                    for (octave_idx_type j = cx_colstart; j < cx; j++)
-                      retval.xdata (j) /= pivot;
                 }
-              retval.xcidx (nr) = cx;
-              retval.maybe_compress ();
-            }
+            }
+
+          // get A(m,m)
+          octave_idx_type colUp;
+          if (typ == MatrixType::Upper)
+            colUp = cidx (i+1) - 1;
           else
-            {
-              octave_idx_type nz = nnz ();
-              octave_idx_type cx = 0;
-              octave_idx_type nz2 = nz;
-              retval = SparseComplexMatrix (nr, nc, nz2);
-
-              OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-
-              octave_idx_type *perm = mattyp.triangular_perm ();
-              if (typ == MatrixType::Permuted_Upper)
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    rperm[perm[i]] = i;
-                }
-              else
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    rperm[i] = perm[i];
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    perm[rperm[i]] = i;
-                }
-
-              for (octave_idx_type i = 0; i < nr; i++)
+            colUp = cidx (i);
+          Complex pivot = data (colUp);
+          if (pivot == 0. || ridx (colUp) != i)
+            (*current_liboctave_error_handler) ("division by zero");
+
+          if (pivot != 1.0)
+            for (octave_idx_type j = cx_colstart; j < cx; j++)
+              retval.xdata (j) /= pivot;
+        }
+      retval.xcidx (nr) = cx;
+      retval.maybe_compress ();
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type cx = 0;
+      octave_idx_type nz2 = nz;
+      retval = SparseComplexMatrix (nr, nc, nz2);
+
+      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+
+      octave_idx_type *perm = mattyp.triangular_perm ();
+      if (typ == MatrixType::Permuted_Upper)
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            rperm[perm[i]] = i;
+        }
+      else
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            rperm[i] = perm[i];
+          for (octave_idx_type i = 0; i < nr; i++)
+            perm[rperm[i]] = i;
+        }
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          octave_quit ();
+          octave_idx_type iidx = rperm[i];
+
+          for (octave_idx_type j = 0; j < nr; j++)
+            work[j] = 0.;
+
+          // place the 1 in the identity position
+          work[iidx] = 1.0;
+
+          // iterate accross columns of input matrix
+          for (octave_idx_type j = iidx+1; j < nr; j++)
+            {
+              Complex v = 0.;
+              octave_idx_type jidx = perm[j];
+              // iterate to calculate sum
+              for (octave_idx_type k = cidx (jidx);
+                   k < cidx (jidx+1); k++)
                 {
                   octave_quit ();
-                  octave_idx_type iidx = rperm[i];
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    work[j] = 0.;
-
-                  // place the 1 in the identity position
-                  work[iidx] = 1.0;
-
-                  // iterate accross columns of input matrix
-                  for (octave_idx_type j = iidx+1; j < nr; j++)
-                    {
-                      Complex v = 0.;
-                      octave_idx_type jidx = perm[j];
-                      // iterate to calculate sum
-                      for (octave_idx_type k = cidx (jidx);
-                           k < cidx (jidx+1); k++)
-                        {
-                          octave_quit ();
-                          v -= work[ridx (k)] * data (k);
-                        }
-
-                      // get A(m,m)
-                      Complex pivot;
-                      if (typ == MatrixType::Permuted_Upper)
-                        pivot = data (cidx (jidx+1) - 1);
-                      else
-                        pivot = data (cidx (jidx));
-                      if (pivot == 0.)
-                        {
-                          (*current_liboctave_error_handler)
-                            ("division by zero");
-                          goto inverse_singular;
-                        }
-
-                      work[j] = v / pivot;
-                    }
-
-                  // get A(m,m)
-                  octave_idx_type colUp;
-                  if (typ == MatrixType::Permuted_Upper)
-                    colUp = cidx (perm[iidx]+1) - 1;
-                  else
-                    colUp = cidx (perm[iidx]);
-
-                  Complex pivot = data (colUp);
-                  if (pivot == 0.)
-                    {
-                      (*current_liboctave_error_handler)
-                        ("division by zero");
-                      goto inverse_singular;
-                    }
-
-                  octave_idx_type new_cx = cx;
-                  for (octave_idx_type j = iidx; j < nr; j++)
-                    if (work[j] != 0.0)
-                      {
-                        new_cx++;
-                        if (pivot != 1.0)
-                          work[j] /= pivot;
-                      }
-
-                  if (cx < new_cx)
-                    {
-                      nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
-                      retval.change_capacity (nz2);
-                    }
-
-                  retval.xcidx (i) = cx;
-                  for (octave_idx_type j = iidx; j < nr; j++)
-                    if (work[j] != 0.)
-                      {
-                        retval.xridx (cx) = j;
-                        retval.xdata (cx++) = work[j];
-                      }
+                  v -= work[ridx (k)] * data (k);
                 }
 
-              retval.xcidx (nr) = cx;
-              retval.maybe_compress ();
-            }
-
-          if (calccond)
-            {
-              // Calculate the 1-norm of inverse matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nr; j++)
-                {
-                  double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx (j);
-                       i < retval.cidx (j+1); i++)
-                    atmp += std::abs (retval.data (i));
-                  if (atmp > ainvnorm)
-                    ainvnorm = atmp;
-                }
-
-              rcond = 1. / ainvnorm / anorm;
-            }
+              // get A(m,m)
+              Complex pivot;
+              if (typ == MatrixType::Permuted_Upper)
+                pivot = data (cidx (jidx+1) - 1);
+              else
+                pivot = data (cidx (jidx));
+              if (pivot == 0.)
+                (*current_liboctave_error_handler) ("division by zero");
+
+              work[j] = v / pivot;
+            }
+
+          // get A(m,m)
+          octave_idx_type colUp;
+          if (typ == MatrixType::Permuted_Upper)
+            colUp = cidx (perm[iidx]+1) - 1;
+          else
+            colUp = cidx (perm[iidx]);
+
+          Complex pivot = data (colUp);
+          if (pivot == 0.)
+            (*current_liboctave_error_handler) ("division by zero");
+
+          octave_idx_type new_cx = cx;
+          for (octave_idx_type j = iidx; j < nr; j++)
+            if (work[j] != 0.0)
+              {
+                new_cx++;
+                if (pivot != 1.0)
+                  work[j] /= pivot;
+              }
+
+          if (cx < new_cx)
+            {
+              nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
+              retval.change_capacity (nz2);
+            }
+
+          retval.xcidx (i) = cx;
+          for (octave_idx_type j = iidx; j < nr; j++)
+            if (work[j] != 0.)
+              {
+                retval.xridx (cx) = j;
+                retval.xdata (cx++) = work[j];
+              }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      retval.xcidx (nr) = cx;
+      retval.maybe_compress ();
+    }
+
+  if (calccond)
+    {
+      // Calculate the 1-norm of inverse matrix for rcond calculation
+      for (octave_idx_type j = 0; j < nr; j++)
+        {
+          double atmp = 0.;
+          for (octave_idx_type i = retval.cidx (j);
+               i < retval.cidx (j+1); i++)
+            atmp += std::abs (retval.data (i));
+          if (atmp > ainvnorm)
+            ainvnorm = atmp;
+        }
+
+      rcond = 1. / ainvnorm / anorm;
     }
 
   return retval;
-
-inverse_singular:
-  return SparseComplexMatrix ();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                               double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseComplexMatrix ret;
@@ -1222,63 +1192,63 @@ SparseComplexMatrix::determinant (octave
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_ZNAME (qsymbolic)
                    (nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0,
                     0, &Symbolic, control, info);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler)
-            ("SparseComplexMatrix::determinant symbolic factorization failed");
-
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           UMFPACK_ZNAME (free_symbolic) (&Symbolic);
+
+          (*current_liboctave_error_handler)
+            ("SparseComplexMatrix::determinant symbolic factorization failed");
         }
       else
         {
           UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status
             = UMFPACK_ZNAME (numeric) (Ap, Ai,
                                        reinterpret_cast<const double *> (Ax),
                                        0, Symbolic, &Numeric, control, info);
           UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler)
-                ("SparseComplexMatrix::determinant numeric factorization failed");
-
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
+
+              (*current_liboctave_error_handler)
+                ("SparseComplexMatrix::determinant numeric factorization failed");
             }
           else
             {
               UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
               double c10[2], e10;
 
               status = UMFPACK_ZNAME (get_determinant) (c10, 0, &e10,
                                                         Numeric, info);
 
               if (status < 0)
                 {
+                  UMFPACK_ZNAME (report_status) (control, status);
+                  UMFPACK_ZNAME (report_info) (control, info);
+
                   (*current_liboctave_error_handler)
                     ("SparseComplexMatrix::determinant error calculating determinant");
-
-                  UMFPACK_ZNAME (report_status) (control, status);
-                  UMFPACK_ZNAME (report_info) (control, info);
                 }
               else
                 retval = ComplexDET (Complex (c10[0], c10[1]), e10, 10);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
         }
     }
@@ -1300,56 +1270,55 @@ SparseComplexMatrix::dsolve (MatrixType 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      retval.resize (nc, b.cols (), Complex (0.,0.));
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type i = 0; i < nm; i++)
+            retval(i,j) = b(i,j) / data (i);
+      else
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type k = 0; k < nc; k++)
+            for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+              retval(k,j) = b(ridx (i),j) / data (i);
+
+      if (calc_cond)
         {
-          retval.resize (nc, b.cols (), Complex (0.,0.));
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type i = 0; i < nm; i++)
-                retval(i,j) = b(i,j) / data (i);
-          else
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
-                  retval(k,j) = b(ridx (i),j) / data (i);
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nm; i++)
-                {
-                  double tmp = std::abs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
-                }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.0;
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              double tmp = std::abs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.0;
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
                              octave_idx_type& err, double& rcond,
@@ -1361,86 +1330,85 @@ SparseComplexMatrix::dsolve (MatrixType 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
-        {
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols (); j++)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          {
+            for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
               {
-                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                  {
-                    if (b.ridx (i) >= nm)
-                      break;
-                    retval.xridx (ii) = b.ridx (i);
-                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
-                  }
-                retval.xcidx (j+1) = ii;
+                if (b.ridx (i) >= nm)
+                  break;
+                retval.xridx (ii) = b.ridx (i);
+                retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
               }
-          else
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              {
-                for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+            retval.xcidx (j+1) = ii;
+          }
+      else
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          {
+            for (octave_idx_type l = 0; l < nc; l++)
+              for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+                {
+                  bool found = false;
+                  octave_idx_type k;
+                  for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                    if (ridx (i) == b.ridx (k))
+                      {
+                        found = true;
+                        break;
+                      }
+                  if (found)
                     {
-                      bool found = false;
-                      octave_idx_type k;
-                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
-                        if (ridx (i) == b.ridx (k))
-                          {
-                            found = true;
-                            break;
-                          }
-                      if (found)
-                        {
-                          retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data (k) / data (i);
-                        }
+                      retval.xridx (ii) = l;
+                      retval.xdata (ii++) = b.data (k) / data (i);
                     }
-                retval.xcidx (j+1) = ii;
-              }
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nm; i++)
-                {
-                  double tmp = std::abs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
                 }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.0;
+            retval.xcidx (j+1) = ii;
+          }
+
+      if (calc_cond)
+        {
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              double tmp = std::abs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.0;
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
@@ -1452,56 +1420,55 @@ SparseComplexMatrix::dsolve (MatrixType 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      retval.resize (nc, b.cols (), Complex (0.,0.));
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type i = 0; i < nm; i++)
+            retval(i,j) = b(i,j) / data (i);
+      else
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type k = 0; k < nc; k++)
+            for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+              retval(k,j) = b(ridx (i),j) / data (i);
+
+      if (calc_cond)
         {
-          retval.resize (nc, b.cols (), Complex (0.,0.));
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type i = 0; i < nm; i++)
-                retval(i,j) = b(i,j) / data (i);
-          else
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
-                  retval(k,j) = b(ridx (i),j) / data (i);
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nr; i++)
-                {
-                  double tmp = std::abs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
-                }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.0;
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              double tmp = std::abs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.0;
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
@@ -1513,86 +1480,85 @@ SparseComplexMatrix::dsolve (MatrixType 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
-        {
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols (); j++)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          {
+            for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
               {
-                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                  {
-                    if (b.ridx (i) >= nm)
-                      break;
-                    retval.xridx (ii) = b.ridx (i);
-                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
-                  }
-                retval.xcidx (j+1) = ii;
+                if (b.ridx (i) >= nm)
+                  break;
+                retval.xridx (ii) = b.ridx (i);
+                retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
               }
-          else
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              {
-                for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+            retval.xcidx (j+1) = ii;
+          }
+      else
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          {
+            for (octave_idx_type l = 0; l < nc; l++)
+              for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+                {
+                  bool found = false;
+                  octave_idx_type k;
+                  for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                    if (ridx (i) == b.ridx (k))
+                      {
+                        found = true;
+                        break;
+                      }
+                  if (found)
                     {
-                      bool found = false;
-                      octave_idx_type k;
-                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
-                        if (ridx (i) == b.ridx (k))
-                          {
-                            found = true;
-                            break;
-                          }
-                      if (found)
-                        {
-                          retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data (k) / data (i);
-                        }
+                      retval.xridx (ii) = l;
+                      retval.xdata (ii++) = b.data (k) / data (i);
                     }
-                retval.xcidx (j+1) = ii;
-              }
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nm; i++)
-                {
-                  double tmp = std::abs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
                 }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.0;
+            retval.xcidx (j+1) = ii;
+          }
+
+      if (calc_cond)
+        {
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              double tmp = std::abs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.0;
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const Matrix& b,
                               octave_idx_type& err, double& rcond,
@@ -1604,226 +1570,225 @@ SparseComplexMatrix::utsolve (MatrixType
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval(perm[i], j) = work[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              retval.resize (nc, b_nc);
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
+                      octave_idx_type iidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          Complex tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
-
-                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                        }
+                    }
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
+                    {
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          retval.resize (nc, b_nc);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = work[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval(perm[i], j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
             }
           else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              retval.resize (nc, b_nc);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
-                    {
-                      if (work[k] != 0.)
-                        {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = work[k] / data (cidx (k+1)-1);
-                          work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              work[iidx] = work[iidx] - tmp * data (i);
-                            }
-                        }
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
+            warn_singular_matrix (rcond);
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
                               octave_idx_type& err, double& rcond,
@@ -1835,278 +1800,277 @@ SparseComplexMatrix::utsolve (MatrixType
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+          for (octave_idx_type i = 0; i < nc; i++)
+            rperm[perm[i]] = i;
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[rperm[i]] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[rperm[i]];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-              for (octave_idx_type i = 0; i < nc; i++)
-                rperm[perm[i]] = i;
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
+                      octave_idx_type iidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          Complex tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
-
-                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                        }
+                    }
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
+                    {
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[rperm[i]] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[rperm[i]];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
             }
           else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
-                    {
-                      if (work[k] != 0.)
-                        {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = work[k] / data (cidx (k+1)-1);
-                          work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              work[iidx] = work[iidx] - tmp * data (i);
-                            }
-                        }
-                    }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
+            warn_singular_matrix (rcond);
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
@@ -2117,226 +2081,225 @@ SparseComplexMatrix::utsolve (MatrixType
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval(perm[i], j) = work[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              retval.resize (nc, b_nc);
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
+                      octave_idx_type iidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          Complex tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
-
-                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                        }
+                    }
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
+                    {
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          retval.resize (nc, b_nc);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = work[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval(perm[i], j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
             }
           else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              retval.resize (nc, b_nc);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
-                    {
-                      if (work[k] != 0.)
-                        {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = work[k] / data (cidx (k+1)-1);
-                          work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              work[iidx] = work[iidx] - tmp * data (i);
-                            }
-                        }
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
+            warn_singular_matrix (rcond);
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
@@ -2348,278 +2311,277 @@ SparseComplexMatrix::utsolve (MatrixType
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+          for (octave_idx_type i = 0; i < nc; i++)
+            rperm[perm[i]] = i;
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[rperm[i]] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[rperm[i]];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-              for (octave_idx_type i = 0; i < nc; i++)
-                rperm[perm[i]] = i;
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
+                      octave_idx_type iidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          Complex tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
-
-                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
+                        }
+                    }
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
+                    {
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nr-1; k >= 0; k--)
+                {
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[rperm[i]] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[rperm[i]];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
             }
           else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nr-1; k >= 0; k--)
-                    {
-                      if (work[k] != 0.)
-                        {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = work[k] / data (cidx (k+1)-1);
-                          work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              work[iidx] = work[iidx] - tmp * data (i);
-                            }
-                        }
-                    }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
+            warn_singular_matrix (rcond);
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
                               octave_idx_type& err, double& rcond,
@@ -2631,245 +2593,244 @@ SparseComplexMatrix::ltsolve (MatrixType
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[perm[i]] = b(i,j);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (work[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (mini);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval(i, j) = work[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              retval.resize (nc, b_nc);
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[perm[i]] = b(i,j);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval(i, j) = work[i];
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
+                    {
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          retval.resize (nc, b_nc, 0.);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (work[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              Complex tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k));
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
                         }
-
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              retval.resize (nc, b_nc, 0.);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = work[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type k = 0; k < nc; k++)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
                     {
+
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
-                }
-            }
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
                               octave_idx_type& err, double& rcond,
@@ -2882,296 +2843,295 @@ SparseComplexMatrix::ltsolve (MatrixType
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
 
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[perm[b.ridx (i)]] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (work[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (mini);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[perm[b.ridx (i)]] = b.data (i);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (work[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k));
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              Complex tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
                         }
-
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = 0; k < nc; k++)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
                     {
+
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
@@ -3183,249 +3143,248 @@ SparseComplexMatrix::ltsolve (MatrixType
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[perm[i]] = b(i,j);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (work[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (mini);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval(i, j) = work[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              retval.resize (nc, b_nc);
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[perm[i]] = b(i,j);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval(i, j) = work[i];
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
+                    {
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          retval.resize (nc, b_nc, 0.);
+
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (work[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              Complex tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k));
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
                         }
-
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              retval.resize (nc, b_nc, 0.);
-
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = work[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type k = 0; k < nc; k++)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
                     {
+
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                               octave_idx_type& err, double& rcond,
@@ -3437,296 +3396,295 @@ SparseComplexMatrix::ltsolve (MatrixType
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += std::abs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[perm[b.ridx (i)]] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (work[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (mini);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += std::abs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[perm[b.ridx (i)]] = b.data (i);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (work[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = work[k] / data (cidx (k));
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              Complex tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
                         }
-
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = 0; k < nc; k++)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
                     {
+
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              Complex tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += std::abs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += std::abs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const Matrix& b,
                                octave_idx_type& err, double& rcond,
@@ -3737,17 +3695,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
@@ -3887,17 +3846,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
@@ -4032,17 +3992,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
@@ -4184,17 +4145,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
@@ -4284,16 +4246,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              Bx, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
+                      // FIXME: This should probably be a warning so that
+                      //        error value can be passed back.
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
                   // Count nonzeros in work vector and adjust
@@ -4341,17 +4305,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -4443,16 +4408,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
                              ldm, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
+                      // FIXME: Probably should be a warning.
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
@@ -4584,17 +4550,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -4696,16 +4663,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
+                          // FIXME: Probably should be a warning.
                           (*current_liboctave_error_handler)
                             ("SparseComplexMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
@@ -4896,17 +4864,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -4999,16 +4968,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
                              ldm, result, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
+                      // FIXME: Probably should be a warning.
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
@@ -5137,17 +5107,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -5253,16 +5224,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
+                          // FIXME: Probably should be a warning.
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       // Count nonzeros in work vector and adjust
                       // space in retval if needed
@@ -5495,24 +5467,25 @@ SparseComplexMatrix::factorize (octave_i
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
                                           reinterpret_cast<const double *> (Ax),
                                           0, 0, &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler)
-        ("SparseComplexMatrix::solve symbolic factorization failed");
-      err = -1;
-
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic);
+
+      // FIXME: Should this be a warning?
+      (*current_liboctave_error_handler)
+        ("SparseComplexMatrix::solve symbolic factorization failed");
+      err = -1;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
                                         reinterpret_cast<const double *> (Ax),
                                         0, Symbolic, &Numeric, control, info);
@@ -5533,22 +5506,23 @@ SparseComplexMatrix::factorize (octave_i
 
           if (sing_handler)
             sing_handler (rcond);
           else
             warn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
+          UMFPACK_ZNAME (report_status) (control, status);
+          UMFPACK_ZNAME (report_info) (control, info);
+
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("SparseComplexMatrix::solve numeric factorization failed");
 
-          UMFPACK_ZNAME (report_status) (control, status);
-          UMFPACK_ZNAME (report_info) (control, info);
-
           err = -1;
         }
       else
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
         }
     }
 
@@ -5573,17 +5547,18 @@ SparseComplexMatrix::fsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -5772,23 +5747,23 @@ SparseComplexMatrix::fsolve (MatrixType 
                                                   0,
                                                   reinterpret_cast<const double *> (Bz),
                                                   0, Numeric,
                                                   control, info);
 #endif
 
                   if (status < 0)
                     {
+                      UMFPACK_ZNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
-                      UMFPACK_ZNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
@@ -5818,17 +5793,18 @@ SparseComplexMatrix::fsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -6044,23 +6020,23 @@ SparseComplexMatrix::fsolve (MatrixType 
                                                   0,
                                                   reinterpret_cast<double *> (Bz),
                                                   0,
                                                   Numeric, control,
                                                   info);
 #endif
                   if (status < 0)
                     {
+                      UMFPACK_ZNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
-                      UMFPACK_ZNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex tmp = Xx[i];
                       if (tmp != 0.0)
                         {
@@ -6111,17 +6087,18 @@ SparseComplexMatrix::fsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -6289,23 +6266,23 @@ SparseComplexMatrix::fsolve (MatrixType 
                                            0,
                                            reinterpret_cast<double *> (&Xx[iidx]),
                                            0,
                                            reinterpret_cast<const double *> (&Bx[iidx]),
                                            0, Numeric, control, info);
 
                   if (status < 0)
                     {
+                      UMFPACK_ZNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
-                      UMFPACK_ZNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
@@ -6335,17 +6312,18 @@ SparseComplexMatrix::fsolve (MatrixType 
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -6539,23 +6517,23 @@ SparseComplexMatrix::fsolve (MatrixType 
                                                   0,
                                                   reinterpret_cast<double *> (Xx),
                                                   0,
                                                   reinterpret_cast<double *> (Bx),
                                                   0, Numeric, control, info);
 
                   if (status < 0)
                     {
+                      UMFPACK_ZNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
-                      UMFPACK_ZNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex tmp = Xx[i];
                       if (tmp != 0.0)
                         {
@@ -6654,20 +6632,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return ComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix, Matrix>
@@ -6722,20 +6697,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return SparseComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix, SparseMatrix>
@@ -6790,20 +6762,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return ComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix, ComplexMatrix>
@@ -6859,20 +6828,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return SparseComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -89,20 +89,17 @@ DiagArray2<T>::hermitian (T (* fcn) (con
 // A two-dimensional array with diagonal elements only.
 
 template <class T>
 void
 DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c,
                        const T& rfv)
 {
   if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler) ("can't resize to negative dimensions");
-      return;
-    }
+    (*current_liboctave_error_handler) ("can't resize to negative dimensions");
 
   if (r != dim1 () || c != dim2 ())
     {
       Array<T>::resize (dim_vector (std::min (r, c), 1), rfv);
       d1 = r; d2 = c;
     }
 }
 
diff --git a/liboctave/array/MArray.cc b/liboctave/array/MArray.cc
--- a/liboctave/array/MArray.cc
+++ b/liboctave/array/MArray.cc
@@ -160,18 +160,17 @@ void MArray<T>::idx_add_nd (const idx_ve
     }
 
   octave_idx_type l,n,u,ns;
   get_extent_triplet (ddv, dim, l, n, u);
   ns = sdv(dim);
 
   sdv(dim) = ddv(dim) = 0;
   if (ddv != sdv)
-    (*current_liboctave_error_handler)
-      ("accumdim: dimension mismatch");
+    (*current_liboctave_error_handler) ("accumdim: dimension mismatch");
 
   T *dst = Array<T>::fortran_vec ();
   const T *src = vals.data ();
   octave_idx_type len = idx.length (ns);
 
   if (l == 1)
     {
       for (octave_idx_type j = 0; j < u; j++)
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -28,18 +28,17 @@ along with Octave; see the file COPYING.
 #include "idx-vector.h"
 #include "Array-util.h"
 #include "oct-locbuf.h"
 
 OCTAVE_NORETURN static
 void
 err_invalid_permutation (void)
 {
-  (*current_liboctave_error_handler)
-    ("PermMatrix: invalid permutation vector");
+  (*current_liboctave_error_handler) ("PermMatrix: invalid permutation vector");
 }
 
 void
 PermMatrix::setup (const Array<octave_idx_type>& p, bool colp, bool check)
 {
   if (check)
     {
       if (! idx_vector (p).is_permutation (p.numel ()))
@@ -97,22 +96,19 @@ PermMatrix::PermMatrix (octave_idx_type 
     xelem (i) = i;
 }
 
 octave_idx_type
 PermMatrix::checkelem (octave_idx_type i, octave_idx_type j) const
 {
   octave_idx_type len = Array<octave_idx_type>::numel ();
   if (i < 0 || j < 0 || i > len || j > len)
-    {
-      (*current_liboctave_error_handler) ("index out of range");
-      return 0;
-    }
-  else
-    return elem (i, j);
+    (*current_liboctave_error_handler) ("index out of range");
+
+  return elem (i, j);
 }
 
 
 PermMatrix
 PermMatrix::transpose (void) const
 {
   octave_idx_type len = Array<octave_idx_type>::numel ();
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -71,57 +71,49 @@ Sparse<T>::Sparse (const PermMatrix& a)
 }
 
 template <class T>
 T&
 Sparse<T>::SparseRep::elem (octave_idx_type _r, octave_idx_type _c)
 {
   octave_idx_type i;
 
-  if (nzmx > 0)
+  if (nzmx <= 0)
+    (*current_liboctave_error_handler)
+      ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
+
+  for (i = c[_c]; i < c[_c + 1]; i++)
+    if (r[i] == _r)
+      return d[i];
+    else if (r[i] > _r)
+      break;
+
+  // Ok, If we've gotten here, we're in trouble.. Have to create a
+  // new element in the sparse array. This' gonna be slow!!!
+  if (c[ncols] == nzmx)
+    (*current_liboctave_error_handler)
+      ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
+
+  octave_idx_type to_move = c[ncols] - i;
+  if (to_move != 0)
     {
-      for (i = c[_c]; i < c[_c + 1]; i++)
-        if (r[i] == _r)
-          return d[i];
-        else if (r[i] > _r)
-          break;
-
-      // Ok, If we've gotten here, we're in trouble.. Have to create a
-      // new element in the sparse array. This' gonna be slow!!!
-      if (c[ncols] == nzmx)
-        {
-          (*current_liboctave_error_handler)
-            ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
-          return *d;
-        }
-
-      octave_idx_type to_move = c[ncols] - i;
-      if (to_move != 0)
+      for (octave_idx_type j = c[ncols]; j > i; j--)
         {
-          for (octave_idx_type j = c[ncols]; j > i; j--)
-            {
-              d[j] = d[j-1];
-              r[j] = r[j-1];
-            }
+          d[j] = d[j-1];
+          r[j] = r[j-1];
         }
-
-      for (octave_idx_type j = _c + 1; j < ncols + 1; j++)
-        c[j] = c[j] + 1;
-
-      d[i] = 0.;
-      r[i] = _r;
-
-      return d[i];
     }
-  else
-    {
-      (*current_liboctave_error_handler)
-        ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
-      return *d;
-    }
+
+  for (octave_idx_type j = _c + 1; j < ncols + 1; j++)
+    c[j] = c[j] + 1;
+
+  d[i] = 0.;
+  r[i] = _r;
+
+  return d[i];
 }
 
 template <class T>
 T
 Sparse<T>::SparseRep::celem (octave_idx_type _r, octave_idx_type _c) const
 {
   if (nzmx > 0)
     for (octave_idx_type i = c[_c]; i < c[_c + 1]; i++)
@@ -222,62 +214,60 @@ Sparse<T>::Sparse (octave_idx_type nr, o
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
   if (dv.length () != 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const dim_vector&): dimension mismatch");
-  else
-    rep = new typename Sparse<T>::SparseRep (dv(0), dv(1), 0);
+
+  rep = new typename Sparse<T>::SparseRep (dv(0), dv(1), 0);
 }
 
 template <class T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
 
   // Work in unsigned long long to avoid overflow issues with numel
   unsigned long long a_nel = static_cast<unsigned long long>(a.rows ()) *
                              static_cast<unsigned long long>(a.cols ());
   unsigned long long dv_nel = static_cast<unsigned long long>(dv(0)) *
                               static_cast<unsigned long long>(dv(1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
-  else
-    {
-      dim_vector old_dims = a.dims ();
-      octave_idx_type new_nzmx = a.nnz ();
-      octave_idx_type new_nr = dv(0);
-      octave_idx_type new_nc = dv(1);
-      octave_idx_type old_nr = old_dims(0);
-      octave_idx_type old_nc = old_dims(1);
-
-      rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
-
-      octave_idx_type kk = 0;
-      xcidx (0) = 0;
-      for (octave_idx_type i = 0; i < old_nc; i++)
-        for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)
-          {
-            octave_idx_type tmp = i * old_nr + a.ridx (j);
-            octave_idx_type ii = tmp % new_nr;
-            octave_idx_type jj = (tmp - ii) / new_nr;
-            for (octave_idx_type k = kk; k < jj; k++)
-              xcidx (k+1) = j;
-            kk = jj;
-            xdata (j) = a.data (j);
-            xridx (j) = ii;
-          }
-      for (octave_idx_type k = kk; k < new_nc; k++)
-        xcidx (k+1) = new_nzmx;
-    }
+
+  dim_vector old_dims = a.dims ();
+  octave_idx_type new_nzmx = a.nnz ();
+  octave_idx_type new_nr = dv(0);
+  octave_idx_type new_nc = dv(1);
+  octave_idx_type old_nr = old_dims(0);
+  octave_idx_type old_nc = old_dims(1);
+
+  rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
+
+  octave_idx_type kk = 0;
+  xcidx (0) = 0;
+  for (octave_idx_type i = 0; i < old_nc; i++)
+    for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)
+      {
+        octave_idx_type tmp = i * old_nr + a.ridx (j);
+        octave_idx_type ii = tmp % new_nr;
+        octave_idx_type jj = (tmp - ii) / new_nr;
+        for (octave_idx_type k = kk; k < jj; k++)
+          xcidx (k+1) = j;
+        kk = jj;
+        xdata (j) = a.data (j);
+        xridx (j) = ii;
+      }
+  for (octave_idx_type k = kk; k < new_nc; k++)
+    xcidx (k+1) = new_nzmx;
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a, const idx_vector& r,
                    const idx_vector& c, octave_idx_type nr,
                    octave_idx_type nc, bool sum_terms,
                    octave_idx_type nzm)
   : rep (0), dimensions ()
@@ -637,42 +627,40 @@ Sparse<T>::Sparse (const Array<T>& a, co
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a)
   : rep (0), dimensions (a.dims ())
 {
   if (dimensions.length () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
-  else
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+  octave_idx_type len = a.numel ();
+  octave_idx_type new_nzmx = 0;
+
+  // First count the number of nonzero terms
+  for (octave_idx_type i = 0; i < len; i++)
+    if (a(i) != T ())
+      new_nzmx++;
+
+  rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
+
+  octave_idx_type ii = 0;
+  xcidx (0) = 0;
+  for (octave_idx_type j = 0; j < nc; j++)
     {
-      octave_idx_type nr = rows ();
-      octave_idx_type nc = cols ();
-      octave_idx_type len = a.numel ();
-      octave_idx_type new_nzmx = 0;
-
-      // First count the number of nonzero terms
-      for (octave_idx_type i = 0; i < len; i++)
-        if (a(i) != T ())
-          new_nzmx++;
-
-      rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
-
-      octave_idx_type ii = 0;
-      xcidx (0) = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-        {
-          for (octave_idx_type i = 0; i < nr; i++)
-            if (a.elem (i,j) != T ())
-              {
-                xdata (ii) = a.elem (i,j);
-                xridx (ii++) = i;
-              }
-          xcidx (j+1) = ii;
-        }
+      for (octave_idx_type i = 0; i < nr; i++)
+        if (a.elem (i,j) != T ())
+          {
+            xdata (ii) = a.elem (i,j);
+            xridx (ii++) = i;
+          }
+      xcidx (j+1) = ii;
     }
 }
 
 template <class T>
 Sparse<T>::~Sparse (void)
 {
   if (--rep->count == 0)
     delete rep;
@@ -695,72 +683,62 @@ Sparse<T>::operator = (const Sparse<T>& 
 
   return *this;
 }
 
 template <class T>
 octave_idx_type
 Sparse<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
-  octave_idx_type retval = -1;
-
   octave_idx_type n = dimensions.length ();
 
-  if (n > 0 && n == ra_idx.numel ())
-    {
-      retval = ra_idx(--n);
-
-      while (--n >= 0)
-        {
-          retval *= dimensions(n);
-          retval += ra_idx(n);
-        }
-    }
-  else
+  if (n <= 0 || n != ra_idx.numel ())
     (*current_liboctave_error_handler)
       ("Sparse<T>::compute_index: invalid ra_idxing operation");
 
+  octave_idx_type retval = -1;
+
+  retval = ra_idx(--n);
+
+  while (--n >= 0)
+    {
+      retval *= dimensions(n);
+      retval += ra_idx(n);
+    }
+
   return retval;
 }
 
 template <class T>
 T
 Sparse<T>::range_error (const char *fcn, octave_idx_type n) const
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
-  return T ();
 }
 
 template <class T>
 T&
 Sparse<T>::range_error (const char *fcn, octave_idx_type n)
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
-  static T foo;
-  return foo;
 }
 
 template <class T>
 T
 Sparse<T>::range_error (const char *fcn, octave_idx_type i,
                         octave_idx_type j) const
 {
-  (*current_liboctave_error_handler)
-    ("%s (%d, %d): range error", fcn, i, j);
-  return T ();
+  (*current_liboctave_error_handler) ("%s (%d, %d): range error", fcn, i, j);
 }
 
 template <class T>
 T&
 Sparse<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j)
 {
-  (*current_liboctave_error_handler)
-    ("%s (%d, %d): range error", fcn, i, j);
-  static T foo;
-  return foo;
+  (*current_liboctave_error_handler) ("%s (%d, %d): range error", fcn, i, j);
 }
 
 template <class T>
 T
 Sparse<T>::range_error (const char *fcn,
                         const Array<octave_idx_type>& ra_idx) const
 {
   std::ostringstream buf;
@@ -775,18 +753,16 @@ Sparse<T>::range_error (const char *fcn,
   for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
 
   std::string buf_str = buf.str ();
 
   (*current_liboctave_error_handler) (buf_str.c_str ());
-
-  return T ();
 }
 
 template <class T>
 T&
 Sparse<T>::range_error (const char *fcn, const Array<octave_idx_type>& ra_idx)
 {
   std::ostringstream buf;
 
@@ -800,19 +776,16 @@ Sparse<T>::range_error (const char *fcn,
   for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
 
   std::string buf_str = buf.str ();
 
   (*current_liboctave_error_handler) (buf_str.c_str ());
-
-  static T foo;
-  return foo;
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::reshape (const dim_vector& new_dims) const
 {
   Sparse<T> retval;
   dim_vector dims2 = new_dims;
@@ -926,34 +899,27 @@ Sparse<T>::resize1 (octave_idx_type n)
 
 template <class T>
 void
 Sparse<T>::resize (const dim_vector& dv)
 {
   octave_idx_type n = dv.length ();
 
   if (n != 2)
-    {
-      (*current_liboctave_error_handler) ("sparse array must be 2-D");
-      return;
-    }
+    (*current_liboctave_error_handler) ("sparse array must be 2-D");
 
   resize (dv(0), dv(1));
 }
 
 template <class T>
 void
 Sparse<T>::resize (octave_idx_type r, octave_idx_type c)
 {
   if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-        ("can't resize to negative dimension");
-      return;
-    }
+    (*current_liboctave_error_handler) ("can't resize to negative dimension");
 
   if (r == dim1 () && c == dim2 ())
     return;
 
   // This wouldn't be necessary for r >= rows () if nrows wasn't part of the
   // Sparse rep. It is not good for anything in there.
   make_unique ();
 
@@ -998,20 +964,17 @@ Sparse<T>&
 Sparse<T>::insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_rows = a.rows ();
   octave_idx_type a_cols = a.cols ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   // First count the number of elements in the final array
   octave_idx_type nel = cidx (c) + a.nnz ();
 
   if (c + a_cols < nc)
     nel += cidx (nc) - cidx (c + a_cols);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
@@ -1078,20 +1041,17 @@ Sparse<T>::insert (const Sparse<T>& a, o
 }
 
 template <class T>
 Sparse<T>&
 Sparse<T>::insert (const Sparse<T>& a, const Array<octave_idx_type>& ra_idx)
 {
 
   if (ra_idx.numel () != 2)
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   return insert (a, ra_idx(0), ra_idx(1));
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::transpose (void) const
 {
@@ -1371,21 +1331,17 @@ template <class T>
 void
 Sparse<T>::delete_elements (int dim, const idx_vector& idx)
 {
   if (dim == 0)
     delete_elements (idx, idx_vector::colon);
   else if (dim == 1)
     delete_elements (idx_vector::colon, idx);
   else
-    {
-      (*current_liboctave_error_handler)
-        ("invalid dimension in delete_elements");
-      return;
-    }
+    (*current_liboctave_error_handler) ("invalid dimension in delete_elements");
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::index (const idx_vector& idx, bool resize_ok) const
 {
   Sparse<T> retval;
 
@@ -2590,38 +2546,35 @@ Sparse<T>::cat (int dim, octave_idx_type
   bool (dim_vector::*concat_rule) (const dim_vector&, int) = &dim_vector::concat;
 
   if (dim == -1 || dim == -2)
     {
       concat_rule = &dim_vector::hvcat;
       dim = -dim - 1;
     }
   else if (dim < 0)
-    (*current_liboctave_error_handler)
-      ("cat: invalid dimension");
+    (*current_liboctave_error_handler) ("cat: invalid dimension");
 
   dim_vector dv;
   octave_idx_type total_nz = 0;
-  if (dim == 0 || dim == 1)
-    {
-      if (n == 1)
-        return sparse_list[0];
-
-      for (octave_idx_type i = 0; i < n; i++)
-        {
-          if (! (dv.*concat_rule) (sparse_list[i].dims (), dim))
-            (*current_liboctave_error_handler)
-              ("cat: dimension mismatch");
-          total_nz += sparse_list[i].nnz ();
-        }
-    }
-  else
+  if (dim != 0 && dim != 1)
     (*current_liboctave_error_handler)
       ("cat: invalid dimension for sparse concatenation");
 
+  if (n == 1)
+    return sparse_list[0];
+
+  for (octave_idx_type i = 0; i < n; i++)
+    {
+      if (! (dv.*concat_rule) (sparse_list[i].dims (), dim))
+        (*current_liboctave_error_handler) ("cat: dimension mismatch");
+
+      total_nz += sparse_list[i].nnz ();
+    }
+
   Sparse<T> retval (dv, total_nz);
 
   if (retval.is_empty ())
     return retval;
 
   switch (dim)
     {
     case 0:
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -717,68 +717,64 @@ read_sparse_matrix (std::istream& is, Sp
           is >> itmp;
           itmp--;
 
           is >> jtmp;
           jtmp--;
 
           if (itmp < 0 || itmp >= nr)
             {
+              is.setstate (std::ios::failbit);
+
               (*current_liboctave_error_handler)
                 ("invalid sparse matrix: row index = %d out of range",
                  itmp + 1);
-              is.setstate (std::ios::failbit);
-              goto done;
             }
 
           if (jtmp < 0 || jtmp >= nc)
             {
+              is.setstate (std::ios::failbit);
+
               (*current_liboctave_error_handler)
                 ("invalid sparse matrix: column index = %d out of range",
                  jtmp + 1);
-              is.setstate (std::ios::failbit);
-              goto done;
             }
 
           if (jtmp < jold)
             {
+              is.setstate (std::ios::failbit);
+
               (*current_liboctave_error_handler)
-                ("invalid sparse matrix: column indices must appear in ascending order");
-              is.setstate (std::ios::failbit);
-              goto done;
+                ("invalid sparse matrix: "
+                 "column indices must appear in ascending order");
             }
           else if (jtmp > jold)
             {
               for (octave_idx_type j = jold; j < jtmp; j++)
                 a.cidx (j+1) = ii;
             }
           else if (itmp < iold)
             {
+              is.setstate (std::ios::failbit);
+
               (*current_liboctave_error_handler)
-                ("invalid sparse matrix: row indices must appear in ascending order in each column");
-              is.setstate (std::ios::failbit);
-              goto done;
+                ("invalid sparse matrix: "
+                 "row indices must appear in ascending order in each column");
             }
 
           iold = itmp;
           jold = jtmp;
 
           tmp = read_fcn (is);
 
-          if (is)
-            {
-              a.data (ii) = tmp;
-              a.ridx (ii++) = itmp;
-            }
-          else
-            goto done;
+          if (! is)
+            return is;  // Problem, return is in error state
+
+          a.data (ii) = tmp;
+          a.ridx (ii++) = itmp;
         }
 
       for (octave_idx_type j = jold; j < nc; j++)
         a.cidx (j+1) = ii;
     }
-
-done:
-
-  return is;
 }
 
 #endif
diff --git a/liboctave/array/chMatrix.cc b/liboctave/array/chMatrix.cc
--- a/liboctave/array/chMatrix.cc
+++ b/liboctave/array/chMatrix.cc
@@ -57,20 +57,17 @@ charMatrix::operator != (const charMatri
 charMatrix&
 charMatrix::insert (const char *s, octave_idx_type r, octave_idx_type c)
 {
   if (s)
     {
       octave_idx_type s_len = strlen (s);
 
       if (r < 0 || r >= rows () || c < 0 || c + s_len - 1 > cols ())
-        {
-          (*current_liboctave_error_handler) ("range error for insert");
-          return *this;
-        }
+        (*current_liboctave_error_handler) ("range error for insert");
 
       for (octave_idx_type i = 0; i < s_len; i++)
         elem (r, c+i) = s[i];
     }
   return *this;
 }
 
 charMatrix&
@@ -87,20 +84,17 @@ charMatrix::row_as_string (octave_idx_ty
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r == 0 && (nr == 0 || nc == 0))
     return retval;
 
   if (r < 0 || r >= nr)
-    {
-      (*current_liboctave_error_handler) ("range error for row_as_string");
-      return retval;
-    }
+    (*current_liboctave_error_handler) ("range error for row_as_string");
 
   retval.resize (nc, '\0');
 
   for (octave_idx_type i = 0; i < nc; i++)
     retval[i] = elem (r, i);
 
   if (strip_ws)
     {
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -115,31 +115,26 @@ charNDArray::concat (const NDArray& rb, 
   if (rb.is_empty ())
     return *this;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = rb.elem (i);
 
       if (xisnan (d))
-        {
-          (*current_liboctave_error_handler)
-            ("invalid conversion from NaN to character");
-          return *this;
-        }
-      else
-        {
-          octave_idx_type ival = NINTbig (d);
+        (*current_liboctave_error_handler)
+          ("invalid conversion from NaN to character");
+
+      octave_idx_type ival = NINTbig (d);
 
-          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            // FIXME: is there something better to do? Should we warn the user?
-            ival = 0;
+      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+        // FIXME: is there something better to do? Should we warn the user?
+        ival = 0;
 
-          tmp.elem (i) = static_cast<char>(ival);
-        }
+      tmp.elem (i) = static_cast<char>(ival);
     }
 
   insert (tmp, ra_idx);
   return *this;
 }
 
 charNDArray
 charNDArray::max (int dim) const
diff --git a/liboctave/array/dColVector.cc b/liboctave/array/dColVector.cc
--- a/liboctave/array/dColVector.cc
+++ b/liboctave/array/dColVector.cc
@@ -68,20 +68,17 @@ ColumnVector::operator != (const ColumnV
 }
 
 ColumnVector&
 ColumnVector::insert (const ColumnVector& a, octave_idx_type r)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i) = a.elem (i);
     }
@@ -106,20 +103,17 @@ ColumnVector::fill (double val)
 }
 
 ColumnVector&
 ColumnVector::fill (double val, octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -58,84 +58,69 @@ DiagMatrix::fill (double val)
     elem (i, i) = val;
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (double val, octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 DiagMatrix
@@ -178,106 +163,85 @@ DiagMatrix::extract (octave_idx_type r1,
 // extract row or column i.
 
 RowVector
 DiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return RowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   RowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 RowVector
 DiagMatrix::row (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return RowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return RowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 ColumnVector
 DiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   ColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ColumnVector
 DiagMatrix::column (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 DiagMatrix
 DiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
 }
 
 DiagMatrix
 DiagMatrix::inverse (octave_idx_type &info) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   octave_idx_type len = length ();
   if (r != c)
-    {
-      (*current_liboctave_error_handler) ("inverse requires square matrix");
-      return DiagMatrix ();
-    }
+    (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   DiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
         retval.elem (i, i) = octave_Inf;
@@ -340,26 +304,21 @@ operator * (const DiagMatrix& a, const D
 
 // other operations
 
 DET
 DiagMatrix::determinant (void) const
 {
   DET det (1.0);
   if (rows () != cols ())
-    {
-      (*current_liboctave_error_handler) ("determinant requires square matrix");
-      det = 0.0;
-    }
-  else
-    {
-      octave_idx_type len = length ();
-      for (octave_idx_type i = 0; i < len; i++)
-        det *= elem (i, i);
-    }
+    (*current_liboctave_error_handler) ("determinant requires square matrix");
+
+  octave_idx_type len = length ();
+  for (octave_idx_type i = 0; i < len; i++)
+    det *= elem (i, i);
 
   return det;
 }
 
 double
 DiagMatrix::rcond (void) const
 {
   ColumnVector av = extract_diag (0).map<double> (fabs);
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -339,20 +339,17 @@ Matrix::insert (const Matrix& a, octave_
 }
 
 Matrix&
 Matrix::insert (const RowVector& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r, c+i) = a.elem (i);
     }
@@ -361,20 +358,17 @@ Matrix::insert (const RowVector& a, octa
 }
 
 Matrix&
 Matrix::insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
@@ -384,20 +378,17 @@ Matrix::insert (const ColumnVector& a, o
 
 Matrix&
 Matrix::insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
@@ -431,20 +422,17 @@ Matrix&
 Matrix::fill (double val, octave_idx_type r1, octave_idx_type c1,
               octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
@@ -457,150 +445,122 @@ Matrix::fill (double val, octave_idx_typ
 }
 
 Matrix
 Matrix::append (const Matrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != 1)
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.numel ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const DiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   Matrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::stack (const Matrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const RowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.numel ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const ColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const DiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   Matrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
@@ -693,142 +653,138 @@ Matrix::tinverse (MatrixType &mattype, o
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
-  else
+
+  int typ = mattype.type ();
+  char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
+  char udiag = 'N';
+  retval = *this;
+  double *tmp_data = retval.fortran_vec ();
+
+  F77_XFCN (dtrtri, DTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                             F77_CONST_CHAR_ARG2 (&udiag, 1),
+                             nr, tmp_data, nr, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
     {
-      int typ = mattype.type ();
-      char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
-      char udiag = 'N';
-      retval = *this;
-      double *tmp_data = retval.fortran_vec ();
-
-      F77_XFCN (dtrtri, DTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+      octave_idx_type dtrcon_info = 0;
+      char job = '1';
+
+      OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
+
+      F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info
+                                 nr, tmp_data, nr, rcon,
+                                 work, iwork, dtrcon_info
+                                 F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+      if (dtrcon_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          octave_idx_type dtrcon_info = 0;
-          char job = '1';
-
-          OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
-
-          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     work, iwork, dtrcon_info
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (dtrcon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this; // Restore matrix contents.
     }
 
+  if (info == -1 && ! force)
+    retval = *this; // Restore matrix contents.
+
   return retval;
 }
 
 
 Matrix
 Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   int force, int calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
+
+  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+  octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+  retval = *this;
+  double *tmp_data = retval.fortran_vec ();
+
+  Array<double> z (dim_vector (1, 1));
+  octave_idx_type lwork = -1;
+
+  // Query the optimum work array size.
+  F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
+                             z.fortran_vec (), lwork, info));
+
+  lwork = static_cast<octave_idx_type> (z(0));
+  lwork = (lwork < 2 *nc ? 2*nc : lwork);
+  z.resize (dim_vector (lwork, 1));
+  double *pz = z.fortran_vec ();
+
+  info = 0;
+
+  // Calculate the norm of the matrix, for later use.
+  double anorm = 0;
+  if (calc_cond)
+    anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
+            .max ();
+
+  F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
+    {
+      octave_idx_type dgecon_info = 0;
+
+      // Now calculate the condition number for non-singular matrix.
+      char job = '1';
+      Array<octave_idx_type> iz (dim_vector (nc, 1));
+      octave_idx_type *piz = iz.fortran_vec ();
+      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nc, tmp_data, nr, anorm,
+                                 rcon, pz, piz, dgecon_info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (dgecon_info != 0)
+        info = -1;
+    }
+
+  if (info == -1 && ! force)
+    retval = *this; // Restore matrix contents.
   else
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      retval = *this;
-      double *tmp_data = retval.fortran_vec ();
-
-      Array<double> z (dim_vector (1, 1));
-      octave_idx_type lwork = -1;
-
-      // Query the optimum work array size.
+      octave_idx_type dgetri_info = 0;
+
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
-                                 z.fortran_vec (), lwork, info));
-
-      lwork = static_cast<octave_idx_type> (z(0));
-      lwork = (lwork < 2 *nc ? 2*nc : lwork);
-      z.resize (dim_vector (lwork, 1));
-      double *pz = z.fortran_vec ();
-
-      info = 0;
-
-      // Calculate the norm of the matrix, for later use.
-      double anorm = 0;
-      if (calc_cond)
-        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
-                .max ();
-
-      F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
-
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+                                 pz, lwork, dgetri_info));
+
+      if (dgetri_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          octave_idx_type dgecon_info = 0;
-
-          // Now calculate the condition number for non-singular matrix.
-          char job = '1';
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
-          F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm,
-                                     rcon, pz, piz, dgecon_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (dgecon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this; // Restore matrix contents.
-      else
-        {
-          octave_idx_type dgetri_info = 0;
-
-          F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
-                                     pz, lwork, dgetri_info));
-
-          if (dgetri_info != 0)
-            info = -1;
-        }
-
-      if (info != 0)
-        mattype.mark_as_rectangular ();
     }
 
+  if (info != 0)
+    mattype.mark_as_rectangular ();
+
   return retval;
 }
 
 Matrix
 Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                  int force, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1261,130 +1217,128 @@ Matrix::determinant (MatrixType& mattype
   info = 0;
   rcon = 0.0;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else
+
+  volatile int typ = mattype.type ();
+
+  // Even though the matrix is marked as singular (Rectangular), we may
+  // still get a useful number from the LU factorization, because it always
+  // completes.
+
+  if (typ == MatrixType::Unknown)
+    typ = mattype.type (*this);
+  else if (typ == MatrixType::Rectangular)
+    typ = MatrixType::Full;
+
+  if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      volatile int typ = mattype.type ();
-
-      // Even though the matrix is marked as singular (Rectangular), we may
-      // still get a useful number from the LU factorization, because it always
-      // completes.
-
-      if (typ == MatrixType::Unknown)
-        typ = mattype.type (*this);
-      else if (typ == MatrixType::Rectangular)
-        typ = MatrixType::Full;
-
-      if (typ == MatrixType::Lower || typ == MatrixType::Upper)
+      for (octave_idx_type i = 0; i < nc; i++)
+        retval *= elem (i,i);
+    }
+  else if (typ == MatrixType::Hermitian)
+    {
+      Matrix atmp = *this;
+      double *tmp_data = atmp.fortran_vec ();
+
+      double anorm = 0;
+      if (calc_cond) anorm = xnorm (*this, 1);
+
+
+      char job = 'L';
+      F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
+                                 tmp_data, nr, info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (info != 0)
         {
-          for (octave_idx_type i = 0; i < nc; i++)
-            retval *= elem (i,i);
+          rcon = 0.0;
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
         }
-      else if (typ == MatrixType::Hermitian)
+      else
         {
-          Matrix atmp = *this;
-          double *tmp_data = atmp.fortran_vec ();
-
-          double anorm = 0;
-          if (calc_cond) anorm = xnorm (*this, 1);
-
-
-          char job = 'L';
-          F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+          Array<double> z (dim_vector (3 * nc, 1));
+          double *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, tmp_data, nr, anorm,
+                                     rcon, pz, piz, info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
+            rcon = 0.0;
+
+          for (octave_idx_type i = 0; i < nc; i++)
+            retval *= atmp (i,i);
+
+          retval = retval.square ();
+        }
+    }
+  else if (typ != MatrixType::Full)
+    (*current_liboctave_error_handler) ("det: invalid dense matrix type");
+
+  if (typ == MatrixType::Full)
+    {
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+      Matrix atmp = *this;
+      double *tmp_data = atmp.fortran_vec ();
+
+      info = 0;
+
+      // Calculate the norm of the matrix, for later use.
+      double anorm = 0;
+      if (calc_cond) anorm = xnorm (*this, 1);
+
+      F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcon = 0.0;
+      if (info != 0)
+        {
+          info = -1;
+          retval = DET ();
+        }
+      else
+        {
+          if (calc_cond)
             {
-              rcon = 0.0;
-              mattype.mark_as_unsymmetric ();
-              typ = MatrixType::Full;
-            }
-          else
-            {
-              Array<double> z (dim_vector (3 * nc, 1));
+              // Now calc the condition number for non-singular matrix.
+              char job = '1';
+              Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
-              F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                         nr, tmp_data, nr, anorm,
+              F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nc, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
-
-              if (info != 0)
-                rcon = 0.0;
-
-              for (octave_idx_type i = 0; i < nc; i++)
-                retval *= atmp (i,i);
-
-              retval = retval.square ();
             }
-        }
-      else if (typ != MatrixType::Full)
-        (*current_liboctave_error_handler) ("det: invalid dense matrix type");
-
-      if (typ == MatrixType::Full)
-        {
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          Matrix atmp = *this;
-          double *tmp_data = atmp.fortran_vec ();
-
-          info = 0;
-
-          // Calculate the norm of the matrix, for later use.
-          double anorm = 0;
-          if (calc_cond) anorm = xnorm (*this, 1);
-
-          F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-          // Throw-away extra info LAPACK gives so as to not change output.
-          rcon = 0.0;
+
           if (info != 0)
             {
               info = -1;
               retval = DET ();
             }
           else
             {
-              if (calc_cond)
+              for (octave_idx_type i = 0; i < nc; i++)
                 {
-                  // Now calc the condition number for non-singular matrix.
-                  char job = '1';
-                  Array<double> z (dim_vector (4 * nc, 1));
-                  double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
-
-                  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, piz, info
-                                             F77_CHAR_ARG_LEN (1)));
-                }
-
-              if (info != 0)
-                {
-                  info = -1;
-                  retval = DET ();
-                }
-              else
-                {
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    {
-                      double c = atmp(i,i);
-                      retval *= (ipvt(i) != (i+1)) ? -c : c;
-                    }
+                  double c = atmp(i,i);
+                  retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
   return retval;
 }
 
@@ -1399,17 +1353,18 @@ double
 Matrix::rcond (MatrixType &mattype) const
 {
   double rcon = octave_NaN;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else if (nr == 0 || nc == 0)
+
+  if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
@@ -1434,17 +1389,17 @@ Matrix::rcond (MatrixType &mattype) cons
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0.0;
         }
-      else if  (typ == MatrixType::Permuted_Upper)
+      else if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const double *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
@@ -1566,92 +1521,87 @@ Matrix::utsolve (MatrixType &mattype, co
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      rcon = 1.;
+      info = 0;
+
+      if (typ == MatrixType::Permuted_Upper)
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
+
+      const double *tmp_data = fortran_vec ();
+
+      retval = b;
+      double *result = retval.fortran_vec ();
+
+      char uplo = 'U';
+      char trans = get_blas_char (transt);
+      char dia = 'N';
+
+      F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                 F77_CONST_CHAR_ARG2 (&trans, 1),
+                                 F77_CONST_CHAR_ARG2 (&dia, 1),
+                                 nr, b_nc, tmp_data, nr,
+                                 result, nr, info
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (calc_cond)
         {
-          octave_idx_type b_nc = b.cols ();
-          rcon = 1.;
-          info = 0;
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
-          else
+          char norm = '1';
+          uplo = 'U';
+          dia = 'N';
+
+          Array<double> z (dim_vector (3 * nc, 1));
+          double *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
+                                     nr, tmp_data, nr, rcon,
+                                     pz, piz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0)
+            info = -2;
+
+          volatile double rcond_plus_one = rcon + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcon))
             {
-              const double *tmp_data = fortran_vec ();
-
-              retval = b;
-              double *result = retval.fortran_vec ();
-
-              char uplo = 'U';
-              char trans = get_blas_char (transt);
-              char dia = 'N';
-
-              F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                         F77_CONST_CHAR_ARG2 (&trans, 1),
-                                         F77_CONST_CHAR_ARG2 (&dia, 1),
-                                         nr, b_nc, tmp_data, nr,
-                                         result, nr, info
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)));
-
-              if (calc_cond)
-                {
-                  char norm = '1';
-                  uplo = 'U';
-                  dia = 'N';
-
-                  Array<double> z (dim_vector (3 * nc, 1));
-                  double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
-
-                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                             F77_CONST_CHAR_ARG2 (&dia, 1),
-                                             nr, tmp_data, nr, rcon,
-                                             pz, piz, info
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)));
-
-                  if (info != 0)
-                    info = -2;
-
-                  volatile double rcond_plus_one = rcon + 1.0;
-
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
-                    {
-                      info = -2;
-
-                      if (sing_handler)
-                        sing_handler (rcon);
-                      else
-                        warn_singular_matrix (rcon);
-                    }
-                }
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                warn_singular_matrix (rcon);
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
@@ -1660,92 +1610,87 @@ Matrix::ltsolve (MatrixType &mattype, co
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      rcon = 1.;
+      info = 0;
+
+      if (typ == MatrixType::Permuted_Lower)
+        (*current_liboctave_error_handler)
+          ("permuted triangular matrix not implemented");
+
+      const double *tmp_data = fortran_vec ();
+
+      retval = b;
+      double *result = retval.fortran_vec ();
+
+      char uplo = 'L';
+      char trans = get_blas_char (transt);
+      char dia = 'N';
+
+      F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                 F77_CONST_CHAR_ARG2 (&trans, 1),
+                                 F77_CONST_CHAR_ARG2 (&dia, 1),
+                                 nr, b_nc, tmp_data, nr,
+                                 result, nr, info
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (calc_cond)
         {
-          octave_idx_type b_nc = b.cols ();
-          rcon = 1.;
-          info = 0;
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
-          else
+          char norm = '1';
+          uplo = 'L';
+          dia = 'N';
+
+          Array<double> z (dim_vector (3 * nc, 1));
+          double *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
+                                     nr, tmp_data, nr, rcon,
+                                     pz, piz, info
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)
+                                     F77_CHAR_ARG_LEN (1)));
+
+          if (info != 0)
+            info = -2;
+
+          volatile double rcond_plus_one = rcon + 1.0;
+
+          if (rcond_plus_one == 1.0 || xisnan (rcon))
             {
-              const double *tmp_data = fortran_vec ();
-
-              retval = b;
-              double *result = retval.fortran_vec ();
-
-              char uplo = 'L';
-              char trans = get_blas_char (transt);
-              char dia = 'N';
-
-              F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                         F77_CONST_CHAR_ARG2 (&trans, 1),
-                                         F77_CONST_CHAR_ARG2 (&dia, 1),
-                                         nr, b_nc, tmp_data, nr,
-                                         result, nr, info
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)
-                                         F77_CHAR_ARG_LEN (1)));
-
-              if (calc_cond)
-                {
-                  char norm = '1';
-                  uplo = 'L';
-                  dia = 'N';
-
-                  Array<double> z (dim_vector (3 * nc, 1));
-                  double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
-
-                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                             F77_CONST_CHAR_ARG2 (&dia, 1),
-                                             nr, tmp_data, nr, rcon,
-                                             pz, piz, info
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)
-                                             F77_CHAR_ARG_LEN (1)));
-
-                  if (info != 0)
-                    info = -2;
-
-                  volatile double rcond_plus_one = rcon + 1.0;
-
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
-                    {
-                      info = -2;
-
-                      if (sing_handler)
-                        sing_handler (rcon);
-                      else
-                        warn_singular_matrix (rcon);
-                    }
-                }
+              info = -2;
+
+              if (sing_handler)
+                sing_handler (rcon);
+              else
+                warn_singular_matrix (rcon);
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::fsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
@@ -1754,17 +1699,18 @@ Matrix::fsolve (MatrixType &mattype, con
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
@@ -1965,20 +1911,17 @@ Matrix::solve (MatrixType &mattype, cons
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, info, rcon, sing_handler, true, transt);
   else if (transt == blas_trans || transt == blas_conj_trans)
     return transpose ().solve (mattype, b, info, rcon, sing_handler,
                                singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
@@ -2270,17 +2213,18 @@ Matrix::lssolve (const Matrix& b, octave
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m == 0 || n == 0 || b.cols () == 0)
+
+  if (m == 0 || n == 0 || b.cols () == 0)
     retval = Matrix (n, b.cols (), 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
       if (m != n)
         {
@@ -2465,17 +2409,18 @@ Matrix::lssolve (const ColumnVector& b, 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m == 0 || n == 0)
+
+  if (m == 0 || n == 0)
     retval = ColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
@@ -2714,18 +2659,17 @@ Matrix::diag (octave_idx_type m, octave_
   DiagMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 1 || nc == 1)
     retval = DiagMatrix (*this, m, n);
   else
-    (*current_liboctave_error_handler)
-      ("diag: expecting vector argument");
+    (*current_liboctave_error_handler) ("diag: expecting vector argument");
 
   return retval;
 }
 
 ColumnVector
 Matrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
@@ -3225,21 +3169,18 @@ min (const Matrix& m, double d)
 
 Matrix
 min (const Matrix& a, const Matrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg min requires same size arguments");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg min requires same size arguments");
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
@@ -3292,21 +3233,18 @@ max (const Matrix& m, double d)
 
 Matrix
 max (const Matrix& a, const Matrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg max requires same size arguments");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg max requires same size arguments");
 
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -762,31 +762,26 @@ NDArray::concat (const charNDArray& rb, 
   charNDArray retval (dims ());
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = elem (i);
 
       if (xisnan (d))
-        {
-          (*current_liboctave_error_handler)
-            ("invalid conversion from NaN to character");
-          return retval;
-        }
-      else
-        {
-          octave_idx_type ival = NINTbig (d);
+        (*current_liboctave_error_handler)
+          ("invalid conversion from NaN to character");
+
+      octave_idx_type ival = NINTbig (d);
 
-          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            // FIXME: is there something better to do? Should we warn the user?
-            ival = 0;
+      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+        // FIXME: is there something better to do? Should we warn the user?
+        ival = 0;
 
-          retval.elem (i) = static_cast<char>(ival);
-        }
+      retval.elem (i) = static_cast<char>(ival);
     }
 
   if (rb.is_empty ())
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -71,20 +71,17 @@ RowVector::operator != (const RowVector&
 }
 
 RowVector&
 RowVector::insert (const RowVector& a, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (c < 0 || c + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (c+i) = a.elem (i);
     }
@@ -109,20 +106,17 @@ RowVector::fill (double val)
 }
 
 RowVector&
 RowVector::fill (double val, octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -746,83 +746,81 @@ atan2 (const SparseMatrix& x, const doub
     }
   else
     return retval;
 }
 
 SparseMatrix
 atan2 (const SparseMatrix& x, const SparseMatrix& y)
 {
+  if ((x.rows () != y.rows ()) || (x.cols () != y.cols ()))
+    (*current_liboctave_error_handler) ("matrix size mismatch");
+
+  octave_idx_type x_nr = x.rows ();
+  octave_idx_type x_nc = x.cols ();
+
+  octave_idx_type y_nr = y.rows ();
+  octave_idx_type y_nc = y.cols ();
+
+  if (x_nr != y_nr || x_nc != y_nc)
+    err_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
+
   SparseMatrix r;
 
-  if ((x.rows () == y.rows ()) && (x.cols () == y.cols ()))
+  r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
+
+  octave_idx_type jx = 0;
+  r.cidx (0) = 0;
+  for (octave_idx_type i = 0 ; i < x_nc ; i++)
     {
-      octave_idx_type x_nr = x.rows ();
-      octave_idx_type x_nc = x.cols ();
-
-      octave_idx_type y_nr = y.rows ();
-      octave_idx_type y_nc = y.cols ();
-
-      if (x_nr != y_nr || x_nc != y_nc)
-        err_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
-
-      r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
-
-      octave_idx_type jx = 0;
-      r.cidx (0) = 0;
-      for (octave_idx_type i = 0 ; i < x_nc ; i++)
+      octave_idx_type  ja = x.cidx (i);
+      octave_idx_type  ja_max = x.cidx (i+1);
+      bool ja_lt_max= ja < ja_max;
+
+      octave_idx_type  jb = y.cidx (i);
+      octave_idx_type  jb_max = y.cidx (i+1);
+      bool jb_lt_max = jb < jb_max;
+
+      while (ja_lt_max || jb_lt_max)
         {
-          octave_idx_type  ja = x.cidx (i);
-          octave_idx_type  ja_max = x.cidx (i+1);
-          bool ja_lt_max= ja < ja_max;
-
-          octave_idx_type  jb = y.cidx (i);
-          octave_idx_type  jb_max = y.cidx (i+1);
-          bool jb_lt_max = jb < jb_max;
-
-          while (ja_lt_max || jb_lt_max)
-            {
-              octave_quit ();
-              if ((! jb_lt_max)
-                  || (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
+          octave_quit ();
+          if ((! jb_lt_max)
+              || (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
+            {
+              r.ridx (jx) = x.ridx (ja);
+              r.data (jx) = atan2 (x.data (ja), 0.);
+              jx++;
+              ja++;
+              ja_lt_max= ja < ja_max;
+            }
+          else if ((! ja_lt_max)
+                   || (jb_lt_max && (y.ridx (jb) < x.ridx (ja))))
+            {
+              jb++;
+              jb_lt_max= jb < jb_max;
+            }
+          else
+            {
+              double tmp = atan2 (x.data (ja), y.data (jb));
+              if (tmp != 0.)
                 {
+                  r.data (jx) = tmp;
                   r.ridx (jx) = x.ridx (ja);
-                  r.data (jx) = atan2 (x.data (ja), 0.);
                   jx++;
-                  ja++;
-                  ja_lt_max= ja < ja_max;
-                }
-              else if ((! ja_lt_max)
-                       || (jb_lt_max && (y.ridx (jb) < x.ridx (ja))))
-                {
-                  jb++;
-                  jb_lt_max= jb < jb_max;
                 }
-              else
-                {
-                  double tmp = atan2 (x.data (ja), y.data (jb));
-                  if (tmp != 0.)
-                    {
-                      r.data (jx) = tmp;
-                      r.ridx (jx) = x.ridx (ja);
-                      jx++;
-                    }
-                  ja++;
-                  ja_lt_max= ja < ja_max;
-                  jb++;
-                  jb_lt_max= jb < jb_max;
-                }
-            }
-          r.cidx (i+1) = jx;
+              ja++;
+              ja_lt_max= ja < ja_max;
+              jb++;
+              jb_lt_max= jb < jb_max;
+            }
         }
-
-      r.maybe_compress ();
+      r.cidx (i+1) = jx;
     }
-  else
-    (*current_liboctave_error_handler) ("matrix size mismatch");
+
+  r.maybe_compress ();
 
   return r;
 }
 
 SparseMatrix
 SparseMatrix::inverse (void) const
 {
   octave_idx_type info;
@@ -854,326 +852,299 @@ SparseMatrix::dinverse (MatrixType &matt
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
+
+  // Print spparms("spumoni") info if requested
+  int typ = mattyp.type ();
+  mattyp.info ();
+
+  if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+    (*current_liboctave_error_handler) ("incorrect matrix type");
+
+  if (typ == MatrixType::Permuted_Diagonal)
+    retval = transpose ();
   else
+    retval = *this;
+
+  // Force make_unique to be called
+  double *v = retval.data ();
+
+  if (calccond)
     {
-      // Print spparms("spumoni") info if requested
-      int typ = mattyp.type ();
-      mattyp.info ();
-
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+      double dmax = 0.;
+      double dmin = octave_Inf;
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          if (typ == MatrixType::Permuted_Diagonal)
-            retval = transpose ();
-          else
-            retval = *this;
-
-          // Force make_unique to be called
-          double *v = retval.data ();
-
-          if (calccond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nr; i++)
-                {
-                  double tmp = fabs (v[i]);
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
-                }
-              rcond = dmin / dmax;
-            }
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            v[i] = 1.0 / v[i];
+          double tmp = fabs (v[i]);
+          if (tmp > dmax)
+            dmax = tmp;
+          if (tmp < dmin)
+            dmin = tmp;
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+      rcond = dmin / dmax;
     }
 
+  for (octave_idx_type i = 0; i < nr; i++)
+    v[i] = 1.0 / v[i];
+
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info,
                         double& rcond, const bool,
                         const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
-  else
+
+  // Print spparms("spumoni") info if requested
+  int typ = mattyp.type ();
+  mattyp.info ();
+
+  if (typ != MatrixType::Upper && typ != MatrixType::Permuted_Upper
+      && typ != MatrixType::Lower && typ != MatrixType::Permuted_Lower)
+    (*current_liboctave_error_handler) ("incorrect matrix type");
+
+  double anorm = 0.;
+  double ainvnorm = 0.;
+
+  if (calccond)
     {
-      // Print spparms("spumoni") info if requested
-      int typ = mattyp.type ();
-      mattyp.info ();
-
-      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper
-          || typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
+      // Calculate the 1-norm of matrix for rcond calculation
+      for (octave_idx_type j = 0; j < nr; j++)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-
-          if (calccond)
-            {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nr; j++)
-                {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-            {
-              octave_idx_type nz = nnz ();
-              octave_idx_type cx = 0;
-              octave_idx_type nz2 = nz;
-              retval = SparseMatrix (nr, nc, nz2);
-
-              for (octave_idx_type i = 0; i < nr; i++)
+          double atmp = 0.;
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            atmp += fabs (data (i));
+          if (atmp > anorm)
+            anorm = atmp;
+        }
+    }
+
+  if (typ == MatrixType::Upper || typ == MatrixType::Lower)
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type cx = 0;
+      octave_idx_type nz2 = nz;
+      retval = SparseMatrix (nr, nc, nz2);
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          octave_quit ();
+          // place the 1 in the identity position
+          octave_idx_type cx_colstart = cx;
+
+          if (cx == nz2)
+            {
+              nz2 *= 2;
+              retval.change_capacity (nz2);
+            }
+
+          retval.xcidx (i) = cx;
+          retval.xridx (cx) = i;
+          retval.xdata (cx) = 1.0;
+          cx++;
+
+          // iterate accross columns of input matrix
+          for (octave_idx_type j = i+1; j < nr; j++)
+            {
+              double v = 0.;
+              // iterate to calculate sum
+              octave_idx_type colXp = retval.xcidx (i);
+              octave_idx_type colUp = cidx (j);
+              octave_idx_type rpX, rpU;
+
+              if (cidx (j) == cidx (j+1))
+                (*current_liboctave_error_handler) ("division by zero");
+
+              do
                 {
                   octave_quit ();
-                  // place the 1 in the identity position
-                  octave_idx_type cx_colstart = cx;
-
+                  rpX = retval.xridx (colXp);
+                  rpU = ridx (colUp);
+
+                  if (rpX < rpU)
+                    colXp++;
+                  else if (rpX > rpU)
+                    colUp++;
+                  else
+                    {
+                      v -= retval.xdata (colXp) * data (colUp);
+                      colXp++;
+                      colUp++;
+                    }
+                }
+              while (rpX < j && rpU < j && colXp < cx && colUp < nz);
+
+              // get A(m,m)
+              if (typ == MatrixType::Upper)
+                colUp = cidx (j+1) - 1;
+              else
+                colUp = cidx (j);
+              double pivot = data (colUp);
+              if (pivot == 0. || ridx (colUp) != j)
+                (*current_liboctave_error_handler) ("division by zero");
+
+              if (v != 0.)
+                {
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx (i) = cx;
-                  retval.xridx (cx) = i;
-                  retval.xdata (cx) = 1.0;
+                  retval.xridx (cx) = j;
+                  retval.xdata (cx) = v / pivot;
                   cx++;
-
-                  // iterate accross columns of input matrix
-                  for (octave_idx_type j = i+1; j < nr; j++)
-                    {
-                      double v = 0.;
-                      // iterate to calculate sum
-                      octave_idx_type colXp = retval.xcidx (i);
-                      octave_idx_type colUp = cidx (j);
-                      octave_idx_type rpX, rpU;
-
-                      if (cidx (j) == cidx (j+1))
-                        {
-                          (*current_liboctave_error_handler)
-                            ("division by zero");
-                          goto inverse_singular;
-                        }
-
-                      do
-                        {
-                          octave_quit ();
-                          rpX = retval.xridx (colXp);
-                          rpU = ridx (colUp);
-
-                          if (rpX < rpU)
-                            colXp++;
-                          else if (rpX > rpU)
-                            colUp++;
-                          else
-                            {
-                              v -= retval.xdata (colXp) * data (colUp);
-                              colXp++;
-                              colUp++;
-                            }
-                        }
-                      while (rpX < j && rpU < j && colXp < cx && colUp < nz);
-
-                      // get A(m,m)
-                      if (typ == MatrixType::Upper)
-                        colUp = cidx (j+1) - 1;
-                      else
-                        colUp = cidx (j);
-                      double pivot = data (colUp);
-                      if (pivot == 0. || ridx (colUp) != j)
-                        {
-                          (*current_liboctave_error_handler)
-                            ("division by zero");
-                          goto inverse_singular;
-                        }
-
-                      if (v != 0.)
-                        {
-                          if (cx == nz2)
-                            {
-                              nz2 *= 2;
-                              retval.change_capacity (nz2);
-                            }
-
-                          retval.xridx (cx) = j;
-                          retval.xdata (cx) = v / pivot;
-                          cx++;
-                        }
-                    }
-
-                  // get A(m,m)
-                  octave_idx_type colUp;
-                  if (typ == MatrixType::Upper)
-                    colUp = cidx (i+1) - 1;
-                  else
-                    colUp = cidx (i);
-                  double pivot = data (colUp);
-                  if (pivot == 0. || ridx (colUp) != i)
-                    {
-                      (*current_liboctave_error_handler) ("division by zero");
-                      goto inverse_singular;
-                    }
-
-                  if (pivot != 1.0)
-                    for (octave_idx_type j = cx_colstart; j < cx; j++)
-                      retval.xdata (j) /= pivot;
                 }
-              retval.xcidx (nr) = cx;
-              retval.maybe_compress ();
-            }
+            }
+
+          // get A(m,m)
+          octave_idx_type colUp;
+          if (typ == MatrixType::Upper)
+            colUp = cidx (i+1) - 1;
           else
-            {
-              octave_idx_type nz = nnz ();
-              octave_idx_type cx = 0;
-              octave_idx_type nz2 = nz;
-              retval = SparseMatrix (nr, nc, nz2);
-
-              OCTAVE_LOCAL_BUFFER (double, work, nr);
-              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-
-              octave_idx_type *perm = mattyp.triangular_perm ();
-              if (typ == MatrixType::Permuted_Upper)
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    rperm[perm[i]] = i;
-                }
-              else
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    rperm[i] = perm[i];
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    perm[rperm[i]] = i;
-                }
-
-              for (octave_idx_type i = 0; i < nr; i++)
+            colUp = cidx (i);
+          double pivot = data (colUp);
+          if (pivot == 0. || ridx (colUp) != i)
+            (*current_liboctave_error_handler) ("division by zero");
+
+          if (pivot != 1.0)
+            for (octave_idx_type j = cx_colstart; j < cx; j++)
+              retval.xdata (j) /= pivot;
+        }
+      retval.xcidx (nr) = cx;
+      retval.maybe_compress ();
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type cx = 0;
+      octave_idx_type nz2 = nz;
+      retval = SparseMatrix (nr, nc, nz2);
+
+      OCTAVE_LOCAL_BUFFER (double, work, nr);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+
+      octave_idx_type *perm = mattyp.triangular_perm ();
+      if (typ == MatrixType::Permuted_Upper)
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            rperm[perm[i]] = i;
+        }
+      else
+        {
+          for (octave_idx_type i = 0; i < nr; i++)
+            rperm[i] = perm[i];
+          for (octave_idx_type i = 0; i < nr; i++)
+            perm[rperm[i]] = i;
+        }
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          octave_quit ();
+          octave_idx_type iidx = rperm[i];
+
+          for (octave_idx_type j = 0; j < nr; j++)
+            work[j] = 0.;
+
+          // place the 1 in the identity position
+          work[iidx] = 1.0;
+
+          // iterate accross columns of input matrix
+          for (octave_idx_type j = iidx+1; j < nr; j++)
+            {
+              double v = 0.;
+              octave_idx_type jidx = perm[j];
+              // iterate to calculate sum
+              for (octave_idx_type k = cidx (jidx);
+                   k < cidx (jidx+1); k++)
                 {
                   octave_quit ();
-                  octave_idx_type iidx = rperm[i];
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    work[j] = 0.;
-
-                  // place the 1 in the identity position
-                  work[iidx] = 1.0;
-
-                  // iterate accross columns of input matrix
-                  for (octave_idx_type j = iidx+1; j < nr; j++)
-                    {
-                      double v = 0.;
-                      octave_idx_type jidx = perm[j];
-                      // iterate to calculate sum
-                      for (octave_idx_type k = cidx (jidx);
-                           k < cidx (jidx+1); k++)
-                        {
-                          octave_quit ();
-                          v -= work[ridx (k)] * data (k);
-                        }
-
-                      // get A(m,m)
-                      double pivot;
-                      if (typ == MatrixType::Permuted_Upper)
-                        pivot = data (cidx (jidx+1) - 1);
-                      else
-                        pivot = data (cidx (jidx));
-                      if (pivot == 0.)
-                        {
-                          (*current_liboctave_error_handler)
-                            ("division by zero");
-                          goto inverse_singular;
-                        }
-
-                      work[j] = v / pivot;
-                    }
-
-                  // get A(m,m)
-                  octave_idx_type colUp;
-                  if (typ == MatrixType::Permuted_Upper)
-                    colUp = cidx (perm[iidx]+1) - 1;
-                  else
-                    colUp = cidx (perm[iidx]);
-
-                  double pivot = data (colUp);
-                  if (pivot == 0.)
-                    {
-                      (*current_liboctave_error_handler)
-                        ("division by zero");
-                      goto inverse_singular;
-                    }
-
-                  octave_idx_type new_cx = cx;
-                  for (octave_idx_type j = iidx; j < nr; j++)
-                    if (work[j] != 0.0)
-                      {
-                        new_cx++;
-                        if (pivot != 1.0)
-                          work[j] /= pivot;
-                      }
-
-                  if (cx < new_cx)
-                    {
-                      nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
-                      retval.change_capacity (nz2);
-                    }
-
-                  retval.xcidx (i) = cx;
-                  for (octave_idx_type j = iidx; j < nr; j++)
-                    if (work[j] != 0.)
-                      {
-                        retval.xridx (cx) = j;
-                        retval.xdata (cx++) = work[j];
-                      }
+                  v -= work[ridx (k)] * data (k);
                 }
 
-              retval.xcidx (nr) = cx;
-              retval.maybe_compress ();
-            }
-
-          if (calccond)
-            {
-              // Calculate the 1-norm of inverse matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nr; j++)
-                {
-                  double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx (j);
-                       i < retval.cidx (j+1); i++)
-                    atmp += fabs (retval.data (i));
-                  if (atmp > ainvnorm)
-                    ainvnorm = atmp;
-                }
-
-              rcond = 1. / ainvnorm / anorm;
-            }
+              // get A(m,m)
+              double pivot;
+              if (typ == MatrixType::Permuted_Upper)
+                pivot = data (cidx (jidx+1) - 1);
+              else
+                pivot = data (cidx (jidx));
+              if (pivot == 0.)
+                  (*current_liboctave_error_handler) ("division by zero");
+
+              work[j] = v / pivot;
+            }
+
+          // get A(m,m)
+          octave_idx_type colUp;
+          if (typ == MatrixType::Permuted_Upper)
+            colUp = cidx (perm[iidx]+1) - 1;
+          else
+            colUp = cidx (perm[iidx]);
+
+          double pivot = data (colUp);
+          if (pivot == 0.)
+            (*current_liboctave_error_handler) ("division by zero");
+
+          octave_idx_type new_cx = cx;
+          for (octave_idx_type j = iidx; j < nr; j++)
+            if (work[j] != 0.0)
+              {
+                new_cx++;
+                if (pivot != 1.0)
+                  work[j] /= pivot;
+              }
+
+          if (cx < new_cx)
+            {
+              nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
+              retval.change_capacity (nz2);
+            }
+
+          retval.xcidx (i) = cx;
+          for (octave_idx_type j = iidx; j < nr; j++)
+            if (work[j] != 0.)
+              {
+                retval.xridx (cx) = j;
+                retval.xdata (cx++) = work[j];
+              }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      retval.xcidx (nr) = cx;
+      retval.maybe_compress ();
+    }
+
+  if (calccond)
+    {
+      // Calculate the 1-norm of inverse matrix for rcond calculation
+      for (octave_idx_type j = 0; j < nr; j++)
+        {
+          double atmp = 0.;
+          for (octave_idx_type i = retval.cidx (j);
+               i < retval.cidx (j+1); i++)
+            atmp += fabs (retval.data (i));
+          if (atmp > ainvnorm)
+            ainvnorm = atmp;
+        }
+
+      rcond = 1. / ainvnorm / anorm;
     }
 
   return retval;
 
 inverse_singular:
   return SparseMatrix ();
 }
 
@@ -1307,61 +1278,60 @@ SparseMatrix::determinant (octave_idx_ty
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai,
                                               Ax, 0, &Symbolic, control, info);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler)
-            ("SparseMatrix::determinant symbolic factorization failed");
-
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           UMFPACK_DNAME (free_symbolic) (&Symbolic);
+
+          (*current_liboctave_error_handler)
+            ("SparseMatrix::determinant symbolic factorization failed");
         }
       else
         {
           UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
                                             &Numeric, control, info);
           UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler)
-                ("SparseMatrix::determinant numeric factorization failed");
-
               UMFPACK_DNAME (report_status) (control, status);
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
+              (*current_liboctave_error_handler)
+                ("SparseMatrix::determinant numeric factorization failed");
             }
           else
             {
               UMFPACK_DNAME (report_numeric) (Numeric, control);
 
               double c10, e10;
 
               status = UMFPACK_DNAME (get_determinant) (&c10, &e10, Numeric,
                                                         info);
 
               if (status < 0)
                 {
+                  UMFPACK_DNAME (report_status) (control, status);
+                  UMFPACK_DNAME (report_info) (control, info);
+
                   (*current_liboctave_error_handler)
                     ("SparseMatrix::determinant error calculating determinant");
-
-                  UMFPACK_DNAME (report_status) (control, status);
-                  UMFPACK_DNAME (report_info) (control, info);
                 }
               else
                 retval = DET (c10, e10, 10);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
         }
     }
@@ -1386,56 +1356,55 @@ SparseMatrix::dsolve (MatrixType &mattyp
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      retval.resize (nc, b.cols (), 0.);
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type i = 0; i < nm; i++)
+            retval(i,j) = b(i,j) / data (i);
+      else
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type k = 0; k < nc; k++)
+            for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+              retval(k,j) = b(ridx (i),j) / data (i);
+
+      if (calc_cond)
         {
-          retval.resize (nc, b.cols (), 0.);
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type i = 0; i < nm; i++)
-                retval(i,j) = b(i,j) / data (i);
-          else
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
-                  retval(k,j) = b(ridx (i),j) / data (i);
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nm; i++)
-                {
-                  double tmp = fabs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
-                }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.;
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              double tmp = fabs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.;
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
                       octave_idx_type& err, double& rcond,
@@ -1446,86 +1415,85 @@ SparseMatrix::dsolve (MatrixType &mattyp
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
-        {
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseMatrix (nc, b_nc, b_nz);
-
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b_nc; j++)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseMatrix (nc, b_nc, b_nz);
+
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b_nc; j++)
+          {
+            for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
               {
-                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                  {
-                    if (b.ridx (i) >= nm)
-                      break;
-                    retval.xridx (ii) = b.ridx (i);
-                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
-                  }
-                retval.xcidx (j+1) = ii;
+                if (b.ridx (i) >= nm)
+                  break;
+                retval.xridx (ii) = b.ridx (i);
+                retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
               }
-          else
-            for (octave_idx_type j = 0; j < b_nc; j++)
-              {
-                for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+            retval.xcidx (j+1) = ii;
+          }
+      else
+        for (octave_idx_type j = 0; j < b_nc; j++)
+          {
+            for (octave_idx_type l = 0; l < nc; l++)
+              for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+                {
+                  bool found = false;
+                  octave_idx_type k;
+                  for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                    if (ridx (i) == b.ridx (k))
+                      {
+                        found = true;
+                        break;
+                      }
+                  if (found)
                     {
-                      bool found = false;
-                      octave_idx_type k;
-                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
-                        if (ridx (i) == b.ridx (k))
-                          {
-                            found = true;
-                            break;
-                          }
-                      if (found)
-                        {
-                          retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data (k) / data (i);
-                        }
+                      retval.xridx (ii) = l;
+                      retval.xdata (ii++) = b.data (k) / data (i);
                     }
-                retval.xcidx (j+1) = ii;
-              }
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nm; i++)
-                {
-                  double tmp = fabs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
                 }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.;
+            retval.xcidx (j+1) = ii;
+          }
+
+      if (calc_cond)
+        {
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              double tmp = fabs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.;
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
@@ -1536,56 +1504,55 @@ SparseMatrix::dsolve (MatrixType &mattyp
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      retval.resize (nc, b.cols (), 0);
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type i = 0; i < nm; i++)
+            retval(i,j) = b(i,j) / data (i);
+      else
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          for (octave_idx_type k = 0; k < nc; k++)
+            for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+              retval(k,j) = b(ridx (i),j) / data (i);
+
+      if (calc_cond)
         {
-          retval.resize (nc, b.cols (), 0);
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type i = 0; i < nm; i++)
-                retval(i,j) = b(i,j) / data (i);
-          else
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
-                  retval(k,j) = b(ridx (i),j) / data (i);
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nm; i++)
-                {
-                  double tmp = fabs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
-                }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.;
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              double tmp = fabs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.;
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
@@ -1596,86 +1563,85 @@ SparseMatrix::dsolve (MatrixType &mattyp
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
-        {
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols (); j++)
+      if (typ != MatrixType::Diagonal && typ != MatrixType::Permuted_Diagonal)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      if (typ == MatrixType::Diagonal)
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          {
+            for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
               {
-                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                  {
-                    if (b.ridx (i) >= nm)
-                      break;
-                    retval.xridx (ii) = b.ridx (i);
-                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
-                  }
-                retval.xcidx (j+1) = ii;
+                if (b.ridx (i) >= nm)
+                  break;
+                retval.xridx (ii) = b.ridx (i);
+                retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
               }
-          else
-            for (octave_idx_type j = 0; j < b.cols (); j++)
-              {
-                for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+            retval.xcidx (j+1) = ii;
+          }
+      else
+        for (octave_idx_type j = 0; j < b.cols (); j++)
+          {
+            for (octave_idx_type l = 0; l < nc; l++)
+              for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
+                {
+                  bool found = false;
+                  octave_idx_type k;
+                  for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                    if (ridx (i) == b.ridx (k))
+                      {
+                        found = true;
+                        break;
+                      }
+                  if (found)
                     {
-                      bool found = false;
-                      octave_idx_type k;
-                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
-                        if (ridx (i) == b.ridx (k))
-                          {
-                            found = true;
-                            break;
-                          }
-                      if (found)
-                        {
-                          retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data (k) / data (i);
-                        }
+                      retval.xridx (ii) = l;
+                      retval.xdata (ii++) = b.data (k) / data (i);
                     }
-                retval.xcidx (j+1) = ii;
-              }
-
-          if (calc_cond)
-            {
-              double dmax = 0.;
-              double dmin = octave_Inf;
-              for (octave_idx_type i = 0; i < nm; i++)
-                {
-                  double tmp = fabs (data (i));
-                  if (tmp > dmax)
-                    dmax = tmp;
-                  if (tmp < dmin)
-                    dmin = tmp;
                 }
-              rcond = dmin / dmax;
-            }
-          else
-            rcond = 1.;
+            retval.xcidx (j+1) = ii;
+          }
+
+      if (calc_cond)
+        {
+          double dmax = 0.;
+          double dmin = octave_Inf;
+          for (octave_idx_type i = 0; i < nm; i++)
+            {
+              double tmp = fabs (data (i));
+              if (tmp > dmax)
+                dmax = tmp;
+              if (tmp < dmin)
+                dmin = tmp;
+            }
+          rcond = dmin / dmax;
         }
       else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+        rcond = 1.;
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::utsolve (MatrixType &mattype, const Matrix& b,
                        octave_idx_type& err, double& rcond,
@@ -1687,225 +1653,224 @@ SparseMatrix::utsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      double tmp = work[k] / data (cidx (kidx+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (perm[i], j) = work[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              retval.resize (nc, b_nc);
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
+                      octave_idx_type iidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          double tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          double tmp = work[k] / data (cidx (kidx+1)-1);
-                          work[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              work[iidx] = work[iidx] - tmp * data (i);
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (perm[i], j) = work[i];
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
+                    {
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+          retval.resize (nc, b_nc);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (work[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
                         {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
+                          err = -2;
+                          goto triangular_error;
                         }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
+
+                      double tmp = work[k] / data (cidx (k+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                         {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
                         }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-              retval.resize (nc, b_nc);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = work[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
                        octave_idx_type& err, double& rcond,
@@ -1917,278 +1882,277 @@ SparseMatrix::utsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+          for (octave_idx_type i = 0; i < nc; i++)
+            rperm[perm[i]] = i;
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      double tmp = work[k] / data (cidx (kidx+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[rperm[i]] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[rperm[i]];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-              for (octave_idx_type i = 0; i < nc; i++)
-                rperm[perm[i]] = i;
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
+                      octave_idx_type iidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          double tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
-
-                          double tmp = work[k] / data (cidx (kidx+1)-1);
+                        }
+                    }
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
+                    {
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  if (work[k] != 0.)
+                    {
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      double tmp = work[k] / data (cidx (k+1)-1);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
+                    {
+                      if (work[k] != 0.)
+                        {
+                          double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[rperm[i]] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[rperm[i]];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
             }
           else
-            {
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
-                    {
-                      if (work[k] != 0.)
-                        {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          double tmp = work[k] / data (cidx (k+1)-1);
-                          work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              work[iidx] = work[iidx] - tmp * data (i);
-                            }
-                        }
-                    }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
-                    {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
+            warn_singular_matrix (rcond);
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
@@ -2199,228 +2163,227 @@ SparseMatrix::utsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                cwork[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                cwork[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (cwork[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          cwork[iidx] = cwork[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (perm[i], j) = cwork[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
-                {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              retval.resize (nc, b_nc);
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    cwork[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    cwork[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
-
-                      if (cwork[k] != 0.)
+                      octave_idx_type iidx = perm[k];
+
+                      if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          double tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              cwork[iidx] = cwork[iidx] - tmp * data (i);
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (perm[i], j) = cwork[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
+                }
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+          retval.resize (nc, b_nc);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                cwork[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                cwork[i] = 0.;
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  if (cwork[k] != 0.)
+                    {
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
                         {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
+                          err = -2;
+                          goto triangular_error;
                         }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+
+                      Complex tmp = cwork[k] / data (cidx (k+1)-1);
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          cwork[iidx] = cwork[iidx] - tmp  * data (i);
+                        }
                     }
-                  rcond = 1. / ainvnorm / anorm;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-              retval.resize (nc, b_nc);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = cwork[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    cwork[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    cwork[i] = 0.;
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      if (cwork[k] != 0.)
+                      if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (cidx (k+1)-1);
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                          double tmp = work[k] / data (cidx (k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
-                              cwork[iidx] = cwork[iidx] - tmp  * data (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = cwork[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
@@ -2432,280 +2395,279 @@ SparseMatrix::utsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
+      if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Upper)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          octave_idx_type *perm = mattype.triangular_perm ();
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+          for (octave_idx_type i = 0; i < nc; i++)
+            rperm[perm[i]] = i;
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                cwork[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                cwork[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
+                {
+                  octave_idx_type kidx = perm[k];
+
+                  if (cwork[k] != 0.)
+                    {
+                      if (ridx (cidx (kidx+1)-1) != k
+                          || data (cidx (kidx+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (kidx);
+                           i < cidx (kidx+1)-1; i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          cwork[iidx] = cwork[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[rperm[i]] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = cwork[rperm[i]];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Upper)
-            {
-              octave_idx_type *perm = mattype.triangular_perm ();
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-              OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
-              for (octave_idx_type i = 0; i < nc; i++)
-                rperm[perm[i]] = i;
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    cwork[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      octave_idx_type kidx = perm[k];
-
-                      if (cwork[k] != 0.)
+                      octave_idx_type iidx = perm[k];
+
+                      if (work[k] != 0.)
                         {
-                          if (ridx (cidx (kidx+1)-1) != k
-                              || data (cidx (kidx+1)-1) == 0.)
+                          double tmp = work[k] / data (cidx (iidx+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (iidx);
+                               i < cidx (iidx+1)-1; i++)
                             {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (kidx);
-                               i < cidx (kidx+1)-1; i++)
-                            {
-                              octave_idx_type iidx = ridx (i);
-                              cwork[iidx] = cwork[iidx] - tmp * data (i);
+                              octave_idx_type idx2 = ridx (i);
+                              work[idx2] = work[idx2] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[rperm[i]] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = cwork[rperm[i]];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                cwork[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                cwork[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = nc-1; k >= 0; k--)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (cwork[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
+                      if (ridx (cidx (k+1)-1) != k
+                          || data (cidx (k+1)-1) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = cwork[k] / data (cidx (k+1)-1);
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                         {
-                          octave_idx_type iidx = perm[k];
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (iidx+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (iidx);
-                                   i < cidx (iidx+1)-1; i++)
-                                {
-                                  octave_idx_type idx2 = ridx (i);
-                                  work[idx2] = work[idx2] - tmp * data (i);
-                                }
-                            }
+                          octave_idx_type iidx = ridx (i);
+                          cwork[iidx] = cwork[iidx] - tmp * data (i);
                         }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = cwork[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    cwork[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = nc-1; k >= 0; k--)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k >= 0; k--)
                     {
-                      if (cwork[k] != 0.)
+                      if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k+1)-1) != k
-                              || data (cidx (k+1)-1) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (cidx (k+1)-1);
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
+                          double tmp = work[k] / data (cidx (k+1)-1);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
-                              cwork[iidx] = cwork[iidx] - tmp * data (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = cwork[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = 0; i < j+1; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k >= 0; k--)
-                        {
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k+1)-1);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1)-1; i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = 0; i < j+1; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
                        octave_idx_type& err, double& rcond,
@@ -2717,249 +2679,248 @@ SparseMatrix::ltsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              if (nc > nr)
+                for (octave_idx_type i = 0; i < nm; i++)
+                  work[i] = 0.;
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[perm[i]] = b(i,j);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (work[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      double tmp = work[k] / data (mini);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval(i, j) = work[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              retval.resize (nc, b_nc);
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  if (nc > nr)
-                    for (octave_idx_type i = 0; i < nm; i++)
-                      work[i] = 0.;
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[perm[i]] = b(i,j);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           double tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval(i, j) = work[i];
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
+                    {
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+          retval.resize (nc, b_nc, 0.);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                work[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                work[i] = 0.;
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (work[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              double tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      double tmp = work[k] / data (cidx (k));
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1;
+                           i < cidx (k+1); i++)
+                        {
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
                         }
-
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-              retval.resize (nc, b_nc, 0.);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = work[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    work[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type k = 0; k < nc; k++)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
                     {
+
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx (k)+1;
                                i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = work[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
                        octave_idx_type& err, double& rcond,
@@ -2971,296 +2932,295 @@ SparseMatrix::ltsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[perm[b.ridx (i)]] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (work[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      double tmp = work[k] / data (mini);
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          work[iidx] = work[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[perm[b.ridx (i)]] = b.data (i);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           double tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nr; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                work[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (work[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      double tmp = work[k] / data (cidx (k));
+                      work[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              double tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          octave_idx_type iidx = ridx (i);
+                          work[iidx] = work[iidx] - tmp * data (i);
                         }
-
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nr; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (double, work, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (work[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = work[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    work[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = 0; k < nc; k++)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
                     {
+
                       if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
                           double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (work[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = work[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
@@ -3272,250 +3232,249 @@ SparseMatrix::ltsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      octave_idx_type b_nc = b.cols ();
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          octave_idx_type b_nc = b.cols ();
-          rcond = 1.;
+          retval.resize (nc, b_nc);
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                cwork[i] = 0.;
+              for (octave_idx_type i = 0; i < nr; i++)
+                cwork[perm[i]] = b(i,j);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (cwork[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = cwork[k] / data (mini);
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          cwork[iidx] = cwork[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval(i, j) = cwork[i];
+            }
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              retval.resize (nc, b_nc);
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    cwork[i] = 0.;
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    cwork[perm[i]] = b(i,j);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
-                      if (cwork[k] != 0.)
+                      if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (mini);
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          double tmp = work[k] / data (mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
-                              cwork[iidx] = cwork[iidx] - tmp * data (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval(i, j) = cwork[i];
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
+                    {
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
+                    }
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+          retval.resize (nc, b_nc, 0.);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nr; i++)
+                cwork[i] = b(i,j);
+              for (octave_idx_type i = nr; i < nc; i++)
+                cwork[i] = 0.;
+
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (cwork[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              double tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          err = -2;
+                          goto triangular_error;
                         }
 
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
+                      Complex tmp = cwork[k] / data (cidx (k));
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                         {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
+                          octave_idx_type iidx = ridx (i);
+                          cwork[iidx] = cwork[iidx] - tmp * data (i);
                         }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
                     }
-                  rcond = 1. / ainvnorm / anorm;
                 }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-              retval.resize (nc, b_nc, 0.);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                retval.xelem (i, j) = cwork[i];
+            }
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    cwork[i] = b(i,j);
-                  for (octave_idx_type i = nr; i < nc; i++)
-                    cwork[i] = 0.;
-
-                  for (octave_idx_type k = 0; k < nc; k++)
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
                     {
-                      if (cwork[k] != 0.)
+
+                      if (work[k] != 0.)
                         {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (cidx (k));
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                          double tmp = work[k] / data (cidx (k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
-                              cwork[iidx] = cwork[iidx] - tmp * data (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    retval.xelem (i, j) = cwork[i];
-                }
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                        octave_idx_type& err, double& rcond,
@@ -3527,298 +3486,297 @@ SparseMatrix::ltsolve (MatrixType &matty
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
-      if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
+      if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
+        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+      double anorm = 0.;
+      double ainvnorm = 0.;
+      rcond = 1.;
+
+      if (calc_cond)
+        {
+          // Calculate the 1-norm of matrix for rcond calculation
+          for (octave_idx_type j = 0; j < nc; j++)
+            {
+              double atmp = 0.;
+              for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                atmp += fabs (data (i));
+              if (atmp > anorm)
+                anorm = atmp;
+            }
+        }
+
+      octave_idx_type b_nc = b.cols ();
+      octave_idx_type b_nz = b.nnz ();
+      retval = SparseComplexMatrix (nc, b_nc, b_nz);
+      retval.xcidx (0) = 0;
+      octave_idx_type ii = 0;
+      octave_idx_type x_nz = b_nz;
+
+      if (typ == MatrixType::Permuted_Lower)
         {
-          double anorm = 0.;
-          double ainvnorm = 0.;
-          rcond = 1.;
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+          octave_idx_type *perm = mattype.triangular_perm ();
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                cwork[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                cwork[perm[b.ridx (i)]] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
+                {
+                  if (cwork[k] != 0.)
+                    {
+                      octave_idx_type minr = nr;
+                      octave_idx_type mini = 0;
+
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        if (perm[ridx (i)] < minr)
+                          {
+                            minr = perm[ridx (i)];
+                            mini = i;
+                          }
+
+                      if (minr != k || data (mini) == 0)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = cwork[k] / data (mini);
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                        {
+                          if (i == mini)
+                            continue;
+
+                          octave_idx_type iidx = perm[ridx (i)];
+                          cwork[iidx] = cwork[iidx] - tmp * data (i);
+                        }
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = cwork[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
 
           if (calc_cond)
             {
-              // Calculate the 1-norm of matrix for rcond calculation
-              for (octave_idx_type j = 0; j < nc; j++)
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
                 {
-                  double atmp = 0.;
-                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
-                    atmp += fabs (data (i));
-                  if (atmp > anorm)
-                    anorm = atmp;
-                }
-            }
-
-          octave_idx_type b_nc = b.cols ();
-          octave_idx_type b_nz = b.nnz ();
-          retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx (0) = 0;
-          octave_idx_type ii = 0;
-          octave_idx_type x_nz = b_nz;
-
-          if (typ == MatrixType::Permuted_Lower)
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-              octave_idx_type *perm = mattype.triangular_perm ();
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    cwork[perm[b.ridx (i)]] = b.data (i);
+                  work[j] = 1.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
-                      if (cwork[k] != 0.)
+                      if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             if (perm[ridx (i)] < minr)
                               {
                                 minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data (mini) == 0)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (mini);
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                          double tmp = work[k] / data (mini);
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (k);
+                               i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
-                              cwork[iidx] = cwork[iidx] - tmp * data (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = cwork[i];
-                      }
-                  retval.xcidx (j+1) = ii;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
+              rcond = 1. / ainvnorm / anorm;
+            }
+        }
+      else
+        {
+          OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+          for (octave_idx_type j = 0; j < b_nc; j++)
+            {
+              for (octave_idx_type i = 0; i < nm; i++)
+                cwork[i] = 0.;
+              for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                cwork[b.ridx (i)] = b.data (i);
+
+              for (octave_idx_type k = 0; k < nc; k++)
                 {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  if (cwork[k] != 0.)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = 0; k < nc; k++)
+                      if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
+                        {
+                          err = -2;
+                          goto triangular_error;
+                        }
+
+                      Complex tmp = cwork[k] / data (cidx (k));
+                      cwork[k] = tmp;
+                      for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                         {
-                          if (work[k] != 0.)
-                            {
-                              octave_idx_type minr = nr;
-                              octave_idx_type mini = 0;
-
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                if (perm[ridx (i)] < minr)
-                                  {
-                                    minr = perm[ridx (i)];
-                                    mini = i;
-                                  }
-
-                              double tmp = work[k] / data (mini);
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k);
-                                   i < cidx (k+1); i++)
-                                {
-                                  if (i == mini)
-                                    continue;
-
-                                  octave_idx_type iidx = perm[ridx (i)];
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
+                          octave_idx_type iidx = ridx (i);
+                          cwork[iidx] = cwork[iidx] - tmp * data (i);
                         }
-
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
+                    }
+                }
+
+              // Count nonzeros in work vector and adjust space in
+              // retval if needed
+              octave_idx_type new_nnz = 0;
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[i] != 0.)
+                  new_nnz++;
+
+              if (ii + new_nnz > x_nz)
+                {
+                  // Resize the sparse matrix
+                  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+                  retval.change_capacity (sz);
+                  x_nz = sz;
+                }
+
+              for (octave_idx_type i = 0; i < nc; i++)
+                if (cwork[i] != 0.)
+                  {
+                    retval.xridx (ii) = i;
+                    retval.xdata (ii++) = cwork[i];
+                  }
+              retval.xcidx (j+1) = ii;
+            }
+
+          retval.maybe_compress ();
+
+          if (calc_cond)
+            {
+              // Calculation of 1-norm of inv(*this)
+              OCTAVE_LOCAL_BUFFER (double, work, nm);
+              for (octave_idx_type i = 0; i < nm; i++)
+                work[i] = 0.;
+
+              for (octave_idx_type j = 0; j < nr; j++)
+                {
+                  work[j] = 1.;
+
+                  for (octave_idx_type k = j; k < nc; k++)
+                    {
+
+                      if (work[k] != 0.)
                         {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
-                    }
-                  rcond = 1. / ainvnorm / anorm;
-                }
-            }
-          else
-            {
-              OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
-
-              for (octave_idx_type j = 0; j < b_nc; j++)
-                {
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
-                    cwork[b.ridx (i)] = b.data (i);
-
-                  for (octave_idx_type k = 0; k < nc; k++)
-                    {
-                      if (cwork[k] != 0.)
-                        {
-                          if (ridx (cidx (k)) != k || data (cidx (k)) == 0.)
-                            {
-                              err = -2;
-                              goto triangular_error;
-                            }
-
-                          Complex tmp = cwork[k] / data (cidx (k));
-                          cwork[k] = tmp;
-                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
+                          double tmp = work[k] / data (cidx (k));
+                          work[k] = tmp;
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
-                              cwork[iidx] = cwork[iidx] - tmp * data (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
-
-                  // Count nonzeros in work vector and adjust space in
-                  // retval if needed
-                  octave_idx_type new_nnz = 0;
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[i] != 0.)
-                      new_nnz++;
-
-                  if (ii + new_nnz > x_nz)
-                    {
-                      // Resize the sparse matrix
-                      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-                      retval.change_capacity (sz);
-                      x_nz = sz;
-                    }
-
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    if (cwork[i] != 0.)
-                      {
-                        retval.xridx (ii) = i;
-                        retval.xdata (ii++) = cwork[i];
-                      }
-                  retval.xcidx (j+1) = ii;
-                }
-
-              retval.maybe_compress ();
-
-              if (calc_cond)
-                {
-                  // Calculation of 1-norm of inv(*this)
-                  OCTAVE_LOCAL_BUFFER (double, work, nm);
-                  for (octave_idx_type i = 0; i < nm; i++)
-                    work[i] = 0.;
-
-                  for (octave_idx_type j = 0; j < nr; j++)
+                  double atmp = 0;
+                  for (octave_idx_type i = j; i < nc; i++)
                     {
-                      work[j] = 1.;
-
-                      for (octave_idx_type k = j; k < nc; k++)
-                        {
-
-                          if (work[k] != 0.)
-                            {
-                              double tmp = work[k] / data (cidx (k));
-                              work[k] = tmp;
-                              for (octave_idx_type i = cidx (k)+1;
-                                   i < cidx (k+1); i++)
-                                {
-                                  octave_idx_type iidx = ridx (i);
-                                  work[iidx] = work[iidx] - tmp * data (i);
-                                }
-                            }
-                        }
-                      double atmp = 0;
-                      for (octave_idx_type i = j; i < nc; i++)
-                        {
-                          atmp += fabs (work[i]);
-                          work[i] = 0.;
-                        }
-                      if (atmp > ainvnorm)
-                        ainvnorm = atmp;
+                      atmp += fabs (work[i]);
+                      work[i] = 0.;
                     }
-                  rcond = 1. / ainvnorm / anorm;
+                  if (atmp > ainvnorm)
+                    ainvnorm = atmp;
                 }
-            }
-
-        triangular_error:
-          if (err != 0)
-            {
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
-            }
-
-          volatile double rcond_plus_one = rcond + 1.0;
-
-          if (rcond_plus_one == 1.0 || xisnan (rcond))
-            {
-              err = -2;
-
-              if (sing_handler)
-                {
-                  sing_handler (rcond);
-                  mattype.mark_as_rectangular ();
-                }
-              else
-                warn_singular_matrix (rcond);
+              rcond = 1. / ainvnorm / anorm;
             }
         }
-      else
-        (*current_liboctave_error_handler) ("incorrect matrix type");
+
+    triangular_error:
+      if (err != 0)
+        {
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
+
+      volatile double rcond_plus_one = rcond + 1.0;
+
+      if (rcond_plus_one == 1.0 || xisnan (rcond))
+        {
+          err = -2;
+
+          if (sing_handler)
+            {
+              sing_handler (rcond);
+              mattype.mark_as_rectangular ();
+            }
+          else
+            warn_singular_matrix (rcond);
+        }
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::trisolve (MatrixType &mattype, const Matrix& b,
                         octave_idx_type& err, double& rcond,
@@ -3829,17 +3787,18 @@ SparseMatrix::trisolve (MatrixType &matt
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
@@ -3978,17 +3937,18 @@ SparseMatrix::trisolve (MatrixType &matt
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
@@ -4123,17 +4083,18 @@ SparseMatrix::trisolve (MatrixType &matt
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
@@ -4274,17 +4235,18 @@ SparseMatrix::trisolve (MatrixType &matt
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
     (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
@@ -4379,31 +4341,33 @@ SparseMatrix::trisolve (MatrixType &matt
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              Bx, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              Bz, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
                   // Count nonzeros in work vector and adjust
@@ -4452,17 +4416,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -4554,16 +4519,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   F77_XFCN (dpbtrs, DPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
                              ldm, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
@@ -4695,17 +4661,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -4807,16 +4774,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
+                          // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
@@ -5007,17 +4975,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -5122,30 +5091,32 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
+                          // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
+                          // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         retval(i, j) = Complex (Bx[i], Bz[i]);
@@ -5300,17 +5271,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
@@ -5421,30 +5393,32 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
+                          // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bz, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
+                          // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
 
                           err = -1;
                           break;
                         }
 
                       // Count nonzeros in work vector and adjust
@@ -5689,24 +5663,25 @@ SparseMatrix::factorize (octave_idx_type
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
                                           &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler)
-        ("SparseMatrix::solve symbolic factorization failed");
-      err = -1;
-
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic);
+
+      // FIXME: Should this be a warning?
+      (*current_liboctave_error_handler)
+        ("SparseMatrix::solve symbolic factorization failed");
+      err = -1;
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
                                         &Numeric, control, info);
       UMFPACK_DNAME (free_symbolic) (&Symbolic);
@@ -5726,22 +5701,23 @@ SparseMatrix::factorize (octave_idx_type
 
           if (sing_handler)
             sing_handler (rcond);
           else
             warn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
+          UMFPACK_DNAME (report_status) (control, status);
+          UMFPACK_DNAME (report_info) (control, info);
+
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("SparseMatrix::solve numeric factorization failed");
 
-          UMFPACK_DNAME (report_status) (control, status);
-          UMFPACK_DNAME (report_info) (control, info);
-
           err = -1;
         }
       else
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
         }
     }
 
@@ -5767,17 +5743,18 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -5940,23 +5917,23 @@ SparseMatrix::fsolve (MatrixType &mattyp
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
                                                   Ai, Ax, &result[iidx],
                                                   &Bx[iidx], Numeric, control,
                                                   info);
                   if (status < 0)
                     {
+                      UMFPACK_DNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
-                      UMFPACK_DNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
@@ -5986,17 +5963,18 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -6183,23 +6161,23 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
                                                   Ai, Ax, Xx, Bx, Numeric,
                                                   control, info);
                   if (status < 0)
                     {
+                      UMFPACK_DNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
-                      UMFPACK_DNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       double tmp = Xx[i];
                       if (tmp != 0.0)
                         {
@@ -6250,17 +6228,18 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -6437,23 +6416,23 @@ SparseMatrix::fsolve (MatrixType &mattyp
                                                   Ai, Ax, Xx, Bx, Numeric,
                                                   control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
                                                        Ap, Ai, Ax, Xz, Bz,
                                                        Numeric, control, info);
 
                   if (status < 0 || status2 < 0)
                     {
+                      UMFPACK_DNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
-                      UMFPACK_DNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     retval(i, j) = Complex (Xx[i], Xz[i]);
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
@@ -6486,17 +6465,18 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Hermitian)
@@ -6694,23 +6674,23 @@ SparseMatrix::fsolve (MatrixType &mattyp
                                                   Ai, Ax, Xx, Bx, Numeric,
                                                   control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
                                                        Ap, Ai, Ax, Xz, Bz,
                                                        Numeric, control, info);
 
                   if (status < 0 || status2 < 0)
                     {
+                      UMFPACK_DNAME (report_status) (control, status);
+
+                      // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
-                      UMFPACK_DNAME (report_status) (control, status);
-
                       err = -1;
-
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex tmp = Complex (Xx[i], Xz[i]);
                       if (tmp != 0.0)
                         {
@@ -6794,20 +6774,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return Matrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
@@ -6862,20 +6839,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return SparseMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseMatrix, SparseMatrix, SparseMatrix>
@@ -6930,20 +6904,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return ComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseMatrix, ComplexMatrix>
@@ -6998,20 +6969,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Tridiagonal
            || typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return SparseComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseMatrix, SparseComplexMatrix>
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -75,20 +75,17 @@ FloatComplexColumnVector::operator != (c
 // destructive insert/delete/reorder operations
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::insert (const FloatColumnVector& a, octave_idx_type r)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i) = a.elem (i);
     }
@@ -98,20 +95,17 @@ FloatComplexColumnVector::insert (const 
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::insert (const FloatComplexColumnVector& a,
                                   octave_idx_type r)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i) = a.elem (i);
     }
@@ -154,20 +148,17 @@ FloatComplexColumnVector::fill (const Fl
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (float val,
                                 octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
@@ -179,20 +170,17 @@ FloatComplexColumnVector::fill (float va
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::fill (const FloatComplex& val,
                                 octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -75,166 +75,136 @@ FloatComplexDiagMatrix::fill (const Floa
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (float val,
                               octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplex& val,
                               octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatColumnVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexColumnVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatRowVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexRowVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatColumnVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexColumnVector& a,
                               octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatRowVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplexRowVector& a,
                               octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix
@@ -274,105 +244,84 @@ FloatComplexDiagMatrix::extract (octave_
 // extract row or column i.
 
 FloatComplexRowVector
 FloatComplexDiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatComplexRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   FloatComplexRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatComplexRowVector
 FloatComplexDiagMatrix::row (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatComplexRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatComplexRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 FloatComplexColumnVector
 FloatComplexDiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatComplexColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   FloatComplexColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatComplexColumnVector
 FloatComplexDiagMatrix::column (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatComplexColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatComplexColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 FloatComplexDiagMatrix
 FloatComplexDiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
 }
 
 FloatComplexDiagMatrix
 FloatComplexDiagMatrix::inverse (octave_idx_type& info) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (r != c)
-    {
-      (*current_liboctave_error_handler) ("inverse requires square matrix");
-      return FloatComplexDiagMatrix ();
-    }
+    (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   FloatComplexDiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < length (); i++)
     {
       if (elem (i, i) == 0.0f)
         {
@@ -523,26 +472,21 @@ operator * (const FloatComplexDiagMatrix
 
 // other operations
 
 FloatComplexDET
 FloatComplexDiagMatrix::determinant (void) const
 {
   FloatComplexDET det (1.0f);
   if (rows () != cols ())
-    {
-      (*current_liboctave_error_handler) ("determinant requires square matrix");
-      det = FloatComplexDET (0.0);
-    }
-  else
-    {
-      octave_idx_type len = length ();
-      for (octave_idx_type i = 0; i < len; i++)
-        det *= elem (i, i);
-    }
+    (*current_liboctave_error_handler) ("determinant requires square matrix");
+
+  octave_idx_type len = length ();
+  for (octave_idx_type i = 0; i < len; i++)
+    det *= elem (i, i);
 
   return det;
 }
 
 float
 FloatComplexDiagMatrix::rcond (void) const
 {
   FloatColumnVector av = extract_diag (0).map<float> (std::abs);
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -402,20 +402,17 @@ FloatComplexMatrix::is_hermitian (void) 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatMatrix& a,
                             octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_nr >0 && a_nc > 0)
     {
       make_unique ();
 
       for (octave_idx_type j = 0; j < a_nc; j++)
         for (octave_idx_type i = 0; i < a_nr; i++)
           xelem (r+i, c+j) = a.elem (i, j);
@@ -426,20 +423,17 @@ FloatComplexMatrix::insert (const FloatM
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatRowVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r, c+i) = a.elem (i);
     }
@@ -449,20 +443,17 @@ FloatComplexMatrix::insert (const FloatR
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatColumnVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
@@ -473,20 +464,17 @@ FloatComplexMatrix::insert (const FloatC
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatDiagMatrix& a,
                             octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
@@ -507,38 +495,32 @@ FloatComplexMatrix::insert (const FloatC
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexRowVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexColumnVector& a,
                             octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
@@ -549,20 +531,17 @@ FloatComplexMatrix::insert (const FloatC
 FloatComplexMatrix&
 FloatComplexMatrix::insert (const FloatComplexDiagMatrix& a,
                             octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
@@ -614,20 +593,17 @@ FloatComplexMatrix&
 FloatComplexMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1,
                           octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
@@ -644,20 +620,17 @@ FloatComplexMatrix::fill (const FloatCom
                           octave_idx_type r1, octave_idx_type c1,
                           octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (r2 >= r1 && c2 >=c1)
     {
       make_unique ();
 
@@ -670,298 +643,242 @@ FloatComplexMatrix::fill (const FloatCom
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != 1)
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.numel ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != 1)
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.numel ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::append (const FloatComplexDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatComplexMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.numel ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.numel ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::stack (const FloatComplexDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatComplexMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
@@ -1050,141 +967,137 @@ FloatComplexMatrix::tinverse (MatrixType
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
-  else
+
+  int typ = mattype.type ();
+  char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
+  char udiag = 'N';
+  retval = *this;
+  FloatComplex *tmp_data = retval.fortran_vec ();
+
+  F77_XFCN (ctrtri, CTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                             F77_CONST_CHAR_ARG2 (&udiag, 1),
+                             nr, tmp_data, nr, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
     {
-      int typ = mattype.type ();
-      char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
-      char udiag = 'N';
-      retval = *this;
-      FloatComplex *tmp_data = retval.fortran_vec ();
-
-      F77_XFCN (ctrtri, CTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+      octave_idx_type ztrcon_info = 0;
+      char job = '1';
+
+      OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
+      OCTAVE_LOCAL_BUFFER (float, rwork, nr);
+
+      F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info
+                                 nr, tmp_data, nr, rcon,
+                                 cwork, rwork, ztrcon_info
+                                 F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+      if (ztrcon_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          octave_idx_type ztrcon_info = 0;
-          char job = '1';
-
-          OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
-          OCTAVE_LOCAL_BUFFER (float, rwork, nr);
-
-          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     cwork, rwork, ztrcon_info
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (ztrcon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this; // Restore matrix contents.
     }
 
+  if (info == -1 && ! force)
+    retval = *this; // Restore matrix contents.
+
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
                               float& rcon, int force, int calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
+
+  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+  octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+  retval = *this;
+  FloatComplex *tmp_data = retval.fortran_vec ();
+
+  Array<FloatComplex> z (dim_vector (1, 1));
+  octave_idx_type lwork = -1;
+
+  // Query the optimum work array size.
+
+  F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
+                             z.fortran_vec (), lwork, info));
+
+  lwork = static_cast<octave_idx_type> (std::real (z(0)));
+  lwork = (lwork <  2 *nc ? 2*nc : lwork);
+  z.resize (dim_vector (lwork, 1));
+  FloatComplex *pz = z.fortran_vec ();
+
+  info = 0;
+
+  // Calculate the norm of the matrix, for later use.
+  float anorm;
+  if (calc_cond)
+    anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
+            .max ();
+
+  F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
+    {
+      // Now calculate the condition number for non-singular matrix.
+      octave_idx_type zgecon_info = 0;
+      char job = '1';
+      Array<float> rz (dim_vector (2 * nc, 1));
+      float *prz = rz.fortran_vec ();
+      F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nc, tmp_data, nr, anorm,
+                                 rcon, pz, prz, zgecon_info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (zgecon_info != 0)
+        info = -1;
+    }
+
+  if (info == -1 && ! force)
+    retval = *this;  // Restore contents.
   else
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      retval = *this;
-      FloatComplex *tmp_data = retval.fortran_vec ();
-
-      Array<FloatComplex> z (dim_vector (1, 1));
-      octave_idx_type lwork = -1;
-
-      // Query the optimum work array size.
+      octave_idx_type zgetri_info = 0;
 
       F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
-                                 z.fortran_vec (), lwork, info));
-
-      lwork = static_cast<octave_idx_type> (std::real (z(0)));
-      lwork = (lwork <  2 *nc ? 2*nc : lwork);
-      z.resize (dim_vector (lwork, 1));
-      FloatComplex *pz = z.fortran_vec ();
-
-      info = 0;
-
-      // Calculate the norm of the matrix, for later use.
-      float anorm;
-      if (calc_cond)
-        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
-                .max ();
-
-      F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
-
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+                                 pz, lwork, zgetri_info));
+
+      if (zgetri_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          // Now calculate the condition number for non-singular matrix.
-          octave_idx_type zgecon_info = 0;
-          char job = '1';
-          Array<float> rz (dim_vector (2 * nc, 1));
-          float *prz = rz.fortran_vec ();
-          F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm,
-                                     rcon, pz, prz, zgecon_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (zgecon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this;  // Restore contents.
-      else
-        {
-          octave_idx_type zgetri_info = 0;
-
-          F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
-                                     pz, lwork, zgetri_info));
-
-          if (zgetri_info != 0)
-            info = -1;
-        }
-
-      if (info != 0)
-        mattype.mark_as_rectangular ();
     }
 
+  if (info != 0)
+    mattype.mark_as_rectangular ();
+
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                              float& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1623,130 +1536,128 @@ FloatComplexMatrix::determinant (MatrixT
   info = 0;
   rcon = 0.0;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else
+
+  volatile int typ = mattype.type ();
+
+  // Even though the matrix is marked as singular (Rectangular), we may
+  // still get a useful number from the LU factorization, because it always
+  // completes.
+
+  if (typ == MatrixType::Unknown)
+    typ = mattype.type (*this);
+  else if (typ == MatrixType::Rectangular)
+    typ = MatrixType::Full;
+
+  if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      volatile int typ = mattype.type ();
-
-      // Even though the matrix is marked as singular (Rectangular), we may
-      // still get a useful number from the LU factorization, because it always
-      // completes.
-
-      if (typ == MatrixType::Unknown)
-        typ = mattype.type (*this);
-      else if (typ == MatrixType::Rectangular)
-        typ = MatrixType::Full;
-
-      if (typ == MatrixType::Lower || typ == MatrixType::Upper)
+      for (octave_idx_type i = 0; i < nc; i++)
+        retval *= elem (i,i);
+    }
+  else if (typ == MatrixType::Hermitian)
+    {
+      FloatComplexMatrix atmp = *this;
+      FloatComplex *tmp_data = atmp.fortran_vec ();
+
+      float anorm = 0;
+      if (calc_cond) anorm = xnorm (*this, 1);
+
+
+      char job = 'L';
+      F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
+                                 tmp_data, nr, info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (info != 0)
         {
-          for (octave_idx_type i = 0; i < nc; i++)
-            retval *= elem (i,i);
+          rcon = 0.0;
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
         }
-      else if (typ == MatrixType::Hermitian)
+      else
         {
-          FloatComplexMatrix atmp = *this;
-          FloatComplex *tmp_data = atmp.fortran_vec ();
-
-          float anorm = 0;
-          if (calc_cond) anorm = xnorm (*this, 1);
-
-
-          char job = 'L';
-          F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+          Array<FloatComplex> z (dim_vector (2 * nc, 1));
+          FloatComplex *pz = z.fortran_vec ();
+          Array<float> rz (dim_vector (nc, 1));
+          float *prz = rz.fortran_vec ();
+
+          F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, tmp_data, nr, anorm,
+                                     rcon, pz, prz, info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
+            rcon = 0.0;
+
+          for (octave_idx_type i = 0; i < nc; i++)
+            retval *= atmp (i,i);
+
+          retval = retval.square ();
+        }
+    }
+  else if (typ != MatrixType::Full)
+    (*current_liboctave_error_handler) ("det: invalid dense matrix type");
+
+  if (typ == MatrixType::Full)
+    {
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+      FloatComplexMatrix atmp = *this;
+      FloatComplex *tmp_data = atmp.fortran_vec ();
+
+      info = 0;
+
+      // Calculate the norm of the matrix, for later use.
+      float anorm = 0;
+      if (calc_cond) anorm = xnorm (*this, 1);
+
+      F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcon = 0.0;
+      if (info != 0)
+        {
+          info = -1;
+          retval = FloatComplexDET ();
+        }
+      else
+        {
+          if (calc_cond)
             {
-              rcon = 0.0;
-              mattype.mark_as_unsymmetric ();
-              typ = MatrixType::Full;
-            }
-          else
-            {
+              // Now calc the condition number for non-singular matrix.
+              char job = '1';
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
-              Array<float> rz (dim_vector (nc, 1));
+              Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
-              F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                         nr, tmp_data, nr, anorm,
+              F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nc, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
-
-              if (info != 0)
-                rcon = 0.0;
-
-              for (octave_idx_type i = 0; i < nc; i++)
-                retval *= atmp (i,i);
-
-              retval = retval.square ();
             }
-        }
-      else if (typ != MatrixType::Full)
-        (*current_liboctave_error_handler) ("det: invalid dense matrix type");
-
-      if (typ == MatrixType::Full)
-        {
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          FloatComplexMatrix atmp = *this;
-          FloatComplex *tmp_data = atmp.fortran_vec ();
-
-          info = 0;
-
-          // Calculate the norm of the matrix, for later use.
-          float anorm = 0;
-          if (calc_cond) anorm = xnorm (*this, 1);
-
-          F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-          // Throw-away extra info LAPACK gives so as to not change output.
-          rcon = 0.0;
+
           if (info != 0)
             {
               info = -1;
               retval = FloatComplexDET ();
             }
           else
             {
-              if (calc_cond)
+              for (octave_idx_type i = 0; i < nc; i++)
                 {
-                  // Now calc the condition number for non-singular matrix.
-                  char job = '1';
-                  Array<FloatComplex> z (dim_vector (2 * nc, 1));
-                  FloatComplex *pz = z.fortran_vec ();
-                  Array<float> rz (dim_vector (2 * nc, 1));
-                  float *prz = rz.fortran_vec ();
-
-                  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
-                                             F77_CHAR_ARG_LEN (1)));
-                }
-
-              if (info != 0)
-                {
-                  info = -1;
-                  retval = FloatComplexDET ();
-                }
-              else
-                {
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    {
-                      FloatComplex c = atmp(i,i);
-                      retval *= (ipvt(i) != (i+1)) ? -c : c;
-                    }
+                  FloatComplex c = atmp(i,i);
+                  retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
   return retval;
 }
 
@@ -1761,17 +1672,18 @@ float
 FloatComplexMatrix::rcond (MatrixType &mattype) const
 {
   float rcon = octave_NaN;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else if (nr == 0 || nc == 0)
+
+  if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
@@ -1931,33 +1843,32 @@ FloatComplexMatrix::utsolve (MatrixType 
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
+            (*current_liboctave_error_handler)
+              ("permuted triangular matrix not implemented");
           else
             {
               const FloatComplex *tmp_data = fortran_vec ();
 
               retval = b;
               FloatComplex *result = retval.fortran_vec ();
 
               char uplo = 'U';
@@ -2026,33 +1937,32 @@ FloatComplexMatrix::ltsolve (MatrixType 
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
+            (*current_liboctave_error_handler)
+              ("permuted triangular matrix not implemented");
           else
             {
               const FloatComplex *tmp_data = fortran_vec ();
 
               retval = b;
               FloatComplex *result = retval.fortran_vec ();
 
               char uplo = 'L';
@@ -2122,17 +2032,18 @@ FloatComplexMatrix::fsolve (MatrixType &
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
@@ -2372,20 +2283,17 @@ FloatComplexMatrix::solve (MatrixType &m
     return transpose ().solve (mattype, b, info, rcon, sing_handler,
                                singular_fallback);
   else if (transt == blas_conj_trans)
     retval = hermitian ().solve (mattype, b, info, rcon, sing_handler,
                                  singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return FloatComplexMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
@@ -2660,17 +2568,18 @@ FloatComplexMatrix::lssolve (const Float
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m== 0 || n == 0 || b.cols () == 0)
+
+  if (m== 0 || n == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (n, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
@@ -2860,17 +2769,18 @@ FloatComplexMatrix::lssolve (const Float
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m == 0 || n == 0 || b.cols () == 0)
+
+  if (m == 0 || n == 0 || b.cols () == 0)
     retval = FloatComplexColumnVector (n, FloatComplex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
@@ -3174,18 +3084,17 @@ FloatComplexMatrix::diag (octave_idx_typ
   FloatComplexDiagMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 1 || nc == 1)
     retval = FloatComplexDiagMatrix (*this, m, n);
   else
-    (*current_liboctave_error_handler)
-      ("diag: expecting vector argument");
+    (*current_liboctave_error_handler) ("diag: expecting vector argument");
 
   return retval;
 }
 
 bool
 FloatComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
@@ -3857,21 +3766,18 @@ min (const FloatComplexMatrix& m, const 
 
 FloatComplexMatrix
 min (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg min requires same size arguments");
-      return FloatComplexMatrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg min requires same size arguments");
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
@@ -3945,21 +3851,18 @@ max (const FloatComplexMatrix& m, const 
 
 FloatComplexMatrix
 max (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg max requires same size arguments");
-      return FloatComplexMatrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg max requires same size arguments");
 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -771,21 +771,18 @@ FloatComplexNDArray::insert (const NDArr
       Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
 
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
 
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dimensions(i))
-            {
-              (*current_liboctave_error_handler)
-                ("Array<T>::insert: range error for insert");
-              return *this;
-            }
+            (*current_liboctave_error_handler)
+              ("Array<T>::insert: range error for insert");
         }
 
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
 
       octave_idx_type n_elt = a.numel ();
 
       // IS make_unique () NECESSARY HERE?
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -74,20 +74,17 @@ FloatComplexRowVector::operator != (cons
 // destructive insert/delete/reorder operations
 
 FloatComplexRowVector&
 FloatComplexRowVector::insert (const FloatRowVector& a, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (c < 0 || c + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (c+i) = a.elem (i);
     }
@@ -97,20 +94,17 @@ FloatComplexRowVector::insert (const Flo
 
 FloatComplexRowVector&
 FloatComplexRowVector::insert (const FloatComplexRowVector& a,
                                octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (c < 0 || c + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (c+i) = a.elem (i);
     }
@@ -151,20 +145,17 @@ FloatComplexRowVector::fill (const Float
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (float val, octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
@@ -176,20 +167,17 @@ FloatComplexRowVector::fill (float val, 
 
 FloatComplexRowVector&
 FloatComplexRowVector::fill (const FloatComplex& val,
                              octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
diff --git a/liboctave/array/fColVector.cc b/liboctave/array/fColVector.cc
--- a/liboctave/array/fColVector.cc
+++ b/liboctave/array/fColVector.cc
@@ -67,20 +67,17 @@ FloatColumnVector::operator != (const Fl
 }
 
 FloatColumnVector&
 FloatColumnVector::insert (const FloatColumnVector& a, octave_idx_type r)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i) = a.elem (i);
     }
@@ -105,20 +102,17 @@ FloatColumnVector::fill (float val)
 }
 
 FloatColumnVector&
 FloatColumnVector::fill (float val, octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = numel ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
 
   if (r2 >= r1)
     {
       make_unique ();
 
       for (octave_idx_type i = r1; i <= r2; i++)
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -58,84 +58,69 @@ FloatDiagMatrix::fill (float val)
     elem (i, i) = val;
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (float val, octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatColumnVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatRowVector& a)
 {
   octave_idx_type len = length ();
   if (a.numel () != len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < len; i++)
     elem (i, i) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatColumnVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix&
 FloatDiagMatrix::fill (const FloatRowVector& a, octave_idx_type beg)
 {
   octave_idx_type a_len = a.numel ();
   if (beg < 0 || beg + a_len >= length ())
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatDiagMatrix
@@ -178,106 +163,85 @@ FloatDiagMatrix::extract (octave_idx_typ
 // extract row or column i.
 
 FloatRowVector
 FloatDiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   FloatRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatRowVector
 FloatDiagMatrix::row (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatRowVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 FloatColumnVector
 FloatDiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   FloatColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatColumnVector
 FloatDiagMatrix::column (char *s) const
 {
   if (! s)
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
-    {
-      (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatColumnVector ();
-    }
+    (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 FloatDiagMatrix
 FloatDiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
 }
 
 FloatDiagMatrix
 FloatDiagMatrix::inverse (octave_idx_type &info) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   octave_idx_type len = length ();
   if (r != c)
-    {
-      (*current_liboctave_error_handler) ("inverse requires square matrix");
-      return FloatDiagMatrix ();
-    }
+    (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   FloatDiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
         retval.elem (i, i) = octave_Inf;
@@ -340,26 +304,21 @@ operator * (const FloatDiagMatrix& a, co
 
 // other operations
 
 FloatDET
 FloatDiagMatrix::determinant (void) const
 {
   FloatDET det (1.0f);
   if (rows () != cols ())
-    {
-      (*current_liboctave_error_handler) ("determinant requires square matrix");
-      det = 0.0f;
-    }
-  else
-    {
-      octave_idx_type len = length ();
-      for (octave_idx_type i = 0; i < len; i++)
-        det *= elem (i, i);
-    }
+    (*current_liboctave_error_handler) ("determinant requires square matrix");
+
+  octave_idx_type len = length ();
+  for (octave_idx_type i = 0; i < len; i++)
+    det *= elem (i, i);
 
   return det;
 }
 
 float
 FloatDiagMatrix::rcond (void) const
 {
   FloatColumnVector av = extract_diag (0).map<float> (fabsf);
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -344,20 +344,17 @@ FloatMatrix::insert (const FloatMatrix& 
 
 FloatMatrix&
 FloatMatrix::insert (const FloatRowVector& a,
                      octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r, c+i) = a.elem (i);
     }
@@ -367,20 +364,17 @@ FloatMatrix::insert (const FloatRowVecto
 
 FloatMatrix&
 FloatMatrix::insert (const FloatColumnVector& a,
                      octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
@@ -391,20 +385,17 @@ FloatMatrix::insert (const FloatColumnVe
 FloatMatrix&
 FloatMatrix::insert (const FloatDiagMatrix& a,
                      octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   fill (0.0, r, c, r + a_nr - 1, c + a_nc - 1);
 
   octave_idx_type a_len = a.length ();
 
   if (a_len > 0)
     {
       make_unique ();
@@ -438,20 +429,17 @@ FloatMatrix&
 FloatMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1,
                    octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (r2 >= r1 && c2 >= c1)
     {
       make_unique ();
 
@@ -464,150 +452,122 @@ FloatMatrix::fill (float val, octave_idx
 }
 
 FloatMatrix
 FloatMatrix::append (const FloatMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::append (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != 1)
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatMatrix retval (nr, nc + a.numel ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::append (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.numel ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::append (const FloatDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nr != a.rows ())
-    {
-      (*current_liboctave_error_handler) ("row dimension mismatch for append");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("row dimension mismatch for append");
 
   octave_idx_type nc_insert = nc;
   FloatMatrix retval (nr, nc + a.cols ());
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::stack (const FloatMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::stack (const FloatRowVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.numel ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::stack (const FloatColumnVector& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != 1)
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + a.numel (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::stack (const FloatDiagMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   if (nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-        ("column dimension mismatch for stack");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("column dimension mismatch for stack");
 
   octave_idx_type nr_insert = nr;
   FloatMatrix retval (nr + a.rows (), nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
@@ -700,142 +660,138 @@ FloatMatrix::tinverse (MatrixType &matty
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
-  else
+
+  int typ = mattype.type ();
+  char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
+  char udiag = 'N';
+  retval = *this;
+  float *tmp_data = retval.fortran_vec ();
+
+  F77_XFCN (strtri, STRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                             F77_CONST_CHAR_ARG2 (&udiag, 1),
+                             nr, tmp_data, nr, info
+                             F77_CHAR_ARG_LEN (1)
+                             F77_CHAR_ARG_LEN (1)));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
     {
-      int typ = mattype.type ();
-      char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
-      char udiag = 'N';
-      retval = *this;
-      float *tmp_data = retval.fortran_vec ();
-
-      F77_XFCN (strtri, STRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+      octave_idx_type dtrcon_info = 0;
+      char job = '1';
+
+      OCTAVE_LOCAL_BUFFER (float, work, 3 * nr);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
+
+      F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info
+                                 nr, tmp_data, nr, rcon,
+                                 work, iwork, dtrcon_info
+                                 F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+      if (dtrcon_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          octave_idx_type dtrcon_info = 0;
-          char job = '1';
-
-          OCTAVE_LOCAL_BUFFER (float, work, 3 * nr);
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
-
-          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
-                                     F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     work, iwork, dtrcon_info
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (dtrcon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this; // Restore matrix contents.
     }
 
+  if (info == -1 && ! force)
+    retval = *this; // Restore matrix contents.
+
   return retval;
 }
 
 
 FloatMatrix
 FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                        int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
+
+  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+  octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+  retval = *this;
+  float *tmp_data = retval.fortran_vec ();
+
+  Array<float> z(dim_vector (1, 1));
+  octave_idx_type lwork = -1;
+
+  // Query the optimum work array size.
+  F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
+                             z.fortran_vec (), lwork, info));
+
+  lwork = static_cast<octave_idx_type> (z(0));
+  lwork = (lwork < 2 *nc ? 2*nc : lwork);
+  z.resize (dim_vector (lwork, 1));
+  float *pz = z.fortran_vec ();
+
+  info = 0;
+
+  // Calculate the norm of the matrix, for later use.
+  float anorm = 0;
+  if (calc_cond)
+    anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
+            .max ();
+
+  F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+
+  // Throw-away extra info LAPACK gives so as to not change output.
+  rcon = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond)
+    {
+      octave_idx_type dgecon_info = 0;
+
+      // Now calculate the condition number for non-singular matrix.
+      char job = '1';
+      Array<octave_idx_type> iz (dim_vector (nc, 1));
+      octave_idx_type *piz = iz.fortran_vec ();
+      F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                 nc, tmp_data, nr, anorm,
+                                 rcon, pz, piz, dgecon_info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (dgecon_info != 0)
+        info = -1;
+    }
+
+  if (info == -1 && ! force)
+    retval = *this; // Restore matrix contents.
   else
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-      retval = *this;
-      float *tmp_data = retval.fortran_vec ();
-
-      Array<float> z(dim_vector (1, 1));
-      octave_idx_type lwork = -1;
-
-      // Query the optimum work array size.
+      octave_idx_type dgetri_info = 0;
+
       F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
-                                 z.fortran_vec (), lwork, info));
-
-      lwork = static_cast<octave_idx_type> (z(0));
-      lwork = (lwork < 2 *nc ? 2*nc : lwork);
-      z.resize (dim_vector (lwork, 1));
-      float *pz = z.fortran_vec ();
-
-      info = 0;
-
-      // Calculate the norm of the matrix, for later use.
-      float anorm = 0;
-      if (calc_cond)
-        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
-                .max ();
-
-      F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
-
-      // Throw-away extra info LAPACK gives so as to not change output.
-      rcon = 0.0;
-      if (info != 0)
+                                 pz, lwork, dgetri_info));
+
+      if (dgetri_info != 0)
         info = -1;
-      else if (calc_cond)
-        {
-          octave_idx_type dgecon_info = 0;
-
-          // Now calculate the condition number for non-singular matrix.
-          char job = '1';
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
-          F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm,
-                                     rcon, pz, piz, dgecon_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          if (dgecon_info != 0)
-            info = -1;
-        }
-
-      if (info == -1 && ! force)
-        retval = *this; // Restore matrix contents.
-      else
-        {
-          octave_idx_type dgetri_info = 0;
-
-          F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
-                                     pz, lwork, dgetri_info));
-
-          if (dgetri_info != 0)
-            info = -1;
-        }
-
-      if (info != 0)
-        mattype.mark_as_rectangular ();
     }
 
+  if (info != 0)
+    mattype.mark_as_rectangular ();
+
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                       int force, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1272,130 +1228,128 @@ FloatMatrix::determinant (MatrixType& ma
   info = 0;
   rcon = 0.0;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else
+
+  volatile int typ = mattype.type ();
+
+  // Even though the matrix is marked as singular (Rectangular), we may
+  // still get a useful number from the LU factorization, because it always
+  // completes.
+
+  if (typ == MatrixType::Unknown)
+    typ = mattype.type (*this);
+  else if (typ == MatrixType::Rectangular)
+    typ = MatrixType::Full;
+
+  if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      volatile int typ = mattype.type ();
-
-      // Even though the matrix is marked as singular (Rectangular), we may
-      // still get a useful number from the LU factorization, because it always
-      // completes.
-
-      if (typ == MatrixType::Unknown)
-        typ = mattype.type (*this);
-      else if (typ == MatrixType::Rectangular)
-        typ = MatrixType::Full;
-
-      if (typ == MatrixType::Lower || typ == MatrixType::Upper)
+      for (octave_idx_type i = 0; i < nc; i++)
+        retval *= elem (i,i);
+    }
+  else if (typ == MatrixType::Hermitian)
+    {
+      FloatMatrix atmp = *this;
+      float *tmp_data = atmp.fortran_vec ();
+
+      float anorm = 0;
+      if (calc_cond) anorm = xnorm (*this, 1);
+
+
+      char job = 'L';
+      F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
+                                 tmp_data, nr, info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (info != 0)
         {
-          for (octave_idx_type i = 0; i < nc; i++)
-            retval *= elem (i,i);
+          rcon = 0.0;
+          mattype.mark_as_unsymmetric ();
+          typ = MatrixType::Full;
         }
-      else if (typ == MatrixType::Hermitian)
+      else
         {
-          FloatMatrix atmp = *this;
-          float *tmp_data = atmp.fortran_vec ();
-
-          float anorm = 0;
-          if (calc_cond) anorm = xnorm (*this, 1);
-
-
-          char job = 'L';
-          F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+          Array<float> z (dim_vector (3 * nc, 1));
+          float *pz = z.fortran_vec ();
+          Array<octave_idx_type> iz (dim_vector (nc, 1));
+          octave_idx_type *piz = iz.fortran_vec ();
+
+          F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                     nr, tmp_data, nr, anorm,
+                                     rcon, pz, piz, info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
+            rcon = 0.0;
+
+          for (octave_idx_type i = 0; i < nc; i++)
+            retval *= atmp (i,i);
+
+          retval = retval.square ();
+        }
+    }
+  else if (typ != MatrixType::Full)
+    (*current_liboctave_error_handler) ("det: invalid dense matrix type");
+
+  if (typ == MatrixType::Full)
+    {
+      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
+      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+      FloatMatrix atmp = *this;
+      float *tmp_data = atmp.fortran_vec ();
+
+      info = 0;
+
+      // Calculate the norm of the matrix, for later use.
+      float anorm = 0;
+      if (calc_cond) anorm = xnorm (*this, 1);
+
+      F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcon = 0.0;
+      if (info != 0)
+        {
+          info = -1;
+          retval = FloatDET ();
+        }
+      else
+        {
+          if (calc_cond)
             {
-              rcon = 0.0;
-              mattype.mark_as_unsymmetric ();
-              typ = MatrixType::Full;
-            }
-          else
-            {
-              Array<float> z (dim_vector (3 * nc, 1));
+              // Now calc the condition number for non-singular matrix.
+              char job = '1';
+              Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
-              F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                         nr, tmp_data, nr, anorm,
+              F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nc, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
-
-              if (info != 0)
-                rcon = 0.0;
-
-              for (octave_idx_type i = 0; i < nc; i++)
-                retval *= atmp (i,i);
-
-              retval = retval.square ();
             }
-        }
-      else if (typ != MatrixType::Full)
-        (*current_liboctave_error_handler) ("det: invalid dense matrix type");
-
-      if (typ == MatrixType::Full)
-        {
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          FloatMatrix atmp = *this;
-          float *tmp_data = atmp.fortran_vec ();
-
-          info = 0;
-
-          // Calculate the norm of the matrix, for later use.
-          float anorm = 0;
-          if (calc_cond) anorm = xnorm (*this, 1);
-
-          F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
-
-          // Throw-away extra info LAPACK gives so as to not change output.
-          rcon = 0.0;
+
           if (info != 0)
             {
               info = -1;
               retval = FloatDET ();
             }
           else
             {
-              if (calc_cond)
+              for (octave_idx_type i = 0; i < nc; i++)
                 {
-                  // Now calc the condition number for non-singular matrix.
-                  char job = '1';
-                  Array<float> z (dim_vector (4 * nc, 1));
-                  float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
-
-                  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, piz, info
-                                             F77_CHAR_ARG_LEN (1)));
-                }
-
-              if (info != 0)
-                {
-                  info = -1;
-                  retval = FloatDET ();
-                }
-              else
-                {
-                  for (octave_idx_type i = 0; i < nc; i++)
-                    {
-                      float c = atmp(i,i);
-                      retval *= (ipvt(i) != (i+1)) ? -c : c;
-                    }
+                  float c = atmp(i,i);
+                  retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
   return retval;
 }
 
@@ -1410,17 +1364,18 @@ float
 FloatMatrix::rcond (MatrixType &mattype) const
 {
   float rcon = octave_NaN;
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
-  else if (nr == 0 || nc == 0)
+
+  if (nr == 0 || nc == 0)
     rcon = octave_Inf;
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
@@ -1445,17 +1400,17 @@ FloatMatrix::rcond (MatrixType &mattype)
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0.0;
         }
-      else if  (typ == MatrixType::Permuted_Upper)
+      else if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const float *tmp_data = fortran_vec ();
           octave_idx_type info = 0;
           char norm = '1';
           char uplo = 'L';
@@ -1578,33 +1533,32 @@ FloatMatrix::utsolve (MatrixType &mattyp
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
+            (*current_liboctave_error_handler)
+              ("permuted triangular matrix not implemented");
           else
             {
               const float *tmp_data = fortran_vec ();
 
               retval = b;
               float *result = retval.fortran_vec ();
 
               char uplo = 'U';
@@ -1674,33 +1628,32 @@ FloatMatrix::ltsolve (MatrixType &mattyp
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || nc == 0 || b.cols () == 0)
+
+  if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
           octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
-            {
-              (*current_liboctave_error_handler)
-                ("permuted triangular matrix not implemented");
-            }
+            (*current_liboctave_error_handler)
+              ("permuted triangular matrix not implemented");
           else
             {
               const float *tmp_data = fortran_vec ();
 
               retval = b;
               float *result = retval.fortran_vec ();
 
               char uplo = 'L';
@@ -1769,17 +1722,18 @@ FloatMatrix::fsolve (MatrixType &mattype
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (nr == 0 || b.cols () == 0)
+
+  if (nr == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
@@ -1982,20 +1936,17 @@ FloatMatrix::solve (MatrixType &mattype,
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, info, rcon, sing_handler, true, transt);
   else if (transt == blas_trans || transt == blas_conj_trans)
     return transpose ().solve (mattype, b, info, rcon, sing_handler,
                                singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
-    {
-      (*current_liboctave_error_handler) ("unknown matrix type");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler) ("unknown matrix type");
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
       retval = lssolve (b, info, rank, rcon);
     }
 
@@ -2294,17 +2245,18 @@ FloatMatrix::lssolve (const FloatMatrix&
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m == 0 || n == 0 || b.cols () == 0)
+
+  if (m == 0 || n == 0 || b.cols () == 0)
     retval = FloatMatrix (n, b.cols (), 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
       if (m != n)
         {
@@ -2489,17 +2441,18 @@ FloatMatrix::lssolve (const FloatColumnV
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
   if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
-  else if (m == 0 || n == 0)
+
+  if (m == 0 || n == 0)
     retval = FloatColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
@@ -2723,18 +2676,17 @@ FloatMatrix::diag (octave_idx_type m, oc
   FloatDiagMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 1 || nc == 1)
     retval = FloatDiagMatrix (*this, m, n);
   else
-    (*current_liboctave_error_handler)
-      ("diag: expecting vector argument");
+    (*current_liboctave_error_handler) ("diag: expecting vector argument");
 
   return retval;
 }
 
 FloatColumnVector
 FloatMatrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
@@ -3230,21 +3182,18 @@ min (const FloatMatrix& m, float d)
 
 FloatMatrix
 min (const FloatMatrix& a, const FloatMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg min requires same size arguments");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg min requires same size arguments");
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
@@ -3297,21 +3246,18 @@ max (const FloatMatrix& m, float d)
 
 FloatMatrix
 max (const FloatMatrix& a, const FloatMatrix& b)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
 
   if (nr != b.rows () || nc != b.columns ())
-    {
-      (*current_liboctave_error_handler)
-        ("two-arg max requires same size arguments");
-      return FloatMatrix ();
-    }
+    (*current_liboctave_error_handler)
+      ("two-arg max requires same size arguments");
 
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -731,31 +731,26 @@ FloatNDArray::concat (const charNDArray&
   charNDArray retval (dims ());
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float d = elem (i);
 
       if (xisnan (d))
-        {
-          (*current_liboctave_error_handler)
-            ("invalid conversion from NaN to character");
-          return retval;
-        }
-      else
-        {
-          octave_idx_type ival = NINTbig (d);
+        (*current_liboctave_error_handler)
+          ("invalid conversion from NaN to character");
+
+      octave_idx_type ival = NINTbig (d);
 
-          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            // FIXME: is there something better to do?  Should we warn the user?
-            ival = 0;
+      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+        // FIXME: is there something better to do?  Should we warn the user?
+        ival = 0;
 
-          retval.elem (i) = static_cast<char>(ival);
-        }
+      retval.elem (i) = static_cast<char>(ival);
     }
 
   if (rb.is_empty ())
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -71,20 +71,17 @@ FloatRowVector::operator != (const Float
 }
 
 FloatRowVector&
 FloatRowVector::insert (const FloatRowVector& a, octave_idx_type c)
 {
   octave_idx_type a_len = a.numel ();
 
   if (c < 0 || c + a_len > numel ())
-    {
-      (*current_liboctave_error_handler) ("range error for insert");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for insert");
 
   if (a_len > 0)
     {
       make_unique ();
 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (c+i) = a.elem (i);
     }
@@ -109,20 +106,17 @@ FloatRowVector::fill (float val)
 }
 
 FloatRowVector&
 FloatRowVector::fill (float val, octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = numel ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    {
-      (*current_liboctave_error_handler) ("range error for fill");
-      return *this;
-    }
+    (*current_liboctave_error_handler) ("range error for fill");
 
   if (c1 > c2) { std::swap (c1, c2); }
 
   if (c2 >= c1)
     {
       make_unique ();
 
       for (octave_idx_type i = c1; i <= c2; i++)
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -54,27 +54,26 @@ err_index_out_of_range (void)
     ("internal error: idx_vector index out of range");
 }
 
 Array<octave_idx_type>
 idx_vector::idx_base_rep::as_array (void)
 {
   (*current_liboctave_error_handler)
     ("internal error: as_array not allowed for this index class");
-
-  return Array<octave_idx_type> ();
 }
 
 
 idx_vector::idx_colon_rep::idx_colon_rep (char c)
 {
   if (c != ':')
     {
       (*current_liboctave_error_handler)
         ("internal error: invalid character converted to idx_vector; must be ':'");
+      // FIXME: this is unreachable now.
       err = true;
     }
 }
 
 octave_idx_type
 idx_vector::idx_colon_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0)
@@ -83,19 +82,16 @@ idx_vector::idx_colon_rep::checkelem (oc
   return i;
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_colon_rep::sort_idx (Array<octave_idx_type>&)
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_colon_rep::sort_idx");
-
-  count++;
-  return this;
 }
 
 std::ostream&
 idx_vector::idx_colon_rep::print (std::ostream& os) const
 {
   return os << ":";
 }
 
@@ -1261,16 +1257,17 @@ idx_vector::is_vector (void) const
 
 octave_idx_type
 idx_vector::freeze (octave_idx_type z_len, const char *, bool resize_ok)
 {
   if (! resize_ok && extent (z_len) > z_len)
     {
       (*current_liboctave_error_handler)
         ("invalid matrix index = %d", extent (z_len));
+      // FIXME: Should we call this before calling error_handler?
       rep->err = true;
       chkerr ();
     }
 
   return length (z_len);
 }
 
 octave_idx_type
diff --git a/liboctave/numeric/CmplxAEPBAL.cc b/liboctave/numeric/CmplxAEPBAL.cc
--- a/liboctave/numeric/CmplxAEPBAL.cc
+++ b/liboctave/numeric/CmplxAEPBAL.cc
@@ -53,20 +53,17 @@ extern "C"
 
 ComplexAEPBALANCE::ComplexAEPBALANCE (const ComplexMatrix& a,
                                       bool noperm, bool noscal)
   : base_aepbal<ComplexMatrix, ColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
-    {
-      (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
-      return;
-    }
+    (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
 
   octave_idx_type info;
 
   scale = ColumnVector (n);
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   Complex *p_balanced_mat = balanced_mat.fortran_vec ();
diff --git a/liboctave/numeric/CmplxCHOL.cc b/liboctave/numeric/CmplxCHOL.cc
--- a/liboctave/numeric/CmplxCHOL.cc
+++ b/liboctave/numeric/CmplxCHOL.cc
@@ -87,21 +87,17 @@ extern "C"
 
 octave_idx_type
 ComplexCHOL::init (const ComplexMatrix& a, bool upper, bool calc_cond)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler)
-        ("ComplexCHOL requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("ComplexCHOL requires square matrix");
 
   octave_idx_type n = a_nc;
   octave_idx_type info;
 
   is_upper = upper;
 
   chol_mat.clear (n, n);
   if (is_upper)
@@ -160,51 +156,49 @@ ComplexCHOL::init (const ComplexMatrix& 
 static ComplexMatrix
 chol2inv_internal (const ComplexMatrix& r, bool is_upper = true)
 {
   ComplexMatrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
-  if (r_nr == r_nc)
-    {
-      octave_idx_type n = r_nc;
-      octave_idx_type info;
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
-      ComplexMatrix tmp = r;
+  octave_idx_type n = r_nc;
+  octave_idx_type info;
+
+  ComplexMatrix tmp = r;
 
-      if (is_upper)
-        F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                                   tmp.fortran_vec (), n, info
-                                   F77_CHAR_ARG_LEN (1)));
-      else
-        F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                                   tmp.fortran_vec (), n, info
-                                   F77_CHAR_ARG_LEN (1)));
+  if (is_upper)
+    F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
+  else
+    F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
 
-      // If someone thinks of a more graceful way of doing this (or
-      // faster for that matter :-)), please let me know!
+  // If someone thinks of a more graceful way of doing this (or
+  // faster for that matter :-)), please let me know!
 
-      if (n > 1)
-        {
-          if (is_upper)
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (i, j) = tmp.xelem (j, i);
-          else
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (j, i) = tmp.xelem (i, j);
-        }
+  if (n > 1)
+    {
+      if (is_upper)
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (i, j) = tmp.xelem (j, i);
+      else
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (j, i) = tmp.xelem (i, j);
+    }
 
-      retval = tmp;
-    }
-  else
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+  retval = tmp;
 
   return retval;
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
 ComplexMatrix
 ComplexCHOL::inverse (void) const
 {
@@ -222,128 +216,116 @@ ComplexCHOL::set (const ComplexMatrix& R
 
 #ifdef HAVE_QRUPDATE
 
 void
 ComplexCHOL::update (const ComplexColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      ComplexColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (double, rw, n);
+  ComplexColumnVector utmp = u;
 
-      F77_XFCN (zch1up, ZCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), rw));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  F77_XFCN (zch1up, ZCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw));
 }
 
 octave_idx_type
 ComplexCHOL::downdate (const ComplexColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      ComplexColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (double, rw, n);
+  ComplexColumnVector utmp = u;
 
-      F77_XFCN (zch1dn, ZCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), rw, info));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  F77_XFCN (zch1dn, ZCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw, info));
 
   return info;
 }
 
 octave_idx_type
 ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
-  else
-    {
-      ComplexColumnVector utmp = u;
+
+  ComplexColumnVector utmp = u;
 
-      OCTAVE_LOCAL_BUFFER (double, rw, n);
-
-      chol_mat.resize (n+1, n+1);
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zchinx, ZCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, utmp.fortran_vec (), rw, info));
-    }
+  chol_mat.resize (n+1, n+1);
+
+  F77_XFCN (zchinx, ZCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, utmp.fortran_vec (), rw, info));
 
   return info;
 }
 
 void
 ComplexCHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zchdex, ZCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, rw));
+  F77_XFCN (zchdex, ZCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, rw));
 
-      chol_mat.resize (n-1, n-1);
-    }
+  chol_mat.resize (n-1, n-1);
 }
 
 void
 ComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (Complex, w, n);
-      OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zchshx, ZCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 i + 1, j + 1, w, rw));
-    }
+  OCTAVE_LOCAL_BUFFER (Complex, w, n);
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  F77_XFCN (zchshx, ZCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             i + 1, j + 1, w, rw));
 }
 
 #else
 
 void
 ComplexCHOL::update (const ComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      init (chol_mat.hermitian () * chol_mat
-            + ComplexMatrix (u) * ComplexMatrix (u).hermitian (), true, false);
-    }
-  else
+  if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  init (chol_mat.hermitian () * chol_mat
+        + ComplexMatrix (u) * ComplexMatrix (u).hermitian (), true, false);
 }
 
 static bool
 singular (const ComplexMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     if (a(i,i) == 0.0) return true;
   return false;
@@ -353,120 +335,112 @@ octave_idx_type
 ComplexCHOL::downdate (const ComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  if (singular (chol_mat))
+    info = 2;
+  else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else
-        {
-          info = init (chol_mat.hermitian () * chol_mat
-                       - ComplexMatrix (u) * ComplexMatrix (u).hermitian (),
-                       true, false);
-          if (info) info = 1;
-        }
+      info = init (chol_mat.hermitian () * chol_mat
+                   - ComplexMatrix (u) * ComplexMatrix (u).hermitian (),
+                   true, false);
+      if (info) info = 1;
     }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
 
 octave_idx_type
 ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
+  
+  if (singular (chol_mat))
+    info = 2;
+  else if (u(j).imag () != 0.0)
+    info = 3;
   else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else if (u(j).imag () != 0.0)
-        info = 3;
-      else
-        {
-          ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-          ComplexMatrix a1 (n+1, n+1);
-          for (octave_idx_type k = 0; k < n+1; k++)
-            for (octave_idx_type l = 0; l < n+1; l++)
-              {
-                if (l == j)
-                  a1(k, l) = u(k);
-                else if (k == j)
-                  a1(k, l) = std::conj (u(l));
-                else
-                  a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-              }
-          info = init (a1, true, false);
-          if (info) info = 1;
-        }
+      ComplexMatrix a = chol_mat.hermitian () * chol_mat;
+      ComplexMatrix a1 (n+1, n+1);
+      for (octave_idx_type k = 0; k < n+1; k++)
+        for (octave_idx_type l = 0; l < n+1; l++)
+          {
+            if (l == j)
+              a1(k, l) = u(k);
+            else if (k == j)
+              a1(k, l) = std::conj (u(l));
+            else
+              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
+          }
+      info = init (a1, true, false);
+      if (info) info = 1;
     }
 
   return info;
 }
 
 void
 ComplexCHOL::delete_sym (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      a.delete_elements (1, idx_vector (j));
-      a.delete_elements (0, idx_vector (j));
-      init (a, true, false);
-    }
+
+  ComplexMatrix a = chol_mat.hermitian () * chol_mat;
+  a.delete_elements (1, idx_vector (j));
+  a.delete_elements (0, idx_vector (j));
+  init (a, true, false);
 }
 
 void
 ComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
+
+  ComplexMatrix a = chol_mat.hermitian () * chol_mat;
+  Array<octave_idx_type> p (dim_vector (n, 1));
+  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
+  if (i < j)
     {
-      ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      Array<octave_idx_type> p (dim_vector (n, 1));
-      for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-      if (i < j)
-        {
-          for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-          p(j) = i;
-        }
-      else if (j < i)
-        {
-          p(j) = i;
-          for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-        }
+      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
+      p(j) = i;
+    }
+  else if (j < i)
+    {
+      p(j) = i;
+      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
+    }
 
-      init (a.index (idx_vector (p), idx_vector (p)), true, false);
-    }
+  init (a.index (idx_vector (p), idx_vector (p)), true, false);
 }
 
 #endif
 
 ComplexMatrix
 chol2inv (const ComplexMatrix& r)
 {
   return chol2inv_internal (r);
diff --git a/liboctave/numeric/CmplxGEPBAL.cc b/liboctave/numeric/CmplxGEPBAL.cc
--- a/liboctave/numeric/CmplxGEPBAL.cc
+++ b/liboctave/numeric/CmplxGEPBAL.cc
@@ -60,21 +60,18 @@ extern "C"
 
 octave_idx_type
 ComplexGEPBALANCE::init (const ComplexMatrix& a, const ComplexMatrix& b,
                          const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
-    {
-      (*current_liboctave_error_handler)
-        ("ComplexGEPBALANCE requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("ComplexGEPBALANCE requires square matrix");
 
   if (a.dims () != b.dims ())
     err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
diff --git a/liboctave/numeric/CmplxHESS.cc b/liboctave/numeric/CmplxHESS.cc
--- a/liboctave/numeric/CmplxHESS.cc
+++ b/liboctave/numeric/CmplxHESS.cc
@@ -62,21 +62,17 @@ extern "C"
 
 octave_idx_type
 ComplexHESS::init (const ComplexMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler)
-        ("ComplexHESS requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("ComplexHESS requires square matrix");
 
   char job = 'N';
   char side = 'R';
 
   octave_idx_type n = a_nc;
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
diff --git a/liboctave/numeric/CmplxLU.cc b/liboctave/numeric/CmplxLU.cc
--- a/liboctave/numeric/CmplxLU.cc
+++ b/liboctave/numeric/CmplxLU.cc
@@ -93,112 +93,104 @@ void ComplexLU::update (const ComplexCol
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      ComplexColumnVector utmp = u;
-      ComplexColumnVector vtmp = v;
-      F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  ComplexColumnVector utmp = u;
+  ComplexColumnVector vtmp = v;
+  F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
+                             utmp.fortran_vec (), vtmp.fortran_vec ()));
 }
 
 void ComplexLU::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   if (packed ())
     unpack ();
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          ComplexColumnVector utmp = u.column (i);
-          ComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec ()));
-        }
+      ComplexColumnVector utmp = u.column (i);
+      ComplexColumnVector vtmp = v.column (i);
+      F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void ComplexLU::update_piv (const ComplexColumnVector& u,
                             const ComplexColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      ComplexColumnVector utmp = u;
-      ComplexColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (Complex, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
-                                   m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (),
-                                   utmp.data (), vtmp.data (), w));
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  ComplexColumnVector utmp = u;
+  ComplexColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (Complex, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
+                               m, r.fortran_vec (), k,
+                               ipvt.fortran_vec (),
+                               utmp.data (), vtmp.data (), w));
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 void ComplexLU::update_piv (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   if (packed ())
     unpack ();
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (Complex, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (Complex, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          ComplexColumnVector utmp = u.column (i);
-          ComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
-                                       m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (),
-                                       utmp.data (), vtmp.data (), w));
-        }
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
+      ComplexColumnVector utmp = u.column (i);
+      ComplexColumnVector vtmp = v.column (i);
+      F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 #else
 
 void ComplexLU::update (const ComplexColumnVector&, const ComplexColumnVector&)
 {
   (*current_liboctave_error_handler)
     ("luupdate: not available in this version");
diff --git a/liboctave/numeric/CmplxQR.cc b/liboctave/numeric/CmplxQR.cc
--- a/liboctave/numeric/CmplxQR.cc
+++ b/liboctave/numeric/CmplxQR.cc
@@ -207,85 +207,79 @@ void ComplexQR::form (octave_idx_type n,
 
 void
 ComplexQR::update (const ComplexColumnVector& u, const ComplexColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      ComplexColumnVector utmp = u;
-      ComplexColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (Complex, w, k);
-      OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (),
-                                 w, rw));
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  ComplexColumnVector utmp = u;
+  ComplexColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (Complex, w, k);
+  OCTAVE_LOCAL_BUFFER (double, rw, k);
+  F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
+                             m, r.fortran_vec (), k,
+                             utmp.fortran_vec (), vtmp.fortran_vec (),
+                             w, rw));
 }
 
 void
 ComplexQR::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (Complex, w, k);
+  OCTAVE_LOCAL_BUFFER (double, rw, k);
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (Complex, w, k);
-      OCTAVE_LOCAL_BUFFER (double, rw, k);
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          ComplexColumnVector utmp = u.column (i);
-          ComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (),
-                                     w, rw));
-        }
+      ComplexColumnVector utmp = u.column (i);
+      ComplexColumnVector vtmp = v.column (i);
+      F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec (),
+                                 w, rw));
     }
-  else
-    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 ComplexQR::insert_col (const ComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
+
+  if (k < m)
+    {
+      q.resize (m, k+1);
+      r.resize (k+1, n+1);
+    }
   else
     {
-      if (k < m)
-        {
-          q.resize (m, k+1);
-          r.resize (k+1, n+1);
-        }
-      else
-        {
-          r.resize (k, n+1);
-        }
+      r.resize (k, n+1);
+    }
 
-      ComplexColumnVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrinc, ZQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 utmp.data (), rw));
-    }
+  ComplexColumnVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (double, rw, k);
+  F77_XFCN (zqrinc, ZQRINC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             utmp.data (), rw));
 }
 
 void
 ComplexQR::insert_col (const ComplexMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
@@ -294,21 +288,22 @@ ComplexQR::insert_col (const ComplexMatr
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
           q.resize (m, kmax);
           r.resize (kmax, n + nj);
         }
       else
@@ -333,31 +328,29 @@ void
 ComplexQR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (double, rw, k);
+  F77_XFCN (zqrdec, ZQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1, rw));
+
+  if (k < m)
+    {
+      q.resize (m, k-1);
+      r.resize (k-1, n-1);
+    }
   else
     {
-      OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrdec, ZQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, rw));
-
-      if (k < m)
-        {
-          q.resize (m, k-1);
-          r.resize (k-1, n-1);
-        }
-      else
-        {
-          r.resize (k, n-1);
-        }
+      r.resize (k, n-1);
     }
 }
 
 void
 ComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -367,19 +360,20 @@ ComplexQR::delete_col (const Array<octav
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
@@ -402,109 +396,99 @@ void
 ComplexQR::insert_row (const ComplexRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      q.resize (m + 1, m + 1);
-      r.resize (m + 1, n);
-      ComplexRowVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrinr, ZQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 j + 1, utmp.fortran_vec (), rw));
 
-    }
+  q.resize (m + 1, m + 1);
+  r.resize (m + 1, n);
+  ComplexRowVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (double, rw, k);
+  F77_XFCN (zqrinr, ZQRINR, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             j + 1, utmp.fortran_vec (), rw));
+
 }
 
 void
 ComplexQR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (Complex, w, m);
-      OCTAVE_LOCAL_BUFFER (double, rw, m);
-      F77_XFCN (zqrder, ZQRDER, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 w, rw));
 
-      q.resize (m - 1, m - 1);
-      r.resize (m - 1, n);
-    }
+  OCTAVE_LOCAL_BUFFER (Complex, w, m);
+  OCTAVE_LOCAL_BUFFER (double, rw, m);
+  F77_XFCN (zqrder, ZQRDER, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             w, rw));
+
+  q.resize (m - 1, m - 1);
+  r.resize (m - 1, n);
 }
 
 void
 ComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (Complex, w, k);
-      OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrshc, ZQRSHC, (m, n, k,
-                                 q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 i + 1, j + 1, w, rw));
-    }
+
+  OCTAVE_LOCAL_BUFFER (Complex, w, k);
+  OCTAVE_LOCAL_BUFFER (double, rw, k);
+  F77_XFCN (zqrshc, ZQRSHC, (m, n, k,
+                             q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             i + 1, j + 1, w, rw));
 }
 
 #else
 
 // Replacement update methods.
 
 void
 ComplexQR::update (const ComplexColumnVector& u, const ComplexColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      init (q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (),
-            get_type ());
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (),
+        get_type ());
 }
 
 void
 ComplexQR::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
-    {
-      init (q*r + u * v.hermitian (), get_type ());
-    }
-  else
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + u * v.hermitian (), get_type ());
 }
 
 static
 ComplexMatrix insert_col (const ComplexMatrix& a, octave_idx_type i,
                           const ComplexColumnVector& x)
 {
   ComplexMatrix retval (a.rows (), a.columns () + 1);
   retval.assign (idx_vector::colon, idx_vector (0, i),
@@ -570,22 +554,20 @@ ComplexQR::insert_col (const ComplexColu
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_col (q*r, j, u), get_type ());
-    }
+
+  init (::insert_col (q*r, j, u), get_type ());
 }
 
 void
 ComplexQR::insert_col (const ComplexMatrix& u, const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
@@ -595,21 +577,22 @@ ComplexQR::insert_col (const ComplexMatr
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       ComplexMatrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
@@ -617,20 +600,18 @@ void
 ComplexQR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_col (q*r, j), get_type ());
-    }
+
+  init (::delete_col (q*r, j), get_type ());
 }
 
 void
 ComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
@@ -639,19 +620,20 @@ ComplexQR::delete_col (const Array<octav
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       ComplexMatrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
@@ -660,49 +642,43 @@ ComplexQR::insert_row (const ComplexRowV
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_row (q*r, j, u), get_type ());
-    }
+
+  init (::insert_row (q*r, j, u), get_type ());
 }
 
 void
 ComplexQR::delete_row (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_row (q*r, j), get_type ());
-    }
+
+  init (::delete_row (q*r, j), get_type ());
 }
 
 void
 ComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      init (::shift_cols (q*r, i, j), get_type ());
-    }
+
+  init (::shift_cols (q*r, i, j), get_type ());
 }
 
 #endif
diff --git a/liboctave/numeric/CmplxSCHUR.cc b/liboctave/numeric/CmplxSCHUR.cc
--- a/liboctave/numeric/CmplxSCHUR.cc
+++ b/liboctave/numeric/CmplxSCHUR.cc
@@ -66,22 +66,19 @@ select_dig (const Complex& a)
 octave_idx_type
 ComplexSCHUR::init (const ComplexMatrix& a, const std::string& ord,
                     bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler)
-        ("ComplexSCHUR requires square matrix");
-      return -1;
-    }
-  else if (a_nr == 0)
+    (*current_liboctave_error_handler) ("ComplexSCHUR requires square matrix");
+
+  if (a_nr == 0)
     {
       schur_mat.clear ();
       unitary_mat.clear ();
       return 0;
     }
 
   // Workspace requirements may need to be fixed if any of the
   // following change.
diff --git a/liboctave/numeric/CmplxSVD.cc b/liboctave/numeric/CmplxSVD.cc
--- a/liboctave/numeric/CmplxSVD.cc
+++ b/liboctave/numeric/CmplxSVD.cc
@@ -52,36 +52,30 @@ extern "C"
                              octave_idx_type *, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 }
 
 ComplexMatrix
 ComplexSVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
-    {
-      (*current_liboctave_error_handler)
-        ("ComplexSVD: U not computed because type == SVD::sigma_only");
-      return ComplexMatrix ();
-    }
-  else
-    return left_sm;
+    (*current_liboctave_error_handler)
+      ("ComplexSVD: U not computed because type == SVD::sigma_only");
+
+  return left_sm;
 }
 
 ComplexMatrix
 ComplexSVD::right_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
-    {
-      (*current_liboctave_error_handler)
-        ("ComplexSVD: V not computed because type == SVD::sigma_only");
-      return ComplexMatrix ();
-    }
-  else
-    return right_sm;
+    (*current_liboctave_error_handler)
+      ("ComplexSVD: V not computed because type == SVD::sigma_only");
+
+  return right_sm;
 }
 
 octave_idx_type
 ComplexSVD::init (const ComplexMatrix& a, SVD::type svd_type,
                   SVD::driver svd_driver)
 {
   octave_idx_type info;
 
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -193,25 +193,27 @@ DASPK::do_integrate (double tout)
       if (user_fun)
         {
           octave_idx_type ires = 0;
 
           ColumnVector res = (*user_fun) (x, xdot, t, ires);
 
           if (res.numel () != x.numel ())
             {
+              // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: inconsistent sizes for state and residual vectors");
 
               integration_error = true;
               return retval;
             }
         }
       else
         {
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: no user supplied RHS subroutine!");
 
           integration_error = true;
           return retval;
         }
 
       info(4) = user_jac ? 1 : 0;
@@ -248,16 +250,18 @@ DASPK::do_integrate (double tout)
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
         }
       else
         {
+
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: inconsistent sizes for tolerance arrays");
 
           integration_error = true;
           return retval;
         }
 
       double hmax = maximum_step_size ();
@@ -283,16 +287,17 @@ DASPK::do_integrate (double tout)
         {
           if (maxord > 0 && maxord < 6)
             {
               info(8) = 1;
               iwork(2) = maxord;
             }
           else
             {
+              // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: invalid value for maximum order");
               integration_error = true;
               return retval;
             }
         }
 
       switch (eiq)
@@ -304,40 +309,43 @@ DASPK::do_integrate (double tout)
 
             if (ict.numel () == n)
               {
                 for (octave_idx_type i = 0; i < n; i++)
                   {
                     octave_idx_type val = ict(i);
                     if (val < -2 || val > 2)
                       {
+                        // FIXME: Should this be a warning?
                         (*current_liboctave_error_handler)
                           ("daspk: invalid value for inequality constraint type");
                         integration_error = true;
                         return retval;
                       }
                     iwork(40+i) = val;
                   }
               }
             else
               {
+                // FIXME: Should this be a warning?
                 (*current_liboctave_error_handler)
                   ("daspk: inequality constraint types size mismatch");
                 integration_error = true;
                 return retval;
               }
           }
           // Fall through...
 
         case 0:
         case 2:
           info(9) = eiq;
           break;
 
         default:
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: invalid value for enforce inequality constraints option");
           integration_error = true;
           return retval;
         }
 
       if (ccic)
         {
@@ -357,24 +365,26 @@ DASPK::do_integrate (double tout)
                   else
                     abort ();
 
                   for (octave_idx_type i = 0; i < n; i++)
                     iwork(lid+i) = av(i) ? -1 : 1;
                 }
               else
                 {
+                  // FIXME: Should this be a warning?
                   (*current_liboctave_error_handler)
                     ("daspk: algebraic variables size mismatch");
                   integration_error = true;
                   return retval;
                 }
             }
           else if (ccic != 2)
             {
+              // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: invalid value for compute consistent initial condition option");
               integration_error = true;
               return retval;
             }
 
           info(10) = ccic;
         }
@@ -413,16 +423,17 @@ DASPK::do_integrate (double tout)
               iwork(33) = NINTbig (ich(2));
               iwork(34) = NINTbig (ich(3));
 
               rwork(13) = ich(4);
               rwork(14) = ich(5);
             }
           else
             {
+              // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: invalid initial condition heuristics option");
               integration_error = true;
               return retval;
             }
 
           info(16) = 1;
         }
@@ -432,16 +443,17 @@ DASPK::do_integrate (double tout)
         {
         case 0:
         case 1:
         case 2:
           info(17) = pici;
           break;
 
         default:
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: invalid value for print initial condition info option");
           integration_error = true;
           return retval;
           break;
         }
 
       DASPK_options::reset = false;
@@ -513,18 +525,17 @@ DASPK::do_integrate (double tout)
               // and control is returned to the calling program. For
               // example, this occurs when invalid input is detected.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
-        ("unrecognized value of istate (= %d) returned from ddaspk",
-         istate);
+        ("unrecognized value of istate (= %d) returned from ddaspk", istate);
       break;
     }
 
   return retval;
 }
 
 Matrix
 DASPK::do_integrate (const ColumnVector& tout)
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -135,32 +135,26 @@ extern "C"
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 EIG::init (const Matrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
   Array<double> wr (dim_vector (n, 1));
   double *pwr = wr.fortran_vec ();
@@ -180,91 +174,77 @@ EIG::init (const Matrix& a, bool calc_ev
 
   F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pwr, pwi, dummy,
                            idummy, pvr, n, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (dim_vector (lwork, 1));
-      double *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("dgeev workspace query failed");
 
-      F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, tmp_data, n, pwr, pwi, dummy,
-                               idummy, pvr, n, pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<double> work (dim_vector (lwork, 1));
+  double *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in dgeev");
-          return info;
-        }
+  F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pwr, pwi, dummy,
+                           idummy, pvr, n, pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("dgeev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in dgeev");
 
-      lambda.resize (n);
-      octave_idx_type nvr = calc_ev ? n : 0;
-      v.resize (nvr, nvr);
+  if (info > 0)
+    (*current_liboctave_error_handler) ("dgeev failed to converge");
+
+  lambda.resize (n);
+  octave_idx_type nvr = calc_ev ? n : 0;
+  v.resize (nvr, nvr);
 
-      for (octave_idx_type j = 0; j < n; j++)
+  for (octave_idx_type j = 0; j < n; j++)
+    {
+      if (wi.elem (j) == 0.0)
         {
-          if (wi.elem (j) == 0.0)
-            {
-              lambda.elem (j) = Complex (wr.elem (j));
-              for (octave_idx_type i = 0; i < nvr; i++)
-                v.elem (i, j) = vr.elem (i, j);
-            }
-          else
+          lambda.elem (j) = Complex (wr.elem (j));
+          for (octave_idx_type i = 0; i < nvr; i++)
+            v.elem (i, j) = vr.elem (i, j);
+        }
+      else
+        {
+          if (j+1 >= n)
+            (*current_liboctave_error_handler) ("EIG: internal error");
+
+          lambda.elem (j) = Complex (wr.elem (j), wi.elem (j));
+          lambda.elem (j+1) = Complex (wr.elem (j+1), wi.elem (j+1));
+
+          for (octave_idx_type i = 0; i < nvr; i++)
             {
-              if (j+1 >= n)
-                {
-                  (*current_liboctave_error_handler) ("EIG: internal error");
-                  return -1;
-                }
-
-              lambda.elem (j) = Complex (wr.elem (j), wi.elem (j));
-              lambda.elem (j+1) = Complex (wr.elem (j+1), wi.elem (j+1));
-
-              for (octave_idx_type i = 0; i < nvr; i++)
-                {
-                  double real_part = vr.elem (i, j);
-                  double imag_part = vr.elem (i, j+1);
-                  v.elem (i, j) = Complex (real_part, imag_part);
-                  v.elem (i, j+1) = Complex (real_part, -imag_part);
-                }
-              j++;
+              double real_part = vr.elem (i, j);
+              double imag_part = vr.elem (i, j+1);
+              v.elem (i, j) = Complex (real_part, imag_part);
+              v.elem (i, j+1) = Complex (real_part, -imag_part);
             }
+          j++;
         }
     }
-  else
-    (*current_liboctave_error_handler) ("dgeev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 EIG::symmetric_init (const Matrix& a, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
@@ -273,69 +253,55 @@ EIG::symmetric_init (const Matrix& a, bo
   double dummy_work;
 
   F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (dim_vector (lwork, 1));
-      double *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("dsyev workspace query failed");
 
-      F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, tmp_data, n, pwr, pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<double> work (dim_vector (lwork, 1));
+  double *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
-          return info;
-        }
+  F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("dsyev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
 
-      lambda = ComplexColumnVector (wr);
-      v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("dsyev workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("dsyev failed to converge");
+
+  lambda = ComplexColumnVector (wr);
+  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const ComplexMatrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
   ComplexColumnVector w (n);
   Complex *pw = w.fortran_vec ();
@@ -356,60 +322,49 @@ EIG::init (const ComplexMatrix& a, bool 
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pw, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (dim_vector (lwork, 1));
-      Complex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("zgeev workspace query failed");
 
-      F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, tmp_data, n, pw, dummy, idummy,
-                               pv, n, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<Complex> work (dim_vector (lwork, 1));
+  Complex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
-          return info;
-        }
+  F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pw, dummy, idummy,
+                           pv, n, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("zgeev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
 
-      lambda = w;
-      v = vtmp;
-    }
-  else
-    (*current_liboctave_error_handler) ("zgeev workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("zgeev failed to converge");
+
+  lambda = w;
+  v = vtmp;
 
   return info;
 }
 
 octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
@@ -423,73 +378,56 @@ EIG::hermitian_init (const ComplexMatrix
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (dim_vector (lwork, 1));
-      Complex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("zheev workspace query failed");
 
-      F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, tmp_data, n, pwr, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<Complex> work (dim_vector (lwork, 1));
+  Complex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in zheev");
-          return info;
-        }
+  F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("zheev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in zheev");
 
-      lambda = ComplexColumnVector (wr);
-      v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("zheev workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("zheev failed to converge");
+
+  lambda = ComplexColumnVector (wr);
+  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const Matrix& a, const Matrix& b, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   Matrix tmp = b;
   double *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                              n, tmp_data, n,
@@ -529,102 +467,85 @@ EIG::init (const Matrix& a, const Matrix
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (dim_vector (lwork, 1));
-      double *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("dggev workspace query failed");
 
-      F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n,
-                               par, pai, pbeta,
-                               dummy, idummy, pvr, n,
-                               pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<double> work (dim_vector (lwork, 1));
+  double *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in dggev");
-          return info;
-        }
+  F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n,
+                           par, pai, pbeta,
+                           dummy, idummy, pvr, n,
+                           pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("dggev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in dggev");
 
-      lambda.resize (n);
-      octave_idx_type nvr = calc_ev ? n : 0;
-      v.resize (nvr, nvr);
+  if (info > 0)
+    (*current_liboctave_error_handler) ("dggev failed to converge");
+
+  lambda.resize (n);
+  octave_idx_type nvr = calc_ev ? n : 0;
+  v.resize (nvr, nvr);
 
-      for (octave_idx_type j = 0; j < n; j++)
+  for (octave_idx_type j = 0; j < n; j++)
+    {
+      if (ai.elem (j) == 0.0)
+        {
+          lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j));
+          for (octave_idx_type i = 0; i < nvr; i++)
+            v.elem (i, j) = vr.elem (i, j);
+        }
+      else
         {
-          if (ai.elem (j) == 0.0)
-            {
-              lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j));
-              for (octave_idx_type i = 0; i < nvr; i++)
-                v.elem (i, j) = vr.elem (i, j);
-            }
-          else
+          if (j+1 >= n)
+            (*current_liboctave_error_handler) ("EIG: internal error");
+
+          lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j),
+                                     ai.elem (j) / beta.elem (j));
+          lambda.elem (j+1) = Complex (ar.elem (j+1) / beta.elem (j+1),
+                                       ai.elem (j+1) / beta.elem (j+1));
+
+          for (octave_idx_type i = 0; i < nvr; i++)
             {
-              if (j+1 >= n)
-                {
-                  (*current_liboctave_error_handler) ("EIG: internal error");
-                  return -1;
-                }
-
-              lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j),
-                                         ai.elem (j) / beta.elem (j));
-              lambda.elem (j+1) = Complex (ar.elem (j+1) / beta.elem (j+1),
-                                           ai.elem (j+1) / beta.elem (j+1));
-
-              for (octave_idx_type i = 0; i < nvr; i++)
-                {
-                  double real_part = vr.elem (i, j);
-                  double imag_part = vr.elem (i, j+1);
-                  v.elem (i, j) = Complex (real_part, imag_part);
-                  v.elem (i, j+1) = Complex (real_part, -imag_part);
-                }
-              j++;
+              double real_part = vr.elem (i, j);
+              double imag_part = vr.elem (i, j+1);
+              v.elem (i, j) = Complex (real_part, imag_part);
+              v.elem (i, j+1) = Complex (real_part, -imag_part);
             }
+          j++;
         }
     }
-  else
-    (*current_liboctave_error_handler) ("dggev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 EIG::symmetric_init (const Matrix& a, const Matrix& b, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   Matrix atmp = a;
   double *atmp_data = atmp.fortran_vec ();
 
   Matrix btmp = b;
   double *btmp_data = btmp.fortran_vec ();
@@ -638,75 +559,58 @@ EIG::symmetric_init (const Matrix& a, co
   F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<double> work (dim_vector (lwork, 1));
-      double *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("dsygv workspace query failed");
 
-      F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n,
-                               btmp_data, n,
-                               pwr, pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<double> work (dim_vector (lwork, 1));
+  double *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in dsygv");
-          return info;
-        }
+  F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n,
+                           btmp_data, n,
+                           pwr, pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("dsygv failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in dsygv");
 
-      lambda = ComplexColumnVector (wr);
-      v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("dsygv workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("dsygv failed to converge");
+
+  lambda = ComplexColumnVector (wr);
+  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   ComplexMatrix tmp = b;
   Complex*tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                              n, tmp_data, n,
@@ -746,73 +650,59 @@ EIG::init (const ComplexMatrix& a, const
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (dim_vector (lwork, 1));
-      Complex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("zggev workspace query failed");
 
-      F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n,
-                               palpha, pbeta, dummy, idummy,
-                               pv, n, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<Complex> work (dim_vector (lwork, 1));
+  Complex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in zggev");
-          return info;
-        }
+  F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n,
+                           palpha, pbeta, dummy, idummy,
+                           pv, n, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("zggev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in zggev");
 
-      lambda.resize (n);
+  if (info > 0)
+    (*current_liboctave_error_handler) ("zggev failed to converge");
 
-      for (octave_idx_type j = 0; j < n; j++)
-        lambda.elem (j) = alpha.elem (j) / beta.elem (j);
+  lambda.resize (n);
 
-      v = vtmp;
-    }
-  else
-    (*current_liboctave_error_handler) ("zggev workspace query failed");
+  for (octave_idx_type j = 0; j < n; j++)
+    lambda.elem (j) = alpha.elem (j) / beta.elem (j);
+
+  v = vtmp;
 
   return info;
 }
 
 octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, const ComplexMatrix& b,
                      bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   ComplexMatrix atmp = a;
   Complex *atmp_data = atmp.fortran_vec ();
 
   ComplexMatrix btmp = b;
   Complex *btmp_data = btmp.fortran_vec ();
@@ -831,42 +721,34 @@ EIG::hermitian_init (const ComplexMatrix
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<Complex> work (dim_vector (lwork, 1));
-      Complex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
-      F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n,
-                               btmp_data, n,
-                               pwr, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<Complex> work (dim_vector (lwork, 1));
+  Complex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
-          return info;
-        }
+  F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n,
+                           btmp_data, n,
+                           pwr, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("zhegv failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
-      lambda = ComplexColumnVector (wr);
-      v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("zhegv workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("zhegv failed to converge");
+
+  lambda = ComplexColumnVector (wr);
+  v = calc_ev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -170,16 +170,17 @@ LSODE::do_integrate (double tout)
         {
           if (maxord > 0 && maxord <= max_maxord)
             {
               iwork(4) = maxord;
               iopt = 1;
             }
           else
             {
+              // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("lsode: invalid value for maximum order");
               integration_error = true;
               return retval;
             }
         }
 
       if (stop_time_set)
@@ -205,16 +206,17 @@ LSODE::do_integrate (double tout)
 
       user_fun = function ();
       user_jac = jacobian_function ();
 
       ColumnVector xdot = (*user_fun) (x, t);
 
       if (x.numel () != xdot.numel ())
         {
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("lsode: inconsistent sizes for state and derivative vectors");
 
           integration_error = true;
           return retval;
         }
 
       ODEFunc::reset = false;
@@ -227,16 +229,17 @@ LSODE::do_integrate (double tout)
       octave_idx_type abs_tol_len = abs_tol.numel ();
 
       if (abs_tol_len == 1)
         itol = 1;
       else if (abs_tol_len == n)
         itol = 2;
       else
         {
+          // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("lsode: inconsistent sizes for state and absolute tolerance vectors");
 
           integration_error = true;
           return retval;
         }
 
       double iss = initial_step_size ();
@@ -299,18 +302,17 @@ LSODE::do_integrate (double tout)
               // component i vanished, and atol or atol(i) = 0.)
     case -13: // return requested in user-supplied function.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
-        ("unrecognized value of istate (= %d) returned from lsode",
-         istate);
+        ("unrecognized value of istate (= %d) returned from lsode", istate);
       break;
     }
 
   return retval;
 }
 
 std::string
 LSODE::error_message (void) const
diff --git a/liboctave/numeric/Quad.cc b/liboctave/numeric/Quad.cc
--- a/liboctave/numeric/Quad.cc
+++ b/liboctave/numeric/Quad.cc
@@ -151,17 +151,16 @@ DefQuad::do_integrate (octave_idx_type& 
 
   return result;
 }
 
 float
 DefQuad::do_integrate (octave_idx_type&, octave_idx_type&, float&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
-  return 0.0;
 }
 
 double
 IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
                          double& abserr)
 {
   double result = 0.0;
 
@@ -205,24 +204,22 @@ IndefQuad::do_integrate (octave_idx_type
 
   return result;
 }
 
 float
 IndefQuad::do_integrate (octave_idx_type&, octave_idx_type&, float&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
-  return 0.0;
 }
 
 double
 FloatDefQuad::do_integrate (octave_idx_type&, octave_idx_type&, double&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
-  return 0.0;
 }
 
 float
 FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
                             float& abserr)
 {
   octave_idx_type npts = singularities.numel () + 2;
   float *points = singularities.fortran_vec ();
@@ -249,17 +246,16 @@ FloatDefQuad::do_integrate (octave_idx_t
 
   return result;
 }
 
 double
 FloatIndefQuad::do_integrate (octave_idx_type&, octave_idx_type&, double&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
-  return 0.0;
 }
 
 float
 FloatIndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
                               float& abserr)
 {
   float result = 0.0;
 
diff --git a/liboctave/numeric/SparseCmplxCHOL.cc b/liboctave/numeric/SparseCmplxCHOL.cc
--- a/liboctave/numeric/SparseCmplxCHOL.cc
+++ b/liboctave/numeric/SparseCmplxCHOL.cc
@@ -34,37 +34,34 @@ along with Octave; see the file COPYING.
 template class sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix>;
 
 // Compute the inverse of a matrix using the Cholesky factorization.
 SparseComplexMatrix
 chol2inv (const SparseComplexMatrix& r)
 {
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
-  SparseComplexMatrix retval;
 
-  if (r_nr == r_nc)
-    {
-      MatrixType mattype (r);
-      int typ = mattype.type (false);
-      double rcond;
-      octave_idx_type info;
-      SparseComplexMatrix rinv;
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("U must be a square matrix");
 
-      if (typ == MatrixType::Upper)
-        {
-          rinv = r.inverse (mattype, info, rcond, true, false);
-          retval = rinv.transpose () * rinv;
-        }
-      else if (typ == MatrixType::Lower)
-        {
-          rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
-          retval = rinv.transpose () * rinv;
-        }
-      else
-        (*current_liboctave_error_handler)
-          ("U must be a triangular matrix");
+  SparseComplexMatrix retval;
+  MatrixType mattype (r);
+  int typ = mattype.type (false);
+  double rcond;
+  octave_idx_type info;
+  SparseComplexMatrix rinv;
+
+  if (typ == MatrixType::Upper)
+    {
+      rinv = r.inverse (mattype, info, rcond, true, false);
+      retval = rinv.transpose () * rinv;
+    }
+  else if (typ == MatrixType::Lower)
+    {
+      rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
+      retval = rinv.transpose () * rinv;
     }
   else
-    (*current_liboctave_error_handler) ("U must be a square matrix");
+    (*current_liboctave_error_handler) ("U must be a triangular matrix");
 
   return retval;
 }
diff --git a/liboctave/numeric/SparseCmplxLU.cc b/liboctave/numeric/SparseCmplxLU.cc
--- a/liboctave/numeric/SparseCmplxLU.cc
+++ b/liboctave/numeric/SparseCmplxLU.cc
@@ -104,64 +104,64 @@ SparseComplexLU::SparseComplexLU (const 
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
                                           reinterpret_cast<const double *> (Ax),
                                           0, 0,
                                           &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler)
-        ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
-
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic);
+
+      (*current_liboctave_error_handler)
+        ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
                                         reinterpret_cast<const double *> (Ax),
                                         0, Symbolic, &Numeric, control,
                                         info);
       UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler)
-            ("SparseComplexLU::SparseComplexLU numeric factorization failed");
-
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           UMFPACK_ZNAME (free_numeric) (&Numeric);
+
+          (*current_liboctave_error_handler)
+            ("SparseComplexLU::SparseComplexLU numeric factorization failed");
         }
       else
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
           status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz, &ignore1,
                                              &ignore2, &ignore3, Numeric);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler)
-                ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
-
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
+
+              (*current_liboctave_error_handler)
+                ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
             }
           else
             {
               octave_idx_type n_inner = (nr < nc ? nr : nc);
 
               if (lnz < 1)
                 Lfact = SparseComplexMatrix (n_inner, nr,
                                              static_cast<octave_idx_type> (1));
@@ -204,20 +204,20 @@ SparseComplexLU::SparseComplexLU (const 
                                                     reinterpret_cast <double *> (Ux),
                                                     0, p, q, 0, 0,
                                                     &do_recip, Rx, Numeric);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
 
               if (status < 0)
                 {
+                  UMFPACK_ZNAME (report_status) (control, status);
+
                   (*current_liboctave_error_handler)
                     ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
-
-                  UMFPACK_ZNAME (report_status) (control, status);
                 }
               else
                 {
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
@@ -251,237 +251,235 @@ SparseComplexLU::SparseComplexLU (const 
                                   const Matrix& piv_thres, bool scale,
                                   bool FixedQ, double droptol,
                                   bool milu, bool udiag)
 {
 #ifdef HAVE_UMFPACK
   if (milu)
     (*current_liboctave_error_handler)
       ("Modified incomplete LU not implemented");
+
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+
+  // Setup the control parameters
+  Matrix Control (UMFPACK_CONTROL, 1);
+  double *control = Control.fortran_vec ();
+  UMFPACK_ZNAME (defaults) (control);
+
+  double tmp = octave_sparse_params::get_key ("spumoni");
+  if (! xisnan (tmp))
+    Control (UMFPACK_PRL) = tmp;
+  if (piv_thres.numel () == 2)
+    {
+      tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
+      if (! xisnan (tmp))
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+      tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
+      if (! xisnan (tmp))
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+    }
+  else
+    {
+      tmp = octave_sparse_params::get_key ("piv_tol");
+      if (! xisnan (tmp))
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+
+      tmp = octave_sparse_params::get_key ("sym_tol");
+      if (! xisnan (tmp))
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+    }
+
+  if (droptol >= 0.)
+    Control (UMFPACK_DROPTOL) = droptol;
+
+  // Set whether we are allowed to modify Q or not
+  if (FixedQ)
+    Control (UMFPACK_FIXQ) = 1.0;
   else
     {
-      octave_idx_type nr = a.rows ();
-      octave_idx_type nc = a.cols ();
-
-      // Setup the control parameters
-      Matrix Control (UMFPACK_CONTROL, 1);
-      double *control = Control.fortran_vec ();
-      UMFPACK_ZNAME (defaults) (control);
-
-      double tmp = octave_sparse_params::get_key ("spumoni");
+      tmp = octave_sparse_params::get_key ("autoamd");
       if (! xisnan (tmp))
-        Control (UMFPACK_PRL) = tmp;
-      if (piv_thres.numel () == 2)
+        Control (UMFPACK_FIXQ) = tmp;
+    }
+
+  // Turn-off UMFPACK scaling for LU
+  if (scale)
+    Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
+  else
+    Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
+
+  UMFPACK_ZNAME (report_control) (control);
+
+  const octave_idx_type *Ap = a.cidx ();
+  const octave_idx_type *Ai = a.ridx ();
+  const Complex *Ax = a.data ();
+
+  UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
+                                 reinterpret_cast<const double *> (Ax), 0,
+                                 1, control);
+
+  void *Symbolic;
+  Matrix Info (1, UMFPACK_INFO);
+  double *info = Info.fortran_vec ();
+  int status;
+
+  // Null loop so that qinit is imediately deallocated when not
+  // needed
+  do
+    {
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
+
+      for (octave_idx_type i = 0; i < nc; i++)
+        qinit[i] = static_cast<octave_idx_type> (Qinit (i));
+
+      status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
+                                          reinterpret_cast<const double *> (Ax),
+                                          0, qinit, &Symbolic, control,
+                                          info);
+    }
+  while (0);
+
+  if (status < 0)
+    {
+      UMFPACK_ZNAME (report_status) (control, status);
+      UMFPACK_ZNAME (report_info) (control, info);
+
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic);
+
+      (*current_liboctave_error_handler)
+        ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
+    }
+  else
+    {
+      UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
+
+      void *Numeric;
+      status = UMFPACK_ZNAME (numeric) (Ap, Ai,
+                                        reinterpret_cast<const double *> (Ax), 0,
+                                        Symbolic, &Numeric, control, info);
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic);
+
+      cond = Info (UMFPACK_RCOND);
+
+      if (status < 0)
         {
-          tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-          if (! xisnan (tmp))
-            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-          tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-          if (! xisnan (tmp))
-            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+          UMFPACK_ZNAME (report_status) (control, status);
+          UMFPACK_ZNAME (report_info) (control, info);
+
+          UMFPACK_ZNAME (free_numeric) (&Numeric);
+
+          (*current_liboctave_error_handler)
+            ("SparseComplexLU::SparseComplexLU numeric factorization failed");
         }
       else
         {
-          tmp = octave_sparse_params::get_key ("piv_tol");
-          if (! xisnan (tmp))
-            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-
-          tmp = octave_sparse_params::get_key ("sym_tol");
-          if (! xisnan (tmp))
-            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-        }
-
-      if (droptol >= 0.)
-        Control (UMFPACK_DROPTOL) = droptol;
-
-      // Set whether we are allowed to modify Q or not
-      if (FixedQ)
-        Control (UMFPACK_FIXQ) = 1.0;
-      else
-        {
-          tmp = octave_sparse_params::get_key ("autoamd");
-          if (! xisnan (tmp))
-            Control (UMFPACK_FIXQ) = tmp;
-        }
-
-      // Turn-off UMFPACK scaling for LU
-      if (scale)
-        Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
-      else
-        Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
-
-      UMFPACK_ZNAME (report_control) (control);
-
-      const octave_idx_type *Ap = a.cidx ();
-      const octave_idx_type *Ai = a.ridx ();
-      const Complex *Ax = a.data ();
-
-      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
-                                     reinterpret_cast<const double *> (Ax), 0,
-                                     1, control);
+          UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
-      void *Symbolic;
-      Matrix Info (1, UMFPACK_INFO);
-      double *info = Info.fortran_vec ();
-      int status;
-
-      // Null loop so that qinit is imediately deallocated when not
-      // needed
-      do
-        {
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
-
-          for (octave_idx_type i = 0; i < nc; i++)
-            qinit[i] = static_cast<octave_idx_type> (Qinit (i));
-
-          status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
-                                              reinterpret_cast<const double *> (Ax),
-                                              0, qinit, &Symbolic, control,
-                                              info);
-        }
-      while (0);
-
-      if (status < 0)
-        {
-          (*current_liboctave_error_handler)
-            ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
-
-          UMFPACK_ZNAME (report_status) (control, status);
-          UMFPACK_ZNAME (report_info) (control, info);
-
-          UMFPACK_ZNAME (free_symbolic) (&Symbolic);
-        }
-      else
-        {
-          UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
-
-          void *Numeric;
-          status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-                                            reinterpret_cast<const double *> (Ax), 0,
-                                            Symbolic, &Numeric, control, info);
-          UMFPACK_ZNAME (free_symbolic) (&Symbolic);
-
-          cond = Info (UMFPACK_RCOND);
+          octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+          status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz,
+                                             &ignore1, &ignore2, &ignore3,
+                                             Numeric);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler)
-                ("SparseComplexLU::SparseComplexLU numeric factorization failed");
-
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
+
+              (*current_liboctave_error_handler)
+                ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
             }
           else
             {
-              UMFPACK_ZNAME (report_numeric) (Numeric, control);
+              octave_idx_type n_inner = (nr < nc ? nr : nc);
+
+              if (lnz < 1)
+                Lfact = SparseComplexMatrix (n_inner, nr,
+                                             static_cast<octave_idx_type> (1));
+              else
+                Lfact = SparseComplexMatrix (n_inner, nr, lnz);
+
+              octave_idx_type *Ltp = Lfact.cidx ();
+              octave_idx_type *Ltj = Lfact.ridx ();
+              Complex *Ltx = Lfact.data ();
+
+              if (unz < 1)
+                Ufact = SparseComplexMatrix (n_inner, nc,
+                                             static_cast<octave_idx_type> (1));
+              else
+                Ufact = SparseComplexMatrix  (n_inner, nc, unz);
+
+              octave_idx_type *Up = Ufact.cidx ();
+              octave_idx_type *Uj = Ufact.ridx ();
+              Complex *Ux = Ufact.data ();
 
-              octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
-              status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz,
-                                                 &ignore1, &ignore2, &ignore3,
-                                                 Numeric);
+              Rfact = SparseMatrix (nr, nr, nr);
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  Rfact.xridx (i) = i;
+                  Rfact.xcidx (i) = i;
+                }
+              Rfact.xcidx (nr) = nr;
+              double *Rx = Rfact.data ();
+
+              P.resize (dim_vector (nr, 1));
+              octave_idx_type *p = P.fortran_vec ();
+
+              Q.resize (dim_vector (nc, 1));
+              octave_idx_type *q = Q.fortran_vec ();
+
+              octave_idx_type do_recip;
+              status =
+                UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
+                                             reinterpret_cast<double *> (Ltx),
+                                             0, Up, Uj,
+                                             reinterpret_cast<double *> (Ux),
+                                             0, p, q, 0, 0,
+                                             &do_recip, Rx, Numeric);
+
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
 
               if (status < 0)
                 {
+                  UMFPACK_ZNAME (report_status) (control, status);
+
                   (*current_liboctave_error_handler)
                     ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
-
-                  UMFPACK_ZNAME (report_status) (control, status);
-                  UMFPACK_ZNAME (report_info) (control, info);
-
-                  UMFPACK_ZNAME (free_numeric) (&Numeric);
                 }
               else
                 {
-                  octave_idx_type n_inner = (nr < nc ? nr : nc);
-
-                  if (lnz < 1)
-                    Lfact = SparseComplexMatrix (n_inner, nr,
-                                                 static_cast<octave_idx_type> (1));
-                  else
-                    Lfact = SparseComplexMatrix (n_inner, nr, lnz);
-
-                  octave_idx_type *Ltp = Lfact.cidx ();
-                  octave_idx_type *Ltj = Lfact.ridx ();
-                  Complex *Ltx = Lfact.data ();
-
-                  if (unz < 1)
-                    Ufact = SparseComplexMatrix (n_inner, nc,
-                                                 static_cast<octave_idx_type> (1));
-                  else
-                    Ufact = SparseComplexMatrix  (n_inner, nc, unz);
+                  Lfact = Lfact.transpose ();
 
-                  octave_idx_type *Up = Ufact.cidx ();
-                  octave_idx_type *Uj = Ufact.ridx ();
-                  Complex *Ux = Ufact.data ();
-
-                  Rfact = SparseMatrix (nr, nr, nr);
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    {
-                      Rfact.xridx (i) = i;
-                      Rfact.xcidx (i) = i;
-                    }
-                  Rfact.xcidx (nr) = nr;
-                  double *Rx = Rfact.data ();
-
-                  P.resize (dim_vector (nr, 1));
-                  octave_idx_type *p = P.fortran_vec ();
-
-                  Q.resize (dim_vector (nc, 1));
-                  octave_idx_type *q = Q.fortran_vec ();
+                  if (do_recip)
+                    for (octave_idx_type i = 0; i < nr; i++)
+                      Rx[i] = 1.0 / Rx[i];
 
-                  octave_idx_type do_recip;
-                  status =
-                    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
-                                                 reinterpret_cast<double *> (Ltx),
-                                                 0, Up, Uj,
-                                                 reinterpret_cast<double *> (Ux),
-                                                 0, p, q, 0, 0,
-                                                 &do_recip, Rx, Numeric);
-
-                  UMFPACK_ZNAME (free_numeric) (&Numeric);
-
-                  if (status < 0)
-                    {
-                      (*current_liboctave_error_handler)
-                        ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
-
-                      UMFPACK_ZNAME (report_status) (control, status);
-                    }
-                  else
-                    {
-                      Lfact = Lfact.transpose ();
+                  UMFPACK_ZNAME (report_matrix) (nr, n_inner,
+                                                 Lfact.cidx (),
+                                                 Lfact.ridx (),
+                                                 reinterpret_cast<double *> (Lfact.data ()),
+                                                 0, 1, control);
 
-                      if (do_recip)
-                        for (octave_idx_type i = 0; i < nr; i++)
-                          Rx[i] = 1.0 / Rx[i];
-
-                      UMFPACK_ZNAME (report_matrix) (nr, n_inner,
-                                                     Lfact.cidx (),
-                                                     Lfact.ridx (),
-                                                     reinterpret_cast<double *> (Lfact.data ()),
-                                                     0, 1, control);
+                  UMFPACK_ZNAME (report_matrix) (n_inner, nc,
+                                                 Ufact.cidx (),
+                                                 Ufact.ridx (),
+                                                 reinterpret_cast<double *> (Ufact.data ()),
+                                                 0, 1, control);
+                  UMFPACK_ZNAME (report_perm) (nr, p, control);
+                  UMFPACK_ZNAME (report_perm) (nc, q, control);
+                }
 
-                      UMFPACK_ZNAME (report_matrix) (n_inner, nc,
-                                                     Ufact.cidx (),
-                                                     Ufact.ridx (),
-                                                     reinterpret_cast<double *> (Ufact.data ()),
-                                                     0, 1, control);
-                      UMFPACK_ZNAME (report_perm) (nr, p, control);
-                      UMFPACK_ZNAME (report_perm) (nc, q, control);
-                    }
-
-                  UMFPACK_ZNAME (report_info) (control, info);
-                }
+              UMFPACK_ZNAME (report_info) (control, info);
             }
         }
+    }
 
-      if (udiag)
-        (*current_liboctave_error_handler)
-          ("Option udiag of incomplete LU not implemented");
-    }
+  if (udiag)
+    (*current_liboctave_error_handler)
+      ("Option udiag of incomplete LU not implemented");
 
 #else
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
 #endif
 }
diff --git a/liboctave/numeric/SparseCmplxQR.cc b/liboctave/numeric/SparseCmplxQR.cc
--- a/liboctave/numeric/SparseCmplxQR.cc
+++ b/liboctave/numeric/SparseCmplxQR.cc
@@ -74,16 +74,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
 #else
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (! N)
     (*current_liboctave_error_handler)
       ("SparseComplexQR: sparse matrix QR factorization filled");
+
   count = 1;
 
 #else
   (*current_liboctave_error_handler)
     ("SparseComplexQR: support for CXSparse was unavailable or disabled when liboctave was built");
 #endif
 }
 
@@ -198,17 +199,18 @@ SparseComplexQR::SparseComplexQR_rep::C 
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   const cs_complex_t *bvec =
     reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix ret(b_nr, b_nc);
   Complex *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
@@ -244,17 +246,18 @@ SparseComplexQR::SparseComplexQR_rep::Q 
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   ComplexMatrix ret(nr, nr);
   Complex *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
-  else if (nr == 0 || nc == 0)
+
+  if (nr == 0 || nc == 0)
     ret = ComplexMatrix (nc, nr, Complex (0.0, 0.0));
   else
     {
       OCTAVE_C99_COMPLEX (bvec, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         bvec[i] = OCTAVE_C99_ZERO;
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
@@ -299,17 +302,18 @@ qrsolve (const SparseComplexMatrix&a, co
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
@@ -427,17 +431,18 @@ qrsolve (const SparseComplexMatrix&a, co
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
@@ -603,17 +608,18 @@ qrsolve (const SparseComplexMatrix&a, co
   octave_idx_type b_nr = b.rows ();
   const cs_complex_t *bvec =
     reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
@@ -723,17 +729,18 @@ qrsolve (const SparseComplexMatrix&a, co
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
diff --git a/liboctave/numeric/SparseQR.cc b/liboctave/numeric/SparseQR.cc
--- a/liboctave/numeric/SparseQR.cc
+++ b/liboctave/numeric/SparseQR.cc
@@ -54,16 +54,17 @@ SparseQR::SparseQR_rep::SparseQR_rep (co
   S = CXSPARSE_DNAME (_sqr) (&A, order - 1, 1);
 #endif
 
   N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (! N)
     (*current_liboctave_error_handler)
       ("SparseQR: sparse matrix QR factorization filled");
+
   count = 1;
 
 #else
   (*current_liboctave_error_handler)
     ("SparseQR: support for CXSparse was unavailable or disabled when liboctave was built");
 #endif
 }
 
@@ -179,17 +180,18 @@ SparseQR::SparseQR_rep::C (const Matrix 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   const double *bvec = b.fortran_vec ();
   Matrix ret (b_nr, b_nc);
   double *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     ret = Matrix (nc, b_nc, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type i = nr; i < S->m2; i++)
@@ -225,17 +227,18 @@ SparseQR::SparseQR_rep::Q (void) const
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   Matrix ret (nr, nr);
   double *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
-  else if (nr == 0 || nc == 0)
+
+  if (nr == 0 || nc == 0)
     ret = Matrix (nc, nr, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, bvec, nr + 1);
       for (octave_idx_type i = 0; i < nr; i++)
         bvec[i] = 0.;
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
@@ -281,17 +284,18 @@ qrsolve (const SparseMatrix&a, const Mat
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   const double *bvec = b.fortran_vec ();
   Matrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return Matrix ();
       x.resize (nc, b_nc);
       double *vec = x.fortran_vec ();
@@ -385,17 +389,18 @@ qrsolve (const SparseMatrix&a, const Spa
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   SparseMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return SparseMatrix ();
       x = SparseMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
@@ -535,17 +540,18 @@ qrsolve (const SparseMatrix&a, const Com
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       Complex *vec = x.fortran_vec ();
@@ -704,17 +710,18 @@ qrsolve (const SparseMatrix&a, const Spa
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx (0) = 0;
diff --git a/liboctave/numeric/SparsedbleCHOL.cc b/liboctave/numeric/SparsedbleCHOL.cc
--- a/liboctave/numeric/SparsedbleCHOL.cc
+++ b/liboctave/numeric/SparsedbleCHOL.cc
@@ -36,35 +36,32 @@ template class sparse_base_chol <SparseM
 // Compute the inverse of a matrix using the Cholesky factorization.
 SparseMatrix
 chol2inv (const SparseMatrix& r)
 {
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
   SparseMatrix retval;
 
-  if (r_nr == r_nc)
-    {
-      MatrixType mattype (r);
-      int typ = mattype.type (false);
-      double rcond;
-      octave_idx_type info;
-      SparseMatrix rinv;
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("U must be a square matrix");
+
+  MatrixType mattype (r);
+  int typ = mattype.type (false);
+  double rcond;
+  octave_idx_type info;
+  SparseMatrix rinv;
 
-      if (typ == MatrixType::Upper)
-        {
-          rinv = r.inverse (mattype, info, rcond, true, false);
-          retval = rinv.transpose () * rinv;
-        }
-      else if (typ == MatrixType::Lower)
-        {
-          rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
-          retval = rinv.transpose () * rinv;
-        }
-      else
-        (*current_liboctave_error_handler)
-          ("U must be a triangular matrix");
+  if (typ == MatrixType::Upper)
+    {
+      rinv = r.inverse (mattype, info, rcond, true, false);
+      retval = rinv.transpose () * rinv;
+    }
+  else if (typ == MatrixType::Lower)
+    {
+      rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
+      retval = rinv.transpose () * rinv;
     }
   else
-    (*current_liboctave_error_handler) ("U must be a square matrix");
+    (*current_liboctave_error_handler) ("U must be a triangular matrix");
 
   return retval;
 }
diff --git a/liboctave/numeric/SparsedbleLU.cc b/liboctave/numeric/SparsedbleLU.cc
--- a/liboctave/numeric/SparsedbleLU.cc
+++ b/liboctave/numeric/SparsedbleLU.cc
@@ -98,62 +98,62 @@ SparseLU::SparseLU (const SparseMatrix& 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
                                           &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler)
-        ("SparseLU::SparseLU symbolic factorization failed");
-
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+
+      (*current_liboctave_error_handler)
+        ("SparseLU::SparseLU symbolic factorization failed");
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
                                         &Numeric, control, info) ;
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler)
-            ("SparseLU::SparseLU numeric factorization failed");
-
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           UMFPACK_DNAME (free_numeric) (&Numeric);
+
+          (*current_liboctave_error_handler)
+            ("SparseLU::SparseLU numeric factorization failed");
         }
       else
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
           status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1,
                                              &ignore2, &ignore3, Numeric) ;
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler)
-                ("SparseLU::SparseLU extracting LU factors failed");
-
               UMFPACK_DNAME (report_status) (control, status);
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
+
+              (*current_liboctave_error_handler)
+                ("SparseLU::SparseLU extracting LU factors failed");
             }
           else
             {
               octave_idx_type n_inner = (nr < nc ? nr : nc);
 
               if (lnz < 1)
                 Lfact = SparseMatrix (n_inner, nr,
                                       static_cast<octave_idx_type> (1));
@@ -194,20 +194,20 @@ SparseLU::SparseLU (const SparseMatrix& 
                                                     Up, Uj, Ux, p, q, 0,
                                                     &do_recip, Rx,
                                                     Numeric) ;
 
               UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
               if (status < 0)
                 {
+                  UMFPACK_DNAME (report_status) (control, status);
+
                   (*current_liboctave_error_handler)
                     ("SparseLU::SparseLU extracting LU factors failed");
-
-                  UMFPACK_DNAME (report_status) (control, status);
                 }
               else
                 {
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
@@ -236,229 +236,227 @@ SparseLU::SparseLU (const SparseMatrix& 
 SparseLU::SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
                     const Matrix& piv_thres, bool scale, bool FixedQ,
                     double droptol, bool milu, bool udiag)
 {
 #ifdef HAVE_UMFPACK
   if (milu)
     (*current_liboctave_error_handler)
       ("Modified incomplete LU not implemented");
+
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+
+  // Setup the control parameters
+  Matrix Control (UMFPACK_CONTROL, 1);
+  double *control = Control.fortran_vec ();
+  UMFPACK_DNAME (defaults) (control);
+
+  double tmp = octave_sparse_params::get_key ("spumoni");
+  if (! xisnan (tmp))
+    Control (UMFPACK_PRL) = tmp;
+
+  if (piv_thres.numel () == 2)
+    {
+      tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
+      if (! xisnan (tmp))
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+      tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
+      if (! xisnan (tmp))
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+    }
+  else
+    {
+      tmp = octave_sparse_params::get_key ("piv_tol");
+      if (! xisnan (tmp))
+        Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+
+      tmp = octave_sparse_params::get_key ("sym_tol");
+      if (! xisnan (tmp))
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+    }
+
+  if (droptol >= 0.)
+    Control (UMFPACK_DROPTOL) = droptol;
+
+
+  // Set whether we are allowed to modify Q or not
+  if (FixedQ)
+    Control (UMFPACK_FIXQ) = 1.0;
   else
     {
-      octave_idx_type nr = a.rows ();
-      octave_idx_type nc = a.cols ();
-
-      // Setup the control parameters
-      Matrix Control (UMFPACK_CONTROL, 1);
-      double *control = Control.fortran_vec ();
-      UMFPACK_DNAME (defaults) (control);
-
-      double tmp = octave_sparse_params::get_key ("spumoni");
+      tmp = octave_sparse_params::get_key ("autoamd");
       if (! xisnan (tmp))
-        Control (UMFPACK_PRL) = tmp;
+        Control (UMFPACK_FIXQ) = tmp;
+    }
+
+  if (scale)
+    Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
+  else
+    Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
+
+  UMFPACK_DNAME (report_control) (control);
+
+  const octave_idx_type *Ap = a.cidx ();
+  const octave_idx_type *Ai = a.ridx ();
+  const double *Ax = a.data ();
+
+  UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1,
+                                 control);
+
+  void *Symbolic;
+  Matrix Info (1, UMFPACK_INFO);
+  double *info = Info.fortran_vec ();
+  int status;
+
+  // Null loop so that qinit is imediately deallocated when not needed
+  do
+    {
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
-      if (piv_thres.numel () == 2)
+      for (octave_idx_type i = 0; i < nc; i++)
+        qinit[i] = static_cast<octave_idx_type> (Qinit (i));
+
+      status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax,
+                                          qinit, &Symbolic, control, info);
+    }
+  while (0);
+
+  if (status < 0)
+    {
+      UMFPACK_DNAME (report_status) (control, status);
+      UMFPACK_DNAME (report_info) (control, info);
+
+      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+
+      (*current_liboctave_error_handler)
+        ("SparseLU::SparseLU symbolic factorization failed");
+    }
+  else
+    {
+      UMFPACK_DNAME (report_symbolic) (Symbolic, control);
+
+      void *Numeric;
+      status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
+                                        &Numeric, control, info) ;
+      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+
+      cond = Info (UMFPACK_RCOND);
+
+      if (status < 0)
         {
-          tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-          if (! xisnan (tmp))
-            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-          tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-          if (! xisnan (tmp))
-            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+          UMFPACK_DNAME (report_status) (control, status);
+          UMFPACK_DNAME (report_info) (control, info);
+
+          UMFPACK_DNAME (free_numeric) (&Numeric);
+
+          (*current_liboctave_error_handler)
+            ("SparseLU::SparseLU numeric factorization failed");
         }
       else
         {
-          tmp = octave_sparse_params::get_key ("piv_tol");
-          if (! xisnan (tmp))
-            Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
-
-          tmp = octave_sparse_params::get_key ("sym_tol");
-          if (! xisnan (tmp))
-            Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
-        }
-
-      if (droptol >= 0.)
-        Control (UMFPACK_DROPTOL) = droptol;
-
-
-      // Set whether we are allowed to modify Q or not
-      if (FixedQ)
-        Control (UMFPACK_FIXQ) = 1.0;
-      else
-        {
-          tmp = octave_sparse_params::get_key ("autoamd");
-          if (! xisnan (tmp))
-            Control (UMFPACK_FIXQ) = tmp;
-        }
-
-      if (scale)
-        Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
-      else
-        Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
-
-      UMFPACK_DNAME (report_control) (control);
-
-      const octave_idx_type *Ap = a.cidx ();
-      const octave_idx_type *Ai = a.ridx ();
-      const double *Ax = a.data ();
-
-      UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1,
-                                     control);
+          UMFPACK_DNAME (report_numeric) (Numeric, control);
 
-      void *Symbolic;
-      Matrix Info (1, UMFPACK_INFO);
-      double *info = Info.fortran_vec ();
-      int status;
-
-      // Null loop so that qinit is imediately deallocated when not needed
-      do
-        {
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
-
-          for (octave_idx_type i = 0; i < nc; i++)
-            qinit[i] = static_cast<octave_idx_type> (Qinit (i));
-
-          status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax,
-                                              qinit, &Symbolic, control, info);
-        }
-      while (0);
-
-      if (status < 0)
-        {
-          (*current_liboctave_error_handler)
-            ("SparseLU::SparseLU symbolic factorization failed");
-
-          UMFPACK_DNAME (report_status) (control, status);
-          UMFPACK_DNAME (report_info) (control, info);
-
-          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
-        }
-      else
-        {
-          UMFPACK_DNAME (report_symbolic) (Symbolic, control);
-
-          void *Numeric;
-          status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-                                            &Numeric, control, info) ;
-          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
-
-          cond = Info (UMFPACK_RCOND);
+          octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+          status = UMFPACK_DNAME (get_lunz) (&lnz, &unz,
+                                             &ignore1, &ignore2, &ignore3,
+                                             Numeric) ;
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler)
-                ("SparseLU::SparseLU numeric factorization failed");
-
               UMFPACK_DNAME (report_status) (control, status);
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
+
+              (*current_liboctave_error_handler)
+                ("SparseLU::SparseLU extracting LU factors failed");
             }
           else
             {
-              UMFPACK_DNAME (report_numeric) (Numeric, control);
+              octave_idx_type n_inner = (nr < nc ? nr : nc);
+
+              if (lnz < 1)
+                Lfact = SparseMatrix (n_inner, nr,
+                                      static_cast<octave_idx_type> (1));
+              else
+                Lfact = SparseMatrix (n_inner, nr, lnz);
+
+              octave_idx_type *Ltp = Lfact.cidx ();
+              octave_idx_type *Ltj = Lfact.ridx ();
+              double *Ltx = Lfact.data ();
+
+              if (unz < 1)
+                Ufact = SparseMatrix (n_inner, nc,
+                                      static_cast<octave_idx_type> (1));
+              else
+                Ufact = SparseMatrix (n_inner, nc, unz);
+
+              octave_idx_type *Up = Ufact.cidx ();
+              octave_idx_type *Uj = Ufact.ridx ();
+              double *Ux = Ufact.data ();
 
-              octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
-              status = UMFPACK_DNAME (get_lunz) (&lnz, &unz,
-                                                 &ignore1, &ignore2, &ignore3,
-                                                 Numeric) ;
+              Rfact = SparseMatrix (nr, nr, nr);
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  Rfact.xridx (i) = i;
+                  Rfact.xcidx (i) = i;
+                }
+              Rfact.xcidx (nr) = nr;
+              double *Rx = Rfact.data ();
+
+              P.resize (dim_vector (nr, 1));
+              octave_idx_type *p = P.fortran_vec ();
+
+              Q.resize (dim_vector (nc, 1));
+              octave_idx_type *q = Q.fortran_vec ();
+
+              octave_idx_type do_recip;
+              status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
+                                                    Ltx, Up, Uj, Ux, p, q,
+                                                    0, &do_recip,
+                                                    Rx, Numeric) ;
+
+              UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
               if (status < 0)
                 {
+                  UMFPACK_DNAME (report_status) (control, status);
+
                   (*current_liboctave_error_handler)
                     ("SparseLU::SparseLU extracting LU factors failed");
-
-                  UMFPACK_DNAME (report_status) (control, status);
-                  UMFPACK_DNAME (report_info) (control, info);
-
-                  UMFPACK_DNAME (free_numeric) (&Numeric);
                 }
               else
                 {
-                  octave_idx_type n_inner = (nr < nc ? nr : nc);
-
-                  if (lnz < 1)
-                    Lfact = SparseMatrix (n_inner, nr,
-                                          static_cast<octave_idx_type> (1));
-                  else
-                    Lfact = SparseMatrix (n_inner, nr, lnz);
-
-                  octave_idx_type *Ltp = Lfact.cidx ();
-                  octave_idx_type *Ltj = Lfact.ridx ();
-                  double *Ltx = Lfact.data ();
-
-                  if (unz < 1)
-                    Ufact = SparseMatrix (n_inner, nc,
-                                          static_cast<octave_idx_type> (1));
-                  else
-                    Ufact = SparseMatrix (n_inner, nc, unz);
+                  Lfact = Lfact.transpose ();
 
-                  octave_idx_type *Up = Ufact.cidx ();
-                  octave_idx_type *Uj = Ufact.ridx ();
-                  double *Ux = Ufact.data ();
-
-                  Rfact = SparseMatrix (nr, nr, nr);
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    {
-                      Rfact.xridx (i) = i;
-                      Rfact.xcidx (i) = i;
-                    }
-                  Rfact.xcidx (nr) = nr;
-                  double *Rx = Rfact.data ();
-
-                  P.resize (dim_vector (nr, 1));
-                  octave_idx_type *p = P.fortran_vec ();
-
-                  Q.resize (dim_vector (nc, 1));
-                  octave_idx_type *q = Q.fortran_vec ();
+                  if (do_recip)
+                    for (octave_idx_type i = 0; i < nr; i++)
+                      Rx[i] = 1.0 / Rx[i];
 
-                  octave_idx_type do_recip;
-                  status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
-                                                        Ltx, Up, Uj, Ux, p, q,
-                                                        0, &do_recip,
-                                                        Rx, Numeric) ;
-
-                  UMFPACK_DNAME (free_numeric) (&Numeric) ;
-
-                  if (status < 0)
-                    {
-                      (*current_liboctave_error_handler)
-                        ("SparseLU::SparseLU extracting LU factors failed");
-
-                      UMFPACK_DNAME (report_status) (control, status);
-                    }
-                  else
-                    {
-                      Lfact = Lfact.transpose ();
+                  UMFPACK_DNAME (report_matrix) (nr, n_inner,
+                                                 Lfact.cidx (),
+                                                 Lfact.ridx (),
+                                                 Lfact.data (),
+                                                 1, control);
+                  UMFPACK_DNAME (report_matrix) (n_inner, nc,
+                                                 Ufact.cidx (),
+                                                 Ufact.ridx (),
+                                                 Ufact.data (),
+                                                 1, control);
+                  UMFPACK_DNAME (report_perm) (nr, p, control);
+                  UMFPACK_DNAME (report_perm) (nc, q, control);
+                }
 
-                      if (do_recip)
-                        for (octave_idx_type i = 0; i < nr; i++)
-                          Rx[i] = 1.0 / Rx[i];
-
-                      UMFPACK_DNAME (report_matrix) (nr, n_inner,
-                                                     Lfact.cidx (),
-                                                     Lfact.ridx (),
-                                                     Lfact.data (),
-                                                     1, control);
-                      UMFPACK_DNAME (report_matrix) (n_inner, nc,
-                                                     Ufact.cidx (),
-                                                     Ufact.ridx (),
-                                                     Ufact.data (),
-                                                     1, control);
-                      UMFPACK_DNAME (report_perm) (nr, p, control);
-                      UMFPACK_DNAME (report_perm) (nc, q, control);
-                    }
-
-                  UMFPACK_DNAME (report_info) (control, info);
-                }
+              UMFPACK_DNAME (report_info) (control, info);
             }
         }
+    }
 
-      if (udiag)
-        (*current_liboctave_error_handler)
-          ("Option udiag of incomplete LU not implemented");
-    }
+  if (udiag)
+    (*current_liboctave_error_handler)
+      ("Option udiag of incomplete LU not implemented");
 
 #else
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
 #endif
 }
diff --git a/liboctave/numeric/base-lu.cc b/liboctave/numeric/base-lu.cc
--- a/liboctave/numeric/base-lu.cc
+++ b/liboctave/numeric/base-lu.cc
@@ -108,16 +108,17 @@ base_lu <lu_type> :: U (void) const
 
 template <class lu_type>
 lu_type
 base_lu <lu_type> :: Y (void) const
 {
   if (! packed ())
     (*current_liboctave_error_handler)
       ("lu: Y () not implemented for unpacked form");
+
   return a_fact;
 }
 
 template <class lu_type>
 Array<octave_idx_type>
 base_lu <lu_type> :: getp (void) const
 {
   if (packed ())
diff --git a/liboctave/numeric/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
--- a/liboctave/numeric/bsxfun-defs.cc
+++ b/liboctave/numeric/bsxfun-defs.cc
@@ -51,22 +51,19 @@ do_bsxfun_op (const Array<X>& x, const A
     {
       octave_idx_type xk = dvx(i);
       octave_idx_type yk = dvy(i);
       if (xk == 1)
         dvr(i) = yk;
       else if (yk == 1 || xk == yk)
         dvr(i) = xk;
       else
-        {
-          (*current_liboctave_error_handler)
-            ("bsxfun: nonconformant dimensions: %s and %s",
-             x.dims ().str ().c_str (), y.dims ().str ().c_str ());
-          break;
-        }
+        (*current_liboctave_error_handler)
+          ("bsxfun: nonconformant dimensions: %s and %s",
+           x.dims ().str ().c_str (), y.dims ().str ().c_str ());
     }
 
   Array<R> retval (dvr);
 
   const X *xvec = x.fortran_vec ();
   const Y *yvec = y.fortran_vec ();
   R *rvec = retval.fortran_vec ();
 
diff --git a/liboctave/numeric/dbleAEPBAL.cc b/liboctave/numeric/dbleAEPBAL.cc
--- a/liboctave/numeric/dbleAEPBAL.cc
+++ b/liboctave/numeric/dbleAEPBAL.cc
@@ -51,20 +51,17 @@ extern "C"
 }
 
 AEPBALANCE::AEPBALANCE (const Matrix& a, bool noperm, bool noscal)
   : base_aepbal<Matrix, ColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
-    {
-      (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
-      return;
-    }
+    (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
 
   octave_idx_type info;
 
   scale = ColumnVector (n);
   double *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   double *p_balanced_mat = balanced_mat.fortran_vec ();
diff --git a/liboctave/numeric/dbleCHOL.cc b/liboctave/numeric/dbleCHOL.cc
--- a/liboctave/numeric/dbleCHOL.cc
+++ b/liboctave/numeric/dbleCHOL.cc
@@ -88,20 +88,17 @@ extern "C"
 
 octave_idx_type
 CHOL::init (const Matrix& a, bool upper, bool calc_cond)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler) ("CHOL requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("CHOL requires square matrix");
 
   octave_idx_type n = a_nc;
   octave_idx_type info;
 
   is_upper = upper;
 
   chol_mat.clear (n, n);
   if (is_upper)
@@ -165,193 +162,179 @@ CHOL::init (const Matrix& a, bool upper,
 static Matrix
 chol2inv_internal (const Matrix& r, bool is_upper = true)
 {
   Matrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
-  if (r_nr == r_nc)
-    {
-      octave_idx_type n = r_nc;
-      octave_idx_type info = 0;
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+
+  octave_idx_type n = r_nc;
+  octave_idx_type info = 0;
+
+  Matrix tmp = r;
+  double *v = tmp.fortran_vec ();
 
-      Matrix tmp = r;
-      double *v = tmp.fortran_vec ();
+  if (info == 0)
+    {
+      if (is_upper)
+        F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
+      else
+        F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
 
-      if (info == 0)
+      // If someone thinks of a more graceful way of doing this (or
+      // faster for that matter :-)), please let me know!
+
+      if (n > 1)
         {
           if (is_upper)
-            F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                                       v, n, info
-                                       F77_CHAR_ARG_LEN (1)));
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (i, j) = tmp.xelem (j, i);
           else
-            F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                                       v, n, info
-                                       F77_CHAR_ARG_LEN (1)));
-
-          // If someone thinks of a more graceful way of doing this (or
-          // faster for that matter :-)), please let me know!
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (j, i) = tmp.xelem (i, j);
+        }
 
-          if (n > 1)
-            {
-              if (is_upper)
-                for (octave_idx_type j = 0; j < r_nc; j++)
-                  for (octave_idx_type i = j+1; i < r_nr; i++)
-                    tmp.xelem (i, j) = tmp.xelem (j, i);
-              else
-                for (octave_idx_type j = 0; j < r_nc; j++)
-                  for (octave_idx_type i = j+1; i < r_nr; i++)
-                    tmp.xelem (j, i) = tmp.xelem (i, j);
-            }
-
-          retval = tmp;
-        }
+      retval = tmp;
     }
-  else
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
 Matrix
 CHOL::inverse (void) const
 {
   return chol2inv_internal (chol_mat, is_upper);
 }
 
 void
 CHOL::set (const Matrix& R)
 {
-  if (R.is_square ())
-    chol_mat = R;
-  else
+  if (! R.is_square ())
     (*current_liboctave_error_handler) ("CHOL requires square matrix");
+
+  chol_mat = R;
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
 CHOL::update (const ColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      ColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (double, w, n);
+  ColumnVector utmp = u;
 
-      F77_XFCN (dch1up, DCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), w));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (double, w, n);
+
+  F77_XFCN (dch1up, DCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), w));
 }
 
 octave_idx_type
 CHOL::downdate (const ColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      ColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (double, w, n);
+  ColumnVector utmp = u;
 
-      F77_XFCN (dch1dn, DCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), w, info));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (double, w, n);
+
+  F77_XFCN (dch1dn, DCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), w, info));
 
   return info;
 }
 
 octave_idx_type
 CHOL::insert_sym (const ColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
-  else
-    {
-      ColumnVector utmp = u;
+
+  ColumnVector utmp = u;
 
-      OCTAVE_LOCAL_BUFFER (double, w, n);
-
-      chol_mat.resize (n+1, n+1);
+  OCTAVE_LOCAL_BUFFER (double, w, n);
 
-      F77_XFCN (dchinx, DCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, utmp.fortran_vec (), w, info));
-    }
+  chol_mat.resize (n+1, n+1);
+
+  F77_XFCN (dchinx, DCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, utmp.fortran_vec (), w, info));
 
   return info;
 }
 
 void
 CHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (double, w, n);
+
+  OCTAVE_LOCAL_BUFFER (double, w, n);
 
-      F77_XFCN (dchdex, DCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, w));
+  F77_XFCN (dchdex, DCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, w));
 
-      chol_mat.resize (n-1, n-1);
-    }
+  chol_mat.resize (n-1, n-1);
 }
 
 void
 CHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (double, w, 2*n);
+
+  OCTAVE_LOCAL_BUFFER (double, w, 2*n);
 
-      F77_XFCN (dchshx, DCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 i + 1, j + 1, w));
-    }
+  F77_XFCN (dchshx, DCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             i + 1, j + 1, w));
 }
 
 #else
 
 void
 CHOL::update (const ColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      init (chol_mat.transpose () * chol_mat
-            + Matrix (u) * Matrix (u).transpose (), true, false);
-    }
-  else
+  if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  init (chol_mat.transpose () * chol_mat
+        + Matrix (u) * Matrix (u).transpose (), true, false);
 }
 
 static bool
 singular (const Matrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     if (a(i,i) == 0.0) return true;
   return false;
@@ -361,117 +344,109 @@ octave_idx_type
 CHOL::downdate (const ColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  if (singular (chol_mat))
+    info = 2;
+  else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else
-        {
-          info = init (chol_mat.transpose () * chol_mat
-                       - Matrix (u) * Matrix (u).transpose (), true, false);
-          if (info) info = 1;
-        }
+      info = init (chol_mat.transpose () * chol_mat
+                   - Matrix (u) * Matrix (u).transpose (), true, false);
+      if (info) info = 1;
     }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
 
 octave_idx_type
 CHOL::insert_sym (const ColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
+
+  if (singular (chol_mat))
+    info = 2;
   else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else
-        {
-          Matrix a = chol_mat.transpose () * chol_mat;
-          Matrix a1 (n+1, n+1);
-          for (octave_idx_type k = 0; k < n+1; k++)
-            for (octave_idx_type l = 0; l < n+1; l++)
-              {
-                if (l == j)
-                  a1(k, l) = u(k);
-                else if (k == j)
-                  a1(k, l) = u(l);
-                else
-                  a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-              }
-          info = init (a1, true, false);
-          if (info) info = 1;
-        }
+      Matrix a = chol_mat.transpose () * chol_mat;
+      Matrix a1 (n+1, n+1);
+      for (octave_idx_type k = 0; k < n+1; k++)
+        for (octave_idx_type l = 0; l < n+1; l++)
+          {
+            if (l == j)
+              a1(k, l) = u(k);
+            else if (k == j)
+              a1(k, l) = u(l);
+            else
+              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
+          }
+      info = init (a1, true, false);
+      if (info) info = 1;
     }
 
   return info;
 }
 
 void
 CHOL::delete_sym (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      Matrix a = chol_mat.transpose () * chol_mat;
-      a.delete_elements (1, idx_vector (j));
-      a.delete_elements (0, idx_vector (j));
-      init (a, true, false);
-    }
+
+  Matrix a = chol_mat.transpose () * chol_mat;
+  a.delete_elements (1, idx_vector (j));
+  a.delete_elements (0, idx_vector (j));
+  init (a, true, false);
 }
 
 void
 CHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
+
+  Matrix a = chol_mat.transpose () * chol_mat;
+  Array<octave_idx_type> p (dim_vector (n, 1));
+  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
+  if (i < j)
     {
-      Matrix a = chol_mat.transpose () * chol_mat;
-      Array<octave_idx_type> p (dim_vector (n, 1));
-      for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-      if (i < j)
-        {
-          for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-          p(j) = i;
-        }
-      else if (j < i)
-        {
-          p(j) = i;
-          for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-        }
+      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
+      p(j) = i;
+    }
+  else if (j < i)
+    {
+      p(j) = i;
+      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
+    }
 
-      init (a.index (idx_vector (p), idx_vector (p)), true, false);
-    }
+  init (a.index (idx_vector (p), idx_vector (p)), true, false);
 }
 
 #endif
 
 Matrix
 chol2inv (const Matrix& r)
 {
   return chol2inv_internal (r);
diff --git a/liboctave/numeric/dbleGEPBAL.cc b/liboctave/numeric/dbleGEPBAL.cc
--- a/liboctave/numeric/dbleGEPBAL.cc
+++ b/liboctave/numeric/dbleGEPBAL.cc
@@ -60,20 +60,17 @@ extern "C"
 
 octave_idx_type
 GEPBALANCE::init (const Matrix& a, const Matrix& b,
                   const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
-    {
-      (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
 
   if (a.dims () != b.dims ())
     err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
diff --git a/liboctave/numeric/dbleHESS.cc b/liboctave/numeric/dbleHESS.cc
--- a/liboctave/numeric/dbleHESS.cc
+++ b/liboctave/numeric/dbleHESS.cc
@@ -62,20 +62,17 @@ extern "C"
 
 octave_idx_type
 HESS::init (const Matrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler) ("HESS requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("HESS requires square matrix");
 
   char job = 'N';
   char side = 'R';
 
   octave_idx_type n = a_nc;
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
diff --git a/liboctave/numeric/dbleLU.cc b/liboctave/numeric/dbleLU.cc
--- a/liboctave/numeric/dbleLU.cc
+++ b/liboctave/numeric/dbleLU.cc
@@ -92,111 +92,103 @@ void LU::update (const ColumnVector& u, 
 
   Matrix& l = l_fact;
   Matrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      ColumnVector utmp = u;
-      ColumnVector vtmp = v;
-      F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  ColumnVector utmp = u;
+  ColumnVector vtmp = v;
+  F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
+                             utmp.fortran_vec (), vtmp.fortran_vec ()));
 }
 
 void LU::update (const Matrix& u, const Matrix& v)
 {
   if (packed ())
     unpack ();
 
   Matrix& l = l_fact;
   Matrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          ColumnVector utmp = u.column (i);
-          ColumnVector vtmp = v.column (i);
-          F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec ()));
-        }
+      ColumnVector utmp = u.column (i);
+      ColumnVector vtmp = v.column (i);
+      F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void LU::update_piv (const ColumnVector& u, const ColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   Matrix& l = l_fact;
   Matrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      ColumnVector utmp = u;
-      ColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (double, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (),
-                                   m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (),
-                                   utmp.data (), vtmp.data (), w));
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  ColumnVector utmp = u;
+  ColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (double, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (),
+                               m, r.fortran_vec (), k,
+                               ipvt.fortran_vec (),
+                               utmp.data (), vtmp.data (), w));
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 void LU::update_piv (const Matrix& u, const Matrix& v)
 {
   if (packed ())
     unpack ();
 
   Matrix& l = l_fact;
   Matrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (double, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (double, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          ColumnVector utmp = u.column (i);
-          ColumnVector vtmp = v.column (i);
-          F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (),
-                                       m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (),
-                                       utmp.data (), vtmp.data (), w));
-        }
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
+      ColumnVector utmp = u.column (i);
+      ColumnVector vtmp = v.column (i);
+      F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 #else
 
 void LU::update (const ColumnVector&, const ColumnVector&)
 {
   (*current_liboctave_error_handler)
     ("luupdate: not available in this version");
diff --git a/liboctave/numeric/dbleQR.cc b/liboctave/numeric/dbleQR.cc
--- a/liboctave/numeric/dbleQR.cc
+++ b/liboctave/numeric/dbleQR.cc
@@ -208,82 +208,76 @@ void QR::form (octave_idx_type n, Matrix
 
 void
 QR::update (const ColumnVector& u, const ColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      ColumnVector utmp = u;
-      ColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (double, w, 2*k);
-      F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (), w));
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  ColumnVector utmp = u;
+  ColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (double, w, 2*k);
+  F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (),
+                             m, r.fortran_vec (), k,
+                             utmp.fortran_vec (), vtmp.fortran_vec (), w));
 }
 
 void
 QR::update (const Matrix& u, const Matrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (double, w, 2*k);
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (double, w, 2*k);
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          ColumnVector utmp = u.column (i);
-          ColumnVector vtmp = v.column (i);
-          F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (),
-                                     w));
-        }
+      ColumnVector utmp = u.column (i);
+      ColumnVector vtmp = v.column (i);
+      F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec (),
+                                 w));
     }
-  else
-    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 QR::insert_col (const ColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
+
+  if (k < m)
+    {
+      q.resize (m, k+1);
+      r.resize (k+1, n+1);
+    }
   else
     {
-      if (k < m)
-        {
-          q.resize (m, k+1);
-          r.resize (k+1, n+1);
-        }
-      else
-        {
-          r.resize (k, n+1);
-        }
+      r.resize (k, n+1);
+    }
 
-      ColumnVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (double, w, k);
-      F77_XFCN (dqrinc, DQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 utmp.data (), w));
-    }
+  ColumnVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (double, w, k);
+  F77_XFCN (dqrinc, DQRINC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             utmp.data (), w));
 }
 
 void
 QR::insert_col (const Matrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
@@ -292,21 +286,22 @@ QR::insert_col (const Matrix& u, const A
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
           q.resize (m, kmax);
           r.resize (kmax, n + nj);
         }
       else
@@ -331,31 +326,29 @@ void
 QR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (double, w, k);
+  F77_XFCN (dqrdec, DQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1, w));
+
+  if (k < m)
+    {
+      q.resize (m, k-1);
+      r.resize (k-1, n-1);
+    }
   else
     {
-      OCTAVE_LOCAL_BUFFER (double, w, k);
-      F77_XFCN (dqrdec, DQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, w));
-
-      if (k < m)
-        {
-          q.resize (m, k-1);
-          r.resize (k-1, n-1);
-        }
-      else
-        {
-          r.resize (k, n-1);
-        }
+      r.resize (k, n-1);
     }
 }
 
 void
 QR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -365,19 +358,20 @@ QR::delete_col (const Array<octave_idx_t
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, w, k);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
@@ -400,106 +394,96 @@ void
 QR::insert_row (const RowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      q.resize (m + 1, m + 1);
-      r.resize (m + 1, n);
-      RowVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (double, w, k);
-      F77_XFCN (dqrinr, DQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 j + 1, utmp.fortran_vec (), w));
 
-    }
+  q.resize (m + 1, m + 1);
+  r.resize (m + 1, n);
+  RowVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (double, w, k);
+  F77_XFCN (dqrinr, DQRINR, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             j + 1, utmp.fortran_vec (), w));
+
 }
 
 void
 QR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (double, w, 2*m);
-      F77_XFCN (dqrder, DQRDER, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 w));
 
-      q.resize (m - 1, m - 1);
-      r.resize (m - 1, n);
-    }
+  OCTAVE_LOCAL_BUFFER (double, w, 2*m);
+  F77_XFCN (dqrder, DQRDER, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             w));
+
+  q.resize (m - 1, m - 1);
+  r.resize (m - 1, n);
 }
 
 void
 QR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (double, w, 2*k);
-      F77_XFCN (dqrshc, DQRSHC, (m, n, k,
-                                 q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 i + 1, j + 1, w));
-    }
+
+  OCTAVE_LOCAL_BUFFER (double, w, 2*k);
+  F77_XFCN (dqrshc, DQRSHC, (m, n, k,
+                             q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             i + 1, j + 1, w));
 }
 
 #else
 
 // Replacement update methods.
 
 void
 QR::update (const ColumnVector& u, const ColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      init (q*r + Matrix (u) * Matrix (v).transpose (), get_type ());
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + Matrix (u) * Matrix (v).transpose (), get_type ());
 }
 
 void
 QR::update (const Matrix& u, const Matrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
-    {
-      init (q*r + u * v.transpose (), get_type ());
-    }
-  else
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + u * v.transpose (), get_type ());
 }
 
 static
 Matrix insert_col (const Matrix& a, octave_idx_type i,
                    const ColumnVector& x)
 {
   Matrix retval (a.rows (), a.columns () + 1);
   retval.assign (idx_vector::colon, idx_vector (0, i),
@@ -565,22 +549,20 @@ QR::insert_col (const ColumnVector& u, o
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_col (q*r, j, u), get_type ());
-    }
+
+  init (::insert_col (q*r, j, u), get_type ());
 }
 
 void
 QR::insert_col (const Matrix& u, const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
@@ -590,21 +572,22 @@ QR::insert_col (const Matrix& u, const A
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       Matrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
@@ -612,20 +595,18 @@ void
 QR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_col (q*r, j), get_type ());
-    }
+
+  init (::delete_col (q*r, j), get_type ());
 }
 
 void
 QR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
@@ -634,19 +615,20 @@ QR::delete_col (const Array<octave_idx_t
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       Matrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
@@ -655,52 +637,46 @@ QR::insert_row (const RowVector& u, octa
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_row (q*r, j, u), get_type ());
-    }
+
+  init (::insert_row (q*r, j, u), get_type ());
 }
 
 void
 QR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_row (q*r, j), get_type ());
-    }
+
+  init (::delete_row (q*r, j), get_type ());
 }
 
 void
 QR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      init (::shift_cols (q*r, i, j), get_type ());
-    }
+
+  init (::shift_cols (q*r, i, j), get_type ());
 }
 
 void warn_qrupdate_once (void)
 {
   static bool warned = false;
   if (! warned)
     {
       (*current_liboctave_warning_with_id_handler)
diff --git a/liboctave/numeric/dbleSCHUR.cc b/liboctave/numeric/dbleSCHUR.cc
--- a/liboctave/numeric/dbleSCHUR.cc
+++ b/liboctave/numeric/dbleSCHUR.cc
@@ -62,21 +62,19 @@ select_dig (const double& a, const doubl
 
 octave_idx_type
 SCHUR::init (const Matrix& a, const std::string& ord, bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler) ("SCHUR requires square matrix");
-      return -1;
-    }
-  else if (a_nr == 0)
+    (*current_liboctave_error_handler) ("SCHUR requires square matrix");
+
+  if (a_nr == 0)
     {
       schur_mat.clear ();
       unitary_mat.clear ();
       return 0;
     }
 
   // Workspace requirements may need to be fixed if any of the
   // following change.
diff --git a/liboctave/numeric/dbleSVD.cc b/liboctave/numeric/dbleSVD.cc
--- a/liboctave/numeric/dbleSVD.cc
+++ b/liboctave/numeric/dbleSVD.cc
@@ -53,36 +53,30 @@ extern "C"
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 }
 
 Matrix
 SVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
-    {
-      (*current_liboctave_error_handler)
-        ("SVD: U not computed because type == SVD::sigma_only");
-      return Matrix ();
-    }
-  else
-    return left_sm;
+    (*current_liboctave_error_handler)
+      ("SVD: U not computed because type == SVD::sigma_only");
+
+  return left_sm;
 }
 
 Matrix
 SVD::right_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
-    {
-      (*current_liboctave_error_handler)
-        ("SVD: V not computed because type == SVD::sigma_only");
-      return Matrix ();
-    }
-  else
-    return right_sm;
+    (*current_liboctave_error_handler)
+      ("SVD: V not computed because type == SVD::sigma_only");
+
+  return right_sm;
 }
 
 octave_idx_type
 SVD::init (const Matrix& a, SVD::type svd_type, SVD::driver svd_driver)
 {
   octave_idx_type info;
 
   octave_idx_type m = a.rows ();
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -303,23 +303,19 @@ vector_product (const Matrix& m, const d
   octave_idx_type nc = m.cols ();
 
   F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            nr, nc, 1.0,  m.data (), nr,
                            x, 1, 0.0, y, 1
                            F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable error in dgemv");
-      return false;
-    }
-  else
-    return true;
+    (*current_liboctave_error_handler) ("eigs: unrecoverable error in dgemv");
+
+  return true;
 }
 
 static bool
 vector_product (const SparseComplexMatrix& m, const Complex* x,
                 Complex* y)
 {
   octave_idx_type nc = m.cols ();
 
@@ -340,23 +336,19 @@ vector_product (const ComplexMatrix& m, 
   octave_idx_type nc = m.cols ();
 
   F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            nr, nc, 1.0,  m.data (), nr,
                            x, 1, 0.0, y, 1
                            F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable error in zgemv");
-      return false;
-    }
-  else
-    return true;
+    (*current_liboctave_error_handler) ("eigs: unrecoverable error in zgemv");
+
+  return true;
 }
 
 static bool
 make_cholb (Matrix& b, Matrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
   CHOL fact (b, info);
   octave_idx_type n = b.cols ();
@@ -772,110 +764,76 @@ EigsRealSymmetricMatrix (const M& m, con
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
-    {
-      (*current_liboctave_error_handler) ("eigs: A must be square");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: B must be square and the same size as A");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: B must be square and the same size as A");
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k < 1 || k > n - 2)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: permB vector invalid");
-          return -1;
-        }
-      else
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (octave_idx_type i = 0; i < n; i++)
         {
-          Array<bool> checked (dim_vector (n, 1), false);
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              octave_idx_type bidx =
-                static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 || bidx >= n
-                  || D_NINT (bidx) != bidx)
-                {
-                  (*current_liboctave_error_handler)
-                    ("eigs: permB vector invalid");
-                  return -1;
-                }
-            }
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecognized sigma value");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
   if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: invalid sigma value for real symmetric problem");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: invalid sigma value for real symmetric problem");
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
@@ -885,21 +843,18 @@ EigsRealSymmetricMatrix (const M& m, con
               permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb (b, bt, permB))
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: The matrix B is not positive definite");
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: The matrix B is not positive definite");
         }
     }
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
@@ -931,21 +886,18 @@ EigsRealSymmetricMatrix (const M& m, con
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in dsaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -977,21 +929,19 @@ EigsRealSymmetricMatrix (const M& m, con
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dsaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dsaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -1013,72 +963,63 @@ EigsRealSymmetricMatrix (const M& m, con
   F77_FUNC (dseupd, DSEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in dseupd");
+
+  if (info2 == 0)
     {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in dseupd");
-      return -1;
-    }
-  else
-    {
-      if (info2 == 0)
+      octave_idx_type k2 = k / 2;
+      if (typ != "SM" && typ != "BE")
         {
-          octave_idx_type k2 = k / 2;
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              double dtmp = d[i];
+              d[i] = d[k - i - 1];
+              d[k - i - 1] = dtmp;
+            }
+        }
+
+      if (rvec)
+        {
           if (typ != "SM" && typ != "BE")
             {
+              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
               for (octave_idx_type i = 0; i < k2; i++)
                 {
-                  double dtmp = d[i];
-                  d[i] = d[k - i - 1];
-                  d[k - i - 1] = dtmp;
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (k - i - 1) * n;
+
+                  if (off1 == off2)
+                    continue;
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    dtmp[j] = z[off1 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off1 + j] = z[off2 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off2 + j] = dtmp[j];
                 }
             }
 
-          if (rvec)
-            {
-              if (typ != "SM" && typ != "BE")
-                {
-                  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-                  for (octave_idx_type i = 0; i < k2; i++)
-                    {
-                      octave_idx_type off1 = i * n;
-                      octave_idx_type off2 = (k - i - 1) * n;
-
-                      if (off1 == off2)
-                        continue;
-
-                      for (octave_idx_type j = 0; j < n; j++)
-                        dtmp[j] = z[off1 + j];
-
-                      for (octave_idx_type j = 0; j < n; j++)
-                        z[off1 + j] = z[off2 + j];
-
-                      for (octave_idx_type j = 0; j < n; j++)
-                        z[off2 + j] = dtmp[j];
-                    }
-                }
-
-              if (note3)
-                eig_vec = ltsolve (b, permB, eig_vec);
-            }
-        }
-      else
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: error %d in dseupd", info2);
-          return -1;
+          if (note3)
+            eig_vec = ltsolve (b, permB, eig_vec);
         }
     }
+  else
+    (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
                               octave_idx_type k, octave_idx_type p,
@@ -1090,97 +1031,71 @@ EigsRealSymmetricMatrixShift (const M& m
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
-    {
-      (*current_liboctave_error_handler) ("eigs: A must be square");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: B must be square and the same size as A");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: B must be square and the same size as A");
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
   //                                disp, maxit);
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
-        {
-          (*current_liboctave_error_handler) ("eigs: permB vector invalid");
-          return -1;
-        }
-      else
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (octave_idx_type i = 0; i < n; i++)
         {
-          Array<bool> checked (dim_vector (n, 1), false);
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              octave_idx_type bidx =
-                static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 || bidx >= n
-                  || D_NINT (bidx) != bidx)
-                {
-                  (*current_liboctave_error_handler)
-                    ("eigs: permB vector invalid");
-                  return -1;
-                }
-            }
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
@@ -1224,21 +1139,18 @@ EigsRealSymmetricMatrixShift (const M& m
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in dsaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -1314,21 +1226,19 @@ EigsRealSymmetricMatrixShift (const M& m
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dsaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dsaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -1350,63 +1260,54 @@ EigsRealSymmetricMatrixShift (const M& m
   F77_FUNC (dseupd, DSEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in dseupd");
+
+  if (info2 == 0)
     {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in dseupd");
-      return -1;
-    }
-  else
-    {
-      if (info2 == 0)
+      octave_idx_type k2 = k / 2;
+      for (octave_idx_type i = 0; i < k2; i++)
         {
-          octave_idx_type k2 = k / 2;
+          double dtmp = d[i];
+          d[i] = d[k - i - 1];
+          d[k - i - 1] = dtmp;
+        }
+
+      if (rvec)
+        {
+          OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
           for (octave_idx_type i = 0; i < k2; i++)
             {
-              double dtmp = d[i];
-              d[i] = d[k - i - 1];
-              d[k - i - 1] = dtmp;
-            }
-
-          if (rvec)
-            {
-              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-              for (octave_idx_type i = 0; i < k2; i++)
-                {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (k - i - 1) * n;
-
-                  if (off1 == off2)
-                    continue;
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    dtmp[j] = z[off1 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off1 + j] = z[off2 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off2 + j] = dtmp[j];
-                }
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (k - i - 1) * n;
+
+              if (off1 == off2)
+                continue;
+
+              for (octave_idx_type j = 0; j < n; j++)
+                dtmp[j] = z[off1 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off1 + j] = z[off2 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off2 + j] = dtmp[j];
             }
         }
-      else
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: error %d in dseupd", info2);
-          return -1;
-        }
     }
+  else
+    (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n,
                        const std::string &_typ, double sigma,
                        octave_idx_type k, octave_idx_type p,
@@ -1425,62 +1326,48 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
           && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
           && typ != "SI")
-        (*current_liboctave_error_handler)
-          ("eigs: unrecognized sigma value");
+        (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
       if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: invalid sigma value for real symmetric problem");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: invalid sigma value for real symmetric problem");
 
       if (typ == "SM")
         {
           typ = "LM";
           sigma = 0.;
           mode = 3;
         }
     }
@@ -1525,21 +1412,18 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in dsaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -1572,21 +1456,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
           ip2 = workd + iptr(1) - 1;
           for (octave_idx_type i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dsaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dsaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -1608,69 +1490,60 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   F77_FUNC (dseupd, DSEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in dseupd");
+
+  if (info2 == 0)
     {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in dseupd");
-      return -1;
-    }
-  else
-    {
-      if (info2 == 0)
+      octave_idx_type k2 = k / 2;
+      if (typ != "SM" && typ != "BE")
         {
-          octave_idx_type k2 = k / 2;
+          for (octave_idx_type i = 0; i < k2; i++)
+            {
+              double dtmp = d[i];
+              d[i] = d[k - i - 1];
+              d[k - i - 1] = dtmp;
+            }
+        }
+
+      if (rvec)
+        {
           if (typ != "SM" && typ != "BE")
             {
+              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
               for (octave_idx_type i = 0; i < k2; i++)
                 {
-                  double dtmp = d[i];
-                  d[i] = d[k - i - 1];
-                  d[k - i - 1] = dtmp;
-                }
-            }
-
-          if (rvec)
-            {
-              if (typ != "SM" && typ != "BE")
-                {
-                  OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-                  for (octave_idx_type i = 0; i < k2; i++)
-                    {
-                      octave_idx_type off1 = i * n;
-                      octave_idx_type off2 = (k - i - 1) * n;
-
-                      if (off1 == off2)
-                        continue;
-
-                      for (octave_idx_type j = 0; j < n; j++)
-                        dtmp[j] = z[off1 + j];
-
-                      for (octave_idx_type j = 0; j < n; j++)
-                        z[off1 + j] = z[off2 + j];
-
-                      for (octave_idx_type j = 0; j < n; j++)
-                        z[off2 + j] = dtmp[j];
-                    }
+                  octave_idx_type off1 = i * n;
+                  octave_idx_type off2 = (k - i - 1) * n;
+
+                  if (off1 == off2)
+                    continue;
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    dtmp[j] = z[off1 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off1 + j] = z[off2 + j];
+
+                  for (octave_idx_type j = 0; j < n; j++)
+                    z[off2 + j] = dtmp[j];
                 }
             }
         }
-      else
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: error %d in dseupd", info2);
-          return -1;
-        }
     }
+  else
+    (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealNonSymmetricMatrix (const M& m, const std::string typ,
                             octave_idx_type k, octave_idx_type p,
@@ -1686,110 +1559,76 @@ EigsRealNonSymmetricMatrix (const M& m, 
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigmar = 0.;
   double sigmai = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
-    {
-      (*current_liboctave_error_handler) ("eigs: A must be square");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: B must be square and the same size as A");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: B must be square and the same size as A");
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: permB vector invalid");
-          return -1;
-        }
-      else
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (octave_idx_type i = 0; i < n; i++)
         {
-          Array<bool> checked (dim_vector (n, 1), false);
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              octave_idx_type bidx =
-                static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 || bidx >= n
-                  || D_NINT (bidx) != bidx)
-                {
-                  (*current_liboctave_error_handler)
-                    ("eigs: permB vector invalid");
-                  return -1;
-                }
-            }
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecognized sigma value");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
   if (typ == "LA" || typ == "SA" || typ == "BE")
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: invalid sigma value for unsymmetric problem");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: invalid sigma value for unsymmetric problem");
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
@@ -1799,21 +1638,18 @@ EigsRealNonSymmetricMatrix (const M& m, 
               permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb (b, bt, permB))
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: The matrix B is not positive definite");
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: The matrix B is not positive definite");
         }
     }
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
@@ -1845,21 +1681,18 @@ EigsRealNonSymmetricMatrix (const M& m, 
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in dnaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in dnaupd");
 
       if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -1891,21 +1724,19 @@ EigsRealNonSymmetricMatrix (const M& m, 
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dnaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dnaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -1937,109 +1768,100 @@ EigsRealNonSymmetricMatrix (const M& m, 
   F77_FUNC (dneupd, DNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in dneupd");
+
+  eig_val.resize (k+1);
+  Complex *d = eig_val.fortran_vec ();
+
+  if (info2 == 0)
     {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in dneupd");
-      return -1;
-    }
-  else
-    {
-      eig_val.resize (k+1);
-      Complex *d = eig_val.fortran_vec ();
-
-      if (info2 == 0)
+      octave_idx_type jj = 0;
+      for (octave_idx_type i = 0; i < k+1; i++)
         {
-          octave_idx_type jj = 0;
-          for (octave_idx_type i = 0; i < k+1; i++)
-            {
-              if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
-                jj++;
-              else
-                d[i-jj] = Complex (dr[i], di[i]);
-            }
-          if (jj == 0 && ! rvec)
-            for (octave_idx_type i = 0; i < k; i++)
-              d[i] = d[i+1];
-
-          octave_idx_type k2 = k / 2;
+          if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
+            jj++;
+          else
+            d[i-jj] = Complex (dr[i], di[i]);
+        }
+      if (jj == 0 && ! rvec)
+        for (octave_idx_type i = 0; i < k; i++)
+          d[i] = d[i+1];
+
+      octave_idx_type k2 = k / 2;
+      for (octave_idx_type i = 0; i < k2; i++)
+        {
+          Complex dtmp = d[i];
+          d[i] = d[k - i - 1];
+          d[k - i - 1] = dtmp;
+        }
+      eig_val.resize (k);
+
+      if (rvec)
+        {
+          OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
           for (octave_idx_type i = 0; i < k2; i++)
             {
-              Complex dtmp = d[i];
-              d[i] = d[k - i - 1];
-              d[k - i - 1] = dtmp;
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (k - i - 1) * n;
+
+              if (off1 == off2)
+                continue;
+
+              for (octave_idx_type j = 0; j < n; j++)
+                dtmp[j] = z[off1 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off1 + j] = z[off2 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off2 + j] = dtmp[j];
             }
-          eig_val.resize (k);
-
-          if (rvec)
+
+          eig_vec.resize (n, k);
+          octave_idx_type i = 0;
+          while (i < k)
             {
-              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-              for (octave_idx_type i = 0; i < k2; i++)
-                {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (k - i - 1) * n;
-
-                  if (off1 == off2)
-                    continue;
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    dtmp[j] = z[off1 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off1 + j] = z[off2 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off2 + j] = dtmp[j];
-                }
-
-              eig_vec.resize (n, k);
-              octave_idx_type i = 0;
-              while (i < k)
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (i+1) * n;
+              if (std::imag (eig_val(i)) == 0)
                 {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (i+1) * n;
-                  if (std::imag (eig_val(i)) == 0)
-                    {
-                      for (octave_idx_type j = 0; j < n; j++)
-                        eig_vec(j,i) =
-                          Complex (z[j+off1],0.);
-                      i++;
-                    }
-                  else
+                  for (octave_idx_type j = 0; j < n; j++)
+                    eig_vec(j,i) =
+                      Complex (z[j+off1],0.);
+                  i++;
+                }
+              else
+                {
+                  for (octave_idx_type j = 0; j < n; j++)
                     {
-                      for (octave_idx_type j = 0; j < n; j++)
-                        {
-                          eig_vec(j,i) =
-                            Complex (z[j+off1],z[j+off2]);
-                          if (i < k - 1)
-                            eig_vec(j,i+1) =
-                              Complex (z[j+off1],-z[j+off2]);
-                        }
-                      i+=2;
+                      eig_vec(j,i) =
+                        Complex (z[j+off1],z[j+off2]);
+                      if (i < k - 1)
+                        eig_vec(j,i+1) =
+                          Complex (z[j+off1],-z[j+off2]);
                     }
+                  i+=2;
                 }
-
-              if (note3)
-                eig_vec = ltsolve (M(b), permB, eig_vec);
             }
-        }
-      else
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: error %d in dneupd", info2);
-          return -1;
+
+          if (note3)
+            eig_vec = ltsolve (M(b), permB, eig_vec);
         }
     }
+  else
+    (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealNonSymmetricMatrixShift (const M& m, double sigmar,
                                  octave_idx_type k, octave_idx_type p,
@@ -2053,97 +1875,71 @@ EigsRealNonSymmetricMatrixShift (const M
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
   double sigmai = 0.;
 
   if (m.rows () != m.cols ())
-    {
-      (*current_liboctave_error_handler) ("eigs: A must be square");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: B must be square and the same size as A");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: B must be square and the same size as A");
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
   //                                   disp, maxit);
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check that we really have a permutation vector
       if (permB.numel () != n)
-        {
-          (*current_liboctave_error_handler) ("eigs: permB vector invalid");
-          return -1;
-        }
-      else
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (octave_idx_type i = 0; i < n; i++)
         {
-          Array<bool> checked (dim_vector (n, 1), false);
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              octave_idx_type bidx =
-                static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 || bidx >= n
-                  || D_NINT (bidx) != bidx)
-                {
-                  (*current_liboctave_error_handler)
-                    ("eigs: permB vector invalid");
-                  return -1;
-                }
-            }
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
@@ -2187,21 +1983,18 @@ EigsRealNonSymmetricMatrixShift (const M
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in dsaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in dsaupd");
 
       if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -2277,21 +2070,19 @@ EigsRealNonSymmetricMatrixShift (const M
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dsaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dsaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -2323,106 +2114,97 @@ EigsRealNonSymmetricMatrixShift (const M
   F77_FUNC (dneupd, DNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in dneupd");
+
+  eig_val.resize (k+1);
+  Complex *d = eig_val.fortran_vec ();
+
+  if (info2 == 0)
     {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in dneupd");
-      return -1;
-    }
-  else
-    {
-      eig_val.resize (k+1);
-      Complex *d = eig_val.fortran_vec ();
-
-      if (info2 == 0)
+      octave_idx_type jj = 0;
+      for (octave_idx_type i = 0; i < k+1; i++)
         {
-          octave_idx_type jj = 0;
-          for (octave_idx_type i = 0; i < k+1; i++)
-            {
-              if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
-                jj++;
-              else
-                d[i-jj] = Complex (dr[i], di[i]);
-            }
-          if (jj == 0 && ! rvec)
-            for (octave_idx_type i = 0; i < k; i++)
-              d[i] = d[i+1];
-
-          octave_idx_type k2 = k / 2;
+          if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
+            jj++;
+          else
+            d[i-jj] = Complex (dr[i], di[i]);
+        }
+      if (jj == 0 && ! rvec)
+        for (octave_idx_type i = 0; i < k; i++)
+          d[i] = d[i+1];
+
+      octave_idx_type k2 = k / 2;
+      for (octave_idx_type i = 0; i < k2; i++)
+        {
+          Complex dtmp = d[i];
+          d[i] = d[k - i - 1];
+          d[k - i - 1] = dtmp;
+        }
+      eig_val.resize (k);
+
+      if (rvec)
+        {
+          OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
           for (octave_idx_type i = 0; i < k2; i++)
             {
-              Complex dtmp = d[i];
-              d[i] = d[k - i - 1];
-              d[k - i - 1] = dtmp;
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (k - i - 1) * n;
+
+              if (off1 == off2)
+                continue;
+
+              for (octave_idx_type j = 0; j < n; j++)
+                dtmp[j] = z[off1 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off1 + j] = z[off2 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off2 + j] = dtmp[j];
             }
-          eig_val.resize (k);
-
-          if (rvec)
+
+          eig_vec.resize (n, k);
+          octave_idx_type i = 0;
+          while (i < k)
             {
-              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-              for (octave_idx_type i = 0; i < k2; i++)
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (i+1) * n;
+              if (std::imag (eig_val(i)) == 0)
                 {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (k - i - 1) * n;
-
-                  if (off1 == off2)
-                    continue;
-
                   for (octave_idx_type j = 0; j < n; j++)
-                    dtmp[j] = z[off1 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off1 + j] = z[off2 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off2 + j] = dtmp[j];
+                    eig_vec(j,i) =
+                      Complex (z[j+off1],0.);
+                  i++;
                 }
-
-              eig_vec.resize (n, k);
-              octave_idx_type i = 0;
-              while (i < k)
+              else
                 {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (i+1) * n;
-                  if (std::imag (eig_val(i)) == 0)
+                  for (octave_idx_type j = 0; j < n; j++)
                     {
-                      for (octave_idx_type j = 0; j < n; j++)
-                        eig_vec(j,i) =
-                          Complex (z[j+off1],0.);
-                      i++;
+                      eig_vec(j,i) =
+                        Complex (z[j+off1],z[j+off2]);
+                      if (i < k - 1)
+                        eig_vec(j,i+1) =
+                          Complex (z[j+off1],-z[j+off2]);
                     }
-                  else
-                    {
-                      for (octave_idx_type j = 0; j < n; j++)
-                        {
-                          eig_vec(j,i) =
-                            Complex (z[j+off1],z[j+off2]);
-                          if (i < k - 1)
-                            eig_vec(j,i+1) =
-                              Complex (z[j+off1],-z[j+off2]);
-                        }
-                      i+=2;
-                    }
+                  i+=2;
                 }
             }
         }
-      else
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: error %d in dneupd", info2);
-          return -1;
-        }
     }
+  else
+    (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n,
                           const std::string &_typ, double sigmar,
                           octave_idx_type k, octave_idx_type p,
@@ -2442,63 +2224,49 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
 
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
           && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
           && typ != "SI")
-        (*current_liboctave_error_handler)
-          ("eigs: unrecognized sigma value");
+        (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: invalid sigma value for unsymmetric problem");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: invalid sigma value for unsymmetric problem");
 
       if (typ == "SM")
         {
           typ = "LM";
           sigmar = 0.;
           mode = 3;
         }
     }
@@ -2543,21 +2311,18 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in dnaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in dnaupd");
 
       if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -2589,21 +2354,19 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 
           ip2 = workd + iptr(1) - 1;
           for (octave_idx_type i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dsaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dsaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -2635,106 +2398,97 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   F77_FUNC (dneupd, DNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
      ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in dneupd");
+
+  eig_val.resize (k+1);
+  Complex *d = eig_val.fortran_vec ();
+
+  if (info2 == 0)
     {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in dneupd");
-      return -1;
-    }
-  else
-    {
-      eig_val.resize (k+1);
-      Complex *d = eig_val.fortran_vec ();
-
-      if (info2 == 0)
+      octave_idx_type jj = 0;
+      for (octave_idx_type i = 0; i < k+1; i++)
         {
-          octave_idx_type jj = 0;
-          for (octave_idx_type i = 0; i < k+1; i++)
-            {
-              if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
-                jj++;
-              else
-                d[i-jj] = Complex (dr[i], di[i]);
-            }
-          if (jj == 0 && ! rvec)
-            for (octave_idx_type i = 0; i < k; i++)
-              d[i] = d[i+1];
-
-          octave_idx_type k2 = k / 2;
+          if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
+            jj++;
+          else
+            d[i-jj] = Complex (dr[i], di[i]);
+        }
+      if (jj == 0 && ! rvec)
+        for (octave_idx_type i = 0; i < k; i++)
+          d[i] = d[i+1];
+
+      octave_idx_type k2 = k / 2;
+      for (octave_idx_type i = 0; i < k2; i++)
+        {
+          Complex dtmp = d[i];
+          d[i] = d[k - i - 1];
+          d[k - i - 1] = dtmp;
+        }
+      eig_val.resize (k);
+
+      if (rvec)
+        {
+          OCTAVE_LOCAL_BUFFER (double, dtmp, n);
+
           for (octave_idx_type i = 0; i < k2; i++)
             {
-              Complex dtmp = d[i];
-              d[i] = d[k - i - 1];
-              d[k - i - 1] = dtmp;
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (k - i - 1) * n;
+
+              if (off1 == off2)
+                continue;
+
+              for (octave_idx_type j = 0; j < n; j++)
+                dtmp[j] = z[off1 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off1 + j] = z[off2 + j];
+
+              for (octave_idx_type j = 0; j < n; j++)
+                z[off2 + j] = dtmp[j];
             }
-          eig_val.resize (k);
-
-          if (rvec)
+
+          eig_vec.resize (n, k);
+          octave_idx_type i = 0;
+          while (i < k)
             {
-              OCTAVE_LOCAL_BUFFER (double, dtmp, n);
-
-              for (octave_idx_type i = 0; i < k2; i++)
+              octave_idx_type off1 = i * n;
+              octave_idx_type off2 = (i+1) * n;
+              if (std::imag (eig_val(i)) == 0)
                 {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (k - i - 1) * n;
-
-                  if (off1 == off2)
-                    continue;
-
                   for (octave_idx_type j = 0; j < n; j++)
-                    dtmp[j] = z[off1 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off1 + j] = z[off2 + j];
-
-                  for (octave_idx_type j = 0; j < n; j++)
-                    z[off2 + j] = dtmp[j];
+                    eig_vec(j,i) =
+                      Complex (z[j+off1],0.);
+                  i++;
                 }
-
-              eig_vec.resize (n, k);
-              octave_idx_type i = 0;
-              while (i < k)
+              else
                 {
-                  octave_idx_type off1 = i * n;
-                  octave_idx_type off2 = (i+1) * n;
-                  if (std::imag (eig_val(i)) == 0)
+                  for (octave_idx_type j = 0; j < n; j++)
                     {
-                      for (octave_idx_type j = 0; j < n; j++)
-                        eig_vec(j,i) =
-                          Complex (z[j+off1],0.);
-                      i++;
+                      eig_vec(j,i) =
+                        Complex (z[j+off1],z[j+off2]);
+                      if (i < k - 1)
+                        eig_vec(j,i+1) =
+                          Complex (z[j+off1],-z[j+off2]);
                     }
-                  else
-                    {
-                      for (octave_idx_type j = 0; j < n; j++)
-                        {
-                          eig_vec(j,i) =
-                            Complex (z[j+off1],z[j+off2]);
-                          if (i < k - 1)
-                            eig_vec(j,i+1) =
-                              Complex (z[j+off1],-z[j+off2]);
-                        }
-                      i+=2;
-                    }
+                  i+=2;
                 }
             }
         }
-      else
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: error %d in dneupd", info2);
-          return -1;
-        }
     }
+  else
+    (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsComplexNonSymmetricMatrix (const M& m, const std::string typ,
                                octave_idx_type k, octave_idx_type p,
@@ -2750,114 +2504,80 @@ EigsComplexNonSymmetricMatrix (const M& 
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   Complex sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
-    {
-      (*current_liboctave_error_handler) ("eigs: A must be square");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: B must be square and the same size as A");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: B must be square and the same size as A");
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       Array<double> rr (octave_rand::vector (n));
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: permB vector invalid");
-          return -1;
-        }
-      else
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (octave_idx_type i = 0; i < n; i++)
         {
-          Array<bool> checked (dim_vector (n, 1), false);
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              octave_idx_type bidx =
-                static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 || bidx >= n
-                  || D_NINT (bidx) != bidx)
-                {
-                  (*current_liboctave_error_handler)
-                    ("eigs: permB vector invalid");
-                  return -1;
-                }
-            }
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecognized sigma value");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
   if (typ == "LA" || typ == "SA" || typ == "BE")
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: invalid sigma value for complex problem");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: invalid sigma value for complex problem");
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
@@ -2867,21 +2587,18 @@ EigsComplexNonSymmetricMatrix (const M& 
               permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb (b, bt, permB))
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: The matrix B is not positive definite");
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: The matrix B is not positive definite");
         }
     }
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
 
   ip(0) = 1; //ishift
   ip(1) = 0;   // ip(1) not referenced
@@ -2914,21 +2631,18 @@ EigsComplexNonSymmetricMatrix (const M& 
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in znaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -2959,21 +2673,19 @@ EigsComplexNonSymmetricMatrix (const M& 
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in znaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in znaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -2997,21 +2709,18 @@ EigsComplexNonSymmetricMatrix (const M& 
   F77_FUNC (zneupd, ZNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in zneupd");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
@@ -3041,21 +2750,17 @@ EigsComplexNonSymmetricMatrix (const M& 
                 z[off2 + j] = ctmp[j];
             }
 
           if (note3)
             eig_vec = ltsolve (b, permB, eig_vec);
         }
     }
   else
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: error %d in zneupd", info2);
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const M& m, Complex sigma,
                                     octave_idx_type k, octave_idx_type p,
@@ -3069,26 +2774,20 @@ EigsComplexNonSymmetricMatrixShift (cons
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
-    {
-      (*current_liboctave_error_handler) ("eigs: A must be square");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: B must be square and the same size as A");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: B must be square and the same size as A");
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
   //                                      rvec, cholB, disp, maxit);
 
   if (cresid.is_empty ())
@@ -3099,71 +2798,51 @@ EigsComplexNonSymmetricMatrixShift (cons
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
       // Check that we really have a permutation vector
       if (permB.numel () != n)
-        {
-          (*current_liboctave_error_handler) ("eigs: permB vector invalid");
-          return -1;
-        }
-      else
+        (*current_liboctave_error_handler) ("eigs: permB vector invalid");
+
+      Array<bool> checked (dim_vector (n, 1), false);
+      for (octave_idx_type i = 0; i < n; i++)
         {
-          Array<bool> checked (dim_vector (n, 1), false);
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              octave_idx_type bidx =
-                static_cast<octave_idx_type> (permB(i));
-              if (checked(bidx) || bidx < 0 || bidx >= n
-                  || D_NINT (bidx) != bidx)
-                {
-                  (*current_liboctave_error_handler)
-                    ("eigs: permB vector invalid");
-                  return -1;
-                }
-            }
+          octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
+
+          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+            (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
@@ -3208,21 +2887,18 @@ EigsComplexNonSymmetricMatrixShift (cons
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in znaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -3299,21 +2975,19 @@ EigsComplexNonSymmetricMatrixShift (cons
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dsaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dsaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -3337,21 +3011,18 @@ EigsComplexNonSymmetricMatrixShift (cons
   F77_FUNC (zneupd, ZNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in zneupd");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
@@ -3378,21 +3049,18 @@ EigsComplexNonSymmetricMatrixShift (cons
                 z[off1 + j] = z[off2 + j];
 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
         }
     }
   else
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: error %d in zneupd", info2);
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
 octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
                              const std::string &_typ, Complex sigma,
                              octave_idx_type k, octave_idx_type p,
@@ -3416,62 +3084,49 @@ EigsComplexNonSymmetricFunc (EigsComplex
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: n must be at least 3");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: n must be at least 3");
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig (full (A))' instead");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+       "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: opts.p must be greater than k and less than n");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: opts.p must be greater than k and less than n");
 
   if (! have_sigma)
     {
       if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
           && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
           && typ != "SI")
-        (*current_liboctave_error_handler)
-          ("eigs: unrecognized sigma value");
+        (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: invalid sigma value for complex problem");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: invalid sigma value for complex problem");
 
       if (typ == "SM")
         {
           typ = "LM";
           sigma = 0.;
           mode = 3;
         }
     }
@@ -3517,21 +3172,18 @@ EigsComplexNonSymmetricFunc (EigsComplex
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
-        {
-          (*current_liboctave_error_handler)
-            ("eigs: unrecoverable exception encountered in znaupd");
-          return -1;
-        }
+        (*current_liboctave_error_handler)
+          ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
@@ -3563,21 +3215,19 @@ EigsComplexNonSymmetricFunc (EigsComplex
 
           ip2 = workd + iptr(1) - 1;
           for (octave_idx_type i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
-            {
-              (*current_liboctave_error_handler)
-                ("eigs: error %d in dsaupd", info);
-              return -1;
-            }
+            (*current_liboctave_error_handler)
+              ("eigs: error %d in dsaupd", info);
+
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
@@ -3601,21 +3251,18 @@ EigsComplexNonSymmetricFunc (EigsComplex
   F77_FUNC (zneupd, ZNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: unrecoverable exception encountered in zneupd");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
@@ -3642,21 +3289,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
                 z[off1 + j] = z[off2 + j];
 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
         }
     }
   else
-    {
-      (*current_liboctave_error_handler)
-        ("eigs: error %d in zneupd", info2);
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
 #if ! defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern octave_idx_type
 EigsRealSymmetricMatrix (const Matrix& m, const std::string typ,
                          octave_idx_type k, octave_idx_type p,
diff --git a/liboctave/numeric/fCmplxAEPBAL.cc b/liboctave/numeric/fCmplxAEPBAL.cc
--- a/liboctave/numeric/fCmplxAEPBAL.cc
+++ b/liboctave/numeric/fCmplxAEPBAL.cc
@@ -53,20 +53,17 @@ extern "C"
 
 FloatComplexAEPBALANCE::FloatComplexAEPBALANCE (const FloatComplexMatrix& a,
                                                 bool noperm, bool noscal)
   : base_aepbal<FloatComplexMatrix, FloatColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
-    {
-      (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
-      return;
-    }
+    (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
 
   octave_idx_type info;
 
   scale = FloatColumnVector (n);
   float *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   FloatComplex *p_balanced_mat = balanced_mat.fortran_vec ();
diff --git a/liboctave/numeric/fCmplxCHOL.cc b/liboctave/numeric/fCmplxCHOL.cc
--- a/liboctave/numeric/fCmplxCHOL.cc
+++ b/liboctave/numeric/fCmplxCHOL.cc
@@ -87,21 +87,18 @@ extern "C"
 
 octave_idx_type
 FloatComplexCHOL::init (const FloatComplexMatrix& a, bool upper, bool calc_cond)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler)
-        ("FloatComplexCHOL requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("FloatComplexCHOL requires square matrix");
 
   octave_idx_type n = a_nc;
   octave_idx_type info;
 
   is_upper = upper;
 
   chol_mat.clear (n, n);
   if (is_upper)
@@ -160,192 +157,178 @@ FloatComplexCHOL::init (const FloatCompl
 static FloatComplexMatrix
 chol2inv_internal (const FloatComplexMatrix& r, bool is_upper = true)
 {
   FloatComplexMatrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
-  if (r_nr == r_nc)
-    {
-      octave_idx_type n = r_nc;
-      octave_idx_type info;
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
-      FloatComplexMatrix tmp = r;
+  octave_idx_type n = r_nc;
+  octave_idx_type info;
+
+  FloatComplexMatrix tmp = r;
 
-      if (is_upper)
-        F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                                   tmp.fortran_vec (), n, info
-                                   F77_CHAR_ARG_LEN (1)));
-      else
-        F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                                   tmp.fortran_vec (), n, info
-                                   F77_CHAR_ARG_LEN (1)));
+  if (is_upper)
+    F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
+  else
+    F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
 
-      // If someone thinks of a more graceful way of doing this (or
-      // faster for that matter :-)), please let me know!
+  // If someone thinks of a more graceful way of doing this (or
+  // faster for that matter :-)), please let me know!
 
-      if (n > 1)
-        {
-          if (is_upper)
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (i, j) = tmp.xelem (j, i);
-          else
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (j, i) = tmp.xelem (i, j);
-        }
+  if (n > 1)
+    {
+      if (is_upper)
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (i, j) = tmp.xelem (j, i);
+      else
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (j, i) = tmp.xelem (i, j);
+    }
 
-      retval = tmp;
-    }
-  else
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+  retval = tmp;
 
   return retval;
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
 FloatComplexMatrix
 FloatComplexCHOL::inverse (void) const
 {
   return chol2inv_internal (chol_mat, is_upper);
 }
 
 void
 FloatComplexCHOL::set (const FloatComplexMatrix& R)
 {
-  if (R.is_square ())
-    chol_mat = R;
-  else
+  if (! R.is_square ())
     (*current_liboctave_error_handler) ("CHOL requires square matrix");
+
+  chol_mat = R;
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
 FloatComplexCHOL::update (const FloatComplexColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      FloatComplexColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (float, rw, n);
+  FloatComplexColumnVector utmp = u;
 
-      F77_XFCN (cch1up, CCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), rw));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  F77_XFCN (cch1up, CCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw));
 }
 
 octave_idx_type
 FloatComplexCHOL::downdate (const FloatComplexColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      FloatComplexColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (float, rw, n);
+  FloatComplexColumnVector utmp = u;
 
-      F77_XFCN (cch1dn, CCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), rw, info));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  F77_XFCN (cch1dn, CCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw, info));
 
   return info;
 }
 
 octave_idx_type
 FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u,
                               octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
-  else
-    {
-      FloatComplexColumnVector utmp = u;
+
+  FloatComplexColumnVector utmp = u;
 
-      OCTAVE_LOCAL_BUFFER (float, rw, n);
-
-      chol_mat.resize (n+1, n+1);
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cchinx, CCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, utmp.fortran_vec (), rw, info));
-    }
+  chol_mat.resize (n+1, n+1);
+
+  F77_XFCN (cchinx, CCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, utmp.fortran_vec (), rw, info));
 
   return info;
 }
 
 void
 FloatComplexCHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cchdex, CCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, rw));
+  F77_XFCN (cchdex, CCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, rw));
 
-      chol_mat.resize (n-1, n-1);
-    }
+  chol_mat.resize (n-1, n-1);
 }
 
 void
 FloatComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
-      OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cchshx, CCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 i + 1, j + 1, w, rw));
-    }
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  F77_XFCN (cchshx, CCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             i + 1, j + 1, w, rw));
 }
 
 #else
 
 void
 FloatComplexCHOL::update (const FloatComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
-    {
-      init (chol_mat.hermitian () * chol_mat
-            + FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (),
-            true, false);
-    }
-  else
+  if (u.length () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  init (chol_mat.hermitian () * chol_mat
+        + FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (),
+        true, false);
 }
 
 static bool
 singular (const FloatComplexMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     if (a(i,i) == 0.0f) return true;
   return false;
@@ -355,122 +338,114 @@ octave_idx_type
 FloatComplexCHOL::downdate (const FloatComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.length () == n)
+  if (u.length () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  if (singular (chol_mat))
+    info = 2;
+  else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else
-        {
-          info = init (chol_mat.hermitian () * chol_mat
-                       - FloatComplexMatrix (u)
-                       * FloatComplexMatrix (u).hermitian (),
-                       true, false);
-          if (info) info = 1;
-        }
+      info = init (chol_mat.hermitian () * chol_mat
+                   - FloatComplexMatrix (u)
+                   * FloatComplexMatrix (u).hermitian (),
+                   true, false);
+      if (info) info = 1;
     }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
 
 octave_idx_type
 FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u,
                               octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
+
+  if (singular (chol_mat))
+    info = 2;
+  else if (u(j).imag () != 0.0)
+    info = 3;
   else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else if (u(j).imag () != 0.0)
-        info = 3;
-      else
-        {
-          FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-          FloatComplexMatrix a1 (n+1, n+1);
-          for (octave_idx_type k = 0; k < n+1; k++)
-            for (octave_idx_type l = 0; l < n+1; l++)
-              {
-                if (l == j)
-                  a1(k, l) = u(k);
-                else if (k == j)
-                  a1(k, l) = std::conj (u(l));
-                else
-                  a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-              }
-          info = init (a1, true, false);
-          if (info) info = 1;
-        }
+      FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
+      FloatComplexMatrix a1 (n+1, n+1);
+      for (octave_idx_type k = 0; k < n+1; k++)
+        for (octave_idx_type l = 0; l < n+1; l++)
+          {
+            if (l == j)
+              a1(k, l) = u(k);
+            else if (k == j)
+              a1(k, l) = std::conj (u(l));
+            else
+              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
+          }
+      info = init (a1, true, false);
+      if (info) info = 1;
     }
 
   return info;
 }
 
 void
 FloatComplexCHOL::delete_sym (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      a.delete_elements (1, idx_vector (j));
-      a.delete_elements (0, idx_vector (j));
-      init (a, true, false);
-    }
+
+  FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
+  a.delete_elements (1, idx_vector (j));
+  a.delete_elements (0, idx_vector (j));
+  init (a, true, false);
 }
 
 void
 FloatComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
+
+  FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
+  Array<octave_idx_type> p (dim_vector (n, 1));
+  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
+  if (i < j)
     {
-      FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      Array<octave_idx_type> p (dim_vector (n, 1));
-      for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-      if (i < j)
-        {
-          for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-          p(j) = i;
-        }
-      else if (j < i)
-        {
-          p(j) = i;
-          for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-        }
+      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
+      p(j) = i;
+    }
+  else if (j < i)
+    {
+      p(j) = i;
+      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
+    }
 
-      init (a.index (idx_vector (p), idx_vector (p)), true, false);
-    }
+  init (a.index (idx_vector (p), idx_vector (p)), true, false);
 }
 
 #endif
 
 FloatComplexMatrix
 chol2inv (const FloatComplexMatrix& r)
 {
   return chol2inv_internal (r);
diff --git a/liboctave/numeric/fCmplxLU.cc b/liboctave/numeric/fCmplxLU.cc
--- a/liboctave/numeric/fCmplxLU.cc
+++ b/liboctave/numeric/fCmplxLU.cc
@@ -117,90 +117,84 @@ void FloatComplexLU::update (const Float
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          FloatComplexColumnVector utmp = u.column (i);
-          FloatComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec ()));
-        }
+      FloatComplexColumnVector utmp = u.column (i);
+      FloatComplexColumnVector vtmp = v.column (i);
+      F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void FloatComplexLU::update_piv (const FloatComplexColumnVector& u,
                                  const FloatComplexColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      FloatComplexColumnVector utmp = u;
-      FloatComplexColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
-                                   m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (),
-                                   utmp.data (), vtmp.data (), w));
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  FloatComplexColumnVector utmp = u;
+  FloatComplexColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
+                               m, r.fortran_vec (), k,
+                               ipvt.fortran_vec (),
+                               utmp.data (), vtmp.data (), w));
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 void FloatComplexLU::update_piv (const FloatComplexMatrix& u,
                                  const FloatComplexMatrix& v)
 {
   if (packed ())
     unpack ();
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          FloatComplexColumnVector utmp = u.column (i);
-          FloatComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
-                                       m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (),
-                                       utmp.data (), vtmp.data (), w));
-        }
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
+      FloatComplexColumnVector utmp = u.column (i);
+      FloatComplexColumnVector vtmp = v.column (i);
+      F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 #else
 
 void FloatComplexLU::update (const FloatComplexColumnVector&,
                              const FloatComplexColumnVector&)
 {
   (*current_liboctave_error_handler)
diff --git a/liboctave/numeric/fCmplxQR.cc b/liboctave/numeric/fCmplxQR.cc
--- a/liboctave/numeric/fCmplxQR.cc
+++ b/liboctave/numeric/fCmplxQR.cc
@@ -211,87 +211,81 @@ void FloatComplexQR::form (octave_idx_ty
 void
 FloatComplexQR::update (const FloatComplexColumnVector& u,
                         const FloatComplexColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      FloatComplexColumnVector utmp = u;
-      FloatComplexColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
-      OCTAVE_LOCAL_BUFFER (float, rw, k);
-      F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (),
-                                 w, rw));
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  FloatComplexColumnVector utmp = u;
+  FloatComplexColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
+  OCTAVE_LOCAL_BUFFER (float, rw, k);
+  F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
+                             m, r.fortran_vec (), k,
+                             utmp.fortran_vec (), vtmp.fortran_vec (),
+                             w, rw));
 }
 
 void
 FloatComplexQR::update (const FloatComplexMatrix& u,
                         const FloatComplexMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
+  OCTAVE_LOCAL_BUFFER (float, rw, k);
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
-      OCTAVE_LOCAL_BUFFER (float, rw, k);
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          FloatComplexColumnVector utmp = u.column (i);
-          FloatComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (),
-                                     w, rw));
-        }
+      FloatComplexColumnVector utmp = u.column (i);
+      FloatComplexColumnVector vtmp = v.column (i);
+      F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec (),
+                                 w, rw));
     }
-  else
-    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatComplexQR::insert_col (const FloatComplexColumnVector& u,
                             octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
+
+  if (k < m)
+    {
+      q.resize (m, k+1);
+      r.resize (k+1, n+1);
+    }
   else
     {
-      if (k < m)
-        {
-          q.resize (m, k+1);
-          r.resize (k+1, n+1);
-        }
-      else
-        {
-          r.resize (k, n+1);
-        }
+      r.resize (k, n+1);
+    }
 
-      FloatComplexColumnVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (float, rw, k);
-      F77_XFCN (cqrinc, CQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 utmp.data (), rw));
-    }
+  FloatComplexColumnVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (float, rw, k);
+  F77_XFCN (cqrinc, CQRINC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             utmp.data (), rw));
 }
 
 void
 FloatComplexQR::insert_col (const FloatComplexMatrix& u,
                             const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -301,21 +295,22 @@ FloatComplexQR::insert_col (const FloatC
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
           q.resize (m, kmax);
           r.resize (kmax, n + nj);
         }
       else
@@ -339,31 +334,29 @@ void
 FloatComplexQR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (float, rw, k);
+  F77_XFCN (cqrdec, CQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1, rw));
+
+  if (k < m)
+    {
+      q.resize (m, k-1);
+      r.resize (k-1, n-1);
+    }
   else
     {
-      OCTAVE_LOCAL_BUFFER (float, rw, k);
-      F77_XFCN (cqrdec, CQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, rw));
-
-      if (k < m)
-        {
-          q.resize (m, k-1);
-          r.resize (k-1, n-1);
-        }
-      else
-        {
-          r.resize (k, n-1);
-        }
+      r.resize (k, n-1);
     }
 }
 
 void
 FloatComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -373,19 +366,20 @@ FloatComplexQR::delete_col (const Array<
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
@@ -408,111 +402,101 @@ void
 FloatComplexQR::insert_row (const FloatComplexRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      q.resize (m + 1, m + 1);
-      r.resize (m + 1, n);
-      FloatComplexRowVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (float, rw, k);
-      F77_XFCN (cqrinr, CQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 j + 1, utmp.fortran_vec (), rw));
 
-    }
+  q.resize (m + 1, m + 1);
+  r.resize (m + 1, n);
+  FloatComplexRowVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (float, rw, k);
+  F77_XFCN (cqrinr, CQRINR, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             j + 1, utmp.fortran_vec (), rw));
+
 }
 
 void
 FloatComplexQR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
-      OCTAVE_LOCAL_BUFFER (float, rw, m);
-      F77_XFCN (cqrder, CQRDER, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 w, rw));
 
-      q.resize (m - 1, m - 1);
-      r.resize (m - 1, n);
-    }
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
+  OCTAVE_LOCAL_BUFFER (float, rw, m);
+  F77_XFCN (cqrder, CQRDER, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             w, rw));
+
+  q.resize (m - 1, m - 1);
+  r.resize (m - 1, n);
 }
 
 void
 FloatComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
-      OCTAVE_LOCAL_BUFFER (float, rw, k);
-      F77_XFCN (cqrshc, CQRSHC, (m, n, k,
-                                 q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 i + 1, j + 1, w, rw));
-    }
+
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
+  OCTAVE_LOCAL_BUFFER (float, rw, k);
+  F77_XFCN (cqrshc, CQRSHC, (m, n, k,
+                             q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             i + 1, j + 1, w, rw));
 }
 
 #else
 
 // Replacement update methods.
 
 void
 FloatComplexQR::update (const FloatComplexColumnVector& u,
                         const FloatComplexColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      init (q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (),
-            get_type ());
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (),
+        get_type ());
 }
 
 void
 FloatComplexQR::update (const FloatComplexMatrix& u,
                         const FloatComplexMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
-    {
-      init (q*r + u * v.hermitian (), get_type ());
-    }
-  else
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + u * v.hermitian (), get_type ());
 }
 
 static
 FloatComplexMatrix insert_col (const FloatComplexMatrix& a, octave_idx_type i,
                                const FloatComplexColumnVector& x)
 {
   FloatComplexMatrix retval (a.rows (), a.columns () + 1);
   retval.assign (idx_vector::colon, idx_vector (0, i),
@@ -579,22 +563,20 @@ FloatComplexQR::insert_col (const FloatC
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_col (q*r, j, u), get_type ());
-    }
+
+  init (::insert_col (q*r, j, u), get_type ());
 }
 
 void
 FloatComplexQR::insert_col (const FloatComplexMatrix& u,
                             const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
@@ -605,21 +587,22 @@ FloatComplexQR::insert_col (const FloatC
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       FloatComplexMatrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
@@ -627,20 +610,18 @@ void
 FloatComplexQR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_col (q*r, j), get_type ());
-    }
+
+  init (::delete_col (q*r, j), get_type ());
 }
 
 void
 FloatComplexQR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
@@ -649,19 +630,20 @@ FloatComplexQR::delete_col (const Array<
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       FloatComplexMatrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
@@ -670,49 +652,43 @@ FloatComplexQR::insert_row (const FloatC
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_row (q*r, j, u), get_type ());
-    }
+
+  init (::insert_row (q*r, j, u), get_type ());
 }
 
 void
 FloatComplexQR::delete_row (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_row (q*r, j), get_type ());
-    }
+
+  init (::delete_row (q*r, j), get_type ());
 }
 
 void
 FloatComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      init (::shift_cols (q*r, i, j), get_type ());
-    }
+
+  init (::shift_cols (q*r, i, j), get_type ());
 }
 
 #endif
diff --git a/liboctave/numeric/fCmplxSCHUR.cc b/liboctave/numeric/fCmplxSCHUR.cc
--- a/liboctave/numeric/fCmplxSCHUR.cc
+++ b/liboctave/numeric/fCmplxSCHUR.cc
@@ -65,22 +65,20 @@ select_dig (const FloatComplex& a)
 octave_idx_type
 FloatComplexSCHUR::init (const FloatComplexMatrix& a, const std::string& ord,
                          bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler)
-        ("FloatComplexSCHUR requires square matrix");
-      return -1;
-    }
-  else if (a_nr == 0)
+    (*current_liboctave_error_handler)
+      ("FloatComplexSCHUR requires square matrix");
+
+  if (a_nr == 0)
     {
       schur_mat.clear ();
       unitary_mat.clear ();
       return 0;
     }
 
   // Workspace requirements may need to be fixed if any of the
   // following change.
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -132,32 +132,26 @@ extern "C"
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
 
   Array<float> wr (dim_vector (n, 1));
   float *pwr = wr.fortran_vec ();
@@ -177,90 +171,76 @@ FloatEIG::init (const FloatMatrix& a, bo
 
   F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pwr, pwi, dummy,
                            idummy, pvr, n, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (dim_vector (lwork, 1));
-      float *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("sgeev workspace query failed");
 
-      F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, tmp_data, n, pwr, pwi, dummy,
-                               idummy, pvr, n, pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<float> work (dim_vector (lwork, 1));
+  float *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in sgeev");
-          return info;
-        }
+  F77_XFCN (sgeev, SGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pwr, pwi, dummy,
+                           idummy, pvr, n, pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("sgeev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in sgeev");
 
-      lambda.resize (n);
-      v.resize (nvr, nvr);
+  if (info > 0)
+    (*current_liboctave_error_handler) ("sgeev failed to converge");
+
+  lambda.resize (n);
+  v.resize (nvr, nvr);
 
-      for (octave_idx_type j = 0; j < n; j++)
+  for (octave_idx_type j = 0; j < n; j++)
+    {
+      if (wi.elem (j) == 0.0)
         {
-          if (wi.elem (j) == 0.0)
-            {
-              lambda.elem (j) = FloatComplex (wr.elem (j));
-              for (octave_idx_type i = 0; i < nvr; i++)
-                v.elem (i, j) = vr.elem (i, j);
-            }
-          else
+          lambda.elem (j) = FloatComplex (wr.elem (j));
+          for (octave_idx_type i = 0; i < nvr; i++)
+            v.elem (i, j) = vr.elem (i, j);
+        }
+      else
+        {
+          if (j+1 >= n)
+            (*current_liboctave_error_handler) ("EIG: internal error");
+
+          lambda.elem (j) = FloatComplex (wr.elem (j), wi.elem (j));
+          lambda.elem (j+1) = FloatComplex (wr.elem (j+1), wi.elem (j+1));
+
+          for (octave_idx_type i = 0; i < nvr; i++)
             {
-              if (j+1 >= n)
-                {
-                  (*current_liboctave_error_handler) ("EIG: internal error");
-                  return -1;
-                }
-
-              lambda.elem (j) = FloatComplex (wr.elem (j), wi.elem (j));
-              lambda.elem (j+1) = FloatComplex (wr.elem (j+1), wi.elem (j+1));
-
-              for (octave_idx_type i = 0; i < nvr; i++)
-                {
-                  float real_part = vr.elem (i, j);
-                  float imag_part = vr.elem (i, j+1);
-                  v.elem (i, j) = FloatComplex (real_part, imag_part);
-                  v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
-                }
-              j++;
+              float real_part = vr.elem (i, j);
+              float imag_part = vr.elem (i, j+1);
+              v.elem (i, j) = FloatComplex (real_part, imag_part);
+              v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
+          j++;
         }
     }
-  else
-    (*current_liboctave_error_handler) ("sgeev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
@@ -269,69 +249,55 @@ FloatEIG::symmetric_init (const FloatMat
   float dummy_work;
 
   F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (dim_vector (lwork, 1));
-      float *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("ssyev workspace query failed");
 
-      F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, tmp_data, n, pwr, pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<float> work (dim_vector (lwork, 1));
+  float *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in ssyev");
-          return info;
-        }
+  F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("ssyev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in ssyev");
 
-      lambda = FloatComplexColumnVector (wr);
-      v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("ssyev workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("ssyev failed to converge");
+
+  lambda = FloatComplexColumnVector (wr);
+  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_ev);
 
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
 
   FloatComplexColumnVector w (n);
   FloatComplex *pw = w.fortran_vec ();
@@ -352,60 +318,49 @@ FloatEIG::init (const FloatComplexMatrix
 
   F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, tmp_data, n, pw, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (dim_vector (lwork, 1));
-      FloatComplex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("cgeev workspace query failed");
 
-      F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, tmp_data, n, pw, dummy, idummy,
-                               pv, n, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<FloatComplex> work (dim_vector (lwork, 1));
+  FloatComplex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in cgeev");
-          return info;
-        }
+  F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, tmp_data, n, pw, dummy, idummy,
+                           pv, n, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("cgeev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in cgeev");
 
-      lambda = w;
-      v = vtmp;
-    }
-  else
-    (*current_liboctave_error_handler) ("cgeev workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("cgeev failed to converge");
+
+  lambda = w;
+  v = vtmp;
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::hermitian_init (const FloatComplexMatrix& a, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
@@ -419,73 +374,56 @@ FloatEIG::hermitian_init (const FloatCom
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (dim_vector (lwork, 1));
-      FloatComplex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("cheev workspace query failed");
 
-      F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, tmp_data, n, pwr, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<FloatComplex> work (dim_vector (lwork, 1));
+  FloatComplex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in cheev");
-          return info;
-        }
+  F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, tmp_data, n, pwr, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("cheev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in cheev");
 
-      lambda = FloatComplexColumnVector (wr);
-      v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("cheev workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("cheev failed to converge");
+
+  lambda = FloatComplexColumnVector (wr);
+  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, const FloatMatrix& b, bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   FloatMatrix tmp = b;
   float *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                              n, tmp_data, n,
@@ -525,102 +463,85 @@ FloatEIG::init (const FloatMatrix& a, co
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (dim_vector (lwork, 1));
-      float *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("sggev workspace query failed");
 
-      F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n,
-                               par, pai, pbeta,
-                               dummy, idummy, pvr, n,
-                               pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<float> work (dim_vector (lwork, 1));
+  float *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in sggev");
-          return info;
-        }
+  F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n,
+                           par, pai, pbeta,
+                           dummy, idummy, pvr, n,
+                           pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("sggev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in sggev");
 
-      lambda.resize (n);
-      v.resize (nvr, nvr);
+  if (info > 0)
+    (*current_liboctave_error_handler) ("sggev failed to converge");
+
+  lambda.resize (n);
+  v.resize (nvr, nvr);
 
-      for (octave_idx_type j = 0; j < n; j++)
+  for (octave_idx_type j = 0; j < n; j++)
+    {
+      if (ai.elem (j) == 0.0)
+        {
+          lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j));
+          for (octave_idx_type i = 0; i < nvr; i++)
+            v.elem (i, j) = vr.elem (i, j);
+        }
+      else
         {
-          if (ai.elem (j) == 0.0)
-            {
-              lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j));
-              for (octave_idx_type i = 0; i < nvr; i++)
-                v.elem (i, j) = vr.elem (i, j);
-            }
-          else
+          if (j+1 >= n)
+            (*current_liboctave_error_handler) ("EIG: internal error");
+
+          lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j),
+                                          ai.elem (j) / beta.elem (j));
+          lambda.elem (j+1) = FloatComplex (ar.elem (j+1) / beta.elem (j+1),
+                                            ai.elem (j+1) / beta.elem (j+1));
+
+          for (octave_idx_type i = 0; i < nvr; i++)
             {
-              if (j+1 >= n)
-                {
-                  (*current_liboctave_error_handler) ("EIG: internal error");
-                  return -1;
-                }
-
-              lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j),
-                                              ai.elem (j) / beta.elem (j));
-              lambda.elem (j+1) = FloatComplex (ar.elem (j+1) / beta.elem (j+1),
-                                                ai.elem (j+1) / beta.elem (j+1));
-
-              for (octave_idx_type i = 0; i < nvr; i++)
-                {
-                  float real_part = vr.elem (i, j);
-                  float imag_part = vr.elem (i, j+1);
-                  v.elem (i, j) = FloatComplex (real_part, imag_part);
-                  v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
-                }
-              j++;
+              float real_part = vr.elem (i, j);
+              float imag_part = vr.elem (i, j+1);
+              v.elem (i, j) = FloatComplex (real_part, imag_part);
+              v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
+          j++;
         }
     }
-  else
-    (*current_liboctave_error_handler) ("sggev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, const FloatMatrix& b,
                           bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   FloatMatrix atmp = a;
   float *atmp_data = atmp.fortran_vec ();
 
   FloatMatrix btmp = b;
   float *btmp_data = btmp.fortran_vec ();
@@ -634,76 +555,59 @@ FloatEIG::symmetric_init (const FloatMat
   F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work);
-      Array<float> work (dim_vector (lwork, 1));
-      float *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("ssygv workspace query failed");
 
-      F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n,
-                               btmp_data, n,
-                               pwr, pwork, lwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work);
+  Array<float> work (dim_vector (lwork, 1));
+  float *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in ssygv");
-          return info;
-        }
+  F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n,
+                           btmp_data, n,
+                           pwr, pwork, lwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("ssygv failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in ssygv");
 
-      lambda = FloatComplexColumnVector (wr);
-      v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("ssygv workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("ssygv failed to converge");
+
+  lambda = FloatComplexColumnVector (wr);
+  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
                 bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
-    {
-      (*current_liboctave_error_handler)
-        ("EIG: matrix contains Inf or NaN values");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("EIG: matrix contains Inf or NaN values");
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix tmp = b;
   FloatComplex *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                              n, tmp_data, n,
@@ -743,73 +647,59 @@ FloatEIG::init (const FloatComplexMatrix
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (dim_vector (lwork, 1));
-      FloatComplex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("cggev workspace query failed");
 
-      F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                               F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n,
-                               palpha, pbeta, dummy, idummy,
-                               pv, n, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<FloatComplex> work (dim_vector (lwork, 1));
+  FloatComplex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in cggev");
-          return info;
-        }
+  F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                           F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           n, atmp_data, n, btmp_data, n,
+                           palpha, pbeta, dummy, idummy,
+                           pv, n, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("cggev failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in cggev");
 
-      lambda.resize (n);
+  if (info > 0)
+    (*current_liboctave_error_handler) ("cggev failed to converge");
 
-      for (octave_idx_type j = 0; j < n; j++)
-        lambda.elem (j) = alpha.elem (j) / beta.elem (j);
+  lambda.resize (n);
 
-      v = vtmp;
-    }
-  else
-    (*current_liboctave_error_handler) ("cggev workspace query failed");
+  for (octave_idx_type j = 0; j < n; j++)
+    lambda.elem (j) = alpha.elem (j) / beta.elem (j);
+
+  v = vtmp;
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::hermitian_init (const FloatComplexMatrix& a,
                           const FloatComplexMatrix& b, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
-    {
-      (*current_liboctave_error_handler) ("EIG requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
-    {
-      (*current_liboctave_error_handler) ("EIG requires same size matrices");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *atmp_data = atmp.fortran_vec ();
 
   FloatComplexMatrix btmp = b;
   FloatComplex *btmp_data = btmp.fortran_vec ();
@@ -828,42 +718,34 @@ FloatEIG::hermitian_init (const FloatCom
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
-  if (info == 0)
-    {
-      lwork = static_cast<octave_idx_type> (dummy_work.real ());
-      Array<FloatComplex> work (dim_vector (lwork, 1));
-      FloatComplex *pwork = work.fortran_vec ();
+  if (info != 0)
+    (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
-      F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n,
-                               btmp_data, n,
-                               pwr, pwork, lwork, prwork, info
-                               F77_CHAR_ARG_LEN (1)
-                               F77_CHAR_ARG_LEN (1)));
+  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  Array<FloatComplex> work (dim_vector (lwork, 1));
+  FloatComplex *pwork = work.fortran_vec ();
 
-      if (info < 0)
-        {
-          (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
-          return info;
-        }
+  F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
+                           F77_CONST_CHAR_ARG2 ("U", 1),
+                           n, atmp_data, n,
+                           btmp_data, n,
+                           pwr, pwork, lwork, prwork, info
+                           F77_CHAR_ARG_LEN (1)
+                           F77_CHAR_ARG_LEN (1)));
 
-      if (info > 0)
-        {
-          (*current_liboctave_error_handler) ("zhegv failed to converge");
-          return info;
-        }
+  if (info < 0)
+    (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
-      lambda = FloatComplexColumnVector (wr);
-      v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-    }
-  else
-    (*current_liboctave_error_handler) ("zhegv workspace query failed");
+  if (info > 0)
+    (*current_liboctave_error_handler) ("zhegv failed to converge");
+
+  lambda = FloatComplexColumnVector (wr);
+  v = calc_ev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
diff --git a/liboctave/numeric/floatAEPBAL.cc b/liboctave/numeric/floatAEPBAL.cc
--- a/liboctave/numeric/floatAEPBAL.cc
+++ b/liboctave/numeric/floatAEPBAL.cc
@@ -52,20 +52,17 @@ extern "C"
 
 FloatAEPBALANCE::FloatAEPBALANCE (const FloatMatrix& a,
                                   bool noperm, bool noscal)
   : base_aepbal<FloatMatrix, FloatColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
-    {
-      (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
-      return;
-    }
+    (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
 
   octave_idx_type info;
 
   scale = FloatColumnVector (n);
   float *pscale = scale.fortran_vec ();
 
   balanced_mat = a;
   float *p_balanced_mat = balanced_mat.fortran_vec ();
diff --git a/liboctave/numeric/floatCHOL.cc b/liboctave/numeric/floatCHOL.cc
--- a/liboctave/numeric/floatCHOL.cc
+++ b/liboctave/numeric/floatCHOL.cc
@@ -88,20 +88,17 @@ extern "C"
 
 octave_idx_type
 FloatCHOL::init (const FloatMatrix& a, bool upper, bool calc_cond)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler) ("FloatCHOL requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("FloatCHOL requires square matrix");
 
   octave_idx_type n = a_nc;
   octave_idx_type info;
 
   is_upper = upper;
 
   chol_mat.clear (n, n);
   if (is_upper)
@@ -165,193 +162,179 @@ FloatCHOL::init (const FloatMatrix& a, b
 static FloatMatrix
 chol2inv_internal (const FloatMatrix& r, bool is_upper = true)
 {
   FloatMatrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
-  if (r_nr == r_nc)
-    {
-      octave_idx_type n = r_nc;
-      octave_idx_type info = 0;
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+
+  octave_idx_type n = r_nc;
+  octave_idx_type info = 0;
+
+  FloatMatrix tmp = r;
+  float *v = tmp.fortran_vec ();
 
-      FloatMatrix tmp = r;
-      float *v = tmp.fortran_vec ();
+  if (info == 0)
+    {
+      if (is_upper)
+        F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
+      else
+        F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
 
-      if (info == 0)
+      // If someone thinks of a more graceful way of doing this (or
+      // faster for that matter :-)), please let me know!
+
+      if (n > 1)
         {
           if (is_upper)
-            F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                                       v, n, info
-                                       F77_CHAR_ARG_LEN (1)));
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (i, j) = tmp.xelem (j, i);
           else
-            F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                                       v, n, info
-                                       F77_CHAR_ARG_LEN (1)));
-
-          // If someone thinks of a more graceful way of doing this (or
-          // faster for that matter :-)), please let me know!
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (j, i) = tmp.xelem (i, j);
+        }
 
-          if (n > 1)
-            {
-              if (is_upper)
-                for (octave_idx_type j = 0; j < r_nc; j++)
-                  for (octave_idx_type i = j+1; i < r_nr; i++)
-                    tmp.xelem (i, j) = tmp.xelem (j, i);
-              else
-                for (octave_idx_type j = 0; j < r_nc; j++)
-                  for (octave_idx_type i = j+1; i < r_nr; i++)
-                    tmp.xelem (j, i) = tmp.xelem (i, j);
-            }
-
-          retval = tmp;
-        }
+      retval = tmp;
     }
-  else
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
 FloatMatrix
 FloatCHOL::inverse (void) const
 {
   return chol2inv_internal (chol_mat, is_upper);
 }
 
 void
 FloatCHOL::set (const FloatMatrix& R)
 {
-  if (R.is_square ())
-    chol_mat = R;
-  else
+  if (! R.is_square ())
     (*current_liboctave_error_handler) ("FloatCHOL requires square matrix");
+
+  chol_mat = R;
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
 FloatCHOL::update (const FloatColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      FloatColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (float, w, n);
+  FloatColumnVector utmp = u;
 
-      F77_XFCN (sch1up, SCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), w));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (float, w, n);
+
+  F77_XFCN (sch1up, SCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), w));
 }
 
 octave_idx_type
 FloatCHOL::downdate (const FloatColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      FloatColumnVector utmp = u;
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-      OCTAVE_LOCAL_BUFFER (float, w, n);
+  FloatColumnVector utmp = u;
 
-      F77_XFCN (sch1dn, SCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 utmp.fortran_vec (), w, info));
-    }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+  OCTAVE_LOCAL_BUFFER (float, w, n);
+
+  F77_XFCN (sch1dn, SCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), w, info));
 
   return info;
 }
 
 octave_idx_type
 FloatCHOL::insert_sym (const FloatColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
-  else
-    {
-      FloatColumnVector utmp = u;
+
+  FloatColumnVector utmp = u;
 
-      OCTAVE_LOCAL_BUFFER (float, w, n);
-
-      chol_mat.resize (n+1, n+1);
+  OCTAVE_LOCAL_BUFFER (float, w, n);
 
-      F77_XFCN (schinx, SCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, utmp.fortran_vec (), w, info));
-    }
+  chol_mat.resize (n+1, n+1);
+
+  F77_XFCN (schinx, SCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, utmp.fortran_vec (), w, info));
 
   return info;
 }
 
 void
 FloatCHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (float, w, n);
+
+  OCTAVE_LOCAL_BUFFER (float, w, n);
 
-      F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 j + 1, w));
+  F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, w));
 
-      chol_mat.resize (n-1, n-1);
-    }
+  chol_mat.resize (n-1, n-1);
 }
 
 void
 FloatCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (float, w, 2*n);
+
+  OCTAVE_LOCAL_BUFFER (float, w, 2*n);
 
-      F77_XFCN (schshx, SCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                                 i + 1, j + 1, w));
-    }
+  F77_XFCN (schshx, SCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             i + 1, j + 1, w));
 }
 
 #else
 
 void
 FloatCHOL::update (const FloatColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
-    {
-      init (chol_mat.transpose () * chol_mat
-            + FloatMatrix (u) * FloatMatrix (u).transpose (), true, false);
-    }
-  else
+  if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  init (chol_mat.transpose () * chol_mat
+        + FloatMatrix (u) * FloatMatrix (u).transpose (), true, false);
 }
 
 static bool
 singular (const FloatMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     if (a(i,i) == 0.0f) return true;
   return false;
@@ -361,118 +344,110 @@ octave_idx_type
 FloatCHOL::downdate (const FloatColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (u.numel () == n)
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  if (singular (chol_mat))
+    info = 2;
+  else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else
-        {
-          info = init (chol_mat.transpose () * chol_mat
-                       - FloatMatrix (u) * FloatMatrix (u).transpose (), true,
-                       false);
-          if (info) info = 1;
-        }
+      info = init (chol_mat.transpose () * chol_mat
+                   - FloatMatrix (u) * FloatMatrix (u).transpose (), true,
+                   false);
+      if (info) info = 1;
     }
-  else
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
 
 octave_idx_type
 FloatCHOL::insert_sym (const FloatColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
+
+  if (singular (chol_mat))
+    info = 2;
   else
     {
-      if (singular (chol_mat))
-        info = 2;
-      else
-        {
-          FloatMatrix a = chol_mat.transpose () * chol_mat;
-          FloatMatrix a1 (n+1, n+1);
-          for (octave_idx_type k = 0; k < n+1; k++)
-            for (octave_idx_type l = 0; l < n+1; l++)
-              {
-                if (l == j)
-                  a1(k, l) = u(k);
-                else if (k == j)
-                  a1(k, l) = u(l);
-                else
-                  a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-              }
-          info = init (a1, true, false);
-          if (info) info = 1;
-        }
+      FloatMatrix a = chol_mat.transpose () * chol_mat;
+      FloatMatrix a1 (n+1, n+1);
+      for (octave_idx_type k = 0; k < n+1; k++)
+        for (octave_idx_type l = 0; l < n+1; l++)
+          {
+            if (l == j)
+              a1(k, l) = u(k);
+            else if (k == j)
+              a1(k, l) = u(l);
+            else
+              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
+          }
+      info = init (a1, true, false);
+      if (info) info = 1;
     }
 
   return info;
 }
 
 void
 FloatCHOL::delete_sym (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
-  else
-    {
-      FloatMatrix a = chol_mat.transpose () * chol_mat;
-      a.delete_elements (1, idx_vector (j));
-      a.delete_elements (0, idx_vector (j));
-      init (a, true, false);
-    }
+
+  FloatMatrix a = chol_mat.transpose () * chol_mat;
+  a.delete_elements (1, idx_vector (j));
+  a.delete_elements (0, idx_vector (j));
+  init (a, true, false);
 }
 
 void
 FloatCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
-  else
+
+  FloatMatrix a = chol_mat.transpose () * chol_mat;
+  Array<octave_idx_type> p (dim_vector (n, 1));
+  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
+  if (i < j)
     {
-      FloatMatrix a = chol_mat.transpose () * chol_mat;
-      Array<octave_idx_type> p (dim_vector (n, 1));
-      for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-      if (i < j)
-        {
-          for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-          p(j) = i;
-        }
-      else if (j < i)
-        {
-          p(j) = i;
-          for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-        }
+      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
+      p(j) = i;
+    }
+  else if (j < i)
+    {
+      p(j) = i;
+      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
+    }
 
-      init (a.index (idx_vector (p), idx_vector (p)), true, false);
-    }
+  init (a.index (idx_vector (p), idx_vector (p)), true, false);
 }
 
 #endif
 
 FloatMatrix
 chol2inv (const FloatMatrix& r)
 {
   return chol2inv_internal (r);
diff --git a/liboctave/numeric/floatGEPBAL.cc b/liboctave/numeric/floatGEPBAL.cc
--- a/liboctave/numeric/floatGEPBAL.cc
+++ b/liboctave/numeric/floatGEPBAL.cc
@@ -60,21 +60,18 @@ extern "C"
 
 octave_idx_type
 FloatGEPBALANCE::init (const FloatMatrix& a, const FloatMatrix& b,
                        const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
-    {
-      (*current_liboctave_error_handler)
-        ("FloatGEPBALANCE requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler)
+      ("FloatGEPBALANCE requires square matrix");
 
   if (a.dims () != b.dims ())
     err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
diff --git a/liboctave/numeric/floatHESS.cc b/liboctave/numeric/floatHESS.cc
--- a/liboctave/numeric/floatHESS.cc
+++ b/liboctave/numeric/floatHESS.cc
@@ -62,20 +62,17 @@ extern "C"
 
 octave_idx_type
 FloatHESS::init (const FloatMatrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler) ("FloatHESS requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("FloatHESS requires square matrix");
 
   char job = 'N';
   char side = 'R';
 
   octave_idx_type n = a_nc;
   octave_idx_type lwork = 32 * n;
   octave_idx_type info;
   octave_idx_type ilo;
diff --git a/liboctave/numeric/floatLU.cc b/liboctave/numeric/floatLU.cc
--- a/liboctave/numeric/floatLU.cc
+++ b/liboctave/numeric/floatLU.cc
@@ -92,113 +92,105 @@ void FloatLU::update (const FloatColumnV
 
   FloatMatrix& l = l_fact;
   FloatMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      FloatColumnVector utmp = u;
-      FloatColumnVector vtmp = v;
-      F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  FloatColumnVector utmp = u;
+  FloatColumnVector vtmp = v;
+  F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
+                             m, r.fortran_vec (), k,
+                             utmp.fortran_vec (), vtmp.fortran_vec ()));
 }
 
 void FloatLU::update (const FloatMatrix& u, const FloatMatrix& v)
 {
   if (packed ())
     unpack ();
 
   FloatMatrix& l = l_fact;
   FloatMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          FloatColumnVector utmp = u.column (i);
-          FloatColumnVector vtmp = v.column (i);
-          F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec ()));
-        }
+      FloatColumnVector utmp = u.column (i);
+      FloatColumnVector vtmp = v.column (i);
+      F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void FloatLU::update_piv (const FloatColumnVector& u,
                           const FloatColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   FloatMatrix& l = l_fact;
   FloatMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      FloatColumnVector utmp = u;
-      FloatColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (float, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (),
-                                   m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (),
-                                   utmp.data (), vtmp.data (), w));
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  FloatColumnVector utmp = u;
+  FloatColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (float, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (),
+                               m, r.fortran_vec (), k,
+                               ipvt.fortran_vec (),
+                               utmp.data (), vtmp.data (), w));
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 void FloatLU::update_piv (const FloatMatrix& u, const FloatMatrix& v)
 {
   if (packed ())
     unpack ();
 
   FloatMatrix& l = l_fact;
   FloatMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (float, w, m);
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (float, w, m);
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          FloatColumnVector utmp = u.column (i);
-          FloatColumnVector vtmp = v.column (i);
-          F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (),
-                                       m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (),
-                                       utmp.data (), vtmp.data (), w));
-        }
-      for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
+      FloatColumnVector utmp = u.column (i);
+      FloatColumnVector vtmp = v.column (i);
+      F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
     }
-  else
-    (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
+  for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 #else
 
 void FloatLU::update (const FloatColumnVector&, const FloatColumnVector&)
 {
   (*current_liboctave_error_handler)
     ("luupdate: not available in this version");
diff --git a/liboctave/numeric/floatQR.cc b/liboctave/numeric/floatQR.cc
--- a/liboctave/numeric/floatQR.cc
+++ b/liboctave/numeric/floatQR.cc
@@ -206,82 +206,76 @@ void FloatQR::form (octave_idx_type n, F
 
 void
 FloatQR::update (const FloatColumnVector& u, const FloatColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      FloatColumnVector utmp = u;
-      FloatColumnVector vtmp = v;
-      OCTAVE_LOCAL_BUFFER (float, w, 2*k);
-      F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (), w));
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  FloatColumnVector utmp = u;
+  FloatColumnVector vtmp = v;
+  OCTAVE_LOCAL_BUFFER (float, w, 2*k);
+  F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (),
+                             m, r.fortran_vec (), k,
+                             utmp.fortran_vec (), vtmp.fortran_vec (), w));
 }
 
 void
 FloatQR::update (const FloatMatrix& u, const FloatMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
+    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  OCTAVE_LOCAL_BUFFER (float, w, 2*k);
+  for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
-      OCTAVE_LOCAL_BUFFER (float, w, 2*k);
-      for (volatile octave_idx_type i = 0; i < u.cols (); i++)
-        {
-          FloatColumnVector utmp = u.column (i);
-          FloatColumnVector vtmp = v.column (i);
-          F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (),
-                                     m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (),
-                                     w));
-        }
+      FloatColumnVector utmp = u.column (i);
+      FloatColumnVector vtmp = v.column (i);
+      F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec (),
+                                 w));
     }
-  else
-    (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatQR::insert_col (const FloatColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
+
+  if (k < m)
+    {
+      q.resize (m, k+1);
+      r.resize (k+1, n+1);
+    }
   else
     {
-      if (k < m)
-        {
-          q.resize (m, k+1);
-          r.resize (k+1, n+1);
-        }
-      else
-        {
-          r.resize (k, n+1);
-        }
+      r.resize (k, n+1);
+    }
 
-      FloatColumnVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (float, w, k);
-      F77_XFCN (sqrinc, SQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 utmp.data (), w));
-    }
+  FloatColumnVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (float, w, k);
+  F77_XFCN (sqrinc, SQRINC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             utmp.data (), w));
 }
 
 void
 FloatQR::insert_col (const FloatMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
@@ -290,21 +284,22 @@ FloatQR::insert_col (const FloatMatrix& 
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       octave_idx_type kmax = std::min (k + nj, m);
       if (k < m)
         {
           q.resize (m, kmax);
           r.resize (kmax, n + nj);
         }
       else
@@ -329,31 +324,29 @@ void
 FloatQR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (float, w, k);
+  F77_XFCN (sqrdec, SQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1, w));
+
+  if (k < m)
+    {
+      q.resize (m, k-1);
+      r.resize (k-1, n-1);
+    }
   else
     {
-      OCTAVE_LOCAL_BUFFER (float, w, k);
-      F77_XFCN (sqrdec, SQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, w));
-
-      if (k < m)
-        {
-          q.resize (m, k-1);
-          r.resize (k-1, n-1);
-        }
-      else
-        {
-          r.resize (k, n-1);
-        }
+      r.resize (k, n-1);
     }
 }
 
 void
 FloatQR::delete_col (const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -363,19 +356,20 @@ FloatQR::delete_col (const Array<octave_
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, w, k);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (),
@@ -398,106 +392,96 @@ void
 FloatQR::insert_row (const FloatRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      q.resize (m + 1, m + 1);
-      r.resize (m + 1, n);
-      FloatRowVector utmp = u;
-      OCTAVE_LOCAL_BUFFER (float, w, k);
-      F77_XFCN (sqrinr, SQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 j + 1, utmp.fortran_vec (), w));
 
-    }
+  q.resize (m + 1, m + 1);
+  r.resize (m + 1, n);
+  FloatRowVector utmp = u;
+  OCTAVE_LOCAL_BUFFER (float, w, k);
+  F77_XFCN (sqrinr, SQRINR, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             j + 1, utmp.fortran_vec (), w));
+
 }
 
 void
 FloatQR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (float, w, 2*m);
-      F77_XFCN (sqrder, SQRDER, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1,
-                                 w));
 
-      q.resize (m - 1, m - 1);
-      r.resize (m - 1, n);
-    }
+  OCTAVE_LOCAL_BUFFER (float, w, 2*m);
+  F77_XFCN (sqrder, SQRDER, (m, n, q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (), j + 1,
+                             w));
+
+  q.resize (m - 1, m - 1);
+  r.resize (m - 1, n);
 }
 
 void
 FloatQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      OCTAVE_LOCAL_BUFFER (float, w, 2*k);
-      F77_XFCN (sqrshc, SQRSHC, (m, n, k,
-                                 q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (),
-                                 i + 1, j + 1, w));
-    }
+
+  OCTAVE_LOCAL_BUFFER (float, w, 2*k);
+  F77_XFCN (sqrshc, SQRSHC, (m, n, k,
+                             q.fortran_vec (), q.rows (),
+                             r.fortran_vec (), r.rows (),
+                             i + 1, j + 1, w));
 }
 
 #else
 
 // Replacement update methods.
 
 void
 FloatQR::update (const FloatColumnVector& u, const FloatColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.numel () == m && v.numel () == n)
-    {
-      init (q*r + FloatMatrix (u) * FloatMatrix (v).transpose (), get_type ());
-    }
-  else
+  if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + FloatMatrix (u) * FloatMatrix (v).transpose (), get_type ());
 }
 
 void
 FloatQR::update (const FloatMatrix& u, const FloatMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
-    {
-      init (q*r + u * v.transpose (), get_type ());
-    }
-  else
+  if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
+
+  init (q*r + u * v.transpose (), get_type ());
 }
 
 static
 FloatMatrix insert_col (const FloatMatrix& a, octave_idx_type i,
                         const FloatColumnVector& x)
 {
   FloatMatrix retval (a.rows (), a.columns () + 1);
   retval.assign (idx_vector::colon, idx_vector (0, i),
@@ -563,22 +547,20 @@ FloatQR::insert_col (const FloatColumnVe
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.numel () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n)
+  if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_col (q*r, j, u), get_type ());
-    }
+
+  init (::insert_col (q*r, j, u), get_type ());
 }
 
 void
 FloatQR::insert_col (const FloatMatrix& u, const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
@@ -588,21 +570,22 @@ FloatQR::insert_col (const FloatMatrix& 
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (u.numel () != m || u.columns () != nj)
+  if (u.numel () != m || u.columns () != nj)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
+  if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       FloatMatrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::insert_col (a, js(i), u.column (i));
       init (a, get_type ());
     }
 }
 
@@ -610,20 +593,18 @@ void
 FloatQR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_col (q*r, j), get_type ());
-    }
+
+  init (::delete_col (q*r, j), get_type ());
 }
 
 void
 FloatQR::delete_col (const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
@@ -632,19 +613,20 @@ FloatQR::delete_col (const Array<octave_
   Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
   octave_idx_type nj = js.numel ();
   bool dups = false;
   for (octave_idx_type i = 0; i < nj - 1; i++)
     dups = dups && js(i) == js(i+1);
 
   if (dups)
     (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
-  else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
+  if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else if (nj > 0)
+
+  if (nj > 0)
     {
       FloatMatrix a = q*r;
       for (octave_idx_type i = 0; i < js.numel (); i++)
         a = ::delete_col (a, js(i));
       init (a, get_type ());
     }
 }
 
@@ -653,49 +635,43 @@ FloatQR::insert_row (const FloatRowVecto
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.numel () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m)
+  if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
-  else
-    {
-      init (::insert_row (q*r, j, u), get_type ());
-    }
+
+  init (::insert_row (q*r, j, u), get_type ());
 }
 
 void
 FloatQR::delete_row (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1)
+  if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
-  else
-    {
-      init (::delete_row (q*r, j), get_type ());
-    }
+
+  init (::delete_row (q*r, j), get_type ());
 }
 
 void
 FloatQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
-  else
-    {
-      init (::shift_cols (q*r, i, j), get_type ());
-    }
+
+  init (::shift_cols (q*r, i, j), get_type ());
 }
 
 #endif
diff --git a/liboctave/numeric/floatSCHUR.cc b/liboctave/numeric/floatSCHUR.cc
--- a/liboctave/numeric/floatSCHUR.cc
+++ b/liboctave/numeric/floatSCHUR.cc
@@ -63,21 +63,19 @@ select_dig (const float& a, const float&
 octave_idx_type
 FloatSCHUR::init (const FloatMatrix& a, const std::string& ord,
                   bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler) ("FloatSCHUR requires square matrix");
-      return -1;
-    }
-  else if (a_nr == 0)
+    (*current_liboctave_error_handler) ("FloatSCHUR requires square matrix");
+
+  if (a_nr == 0)
     {
       schur_mat.clear ();
       unitary_mat.clear ();
       return 0;
     }
 
   // Workspace requirements may need to be fixed if any of the
   // following change.
diff --git a/liboctave/numeric/floatSVD.cc b/liboctave/numeric/floatSVD.cc
--- a/liboctave/numeric/floatSVD.cc
+++ b/liboctave/numeric/floatSVD.cc
@@ -53,36 +53,30 @@ extern "C"
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 }
 
 FloatMatrix
 FloatSVD::left_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
-    {
-      (*current_liboctave_error_handler)
-        ("FloatSVD: U not computed because type == SVD::sigma_only");
-      return FloatMatrix ();
-    }
-  else
-    return left_sm;
+    (*current_liboctave_error_handler)
+      ("FloatSVD: U not computed because type == SVD::sigma_only");
+
+  return left_sm;
 }
 
 FloatMatrix
 FloatSVD::right_singular_matrix (void) const
 {
   if (type_computed == SVD::sigma_only)
-    {
-      (*current_liboctave_error_handler)
-        ("FloatSVD: V not computed because type == SVD::sigma_only");
-      return FloatMatrix ();
-    }
-  else
-    return right_sm;
+    (*current_liboctave_error_handler)
+      ("FloatSVD: V not computed because type == SVD::sigma_only");
+
+  return right_sm;
 }
 
 octave_idx_type
 FloatSVD::init (const FloatMatrix& a, SVD::type svd_type,
                 SVD::driver svd_driver)
 {
   octave_idx_type info;
 
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -1191,33 +1191,31 @@ do_bessel (dptr f, const char *fn, const
   ComplexMatrix retval;
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type alpha_nr = alpha.rows ();
   octave_idx_type alpha_nc = alpha.cols ();
 
-  if (x_nr == alpha_nr && x_nc == alpha_nc)
-    {
-      octave_idx_type nr = x_nr;
-      octave_idx_type nc = x_nc;
-
-      retval.resize (nr, nc);
-
-      ierr.resize (dim_vector (nr, nc));
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
-    }
-  else
+  if (x_nr != alpha_nr || x_nc != alpha_nc)
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
+  octave_idx_type nr = x_nr;
+  octave_idx_type nc = x_nc;
+
+  retval.resize (nr, nc);
+
+  ierr.resize (dim_vector (nr, nc));
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
+      retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *, double alpha, const ComplexNDArray& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
@@ -1250,30 +1248,28 @@ do_bessel (dptr f, const char *, const N
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *fn, const NDArray& alpha,
            const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   ComplexNDArray retval;
 
-  if (dv == alpha.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-      ierr.resize (dv);
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
-    }
-  else
+  if (dv != alpha.dims ())
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+  ierr.resize (dv);
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
+
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, const RowVector& alpha,
            const ComplexColumnVector& x, bool scaled,
            Array<octave_idx_type>& ierr)
 {
@@ -1801,33 +1797,31 @@ do_bessel (fptr f, const char *fn, const
   FloatComplexMatrix retval;
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type alpha_nr = alpha.rows ();
   octave_idx_type alpha_nc = alpha.cols ();
 
-  if (x_nr == alpha_nr && x_nc == alpha_nc)
-    {
-      octave_idx_type nr = x_nr;
-      octave_idx_type nc = x_nc;
-
-      retval.resize (nr, nc);
-
-      ierr.resize (dim_vector (nr, nc));
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
-    }
-  else
+  if (x_nr != alpha_nr || x_nc != alpha_nc)
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
+  octave_idx_type nr = x_nr;
+  octave_idx_type nc = x_nc;
+
+  retval.resize (nr, nc);
+
+  ierr.resize (dim_vector (nr, nc));
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
+      retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *, float alpha, const FloatComplexNDArray& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
@@ -1861,30 +1855,28 @@ do_bessel (fptr f, const char *, const F
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *fn, const FloatNDArray& alpha,
            const FloatComplexNDArray& x, bool scaled,
            Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   FloatComplexNDArray retval;
 
-  if (dv == alpha.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-      ierr.resize (dv);
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
-    }
-  else
+  if (dv != alpha.dims ())
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+  ierr.resize (dv);
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
+
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatRowVector& alpha,
            const FloatComplexColumnVector& x, bool scaled,
            Array<octave_idx_type>& ierr)
 {
@@ -2573,18 +2565,18 @@ gammainc (double x, double a, bool& err)
 {
   double retval;
 
   err = false;
 
   if (a < 0.0 || x < 0.0)
     (*current_liboctave_error_handler)
       ("gammainc: A and X must be non-negative");
-  else
-    F77_XFCN (xgammainc, XGAMMAINC, (a, x, retval));
+
+  F77_XFCN (xgammainc, XGAMMAINC, (a, x, retval));
 
   return retval;
 }
 
 Matrix
 gammainc (double x, const Matrix& a)
 {
   octave_idx_type nr = a.rows ();
@@ -2596,17 +2588,17 @@ gammainc (double x, const Matrix& a)
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         result(i,j) = gammainc (x, a(i,j), err);
 
         if (err)
-          goto done;
+          goto done;  // FIXME: why not just use return to exit?
       }
 
   retval = result;
 
 done:
 
   return retval;
 }
@@ -2623,17 +2615,17 @@ gammainc (const Matrix& x, double a)
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         result(i,j) = gammainc (x(i,j), a, err);
 
         if (err)
-          goto done;
+          goto done;  // FIXME: why not just use return to exit?
       }
 
   retval = result;
 
 done:
 
   return retval;
 }
@@ -2645,38 +2637,36 @@ gammainc (const Matrix& x, const Matrix&
   Matrix retval;
 
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
-  if (nr == a_nr && nc == a_nc)
-    {
-      result.resize (nr, nc);
-
-      bool err;
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          {
-            result(i,j) = gammainc (x(i,j), a(i,j), err);
-
-            if (err)
-              goto done;
-          }
-
-      retval = result;
-    }
-  else
+  if (nr != a_nr || nc != a_nc)
     (*current_liboctave_error_handler)
       ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
        nr, nc, a_nr, a_nc);
 
+  result.resize (nr, nc);
+
+  bool err;
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
+      {
+        result(i,j) = gammainc (x(i,j), a(i,j), err);
+
+        if (err)
+          goto done;  // FIXME: why not just use return to exit?
+      }
+
+  retval = result;
+
 done:
 
   return retval;
 }
 
 NDArray
 gammainc (double x, const NDArray& a)
 {
@@ -2688,17 +2678,17 @@ gammainc (double x, const NDArray& a)
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result(i) = gammainc (x, a(i), err);
 
       if (err)
-        goto done;
+        goto done;  // FIXME: why not just use return to exit?
     }
 
   retval = result;
 
 done:
 
   return retval;
 }
@@ -2714,78 +2704,74 @@ gammainc (const NDArray& x, double a)
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result(i) = gammainc (x(i), a, err);
 
       if (err)
-        goto done;
+        goto done;  // FIXME: why not just use return to exit?
     }
 
   retval = result;
 
 done:
 
   return retval;
 }
 
 NDArray
 gammainc (const NDArray& x, const NDArray& a)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
 
-  NDArray retval;
-  NDArray result;
-
-  if (dv == a.dims ())
-    {
-      result.resize (dv);
-
-      bool err;
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        {
-          result(i) = gammainc (x(i), a(i), err);
-
-          if (err)
-            goto done;
-        }
-
-      retval = result;
-    }
-  else
+  if (dv != a.dims ())
     {
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
         ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
          x_str.c_str (), a_str. c_str ());
     }
 
+  NDArray retval;
+  NDArray result (dv);
+
+  bool err;
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      result(i) = gammainc (x(i), a(i), err);
+
+      if (err)
+        goto done;  // FIXME: why not just use return to exit?
+    }
+
+  retval = result;
+
 done:
 
   return retval;
 }
 
 float
 gammainc (float x, float a, bool& err)
 {
   float retval;
 
   err = false;
 
   if (a < 0.0 || x < 0.0)
     (*current_liboctave_error_handler)
       ("gammainc: A and X must be non-negative");
-  else
-    F77_XFCN (xsgammainc, XSGAMMAINC, (a, x, retval));
+
+  F77_XFCN (xsgammainc, XSGAMMAINC, (a, x, retval));
 
   return retval;
 }
 
 FloatMatrix
 gammainc (float x, const FloatMatrix& a)
 {
   octave_idx_type nr = a.rows ();
@@ -2797,17 +2783,17 @@ gammainc (float x, const FloatMatrix& a)
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         result(i,j) = gammainc (x, a(i,j), err);
 
         if (err)
-          goto done;
+          goto done;  // FIXME: why not just use return to exit?
       }
 
   retval = result;
 
 done:
 
   return retval;
 }
@@ -2824,17 +2810,17 @@ gammainc (const FloatMatrix& x, float a)
   bool err;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         result(i,j) = gammainc (x(i,j), a, err);
 
         if (err)
-          goto done;
+          goto done;  // FIXME: why not just use return to exit?
       }
 
   retval = result;
 
 done:
 
   return retval;
 }
@@ -2846,38 +2832,36 @@ gammainc (const FloatMatrix& x, const Fl
   FloatMatrix retval;
 
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
-  if (nr == a_nr && nc == a_nc)
-    {
-      result.resize (nr, nc);
-
-      bool err;
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          {
-            result(i,j) = gammainc (x(i,j), a(i,j), err);
-
-            if (err)
-              goto done;
-          }
-
-      retval = result;
-    }
-  else
+  if (nr != a_nr || nc != a_nc)
     (*current_liboctave_error_handler)
       ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
        nr, nc, a_nr, a_nc);
 
+  result.resize (nr, nc);
+
+  bool err;
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = 0; i < nr; i++)
+      {
+        result(i,j) = gammainc (x(i,j), a(i,j), err);
+
+        if (err)
+          goto done;  // FIXME: why not just use return to exit?
+      }
+
+  retval = result;
+
 done:
 
   return retval;
 }
 
 FloatNDArray
 gammainc (float x, const FloatNDArray& a)
 {
@@ -2889,17 +2873,17 @@ gammainc (float x, const FloatNDArray& a
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result(i) = gammainc (x, a(i), err);
 
       if (err)
-        goto done;
+        goto done;  // FIXME: why not just use return to exit?
     }
 
   retval = result;
 
 done:
 
   return retval;
 }
@@ -2915,17 +2899,17 @@ gammainc (const FloatNDArray& x, float a
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       result(i) = gammainc (x(i), a, err);
 
       if (err)
-        goto done;
+        goto done;  // FIXME: why not just use return to exit?
     }
 
   retval = result;
 
 done:
 
   return retval;
 }
@@ -2934,42 +2918,40 @@ FloatNDArray
 gammainc (const FloatNDArray& x, const FloatNDArray& a)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
 
   FloatNDArray retval;
   FloatNDArray result;
 
-  if (dv == a.dims ())
-    {
-      result.resize (dv);
-
-      bool err;
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        {
-          result(i) = gammainc (x(i), a(i), err);
-
-          if (err)
-            goto done;
-        }
-
-      retval = result;
-    }
-  else
+  if (dv != a.dims ())
     {
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
         ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
          x_str.c_str (), a_str.c_str ());
     }
 
+  result.resize (dv);
+
+  bool err;
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      result(i) = gammainc (x(i), a(i), err);
+
+      if (err)
+        goto done;  // FIXME: why not just use return to exit?
+    }
+
+  retval = result;
+
 done:
 
   return retval;
 }
 
 
 Complex rc_log1p (double x)
 {
@@ -3302,31 +3284,22 @@ betaincinv (double y, double p, double q
   double beta = xlgamma (p) + xlgamma (q) - xlgamma (p + q);
   bool err = false;
   fpu = pow (10.0, sae);
   value = y;
 
   //  Test for admissibility of parameters.
 
   if (p <= 0.0 || q <= 0.0)
-    {
-      (*current_liboctave_error_handler)
-        ("betaincinv: wrong parameters");
-    }
-
+    (*current_liboctave_error_handler) ("betaincinv: wrong parameters");
   if (y < 0.0 || 1.0 < y)
-    {
-      (*current_liboctave_error_handler)
-        ("betaincinv: wrong parameter Y");
-    }
+    (*current_liboctave_error_handler) ("betaincinv: wrong parameter Y");
 
   if (y == 0.0 || y == 1.0)
-    {
-      return value;
-    }
+    return value;
 
   //  Change tail if necessary.
 
   if (0.5 < y)
     {
       a = 1.0 - y;
       pp = q;
       qq = p;
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -68,16 +68,17 @@ octave_fftw_planner::octave_fftw_planner
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
 #if defined (HAVE_FFTW3_THREADS)
   int init_ret = fftw_init_threads ();
   if (! init_ret)
     (*current_liboctave_error_handler) ("Error initializing FFTW threads");
+
   //Use number of processors available to the current process
   //This can be later changed with fftw ("threads", nthreads)
   nthreads = num_processors (NPROC_CURRENT);
   fftw_plan_with_nthreads (nthreads);
 #endif
 
   // If we have a system wide wisdom file, import it.
   fftw_import_system_wisdom ();
@@ -109,22 +110,18 @@ octave_fftw_planner::instance_ok (void)
     {
       instance = new octave_fftw_planner ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create octave_fftw_planner object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create octave_fftw_planner object!");
 
   return retval;
 }
 
 #define CHECK_SIMD_ALIGNMENT(x) \
   (((reinterpret_cast<ptrdiff_t> (x)) & 0xF) == 0)
 
 fftw_plan
@@ -412,16 +409,17 @@ octave_float_fftw_planner::octave_float_
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
 #if defined (HAVE_FFTW3F_THREADS)
   int init_ret = fftwf_init_threads ();
   if (! init_ret)
     (*current_liboctave_error_handler) ("Error initializing FFTW3F threads");
+
   //Use number of processors available to the current process
   //This can be later changed with fftw ("threads", nthreads)
   nthreads = num_processors (NPROC_CURRENT);
   fftwf_plan_with_nthreads (nthreads);
 #endif
 
   // If we have a system wide wisdom file, import it.
   fftwf_import_system_wisdom ();
@@ -453,22 +451,18 @@ octave_float_fftw_planner::instance_ok (
     {
       instance = new octave_float_fftw_planner ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create octave_fftw_planner object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create octave_fftw_planner object!");
 
   return retval;
 }
 
 fftwf_plan
 octave_float_fftw_planner::do_create_plan (int dir, const int rank,
                                            const dim_vector dims,
                                            octave_idx_type howmany,
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -93,22 +93,18 @@ octave_rand::instance_ok (void)
     {
       instance = new octave_rand ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create octave_rand object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create octave_rand object!");
 
   return retval;
 }
 
 double
 octave_rand::do_seed (void)
 {
   union d2i { double d; int32_t i[2]; };
diff --git a/liboctave/numeric/oct-spparms.cc b/liboctave/numeric/oct-spparms.cc
--- a/liboctave/numeric/oct-spparms.cc
+++ b/liboctave/numeric/oct-spparms.cc
@@ -42,22 +42,18 @@ octave_sparse_params::instance_ok (void)
     {
       instance = new octave_sparse_params ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create octave_sparse_params object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create octave_sparse_params object!");
 
   return retval;
 }
 
 void
 octave_sparse_params::defaults (void)
 {
   if (instance_ok ())
@@ -175,29 +171,23 @@ octave_sparse_params::do_get_bandden (vo
 }
 
 bool
 octave_sparse_params::do_set_vals (const NDArray& vals)
 {
   octave_idx_type len = vals.numel ();
 
   if (len > OCTAVE_SPARSE_CONTROLS_SIZE)
-    {
-      (*current_liboctave_error_handler)
-        ("octave_sparse_params::do_set_vals: too many values");
+    (*current_liboctave_error_handler)
+      ("octave_sparse_params::do_set_vals: too many values");
 
-      return false;
-    }
-  else
-    {
-      for (int i = 0; i < len; i++)
-        params(i) = vals(i);
+  for (int i = 0; i < len; i++)
+    params(i) = vals(i);
 
-      return true;
-    }
+  return true;
 }
 
 bool
 octave_sparse_params::do_set_key (const std::string& key, const double& val)
 {
   for (int i = 0; i < OCTAVE_SPARSE_CONTROLS_SIZE; i++)
     {
       if (keys (i) == key)
diff --git a/liboctave/numeric/sparse-base-chol.cc b/liboctave/numeric/sparse-base-chol.cc
--- a/liboctave/numeric/sparse-base-chol.cc
+++ b/liboctave/numeric/sparse-base-chol.cc
@@ -84,21 +84,17 @@ sparse_base_chol<chol_type, chol_elt, p_
 {
   volatile octave_idx_type info = 0;
 
 #ifdef HAVE_CHOLMOD
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    {
-      (*current_liboctave_error_handler)
-        ("SparseCHOL requires square matrix");
-      return -1;
-    }
+    (*current_liboctave_error_handler) ("SparseCHOL requires square matrix");
 
   cholmod_common *cm = &Common;
 
   // Setup initial parameters
   CHOLMOD_NAME(start) (cm);
   cm->prefer_zomplex = false;
 
   double spu = octave_sparse_params::get_key ("spumoni");
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -378,17 +378,18 @@ dmsolve (const ST &a, const T &b, octave
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   RT retval;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
-  else if (nr == 0 || nc == 0 || b_nc == 0)
+
+  if (nr == 0 || nc == 0 || b_nc == 0)
     retval = RT (nc, b_nc, 0.0);
   else
     {
       octave_idx_type nnz_remaining = a.nnz ();
       CXSPARSE_DNAME () csm;
       csm.m = nr;
       csm.n = nc;
       csm.x = 0;
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -83,22 +83,18 @@ file_ops::instance_ok (void)
       instance = new file_ops (system_dir_sep_char, system_dir_sep_str,
                                system_dir_sep_chars);
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create file_ops object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create file_ops object!");
 
   return retval;
 }
 
 // The following tilde-expansion code was stolen and adapted from
 // readline.
 
 // The default value of tilde_additional_prefixes.  This is set to
diff --git a/liboctave/system/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
--- a/liboctave/system/lo-sysdep.cc
+++ b/liboctave/system/lo-sysdep.cc
@@ -51,24 +51,22 @@ octave_getcwd (void)
   std::string retval;
 
   // Using the gnulib getcwd module ensures that we have a getcwd that
   // will allocate a buffer as large as necessary if buf and size are
   // both 0.
 
   char *tmp = gnulib::getcwd (0, 0);
 
-  if (tmp)
-    {
-      retval = tmp;
-      free (tmp);
-    }
-  else
+  if (! tmp)
     (*current_liboctave_error_handler) ("unable to find current directory");
 
+  retval = tmp;
+  free (tmp);
+
   return retval;
 }
 
 int
 octave_chdir (const std::string& path_arg)
 {
   std::string path = file_ops::tilde_expand (path_arg);
 
diff --git a/liboctave/system/mach-info.cc b/liboctave/system/mach-info.cc
--- a/liboctave/system/mach-info.cc
+++ b/liboctave/system/mach-info.cc
@@ -145,22 +145,18 @@ oct_mach_info::instance_ok (void)
     {
       instance = new oct_mach_info ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create command history object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create command history object!");
 
   return retval;
 }
 
 oct_mach_info::float_format
 oct_mach_info::native_float_format (void)
 {
   return (instance_ok ())
@@ -190,18 +186,17 @@ oct_mach_info::string_to_float_format (c
     retval = oct_mach_info::native_float_format ();
   else if (s == "ieee-be" || s == "b")
     retval = oct_mach_info::flt_fmt_ieee_big_endian;
   else if (s == "ieee-le" || s == "l")
     retval = oct_mach_info::flt_fmt_ieee_little_endian;
   else if (s == "unknown")
     retval = oct_mach_info::flt_fmt_unknown;
   else
-    (*current_liboctave_error_handler)
-      ("invalid architecture type specified");
+    (*current_liboctave_error_handler) ("invalid architecture type specified");
 
   return retval;
 }
 
 std::string
 oct_mach_info::float_format_as_string (float_format flt_fmt)
 {
   std::string retval = "unknown";
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -85,22 +85,18 @@ octave_env::instance_ok (void)
     {
       instance = new octave_env ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create current working directory object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create current working directory object!");
 
   return retval;
 }
 
 std::string
 octave_env::polite_directory_format (const std::string& name)
 {
   return (instance_ok ())
diff --git a/liboctave/system/oct-syscalls.cc b/liboctave/system/oct-syscalls.cc
--- a/liboctave/system/oct-syscalls.cc
+++ b/liboctave/system/oct-syscalls.cc
@@ -352,17 +352,17 @@ octave_syscalls::popen2 (const std::stri
                         child_msg = "popen2 (child): unable to start process -- " + child_msg;
                     }
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
 
-              (*current_liboctave_error_handler)(child_msg.c_str ());
+              (*current_liboctave_error_handler) (child_msg.c_str ());
 
               exit (0);
             }
           else
             {
               // Parent process
               gnulib::close (child_stdin[0]);
               gnulib::close (child_stdout[1]);
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -960,22 +960,18 @@ command_editor::instance_ok (void)
     {
       make_command_editor ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create command history object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create command history object!");
 
   return retval;
 }
 
 void
 command_editor::make_command_editor (void)
 {
 #if defined (USE_READLINE)
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -507,22 +507,18 @@ command_history::instance_ok (void)
     {
       make_command_history ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create command history object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create command history object!");
 
   return retval;
 }
 
 void
 command_history::make_command_history (void)
 {
 #if defined (USE_READLINE)
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -385,22 +385,18 @@ oct_data_conv::string_to_data_type (cons
       if (pos > 0)
         {
           if (s[pos] == '*')
             {
               block_size = atoi (s.c_str ());
               s = s.substr (pos+1);
             }
           else
-            {
-              (*current_liboctave_error_handler)
-                ("invalid repeat count in '%s'", str.c_str ());
-
-              return;
-            }
+            (*current_liboctave_error_handler)
+              ("invalid repeat count in '%s'", str.c_str ());
         }
     }
 
   pos = s.find ('=');
 
   if (pos != std::string::npos)
     {
       if (s[pos+1] == '>')
@@ -456,22 +452,18 @@ oct_data_conv::string_to_data_type (cons
   if (pos > 0)
     {
       if (s[pos] == '*')
         {
           block_size = atoi (s.c_str ());
           s = s.substr (pos+1);
         }
       else
-        {
-          (*current_liboctave_error_handler)
-            ("invalid repeat count in '%s'", str.c_str ());
-
-          return;
-        }
+        (*current_liboctave_error_handler)
+          ("invalid repeat count in '%s'", str.c_str ());
     }
 
   output_type = string_to_data_type (s);
 }
 
 std::string
 oct_data_conv::data_type_as_string (oct_data_conv::data_type dt)
 {
diff --git a/liboctave/util/lo-ieee.cc b/liboctave/util/lo-ieee.cc
--- a/liboctave/util/lo-ieee.cc
+++ b/liboctave/util/lo-ieee.cc
@@ -264,16 +264,17 @@ octave_ieee_init (void)
           break;
 
         default:
           // If the format is unknown, then you will probably not have a
           // useful system, so we will abort here.  Anyone wishing to
           // experiment with building Octave on a system without IEEE
           // floating point should be capable of removing this check and
           // the configure test.
+          // FIXME: Should this be a warning so that abort is reached?
           (*current_liboctave_error_handler)
             ("lo_ieee_init: floating point format is not IEEE!  Maybe DLAMCH is miscompiled, or you are using some strange system without IEEE floating point math?");
           abort ();
         }
 
       initialized = true;
     }
 }
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -90,21 +90,18 @@ regexp::compile_internal (void)
           // should be perfectly legal, while pcre does not allow the same
           // named token name on both sides of the alternative. Also fix
           // that here by replacing name tokens by dummy names, and dealing
           // with the dummy names later.
 
           size_t tmp_pos = pattern.find_first_of ('>', new_pos);
 
           if (tmp_pos == std::string::npos)
-            {
-              (*current_liboctave_error_handler)
-                ("regexp: syntax error in pattern");
-              return;
-            }
+            (*current_liboctave_error_handler)
+              ("regexp: syntax error in pattern");
 
           std::string tmp_name =
             pattern.substr (new_pos+3, tmp_pos-new_pos-3);
 
           bool found = false;
 
           for (int i = 0; i < nnames; i++)
             {
@@ -230,18 +227,17 @@ regexp::compile_internal (void)
        | (options.dotexceptnewline () ? 0 : PCRE_DOTALL)
        | (options.lineanchors () ? PCRE_MULTILINE : 0)
        | (options.freespacing () ? PCRE_EXTENDED : 0));
 
   data = pcre_compile (buf_str.c_str (), pcre_options, &err, &erroffset, 0);
 
   if (! data)
     (*current_liboctave_error_handler)
-      ("%s: %s at position %d of expression", who.c_str (),
-       err, erroffset);
+      ("%s: %s at position %d of expression", who.c_str (), err, erroffset);
 }
 
 regexp::match_data
 regexp::match (const std::string& buffer)
 {
   regexp::match_data retval;
 
   std::list<regexp::match_element> lst;
@@ -304,23 +300,21 @@ regexp::match (const std::string& buffer
               matches = pcre_exec (re, &pe, buffer.c_str (),
                                    buffer.length (), idx,
                                    (idx ? PCRE_NOTBOL : 0),
                                    ovector, (subpatterns+1)*3);
             }
         }
 
       if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
-        {
-          (*current_liboctave_error_handler)
-            ("%s: internal error calling pcre_exec; error code from pcre_exec is %i",
-             who.c_str (), matches);
-          return retval;
-        }
-      else if (matches == PCRE_ERROR_NOMATCH)
+        (*current_liboctave_error_handler)
+          ("%s: internal error calling pcre_exec; "
+           "error code from pcre_exec is %i", who.c_str (), matches);
+
+      if (matches == PCRE_ERROR_NOMATCH)
         break;
       else if (ovector[1] <= ovector[0] && ! options.emptymatch ())
         {
           // Zero length match.  Skip to next char.
           idx = ovector[0] + 1;
           if (idx < buffer.length ())
             continue;
           else
@@ -347,22 +341,19 @@ regexp::match (const std::string& buffer
           double start = double (ovector[0]+1);
           double end = double (ovector[1]);
 
           const char **listptr;
           int status = pcre_get_substring_list (buffer.c_str (), ovector,
                                                 matches, &listptr);
 
           if (status == PCRE_ERROR_NOMEMORY)
-            {
-              (*current_liboctave_error_handler)
-                ("%s: cannot allocate memory in pcre_get_substring_list",
-                 who.c_str ());
-              return retval;
-            }
+            (*current_liboctave_error_handler)
+              ("%s: cannot allocate memory in pcre_get_substring_list",
+               who.c_str ());
 
           string_vector tokens (pos_match);
           string_vector named_tokens (nnames);
           int pos_offset = 0;
           pos_match = 0;
 
           for (int i = 1; i < matches; i++)
             {
diff --git a/liboctave/util/oct-base64.cc b/liboctave/util/oct-base64.cc
--- a/liboctave/util/oct-base64.cc
+++ b/liboctave/util/oct-base64.cc
@@ -63,32 +63,30 @@ octave_base64_decode (const std::string&
   char *out;
   size_t outlen;
 
   bool ok = base64_decode_alloc (inc, str.length (), &out, &outlen);
 
   if (! ok)
     (*current_liboctave_error_handler)
       ("base64_decode: input was not valid base64");
-  else if (! out)
+  if (! out)
     (*current_liboctave_error_handler)
       ("base64_decode: memory allocation error");
+
+  if ((outlen % (sizeof (double) / sizeof (char))) != 0)
+    {
+      ::free (out);
+      (*current_liboctave_error_handler)
+        ("base64_decode: incorrect input size");
+    }
   else
     {
-      if ((outlen % (sizeof (double) / sizeof (char))) != 0)
-        {
-          ::free (out);
-          (*current_liboctave_error_handler)
-            ("base64_decode: incorrect input size");
-        }
-      else
-        {
-          octave_idx_type len = (outlen * sizeof (char)) / sizeof (double);
-          retval.resize (dim_vector (1, len));
-          double *dout = reinterpret_cast<double*> (out);
-          std::copy (dout, dout + len, retval.fortran_vec ());
-          ::free (out);
-        }
+      octave_idx_type len = (outlen * sizeof (char)) / sizeof (double);
+      retval.resize (dim_vector (1, len));
+      double *dout = reinterpret_cast<double*> (out);
+      std::copy (dout, dout + len, retval.fortran_vec ());
+      ::free (out);
     }
 
   return retval;
 }
 
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -223,29 +223,27 @@ octave_dlopen_shlib::~octave_dlopen_shli
 }
 
 void *
 octave_dlopen_shlib::search (const std::string& name,
                              octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
-  if (is_open ())
-    {
-      std::string sym_name = name;
-
-      if (mangler)
-        sym_name = mangler (name);
-
-      function = dlsym (library, sym_name.c_str ());
-    }
-  else
+  if (! is_open ())
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
+  std::string sym_name = name;
+
+  if (mangler)
+    sym_name = mangler (name);
+
+  function = dlsym (library, sym_name.c_str ());
+
   return function;
 }
 
 #elif defined (HAVE_SHL_LOAD_API)
 
 class
 octave_shl_load_shlib : public octave_shlib::shlib_rep
 {
@@ -275,47 +273,45 @@ octave_shl_load_shlib::octave_shl_load_s
   : octave_shlib::shlib_rep (f), library (0)
 {
   file = f;
 
   library = shl_load (file.c_str (), BIND_IMMEDIATE, 0L);
 
   if (! library)
     {
-      using namespace std;
+      using namespace std;  // FIXME: Why have this line?
       (*current_liboctave_error_handler) ("%s", gnulib::strerror (errno));
     }
 }
 
 octave_shl_load_shlib::~octave_shl_load_shlib (void)
 {
   if (library)
     shl_unload (library);
 }
 
 void *
 octave_shl_load_shlib::search (const std::string& name,
                                octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
-  if (is_open ())
-    {
-      std::string sym_name = name;
-
-      if (mangler)
-        sym_name = mangler (name);
-
-      int status = shl_findsym (&library, sym_name.c_str (),
-                                TYPE_UNDEFINED, &function);
-    }
-  else
+  if (! is_open ())
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
+  std::string sym_name = name;
+
+  if (mangler)
+    sym_name = mangler (name);
+
+  int status = shl_findsym (&library, sym_name.c_str (),
+                            TYPE_UNDEFINED, &function);
+
   return function;
 }
 
 #elif defined (HAVE_LOADLIBRARY_API)
 
 class
 octave_w32_shlib: public octave_shlib::shlib_rep
 {
@@ -386,29 +382,27 @@ extern "C"
 }
 
 void *
 octave_w32_shlib::search (const std::string& name,
                           octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
-  if (is_open ())
-    {
-      std::string sym_name = name;
-
-      if (mangler)
-        sym_name = mangler (name);
-
-      function = octave_w32_library_search (handle, sym_name.c_str ());
-    }
-  else
+  if (! is_open ())
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
+  std::string sym_name = name;
+
+  if (mangler)
+    sym_name = mangler (name);
+
+  function = octave_w32_library_search (handle, sym_name.c_str ());
+
   return function;
 }
 
 #elif defined (HAVE_DYLD_API)
 
 class
 octave_dyld_shlib : public octave_shlib::shlib_rep
 {
@@ -439,44 +433,41 @@ private:
   NSModule handle;
 };
 
 octave_dyld_shlib::octave_dyld_shlib (const std::string& f)
   : octave_shlib::shlib_rep (f), handle (0)
 {
   int returnCode = NSCreateObjectFileImageFromFile (file.c_str (), &img);
 
-  if (NSObjectFileImageSuccess == returnCode)
-    {
-      handle = NSLinkModule (img, file.c_str (),
-                             (NSLINKMODULE_OPTION_RETURN_ON_ERROR
-                              | NSLINKMODULE_OPTION_PRIVATE));
-      if (! handle)
-        {
-          NSLinkEditErrors ler;
-          int lerno;
-          const char *file2;
-          const char *errstr = 0;
-
-          NSLinkEditError (&ler, &lerno, &file2, &errstr);
-
-          if (! errstr)
-            errstr = "unspecified error";
-
-          (*current_liboctave_error_handler)
-            ("%s: %s", file.c_str (), errstr);
-        }
-    }
-  else
+  if (NSObjectFileImageSuccess != returnCode)
     {
       (*current_liboctave_error_handler)
         ("got NSObjectFileImageReturnCode %d", returnCode);
 
       // FIXME: should use NSLinkEditError () to get
-      // more info on what went wrong.
+      //        more info on what went wrong.
+    }
+
+  handle = NSLinkModule (img, file.c_str (),
+                         (NSLINKMODULE_OPTION_RETURN_ON_ERROR
+                          | NSLINKMODULE_OPTION_PRIVATE));
+  if (! handle)
+    {
+      NSLinkEditErrors ler;
+      int lerno;
+      const char *file2;
+      const char *errstr = 0;
+
+      NSLinkEditError (&ler, &lerno, &file2, &errstr);
+
+      if (! errstr)
+        errstr = "unspecified error";
+
+      (*current_liboctave_error_handler) ("%s: %s", file.c_str (), errstr);
     }
 }
 
 octave_dyld_shlib::~octave_dyld_shlib (void)
 {
   if (handle)
     NSUnLinkModule (handle, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
 
@@ -484,34 +475,32 @@ octave_dyld_shlib::~octave_dyld_shlib (v
 }
 
 void *
 octave_dyld_shlib::search (const std::string& name,
                            octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
-  if (is_open ())
-    {
-      std::string sym_name = name;
-
-      if (mangler)
-        sym_name = mangler (name);
-
-      NSSymbol symbol = NSLookupSymbolInModule (handle, sym_name.c_str ());
-
-      if (symbol)
-        {
-          function = NSAddressOfSymbol (symbol);
-        }
-    }
-  else
+  if (! is_open ())
     (*current_liboctave_error_handler)
       ("bundle %s is not open", file.c_str ());
 
+  std::string sym_name = name;
+
+  if (mangler)
+    sym_name = mangler (name);
+
+  NSSymbol symbol = NSLookupSymbolInModule (handle, sym_name.c_str ());
+
+  if (symbol)
+    {
+      function = NSAddressOfSymbol (symbol);
+    }
+
   return function;
 }
 
 #endif
 
 octave_shlib::shlib_rep *
 octave_shlib::shlib_rep::new_instance (const std::string& f)
 {
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -50,22 +50,18 @@ dir_path::static_members::instance_ok (v
     {
       instance = new static_members ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create dir_path::static_members object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create dir_path::static_members object!");
 
   return retval;
 }
 
 string_vector
 dir_path::elements (void)
 {
   return initialized ? pv : string_vector ();
diff --git a/liboctave/util/singleton-cleanup.cc b/liboctave/util/singleton-cleanup.cc
--- a/liboctave/util/singleton-cleanup.cc
+++ b/liboctave/util/singleton-cleanup.cc
@@ -44,17 +44,13 @@ bool
 singleton_cleanup_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     instance = new singleton_cleanup_list ();
 
   if (! instance)
-    {
-      (*current_liboctave_error_handler)
-        ("unable to create singleton_cleanup_list object!");
-
-      retval = false;
-    }
+    (*current_liboctave_error_handler)
+      ("unable to create singleton_cleanup_list object!");
 
   return retval;
 }
diff --git a/liboctave/util/sparse-util.cc b/liboctave/util/sparse-util.cc
--- a/liboctave/util/sparse-util.cc
+++ b/liboctave/util/sparse-util.cc
@@ -39,17 +39,16 @@ SparseCholError (int status, char *file,
   SparseCholError (status, file, line, message);
 }
 
 #ifdef HAVE_CHOLMOD
 
 void
 SparseCholError (int status, const char *file, int line, const char *message)
 {
-
   // Ignore CHOLMOD_NOT_POSDEF, since we handle that in Fchol as an
   // error or exit status.
   if (status != CHOLMOD_NOT_POSDEF)
     (*current_liboctave_warning_with_id_handler)
       ("Octave:cholmod-message", "warning %i, at line %i in file %s: %s",
        status, line, file, message);
 }
 
@@ -76,59 +75,45 @@ SparseCholPrint (const char *fmt, ...)
 bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
                    octave_idx_type nrows, octave_idx_type ncols,
                    octave_idx_type nnz)
 {
   if (nnz > 0)
     {
       if (c[0] != 0)
-        {
-          (*current_liboctave_error_handler)
-            ("invalid sparse matrix: cidx[0] must be zero");
-          return false;
-        }
+        (*current_liboctave_error_handler)
+          ("invalid sparse matrix: cidx[0] must be zero");
 
       octave_idx_type jold = 0;
 
       for (octave_idx_type j = 1; j < ncols+1; j++)
         {
           if (c[j] < c[j-1])
-            {
-              (*current_liboctave_error_handler)
-                ("invalid sparse matrix: cidx elements must appear in ascending order");
-              return false;
-            }
+            (*current_liboctave_error_handler)
+              ("invalid sparse matrix: cidx elements must appear in ascending order");
 
           if (c[j] > nnz)
-            {
-              (*current_liboctave_error_handler)
-                ("invalid sparse matrix: cidx[%d] = %d exceeds number of nonzero elements",
-                 j, c[j]+1);
-              return false;
-            }
+            (*current_liboctave_error_handler)
+              ("invalid sparse matrix: cidx[%d] = %d "
+               "exceeds number of nonzero elements", j, c[j]+1);
 
           if (c[j] != jold)
             {
               for (octave_idx_type i = jold+1; i < c[j]; i++)
                 {
                   if (r[i] < r[i-1])
-                    {
-                      (*current_liboctave_error_handler)
-                        ("invalid sparse matrix: ridx elements must appear in ascending order for each column");
-                      return false;
-                    }
+                    (*current_liboctave_error_handler)
+                      ("invalid sparse matrix: ridx elements must appear "
+                       "in ascending order for each column");
 
                   if (r[i] >= nrows)
-                    {
-                      (*current_liboctave_error_handler)
-                        ("invalid sparse matrix: ridx[%d] = %d out of range",
-                         i, r[i]+1);
-                      return false;
-                    }
+                    (*current_liboctave_error_handler)
+                      ("invalid sparse matrix: ridx[%d] = %d out of range",
+                       i, r[i]+1);
                 }
 
               jold = c[j];
             }
         }
     }
 
   return true;
diff --git a/liboctave/util/unwind-prot.cc b/liboctave/util/unwind-prot.cc
--- a/liboctave/util/unwind-prot.cc
+++ b/liboctave/util/unwind-prot.cc
@@ -28,12 +28,11 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 #include "unwind-prot.h"
 
 void
 unwind_protect_safe::err_unhandled_exception (void)
 {
   // FIXME: can this throw an exception?
   //        Yes, it can now (1/18/16).  Maybe this needs to be re-done?
-
   (*current_liboctave_error_handler)
     ("internal: unhandled exception in unwind_protect handler");
 }
