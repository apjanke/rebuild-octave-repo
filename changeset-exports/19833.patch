# HG changeset patch
# User Rik <rik@octave.org>
# Date 1424732079 28800
#      Mon Feb 23 14:54:39 2015 -0800
# Node ID 9fc020886ae911ef791999e90a7e78415266c403
# Parent  a1acca0c2216fd573a428cab6fa68ec99799406b
maint: Clean up m-files to follow Octave coding conventions.
Try to trim long lines to < 80 chars.
Use '##' for single line comments.
Use '(...)' around tests for if/elseif/switch/while.
Abut cell indexing operator '{' next to variable.
Abut array indexing operator '(' next to variable.
Use space between negation operator '!' and following expression.
Use two newlines between endfunction and start of %!test or %!demo code.
Remove unnecessary parens grouping between short-circuit operators.
Remove stray extra spaces (typos) between variables and assignment operators.
Remove stray extra spaces from ends of lines.

diff --git a/scripts/audio/@audioplayer/audioplayer.m b/scripts/audio/@audioplayer/audioplayer.m
--- a/scripts/audio/@audioplayer/audioplayer.m
+++ b/scripts/audio/@audioplayer/audioplayer.m
@@ -102,16 +102,17 @@ function player = audioplayer (varargin)
       varargin{1} = str2func (varargin{1});
     endif
     player.player = __player_audioplayer__ (varargin{:});
     player = class (player, "audioplayer");
   endif
 
 endfunction
 
+
 %!demo
 %! fs = 44100;
 %! audio = randn (2, 2*fs) - 0.5;
 %! player = audioplayer (audio, fs);
 %! play (player);
 %! sleep (1);
 %! pause (player);
 %! sleep (1);
diff --git a/scripts/audio/@audiorecorder/audiorecorder.m b/scripts/audio/@audiorecorder/audiorecorder.m
--- a/scripts/audio/@audiorecorder/audiorecorder.m
+++ b/scripts/audio/@audiorecorder/audiorecorder.m
@@ -46,16 +46,17 @@ function recorder = audiorecorder (varar
     varargin{1} = str2func (varargin{1});
   endif
 
   recorder.recorder = __recorder_audiorecorder__ (varargin{:});
   recorder = class (recorder, "audiorecorder");
 
 endfunction
 
+
 %!demo
 %! recorder = audiorecorder (44100, 16, 2);
 %! record (recorder, 1);
 %! sleep (2);
 %! player1 = audioplayer (recorder);
 %! player2 = getplayer (recorder);
 %! play (player1);
 %! sleep (2);
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -58,17 +58,17 @@ function y = mu2lin (x, n = 0)
             120,   112,   104,    96,    88,    80,    72,    64, ...
              56,    48,    40,    32,    24,    16,     8,     0 ];
 
   ulaw = [ -ulaw, ulaw ];
 
   ## Set the shape of y to that of x overwrites the contents of y with
   ## ulaw of x.
   y = x;
-  y(:) = ulaw (x + 1);
+  y(:) = ulaw(x + 1);
 
   ## Convert to real or 8-bit.
   if (n == 0)
     ## [ -32768, 32767 ] -> [ -1, 1)
     y = y/32768;
   elseif (n == 8)
     ld = max (abs (y (:)));
     if (ld < 16384 && ld > 0)
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -57,14 +57,14 @@ function x = record (sec, fs)
 
 endfunction
 
 
 ## Tests of record must not actually record anything.
 
 %!assert (isempty (record (0)))
 
-%% Test input validation
+## Test input validation
 %!error record ()
 %!error record (1,2,3)
 %!error record (-1)
 %!error record (1, -1)
 
diff --git a/scripts/audio/sound.m b/scripts/audio/sound.m
--- a/scripts/audio/sound.m
+++ b/scripts/audio/sound.m
@@ -54,14 +54,14 @@ function sound (y, fs, nbits)
 
   playblocking (play);
 
 endfunction
 
 
 ## Tests of sound must not actually play anything.
 
-%% Test input validation
+## Test input validation
 %!error sound ()
 %!error sound (1,2,3,4)
 %!error sound (1, -1)
 %!error sound (1, [], 2)
 
diff --git a/scripts/audio/soundsc.m b/scripts/audio/soundsc.m
--- a/scripts/audio/soundsc.m
+++ b/scripts/audio/soundsc.m
@@ -45,26 +45,26 @@ function soundsc (y, fs, nbits, yrange)
   endif
 
   if (nargin < 4)
     yrange = [];
   endif
 
   if (nargin < 2 || isempty (fs))
     fs = 8000;
-  elseif ((nargin == 2) && (numel (fs) > 1))
+  elseif (nargin == 2 && numel (fs) > 1)
     yrange = fs;
     fs = 8000;
   elseif (! (isscalar (fs) && (fs > 0)))
     error ("soundsc: sample rate FS must be a positive number");
   endif
 
   if (nargin < 3 || isempty (nbits))
     nbits = 8;
-  elseif ((nargin == 3) && (numel (nbits) > 1))
+  elseif (nargin == 3 && numel (nbits) > 1)
     yrange = nbits;
     nbits = 8;
   elseif (! (isscalar (nbits) && (nbits == 8 || nbits == 16 || nbits == 24)))
     error ("soundsc: bit depth NBITS must be 8, 16, or 24");
   endif
 
   if (isreal (yrange) && (numel (yrange) == 2) && (yrange(1) <= yrange(2)))
     ymin = yrange(1);
@@ -87,17 +87,17 @@ function soundsc (y, fs, nbits, yrange)
 
   playblocking (play);
 
 endfunction
 
 
 ## Tests of soundsc must not actually play anything.
 
-%% Test input validation
+## Test input validation
 %!error soundsc ()
 %!error soundsc (1,2,3,4,5)
 %!error soundsc (1, -1)
 %!error soundsc (1, [], 2)
 %!error soundsc (1, [2 1])
 %!error soundsc (1, [1 2 3])
 %!error soundsc (1, 8000, [2 1])
 %!error soundsc (1, 8000, [1 2 3])
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -98,16 +98,16 @@ function [y, fs, nbits] = wavread (filen
     nbits = info.BitsPerSample;
   endif
 
 endfunction
 
 
 ## Functional tests for wavread/wavwrite pair are in wavwrite.m.
 
-%% Test input validation
+## Test input validation
 %!error wavread ()
 %!error wavread (1)
 %!error wavread ("foo.wav", 2, 3, 4)
 %!error wavread ("foo.wav", "foo")
 %!error wavread ("foo.wav", -1)
 %!error wavread ("foo.wav", [1, Inf], "foo");
 
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -163,14 +163,14 @@ endfunction
 %!   wavwrite (A, fname);
 %!   [nsamp, nchan] = wavread (fname, "size");
 %!   assert (nsamp, 21);
 %!   assert (nchan, 2);
 %! unwind_protect_cleanup
 %!   unlink (fname);
 %! end_unwind_protect
 
-%% Test input validation
+## Test input validation
 %!error wavwrite ()
 %!error wavwrite (1)
 %!error wavwrite (1,2,3,4,5)
 %!error wavwrite ([], "foo.wav");
 
diff --git a/scripts/deprecated/delaunay3.m b/scripts/deprecated/delaunay3.m
--- a/scripts/deprecated/delaunay3.m
+++ b/scripts/deprecated/delaunay3.m
@@ -81,10 +81,10 @@ function tetr = delaunay3 (x, y, z, opti
 
 endfunction
 
 
 %!testif HAVE_QHULL
 %! x = [-1, -1, 1, 0, -1]; y = [-1, 1, 1, 0, -1]; z = [0, 0, 0, 1, 1];
 %! assert (sortrows (sort (delaunay3 (x, y, z), 2)), [1,2,3,4;1,2,4,5])
 
-%% FIXME: Need input validation tests
+## FIXME: Need input validation tests
 
diff --git a/scripts/deprecated/interp1q.m b/scripts/deprecated/interp1q.m
--- a/scripts/deprecated/interp1q.m
+++ b/scripts/deprecated/interp1q.m
@@ -50,17 +50,17 @@ function yi = interp1q (x, y, xi)
   szy = size (y);
   y = y(:,:);
   [ny, nc] = size (y);
   szx = size (xi);
   xi = xi (:);
   dy = diff (y);
   dx = diff (x);
   idx = lookup (x, xi, "lr");
-  s = (xi - x (idx)) ./ dx (idx);
+  s = (xi - x(idx)) ./ dx(idx);
   yi = bsxfun (@times, s, dy(idx,:)) + y(idx,:);
   range = xi < x(1) | !(xi <= x(nx));
   yi(range,:) = NA;
   if (length (szx) == 2 && any (szx == 1))
     yi = reshape (yi, [max(szx), szy(2:end)]);
   else
     yi = reshape (yi, [szx, szy(2:end)]);
   endif
diff --git a/scripts/deprecated/java_convert_matrix.m b/scripts/deprecated/java_convert_matrix.m
--- a/scripts/deprecated/java_convert_matrix.m
+++ b/scripts/deprecated/java_convert_matrix.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_convert_matrix ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_convert_matrix (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_convert_matrix (@var{new_val}, "local")
 ## Query or set the internal variable that controls whether Java arrays are
 ## automatically converted to Octave matrices.  The default value is false.
-## 
+##
 ## When called from inside a function with the @qcode{"local"} option, the
 ## variable is changed locally for the function and any subroutines it calls.
 ##  The original variable value is restored when exiting the function.
 ## @seealso{java_matrix_autoconversion, java_unsigned_conversion, java_debug}
 ## @end deftypefn
 
 function old_val = java_convert_matrix (varargin)
 
diff --git a/scripts/deprecated/java_debug.m b/scripts/deprecated/java_debug.m
--- a/scripts/deprecated/java_debug.m
+++ b/scripts/deprecated/java_debug.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_debug ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_debug (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_debug (@var{new_val}, "local")
 ## Query or set the internal variable that determines whether extra debugging
 ## information regarding the initialization of the JVM and any Java exceptions
 ## is printed.
-## 
+##
 ## When called from inside a function with the @qcode{"local"} option, the
 ## variable is changed locally for the function and any subroutines it calls.
 ##  The original variable value is restored when exiting the function.
 ## @seealso{debug_java, java_convert_matrix, java_unsigned_conversion}
 ## @end deftypefn
 
 function old_val = java_debug (varargin)
 
diff --git a/scripts/deprecated/java_invoke.m b/scripts/deprecated/java_invoke.m
--- a/scripts/deprecated/java_invoke.m
+++ b/scripts/deprecated/java_invoke.m
@@ -16,42 +16,42 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{ret} =} java_invoke (@var{obj}, @var{methodname})
 ## @deftypefnx {Built-in Function} {@var{ret} =} java_invoke (@var{obj}, @var{methodname}, @var{arg1}, @dots{})
 ## Invoke the method @var{methodname} on the Java object @var{obj} with the
 ## arguments @var{arg1}, @dots{}  For static methods, @var{obj} can be a
-## string representing the fully qualified name of the corresponding class. 
+## string representing the fully qualified name of the corresponding class.
 ## The function returns the result of the method invocation.
-## 
+##
 ## When @var{obj} is a regular Java object, structure-like indexing can be
 ## used as a shortcut syntax.  For instance, the two following statements are
 ## equivalent
-## 
+##
 ## @example
 ## @group
 ##   ret = java_invoke (x, "method1", 1.0, "a string")
 ##   ret = x.method1 (1.0, "a string")
 ## @end group
 ## @end example
-## 
+##
 ## @seealso{javaMethod, javaObject}
 ## @end deftypefn
 
 function retval = java_invoke (obj, methodname, varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "java_invoke is obsolete and will be removed from a future version of Octave, please use javaMethod instead");
   endif
-  
+
   if (nargin < 2)
     print_usage ();
   endif
 
   retval = javaMethod (methodname, obj, varargin{:});
 
 endfunction
 
diff --git a/scripts/deprecated/java_new.m b/scripts/deprecated/java_new.m
--- a/scripts/deprecated/java_new.m
+++ b/scripts/deprecated/java_new.m
@@ -16,24 +16,24 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Loadable Function} {@var{obj} =} java_new (@var{name})
 ## @deftypefnx {Loadable Function} {@var{obj} =} java_new (@var{name}, @var{arg1}, @dots{})
 ## Create a Java object of class @var{name}, by calling the class constructor
 ## with the arguments @var{arg1}, @dots{}
-## 
+##
 ## @example
 ## @group
 ##   x = java_new ("java.lang.StringBuffer")
 ##   x = java_new ("java.lang.StringBuffer", "Initial string")
 ## @end group
 ## @end example
-## 
+##
 ## @seealso{javaObject, javaMethod}
 ## @end deftypefn
 
 function retval = java_new (varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
diff --git a/scripts/deprecated/java_unsigned_conversion.m b/scripts/deprecated/java_unsigned_conversion.m
--- a/scripts/deprecated/java_unsigned_conversion.m
+++ b/scripts/deprecated/java_unsigned_conversion.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_conversion ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_conversion (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_unsigned_conversion (@var{new_val}, "local")
 ## Query or set the internal variable that controls how integer classes are
 ## converted when Java matrix autoconversion is enabled.  When enabled, Java
 ## arrays of class Byte or Integer are converted to matrices of class uint8 or
 ## uint32 respectively.
-## 
+##
 ## When called from inside a function with the @qcode{"local"} option, the
 ## variable is changed locally for the function and any subroutines it calls.
 ##  The original variable value is restored when exiting the function.
 ## @seealso{java_unsigned_autoconversion, java_convert_matrix, debug_java}
 ## @end deftypefn
 
 function old_val = java_unsigned_conversion (varargin)
 
diff --git a/scripts/deprecated/javafields.m b/scripts/deprecated/javafields.m
--- a/scripts/deprecated/javafields.m
+++ b/scripts/deprecated/javafields.m
@@ -15,35 +15,35 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} javafields (@var{javaobj})
 ## @deftypefnx {Function File} {} javafields ("@var{classname}")
 ## @deftypefnx {Function File} {@var{fld_names} =} javafields (@dots{})
-## Return the fields of a Java object or Java class in the form of a cell 
+## Return the fields of a Java object or Java class in the form of a cell
 ## array of strings.  If no output is requested, print the result
 ## to the standard output.
 ## @seealso{fieldnames, methods, javaObject}
 ## @end deftypefn
 
 function fld_names = javafields (javaobj)
 
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "javafields is obsolete and will be removed from a future version of Octave, please use fieldnames instead");
   endif
-  
+
   if (nargin != 1)
     print_usage ();
   endif
-  
+
   c_methods = javaMethod ("getFields", "org.octave.ClassHelper", javaobj);
   method_list = ostrsplit (c_methods, ';');
 
   if (nargout == 0)
     if (! isempty (method_list))
       disp (method_list);
     endif
   else
diff --git a/scripts/deprecated/javamethods.m b/scripts/deprecated/javamethods.m
--- a/scripts/deprecated/javamethods.m
+++ b/scripts/deprecated/javamethods.m
@@ -15,31 +15,31 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} javamethods (@var{javaobj})
 ## @deftypefnx {Function File} {} javamethods ("@var{classname}")
 ## @deftypefnx {Function File} {@var{mtd_names} =} javamethods (@dots{})
-## Return the methods of a Java object or Java class in the form of a cell 
+## Return the methods of a Java object or Java class in the form of a cell
 ## array of strings.  If no output is requested, print the result to the
 ## standard output.
 ## @seealso{methods, fieldnames, javaMethod, javaObject}
 ## @end deftypefn
 
 function mtd_names = javamethods (classname)
 
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "javamethods is obsolete and will be removed from a future version of Octave, please use methods instead");
   endif
-  
+
   if (nargin != 1)
     print_usage ();
   endif
 
   cls_methods = javaMethod ("getMethods", "org.octave.ClassHelper", classname);
   method_list = ostrsplit (cls_methods, ';');
 
   if (nargout == 0)
diff --git a/scripts/deprecated/playaudio.m b/scripts/deprecated/playaudio.m
--- a/scripts/deprecated/playaudio.m
+++ b/scripts/deprecated/playaudio.m
@@ -85,15 +85,15 @@ function playaudio (name, ext)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error playaudio ()
 %!error playaudio (1,2,3)
 %!error <X must be a vector> playaudio (magic (3))
 %!error <unsupported extension> playaudio ("file", "abc")
 %!error playaudio ({"abc"})
 
diff --git a/scripts/deprecated/strmatch.m b/scripts/deprecated/strmatch.m
--- a/scripts/deprecated/strmatch.m
+++ b/scripts/deprecated/strmatch.m
@@ -114,17 +114,17 @@ endfunction
 %!assert (strmatch ("apple", {"apple pie"; "apple juice"; "tomato"}), [1; 2])
 %!assert (strmatch ("apple pie", "apple"), [])
 %!assert (strmatch ("a ", "a"), 1)
 %!assert (strmatch ("a", "a \0", "exact"), 1)
 %!assert (strmatch ("a b", {"a b", "a c", "c d"}), 1)
 %!assert (strmatch ("", {"", "foo", "bar", ""}), [1, 4])
 %!assert (strmatch ('', { '', '% comment', 'var a = 5', ''}, 'exact'), [1,4])
 
-%% Test input validation
+## Test input validation
 %!error <Invalid call to strmatch> strmatch ()
 %!error <Invalid call to strmatch> strmatch ("a")
 %!error <Invalid call to strmatch> strmatch ("a", "aaa", "exact", 1)
 %!error <S must be a string> strmatch (1, "aaa")
 %!error <S must be a string> strmatch (char ("a", "bb"), "aaa")
 %!error <A must be a string> strmatch ("a", 1)
 %!error <A must be a string> strmatch ("a", {"hello", [1]})
 
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -144,30 +144,30 @@ function A = accumdim (subs, vals, dim, 
 
   ## Set the reduced values.
   subsc{dim} = subs;
   A(subsc{:}) = vals;
 
 endfunction
 
 
-%% Test accumdim vs. accumarray
+## Test accumdim vs. accumarray
 %!shared a
 %! a = rand (5, 5, 5);
 
 %!assert (accumdim ([1;3;1;3;3], a)(:,2,3), accumarray ([1;3;1;3;3], a(:,2,3)))
 %!assert (accumdim ([2;3;2;2;2], a, 2, 4)(4,:,2), accumarray ([2;3;2;2;2], a(4,:,2), [1,4]))
 %!assert (accumdim ([2;3;2;1;2], a, 3, 3, @min)(1,5,:), accumarray ([2;3;2;1;2], a(1,5,:), [1,1,3], @min))
 %!assert (accumdim ([1;3;2;2;1], a, 2, 3, @median)(4,:,5), accumarray ([1;3;2;2;1], a(4,:,5), [1,3], @median))
 
-%% Test fillval
+## Test fillval
 %!assert (accumdim ([1;3;1;3;3], a)(2,:,:), zeros (1,5,5))
 %!assert (accumdim ([1;3;1;3;3], a, 1, 4)([2 4],:,:), zeros (2,5,5))
 %!assert (accumdim ([1;3;1;3;3], a, 1, 4, [], pi)([2 4],:,:), pi (2,5,5))
 
-%% Test input validation
+## Test input validation
 %!error accumdim (1)
 %!error accumdim (1,2,3,4,5,6,7)
 %!error <SUBS must be a subscript vector> accumdim (ones (2,2), ones (2,2))
 %!error <indices must be positive integers> accumdim ([-1 1], ones (2,2))
 %!error <N index out of range> accumdim ([1 2], ones (2,2), 1, 1)
 %!error <dimension mismatch> accumdim ([1], ones (2,2))
 
diff --git a/scripts/general/bincoeff.m b/scripts/general/bincoeff.m
--- a/scripts/general/bincoeff.m
+++ b/scripts/general/bincoeff.m
@@ -107,14 +107,14 @@ endfunction
 %!assert (bincoeff (2, 4), 0)
 %!assert (bincoeff (-4, 2), 10)
 %!assert (bincoeff (5, 2), 10)
 %!assert (bincoeff (50, 6), 15890700)
 %!assert (bincoeff (0.4, 2), -.12, 8*eps)
 
 %!assert (bincoeff ([4 NaN 4], [-1, 2, 2.5]), NaN (1, 3))
 
-%% Test input validation
+## Test input validation
 %!error bincoeff ()
 %!error bincoeff (1, 2, 3)
 %!error bincoeff (ones (3),ones (2))
 %!error bincoeff (ones (2),ones (3))
 
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -71,13 +71,13 @@ endfunction
 %!assert (blkdiag ([1,2;3,4],[5,6,7]), [1,2,0,0,0;3,4,0,0,0;0,0,5,6,7])
 ## tests involving empty matrices
 %!assert (blkdiag ([],[],[]), [])
 %!assert (blkdiag ([],[1,2;3,4],[],5,[]), [1,2,0;3,4,0;0,0,5])
 %!assert (blkdiag (zeros (1,0,1),[1,2,3],1,0,5,zeros (0,1,1)), [0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0]);
 ## tests involving sparse matrices
 %!assert (blkdiag (sparse ([1,2;3,4]),[5,6;7,8]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6;0,0,7,8]))
 %!assert (blkdiag (sparse ([1,2;3,4]),[5,6]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6]))
-# sanity checks
+## sanity checks
 %!test
 %! A = rand (round (rand (1, 2) * 10));
 %! assert (blkdiag (A), A);
 
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -37,17 +37,17 @@
 ##     1, 2, 3
 ##     4, 5, 6
 ## circshift (x, [0,1])
 ## @result{}  3, 1, 2
 ##     6, 4, 5
 ##     9, 7, 8
 ## @end group
 ## @end example
-## @seealso {permute, ipermute, shiftdim}
+## @seealso{permute, ipermute, shiftdim}
 ## @end deftypefn
 
 function y = circshift (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
@@ -89,16 +89,16 @@ endfunction
 %!assert (circshift (x, 1), [7, 8, 9; 1, 2, 3; 4, 5, 6])
 %!assert (circshift (x, -2), [7, 8, 9; 1, 2, 3; 4, 5, 6])
 %!assert (circshift (x, [0, 1]), [3, 1, 2; 6, 4, 5; 9, 7, 8])
 %!assert (circshift ([], 1), [])
 
 %!assert (circshift (eye (3), 1), circshift (eye (3), 1))
 %!assert (circshift (eye (3), 1), [0,0,1;1,0,0;0,1,0])
 
-%% Test input validation
+## Test input validation
 %!error circshift ()
 %!error circshift (1)
 %!error circshift (1,2,3)
 %!error circshift (1, ones (2,2))
 %!error circshift (1, [1 2 3])
 %!error circshift (1, 1.5)
 
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -62,17 +62,17 @@ function [errorcode, varargout] = common
   else
     match = cellfun ("size_equal", varargin, varargin(i));
     if (any (nscal &! match))
       errorcode = 1;
       varargout = varargin;
     else
       errorcode = 0;
       if (nargout > 1)
-        scal = !nscal;
+        scal = ! nscal;
         varargout = varargin;
         if (any (nscal))
           dims = size (varargin{find (nscal, 1)});
           subs = arrayfun (@ones, 1, dims, "uniformoutput", false);
           varargout(scal) = cellindexmat (varargin(scal), subs{:});
         endif
       endif
     endif
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -87,17 +87,17 @@ function y = cplxpair (z, tol, dim)
       error ("cplxpair: invalid dimension along which to sort");
     endif
   endif
 
   ## Move dimension to treat first, and convert to a 2-D matrix.
   perm = [dim:nd, 1:dim-1];
   z = permute (z, perm);
   sz = size (z);
-  n = sz (1);
+  n = sz(1);
   m = prod (sz) / n;
   z = reshape (z, n, m);
 
   ## Sort the sequence in terms of increasing real values.
   [q, idx] = sort (real (z), 1);
   z = z(idx + n * ones (n, 1) * [0:m-1]);
 
   ## Put the purely real values at the end of the returned list.
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -85,17 +85,17 @@ function z = cumtrapz (x, y, dim)
   n = sz(dim);
   idx1 = idx2 = repmat ({':'}, [nd, 1]);
   idx1{dim} = 2 : n;
   idx2{dim} = 1 : (n - 1);
 
   if (! have_xy)
     z = 0.5 * cumsum (x(idx1{:}) + x(idx2{:}), dim);
   else
-    if (isvector (x) && !isvector (y))
+    if (isvector (x) && ! isvector (y))
       if (length (x) != sz(dim))
         error ("cumtrapz: length of X and length of Y along DIM must match");
       endif
       ## Reshape vector to point along dimension DIM
       shape = ones (nd, 1);
       shape(dim) = sz(dim);
       x = reshape (x, shape);
       z = 0.5 * cumsum (bsxfun (@times, diff (x), y(idx1{:}) + y(idx2{:})), dim);
@@ -112,23 +112,26 @@ function z = cumtrapz (x, y, dim)
 
 endfunction
 
 
 %!shared x1,x2,y
 %! x1 = [0,0,0;2,2,2];
 %! x2 = [0,2,4;0,2,4];
 %! y = [1,2,3;4,5,6];
+%!
 %!assert (cumtrapz (y), [0,0,0;2.5,3.5,4.5])
 %!assert (cumtrapz (x1,y), [0,0,0;5,7,9])
 %!assert (cumtrapz (y,1), [0,0,0;2.5,3.5,4.5])
 %!assert (cumtrapz (x1,y,1), [0,0,0;5,7,9])
 %!assert (cumtrapz (y,2), [0,1.5,4;0,4.5,10])
 %!assert (cumtrapz (x2,y,2), [0,3,8;0,9,20])
-%% Test ND-array implementation
+
+## Test ND-array implementation
 %!shared x1,x2,y
 %! x1 = 1:3;
 %! x2 = reshape ([0,2,4;0,2,4], [1 2 3]);
 %! y = reshape ([1,2,3;4,5,6], [1 2 3]);
+%!
 %!assert (cumtrapz (y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
 %!assert (cumtrapz (x1,y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
 %!assert (cumtrapz (x2,y,3), reshape ([0,3,8;0,9,20],[1 2 3]))
 
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -69,18 +69,18 @@ function varargout = curl (varargin)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
     print_usage ();
   endif
 
-  if ((nargin == 4) || (nargin == 2))
-    if (!size_equal (varargin{fidx}, varargin{fidx + 1}))
+  if (nargin == 4 || nargin == 2)
+    if (! size_equal (varargin{fidx}, varargin{fidx + 1}))
       error ("curl: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
       error ("curl: expected two-dimensional matrices X and Y");
     elseif ((length (dx) != columns (varargin{fidx}))
          || (length (dy) != rows (varargin{fidx})))
       error ("curl: size of dx and dy must match the respective dimension of X and Y");
     endif
 
@@ -90,18 +90,18 @@ function varargout = curl (varargin)
     av = rot_z / 2;
     if (nargout == 0 || nargout == 1)
       varargout{1} = av;
     else
       varargout{1} = rot_z;
       varargout{2} = av;
     endif
 
-  elseif ((nargin == 6) || (nargin == 3))
-    if (!size_equal (varargin{fidx}, varargin{fidx + 1}, varargin{fidx + 2}))
+  elseif (nargin == 6 || nargin == 3)
+    if (! size_equal (varargin{fidx}, varargin{fidx + 1}, varargin{fidx + 2}))
       error ("curl: size of X, Y, and Z must match");
     elseif (ndims (varargin{fidx}) != 3)
       error ("curl: expected two-dimensional matrices X, Y, and Z");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
       error ("curl: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
     endif
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -70,15 +70,15 @@ endfunction
 function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
   q = zeros (size (y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
 
-%% Nasty integrand to show quadcc off
+## Nasty integrand to show quadcc off
 %!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log (2), 1e-6)
 
 %!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadgk), pi * erf (1).^2, 1e-6)
 %!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadl), pi * erf (1).^2, 1e-6)
 %!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadv), pi * erf (1).^2, 1e-6)
 
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -135,25 +135,25 @@ function D = del2 (M, varargin)
 
       ## left and right boundary
       if (sz(i) == 3)
         DD(idx1{:}) = DD(idx3{:}) = DD(idx2{:});
       else
         idx1{i} = 1;
         idx2{i} = 2;
         idx3{i} = 3;
-        DD(idx1{:}) = (dx{i}(1) + dx{i}(2)) / dx{i}(2) * DD (idx2{:}) - ...
-            dx{i}(1) / dx{i}(2) * DD (idx3{:});
+        DD(idx1{:}) = (dx{i}(1) + dx{i}(2)) / dx{i}(2) * DD(idx2{:}) - ...
+            dx{i}(1) / dx{i}(2) * DD(idx3{:});
 
         idx1{i} = sz(i);
         idx2{i} = sz(i) - 1;
         idx3{i} = sz(i) - 2;
-        DD(idx1{:}) =  (dx{i}(sz(i) - 1) + dx{i}(sz(i) - 2)) / ...
-            dx{i}(sz(i) - 2) * DD (idx2{:}) - ...
-            dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD (idx3{:});
+        DD(idx1{:}) = (dx{i}(sz(i) - 1) + dx{i}(sz(i) - 2)) / ...
+            dx{i}(sz(i) - 2) * DD(idx2{:}) - ...
+            dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD(idx3{:});
       endif
 
       D += DD;
     endif
   endfor
 
   D = D ./ nd;
 endfunction
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -67,30 +67,31 @@ function retval = divergence (varargin)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
     print_usage ();
   endif
 
-  if ((nargin == 4) || (nargin == 2))
-    if (!size_equal (varargin{fidx},varargin{fidx + 1}))
+  if (nargin == 4 || nargin == 2)
+    if (! size_equal (varargin{fidx},varargin{fidx + 1}))
       error ("divergence: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
       error ("divergence: expected two-dimensional matrices X and Y");
-    elseif ((length (dx) != columns (varargin{fidx})) || (length (dy) != rows (varargin{fidx})))
+    elseif (length (dx) != columns (varargin{fidx})
+            || length (dy) != rows (varargin{fidx}))
       error ("divergence: size of dx and dy must match the respective dimension of X and Y");
     endif
 
     retval = gradient (varargin{fidx}, dx, dy);
     retval += gradient (varargin{fidx + 1}.', dy, dx).';
 
-  elseif ((nargin == 6) || (nargin == 3))
-    if (!size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
+  elseif (nargin == 6 || nargin == 3)
+    if (! size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
       error ("divergence: size of X, Y, and Z must match");
     elseif (ndims (varargin{fidx}) != 3)
       error ("divergence: expected two-dimensional matrices X, Y, and Z");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
       error ("divergence: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
     endif
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -71,17 +71,18 @@ function varargout = gradient (m, vararg
   endif
 
   nargout_with_ans = max (1,nargout);
   if (isnumeric (m))
     [varargout{1:nargout_with_ans}] = matrix_gradient (m, varargin{:});
   elseif (isa (m, "function_handle"))
     [varargout{1:nargout_with_ans}] = handle_gradient (m, varargin{:});
   elseif (ischar (m))
-    [varargout{1:nargout_with_ans}] = handle_gradient (str2func (m), varargin{:});
+    [varargout{1:nargout_with_ans}] = handle_gradient (str2func (m), ...
+                                                       varargin{:});
   else
     error ("gradient: first input must be an array or a function");
   endif
 
 endfunction
 
 function varargout = matrix_gradient (m, varargin)
   transposed = false;
@@ -174,17 +175,17 @@ function varargout = handle_gradient (f,
   ## Input checking
   p0_size = size (p0);
 
   if (numel (p0_size) != 2)
     error ("gradient: the second input argument should either be a vector or a matrix");
   endif
 
   if (any (p0_size == 1))
-    p0 = p0 (:);
+    p0 = p0(:);
     dim = 1;
     num_points = numel (p0);
   else
     num_points = p0_size (1);
     dim = p0_size (2);
   endif
 
   if (length (varargin) == 0)
@@ -196,25 +197,25 @@ function varargout = handle_gradient (f,
       error ("gradient: spacing parameters must be scalars or a vector");
     end_try_catch
   else
     error ("gradient: incorrect number of spacing parameters");
   endif
 
   if (isscalar (delta))
     delta = repmat (delta, 1, dim);
-  elseif (!isvector (delta))
+  elseif (! isvector (delta))
     error ("gradient: spacing values must be scalars or a vector");
   endif
 
   ## Calculate the gradient
   p0 = mat2cell (p0, num_points, ones (1, dim));
   varargout = cell (1, dim);
   for d = 1:dim
-    s = delta (d);
+    s = delta(d);
     df_dx = (f (p0{1:d-1}, p0{d}+s, p0{d+1:end})
            - f (p0{1:d-1}, p0{d}-s, p0{d+1:end})) ./ (2*s);
     if (dim == 1)
       varargout{d} = reshape (df_dx, p0_size);
     else
       varargout{d} = df_dx;
     endif
   endfor
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -78,17 +78,17 @@ function z = idivide (x, y, op)
     z = x ./ y;
   else
     if (isfloat (x))
       typ = class (y);
     elseif (isfloat (y))
       typ = class (x);
     else
       typ = class (x);
-      if (!strcmp (class (x), class (y)))
+      if (! strcmp (class (x), class (y)))
         error ("idivide: incompatible types");
       endif
     endif
 
     if (strcmp (op, "fix"))
       z = cast (fix (double (x) ./ double (y)), typ);
     elseif (strcmp (op, "floor"))
       z = cast (floor (double (x) ./ double (y)), typ);
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -1,13 +1,13 @@
 ## Copyright (C) 2011-2014 Carnë Draug
 ##
 ## This file is part of Octave.
 ##
-# Octave is free software; you can redistribute it and/or modify it
+## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 ## General Public License for more details.
@@ -106,17 +106,17 @@
 ##
 ##   ## the rest of the function can access inputs by using p.Results.
 ##   ## for example, get the tolerance input with p.Results.tolerance
 ## endfunction
 ## @end group
 ##
 ## check ("mech");           # valid, use defaults for other arguments
 ## check ();                 # error, one argument is mandatory
-## check (1);                # error, since !ischar
+## check (1);                # error, since ! ischar
 ## check ("mech", "~/dev");  # valid, use defaults for other arguments
 ##
 ## check ("mech", "~/dev", [0 1 0 0], "type", "linear");  # valid
 ##
 ## ## following is also valid.  Note how the Switch argument type can
 ## ## be mixed into or before the ParamValue argument type (but it
 ## ## must still appear after any Optional argument).
 ## check ("mech", "~/dev", [0 1 0 0], "verbose", "tolerance", "high");
@@ -237,48 +237,48 @@
 ##
 ## @end deftypefn
 
 ## Author: Carnë Draug <carandraug@octave.org>
 
 classdef inputParser < handle
   properties
     ## TODO set input checking for this properties
-    CaseSensitive   = false;
-    FunctionName    = "";
-    KeepUnmatched   = false;
-#    PartialMatching = true;   # TODO unimplemented
-#    StructExpand    = true;   # TODO unimplemented
+    CaseSensitive     = false;
+    FunctionName      = "";
+    KeepUnmatched     = false;
+    # PartialMatching = true;   # TODO unimplemented
+    # StructExpand    = true;   # TODO unimplemented
   endproperties
 
   properties (SetAccess = protected)
-    Parameters      = cell ();
-    Results         = struct ();
-    Unmatched       = struct ();
-    UsingDefaults   = cell ();
+    Parameters    = cell ();
+    Results       = struct ();
+    Unmatched     = struct ();
+    UsingDefaults = cell ();
   endproperties
 
   properties (Access = protected)
     ## Since Required and Optional are ordered, they get a cell array of
     ## structs with the fields "name", "def" (default), and "val" (validator).
-    Required    = cell ();
-    Optional    = cell ();
+    Required   = cell ();
+    Optional   = cell ();
     ## ParamValue and Swicth are unordered so we have a struct whose fieldnames
     ## are the argname, and values are a struct with fields "def" and "val"
-    ParamValue  = struct ();
-    Switch      = struct ();
+    ParamValue = struct ();
+    Switch     = struct ();
 
     ## List of ParamValues and Switch names to ease searches
     ParamValueNames = cell ();
     SwitchNames     = cell ();
 
     ## When checking for fieldnames in a Case Insensitive way, this variable
     ## holds the correct identifier for the last searched named using the
     ## is_argname method.
-    last_name = "";
+    last_name  = "";
   endproperties
 
   properties (Access = protected, Constant = true)
     ## Default validator, always returns scalar true.
     def_val = @() true;
   endproperties
 
   methods
@@ -380,17 +380,18 @@ classdef inputParser < handle
       ## Search unordered Options (Switch and ParamValue)
       while (vidx++ < pnargin)
         name = varargin{vidx};
         if (this.is_argname ("ParamValue", name))
           if (vidx++ > pnargin)
             this.error (sprintf ("no matching value for option '%s'",
                                  toupper (name)));
           endif
-          this.validate_arg (this.last_name, this.ParamValue.(this.last_name).val,
+          this.validate_arg (this.last_name,
+                             this.ParamValue.(this.last_name).val,
                              varargin{vidx});
         elseif (this.is_argname ("Switch", name))
           this.Results.(this.last_name) = true;
         else
           if (vidx++ < pnargin && this.KeepUnmatched)
             this.Unmatched.(name) = varargin{vidx};
           else
             this.error (sprintf ("argument '%s' is not a valid parameter",
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -555,53 +555,53 @@ endfunction
 %!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
 %!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
-# %!assert (interp1 (xp,yp,xi,style),...
-# %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+#%!assert (interp1 (xp,yp,xi,style),...
+#%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
 %!test style = "next";
 ## BLOCK
 %!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
 %!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
 %!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
-# %!assert (interp1 (xp,yp,xi,style),...
-# %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+#%!assert (interp1 (xp,yp,xi,style),...
+#%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 %!assert (interp1 (xp,[yp',yp'],xi,style),
 %!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
 %!test style = ["*",style];
 %!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
 %!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
 %!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
-# %!assert (interp1 (xp,yp,xi,style),...
-# %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+#%!assert (interp1 (xp,yp,xi,style),...
+#%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
 %!test style = "linear";
 ## BLOCK
 %!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
@@ -775,17 +775,17 @@ endfunction
 
 %!assert (interp1 ([4,4,3,2,0],[0,1,4,2,1],[1.5,4,4.5], "linear"), [1.75,1,NA])
 %!assert (interp1 (0:4, 2.5), 1.5)
 
 ## Left and Right discontinuities
 %!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap", "right"), [-2,0.5,4,3,1.5])
 %!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap", "left"), [-2,0.5,1,3,1.5])
 
-%% Test input validation
+## Test input validation
 %!error interp1 ()
 %!error interp1 (1,2,3,4,5,6,7)
 %!error <minimum of 2 points required> interp1 (1,1,1, "linear")
 %!error <minimum of 2 points required> interp1 (1,1,1, "*nearest")
 %!error <minimum of 2 points required> interp1 (1,1,1, "*linear")
 %!error <minimum of 2 points required> interp1 (1,1,1, "previous")
 %!error <minimum of 2 points required> interp1 (1,1,1, "*previous")
 %!warning <multiple discontinuities> interp1 ([1 1 1 2], [1 2 3 4], 1);
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -309,21 +309,21 @@ function ZI = interp2 (varargin)
         error ("interp2: XI, YI must have uniform spacing ('meshgrid' format)");
       endif
     endif
 
     return; # spline doesn't need NA extrapolation value (MATLAB compatibility)
 
   endif
 
-  ## extrapolation 'extrap' 
+  ## extrapolation 'extrap'
   if (isempty (extrap))
     extrap = NA;
   endif
-  
+
   if (X(1) < X(end))
     if (Y(1) < Y(end))
       ZI(XI < X(1,1) | XI > X(end) | YI < Y(1,1) | YI > Y(end)) = extrap;
     else
       ZI(XI < X(1) | XI > X(end) | YI < Y(end) | YI > Y(1)) = extrap;
     endif
   else
     if (Y(1) < Y(end))
@@ -557,17 +557,17 @@ endfunction
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "pchip"), repmat ([5, 7, 3], [3, 1]), tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "cubic"), repmat ([5, 7, 3], [3, 1]), 10 * tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "spline"), repmat ([5, 7, 3], [3, 1]), tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "linear"), [5 7 3], tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "pchip"), [5 7 3], tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "cubic"), [5 7 3], 10 * tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2], "spline"), [5 7 3], tol)
 
-%% Test input validation
+## Test input validation
 %!error interp2 (1, 1, 1, 1, 1, 2)    #only 5 numeric inputs
 %!error interp2 (1, 1, 1, 1, 1, 2, 2) #only 5 numeric inputs
 %!error <Z must be a 2-D matrix> interp2 ({1})
 %!error <Z must be a 2-D matrix> interp2 (1,1,1)
 %!error <Z must be a 2-D matrix> interp2 (ones (2,2,2))
 %!error <N must be an integer .= 0> interp2 (ones (2), ones (2))
 %!error <N must be an integer .= 0> interp2 (ones (2), -1)
 %!error <N must be an integer .= 0> interp2 (ones (2), 1.5)
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -187,17 +187,17 @@ function vi = interp3 (varargin)
 
   else
     error ("interp3: wrong number or incorrectly formatted input arguments");
   endif
 
 endfunction
 
 
-%% FIXME: Need some demo blocks here to show off the function like interp2.m.
+## FIXME: Need some demo blocks here to show off the function like interp2.m.
 
 %!test  # basic test
 %! x = y = z = -1:1;  y = y + 2;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
 %! xi = yi = zi = -1:0.5:1;  yi = yi + 2.1;
 %! [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
@@ -250,17 +250,17 @@ endfunction
 
 %!test # extrapolation
 %! X=[0,0.5,1]; Y=X; Z=X;
 %! V = zeros (3,3,3);
 %! V(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
 %! V(:,:,2) = V(:,:,1) + 2;
 %! V(:,:,3) = V(:,:,2) + 2;
 %! tol = 10 * eps;
-%! x=[-0.1,0,0.1]; y=x; z=x; 
+%! x=[-0.1,0,0.1]; y=x; z=x;
 %! assert(interp3(X,Y,Z,V,x,y,z,"spline"), [-0.2, 1.0, 2.2]',tol);
 %! assert(interp3(X,Y,Z,V,x,y,z,"linear"), [NA, 1.0, 2.2]',tol);
 %! assert(interp3(X,Y,Z,V,x,y,z,"spline", 0), [0, 1.0, 2.2]',tol);
 %! assert(interp3(X,Y,Z,V,x,y,z,"linear", 0), [0, 1.0, 2.2]',tol);
 
 %!shared z, zout, tol
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
@@ -275,17 +275,17 @@ endfunction
 %!                  5 6 7 8 9] + (n-1);
 %! end
 %! tol = 10 * eps;
 %!
 %!assert (interp3 (z), zout, tol)
 %!assert (interp3 (z, "linear"), zout, tol)
 %!assert (interp3 (z, "spline"), zout, tol)
 
-%% Test input validation
+## Test input validation
 %!error interp3 ()
 %!error interp3 ({1})
 %!error <EXTRAPVAL must be a numeric scalar> interp3 (1,2,3,4,1,2,3,"linear", {1})
 %!error <EXTRAPVAL must be a numeric scalar> interp3 (1,2,3,4,1,2,3,"linear", ones (2,2))
 %!warning <ignoring unsupported '\*' flag> interp3 (rand (3,3,3), 1, "*linear");
 %!error <V must be a 3-D array> interp3 (rand (2,2))
 %!error <V must be a 3-D array> interp3 (rand (2,2), 1,1,1)
 %!error <XI, YI, and ZI dimensions must be equal> interp3 (rand (2,2,2), 1,1, ones (2,2))
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -115,29 +115,29 @@ endfunction
 %! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
 %! x = [0:10]';  y = sin(x);  n = length (x);
 %!assert (interpft (y, n), y, 20*eps);
 %!assert (interpft (y', n), y', 20*eps);
 %!assert (interpft ([y,y],n), [y,y], 20*eps);
 
-%% Test case with complex input from bug #39566
+## Test case with complex input from bug #39566
 %!test
 %! x = (1 + j) * [1:4]';
 %! y = ifft ([15 + 15*j; -6; -1.5 - 1.5*j; 0; -1.5 - 1.5*j; -6*j]);
 %! assert (interpft (x, 6), y, 10*eps);
 
-%% Test for correct spectral symmetry with even/odd lengths
+## Test for correct spectral symmetry with even/odd lengths
 %!assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps);
 %!assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps);
 %!assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps);
 %!assert (max (abs (imag (interpft ([1:9], 21)))), 0, 21*eps);
 
-%% Test input validation
+## Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
 %!error <N must be a scalar integer> interpft (1,[2,2])
 %!error <N must be a scalar integer> interpft (1,2.1)
 %!error <invalid dimension DIM> interpft (1,2,0)
 %!error <invalid dimension DIM> interpft (1,2,3)
 
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -176,17 +176,18 @@ function vi = interpn (varargin)
     yshape = size (y{1});
     yidx = cell (1, nd);
     for i = 1 : nd
       y{i} = y{i}(:);
       yidx{i} = lookup (x{i}, y{i}, "lr");
     endfor
     idx = cell (1,nd);
     for i = 1 : nd
-      idx{i} = yidx{i} + (y{i} - x{i}(yidx{i})(:) >= x{i}(yidx{i} + 1)(:) - y{i});
+      idx{i} = yidx{i} ...
+               + (y{i} - x{i}(yidx{i})(:) >= x{i}(yidx{i} + 1)(:) - y{i});
     endfor
     vi = v(sub2ind (sz, idx{:}));
     idx = zeros (prod (yshape), 1);
     for i = 1 : nd
       idx |= y{i} < min (x{i}(:)) | y{i} > max (x{i}(:));
     endfor
     if (isempty (extrapval))
       extrapval = NA;
@@ -333,11 +334,11 @@ endfunction
 %!                  4 5 6 7 8;
 %!                  5 6 7 8 9] + (n-1);
 %! endfor
 %! tol = 10*eps;
 %! assert (interpn (z), zout, tol);
 %! assert (interpn (z, "linear"), zout, tol);
 %! assert (interpn (z, "spline"), zout, tol);
 
-%% Test input validation
+## Test input validation
 %!warning <ignoring unsupported '\*' flag> interpn (rand (3,3), 1, "*linear");
 
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -85,15 +85,15 @@ endfunction
 %! x2 = logspace (1, 2, 10.1);
 %! x3 = logspace (1, -2, 10);
 %! x4 = logspace (1, pi, 10);
 %! assert (size (x1) == [1, 50] && abs (x1(1) - 10) < eps && abs (x1(50) - 100) < eps);
 %! assert (size (x2) == [1, 10] && abs (x2(1) - 10) < eps && abs (x2(10) - 100) < eps);
 %! assert (size (x3) == [1, 10] && abs (x3(1) - 10) < eps && abs (x3(10) - 0.01) < eps);
 %! assert (size (x4) == [1, 10] && abs (x4(1) - 10) < eps && abs (x4(10) - pi) < sqrt (eps));
 
-%% Test input validation
+## Test input validation
 %!error logspace ()
 %!error logspace (1, 2, 3, 4)
 %!error logspace ([1, 2; 3, 4], 5, 6)
 %!error logspace (1, [1, 2; 3, 4], 6)
 %!error logspace (1, 2, [1, 2; 3, 4])
 
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -32,19 +32,19 @@
 ## @end deftypefn
 
 ## Author: Carnë Draug <carandraug+dev@gmail.com>
 
 function narginchk (minargs, maxargs)
 
   if (nargin != 2)
     print_usage;
-  elseif (!isnumeric (minargs) || !isscalar (minargs))
+  elseif (! isnumeric (minargs) || ! isscalar (minargs))
     error ("minargs must be a numeric scalar");
-  elseif (!isnumeric (maxargs) || !isscalar (maxargs))
+  elseif (! isnumeric (maxargs) || ! isscalar (maxargs))
     error ("maxargs must be a numeric scalar");
   elseif (minargs > maxargs)
     error ("minargs cannot be larger than maxargs");
   endif
 
   args = evalin ("caller", "nargin;");
 
   if (args < minargs)
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -45,17 +45,18 @@
 ## Author: Carnë Draug <carandraug+dev@gmail.com>
 
 function msg = nargoutchk (minargs, maxargs, nargs, outtype)
 
   ## before matlab's 2011b, nargoutchk would return an error message (just the
   ## message in a string). With 2011b, it no longer returns anything, it simply
   ## gives an error if the args number is incorrect.
   ## To try to keep compatibility with both versions, check nargout and nargin
-  ## to guess if the caller is expecting a value (old syntax) or none (new syntax)
+  ## to guess if the caller is expecting a value (old syntax)
+  ## or none (new syntax).
 
   if (nargout == 1 && (nargin == 3 || nargin == 4))
 
     if (minargs > maxargs)
       error ("nargoutchk: MINARGS must be <= MAXARGS");
     elseif (nargin == 3)
       outtype = "string";
     elseif (! any (strcmpi (outtype, {"string" "struct"})))
@@ -77,19 +78,19 @@ function msg = nargoutchk (minargs, maxa
       msg = msg.message;
     elseif (isempty (msg.message))
       ## Compatibility: Matlab returns a 0x1 empty struct when nargoutchk passes
       msg = resize (msg, 0, 1);
     endif
 
   elseif (nargout == 0 && nargin == 2)
 
-    if (!isnumeric (minargs) || !isscalar (minargs))
+    if (! isnumeric (minargs) || ! isscalar (minargs))
       error ("minargs must be a numeric scalar");
-    elseif (!isnumeric (maxargs) || !isscalar (maxargs))
+    elseif (! isnumeric (maxargs) || ! isscalar (maxargs))
       error ("maxargs must be a numeric scalar");
     elseif (minargs > maxargs)
       error ("minargs cannot be larger than maxargs");
     endif
 
     args = evalin ("caller", "nargout;");
 
     if (args < minargs)
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -86,17 +86,17 @@ function retval = num2str (x, arg)
       elseif (isnumeric (arg) && isscalar (arg) && arg >= 0 && arg == fix (arg))
         fmt = sprintf ("%%%d.%dg", arg+7, arg);
       else
         error ("num2str: PRECISION must be a scalar integer >= 0");
       endif
     else
       if (isnumeric (x))
         ## Setup a suitable format string, ignoring inf entries
-        dgt = floor (log10 (max (abs (x(!isinf (x(:)))))));
+        dgt = floor (log10 (max (abs (x(! isinf (x(:)))))));
         if (isempty (dgt))
           ## If the whole input array is inf...
           dgt = 1;
         endif
 
         if (any (x(:) != fix (x(:))))
           ## Floating point input
           dgt = max (dgt + 4, 5);   # Keep 4 sig. figures after decimal point
@@ -124,18 +124,18 @@ function retval = num2str (x, arg)
         fmt = [arg "%-+" arg(2:end) "i"];
       elseif (isnumeric (arg) && isscalar (arg) && arg >= 0 && arg == fix (arg))
         fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
       else
         error ("num2str: PRECISION must be a scalar integer >= 0");
       endif
     else
       ## Setup a suitable format string
-      dgt = floor (log10 (max (max (abs (real (x(!isinf (real (x(:))))))),
-                               max (abs (imag (x(!isinf (imag (x(:))))))))));
+      dgt = floor (log10 (max (max (abs (real (x(! isinf (real (x(:))))))),
+                               max (abs (imag (x(! isinf (imag (x(:))))))))));
       if (isempty (dgt))
         ## If the whole input array is inf...
         dgt = 1;
       endif
 
       if (any (x(:) != fix (x(:))))
         ## Floating point input
           dgt = max (dgt + 4, 5);   # Keep 4 sig. figures after decimal point
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -67,24 +67,24 @@ function y = postpad (x, l, c, dim)
   if (! isscalar (l) || l < 0)
     error ("postpad: second argument must be a positive scaler");
   endif
 
   if (dim > nd)
     sz(nd+1:dim) = 1;
   endif
 
-  d = sz (dim);
+  d = sz(dim);
 
   if (d >= l)
     idx = repmat ({':'}, nd, 1);
     idx{dim} = 1:l;
     y = x(idx{:});
   else
-    sz (dim) = l - d;
+    sz(dim) = l - d;
     y = cat (dim, x, c(ones (sz)));
   endif
 
 endfunction
 
 
 %!assert (postpad ([1,2], 4), [1,2,0,0])
 %!assert (postpad ([1;2], 4), [1;2;0;0])
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -67,24 +67,24 @@ function y = prepad (x, l, c, dim)
   if (! isscalar (l) || l < 0)
     error ("prepad: length L must be a positive scalar");
   endif
 
   if (dim > nd)
     sz(nd+1:dim) = 1;
   endif
 
-  d = sz (dim);
+  d = sz(dim);
 
   if (d >= l)
     idx = repmat ({':'}, nd, 1);
     idx{dim} = d-l+1:d;
     y = x(idx{:});
   else
-    sz (dim) = l - d;
+    sz(dim) = l - d;
     y = cat (dim, c(ones (sz)), x);
   endif
 
 endfunction
 
 
 %!assert (prepad ([1,2], 4), [0,0,1,2])
 %!assert (prepad ([1;2], 4), [0;0;1;2])
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -23,27 +23,28 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
   ## ND isvector function.
   isvec = @(x) numel (x) == length (x);
-  if (!iscell (x) || length (x) < ndims (y) || any (! cellfun (isvec, x))
-      || !iscell (xi) || length (xi) < ndims (y) || any (! cellfun (isvec, xi)))
+  if (! iscell (x) || length (x) < ndims (y) || any (! cellfun (isvec, x))
+      || ! iscell (xi) || length (xi) < ndims (y)
+      || any (! cellfun (isvec, xi)))
     error ("__splinen__: %s: non-gridded data or dimensions inconsistent", f);
   endif
   yi = y;
   for i = length (x):-1:1
     yi = permute (spline (x{i}, yi, xi{i}(:)), [length(x),1:length(x)-1]);
   endfor
 
   [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "uniformoutput", false){:});
-  if (!isempty (extrapval))
+  if (! isempty (extrapval))
     idx = zeros (size (xi{1}));
     for i = 1 : length (x)
       idx |= xi{i} < min (x{i}(:)) | xi{i} > max (x{i}(:));
     endfor
     yi(idx) = extrapval;
   endif
 endfunction
 
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -142,13 +142,13 @@ endfunction
 %! assert (fieldnames (info), {"FunctionTable"; "Hierarchical"});
 %! ftbl = info.FunctionTable;
 %! assert (size (ftbl), [0, 1]);
 %! assert (fieldnames (ftbl), {"FunctionName"; "TotalTime"; "NumCalls"; "IsRecursive"; "Parents"; "Children"});
 %! hier = info.Hierarchical;
 %! assert (size (hier), [0, 1]);
 %! assert (fieldnames (hier), {"Index"; "SelfTime"; "NumCalls"; "Children"});
 
-%% Test input validation
+## Test input validation
 %!error profile ()
 %!error profile ("on", 2)
 %!error profile ("INVALID_OPTION")
 
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -158,17 +158,17 @@ function [q, err] = quadgk (f, a, b, var
             str = varargin{idx++};
             if (strcmpi (str, "reltol"))
               reltol = varargin{idx++};
             elseif (strcmpi (str, "abstol"))
               abstol = varargin{idx++};
             elseif (strcmpi (str, "waypoints"))
               waypoints = varargin{idx++} (:);
               if (isreal (waypoints))
-                waypoints (waypoints < a | waypoints > b) = [];
+                waypoints(waypoints < a | waypoints > b) = [];
               endif
             elseif (strcmpi (str, "maxintervalcount"))
               maxint = varargin{idx++};
             elseif (strcmpi (str, "trace"))
               trace = varargin{idx++};
             else
               error ("quadgk: unknown property '%s'", str);
             endif
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -147,17 +147,17 @@ function [q, nfun, hmin] = simpsonstp (f
     endif
   endif
 endfunction
 
 
 %!assert (quadv (@sin, 0, 2 * pi), 0, 1e-5)
 %!assert (quadv (@sin, 0, pi), 2, 1e-5)
 
-%% Handles weak singularities at the edge
+## Handles weak singularities at the edge
 %!assert (quadv (@(x) 1 ./ sqrt (x), 0, 1), 2, 1e-5)
 
-%% Handles vector-valued functions
+## Handles vector-valued functions
 %!assert (quadv (@(x) [(sin (x)), (sin (2 * x))], 0, pi), [2, 0], 1e-5)
 
-%% Handles matrix-valued functions
+## Handles matrix-valued functions
 %!assert (quadv (@(x) [ x, x, x; x, 1./sqrt(x), x; x, x, x ], 0, 1 ), [0.5, 0.5, 0.5; 0.5, 2, 0.5; 0.5, 0.5, 0.5], 1e-5)
 
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -124,17 +124,17 @@ endfunction
 %! ri = randi ([-5, 10], 1000, 1, "int8");
 %! assert (ri, fix (ri));
 %! assert (min (ri), int8 (-5));
 %! assert (max (ri), int8 (10));
 %! assert (class (ri), "int8");
 %!
 %!assert (size (randi (10, 3,1,2)), [3, 1, 2])
 
-%% Test input validation
+## Test input validation
 %!error (randi ())
 %!error (randi ("test"))
 %!error (randi (10+2i))
 %!error (randi (0))
 %!error (randi ([10, 1]))
 %!error (randi (256, "uint8"))
 %!error (randi (2^25, "single"))
 %!error (randi (bitmax () + 1))
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -63,17 +63,17 @@ function x = repmat (A, m, varargin)
       if (all (size (n) > 1))
         n = n(:,1);
       endif
       m = m(:).';
       n = n(:).';
     endif
   else
     if (nargin > 3)
-      # input check for m and varargin
+      ## input check for m and varargin
       if (isscalar (m) && all (cellfun ("numel", varargin) == 1))
         m = [m varargin{:}];
         n = [];
       else
         error ("repmat: all input arguments must be scalar");
       end
     elseif (isempty (m))
       m = n = 1;
@@ -132,68 +132,68 @@ function x = repmat (A, m, varargin)
     aaidx(2,:) = 1;
     A = reshape (A, aaidx(:));
     x = reshape (A (cidx{:}), idx .* aidx);
   endif
 
 endfunction
 
 
-# Tests for ML compatibility
+## Tests for ML compatibility
 %!shared x
 %! x = [1 2 3];
 %!assert (repmat (x, [3, 1]), repmat (x, 3, []))
 %!assert (repmat (x, [3, 1]), repmat (x, [], 3))
 %!assert (repmat (x, [1, 3]), repmat (x, [], [1, 3]))
 %!assert (repmat (x, [1, 3]), repmat (x, [1, 3], []))
 %!assert (repmat (x, [1 3]), repmat (x, [1 3; 3 3]))
 %!assert (repmat (x, [1 1 2]), repmat (x, [1 1; 1 3; 2 1]))
 %!assert (repmat (x, [1 3; 1 3], [1; 3]), repmat (x, [1 1 3]))
 %!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1; 4]))
 %!assert (repmat (x, [1 1], 4), repmat (x, [1 3; 1 3], [1 2; 3 4]))
 %!assert (repmat (x, [1 1], 4), repmat (x, [1 1 4]));
 %!assert (repmat (x, [1 1], 4), repmat (x, 1, [1 4]));
 
-# Test various methods of providing size parameters
+## Test various methods of providing size parameters
 %!shared x
 %! x = [1 2;3 4];
 %!assert (repmat (x, [1 1]), repmat (x, 1))
 %!assert (repmat (x, [3 3]), repmat (x, 3))
 %!assert (repmat (x, [1 1]), repmat (x, 1, 1))
 %!assert (repmat (x, [1 3]), repmat (x, 1, 3))
 %!assert (repmat (x, [3 1]), repmat (x, 3, 1))
 %!assert (repmat (x, [3 3]), repmat (x, 3, 3))
 %!assert (repmat (pi, [1,2,3,4]), repmat (pi, 1,2,3,4))
 
-# Tests for numel==1 case:
+## Tests for numel==1 case:
 %!shared x, r
 %! x = [ 65 ];
 %! r = kron (ones (2,2), x);
 %!assert (r, repmat (x, [2 2]))
 %!assert (char (r), repmat (char (x), [2 2]))
 %!assert (int8 (r), repmat (int8 (x), [2 2]))
 
-# Tests for ndims==2 case:
+## Tests for ndims==2 case:
 %!shared x, r
 %! x = [ 65 66 67 ];
 %! r = kron (ones (2,2), x);
 %!assert (r, repmat (x, [2 2]))
 %!assert (char (r), repmat (char (x), [2 2]))
 %!assert (int8 (r), repmat (int8 (x), [2 2]))
 
-# Tests for dim>2 case:
+## Tests for dim>2 case:
 %!shared x, r
 %! x = [ 65 66 67 ];
 %! r = kron (ones (2,2), x);
 %! r(:,:,2) = r(:,:,1);
 %!assert (r, repmat (x, [2 2 2]))
 %!assert (char (r), repmat (char (x), [2 2 2]))
 %!assert (int8 (r), repmat (int8 (x), [2 2 2]))
 
-# Test that sparsity is kept
+## Test that sparsity is kept
 %!assert (sparse (4,4), repmat (sparse (2,2),[2 2]))
 
 %!assert (size (repmat (".", -1, 1)), [0, 1])
 %!assert (size (repmat (".", 1, -1)), [1, 0])
 
 %!assert (size (repmat (1, [1, 0])), [1, 0])
 %!assert (size (repmat (1, [5, 0])), [5, 0])
 %!assert (size (repmat (1, [0, 1])), [0, 1])
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -127,15 +127,15 @@ endfunction
 %! a(1:2,1:3,:,1) = [ 1  2  3;  4  5  6];
 %! a(1:2,1:3,:,2) = [ 7  8  9; 10 11 12];
 %! b(1:3,1:2,:,1) = [ 3  6;  2  5;  1  4];
 %! b(1:3,1:2,:,2) = [ 9 12;  8 11;  7 10];
 %! assert (rot90 (a, 1), b)
 %! assert (rot90 (a, 2), rot90 (b, 1))
 %! assert (rot90 (a, 3), rot90 (b, 2))
 
-%% Test input validation
+## Test input validation
 %!error rot90 ()
 %!error rot90 (1, 2, 3)
 %!error rot90 (1, ones (2))
 %!error rot90 (1, 1.5)
 %!error rot90 (1, 1+i)
 
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -56,17 +56,17 @@
 
 function y = rotdim (x, n, plane)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin > 1 && ! isempty (n))
-    if (!isscalar (n) || !isreal (n) || fix (n) != n)
+    if (! isscalar (n) || ! isreal (n) || fix (n) != n)
       error ("rotdim: N must be a scalar integer");
     endif
   else
     n = 1;
   endif
 
   nd = ndims (x);
   sz = size (x);
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -82,17 +82,17 @@ endfunction
 %!
 %! assert (shift (r, 0), r);
 %! assert (shift (r, 3), [c, a, b]);
 %! assert (shift (r, -6), [c, a, b]);
 %! assert (shift (r, -3), [b, c, a]);
 %! assert (shift (m, 1), [c; a; b]);
 %! assert (shift (m, -2), [c; a; b]);
 
-%% Test input validation
+## Test input validation
 %!error shift ()
 %!error shift (1, 2, 3, 4)
 %!error shift ([], 1)
 %!error shift (ones (2), ones (2))
 %!error shift (ones (2), 1.5)
 %!error shift (1, 1, 1.5)
 %!error shift (1, 1, 0)
 %!error shift (1, 1, 3)
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -39,17 +39,17 @@
 ##    @result{} [1, 1, 2, 3]
 ## size (shiftdim (x, 1))
 ##    @result{} [2, 3]
 ## [b, ns] = shiftdim (x)
 ##    @result{} b = [1, 1, 1; 1, 1, 1]
 ##    @result{} ns = 1
 ## @end group
 ## @end example
-## @seealso {reshape, permute, ipermute, circshift, squeeze}
+## @seealso{reshape, permute, ipermute, circshift, squeeze}
 ## @end deftypefn
 
 function [y, ns]  = shiftdim (x, n)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
@@ -88,14 +88,14 @@ endfunction
 %! [y, ns] = shiftdim (x);
 %! assert (size (y), [4 2]);
 %! assert (ns, 2);
 %! assert (shiftdim (y, -2), x);
 %! assert (size (shiftdim (x, 2)), [4 2]);
 
 %!assert (size (shiftdim (rand (0, 1, 2))), [0 1 2])
 
-%% Test input validation
+## Test input validation
 %!error (shiftdim ())
 %!error (shiftdim (1,2,3))
 %!error (shiftdim (1, ones (2)))
 %!error (shiftdim (1, 1.5))
 
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -122,16 +122,16 @@ endfunction
 %! [x, idx] = sortrows (m, c);
 %! [sx, sidx] = sortrows (sparse (m), c);
 %! assert (x, m);
 %! assert (idx, 1);
 %! assert (issparse (sx));
 %! assert (x, full (sx));
 %! assert (idx, sidx);
 
-%% Test input validation
+## Test input validation
 %!error sortrows ()
 %!error sortrows (1, 2, 3)
 %!error sortrows (1, "ascend")
 %!error sortrows (1, ones (2,2))
 %!error sortrows (1, 0)
 %!error sortrows (1, 2)
 
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -101,17 +101,18 @@ function varargout = structfun (func, S,
   if (nargs > 0)
     error ("structfun: invalid options");
   endif
 
   varargout = cell (max ([nargout, 1]), 1);
   [varargout{:}] = cellfun (func, struct2cell (S), varargin{:});
 
   if (! uniform_output)
-    varargout = cellfun ("cell2struct", varargout, {fieldnames(S)}, {1}, uo_str, false);
+    varargout = cellfun ("cell2struct", varargout, {fieldnames(S)}, {1}, ...
+                         uo_str, false);
   endif
 endfunction
 
 
 %!test
 %! s.name1 = "John Smith";
 %! s.name2 = "Jill Jones";
 %! l.name1 = "Smith";
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -99,17 +99,17 @@ function z = trapz (x, y, dim)
   n = sz(dim);
   idx1 = idx2 = repmat ({':'}, [nd, 1]);
   idx1{dim} = 2 : n;
   idx2{dim} = 1 : (n - 1);
 
   if (! have_xy)
     z = 0.5 * sum (x(idx1{:}) + x(idx2{:}), dim);
   else
-    if (isvector (x) && !isvector (y))
+    if (isvector (x) && ! isvector (y))
       if (length (x) != sz(dim))
         error ("trapz: length of X and length of Y along DIM must match");
       endif
       ## Reshape vector to point along dimension DIM
       shape = ones (nd, 1);
       shape(dim) = sz(dim);
       x = reshape (x, shape);
       z = 0.5 * sum (bsxfun (@times, diff (x), y(idx1{:}) + y(idx2{:})), dim);
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -60,27 +60,28 @@ function q = triplequad (f, xa, xb, ya, 
   endif
 
   inner = @__triplequad_inner__;
   if (ischar (f))
     f = @(x,y,z) feval (f, x, y, z, varargin{:});
     varargin = {};
   endif
 
-  q = dblquad (@(y, z) inner (y, z, f, xa, xb, tol, quadf, varargin{:}), ya, yb, za, zb, tol);
+  q = dblquad (@(y, z) inner (y, z, f, xa, xb, tol, quadf, varargin{:}), ...
+               ya, yb, za, zb, tol);
 
 endfunction
 
 function q = __triplequad_inner__ (y, z, f, xa, xb, tol, quadf, varargin)
   q = zeros (size (y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f (x, y(i), z, varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
 
 %!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadcc), pi^(3/2) * erf (1).^3, 1e-6)
 
-%% These tests are too expensive to run normally (~30 sec each).  Disable them
+## These tests are too expensive to run normally (~30 sec each).  Disable them
 #%!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadgk), pi^(3/2) * erf (1).^3, 1e-6)
 #%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadl), pi^(3/2) * erf (1).^3, 1e-6)
 #%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadv), pi^(3/2) * erf (1).^3, 1e-6)
 
diff --git a/scripts/general/validateattributes.m b/scripts/general/validateattributes.m
--- a/scripts/general/validateattributes.m
+++ b/scripts/general/validateattributes.m
@@ -333,16 +333,17 @@ endfunction
 function cls = replace_cl_group (cls, name, group)
   num_pos = strcmpi (cls, name);
   if (any (num_pos))
     cls(num_pos) = [];
     cls(end+1:end+numel(group)) = group;
   endif
 endfunction
 
+
 %!error <double> validateattributes (rand (5), {"uint8"}, {})
 %!error <single> validateattributes (uint8 (rand (5)), {"float"}, {})
 %!error <2d> validateattributes (rand (5, 5, 5), {}, {"2d"})
 %!error <3d> validateattributes (rand (5, 5, 5, 7), {}, {"3d"})
 %!error <column> validateattributes (rand (5, 5), {}, {"column"})
 %!error <column> validateattributes (rand (1, 5), {}, {"column"})
 %!error <row> validateattributes (rand (5, 5), {}, {"row"})
 %!error <row> validateattributes (rand (5, 1), {}, {"row"})
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -95,10 +95,10 @@ endfunction
 %! plot (x(k),y(k),"r-;convex hull;", x,y,"b+;points;");
 %! axis ([-3.05, 3.05, -0.05, 1.05]);
 
 %!testif HAVE_QHULL
 %! x = -3:0.5:3;
 %! y = abs (sin (x));
 %! assert (convhull (x, y), [1;7;13;12;11;10;4;3;2;1]);
 
-%% FIXME: Need input validation tests
+## FIXME: Need input validation tests
 
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -192,17 +192,17 @@ endfunction
 %! y = [5 7 8; 1 2 3];
 %! assert (sortrows (sort (delaunay (x, y), 2)), [1,2,4;1,3,4;1,3,5;3,4,6]);
 
 ## Test 3-D input
 %!testif HAVE_QHULL
 %! x = [-1, -1, 1, 0, -1]; y = [-1, 1, 1, 0, -1]; z = [0, 0, 0, 1, 1];
 %! assert (sortrows (sort (delaunay (x, y, z), 2)), [1,2,3,4;1,2,4,5])
 
-%% Input validation tests
+## Input validation tests
 %!error delaunay ()
 %!error delaunay (1,2,3,4,5)
 %!error <X must be a matrix with 2 or 3 columns> delaunay (ones (2,4))
 %!error <OPTIONS must be a string or cell array> delaunay (ones (2,2), struct())
 %!error <X must be a matrix with 2 or 3 columns> delaunay (ones (2,4), "")
 %!error <OPTIONS must be a string or cell array> delaunay (ones (2,2), ones (2,2), struct())
 %!error <OPTIONS must be a string or cell array> delaunay (ones (2,2), ones (2,2), ones (2,2), struct())
 %!error <X and Y must be the same size> delaunay (1, [1 2])
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -91,13 +91,13 @@ endfunction
 %! x = [-1, 0; 0, 1; 1, 0; 0, -1; 0, 0];
 %! assert (sortrows (sort (delaunayn (x), 2)), [1,2,5;1,4,5;2,3,5;3,4,5]);
 
 ## Test 3-D input
 %!testif HAVE_QHULL
 %! x = [-1, -1, 1, 0, -1]; y = [-1, 1, 1, 0, -1]; z = [0, 0, 0, 1, 1];
 %! assert (sortrows (sort (delaunayn ([x(:) y(:) z(:)]), 2)), [1,2,3,4;1,2,4,5])
 
-%% FIXME: Need tests for delaunayn
+## FIXME: Need tests for delaunayn
 
-%% Input validation tests
+## Input validation tests
 %!error delaunayn ()
 
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -84,25 +84,25 @@ function [rx, ry, rz] = griddata (x, y, 
   zi = NaN (size (xi));
 
   if (strcmp (method, "cubic"))
     error ("griddata: cubic interpolation not yet implemented");
 
   elseif (strcmp (method, "nearest"))
     ## Search index of nearest point.
     idx = dsearch (x, y, tri, xi, yi);
-    valid = !isnan (idx);
+    valid = ! isnan (idx);
     zi(valid) = z(idx(valid));
 
   elseif (strcmp (method, "linear"))
     ## Search for every point the enclosing triangle.
     tri_list = tsearch (x, y, tri, xi(:), yi(:));
 
     ## Only keep the points within triangles.
-    valid = !isnan (tri_list);
+    valid = ! isnan (tri_list);
     tri_list = tri_list(valid);
     nr_t = rows (tri_list);
 
     tri = tri(tri_list,:);
 
     ## Assign x,y,z for each point of triangle.
     x1 = x(tri(:,1));
     x2 = x(tri(:,2));
@@ -182,17 +182,17 @@ endfunction
 %! y = yy(:);
 %! y = y + 10*(2*round (rand (size (y))) - 1) * eps;
 %! z = sin (2*(x.^2 + y.^2));
 %! zz = griddata (x,y,z,xx,yy,"linear");
 %! zz2 = sin (2*(xx.^2 + yy.^2));
 %! zz2(isnan (zz)) = NaN;
 %! assert (zz, zz2, 100*eps);
 
-%% Test input validation
+## Test input validation
 %!error griddata ()
 %!error griddata (1)
 %!error griddata (1,2)
 %!error griddata (1,2,3)
 %!error griddata (1,2,3,4)
 %!error griddata (1,2,3,4,5,6,7)
 %!error <vectors of the same length> griddata (1:3, 1:3, 1:4, 1:3, 1:3)
 %!error <vectors of the same length> griddata (1:3, 1:4, 1:3, 1:3, 1:3)
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -57,31 +57,31 @@ function yi = griddatan (x, y, xi, metho
   ## triangulate data
   tri = delaunayn (x, varargin{:});
 
   yi = NaN (mi, 1);
 
   if (strcmp (method, "nearest"))
     ## search index of nearest point
     idx = dsearchn (x, tri, xi);
-    valid = !isnan (idx);
+    valid = ! isnan (idx);
     yi(valid) = y(idx(valid));
 
   elseif (strcmp (method, "linear"))
     ## search for every point the enclosing triangle
     [tri_list, bary_list] = tsearchn (x, tri, xi);
 
     ## only keep the points within triangles.
-    valid = !isnan (tri_list);
-    tri_list = tri_list(!isnan (tri_list));
-    bary_list = bary_list(!isnan (tri_list), :);
+    valid = ! isnan (tri_list);
+    tri_list = tri_list(! isnan (tri_list));
+    bary_list = bary_list(! isnan (tri_list), :);
     nr_t = rows (tri_list);
 
     ## assign x,y for each point of simplex
-    xt =  reshape (x(tri(tri_list,:),:), [nr_t, n+1, n]);
+    xt = reshape (x(tri(tri_list,:),:), [nr_t, n+1, n]);
     yt = y(tri(tri_list,:));
 
     ## Use barycentric coordinate of point to calculate yi
     yi(valid) = sum (y(tri(tri_list,:)) .* bary_list, 2);
 
   else
     error ("griddatan: unknown interpolation METHOD");
   endif
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -65,24 +65,24 @@ function [in, on] = inpolygon (x, y, xv,
     delta_yv = yv(j) - yv(i);
     ## distance = [distance from (x,y) to edge] * length(edge)
     distance = delta_xv .* (y - yv(i)) - (x - xv(i)) .* delta_yv;
     ##
     ## is y between the y-values of edge i,j
     ##        AND (x,y) on the left of the edge ?
     idx1 = (((yv(i) <= y & y < yv(j)) | (yv(j) <= y & y < yv(i)))
             & 0 < distance.*delta_yv);
-    in (idx1) = !in (idx1);
+    in(idx1) = ! in(idx1);
 
     ## Check if (x,y) are actually on the boundary of the polygon.
     if (do_boundary)
        idx2 = (((yv(i) <= y & y <= yv(j)) | (yv(j) <= y & y <= yv(i)))
                & ((xv(i) <= x & x <= xv(j)) | (xv(j) <= x & x <= xv(i)))
                & (0 == distance | !delta_xv));
-       on (idx2) = true;
+       on(idx2) = true;
     endif
     j = i;
   endfor
 
 endfunction
 
 
 %!demo
@@ -133,15 +133,15 @@ endfunction
 %! disp ("Green points are inside polygon, magenta are outside,");
 %! disp ("and blue are on boundary.");
 
 %!test
 %! [in, on] = inpolygon ([1, 0], [1, 0], [-1, -1, 1, 1], [-1, 1, 1, -1]);
 %! assert (in, [false, true]);
 %! assert (on, [true, false]);
 
-%% Test input validation
+## Test input validation
 %!error inpolygon ()
 %!error inpolygon (1, 2)
 %!error inpolygon (1, 2, 3)
 %!error inpolygon (1, [1,2], [3, 4], [5, 6])
 %!error inpolygon ([1,2], [3, 4], [5, 6], 1)
 
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -198,16 +198,16 @@ endfunction
 
 %!testif HAVE_QHULL
 %! ## Special case of just 2 points
 %! x = [0 1];  y = [1 0];
 %! [vx, vy] = voronoi (x,y);
 %! assert (vx, [-0.7; 1.7], eps);
 %! assert (vy, [-0.7; 1.7], eps);
 
-%% Input validation tests
+## Input validation tests
 %!error voronoi ()
 %!error voronoi (ones (3,1))
 %!error voronoi (ones (3,1), ones (3,1), "bogus1", "bogus2", "bogus3")
 %!error <HAX argument must be an axes object> voronoi (0, ones (3,1), ones (3,1))
 %!error <X and Y must be vectors of the same length> voronoi (ones (3,1), ones (4,1))
 %!error <minimum of 2 points needed> voronoi (2.5, 3.5)
 
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -70,14 +70,14 @@ function [C, F] = voronoin (pts, options
     [C, F] = __voronoi__ (caller, pts);
   else
     [C, F] = __voronoi__ (caller, pts, options);
   endif
 
 endfunction
 
 
-%% FIXME: Need functional tests
+## FIXME: Need functional tests
 
 %!error voronoin ()
 %!error voronoin (1,2,3)
 %!error <number of points must be greater than their dimension> voronoin ([1 2])
 
diff --git a/scripts/gui/guidata.m b/scripts/gui/guidata.m
--- a/scripts/gui/guidata.m
+++ b/scripts/gui/guidata.m
@@ -54,14 +54,14 @@ function dataout = guidata (h, data)
     if (nargout == 1)
       dataout = data;
     endif
   endif
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error guidata ()
 %!error guidata (1,2,3)
 %!error <H must be a valid object handle> guidata ({1})
 %!error <no ancestor figure of H found> guidata (0)
 
diff --git a/scripts/gui/private/__get_funcname__.m b/scripts/gui/private/__get_funcname__.m
--- a/scripts/gui/private/__get_funcname__.m
+++ b/scripts/gui/private/__get_funcname__.m
@@ -26,17 +26,19 @@
 
 ## Author: Andreas Weber
 
 function funcname = __get_funcname__ (basename)
 
   if (! __octave_link_enabled__ ())
     tk = graphics_toolkit ();
     funcname = strcat ("__", basename, "_", tk, "__");
-    if ((numel (tk) > 0) && (! strcmp(tk, "fltk")) && (! __is_function__ (funcname)))
-      warning ("%s: no implementation for toolkit '%s', using 'fltk' instead",basename, tk);
+    if (numel (tk) > 0 && ! strcmp (tk, "fltk")
+        && ! __is_function__ (funcname)))
+      warning ("%s: no implementation for toolkit '%s', using 'fltk' instead",
+               basename, tk);
     endif
     funcname = strcat ("__", basename, "_fltk__");
   else
     funcname = "";
   endif
 
 endfunction
diff --git a/scripts/gui/private/__uigetdir_fltk__.m b/scripts/gui/private/__uigetdir_fltk__.m
--- a/scripts/gui/private/__uigetdir_fltk__.m
+++ b/scripts/gui/private/__uigetdir_fltk__.m
@@ -24,12 +24,13 @@
 ## Author: Michael Goffioul
 
 function dirname = __uigetdir_fltk__ (start_path, dialog_title)
 
   if (exist ("__fltk_uigetfile__") != 3)
     error ("uigetdir: fltk graphics toolkit required");
   endif
 
-  dirname = __fltk_uigetfile__ ("", dialog_title, start_path, [240, 120], "dir");
+  dirname = __fltk_uigetfile__ ("", dialog_title,
+                                start_path, [240, 120], "dir");
 
 endfunction
 
diff --git a/scripts/gui/private/__uigetfile_fltk__.m b/scripts/gui/private/__uigetfile_fltk__.m
--- a/scripts/gui/private/__uigetfile_fltk__.m
+++ b/scripts/gui/private/__uigetfile_fltk__.m
@@ -28,12 +28,13 @@ function [retval, retpath, retindex] = _
   if (exist ("__fltk_uigetfile__") != 3)
     error ("uigetfile: fltk graphics toolkit required");
   endif
 
   filters = __fltk_file_filter__ (filters);
   if (length (defdir) > 0)
     defval = fullfile (defdir, defval);
   endif
-  [retval, retpath, retindex] = __fltk_uigetfile__ (filters, title, defval, position, multiselect);
+  [retval, retpath, retindex] = ...
+    __fltk_uigetfile__ (filters, title, defval, position, multiselect);
 
 endfunction
 
diff --git a/scripts/gui/private/__uiobject_split_args__.m b/scripts/gui/private/__uiobject_split_args__.m
--- a/scripts/gui/private/__uiobject_split_args__.m
+++ b/scripts/gui/private/__uiobject_split_args__.m
@@ -50,17 +50,18 @@ function [parent, args] = __uiobject_spl
       if (! ishandle (parent))
         error ("%s: invalid parent handle.", who);
       endif
       args([2*i-1, 2*i]) = [];
     endif
   endif
 
   if (! isempty (parent))
-    if (! isempty (parent_type) && isempty (find (strcmpi (get (parent, "type"), parent_type))))
+    if (! isempty (parent_type)
+        && isempty (find (strcmpi (get (parent, "type"), parent_type))))
       error ("%s: invalid parent, the parent type must be: %s", ...
              who, sprintf ("%s, ", parent_type{:})(1:end-2));
     endif
   elseif (use_gcf)
     parent = gcf ();
   endif
 
 endfunction
diff --git a/scripts/gui/private/__uiputfile_fltk__.m b/scripts/gui/private/__uiputfile_fltk__.m
--- a/scripts/gui/private/__uiputfile_fltk__.m
+++ b/scripts/gui/private/__uiputfile_fltk__.m
@@ -28,12 +28,13 @@ function [retval, retpath, retindex] = _
   if (exist ("__fltk_uigetfile__") != 3)
     error ("uiputfile: fltk graphics toolkit required");
   endif
 
   filters = __fltk_file_filter__ (filters);
   if (length (defdir) > 0)
     defval = fullfile (defdir, defval);
   endif
-  [retval, retpath, retindex] = __fltk_uigetfile__ (filters, title, defval, position, tag);
+  [retval, retpath, retindex] = ...
+    __fltk_uigetfile__ (filters, title, defval, position, tag);
 
 endfunction
 
diff --git a/scripts/gui/uicontextmenu.m b/scripts/gui/uicontextmenu.m
--- a/scripts/gui/uicontextmenu.m
+++ b/scripts/gui/uicontextmenu.m
@@ -12,20 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{handle} =} uicontextmenu ("Name", value, @dots{})
+## @deftypefn {Function File} {@var{hui} =} uicontextmenu ("Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
-function handle = uicontextmenu (varargin)
+function hui = uicontextmenu (varargin)
 
   [h, args] = __uiobject_split_args__ ("uicontextmenu", varargin, {"figure"});
-  handle = __go_uicontextmenu__ (h, args{:});
+  hui = __go_uicontextmenu__ (h, args{:});
 
 endfunction
 
diff --git a/scripts/gui/uicontrol.m b/scripts/gui/uicontrol.m
--- a/scripts/gui/uicontrol.m
+++ b/scripts/gui/uicontrol.m
@@ -12,26 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uicontrol ("Name", value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uicontrol (@var{parent}, "Name", value, @dots{})
-## @deftypefnx {Function File} {} uicontrol (@var{handle})
+## @deftypefn  {Function File} {@var{hui} =} uicontrol ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{hui} =} uicontrol (@var{parent}, "Name", value, @dots{})
+## @deftypefnx {Function File} {} uicontrol (@var{h})
 ## @end deftypefn
 
 ## Author: goffioul
 
-function handle = uicontrol (varargin)
+function hui = uicontrol (varargin)
 
-  if (nargin == 1 && ishandle (varargin{1}) && strcmpi (get (varargin{1}, "type"), "uicontrol"))
+  if (nargin == 1 && ishandle (varargin{1})
+      && strcmpi (get (varargin{1}, "type"), "uicontrol"))
     error ("uicontrol focusing not implemented yet.");
-  else
-    [h, args] = __uiobject_split_args__ ("uicontrol", varargin, {"figure", "uipanel", "uibuttongroup"});
-    handle = __go_uicontrol__ (h, args{:});
   endif
 
+  [h, args] = __uiobject_split_args__ ("uicontrol", varargin,
+                                       {"figure", "uipanel", "uibuttongroup"});
+  hui = __go_uicontrol__ (h, args{:});
+
 endfunction
 
diff --git a/scripts/gui/uigetdir.m b/scripts/gui/uigetdir.m
--- a/scripts/gui/uigetdir.m
+++ b/scripts/gui/uigetdir.m
@@ -15,53 +15,54 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{dirname} =} uigetdir ()
 ## @deftypefnx {Function File} {@var{dirname} =} uigetdir (@var{init_path})
 ## @deftypefnx {Function File} {@var{dirname} =} uigetdir (@var{init_path}, @var{dialog_name})
-## Open a GUI dialog for selecting a directory.  If @var{init_path} is not
-## given the current working directory is used.  @var{dialog_name} may be
-## used to customize the dialog title.
+## Open a GUI dialog for selecting a directory.
+##
+## If @var{init_path} is not given the current working directory is used.
+## @var{dialog_name} may be used to customize the dialog title.
 ## @seealso{uigetfile, uiputfile}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function dirname = uigetdir (init_path = pwd, dialog_name = "Select Directory to Open")
 
-  funcname = __get_funcname__ (mfilename ());
-
   if (nargin > 2)
     print_usage ();
   endif
 
-  if (!ischar (init_path) || !ischar (dialog_name))
+  if (! ischar (init_path) || ! ischar (dialog_name))
     error ("uigetdir: INIT_PATH and DIALOG_NAME must be string arguments");
   endif
 
-  if (!isdir (init_path))
+  if (! isdir (init_path))
     init_path = fileparts (init_path);
   endif
 
   if (isguirunning ())
     file_filter = cell (0, 2);
     default_file_name = "";
     dialog_position = [240, 120];
     dialog_mode = "dir";
 
     [filename, dirname, filterindex] ...
       = __octave_link_file_dialog__ (file_filter, dialog_name,
                                      default_file_name, dialog_position,
                                      dialog_mode, init_path);
   else
+    funcname = __get_funcname__ (mfilename ());
     dirname = feval (funcname, init_path, dialog_name);
   endif
+
 endfunction
 
 
 %!demo
 %! uigetdir (pwd, 'Select Directory');
 
 ## Remove from test statistics.  No real tests possible.
 %!assert (1)
diff --git a/scripts/gui/uigetfile.m b/scripts/gui/uigetfile.m
--- a/scripts/gui/uigetfile.m
+++ b/scripts/gui/uigetfile.m
@@ -21,16 +21,17 @@
 ## @deftypefnx {Function File} {[@dots{}] =} uigetfile (@var{flt})
 ## @deftypefnx {Function File} {[@dots{}] =} uigetfile (@var{flt}, @var{dialog_name})
 ## @deftypefnx {Function File} {[@dots{}] =} uigetfile (@var{flt}, @var{dialog_name}, @var{default_file})
 ## @deftypefnx {Function File} {[@dots{}] =} uigetfile (@dots{}, "Position", [@var{px} @var{py}])
 ## @deftypefnx {Function File} {[@dots{}] =} uigetfile (@dots{}, "MultiSelect", @var{mode})
 ##
 ## Open a GUI dialog for selecting a file and return the filename @var{fname},
 ## the path to this file @var{fpath}, and the filter index @var{fltidx}.
+##
 ## @var{flt} contains a (list of) file filter string(s) in one of the following
 ## formats:
 ##
 ## @table @asis
 ## @item @qcode{"/path/to/filename.ext"}
 ## If a filename is given then the file extension is extracted and used as
 ## filter.  In addition, the path is selected as current path and the filename
 ## is selected as default file.  Example: @code{uigetfile ("myfun.m")}
@@ -61,33 +62,27 @@
 ## cell array containing the files.
 ## @seealso{uiputfile, uigetdir}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function [retfile, retpath, retindex] = uigetfile (varargin)
 
-  funcname = __get_funcname__ (mfilename ());
-
   if (nargin > 7)
     error ("uigetfile: number of input arguments must be less than eight");
   endif
 
-  defaultvals = {cell(0, 2),         # File Filter
-                 "Open File",        # Dialog Title
-                 "",                 # Default file name
-                 [240, 120],         # Dialog Position (pixel x/y)
-                 "off",              # MultiSelect on/off
-                 pwd};               # Default directory
-
-  outargs = cell (6, 1);
-  for i = 1 : 6
-    outargs{i} = defaultvals{i};
-  endfor
+  ## Preset default values
+  outargs = {cell(0, 2),         # File Filter
+             "Open File",        # Dialog Title
+             "",                 # Default file name
+             [240, 120],         # Dialog Position (pixel x/y)
+             "off",              # MultiSelect on/off
+             pwd};               # Default directory
 
   idx1 = idx2 = [];
   if (length (varargin) > 0)
     for i = 1 : length (varargin)
       val = varargin{i};
       if (ischar (val))
         val = tolower (val);
         if (strcmp (val, "multiselect"))
@@ -145,17 +140,17 @@ function [retfile, retpath, retindex] = 
         outargs{3} = strcat (fname, fext);
       endif
     elseif (! isempty (args{3}))
       print_usage ();
     endif
   endif
 
   if (stridx)
-    ## we have string arguments ("position" or "multiselect")
+    ## string arguments ("position" or "multiselect")
 
     ## check for even number of remaining arguments, prop/value pair(s)
     if (rem (nargin - stridx + 1, 2))
       error ("uigetfile: expecting property/value pairs");
     endif
 
     for i = stridx : 2 : nargin
       prop = varargin{i};
@@ -176,16 +171,17 @@ function [retfile, retpath, retindex] = 
         error ("uigetfile: unknown argument");
       endif
     endfor
   endif
 
   if (isguirunning ())
     [retfile, retpath, retindex] = __octave_link_file_dialog__ (outargs{:});
   else
+    funcname = __get_funcname__ (mfilename ());
     [retfile, retpath, retindex] = feval (funcname, outargs{:});
   endif
 
 endfunction
 
 
 %!demo
 %! uigetfile ({'*.gif;*.png;*.jpg', 'Supported Picture Formats'});
diff --git a/scripts/gui/uimenu.m b/scripts/gui/uimenu.m
--- a/scripts/gui/uimenu.m
+++ b/scripts/gui/uimenu.m
@@ -12,21 +12,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} uimenu (@var{property}, @var{value}, @dots{})
-## @deftypefnx {Function File} {} uimenu (@var{h}, @var{property}, @var{value}, @dots{})
-## Create a uimenu object and return a handle to it.  If @var{h} is omitted
-## then a top-level menu for the current figure is created.  If @var{h}
-## is given then a submenu relative to @var{h} is created.
+## @deftypefn  {Function File} {@var{hui} =} uimenu (@var{property}, @var{value}, @dots{})
+## @deftypefnx {Function File} {@var{hui} =} uimenu (@var{h}, @var{property}, @var{value}, @dots{})
+## Create a uimenu object and return a handle to it.
+##
+## If @var{h} is omitted then a top-level menu for the current figure is
+## created.  If @var{h} is given then a submenu relative to @var{h} is created.
 ##
 ## uimenu objects have the following specific properties:
 ##
 ## @table @asis
 ## @item @qcode{"accelerator"}
 ## A string containing the key combination together with CTRL to execute this
 ## menu entry (e.g., @qcode{"x"} for CTRL+x).
 ##
@@ -75,17 +76,18 @@
 ## @end example
 ## @seealso{figure}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function hui = uimenu (varargin)
 
-  [h, args] = __uiobject_split_args__ ("uimenu", varargin, {"figure", "uicontextmenu", "uimenu"});
+  [h, args] = __uiobject_split_args__ ("uimenu", varargin,
+                                       {"figure", "uicontextmenu", "uimenu"});
 
   tmp = __go_uimenu__ (h, args{:});
 
   if (nargout > 0)
     hui = tmp;
   endif
 
 endfunction
@@ -112,17 +114,17 @@ endfunction
 %!   assert (get (ui, "separator"), "off");
 %!   assert (get (ui, "enable"), "on");
 %!   assert (get (ui, "position"), 9);
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
-%% check for top level menus file, edit, and help
+## check for top level menus file, edit, and help
 %!testif HAVE_FLTK
 %! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uif = findall (hf, "label", "&file");
 %!   assert (ishghandle (uif));
 %!   uie = findall (hf, "label", "&edit");
 %!   assert (ishghandle (uie));
diff --git a/scripts/gui/uipanel.m b/scripts/gui/uipanel.m
--- a/scripts/gui/uipanel.m
+++ b/scripts/gui/uipanel.m
@@ -12,21 +12,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uipanel ("Name", value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uipanel (@var{parent}, "Name", value, @dots{})
+## @deftypefn  {Function File} {@var{hui} =} uipanel ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{hui} =} uipanel (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
-function handle = uipanel (varargin)
+function hui = uipanel (varargin)
 
-  [h, args] = __uiobject_split_args__ ("uipanel", varargin, {"figure", "uipanel", "uibuttongroup"});
-  handle = __go_uipanel__ (h, args{:});
+  [h, args] = __uiobject_split_args__ ("uipanel", varargin,
+                                       {"figure", "uipanel", "uibuttongroup"});
+  hui = __go_uipanel__ (h, args{:});
 
 endfunction
 
diff --git a/scripts/gui/uipushtool.m b/scripts/gui/uipushtool.m
--- a/scripts/gui/uipushtool.m
+++ b/scripts/gui/uipushtool.m
@@ -12,29 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uipushtool ("Name", value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uipushtool (@var{parent}, "Name", value, @dots{})
+## @deftypefn  {Function File} {@var{hui} =} uipushtool ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{hui} =} uipushtool (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
-function handle = uipushtool (varargin)
+function hui = uipushtool (varargin)
 
-  [h, args] = __uiobject_split_args__ ("uipushtool", varargin, {"uitoolbar"}, 0);
+  [h, args] = __uiobject_split_args__ ("uipushtool", varargin,
+                                       {"uitoolbar"}, 0);
   if (isempty (h))
     h = findobj (gcf, "-depth", 1, "type", "uitoolbar");
     if (isempty (h))
       h = uitoolbar ();
     else
       h = h(1);
     endif
   endif
-  handle = __go_uipushtool__ (h, args{:});
+  hui = __go_uipushtool__ (h, args{:});
 
 endfunction
 
diff --git a/scripts/gui/uiputfile.m b/scripts/gui/uiputfile.m
--- a/scripts/gui/uiputfile.m
+++ b/scripts/gui/uiputfile.m
@@ -16,18 +16,20 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile ()
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt})
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt}, @var{dialog_name})
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt}, @var{dialog_name}, @var{default_file})
-## Open a GUI dialog for selecting a file.  @var{flt} contains a (list of) file
-## filter string(s) in one of the following formats:
+## Open a GUI dialog for selecting a file.
+##
+## @var{flt} contains a (list of) file filter string(s) in one of the following
+## formats:
 ##
 ## @table @asis
 ## @item @qcode{"/path/to/filename.ext"}
 ## If a filename is given the file extension is extracted and used as filter.
 ## In addition the path is selected as current path and the filename is
 ## selected as default file.  Example: @code{uiputfile ("myfun.m")}
 ##
 ## @item @qcode{"*.ext"}
@@ -51,33 +53,27 @@
 ## If, in addition, a path is given it is also used as current path.
 ## @seealso{uigetfile, uigetdir}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function [retfile, retpath, retindex] = uiputfile (varargin)
 
-  funcname = __get_funcname__ (mfilename ());
-
   if (nargin > 3)
     print_usage ();
   endif
 
-  defaultvals = {cell(0, 2),     # File Filter
-                 "Save File",    # Dialog Title
-                 "",             # Default file name
-                 [240, 120],     # Dialog Position (pixel x/y)
-                 "create",
-                 pwd};           # Default directory
-
-  outargs = cell (6, 1);
-  for i = 1 : 6
-    outargs{i} = defaultvals{i};
-  endfor
+  ## Preset default values
+  outargs = {cell(0, 2),     # File Filter
+             "Save File",    # Dialog Title
+             "",             # Default file name
+             [240, 120],     # Dialog Position (pixel x/y)
+             "create",
+             pwd};           # Default directory
 
   if (nargin > 0)
     file_filter = varargin{1};
     [outargs{1}, outargs{3}, defdir] = __file_filter__ (file_filter);
     if (length (defdir) > 0)
       outargs{6} = defdir;
     endif
   else
@@ -109,27 +105,27 @@ function [retfile, retpath, retindex] = 
     elseif (! isempty (varargin{3}))
       print_usage ();
     endif
   endif
 
   if (isguirunning ())
     [retfile, retpath, retindex] = __octave_link_file_dialog__ (outargs{:});
   else
+    funcname = __get_funcname__ (mfilename ());
     [retfile, retpath, retindex] = feval (funcname, outargs{:});
   endif
 
-  # add extension to the name it isnt already added
-
-  if ischar (retfile)
+  ## Append extension to the name if it isn't already added.
+  if (ischar (retfile))
     ext = outargs{1}{retindex};
-    ext = strrep (ext, '*', '');
+    ext = strrep (ext, "*", "");
 
-    if length (retfile) >= length (ext)
-      if ! strcmp (retfile(end-length (ext)+1:end), ext)
+    if (length (retfile) >= length (ext))
+      if (! strcmp (retfile(end-length (ext)+1:end), ext))
         retfile = [retfile ext];
       endif
     endif
   endif
 
 endfunction
 
 
diff --git a/scripts/gui/uiresume.m b/scripts/gui/uiresume.m
--- a/scripts/gui/uiresume.m
+++ b/scripts/gui/uiresume.m
@@ -13,20 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} uiresume (@var{h})
-## Resume program execution suspended with @code{uiwait}.  The handle @var{h}
-## must be the same as the on specified in @code{uiwait}.  If the handle
-## is invalid or there is no @code{uiwait} call pending for the figure
-## with handle @var{h}, this function does nothing.
+## Resume program execution suspended with @code{uiwait}.
+##
+## The handle @var{h} must be the same as the on specified in @code{uiwait}.
+## If the handle is invalid or there is no @code{uiwait} call pending for the
+## figure with handle @var{h}, this function does nothing.
 ## @seealso{uiwait}
 ## @end deftypefn
 
 ## Author: goffioul
 
 function uiresume (h)
 
   if (! isfigure (h))
diff --git a/scripts/gui/uitoggletool.m b/scripts/gui/uitoggletool.m
--- a/scripts/gui/uitoggletool.m
+++ b/scripts/gui/uitoggletool.m
@@ -12,29 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uitoggletool ("Name", value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uitoggletool (@var{parent}, "Name", value, @dots{})
+## @deftypefn  {Function File} {@var{hui} =} uitoggletool ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{hui} =} uitoggletool (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
-function handle = uitoggletool (varargin)
+function hui = uitoggletool (varargin)
 
-  [h, args] = __uiobject_split_args__ ("uitoggletool", varargin, {"uitoolbar"}, 0);
+  [h, args] = __uiobject_split_args__ ("uitoggletool", varargin,
+                                       {"uitoolbar"}, 0);
   if (isempty (h))
     h = findobj (gcf, "-depth", 1, "type", "uitoolbar");
     if (isempty (h))
       h = uitoolbar ();
     else
       h = h(1);
     endif
   endif
-  handle = __go_uitoggletool__ (h, args{:});
+  hui = __go_uitoggletool__ (h, args{:});
 
 endfunction
 
diff --git a/scripts/gui/uitoolbar.m b/scripts/gui/uitoolbar.m
--- a/scripts/gui/uitoolbar.m
+++ b/scripts/gui/uitoolbar.m
@@ -12,21 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uitoolbar ("Name", value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uitoolbar (@var{parent}, "Name", value, @dots{})
+## @deftypefn  {Function File} {@var{hui} =} uitoolbar ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{hui} =} uitoolbar (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
-function handle = uitoolbar (varargin)
+function hui = uitoolbar (varargin)
 
   [h, args] = __uiobject_split_args__ ("uitoolbar", varargin, {"figure"});
-  handle = __go_uitoolbar__ (h, args{:});
+  hui = __go_uitoolbar__ (h, args{:});
 
 endfunction
 
diff --git a/scripts/gui/uiwait.m b/scripts/gui/uiwait.m
--- a/scripts/gui/uiwait.m
+++ b/scripts/gui/uiwait.m
@@ -16,19 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} uiwait
 ## @deftypefnx {Function File} {} uiwait (@var{h})
 ## @deftypefnx {Function File} {} uiwait (@var{h}, @var{timeout})
 ## Suspend program execution until the figure with handle @var{h} is
-## deleted or @code{uiresume} is called.  When no figure handle is specified,
-## this function uses the current figure.
+## deleted or @code{uiresume} is called.
 ##
+## When no figure handle is specified this function uses the current figure.
 ## If the figure handle is invalid or there is no current figure, this
 ## functions returns immediately.
 ##
 ## When specified, @var{timeout} defines the number of seconds to wait
 ## for the figure deletion or the @code{uiresume} call.  The timeout value
 ## must be at least 1.  If a smaller value is specified, a warning is issued
 ## and a timeout value of 1 is used instead.  If a non-integer value is
 ## specified, it is truncated towards 0.  If @var{timeout} is not specified,
diff --git a/scripts/gui/waitbar.m b/scripts/gui/waitbar.m
--- a/scripts/gui/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -185,14 +185,14 @@ endfunction
 %!   pause (0.5);
 %!   waitbar (i/4, h2);
 %!   pause (0.5);
 %! end
 %! pause (0.5);
 %! close (h1);
 %! close (h2);
 
-%% Test input validation
+## Test input validation
 %!error <FRAC must be between 0 and 1> waitbar (-0.5)
 %!error <FRAC must be between 0 and 1> waitbar (1.5)
 %!error <MSG must be a character string> waitbar (0.5, struct ())
 %!error <invalid number of property/value pairs> waitbar (0.5, "msg", "Name")
 
diff --git a/scripts/gui/waitforbuttonpress.m b/scripts/gui/waitforbuttonpress.m
--- a/scripts/gui/waitforbuttonpress.m
+++ b/scripts/gui/waitforbuttonpress.m
@@ -44,12 +44,12 @@ function b = waitforbuttonpress ()
     else
       b = 1;
     endif
   endif
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error waitforbuttonpress (1)
 %!error [a,b,c] = waitforbuttonpress ()
 
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -49,17 +49,17 @@ function retval = doc (fname)
       else
         error ("doc: expecting argument to be a character string");
       endif
     else
       fname = "";
     endif
 
     ## if GUI is running, let it display the function
-    if isguirunning ()
+    if (isguirunning ())
       __octave_link_show_doc__ (fname);
     else
 
       if (ftype == 2 || ftype == 3)
         ffile = which (fname);
       else
         ffile = "";
       endif
diff --git a/scripts/help/doc_cache_create.m b/scripts/help/doc_cache_create.m
--- a/scripts/help/doc_cache_create.m
+++ b/scripts/help/doc_cache_create.m
@@ -119,17 +119,17 @@ function cache = gen_doc_cache_in_dir (d
 
   ## If 'directory' is not in the current path, add it so we search it
   dir_in_path = ismember (directory, ostrsplit (path (), pathsep ()));
 
   ## dirs not in path
   if (! iscell (directory))
     directory = {directory};
   endif
-  dirs_notpath = {directory{!dir_in_path}};
+  dirs_notpath = {directory{! dir_in_path}};
 
   ## add them
   if (! isempty (dirs_notpath))
     addpath (dirs_notpath{:});
   endif
 
   ## create cache
   func = @(s_) create_cache (__list_functions__ (s_));
@@ -150,12 +150,12 @@ function cache = gen_builtin_cache ()
   keywords = __keywords__ ();
   builtins = __builtins__ ();
   list = {operators{:}, keywords{:}, builtins{:}};
 
   cache = create_cache (list);
 endfunction
 
 
-%% No true tests desirable for this function.
-%% Test input validation
+## No true tests desirable for this function.
+## Test input validation
 %!error doc_cache_create (1)
 
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 function [text, status] = get_first_help_sentence (name, max_len = 80)
   ## Check input
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  if (!ischar (name))
+  if (! ischar (name))
     error ("get_first_help_sentence: NAME must be a string");
   endif
 
   if (! isnumeric (max_len) || max_len <= 0 || max_len != fix (max_len))
     error ("get_first_help_sentence: MAX_LEN must be positive integer");
   endif
 
   ## First, we get the raw help text
@@ -87,17 +87,18 @@ function [text, status] = first_sentence
   ## in capturing the first newline).
   line_end_idx = regexp (help_text, "\n\n", "once") - 1;
   text = help_text (1:min ([period_idx; line_end_idx; max_len; length(help_text)]));
   status = 0;
 endfunction
 
 ## This function extracts the first sentence from a Texinfo help text.
 ## The function works by removing @def* from the texinfo text. After this, we
-## render the text to plain text using makeinfo, and then extract the first line.
+## render the text to plain text using makeinfo, and then extract the first
+## line.
 function [text, status] = first_sentence_texinfo (help_text, max_len)
   ## Lines ending with "@\n" are continuation lines, so they should be
   ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
 
   ## Find, and remove, lines that start with @def. This should remove things
   ## such as @deftypefn, @deftypefnx, @defvar, etc.
   keep = true (size (help_text));
@@ -149,16 +150,16 @@ function [text, status] = first_sentence
   ## Extract first line with plain text method.
   text = first_sentence_plain_text (help_text, max_len);
 endfunction
 
 
 %!assert (get_first_help_sentence ('get_first_help_sentence'), ...
 %!        "Return the first sentence of a function's help text.")
 
-%% Test input validation
+## Test input validation
 %!error get_first_help_sentence ()
 %!error get_first_help_sentence (1, 2, 3)
 %!error <NAME must be a string> get_first_help_sentence (1)
 %!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", "a")
 %!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 0)
 %!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 80.1)
 
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -108,17 +108,17 @@ function [retval, status] = get_usage_te
   ## corresponding @end's.
   def_idx = strfind (help_text, "@def");
   if (! isempty (def_idx))
     endf_idx = strfind (help_text, "@end def");
     def_idx = sort ([def_idx, endf_idx]);
     endl_idx = find (help_text == "\n");
     buffer = "";
     for k = 1:length (def_idx)
-      endl = endl_idx (find (endl_idx > def_idx(k), 1));
+      endl = endl_idx(find (endl_idx > def_idx(k), 1));
       if (isempty (endl))
         buffer = strcat (buffer, help_text (def_idx(k):end), "\n");
       else
         buffer = strcat (buffer, help_text (def_idx(k):endl));
       endif
     endfor
   else
     [retval, status] = get_usage_plain_text (help_text, max_len);
diff --git a/scripts/help/private/__strip_html_tags__.m b/scripts/help/private/__strip_html_tags__.m
--- a/scripts/help/private/__strip_html_tags__.m
+++ b/scripts/help/private/__strip_html_tags__.m
@@ -45,38 +45,38 @@ endfunction
 ## This function removes end-lines (\n) that makes printing look bad
 function text = strip_superfluous_endlines (text)
   ## Find groups of end-lines
   els = find (text == "\n");
   dels = diff (els);
   groups = [els(1), 1]; # list containing [start, length] of each group
   for k = 1:length (dels)
     if (dels (k) == 1)
-      groups (end, 2) ++;
+      groups(end, 2) ++;
     else
-      groups (end+1, 1:2) = [els(k+1), 1];
+      groups(end+1, 1:2) = [els(k+1), 1];
     endif
   endfor
 
   keep = true (size (text));
 
   ## Remove end-lines in the beginning
   if (groups (1, 1) == 1)
-    keep (1:groups (1, 2)) = false;
+    keep(1:groups (1, 2)) = false;
   endif
 
   ## Remove end-lines from the end
-  if (sum (groups (end, :)) - 1 == length (text))
-    keep (groups (end, 1):end) = false;
+  if (sum (groups(end, :)) - 1 == length (text))
+    keep(groups(end, 1):end) = false;
   endif
 
   ## Remove groups of end-lines with more than 3 end-lines next to each other
   idx = find (groups (:, 2) >= 3);
   for k = 1:length (idx)
-    start = groups (idx (k), 1);
-    stop = start + groups (idx (k), 2) - 1;
-    keep (start+2:stop) = false;
+    start = groups(idx(k), 1);
+    stop = start + groups(idx(k), 2) - 1;
+    keep(start+2:stop) = false;
   endfor
 
   ## Actually remove the elements
   text = text (keep);
 endfunction
 
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -48,14 +48,15 @@ function map = autumn (n = rows (colorma
     b = zeros (n, 1);
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'autumn' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (autumn (64));
 
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -75,14 +75,15 @@ function map = bone (n = rows (colormap 
 
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'bone' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (bone (64));
 
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -47,14 +47,15 @@ function map = cool (n = rows (colormap 
     b = ones (n, 1);
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'cool' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (cool (64));
 
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -50,14 +50,15 @@ function map = copper (n = rows (colorma
     b = 0.4975 * x;
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'copper' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (copper (64));
 
diff --git a/scripts/image/cubehelix.m b/scripts/image/cubehelix.m
--- a/scripts/image/cubehelix.m
+++ b/scripts/image/cubehelix.m
@@ -74,14 +74,15 @@ function map = cubehelix (n = rows (colo
   elseif (n > 0)
     map = [0, 0, 0];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! subplot (1, 2, 1)
 %! rgbplot (cubehelix (256), "composite")
 %! subplot (1, 2, 2)
 %! rgbplot (cubehelix (256))
 
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -45,14 +45,15 @@ function map = flag (n = rows (colormap 
     C = [1, 0, 0; 1, 1, 1; 0, 0, 1; 0, 0, 0];
     map = C(rem (0:(n-1), 4) + 1, :);
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'flag' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (flag (64));
 
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -43,14 +43,15 @@ function map = gmap40 (n = rows (colorma
     C = [1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1];
     map = C(rem (0:(n-1), 6) + 1, :);
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'gmap40' colormap as an image
 %! image (1:6, linspace (0, 1, 6), repmat ((1:6)', 1, 6));
 %! axis ([1, 6, 0, 1], "ticy", "xy");
 %! colormap (gmap40 (6));
 
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -48,14 +48,15 @@ function map = gray (n = rows (colormap 
     gr = [0:(n-1)]' / (n - 1);
     map = [gr, gr, gr];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'gray' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (gray (64));
 
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -50,17 +50,18 @@ function [I, map] = gray2ind (I, n = 64)
   endif
 
   ## default n is different if image is logical
   if (nargin == 1 && islogical (I))
     n = 2;
   endif
 
   cls = class (I);
-  if (! any (strcmp (cls, {"logical", "uint8", "uint16", "int16", "single", "double"})))
+  if (! any (strcmp (cls, {"logical", "uint8", "uint16", "int16", ...
+                           "single", "double"})))
     error ("gray2ind: invalid data type '%s'", cls);
   elseif (isfloat (I) && (min (I(:) < 0) || max (I(:) > 1)))
     error ("gray2ind: floating point images may only contain values between 0 and 1");
   endif
 
   map = gray (n);
 
   ## Set up scale factor
@@ -98,17 +99,17 @@ endfunction
 %!assert (gray2ind ([0 (1/511) (1/510) 1-(1/509) 1-(1/510) 1], 256),
 %!        uint8 ([0 0 1 254 255 255]))
 
 %!test
 %! assert (class (gray2ind ([0.0 0.5 1.0], 255)), "uint8")
 %! assert (class (gray2ind ([0.0 0.5 1.0], 256)), "uint8")
 %! assert (class (gray2ind ([0.0 0.5 1.0], 257)), "uint16")
 
-%% Test input validation
+## Test input validation
 %!error gray2ind ()
 %!error gray2ind (1,2,3)
 %!error <I must be a grayscale or binary image> gray2ind ({1})
 %!error <I must be a grayscale or binary image> gray2ind ([1+i])
 %!error <I must be a grayscale or binary image> gray2ind (sparse ([1]))
 %!error <N must be a positive integer> gray2ind (1, ones (2,2))
 %!error <N must be a positive integer> gray2ind (1, 0)
 %!error <N must be a positive integer> gray2ind (1, 65537)
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -63,14 +63,15 @@ function map = hot (n = rows (colormap (
 
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'hot' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (hot (64));
 
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -50,14 +50,15 @@ function map = hsv (n = rows (colormap (
     hue = [0:n-1]' / n;
     map = hsv2rgb ([hue, ones(n,1), ones(n,1)]);
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'hsv' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (hsv (64));
 
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -101,29 +101,29 @@ function rgb_map = hsv2rgb (hsv_map)
   ## If input was an image, convert it back into one.
   if (is_image)
     rgb_map = reshape (rgb_map, sz);
   endif
 
 endfunction
 
 
-%% Test pure colors
+## Test pure colors
 %!assert (hsv2rgb ([0 1 1]), [1 0 0])
 %!assert (hsv2rgb ([1 1 1]), [1 0 0])
 %!assert (hsv2rgb ([1/3 1 1]), [0 1 0])
 %!assert (hsv2rgb ([2/3 1 1]), [0 0 1])
 
 %!test
 %! hsv_map = rand (64, 3);
 %! assert (rgb2hsv (hsv2rgb (hsv_map)), hsv_map, 1e-6);
 
 %!test
 %! hsv_img = rand (64, 64, 3);
 %! assert (rgb2hsv (hsv2rgb (hsv_img)), hsv_img, 1e-6);
 
-%% Test input validation
+## Test input validation
 %!error hsv2rgb ()
 %!error hsv2rgb (1,2)
 %!error <invalid data type> hsv2rgb ({1})
 %!error <must be a matrix of size Nx3> hsv2rgb (ones (2,2))
 %!error <must be a matrix of size Nx3> hsv2rgb (sparse (ones(1,3)))
 
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -100,17 +100,19 @@
 
 function [img, varargout] = imread (filename, varargin)
   if (nargin < 1)
     print_usage ();
   elseif (! ischar (filename))
     error ("imread: FILENAME must be a string");
   endif
 
-  [img, varargout{1:nargout-1}] = imageIO ("imread", @__imread__, "read", filename, varargin{:});
+  [img, varargout{1:nargout-1}] = ...
+    imageIO ("imread", @__imread__, "read", filename, varargin{:});
+
 endfunction
 
 
 %!testif HAVE_MAGICK
 %! vpng = [ ...
 %!  137,  80,  78,  71,  13,  10,  26,  10,   0,   0, ...
 %!    0,  13,  73,  72,  68,  82,   0,   0,   0,   3, ...
 %!    0,   0,   0,   3,   8,   2,   0,   0,   0, 217, ...
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -203,17 +203,18 @@ function h = imshow (im, varargin)
   ##endif
 
   if (truecolor || indexed)
     htmp = image (xdata, ydata, im);
   else
     htmp = imagesc (xdata, ydata, im, display_range);
     set (gca (), "clim", display_range);
   endif
-  set (gca (), "visible", "off", "view", [0, 90], "ydir", "reverse", "layer", "top");
+  set (gca (), "visible", "off", "view", [0, 90],
+               "ydir", "reverse", "layer", "top");
   axis ("image");
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
@@ -250,17 +251,17 @@ endfunction
 %! clf;
 %! imshow (100*rand (100, 100, 3));
 
 %!demo
 %! clf;
 %! imshow (rand (100, 100));
 %! colormap (jet (64));
 
-%% Test input validation
+## Test input validation
 %!error imshow ()
 %!error <IM must be an image> imshow ({"cell"})
 %!error <TrueColor image must be uint8> imshow (ones (3,3,3, "uint32"))
 %!error <TrueColor image must be uint8> imshow (ones (3,3,3, "int16"))
 %!error <expecting MxN or MxNx3 matrix> imshow (ones (4,4,4))
 
 %!test
 %! hf = figure ("visible", "off");
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -109,17 +109,17 @@ function imwrite (varargin)
              ext);
     __imwrite__ (varargin{:});
   else
     fmt.write (varargin{:});
   endif
 
 endfunction
 
-%% Test input validation
+## Test input validation
 %!error imwrite ()                            # Wrong # of args
 %!error imwrite (1)                           # Wrong # of args
 %!error imwrite ({"cell"}, "filename.jpg")    # Wrong class for img
 %!error imwrite (1, [], "filename.jpg")       # Empty image map
 %!error imwrite (1, 2, 3)                     # No filename specified
 %!error imwrite (1, "filename")               # No fmt specified
 %!error imwrite (1, "filename", "junk")       # Invalid fmt specified
 %!error imwrite ([], "filename.jpg")          # Empty img matrix
@@ -187,17 +187,17 @@ endfunction
 %!testif HAVE_MAGICK
 %! rgb   = randi (255, 10, 10, 3, 5, "uint8");
 %! alpha = randi (255, 10, 10, 1, 5, "uint8");
 %! [r, ~, a] = write_and_read (".tif", rgb, "Alpha", alpha);
 %! assert (r, rgb)
 %! assert (a, alpha)
 
 %!testif HAVE_MAGICK
-%! gray   = repmat (uint8 (0:255), 100, 1);
+%! gray = repmat (uint8 (0:255), 100, 1);
 %! [g] = write_and_read (".jpeg", gray);
 %! assert (g, gray, 2)
 
 %!testif HAVE_MAGICK
-%! gray   = repmat (uint8 (0:255), 100, 1);
+%! gray = repmat (uint8 (0:255), 100, 1);
 %! [g] = write_and_read (".jpeg", gray, "quality", 100);
 %! assert (g, gray)
 
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -68,17 +68,17 @@ endfunction
 
 
 %!shared i2g
 %! i2g = ind2gray (1:100, gray (100));
 %!
 %!assert (i2g, 0:1/99:1, eps)
 %!assert (gray2ind (i2g, 100), uint8 (0:99))
 
-%% Test input validation
+## Test input validation
 %!error ind2gray ()
 %!error ind2gray (1)
 %!error ind2gray (1,2,3)
 %!error <X must be an indexed image> ind2gray (ones (3,3,3), jet (64))
 %!error <X must be an indexed image> ind2gray (1+i, jet (64))
 %!error <X must be an indexed image> ind2gray (sparse (1), jet (64))
 %!error <X must be an indexed image> ind2gray (1.1, jet (64))
 %!error <X must be an indexed image> ind2gray ({1}, jet (64))
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -54,17 +54,18 @@ function [R, G, B] = ind2rgb (x, map)
   G = reshape (map(x(:), 2), sz);
   B = reshape (map(x(:), 3), sz);
 
   ## Use ND array if only one output is requested.
   if (nargout <= 1)
     if (ndims (x) == 2)
       R = reshape ([R(:); G(:); B(:)], [sz, 3]);
     elseif (ndims (x) == 4)
-      R = permute (reshape ([R(:); G(:); B(:)], [sz(1) sz(2) sz(4) 3]), [1 2 4 3]);
+      R = permute (reshape ([R(:); G(:); B(:)], [sz(1) sz(2) sz(4) 3]), ...
+                   [1 2 4 3]);
     else
       ## we should never reach here since ind2x() should filter them out
       error ("ind2rgb: an indexed image must have 2 or 4 dimensions.");
     endif
   endif
 
 endfunction
 
@@ -92,17 +93,17 @@ endfunction
 %! assert (ergb, rgb);
 %!test
 %! ## Check that values below lower bound are mapped to first color value
 %! warning ("off", "Octave:ind2rgb:invalid-idx-img", "local");
 %! rgb = ind2rgb ([-1 0 2], gray (64));
 %! assert (rgb(:,1:2,:), zeros (1,2,3));
 %! assert (rgb(:,3,:), 1/63 * ones (1,1,3));
 
-%% Test input validation
+## Test input validation
 %!error ind2rgb ()
 %!error ind2rgb (1,2,3)
 %!error <X must be an indexed image> ind2rgb (ones (3,3,3), jet (64))
 %!error <X must be an indexed image> ind2rgb (1+i, jet (64))
 %!error <X must be an indexed image> ind2rgb (sparse (1), jet (64))
 %!error <X must be an indexed image> ind2rgb (1.1, jet (64))
 %!error <X must be an indexed image> ind2rgb ({1}, jet (64))
 %!error <MAP must be a valid colormap> ind2rgb (1, {1})
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -82,14 +82,15 @@ function map = jet (n = rows (colormap (
 
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'jet' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (jet (64));
 
diff --git a/scripts/image/lines.m b/scripts/image/lines.m
--- a/scripts/image/lines.m
+++ b/scripts/image/lines.m
@@ -45,14 +45,15 @@ function map = lines (n = rows (colormap
     nr = rows (C);
     map = C(rem (0:(n-1), nr) + 1, :);
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'lines' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (lines (64));
 
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -76,27 +76,27 @@ function rgb = ntsc2rgb (yiq)
   ## If input was an image, convert it back into one.
   if (is_image)
     rgb = reshape (rgb, sz);
   endif
 
 endfunction
 
 
-%% Test pure R, G, B colors
+## Test pure R, G, B colors
 %!assert (ntsc2rgb ([.299  .596  .211]), [1 0 0], 1e-5)
 %!assert (ntsc2rgb ([.587 -.274 -.523]), [0 1 0], 1e-5)
 %!assert (ntsc2rgb ([.114 -.322  .312]), [0 0 1], 1e-5)
 
 %!test
 %! rgb_map = rand (64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_map)), rgb_map, 1e-3);
 
 %!test
 %! rgb_img = rand (64, 64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_img)), rgb_img, 1e-3);
 
-%% Test input validation
+## Test input validation
 %!error ntsc2rgb ()
 %!error ntsc2rgb (1,2)
 %!error <YIQ must be of type double> ntsc2rgb (uint8 (1))
 %!error <must be a matrix of size Nx3 or NxMx3> ntsc2rgb (ones (2,2))
 
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -57,14 +57,15 @@ function map = ocean (n = rows (colormap
 
     map = [r, g, b] / (n - 1);
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'ocean' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (ocean (64));
 
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -63,14 +63,15 @@ function map = pink (n = rows (colormap 
 
     map = sqrt ([r, g, b]);
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'pink' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (pink (64));
 
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -45,14 +45,15 @@ function map = prism (n = rows (colormap
     C = [1, 0, 0; 1, 1/2, 0; 1, 1, 0; 0, 1, 0; 0, 0, 1; 2/3, 0, 1];
     map = C(rem (0:(n-1), 6) + 1, :);
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'prism' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (prism (64));
 
diff --git a/scripts/image/private/__imread__.m b/scripts/image/private/__imread__.m
--- a/scripts/image/private/__imread__.m
+++ b/scripts/image/private/__imread__.m
@@ -63,21 +63,22 @@ function varargout = __imread__ (filenam
   endif
 
   if (rem (numel (varargin) - offset + 1, 2) != 0)
     error ("imread: no pair for all arguments (odd number left over)");
   endif
 
   ## Check key/value options.
   indexes = cellfun ("isclass", varargin, "char");
-  indexes(indexes) &= ismember (tolower (varargin(indexes)), {"frames", "index"});
+  indexes(indexes) &= ismember (tolower (varargin(indexes)),
+                                {"frames", "index"});
   indexes = find (indexes);
   if (indexes)
     options.index = varargin{indexes+1};
-    if (! (is_valid_index_option (options.index)) &&
+    if (! is_valid_index_option (options.index) &&
         ! (ischar (options.index) && strcmpi (options.index, "all")))
       error ("imread: value for %s must be a vector or the string `all'");
     endif
   endif
 
   ## Use information from the first image to be read to set defaults.
   if (ischar (options.index) && strcmpi (options.index, "all"))
     info = __magick_ping__ (filename, 1);
diff --git a/scripts/image/private/__imwrite__.m b/scripts/image/private/__imwrite__.m
--- a/scripts/image/private/__imwrite__.m
+++ b/scripts/image/private/__imwrite__.m
@@ -75,40 +75,43 @@ function __imwrite__ (img, varargin)
         endif
         options.delaytime *= 100; # convert to 1/100ths of second
         if (isscalar (options.delaytime))
           options.delaytime(1:size (img, 4)) = options.delaytime;
         elseif (size (img, 4) != numel (options.delaytime))
           error ("imwrite: value for %s must either be a scalar or the number of frames",
                  param_list{idx});
         endif
-        if (any (options.delaytime(:) < 0) || any (options.delaytime(:) > 65535))
+        if (any (options.delaytime(:) < 0)
+            || any (options.delaytime(:) > 65535))
           error ("imwrite: value for %s must be between 0 and 655.35 seconds",
                  param_list{idx});
         endif
 
       case "disposalmethod"
         options.disposalmethod = param_list{idx+1};
         if (! ischar (options.disposalmethod) &&
             ! iscellstr (options.disposalmethod))
           error ("imwrite: value for %s must be a string or cell array of strings",
                  param_list{idx});
         elseif (! iscell (options.disposalmethod))
           options.disposalmethod = {options.disposalmethod};
         endif
         options.disposalmethod = tolower (options.disposalmethod);
         matches = ismember (options.disposalmethod,
-                            {"donotspecify", "leaveinplace", "restorebg", "restoreprevious"});
+                            {"donotspecify", "leaveinplace", ...
+                             "restorebg", "restoreprevious"});
         if (any (! matches))
           error ("imwrite: unknow method %s for option %s",
                  options.disposalmethod{find (! matches, 1)},
                  param_list{idx});
         endif
         if (isscalar (options.disposalmethod))
-          options.disposalmethod = repmat (options.disposalmethod, 1, size (img, 4));
+          options.disposalmethod = repmat (options.disposalmethod, ...
+                                           1, size (img, 4));
         elseif (numel (options.disposalmethod) != size (img, 4))
           error ("imwrite: if value %s is a cell array must have same length as number of frames",
                  param_list{idx});
         endif
 
       case "loopcount"
         options.loopcount = param_list{idx+1};
         if (! isscalar (options.loopcount) || ! isnumeric (options.loopcount)
diff --git a/scripts/image/private/imwrite_filename.m b/scripts/image/private/imwrite_filename.m
--- a/scripts/image/private/imwrite_filename.m
+++ b/scripts/image/private/imwrite_filename.m
@@ -29,17 +29,18 @@
 ## to be used, the only part that imwrite actually needs.
 
 function [filename, ext, cmap, options] = imwrite_filename (varargin)
 
   ## First, we check if the first argument is a colormap or a filename.
   cmap = [];
   if (ischar (varargin{1}))
     filename_idx = 1;
-  elseif (numel (varargin) >= 2 && iscolormap (varargin{1}) && ischar (varargin{2}))
+  elseif (numel (varargin) >= 2
+          && iscolormap (varargin{1}) && ischar (varargin{2}))
     filename_idx = 2;
     cmap = varargin{1};
   else
     error ("imwrite: no FILENAME specified");
   endif
   filename = tilde_expand (varargin{filename_idx});
 
   ## Next, we get the file extension.
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -61,14 +61,15 @@ function map = rainbow (n = rows (colorm
 
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'rainbow' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (rainbow (64));
 
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -104,28 +104,28 @@ function hsv_map = rgb2hsv (rgb)
   ## If input was an image, convert it back into one.
   if (is_image)
     hsv_map = reshape (hsv_map, sz);
   endif
 
 endfunction
 
 
-%% Test pure colors and gray
+## Test pure colors and gray
 %!assert (rgb2hsv ([1 0 0]), [0 1 1])
 %!assert (rgb2hsv ([0 1 0]), [1/3 1 1])
 %!assert (rgb2hsv ([0 0 1]), [2/3 1 1])
 %!assert (rgb2hsv ([0.5 0.5 0.5]), [0 0 0.5])
 
 %!test
 %! rgb_map = rand (64, 3);
 %! assert (hsv2rgb (rgb2hsv (rgb_map)), rgb_map, 1e-6);
 
 %!test
 %! rgb_img = rand (64, 64, 3);
 %! assert (hsv2rgb (rgb2hsv (rgb_img)), rgb_img, 1e-6);
 
-%% Test input validation
+## Test input validation
 %!error rgb2hsv ()
 %!error rgb2hsv (1,2)
 %!error <invalid data type 'cell'> rgb2hsv ({1})
 %!error <must be a matrix of size Nx3> rgb2hsv (ones (2,2))
 
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -94,17 +94,17 @@ function [x, map] = rgb2ind (R, G, B)
   elseif (rows (map) < 65536)
     x = uint16 (x - 1);
   else
     ## leave it as double
   endif
 
 endfunction
 
-%% Test input validation
+## Test input validation
 %!error rgb2ind ()
 %!error rgb2ind (1,2,3,4,5,6,7)
 %!error <RGB> rgb2ind (rand (10, 10, 4))
 
 ## FIXME: the following tests simply make sure that rgb2ind and ind2rgb
 ##        reverse each other. We should have better tests for this.
 
 ## Typical usage
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -92,27 +92,27 @@ function yiq = rgb2ntsc (rgb)
   ## If input was an image, convert it back into one.
   if (is_image)
     yiq = reshape (yiq, sz);
   endif
 
 endfunction
 
 
-%% Test pure RED, GREEN, BLUE colors
+## Test pure RED, GREEN, BLUE colors
 %!assert (rgb2ntsc ([1 0 0]), [.299  .596  .211])
 %!assert (rgb2ntsc ([0 1 0]), [.587 -.274 -.523])
 %!assert (rgb2ntsc ([0 0 1]), [.114 -.322  .312])
 
 %!test
 %! rgb_map = rand (64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_map)), rgb_map, 1e-3);
 
 %!test
 %! rgb_img = rand (64, 64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_img)), rgb_img, 1e-3);
 
-%% Test input validation
+## Test input validation
 %!error rgb2ntsc ()
 %!error rgb2ntsc (1,2)
 %!error <invalid data type 'cell'> rgb2ntsc ({1})
 %!error <must be a matrix of size Nx3 or NxMx3> rgb2ntsc (ones (2,2))
 
diff --git a/scripts/image/rgbplot.m b/scripts/image/rgbplot.m
--- a/scripts/image/rgbplot.m
+++ b/scripts/image/rgbplot.m
@@ -78,15 +78,15 @@ endfunction
 
 %!demo
 %! clf;
 %! subplot (1, 2, 1);
 %! rgbplot (ocean, "profile");
 %! subplot (1, 2, 2);
 %! rgbplot (ocean, "composite");
 
-%% Test input validation
+## Test input validation
 %!error rgbplot ()
 %!error rgbplot (1,2)
 %!error <CMAP must be a valid colormap> rgbplot ({0 1 0})
 %!error <STYLE must be a string> rgbplot ([0 1 0], 2)
 %!error <unknown style 'nostyle'> rgbplot ([0 1 0], "nostyle")
 
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -47,14 +47,15 @@ function map = spring (n = rows (colorma
     b = 1 - g;
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'spring' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (spring (64));
 
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -48,14 +48,15 @@ function map = summer (n = rows (colorma
     b = 0.4 * ones (n, 1);
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'summer' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (summer (64));
 
diff --git a/scripts/image/white.m b/scripts/image/white.m
--- a/scripts/image/white.m
+++ b/scripts/image/white.m
@@ -37,14 +37,15 @@ function map = white (n = rows (colormap
   elseif (! isscalar (n))
     error ("white: N must be a scalar");
   endif
 
   map = ones (n, 3);
 
 endfunction
 
+
 %!demo
 %! ## Show the 'white' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (white (64));
 
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -47,14 +47,15 @@ function map = winter (n = rows (colorma
     b = 1 - g / 2;
     map = [r, g, b];
   else
     map = zeros (0, 3);
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'winter' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
 %! colormap (winter (64));
 
diff --git a/scripts/io/csvread.m b/scripts/io/csvread.m
--- a/scripts/io/csvread.m
+++ b/scripts/io/csvread.m
@@ -30,12 +30,12 @@
 ## @seealso{csvwrite, dlmread, dlmwrite}
 ## @end deftypefn
 
 function x = csvread (filename, varargin)
   x = dlmread (filename, ",", varargin{:});
 endfunction
 
 
-%% Tests for csvread() are in csvwrite()
-%% Mark file as being tested
+## Tests for csvread() are in csvwrite()
+## Mark file as being tested
 %!assert (1)
 
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -51,13 +51,13 @@ endfunction
 %! fname = tempname ();
 %! fid = fopen (fname, "w");
 %! fprintf (fid, "%s\n", cstr{:});
 %! fclose (fid);
 %! str = fileread (fname);
 %! unlink (fname);
 %! assert (str, [cstr{1} "\n" cstr{2} "\n" cstr{3} "\n"]);
 
-%% Test input validation
+## Test input validation
 %!error fileread ()
 %!error fileread (1, 2)
 %!error <FILENAME argument must be a string> fileread (1)
 
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -124,18 +124,18 @@ function [output, delimiter, header_rows
         output = xlsread (fname);
       end_try_catch
     case {".wav", ".wave"}
       delimiter = NaN;
       header_rows = 0;
       [output.data, output.fs] = wavread (fname);
     otherwise
       ## Assume the file is in ASCII format.
-      [output, delimiter, header_rows]  = ...
-          importdata_ascii (fname, delimiter, header_rows);
+      [output, delimiter, header_rows] = ...
+        importdata_ascii (fname, delimiter, header_rows);
   endswitch
 
   ## If there are any empty fields in the output structure, then remove them
   if (isstruct (output) && numel (output) == 1)
     fields = fieldnames (output);
     for i=1:length (fields)
       if (isempty (output.(fields{i})))
         output = rmfield (output, fields{i});
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -488,19 +488,20 @@ function varargout = strread (str, forma
 
   ## If needed, split up columns in three steps:
   if (! isempty (idy))
     ## Try-catch because complexity of strings to read can be infinite
     try
 
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
-      ## Alternative below goes by simply parsing a first grab of words
-      ## and matching fmt_words to words until the fmt_words array is exhausted.
-      ## iwrd: ptr to current analyzed word; iwrdp: ptr to pos before analyzed char
+      ## Alternative below goes by simply parsing a first grab of words and
+      ## matching fmt_words to words until the fmt_words array is exhausted.
+      ## iwrd: ptr to current analyzed word.
+      ## iwrdp: ptr to pos before analyzed char.
       iwrd = 1; iwrdp = 0; iwrdl = length (words{1});
       fwptr = zeros (1, numel (fmt_words));
       ii = 1;
       while (ii <= numel (fmt_words))
 
         nxt_wrd = 0;
         ## Keep track of which words nr. every fmt_words{} is (starts) in.
         fwptr(ii) = iwrd;
@@ -596,39 +597,41 @@ function varargout = strread (str, forma
             s = strfind (words(icol, 1), fmt_words{ii});
             if (isempty (s{:}))
               error ("strread: Literal '%s' not found in column %d", fmt_words{ii}, icol);
             endif
             s = s{:}(1);
             e = s(1) + length (fmt_words{ii}) - 1;
           endif
           if (! strcmp (fmt_words{ii}, words{icol, 1}))
-            ## Column doesn't exactly match literal => split needed.  Insert a column
+            ## Column doesn't exactly match literal => split needed.
+            ## Insert a column
             words(icol+1:end+1, :) = words(icol:end, :);
             ## Watch out for empty cells
             jptr = find (! cellfun ("isempty", words(icol, :)));
 
             ## Distinguish leading or trailing literals
             if (! idg(ii) && ! isempty (s) && s(1) == 1)
-              ## Leading literal.  Assign literal to icol, paste rest in icol + 1
+              ## Leading literal.
+              ## Assign literal to icol, paste rest in icol + 1
               ## Apply only to those cells that do have something beyond literal
               jptr = find (cellfun ("length", words(icol+1, jptr), ...
                                     "UniformOutput", false) > e(1));
               words(icol+1, :) = {""};
-              words(icol+1, jptr) = cellfun ...
-                (@(x) substr (x, e(1)+1, length (x) - e(1)), words(icol, jptr), ...
+              words(icol+1, jptr) = cellfun (
+                @(x) substr (x, e(1)+1, length (x) - e(1)), words(icol, jptr),
                 "UniformOutput", false);
               words(icol, jptr) = fmt_words{ii};
               fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
 
             else
               if (! idg(ii) && ! isempty (strfind (fmt_words{ii-1}, "%s")))
-                ## Trailing literal.  If preceding format == '%s' this is an error
-                warning ...
-                 ("strread: ambiguous '%s' specifier next to literal in column %d", icol);
+                ## Trailing literal.
+                ## If preceding format == '%s' this is an error.
+                warning ("strread: ambiguous '%s' specifier next to literal in column %d", icol);
               elseif (idg(ii))
                 ## Current field = fixed width. Strip into icol, rest in icol+1
                 sw = regexp (fmt_words{ii}, '\d', "once");
                 ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
                 wdth = floor (str2double (fmt_words{ii}(sw:ew)));
                 words(icol+1, jptr) = cellfun (@(x) x(wdth+1:end),
                      words(icol,jptr), "UniformOutput", false);
                 if (isempty ([words(icol+1, :){:}]))
@@ -656,28 +659,30 @@ function varargout = strread (str, forma
                 ## Former trailing literal may now be leading for next specifier
                 --ii;
                 fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
               endif
             endif
           endif
 
         else
-          ## Conv. specifier.  Peek if next fmt_word needs split from current column
+          ## Conversion specifier.
+          ## Peek if next fmt_word needs split from current column.
           if (ii < num_words_per_line)
             if (fwptr(ii) == fwptr(ii+1))
               --icol;
             endif
           endif
         endif
         ## Next fmt_word, next column
         ++ii; ++icol;
       endwhile
 
-      ## Done.  Reshape words back into 1 long vector and strip padded empty words
+      ## Done.
+      ## Reshape words back into one long vector and strip padded empty words
       words = reshape (words, 1, numel (words))(1 : end-num_words_padded);
 
     catch
       warning ("strread: unable to parse text or file with given format string");
       return;
 
     end_try_catch
   endif
@@ -795,17 +800,17 @@ function out = split_by (text, sep, mult
   else
     mult_dlms_s1 = false;
   endif
 
   ## Split text string along delimiters
   out = ostrsplit (text, sep, mult_dlms_s1);
   if (index (sep, eol_char)); out = strrep (out, char (255), ''); endif
   ## In case of trailing delimiter, strip stray last empty word
-  if (!isempty (out) && any (sep == text(end)))
+  if (! isempty (out) && any (sep == text(end)))
     out(end) = [];
   endif
 
   ## Empty cells converted to empty cellstrings.
   out(cellfun ("isempty", out)) = {""};
 
 endfunction
 
@@ -845,17 +850,17 @@ endfunction
 %! str = "# comment\n# comment\n1 2 3";
 %! [a, b] = strread (str, "%n %s", "commentstyle", "shell", "endofline", "\n");
 %! assert (a, [1; 3]);
 %! assert (b, {"2"});
 
 %!test
 %! assert (strread ("Hello World! // this is comment", "%s",...
 %! "commentstyle", "c++"), ...
-%! {"Hello"; "World!"}); 
+%! {"Hello"; "World!"});
 %! assert (strread ("Hello World! % this is comment", "%s",...
 %! "commentstyle", "matlab"), ...
 %! {"Hello"; "World!"});
 %! assert (strread ("Hello World! # this is comment", "%s",...
 %! "commentstyle", "shell"), ...
 %! {"Hello"; "World!"});
 
 %!test
@@ -918,67 +923,67 @@ endfunction
 %!test
 %! ## No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
 %! [a, b] = strread (str, "Text%dText%1sText");
 %! assert (a, int32 ([1; 398; 57]));
 %! assert (b(1:2), {"2"; "4"});
 %! assert (isempty (b{3}), true);
 
-%% MultipleDelimsAsOne
+## MultipleDelimsAsOne
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
 %! [a b c d] = strread (str, "%f %f %f %f", "delimiter", ",", "multipledelimsasone", 1, "endofline", "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
-%% delimiter as sq_string and dq_string
+## delimiter as sq_string and dq_string
 %!test
 %! assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
 %!         strread ("1\n2\n3", "%d", "delimiter", '\n'))
 
-%% whitespace as sq_string and dq_string
+## whitespace as sq_string and dq_string
 %!test
 %! assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
 %!         strread ("1\b2\r3\b4\t5", "%d", "whitespace", '\b\r\n\t'))
 
 %!test
 %! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", " ", "endofline", "\n", "whitespace", " "};
-%! [a, b, c] = strread (str, fmt, args {:});
+%! [a, b, c] = strread (str, fmt, args{:});
 %! assert (a, [0.31; 0.60], 0.01)
 %! assert (b, [0.86; 0.72], 0.01)
 %! assert (c, [0.94; 0.87], 0.01)
 
 %!test
 %! str =  "0.31,0.86,0.94\n0.60,0.72,0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
-%! [a, b, c] = strread (str, fmt, args {:});
+%! [a, b, c] = strread (str, fmt, args{:});
 %! assert (a, [0.31; 0.60], 0.01)
 %! assert (b, [0.86; 0.72], 0.01)
 %! assert (c, [0.94; 0.87], 0.01)
 
 %!test
 %! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
-%! [a, b, c] = strread (str, fmt, args {:});
+%! [a, b, c] = strread (str, fmt, args{:});
 %! assert (a, [0.31; 0.60], 0.01)
 %! assert (b, [0.86; 0.72], 0.01)
 %! assert (c, [0.94; 0.87], 0.01)
 
 %!test
 %! str =  "0.31, 0.86, 0.94\n 0.60, 0.72, 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
-%! [a, b, c] = strread (str, fmt, args {:});
+%! [a, b, c] = strread (str, fmt, args{:});
 %! assert (a, [0.31; 0.60], 0.01)
 %! assert (b, [0.86; 0.72], 0.01)
 %! assert (c, [0.94; 0.87], 0.01)
 
 %!test
 %! [a, b] = strread (["Empty 1" char(10)], "Empty%s %f");
 %! assert (a{1}, '1');
 %! assert (b, NaN);
@@ -996,64 +1001,64 @@ endfunction
 %! assert (isempty (c));
 
 %!test
 %! ## bug #37023
 %! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
 %! assert (a, [1; 2], 1e-15);
 %! assert (b, [1; 3], 1e-15);
 
-%% Test for no output arg (interactive use)
+## Test for no output arg (interactive use)
 %!test
 %! assert (strread (",2,,4\n5,,7,", "", "delimiter", ","), [NaN; 2; NaN; 4; 5; NaN; 7]);
 
-%% Test #1 bug #42609
+## Test #1 bug #42609
 %!test
 %! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", "%f %f %f\n");
 %! assert (a, [1; 4; 7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
-%% Test #2 bug #42609
+## Test #2 bug #42609
 %!test
 %! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", "%f %f\n%f");
 %! assert (a, [1;4;7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
-%% Test #3 bug #42609
+## Test #3 bug #42609
 %!test
 %! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", '%f %f %f\n');
 %! assert (a, [1; 4; 7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
-%% Test #3 bug #42609
+## Test #3 bug #42609
 %!test
 %! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", '%f %f\n%f');
 %! assert (a, [1;4;7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
-%% Unsupported format specifiers
+## Unsupported format specifiers
 %!test
 %!error <format specifiers are not supported> strread ("a", "%c")
 %!error <format specifiers are not supported> strread ("a", "%*c %d")
 %!error <format specifiers are not supported> strread ("a", "%q")
 %!error <format specifiers are not supported> strread ("a", "%*q %d")
 %!error <format specifiers are not supported> strread ("a", "%[a]")
 %!error <format specifiers are not supported> strread ("a", "%*[a] %d")
 %!error <format specifiers are not supported> strread ("a", "%[^a]")
 %!error <format specifiers are not supported> strread ("a", "%*[^a] %d")
 %!error <format specifiers are not supported> strread ("a", "%d8")
 %!error <format specifiers are not supported> strread ("a", "%*d8 %s")
 %!error <format specifiers are not supported> strread ("a", "%f64")
 %!error <format specifiers are not supported> strread ("a", "%*f64 %s")
 %!error <format specifiers are not supported> strread ("a", "%u32")
 %!error <format specifiers are not supported> strread ("a", "%*u32 %d")
 
-%% Illegal format specifiers
+## Illegal format specifiers
 %!test
 %!error <no valid format conversion specifiers> strread ("1.0", "%z");
 
-%% Test for false positives in check for non-supported format specifiers
+## Test for false positives in check for non-supported format specifiers
 %!test
 %! assert (strread ("Total: 32.5 % (of cm values)","Total: %f % (of cm values)"), 32.5, 1e-5);
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -113,17 +113,18 @@ function varargout = textread (filename,
 
   endofline = find (strcmpi (varargin, "endofline"), 1);
   if (! isempty (endofline))
     ## 'endofline' option set by user.
     if (! ischar (varargin{endofline + 1}));
       error ("character value required for EndOfLine");
     endif
   else
-    ## Determine EOL from file.  Search for EOL candidates in first BUFLENGTH chars
+    ## Determine EOL from file.
+    ## Search for EOL candidates in the first BUFLENGTH chars
     eol_srch_len = min (length (str), BUFLENGTH);
     ## First try DOS (CRLF)
     if (! isempty (strfind (str(1 : eol_srch_len), "\r\n")))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
     elseif (! isempty (strfind (str(1 : eol_srch_len), "\r")))
       eol_char = "\r";
     ## Otherwise, use plain *nix (LF)
@@ -153,17 +154,17 @@ function varargout = textread (filename,
         endif
         eoi = findstr (str, eol_char);
         n_eoi += numel (eoi);
         ++nblks;
       endif
     endwhile
     ## Found EOL delimiting last requested line. Compute ptr (incl. EOL)
     if (isempty (eoi))
-      printf ("textread: format repeat count specified but no endofline found\n");
+      disp ("textread: format repeat count specified but no endofline found");
       eoi_pos = nblks * BUFLENGTH + count;
     else
       eoi_pos = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi);
     endif
     fseek (fid, st_pos, "bof");
     str = fscanf (fid, "%c", eoi_pos);
   else
     fseek (fid, st_pos, "bof");
@@ -172,17 +173,17 @@ function varargout = textread (filename,
   fclose (fid);
 
   ## Set up default whitespace param value if needed
   if (isempty (find (strcmpi ("whitespace", varargin))))
     varargin(end+1:end+2) = {"whitespace", " \b\t"};
   endif
 
   ## Call strread to make it do the real work
-  [varargout{1:max (nargout, 1)}] = strread (str, format, varargin {:});
+  [varargout{1:max (nargout, 1)}] = strread (str, format, varargin{:});
 
   ## Hack to concatenate/reshape numeric output into 2D array (undocumented ML)
   ## In ML this only works in case of an empty format string
   if (isempty (format))
     ## Get number of fields per line.
     ## 1. Get eol_char position
     iwhsp = find (strcmpi ("whitespace", varargin));
     whsp = varargin{iwhsp + 1};
@@ -197,17 +198,17 @@ function varargout = textread (filename,
       ## 3A. whitespace incl. consecutive whitespace => single space
       str = regexprep (str, sprintf ("[%s]+", whsp), ' ');
       ## 4A. Remove possible leading & trailing spaces
       str = strtrim (str);
       ## 5A. Count spaces, add one to get nr of data fields per line
       ncols = numel (strfind (str, " ")) + 1;
     else
       ## 3B. Just count delimiters. FIXME: delimiters could occur in literals
-      delimiter = varargin {idelimiter+1};
+      delimiter = varargin{idelimiter+1};
       ncols = numel (regexp (str, sprintf ("[%s]", delimiter))) + 1;
     endif
     ## 6. Reshape; watch out, we need a transpose
     nrows = ceil (numel (varargout{1}) / ncols);
     pad = mod (numel (varargout{1}), ncols);
     if (pad > 0)
       pad = ncols - pad;
       varargout{1}(end+1 : end+pad) = NaN;
@@ -233,87 +234,87 @@ endfunction
 %!test
 %! f = tempname ();
 %! d = rand (7, 2);
 %! dlmwrite (f, d, "precision", "%5.2f");
 %! [a, b] = textread (f, "%f, %f", "headerlines", 1);
 %! unlink (f);
 %! assert (a, d(2:7, 1), 1e-2);
 
-%% Test reading 2D matrix with empty format
+## Test reading 2D matrix with empty format
 %!test
 %! f = tempname ();
 %! d = rand (5, 2);
 %! dlmwrite (f, d, "precision", "%5.2f");
 %! A = textread (f, "", "headerlines", 3);
 %! unlink (f);
 %! assert (A, d(4:5, :), 1e-2);
 
-%% Read multiple lines using empty format string
+## Read multiple lines using empty format string
 %!test
 %! f = tempname ();
 %! unlink (f);
 %! fid = fopen (f, "w");
 %! d = rand (1, 4);
 %! fprintf (fid, "  %f %f   %f  %f ", d);
 %! fclose (fid);
 %! A = textread (f, "");
 %! unlink (f);
 %! assert (A, d, 1e-6);
 
-%% Empty format, corner case = one line w/o EOL
+## Empty format, corner case = one line w/o EOL
 %!test
 %! f = tempname ();
 %! unlink (f);
 %! fid = fopen (f, "w");
 %! d = rand (1, 4);
 %! fprintf (fid, "  %f %f   %f  %f ", d);
 %! fclose (fid);
 %! A = textread (f, "");
 %! unlink (f);
 %! assert (A, d, 1e-6);
 
-%% Read multiple lines using empty format string, missing data (should be 0)
+## Read multiple lines using empty format string, missing data (should be 0)
 %!test
 %! f = tempname ();
 %! unlink (f);
 %! fid = fopen (f, "w");
 %! d = rand (1, 4);
 %! fprintf (fid, "%f, %f, ,  %f,  %f ", d);
 %! fclose (fid);
 %! A = textread (f, "");
 %! unlink (f);
 %! assert (A, [ d(1:2) 0 d(3:4)], 1e-6);
 
-%% Test with empty positions - ML returns 0 for empty fields
+## Test with empty positions - ML returns 0 for empty fields
 %!test
 %! f = tempname ();
 %! unlink (f);
 %! fid = fopen (f, "w");
 %! d = rand (1, 4);
 %! fprintf (fid, ",2,,4\n5,,7,\n");
 %! fclose (fid);
 %! A = textread (f, "", "delimiter", ",");
 %! unlink (f);
 %! assert (A, [0 2 0 4; 5 0 7 0], 1e-6);
 
-%% Another test with empty format + positions, now with more incomplete lower
-%% row (must be appended with zeros to get rectangular matrix)
+## Another test with empty format + positions, now with more incomplete lower
+## row (must be appended with zeros to get rectangular matrix)
 %!test
 %! f = tempname ();
 %! unlink (f);
 %! fid = fopen (f, "w");
 %! d = rand (1, 4);
 %! fprintf (fid, ",2,,4\n5,\n");
 %! fclose (fid);
 %! A = textread (f, "", "delimiter", ",");
 %! unlink (f);
 %! assert (A, [0 2 0 4; 5 0 0 0], 1e-6);
 
-%% Test input validation
+## Test input validation
 %!error textread ()
 %!error textread (1)
 %!error <arguments must be strings> textread (1, "%f")
 %!error <arguments must be strings> textread ("fname", 1)
 %!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
 %!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
 %!error <character value required for> textread (file_in_loadpath ("textread.m"), "%s", "endofline", true)
 
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -227,17 +227,18 @@ function [C, position] = textscan (fid, 
       if (! any (strcmp (eol_char, {"", "\n", "\r", "\r\n"})))
         error ("textscan: illegal EndOfLine character value specified");
       endif
     else
       error ("textscan: character value required for EndOfLine");
     endif
   else
     if (! ischar (fid))
-    ## Determine EOL from file.  Search for EOL candidates in first BUFLENGTH chars
+    ## Determine EOL from file.
+    ## Search for EOL candidates in the first BUFLENGTH chars
     eol_srch_len = min (length (str), BUFLENGTH);
     ## First try DOS (CRLF)
     if (! isempty (strfind (str(1 : eol_srch_len), "\r\n")))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
     elseif (! isempty (strfind (str(1 : eol_srch_len), "\r")))
       eol_char = "\r";
     ## Otherwise, use plain UNIX (LF)
@@ -246,17 +247,17 @@ function [C, position] = textscan (fid, 
     endif
     else
       eol_char = "\n";
     endif
     ## Set up the default endofline param value
     args(end+1:end+2) = {"endofline", eol_char};
   endif
 
-  if (!ischar (fid))
+  if (! ischar (fid))
     ## Now that we know what EOL looks like, we can process format_repeat_count.
     ## FIXME The below isn't ML-compatible: counts lines, not format string uses
     if (isfinite (nlines) && (nlines >= 0))
       l_eol_char = length (eol_char);
       eoi = findstr (str, eol_char);
       n_eoi = length (eoi);
       nblks = 0;
       ## Avoid slow repeated str concatenation, first seek requested end of data
@@ -271,21 +272,22 @@ function [C, position] = textscan (fid, 
           endif
           eoi = findstr (str, eol_char);
           n_eoi += numel (eoi);
           ++nblks;
         endif
       endwhile
       ## OK, found EOL delimiting last requested line. Compute ptr (incl. EOL)
       if (isempty (eoi))
-        printf ("textscan: format repeat count specified but no endofline found\n");
+        disp ("textscan: format repeat count specified but no endofline found");
         data_size = nblks * BUFLENGTH + count;
       else
         ## Compute data size to read incl complete EOL
-        data_size = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi) ...
+        data_size = (nblks * BUFLENGTH) ...
+                    + eoi(end + min (nlines, n_eoi) - n_eoi) ...
                     + l_eol_char - 1;
       endif
       fseek (fid, st_pos, "bof");
       str = fscanf (fid, "%c", data_size);
     else
       fseek (fid, st_pos, "bof");
       str = fread (fid, "char=>char").';
     endif
@@ -429,111 +431,111 @@ endfunction
 %! str = [str "Km:2 = hhhRjjj miles3hour\r\n"];
 %! str = [str "Km:25 = hhhZ\r\n"];
 %! fmt = "Km:%d = hhh%1sjjj miles%dhour";
 %! a = textscan (str, fmt, "delimiter", " ");
 %! assert (a{1}', int32 ([10 15 2 25]));
 %! assert (a{2}', {'B' 'J' 'R' 'Z'});
 %! assert (a{3}', int32 ([16 241 3 0]));
 
-%% Test with default endofline parameter
+## Test with default endofline parameter
 %!test
 %! c = textscan ("L1\nL2", "%s");
 %! assert (c{:}, {"L1"; "L2"});
 
-%% Test with endofline parameter set to "" (empty) - newline should be in word
+## Test with endofline parameter set to "" (empty) - newline should be in word
 %!test
 %! c = textscan ("L1\nL2", "%s", "endofline", "");
 %! assert (int8 (c{:}{:}), int8 ([ 76,  49,  10,  76,  50 ]));
 
 %!test
 %! ## No delimiters at all besides EOL.  Skip fields, even empty fields
 %! str = "Text1Text2Text\nTextText4Text\nText57Text";
 %! c = textscan (str, "Text%*dText%dText");
 %! assert (c{1}, int32 ([2; 4; 0]));
 
+## CollectOutput test
 %!test
-%% CollectOutput test
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
 %! c = textscan (str, fmt, "collectoutput", 1);
 %! assert (size (c{3}), [10, 2]);
 %! assert (size (c{2}), [10, 2]);
 
+## CollectOutput test with uneven column length files
 %!test
-%% CollectOutput test with uneven column length files
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! str = [str "110 miles/hr"];
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
 %! c = textscan (str, fmt, "collectoutput", 1);
 %! assert (size (c{1}), [11, 1]);
 %! assert (size (c{3}), [11, 2]);
 %! assert (size (c{2}), [11, 2]);
 %! assert (c{3}(end), NaN);
 %! assert (c{2}{11, 1}, "/hr");
 %! assert (isempty (c{2}{11, 2}), true);
 
-%% Test input validation
+## Test input validation
 %!error textscan ()
 %!error textscan (single (4))
 %!error textscan ({4})
 %!error <must be a string> textscan ("Hello World", 2)
 %!error <cannot provide position information> [C, pos] = textscan ("Hello World")
 %!error <character value required> textscan ("Hello World", '%s', 'EndOfLine', 3)
 
 %! Test incomplete first data line
 %! R = textscan (['Empty1' char(10)], 'Empty%d %f');
 %! assert (R{1}, int32 (1));
 %! assert (isempty (R{2}), true);
 
-%% bug #37023 (actually a strread test)
+## bug #37023 (actually a strread test)
 %!test
 %! data = textscan("   1. 1 \n 2 3\n", '%f %f');
 %! assert (data{1}, [1; 2], 1e-15);
 %! assert (data{2}, [1; 3], 1e-15);
 
-%%  Whitespace test (bug #37333) using delimiter ";"
+## Whitespace test (bug #37333) using delimiter ";"
 %!test
 %! tc = [];
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = "C:/code/meas;";
 %! tc{1, end+1} = " C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";");
 %! for k = 1:numel (c{1})
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! end
 
-%%  Whitespace test (bug #37333), adding multipleDelimsAsOne true arg
+## Whitespace test (bug #37333), adding multipleDelimsAsOne true arg
 %!test
 %! tc = [];
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "multipleDelimsAsOne", 1);
 %! for k = 1:numel (c{1})
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! end
 
-%%  Whitespace test (bug #37333), adding multipleDelimsAsOne false arg
+## Whitespace test (bug #37333), adding multipleDelimsAsOne false arg
 %!test
 %! tc = [];
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;;";
 %! tc{1, end+1} = "";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
@@ -541,88 +543,88 @@ endfunction
 %! for k = 1:numel (c{1})
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! end
 
-%%  Whitespace test (bug #37333) whitespace "" arg
+## Whitespace test (bug #37333) whitespace "" arg
 %!test
 %! tc = [];
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "whitespace", "");
 %! for k = 1:numel (c{1})
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   assert (strcmp (lh, rh));
 %! end
 
-%%  Whitespace test (bug #37333), whitespace " " arg
+## Whitespace test (bug #37333), whitespace " " arg
 %!test
 %! tc = [];
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "whitespace", " ");
 %! for k = 1:numel (c{1})
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! end
 
-%% Test reading from a real file
+## Test reading from a real file
 %!test
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! d = rand (1, 4);
 %! fprintf (fid, "  %f %f   %f  %f ", d);
 %! fseek (fid, 0, "bof");
 %! A = textscan (fid, "%f %f");
 %! fclose (fid);
 %! unlink (f);
 %! assert (A{1}, [d(1); d(3)], 1e-6);
 %! assert (A{2}, [d(2); d(4)], 1e-6);
 
-%% Tests reading with empty format, should return proper nr of columns
+## Tests reading with empty format, should return proper nr of columns
 %!test
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! fprintf (fid, " 1 2 3 4\n5 6 7 8");
 %! fseek (fid, 0, "bof");
 %! A = textscan (fid, "");
 %! fclose (fid);
 %! unlink (f);
 %! assert (A{1}, [1 ; 5], 1e-6);
 %! assert (A{2}, [2 ; 6], 1e-6);
 %! assert (A{3}, [3 ; 7], 1e-6);
 %! assert (A{4}, [4 ; 8], 1e-6);
 
-%% Tests reading with empty format; empty fields & incomplete lower row
+## Tests reading with empty format; empty fields & incomplete lower row
 %!test
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! fprintf (fid, " ,2,,4\n5,6");
 %! fseek (fid, 0, "bof");
 %! A = textscan (fid, "", "delimiter", ",", "EmptyValue", 999, "CollectOutput" , 1);
 %! fclose (fid);
 %! unlink (f);
 %! assert (A{1}, [999, 2, 999, 4; 5, 6, 999, 999], 1e-6);
 
-%% Error message tests
+## Error message tests
 
 %!test
 %! f = tempname ();
 %! fid = fopen (f, "w+");
 %! msg1 = "Missing or illegal value for 'headerlines'";
 %! try
 %! A = textscan (fid, "", "headerlines");
 %! end_try_catch;
@@ -662,29 +664,29 @@ endfunction
 %! msg1 = "textscan: character value required for EndOfLine";
 %! try
 %! A = textscan (fid, "%f", "EndOfLine", 33);
 %! end_try_catch;
 %! fclose (fid);
 %! unlink (f);
 %! assert (msg1, lasterr);
 
-%% Bug #41824
+## Bug #41824
 %!test
 %! assert (textscan ("123", "", "whitespace", " "){:}, 123);
 
-%% Bug #42343-1, just test supplied emptyvalue (actually done by strread.m)
+## Bug #42343-1, just test supplied emptyvalue (actually done by strread.m)
 %!test
 %! assert (textscan (",NaN", "", "delimiter", "," ,"emptyValue" ,Inf), {Inf, NaN});
 
-%% Bug #42343-2, test padding with supplied emptyvalue (done by textscan.m)
+## Bug #42343-2, test padding with supplied emptyvalue (done by textscan.m)
 %!test
 %! a = textscan (",1,,4\nInf,  ,NaN", "", "delimiter", ",", "emptyvalue", -10);
 %! assert (cell2mat (a), [-10, 1, -10, 4; Inf, -10, NaN, -10]);
 
-%% Bug #42528
+## Bug #42528
 %!test
 %! assert (textscan ("1i", ""){1},  0+1i);
 %! assert (cell2mat (textscan ("3, 2-4i, NaN\n -i, 1, 23.4+2.2i", "")), [3+0i, 2-4i, NaN+0i; 0-i,  1+0i, 23.4+2.2i]);
 
-%% Illegal format specifiers
+## Illegal format specifiers
 %!test
 %!error <no valid format conversion specifiers> textscan ("1.0", "%z");
diff --git a/scripts/java/javachk.m b/scripts/java/javachk.m
--- a/scripts/java/javachk.m
+++ b/scripts/java/javachk.m
@@ -141,11 +141,11 @@ endfunction
 %!test
 %! msg = javachk ("desktop", "Java DESKTOP");
 %! assert (msg.message, "javachk: desktop is not supported");
 %! assert (msg.identifier, "Java DESKTOP");
 
 %!testif HAVE_JAVA
 %! assert (javachk ("jvm"), "");
 
-%% Test input validation
+## Test input validation
 %!error <javachk: unrecognized feature 'foobar'> javachk ("foobar")
 
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
--- a/scripts/java/javaclasspath.m
+++ b/scripts/java/javaclasspath.m
@@ -23,18 +23,18 @@
 ## @deftypefnx {Function File} {[@var{dpath}, @var{spath}] =} javaclasspath ()
 ## @deftypefnx {Function File} {@var{clspath} =} javaclasspath (@var{what})
 ## Return the class path of the Java virtual machine in the form of a cell
 ## array of strings.
 ##
 ## If called with no inputs:
 ##
 ## @itemize
-## @item If no output is requested, the dynamic and static classpaths are printed
-## to the standard output.
+## @item If no output is requested, the dynamic and static classpaths are
+## printed to the standard output.
 ##
 ## @item If one output value @var{dpath} is requested, the result is
 ## the dynamic classpath.
 ##
 ## @item If two output values@var{dpath} and @var{spath} are
 ## requested, the first variable will contain the dynamic classpath and
 ## the second will be contain the static classpath.
 ## @end itemize
@@ -60,17 +60,18 @@ function [path1, path2] = javaclasspath 
     print_usage ();
   endif
 
   ## dynamic classpath
   dynamic_path = javaMethod ("getClassPath", "org.octave.ClassHelper");
   dynamic_path_list = ostrsplit (dynamic_path, pathsep ());
 
   ## static classpath
-  static_path = javaMethod ("getProperty", "java.lang.System", "java.class.path");
+  static_path = javaMethod ("getProperty",
+                            "java.lang.System", "java.class.path");
   static_path_list = ostrsplit (static_path, pathsep ());
   if (numel (static_path_list) > 1)
     ## remove first element (which is .../octave.jar)
     static_path_list(1) = [];
   else
     static_path_list = {};
   endif
 
@@ -93,17 +94,17 @@ function [path1, path2] = javaclasspath 
     if (! nargin)
       ## This is to allow retrieval of both paths in separate variables with
       ## a single call to javaclasspath(). Matlab returns only the -dynamic
       ## path in this case but this won't break compatibility.
       path1 = cellstr (dynamic_path_list);
       path2 = cellstr (static_path_list);
     else
       switch (tolower (which))
-        case "-all",     path1 = cellstr ([static_path_list, dynamic_path_list]);
+        case "-all",     path1 = cellstr ([static_path_list,dynamic_path_list]);
         case "-dynamic", path1 = cellstr (dynamic_path_list);
         case "-static",  path1 = cellstr (static_path_list);
         otherwise
           error ("javaclasspath: invalid value for WHAT");
       endswitch
     endif
   endif
 
diff --git a/scripts/java/usejava.m b/scripts/java/usejava.m
--- a/scripts/java/usejava.m
+++ b/scripts/java/usejava.m
@@ -52,17 +52,17 @@
 function retval = usejava (feature)
 
   if (nargin != 1 || ! ischar (feature))
     print_usage ();
   endif
 
   retval = false;
 
-  switch feature
+  switch (feature)
     ## For each feature, try methods() on a Java class of a feature
     case "awt"
       try
         dum = methods ("java.awt.Frame");
         retval = true;
       end_try_catch
     case "desktop"
       ## Octave has no Java based GUI/desktop, leave retval = false
@@ -83,14 +83,14 @@ function retval = usejava (feature)
 endfunction
 
 
 %!assert (usejava ("desktop"), false)
 
 %!testif HAVE_JAVA
 %! assert (usejava ("jvm"), true);
 
-%% Test input validation
+## Test input validation
 %!error usejava ()
 %!error usejava (1, 2)
 %!error usejava (1)
 %!error <unrecognized feature> usejava ("abc")
 
diff --git a/scripts/linear-algebra/bandwidth.m b/scripts/linear-algebra/bandwidth.m
--- a/scripts/linear-algebra/bandwidth.m
+++ b/scripts/linear-algebra/bandwidth.m
@@ -93,17 +93,17 @@ endfunction
 %! assert ([a,b] == [0,0]);
 %!test
 %! [a,b] = bandwidth (zeros (3,3));
 %! assert ([a,b] == [0,0]);
 %!test
 %! [a,b] = bandwidth (ones (5,5));
 %! assert ([a,b] == [4,4]);
 
-%% Test input validation
+## Test input validation
 %!error bandwidth ()
 %!error bandwidth (1,2,3)
 %!error [a,b,c] = bandwidth (ones (2))
 %!error [a,b] = bandwidth (ones (2), "upper")
 %!error <A must be a 2-D numeric or logical> bandwidth ("string", "lower")
 %!error <A must be a 2-D numeric or logical> bandwidth (ones (3,3,3), "lower")
 %!error <TYPE must be "lower" or "upper"> bandwidth (ones (2), "uper")
 %!error <TYPE must be "lower" or "upper"> bandwidth (ones (2), "uppper")
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -85,17 +85,17 @@ function k = commutation_matrix (m, n)
       error ("commutation_matrix: N must be a positive integer");
     endif
   endif
 
   ## It is clearly possible to make this a LOT faster!
   k = zeros (m * n, m * n);
   for i = 1 : m
     for j = 1 : n
-      k ((i - 1) * n + j, (j - 1) * m + i) = 1;
+      k((i - 1) * n + j, (j - 1) * m + i) = 1;
     endfor
   endfor
 
 endfunction
 
 
 %!test
 %! c = commutation_matrix (1,1);
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -72,20 +72,20 @@ function d = duplication_matrix (n)
     error ("duplication_matrix: N must be a positive integer");
   endif
 
   d = zeros (n * n, n * (n + 1) / 2);
 
   ## It is clearly possible to make this a LOT faster!
   count = 0;
   for j = 1 : n
-    d ((j - 1) * n + j, count + j) = 1;
+    d((j - 1) * n + j, count + j) = 1;
     for i = (j + 1) : n
-      d ((j - 1) * n + i, count + i) = 1;
-      d ((i - 1) * n + j, count + i) = 1;
+      d((j - 1) * n + i, count + i) = 1;
+      d((i - 1) * n + j, count + i) = 1;
     endfor
     count = count + n - j;
   endfor
 
 endfunction
 
 
 %!test
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -144,13 +144,13 @@ endfunction
 
 %!assert (norm (expm ([1 -1;0 1]) - [e -e; 0 e]) < 1e-5);
 %!assert (expm ([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5);
 
 %!assert (expm (10), expm (10))
 %!assert (full (expm (eye (3))), expm (full (eye (3))))
 %!assert (full (expm (10*eye (3))), expm (full (10*eye (3))), 8*eps)
 
-%% Test input validation
+## Test input validation
 %!error expm ()
 %!error expm (1, 2)
 %!error <expm: A must be a square matrix> expm ([1 0;0 1; 2 2])
 
diff --git a/scripts/linear-algebra/isbanded.m b/scripts/linear-algebra/isbanded.m
--- a/scripts/linear-algebra/isbanded.m
+++ b/scripts/linear-algebra/isbanded.m
@@ -69,17 +69,17 @@ endfunction
 %!assert (isbanded (i*eye(10),1,1))
 %!assert (isbanded (logical (eye (10)),1,1))
 
 %! A = [2 3 0 0 0; 1 2 3 0 0; 0 1 2 3 0; 0 0 1 2 3; 0 0 0 1 2];
 %! assert (isbanded (A,1,1))
 %! assert (! isbanded (A,0,1))
 %! assert (! isbanded (A,1,0))
 
-%% Test input validation
+## Test input validation
 %!error isbanded ()
 %!error isbanded (1)
 %!error isbanded (1,2)
 %!error isbanded (1,2,3,4)
 %!error <LOWER and UPPER must be non-negative> isbanded (1, -1, 1)
 %!error <LOWER and UPPER must be non-negative> isbanded (1, 1, -1)
 %!error <LOWER and UPPER must be non-negative> isbanded (1, {1}, 1)
 %!error <LOWER and UPPER must be non-negative> isbanded (1, 1, {1})
diff --git a/scripts/linear-algebra/isdiag.m b/scripts/linear-algebra/isdiag.m
--- a/scripts/linear-algebra/isdiag.m
+++ b/scripts/linear-algebra/isdiag.m
@@ -45,12 +45,12 @@ endfunction
 %!assert (isdiag (1))
 %!assert (! isdiag ([1, 1]))
 %!assert (! isdiag ([1; 1]))
 %!assert (isdiag (eye (10)))
 %!assert (issymmetric ([i, 0; 0, 1 + i]))
 %!assert (isdiag (speye (1000000)))
 %!assert (isdiag (logical (eye (10))))
 
-%% Test input validation
+## Test input validation
 %!error isdiag ()
 %!error isdiag (1,2)
 
diff --git a/scripts/linear-algebra/istril.m b/scripts/linear-algebra/istril.m
--- a/scripts/linear-algebra/istril.m
+++ b/scripts/linear-algebra/istril.m
@@ -50,12 +50,12 @@ endfunction
 %!assert (! istril ([1, 1]))
 %!assert (istril ([1; 1]))
 %!assert (istril (eye (10)))
 %!assert (istril (speye (100)))
 
 %!assert (istril (tril (randn (10))))
 %!assert (! istril (randn (10)))
 
-%% Test input validation
+## Test input validation
 %!error istril ()
 %!error istril (1,2)
 
diff --git a/scripts/linear-algebra/istriu.m b/scripts/linear-algebra/istriu.m
--- a/scripts/linear-algebra/istriu.m
+++ b/scripts/linear-algebra/istriu.m
@@ -50,12 +50,12 @@ endfunction
 %!assert (istriu ([1, 1]))
 %!assert (! istriu ([1; 1]))
 %!assert (istriu (eye (10)))
 %!assert (istriu (speye (100)))
 
 %!assert (istriu (triu (randn (10))))
 %!assert (! istriu (randn (10)))
 
-%% Test input validation
+## Test input validation
 %!error istriu ()
 %!error istriu (1,2)
 
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -165,13 +165,13 @@ endfunction
 %! warning ("off", "Octave:logm:non-principal", "local");
 %! assert (norm (expm (logm ([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5);
 %!assert (logm ([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5)
 %!assert (logm (10), log (10))
 %!assert (full (logm (eye (3))), logm (full (eye (3))))
 %!assert (full (logm (10*eye (3))), logm (full (10*eye (3))), 8*eps)
 %!assert (logm (expm ([0 1i; -1i 0])), [0 1i; -1i 0], 10 * eps)
 
-%% Test input validation
+## Test input validation
 %!error logm ()
 %!error logm (1, 2, 3)
 %!error <logm: A must be a square matrix> logm ([1 0;0 1; 2 2])
 
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -79,16 +79,16 @@ endfunction
 %!test
 %! A = toeplitz ([-2,1,0,0]);
 %! assert (normest (A), norm (A), 1e-6);
 
 %!test
 %! A = rand (10);
 %! assert (normest (A), norm (A), 1e-6);
 
-%% Test input validation
+## Test input validation
 %!error normest ()
 %!error normest (1, 2, 3)
 %!error normest ([true true])
 %!error normest (ones (3,3,3))
 %!error normest (1, [1, 2])
 %!error normest (1, 1+1i)
 
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -60,31 +60,31 @@ function retval = null (A, tol)
       endif
     elseif (nargin != 2)
       print_usage ();
     endif
 
     rank = sum (s > tol);
 
     if (rank < cols)
-      retval = V (:, rank+1:cols);
+      retval = V(:, rank+1:cols);
       if (isa (A, "single"))
         retval (abs (retval) < eps ("single")) = 0;
       else
         retval (abs (retval) < eps) = 0;
       endif
     else
       retval = zeros (cols, 0);
     endif
   endif
 
 endfunction
 
 
-%% FIXME: Need some tests for 'single' variables as well
+## FIXME: Need some tests for 'single' variables as well
 
 %!test
 %! A = 0;
 %! assert (null (A), 1);
 
 %!test
 %! A = 1;
 %! assert (null (A), zeros (1,0));
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -62,17 +62,17 @@ function retval = orth (A, tol)
       else
         tol = max (size (A)) * s (1) * eps;
       endif
     endif
 
     rank = sum (s > tol);
 
     if (rank > 0)
-      retval = -U (:, 1:rank);
+      retval = -U(:, 1:rank);
     else
       retval = zeros (rows, 0);
     endif
 
   else
 
     print_usage ();
 
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -66,31 +66,31 @@ function [aa, bb, q, z] = qzhess (A, B)
   q = q';
   z = eye (na);
   for j = 1:(na-2)
     for i = na:-1:(j+2)
 
       ## disp (["zero out aa(", num2str(i), ",", num2str(j), ")"])
 
       rot = givens (aa (i-1, j), aa (i, j));
-      aa ((i-1):i, :) = rot *aa ((i-1):i, :);
-      bb ((i-1):i, :) = rot *bb ((i-1):i, :);
-      q  ((i-1):i, :) = rot *q  ((i-1):i, :);
+      aa((i-1):i, :) = rot *aa((i-1):i, :);
+      bb((i-1):i, :) = rot *bb((i-1):i, :);
+       q((i-1):i, :) = rot * q((i-1):i, :);
 
       ## disp (["now zero out bb(", num2str(i), ",", num2str(i-1), ")"])
 
       rot = givens (bb (i, i), bb (i, i-1))';
-      bb (:, (i-1):i) = bb (:, (i-1):i) * rot';
-      aa (:, (i-1):i) = aa (:, (i-1):i) * rot';
-      z  (:, (i-1):i) = z  (:, (i-1):i) * rot';
+      bb(:, (i-1):i) = bb(:, (i-1):i) * rot';
+      aa(:, (i-1):i) = aa(:, (i-1):i) * rot';
+       z(:, (i-1):i) =  z(:, (i-1):i) * rot';
 
     endfor
   endfor
 
-  bb (2, 1) = 0.0;
+  bb(2, 1) = 0.0;
   for i = 3:na
     bb (i, 1:(i-1)) = zeros (1, i-1);
     aa (i, 1:(i-2)) = zeros (1, i-2);
   endfor
 
 endfunction
 
 
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -60,17 +60,17 @@ function [A, k] = rref (A, tol)
     pivot = r + pivot - 1;
 
     if (m <= tol)
       ## Skip column c, making sure the approximately zero terms are
       ## actually zero.
       A(r:rows, c) = zeros (rows-r+1, 1);
     else
       ## keep track of bound variables
-      used (1, c) = 1;
+      used(1, c) = 1;
 
       ## Swap current row and pivot row
       A([pivot, r], c:cols) = A([r, pivot], c:cols);
 
       ## Normalize pivot row
       A(r, c:cols) = A(r, c:cols) / A(r, c);
 
       ## Eliminate the current column
diff --git a/scripts/miscellaneous/citation.m b/scripts/miscellaneous/citation.m
--- a/scripts/miscellaneous/citation.m
+++ b/scripts/miscellaneous/citation.m
@@ -42,13 +42,13 @@ function citation (package = "octave")
     print_usage ();
   else
     display_info_file ("citation", package, "CITATION");
   endif
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error citation (1, 2)
 %!error <citation: PACKAGE must be a string> citation (1)
 %!error <citation: package .* is not installed> citation ("__NOT_A_VALID_PKG_NAME__")
 
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -117,17 +117,17 @@ function out = compare_versions (v1, v2,
   endif
   v2n = str2double (ostrsplit (v2nochar, ".")');
   if (isnan (v2n))
     v2n = [];
   endif
 
   if (isempty (v1n) && isempty (v1c))
     error ("compare_versions: version string V1 is not valid: %s", v1);
-  elseif  (isempty (v2n) && isempty (v2c))
+  elseif (isempty (v2n) && isempty (v2c))
     error ("compare_versions: version string V2 is not valid: %s", v2);
   endif
 
   ## Assume any additional elements would be 0 if one is longer than the other.
   maxnumlen = max ([length(v1n) length(v2n)]);
   v1n(end+1:maxnumlen) = 0;
   v2n(end+1:maxnumlen) = 0;
 
@@ -217,17 +217,17 @@ endfunction
 %!assert (compare_versions ("1.25", "1.24", "=<"), false)
 ## test different length numbers
 %!assert (compare_versions ("23.2", "23.100", ">"), false)
 %!assert (compare_versions ("0.0.0.2", "0.0.1", ">="), false)
 %!assert (compare_versions ("0.0.20", "0.10.2", "=>"), false)
 %!assert (compare_versions ("0.1", "0.1", "!="), false)
 %!assert (compare_versions ("0.1", "0.1", "~="), false)
 
-%% Test input validation
+## Test input validation
 %!error compare_versions ()
 %!error compare_versions (1)
 %!error compare_versions (1,2)
 %!error compare_versions (1,2,3,4)
 %!error <V1 and V2 must be strings> compare_versions (0.1, "0.1", "==")
 %!error <V1 and V2 must be strings> compare_versions ("0.1", 0.1, "==")
 %!error <V1 and V2 must be a single row> compare_versions (["0";".";"1"], "0.1", "==")
 %!error <V1 and V2 must be a single row> compare_versions ("0.1", ["0";".";"1"], "==")
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -84,12 +84,12 @@ endfunction
 %!   hl = plot (1:10);
 %!   assert (get (gca, "children"), hl);
 %!   delete (hl);
 %!   assert (get (gca, "children"), zeros (0,1));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
-%% Test input validation
+## Test input validation
 %!error delete ()
 %!error <first argument must be a filename> delete (struct ())
 
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -577,17 +577,17 @@ endfunction
 %! s.email = edit ("get", "email");
 %! s.license = edit ("get", "license");
 %! s.editinplace = edit ("get", "editinplace");
 %! s.mode = edit ("get", "mode");
 %! edit home none
 %! edit author none
 %! edit email none
 %! edit license none
-%! edit ("editinplace", !s.editinplace)
+%! edit ("editinplace", ! s.editinplace)
 %! if (s.mode(1) == "a")
 %!   edit mode sync
 %! else
 %!   edit mode async
 %! endif
 %! edit ("home", s.home);
 %! edit ("author", s.author);
 %! edit ("email", s.email);
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -98,14 +98,14 @@ endfunction
 %!test
 %! [d, n, e] = fileparts ("/.ext");
 %! assert (strcmp (d, "/") && strcmp (n, "") && strcmp (e, ".ext"));
 
 %!test
 %! [d, n, e] = fileparts (".ext");
 %! assert (strcmp (d, "") && strcmp (n, "") && strcmp (e, ".ext"));
 
-%% Test input validation
+## Test input validation
 %!error fileparts ()
 %!error fileparts (1,2)
 %!error <FILENAME must be a single string> fileparts (1)
 %!error <FILENAME must be a single string> fileparts (["a"; "b"])
 
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -97,23 +97,23 @@ endfunction
 %!assert (fullfile ("/", "x/", "/", "/", "y", "/", "/"), [fs xfsyfs])
 %!assert (fullfile ("/x/", "/", "/", "y", "/", "/"), [fs xfsyfs])
 
 ## different on purpose so that "fullfile (c{:})" works for empty c
 %!assert (fullfile (), "")
 
 %!assert (fullfile ("x", "y", {"c", "d"}), {[xfsyfs "c"], [xfsyfs "d"]})
 
-%% Windows specific - drive letters and file sep type
+## Windows specific - drive letters and file sep type
 %!test
 %! if (ispc)
 %!   assert (fullfile ('\/\/\//A:/\/\', "x/", "/", "/", "y", "/", "/"), ...
 %!           ['A:\' xfsyfs]);
 %! endif
 
-%% Windows specific - drive letters and file sep type, cell array
+## Windows specific - drive letters and file sep type, cell array
 %!test
 %! if (ispc)
 %!  tmp = fullfile ({"\\\/B:\//", "A://c", "\\\C:/g/h/i/j\/"});
 %!  assert (tmp{1}, 'B:\');
 %!  assert (tmp{2}, 'A:\c');
 %!  assert (tmp{3}, 'C:\g\h\i\j\');
-%! endif
\ No newline at end of file
+%! endif
diff --git a/scripts/miscellaneous/genvarname.m b/scripts/miscellaneous/genvarname.m
--- a/scripts/miscellaneous/genvarname.m
+++ b/scripts/miscellaneous/genvarname.m
@@ -205,16 +205,16 @@ endfunction
 %!assert (genvarname ("__foo__", "x__foo__"), "x__foo__1")
 %!assert (genvarname ("1million_and1", "x1million_and1"), "x1million_and1_1")
 %!assert (genvarname ({"", "", ""}), {"x", "x1", "x2"})
 %!assert (genvarname ("if"), "xIf")
 %!assert (genvarname ({"if", "if", "if"}), {"xIf", "xIf1", "xIf2"})
 ## Exclusions in odd format
 %!assert (genvarname ("x", {"a", "b"; "x", "d"}), "x1")
 
-%% Test input validation
+## Test input validation
 %!error genvarname ()
 %!error genvarname (1,2,3)
 %!error <more than one STR is given, it must be a cellstr> genvarname (char ("a", "b", "c"))
 %!error <STR must be a string or cellstr> genvarname (1)
 %!error <more than one exclusion is given, it must be a cellstr> genvarname ("x", char ("a", "b", "c"))
 %!error <EXCLUSIONS must be a string or cellstr> genvarname ("x", 1)
 
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -55,13 +55,13 @@ endfunction
 
 %!test
 %! x.a = "hello";
 %! assert (getfield (x, "a"), "hello");
 %!test
 %! ss(1,2).fd(3).b(1,4) = 5;
 %! assert (getfield (ss,{1,2},"fd",{3},"b", {1,4}), 5);
 
-%% Test input validation
+## Test input validation
 %!error getfield ()
 %!error getfield (1)
 %!error <invalid index> getfield (1,2)
 
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -97,17 +97,17 @@ function [retval, errmsg] = license (cmd
       if (nargin < 2)
         print_usage ();
       endif
 
       if (nargin > 2)
         ## We ignore the toogle argument because... what's the point?  We
         ## don't need a license management system on Octave.  This function
         ## will return true, even if anyone tries to disabled a license.
-        switch tolower (toogle)
+        switch (tolower (toogle))
           case "enable"   # do nothing
           case "disable"  # do nothing
           otherwise       error ("license: TOOGLE must be enable or disable");
         endswitch
       endif
 
       retval = any (strcmp (features, feature));
 
@@ -176,13 +176,13 @@ endfunction
 %! endfor
 
 %!assert (license ("checkout", "octave"), true)
 
 %!test
 %! [s, e] = license ("checkout", "NOT_A_PACKAGE");
 %! assert (e, 'No package named "NOT_A_PACKAGE" installed');
 
-%% Test input validation
+## Test input validation
 %!error license ("not_inuse")
 %!error license ("not_test", "octave", "enable")
 %!error <TOOGLE must be enable or disable> license ("test", "octave", "invalid_toogle")
 
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -143,17 +143,18 @@
 ## @end table
 ## @end deftypefn
 
 function [output, status] = mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
   ext = octave_config_info ("EXEEXT");
 
-  shell_script = fullfile (bindir, sprintf ("mkoctfile-%s%s", OCTAVE_VERSION, ext));
+  shell_script = fullfile (bindir,
+                           sprintf ("mkoctfile-%s%s", OCTAVE_VERSION, ext));
 
   if (! exist (shell_script, "file"))
     __gripe_missing_component__ ("mkoctfile", "mkoctfile");
   endif
 
   cmd = ['"' shell_script '"'];
   for i = 1:nargin
     cmd = [cmd ' "' varargin{i} '"'];
diff --git a/scripts/miscellaneous/open.m b/scripts/miscellaneous/open.m
--- a/scripts/miscellaneous/open.m
+++ b/scripts/miscellaneous/open.m
@@ -67,12 +67,12 @@ function output = open (file)
       error ("executing .exe files is only supported on Windows systems");
     endif
   else
     open_with_system_app (file);
   endif
 
 endfunction
 
-%% Test input validation
+## Test input validation
 %!error open
 %!error open (1)
 %!error output = open (1)
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -82,13 +82,13 @@ function run (script)
       script = which ([script "."]);
     endif
     evalin ("caller", sprintf ('source ("%s");', script),
             "rethrow (lasterror ())");
   endif
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error run ()
 %!error run ("a", "b")
 %!error <SCRIPT must exist> run ("__A_very_#unlikely#_file_name__")
 
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -136,14 +136,14 @@ endfunction
 %! x = setfield (x, "b", "world");
 %! y = struct ("a", "hello", "b", "world");
 %! assert (x, y);
 %!test
 %! oo(1,1).f0 = 1;
 %! oo = setfield (oo,{1,2},"fd",{3},"b", {1,4}, 6);
 %! assert (oo(1,2).fd(3).b(1,4), 6);
 
-%% Test input validation
+## Test input validation
 %!error setfield ()
 %!error setfield (1)
 %!error setfield (1,2)
 %!error <invalid index> setfield (1,2,3)
 
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -89,13 +89,13 @@ endfunction
 %!assert (xor ([i, i, 0, 0], [1, 0, 1, 0]), logical ([0, 1, 1, 0]))
 
 %!assert (xor (eye (2), fliplr (eye (2))), logical (ones (2)))
 %!assert (xor (speye (2), fliplr (speye (2))), sparse (logical (ones (2))))
 
 ## Test XOR reduction
 %!assert (xor ([1 0], [1 1], [0 0]), logical ([0 1]))
 
-%% Test input validation
+## Test input validation
 %!error xor ()
 %!error xor (1)
 %!error <X and Y must be of compatible size> xor (ones (3,2), ones (2,3))
 
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -48,17 +48,18 @@
 ## bound by @var{a} and @var{b}.  If you only have an initial point
 ## to begin searching from you will need to use an unconstrained
 ## minimization algorithm such as @code{fminunc} or @code{fminsearch}.
 ## @code{fminbnd} internally uses a Golden Section search strategy.
 ## @seealso{fzero, fminunc, fminsearch, optimset}
 ## @end deftypefn
 
 ## This is patterned after opt/fmin.f from Netlib, which in turn is taken from
-## Richard Brent: Algorithms For Minimization Without Derivatives, Prentice-Hall (1973)
+## Richard Brent: Algorithms For Minimization Without Derivatives,
+## Prentice-Hall (1973)
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fminbnd");
 
 function [x, fval, info, output] = fminbnd (fun, xmin, xmax, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -246,17 +246,17 @@ function [x, fval, info, output, grad, h
         delta = min (delta, sn);
       endif
 
       fval1 = fcn (reshape (x + s, xsiz)) (:);
       nfev ++;
 
       if (fval1 < fval)
         ## Scaled actual reduction.
-        actred =  (fval - fval1) / (abs (fval1) + abs (fval));
+        actred = (fval - fval1) / (abs (fval1) + abs (fval));
       else
         actred = -1;
       endif
 
       w = hesr*s;
       ## Scaled predicted reduction, and ratio.
       t = 1/2 * sumsq (w) + grad'*s;
       if (t < 0)
@@ -366,29 +366,31 @@ function [fx, gx] = guarded_eval (fun, x
   endif
 endfunction
 
 
 %!function f = __rosenb (x)
 %!  n = length (x);
 %!  f = sumsq (1 - x(1:n-1)) + 100 * sumsq (x(2:n) - x(1:n-1).^2);
 %!endfunction
+%!
 %!test
 %! [x, fval, info, out] = fminunc (@__rosenb, [5, -5]);
 %! tol = 2e-5;
 %! assert (info > 0);
 %! assert (x, ones (1, 2), tol);
 %! assert (fval, 0, tol);
 %!test
 %! [x, fval, info, out] = fminunc (@__rosenb, zeros (1, 4));
 %! tol = 2e-5;
 %! assert (info > 0);
 %! assert (x, ones (1, 4), tol);
 %! assert (fval, 0, tol);
-%% Test FunValCheck works correctly
+
+## Test FunValCheck works correctly
 %!assert (fminunc (@(x) x^2, 1, optimset ("FunValCheck", "on")), 0, eps)
 %!error <non-real value> fminunc (@(x) x + i, 1, optimset ("FunValCheck", "on"))
 %!error <NaN value> fminunc (@(x) x + NaN, 1, optimset ("FunValCheck", "on"))
 %!error <Inf value> fminunc (@(x) x + Inf, 1, optimset ("FunValCheck", "on"))
 
 
 ## Solve the double dogleg trust-region minimization problem:
 ## Minimize 1/2*norm(r*x)^2  subject to the constraint norm(d.*x) <= delta,
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -257,19 +257,19 @@ function [x, fvec, info, output, fjac] =
       if (niter == 1)
         dg = jcn;
         dg(dg == 0) = 1;
       else
         ## Rescale adaptively.
         ## FIXME: the original minpack used the following rescaling strategy:
         ##   dg = max (dg, jcn);
         ## but it seems not good if we start with a bad guess yielding Jacobian
-        ## columns with large norms that later decrease, because the corresponding
-        ## variable will still be overscaled. So instead, we only give the old
-        ## scaling a small momentum, but do not honor it.
+        ## columns with large norms that later decrease, because the
+        ## corresponding variable will still be overscaled. So instead, we only
+        ## give the old scaling a small momentum, but do not honor it.
 
         dg = max (0.1*dg, jcn);
       endif
     endif
 
     if (niter == 1)
       xn = norm (dg .* x);
       ## FIXME: something better?
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -328,17 +328,18 @@ function [x, fval, info, output] = fzero
     endif
     if (itype == 2)
       mba = mu * (b - a);
     endif
   endwhile
 
   ## Check solution for a singularity by examining slope
   if (info == 1)
-    if ((b - a) != 0 && abs ((fb - fa)/(b - a) / slope0) > max (1e6, 0.5/(eps+tolx)))
+    if ((b - a) != 0
+        && abs ((fb - fa)/(b - a) / slope0) > max (1e6, 0.5/(eps+tolx)))
       info = -5;
     endif
   endif
 
   output.iterations = niter;
   output.funcCount = nfev;
   output.bracketx = [a, b];
   output.brackety = [fa, fb];
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -77,17 +77,18 @@
 
 function [x, resnorm, residual, exitflag, output, lambda] = lsqnonneg (c, d, x = [], options = struct ())
 
   if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
     x = optimset ("MaxIter", 1e5);
     return;
   endif
 
-  if (! (nargin >= 2 && nargin <= 4 && ismatrix (c) && ismatrix (d) && isstruct (options)))
+  if (nargin < 2 || nargin > 4
+      || ! (ismatrix (c) && ismatrix (d) && isstruct (options)))
     print_usage ();
   endif
 
   ## Lawson-Hanson Step 1 (LH1): initialize the variables.
   m = rows (c);
   n = columns (c);
   if (isempty (x))
     ## Initial guess is 0s.
diff --git a/scripts/optimization/optimget.m b/scripts/optimization/optimget.m
--- a/scripts/optimization/optimget.m
+++ b/scripts/optimization/optimget.m
@@ -63,17 +63,17 @@ endfunction
 %!shared opts
 %! opts = optimset ("tolx", 0.1, "maxit", 100);
 %!assert (optimget (opts, "TolX"), 0.1)
 %!assert (optimget (opts, "maxit"), 100)
 %!assert (optimget (opts, "MaxITer"), 100)
 %!assert (optimget (opts, "TolFun"), [])
 %!assert (optimget (opts, "TolFun", 1e-3), 1e-3)
 
-%% Test input validation
+## Test input validation
 %!error optimget ()
 %!error optimget (1)
 %!error optimget (1,2,3,4,5)
 %!error optimget (1, "name")
 %!error optimget (struct (), 2)
 %!warning <unrecognized option: foobar> (optimget (opts, "foobar"));
 %!warning <ambiguous option: Max> (optimget (opts, "Max"));
 
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -179,14 +179,14 @@ function retval = optimset (varargin)
 
 endfunction
 
 
 %!assert (isfield (optimset (), "TolFun"))
 %!assert (isfield (optimset ("tolFun", 1e-3), "TolFun"))
 %!assert (optimget (optimset ("tolx", 1e-2), "tOLx"), 1e-2)
 
-%% Test input validation
+## Test input validation
 %!error optimset ("1_Parameter")
 %!error <no defaults for function> optimset ("%NOT_A_REAL_FUNCTION_NAME%")
 %!warning <unrecognized option: foobar> optimset ("foobar", 13);
 %!warning <ambiguous option: Max> optimset ("Max", 10);
 
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -70,17 +70,18 @@
 
 function [x, minval, exitflag, output, lambda] = pqpnonneg (c, d, x = [], options = struct ())
 
   if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
     x = optimset ("MaxIter", 1e5);
     return;
   endif
 
-  if (! (nargin >= 2 && nargin <= 4 && ismatrix (c) && ismatrix (d) && isstruct (options)))
+  if (nargin < 2 || nargin > 4
+      || ! (ismatrix (c) && ismatrix (d) && isstruct (options)))
     print_usage ();
   endif
 
   ## Lawson-Hanson Step 1 (LH1): initialize the variables.
   m = rows (c);
   n = columns (c);
   if (m != n)
     error ("pqpnonneg: matrix must be square");
@@ -129,17 +130,17 @@ function [x, minval, exitflag, output, l
         sf = x(pidx)./(x(pidx) - xtmp(idx));
         alpha = min (sf);
         ## LH10: adjust X.
         xx = zeros (n, 1);
         xx(p) = xtmp;
         x += alpha*(xx - x);
         ## LH11: move from P to Z all X == 0.
         ## This corresponds to those indices where minimum of sf is attained.
-        idx = idx (sf == alpha);
+        idx = idx(sf == alpha);
         p(idx) = [];
         if (usechol)
           ## update the Cholesky factorization.
           r = choldelete (r, idx);
         endif
       endif
     endwhile
 
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -268,17 +268,18 @@ function [x, obj, INFO, lambda] = qp (x0
             Ain = [Ain; -A_in];
             bin = [bin; -A_ub];
           endif
         endif
 
         if (! isempty (A_lb) && ! isempty (A_ub))
           rtol = sqrt (eps);
           for i = 1:dimA_in
-            if (abs (A_lb(i) - A_ub(i)) < rtol*(1 + max (abs (A_lb(i) + A_ub(i)))))
+            if (abs (A_lb(i) - A_ub(i))
+                < rtol*(1 + max (abs (A_lb(i) + A_ub(i)))))
               ## These are actually an equality constraint
               tmprow = A_in(i,:);
               A = [A;tmprow];
               b = [b; 0.5*(A_lb(i) + A_ub(i))];
               n_eq = n_eq + 1;
             else
               tmprow = A_in(i,:);
               Ain = [Ain; tmprow; -tmprow];
@@ -301,18 +302,18 @@ function [x, obj, INFO, lambda] = qp (x0
     idx = isinf (bin) & bin < 0;
 
     bin(idx) = [];
     Ain(idx,:) = [];
 
     n_in = numel (bin);
 
     ## Check if the initial guess is feasible.
-    if (isa (x0, "single") || isa (H, "single") || isa (q, "single") || isa (A, "single")
-        || isa (b, "single"))
+    if (isa (x0, "single") || isa (H, "single") || isa (q, "single")
+        || isa (A, "single") || isa (b, "single"))
       rtol = sqrt (eps ("single"));
     else
       rtol = sqrt (eps);
     endif
 
     eq_infeasible = (n_eq > 0 && norm (A*x0-b) > rtol*(1+abs (b)));
     in_infeasible = (n_in > 0 && any (Ain*x0-bin < -rtol*(1+abs (bin))));
 
@@ -403,17 +404,17 @@ function [x, obj, INFO, lambda] = qp (x0
 
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Test infeasible initial guess (bug #40536)
+## Test infeasible initial guess (bug #40536)
 %!testif HAVE_GLPK
 %!
 %! H = 1;  q = 0;                # objective: x -> 0.5 x^2
 %! A = 1;  lb = 1;  ub = +inf;   # constraint: x >= 1
 %! x0 = 0;                       # infeasible initial guess
 %!
 %! [x, obj_qp, INFO, lambda] = qp (x0, H, q, [], [], [], [], lb, A, ub);
 %!
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -191,62 +191,62 @@
 function [x, obj, info, iter, nf, lambda] = sqp (x0, objf, cef, cif, lb, ub, maxiter, tolerance)
 
   globals = struct (); # data and handles, needed and changed by subfunctions
 
   if (nargin < 2 || nargin > 8 || nargin == 5)
     print_usage ();
   endif
 
-  if (!isvector (x0))
+  if (! isvector (x0))
     error ("sqp: X0 must be a vector");
   endif
   if (rows (x0) == 1)
     x0 = x0';
   endif
 
   have_hess = 0;
   if (iscell (objf))
     switch (numel (objf))
       case 1
         obj_fun = objf{1};
-        obj_grd = @ (x) fd_obj_grd (x, obj_fun);
+        obj_grd = @(x) fd_obj_grd (x, obj_fun);
       case 2
         obj_fun = objf{1};
         obj_grd = objf{2};
       case 3
         obj_fun = objf{1};
         obj_grd = objf{2};
         obj_hess = objf{3};
         have_hess = 1;
       otherwise
         error ("sqp: invalid objective function specification");
     endswitch
   else
     obj_fun = objf;   # No cell array, only obj_fun set
-    obj_grd = @ (x) fd_obj_grd (x, obj_fun);
+    obj_grd = @(x) fd_obj_grd (x, obj_fun);
   endif
 
   ce_fun = @empty_cf;
   ce_grd = @empty_jac;
   if (nargin > 2)
     if (iscell (cef))
       switch (numel (cef))
         case 1
           ce_fun = cef{1};
-          ce_grd = @ (x) fd_ce_jac (x, ce_fun);
+          ce_grd = @(x) fd_ce_jac (x, ce_fun);
         case 2
           ce_fun = cef{1};
           ce_grd = cef{2};
         otherwise
           error ("sqp: invalid equality constraint function specification");
       endswitch
     elseif (! isempty (cef))
       ce_fun = cef;   # No cell array, only constraint equality function set
-      ce_grd = @ (x) fd_ce_jac (x, ce_fun);
+      ce_grd = @(x) fd_ce_jac (x, ce_fun);
     endif
   endif
 
   ci_fun = @empty_cf;
   ci_grd = @empty_jac;
   if (nargin > 3)
     ## constraint function given by user with possible gradient
     globals.cif = cif;
@@ -257,17 +257,17 @@ function [x, obj, info, iter, nf, lambda
         globals.cifcn = cif{1};
       endif
     elseif (! isempty (cif))
       globals.cifcn = cif;
     endif
 
     if (nargin < 5 || (nargin > 5 && isempty (lb) && isempty (ub)))
       ## constraint inequality function only without any bounds
-      ci_grd = @ (x) fd_ci_jac (x, globals.cifcn);
+      ci_grd = @(x) fd_ci_jac (x, globals.cifcn);
       if (iscell (cif))
         switch (length (cif))
           case 1
             ci_fun = cif{1};
           case 2
             ci_fun = cif{1};
             ci_grd = cif{2};
           otherwise
@@ -309,18 +309,18 @@ function [x, obj, info, iter, nf, lambda
       else
         error ("sqp: invalid upper bound");
       endif
 
       if (any (tmp_lb > tmp_ub))
         error ("sqp: upper bound smaller than lower bound");
       endif
       bounds_grad = [lb_grad; ub_grad];
-      ci_fun = @ (x) cf_ub_lb (x, lb_idx, ub_idx, globals);
-      ci_grd = @ (x) cigrad_ub_lb (x, bounds_grad, globals);
+      ci_fun = @(x) cf_ub_lb (x, lb_idx, ub_idx, globals);
+      ci_grd = @(x) cigrad_ub_lb (x, bounds_grad, globals);
     endif
 
   endif   # if (nargin > 3)
 
   iter_max = 100;
   if (nargin > 6 && ! isempty (maxiter))
     if (isscalar (maxiter) && maxiter > 0 && fix (maxiter) == maxiter)
       iter_max = maxiter;
@@ -699,44 +699,44 @@ function res = cf_ub_lb (x, lbidx, ubidx
            globals.ub-x(ubidx,1)];
   endif
 
 endfunction
 
 
 function res = cigrad_ub_lb (x, bgrad, globals)
 
-  cigradfcn = @ (x) fd_ci_jac (x, globals.cifcn);
+  cigradfcn = @(x) fd_ci_jac (x, globals.cifcn);
 
   if (iscell (globals.cif) && length (globals.cif) > 1)
     cigradfcn = globals.cif{2};
   endif
 
   if (isempty (cigradfcn))
     res = bgrad;
   else
     res = [feval(cigradfcn,x); bgrad];
   endif
 
 endfunction
 
-# Utility function used to debug sqp
+## Utility function used to debug sqp
 function report (iter, qp_iter, alpha, nfun, obj)
 
   if (nargin == 0)
     printf ("  Itn ItQP     Step  Nfun     Objective\n");
   else
     printf ("%5d %4d %8.1g %5d %13.6e\n", iter, qp_iter, alpha, nfun, obj);
   endif
 
 endfunction
 
 
-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-%% Test Code
+################################################################################
+## Test Code
 
 %!function r = __g (x)
 %!  r = [sumsq(x)-10;
 %!       x(2)*x(3)-5*x(4)*x(5);
 %!       x(1)^3+x(2)^3+1 ];
 %!endfunction
 %!
 %!function obj = __phi (x)
@@ -755,17 +755,17 @@ endfunction
 %!          -0.763643103133572;
 %!          -0.763643068453300];
 %!
 %! obj_opt = 0.0539498477702739;
 %!
 %! assert (x, x_opt, 8*sqrt (eps));
 %! assert (obj, obj_opt, sqrt (eps));
 
-%% Test input validation
+## Test input validation
 %!error sqp ()
 %!error sqp (1)
 %!error sqp (1,2,3,4,5,6,7,8,9)
 %!error sqp (1,2,3,4,5)
 %!error sqp (ones (2,2))
 %!error sqp (1, cell (4,1))
 %!error sqp (1, cell (3,1), cell (3,1))
 %!error sqp (1, cell (3,1), cell (2,1), cell (3,1))
diff --git a/scripts/path/pathdef.m b/scripts/path/pathdef.m
--- a/scripts/path/pathdef.m
+++ b/scripts/path/pathdef.m
@@ -71,17 +71,17 @@ function val = pathdef ()
     return;
   endif
 
   ## No project, user, or site octaverc file.  Use Octave's default.
   val = __pathorig__ ();
 
 endfunction
 
-## Extact the path information from the script/function @var{file}, created by
+## Extract the path information from the script/function @var{file}, created by
 ## @file{savepath.m}.  If successful, @code{__extractpath__} returns the path
 ## specified in @var{file}.
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function path = __extractpath__ (savefile)
 
   [filelines, startline, endline] = getsavepath (savefile);
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -181,16 +181,17 @@ function retval = savepath (file)
 
 endfunction
 
 ## Convert single string of paths to cell array of paths
 function path_elements = parsepath (p)
   path_elements = strcat (ostrsplit (p, pathsep), pathsep);
 endfunction
 
+
 %!test
 %! fname = tempname ();
 %! status = savepath (fname);
 %! assert (status == 0);
 %! old_dir = pwd;
 %! unwind_protect
 %!   cd (P_tmpdir);
 %!   if (exist (fullfile (pwd, ".octaverc")))
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -385,22 +385,25 @@ function [local_packages, global_package
       if (isempty (files))
         error ("you must specify at least one filename when calling 'pkg install'");
       endif
 
       local_files = {};
       unwind_protect
 
         if (octave_forge)
-          [urls, local_files] = cellfun ("get_forge_download", files, "uniformoutput", false);
-          [files, succ] = cellfun ("urlwrite", urls, local_files, "uniformoutput", false);
+          [urls, local_files] = cellfun ("get_forge_download", files,
+                                         "uniformoutput", false);
+          [files, succ] = cellfun ("urlwrite", urls, local_files,
+                                   "uniformoutput", false);
           succ = [succ{:}];
           if (! all (succ))
             i = find (! succ, 1);
-            error ("could not download file %s from url %s", local_files{i}, urls{i});
+            error ("could not download file %s from url %s",
+                   local_files{i}, urls{i});
           endif
         endif
 
         install (files, deps, auto, prefix, archprefix, verbose, local_list,
                  global_list, global_install);
 
       unwind_protect_cleanup
         cellfun ("unlink", local_files);
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -24,18 +24,20 @@
 
 function configure_make (desc, packdir, verbose)
   ## Perform ./configure, make, make install in "src".
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
     octave_bindir = octave_config_info ("bindir");
     ver = version ();
     ext = octave_config_info ("EXEEXT");
-    mkoctfile_program = fullfile (octave_bindir, sprintf ("mkoctfile-%s%s", ver, ext));
-    octave_config_program = fullfile (octave_bindir, sprintf ("octave-config-%s%s", ver, ext));
+    mkoctfile_program = fullfile (octave_bindir, ...
+                                  sprintf ("mkoctfile-%s%s", ver, ext));
+    octave_config_program = fullfile (octave_bindir, ...
+                                      sprintf ("octave-config-%s%s", ver, ext));
     octave_binary = fullfile (octave_bindir, sprintf ("octave-%s%s", ver, ext));
 
     if (! exist (mkoctfile_program, "file"))
       __gripe_missing_component__ ("pkg", "mkoctfile");
     endif
     if (! exist (octave_config_program, "file"))
       __gripe_missing_component__ ("pkg", "octave-config");
     endif
@@ -77,17 +79,17 @@ function configure_make (desc, packdir, 
         error ("pkg: error running the configure script for %s.", desc.name);
       endif
     endif
 
     ## Make.
     if (ispc ())
       jobs = 1;
     else
-      jobs =  nproc ("overridable");
+      jobs = nproc ("overridable");
     endif
 
     if (exist (fullfile (src, "Makefile"), "file"))
       [status, output] = shell (sprintf ("%s make --jobs %i --directory '%s'",
                                          scenv, jobs, src), verbose);
       if (status != 0)
         rmdir (desc.dir, "s");
         disp (output);
@@ -108,17 +110,17 @@ function configure_make (desc, packdir, 
         error ("couldn't open %s: %s", files, msg);
       endif
       filenames = char (fread (fid))';
       fclose (fid);
       if (filenames(end) == "\n")
         filenames(end) = [];
       endif
       filenames = strtrim (ostrsplit (filenames, "\n"));
-      delete_idx =  [];
+      delete_idx = [];
       for i = 1:length (filenames)
         if (! all (isspace (filenames{i})))
           filenames{i} = fullfile (src, filenames{i});
         else
           delete_idx(end+1) = i;
         endif
       endfor
       filenames(delete_idx) = [];
@@ -133,18 +135,18 @@ function configure_make (desc, packdir, 
     endif
 
     ## Split into architecture dependent and independent files.
     if (isempty (filenames))
       idx = [];
     else
       idx = cellfun ("is_architecture_dependent", filenames);
     endif
-    archdependent = filenames (idx);
-    archindependent = filenames (!idx);
+    archdependent = filenames(idx);
+    archindependent = filenames(!idx);
 
     ## Copy the files.
     if (! all (isspace ([filenames{:}])))
         if (! exist (instdir, "dir"))
           mkdir (instdir);
         endif
         if (! all (isspace ([archindependent{:}])))
           if (verbose)
diff --git a/scripts/pkg/private/copy_files.m b/scripts/pkg/private/copy_files.m
--- a/scripts/pkg/private/copy_files.m
+++ b/scripts/pkg/private/copy_files.m
@@ -99,17 +99,16 @@ function copy_files (desc, packdir, glob
   if (status != 1)
     rmdir (desc.dir, "s");
     rmdir (octfiledir, "s");
     error ("couldn't create packinfo directory: %s", msg);
   endif
 
   packinfo_copy_file ("DESCRIPTION", "required", packdir, packinfo, desc, octfiledir);
   packinfo_copy_file ("COPYING", "required", packdir, packinfo, desc, octfiledir);
-
   packinfo_copy_file ("CITATION", "optional", packdir, packinfo, desc, octfiledir);
   packinfo_copy_file ("NEWS", "optional", packdir, packinfo, desc, octfiledir);
   packinfo_copy_file ("ONEWS", "optional", packdir, packinfo, desc, octfiledir);
   packinfo_copy_file ("ChangeLog", "optional", packdir, packinfo, desc, octfiledir);
 
   ## Is there an INDEX file to copy or should we generate one?
   index_file = fullfile (packdir, "INDEX");
   if (exist (index_file, "file"))
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -32,17 +32,18 @@ function [ver, url] = get_forge_pkg (nam
     error ("get_forge_pkg: package NAME must be a string");
   elseif (! all (isalnum (name) | name == "-" | name == "." | name == "_"))
     error ("get_forge_pkg: invalid package name: %s", name);
   endif
 
   name = tolower (name);
 
   ## Try to download package's index page.
-  [html, succ] = urlread (sprintf ("http://packages.octave.org/%s/index.html", name));
+  [html, succ] = urlread (sprintf ("http://packages.octave.org/%s/index.html",
+                                   name));
   if (succ)
     ## Remove blanks for simpler matching.
     html(isspace(html)) = [];
     ## Good. Let's grep for the version.
     pat = "<tdclass=""package_table"">PackageVersion:</td><td>([\\d.]*)</td>";
     t = regexp (html, pat, "tokens");
     if (isempty (t) || isempty (t{1}))
       error ("get_forge_pkg: could not read version number from package's page");
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -317,28 +317,29 @@ function install (files, handle_deps, au
   ## can begin using them. Only load them if they are marked autoload.
   if (length (descriptions) > 0)
     idx = [];
     for i = 1:length (descriptions)
       if (descriptions{i}.autoload > 0)
         nm = descriptions{i}.name;
         for j = 1:length (installed_pkgs_lst)
           if (strcmp (nm, installed_pkgs_lst{j}.name))
-            idx (end + 1) = j;
+            idx(end + 1) = j;
             break;
           endif
         endfor
       endif
     endfor
     load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
                                     global_install);
   endif
 
-  ## If there's a NEWS file, mention it
-  ## we are checking if desc exists too because it's possible to ge to this point
+  ## If there is a NEWS file, mention it.
+  ## Check if desc exists too because it's possible to get to this point
   ## without creating it such as giving an invalid filename for the package
-  if (exist ("desc", "var") && exist (fullfile (desc.dir, "packinfo", "NEWS"), "file"))
+  if (exist ("desc", "var")
+      && exist (fullfile (desc.dir, "packinfo", "NEWS"), "file"))
     printf ("For information about changes from previous versions of the %s package, run 'news %s'.\n",
             desc.name, desc.name);
   endif
 
 endfunction
 
diff --git a/scripts/pkg/private/load_package_dirs.m b/scripts/pkg/private/load_package_dirs.m
--- a/scripts/pkg/private/load_package_dirs.m
+++ b/scripts/pkg/private/load_package_dirs.m
@@ -37,17 +37,17 @@ function idx = load_package_dirs (lidx, 
         deps = installed_pkgs_lst{i}.depends;
         if ((length (deps) > 1)
             || (length (deps) == 1 && ! strcmp (deps{1}.package, "octave")))
           tmplidx = [];
           for k = 1 : length (deps)
             for j = 1 : length (installed_pkgs_lst)
               if (strcmp (installed_pkgs_lst{j}.name, deps{k}.package))
                 if (! any (idx == j))
-                  tmplidx (end + 1) = j;
+                  tmplidx(end + 1) = j;
                   break;
                 endif
               endif
             endfor
           endfor
           idx = load_package_dirs (tmplidx, idx, handle_deps,
                                  installed_pkgs_lst);
         endif
diff --git a/scripts/pkg/private/load_packages.m b/scripts/pkg/private/load_packages.m
--- a/scripts/pkg/private/load_packages.m
+++ b/scripts/pkg/private/load_packages.m
@@ -36,27 +36,27 @@ function load_packages (files, handle_de
   ## Load all.
   if (length (files) == 1 && strcmp (files{1}, "all"))
     idx = [1:length(installed_pkgs_lst)];
   ## Load auto.
   elseif (length (files) == 1 && strcmp (files{1}, "auto"))
     idx = [];
     for i = 1:length (installed_pkgs_lst)
       if (exist (fullfile (pdirs{i}, "packinfo", ".autoload"), "file"))
-        idx (end + 1) = i;
+        idx(end + 1) = i;
       endif
     endfor
   ## Load package_name1 ...
   else
     idx = [];
     for i = 1:length (files)
       idx2 = find (strcmp (pnames, files{i}));
       if (! any (idx2))
           error ("package %s is not installed", files{i});
       endif
-      idx (end + 1) = idx2;
+      idx(end + 1) = idx2;
     endfor
   endif
 
   ## Load the packages, but take care of the ordering of dependencies.
   load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst, true);
 endfunction
 
diff --git a/scripts/pkg/private/packinfo_copy_file.m b/scripts/pkg/private/packinfo_copy_file.m
--- a/scripts/pkg/private/packinfo_copy_file.m
+++ b/scripts/pkg/private/packinfo_copy_file.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} packinfo_copy_file (@var{filename}, @var{requirement}, @var{packdir}, @var{packinfo}, @var{desc}, @var{octfiledir})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function packinfo_copy_file (filename, requirement, packdir, packinfo, desc, octfiledir)
   filepath = fullfile (packdir, filename);
-  if (!exist (filepath, "file") && strcmpi (requirement, "optional"))
+  if (! exist (filepath, "file") && strcmpi (requirement, "optional"))
     ## do nothing, it's still OK
   else
     [status, output] = copyfile (filepath, packinfo);
     if (status != 1)
       rmdir (desc.dir, "s");
       rmdir (octfiledir, "s");
       error ("Couldn't copy %s file: %s", filename, output);
     endif
diff --git a/scripts/pkg/private/rebuild.m b/scripts/pkg/private/rebuild.m
--- a/scripts/pkg/private/rebuild.m
+++ b/scripts/pkg/private/rebuild.m
@@ -88,13 +88,13 @@ function descriptions = rebuild (prefix,
           continue;
         endif
         if (strcmp (descriptions{i}.name, descriptions{j}.name))
           dup = [dup, j];
         endif
       endfor
     endfor
     if (! isempty (dup))
-      descriptions (dup) = [];
+      descriptions(dup) = [];
     endif
   endif
 endfunction
 
diff --git a/scripts/pkg/private/save_order.m b/scripts/pkg/private/save_order.m
--- a/scripts/pkg/private/save_order.m
+++ b/scripts/pkg/private/save_order.m
@@ -23,17 +23,17 @@
 ## @end deftypefn
 
 function newdesc = save_order (desc)
   newdesc = {};
   for i = 1 : length (desc)
     deps = desc{i}.depends;
     if (isempty (deps)
         || (length (deps) == 1 && strcmp (deps{1}.package, "octave")))
-      newdesc {end + 1} = desc{i};
+      newdesc{end + 1} = desc{i};
     else
       tmpdesc = {};
       for k = 1 : length (deps)
         for j = 1 : length (desc)
           if (strcmp (desc{j}.name, deps{k}.package))
             tmpdesc{end+1} = desc{j};
             break;
           endif
@@ -46,15 +46,15 @@ function newdesc = save_order (desc)
       endif
     endif
   endfor
   ## Eliminate the duplicates.
   idx = [];
   for i = 1 : length (newdesc)
     for j = (i + 1) : length (newdesc)
       if (strcmp (newdesc{i}.name, newdesc{j}.name))
-        idx (end + 1) = j;
+        idx(end + 1) = j;
       endif
     endfor
   endfor
   newdesc(idx) = [];
 endfunction
 
diff --git a/scripts/pkg/private/write_index.m b/scripts/pkg/private/write_index.m
--- a/scripts/pkg/private/write_index.m
+++ b/scripts/pkg/private/write_index.m
@@ -32,17 +32,17 @@ function write_index (desc, dir, index_f
   [files, err, msg] = readdir (dir);
   if (err)
     error ("couldn't read directory %s: %s", dir, msg);
   endif
 
   ## Get classes in dir
   class_idx = find (strncmp (files, '@', 1));
   for k = 1:length (class_idx)
-    class_name = files {class_idx (k)};
+    class_name = files {class_idx(k)};
     class_dir = fullfile (dir, class_name);
     if (exist (class_dir, "dir"))
       [files2, err, msg] = readdir (class_dir);
       if (err)
         error ("couldn't read directory %s: %s", class_dir, msg);
       endif
       files2 = strcat (class_name, filesep (), files2);
       files = [files; files2];
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 2015 Pantxo Diribarne
-## 
+##
 ##   This program is free software; you can redistribute it and/or modify
 ##   it under the terms of the GNU General Public License as published by
 ##   the Free Software Foundation; either version 3 of the License, or
 ##   (at your option) any later version.
-##   
+##
 ##   This program is distributed in the hope that it will be useful,
 ##   but WITHOUT ANY WARRANTY; without even the implied warranty of
 ##   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ##   GNU General Public License for more details.
-##   
+##
 ##   You should have received a copy of the GNU General Public License
 ##   along with Octave; see the file COPYING.  If not, see
 ##   <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} annotation (@var{type})
 ## @deftypefnx {Function File} {} annotation ("line", @var{x}, @var{y})
 ## @deftypefnx {Function File} {} annotation ("arrow", @var{x}, @var{y})
@@ -31,29 +31,29 @@
 ## You may build a default annotation specifying only the type
 ## @var{type} of the annotation.  Otherwise you can set the position of
 ## the annotation using either @var{x} and @var{y} coordinates for
 ## line-based annotations or a position vector @var{pos} for others.
 ## In any case, coordinates are interpreted using the @qcode{"units"}
 ## property of the annotation objects: the default is
 ## @qcode{"normalized"}, which means the lower left hand corner of the
 ## figure has coordinates @samp{[0 0]} and the upper right hand corner
-## @samp{[1 1]}. 
+## @samp{[1 1]}.
 ##
-## The figure on which the annotations should be drawn may be 
+## The figure on which the annotations should be drawn may be
 ## specified by providing its graphics handle @var{hf} before any
 ## other argument.  Otherwise annotations are drawn on the current
-## figure. 
-## 
+## figure.
+##
 ## Further arguments can be provided in the form of
 ## @var{prop}/@var{val} pairs to customize the annotation appearance
 ## and the units in which coordinates are interpreted.  The annotation
-## can also be customized afterward using its graphics handle 
+## can also be customized afterward using its graphics handle
 ## @var{h} and @code{set} function.
-## 
+##
 ## All annotation objects share two properties:
 ##
 ## @itemize
 ## @item
 ##  @qcode{"units"}: the units in which coordinates are interpreted.
 ##  Its value may be one of @qcode{"centimeters"} |
 ##  @qcode{"characters"} | @qcode{"inches"} | @qcode{"@{normalized@}"}
 ##  | @qcode{"pixels"} | @qcode{"points"}.
@@ -62,17 +62,17 @@
 ##  @qcode{"position"}: a four elements vector [x0 y0 width height]
 ##  specifying the coordinates (x0,y0) of the origin of the annotation
 ##  object, its width and its height.  The width and height may be
 ##  negative, depending on the orientation of the object.
 ##
 ## @end itemize
 ##
 ## Valid annotation types and their specific properties are described
-## below: 
+## below:
 ##
 ## @table @asis
 ## @item @qcode{"line"}
 ##  Constructs a line.  @var{x} and @var{y} must be two
 ##  elements vectors specifying the x and y coordinates of the two
 ##  ends of the line.
 ##
 ##  The line can be customized using @qcode{"linewidth"},
@@ -82,29 +82,29 @@
 ## @item  @qcode{"arrow"}
 ##   Construct an arrow.  The second point in vectors @var{x} and
 ##   @var{y} specifies the arrowhead coordinates.
 ##
 ##  Besides line properties, the arrowhead can be customized using
 ##  @qcode{"headlength"}, @qcode{"headwidth"} and @qcode{"headstyle"}
 ##  properties.  Supported values for @qcode{"headstyle"} property are:
 ##  [@qcode{"diamond"} | @qcode{"ellipse"} | @qcode{"plain"} |
-##  @qcode{"rectangle"} | @qcode{"vback1"} | @qcode{"@{vback2@}"} | 
-##  @qcode{"vback3"}] 
-## 
+##  @qcode{"rectangle"} | @qcode{"vback1"} | @qcode{"@{vback2@}"} |
+##  @qcode{"vback3"}]
+##
 ## @item  @qcode{"doublearrow"}
 ##   Construct a double arrow.  Vectors @var{x} and @var{y} specify the
 ##   arrowheads coordinates.
 ##
 ##  The line and the arrowhead can be customized as for arrow
 ##  annotations but some property names are duplicated:
 ##  @qcode{"head1length"}/@qcode{"head2length"},
 ##  @qcode{"head1width"}/@qcode{"head2width"}, etc.  The index 1 marks
 ##  the properties of the arrowhead at the first point in @var{x} and
-##  @var{y} coordinates. 
+##  @var{y} coordinates.
 ##
 ## @item  @qcode{"textarrow"}
 ##  Construct an arrow with a text label at the opposite of the
 ##  arrowhead.
 ##
 ##  The line and the arrowhead can be customized as for arrow
 ##  annotations, and the text can be customized using the same
 ##  properties as @code{text} graphics objects.  Note however
@@ -127,291 +127,291 @@
 ##  move the text inside the box.
 ##
 ##  Finally the  @qcode{"fitboxtotext"} property controls the actual
 ##  extent of the box.  If @qcode{"on"} (the default) the
 ##  box limits are fitted to the text extent.
 ##
 ## @item  @qcode{"rectangle"}
 ##  Construct a rectangle.  @var{pos} specifies the
-##  @qcode{"position"} property of the annotation. 
+##  @qcode{"position"} property of the annotation.
 ##
 ##  You may use @qcode{"facecolor"}, @qcode{"color"},
 ##  @qcode{"linestyle"} and @qcode{"linewidth"} properties to customize
 ##  the rectangle background color and edges appearance.
 ##
 ## @item  @qcode{"ellipse"}
 ##  Construct an ellipse.  @var{pos} specifies the
-##  @qcode{"position"} property of the annotation. 
+##  @qcode{"position"} property of the annotation.
 ##
-##  See @qcode{"rectangle"} annotations for customization. 
+##  See @qcode{"rectangle"} annotations for customization.
 ## @end table
-## 
+##
 ## @seealso{xlabel, title}
 ## @end deftypefn
 
 function varargout = annotation (varargin)
 
   objtype = "";
   hf = [];
   lims = [];
   x = y = [];
   opts = {};
-  
+
   nargin = numel (varargin);
   if (nargin == 0)
     print_usage ();
   endif
-  
-  
+
+
   ## Parent figure
   if (isfigure (varargin{1}))
     hf = varargin{1};
     varargin = varargin(2:end);
     nargin --;
   endif
-  
+
   ## Annotation type
   types = {"line", "arrow", "doublearrow", "textarrow", ...
            "textbox", "ellipse", "rectangle"};
   if (ischar (varargin{1}))
     objtype = varargin{1};
     varargin(1) = [];
     nargin --;
   else
     print_usage ();
   endif
-  
-  switch objtype
+
+  switch (objtype)
     case types(1:4)
-         
+
       if (nargin == 0)
-        lims  = [];
+        lims = [];
       elseif (nargin >= 2)
         x = varargin{1};
         y = varargin{2};
         varargin(1:2) = [];
-      
-        if (isnumeric (x) && isnumeric (y) && 
+
+        if (isnumeric (x) && isnumeric (y) &&
             length (x) == 2 && length (y) == 2)
           lims = [x(1) y(1) diff(x) diff(y)];
-        else 
+        else
           error ("annotation: expect 2 elements vectors for X and Y");
         endif
       else
         print_usage ();
       endif
     case types(5:end)
       if (nargin == 0)
-        lims  = [];
+        lims = [];
       else
         lims = varargin{1};
         varargin(1) = [];
-        
+
         if (! isvector (lims) || length (lims) != 4)
           error ("annotation: expect 4 elements vector for POS")
         endif
       endif
     otherwise
       error ("annotation: unknown annotation type %s", objtype)
   endswitch
 
   ## options
   opts = varargin;
   nopts = numel (opts);
   if (! isempty (opts))
-    if (fix (nopts/2) != nopts/2 ||
-        !all (cellfun (@ischar, opts(1:2:end))))
+    if (fix (nopts/2) != nopts/2
+        || ! all (cellfun (@ischar, opts(1:2:end))))
       warning ("annotation: couldn't parse PROP/VAL pairs, skipping");
       opts = {};
     endif
   endif
-  
+
   ## create annotation
   showhidden = get (0, "showhiddenhandles");
   set (0, "showhiddenhandles", "on");
 
   unwind_protect
     if (isempty (hf))
       hf = gcf ();
     endif
-    
+
     ## Axes
     hca = get (hf, "currentaxes");
 
     hax = findall (hf, "-depth", 1, "tag", "scribeoverlay");
     if (isempty (hax))
       hax = buildoverlay (hf);
     else
       ## Make sure the annotations are on top of other axes
       axes (hax);
     endif
 
     ## Build annotation
     htmp = buildannot (hax, objtype, lims);
 
     ## Set user defined properties
-    if (!isempty (opts))
+    if (! isempty (opts))
       set (htmp, opts{:});
     endif
-    
+
   unwind_protect_cleanup
     set (0, "showhiddenhandles", showhidden);
     set (hf, "currentaxes", hca);
   end_unwind_protect
-  
+
   if (nargout != 0)
     varargout{1} = htmp;
   endif
 
 endfunction
 
 function hax = buildoverlay (hf)
 
   hax = axes ("parent", hf, "position", [0 0 1 1], ...
               "visible", "off","tag", "scribeoverlay", ...
               "xlim", [0 1], "ylim", [0 1], ...
               "handlevisibility", "off");
-  
+
   ## hidden property to store figure size in absolute (points)
-  ## coordinates 
+  ## coordinates
   addproperty ("figsize_points", hax, "axesxmtick", []);
   update_figsize_points (hf, {}, hax);
 
-  
+
   listener = {@update_figsize_points, hax};
   addlistener (hf, "position", listener);
-    
+
   delfcn = @() dellistener (hf, "position", listener);
   set (hax, "deletefcn", delfcn);
-  
+
 endfunction
 
 function update_figsize_points (hf, dummy, hax)
 
   persistent recursive = false;
   if (! recursive)
     recursive = true;
     units = get (hf, "units");
     set (hf, "units", "points");
     pos = get (hf, "position");
     set (hf, "units", units);
-    
+
     set (hax, "figsize_points", pos(3:4));
     recursive = false;
   endif
-  
+
 endfunction
-  
+
 function h = buildannot (hax, objtype, pos)
 
   ## Base hggroup
   h = hggroup ("parent", hax);
-  
+
   ## Add common properties
   if (strcmp (graphics_toolkit (), "gnuplot"))
     ## FIXME: this is a workaround for bug #39394 (gnuplot toolkit)
     defprops = {"position", "axesposition", [0.3 0.3 0.1 0.1], ...
-                "units", "textunits", "data"}; 
+                "units", "textunits", "data"};
   else
     defprops = {"position", "axesposition", [0.3 0.3 0.1 0.1], ...
                 "units", "axesunits", "normalized"};
   endif
   addbaseprops (h, defprops);
   setappdata (h, "__former_units__", "normalized");
 
   ## Common updaters
   listener = {@update_position, h, true};
-  
+
   addlistener (hax, "figsize_points", listener);
-  
+
   delfcn = @() dellistener (hax, "figsize_points", listener);
   set (h, "deletefcn", delfcn);
-  
+
   addlistener (h, "units", {@update_position, h});
-  
+
   ## Now work with normalized coordinates
   if (! isempty (pos))
     set (h, "position", pos);
   endif
   pos = getnormpos (h);
-  
+
   ## Build annotation object and its specific properties/updaters
-  switch objtype
+  switch (objtype)
     case {"line", "arrow", "doublearrow", "textarrow"}
       ## Add properties
       proptable = lineprops ();
       if (strcmp (objtype, "arrow"))
         proptable = [proptable arrowprops()];
       elseif (strcmp (objtype, "doublearrow"))
         proptable = [proptable dblarrowprops()];
       elseif (strcmp (objtype, "textarrow"))
         proptable = [proptable arrowprops()];
         proptable = [proptable textprops()];
       endif
 
       addbaseprops (h, proptable);
-      
+
       ## create line
       hli = line ([pos(1); (pos(1) + pos(3))],
                   [pos(2); (pos(2) + pos(4))],
                   "parent", h, "color", get (h, "color"),
                   "linestyle", get (h, "linestyle"),
                   "linewidth", get (h, "linewidth"));
-      
+
       ## create patch(s) and text
       if (strcmp (objtype, "arrow"))
         [x, y] = arrowcoordinates (h);
         hpa = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
         update_arrow (h, {}, "position", hpa);
       elseif (strcmp (objtype, "doublearrow"))
         [x, y] = arrowcoordinates (h, 1);
         hpa = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
-        
+
         [x, y] = arrowcoordinates (h, 2);
         hpa(2) = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
-        
+
         update_arrow (h, {}, "position", hpa);
       elseif (strcmp (objtype, "textarrow"))
         [x, y] = arrowcoordinates (h);
         hpa = patch (x, y, get (h, "color"), "parent", h,
                     "edgecolor",  get (h, "color"));
         update_arrow (h, {}, "position", hpa);
-        
+
         hte = text (get (h, "position")(1), ...
                    get (h, "position")(2), ...
                    get (h, "string"), "parent", h, ...
                    "color", get (h, "color"));
         propnames = textprops ("names");
         for ii = 1:numel (propnames)
           update_text (h, {}, propnames{ii}, hte);
         endfor
         update_text (h, {}, "position", hte);
       endif
-      
+
       ## updaters
       addlistener (h, "color", {@update_line, "color", hli});
       addlistener (h, "linestyle", {@update_line, "linestyle", hli});
       addlistener (h, "linewidth", {@update_line, "linewidth", hli});
       addlistener (h, "x", {@update_line, "x", hli});
       addlistener (h, "y", {@update_line, "y", hli});
       addlistener (h, "position", {@update_line, "position", hli});
 
       if (strcmp (objtype, "arrow"))
         addlistener (h, "position", {@update_arrow, "position", hpa});
         addlistener (h, "headwidth", {@update_arrow, "position", hpa});
         addlistener (h, "headstyle", {@update_arrow, "position", hpa});
         addlistener (h, "headlength", {@update_arrow, "position", hpa});
         addlistener (h, "color", {@update_arrow, "color", hpa});
       elseif (strcmp (objtype, "doublearrow"))
         addlistener (h, "position", {@update_arrow, "position", hpa});
-        addlistener (h, "head1width", 
+        addlistener (h, "head1width",
                      {@update_arrow, "position", [hpa(1) 0]});
         addlistener (h, "head2width",
                      {@update_arrow, "position", [0 hpa(2)]});
         addlistener (h, "head1style",
                      {@update_arrow, "position", [hpa(1) 0]});
         addlistener (h, "head2style",
                      {@update_arrow, "position", [0 hpa(2)]});
         addlistener (h, "head1length",
@@ -438,98 +438,98 @@ function h = buildannot (hax, objtype, p
                             "verticalalignment"})))
             addlistener (h, propnames{ii}, ...
                          {@update_text, "position", hte});
           endif
         endfor
         addlistener (h, "position", {@update_text, "position", hte});
         addlistener (h, "color", {@update_text, "color", hte});
       endif
-      
+
     case {"rectangle", "ellipse"}
-         
+
       ## Add properties
       addbaseprops (h, rectprops ());
-      
+
       ## Create rectangle/ellipse
       if (strcmp (objtype, "rectangle"))
         [x, y] = pos2rect (pos);
       else
         [x, y] = pos2ell (pos);
       endif
-          
-      hr =  patch (x, y, "parent", h);
-      
+
+      hr = patch (x, y, "parent", h);
+
       propnames = rectprops ("names");
       for ii = 1:numel (propnames)
         update_rect (h, {}, propnames{ii}, hr, objtype);
       endfor
 
       ## Updaters
       addlistener (h, "position", {@update_rect, "position", hr, objtype});
       for ii = 1:numel (propnames)
         addlistener (h, propnames{ii},
                      {@update_rect, propnames{ii}, hr, objtype});
       endfor
 
     case "textbox"
-         
+
       ## Add properties
       addbaseprops (h, textboxprops());
 
       ## Create textbox
       hpa = patch ("parent", h);
       hte = text (pos(1), pos(2), get (h, "string"), "parent", h, ...
                  "color", get (h, "color"));
       update_textbox (h, {}, "position", [hte hpa]);
-      
+
       propnames = textboxprops ("names");
       for ii = 1:numel (propnames)
         update_textbox (h, {}, propnames{ii}, [hte hpa]);
       endfor
 
       ## Updaters
       addlistener (h, "position", {@update_textbox, "position", [hte hpa]});
       for ii = 1:numel (propnames)
         addlistener (h, propnames{ii},
                      {@update_textbox, propnames{ii}, [hte hpa]});
       endfor
       addlistener (h, "horizontalalignment",
                    {@update_textbox, "position", [hte hpa]});
       addlistener (h, "verticalalignment",
                    {@update_textbox, "position", [hte hpa]});
-      
+
   endswitch
-  
+
 endfunction
 
 function props = lineprops (varargin)
   props = {"color", "color", [0 0 0], ...
            "linestyle",  "linelinestyle", "-", ...
            "linewidth", "linelinewidth", 0.5, ...
            "x", "linexdata", [0.3 0.4], ...
            "y", "lineydata", [0.3 0.4]};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
 endfunction
 
 function props = arrowprops (varargin)
   props = {"headlength", "data", 10, ...
            "headstyle",  "radio", "diamond|ellipse|none|plain|rectangle|vback1|{vback2}|vback3", ...
-           "headwidth", "data", 10};
+           "headwidth",  "data", 10};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
 endfunction
 
 function props = dblarrowprops (varargin)
   props = {"head1length", "data", 10, ...
            "head1style",  "radio", "diamond|ellipse|none|plain|rectangle|vback1|{vback2}|vback3", ...
-           "head1width", "data", 10, ...
+           "head1width",  "data", 10, ...
            "head2length", "data", 10, ...
            "head2style",  "radio", "diamond|ellipse|none|plain|rectangle|vback1|{vback2}|vback3", ...
            "head2width", "data", 10};
   if (strcmp (varargin, "names"))
     props = props(1:3:end);
   endif
 endfunction
 
@@ -598,24 +598,24 @@ function update_position (h1, dummy, h, 
     pos = convertposition (h, getappdata (h, "__former_units__"),
                            get (h, "units"));
     setappdata (h, "__former_units__", get (h, "units"));
     set (h, "position", pos);
   else
     ## FIXME: Inefficient trick to force all objects to be redrawn
     set (h, "position", [0 0 .5 .5],
          "position", get (h, "position"));
-  endif      
+  endif
 endfunction
 
 
 function update_line (h, dummy, prop, hli)
   persistent recursive = false;
   if (! recursive)
-    switch prop
+    switch (prop)
       case "color"
         set (hli, "color", get (h, "color"));
       case "linestyle"
         set (hli, "linestyle", get (h, "linestyle"));
       case "linewidth"
         set (hli, "linewidth", get (h, "linewidth"));
       case "x"
         ## Update position
@@ -626,17 +626,17 @@ function update_line (h, dummy, prop, hl
         recursive = true;
         set (h, "position", pos);
         recursive = false;
 
         ## Draw in normalized coordinates
         pos = getnormpos (h);
         x = [pos(1) (pos(1) + pos(3))];
         set (hli, "xdata", x);
-        
+
       case "y"
        ## Update position
         y = get (h, "y");
         pos = get (h, "position");
         pos(2) = y(1);
         pos(4) = diff (y);
         recursive = true;
         set (h, "position", pos);
@@ -646,29 +646,29 @@ function update_line (h, dummy, prop, hl
         pos = getnormpos (h);
         y = [pos(2) (pos(2) + pos(4))];
         set (hli, "ydata", y);
       case "position"
         ## Update x and y
         pos = get (h, "position");
         x = [pos(1) (pos(1) + pos(3))];
         y = [pos(2) (pos(2) + pos(4))];
-        
+
         recursive = true;
         set (h, "x", x);
         set (h, "y", y);
         recursive = false;
-        
+
         ## Draw in normalized coordinates
         pos = getnormpos (h);
         x = [pos(1) (pos(1) + pos(3))];
         y = [pos(2) (pos(2) + pos(4))];
         set (hli, "xdata", x);
         set (hli, "ydata", y);
-        
+
     endswitch
   endif
 endfunction
 
 function [x, y] = arrowcoordinates (h, nar = [])
   warning ("off", "Octave:broadcast", "local")
   pos = getnormpos (h);
   ppos = norm2pts (h, pos(3:4).');
@@ -689,17 +689,17 @@ function [x, y] = arrowcoordinates (h, n
     ln = get (h, "head2length"); # in points
     wd = get (h, "head2width");
     headstyle = get (h, "head2style");
     pos = pos(1:2) .+ pos(3:4);
   else
     error ("annotation: %d, no such arrow number")
   endif
 
-  switch headstyle
+  switch (headstyle)
     case "diamond"
       x = [0 -ln/2 -ln -ln/2 0];
       y = [0 -wd/2 0 wd/2 0];
     case "ellipse"
       pts = linspace (0, 2*pi, 12);
       x = ln/2 * (cos (pts) - 1);
       y = wd/2 * sin (pts);
     case "rectangle"
@@ -724,93 +724,93 @@ function [x, y] = arrowcoordinates (h, n
       error ("annotation: \"%s\" headstyle not implemented", headstyle)
   endswitch
 
   R = [cos(ang) -sin(ang);
        sin(ang) cos(ang)];
   XY = R * [x; y];
   XY = pts2norm (h, XY);
   XY = pos(1:2).' .+ XY;
-  
+
   x = XY(1,:).';
   y = XY(2,:).';
 endfunction
 
 function update_arrow (h, dummy, prop, hpa = [])
   persistent recursive = false;
-  
+
   nar = [];
   for ii = 1:numel (hpa)
     if (numel (hpa) == 2)
       nar = ii;
     endif
     if (hpa(ii))
-      switch prop
+      switch (prop)
         case "position"
           [x, y] = arrowcoordinates (h, nar);
           set (hpa(ii), "xdata", x, "ydata", y);
         case "color"
           set (hpa(ii), "facecolor", get (h, "color"));
           set (hpa(ii), "edgecolor", get (h, "color"));
       endswitch
     endif
   endfor
 endfunction
 
 function update_text (h, dummy, prop, hte)
   persistent recursive = false;
 
   if (! recursive)
-    switch prop
+    switch (prop)
       case "position"
         if (isempty (get (h, "string")))
           return
         endif
-        
+
         pos = getnormpos (h);
-        
+
         set (hte, "position", [textcoordinates(hte, pos) 0]);
-        
+
       otherwise
         if (strncmp (prop, "text", 4))
           set (hte, prop(5:end), get (h, prop));
         else
           set (hte, prop, get (h, prop));
         endif
     endswitch
   endif
 endfunction
 
 function update_textbox (h, dummy, prop, htb)
   persistent recursive = false;
 
   hte = htb(1);
   hpa = htb(2);
-  
+
   if (! recursive)
-    switch prop
+    switch (prop)
       case {"edgecolor", "facealpha",
             "linestyle", "linewidth"}
         set (hpa, prop, get (h, prop));
       case {"backgroundcolor"}
         set (hpa, "facecolor", get (h, prop));
       otherwise
         if (! any (strcmp (prop, {"fitboxtotext", "position"})))
           set (hte, prop, get (h, prop));
         endif
-           
+
         pos = getnormpos (h);
-        
+
         if (strcmp (get (h, "fitboxtotext"), "on"))
           pos(3:4) = get (hte, "extent")(3:4);
         endif
-        
+
         [x, y] = pos2rect (pos);
         set (hpa, "xdata", x', "ydata", y');
-          
+
         switch (get (h, "horizontalalignment"))
           case "left"
             x = x(1);
           case "center"
             x = mean (x(1:2));
           case "right"
             x = x(2);
         endswitch
@@ -821,102 +821,102 @@ function update_textbox (h, dummy, prop,
           case "middle"
             y = mean (y(2:3));
           case {"bottom", "baseline"}
             y = y(2);
         endswitch
         set (hte, "position", [x y 0]);
     endswitch
   endif
-  
+
 endfunction
 
 function XY = textcoordinates (hte, pos)
   warning ("off", "Octave:broadcast", "local")
 
   ## Get the "tight" extent of the text object in points units
   textpos = get(hte, "position");
   rot = get (hte, "rotation");
   units = get (hte, "units");
 
   set (hte, "rotation", 0, "units", "points", "position", [0 0 0]);
   ext = get (hte, "extent");
   set (hte, "rotation", rot, "units", units, "position", textpos);
-  
+
   ## Find which one of the 8 following points we should align the
   ## arrow with
   ##  8-----7-----6
   ##  1  text box 5
   ##  2-----3-----4
-  
+
   ## FIXME: Matlab's horizontal/verticalalignment properties are
-  ## interpreted differently: horizontalalignment is passed to the 
+  ## interpreted differently: horizontalalignment is passed to the
   ## underlying text object whereas the verticalalignement controls
   ## the vertical alignment of the arrow.
-  
+
   ang = angle (complex (pos(3), pos(4)));
   rot = rot / 180 * pi;
 
-  [~, pt] = min (abs ((-pi:pi/4:pi) - ang)); 
+  [~, pt] = min (abs ((-pi:pi/4:pi) - ang));
   pt -= floor (rot / (pi/4));
   if (pt <= 0)
     pt = rem (pt, 8) + 8;
   elseif (pt > 8)
     pt = rem (pt, 8);
   endif
-  
+
   ## Compute the text actual "position" property
   dx = ext(3)/2;
   dy = ext(4)/2;
   XY = [-dx -dx 0 dx dx dx 0 -dx;
         0 -dy -dy -dy 0 dy dy dy];
-  
-  switch get (hte, "horizontalalignment")
+
+  switch (get (hte, "horizontalalignment"))
     case "left"
       XY(1,:) += dx;
     case "right"
       XY(1,:) -= dx;
   endswitch
-  
-  switch get (hte, "verticalalignment")
+
+  switch (get (hte, "verticalalignment"))
     case {"baseline", "bottom"}
       XY(2,:) += dy;
     case {"cap", "top"}
       XY(2,:) -= dy;
   endswitch
-  
+
   R = [cos(rot) -sin(rot);
        sin(rot) cos(rot)];
   XY = R * XY;
   XY = pts2norm (get (hte, "parent"), XY);
   XY = pos(1:2) .- XY(:,pt).';
-  
+
 endfunction
 
 function nXY = pts2norm (h, pXY)
   sz = get (get (h,"parent"), "figsize_points");
-  
+
   nXY(1,:) = pXY(1,:) ./ sz(1);
   nXY(2,:) = pXY(2,:) ./ sz(2);
 endfunction
 
 function pXY = norm2pts (h, nXY)
   sz = get (get (h,"parent"), "figsize_points");
-  
+
   pXY(1,:) = nXY(1,:) .* sz(1);
   pXY(2,:) = nXY(2,:) .* sz(2);
 endfunction
 
 function pos = convertposition (h, from, to)
-  ## FIXME: handle "characters" units  
+  ## FIXME: handle "characters" units
   pos = get (h, "position");
-  
+
   ## First convert to normalized coordinates
   sz = get (get (h,"parent"), "figsize_points");
-  switch from
+  switch (from)
     case "centimeters"
       pos /= 2.54;
       pos *= 72;
       pos(1:2:end) /= sz(1);
       pos(2:2:end) /= sz(2);
     case "inches"
       pos *= 72;
       pos(1:2:end) /= sz(1);
@@ -924,29 +924,29 @@ function pos = convertposition (h, from,
     case "pixels"
       pos /= get (0, "screenpixelsperinch");
       pos *= 72;
       pos(1:2:end) /= sz(1);
       pos(2:2:end) /= sz(2);
   endswitch
 
   ## Then convert to requested coordinates
-  switch to
+  switch (to)
     case "centimeters"
       sz /= 72;
       sz *= 2.54;
       pos(1:2:end) *= sz(1);
       pos(2:2:end) *= sz(2);
     case "inches"
       sz /= 72;
       pos(1:2:end) *= sz(1);
       pos(2:2:end) *= sz(2);
     case "pixels"
       sz /= 72;
-      sz *= get (0, "screenpixelsperinch"); 
+      sz *= get (0, "screenpixelsperinch");
       pos(1:2:end) *= sz(1);
       pos(2:2:end) *= sz(2);
   endswitch
 
 endfunction
 
 function pos = getnormpos (h)
   units = get (h, "units");
@@ -957,40 +957,40 @@ function [x, y] = pos2rect (pos)
   x = [pos(1) pos(1)+pos(3) pos(1)+pos(3) pos(1)];
   y = [pos(2) pos(2) pos(2)+pos(4) pos(2)+pos(4)];
 endfunction
 
 function [x, y] = pos2ell (pos)
   a = pos(3)/2;
   b = pos(4)/2;
 
-  ## Arbitrarily use 100 points 
+  ## Arbitrarily use 100 points
   ## when it is spread over
   ang = linspace (0, 2*pi, 100);
-  
+
   x = a * cos (ang);
   y = b * sin (ang);
 
   x += pos(1) + a;
   y += pos(2) + b;
 endfunction
 
 function update_rect (h, dummy, prop, hre, typ)
   persistent recursive = false;
-  
+
   if (! recursive)
-    switch prop
+    switch (prop)
       case "position"
         pos = getnormpos (h);
         if (strcmp (typ, "rectangle"))
           [x, y] = pos2rect (pos);
         else
           [x, y] = pos2ell (pos);
         endif
-        
+
         set (hre, "xdata", x, "ydata", y);
       otherwise
         set (hre, prop, get (h, prop));
     endswitch
   endif
 endfunction
 
 
@@ -1005,72 +1005,72 @@ endfunction
 %! y0 = 0.5;
 %! r = 0.3;
 %! for ii = 1:4
 %!   x = r * cos (ang(ii)) + x0;
 %!   y = r * sin (ang(ii)) + y0;
 %!   annotation ('textarrow', [x x0], [y y0], ...
 %!               'string', lab{ii},  'fontsize', 20);
 %! end
-%! 
+%!
 %! h = annotation ('doublearrow', [x0 x0], [y0-r y0+r], ...
 %!                 'head1style', 'diamond', 'head1length', 60, ...
 %!                 'head2style', 'diamond', 'head2length', 60);
 
 %!demo
 %! clf; axes ('visible', 'off');
 %! plot (1:10);
 %! xlabel ('X-LABEL')
 %! ylabel ('LARGE Y-LABEL', 'fontsize', 20)
 %! title ('FIGURE LAYOUT', 'fontsize', 24)
-%! 
+%!
 %! ti = get (gca, 'tightinset');
 %! pos = get (gca, 'position');
 %! pos(1:2) = pos(1:2) - ti(1:2);
 %! pos(3) = pos(3) + ti (1) + ti (3);
 %! pos(4) = pos(4) + ti (2) + ti (4);
-%! 
+%!
 %! ht = annotation ('textbox', pos, 'string', ' Position + tighinset', ...
 %!                  'fitboxtotext', 'off', 'linestyle', '--', ...
 %!                  'edgecolor', 'g', 'linewidth', 3, 'color', 'g', ...
 %!                  'verticalalignment', 'bottom', 'fontsize', 15);
-%! 
+%!
 %! ho = annotation ('textbox', get (gca, 'outerposition'), ...
 %!                  'string', ' Outerposition','fitboxtotext', 'off', ...
 %!                  'linestyle', '--', 'edgecolor', 'r', ...
 %!                  'linewidth', 3, 'color', 'r', ...
 %!                  'verticalalignment', 'bottom', 'fontsize', 15);
-%! 
+%!
 %! hi = annotation ('textbox', get (gca, 'position'), ...
 %!                  'string', ' Position','fitboxtotext', 'off', ...
 %!                  'linestyle', '--', 'edgecolor', 'b', ...
 %!                  'linewidth', 3, 'color', 'b', ...
 %!                  'verticalalignment', 'bottom', 'fontsize', 15);
 
 %!demo
 %! clf; axes ('visible', 'off');
 %! h = annotation ('arrow');
-%! 
+%!
 %! %% Get allowed headstyles
 %! styles = set (h, 'headstyle');
 %! delete (h)
-%! 
+%!
 %! %% Textbox for the title
 %! annotation ('textbox', [0.1 0 0.8 1], 'string', ...
 %!             '"headstyle" property:', ...
 %!             'backgroundcolor', [0.7 0.7 0.7], 'fontsize', 20, ...
 %!             'fitboxtotext', 'off', 'verticalalignment', 'top', ...
 %!             'horizontalalignment', 'center');
-%! 
-%! %% Textarrows 
+%!
+%! %% Textarrows
 %! ns = numel (styles);
 %! nrows = ceil (ns/2);
 %! dy = 1/nrows;
 %! y = 1 - dy/2;
-%! 
+%!
 %! jj = 1;
 %! for ii = 1:nrows
 %!   annotation ('textarrow', [0.3 0.5], [y y], ...
 %!               'string', ['"' styles{jj} '"'], 'fontsize', 15, ...
 %!               'headstyle', styles{jj}, 'textcolor', 'b');
 %!   jj = jj + 1;
 %!   if (jj <= ns)
 %!     annotation ('textarrow', [0.7 0.5], [y y], ...
@@ -1079,86 +1079,86 @@ endfunction
 %!   jj = jj + 1;
 %!   end
 %!   y = y - dy;
 %! end
 %! annotation ('line', [0.5 0.5], [dy/2 1-dy/2], 'linestyle', '-.')
 
 %!demo
 %! clf; axes ('visible', 'off');
-%! 
+%!
 %! %% Textbox for the title
 %! annotation ('textbox', [0.1 0 0.8 1], 'string', ...
 %!             'Text arrows: text rotation', ...
 %!             'backgroundcolor', [0.7 0.7 0.7], 'fontsize', 20, ...
 %!             'fitboxtotext', 'off', 'verticalalignment', 'top', ...
 %!             'horizontalalignment', 'center');
-%! 
-%! %% Textarrows 
+%!
+%! %% Textarrows
 %! for ii = 1:10
 %!   rot = floor (rand (1) * 360 / 90) * 90;
 %!   annotation ('textarrow', 0.5 + [(0.6 * (rand(1) - .5)) 0], ...
 %!               0.5 + [(0.6 * (rand(1) - .5)) 0], ...
 %!               'string', 'A text', ...
 %!               'headstyle', 'none', 'textrotation', rot);
 %! end
 
 %!demo
 %! clf; axes ('visible', 'off');
-%! 
+%!
 %! %% Textbox for the title
 %! annotation ('textbox', [0.1 0 0.8 1], 'string', ...
 %!             'Text arrows: text alignment', ...
 %!             'backgroundcolor', [0.7 0.7 0.7], 'fontsize', 20, ...
 %!             'fitboxtotext', 'off', 'verticalalignment', 'top', ...
 %!             'horizontalalignment', 'center');
-%! 
+%!
 %! %% Textarrows
 %! halig = {'right', 'center', 'left'};
 %! ii = 1;
 %! for x = .3:.2:.7
 %!   annotation ('textarrow', [x .5], [.5 .9], ...
 %!               'string', {'Multiple lines', 'text'}, ...
 %!               'headstyle', 'none', 'horizontalalignment', halig{ii});
 %!   ii = ii + 1;
 %! end
 
 %!demo
 %! clf; axes ('visible', 'off');
-%! 
+%!
 %! x = 0:0.01:2*pi;
 %! y = sin (x);
 %! plot (x, y)
-%! 
+%!
 %! %% Extrema
 %! x0 = [pi/2 3*pi/2];
 %! y0 = [1 -1];
-%! 
+%!
 %! %% Convert axes coordinates into normalized coordinates
 %! xl = xlim ();
 %! yl = [-1.2 1.5];
 %! ylim (yl);
 %! x0 = (x0 - xl(1)) / diff(xl);
 %! y0 = (y0 - yl(1)) / diff(yl);
-%! 
+%!
 %! pos = get (gca (), 'position');
 %! x0 = x0*pos(3) + pos(1);
 %! y0 = y0*pos(4) + pos(2);
-%! 
-%! 
+%!
+%!
 %! %% Textarrows
 %! for ii = 1:2
 %!   annotation ('doublearrow', [(x0(ii) - .05) (x0(ii) + .05)], ...
 %!               [y0(ii) y0(ii)], 'head1style', 'vback3', ...
 %!               'head2style', 'vback3', ...
 %!               'head1width', 4, 'head2width', 4)
 %!   h = annotation ('textarrow', [0.5 x0(ii)], [.85 y0(ii)], ...
 %!                   'linestyle', '--', 'headstyle', 'none');
 %! end
-%! set (h, 'string', 'Extrema', 'fontsize', 15) 
+%! set (h, 'string', 'Extrema', 'fontsize', 15)
 
 ## test line properties
 %!test
 %! hf = figure ("visible", "off");
 %! hax = axes ();
 %! unwind_protect
 %!   h = annotation ("line", [0.2 0.7], [0.2 0.7], "linewidth", 2,
 %!                   "linestyle", "--", "color", "r");
@@ -1171,33 +1171,33 @@ endfunction
 %!   close (hf)
 %! end_unwind_protect
 
 ## test textarrow properties
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = annotation ("textarrow", [0.2 0.7], [0.2 0.7],
-%!                   "string", "Hello!", "fontsize", 20, 
+%!                   "string", "Hello!", "fontsize", 20,
 %!                   "textrotation", 90, "textcolor", "r");
 %!   hte = findobj (h, "-depth", 1, "type", "text");
 %!   assert (get (hte, "string"), "Hello!");
 %!   assert (get (hte, "fontsize"), 20);
 %!   assert (get (hte, "rotation"), 90);
 %!   assert (get (hte, "color"), [1 0 0]);
 %! unwind_protect_cleanup
 %!   close (hf)
 %! end_unwind_protect
 
 ## test textbox properties
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = annotation ("textbox", [0.2 0.2 0.7 0.3], "string", "Hello!",
-%!                   "horizontalalignment", "left", 
+%!                   "horizontalalignment", "left",
 %!                   "verticalalignment", "bottom",
 %!                   "backgroundcolor", "r");
 %!   hte = findobj (h, "-depth", 1, "type", "text");
 %!   hpa = findobj (h, "-depth", 1, "type", "patch");
 %!   assert (get (hte, "string"), "Hello!");
 %!   assert (get (hte, "verticalalignment"), "bottom");
 %!   assert (get (hte, "horizontalalignment"), "left");
 %!   assert (get (hpa, "facecolor"), [1 0 0]);
@@ -1229,16 +1229,16 @@ endfunction
 %! unwind_protect
 %!   h = annotation (hf1, "doublearrow");
 %!   assert (ancestor (h, "figure"), hf1);
 %!   assert (gcf (), hf2);
 %! unwind_protect_cleanup
 %!   close (hf1)
 %!   close (hf2)
 %! end_unwind_protect
-  
+
 ## Test input validation
 %!error <unknown annotation type foo> annotation ("foo")
 %!error annotation ([], "foo")
 %!error annotation ({})
 %!error annotation ("line", [.5 .6])
 %!error <expect 2 elements vectors for X and Y> annotation ("line", 1:3, 1:3)
 %!error <expect 4 elements vector for POS> annotation ("textbox", 1:3)
diff --git a/scripts/plot/appearance/clabel.m b/scripts/plot/appearance/clabel.m
--- a/scripts/plot/appearance/clabel.m
+++ b/scripts/plot/appearance/clabel.m
@@ -122,17 +122,17 @@ function h = clabel (c, varargin)
         set (hg, "showtext", "on");
       endif
     endif
     htmp = findobj (hg, "type", "text");
     if (! isempty (varargin))
       set (htmp, varargin{:});
     endif
   else
-    htmp =  __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
+    htmp = __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
   endif
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -302,17 +302,17 @@ function [hleg, hleg_obj, hplot, labels]
   elseif (nargs > 1 && iscellstr (varargin{1}))
     ## Cell array of labels followed by property/value pairs
     varargin = {varargin{1}{:}, varargin{2:end}};
     nargs = numel (varargin);
   endif
 
   have_labels = (nargs > 0);
   hobjects = [];
-  hplots  = [];
+  hplots = [];
   text_strings = {};
 
   if (delete_leg)
     delete (hlegend);
     hlegend = [];
   elseif (find_leg_hdl)
     ## Don't change anything about legend.
     ## hleg output will be assigned hlegend value at end of function.
@@ -331,17 +331,18 @@ function [hleg, hleg_obj, hplot, labels]
     if (! isempty (hlegend))
       set (hlegend, "box", "on", "visible", "on");
     endif
   elseif (strcmp (box, "off"))
     if (! isempty (hlegend))
       set (hlegend, "box", "off", "visible", "off");
     endif
   elseif (! have_labels && ! isempty (hlegend)
-          && ! (strcmp (location, "default") && strcmp (orientation, "default")))
+          && ! (strcmp (location, "default")
+                && strcmp (orientation, "default")))
     ## Changing location or orientation of existing legend
     if (strcmp (location, "default"))
       set (hlegend, "orientation", orientation);
     elseif (strcmp (orientation, "default"))
       if (outside)
         set (hlegend, "location", [location "outside"]);
       else
         set (hlegend, "location", location);
@@ -353,17 +354,17 @@ function [hleg, hleg_obj, hplot, labels]
       else
         set (hlegend, "location", location,
                       "orientation", orientation);
       endif
     endif
   else
     ## Create new legend
     hobjects = [];
-    hplots  = [];
+    hplots = [];
     text_strings = {};
 
     if (have_labels)
       ## Check for valid data that can be labeled.
       have_data = false;
       have_dname = false;
       for k = 1 : nkids
         typ = get (kids(k), "type");
@@ -494,17 +495,17 @@ function [hleg, hleg_obj, hplot, labels]
     endif
 
     if (isempty (hplots))
       if (! isempty (hlegend))
         fkids = get (fig, "children");
         delete (fkids(fkids == hlegend));
         hlegend = [];
         hobjects = [];
-        hplots  = [];
+        hplots = [];
         text_strings = {};
       endif
     else
       ## Preserve the old legend if it exists
       if (! isempty (hlegend))
         if (strcmp (textpos, "default"))
           textpos = get (hlegend, "textposition");
         endif
diff --git a/scripts/plot/appearance/orient.m b/scripts/plot/appearance/orient.m
--- a/scripts/plot/appearance/orient.m
+++ b/scripts/plot/appearance/orient.m
@@ -151,15 +151,15 @@ endfunction
 %! assert (get (hfig, "paperposition"), fullpaperposition);
 
 %!test
 %! orient portrait   # errors don't change the state
 %! assert (orient, "portrait");
 %! assert (get (hfig, "papersize"), papersize);
 %! assert (get (hfig, "paperposition"), paperposition);
 
-%% Test input validation
+## Test input validation
 %!error orient (1.73, 2.5)
 %!error <unknown ORIENTATION> orient ("nobody")
 
 %!test
 %! close (hfig);
 
diff --git a/scripts/plot/appearance/private/__axis_limits__.m b/scripts/plot/appearance/private/__axis_limits__.m
--- a/scripts/plot/appearance/private/__axis_limits__.m
+++ b/scripts/plot/appearance/private/__axis_limits__.m
@@ -37,17 +37,17 @@ function retval = __axis_limits__ (fcn, 
     arg = varargin{1};
     if (ischar (arg))
       if (strcmpi (arg, "mode"))
         retval = get (hax, fcnmode);
       elseif (any (strcmpi (arg, {"auto", "manual"})))
         set (hax, fcnmode, arg);
       endif
     else
-      if (!isnumeric (arg) && any (size (arg(:)) != [2, 1]))
+      if (! isnumeric (arg) && any (size (arg(:)) != [2, 1]))
         error ("%s: LIMITS must be a 2-element vector", fcn);
       else
         if (arg(1) >= arg(2))
           error ("%s: axis limits must be increasing", fcn);
         else
           autoscale = isinf (arg);
           if (any (autoscale))
             set (hax, fcnmode, "auto");
diff --git a/scripts/plot/appearance/whitebg.m b/scripts/plot/appearance/whitebg.m
--- a/scripts/plot/appearance/whitebg.m
+++ b/scripts/plot/appearance/whitebg.m
@@ -70,25 +70,25 @@ function whitebg (varargin)
 
   axes = findall (fig, "type", "axes");
   if (isnan (color))
     ## Root figure. Set the default axes and figure properties so that
     ## subsequent plots have the new color scheme
     if (isroot)
       fac = get (0, "factory");
       fields = fieldnames (fac);
-      fieldindex = intersect (find (!cellfun ("isempty", regexp (fields, 'color'))), union (find (!cellfun ("isempty", regexp (fields, 'factoryaxes.*'))), find (!cellfun ("isempty", regexp (fields, 'factoryfigure.*')))));
+      fieldindex = intersect (find (! cellfun ("isempty", regexp (fields, 'color'))), union (find (! cellfun ("isempty", regexp (fields, 'factoryaxes.*'))), find (!cellfun ("isempty", regexp (fields, 'factoryfigure.*')))));
 
       ## Check whether the factory value has been replaced
       for nf = 1 : numel (fieldindex);
-        defaultfield = strrep (fields {fieldindex (nf)}, "factory", "default");
+        defaultfield = strrep (fields{fieldindex(nf)}, "factory", "default");
         try
-          defaultvalue = 1 - get (0, defaultfield {n});
+          defaultvalue = 1 - get (0, defaultfield{n});
         catch
-          field = fields {fieldindex (nf)};
+          field = fields{fieldindex(nf)};
           defaultvalue = 1 - subsref (fac, struct ("type", ".", "subs", field));
         end_try_catch
         set (0, defaultfield, defaultvalue);
       endfor
     endif
 
     ## Load all objects which qualify for being searched.
     handles = fig;
@@ -103,34 +103,35 @@ function whitebg (varargin)
     endwhile
 
     for nh = 1 : numel (h)
       p = get (h (nh));
       fields = fieldnames (p);
       fieldindex = find (!cellfun ("isempty", regexp (fields, 'color')));
       if (numel (fieldindex))
         for nf = 1 : numel (fieldindex);
-          field = fields {fieldindex (nf)};
+          field = fields{fieldindex(nf)};
           c = subsref (p, struct ("type", ".", "subs", field));
           if (! ischar (c) && columns (c) == 3)
             set (h (nh), field, 1 - c);
           endif
         endfor
       endif
 
       ## If h(nh) is a figure or axes invert default color properties
       typ = subsref (p, struct ("type", ".", "subs", "type"));
       if (strcmp (typ, "axes") || strcmp (typ, "figure"))
         def = get (h (nh), "default");
         fields = fieldnames (def);
         if (! isempty (fields))
-          fieldindex = find (!cellfun ("isempty", regexp (fields, 'color')));
+          fieldindex = find (! cellfun ("isempty", regexp (fields, 'color')));
           for nf = 1 : numel (fieldindex)
-            defaultfield = fields {fieldindex (nf)};
-            defaultvalue = 1 - subsref (def, struct ("type", ".", "subs", defaultfield));
+            defaultfield = fields{fieldindex(nf)};
+            defaultvalue = ...
+              1 - subsref (def, struct ("type", ".", "subs", defaultfield));
             set (h (nh), defaultfield, defaultvalue);
           endfor
         endif
       endif
     endfor
   else
     ## FIXME
     ## Is this the right thing to do in this case?
diff --git a/scripts/plot/draw/area.m b/scripts/plot/draw/area.m
--- a/scripts/plot/draw/area.m
+++ b/scripts/plot/draw/area.m
@@ -266,17 +266,17 @@ endfunction
 %!demo
 %! clf;
 %! x = 0:10;
 %! y = rand (size (x));
 %! h = area (x, y);
 %! set (h, 'ydata', sort (get (h, 'ydata')))
 %! title ('area() plot of sorted data');
 
-%% Test input validation
+## Test input validation
 %!error area ()
 %!error area (1,2,3,4)
 %!error <X and Y must be real vectors or matrices> area ({1})
 %!error <X and Y must be real vectors or matrices> area (1+i)
 %!error <X and Y must be real vectors or matrices> area (1:2, {1, 2})
 %!error <X and Y must be real vectors or matrices> area (1:2, [1 1+i])
 %!error <LVL must be a real scalar> area (1, i)
 %!error <LVL must be a real scalar> area (1, 2, ones (2,2))
diff --git a/scripts/plot/draw/colorbar.m b/scripts/plot/draw/colorbar.m
--- a/scripts/plot/draw/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -138,37 +138,38 @@ function h = colorbar (varargin)
       if (nargout > 0)
         h = hcb;
       endif
       return;
     else
       ## FIXME: No listener on location property so have to re-create
       ##        colorbar whenever an option changes.
       ##        re-instate this code if listener is developed.
-      # if (! isempty (loc))
-      #   set (hcb, "location", loc);
-      # endif
-      # if (! isempty (args))
-      #   set (hcb, args{:});
-      # endif
+      ## if (! isempty (loc))
+      ##   set (hcb, "location", loc);
+      ## endif
+      ## if (! isempty (args))
+      ##   set (hcb, args{:});
+      ## endif
       ax = get (get (hcb, "parent"), "currrentaxes");
     endif
   endif
 
   if (isempty (loc))
     loc = "eastoutside";
   endif
   if (isempty (ax))
     ax = gca ();
   endif
 
   showhiddenhandles = get (0, "showhiddenhandles");
   unwind_protect
     set (0, "showhiddenhandles", "on");
-    cax = findobj (get (ax, "parent"), "tag", "colorbar", "type", "axes", "axes", ax);
+    cax = findobj (get (ax, "parent"),
+                   "tag", "colorbar", "type", "axes", "axes", ax);
     if (! isempty (cax))
       delete (cax);
     endif
   unwind_protect_cleanup
     set (0, "showhiddenhandles", showhiddenhandles);
   end_unwind_protect
 
   if (! deleting)
@@ -182,18 +183,18 @@ function h = colorbar (varargin)
     ## FIXME: Should this be ancestor to accommodate hggroups?
     hpar = get (ax, "parent");
     clen = rows (get (hpar, "colormap"));
     cext = get (ax, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
-    [pos, cpos, vertical, mirror] =  ...
-        __position_colorbox__ (loc, obj, ancestor (ax, "figure"));
+    [pos, cpos, vertical, mirror] = ...
+       __position_colorbox__ (loc, obj, ancestor (ax, "figure"));
     set (ax, "position", pos);
 
     cax = __go_axes__ (hpar, "tag", "colorbar",
                              "handlevisibility", "on",
                              "activepositionproperty", "position",
                              "position", cpos);
     addproperty ("location", cax, "radio",
                  "eastoutside|east|westoutside|west|northoutside|north|southoutside|south",
@@ -255,17 +256,17 @@ endfunction
 function deletecolorbar (h, d, hc, orig_props)
   ## Don't delete the colorbar and reset the axis size if the
   ## parent figure is being deleted.
   if (isaxes (hc)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
     if (strcmp (get (hc, "beingdeleted"), "off"))
       delete (hc);
     endif
-    if (!isempty (ancestor (h, "axes"))
+    if (! isempty (ancestor (h, "axes"))
         && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       ax = ancestor (h, "axes");
       units = get (ax, "units");
       set (ax, "units", orig_props.units);
       set (ancestor (h, "axes"), "position", orig_props.position,
                             "outerposition", orig_props.outerposition,
                    "activepositionproperty", orig_props.activepositionproperty);
       set (ax, "units", units);
@@ -335,18 +336,18 @@ endfunction
 function update_colorbar_axis (h, d, cax, orig_props)
   if (isaxes (cax)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     loc = get (cax, "location");
     obj = get (h);
     obj.__cbar_hax__ = h;
     obj.position = orig_props.position;
     obj.outerposition = orig_props.outerposition;
-    [pos, cpos, vertical, mirror] =  ...
-        __position_colorbox__ (loc, obj, ancestor (h, "figure"));
+    [pos, cpos, vertical, mirror] = ...
+       __position_colorbox__ (loc, obj, ancestor (h, "figure"));
 
     if (vertical)
       if (mirror)
         set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
                   "yaxislocation", "right", "position", cpos);
       else
         set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
                   "yaxislocation", "left", "position", cpos);
diff --git a/scripts/plot/draw/compass.m b/scripts/plot/draw/compass.m
--- a/scripts/plot/draw/compass.m
+++ b/scripts/plot/draw/compass.m
@@ -123,15 +123,15 @@ endfunction
 
 %!demo
 %! clf;
 %! randn_9x1_data = [-2.555884; 0.394974; -0.191871; -1.147024; 1.355425; -0.437335; -0.014370; -0.941312; 1.240300];
 %! randn_1x9_data = [1.42934, -1.10821, -1.70404, 0.63357, -0.68337, -1.19771, -0.96502, -1.12810, 0.22457];
 %! a = toeplitz ([1;randn_9x1_data], [1,randn_1x9_data]);
 %! compass (eig (a));
 
-%% Test input validation
+## Test input validation
 %!error compass ()
 %!error compass (1,2,3,4)
 %!error compass (1, "-r", 2)
 %!error <invalid linestyle STYLE> compass (1, "abc")
 %!error <invalid linestyle STYLE> compass (1, {1})
 
diff --git a/scripts/plot/draw/feather.m b/scripts/plot/draw/feather.m
--- a/scripts/plot/draw/feather.m
+++ b/scripts/plot/draw/feather.m
@@ -122,15 +122,15 @@ endfunction
 
 %!demo
 %! clf;
 %! phi = [0 : 15 : 360] * pi/180;
 %! feather (sin (phi), cos (phi));
 %! axis tight;
 %! title ('feather plot');
 
-%% Test input validation
+## Test input validation
 %!error feather ()
 %!error feather (1,2,3,4)
 %!error feather (1, "-r", 2)
 %!error <invalid linestyle STYLE> feather (1, "abc")
 %!error <invalid linestyle STYLE> feather (1, {1})
 
diff --git a/scripts/plot/draw/fplot.m b/scripts/plot/draw/fplot.m
--- a/scripts/plot/draw/fplot.m
+++ b/scripts/plot/draw/fplot.m
@@ -203,17 +203,17 @@ endfunction
 %! title ('fplot() sinc function');
 
 %!test
 %! [x, y] = fplot ("[cos(x), sin(x)]", [0, 2*pi]);
 %! assert (columns (y) == 2);
 %! assert (rows (x) == rows (y));
 %! assert (y, [cos(x), sin(x)], -2e-3);
 
-%% Test input validation
+## Test input validation
 %!error fplot (1)
 %!error fplot (1,2,3,4,5,6)
 %!error <FN must be a function handle> fplot (1, [0 1])
 %!error <LIMITS must be a real vector> fplot (@cos, [i, 2*i])
 %!error <LIMITS must be a real vector with 2 or 4> fplot (@cos, [1])
 %!error <LIMITS must be a real vector with 2 or 4> fplot (@cos, [1 2 3])
 %!error <bad input in position 3> fplot (@cos,[-1,1], {1})
 
diff --git a/scripts/plot/draw/isocolors.m b/scripts/plot/draw/isocolors.m
--- a/scripts/plot/draw/isocolors.m
+++ b/scripts/plot/draw/isocolors.m
@@ -49,17 +49,17 @@
 ## For example:
 ##
 ## @example
 ## function [] = isofinish (p)
 ##   set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##             "PlotBoxAspectRatio", [1 1 1]);
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "flat");
-##   ## light ("Position", [1 1 5]); ## Available with JHandles
+##   ## light ("Position", [1 1 5]);  # Available with JHandles
 ## endfunction
 ##
 ## N = 15;    # Increase number of vertices in each direction
 ## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); # Open another figure window
@@ -147,17 +147,17 @@ function varargout = isocolors (varargin
     new_col(:,1) = __interp_cube__ (x, y, z, R, v, "values" );
     new_col(:,2) = __interp_cube__ (x, y, z, G, v, "values" );
     new_col(:,3) = __interp_cube__ (x, y, z, B, v, "values" );
   else
     new_col = __interp_cube__ (x, y, z, c, v, "values" );
   endif
   switch (nargout)
     case 0
-      if (!isempty (pa))
+      if (! isempty (pa))
         set (pa, "FaceVertexCData", new_col);
       endif
     case 1
       varargout = {new_col};
     otherwise
       print_usage ();
   endswitch
 endfunction
diff --git a/scripts/plot/draw/isonormals.m b/scripts/plot/draw/isonormals.m
--- a/scripts/plot/draw/isonormals.m
+++ b/scripts/plot/draw/isonormals.m
@@ -63,17 +63,17 @@
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); # Open another figure window
 ##
 ## subplot (2,2,1); view (-38, 20);
 ## [f, v, cdat] = isosurface (x, y, z, c, iso, y);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
-## isofinish (p); ## Call user function isofinish
+## isofinish (p);  # Call user function isofinish
 ##
 ## subplot (2,2,2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## isonormals (x, y, z, c, p); # Directly modify patch
 ## isofinish (p);
 ##
 ## subplot (2,2,3); view (-38, 20);
@@ -133,17 +133,17 @@ function varargout = isonormals (varargi
   endif
   if (negate)
     normals = -__interp_cube__ (x, y, z, c, v, "normals");
   else
     normals = __interp_cube__ (x, y, z, c, v, "normals");
   endif
   switch (nargout)
     case 0
-      if (!isempty (pa))
+      if (! isempty (pa))
         set (pa, "VertexNormals", normals);
       endif
     case 1
       varargout = {normals};
     otherwise
       print_usage ();
   endswitch
 endfunction
diff --git a/scripts/plot/draw/isosurface.m b/scripts/plot/draw/isosurface.m
--- a/scripts/plot/draw/isosurface.m
+++ b/scripts/plot/draw/isosurface.m
@@ -147,17 +147,18 @@ function varargout = isosurface (varargi
         colors = varargin{3};
         calc_colors = true;
     endif
   endif
   if (calc_colors)
     if (nargout == 2)
       warning ("isosurface: colors will be calculated, but no output argument to receive it.");
     endif
-    [fvc.faces, fvc.vertices, fvc.facevertexcdata] = __marching_cube__ (x, y, z, val, iso, colors);
+    [fvc.faces, fvc.vertices, fvc.facevertexcdata] = ...
+      __marching_cube__ (x, y, z, val, iso, colors);
   else
     [fvc.faces, fvc.vertices] = __marching_cube__ (x, y, z, val, iso);
   endif
 
   if (isempty (fvc.vertices) || isempty (fvc.faces))
     warning ("isosurface: triangulation is empty");
   endif
 
diff --git a/scripts/plot/draw/private/__contour__.m b/scripts/plot/draw/private/__contour__.m
--- a/scripts/plot/draw/private/__contour__.m
+++ b/scripts/plot/draw/private/__contour__.m
@@ -84,17 +84,17 @@ function [c, hg] = __contour__ (varargin
   else
     vn = 10;
     vnauto = true;
   endif
 
   if (isscalar (vn))
     ## FIXME: The levels should be determined similarly to {x,y,z}ticks
     ##        so that they aren't set at extremely odd values.
-    lvl = linspace (min (z1(!isinf (z1))), max (z1(!isinf (z1))), vn + 2);
+    lvl = linspace (min (z1(! isinf (z1))), max (z1(! isinf (z1))), vn + 2);
     ## Strip off max outlier, min must stay for contourf hole algorithm.
     lvl = lvl(1:end-1);
   else
     lvl = sort (vn);
   endif
 
   if (strcmpi (filled, "on"))
     if (isvector (x1) || isvector (y1))
@@ -441,17 +441,17 @@ function update_data (h, ~, prop = "")
         lvl = lvl(1) : lvs : lvl(2);
       endif
       set (h, "levellist", lvl);
       set (h, "levellistmode", "auto");
     else
       z = get (h, "zdata");
       ## FIXME: The levels should be determined similarly to {x,y,z}ticks
       ##        so that they aren't set at extremely odd values.
-      lvl = linspace (min (z(!isinf (z))), max (z(!isinf (z))), 10 + 2);
+      lvl = linspace (min (z(! isinf (z))), max (z(! isinf (z))), 10 + 2);
       ## Strip off max outlier, min must stay for contourf hole algorithm.
       lvl = lvl(1:end-1);
     endif
 
     if (strcmp (get (h, "fill"), "on"))
       X = get (h, "xdata");
       Y = get (h, "ydata");
       Z = get (h, "zdata");
diff --git a/scripts/plot/draw/private/__errplot__.m b/scripts/plot/draw/private/__errplot__.m
--- a/scripts/plot/draw/private/__errplot__.m
+++ b/scripts/plot/draw/private/__errplot__.m
@@ -202,17 +202,17 @@ function h = __errplot__ (fstr, hax, var
   if (! isempty (fmt.key))
     hlegend = [];
     fkids = get (gcf (), "children");
     for i = 1 : numel (fkids)
       if (   strcmp (get (fkids(i), "type"), "axes")
           && strcmp (get (fkids(i), "tag"), "legend"))
         udata = get (fkids(i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
-          hlegend = fkids (i);
+          hlegend = fkids(i);
           break;
         endif
       endif
     endfor
 
     if (isempty (hlegend))
       hlgnd = [];
       tlgnd = {};
diff --git a/scripts/plot/draw/private/__interp_cube__.m b/scripts/plot/draw/private/__interp_cube__.m
--- a/scripts/plot/draw/private/__interp_cube__.m
+++ b/scripts/plot/draw/private/__interp_cube__.m
@@ -37,17 +37,17 @@ function [Vxyz, idx, frac] = __interp_cu
     error ("__interp_cube__: X, Y, Z have wrong dimensions");
   endif
   if (size (val) != [length(x), length(y), length(z)])
     error ("__interp_cube__: VAL has wrong dimensions");
   endif
   if (columns (v) != 3)
     error ( "V has to be Nx3 matrix");
   endif
-  ##if (!ischar (req))
+  ##if (! ischar (req))
   ## error ('__interp_cube__: Invalid request parameter use "values", "normals" or "normals8"');
   ##endif
   if (isempty (v))
     Vxyz = idx = frac = [];
     return;
   endif
 
   switch (req)
diff --git a/scripts/plot/draw/private/__line__.m b/scripts/plot/draw/private/__line__.m
--- a/scripts/plot/draw/private/__line__.m
+++ b/scripts/plot/draw/private/__line__.m
@@ -42,17 +42,18 @@ function h = __line__ (p, varargin)
   endif
 
   if (num_data_args > 0 && ! size_equal (varargin{1:num_data_args}))
     n = 1:num_data_args;
     m = cellfun (@numel, varargin(1:num_data_args));
     [~, m] = max (m);
     b = ones (size (varargin{m(1)}));
     try
-      varargin(n) = cellfun (@(x) bsxfun (@times, b, x), varargin(n), "uniformoutput", false);
+      varargin(n) = cellfun (@(x) bsxfun (@times, b, x), varargin(n),
+                             "uniformoutput", false);
     catch
       error ("line: number of X, Y, and Z points must be equal");
     end_try_catch
   endif
 
   if (rem (nvargs - num_data_args, 2) != 0)
     error ("line: invalid number of PROPERTY / VALUE pairs");
   endif
diff --git a/scripts/plot/draw/private/__marching_cube__.m b/scripts/plot/draw/private/__marching_cube__.m
--- a/scripts/plot/draw/private/__marching_cube__.m
+++ b/scripts/plot/draw/private/__marching_cube__.m
@@ -93,35 +93,36 @@ function [T, p, col] = __marching_cube__
   if (isempty (tri_table) || isempty (edge_table))
     [edge_table, tri_table] = init_mc ();
   endif
 
   if ((nargin != 5 && nargin != 6) || (nargout != 2 && nargout != 3))
     print_usage ();
   endif
 
-  if (!isnumeric (xx) || !isnumeric (yy) || !isnumeric (zz) || !isnumeric (c) || ...
-    ndims (xx) != 3 || ndims (yy) != 3 || ndims (zz) != 3 || ndims (c) != 3)
+  if (! isnumeric (xx) || ! isnumeric (yy) || ! isnumeric (zz)
+      || ! isnumeric (c) || ndims (xx) != 3 || ndims (yy) != 3
+      || ndims (zz) != 3 || ndims (c) != 3)
     error ("__marching_cube__: XX, YY, ZZ, C must be matrices of dim 3");
   endif
 
-  if (!size_equal (xx, yy, zz, c))
+  if (! size_equal (xx, yy, zz, c))
     error ("__marching_cube__: XX, YY, ZZ, C must be of equal size");
   endif
 
   if (any (size (xx) < [2 2 2]))
     error ("__marching_cube__: grid size must be at least 2x2x2");
   endif
 
-  if (!isscalar (iso))
+  if (! isscalar (iso))
     error ("__marching_cube__: ISO must be scalar value");
   endif
 
   if (nargin == 6)
-    if ( !isnumeric (colors) || ndims (colors) != 3 || size (colors) != size (c) )
+    if ( ! isnumeric (colors) || ndims (colors) != 3 || size (colors) != size (c) )
       error ( "COLORS must be a matrix of dim 3 and of same size as C" );
     endif
     calc_cols = true;
     lindex = 5;
   endif
 
   n = size (c) - 1;
 
@@ -141,17 +142,17 @@ function [T, p, col] = __marching_cube__
 
   ## calculate which vertices have values higher than iso
   for ii=1:8
     idx = c(vertex_idx{ii, :}) > iso;
     cc(idx) = bitset (cc(idx), ii);
   endfor
 
   cedge = edge_table(cc+1); # assign the info about intersected edges
-  id =  find (cedge); # select only voxels which are intersected
+  id = find (cedge); # select only voxels which are intersected
   if (isempty (id))
     T = p = col = [];
     return;
   endif
 
   ## phase II: calculate the list of intersection points
   xyz_off = [1, 1, 1; 2, 1, 1; 2, 2, 1; 1, 2, 1; 1, 1, 2;  2, 1, 2; 2, 2, 2; 1, 2, 2];
   edges = [1 2; 2 3; 3 4; 4 1; 5 6; 6 7; 7 8; 8 5; 1 5; 2 6; 3 7; 4 8];
@@ -179,17 +180,17 @@ function [T, p, col] = __marching_cube__
   endfor
 
   ## phase III: calculate the triangulation from the point list
   T = [];
   tri = tri_table(cc(id)+1, :);
   for jj=1:3:15
     id_ = find (tri(:, jj)>0);
     p = [id_, lindex*ones(rows (id_), 1),tri(id_, jj:jj+2)];
-    if (!isempty (p))
+    if (! isempty (p))
       p1 = sub2ind (size (pp), p(:,1), p(:,2), p(:,3));
       p2 = sub2ind (size (pp), p(:,1), p(:,2), p(:,4));
       p3 = sub2ind (size (pp), p(:,1), p(:,2), p(:,5));
       T = [T; pp(p1), pp(p2), pp(p3)];
     endif
   endfor
 
   p = [];
diff --git a/scripts/plot/draw/private/__patch__.m b/scripts/plot/draw/private/__patch__.m
--- a/scripts/plot/draw/private/__patch__.m
+++ b/scripts/plot/draw/private/__patch__.m
@@ -163,28 +163,28 @@ function [h, failed] = __patch__ (p, var
             args{10} = c;
           else
             error ("patch: size of X, Y, and C must be equal");
           endif
         endif
       elseif (ischar (c) && rem (nargin - iarg, 2) == 0)
         ## Assume any additional argument over an even number is a color string.
         args{7} = "facecolor";
-        args{8} =  tolower (c);
+        args{8} = tolower (c);
         args{9} = "cdata";
         args{10} = [];
       else
         args{7} = "facecolor";
         args{8} = [0, 0, 0];
         args{9} = "cdata";
         args{10} = [];
       endif
 
       args = [args, varargin(iarg:end)];
     endif
   else
     args = varargin;
   endif
 
-  if (!failed)
+  if (! failed)
     h = __go_patch__ (p, args{:});
   endif
 endfunction
diff --git a/scripts/plot/draw/private/__plt__.m b/scripts/plot/draw/private/__plt__.m
--- a/scripts/plot/draw/private/__plt__.m
+++ b/scripts/plot/draw/private/__plt__.m
@@ -106,35 +106,38 @@ function retval = __plt__ (caller, h, va
               endif
               properties = [properties, varargin(k:k+1)];
               k += 2;
               nargs -= 2;
             endwhile
           endif
           if (y_set)
             tmp = __plt2__ (h, x, y, options, properties);
-            [hlgnd, tlgnd, setlgnd] = __plt_key__ (tmp, options, hlgnd, tlgnd, setlgnd);
+            [hlgnd, tlgnd, setlgnd] = ...
+              __plt_key__ (tmp, options, hlgnd, tlgnd, setlgnd);
             properties = {};
             retval = [retval; tmp];
           else
             tmp = __plt1__ (h, x, options, properties);
-            [hlgnd, tlgnd, setlgnd] = __plt_key__ (tmp, options, hlgnd, tlgnd, setlgnd);
+            [hlgnd, tlgnd, setlgnd] = ...
+               __plt_key__ (tmp, options, hlgnd, tlgnd, setlgnd);
             properties = {};
             retval = [retval; tmp];
           endif
           x_set = false;
           y_set = false;
         else
           error ("plot: no data to plot");
         endif
       elseif (x_set)
         if (y_set)
           options = __pltopt__ (caller, {""});
           tmp = __plt2__ (h, x, y, options, properties);
-          [hlgnd, tlgnd, setlgnd] = __plt_key__ (tmp, options, hlgnd, tlgnd, setlgnd);
+          [hlgnd, tlgnd, setlgnd] = ...
+            __plt_key__ (tmp, options, hlgnd, tlgnd, setlgnd);
           retval = [retval; tmp];
           x = next_arg;
           y_set = false;
           properties = {};
         else
           y = next_arg;
           y_set = true;
         endif
diff --git a/scripts/plot/draw/private/__stem__.m b/scripts/plot/draw/private/__stem__.m
--- a/scripts/plot/draw/private/__stem__.m
+++ b/scripts/plot/draw/private/__stem__.m
@@ -419,17 +419,17 @@ function update_props (h, ~)
                 "markersize", get (h, "markersize"));
 endfunction
 
 function update_data (h, ~)
   x = get (h, "xdata");
   y = get (h, "ydata");
   z = get (h, "zdata");
 
-  if (!isempty (z) && size_equal (x, y, z))
+  if (! isempty (z) && size_equal (x, y, z))
     sz = min ([size(x); size(y); size(z)]);
     x = x(1:sz(1),1:sz(2));
     y = y(1:sz(1),1:sz(2));
     z = z(1:sz(1),1:sz(2));
   elseif (numel (x) != numel (y));
     sz = min ([size(x); size(y)]);
     x = x(1:sz(1),1:sz(2));
     y = y(1:sz(1),1:sz(2));
diff --git a/scripts/plot/draw/rectangle.m b/scripts/plot/draw/rectangle.m
--- a/scripts/plot/draw/rectangle.m
+++ b/scripts/plot/draw/rectangle.m
@@ -98,17 +98,17 @@ function hg = __rectangle__ (hax, vararg
         pos = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
         if (! isvector (pos) || numel (pos) != 4)
           error ("rectangle: position must be a 4 element vector");
         endif
       elseif (strcmpi (arg, "curvature"))
         curv2 = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
-        if (!isnumeric (curv2) || (numel (curv2) != 1 && numel (curv2) != 2))
+        if (! isnumeric (curv2) || (numel (curv2) != 1 && numel (curv2) != 2))
           error ("rectangle: curvature must be a 2-element vector or a scalar");
         endif
         if (any (curv2 < 0) || any (curv2 > 1))
           error ("rectangle: curvature values must be between 0 and 1");
         endif
       elseif (strcmpi (arg, "edgecolor"))
         ec = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
diff --git a/scripts/plot/draw/shrinkfaces.m b/scripts/plot/draw/shrinkfaces.m
--- a/scripts/plot/draw/shrinkfaces.m
+++ b/scripts/plot/draw/shrinkfaces.m
@@ -212,17 +212,17 @@ endfunction
 %! nfv = shrinkfaces (faces, vertices, 0.7);
 %! nfv2 = shrinkfaces (nfv, 1/0.7);
 %!assert (isfield (nfv, "faces"))
 %!assert (isfield (nfv, "vertices"))
 %!assert (size (nfv.faces), [1 3])
 %!assert (size (nfv.vertices), [3 3])
 %!assert (norm (nfv2.vertices - vertices), 0, 2*eps)
 
-%% Test input validation
+## Test input validation
 %!error shrinkfaces ()
 %!error shrinkfaces (1,2,3,4)
 %!error [a,b,c] = shrinkfaces (1)
 %!error <scale factor must be a positive scalar> shrinkfaces (nfv, ones (2))
 %!error <scale factor must be a positive scalar> shrinkfaces (nfv, 0)
 %!error <only 2-D and 3-D patches are supported> shrinkfaces (faces, ones (3,1))
 %!error <only 2-D and 3-D patches are supported> shrinkfaces (faces, ones (3,4))
 %!error <faces must consist of at least 3 vertices> shrinkfaces (faces(1:2), vertices)
diff --git a/scripts/plot/draw/slice.m b/scripts/plot/draw/slice.m
--- a/scripts/plot/draw/slice.m
+++ b/scripts/plot/draw/slice.m
@@ -155,17 +155,19 @@ function h = slice (varargin)
                                    squeeze (y(:,1,1)), sz(i));
           vz = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
           htmp(sidx++) = surface (xi, yi, sz(i) * ones (size (yi)), vz);
         endfor
       endif
 
       if (length (sy) > 0)
         for i = length (sy):-1:1
-          [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)), sy(i), squeeze (z(1,1,:)));
+          [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)),
+                                   sy(i),
+                                   squeeze (z(1,1,:)));
           vy = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
           htmp(sidx++) = surface (squeeze (xi),
                                   squeeze (sy(i) * ones (size (zi))),
                                   squeeze (zi), vy);
         endfor
       endif
 
       if (length (sx) > 0)
diff --git a/scripts/plot/draw/surface.m b/scripts/plot/draw/surface.m
--- a/scripts/plot/draw/surface.m
+++ b/scripts/plot/draw/surface.m
@@ -138,33 +138,33 @@ function [h, bad_usage] = __surface__ (a
     case 3
       z = varargin{1};
       c = varargin{2};
 
       if (iscomplex (z) || iscomplex (c))
         error ("mesh: X, C arguments must be real");
       endif
 
-      if (ismatrix (z) && !isvector (z) && !isscalar (z))
+      if (ismatrix (z) && ! isvector (z) && ! isscalar (z))
         [nr, nc] = size (z);
         x = 1:nc;
         y = (1:nr)';
       else
         error ("surface: Z argument must be a matrix");
       endif
 
     case 2
       z = varargin{1};
       c = z;
 
       if (iscomplex (z))
         error ("mesh: Z argument must be real");
       endif
 
-      if (ismatrix (z) && !isvector (z) && !isscalar (z))
+      if (ismatrix (z) && ! isvector (z) && ! isscalar (z))
         [nr, nc] = size (z);
         x = 1:nc;
         y = (1:nr)';
       else
         error ("surface: Z argument must be a matrix");
       endif
 
     case 1
diff --git a/scripts/plot/draw/surfnorm.m b/scripts/plot/draw/surfnorm.m
--- a/scripts/plot/draw/surfnorm.m
+++ b/scripts/plot/draw/surfnorm.m
@@ -183,17 +183,17 @@ endfunction
 %!         'peaks() function with 32 faces'});
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = sombrero (10);
 %! surfnorm (x, y, z);
 
-%% Test input validation
+## Test input validation
 %!error surfnorm ()
 %!error surfnorm (1,2)
 %!error <X, Y, and Z must be 2-D real matrices> surfnorm (i)
 %!error <X, Y, and Z must be 2-D real matrices> surfnorm (i, 1, 1)
 %!error <X, Y, and Z must be 2-D real matrices> surfnorm (1, i, 1)
 %!error <X, Y, and Z must be 2-D real matrices> surfnorm (1, 1, i)
 %!error <X, Y, and Z must have the same dimensions> surfnorm ([1 2], 1, 1)
 %!error <X, Y, and Z must have the same dimensions> surfnorm (1, [1 2], 1)
diff --git a/scripts/plot/draw/trimesh.m b/scripts/plot/draw/trimesh.m
--- a/scripts/plot/draw/trimesh.m
+++ b/scripts/plot/draw/trimesh.m
@@ -104,17 +104,17 @@ endfunction
 %! rand ('state', 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
 %! trimesh (tri, x(:), y(:), z(:));
 
-%% Test input validation
+## Test input validation
 %!error trimesh ()
 %!error trimesh (1)
 %!error trimesh (1,2)
 %!error <C must have 'numel \(Z\)' elements> trimesh (1,2,3,4,[5 6])
 %!error <C must have 'numel \(Z\)' elements> trimesh (1,2,3,4,[5 6]')
 %!error <TrueColor C matrix must> trimesh ([1;1],[2;2],[3;3],[4;4],zeros(3,3))
 %!error <TrueColor C matrix must> trimesh ([1;1],[2;2],[3;3],[4;4],zeros(2,2))
 
diff --git a/scripts/plot/draw/trisurf.m b/scripts/plot/draw/trisurf.m
--- a/scripts/plot/draw/trisurf.m
+++ b/scripts/plot/draw/trisurf.m
@@ -157,17 +157,17 @@ endfunction
 %! clf;
 %! colormap ('default');
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, 'facecolor', 'interp', 'edgecolor', 'k');
 
-%% Test input validation
+## Test input validation
 %!error trisurf ()
 %!error trisurf (1)
 %!error trisurf (1,2)
 %!error trisurf (1,2,3)
 %!error <C must have 'numel \(Z\)' elements> trisurf (1,2,3,4,[5 6])
 %!error <C must have 'numel \(Z\)' elements> trisurf (1,2,3,4,[5 6]')
 %!error <TrueColor C matrix must> trisurf ([1;1],[2;2],[3;3],[4;4],zeros(3,3))
 %!error <TrueColor C matrix must> trisurf ([1;1],[2;2],[3;3],[4;4],zeros(2,2))
diff --git a/scripts/plot/util/__actual_axis_position__.m b/scripts/plot/util/__actual_axis_position__.m
--- a/scripts/plot/util/__actual_axis_position__.m
+++ b/scripts/plot/util/__actual_axis_position__.m
@@ -61,17 +61,17 @@ function pos = __actual_axis_position__ 
       aspect_ratio_2d = axis_obj.plotboxaspectratio(1:2);
     else
       ## FIXME: This works for "axis square", but has not been
       ##        thoroughly tested for other aspect ratios.
       aspect_ratio_2d = [max(axis_obj.plotboxaspectratio(1:2)), ...
                              axis_obj.plotboxaspectratio(3)/sqrt(2)];
     endif
     orig_aspect_ratio_2d = pos_in_pixels(3:4);
-    rel_aspect_ratio_2d =  aspect_ratio_2d ./ orig_aspect_ratio_2d;
+    rel_aspect_ratio_2d = aspect_ratio_2d ./ orig_aspect_ratio_2d;
     rel_aspect_ratio_2d = rel_aspect_ratio_2d ./ max (rel_aspect_ratio_2d);
     if (rel_aspect_ratio_2d(1) < rel_aspect_ratio_2d(2));
       dx = (1.0 - rel_aspect_ratio_2d(1)) * pos_in_pixels(3);
       pos_in_pixels = pos_in_pixels + dx*[0.5, 0.0, -1.0, 0.0];
     elseif (rel_aspect_ratio_2d(1) > rel_aspect_ratio_2d(2))
       dy = (1.0 - rel_aspect_ratio_2d(2)) * pos_in_pixels(4);
       pos_in_pixels = pos_in_pixels + dy*[0.0, 0.5, 0.0, -1.0];
     endif
diff --git a/scripts/plot/util/__gnuplot_drawnow__.m b/scripts/plot/util/__gnuplot_drawnow__.m
--- a/scripts/plot/util/__gnuplot_drawnow__.m
+++ b/scripts/plot/util/__gnuplot_drawnow__.m
@@ -204,19 +204,21 @@ function enhanced = gnuplot_set_term (pl
           endif
           switch (term)
             case terminals_with_size
               size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
             case "tikz"
               size_str = sprintf ("size %gin,%gin", gnuplot_size);
             case "dumb"
               new_stream = 1;
-              if (!isempty (getenv ("COLUMNS")) && !isempty (getenv ("LINES")))
+              if (! isempty (getenv ("COLUMNS"))
+                  && ! isempty (getenv ("LINES")))
                 ## Let dumb use full text screen size (minus prompt lines).
-                n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
+                n = sprintf ("%i",
+                             -2 - length (find (sprintf ("%s", PS1) == "\n")));
                 ## n = the number of times \n appears in PS1
                 size_str = ["size " getenv("COLUMNS") "," getenv("LINES") n];
               else
                 ## Use the gnuplot default.
                 size_str = "";
               endif
             case {"aqua", "fig", "corel"}
               size_str = sprintf ("size %g %g", gnuplot_size);
@@ -292,18 +294,18 @@ function enhanced = gnuplot_set_term (pl
         ## the canvas size for terminals cdr/corel.
         term_str = [term_str " " size_str];
       endif
     endif
     if (! __gnuplot_has_feature__ ("has_termoption_dashed"))
       ## If "set termoption dashed" isn't available add "dashed" option
       ## to the "set terminal ..." command, if it is supported.
       if (any (strcmp (term, {"aqua", "cgm", "eepic", "emf", "epslatex", ...
-                              "fig", "pcl5", "mp", "next", "openstep", "pdf", ...
-                              "pdfcairo", "pngcairo", "postscript", ...
+                              "fig", "pcl5", "mp", "next", "openstep", ...
+                              "pdf", "pdfcairo", "pngcairo", "postscript", ...
                               "pslatex", "pstext", "svg", "tgif", "x11"})))
         term_str = [term_str " dashed"];
       endif
     endif
     if (any (strcmp (term, {"aqua", "wxt"})))
       term_str = [term_str, " ", "dashlength 1"];
     elseif (any (strcmp (term, {"epslatex", "postscript", "pslatex"})))
       term_str = [term_str, " ", "dashlength 2"];
diff --git a/scripts/plot/util/axes.m b/scripts/plot/util/axes.m
--- a/scripts/plot/util/axes.m
+++ b/scripts/plot/util/axes.m
@@ -29,17 +29,17 @@
 ## values, @pxref{XREFset,,set}.
 ##
 ## Called with a single axes handle argument @var{hax}, the function makes
 ## @var{hax} the current axis.  It also restacks the axes in the
 ## corresponding figure so that @var{hax} is the first entry in the list
 ## of children.  This causes @var{hax} to be displayed on top of any other
 ## axes objects (Z-order stacking).
 ##
-## @seealso {gca, set, get}
+## @seealso{gca, set, get}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = axes (varargin)
 
   if (nargin == 0 || nargin > 1)
     ## Parent figure
@@ -56,17 +56,17 @@ function h = axes (varargin)
     do_restack = false;
     ch = allchild (cf);
     hax = ch(isaxes (ch));
     idx = find (strcmp (get (hax, "tag"), "scribeoverlay"));
     if (idx == 1)
       hover = hax(idx);
       do_restack = true;
     endif
-    
+
     ## Create an axes object.
     htmp = __go_axes__ (cf, varargin{:});
     if (__is_handle_visible__ (htmp))
       set (ancestor (cf, "figure"), "currentaxes", htmp);
     endif
 
     ## Restack if necessary
     if (do_restack)
diff --git a/scripts/plot/util/clf.m b/scripts/plot/util/clf.m
--- a/scripts/plot/util/clf.m
+++ b/scripts/plot/util/clf.m
@@ -71,17 +71,17 @@ function h = clf (varargin)
 
   if (do_reset)
     ## Select all the children, including the one with hidden handles.
     delete (allchild (hfig));
     reset (hfig);
   else
     ## Select only the chilren with visible handles.
     delete (get (hfig, "children"));
-    
+
     ## Also delete the annotation axes
     hover = findall (hfig, "-depth", 1, "tag", "scribeoverlay");
     delete (hover);
   endif
 
   if (nargout > 0)
     h = hfig;
   endif
diff --git a/scripts/plot/util/colstyle.m b/scripts/plot/util/colstyle.m
--- a/scripts/plot/util/colstyle.m
+++ b/scripts/plot/util/colstyle.m
@@ -79,13 +79,13 @@ endfunction
 %! assert (l, "none");
 %! assert (c, []);
 %! assert (m, ".");
 
 %!test
 %! [l, c, m, msg] = colstyle ("~");
 %! assert (msg, "colstyle: unrecognized format character: '~'");
 
-%% Test input validation
+## Test input validation
 %!error colstyle ()
 %!error colstyle (1, 2)
 %!error <STYLE must be a string> colstyle (1.5)
 
diff --git a/scripts/plot/util/figure.m b/scripts/plot/util/figure.m
--- a/scripts/plot/util/figure.m
+++ b/scripts/plot/util/figure.m
@@ -116,16 +116,17 @@ function __add_default_mouse_modes__ (fi
 
   set (fig, "__zoom_mode__", struct ("Enable", "off",
                                      "Motion", "both",
                                      "Direction", "in",
                                      "FigureHandle", fig));
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (hf, gcf);
 %!   assert (isfigure (hf));
 %!   hf2 = figure (hf, "visible", "off");
 %!   assert (hf, hf2);
 %!   assert (hf2, gcf);
diff --git a/scripts/plot/util/frame2im.m b/scripts/plot/util/frame2im.m
--- a/scripts/plot/util/frame2im.m
+++ b/scripts/plot/util/frame2im.m
@@ -52,16 +52,17 @@ function [x, map] = frame2im (frame)
   ## support for N dimensional images if we receive a struct array
   if (n > 1)
     x = reshape (x, rows (x), columns (x) / n, n, size (frame(1).cdata, 3));
     x = permute (x, [1 2 4 3]);
   endif
 
 endfunction
 
+
 %!function f = make_rgb_f ()
 %! f = randi ([0 255], 10, 20, 3);
 %!endfunction
 
 %!function f = make_ind_f ()
 %! f = randi ([1 100], 10, 20, 3);
 %!endfunction
 
diff --git a/scripts/plot/util/hdl2struct.m b/scripts/plot/util/hdl2struct.m
--- a/scripts/plot/util/hdl2struct.m
+++ b/scripts/plot/util/hdl2struct.m
@@ -26,30 +26,30 @@
 ## @seealso{struct2hdl, hgsave, findobj}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-03-04
 
 function s = hdl2struct (h)
 
-  if (nargin != 1 || !ishandle (h))
+  if (nargin != 1 || ! ishandle (h))
     print_usage ();
   endif
 
   hiddenh = get (0, "showhiddenhandles");
   if (strcmp (hiddenh, "on"))
     set (0, "showhiddenhandles", "off");
   endif
 
   ## main object
   main = get (h);
   s.handle = h;
-  s.type =  main.type;
-  s.properties  = getprops (h);
+  s.type = main.type;
+  s.properties = getprops (h);
   s.children = [];
   s.special = [];
 
   ## sweep all children but legends, colorbars, uimenu and hggroup children
   ## in reverse order
   kids = main.children;
   lg = findobj (h, "-depth", 1, "tag", "legend");
   cb = findobj (h, "-depth", 1, "tag", "colorbar");
diff --git a/scripts/plot/util/hgload.m b/scripts/plot/util/hgload.m
--- a/scripts/plot/util/hgload.m
+++ b/scripts/plot/util/hgload.m
@@ -57,13 +57,13 @@ function h = hgload (filename)
 
   h = struct2hdl (stmp.s_oct40);
 
 endfunction
 
 
 ## Functional test for hgload/hgsave pair is in hgsave.m
 
-%% Test input validation
+## Test input validation
 %!error hgload ()
 %!error hgload (1, 2)
 %!error <unable to locate file> hgload ("%%_A_REALLY_UNLIKELY_FILENAME_%%")
 
diff --git a/scripts/plot/util/hgsave.m b/scripts/plot/util/hgsave.m
--- a/scripts/plot/util/hgsave.m
+++ b/scripts/plot/util/hgsave.m
@@ -116,13 +116,13 @@ endfunction
 %!   assert (map1, map2);
 %!   assert (alpha1, alpha2);
 %! unwind_protect_cleanup
 %!   close (h1);
 %!   close (h2);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
-%% Test input validation
+## Test input validation
 %!error hgsave ()
 %!error hgsave (1, 2, 3, 4)
 %!error hgsave ("abc", "def")
 
diff --git a/scripts/plot/util/im2frame.m b/scripts/plot/util/im2frame.m
--- a/scripts/plot/util/im2frame.m
+++ b/scripts/plot/util/im2frame.m
@@ -60,16 +60,17 @@ function [frame] = im2frame (x, map = []
   ## support N dimensional images and return a struct array
   if (ndims (x) == 4)
     x = reshape (num2cell (x, [1 2 3]), 1, size (x, 4));
   endif
 
   frame = struct ("cdata", x, "colormap", map);
 endfunction
 
+
 %!function f = make_rgb_f ()
 %! f = randi ([0 255], 10, 20, 3);
 %!endfunction
 
 %!function f = make_ind_f ()
 %! f = randi ([1 100], 10, 20, 3);
 %!endfunction
 
diff --git a/scripts/plot/util/linkaxes.m b/scripts/plot/util/linkaxes.m
--- a/scripts/plot/util/linkaxes.m
+++ b/scripts/plot/util/linkaxes.m
@@ -50,17 +50,17 @@
 ## @seealso{linkprop, addproperty}
 ## @end deftypefn
 
 ## Author: Willem Atsma willem.atsma at tanglebridge.com
 ## Created: 2014-03-18
 
 function linkaxes (hax, optstr = "xy")
 
-  if  (nargin < 1 || nargin > 2)
+  if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (numel (hax) < 2)
     error ("linkaxes: HAX must contain at least 2 handles");
   elseif (! all (isaxes (hax(:))))
     error ("linkaxes: HAX must be a vector of axes handles");
   endif
@@ -73,17 +73,17 @@ function linkaxes (hax, optstr = "xy")
       try
         rmappdata (hld, "linkprop_data");
       end_try_catch
     else
       addproperty ("linkaxes_data", hax(i), "any");
     endif
   endfor
 
-  switch  (optstr)
+  switch (optstr)
     case "x"
       hlink = linkprop (hax, "xlim");
     case "y"
       hlink = linkprop (hax, "ylim");
     case "xy"
       hlink = linkprop (hax, {"xlim" "ylim"});
     case "off"
       ## do nothing - link already deleted
@@ -155,13 +155,13 @@ endfunction
 %!   ## Test deletion of link
 %!   linkaxes ([hax1, hax3], "off");
 %!   xlim (hax3, [0 3]);
 %!   assert (xlim (hax1), [0 2]);
 %!  unwind_protect_cleanup
 %!   close ([hf1 hf2 hf3]);
 %!  end_unwind_protect
 
-%% Test input validation
+## Test input validation
 %!error linkaxes ()
 %!error linkaxes (1,2,3)
 %!error <HAX must be a vector of axes handles> linkaxes ([pi, e])
 
diff --git a/scripts/plot/util/linkprop.m b/scripts/plot/util/linkprop.m
--- a/scripts/plot/util/linkprop.m
+++ b/scripts/plot/util/linkprop.m
@@ -157,16 +157,16 @@ endfunction
 %!   ## Test deletion of link
 %!   clear hlink;
 %!   set (hl1, "color", "g");
 %!   assert (get (hl3, "color"), [0 0 1]);
 %! unwind_protect_cleanup
 %!   close ([hf1 hf2 hf3]);
 %! end_unwind_protect
 
-%% Test input validation
+## Test input validation
 %!error linkprop ()
 %!error linkprop (1)
 %!error linkprop (1,2,3)
 %!error <H must contain at least 2 handles> linkprop (1, "color")
 %!error <invalid graphic handle in input H> linkprop ([pi, e], "color")
 %!error <PROP must be a string or cell string array> linkprop ([0, 0], 1)
 
diff --git a/scripts/plot/util/meshgrid.m b/scripts/plot/util/meshgrid.m
--- a/scripts/plot/util/meshgrid.m
+++ b/scripts/plot/util/meshgrid.m
@@ -121,15 +121,15 @@ endfunction
 %! [XX1, YY1] = meshgrid (x, x);
 %! [XX2, YY2] = meshgrid (x);
 %! assert (size_equal (XX1, XX2, YY1, YY2));
 %! assert (ndims (XX1), 2);
 %! assert (size (XX1), [3, 3]);
 %! assert (XX1, XX2);
 %! assert (YY1, YY2);
 
-%% Test input validation
+## Test input validation
 %!error meshgrid ()
 %!error meshgrid (1,2,3,4)
 %!error <X and Y must be vectors> meshgrid (ones (2,2), 1:3)
 %!error <X and Y must be vectors> meshgrid (1:3, ones (2,2))
 %!error <X, Y, and Z must be vectors> [X,Y,Z] = meshgrid (1:3, 1:3, ones (2,2))
 
diff --git a/scripts/plot/util/ndgrid.m b/scripts/plot/util/ndgrid.m
--- a/scripts/plot/util/ndgrid.m
+++ b/scripts/plot/util/ndgrid.m
@@ -116,13 +116,13 @@ endfunction
 %! assert (XX2(1) * YY2(1), x(1) * y(1));
 %! assert (XX2(end) * YY2(end), x(end) * y(end));
 %! assert (XX1, XX2.');
 %! assert (YY1, YY2.');
 
 %!assert (ndgrid ([]), zeros(0,1))
 %!assert (ndgrid ([], []), zeros(0,0))
 
-%% Test input validation
+## Test input validation
 %!error ndgrid ()
 %!error <wrong number of input arguments> [a,b,c] = ndgrid (1:3,1:3)
 %!error <arguments must be vectors> ndgrid (ones (2,2))
 
diff --git a/scripts/plot/util/newplot.m b/scripts/plot/util/newplot.m
--- a/scripts/plot/util/newplot.m
+++ b/scripts/plot/util/newplot.m
@@ -27,38 +27,39 @@
 ## functions.  It is not normally required in user programs.  @code{newplot}
 ## queries the @qcode{"NextPlot"} field of the current figure and axis to
 ## determine what to do.
 ##
 ## @multitable @columnfractions .25 .75
 ## @headitem Figure NextPlot @tab Action
 ## @item @qcode{"new"} @tab Create a new figure and make it the current figure.
 ##
-## @item @qcode{"add"} (default) @tab Add new graphic objects to the current figure.
+## @item @qcode{"add"} (default) @tab Add new graphic objects to the current
+## figure.
 ##
-## @item @qcode{"replacechildren"} @tab Delete child objects whose HandleVisibility is
-## set to @qcode{"on"}.  Set NextPlot property to @qcode{"add"}.  This
-## typically clears a figure, but leaves in place hidden objects such as
-## menubars.  This is equivalent to @code{clf}.
+## @item @qcode{"replacechildren"} @tab Delete child objects whose
+## HandleVisibility is set to @qcode{"on"}.  Set NextPlot property to
+## @qcode{"add"}.  This typically clears a figure, but leaves in place hidden
+## objects such as menubars.  This is equivalent to @code{clf}.
 ##
 ## @item @qcode{"replace"} @tab Delete all child objects of the figure and
 ## reset all figure properties to their defaults.  However, the following
 ## four properties are not reset: Position, Units, PaperPosition, PaperUnits.
-##  This is equivalent to @code{clf reset}.
+## This is equivalent to @code{clf reset}.
 ## @end multitable
 ##
 ## @multitable @columnfractions .25 .75
 ## @headitem Axis NextPlot @tab Action
-## @item @qcode{"add"} @tab Add new graphic objects to the current axes.  This is
-## equivalent to @code{hold on}.
+## @item @qcode{"add"} @tab Add new graphic objects to the current axes.  This
+## is equivalent to @code{hold on}.
 ##
-## @item @qcode{"replacechildren"} @tab Delete child objects whose HandleVisibility is
-## set to @qcode{"on"}, but leave axis properties unmodified.  This typically
-## clears a plot, but preserves special settings such as log scaling for
-## axes.  This is equivalent to @code{cla}.
+## @item @qcode{"replacechildren"} @tab Delete child objects whose
+## HandleVisibility is set to @qcode{"on"}, but leave axis properties
+## unmodified.  This typically clears a plot, but preserves special settings
+## such as log scaling for axes.  This is equivalent to @code{cla}.
 ##
 ## @item @qcode{"replace"} (default) @tab Delete all child objects of the
 ## axis and reset all axis properties to their defaults.  However, the
 ## following properties are not reset: Position, Units.  This is equivalent
 ## to @code{cla reset}.
 ## @end multitable
 ##
 ## If the optional input @var{hfig} or @var{hax} is given then prepare the
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -478,17 +478,17 @@ function cmd = epstool (opts, filein, fi
   if (isempty (epsdevice))
     [status, devlist] = system (sprintf ("%s -h", opts.ghostscript.binary));
     if (isempty (strfind (devlist, "eps2write")))
       epsdevice = "epswrite";
     else
       epsdevice = "eps2write";
     endif
   endif
-  
+
   dos_shell = (ispc () && ! isunix ());
 
   cleanup = "";
   if (nargin < 3)
     fileout = opts.name;
   elseif (isempty (fileout))
     fileout = "-";
   endif
@@ -504,19 +504,19 @@ function cmd = epstool (opts, filein, fi
   else
     pipein = false;
     filein = strcat ("'", strtrim (filein), "'");
   endif
   if (strcmp (fileout, "-"))
     pipeout = true;
     fileout = [tempname() ".eps"];
     if (dos_shell)
-      cleanup = horzcat (cleanup, sprintf ("& del %s ", strrep (fileout, '/', '\')));
+      cleanup = [cleanup, sprintf("& del %s ", strrep (fileout, '/', '\'))];
     else
-      cleanup = horzcat (cleanup, sprintf ("; rm %s ", fileout));
+      cleanup = [cleanup, sprintf("; rm %s ", fileout)];
     endif
   else
     pipeout = false;
     fileout = strcat ("'", strtrim (fileout), "'");
   endif
 
   if (! isempty (opts.preview) && opts.tight_flag)
     warning ("print:previewandtight",
@@ -620,17 +620,17 @@ function cmd = epstool (opts, filein, fi
   endif
   if (opts.debug)
     fprintf ("epstool command: '%s'\n", cmd);
   endif
 endfunction
 
 function cmd = fig2dev (opts, devopt)
   if (nargin < 2)
-    devopt =  opts.devopt;
+    devopt = opts.devopt;
   endif
   dos_shell = (ispc () && ! isunix ());
   if (! isempty (opts.fig2dev_binary))
     if (dos_shell)
       ## FIXME: Is this the right thing to do for DOS?
       cmd = sprintf ("%s -L %s 2> NUL", opts.fig2dev_binary, devopt);
     else
       cmd = sprintf ("%s -L %s 2> /dev/null", opts.fig2dev_binary, devopt);
@@ -696,17 +696,17 @@ function latex_standalone (opts)
   else
     error ("print:erroropeningfile",
            "print.m: error opening file '%s'", latexfile);
   endif
 endfunction
 
 function cmd = lpr (opts)
   if (nargin < 2)
-    devopt =  opts.devopt;
+    devopt = opts.devopt;
   endif
   if (! isempty (opts.lpr_binary))
     cmd = opts.lpr_binary;
     if (! isempty (opts.lpr_options))
       cmd = sprintf ("%s %s", cmd, opts.lpr_options);
     endif
     if (! isempty (opts.printer))
       cmd = sprintf ("%s %s", cmd, opts.printer);
@@ -716,17 +716,17 @@ function cmd = lpr (opts)
   endif
   if (opts.debug)
     fprintf ("lpr command: '%s'\n", cmd);
   endif
 endfunction
 
 function cmd = pstoedit (opts, devopt)
   if (nargin < 2)
-    devopt =  opts.devopt;
+    devopt = opts.devopt;
   endif
   dos_shell = (ispc () && ! isunix ());
   if (! isempty (opts.pstoedit_binary))
     if (dos_shell)
       cmd = sprintf ("%s -f %s 2> NUL", opts.pstoedit_binary, devopt);
     else
       ## FIXME: Is this the right thing to do for DOS?
       cmd = sprintf ("%s -f %s 2> /dev/null", opts.pstoedit_binary, devopt);
diff --git a/scripts/plot/util/printd.m b/scripts/plot/util/printd.m
--- a/scripts/plot/util/printd.m
+++ b/scripts/plot/util/printd.m
@@ -48,27 +48,25 @@ function pr_out = printd (obj, filename)
   fprintf (pf, "%s", disp (obj));
   frewind (pf);
 
   ## It seems best to only use convert for image output.  Its ps and pdf
   ## are badly rendered.
   opt = lower (opt);
   switch (opt)
     case "pdf"
-      enscr = sprintf (
-                       "enscript --no-header -o %s.ps %s ; ps2pdf %s.ps %s.pdf; mv %s.pdf %s;exit",...
+      enscr = sprintf ("enscript --no-header -o %s.ps %s ; ps2pdf %s.ps %s.pdf; mv %s.pdf %s;exit", ...
                        tempf, tempf, tempf, tempf, tempf, filename);
       system (enscr);
       delete ([tempf ".ps"]);
     case "ps"
       enscr = sprintf ("enscript --no-header -o %s %s ; exit", filename, tempf);
       system (enscr);
     case "eps"
-      enscr = sprintf (
-                       "enscript --no-header -o %s.ps %s ; ps2eps --ignoreBB %s.ps; mv %s.eps %s; exit",...
+      enscr = sprintf ("enscript --no-header -o %s.ps %s ; ps2eps --ignoreBB %s.ps; mv %s.eps %s; exit", ...
                        tempf, tempf, tempf, tempf, filename);
       system (enscr);
       delete ([tempf ".ps"]);
     case "txt"
       enscr = sprintf ("cp %s %s", tempf, filename);
       system (enscr);
     case {"jpg", "jpeg"}
       enscr = sprintf ("convert -trim txt:%s  jpg:%s", tempf, filename);
@@ -76,17 +74,17 @@ function pr_out = printd (obj, filename)
     otherwise
       fclose (pf);
       delete (tempf);
       error ("Unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg", opt);
 
   endswitch
   fclose (pf);
   delete (tempf);
-  pr_out =  sprintf ("%s file %s written\n", opt, filename);
+  pr_out = sprintf ("%s file %s written\n", opt, filename);
 endfunction
 
 
 %!demo
 %! r2 = char ( ...
 %! 'stem step: 10, data: unsorted.', ...
 %! 'Hinges:    lo: 12, hi: 42'     , ...
 %! '   1 | 22118'                  , ...
diff --git a/scripts/plot/util/private/__ghostscript__.m b/scripts/plot/util/private/__ghostscript__.m
--- a/scripts/plot/util/private/__ghostscript__.m
+++ b/scripts/plot/util/private/__ghostscript__.m
@@ -28,17 +28,17 @@ function [gs_cmd, cleanup_cmd] = __ghost
 
   dos_shell = (ispc () && ! isunix ());
 
   opts.binary = "";
   opts.source = "-";
   opts.output = "-";
   opts.device = "";
   opts.epscrop = false;
-  opts.antialiasing  = false;
+  opts.antialiasing = false;
   opts.antialiasing_textalphabits = 4;,
   opts.antialiasing_graphicsalphabits = 4;
   opts.resolution = 150;
   opts.papersize = "";
   opts.pageoffset = [0 0];
   opts.debug = false;
   opts.level = [];
   opts.prepend = "";
@@ -61,17 +61,17 @@ function [gs_cmd, cleanup_cmd] = __ghost
   endfor
 
   if (isempty (opts.papersize))
     format_for_printer = false;
   else
     format_for_printer = true;
   endif
 
-  gs_opts = sprintf ("-dQUIET -dNOPAUSE -dBATCH -dSAFER -sDEVICE=%s", opts.device);
+  gs_opts = ["-dQUIET -dNOPAUSE -dBATCH -dSAFER -sDEVICE=" opts.device];
 
   if (! isempty (opts.level) && ismember (opts.level, [1, 2, 3]))
     gs_opts = sprintf ("%s -dLanguageLevel=%d", gs_opts, opts.level);
   endif
 
   if (opts.antialiasing && isempty (strfind (opts.device, "write")))
     ## Apply anti-aliasing to all bitmap formats/devices
     gs_opts = sprintf ("%s -dTextAlphaBits=%d -dGraphicsAlphaBits=%d",
diff --git a/scripts/plot/util/private/__gnuplot_ginput__.m b/scripts/plot/util/private/__gnuplot_ginput__.m
--- a/scripts/plot/util/private/__gnuplot_ginput__.m
+++ b/scripts/plot/util/private/__gnuplot_ginput__.m
@@ -112,17 +112,18 @@ function [x, y, button] = __gnuplot_ginp
           str = fread (istream, "*char")';
           if (isempty (str))
             sleep (0.05);
           else
             str = regexp (str, 'OCTAVE:\s+[-+.\d]+\s+[-+.\d]+\s+\d*', 'match');
           endif
           fclear (istream);
         endwhile
-        [x(k), y(k), button(k), count] = sscanf (str{end}(8:end), "%f %f %d", "C");
+        [x(k), y(k), button(k), count] = ...
+          sscanf (str{end}(8:end), "%f %f %d", "C");
       endif
 
       if ([x(k), y(k), button(k)] == [0, 0, -1])
         ## Mousing not active (no plot yet).
         break;
       endif
 
       if (button(k) == 0x0D || button(k) == 0x0A)
diff --git a/scripts/plot/util/private/__go_draw_axes__.m b/scripts/plot/util/private/__go_draw_axes__.m
--- a/scripts/plot/util/private/__go_draw_axes__.m
+++ b/scripts/plot/util/private/__go_draw_axes__.m
@@ -704,22 +704,22 @@ function __go_draw_axes__ (h, plot_strea
              if (isfield (obj, "facecolor"))
                if ((strcmp (obj.facecolor, "flat")
                    || strcmp (obj.facecolor, "interp"))
                    && isfield (obj, "cdata"))
                  if (ndims (obj.cdata) == 2
                      && (columns (obj.cdata) == nc
                          && (rows (obj.cdata) == 1
                              || rows (obj.cdata) == 3)))
-                   ccol = cdat (:, i);
+                   ccol = cdat(:, i);
                  elseif (ndims (obj.cdata) == 2
                      && (rows (obj.cdata) == nc
                          && (columns (obj.cdata) == 1
                              || columns (obj.cdata) == 3)))
-                   ccol = cdat (i, :);
+                   ccol = cdat(i, :);
                  elseif (ndims (obj.cdata) == 3)
                    ccol = permute (cdat (:, i, :), [1, 3, 2]);
                  else
                    ccol = cdat;
                  endif
                  if (strcmp (obj.facecolor, "flat"))
                    if (isequal (size (ccol), [1, 3]))
                      ## RGB Triplet
@@ -837,22 +837,22 @@ function __go_draw_axes__ (h, plot_strea
 
              if ((strcmp (ec, "flat")
                   || strcmp (ec, "interp"))
                  && isfield (obj, "cdata"))
                if (ndims (obj.cdata) == 2
                    && (columns (obj.cdata) == nc
                        && (rows (obj.cdata) == 1
                            || rows (obj.cdata) == 3)))
-                 ccol = cdat (:, i);
+                 ccol = cdat(:, i);
                elseif (ndims (obj.cdata) == 2
                        && (rows (obj.cdata) == nc
                            && (columns (obj.cdata) == 1
                                || columns (obj.cdata) == 3)))
-                 ccol = cdat (i, :);
+                 ccol = cdat(i, :);
                elseif (ndims (obj.cdata) == 3)
                  ccol = permute (cdat (:, i, :), [1, 3, 2]);
                else
                  ccol = cdat;
                endif
                if (strcmp (ec, "flat"))
                  if (numel (ccol) == 3)
                    color = ccol;
@@ -901,17 +901,17 @@ function __go_draw_axes__ (h, plot_strea
              endswitch
            else
              lt = "";
            endif
 
            if (isfield (obj, "linewidth"))
              lw = sprintf ("linewidth %f", obj.linewidth);
            else
-             lw  = "";
+             lw = "";
            endif
 
            [pt, pt2, obj] = gnuplot_pointtype (obj);
            if (! isempty (pt))
              pt = sprintf ("pointtype %s", pt);
            endif
            if (! isempty (pt2))
              pt2 = sprintf ("pointtype %s", pt2);
@@ -933,17 +933,17 @@ function __go_draw_axes__ (h, plot_strea
              style = "";
            else
              style = "lines";
            endif
            tmpwith = {};
 
            facesame = true;
            if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
-               && !strcmp (obj.markerfacecolor, "none"))
+               && ! strcmp (obj.markerfacecolor, "none"))
              if (strcmp (obj.markerfacecolor, "auto")
                  || ! isnumeric (obj.markerfacecolor)
                  || (isnumeric (obj.markerfacecolor)
                      && isequal (color, obj.markerfacecolor)))
                style = strcat (style, "points");
                if (isfield (obj, "markersize"))
                  if (length (mdat) == nc)
                    m = mdat(i);
@@ -983,18 +983,18 @@ function __go_draw_axes__ (h, plot_strea
                endif
                tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
                                         style, lw, pt2, lt, ps,
                                         colorspec);
              endif
            endif
 
            if (isfield (obj, "markeredgecolor")
-               && !strcmp (obj.markeredgecolor, "none"))
-             if (facesame && !isempty (pt)
+               && ! strcmp (obj.markeredgecolor, "none"))
+             if (facesame && ! isempty (pt)
                  && (strcmp (obj.markeredgecolor, "auto")
                      || ! isnumeric (obj.markeredgecolor)
                      || (isnumeric (obj.markeredgecolor)
                          && isequal (color, obj.markeredgecolor))))
                if (sidx == 1 && ((length (style) == 5
                         && strncmp (style, "lines", 5))
                        || isempty (style)))
                  style = strcat (style, "points");
@@ -1008,26 +1008,26 @@ function __go_draw_axes__ (h, plot_strea
                  else
                    ps = "";
                  endif
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
                                           style, lw, pt, lt, ps,
                                           colorspec);
                endif
              else
-               if (!isempty (style))
+               if (! isempty (style))
                  if (length (tmpwith) < sidx || isempty (tmpwith{sidx}))
                    tmpwith{sidx} = sprintf ("with %s %s %s %s",
                                             style, lw, lt,
                                             colorspec);
                  endif
                  sidx ++;
                endif
 
-               if (!isempty (pt))
+               if (! isempty (pt))
                  if (! mono)
                    if (strcmp (obj.markeredgecolor, "auto"))
                      colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                           round (255*color));
                    elseif (isnumeric (obj.markeredgecolor) && ! mono)
                      colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                           round (255*obj.markeredgecolor));
                    endif
@@ -1203,17 +1203,17 @@ function __go_draw_axes__ (h, plot_strea
 
           facecolor_none_or_white = (strcmp (obj.facecolor, "none")
                                      || (isnumeric (obj.facecolor)
                                          && all (obj.facecolor == 1)));
           hidden_removal = false;
           fputs (plot_stream, "set style increment default;\n");
           if (flat_interp_edge && facecolor_none_or_white)
             withpm3d = false;
-            withclause{data_idx} = sprintf ("with %s palette", style {1});
+            withclause{data_idx} = sprintf ("with %s palette", style{1});
             fputs (plot_stream, "unset pm3d\n");
             if (all (obj.facecolor == 1))
               hidden_removal = true;
             endif
           elseif (facecolor_none_or_white)
             if (all (obj.facecolor == 1))
               hidden_removal = true;
             endif
@@ -1231,17 +1231,17 @@ function __go_draw_axes__ (h, plot_strea
           else
             dord = "depthorder";
           endif
 
           if (flat_interp_face && strcmp (obj.edgecolor, "flat"))
             fprintf (plot_stream,
                      "set pm3d explicit at s %s %s corners2color c3;\n",
                      interp_str, dord);
-          elseif (!facecolor_none_or_white)
+          elseif (! facecolor_none_or_white)
             if (strcmp (obj.edgecolor, "none"))
               if (__gnuplot_has_feature__ ("transparent_surface")
                   && isscalar (obj.facealpha))
                 fprintf (plot_stream,
                          "set style fill transparent solid %f;\n",
                          obj.facealpha);
               endif
               fprintf (plot_stream,
@@ -1399,17 +1399,17 @@ function __go_draw_axes__ (h, plot_strea
         error ("__go_draw_axes__: unknown object class, %s",
                obj.type);
     endswitch
 
   endwhile
 
   ## This is need to prevent warnings for rotations in 3D plots, while
   ## allowing colorbars with contours.
-  if (nd == 2 || (data_idx > 1 && !view_map))
+  if (nd == 2 || (data_idx > 1 && ! view_map))
     fputs (plot_stream, "set pm3d implicit;\n");
   else
     fputs (plot_stream, "set pm3d explicit;\n");
   endif
 
   if (isnan (hidden_removal) || hidden_removal)
     fputs (plot_stream, "set hidden3d;\n");
   else
@@ -1771,22 +1771,23 @@ function x = flip (x)
   elseif (columns (x) == 1 || ischar (x))
     x = flipud (x);
   else
     x = flipud (fliplr (x));
   endif
 endfunction
 
 function spacing_spec = create_spacingspec (f, s, gp_term)
-  # The gnuplot default font size is 10, and default spacing is 1.25.
-  # gnuplot has a concept of a figure global font, and sizes everything
-  # appropriate to that, including the legend spacing.
-  #
-  # This means that if an alternative size is used, gnuplot will use an
-  # inappropriate spacing in the legend by default.
+  ## The gnuplot default font size is 10, and default spacing is 1.25.
+  ## gnuplot has a concept of a figure global font, and sizes everything
+  ## appropriate to that, including the legend spacing.
+  ##
+  ## This means that if an alternative size is used, gnuplot will use an
+  ## inappropriate spacing in the legend by default.
+  ##
   ## FIXME: Are fractional spacing specifications allowed?  Or should this
   ##        number be rounded?
   spc = s / 10 * 1.25;
   spacing_spec = sprintf ("spacing %d", spc);
 
 endfunction
 
 function fontspec = create_fontspec (f, s, gp_term)
@@ -1851,85 +1852,85 @@ function style = do_linestyle_command (o
 
   if (! isempty (pt))
     found_style = true;
   endif
 
   sidx = 1;
   if (isempty (errbars))
     if (isempty (lt))
-      style {sidx} = "";
+      style{sidx} = "";
     else
-      style {sidx} = "lines";
+      style{sidx} = "lines";
     endif
 
     facesame = true;
     if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
-        && !strcmp (obj.markerfacecolor, "none"))
+        && ! strcmp (obj.markerfacecolor, "none"))
       if (strcmp (obj.markerfacecolor, "auto")
           || ! isnumeric (obj.markerfacecolor)
           || (isnumeric (obj.markerfacecolor)
               && isequal (color, obj.markerfacecolor)))
         if (! isempty (pt2))
           fprintf (plot_stream, " pointtype %s", pt2);
-          style {sidx} = strcat (style{sidx}, "points");
+          style{sidx} = strcat (style{sidx}, "points");
         endif
         if (isfield (obj, "markersize"))
           fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
         endif
       else
         facesame = false;
         if (! found_style)
           fputs (plot_stream, " default");
         endif
         fputs (plot_stream, ";\n");
-        if (! isempty (style {sidx}))
+        if (! isempty (style{sidx}))
           sidx ++;
           idx ++;
         else
           fputs (plot_stream, ";\n");
         endif
         fprintf (plot_stream, "set style line %d default;\n", idx);
         fprintf (plot_stream, "set style line %d", idx);
         if (isnumeric (obj.markerfacecolor) && ! mono)
           fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
                    round (255*obj.markerfacecolor));
         endif
         if (! isempty (pt2))
-          style {sidx} = "points";
+          style{sidx} = "points";
           fprintf (plot_stream, " pointtype %s", pt2);
         endif
         if (isfield (obj, "markersize"))
           fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
         endif
       endif
     endif
     if (isfield (obj, "markeredgecolor")
-        && !strcmp (obj.markeredgecolor, "none"))
-      if (facesame && !isempty (pt)
+        && ! strcmp (obj.markeredgecolor, "none"))
+      if (facesame && ! isempty (pt)
           && (strcmp (obj.markeredgecolor, "auto")
               || ! isnumeric (obj.markeredgecolor)
               || (isnumeric (obj.markeredgecolor)
                   && isequal (color, obj.markeredgecolor))))
-        if (sidx == 1 && ((length (style {sidx}) == 5
-            && strncmp (style{sidx}, "lines", 5)) || isempty (style {sidx})))
+        if (sidx == 1 && ((length (style{sidx}) == 5
+            && strncmp (style{sidx}, "lines", 5)) || isempty (style{sidx})))
           if (! isempty (pt))
-            style {sidx} = strcat (style{sidx}, "points");
+            style{sidx} = strcat (style{sidx}, "points");
             fprintf (plot_stream, " pointtype %s", pt);
           endif
           if (isfield (obj, "markersize"))
             fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
           endif
         endif
       else
         if (! found_style)
           fputs (plot_stream, " default");
         endif
         fputs (plot_stream, ";\n");
-        if (!isempty (style {sidx}))
+        if (! isempty (style{sidx}))
           sidx ++;
           idx ++;
         else
           fputs (plot_stream, ";\n");
         endif
         fprintf (plot_stream, "set style line %d default;\n", idx);
         fprintf (plot_stream, "set style line %d", idx);
         if (! mono)
@@ -1937,30 +1938,30 @@ function style = do_linestyle_command (o
             fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
                      round (255*color));
           elseif (isnumeric (obj.markeredgecolor) && ! mono)
             fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
                      round (255*obj.markeredgecolor));
           endif
         endif
         if (! isempty (pt))
-          style {sidx} = "points";
+          style{sidx} = "points";
           fprintf (plot_stream, " pointtype %s", pt);
         endif
         if (isfield (obj, "markersize"))
           fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
         endif
       endif
     endif
   else
     style{1} = errbars;
     fputs (plot_stream, " pointtype 0");
   endif
 
-  if (! found_style && isempty (style {1}))
+  if (! found_style && isempty (style{1}))
     fputs (plot_stream, " default");
   endif
 
   fputs (plot_stream, ";\n");
 
 endfunction
 
 function [pt, pt2, obj] = gnuplot_pointtype (obj)
@@ -2414,20 +2415,20 @@ function str = __tex2enhanced__ (str, fn
             str = [str(1:s(i) - 1) g str(s(i) + length (flds{j}) + 1:end)];
             break;
           endif
         endfor
       endif
     endif
   endfor
 
-  ## Prepend @ to things  things like _0^x or _{-100}^{100} for
-  ## alignment But need to put the shorter of the two arguments first.
-  ## Carful of nested {} and unprinted characters when defining
-  ## shortest.. Don't have to worry about things like ^\theta as they
+  ## Prepend @ to things like _0^x or _{-100}^{100} for alignment.
+  ## But need to put the shorter of the two arguments first.
+  ## Careful of nested {} and unprinted characters when defining
+  ## shortest..  Don't have to worry about things like ^\theta as they
   ## are already converted to ^{/Symbol q}.
 
   ## FIXME: This is a mess... Is it worth it just for a "@" character?
 
   [s, m] = regexp (str,'[_\^]','start','matches');
   i = 1;
   p = 0;
   while (i < length (s))
@@ -2499,17 +2500,17 @@ function str = __tex2enhanced__ (str, fn
     endif
   endwhile
 
 endfunction
 
 function l = length_string (s)
   l = length (s) - length (strfind (s,'{')) - length (strfind (s,'}'));
   m = regexp (s, '/([\w-]+|[\w-]+=\d+)', 'matches');
-  if (!isempty (m))
+  if (! isempty (m))
     l = l - sum (cellfun ("length", m));
   endif
 endfunction
 
 function sym = __setup_sym_table__ ()
   ## Setup the translation table for TeX to gnuplot enhanced mode.
   sym.forall = '{/Symbol \042}';
   sym.exists = '{/Symbol \044}';
@@ -2537,17 +2538,17 @@ function sym = __setup_sym_table__ ()
   sym.gamma = '{/Symbol g}';
   sym.eta = '{/Symbol h}';
   sym.iota = '{/Symbol i}';
   sym.varphi = '{/Symbol j}';              # Not in OpenGL
   sym.kappa = '{/Symbol k}';
   sym.lambda = '{/Symbol l}';
   sym.mu = '{/Symbol m}';
   sym.nu = '{/Symbol n}';
-  sym.o =  '{/Symbol o}';
+  sym.o = '{/Symbol o}';
   sym.pi = '{/Symbol p}';
   sym.theta = '{/Symbol q}';
   sym.rho = '{/Symbol r}';
   sym.sigma = '{/Symbol s}';
   sym.tau = '{/Symbol t}';
   sym.upsilon = '{/Symbol u}';
   sym.varpi = '{/Symbol v}';
   sym.omega = '{/Symbol w}';
@@ -2613,19 +2614,19 @@ function sym = __setup_sym_table__ ()
   sym.Leftrightarrow = '{/Symbol \333}';   # Not in OpenGL
   sym.Leftarrow = '{/Symbol \334}';
   sym.Uparrow = '{/Symbol \335}';          # Not in OpenGL
   sym.Rightarrow = '{/Symbol \336}';
   sym.Downarrow = '{/Symbol \337}';        # Not in OpenGL
   sym.diamond = '{/Symbol \340}';          # Not in OpenGL
   sym.copyright = '{/Symbol \343}';
   sym.lfloor = '{/Symbol \353}';
-  sym.lceil  = '{/Symbol \351}';
+  sym.lceil = '{/Symbol \351}';
   sym.rfloor = '{/Symbol \373}';
-  sym.rceil  = '{/Symbol \371}';
+  sym.rceil = '{/Symbol \371}';
   sym.int = '{/Symbol \362}';
 endfunction
 
 function retval = __do_enhanced_option__ (enhanced, obj)
   retval = "";
   if (enhanced)
     if (strcmpi (obj.interpreter, "none"))
       retval = "noenhanced";
diff --git a/scripts/plot/util/private/__go_draw_figure__.m b/scripts/plot/util/private/__go_draw_figure__.m
--- a/scripts/plot/util/private/__go_draw_figure__.m
+++ b/scripts/plot/util/private/__go_draw_figure__.m
@@ -99,17 +99,17 @@ function __go_draw_figure__ (h, plot_str
                         ll = hobj(k);
                       endif
                       if (! strcmp (get (hobj(k), "marker"), "none"))
                         lm = hobj(k);
                       endif
                     endfor
 
                     if (! isempty (ll))
-                      if (!isempty (lm))
+                      if (! isempty (lm))
                         toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", get(ll,"linestyle"), "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
                       else
                         toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(ll,"color"), "linestyle", get(ll,"linestyle"), "marker", "none", "displayname", displayname, "parent", kids(i))];
                       endif
                     elseif (! isempty (lm))
                       toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", "none", "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
                     endif
                   endfor
diff --git a/scripts/plot/util/private/__opengl_print__.m b/scripts/plot/util/private/__opengl_print__.m
--- a/scripts/plot/util/private/__opengl_print__.m
+++ b/scripts/plot/util/private/__opengl_print__.m
@@ -160,20 +160,20 @@ function opts = __opengl_print__ (opts)
 
   for n = 1:numel (pipeline)
     if (opts.debug)
       fprintf ("opengl-pipeline: '%s'\n", pipeline{n});
     endif
 
     if (strcmp (get (opts.figure, "visible"), "on"))
       ## Use toolkits "print_figure" method
-      drawnow (gl2ps_device{n}, strcat ('|', pipeline{n}));
+      drawnow (gl2ps_device{n}, ['|' pipeline{n}]);
     else
       ## Use OpenGL offscreen rendering with OSMesa
-      __osmesa_print__ (opts.figure, strcat ('|', pipeline{n}), gl2ps_device{n});
+      __osmesa_print__ (opts.figure, ['|', pipeline{n}), gl2ps_device{n}]);
     endif
   endfor
 
   if (! isempty (strfind (opts.devopt, "standalone")))
     opts.latex_standalone (opts);
   endif
 
 endfunction
diff --git a/scripts/plot/util/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/util/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -248,17 +248,17 @@ function arg_st = __print_parse_opts__ (
 
   if (strcmp (__graphics_toolkit__, "gnuplot")
       && __gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
     suffixes(strncmp (dev_list, "epslatex", 8)) = {"eps"};
   endif
 
   match = strcmpi (dev_list, arg_st.devopt);
   if (any (match))
-    default_suffix = suffixes {match};
+    default_suffix = suffixes{match};
   else
     default_suffix = arg_st.devopt;
   endif
 
   if (dot == 0 && ! isempty (arg_st.name))
     arg_st.name = strcat (arg_st.name, ".", default_suffix);
   endif
 
@@ -340,17 +340,18 @@ function arg_st = __print_parse_opts__ (
       [arg_st.ghostscript.papersize, paperposition] = ...
                            gs_papersize (arg_st.figure, arg_st.orientation);
     else
       ## allows tests to be run
       arg_st.ghostscript.papersize = "letter";
       paperposition = [0.25, 2.50, 8.00, 6.00] * 72;
     endif
     arg_st.canvas_size = paperposition(3:4);
-    if (strcmp (__graphics_toolkit__, "gnuplot") && ! arg_st.ghostscript.epscrop)
+    if (strcmp (__graphics_toolkit__, "gnuplot")
+        && ! arg_st.ghostscript.epscrop)
       arg_st.ghostscript.pageoffset = paperposition(1:2) - 50;
     else
       arg_st.ghostscript.pageoffset = paperposition(1:2);
     endif
   else
     ## Convert canvas size to points from pixels.
     if (! isempty (arg_st.fontsize))
       ## Work around the eps bbox having whole numbers (both gnuplot & gl2ps).
@@ -477,20 +478,21 @@ function gs = __ghostscript_binary__ ()
                "print.m: GSC environment variable not set properly");
       warn_on_bad_gsc = false;
       gs_binaries = {};
     else
       gs_binaries = {};
     endif
     if (isunix ())
       ## Unix - Includes Mac OSX and Cygwin.
-      gs_binaries = horzcat (gs_binaries, {"gs", "gs.exe"});
+      gs_binaries = [gs_binaries, {"gs", "gs.exe"}];
     else
       ## pc - Includes Win32 and mingw.
-      gs_binaries = horzcat (gs_binaries, {"gs.exe", "gswin32c.exe", "gswin64c.exe", "mgs.exe"});
+      gs_binaries = [gs_binaries, ...
+                     {"gs.exe", "gswin32c.exe", "gswin64c.exe", "mgs.exe"}];
     endif
     n = 0;
     while (n < numel (gs_binaries) && isempty (ghostscript_binary))
       n = n + 1;
       ghostscript_binary = file_in_path (getenv ("PATH"), gs_binaries{n});
     endwhile
     if (warn_on_no_ghostscript && isempty (ghostscript_binary))
       warning ("print:noghostscript",
@@ -576,17 +578,18 @@ function [papersize, paperposition] = gs
   ## FIXME: This will be obsoleted by listeners for paper properties.
   ##        Papersize is tall when portrait,and wide when landscape.
   if ((papersize(1) > papersize(2) && strcmpi (paperorientation, "portrait"))
       || (papersize(1) < papersize(2) && strcmpi (paperorientation, "landscape")))
     papersize = papersize([2,1]);
     paperposition = paperposition([2,1,4,3]);
   endif
 
-  if ((! strcmp (papertype, "<custom>")) && (strcmp (paperorientation, "portrait")))
+  if (! strcmp (papertype, "<custom>")
+      && (strcmp (paperorientation, "portrait")))
     ## For portrait use the ghostscript name
     papersize = papertype;
     papersize(papersize=="-") = "";
     papersize = strrep (papersize, "us", "");
     switch (papersize)
       case "a"
         papersize = "letter";
       case {"b", "tabloid"}
@@ -611,18 +614,18 @@ function value = convert2points (value, 
       error ("print:customnormalized",
              "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined");
   endswitch
 endfunction
 
 function device_list = gs_device_list ();
   ## Graphics formats/languages, not printers.
   device_list = {"bmp16"; "bmp16m"; "bmp256"; "bmp32b"; "bmpgray"; ...
-                 "epswrite"; "eps2write"; "jpeg"; "jpegcymk"; "jpeggray"; "pbm"; ...
-                 "pbmraw"; "pcx16"; "pcx24b"; "pcx256"; "pcx2up"; ...
+                 "epswrite"; "eps2write"; "jpeg"; "jpegcymk"; "jpeggray";
+                 "pbm"; "pbmraw"; "pcx16"; "pcx24b"; "pcx256"; "pcx2up"; ...
                  "pcxcmyk"; "pcxgray"; "pcxmono"; "pdfwrite"; "pgm"; ...
                  "pgmraw"; "pgnm"; "pgnmraw"; "png16"; "png16m"; ...
                  "png256"; "png48"; "pngalpha"; "pnggray"; "pngmono"; ...
                  "pnm"; "pnmraw"; "ppm"; "ppmraw"; "pswrite"; ...
                  "ps2write"; "tiff12nc"; "tiff24nc"; "tiff32nc"; ...
                  "tiffcrle"; "tiffg3"; "tiffg32d"; "tiffg4"; ...
                  "tiffgray"; "tifflzw"; "tiffpack"; "tiffsep"};
 endfunction
diff --git a/scripts/plot/util/refreshdata.m b/scripts/plot/util/refreshdata.m
--- a/scripts/plot/util/refreshdata.m
+++ b/scripts/plot/util/refreshdata.m
@@ -85,17 +85,17 @@ function refreshdata (h, workspace)
   for i = 1 : numel (h)
     obj = get (h(i));
     flds = fieldnames (obj);
     ## regexp() is proper way to do searching, but is 3X slower.
     ## Pretty unlikely that people are going to be adding datasource
     ## properties that are not, in fact, datasources.
     ## m = regexp (flds, '^.+datasource$');
     m = strfind (flds, "datasource");
-    m = flds(!cellfun (@isempty, m));
+    m = flds(! cellfun (@isempty, m));
     for j = 1 : numel (m)
       if (isempty (obj.(m{j})))
         continue;  # datasource field doesn't point to anything
       endif
       expr = obj.(m{j});       # datasource field
       val = evalin (workspace, expr);
       pdname = m{j}(1:end-6);  # property data name without "source"
       set (h(i), pdname, val);
diff --git a/scripts/plot/util/rotate.m b/scripts/plot/util/rotate.m
--- a/scripts/plot/util/rotate.m
+++ b/scripts/plot/util/rotate.m
@@ -161,17 +161,17 @@ function rotate (h, direction, alpha, or
 
     if (! is_image(i))
       set (h(i), "zdata", zr);
     endif
   endfor
 
 endfunction
 
-%% Test input validation
+## Test input validation
 %!shared h1, h2, o1, o2, o3
 %! h1 = figure ("visible", "off");
 %! o1 = line ();
 %! h2 = figure ("visible", "off");
 %! o2 = line ();
 %! o3 = text (0, 0, "foobar");
 %!error rotate ()
 %!error rotate (o1)
diff --git a/scripts/plot/util/saveas.m b/scripts/plot/util/saveas.m
--- a/scripts/plot/util/saveas.m
+++ b/scripts/plot/util/saveas.m
@@ -56,45 +56,45 @@
 ## @end group
 ## @end example
 ##
 ## @seealso{print, hgsave, orient}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
-function  saveas (h, filename, fmt = "pdf")
+function saveas (h, filename, fmt = "pdf")
 
-  if ((nargin != 2) && (nargin != 3))
+  if (nargin != 2 && nargin != 3)
     print_usage ();
   endif
 
   if (ishandle (h))
     if (isfigure (h))
       fig = h;
     else
       fig = ancestor (h, "figure");
     endif
   else
     error ("saveas: first argument H must be a graphics handle");
   endif
 
-  if (!ischar (filename))
+  if (! ischar (filename))
     error ("saveas: FILENAME must be a string");
   endif
 
   if (nargin == 2)
     [~, ~, ext] = fileparts (filename);
-    if (!isempty (ext))
+    if (! isempty (ext))
       fmt = ext(2:end);
     endif
   endif
 
   if (nargin == 3)
-    if (!ischar (filename))
+    if (! ischar (filename))
       error ("saveas: EXT must be a string");
     endif
 
     [~, ~, ext] = fileparts (filename);
 
     if (isempty (ext))
       filename = strcat (filename, ".", fmt);
     endif
diff --git a/scripts/plot/util/struct2hdl.m b/scripts/plot/util/struct2hdl.m
--- a/scripts/plot/util/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -458,17 +458,17 @@ function [h, sout, pout] = createhg_hile
 
     bargroup = s.properties.bargroup;
     oldh = s.handle;
 
     temp = ismember ([p(1:2:end) oldh], bargroup);
 
     tst = sum (temp) == length (bargroup);
 
-    if (isscalar (bargroup) || !tst)
+    if (isscalar (bargroup) || ! tst)
       xdata = s.properties.xdata;
       ydata = s.properties.ydata;
 
       h = bar (xdata, ydata);
 
       ## delete already set properties,
       s.properties = rmfield (s.properties, ...
                                 {"xdata", "ydata", ...
@@ -479,17 +479,17 @@ function [h, sout, pout] = createhg_hile
       xdata = [];
       ydata = [];
 
       ##build x/y matrix
       nbar = length (bargroup);
       tmp = struct ("handle", NaN, "type", "", "children", [], "special", []);
       for ii = 1:(nbar - 1)
         idx = find (p(1:2:end) == bargroup(ii)) * 2;
-        hdl = p (idx);
+        hdl = p(idx);
         xdata = [xdata get(hdl).xdata];
         ydata = [ydata get(hdl).ydata];
         tmp.children(ii) = hdl2struct (hdl);
       endfor
 
       xdata = [xdata s.properties.xdata];
       ydata = [ydata s.properties.ydata];
       width = s.properties.barwidth;
diff --git a/scripts/plot/util/subplot.m b/scripts/plot/util/subplot.m
--- a/scripts/plot/util/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -192,28 +192,28 @@ function h = subplot (varargin)
 
     ## FIXME: At the moment we force gnuplot to use the aligned mode
     ##        which will set "activepositionproperty" to "position".
     ##        This can yield to text overlap between labels and titles.
     ##        See bug #31610.
     if (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
       align_axes = true;
     endif
-    
-    if (! have_position)    
+
+    if (! have_position)
       ## Subplots that cover more that one base subplot are not updated
       align_axes = (align_axes || (! isscalar (index)));
       ## Normal case where subplot indices have been given
       [pos, opos, li] = subplot_position (cf, rows, cols, index);
     else
       ## Position is specified by the user.
       li = zeros (1,4);
       align_axes = true;
     endif
-    
+
     set (cf, "nextplot", "add");
 
     found = false;
     kids = get (cf, "children");
     for child = kids(:)'
       ## Check whether this child is still valid; this might not be the
       ## case anymore due to the deletion of previous children (due to
       ## "deletefcn" callback or for legends/colorbars that are deleted
@@ -228,25 +228,25 @@ function h = subplot (varargin)
         endif
 
         if (isappdata (child, "__subplotposition__"))
           objpos = getappdata (child, "__subplotposition__");
         else
           objpos = get (child, "position");
         endif
         if (all (abs (objpos - pos) < eps) && ! replace_axes)
-          ## If the new axes are in exactly the same position  
+          ## If the new axes are in exactly the same position
           ## as an existing axes object, or if they share the same
           ## appdata "__subplotposition__", use the existing axes.
           found = true;
           hsubplot = child;
         else
           ## If the new axes overlap an old axes object, delete the old axes.
           objpos = get (child, "position");
-          
+
           x0 = pos(1);
           x1 = x0 + pos(3);
           y0 = pos(2);
           y1 = y0 + pos(4);
           objx0 = objpos(1);
           objx1 = objx0 + objpos(3);
           objy0 = objpos(2);
           objy1 = objy0 + objpos(4);
@@ -267,82 +267,82 @@ function h = subplot (varargin)
       hsubplot = axes ("box", "off",
                        "activepositionproperty", "position",
                        "position", pos, "looseinset", li,
                        varargin{:});
 
       if (! align_axes)
         ## base position (no ticks, no annotation, no cumbersome neighbor)
         setappdata (hsubplot, "__subplotposition__", pos);
-        ## max outerposition 
+        ## max outerposition
         setappdata (hsubplot, "__subplotouterposition__", opos);
         addlistener (hsubplot, "outerposition", @subplot_align);
         addlistener (hsubplot, "xaxislocation", @subplot_align);
         addlistener (hsubplot, "yaxislocation", @subplot_align);
         addlistener (hsubplot, "position", {@subplot_align, true});
         subplot_align (hsubplot);
       endif
-      
+
     endif
   unwind_protect_cleanup
     set (0, "defaultaxesunits", axesunits);
     set (cf, "units", figureunits);
   end_unwind_protect
-  
+
   if (nargout > 0)
     h = hsubplot;
   endif
 
 endfunction
 
 function [pos, opos, li] = subplot_position (hf, nrows, ncols, idx)
 
   if (nrows == 1 && ncols == 1)
     ## Trivial result for subplot (1,1,1)
     pos = get (0, "defaultaxesposition");
     opos = get (0, "defaultaxesouterposition");
     li = get (0, "defaultaxeslooseinset");
     return;
   endif
-  
-  ## Row/Column inside the axes array  
+
+  ## Row/Column inside the axes array
   row = ceil (idx / ncols);
   col = idx .- (row - 1) * ncols;
   row = [min(row) max(row)];
-  col = [min(col) max(col)];  
-  
+  col = [min(col) max(col)];
+
   ## Minimal margins around subplots defined in points
   fig_units = get (hf, "units");
   set (hf, "units", "points");
   pts_size = get (gcf, "position")(3:4);
   xbasemargin = 6 / pts_size(1);
   ybasemargin = 6 / pts_size(2);
 
   ## Column/row separation
   margin.column = .2 / ncols + 2 * xbasemargin;
   margin.row = .2 / nrows + 2 * ybasemargin;
-  
+
   set (hf, "units", fig_units);
   margin.left = xbasemargin;
   margin.right = xbasemargin;
   margin.bottom = ybasemargin;
   margin.top = ybasemargin;
-  
+
   ## Boundary axes have default margins
   borders = get (0, "defaultaxesposition");
   if (col(1) == 1)
     margin.left = borders(1);
   else
     margin.left = margin.column - margin.right;
   endif
   if (col(2) == ncols)
     margin.right = 1 - borders(1) - borders(3);
   endif
 
-  
+
   if (row(2) == nrows)
     margin.bottom = borders(2);
   else
     margin.bottom = margin.row - margin.top;
   endif
   if (row(1) == 1)
     margin.top = 1 - borders(2) - borders(4);
   endif
@@ -352,17 +352,17 @@ function [pos, opos, li] = subplot_posit
   width = (borders(3) - (ncols - 1) * margin.column) / ncols;
   height = (borders(4) - (nrows - 1) * margin.row) /nrows;
 
   ## Position, outerposition and looseinset
   x0 = borders(1) + (col(1) - 1) * (width + margin.column);
   y0 = borders(2) + (nrows - row(2)) * (height + margin.row);
   width += diff (col) * (width + margin.column);
   height += diff (row) * (height + margin.row);
-  
+
   pos = [x0 y0 width height];
   opos = [(x0 - margin.left), (y0 - margin.bottom), ...
           (width + margin.left + margin.right), ...
           (height + margin.bottom + margin.top)];
   li = [margin.left, margin.bottom, margin.right, margin.top];
 
 endfunction
 
@@ -373,34 +373,34 @@ function subplot_align (h, d, rmupdate =
       ## The "position" property has been changed from outside this
       ## routine. Don't update anymore.
       if (isappdata (h, "__subplotposition__"))
         rmappdata (h, "__subplotposition__");
         rmappdata (h, "__subplotouterposition__");
       endif
       return
     endif
-    
+
     unwind_protect
       updating = true;
       hf = ancestor (h, "figure");
       children = get (hf, "children");
-                 
+
       ## Base position of the subplot
       pos = getappdata (children, "__subplotposition__");
 
       if (iscell (pos))
         do_align = ! cellfun (@isempty, pos);
         pos = cell2mat (pos(do_align));
       else
         return
       endif
       hsubplots = children(do_align);
-      
-      
+
+
       ## There may be mixed subplot series (e.g. 2-by-6 and 1-by-6) in
       ## the same figure. Only subplots that have the same width and
       ## height as this one are updated.
       if (any (h == hsubplots))
         width = pos(h == hsubplots, 3);
         height = pos(h == hsubplots, 4);
         do_align = (pos(:,3) == width) & (pos(:,4) == height);
         hsubplots(! do_align) = [];
@@ -412,17 +412,17 @@ function subplot_align (h, d, rmupdate =
       ## Reset outerpositions to their default value
       opos = getappdata (hsubplots, "__subplotouterposition__");
       if (iscell (opos))
         opos = cell2mat (opos);
       endif
       for ii = 1:numel (hsubplots);
         set (hsubplots(ii), "outerposition", opos(ii,:), ...
              "activepositionproperty", "position");
-      endfor   
+      endfor
 
       ## Compare current positions to default and compute the new ones
       curpos = get (hsubplots, "position");
       if (iscell (curpos))
         curpos = cell2mat (curpos);
       endif
       dx0 = max (curpos(:,1) - pos(:,1));
       dx0(dx0<0) = 0;
@@ -432,21 +432,21 @@ function subplot_align (h, d, rmupdate =
       dy0(dy0<0) = 0;
       dy1 = max ((pos(:,2) + pos(:,4)) - (curpos(:,2) + curpos(:,4)));
       dy1(dy1<0) = 0;
 
       pos(:,1) += dx0;
       pos(:,2) += dy0;
       pos(:,3) -= dx0 + dx1;
       pos(:,4) -= dy0 + dy1;
-      
+
       for ii = 1:numel (hsubplots)
         set (hsubplots(ii), "position", pos(ii,:));
       endfor
-      
+
     unwind_protect_cleanup
       updating = false;
     end_unwind_protect
   endif
 
 endfunction
 
 
diff --git a/scripts/plot/util/zoom.m b/scripts/plot/util/zoom.m
--- a/scripts/plot/util/zoom.m
+++ b/scripts/plot/util/zoom.m
@@ -55,28 +55,26 @@
 ## @seealso{pan, rotate3d}
 ## @end deftypefn
 
 ## Eventually we need to also support these features:
 ## @deftypefnx {Command} {zoom_object_handle =} zoom (@var{hfig})
 
 function zoom (varargin)
 
-  hfig = NaN;
-
   nargs = nargin;
-
   if (nargs > 2)
     print_usage ();
   endif
 
-  if (nargin == 1 && nargout > 0 && isfigure (varargin{1}))
+  if (nargs == 1 && nargout > 0 && isfigure (varargin{1}))
     error ("zoom_object_handle = zoom (hfig): not implemented");
   endif
 
+  hfig = NaN;
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
       nargs--;
     else
       error ("zoom: expecting figure handle as first argument");
     endif
@@ -171,16 +169,17 @@ function zoom (varargin)
       endswitch
     else
       error ("zoom: wrong type argument '%s'", class (arg));
     endif
   endif
 
 endfunction
 
+
 %!demo
 %! clf;
 %! sombrero ();
 %! pause (1);
 %! %% zoom in by a factor of 2
 %! zoom (2);
 %! pause (1);
 %! %% return to original zoom level
@@ -191,8 +190,9 @@ endfunction
 %! pause (1);
 %! %% set this zoom level as the "initial zoom level"
 %! %% and zoom in some more
 %! zoom reset;
 %! zoom (2);
 %! pause (1);
 %! %% return to zoom level set by last call to "zoom reset"
 %! zoom out;
+
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -132,15 +132,15 @@ endfunction
 
 %!assert (conv (a,b,"same"), [4, 10, 16, 22, 28, 34, 40, 46, 52, 47])
 %!assert (conv (b,a,"same"), [28, 34, 40])
 
 %!assert (conv (a,b,"valid"), [10, 16, 22, 28, 34, 40, 46, 52])
 %!assert (conv (b,a,"valid"), zeros (1,0))
 
 
-%% Test input validation
+## Test input validation
 %!error conv (1)
 %!error conv (1,2,3,4)
 %!error <A and B must be vectors> conv ([1, 2; 3, 4], 3)
 %!error <A and B must be vectors> conv (3, [1, 2; 3, 4])
 %!error <SHAPE argument must be> conv (2, 3, "INVALID_SHAPE")
 
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -50,17 +50,17 @@ function [b, r] = deconv (y, a)
 
   ## Ensure A is oriented as Y.
   if (diff (size (y)(1:2)) * diff (size (a)(1:2)) < 0)
     a = permute (a, [2, 1]);
   endif
 
   if (ly > la)
     x = zeros (size (y) - size (a) + 1);
-    x (1) = 1;
+    x(1) = 1;
     b = filter (y, a, x);
   elseif (ly == la)
     b = filter (y, a, 1);
   else
     b = 0;
   endif
 
   lc = la + length (b) - 1;
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -50,17 +50,17 @@ function pp = mkpp (x, P, d)
     print_usage ();
   endif
 
   ## check x
   if (length (x) < 2)
     error ("mkpp: at least one interval is needed");
   endif
 
-  if (!isvector (x))
+  if (! isvector (x))
     error ("mkpp: x must be a vector");
   endif
 
   len = length (x) - 1;
   dP = length (size (P));
 
   pp = struct ("form", "pp",
                "breaks", x(:).',
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -72,17 +72,17 @@ function ret = pchip (x, y, xi)
   endif
 
   ## make row vector
   x = x(:).';
   n = length (x);
 
   ## Check the size and shape of y
   if (isvector (y))
-    y = y(:).'; ##row vector
+    y = y(:).';  # force row vector
     szy = size (y);
     if (! size_equal (x, y))
       error ("pchip: length of X and Y must match");
     endif
   else
     szy = size (y);
     if (n != szy(end))
       error ("pchip: length of X and last dimension of Y must match");
diff --git a/scripts/polynomial/polyeig.m b/scripts/polynomial/polyeig.m
--- a/scripts/polynomial/polyeig.m
+++ b/scripts/polynomial/polyeig.m
@@ -90,13 +90,13 @@ endfunction
 
 %!test
 %! [v,z] = polyeig (C0, C1);
 %! assert (z, [-8; -4]);
 %! z = diag (z);
 %! d = C0*v + C1*v*z;
 %! assert (norm (d), 0.0);
 
-%% Input validation tests
+## Test input validation
 %!error polyeig ()
 %!error [a,b,c] = polyeig (1)
 %!error <coefficients must be square matrices> polyeig (ones (3,2))
 %!error <coefficients must have the same dimensions> polyeig (ones (3,3), ones (2,2))
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -19,22 +19,20 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {ppd =} ppder (pp)
 ## @deftypefnx {Function File} {ppd =} ppder (pp, m)
 ## Compute the piecewise @var{m}-th derivative of a piecewise polynomial
 ## struct @var{pp}.  If @var{m} is omitted the first derivative is calculated.
 ## @seealso{mkpp, ppval, ppint}
 ## @end deftypefn
 
-function ppd = ppder (pp, m)
+function ppd = ppder (pp, m = 1)
 
-  if ((nargin < 1) || (nargin > 2))
+  if (nargin < 1 || nargin > 2)
     print_usage ();
-  elseif (nargin == 1)
-    m = 1;
   endif
 
   if (! (isstruct (pp) && strcmp (pp.form, "pp")))
     error ("ppder: PP must be a structure");
   endif
 
   [x, p, n, k, d] = unmkpp (pp);
 
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -126,16 +126,16 @@ endfunction
 %! breaks = [0, 1, 2, 3];
 %! coefs = rand (6, 4);
 %! pp = mkpp (breaks, coefs, 2);
 %! ret = zeros (2, 4, 2);
 %! ret(:,:,1) = ppval (pp, breaks');
 %! ret(:,:,2) = ppval (pp, breaks');
 %! assert (ppval (pp, [breaks',breaks']), ret)
 
-%% Test input validation
+## Test input validation
 %!error ppval ()
 %!error ppval (1)
 %!error ppval (1,2,3)
 %!error <argument must be a pp-form structure> ppval (1,2)
 %!error <argument must be a pp-form structure> ppval (struct ("a", 1), 2)
 %!error <argument must be a pp-form structure> ppval (struct ("form", "ab"), 2)
 
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -188,17 +188,17 @@ function [r, p, k, e] = residue (b, a, v
   ## Find the poles.
 
   p = roots (a);
   lp = length (p);
 
   ## Sort poles so that multiplicity loop will work.
 
   [e, indx] = mpoles (p, toler, 1);
-  p = p (indx);
+  p = p(indx);
 
   ## For each group of pole multiplicity, set the value of each
   ## pole to the average of the group. This reduces the error in
   ## the resulting poles.
 
   p_group = cumsum (e == 1);
   for ng = 1:p_group(end)
     m = find (p_group == ng);
@@ -284,18 +284,18 @@ function [pnum, pden, e] = rresidue (r, 
   if (nargin < 3)
     k = [];
   endif
 
   if (numel (e))
     indx = 1:numel (p);
   else
     [e, indx] = mpoles (p, toler, 0);
-    p = p (indx);
-    r = r (indx);
+    p = p(indx);
+    r = r(indx);
   endif
 
   indx = 1:numel (p);
 
   for n = indx
     pn = [1, -p(n)];
     if (n == 1)
       pden = pn;
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -69,15 +69,15 @@ endfunction
 %! pp = mkpp (b,c);
 %! [x, P, n, k, d] = unmkpp (pp);
 %! assert (x, b);
 %! assert (P, reshape (c, [2 12]));
 %! assert (n, 2);
 %! assert (k, 12);
 %! assert (d, 1);
 
-%% Test input validation
+## Test input validation
 %!error unmkpp ()
 %!error unmkpp (1,2)
 %!error <piecewise polynomial structure> unmkpp (1)
 %!error <piecewise polynomial structure> unmkpp (struct ("field1", "pp"))
 %!error <piecewise polynomial structure> unmkpp (struct ("form", "not_a_pp"))
 
diff --git a/scripts/prefs/addpref.m b/scripts/prefs/addpref.m
--- a/scripts/prefs/addpref.m
+++ b/scripts/prefs/addpref.m
@@ -65,12 +65,12 @@ function addpref (group, pref, val)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Testing these functions will require some care to avoid wiping out
-%% existing (or creating unwanted) preferences for the user running the
-%% tests.
+## Testing these functions will require some care to avoid wiping out
+## existing (or creating unwanted) preferences for the user running the
+## tests.
 
diff --git a/scripts/prefs/getpref.m b/scripts/prefs/getpref.m
--- a/scripts/prefs/getpref.m
+++ b/scripts/prefs/getpref.m
@@ -86,12 +86,12 @@ function retval = getpref (group, pref, 
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Testing these functions will require some care to avoid wiping out
-%% existing (or creating unwanted) preferences for the user running the
-%% tests.
+## Testing these functions will require some care to avoid wiping out
+## existing (or creating unwanted) preferences for the user running the
+## tests.
 
diff --git a/scripts/prefs/ispref.m b/scripts/prefs/ispref.m
--- a/scripts/prefs/ispref.m
+++ b/scripts/prefs/ispref.m
@@ -51,12 +51,12 @@ function retval = ispref (group, pref)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Testing these functions will require some care to avoid wiping out
-%% existing (or creating unwanted) preferences for the user running the
-%% tests.
+## Testing these functions will require some care to avoid wiping out
+## existing (or creating unwanted) preferences for the user running the
+## tests.
 
diff --git a/scripts/prefs/private/loadprefs.m b/scripts/prefs/private/loadprefs.m
--- a/scripts/prefs/private/loadprefs.m
+++ b/scripts/prefs/private/loadprefs.m
@@ -34,12 +34,12 @@ function retval = loadprefs ()
     retval= tmp.prefs;
   else
     retval = [];
   endif
 
 endfunction
 
 
-%% Testing these functions will require some care to avoid wiping out
-%% existing (or creating unwanted) preferences for the user running the
-%% tests.
+## Testing these functions will require some care to avoid wiping out
+## existing (or creating unwanted) preferences for the user running the
+## tests.
 
diff --git a/scripts/prefs/private/prefsfile.m b/scripts/prefs/private/prefsfile.m
--- a/scripts/prefs/private/prefsfile.m
+++ b/scripts/prefs/private/prefsfile.m
@@ -25,12 +25,12 @@
 
 function retval = prefsfile ()
 
   retval = [prefdir() filesep() ".octave_prefs"];
 
 endfunction
 
 
-%% Testing these functions will require some care to avoid wiping out
-%% existing (or creating unwanted) preferences for the user running the
-%% tests.
+## Testing these functions will require some care to avoid wiping out
+## existing (or creating unwanted) preferences for the user running the
+## tests.
 
diff --git a/scripts/prefs/private/saveprefs.m b/scripts/prefs/private/saveprefs.m
--- a/scripts/prefs/private/saveprefs.m
+++ b/scripts/prefs/private/saveprefs.m
@@ -27,12 +27,12 @@ function retval = saveprefs (s)
 
   prefs = s;
 
   save (prefsfile (), "prefs");
 
 endfunction
 
 
-%% Testing these functions will require some care to avoid wiping out
-%% existing (or creating unwanted) preferences for the user running the
-%% tests.
+## Testing these functions will require some care to avoid wiping out
+## existing (or creating unwanted) preferences for the user running the
+## tests.
 
diff --git a/scripts/prefs/setpref.m b/scripts/prefs/setpref.m
--- a/scripts/prefs/setpref.m
+++ b/scripts/prefs/setpref.m
@@ -58,12 +58,12 @@ function setpref (group, pref, val)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Testing these functions will require some care to avoid wiping out
-%% existing (or creating unwanted) preferences for the user running the
-%% tests.
+## Testing these functions will require some care to avoid wiping out
+## existing (or creating unwanted) preferences for the user running the
+## tests.
 
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -95,16 +95,16 @@ endfunction
 
 %!test
 %! c = sort (cellstr ({ [], [1:3], [2:4], [3:5], [1:3; 2:4], [1:3; 3:5], [2:4; 3:5], [1:3; 2:4; 3:5]}));
 %! p = sort (cellstr (powerset ([1:3;2:4;3:5], "rows")));
 %! assert (p,c);
 
 %!assert (powerset([]), {});  # always return a cell array
 
-%% Test input validation
+## Test input validation
 %!error powerset ()
 %!error powerset (1,2,3)
 %!error <expecting second argument to be "rows"> powerset (1, "cols")
 %!error <"rows" not valid for cell arrays> powerset ({1}, "rows")
 %!error <cell arrays can only be used for character> powerset ({1})
 %!error <not implemented for more than 32 elements> powerset (1:33)
 
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -110,17 +110,17 @@ endfunction
 
 %!test
 %! a = [3, 1, 4, 1, 5];
 %! b = [1, 2, 3, 4];
 %! [c, ia] = setdiff (a, b');
 %! assert (c, [5]);
 %! assert (c, a(ia));
 
-%% Test output orientation compatibility (bug #42577)
+## Test output orientation compatibility (bug #42577)
 %!assert (setdiff ([1:5], 2), [1,3,4,5])
 %!assert (setdiff ([1:5]', 2), [1;3;4;5])
 %!assert (setdiff ([1:5], [2:3]), [1,4,5])
 %!assert (setdiff ([1:5], [2:3]'), [1,4,5])
 %!assert (setdiff ([1:5]', [2:3]), [1,4,5])
 %!assert (setdiff ([1:5]', [2:3]'), [1;4;5])
 
 %!test
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -89,18 +89,17 @@ endfunction
 
 %!test
 %! a = [3, 1, 4, 1, 5];
 %! b = [1, 2, 3, 4];
 %! [y, ia, ib] = union (a, b.');
 %! assert (y, [1, 2, 3, 4, 5]);
 %! assert (y, sort ([a(ia), b(ib)]));
 
-
-%% Test common input validation for set routines contained in validsetargs
+## Test common input validation for set routines contained in validsetargs
 %!error <cell array of strings cannot be combined> union ({"a"}, 1)
 %!error <A and B must be arrays or cell arrays> union (@sin, 1)
 %!error <invalid option: columns> union (1, 2, "columns")
 %!error <cells not supported with "rows"> union ({"a"}, {"b"}, "rows")
 %!error <A and B must be arrays or cell arrays> union (@sin, 1, "rows")
 %!error <A and B must be 2-dimensional matrices> union (rand(2,2,2), 1, "rows")
 %!error <number of columns in A and B must match> union ([1 2], 1, "rows")
 
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -209,17 +209,17 @@ endfunction
 %!
 %!test
 %! A = [1,2,3;1,2,3];
 %! [a,i,j] = unique (A, "rows");
 %! assert (a, [1,2,3]);
 %! assert (A(i,:), a);
 %! assert (a(j,:), A);
 
-%% Test input validation
+## Test input validation
 %!error unique ()
 %!error <X must be an array or cell array of strings> unique ({1})
 %!error <options must be strings> unique (1, 2)
 %!error <cannot specify both "first" and "last"> unique (1, "first", "last")
 %!error <invalid option> unique (1, "middle")
 %!error <invalid option> unique ({"a", "b", "c"}, "UnknownOption")
 %!error <invalid option> unique ({"a", "b", "c"}, "UnknownOption1", "UnknownOption2")
 %!error <invalid option> unique ({"a", "b", "c"}, "rows", "UnknownOption2")
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -47,73 +47,73 @@
 ## @math{b0} for the scoring algorithm.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Fit an ARCH regression model
 
 function [a, b] = arch_fit (y, x, p, iter, gamma, a0, b0)
 
-  if ((nargin < 3) || (nargin == 6) || (nargin > 7))
+  if (nargin < 3 || nargin == 6 || nargin > 7)
     print_usage ();
   endif
 
   if (! (isvector (y)))
     error ("arch_fit: Y must be a vector");
   endif
 
-  T   = length (y);
-  y   = reshape (y, T, 1);
+  T = length (y);
+  y = reshape (y, T, 1);
   [rx, cx] = size (x);
   if ((rx == 1) && (cx == 1))
     x = autoreg_matrix (y, x);
   elseif (! (rx == T))
     error ("arch_fit: either rows (X) == length (Y), or X is a scalar");
   endif
 
   [T, k] = size (x);
 
   if (nargin == 7)
-    a   = a0;
-    b   = b0;
-    e   = y - x * b;
+    a = a0;
+    b = b0;
+    e = y - x * b;
   else
     [b, v_b, e] = ols (y, x);
-    a   = [v_b, (zeros (1, p))]';
+    a = [v_b, (zeros (1, p))]';
     if (nargin < 5)
       gamma = 0.1;
       if (nargin < 4)
         iter = 50;
       endif
     endif
   endif
 
   esq = e.^2;
-  Z   = autoreg_matrix (esq, p);
+  Z = autoreg_matrix (esq, p);
 
   for i = 1 : iter;
-    h    = Z * a;
-    tmp  = esq ./ h.^2 - 1 ./ h;
-    s    = 1 ./ h(1:T-p);
+    h   = Z * a;
+    tmp = esq ./ h.^2 - 1 ./ h;
+    s   = 1 ./ h(1:T-p);
     for j = 1 : p;
       s = s - a(j+1) * tmp(j+1:T-p+j);
     endfor
-    r    = 1 ./ h(1:T-p);
+    r = 1 ./ h(1:T-p);
     for j = 1:p;
       r = r + 2 * h(j+1:T-p+j).^2 .* esq(1:T-p);
     endfor
-    r   = sqrt (r);
+    r = sqrt (r);
     X_tilde = x(1:T-p, :) .* (r * ones (1,k));
     e_tilde = e(1:T-p) .*s ./ r;
     delta_b = inv (X_tilde' * X_tilde) * X_tilde' * e_tilde;
     b   = b + gamma * delta_b;
     e   = y - x * b;
     esq = e .^ 2;
     Z   = autoreg_matrix (esq, p);
     h   = Z * a;
     f   = esq ./ h - ones (T,1);
     Z_tilde = Z ./ (h * ones (1, p+1));
     delta_a = inv (Z_tilde' * Z_tilde) * Z_tilde' * f;
-    a   = a + gamma * delta_a;
+    a = a + gamma * delta_a;
   endfor
 
 endfunction
 
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -66,21 +66,21 @@ function y = arch_rnd (a, b, t)
   endif
 
   lb = length (b);
   b  = reshape (b, 1, lb);
   if (lb == 1)
     b  = [b, 0];
     lb = lb + 1;
   endif
-  m  = max ([la, lb]);
+  m = max ([la, lb]);
 
-  e  = zeros (t, 1);
-  h  = zeros (t, 1);
-  y  = zeros (t, 1);
+  e = zeros (t, 1);
+  h = zeros (t, 1);
+  y = zeros (t, 1);
 
   h(1) = a(1);
   e(1) = sqrt (h(1)) * randn;
   y(1) = b(1) + e(1);
 
   for t = 2:m
     ta   = min ([t, la]);
     h(t) = a(1) + a(2:ta) * e(t-ta+1:t-1).^2;
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -69,18 +69,18 @@ function [pval, lm] = arch_test (y, x, p
 
   if (nargin != 3)
     error ("arch_test: 3 input arguments required");
   endif
 
   if (! (isvector (y)))
     error ("arch_test: Y must be a vector");
   endif
-  T   = length (y);
-  y   = reshape (y, T, 1);
+  T = length (y);
+  y = reshape (y, T, 1);
   [rx, cx] = size (x);
   if ((rx == 1) && (cx == 1))
     x = autoreg_matrix (y, x);
   elseif (! (rx == T))
     error ("arch_test: either rows (X) == length (Y), or X is a scalar");
   endif
   if (! (isscalar (p) && (rem (p, 1) == 0) && (p > 0)))
     error ("arch_test: P must be a positive integer");
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -41,28 +41,28 @@
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Simulate an ARMA process
 
 function x = arma_rnd (a, b, v, t, n)
 
   if (nargin == 4)
     n = 100;
   elseif (nargin == 5)
-    if (!isscalar (n))
+    if (! isscalar (n))
       error ("arma_rnd: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if ((min (size (a)) > 1) || (min (size (b)) > 1))
     error ("arma_rnd: A and B must not be matrices");
   endif
 
-  if (!isscalar (t))
+  if (! isscalar (t))
     error ("arma_rnd: T must be a scalar");
   endif
 
   ar = length (a);
   br = length (b);
 
   a = reshape (a, ar, 1);
   b = reshape (b, br, 1);
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -41,17 +41,17 @@
 function y = detrend (x, p = 1)
   ## Check input
   if (nargin > 0 && isreal (x) && ndims (x) <= 2)
     ## Check p
     if (ischar (p) && strcmpi (p, "constant"))
       p = 0;
     elseif (ischar (p) && strcmpi (p, "linear"))
       p = 1;
-    elseif (!isscalar (p) || p < 0 || p != fix (p))
+    elseif (! isscalar (p) || p < 0 || p != fix (p))
       error ("detrend: second input argument must be 'constant', 'linear' or a positive integer");
     endif
   else
     error ("detrend: first input argument must be a real vector or matrix");
   endif
 
   [m, n] = size (x);
   if (m == 1)
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -36,33 +36,33 @@
 ## Theory and Methods}. Springer 1987.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Estimate the fractional differencing parameter
 
 function [d, dd] = diffpara (x, a, b)
 
-  if ((nargin < 1) || (nargin > 3))
+  if (nargin < 1 || nargin > 3)
     print_usage ();
+  endif
+
+  if (isvector (x))
+    n = length (x);
+    k = 1;
+    x = reshape (x, n, 1);
   else
-    if (isvector (x))
-      n = length (x);
-      k = 1;
-      x = reshape (x, n, 1);
-    else
-      [n, k] = size (x);
-    endif
-    if (nargin == 1)
-      a = 0.5 * sqrt (n);
-      b = 1.5 * sqrt (n);
-    elseif (nargin == 2)
-      b = a;
-      a = 1;
-    endif
+    [n, k] = size (x);
+  endif
+  if (nargin == 1)
+    a = 0.5 * sqrt (n);
+    b = 1.5 * sqrt (n);
+  elseif (nargin == 2)
+    b = a;
+    a = 1;
   endif
 
   if (! (isscalar (a) && isscalar (b)))
     error ("diffpara: A and B must be scalars");
   endif
 
   dd = zeros (b - a + 1, k);
 
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -29,17 +29,17 @@
 ## @var{t} of the algorithm are performed.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Perform one step of the Durbin-Levinson algorithm
 
 function [newphi, newv] = durbinlevinson (c, oldphi, oldv)
 
-  if (! ((nargin == 1) || (nargin == 3)))
+  if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (columns (c) > 1)
     c = c';
   endif
 
   newphi = 0;
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -60,17 +60,17 @@ function c = fftconv (x, y, n)
       endif
       c = fftfilt (x, y, n);
     endif
   endif
 
 endfunction
 
 
-%% FIXME: Borrow tests from conv.m.  May need a tolerance on the assert comparison
+## FIXME: Borrow tests from conv.m.  May need tolerance on the assert stmt.
 %!test
 %! x = ones (3,1);
 %! y = ones (1,3);
 %! b = 2;
 %! c = 3;
 %! assert (fftconv (x, x), [1; 2; 3; 2; 1], 5*eps);
 %! assert (fftconv (y, y), [1, 2, 3, 2, 1], 5*eps);
 %! assert (fftconv (x, y), [1, 2, 3, 2, 1], 5*eps);
@@ -93,15 +93,15 @@ endfunction
 %! assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1]);
 
 %!test
 %! a = 1:10;
 %! b = (1:3).';
 %! assert (size (conv (a,b)), [1, numel(a)+numel(b)-1]);
 %! assert (size (conv (b,a)), [1, numel(a)+numel(b)-1]);
 
-%% Test input validation
+## Test input validation
 %!error fftconv (1)
 %!error fftconv (1,2,3,4)
 %!error fftconv ([1, 2; 3, 4], 3)
 %!error fftconv (2, [])
 %!error fftconv ([1,1], [2,2] , [3, 4])
 
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -180,15 +180,15 @@ endfunction
 
 %!test
 %! b  = rand (10, 1) + i*rand (10, 1);
 %! x  = rand (10, 1) + i*rand (10, 1);
 %! y0 = filter (b, 1, x);
 %! y  = fftfilt (b, x);
 %! assert (y0, y, 55*eps);
 
-%% Test input validation
+## Test input validation
 %!error fftfilt (1)
 %!error fftfilt (1, 2, 3, 4)
 %!error fftfilt (ones (2), 1)
 %!error fftfilt (2, ones (3,3,3))
 %!error fftfilt (2, 1, ones (2))
 
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -223,11 +223,11 @@ endfunction
 %! [h,f] = freqz (b,a,16,320);
 %! assert (f,[0:15]'*10,10*eps);
 %! [h2,f2] = freqz (b,a,[0:15]*10,320);
 %! assert (f2,[0:15]*10,10*eps);
 %! assert (h,h2.',20*eps);
 %! [h3,f3] = freqz (b,a,32,"whole",320);
 %! assert (f3,[0:31]'*10,10*eps);
 
-%% Test input validation
-## FIXME: Need to put tests here and simplify the input validation in the main code.
+## Test input validation
+## FIXME: Need to put tests here and simplify input validation in the main code.
 
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -203,17 +203,17 @@ function [pxx, f] = periodogram (x, vara
   endif
 
 endfunction
 
 
 ## FIXME: Need some functional tests
 
 
-%% Test input validation
+## Test input validation
 %!error periodogram ()
 %!error periodogram (1,2,3,4,5,6)
 %!error <X must be a real or complex vector> periodogram (ones (2,2))
 %!error <WIN must be a vector.*same length> periodogram (1:5, ones (2,2))
 %!error <WIN must be a vector.*same length> periodogram (1:5, 1:6)
 %!error <NFFT must be a scalar> periodogram (1:5, 1:5, 1:5)
 %!error <FS must be a scalar> periodogram (1:5, [], [], 1:5)
 %!error <"centered" range type is not implemented> periodogram (1:5, "centered")
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -23,28 +23,19 @@
 ## The arguments @var{freq} and @var{ampl} may be vectors of common size.
 ##
 ## Defaults are @var{rate} = 8000, @var{sec} = 1 and @var{ampl} = 64.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute a sine tone
 
-function retval = sinetone (freq, rate, sec, ampl)
+function retval = sinetone (freq, rate = 8000, sec = 1, ampl = 64)
 
-  if (nargin == 1)
-    rate = 8000;
-    sec = 1;
-    ampl = 64;
-  elseif (nargin == 2)
-    sec = 1;
-    ampl = 64;
-  elseif (nargin == 3)
-    ampl = 64;
-  elseif ((nargin < 1) || (nargin > 4))
+  if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   [err, freq, ampl] = common_size (freq, ampl);
   if (err || ! isvector (freq))
     error ("sinetone: FREQ and AMPL must be vectors of common size");
   endif
 
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -64,14 +64,14 @@ function retval = spectral_adf (c, win, 
 
   retval = 2 * real (fft (c)) - c(1);
   retval = [(zeros (cr, 1)), retval];
   retval(:, 1) = (0 : cr-1)' / cr;
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error spectral_adf ();
 %!error spectral_adf (1, 2, 3, 4);
 %!error spectral_adf (1, 2);
 %!error spectral_adf (1, "invalid");
 
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -65,14 +65,14 @@ function retval = spectral_xdf (x, win, 
   retval = real (ifft (fft (retval) .* fft (w)));
 
   retval = [(zeros (xr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error spectral_xdf ();
 %!error spectral_xdf (1, 2, 3, 4);
 %!error spectral_xdf (1, 2);
 %!error spectral_xdf (1, "invalid");
 
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -31,17 +31,17 @@
 ## Author: Bill Lash <lash@tellabs.com>
 
 function retval = unwrap (x, tol, dim)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (!isnumeric (x))
+  if (! isnumeric (x))
     error ("unwrap: X must be a numeric matrix or vector");
   endif
 
   if (nargin < 2 || isempty (tol))
     tol = pi;
   endif
 
   ## Don't let anyone use a negative value for TOL.
@@ -73,17 +73,17 @@ function retval = unwrap (x, tol, dim)
   ## as large values, and the sign will show direction.
   idx = repmat ({':'}, nd, 1);
   idx{dim} = [1,1:m-1];
   d = x(idx{:}) - x;
 
   ## Find only the peaks, and multiply them by the appropriate amount
   ## of ranges so that there are kronecker deltas at each wrap point
   ## multiplied by the appropriate amount of range values.
-  p =  ceil (abs (d)./rng) .* rng .* (((d > tol) > 0) - ((d < -tol) > 0));
+  p = ceil (abs (d)./rng) .* rng .* (((d > tol) > 0) - ((d < -tol) > 0));
 
   ## Now need to "integrate" this so that the deltas become steps.
   r = cumsum (p, dim);
 
   ## Now add the "steps" to the original data and put output in the
   ## same shape as originally.
   retval = x + r;
 
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -58,17 +58,18 @@
 ## @end itemize
 ##
 ## (the value 2 is unused but skipped for compatibility).
 ##
 ## @item @var{relres} is the final value of the relative residual.
 ##
 ## @item @var{iter} is the number of iterations performed.
 ##
-## @item @var{resvec} is a vector containing the relative residual at each iteration.
+## @item @var{resvec} is a vector containing the relative residual at each
+## iteration.
 ## @end itemize
 ##
 ## @seealso{bicgstab, cgs, gmres, pcg}
 ##
 ## @end deftypefn
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 ## Author: Carlo de Falco
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -58,17 +58,18 @@
 ## @end itemize
 ##
 ## (the value 2 is unused but skipped for compatibility).
 ##
 ## @item @var{relres} is the final value of the relative residual.
 ##
 ## @item @var{iter} is the number of iterations performed.
 ##
-## @item @var{resvec} is a vector containing the relative residual at each iteration.
+## @item @var{resvec} is a vector containing the relative residual at each
+## iteration.
 ## @end itemize
 ##
 ## @seealso{bicg, cgs, gmres, pcg}
 ##
 ## @end deftypefn
 
 function [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, maxit,
                                                      M1, M2, x0)
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -154,17 +154,17 @@ function [x, flag, relres, iter, resvec]
       res = res - alpha * q;
       relres = norm (res) / norm_b;
       resvec = [resvec; relres];
 
       if (relres <= tol)
         ## We reach tolerance tol within maxit iterations.
         flag = 0;
         break
-      elseif (resvec (end) == resvec (end - 1))
+      elseif (resvec(end) == resvec(end - 1))
         ## The method stagnates.
         flag = 3;
         break
       endif
     endfor
 
     if (nargout < 1)
       if (flag == 0)
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -485,17 +485,17 @@ endfunction
 %! for i=1:k
 %!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 
 ## Real unsymmetric tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
-%! A =  sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
+%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
 %! d0 = eig (A);
 %! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
 %! rand ("state", 42); % initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
@@ -854,17 +854,17 @@ endfunction
 %! for i=1:k
 %!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
 %! endfor
 
 ## Real unsymmetric tests
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
-%! A =  full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
+%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
 %! d0 = eig (A);
 %! [~, idx] = sort (abs (d0));
 %! d0 = d0(idx);
 %! rand ("state", 42); % initialize generator to make eigs behavior reproducible
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -160,17 +160,17 @@ function [x, flag, relres, it, resvec] =
       V(:, 1) = prec_res / presn;
     endif
 
     ## basic iteration
     tmp = Pm1x (Ax (V(:, restart_it)));
     [V(:,restart_it+1), H(1:restart_it+1, restart_it)] = ...
         mgorth (tmp, V(:,1:restart_it));
 
-    Y = (H(1:restart_it+1, 1:restart_it) \ B (1:restart_it+1));
+    Y = (H(1:restart_it+1, 1:restart_it) \ B(1:restart_it+1));
 
     little_res = B(1:restart_it+1) - ...
         H(1:restart_it+1, 1:restart_it) * Y(1:restart_it);
 
     presn = norm (little_res, 2);
 
     x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
 
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -74,11 +74,11 @@ endfunction
 %!       3  , 0
 %!       4  , 0];
 %!
 %! clf;
 %! gplot (A, xy, "o-");
 %! set (get (gca, ("children")), "markersize", 12);
 %! title ("gplot() of Binary Tree Adjacency matrix");
 
-%% Mark graphical function as tested by demo block
+## Mark graphical function as tested by demo block
 %!assert (1)
 
diff --git a/scripts/sparse/ichol.m b/scripts/sparse/ichol.m
--- a/scripts/sparse/ichol.m
+++ b/scripts/sparse/ichol.m
@@ -353,30 +353,30 @@ endfunction
 ## Negative pivot
 %!error <negative pivot> ichol (A6)
 %!error ichol (A6)
 ## Complex entry in the diagonal
 %!error <non-real pivot> ichol (A7)
 
 ## ICHOLT tests
 
-%%!test
+#%!test
 %! opts.type = "ict";
 %! opts.droptol = 1e-1;
 %! opts.michol = "off";
 %! L = ichol (A1, opts);
 %! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.2065, 1e-4);
 %! opts.shape = "upper";
 %! U = ichol (A1, opts);
 %! assert (norm (A1 - U' * U, "fro") / norm (A1, "fro"), 0.2065, 1e-4);
 %! opts.shape = "lower";
 %! L = ichol (A1, opts);
 %! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.2065, 1e-4);
 %!
-%%!test
+#%!test
 %! opts.type = "ict";
 %! opts.droptol = 1e-1;
 %! opts.michol = "on";
 %! L = ichol (A1, opts);
 %! assert (norm (A1 - L * L', "fro") / norm (A1, "fro"), 0.3266, 1e-4);
 %! opts.shape = "upper";
 %! U = ichol (A1, opts);
 %! assert (norm (A1 - U' * U, "fro") / norm (A1, "fro"), 0.3266, 1e-4);
@@ -420,18 +420,17 @@ endfunction
 %! opts.droptol = 1e-1;
 %! opts.michol = "off";
 %! L = ichol (A5, opts);
 %! assert (norm (A5 - L*L', "fro") / norm (A5, "fro"), 0.2044, 1e-4);
 %! opts.michol = "on";
 %! L = ichol (A5, opts);
 %! assert (norm (A5 - L*L', "fro") / norm (A5, "fro"), 0.3231, 1e-4);
 
-%% Input validation tests
-
+## Test input validation
 %!error <A must be a sparse square matrix> ichol ([])
 %!error <A must be a sparse square matrix> ichol (0)
 %!error <pivot equal to 0> ichol (sparse (0))
 %!error <pivot equal to 0> ichol (sparse (-0))
 %!error <negative pivot> ichol (sparse (-1))
 %!test
 %! opts.type = "foo";
 %! fail ("ichol (A1, opts)", 'TYPE must be "nofill"');
diff --git a/scripts/sparse/ilu.m b/scripts/sparse/ilu.m
--- a/scripts/sparse/ilu.m
+++ b/scripts/sparse/ilu.m
@@ -473,17 +473,17 @@ endfunction
 %!
 %!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! opts.milu = "row";
 %! #fail ("ilu (a2, opts)");
 
-%% Tests for input validation
+## Tests for input validation
 %!shared A_tiny
 %! A_tiny = spconvert ([1 4 2 3 3 4 2 5; 1 1 2 3 4 4 5 5; 1 2 3 4 5 6 7 8]');
 
 %!test
 %! [L, U] = ilu (sparse ([]));
 %! assert (isempty (L));
 %! assert (isempty (U));
 %! opts.type = "crout";
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -521,18 +521,18 @@ endfunction
 
 %!test
 %! ## solve tridiagonal system with 'perfect' preconditioner
 %! ## which converges in one iteration, so the eigest does not
 %! ## work and issues a warning
 %!
 %! N = 100;
 %! A = zeros (N, N);
-%! for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!         A (i:i+1, i:i+1) = [2 -1; -1 2];
+%! for i = 1 : N - 1  # form 1-D Laplacian matrix
+%!   A(i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
 %! assert (norm (x - X) / norm (X), 0, 1e-6);
 %! assert (flag, 0);
 %! assert (iter, 1); # should converge in one iteration
 %! assert (isnan (eigest), isnan ([NaN, NaN]));
diff --git a/scripts/sparse/qmr.m b/scripts/sparse/qmr.m
--- a/scripts/sparse/qmr.m
+++ b/scripts/sparse/qmr.m
@@ -181,42 +181,42 @@ function [x, flag, relres, iter, resvec]
     flag = 1;
     for iter=1:1:maxit
       ## If rho0 == 0 or xi1 == 0, method fails.
       v = vt / rho0;
       y = y / rho0;
       w = wt / xi1;
       z = z / xi1;
 
-      delta1 = z' * y; ## If delta1 == 0, method fails.
+      delta1 = z' * y;   # If delta1 == 0, method fails.
 
       yt = M2m1x (y);
       zt = M1tm1x (z);
 
       if (iter == 1)
         p = yt;
         q = zt;
       else
         p = yt - (xi1*delta1/eps0) * p;
         q = zt - (rho0*delta1/eps0) * q;
       endif
       pt = Ax (p);
 
-      eps0 = q' * pt; ## If eps0 == 0, method fails.
-      beta1 = eps0 / delta1; ## If beta1 == 0, method fails.
+      eps0 = q' * pt;          # If eps0 == 0, method fails.
+      beta1 = eps0 / delta1;   # If beta1 == 0, method fails.
       vt = pt - beta1 * v;
 
       y = M1m1x (vt);
       rho1 = norm(y);
       wt = Atx (q) - beta1 * w;
       z = M2tm1x (wt);
 
       xi1 = norm(z);
       theta1 = rho1 / (gamma0 * abs(beta1));
-      gamma1 = 1 / sqrt(1 + theta1^2); ## If gamma1 == 0, method fails.
+      gamma1 = 1 / sqrt(1 + theta1^2);   # If gamma1 == 0, method fails.
       eta1 = -eta0 * rho0 * gamma1^2 / (beta1 * gamma0^2);
 
       if (iter == 1)
         d = eta1 * p;
         s = eta1 * pt;
       else
         d = eta1 * p + (theta0*gamma1)^2 * d;
         s = eta1 * pt + (theta0 * gamma1)^2 * s;
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -80,17 +80,17 @@ function s = spaugment (A, c)
       c = max (max (abs (A))) / 1000;
     else
       if (ndims (A) != 2)
         error ("spaugment: expecting 2-dimenisional matrix");
       else
         c = max (abs (A(:))) / 1000;
       endif
     endif
-  elseif (!isscalar (c))
+  elseif (! isscalar (c))
     error ("spaugment: C must be a scalar");
   endif
 
   [m, n] = size (A);
   s = [ c * speye(m, m), A; A', sparse(n, n)];
 endfunction
 
 
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -55,16 +55,16 @@ endfunction
 %! assert (issparse (s));
 %! [fi, fj, fv] = find (s);
 %! assert (isequal (i, fi) && isequal (j, fj) && isequal (v, fv));
 %! s = spconvert ([i, j, v, j]);
 %! [fi, fj, fv] = find (s);
 %! assert (isequal (i, fi) && isequal (j, fj) && isequal (complex (v, j), fv));
 %! assert (size (spconvert ([1, 1, 3; 5, 15, 0])), [5, 15]);
 
-%% Test input validation
+## Test input validation
 %!error spconvert ()
 %!error spconvert (1, 2)
 %!error spconvert ({[1 2 3]})
 %!error spconvert ([1 2])
 %!error spconvert ([1 2 3i])
 %!error spconvert ([1 2 3 4 5])
 
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -164,12 +164,12 @@ endfunction
 %! assert (d, [-2 2]');
 %! assert (B, [0 13; 0 0; 31 0]);
 %! assert (spdiags (B, d, 3,4), A)
 
 %!assert (spdiags (zeros (1,0),1,1,1), sparse (0))
 %!assert (spdiags (zeros (0,1),1,1,1), sparse (0))
 %!assert (spdiags ([0.5 -1 0.5], 0:2, 1, 1), sparse (0.5))
 
-%% Test input validation
+## Test input validation
 %!error spdiags ()
 %!error spdiags (1,2,3,4,5)
 
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -60,55 +60,55 @@ function s = sprand (m, n, d, rc)
     s = __sprand_impl__ (m, n, d, rc, "sprand", @rand);
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Test 3-input calling form
+## Test 3-input calling form
 %!test
 %! s = sprand (4, 10, 0.1);
 %! assert (size (s), [4, 10]);
 %! assert (nnz (s) / numel (s), 0.1);
 
-%% Test 4-input calling form
+## Test 4-input calling form
 %!test
 %! d = rand ();
 %! s1 = sprand (100, 100, d, 0.4);
 %! rc = [5, 4, 3, 2, 1, 0.1];
 %! s2 = sprand (100, 100, d, rc);
 %! s3 = sprand (6, 4, d, rc);
 %! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps));
 %! assert (1/cond (s1), 0.4, sqrt (eps));
 %! assert (nnz (s1) / (100*100), d, 0.02);
 %! assert (nnz (s2) / (100*100), d, 0.02);
 %! assert (svd (s3)', [5 4 3 2], sqrt (eps));
 
-%% Test 1-input calling form
+## Test 1-input calling form
 %!test
 %! s = sprand (sparse ([1 2 3], [3 2 3], [2 2 2]));
 %! [i, j, v] = find (s);
 %! assert (sort (i), [1 2 3]');
 %! assert (sort (j), [2 3 3]');
 %! assert (all (v > 0 & v < 1));
 
-%% Test input validation
+## Test very large, very low density matrix doesn't fail
+%!test
+%! s = sprand (1e6, 1e6, 1e-7);
+
+## Test input validation
 %!error sprand ()
 %!error sprand (1, 2)
 %!error sprand (1, 2, 3, 4)
 %!error <M must be an integer greater than 0> sprand (ones (3), 3, 0.5)
 %!error <M must be an integer greater than 0> sprand (3.5, 3, 0.5)
 %!error <M must be an integer greater than 0> sprand (0, 3, 0.5)
 %!error <N must be an integer greater than 0> sprand (3, ones (3), 0.5)
 %!error <N must be an integer greater than 0> sprand (3, 3.5, 0.5)
 %!error <N must be an integer greater than 0> sprand (3, 0, 0.5)
 %!error <D must be between 0 and 1> sprand (3, 3, -1)
 %!error <D must be between 0 and 1> sprand (3, 3, 2)
 %!error <RC must be a scalar or vector> sprand (2, 2, 0.2, ones (3,3))
 %!error <RC must be between 0 and 1> sprand (2, 2, 0.2, -1)
 %!error <RC must be between 0 and 1> sprand (2, 2, 0.2, 2)
 
-%% Test very large, very low density matrix doesn't fail
-%!test
-%! s = sprand (1e6, 1e6, 1e-7);
-
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -52,54 +52,54 @@ function s = sprandn (m, n, d, rc)
     s = __sprand_impl__ (m, n, d, rc, "sprandn", @randn);
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%% Test 3-input calling form
+## Test 3-input calling form
 %!test
 %! s = sprandn (4, 10, 0.1);
 %! assert (size (s), [4, 10]);
 %! assert (nnz (s) / numel (s), 0.1);
 
-%% Test 4-input calling form
+## Test 4-input calling form
 %!test
 %! d = rand ();
 %! s1 = sprandn (100, 100, d, 0.4);
 %! rc = [5, 4, 3, 2, 1, 0.1];
 %! s2 = sprandn (100, 100, d, rc);
 %! s3 = sprandn (6, 4, d, rc);
 %! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps));
 %! assert (1/cond (s1), 0.4, sqrt (eps));
 %! assert (nnz (s1) / (100*100), d, 0.02);
 %! assert (nnz (s2) / (100*100), d, 0.02);
 %! assert (svd (s3)', [5 4 3 2], sqrt (eps));
 
-%% Test 1-input calling form
+## Test 1-input calling form
 %!test
 %! s = sprandn (sparse ([1 2 3], [3 2 3], [2 2 2]));
 %! [i, j] = find (s);
 %! assert (sort (i), [1 2 3]');
 %! assert (sort (j), [2 3 3]');
 
-%% Test input validation
+## Test very large, very low density matrix doesn't fail
+%!test
+%! s = sprandn (1e6,1e6,1e-7);
+
+## Test input validation
 %!error sprandn ()
 %!error sprandn (1, 2)
 %!error sprandn (1, 2, 3, 4)
 %!error <M must be an integer greater than 0> sprandn (ones (3), 3, 0.5)
 %!error <M must be an integer greater than 0> sprandn (3.5, 3, 0.5)
 %!error <M must be an integer greater than 0> sprandn (0, 3, 0.5)
 %!error <N must be an integer greater than 0> sprandn (3, ones (3), 0.5)
 %!error <N must be an integer greater than 0> sprandn (3, 3.5, 0.5)
 %!error <N must be an integer greater than 0> sprandn (3, 0, 0.5)
 %!error <D must be between 0 and 1> sprandn (3, 3, -1)
 %!error <D must be between 0 and 1> sprandn (3, 3, 2)
 %!error <RC must be a scalar or vector> sprandn (2, 2, 0.2, ones (3,3))
 %!error <RC must be between 0 and 1> sprandn (2, 2, 0.2, -1)
 %!error <RC must be between 0 and 1> sprandn (2, 2, 0.2, 2)
 
-%% Test very large, very low density matrix doesn't fail
-%!test
-%! s = sprandn (1e6,1e6,1e-7);
-
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -154,24 +154,24 @@ endfunction
 
 %!test
 %! s = sprandsym (10, 0.1);
 %! assert (issparse (s));
 %! assert (issymmetric (s));
 %! assert (size (s), [10, 10]);
 %! assert (nnz (s) / numel (s), 0.1, .01);
 
-%% Test 1-input calling form
+## Test 1-input calling form
 %!test
 %! s = sprandsym (sparse ([1 2 3], [3 2 3], [2 2 2]));
 %! [i, j] = find (s);
 %! assert (sort (i), [2 3]');
 %! assert (sort (j), [2 3]');
 
-%% Test input validation
+## Test input validation
 %!error sprandsym ()
 %!error sprandsym (1, 2, 3)
 %!error sprandsym (ones (3), 0.5)
 %!error sprandsym (3.5, 0.5)
 %!error sprandsym (0, 0.5)
 %!error sprandsym (3, -1)
 %!error sprandsym (3, 2)
 
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -67,11 +67,11 @@ function spy (x, varargin)
 
 endfunction
 
 
 %!demo
 %! clf;
 %! spy (sprand (10,10, 0.2));
 
-%% Mark graphical function as tested by demo block
+## Mark graphical function as tested by demo block
 %!assert (1)
 
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -102,26 +102,26 @@ function [u, s, v, flag] = svds (A, k, s
     error ("svds: A must be a 2-D matrix");
   endif
 
   if (nargin < 4)
     opts.tol = 0;    # use ARPACK default
     opts.disp = 0;
     opts.maxit = 300;
   else
-    if (!isstruct (opts))
+    if (! isstruct (opts))
       error ("svds: OPTS must be a structure");
     endif
-    if (!isfield (opts, "tol"))
+    if (! isfield (opts, "tol"))
       opts.tol = 0;  # use ARPACK default
     else
       opts.tol = opts.tol / root2;
     endif
     if (isfield (opts, "v0"))
-      if (!isvector (opts.v0) || (length (opts.v0) != sum (size (A))))
+      if (! isvector (opts.v0) || (length (opts.v0) != sum (size (A))))
         error ("svds: OPTS.v0 must be a vector with rows(A)+columns(A) entries");
       endif
     endif
   endif
 
   if (nargin < 3 || strcmp (sigma, "L"))
     if (isreal (A))
       sigma = "LA";
@@ -155,17 +155,17 @@ function [u, s, v, flag] = svds (A, k, s
     endif
 
     ## Scale everything by the 1-norm to make things more stable.
     b = A / max_a;
     b_opts = opts;
     ## Call to eigs is always a symmetric matrix by construction
     b_opts.issym = true;
     b_sigma = sigma;
-    if (!ischar (b_sigma))
+    if (! ischar (b_sigma))
       b_sigma = b_sigma / max_a;
     endif
 
     if (b_sigma == 0)
       ## Find the smallest eigenvalues
       ## The eigenvalues returns by eigs for sigma=0 are symmetric about 0.
       ## As we are only interested in the positive eigenvalues, we have to
       ## double k and then throw out the k negative eigenvalues.
@@ -214,17 +214,17 @@ function [u, s, v, flag] = svds (A, k, s
       else
         ind = ind(1:k);         # largest eigenvalues
       endif
     endif
     s = s(ind);
 
     if (length (s) < k)
       warning ("returning fewer singular values than requested");
-      if (!ischar (sigma))
+      if (! ischar (sigma))
         warning ("try increasing the value of sigma");
       endif
     endif
 
     s = s * max_a;
   endif
 
   if (nargout < 2)
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -27,17 +27,17 @@
 ## terms of time and memory requirements.
 ## @seealso{etreeplot, gplot, treeplot}
 ## @end deftypefn
 
 function [x_coordinate, y_coordinate, height, s] = treelayout (tree, permutation)
   if (nargin < 1 || nargin > 2 || nargout > 4)
     print_usage ();
   elseif (! isvector (tree) || rows (tree) != 1 || ! isnumeric (tree)
-          ||  any (tree > length (tree)) || any (tree < 0))
+          || any (tree > length (tree)) || any (tree < 0))
     error ("treelayout: the first input argument must be a vector of predecessors");
   else
     ## Make it a row vector.
     tree = tree(:)';
 
     ## The count of nodes of the graph.
     num_nodes = length (tree);
     ## The number of children.
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -59,17 +59,17 @@ function retval = betaln (a, b)
 
   retval = gammaln (a) + gammaln (b) - gammaln (a + b);
 
 endfunction
 
 
 %!assert (betaln (3,4), log (beta (3,4)), eps)
 
-%% Test input validation
+## Test input validation
 %!error betaln ()
 %!error betaln (1)
 %!error betaln (1,2,3)
 %!error <A and B must be real> betaln (1i, 2)
 %!error <A and B must be real> betaln (2, 1i)
 %!error <A and B must have consistent sizes> betaln ([1 2], [1 2 3])
 %!error <A and B must have consistent sizes> betaln ([1 2 3], [1 2])
 %!error <A and B must have consistent sizes> betaln ([1 2 3], [1 2 3]')
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -102,15 +102,15 @@ endfunction
 %!   pf = factor (i);
 %!   assert (prod (pf), i);
 %!   assert (all (isprime (pf)));
 %!   [pf, n] = factor (i);
 %!   assert (prod (pf.^n), i);
 %!   assert (all ([0,pf] != [pf,0]));
 %! endfor
 
-%% Test input validation
+## Test input validation
 %!error factor ()
 %!error factor (1,2)
 %!error <Q must be a real integer> factor (6i)
 %!error <Q must be a real integer> factor ([1,2])
 %!error <Q must be a real integer> factor (1.5)
 
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -159,14 +159,14 @@ endfunction
 %!assert (isprime ([1+2i, (2+3i)*(-1+2i)]), [true, false])
 %!assert (isprime (-2), true)
 %!assert (isprime (complex (-2)), false)
 %!assert (isprime (2i), false)
 %!assert (isprime ([i, 2, 3, 5]), [false, false, true, false])
 %!assert (isprime (0), false)
 %!assert (isprime (magic (3)), logical ([0, 0, 0; 1, 1, 1; 0, 0, 1]))
 
-%% Test input validation
+## Test input validation
 %!error isprime ()
 %!error isprime (1, 2)
 %!error <X contains non-integer entries> isprime (0.5i)
 %!error <X contains non-integer entries> isprime (0.5)
 
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -300,17 +300,17 @@ endfunction
 %! assert (result, expected);
 
 %!test
 %! result = legendre (3, [-1,0,1;1,0,-1]');
 %! expected(:,:,1) = [-1,0,1;0,1.5,0;0,0,0;0,-15,0];
 %! expected(:,:,2) = [1,0,-1;0,1.5,0;0,0,0;0,-15,0];
 %! assert (result, expected);
 
-%% Check correct invocation
+## Test input validation
 %!error legendre ()
 %!error legendre (1)
 %!error legendre (1,2,3,4)
 %!error <must be a real non-negative integer> legendre (i, [-1, 0, 1])
 %!error <must be a real non-negative integer> legendre ([1, 2], [-1, 0, 1])
 %!error <must be a real non-negative integer> legendre (-1, [-1, 0, 1])
 %!error <must be a real non-negative integer> legendre (1.1, [-1, 0, 1])
 %!error <must be real-valued vector> legendre (1, [-1+i, 0, 1])
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -141,17 +141,17 @@ function C = nchoosek (v, k)
 
 endfunction
 
 
 %!assert (nchoosek (80,10), bincoeff (80,10))
 %!assert (nchoosek (1:5,3), [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
 %!assert (size (nchoosek (1:5,0)), [1 0])
 
-%% Test input validation
+## Test input validation
 %!error nchoosek ()
 %!error nchoosek (1)
 %!error nchoosek (1,2,3)
 
 %!error nchoosek (100, 2i)
 %!error nchoosek (100, [2 3])
 %!error nchoosek ("100", 45)
 %!error nchoosek (100*ones (2, 2), 45)
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -94,17 +94,17 @@ endfunction
 %!assert (nthroot (-Inf, -7), 0)
 
 ## Bug #43492.  This should not generate a division by zero warning
 %!test
 %! warnmsg = lastwarn ();
 %! assert (nthroot (0, 2), 0);
 %! assert (lastwarn (), warnmsg);
 
-%% Test input validation
+## Test input validation
 %!error nthroot ()
 %!error nthroot (1)
 %!error nthroot (1,2,3)
 %!error <X must not contain complex values> nthroot (1+j, 2)
 %!error <N must be a real nonzero scalar> nthroot (1, i)
 %!error <N must be a real nonzero scalar> nthroot (1, [1 2])
 %!error <N must be a real nonzero scalar> nthroot (1, 0)
 %!error <N must be an odd integer> nthroot (-1, 2)
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -500,36 +500,36 @@ function [varargout] = gallery (name, va
     otherwise
       error ("gallery: unknown matrix with NAME %s", name);
   endswitch
 
 endfunction
 
 function C = cauchy (x, y)
   ##CAUCHY  Cauchy matrix.
-  ##        C = CAUCHY(X, Y), where X, Y are N-vectors, is the N-by-N matrix
-  ##        with C(i,j) = 1/(X(i)+Y(j)).   By default, Y = X.
-  ##        Special case: if X is a scalar CAUCHY(X) is the same as CAUCHY(1:X).
-  ##        Explicit formulas are known for DET(C) (which is nonzero if X and Y
-  ##        both have distinct elements) and the elements of INV(C).
-  ##        C is totally positive if 0 < X(1) < ... < X(N) and
-  ##        0 < Y(1) < ... < Y(N).
+  ##  C = CAUCHY(X, Y), where X, Y are N-vectors, is the N-by-N matrix
+  ##  with C(i,j) = 1/(X(i)+Y(j)).   By default, Y = X.
+  ##  Special case: if X is a scalar CAUCHY(X) is the same as CAUCHY(1:X).
+  ##  Explicit formulas are known for DET(C) (which is nonzero if X and Y
+  ##  both have distinct elements) and the elements of INV(C).
+  ##  C is totally positive if 0 < X(1) < ... < X(N) and
+  ##  0 < Y(1) < ... < Y(N).
   ##
-  ##        References:
-  ##        N.J. Higham, Accuracy and Stability of Numerical Algorithms,
-  ##          Society for Industrial and Applied Mathematics, Philadelphia, PA,
-  ##          USA, 1996; sec. 26.1.
-  ##        D.E. Knuth, The Art of Computer Programming, Volume 1,
-  ##          Fundamental Algorithms, second edition, Addison-Wesley, Reading,
-  ##          Massachusetts, 1973, p. 36.
-  ##        E.E. Tyrtyshnikov, Cauchy-Toeplitz matrices and some applications,
-  ##          Linear Algebra and Appl., 149 (1991), pp. 1-18.
-  ##          O. Taussky and M. Marcus, Eigenvalues of finite matrices, in
-  ##          Survey of Numerical Analysis, J. Todd, ed., McGraw-Hill, New York,
-  ##          pp. 279-313, 1962. (States the totally positive property on p. 295.)
+  ##  References:
+  ##  N.J. Higham, Accuracy and Stability of Numerical Algorithms,
+  ##    Society for Industrial and Applied Mathematics, Philadelphia, PA,
+  ##    USA, 1996; sec. 26.1.
+  ##  D.E. Knuth, The Art of Computer Programming, Volume 1,
+  ##    Fundamental Algorithms, second edition, Addison-Wesley, Reading,
+  ##    Massachusetts, 1973, p. 36.
+  ##  E.E. Tyrtyshnikov, Cauchy-Toeplitz matrices and some applications,
+  ##    Linear Algebra and Appl., 149 (1991), pp. 1-18.
+  ##    O. Taussky and M. Marcus, Eigenvalues of finite matrices, in
+  ##    Survey of Numerical Analysis, J. Todd, ed., McGraw-Hill, New York,
+  ##    pp. 279-313, 1962. (States the totally positive property on p. 295.)
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for cauchy matrix.");
   elseif (! isnumeric (x))
     error ("gallery: X must be numeric for cauchy matrix.");
   elseif (nargin == 2 && ! isnumeric (y))
     error ("gallery: Y must be numeric for cauchy matrix.");
   endif
@@ -556,33 +556,33 @@ function C = cauchy (x, y)
   endif
 
   C = x * ones (1, n) + ones (n, 1) * y.';
   C = ones (n) ./ C;
 endfunction
 
 function C = chebspec (n, k = 0)
   ## CHEBSPEC  Chebyshev spectral differentiation matrix.
-  ##           C = CHEBSPEC(N, K) is a Chebyshev spectral differentiation
-  ##           matrix of order N.  K = 0 (the default) or 1.
-  ##           For K = 0 (`no boundary conditions'), C is nilpotent, with
-  ##               C^N = 0 and it has the null vector ONES(N,1).
-  ##               C is similar to a Jordan block of size N with eigenvalue zero.
-  ##           For K = 1, C is nonsingular and well-conditioned, and its eigenvalues
-  ##               have negative real parts.
-  ##           For both K, the computed eigenvector matrix X from EIG is
-  ##               ill-conditioned (MESH(REAL(X)) is interesting).
+  ##   C = CHEBSPEC(N, K) is a Chebyshev spectral differentiation
+  ##   matrix of order N.  K = 0 (the default) or 1.
+  ##   For K = 0 (`no boundary conditions'), C is nilpotent, with
+  ##       C^N = 0 and it has the null vector ONES(N,1).
+  ##       C is similar to a Jordan block of size N with eigenvalue zero.
+  ##   For K = 1, C is nonsingular and well-conditioned, and its eigenvalues
+  ##       have negative real parts.
+  ##   For both K, the computed eigenvector matrix X from EIG is
+  ##       ill-conditioned (MESH(REAL(X)) is interesting).
   ##
-  ##           References:
-  ##           C. Canuto, M.Y. Hussaini, A. Quarteroni and T.A. Zang, Spectral
-  ##              Methods in Fluid Dynamics, Springer-Verlag, Berlin, 1988; p. 69.
-  ##           L.N. Trefethen and M.R. Trummer, An instability phenomenon in
-  ##              spectral methods, SIAM J. Numer. Anal., 24 (1987), pp. 1008-1023.
-  ##           D. Funaro, Computing the inverse of the Chebyshev collocation
-  ##              derivative, SIAM J. Sci. Stat. Comput., 9 (1988), pp. 1050-1057.
+  ##   References:
+  ##   C. Canuto, M.Y. Hussaini, A. Quarteroni and T.A. Zang, Spectral
+  ##      Methods in Fluid Dynamics, Springer-Verlag, Berlin, 1988; p. 69.
+  ##   L.N. Trefethen and M.R. Trummer, An instability phenomenon in
+  ##      spectral methods, SIAM J. Numer. Anal., 24 (1987), pp. 1008-1023.
+  ##   D. Funaro, Computing the inverse of the Chebyshev collocation
+  ##      derivative, SIAM J. Sci. Stat. Comput., 9 (1988), pp. 1050-1057.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for chebspec matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for chebspec matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a scalar for chebspec matrix.");
   endif
@@ -623,28 +623,28 @@ function C = chebspec (n, k = 0)
 
   if (k == 1)
     C = C(2:n+1,2:n+1);
   endif
 endfunction
 
 function C = chebvand (m, p)
   ## CHEBVAND Vandermonde-like matrix for the Chebyshev polynomials.
-  ##          C = CHEBVAND(P), where P is a vector, produces the (primal)
-  ##          Chebyshev Vandermonde matrix based on the points P,
-  ##          i.e., C(i,j) = T_{i-1}(P(j)), where T_{i-1} is the Chebyshev
-  ##          polynomial of degree i-1.
-  ##          CHEBVAND(M,P) is a rectangular version of CHEBVAND(P) with M rows.
-  ##          Special case: If P is a scalar then P equally spaced points on
-  ##                        [0,1] are used.
+  ##   C = CHEBVAND(P), where P is a vector, produces the (primal)
+  ##   Chebyshev Vandermonde matrix based on the points P,
+  ##   i.e., C(i,j) = T_{i-1}(P(j)), where T_{i-1} is the Chebyshev
+  ##   polynomial of degree i-1.
+  ##   CHEBVAND(M,P) is a rectangular version of CHEBVAND(P) with M rows.
+  ##   Special case: If P is a scalar then P equally spaced points on
+  ##                 [0,1] are used.
   ##
-  ##          Reference:
-  ##          N.J. Higham, Stability analysis of algorithms for solving confluent
-  ##            Vandermonde-like systems, SIAM J. Matrix Anal. Appl., 11 (1990),
-  ##            pp. 23-41.
+  ##   Reference:
+  ##   N.J. Higham, Stability analysis of algorithms for solving confluent
+  ##     Vandermonde-like systems, SIAM J. Matrix Anal. Appl., 11 (1990),
+  ##     pp. 23-41.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for chebvand matrix.");
   endif
 
   ## because the order of the arguments changes if nargin is 1 or 2 ...
 
   if (nargin == 1)
@@ -675,55 +675,55 @@ function C = chebvand (m, p)
     for i = 3:m
       C(i,:) = 2.*p.*C(i-1,:) - C(i-2,:);
     endfor
   endif
 endfunction
 
 function A = chow (n, alpha = 1, delta = 0)
   ## CHOW    Chow matrix - a singular Toeplitz lower Hessenberg matrix.
-  ##         A = CHOW(N, ALPHA, DELTA) is a Toeplitz lower Hessenberg matrix
-  ##         A = H(ALPHA) + DELTA*EYE, where H(i,j) = ALPHA^(i-j+1).
-  ##         H(ALPHA) has p = FLOOR(N/2) zero eigenvalues, the rest being
-  ##         4*ALPHA*COS( k*PI/(N+2) )^2, k=1:N-p.
-  ##         Defaults: ALPHA = 1, DELTA = 0.
+  ##   A = CHOW(N, ALPHA, DELTA) is a Toeplitz lower Hessenberg matrix
+  ##   A = H(ALPHA) + DELTA*EYE, where H(i,j) = ALPHA^(i-j+1).
+  ##   H(ALPHA) has p = FLOOR(N/2) zero eigenvalues, the rest being
+  ##   4*ALPHA*COS( k*PI/(N+2) )^2, k=1:N-p.
+  ##   Defaults: ALPHA = 1, DELTA = 0.
   ##
-  ##         References:
-  ##         T.S. Chow, A class of Hessenberg matrices with known
-  ##            eigenvalues and inverses, SIAM Review, 11 (1969), pp. 391-395.
-  ##         G. Fairweather, On the eigenvalues and eigenvectors of a class of
-  ##            Hessenberg matrices, SIAM Review, 13 (1971), pp. 220-221.
+  ##   References:
+  ##   T.S. Chow, A class of Hessenberg matrices with known
+  ##      eigenvalues and inverses, SIAM Review, 11 (1969), pp. 391-395.
+  ##   G. Fairweather, On the eigenvalues and eigenvectors of a class of
+  ##      Hessenberg matrices, SIAM Review, 13 (1971), pp. 220-221.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for chow matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for chow matrix.");
   elseif (! isnumeric (alpha) || ! isscalar (alpha))
     error ("gallery: ALPHA must be a scalar for chow matrix.");
   elseif (! isnumeric (delta) || ! isscalar (delta))
     error ("gallery: DELTA must be a scalar for chow matrix.");
   endif
 
   A = toeplitz (alpha.^(1:n), [alpha 1 zeros(1, n-2)]) + delta * eye (n);
 endfunction
 
 function C = circul (v)
   ## CIRCUL  Circulant matrix.
-  ##         C = CIRCUL(V) is the circulant matrix whose first row is V.
-  ##         (A circulant matrix has the property that each row is obtained
-  ##         from the previous one by cyclically permuting the entries one step
-  ##         forward; it is a special Toeplitz matrix in which the diagonals
-  ##         `wrap round'.)
-  ##         Special case: if V is a scalar then C = CIRCUL(1:V).
-  ##         The eigensystem of C (N-by-N) is known explicitly.   If t is an Nth
-  ##         root of unity, then the inner product of V with W = [1 t t^2 ... t^N]
-  ##         is an eigenvalue of C, and W(N:-1:1) is an eigenvector of C.
+  ##   C = CIRCUL(V) is the circulant matrix whose first row is V.
+  ##   (A circulant matrix has the property that each row is obtained
+  ##   from the previous one by cyclically permuting the entries one step
+  ##   forward; it is a special Toeplitz matrix in which the diagonals
+  ##   `wrap round'.)
+  ##   Special case: if V is a scalar then C = CIRCUL(1:V).
+  ##   The eigensystem of C (N-by-N) is known explicitly.   If t is an Nth
+  ##   root of unity, then the inner product of V with W = [1 t t^2 ... t^N]
+  ##   is an eigenvalue of C, and W(N:-1:1) is an eigenvector of C.
   ##
-  ##         Reference:
-  ##         P.J. Davis, Circulant Matrices, John Wiley, 1977.
+  ##   Reference:
+  ##   P.J. Davis, Circulant Matrices, John Wiley, 1977.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for circul matrix.");
   elseif (! isnumeric (v))
     error ("gallery: V must be numeric for circul matrix.");
   endif
 
   n = numel (v);
@@ -737,38 +737,38 @@ function C = circul (v)
   endif
 
   v = v(:).';   # Make sure v is a row vector
   C = toeplitz ([v(1) v(n:-1:2)], v);
 endfunction
 
 function A = clement (n, k = 0)
   ## CLEMENT   Clement matrix - tridiagonal with zero diagonal entries.
-  ##           CLEMENT(N, K) is a tridiagonal matrix with zero diagonal entries
-  ##           and known eigenvalues.  It is singular if N is odd.  About 64
-  ##           percent of the entries of the inverse are zero.  The eigenvalues
-  ##           are plus and minus the numbers N-1, N-3, N-5, ..., (1 or 0).
-  ##           For K = 0 (the default) the matrix is unsymmetric, while for
-  ##           K = 1 it is symmetric.
-  ##           CLEMENT(N, 1) is diagonally similar to CLEMENT(N).
+  ##   CLEMENT(N, K) is a tridiagonal matrix with zero diagonal entries
+  ##   and known eigenvalues.  It is singular if N is odd.  About 64
+  ##   percent of the entries of the inverse are zero.  The eigenvalues
+  ##   are plus and minus the numbers N-1, N-3, N-5, ..., (1 or 0).
+  ##   For K = 0 (the default) the matrix is unsymmetric, while for
+  ##   K = 1 it is symmetric.
+  ##   CLEMENT(N, 1) is diagonally similar to CLEMENT(N).
   ##
-  ##           Similar properties hold for TRIDIAG(X,Y,Z) where Y = ZEROS(N,1).
-  ##           The eigenvalues still come in plus/minus pairs but they are not
-  ##           known explicitly.
+  ##   Similar properties hold for TRIDIAG(X,Y,Z) where Y = ZEROS(N,1).
+  ##   The eigenvalues still come in plus/minus pairs but they are not
+  ##   known explicitly.
   ##
-  ##           References:
-  ##           P.A. Clement, A class of triple-diagonal matrices for test
-  ##              purposes, SIAM Review, 1 (1959), pp. 50-52.
-  ##           A. Edelman and E. Kostlan, The road from Kac's matrix to Kac's
-  ##              random polynomials. In John~G. Lewis, editor, Proceedings of
-  ##              the Fifth SIAM Conference on Applied Linear Algebra Society
-  ##              for Industrial and Applied Mathematics, Philadelphia, 1994,
-  ##              pp. 503-507.
-  ##           O. Taussky and J. Todd, Another look at a matrix of Mark Kac,
-  ##              Linear Algebra and Appl., 150 (1991), pp. 341-360.
+  ##   References:
+  ##   P.A. Clement, A class of triple-diagonal matrices for test
+  ##      purposes, SIAM Review, 1 (1959), pp. 50-52.
+  ##   A. Edelman and E. Kostlan, The road from Kac's matrix to Kac's
+  ##      random polynomials. In John~G. Lewis, editor, Proceedings of
+  ##      the Fifth SIAM Conference on Applied Linear Algebra Society
+  ##      for Industrial and Applied Mathematics, Philadelphia, 1994,
+  ##      pp. 503-507.
+  ##   O. Taussky and J. Todd, Another look at a matrix of Mark Kac,
+  ##      Linear Algebra and Appl., 150 (1991), pp. 341-360.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for clement matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for clement matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for clement matrix.");
   endif
@@ -784,27 +784,27 @@ function A = clement (n, k = 0)
     A = diag (y, -1) + diag (y, 1);
   else
     error ("gallery: K must have a value of 0 or 1 for clement matrix.");
   endif
 endfunction
 
 function C = compar (A, k = 0)
   ## COMP    Comparison matrices.
-  ##         COMP(A) is DIAG(B) - TRIL(B,-1) - TRIU(B,1), where B = ABS(A).
-  ##         COMP(A, 1) is A with each diagonal element replaced by its
-  ##         absolute value, and each off-diagonal element replaced by minus
-  ##         the absolute value of the largest element in absolute value in
-  ##         its row.  However, if A is triangular COMP(A, 1) is too.
-  ##         COMP(A, 0) is the same as COMP(A).
-  ##         COMP(A) is often denoted by M(A) in the literature.
+  ##   COMP(A) is DIAG(B) - TRIL(B,-1) - TRIU(B,1), where B = ABS(A).
+  ##   COMP(A, 1) is A with each diagonal element replaced by its
+  ##   absolute value, and each off-diagonal element replaced by minus
+  ##   the absolute value of the largest element in absolute value in
+  ##   its row.  However, if A is triangular COMP(A, 1) is too.
+  ##   COMP(A, 0) is the same as COMP(A).
+  ##   COMP(A) is often denoted by M(A) in the literature.
   ##
-  ##         Reference (e.g.):
-  ##         N.J. Higham, A survey of condition number estimation for
-  ##         triangular matrices, SIAM Review, 29 (1987), pp. 575-596.
+  ##   Reference (e.g.):
+  ##   N.J. Higham, A survey of condition number estimation for
+  ##   triangular matrices, SIAM Review, 29 (1987), pp. 575-596.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for compar matrix.");
   elseif (! isnumeric (A) || ndims (A) != 2)
     error ("gallery: A must be a 2-D matrix for compar matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for compar matrix.");
   endif
@@ -836,36 +836,36 @@ function C = compar (A, k = 0)
   else
     error ("gallery: K must have a value of 0 or 1 for compar matrix.");
   endif
 
 endfunction
 
 function A = condex (n, k = 4, theta = 100)
   ## CONDEX   `Counterexamples' to matrix condition number estimators.
-  ##          CONDEX(N, K, THETA) is a `counterexample' matrix to a condition
-  ##          estimator.  It has order N and scalar parameter THETA (default 100).
-  ##          If N is not equal to the `natural' size of the matrix then
-  ##          the matrix is padded out with an identity matrix to order N.
-  ##          The matrix, its natural size, and the estimator to which it applies
-  ##          are specified by K (default K = 4) as follows:
-  ##              K = 1:   4-by-4,     LINPACK (RCOND)
-  ##              K = 2:   3-by-3,     LINPACK (RCOND)
-  ##              K = 3:   arbitrary,  LINPACK (RCOND) (independent of THETA)
-  ##              K = 4:   N >= 4,     SONEST (Higham 1988)
-  ##          (Note that in practice the K = 4 matrix is not usually a
-  ##           counterexample because of the rounding errors in forming it.)
+  ##   CONDEX(N, K, THETA) is a `counterexample' matrix to a condition
+  ##   estimator.  It has order N and scalar parameter THETA (default 100).
+  ##   If N is not equal to the `natural' size of the matrix then
+  ##   the matrix is padded out with an identity matrix to order N.
+  ##   The matrix, its natural size, and the estimator to which it applies
+  ##   are specified by K (default K = 4) as follows:
+  ##       K = 1:   4-by-4,     LINPACK (RCOND)
+  ##       K = 2:   3-by-3,     LINPACK (RCOND)
+  ##       K = 3:   arbitrary,  LINPACK (RCOND) (independent of THETA)
+  ##       K = 4:   N >= 4,     SONEST (Higham 1988)
+  ##   (Note that in practice the K = 4 matrix is not usually a
+  ##    counterexample because of the rounding errors in forming it.)
   ##
-  ##          References:
-  ##          A.K. Cline and R.K. Rew, A set of counter-examples to three
-  ##             condition number estimators, SIAM J. Sci. Stat. Comput.,
-  ##             4 (1983), pp. 602-611.
-  ##          N.J. Higham, FORTRAN codes for estimating the one-norm of a real or
-  ##             complex matrix, with applications to condition estimation
-  ##             (Algorithm 674), ACM Trans. Math. Soft., 14 (1988), pp. 381-396.
+  ##   References:
+  ##   A.K. Cline and R.K. Rew, A set of counter-examples to three
+  ##      condition number estimators, SIAM J. Sci. Stat. Comput.,
+  ##      4 (1983), pp. 602-611.
+  ##   N.J. Higham, FORTRAN codes for estimating the one-norm of a real or
+  ##      complex matrix, with applications to condition estimation
+  ##      (Algorithm 674), ACM Trans. Math. Soft., 14 (1988), pp. 381-396.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for condex matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for condex matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for condex matrix.");
   elseif (! isnumeric (theta) || ! isscalar (theta))
@@ -908,24 +908,24 @@ function A = condex (n, k = 4, theta = 1
     for i = n:-1:m+1
       A(i,i) = 1;
     endfor
   endif
 endfunction
 
 function A = cycol (n, k)
   ## CYCOL   Matrix whose columns repeat cyclically.
-  ##         A = CYCOL([M N], K) is an M-by-N matrix of the form A = B(1:M,1:N)
-  ##         where B = [C C C...] and C = RANDN(M, K).  Thus A's columns repeat
-  ##         cyclically, and A has rank at most K.   K need not divide N.
-  ##         K defaults to ROUND(N/4).
-  ##         CYCOL(N, K), where N is a scalar, is the same as CYCOL([N N], K).
+  ##   A = CYCOL([M N], K) is an M-by-N matrix of the form A = B(1:M,1:N)
+  ##   where B = [C C C...] and C = RANDN(M, K).  Thus A's columns repeat
+  ##   cyclically, and A has rank at most K.   K need not divide N.
+  ##   K defaults to ROUND(N/4).
+  ##   CYCOL(N, K), where N is a scalar, is the same as CYCOL([N N], K).
   ##
-  ##         This type of matrix can lead to underflow problems for Gaussian
-  ##         elimination: see NA Digest Volume 89, Issue 3 (January 22, 1989).
+  ##   This type of matrix can lead to underflow problems for Gaussian
+  ##   elimination: see NA Digest Volume 89, Issue 3 (January 22, 1989).
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for cycol matrix.");
   elseif (! isnumeric (n) || all (numel (n) != [1 2]) || fix (n) != n)
     error ("gallery: N must be a 1 or 2 element integer for cycol matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a scalar for cycol matrix.");
   endif
@@ -942,29 +942,29 @@ function A = cycol (n, k)
   for i = 2:ceil (n/k)
     A = [A A(:,1:k)];
   endfor
   A = A(:,1:n);
 endfunction
 
 function [c, d, e] = dorr (n, theta = 0.01)
   ## DORR  Dorr matrix - diagonally dominant, ill conditioned, tridiagonal.
-  ##       [C, D, E] = DORR(N, THETA) returns the vectors defining a row diagonally
-  ##       dominant, tridiagonal M-matrix that is ill conditioned for small
-  ##       values of the parameter THETA >= 0.
-  ##       If only one output parameter is supplied then
-  ##       C = FULL(TRIDIAG(C,D,E)), i.e., the matrix iself is returned.
-  ##       The columns of INV(C) vary greatly in norm.  THETA defaults to 0.01.
-  ##       The amount of diagonal dominance is given by (ignoring rounding errors):
-  ##             COMP(C)*ONES(N,1) = THETA*(N+1)^2 * [1 0 0 ... 0 1]'.
+  ##   [C, D, E] = DORR(N, THETA) returns the vectors defining a row diagonally
+  ##   dominant, tridiagonal M-matrix that is ill conditioned for small
+  ##   values of the parameter THETA >= 0.
+  ##   If only one output parameter is supplied then
+  ##   C = FULL(TRIDIAG(C,D,E)), i.e., the matrix iself is returned.
+  ##   The columns of INV(C) vary greatly in norm.  THETA defaults to 0.01.
+  ##   The amount of diagonal dominance is given by (ignoring rounding errors):
+  ##         COMP(C)*ONES(N,1) = THETA*(N+1)^2 * [1 0 0 ... 0 1]'.
   ##
-  ##       Reference:
-  ##       F.W. Dorr, An example of ill-conditioning in the numerical
-  ##       solution of singular perturbation problems, Math. Comp., 25 (1971),
-  ##       pp. 271-283.
+  ##   Reference:
+  ##   F.W. Dorr, An example of ill-conditioning in the numerical
+  ##   solution of singular perturbation problems, Math. Comp., 25 (1971),
+  ##   pp. 271-283.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for dorr matrix.");
   elseif (! isscalar (n) || ! isnumeric (n) || fix (n) != n)
     error ("gallery: N must be an integer for dorr matrix.");
   elseif (! isscalar (theta) || ! isnumeric (theta))
     error ("gallery: THETA must be a numeric scalar for dorr matrix.");
   endif
@@ -993,37 +993,37 @@ function [c, d, e] = dorr (n, theta = 0.
 
   if (nargout <= 1)
     c = tridiag (c, d, e);
   endif
 endfunction
 
 function A = dramadah (n, k = 1)
   ## DRAMADAH  A (0,1) matrix whose inverse has large integer entries.
-  ##           An anti-Hadamard matrix A is a matrix with elements 0 or 1 for
-  ##           which MU(A) := NORM(INV(A),'FRO') is maximal.
-  ##           A = DRAMADAH(N, K) is an N-by-N (0,1) matrix for which MU(A) is
-  ##           relatively large, although not necessarily maximal.
-  ##           Available types (the default is K = 1):
-  ##           K = 1: A is Toeplitz, with ABS(DET(A)) = 1, and MU(A) > c(1.75)^N,
-  ##                  where c is a constant.
-  ##           K = 2: A is upper triangular and Toeplitz.
-  ##           The inverses of both types have integer entries.
+  ##   An anti-Hadamard matrix A is a matrix with elements 0 or 1 for
+  ##   which MU(A) := NORM(INV(A),'FRO') is maximal.
+  ##   A = DRAMADAH(N, K) is an N-by-N (0,1) matrix for which MU(A) is
+  ##   relatively large, although not necessarily maximal.
+  ##   Available types (the default is K = 1):
+  ##   K = 1: A is Toeplitz, with ABS(DET(A)) = 1, and MU(A) > c(1.75)^N,
+  ##          where c is a constant.
+  ##   K = 2: A is upper triangular and Toeplitz.
+  ##   The inverses of both types have integer entries.
   ##
-  ##           Another interesting (0,1) matrix:
-  ##           K = 3: A has maximal determinant among (0,1) lower Hessenberg
-  ##           matrices: det(A) = the n'th Fibonacci number.  A is Toeplitz.
-  ##           The eigenvalues have an interesting distribution in the complex
-  ##           plane.
+  ##   Another interesting (0,1) matrix:
+  ##   K = 3: A has maximal determinant among (0,1) lower Hessenberg
+  ##   matrices: det(A) = the n'th Fibonacci number.  A is Toeplitz.
+  ##   The eigenvalues have an interesting distribution in the complex
+  ##   plane.
   ##
-  ##           References:
-  ##           R.L. Graham and N.J.A. Sloane, Anti-Hadamard matrices,
-  ##              Linear Algebra and Appl., 62 (1984), pp. 113-137.
-  ##           L. Ching, The maximum determinant of an nxn lower Hessenberg
-  ##              (0,1) matrix, Linear Algebra and Appl., 183 (1993), pp. 147-153.
+  ##   References:
+  ##   R.L. Graham and N.J.A. Sloane, Anti-Hadamard matrices,
+  ##      Linear Algebra and Appl., 62 (1984), pp. 113-137.
+  ##   L. Ching, The maximum determinant of an nxn lower Hessenberg
+  ##      (0,1) matrix, Linear Algebra and Appl., 183 (1993), pp. 147-153.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for dramadah matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for dramadah matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for dramadah matrix.");
   endif
@@ -1060,34 +1060,34 @@ function A = dramadah (n, k = 1)
 
     otherwise
       error ("gallery: unknown K '%d' for dramadah matrix.", k);
   endswitch
 endfunction
 
 function A = fiedler (c)
   ## FIEDLER  Fiedler matrix - symmetric.
-  ##          A = FIEDLER(C), where C is an n-vector, is the n-by-n symmetric
-  ##          matrix with elements ABS(C(i)-C(j)).
-  ##          Special case: if C is a scalar, then A = FIEDLER(1:C)
-  ##                        (i.e. A(i,j) = ABS(i-j)).
-  ##          Properties:
-  ##            FIEDLER(N) has a dominant positive eigenvalue and all the other
-  ##                       eigenvalues are negative (Szego, 1936).
-  ##            Explicit formulas for INV(A) and DET(A) are given by Todd (1977)
-  ##            and attributed to Fiedler.  These indicate that INV(A) is
-  ##            tridiagonal except for nonzero (1,n) and (n,1) elements.
-  ##            [I think these formulas are valid only if the elements of
-  ##            C are in increasing or decreasing order---NJH.]
+  ##   FIEDLER(C), where C is an n-vector, is the n-by-n symmetric
+  ##   matrix with elements ABS(C(i)-C(j)).
+  ##   Special case: if C is a scalar, then A = FIEDLER(1:C)
+  ##               (i.e. A(i,j) = ABS(i-j)).
+  ##   Properties:
+  ##   FIEDLER(N) has a dominant positive eigenvalue and all the other
+  ##              eigenvalues are negative (Szego, 1936).
+  ##   Explicit formulas for INV(A) and DET(A) are given by Todd (1977)
+  ##   and attributed to Fiedler.  These indicate that INV(A) is
+  ##   tridiagonal except for nonzero (1,n) and (n,1) elements.
+  ##   [I think these formulas are valid only if the elements of
+  ##   C are in increasing or decreasing order---NJH.]
   ##
-  ##            References:
-  ##            G. Szego, Solution to problem 3705, Amer. Math. Monthly,
-  ##               43 (1936), pp. 246-259.
-  ##            J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
-  ##               Birkhauser, Basel, and Academic Press, New York, 1977, p. 159.
+  ##   References:
+  ##   G. Szego, Solution to problem 3705, Amer. Math. Monthly,
+  ##      43 (1936), pp. 246-259.
+  ##   J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
+  ##      Birkhauser, Basel, and Academic Press, New York, 1977, p. 159.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for fiedler matrix.");
   elseif (! isnumeric (c))
     error ("gallery: C must be numeric for fiedler matrix.");
   endif
 
   n = numel (c);
@@ -1102,21 +1102,21 @@ function A = fiedler (c)
   c = c(:).';           # Ensure c is a row vector.
 
   A = ones (n, 1) * c;
   A = abs (A - A.');    # NB. array transpose.
 endfunction
 
 function A = forsythe (n, alpha = sqrt (eps), lambda = 0)
   ## FORSYTHE  Forsythe matrix - a perturbed Jordan block.
-  ##           FORSYTHE(N, ALPHA, LAMBDA) is the N-by-N matrix equal to
-  ##           JORDBLOC(N, LAMBDA) except it has an ALPHA in the (N,1) position.
-  ##           It has the characteristic polynomial
-  ##                   DET(A-t*EYE) = (LAMBDA-t)^N - (-1)^N ALPHA.
-  ##           ALPHA defaults to SQRT(EPS) and LAMBDA to 0.
+  ##   FORSYTHE(N, ALPHA, LAMBDA) is the N-by-N matrix equal to
+  ##   JORDBLOC(N, LAMBDA) except it has an ALPHA in the (N,1) position.
+  ##   It has the characteristic polynomial
+  ##           DET(A-t*EYE) = (LAMBDA-t)^N - (-1)^N ALPHA.
+  ##   ALPHA defaults to SQRT(EPS) and LAMBDA to 0.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for forsythe matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for forsythe matrix.");
   elseif (! isnumeric (alpha) || ! isscalar (alpha))
     error ("gallery: ALPHA must be a numeric scalar for forsythe matrix.");
   elseif (! isnumeric (lambda) || ! isscalar (lambda))
@@ -1124,51 +1124,51 @@ function A = forsythe (n, alpha = sqrt (
   endif
 
   A = jordbloc (n, lambda);
   A(n,1) = alpha;
 endfunction
 
 function F = frank (n, k = 0)
   ## FRANK   Frank matrix---ill conditioned eigenvalues.
-  ##         F = FRANK(N, K) is the Frank matrix of order N.  It is upper
-  ##         Hessenberg with determinant 1.  K = 0 is the default; if K = 1 the
-  ##         elements are reflected about the anti-diagonal (1,N)--(N,1).
-  ##         F has all positive eigenvalues and they occur in reciprocal pairs
-  ##         (so that 1 is an eigenvalue if N is odd).
-  ##         The eigenvalues of F may be obtained in terms of the zeros of the
-  ##         Hermite polynomials.
-  ##         The FLOOR(N/2) smallest eigenvalues of F are ill conditioned,
-  ##         the more so for bigger N.
+  ##   F = FRANK(N, K) is the Frank matrix of order N.  It is upper
+  ##   Hessenberg with determinant 1.  K = 0 is the default; if K = 1 the
+  ##   elements are reflected about the anti-diagonal (1,N)--(N,1).
+  ##   F has all positive eigenvalues and they occur in reciprocal pairs
+  ##   (so that 1 is an eigenvalue if N is odd).
+  ##   The eigenvalues of F may be obtained in terms of the zeros of the
+  ##   Hermite polynomials.
+  ##   The FLOOR(N/2) smallest eigenvalues of F are ill conditioned,
+  ##   the more so for bigger N.
   ##
-  ##         DET(FRANK(N)') comes out far from 1 for large N---see Frank (1958)
-  ##         and Wilkinson (1960) for discussions.
+  ##   DET(FRANK(N)') comes out far from 1 for large N---see Frank (1958)
+  ##   and Wilkinson (1960) for discussions.
   ##
-  ##         This version incorporates improvements suggested by W. Kahan.
+  ##   This version incorporates improvements suggested by W. Kahan.
   ##
-  ##         References:
-  ##         W.L. Frank, Computing eigenvalues of complex matrices by determinant
-  ##            evaluation and by methods of Danilewski and Wielandt, J. Soc.
-  ##            Indust. Appl. Math., 6 (1958), pp. 378-392 (see pp. 385, 388).
-  ##         G.H. Golub and J.H. Wilkinson, Ill-conditioned eigensystems and the
-  ##            computation of the Jordan canonical form, SIAM Review, 18 (1976),
-  ##              pp. 578-619 (Section 13).
-  ##         H. Rutishauser, On test matrices, Programmation en Mathematiques
-  ##            Numeriques, Editions Centre Nat. Recherche Sci., Paris, 165,
-  ##            1966, pp. 349-365.  Section 9.
-  ##         J.H. Wilkinson, Error analysis of floating-point computation,
-  ##            Numer. Math., 2 (1960), pp. 319-340 (Section 8).
-  ##         J.H. Wilkinson, The Algebraic Eigenvalue Problem, Oxford University
-  ##            Press, 1965 (pp. 92-93).
-  ##         The next two references give details of the eigensystem, as does
-  ##         Rutishauser (see above).
-  ##         P.J. Eberlein, A note on the matrices denoted by B_n, SIAM J. Appl.
-  ##            Math., 20 (1971), pp. 87-92.
-  ##         J.M. Varah, A generalization of the Frank matrix, SIAM J. Sci. Stat.
-  ##            Comput., 7 (1986), pp. 835-839.
+  ##   References:
+  ##   W.L. Frank, Computing eigenvalues of complex matrices by determinant
+  ##      evaluation and by methods of Danilewski and Wielandt, J. Soc.
+  ##      Indust. Appl. Math., 6 (1958), pp. 378-392 (see pp. 385, 388).
+  ##   G.H. Golub and J.H. Wilkinson, Ill-conditioned eigensystems and the
+  ##      computation of the Jordan canonical form, SIAM Review, 18 (1976),
+  ##        pp. 578-619 (Section 13).
+  ##   H. Rutishauser, On test matrices, Programmation en Mathematiques
+  ##      Numeriques, Editions Centre Nat. Recherche Sci., Paris, 165,
+  ##      1966, pp. 349-365.  Section 9.
+  ##   J.H. Wilkinson, Error analysis of floating-point computation,
+  ##      Numer. Math., 2 (1960), pp. 319-340 (Section 8).
+  ##   J.H. Wilkinson, The Algebraic Eigenvalue Problem, Oxford University
+  ##      Press, 1965 (pp. 92-93).
+  ##   The next two references give details of the eigensystem, as does
+  ##   Rutishauser (see above).
+  ##   P.J. Eberlein, A note on the matrices denoted by B_n, SIAM J. Appl.
+  ##      Math., 20 (1971), pp. 87-92.
+  ##   J.M. Varah, A generalization of the Frank matrix, SIAM J. Sci. Stat.
+  ##      Comput., 7 (1986), pp. 835-839.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for frank matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for frank matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for frank matrix.");
   endif
@@ -1191,30 +1191,30 @@ function c = gcdmat (n)
     error ("gallery: N must be an integer for gcdmat matrix.");
   endif
   c = gcd (repmat ((1:n)', [1 n]), repmat (1:n, [n 1]));
 endfunction
 
 function A = gearmat (n, i = n, j = -n)
   ## NOTE: this function was named gearm in the original Test Matrix Toolbox
   ## GEARMAT   Gear matrix.
-  ##         A = GEARMAT(N,I,J) is the N-by-N matrix with ones on the sub- and
-  ##         super-diagonals, SIGN(I) in the (1,ABS(I)) position, SIGN(J)
-  ##         in the (N,N+1-ABS(J)) position, and zeros everywhere else.
-  ##         Defaults: I = N, j = -N.
-  ##         All eigenvalues are of the form 2*COS(a) and the eigenvectors
-  ##         are of the form [SIN(w+a), SIN(w+2a), ..., SIN(w+Na)].
-  ##         The values of a and w are given in the reference below.
-  ##         A can have double and triple eigenvalues and can be defective.
-  ##         GEARMAT(N) is singular.
+  ##   A = GEARMAT(N,I,J) is the N-by-N matrix with ones on the sub- and
+  ##   super-diagonals, SIGN(I) in the (1,ABS(I)) position, SIGN(J)
+  ##   in the (N,N+1-ABS(J)) position, and zeros everywhere else.
+  ##   Defaults: I = N, j = -N.
+  ##   All eigenvalues are of the form 2*COS(a) and the eigenvectors
+  ##   are of the form [SIN(w+a), SIN(w+2a), ..., SIN(w+Na)].
+  ##   The values of a and w are given in the reference below.
+  ##   A can have double and triple eigenvalues and can be defective.
+  ##   GEARMAT(N) is singular.
   ##
-  ##         (GEAR is a Simulink function, hence GEARMAT for Gear matrix.)
-  ##         Reference:
-  ##         C.W. Gear, A simple set of test matrices for eigenvalue programs,
-  ##         Math. Comp., 23 (1969), pp. 119-125.
+  ##   (GEAR is a Simulink function, hence GEARMAT for Gear matrix.)
+  ##   Reference:
+  ##   C.W. Gear, A simple set of test matrices for eigenvalue programs,
+  ##   Math. Comp., 23 (1969), pp. 119-125.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for gearmat matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for gearmat matrix.");
   elseif (! isnumeric (i) || ! isscalar (i) || i == 0 || abs (i) <= n)
     error ("gallery: I must be a nonzero scalar, and abs (I) <= N for gearmat matrix.");
   elseif (! isnumeric (j) || ! isscalar (j) || i == 0 || abs (j) <= n)
@@ -1223,52 +1223,52 @@ function A = gearmat (n, i = n, j = -n)
 
   A = diag (ones (n-1, 1), -1) + diag (ones (n-1, 1), 1);
   A(1, abs (i)) = sign (i);
   A(n, n+1 - abs (j)) = sign (j);
 endfunction
 
 function G = grcar (n, k = 3)
   ## GRCAR     Grcar matrix - a Toeplitz matrix with sensitive eigenvalues.
-  ##           GRCAR(N, K) is an N-by-N matrix with -1s on the
-  ##           subdiagonal, 1s on the diagonal, and K superdiagonals of 1s.
-  ##           The default is K = 3.  The eigenvalues of this matrix form an
-  ##           interesting pattern in the complex plane (try PS(GRCAR(32))).
+  ##   GRCAR(N, K) is an N-by-N matrix with -1s on the
+  ##   subdiagonal, 1s on the diagonal, and K superdiagonals of 1s.
+  ##   The default is K = 3.  The eigenvalues of this matrix form an
+  ##   interesting pattern in the complex plane (try PS(GRCAR(32))).
   ##
-  ##           References:
-  ##           J.F. Grcar, Operator coefficient methods for linear equations,
-  ##                Report SAND89-8691, Sandia National Laboratories, Albuquerque,
-  ##                New Mexico, 1989 (Appendix 2).
-  ##           N.M. Nachtigal, L. Reichel and L.N. Trefethen, A hybrid GMRES
-  ##                algorithm for nonsymmetric linear systems, SIAM J. Matrix Anal.
-  ##                Appl., 13 (1992), pp. 796-825.
+  ##   References:
+  ##   J.F. Grcar, Operator coefficient methods for linear equations,
+  ##        Report SAND89-8691, Sandia National Laboratories, Albuquerque,
+  ##        New Mexico, 1989 (Appendix 2).
+  ##   N.M. Nachtigal, L. Reichel and L.N. Trefethen, A hybrid GMRES
+  ##        algorithm for nonsymmetric linear systems, SIAM J. Matrix Anal.
+  ##        Appl., 13 (1992), pp. 796-825.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for grcar matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for grcar matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for grcar matrix.");
   endif
 
   G = tril (triu (ones (n)), k) - diag (ones (n-1, 1), -1);
 endfunction
 
 function A = hanowa (n, d = -1)
   ## HANOWA  A matrix whose eigenvalues lie on a vertical line in the complex plane.
-  ##         HANOWA(N, d) is the N-by-N block 2x2 matrix (thus N = 2M must be even)
-  ##                       [d*EYE(M)   -DIAG(1:M)
-  ##                        DIAG(1:M)   d*EYE(M)]
-  ##         It has complex eigenvalues lambda(k) = d +/- k*i  (1 <= k <= M).
-  ##         Parameter d defaults to -1.
+  ##   HANOWA(N, d) is the N-by-N block 2x2 matrix (thus N = 2M must be even)
+  ##                 [d*EYE(M)   -DIAG(1:M)
+  ##                  DIAG(1:M)   d*EYE(M)]
+  ##   It has complex eigenvalues lambda(k) = d +/- k*i  (1 <= k <= M).
+  ##   Parameter d defaults to -1.
   ##
-  ##         Reference:
-  ##         E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary
-  ##         Differential Equations I: Nonstiff Problems, Springer-Verlag,
-  ##         Berlin, 1987. (pp. 86-87)
+  ##   Reference:
+  ##   E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary
+  ##   Differential Equations I: Nonstiff Problems, Springer-Verlag,
+  ##   Berlin, 1987. (pp. 86-87)
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for hanowa matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for hanowa matrix.");
   elseif (rem (n, 2) != 0)
     error ("gallery: N must be even for hanowa matrix.");
   elseif (! isnumeric (lambda) || ! isscalar (lambda))
@@ -1277,38 +1277,38 @@ function A = hanowa (n, d = -1)
 
   m = n/2;
   A = [ d*eye(m)  -diag(1:m)
         diag(1:m)  d*eye(m) ];
 endfunction
 
 function [v, beta] = house (x)
   ## HOUSE   Householder matrix.
-  ##         If [v, beta] = HOUSE(x) then H = EYE - beta*v*v' is a Householder
-  ##         matrix such that Hx = -sign(x(1))*norm(x)*e_1.
-  ##         NB: If x = 0 then v = 0, beta = 1 is returned.
-  ##             x can be real or complex.
-  ##             sign(x) := exp(i*arg(x)) ( = x./abs(x) when x ~= 0).
+  ##   If [v, beta] = HOUSE(x) then H = EYE - beta*v*v' is a Householder
+  ##   matrix such that Hx = -sign(x(1))*norm(x)*e_1.
+  ##   NB: If x = 0 then v = 0, beta = 1 is returned.
+  ##       x can be real or complex.
+  ##       sign(x) := exp(i*arg(x)) ( = x./abs(x) when x ~= 0).
   ##
-  ##         Theory: (textbook references Golub & Van Loan 1989, 38-43;
-  ##                  Stewart 1973, 231-234, 262; Wilkinson 1965, 48-50).
-  ##         Hx = y: (I - beta*v*v')x = -s*e_1.
-  ##         Must have |s| = norm(x), v = x+s*e_1, and
-  ##         x'y = x'Hx =(x'Hx)' real => arg(s) = arg(x(1)).
-  ##         So take s = sign(x(1))*norm(x) (which avoids cancellation).
-  ##         v'v = (x(1)+s)^2 + x(2)^2 + ... + x(n)^2
-  ##             = 2*norm(x)*(norm(x) + |x(1)|).
+  ##   Theory: (textbook references Golub & Van Loan 1989, 38-43;
+  ##            Stewart 1973, 231-234, 262; Wilkinson 1965, 48-50).
+  ##   Hx = y: (I - beta*v*v')x = -s*e_1.
+  ##   Must have |s| = norm(x), v = x+s*e_1, and
+  ##   x'y = x'Hx =(x'Hx)' real => arg(s) = arg(x(1)).
+  ##   So take s = sign(x(1))*norm(x) (which avoids cancellation).
+  ##   v'v = (x(1)+s)^2 + x(2)^2 + ... + x(n)^2
+  ##       = 2*norm(x)*(norm(x) + |x(1)|).
   ##
-  ##         References:
-  ##         G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
-  ##            Johns Hopkins University Press, Baltimore, Maryland, 1989.
-  ##         G.W. Stewart, Introduction to Matrix Computations, Academic Press,
-  ##            New York, 1973,
-  ##         J.H. Wilkinson, The Algebraic Eigenvalue Problem, Oxford University
-  ##            Press, 1965.
+  ##   References:
+  ##   G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
+  ##      Johns Hopkins University Press, Baltimore, Maryland, 1989.
+  ##   G.W. Stewart, Introduction to Matrix Computations, Academic Press,
+  ##      New York, 1973,
+  ##   J.H. Wilkinson, The Algebraic Eigenvalue Problem, Oxford University
+  ##      Press, 1965.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for house matrix.");
   elseif (! isnumeric (x) || ! isvector (x) || numel (x) <= 1)
     error ("gallery: X must be a vector for house matrix.");
   endif
 
   ## must be a column vector
@@ -1366,36 +1366,36 @@ function A = integerdata (varargin)
   unwind_protect_cleanup
     rand ("state", randstate);
   end_unwind_protect
 
 endfunction
 
 function A = invhess (x, y)
   ## INVHESS  Inverse of an upper Hessenberg matrix.
-  ##          INVHESS(X, Y), where X is an N-vector and Y an N-1 vector,
-  ##          is the matrix whose lower triangle agrees with that of
-  ##          ONES(N,1)*X' and whose strict upper triangle agrees with
-  ##          that of [1 Y]*ONES(1,N).
-  ##          The matrix is nonsingular if X(1) ~= 0 and X(i+1) ~= Y(i)
-  ##          for all i, and its inverse is an upper Hessenberg matrix.
-  ##          If Y is omitted it defaults to -X(1:N-1).
-  ##          Special case: if X is a scalar INVHESS(X) is the same as
-  ##          INVHESS(1:X).
+  ##   INVHESS(X, Y), where X is an N-vector and Y an N-1 vector,
+  ##   is the matrix whose lower triangle agrees with that of
+  ##   ONES(N,1)*X' and whose strict upper triangle agrees with
+  ##   that of [1 Y]*ONES(1,N).
+  ##   The matrix is nonsingular if X(1) ~= 0 and X(i+1) ~= Y(i)
+  ##   for all i, and its inverse is an upper Hessenberg matrix.
+  ##   If Y is omitted it defaults to -X(1:N-1).
+  ##   Special case: if X is a scalar INVHESS(X) is the same as
+  ##   INVHESS(1:X).
   ##
-  ##          References:
-  ##          F.N. Valvi and V.S. Geroyannis, Analytic inverses and
-  ##              determinants for a class of matrices, IMA Journal of Numerical
-  ##              Analysis, 7 (1987), pp. 123-128.
-  ##          W.-L. Cao and W.J. Stewart, A note on inverses of Hessenberg-like
-  ##              matrices, Linear Algebra and Appl., 76 (1986), pp. 233-240.
-  ##          Y. Ikebe, On inverses of Hessenberg matrices, Linear Algebra and
-  ##              Appl., 24 (1979), pp. 93-97.
-  ##          P. Rozsa, On the inverse of band matrices, Integral Equations and
-  ##              Operator Theory, 10 (1987), pp. 82-95.
+  ##   References:
+  ##   F.N. Valvi and V.S. Geroyannis, Analytic inverses and
+  ##       determinants for a class of matrices, IMA Journal of Numerical
+  ##       Analysis, 7 (1987), pp. 123-128.
+  ##   W.-L. Cao and W.J. Stewart, A note on inverses of Hessenberg-like
+  ##       matrices, Linear Algebra and Appl., 76 (1986), pp. 233-240.
+  ##   Y. Ikebe, On inverses of Hessenberg matrices, Linear Algebra and
+  ##       Appl., 24 (1979), pp. 93-97.
+  ##   P. Rozsa, On the inverse of band matrices, Integral Equations and
+  ##       Operator Theory, 10 (1987), pp. 82-95.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for invhess matrix.");
   elseif (! isnumeric (x))
     error ("gallery: X must be numeric for invhess matrix.");
   endif
 
   if (isscalar (x) && fix (x) == x)
@@ -1420,25 +1420,25 @@ function A = invhess (x, y)
   A = ones (n, 1) * x';
   for j = 2:n
     A(1:j-1,j) = y(1:j-1);
   endfor
 endfunction
 
 function A = invol (n)
   ## INVOL   An involutory matrix.
-  ##         A = INVOL(N) is an N-by-N involutory (A*A = EYE(N)) and
-  ##         ill-conditioned matrix.
-  ##         It is a diagonally scaled version of HILB(N).
-  ##         NB: B = (EYE(N)-A)/2 and B = (EYE(N)+A)/2 are idempotent (B*B = B).
+  ##   A = INVOL(N) is an N-by-N involutory (A*A = EYE(N)) and
+  ##   ill-conditioned matrix.
+  ##   It is a diagonally scaled version of HILB(N).
+  ##   NB: B = (EYE(N)-A)/2 and B = (EYE(N)+A)/2 are idempotent (B*B = B).
   ##
-  ##         Reference:
-  ##         A.S. Householder and J.A. Carpenter, The singular values
-  ##         of involutory and of idempotent matrices, Numer. Math. 5 (1963),
-  ##         pp. 234-237.
+  ##   Reference:
+  ##   A.S. Householder and J.A. Carpenter, The singular values
+  ##   of involutory and of idempotent matrices, Numer. Math. 5 (1963),
+  ##   pp. 234-237.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for invol matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for invol matrix.");
   endif
 
   A = hilb (n);
@@ -1449,29 +1449,29 @@ function A = invol (n)
   for i = 1:n-1
     d = -(n+i)*(n-i)*d/(i*i);
     A(i+1,:) = d * A(i+1,:);
   endfor
 endfunction
 
 function [A, detA] = ipjfact (n, k = 0)
   ## IPJFACT   A Hankel matrix with factorial elements.
-  ##           A = IPJFACT(N, K) is the matrix with
-  ##                     A(i,j) = (i+j)!    (K = 0, default)
-  ##                     A(i,j) = 1/(i+j)!  (K = 1)
-  ##           Both are Hankel matrices.
-  ##           The determinant and inverse are known explicitly.
-  ##           If a second output argument is present, d = DET(A) is returned:
-  ##           [A, d] = IPJFACT(N, K);
+  ##   A = IPJFACT(N, K) is the matrix with
+  ##             A(i,j) = (i+j)!    (K = 0, default)
+  ##             A(i,j) = 1/(i+j)!  (K = 1)
+  ##   Both are Hankel matrices.
+  ##   The determinant and inverse are known explicitly.
+  ##   If a second output argument is present, d = DET(A) is returned:
+  ##   [A, d] = IPJFACT(N, K);
   ##
-  ##           Suggested by P. R. Graves-Morris.
+  ##   Suggested by P. R. Graves-Morris.
   ##
-  ##           Reference:
-  ##           M.J.C. Gover, The explicit inverse of factorial Hankel matrices,
-  ##           Dept. of Mathematics, University of Bradford, 1993.
+  ##   Reference:
+  ##   M.J.C. Gover, The explicit inverse of factorial Hankel matrices,
+  ##   Dept. of Mathematics, University of Bradford, 1993.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for ipjfact matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for ipjfact matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for ipjfact matrix.");
   endif
@@ -1510,56 +1510,56 @@ function [A, detA] = ipjfact (n, k = 0)
     endif
 
     detA = d;
   endif
 endfunction
 
 function J = jordbloc (n, lambda = 1)
   ## JORDBLOC  Jordan block.
-  ##           JORDBLOC(N, LAMBDA) is the N-by-N Jordan block with eigenvalue
-  ##           LAMBDA.  LAMBDA = 1 is the default.
+  ##   JORDBLOC(N, LAMBDA) is the N-by-N Jordan block with eigenvalue
+  ##   LAMBDA.  LAMBDA = 1 is the default.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for jordbloc matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for jordbloc matrix.");
   elseif (! isnumeric (lambda) || ! isscalar (lambda))
     error ("gallery: LAMBDA must be a numeric scalar for jordbloc matrix.");
   endif
 
   J = lambda * eye (n) + diag (ones (n-1, 1), 1);
 endfunction
 
 function U = kahan (n, theta = 1.2, pert = 25)
   ## KAHAN  Kahan matrix - upper trapezoidal.
-  ##        KAHAN(N, THETA) is an upper trapezoidal matrix
-  ##        that has some interesting properties regarding estimation of
-  ##        condition and rank.
-  ##        The matrix is N-by-N unless N is a 2-vector, in which case it
-  ##        is N(1)-by-N(2).
-  ##        The parameter THETA defaults to 1.2.
-  ##        The useful range of THETA is 0 < THETA < PI.
+  ##   KAHAN(N, THETA) is an upper trapezoidal matrix
+  ##   that has some interesting properties regarding estimation of
+  ##   condition and rank.
+  ##   The matrix is N-by-N unless N is a 2-vector, in which case it
+  ##   is N(1)-by-N(2).
+  ##   The parameter THETA defaults to 1.2.
+  ##   The useful range of THETA is 0 < THETA < PI.
   ##
-  ##        To ensure that the QR factorization with column pivoting does not
-  ##        interchange columns in the presence of rounding errors, the diagonal
-  ##        is perturbed by PERT*EPS*diag( [N:-1:1] ).
-  ##        The default is PERT = 25, which ensures no interchanges for KAHAN(N)
-  ##        up to at least N = 90 in IEEE arithmetic.
-  ##        KAHAN(N, THETA, PERT) uses the given value of PERT.
+  ##   To ensure that the QR factorization with column pivoting does not
+  ##   interchange columns in the presence of rounding errors, the diagonal
+  ##   is perturbed by PERT*EPS*diag( [N:-1:1] ).
+  ##   The default is PERT = 25, which ensures no interchanges for KAHAN(N)
+  ##   up to at least N = 90 in IEEE arithmetic.
+  ##   KAHAN(N, THETA, PERT) uses the given value of PERT.
   ##
-  ##        The inverse of KAHAN(N, THETA) is known explicitly: see
-  ##        Higham (1987, p. 588), for example.
-  ##        The diagonal perturbation was suggested by Christian Bischof.
+  ##   The inverse of KAHAN(N, THETA) is known explicitly: see
+  ##   Higham (1987, p. 588), for example.
+  ##   The diagonal perturbation was suggested by Christian Bischof.
   ##
-  ##        References:
-  ##        W. Kahan, Numerical linear algebra, Canadian Math. Bulletin,
-  ##           9 (1966), pp. 757-801.
-  ##        N.J. Higham, A survey of condition number estimation for
-  ##           triangular matrices, SIAM Review, 29 (1987), pp. 575-596.
+  ##   References:
+  ##   W. Kahan, Numerical linear algebra, Canadian Math. Bulletin,
+  ##      9 (1966), pp. 757-801.
+  ##   N.J. Higham, A survey of condition number estimation for
+  ##      triangular matrices, SIAM Review, 29 (1987), pp. 575-596.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for kahan matrix.");
   elseif (! isnumeric (n) || all (numel (n) != [1 2]) || fix (n) != n)
     error ("gallery: N must be a 1 or 2 element integer for kahan matrix.");
   elseif (! isnumeric (theta) || ! isscalar (theta))
     error ("gallery: THETA must be a numeric scalar for kahan matrix.");
   elseif (! isnumeric (pert) || ! isscalar (pert))
@@ -1579,32 +1579,32 @@ function U = kahan (n, theta = 1.2, pert
     U(r,n) = 0;     # Extend to an r-by-n matrix
   else
     U = U(1:r,:);   # Reduce to an r-by-n matrix
   endif
 endfunction
 
 function A = kms (n, rho = 0.5)
   ## KMS   Kac-Murdock-Szego Toeplitz matrix.
-  ##       A = KMS(N, RHO) is the N-by-N Kac-Murdock-Szego Toeplitz matrix with
-  ##       A(i,j) = RHO^(ABS((i-j))) (for real RHO).
-  ##       If RHO is complex, then the same formula holds except that elements
-  ##       below the diagonal are conjugated.
-  ##       RHO defaults to 0.5.
-  ##       Properties:
-  ##          A has an LDL' factorization with
-  ##                   L = INV(TRIW(N,-RHO,1)'),
-  ##                   D(i,i) = (1-ABS(RHO)^2)*EYE(N) except D(1,1) = 1.
-  ##          A is positive definite if and only if 0 < ABS(RHO) < 1.
-  ##          INV(A) is tridiagonal.
+  ##   A = KMS(N, RHO) is the N-by-N Kac-Murdock-Szego Toeplitz matrix with
+  ##   A(i,j) = RHO^(ABS((i-j))) (for real RHO).
+  ##   If RHO is complex, then the same formula holds except that elements
+  ##   below the diagonal are conjugated.
+  ##   RHO defaults to 0.5.
+  ##   Properties:
+  ##      A has an LDL' factorization with
+  ##               L = INV(TRIW(N,-RHO,1)'),
+  ##               D(i,i) = (1-ABS(RHO)^2)*EYE(N) except D(1,1) = 1.
+  ##      A is positive definite if and only if 0 < ABS(RHO) < 1.
+  ##      INV(A) is tridiagonal.
   ##
-  ##        Reference:
-  ##        W.F. Trench, Numerical solution of the eigenvalue problem
-  ##        for Hermitian Toeplitz matrices, SIAM J. Matrix Analysis and Appl.,
-  ##        10 (1989), pp. 135-146 (and see the references therein).
+  ##    Reference:
+  ##    W.F. Trench, Numerical solution of the eigenvalue problem
+  ##    for Hermitian Toeplitz matrices, SIAM J. Matrix Analysis and Appl.,
+  ##    10 (1989), pp. 135-146 (and see the references therein).
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for lauchli matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for lauchli matrix.")
   elseif (! isscalar (mu))
     error ("gallery: MU must be a scalar for lauchli matrix.")
   endif
@@ -1614,25 +1614,25 @@ function A = kms (n, rho = 0.5)
   A = rho .^ A;
   if (imag (rho))
     A = conj (tril (A,-1)) + triu (A);
   endif
 endfunction
 
 function B = krylov (A, x, j)
   ## KRYLOV    Krylov matrix.
-  ##           KRYLOV(A, x, j) is the Krylov matrix
-  ##                [x, Ax, A^2x, ..., A^(j-1)x],
-  ##           where A is an n-by-n matrix and x is an n-vector.
-  ##           Defaults: x = ONES(n,1), j = n.
-  ##           KRYLOV(n) is the same as KRYLOV(RANDN(n)).
+  ##   KRYLOV(A, x, j) is the Krylov matrix
+  ##        [x, Ax, A^2x, ..., A^(j-1)x],
+  ##   where A is an n-by-n matrix and x is an n-vector.
+  ##   Defaults: x = ONES(n,1), j = n.
+  ##   KRYLOV(n) is the same as KRYLOV(RANDN(n)).
   ##
-  ##           Reference:
-  ##           G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
-  ##           Johns Hopkins University Press, Baltimore, Maryland, 1989, p. 369.
+  ##   Reference:
+  ##   G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
+  ##   Johns Hopkins University Press, Baltimore, Maryland, 1989, p. 369.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for krylov matrix.");
   elseif (! isnumeric (A) || ! issquare (A) || ndims (A) != 2)
     error ("gallery: A must be a square 2-D matrix for krylov matrix.");
   endif
 
   n = length (A);
@@ -1657,178 +1657,178 @@ function B = krylov (A, x, j)
   B(:,1) = x(:);
   for i = 2:j
     B(:,i) = A*B(:,i-1);
   endfor
 endfunction
 
 function A = lauchli (n, mu = sqrt (eps))
   ## LAUCHLI   Lauchli matrix - rectangular.
-  ##           LAUCHLI(N, MU) is the (N+1)-by-N matrix [ONES(1,N); MU*EYE(N))].
-  ##           It is a well-known example in least squares and other problems
-  ##           that indicates the dangers of forming A'*A.
-  ##           MU defaults to SQRT(EPS).
+  ##   LAUCHLI(N, MU) is the (N+1)-by-N matrix [ONES(1,N); MU*EYE(N))].
+  ##   It is a well-known example in least squares and other problems
+  ##   that indicates the dangers of forming A'*A.
+  ##   MU defaults to SQRT(EPS).
   ##
-  ##           Reference:
-  ##           P. Lauchli, Jordan-Elimination und Ausgleichung nach
-  ##           kleinsten Quadraten, Numer. Math, 3 (1961), pp. 226-240.
+  ##   Reference:
+  ##   P. Lauchli, Jordan-Elimination und Ausgleichung nach
+  ##   kleinsten Quadraten, Numer. Math, 3 (1961), pp. 226-240.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for lauchli matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for lauchli matrix.");
   elseif (! isscalar (mu))
     error ("gallery: MU must be a scalar for lauchli matrix.");
   endif
 
   A = [ones(1, n)
        mu*eye(n) ];
 endfunction
 
 function A = lehmer (n)
   ## LEHMER  Lehmer matrix - symmetric positive definite.
-  ##         A = LEHMER(N) is the symmetric positive definite N-by-N matrix with
-  ##                          A(i,j) = i/j for j >= i.
-  ##         A is totally nonnegative.  INV(A) is tridiagonal, and explicit
-  ##         formulas are known for its entries.
-  ##         N <= COND(A) <= 4*N*N.
+  ##   A = LEHMER(N) is the symmetric positive definite N-by-N matrix with
+  ##                    A(i,j) = i/j for j >= i.
+  ##   A is totally nonnegative.  INV(A) is tridiagonal, and explicit
+  ##   formulas are known for its entries.
+  ##   N <= COND(A) <= 4*N*N.
   ##
-  ##         References:
-  ##         M. Newman and J. Todd, The evaluation of matrix inversion
-  ##            programs, J. Soc. Indust. Appl. Math., 6 (1958), pp. 466-476.
-  ##         Solutions to problem E710 (proposed by D.H. Lehmer): The inverse
-  ##            of a matrix, Amer. Math. Monthly, 53 (1946), pp. 534-535.
-  ##         J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
-  ##            Birkhauser, Basel, and Academic Press, New York, 1977, p. 154.
+  ##   References:
+  ##   M. Newman and J. Todd, The evaluation of matrix inversion
+  ##      programs, J. Soc. Indust. Appl. Math., 6 (1958), pp. 466-476.
+  ##   Solutions to problem E710 (proposed by D.H. Lehmer): The inverse
+  ##      of a matrix, Amer. Math. Monthly, 53 (1946), pp. 534-535.
+  ##   J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
+  ##      Birkhauser, Basel, and Academic Press, New York, 1977, p. 154.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for lehmer matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for lehmer matrix.");
   endif
 
   A = ones (n, 1) * (1:n);
   A = A./A';
   A = tril (A) + tril (A, -1)';
 endfunction
 
 function T = lesp (n)
   ## LESP   A tridiagonal matrix with real, sensitive eigenvalues.
-  ##        LESP(N) is an N-by-N matrix whose eigenvalues are real and smoothly
-  ##        distributed in the interval approximately [-2*N-3.5, -4.5].
-  ##        The sensitivities of the eigenvalues increase exponentially as
-  ##        the eigenvalues grow more negative.
-  ##        The matrix is similar to the symmetric tridiagonal matrix with
-  ##        the same diagonal entries and with off-diagonal entries 1,
-  ##        via a similarity transformation with D = diag(1!,2!,...,N!).
+  ##   LESP(N) is an N-by-N matrix whose eigenvalues are real and smoothly
+  ##   distributed in the interval approximately [-2*N-3.5, -4.5].
+  ##   The sensitivities of the eigenvalues increase exponentially as
+  ##   the eigenvalues grow more negative.
+  ##   The matrix is similar to the symmetric tridiagonal matrix with
+  ##   the same diagonal entries and with off-diagonal entries 1,
+  ##   via a similarity transformation with D = diag(1!,2!,...,N!).
   ##
-  ##        References:
-  ##        H.W.J. Lenferink and M.N. Spijker, On the use of stability regions in
-  ##             the numerical analysis of initial value problems,
-  ##             Math. Comp., 57 (1991), pp. 221-237.
-  ##        L.N. Trefethen, Pseudospectra of matrices, in Numerical Analysis 1991,
-  ##             Proceedings of the 14th Dundee Conference,
-  ##             D.F. Griffiths and G.A. Watson, eds, Pitman Research Notes in
-  ##             Mathematics, volume 260, Longman Scientific and Technical, Essex,
-  ##             UK, 1992, pp. 234-266.
+  ##   References:
+  ##   H.W.J. Lenferink and M.N. Spijker, On the use of stability regions in
+  ##        the numerical analysis of initial value problems,
+  ##        Math. Comp., 57 (1991), pp. 221-237.
+  ##   L.N. Trefethen, Pseudospectra of matrices, in Numerical Analysis 1991,
+  ##        Proceedings of the 14th Dundee Conference,
+  ##        D.F. Griffiths and G.A. Watson, eds, Pitman Research Notes in
+  ##        Mathematics, volume 260, Longman Scientific and Technical, Essex,
+  ##        UK, 1992, pp. 234-266.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for lesp matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for lesp matrix.");
   endif
 
   x = 2:n;
   T = full (tridiag (ones (size (x)) ./x, -(2*[x n+1]+1), x));
 endfunction
 
 function A = lotkin (n)
   ## LOTKIN  Lotkin matrix.
-  ##         A = LOTKIN(N) is the Hilbert matrix with its first row altered to
-  ##         all ones.  A is unsymmetric, ill-conditioned, and has many negative
-  ##         eigenvalues of small magnitude.
-  ##         The inverse has integer entries and is known explicitly.
+  ##   A = LOTKIN(N) is the Hilbert matrix with its first row altered to
+  ##   all ones.  A is unsymmetric, ill-conditioned, and has many negative
+  ##   eigenvalues of small magnitude.
+  ##   The inverse has integer entries and is known explicitly.
   ##
-  ##         Reference:
-  ##         M. Lotkin, A set of test matrices, MTAC, 9 (1955), pp. 153-161.
+  ##   Reference:
+  ##   M. Lotkin, A set of test matrices, MTAC, 9 (1955), pp. 153-161.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for lotkin matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for lotkin matrix.");
   endif
 
   A = hilb (n);
   A(1,:) = ones (1, n);
 endfunction
 
 function A = minij (n)
   ## MINIJ   Symmetric positive definite matrix MIN(i,j).
-  ##         A = MINIJ(N) is the N-by-N symmetric positive definite matrix with
-  ##         A(i,j) = MIN(i,j).
-  ##         Properties, variations:
-  ##         INV(A) is tridiagonal: it is minus the second difference matrix
-  ##                     except its (N,N) element is 1.
-  ##         2*A-ONES(N) (Givens' matrix) has tridiagonal inverse and
-  ##                     eigenvalues .5*sec^2([2r-1)PI/4N], r=1:N.
-  ##         (N+1)*ONES(N)-A also has a tridiagonal inverse.
+  ##   A = MINIJ(N) is the N-by-N symmetric positive definite matrix with
+  ##   A(i,j) = MIN(i,j).
+  ##   Properties, variations:
+  ##   INV(A) is tridiagonal: it is minus the second difference matrix
+  ##               except its (N,N) element is 1.
+  ##   2*A-ONES(N) (Givens' matrix) has tridiagonal inverse and
+  ##               eigenvalues .5*sec^2([2r-1)PI/4N], r=1:N.
+  ##   (N+1)*ONES(N)-A also has a tridiagonal inverse.
   ##
-  ##         References:
-  ##         J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
-  ##            Birkhauser, Basel, and Academic Press, New York, 1977, p. 158.
-  ##         D.E. Rutherford, Some continuant determinants arising in physics and
-  ##            chemistry---II, Proc. Royal Soc. Edin., 63, A (1952), pp. 232-241.
-  ##            (For the eigenvalues of Givens' matrix.)
+  ##   References:
+  ##   J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
+  ##      Birkhauser, Basel, and Academic Press, New York, 1977, p. 158.
+  ##   D.E. Rutherford, Some continuant determinants arising in physics and
+  ##      chemistry---II, Proc. Royal Soc. Edin., 63, A (1952), pp. 232-241.
+  ##      (For the eigenvalues of Givens' matrix.)
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for minij matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for minij matrix.");
   endif
 
   A = min (ones (n, 1) * (1:n), (1:n)' * ones (1, n));
 endfunction
 
 function A = moler (n, alpha = -1)
   ## MOLER   Moler matrix - symmetric positive definite.
-  ##         A = MOLER(N, ALPHA) is the symmetric positive definite N-by-N matrix
-  ##         U'*U where U = TRIW(N, ALPHA).
-  ##         For ALPHA = -1 (the default) A(i,j) = MIN(i,j)-2, A(i,i) = i.
-  ##         A has one small eigenvalue.
+  ##   A = MOLER(N, ALPHA) is the symmetric positive definite N-by-N matrix
+  ##   U'*U where U = TRIW(N, ALPHA).
+  ##   For ALPHA = -1 (the default) A(i,j) = MIN(i,j)-2, A(i,i) = i.
+  ##   A has one small eigenvalue.
   ##
-  ##         Nash (1990) attributes the ALPHA = -1 matrix to Moler.
+  ##   Nash (1990) attributes the ALPHA = -1 matrix to Moler.
   ##
-  ##         Reference:
-  ##         J.C. Nash, Compact Numerical Methods for Computers: Linear
-  ##         Algebra and Function Minimisation, second edition, Adam Hilger,
-  ##         Bristol, 1990 (Appendix 1).
+  ##   Reference:
+  ##   J.C. Nash, Compact Numerical Methods for Computers: Linear
+  ##   Algebra and Function Minimisation, second edition, Adam Hilger,
+  ##   Bristol, 1990 (Appendix 1).
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for moler matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for moler matrix.");
   elseif (! isscalar (alpha))
     error ("gallery: ALPHA must be a scalar for moler matrix.");
   endif
 
   A = triw (n, alpha)' * triw (n, alpha);
 endfunction
 
 function [A, T] = neumann (n)
   ## NEUMANN  Singular matrix from the discrete Neumann problem (sparse).
-  ##          NEUMANN(N) is the singular, row diagonally dominant matrix resulting
-  ##          from discretizing the Neumann problem with the usual five point
-  ##          operator on a regular mesh.
-  ##          It has a one-dimensional null space with null vector ONES(N,1).
-  ##          The dimension N should be a perfect square, or else a 2-vector,
-  ##          in which case the dimension of the matrix is N(1)*N(2).
+  ##   NEUMANN(N) is the singular, row diagonally dominant matrix resulting
+  ##   from discretizing the Neumann problem with the usual five point
+  ##   operator on a regular mesh.
+  ##   It has a one-dimensional null space with null vector ONES(N,1).
+  ##   The dimension N should be a perfect square, or else a 2-vector,
+  ##   in which case the dimension of the matrix is N(1)*N(2).
   ##
-  ##          Reference:
-  ##          R.J. Plemmons, Regular splittings and the discrete Neumann
-  ##          problem, Numer. Math., 25 (1976), pp. 153-161.
+  ##   Reference:
+  ##   R.J. Plemmons, Regular splittings and the discrete Neumann
+  ##   problem, Numer. Math., 25 (1976), pp. 153-161.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for neumann matrix.");
   elseif (! isnumeric (n) || all (numel (n) != [1 2]) || fix (n) != n)
     error ("gallery: N must be a 1 or 2 element integer for neumann matrix.");
   endif
 
   if (isscalar (n))
@@ -1885,47 +1885,47 @@ function A = normaldata (varargin)
   unwind_protect_cleanup
     randn ("state", randstate);
   end_unwind_protect
 
 endfunction
 
 function Q = orthog (n, k = 1)
   ## ORTHOG Orthogonal and nearly orthogonal matrices.
-  ##        Q = ORTHOG(N, K) selects the K'th type of matrix of order N.
-  ##        K > 0 for exactly orthogonal matrices, K < 0 for diagonal scalings of
-  ##        orthogonal matrices.
-  ##        Available types: (K = 1 is the default)
-  ##        K = 1:  Q(i,j) = SQRT(2/(n+1)) * SIN( i*j*PI/(n+1) )
-  ##                Symmetric eigenvector matrix for second difference matrix.
-  ##        K = 2:  Q(i,j) = 2/SQRT(2*n+1)) * SIN( 2*i*j*PI/(2*n+1) )
-  ##                Symmetric.
-  ##        K = 3:  Q(r,s) = EXP(2*PI*i*(r-1)*(s-1)/n) / SQRT(n)  (i=SQRT(-1))
-  ##                Unitary, the Fourier matrix.  Q^4 is the identity.
-  ##                This is essentially the same matrix as FFT(EYE(N))/SQRT(N)!
-  ##        K = 4:  Helmert matrix: a permutation of a lower Hessenberg matrix,
-  ##                whose first row is ONES(1:N)/SQRT(N).
-  ##        K = 5:  Q(i,j) = SIN( 2*PI*(i-1)*(j-1)/n ) + COS( 2*PI*(i-1)*(j-1)/n ).
-  ##                Symmetric matrix arising in the Hartley transform.
-  ##        K = -1: Q(i,j) = COS( (i-1)*(j-1)*PI/(n-1) )
-  ##                Chebyshev Vandermonde-like matrix, based on extrema of T(n-1).
-  ##        K = -2: Q(i,j) = COS( (i-1)*(j-1/2)*PI/n) )
-  ##                Chebyshev Vandermonde-like matrix, based on zeros of T(n).
+  ##   Q = ORTHOG(N, K) selects the K'th type of matrix of order N.
+  ##   K > 0 for exactly orthogonal matrices, K < 0 for diagonal scalings of
+  ##   orthogonal matrices.
+  ##   Available types: (K = 1 is the default)
+  ##   K = 1:  Q(i,j) = SQRT(2/(n+1)) * SIN( i*j*PI/(n+1) )
+  ##           Symmetric eigenvector matrix for second difference matrix.
+  ##   K = 2:  Q(i,j) = 2/SQRT(2*n+1)) * SIN( 2*i*j*PI/(2*n+1) )
+  ##           Symmetric.
+  ##   K = 3:  Q(r,s) = EXP(2*PI*i*(r-1)*(s-1)/n) / SQRT(n)  (i=SQRT(-1))
+  ##           Unitary, the Fourier matrix.  Q^4 is the identity.
+  ##           This is essentially the same matrix as FFT(EYE(N))/SQRT(N)!
+  ##   K = 4:  Helmert matrix: a permutation of a lower Hessenberg matrix,
+  ##           whose first row is ONES(1:N)/SQRT(N).
+  ##   K = 5:  Q(i,j) = SIN( 2*PI*(i-1)*(j-1)/n ) + COS( 2*PI*(i-1)*(j-1)/n ).
+  ##           Symmetric matrix arising in the Hartley transform.
+  ##   K = -1: Q(i,j) = COS( (i-1)*(j-1)*PI/(n-1) )
+  ##           Chebyshev Vandermonde-like matrix, based on extrema of T(n-1).
+  ##   K = -2: Q(i,j) = COS( (i-1)*(j-1/2)*PI/n) )
+  ##           Chebyshev Vandermonde-like matrix, based on zeros of T(n).
   ##
-  ##        References:
-  ##        N.J. Higham and D.J. Higham, Large growth factors in Gaussian
-  ##             elimination with pivoting, SIAM J. Matrix Analysis and  Appl.,
-  ##             10 (1989), pp. 155-164.
-  ##        P. Morton, On the eigenvectors of Schur's matrix, J. Number Theory,
-  ##             12 (1980), pp. 122-127. (Re. ORTHOG(N, 3))
-  ##        H.O. Lancaster, The Helmert Matrices, Amer. Math. Monthly, 72 (1965),
-  ##             pp. 4-12.
-  ##        D. Bini and P. Favati, On a matrix algebra related to the discrete
-  ##             Hartley transform, SIAM J. Matrix Anal. Appl., 14 (1993),
-  ##             pp. 500-507.
+  ##   References:
+  ##   N.J. Higham and D.J. Higham, Large growth factors in Gaussian
+  ##        elimination with pivoting, SIAM J. Matrix Analysis and  Appl.,
+  ##        10 (1989), pp. 155-164.
+  ##   P. Morton, On the eigenvectors of Schur's matrix, J. Number Theory,
+  ##        12 (1980), pp. 122-127. (Re. ORTHOG(N, 3))
+  ##   H.O. Lancaster, The Helmert Matrices, Amer. Math. Monthly, 72 (1965),
+  ##        pp. 4-12.
+  ##   D. Bini and P. Favati, On a matrix algebra related to the discrete
+  ##        Hartley transform, SIAM J. Matrix Anal. Appl., 14 (1993),
+  ##        pp. 500-507.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for orthog matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for orthog matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for orthog matrix.");
   endif
@@ -1971,97 +1971,97 @@ function Q = orthog (n, k = 1)
 
     otherwise
       error ("gallery: unknown K '%d' for orthog matrix.", k);
   endswitch
 endfunction
 
 function A = parter (n)
   ## PARTER    Parter matrix - a Toeplitz matrix with singular values near PI.
-  ##           PARTER(N) is the matrix with (i,j) element 1/(i-j+0.5).
-  ##           It is a Cauchy matrix and a Toeplitz matrix.
+  ##   PARTER(N) is the matrix with (i,j) element 1/(i-j+0.5).
+  ##   It is a Cauchy matrix and a Toeplitz matrix.
   ##
-  ##           At the Second SIAM Conference on Linear Algebra, Raleigh, N.C.,
-  ##           1985, Cleve Moler noted that most of the singular values of
-  ##           PARTER(N) are very close to PI.  An explanation of the phenomenon
-  ##           was given by Parter; see also the paper by Tyrtyshnikov.
+  ##   At the Second SIAM Conference on Linear Algebra, Raleigh, N.C.,
+  ##   1985, Cleve Moler noted that most of the singular values of
+  ##   PARTER(N) are very close to PI.  An explanation of the phenomenon
+  ##   was given by Parter; see also the paper by Tyrtyshnikov.
   ##
-  ##           References:
-  ##           The MathWorks Newsletter, Volume 1, Issue 1, March 1986, page 2.
-  ##           S.V. Parter, On the distribution of the singular values of Toeplitz
-  ##                matrices, Linear Algebra and Appl., 80 (1986), pp. 115-130.
-  ##           E.E. Tyrtyshnikov, Cauchy-Toeplitz matrices and some applications,
-  ##                Linear Algebra and Appl., 149 (1991), pp. 1-18.
+  ##   References:
+  ##   The MathWorks Newsletter, Volume 1, Issue 1, March 1986, page 2.
+  ##   S.V. Parter, On the distribution of the singular values of Toeplitz
+  ##        matrices, Linear Algebra and Appl., 80 (1986), pp. 115-130.
+  ##   E.E. Tyrtyshnikov, Cauchy-Toeplitz matrices and some applications,
+  ##        Linear Algebra and Appl., 149 (1991), pp. 1-18.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for parter matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for parter matrix.");
   endif
 
   A = cauchy ((1:n) + 0.5, -(1:n));
 endfunction
 
 function P = pei (n, alpha = 1)
   ## PEI    Pei matrix.
-  ##        PEI(N, ALPHA), where ALPHA is a scalar, is the symmetric matrix
-  ##        ALPHA*EYE(N) + ONES(N).
-  ##        If ALPHA is omitted then ALPHA = 1 is used.
-  ##        The matrix is singular for ALPHA = 0, -N.
+  ##   PEI(N, ALPHA), where ALPHA is a scalar, is the symmetric matrix
+  ##   ALPHA*EYE(N) + ONES(N).
+  ##   If ALPHA is omitted then ALPHA = 1 is used.
+  ##   The matrix is singular for ALPHA = 0, -N.
   ##
-  ##        Reference:
-  ##        M.L. Pei, A test matrix for inversion procedures,
-  ##        Comm. ACM, 5 (1962), p. 508.
+  ##   Reference:
+  ##   M.L. Pei, A test matrix for inversion procedures,
+  ##   Comm. ACM, 5 (1962), p. 508.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for pei matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for pei matrix.");
   elseif (! isnumeric (w) || ! isscalar (w))
     error ("gallery: ALPHA must be a scalar for pei matrix.");
   endif
 
   P = alpha * eye (n) + ones (n);
 endfunction
 
 function A = poisson (n)
   ## POISSON   Block tridiagonal matrix from Poisson's equation (sparse).
-  ##           POISSON(N) is the block tridiagonal matrix of order N^2
-  ##           resulting from discretizing Poisson's equation with the
-  ##           5-point operator on an N-by-N mesh.
+  ##   POISSON(N) is the block tridiagonal matrix of order N^2
+  ##   resulting from discretizing Poisson's equation with the
+  ##   5-point operator on an N-by-N mesh.
   ##
-  ##           Reference:
-  ##           G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
-  ##           Johns Hopkins University Press, Baltimore, Maryland, 1989
-  ##           (Section 4.5.4).
+  ##   Reference:
+  ##   G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
+  ##   Johns Hopkins University Press, Baltimore, Maryland, 1989
+  ##   (Section 4.5.4).
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for poisson matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for poisson matrix.");
   endif
 
   S = tridiag (n, -1, 2, -1);
   I = speye (n);
   A = kron (I, S) + kron (S, I);
 endfunction
 
 function A = prolate (n, w = 0.25)
   ## PROLATE   Prolate matrix - symmetric, ill-conditioned Toeplitz matrix.
-  ##           A = PROLATE(N, W) is the N-by-N prolate matrix with parameter W.
-  ##           It is a symmetric Toeplitz matrix.
-  ##           If 0 < W < 0.5 then
-  ##              - A is positive definite
-  ##              - the eigenvalues of A are distinct, lie in (0, 1), and
-  ##                tend to cluster around 0 and 1.
-  ##           W defaults to 0.25.
+  ##   A = PROLATE(N, W) is the N-by-N prolate matrix with parameter W.
+  ##   It is a symmetric Toeplitz matrix.
+  ##   If 0 < W < 0.5 then
+  ##      - A is positive definite
+  ##      - the eigenvalues of A are distinct, lie in (0, 1), and
+  ##        tend to cluster around 0 and 1.
+  ##   W defaults to 0.25.
   ##
-  ##           Reference:
-  ##           J.M. Varah. The Prolate matrix. Linear Algebra and Appl.,
-  ##           187:269--278, 1993.
+  ##   Reference:
+  ##   J.M. Varah. The Prolate matrix. Linear Algebra and Appl.,
+  ##   187:269--278, 1993.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for prolate matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for prolate matrix.");
   elseif (! isnumeric (w) || ! isscalar (w))
     error ("gallery: W must be a scalar for prolate matrix.");
   endif
@@ -2071,33 +2071,33 @@ function A = prolate (n, w = 0.25)
   a(2:n) = sin (2*pi*w*(1:n-1)) ./ (pi*(1:n-1));
 
   A = toeplitz (a);
 endfunction
 
 function H = randhess (x)
   ## NOTE: this function was named ohess in the original Test Matrix Toolbox
   ## RANDHESS  Random, orthogonal upper Hessenberg matrix.
-  ##        H = RANDHESS(N) is an N-by-N real, random, orthogonal
-  ##        upper Hessenberg matrix.
-  ##        Alternatively, H = RANDHESS(X), where X is an arbitrary real
-  ##        N-vector (N > 1) constructs H non-randomly using the elements
-  ##        of X as parameters.
-  ##        In both cases H is constructed via a product of N-1 Givens rotations.
+  ##   H = RANDHESS(N) is an N-by-N real, random, orthogonal
+  ##   upper Hessenberg matrix.
+  ##   Alternatively, H = RANDHESS(X), where X is an arbitrary real
+  ##   N-vector (N > 1) constructs H non-randomly using the elements
+  ##   of X as parameters.
+  ##   In both cases H is constructed via a product of N-1 Givens rotations.
   ##
-  ##        Note: See Gragg (1986) for how to represent an N-by-N (complex)
-  ##        unitary Hessenberg matrix with positive subdiagonal elements in terms
-  ##        of 2N-1 real parameters (the Schur parametrization).
-  ##        This M-file handles the real case only and is intended simply as a
-  ##        convenient way to generate random or non-random orthogonal Hessenberg
-  ##        matrices.
+  ##   Note: See Gragg (1986) for how to represent an N-by-N (complex)
+  ##   unitary Hessenberg matrix with positive subdiagonal elements in terms
+  ##   of 2N-1 real parameters (the Schur parametrization).
+  ##   This M-file handles the real case only and is intended simply as a
+  ##   convenient way to generate random or non-random orthogonal Hessenberg
+  ##   matrices.
   ##
-  ##        Reference:
-  ##        W.B. Gragg, The QR algorithm for unitary Hessenberg matrices,
-  ##        J. Comp. Appl. Math., 16 (1986), pp. 1-8.
+  ##   Reference:
+  ##   W.B. Gragg, The QR algorithm for unitary Hessenberg matrices,
+  ##   J. Comp. Appl. Math., 16 (1986), pp. 1-8.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for randhess matrix.");
   elseif (! isnumeric (x) || ! isreal (x))
     error ("gallery: N or X must be numeric real values for randhess matrix.");
   endif
 
   if (isscalar (x))
@@ -2120,22 +2120,22 @@ function H = randhess (x)
     s = sin (theta);
     H([i-1 i], :) = [ c*H(i-1,:)+s*H(i,:)
                      -s*H(i-1,:)+c*H(i,:) ];
   endfor
 endfunction
 
 function A = rando (n, k = 1)
   ## RANDO   Random matrix with elements -1, 0 or 1.
-  ##         A = RANDO(N, K) is a random N-by-N matrix with elements from
-  ##         one of the following discrete distributions (default K = 1):
-  ##           K = 1:  A(i,j) =  0 or 1    with equal probability,
-  ##           K = 2:  A(i,j) = -1 or 1    with equal probability,
-  ##           K = 3:  A(i,j) = -1, 0 or 1 with equal probability.
-  ##         N may be a 2-vector, in which case the matrix is N(1)-by-N(2).
+  ##   A = RANDO(N, K) is a random N-by-N matrix with elements from
+  ##   one of the following discrete distributions (default K = 1):
+  ##     K = 1:  A(i,j) =  0 or 1    with equal probability,
+  ##     K = 2:  A(i,j) = -1 or 1    with equal probability,
+  ##     K = 3:  A(i,j) = -1, 0 or 1 with equal probability.
+  ##   N may be a 2-vector, in which case the matrix is N(1)-by-N(2).
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for rando matrix.");
   elseif (! isnumeric (n) || all (numel (n) != [1 2]) || fix (n) != n)
     error ("gallery: N must be an integer for rando matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for smoke matrix.");
   endif
@@ -2151,47 +2151,47 @@ function A = rando (n, k = 1)
     otherwise
       error ("gallery: unknown K '%d' for smoke matrix.", k);
   endswitch
 
 endfunction
 
 function A = randsvd (n, kappa = sqrt (1/eps), mode = 3, kl = n-1, ku = kl)
   ## RANDSVD  Random matrix with pre-assigned singular values.
-  ##       RANDSVD(N, KAPPA, MODE, KL, KU) is a (banded) random matrix of order N
-  ##       with COND(A) = KAPPA and singular values from the distribution MODE.
-  ##       N may be a 2-vector, in which case the matrix is N(1)-by-N(2).
-  ##       Available types:
-  ##              MODE = 1:   one large singular value,
-  ##              MODE = 2:   one small singular value,
-  ##              MODE = 3:   geometrically distributed singular values,
-  ##              MODE = 4:   arithmetically distributed singular values,
-  ##              MODE = 5:   random singular values with unif. dist. logarithm.
-  ##       If omitted, MODE defaults to 3, and KAPPA defaults to SQRT(1/EPS).
-  ##       If MODE < 0 then the effect is as for ABS(MODE) except that in the
-  ##       original matrix of singular values the order of the diagonal entries
-  ##       is reversed: small to large instead of large to small.
-  ##       KL and KU are the lower and upper bandwidths respectively; if they
-  ##       are omitted a full matrix is produced.
-  ##       If only KL is present, KU defaults to KL.
-  ##       Special case: if KAPPA < 0 then a random full symmetric positive
-  ##                     definite matrix is produced with COND(A) = -KAPPA and
-  ##                     eigenvalues distributed according to MODE.
-  ##                     KL and KU, if present, are ignored.
+  ##   RANDSVD(N, KAPPA, MODE, KL, KU) is a (banded) random matrix of order N
+  ##   with COND(A) = KAPPA and singular values from the distribution MODE.
+  ##   N may be a 2-vector, in which case the matrix is N(1)-by-N(2).
+  ##   Available types:
+  ##          MODE = 1:   one large singular value,
+  ##          MODE = 2:   one small singular value,
+  ##          MODE = 3:   geometrically distributed singular values,
+  ##          MODE = 4:   arithmetically distributed singular values,
+  ##          MODE = 5:   random singular values with unif. dist. logarithm.
+  ##   If omitted, MODE defaults to 3, and KAPPA defaults to SQRT(1/EPS).
+  ##   If MODE < 0 then the effect is as for ABS(MODE) except that in the
+  ##   original matrix of singular values the order of the diagonal entries
+  ##   is reversed: small to large instead of large to small.
+  ##   KL and KU are the lower and upper bandwidths respectively; if they
+  ##   are omitted a full matrix is produced.
+  ##   If only KL is present, KU defaults to KL.
+  ##   Special case: if KAPPA < 0 then a random full symmetric positive
+  ##                 definite matrix is produced with COND(A) = -KAPPA and
+  ##                 eigenvalues distributed according to MODE.
+  ##                 KL and KU, if present, are ignored.
   ##
-  ##       Reference:
-  ##       N.J. Higham, Accuracy and Stability of Numerical Algorithms,
-  ##          Society for Industrial and Applied Mathematics, Philadelphia, PA,
-  ##          USA, 1996; sec. 26.3.
+  ##   Reference:
+  ##   N.J. Higham, Accuracy and Stability of Numerical Algorithms,
+  ##      Society for Industrial and Applied Mathematics, Philadelphia, PA,
+  ##      USA, 1996; sec. 26.3.
   ##
-  ##       This routine is similar to the more comprehensive Fortran routine xLATMS
-  ##       in the following reference:
-  ##       J.W. Demmel and A. McKenney, A test matrix generation suite,
-  ##       LAPACK Working Note #9, Courant Institute of Mathematical Sciences,
-  ##       New York, 1989.
+  ##   This routine is similar to the more comprehensive Fortran routine xLATMS
+  ##   in the following reference:
+  ##   J.W. Demmel and A. McKenney, A test matrix generation suite,
+  ##   LAPACK Working Note #9, Courant Institute of Mathematical Sciences,
+  ##   New York, 1989.
 
   if (nargin < 1 || nargin > 5)
     error ("gallery: 1 to 5 arguments are required for randsvd matrix.");
   elseif (! isnumeric (n) || all (numel (n) != [1 2]) || fix (n) != n)
     error ("gallery: N must be a 1 or 2 element integer vector for randsvd matrix.");
   elseif (! isnumeric (kappa) || ! isscalar (kappa))
     error ("gallery: KAPPA must be a numeric scalar for randsvd matrix.");
   elseif (abs (kappa) < 1)
@@ -2240,17 +2240,17 @@ function A = randsvd (n, kappa = sqrt (1
       rand ("uniform");
       sigma = exp (-rand (p, 1) * log (kappa));
     otherwise
       error ("gallery: unknown MODE '%d' for randsvd matrix.", mode);
   endswitch
 
   ##  Convert to diagonal matrix of singular values.
   if (mode < 0)
-    sigma = sigma (p:-1:1);
+    sigma = sigma(p:-1:1);
   endif
   sigma = diag (sigma);
 
   if (posdef)
     ## handle case where KAPPA was negative
     Q = qmult (p);
     A = Q' * sigma * Q;
     A = (A + A') / 2;  # Ensure matrix is symmetric.
@@ -2275,121 +2275,121 @@ function A = randsvd (n, kappa = sqrt (1
       ## Bandwidth reduction
       A = bandred (A, kl, ku);
     endif
   endif
 endfunction
 
 function A = redheff (n)
   ## REDHEFF    A (0,1) matrix of Redheffer associated with the Riemann hypothesis.
-  ##            A = REDHEFF(N) is an N-by-N matrix of 0s and 1s defined by
-  ##                A(i,j) = 1 if j = 1 or if i divides j,
-  ##                A(i,j) = 0 otherwise.
-  ##            It has N - FLOOR(LOG2(N)) - 1 eigenvalues equal to 1,
-  ##            a real eigenvalue (the spectral radius) approximately SQRT(N),
-  ##            a negative eigenvalue approximately -SQRT(N),
-  ##            and the remaining eigenvalues are provably ``small''.
-  ##            Barrett and Jarvis (1992) conjecture that
-  ##              ``the small eigenvalues all lie inside the unit circle
-  ##                ABS(Z) = 1'',
-  ##            and a proof of this conjecture, together with a proof that some
-  ##            eigenvalue tends to zero as N tends to infinity, would yield
-  ##            a new proof of the prime number theorem.
-  ##            The Riemann hypothesis is true if and only if
-  ##            DET(A) = O( N^(1/2+epsilon) ) for every epsilon > 0
-  ##                                              (`!' denotes factorial).
-  ##            See also RIEMANN.
+  ##   A = REDHEFF(N) is an N-by-N matrix of 0s and 1s defined by
+  ##       A(i,j) = 1 if j = 1 or if i divides j,
+  ##       A(i,j) = 0 otherwise.
+  ##   It has N - FLOOR(LOG2(N)) - 1 eigenvalues equal to 1,
+  ##   a real eigenvalue (the spectral radius) approximately SQRT(N),
+  ##   a negative eigenvalue approximately -SQRT(N),
+  ##   and the remaining eigenvalues are provably ``small''.
+  ##   Barrett and Jarvis (1992) conjecture that
+  ##     ``the small eigenvalues all lie inside the unit circle
+  ##       ABS(Z) = 1'',
+  ##   and a proof of this conjecture, together with a proof that some
+  ##   eigenvalue tends to zero as N tends to infinity, would yield
+  ##   a new proof of the prime number theorem.
+  ##   The Riemann hypothesis is true if and only if
+  ##   DET(A) = O( N^(1/2+epsilon) ) for every epsilon > 0
+  ##                                     (`!' denotes factorial).
+  ##   See also RIEMANN.
   ##
-  ##            Reference:
-  ##            W.W. Barrett and T.J. Jarvis,
-  ##            Spectral Properties of a Matrix of Redheffer,
-  ##            Linear Algebra and Appl., 162 (1992), pp. 673-683.
+  ##   Reference:
+  ##   W.W. Barrett and T.J. Jarvis,
+  ##   Spectral Properties of a Matrix of Redheffer,
+  ##   Linear Algebra and Appl., 162 (1992), pp. 673-683.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for redheff matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for redheff matrix.");
   endif
 
   i = (1:n)' * ones (1, n);
   A = ! rem (i', i);
   A(:,1) = ones (n, 1);
 endfunction
 
 function A = riemann (n)
   ## RIEMANN    A matrix associated with the Riemann hypothesis.
-  ##            A = RIEMANN(N) is an N-by-N matrix for which the
-  ##            Riemann hypothesis is true if and only if
-  ##            DET(A) = O( N! N^(-1/2+epsilon) ) for every epsilon > 0
-  ##                                              (`!' denotes factorial).
-  ##            A = B(2:N+1, 2:N+1), where
-  ##            B(i,j) = i-1 if i divides j and -1 otherwise.
-  ##            Properties include, with M = N+1:
-  ##               Each eigenvalue E(i) satisfies ABS(E(i)) <= M - 1/M.
-  ##               i <= E(i) <= i+1 with at most M-SQRT(M) exceptions.
-  ##               All integers in the interval (M/3, M/2] are eigenvalues.
+  ##   A = RIEMANN(N) is an N-by-N matrix for which the
+  ##   Riemann hypothesis is true if and only if
+  ##   DET(A) = O( N! N^(-1/2+epsilon) ) for every epsilon > 0
+  ##                                     (`!' denotes factorial).
+  ##   A = B(2:N+1, 2:N+1), where
+  ##   B(i,j) = i-1 if i divides j and -1 otherwise.
+  ##   Properties include, with M = N+1:
+  ##      Each eigenvalue E(i) satisfies ABS(E(i)) <= M - 1/M.
+  ##      i <= E(i) <= i+1 with at most M-SQRT(M) exceptions.
+  ##      All integers in the interval (M/3, M/2] are eigenvalues.
   ##
-  ##            See also REDHEFF.
+  ##   See also REDHEFF.
   ##
-  ##            Reference:
-  ##            F. Roesler, Riemann's hypothesis as an eigenvalue problem,
-  ##            Linear Algebra and Appl., 81 (1986), pp. 153-198.
+  ##   Reference:
+  ##   F. Roesler, Riemann's hypothesis as an eigenvalue problem,
+  ##   Linear Algebra and Appl., 81 (1986), pp. 153-198.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for riemann matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for riemann matrix.");
   endif
 
   n = n+1;
   i = (2:n)' * ones (1, n-1);
   j = i';
   A = i .* (! rem (j, i)) - ones (n-1);
 endfunction
 
 function A = ris (n)
   ## NOTE: this function was named dingdong in the original Test Matrix Toolbox
   ## RIS       Dingdong matrix - a symmetric Hankel matrix.
-  ##           A = RIS(N) is the symmetric N-by-N Hankel matrix with
-  ##                          A(i,j) = 0.5/(N-i-j+1.5).
-  ##           The eigenvalues of A cluster around PI/2 and -PI/2.
+  ##   A = RIS(N) is the symmetric N-by-N Hankel matrix with
+  ##                  A(i,j) = 0.5/(N-i-j+1.5).
+  ##   The eigenvalues of A cluster around PI/2 and -PI/2.
   ##
-  ##           Invented by F.N. Ris.
+  ##   Invented by F.N. Ris.
   ##
-  ##           Reference:
-  ##           J.C. Nash, Compact Numerical Methods for Computers: Linear
-  ##           Algebra and Function Minimisation, second edition, Adam Hilger,
-  ##           Bristol, 1990 (Appendix 1).
+  ##   Reference:
+  ##   J.C. Nash, Compact Numerical Methods for Computers: Linear
+  ##   Algebra and Function Minimisation, second edition, Adam Hilger,
+  ##   Bristol, 1990 (Appendix 1).
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for ris matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for ris matrix.");
   endif
 
   p = -2*(1:n) + (n+1.5);
   A = cauchy (p);
 endfunction
 
 function A = smoke (n, k = 0)
   ## SMOKE     Smoke matrix - complex, with a `smoke ring' pseudospectrum.
-  ##           SMOKE(N) is an N-by-N matrix with 1s on the
-  ##           superdiagonal, 1 in the (N,1) position, and powers of
-  ##           roots of unity along the diagonal.
-  ##           SMOKE(N, 1) is the same except for a zero (N,1) element.
-  ##           The eigenvalues of SMOKE(N, 1) are the N'th roots of unity;
-  ##           those of SMOKE(N) are the N'th roots of unity times 2^(1/N).
+  ##   SMOKE(N) is an N-by-N matrix with 1s on the
+  ##   superdiagonal, 1 in the (N,1) position, and powers of
+  ##   roots of unity along the diagonal.
+  ##   SMOKE(N, 1) is the same except for a zero (N,1) element.
+  ##   The eigenvalues of SMOKE(N, 1) are the N'th roots of unity;
+  ##   those of SMOKE(N) are the N'th roots of unity times 2^(1/N).
   ##
-  ##           Try PS(SMOKE(32)).  For SMOKE(N, 1) the pseudospectrum looks
-  ##           like a sausage folded back on itself.
-  ##           GERSH(SMOKE(N, 1)) is interesting.
+  ##   Try PS(SMOKE(32)).  For SMOKE(N, 1) the pseudospectrum looks
+  ##   like a sausage folded back on itself.
+  ##   GERSH(SMOKE(N, 1)) is interesting.
   ##
-  ##           Reference:
-  ##           L. Reichel and L.N. Trefethen, Eigenvalues and pseudo-eigenvalues of
-  ##           Toeplitz matrices, Linear Algebra and Appl., 162-164:153-185, 1992.
+  ##   Reference:
+  ##   L. Reichel and L.N. Trefethen, Eigenvalues and pseudo-eigenvalues of
+  ##   Toeplitz matrices, Linear Algebra and Appl., 162-164:153-185, 1992.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for smoke matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for smoke matrix.");
   elseif (! isnumeric (n) || ! isscalar (n))
     error ("gallery: K must be a numeric scalar for smoke matrix.");
   endif
@@ -2403,28 +2403,28 @@ function A = smoke (n, k = 0)
     otherwise,
       error ("gallery: K must have a value of 0 or 1 for smoke matrix.");
   endswitch
 endfunction
 
 function T = toeppd (n, m = n, w = rand (m,1), theta = rand (m,1))
   ## NOTE: this function was named pdtoep in the original Test Matrix Toolbox
   ## TOEPPD   Symmetric positive definite Toeplitz matrix.
-  ##          TOEPPD(N, M, W, THETA) is an N-by-N symmetric positive (semi-)
-  ##          definite (SPD) Toeplitz matrix, comprised of the sum of M rank 2
-  ##          (or, for certain THETA, rank 1) SPD Toeplitz matrices.
-  ##          Specifically,
-  ##                  T = W(1)*T(THETA(1)) + ... + W(M)*T(THETA(M)),
-  ##          where T(THETA(k)) has (i,j) element COS(2*PI*THETA(k)*(i-j)).
-  ##          Defaults: M = N, W = RAND(M,1), THETA = RAND(M,1).
+  ##   TOEPPD(N, M, W, THETA) is an N-by-N symmetric positive (semi-)
+  ##   definite (SPD) Toeplitz matrix, comprised of the sum of M rank 2
+  ##   (or, for certain THETA, rank 1) SPD Toeplitz matrices.
+  ##   Specifically,
+  ##           T = W(1)*T(THETA(1)) + ... + W(M)*T(THETA(M)),
+  ##   where T(THETA(k)) has (i,j) element COS(2*PI*THETA(k)*(i-j)).
+  ##   Defaults: M = N, W = RAND(M,1), THETA = RAND(M,1).
   ##
-  ##          Reference:
-  ##          G. Cybenko and C.F. Van Loan, Computing the minimum eigenvalue of
-  ##          a symmetric positive definite Toeplitz matrix, SIAM J. Sci. Stat.
-  ##          Comput., 7 (1986), pp. 123-131.
+  ##   Reference:
+  ##   G. Cybenko and C.F. Van Loan, Computing the minimum eigenvalue of
+  ##   a symmetric positive definite Toeplitz matrix, SIAM J. Sci. Stat.
+  ##   Comput., 7 (1986), pp. 123-131.
 
   if (nargin < 1 || nargin > 4)
     error ("gallery: 1 to 4 arguments are required for toeppd matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be a numeric integer for toeppd matrix.");
   elseif (! isnumeric (m) || ! isscalar (m) || fix (m) != m)
     error ("gallery: M must be a numeric integer for toeppd matrix.");
   elseif (numel (w) != m || numel (theta) != m)
@@ -2437,67 +2437,67 @@ function T = toeppd (n, m = n, w = rand 
   for i = 1:m
     T = T + w(i) * cos (theta(i)*E);
   endfor
 endfunction
 
 function P = toeppen (n, a = 1, b = -10, c = 0, d = 10, e = 1)
   ## NOTE: this function was named pentoep in the original Test Matrix Toolbox
   ## TOEPPEN   Pentadiagonal Toeplitz matrix (sparse).
-  ##           P = TOEPPEN(N, A, B, C, D, E) is the N-by-N pentadiagonal
-  ##           Toeplitz matrix with diagonals composed of the numbers
-  ##           A =: P(3,1), B =: P(2,1), C =: P(1,1), D =: P(1,2), E =: P(1,3).
-  ##           Default: (A,B,C,D,E) = (1,-10,0,10,1) (a matrix of Rutishauser).
-  ##                     This matrix has eigenvalues lying approximately on
-  ##                     the line segment 2*cos(2*t) + 20*i*sin(t).
+  ##   P = TOEPPEN(N, A, B, C, D, E) is the N-by-N pentadiagonal
+  ##   Toeplitz matrix with diagonals composed of the numbers
+  ##   A =: P(3,1), B =: P(2,1), C =: P(1,1), D =: P(1,2), E =: P(1,3).
+  ##   Default: (A,B,C,D,E) = (1,-10,0,10,1) (a matrix of Rutishauser).
+  ##             This matrix has eigenvalues lying approximately on
+  ##             the line segment 2*cos(2*t) + 20*i*sin(t).
   ##
-  ##           Interesting plots are
-  ##           PS(FULL(TOEPPEN(32,0,1,0,0,1/4)))  - `triangle'
-  ##           PS(FULL(TOEPPEN(32,0,1/2,0,0,1)))  - `propeller'
-  ##           PS(FULL(TOEPPEN(32,0,1/2,1,1,1)))  - `fish'
+  ##   Interesting plots are
+  ##   PS(FULL(TOEPPEN(32,0,1,0,0,1/4)))  - `triangle'
+  ##   PS(FULL(TOEPPEN(32,0,1/2,0,0,1)))  - `propeller'
+  ##   PS(FULL(TOEPPEN(32,0,1/2,1,1,1)))  - `fish'
   ##
-  ##           References:
-  ##           R.M. Beam and R.F. Warming, The asymptotic spectra of
-  ##              banded Toeplitz and quasi-Toeplitz matrices, SIAM J. Sci.
-  ##              Comput. 14 (4), 1993, pp. 971-1006.
-  ##           H. Rutishauser, On test matrices, Programmation en Mathematiques
-  ##              Numeriques, Editions Centre Nat. Recherche Sci., Paris, 165,
-  ##              1966, pp. 349-365.
+  ##   References:
+  ##   R.M. Beam and R.F. Warming, The asymptotic spectra of
+  ##      banded Toeplitz and quasi-Toeplitz matrices, SIAM J. Sci.
+  ##      Comput. 14 (4), 1993, pp. 971-1006.
+  ##   H. Rutishauser, On test matrices, Programmation en Mathematiques
+  ##      Numeriques, Editions Centre Nat. Recherche Sci., Paris, 165,
+  ##      1966, pp. 349-365.
 
   if (nargin < 1 || nargin > 6)
     error ("gallery: 1 to 6 arguments are required for toeppen matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be a numeric integer for toeppen matrix.");
   elseif (any (! cellfun ("isnumeric", {a b c d e})) || any (cellfun ("numel", {a b c d e}) != 1))
     error ("gallery: A, B, C, D and E must be numeric scalars for toeppen matrix.");
   endif
 
   P = spdiags ([a*ones(n,1) b*ones(n,1) c*ones(n,1) d*ones(n,1) e*ones(n,1)],
                 -2:2, n, n);
 endfunction
 
 function T = tridiag (n, x = -1, y = 2, z = -1)
   ## TRIDIAG  Tridiagonal matrix (sparse).
-  ##          TRIDIAG(X, Y, Z) is the tridiagonal matrix with subdiagonal X,
-  ##          diagonal Y, and superdiagonal Z.
-  ##          X and Z must be vectors of dimension one less than Y.
-  ##          Alternatively TRIDIAG(N, C, D, E), where C, D, and E are all
-  ##          scalars, yields the Toeplitz tridiagonal matrix of order N
-  ##          with subdiagonal elements C, diagonal elements D, and superdiagonal
-  ##          elements E.   This matrix has eigenvalues (Todd 1977)
-  ##                   D + 2*SQRT(C*E)*COS(k*PI/(N+1)), k=1:N.
-  ##          TRIDIAG(N) is the same as TRIDIAG(N,-1,2,-1), which is
-  ##          a symmetric positive definite M-matrix (the negative of the
-  ##          second difference matrix).
+  ##   TRIDIAG(X, Y, Z) is the tridiagonal matrix with subdiagonal X,
+  ##   diagonal Y, and superdiagonal Z.
+  ##   X and Z must be vectors of dimension one less than Y.
+  ##   Alternatively TRIDIAG(N, C, D, E), where C, D, and E are all
+  ##   scalars, yields the Toeplitz tridiagonal matrix of order N
+  ##   with subdiagonal elements C, diagonal elements D, and superdiagonal
+  ##   elements E.   This matrix has eigenvalues (Todd 1977)
+  ##            D + 2*SQRT(C*E)*COS(k*PI/(N+1)), k=1:N.
+  ##   TRIDIAG(N) is the same as TRIDIAG(N,-1,2,-1), which is
+  ##   a symmetric positive definite M-matrix (the negative of the
+  ##   second difference matrix).
   ##
-  ##          References:
-  ##          J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
-  ##            Birkhauser, Basel, and Academic Press, New York, 1977, p. 155.
-  ##          D.E. Rutherford, Some continuant determinants arising in physics and
-  ##            chemistry---II, Proc. Royal Soc. Edin., 63, A (1952), pp. 232-241.
+  ##   References:
+  ##   J. Todd, Basic Numerical Mathematics, Vol. 2: Numerical Algebra,
+  ##     Birkhauser, Basel, and Academic Press, New York, 1977, p. 155.
+  ##   D.E. Rutherford, Some continuant determinants arising in physics and
+  ##     chemistry---II, Proc. Royal Soc. Edin., 63, A (1952), pp. 232-241.
 
   if (nargin != 1 && nargin != 3 && nargin != 4)
     error ("gallery: 1, 3, or 4 arguments are required for tridiag matrix.");
   elseif (nargin == 3)
     z = y;
     y = x;
     x = n;
   endif
@@ -2519,43 +2519,43 @@ function T = tridiag (n, x = -1, y = 2, 
 
   ##  T = diag (x, -1) + diag (y) + diag (z, 1);  # For non-sparse matrix.
   n = numel (y);
   T = spdiags ([[x;0] y [0;z]], -1:1, n, n);
 endfunction
 
 function t = triw (n, alpha = -1, k = n(end) - 1)
   ## TRIW   Upper triangular matrix discussed by Wilkinson and others.
-  ##        TRIW(N, ALPHA, K) is the upper triangular matrix with ones on
-  ##        the diagonal and ALPHAs on the first K >= 0 superdiagonals.
-  ##        N may be a 2-vector, in which case the matrix is N(1)-by-N(2) and
-  ##        upper trapezoidal.
-  ##        Defaults: ALPHA = -1,
-  ##                  K = N - 1     (full upper triangle).
-  ##        TRIW(N) is a matrix discussed by Kahan, Golub and Wilkinson.
+  ##   TRIW(N, ALPHA, K) is the upper triangular matrix with ones on
+  ##   the diagonal and ALPHAs on the first K >= 0 superdiagonals.
+  ##   N may be a 2-vector, in which case the matrix is N(1)-by-N(2) and
+  ##   upper trapezoidal.
+  ##   Defaults: ALPHA = -1,
+  ##             K = N - 1     (full upper triangle).
+  ##   TRIW(N) is a matrix discussed by Kahan, Golub and Wilkinson.
   ##
-  ##        Ostrowski (1954) shows that
-  ##          COND(TRIW(N,2)) = COT(PI/(4*N))^2,
-  ##        and for large ABS(ALPHA),
-  ##          COND(TRIW(N,ALPHA)) is approximately ABS(ALPHA)^N*SIN(PI/(4*N-2)).
+  ##   Ostrowski (1954) shows that
+  ##     COND(TRIW(N,2)) = COT(PI/(4*N))^2,
+  ##   and for large ABS(ALPHA),
+  ##     COND(TRIW(N,ALPHA)) is approximately ABS(ALPHA)^N*SIN(PI/(4*N-2)).
   ##
-  ##        Adding -2^(2-N) to the (N,1) element makes TRIW(N) singular,
-  ##        as does adding -2^(1-N) to all elements in the first column.
+  ##   Adding -2^(2-N) to the (N,1) element makes TRIW(N) singular,
+  ##   as does adding -2^(1-N) to all elements in the first column.
   ##
-  ##        References:
-  ##        G.H. Golub and J.H. Wilkinson, Ill-conditioned eigensystems and the
-  ##           computation of the Jordan canonical form, SIAM Review,
-  ##           18(4), 1976, pp. 578-619.
-  ##        W. Kahan, Numerical linear algebra, Canadian Math. Bulletin,
-  ##           9 (1966), pp. 757-801.
-  ##        A.M. Ostrowski, On the spectrum of a one-parametric family of
-  ##           matrices, J. Reine Angew. Math., 193 (3/4), 1954, pp. 143-160.
-  ##        J.H. Wilkinson, Singular-value decomposition---basic aspects,
-  ##           in D.A.H. Jacobs, ed., Numerical Software---Needs and Availability,
-  ##           Academic Press, London, 1978, pp. 109-135.
+  ##   References:
+  ##   G.H. Golub and J.H. Wilkinson, Ill-conditioned eigensystems and the
+  ##      computation of the Jordan canonical form, SIAM Review,
+  ##      18(4), 1976, pp. 578-619.
+  ##   W. Kahan, Numerical linear algebra, Canadian Math. Bulletin,
+  ##      9 (1966), pp. 757-801.
+  ##   A.M. Ostrowski, On the spectrum of a one-parametric family of
+  ##      matrices, J. Reine Angew. Math., 193 (3/4), 1954, pp. 143-160.
+  ##   J.H. Wilkinson, Singular-value decomposition---basic aspects,
+  ##      in D.A.H. Jacobs, ed., Numerical Software---Needs and Availability,
+  ##      Academic Press, London, 1978, pp. 109-135.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for triw matrix.");
   elseif (! isnumeric (n) || all (numel (n) != [1 2]))
     error ("gallery: N must be a 1 or 2 elements vector for triw matrix.");
   elseif (! isscalar (alpha))
     error ("gallery: ALPHA must be a scalar for triw matrix.");
   elseif (! isscalar (k) || ! isnumeric (k) || fix (k) != k || k < 0)
@@ -2605,89 +2605,89 @@ function A = uniformdata (varargin)
     A = rand (varargin{:});
   unwind_protect_cleanup
     rand ("state", randstate);
   end_unwind_protect
 
 endfunction
 
 function A = wathen (nx, ny, k = 0)
-  ## # WATHEN returns the Wathen matrix.
+  ## WATHEN returns the Wathen matrix.
   ##
-  ##   Discussion:
+  ## Discussion:
   ##
-  ##     The Wathen matrix is a finite element matrix which is sparse.
+  ##   The Wathen matrix is a finite element matrix which is sparse.
   ##
-  ##     The entries of the matrix depend in part on a physical quantity
-  ##     related to density.  That density is here assigned random values between
-  ##     0 and 100.
+  ##   The entries of the matrix depend in part on a physical quantity
+  ##   related to density.  That density is here assigned random values between
+  ##   0 and 100.
   ##
-  ##     A = WATHEN ( NX, NY ) is a sparse random N-by-N finite element matrix
-  ##     where N = 3*NX*NY + 2*NX + 2*NY + 1.
+  ##   A = WATHEN ( NX, NY ) is a sparse random N-by-N finite element matrix
+  ##   where N = 3*NX*NY + 2*NX + 2*NY + 1.
   ##
-  ##     A is the consistent mass matrix for a regular NX-by-NY
-  ##     grid of 8-node (serendipity) elements in 2 space dimensions.
+  ##   A is the consistent mass matrix for a regular NX-by-NY
+  ##   grid of 8-node (serendipity) elements in 2 space dimensions.
   ##
-  ##     Here is an illustration for NX = 3, NX = 2:
+  ##   Here is an illustration for NX = 3, NX = 2:
   ##
-  ##      23-24-25-26-27-28-29
-  ##       |     |     |     |
-  ##      19    20    21    22
-  ##       |     |     |     |
-  ##      12-13-14-15-16-17-18
-  ##       |     |     |     |
-  ##       8     9    10    11
-  ##       |     |     |     |
-  ##       1--2--3--4--5--6--7
+  ##    23-24-25-26-27-28-29
+  ##     |     |     |     |
+  ##    19    20    21    22
+  ##     |     |     |     |
+  ##    12-13-14-15-16-17-18
+  ##     |     |     |     |
+  ##     8     9    10    11
+  ##     |     |     |     |
+  ##     1--2--3--4--5--6--7
   ##
-  ##     For this example, the total number of nodes is, as expected,
+  ##   For this example, the total number of nodes is, as expected,
   ##
-  ##       N = 3 * 3 * 2 + 2 * 2 + 2 * 3 + 1 = 29.
+  ##     N = 3 * 3 * 2 + 2 * 2 + 2 * 3 + 1 = 29.
   ##
-  ##     A is symmetric positive definite for any (positive) values of
-  ##     the density, RHO(NX,NY), which is chosen randomly in this routine.
+  ##   A is symmetric positive definite for any (positive) values of
+  ##   the density, RHO(NX,NY), which is chosen randomly in this routine.
   ##
-  ##     In particular, if D = DIAG(DIAG(A)), then
-  ##       0.25 <= EIG(INV(D)*A) <= 4.5
-  ##     for any positive integers NX and NY and any densities RHO(NX,NY).
+  ##   In particular, if D = DIAG(DIAG(A)), then
+  ##     0.25 <= EIG(INV(D)*A) <= 4.5
+  ##   for any positive integers NX and NY and any densities RHO(NX,NY).
   ##
-  ##     A = WATHEN ( NX, NY, 1 ) returns the diagonally scaled matrix.
+  ##   A = WATHEN ( NX, NY, 1 ) returns the diagonally scaled matrix.
   ##
-  ##   Modified:
+  ## Modified:
   ##
-  ##     17 September 2007
+  ##   17 September 2007
   ##
-  ##   Author:
+  ## Author:
   ##
-  ##     Nicholas Higham
+  ##   Nicholas Higham
   ##
-  ##   Reference:
+  ## Reference:
   ##
-  ##     Nicholas Higham,
-  ##     Algorithm 694: A Collection of Test Matrices in MATLAB,
-  ##     ACM Transactions on Mathematical Software,
-  ##     Volume 17, Number 3, September 1991, pages 289-305.
+  ##   Nicholas Higham,
+  ##   Algorithm 694: A Collection of Test Matrices in MATLAB,
+  ##   ACM Transactions on Mathematical Software,
+  ##   Volume 17, Number 3, September 1991, pages 289-305.
   ##
-  ##     Andrew Wathen,
-  ##     Realistic eigenvalue bounds for the Galerkin mass matrix,
-  ##     IMA Journal of Numerical Analysis,
-  ##     Volume 7, 1987, pages 449-457.
+  ##   Andrew Wathen,
+  ##   Realistic eigenvalue bounds for the Galerkin mass matrix,
+  ##   IMA Journal of Numerical Analysis,
+  ##   Volume 7, 1987, pages 449-457.
   ##
-  ##   Parameters:
+  ## Parameters:
   ##
-  ##     Input, integer NX, NY, the number of elements in the X and Y directions
-  ##     of the finite element grid.  NX and NY must each be at least 1.
+  ##   Input, integer NX, NY, the number of elements in the X and Y directions
+  ##   of the finite element grid.  NX and NY must each be at least 1.
   ##
-  ##     Optional input, integer K, is used to request that the diagonally scaled
-  ##     version of the matrix be returned.  This happens if K is specified with
-  ##     the value 1.
+  ##   Optional input, integer K, is used to request that the diagonally scaled
+  ##   version of the matrix be returned.  This happens if K is specified with
+  ##   the value 1.
   ##
-  ##     Output, sparse real A(N,N), the matrix.  The dimension N is determined by
-  ##     NX and NY, as described above.  A is stored in the MATLAB sparse matrix
-  ##     format.
+  ##   Output, sparse real A(N,N), the matrix.  The dimension N is determined by
+  ##   NX and NY, as described above.  A is stored in the MATLAB sparse matrix
+  ##   format.
 
   if (nargin < 2 || nargin > 3)
     error ("gallery: 2 or 3 arguments are required for wathen matrix.");
   elseif (! isnumeric (nx) || ! isscalar (nx) || nx < 1)
     error ("gallery: NX must be a positive scalar for wathen matrix.");
   elseif (! isnumeric (ny) || ! isscalar (ny) || ny < 1)
     error ("gallery: NY must be a positive scalar for wathen matrix.");
   elseif (! isscalar (k))
@@ -2741,29 +2741,29 @@ function A = wathen (nx, ny, k = 0)
   ## If requested, return A with diagonal scaling.
   if (k)
     A = diag (diag (A)) \ A;
   endif
 endfunction
 
 function [A, b] = wilk (n)
   ## WILK   Various specific matrices devised/discussed by Wilkinson.
-  ##        [A, b] = WILK(N) is the matrix or system of order N.
-  ##        N = 3: upper triangular system Ux=b illustrating inaccurate solution.
-  ##        N = 4: lower triangular system Lx=b, ill-conditioned.
-  ##        N = 5: HILB(6)(1:5,2:6)*1.8144.  Symmetric positive definite.
-  ##        N = 21: W21+, tridiagonal.   Eigenvalue problem.
+  ##   [A, b] = WILK(N) is the matrix or system of order N.
+  ##   N = 3: upper triangular system Ux=b illustrating inaccurate solution.
+  ##   N = 4: lower triangular system Lx=b, ill-conditioned.
+  ##   N = 5: HILB(6)(1:5,2:6)*1.8144.  Symmetric positive definite.
+  ##   N = 21: W21+, tridiagonal.   Eigenvalue problem.
   ##
-  ##        References:
-  ##        J.H. Wilkinson, Error analysis of direct methods of matrix inversion,
-  ##           J. Assoc. Comput. Mach., 8 (1961),  pp. 281-330.
-  ##        J.H. Wilkinson, Rounding Errors in Algebraic Processes, Notes on Applied
-  ##           Science No. 32, Her Majesty's Stationery Office, London, 1963.
-  ##        J.H. Wilkinson, The Algebraic Eigenvalue Problem, Oxford University
-  ##           Press, 1965.
+  ##   References:
+  ##   J.H. Wilkinson, Error analysis of direct methods of matrix inversion,
+  ##      J. Assoc. Comput. Mach., 8 (1961),  pp. 281-330.
+  ##   J.H. Wilkinson, Rounding Errors in Algebraic Processes, Notes on Applied
+  ##      Science No. 32, Her Majesty's Stationery Office, London, 1963.
+  ##   J.H. Wilkinson, The Algebraic Eigenvalue Problem, Oxford University
+  ##      Press, 1965.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for wilk matrix.");
   elseif (! isnumeric (n) || ! isscalar (n))
     error ("gallery: N must be a numeric scalar for wilk matrix.");
   endif
 
   if (n == 3)
@@ -2802,31 +2802,31 @@ function [A, b] = wilk (n)
   else
     error ("gallery: unknown N '%d' for wilk matrix.", n);
   endif
 endfunction
 
 ## NOTE: bandred is part of the Test Matrix Toolbox and is used by randsvd()
 function A = bandred (A, kl, ku)
   ## BANDRED  Band reduction by two-sided unitary transformations.
-  ##          B = BANDRED(A, KL, KU) is a matrix unitarily equivalent to A
-  ##          with lower bandwidth KL and upper bandwidth KU
-  ##          (i.e. B(i,j) = 0 if i > j+KL or j > i+KU).
-  ##          The reduction is performed using Householder transformations.
-  ##          If KU is omitted it defaults to KL.
+  ##   B = BANDRED(A, KL, KU) is a matrix unitarily equivalent to A
+  ##   with lower bandwidth KL and upper bandwidth KU
+  ##   (i.e. B(i,j) = 0 if i > j+KL or j > i+KU).
+  ##   The reduction is performed using Householder transformations.
+  ##   If KU is omitted it defaults to KL.
   ##
-  ##          Called by RANDSVD.
-  ##          This is a `standard' reduction.  Cf. reduction to bidiagonal form
-  ##          prior to computing the SVD.  This code is a little wasteful in that
-  ##          it computes certain elements which are immediately set to zero!
+  ##   Called by RANDSVD.
+  ##   This is a `standard' reduction.  Cf. reduction to bidiagonal form
+  ##   prior to computing the SVD.  This code is a little wasteful in that
+  ##   it computes certain elements which are immediately set to zero!
   ##
-  ##          Reference:
-  ##          G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
-  ##          Johns Hopkins University Press, Baltimore, Maryland, 1989.
-  ##          Section 5.4.3.
+  ##   Reference:
+  ##   G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
+  ##   Johns Hopkins University Press, Baltimore, Maryland, 1989.
+  ##   Section 5.4.3.
 
   ##  Check for special case where order of left/right transformations matters.
   ##  Easiest approach is to work on the transpose, flipping back at the end.
   flip = false;
   if (ku == 0)
     flip = true;
     A = A';
     [ku, kl] = deal (kl, ku);
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -83,15 +83,15 @@ endfunction
 %! for i = 3:30
 %!   A = magic (i);
 %!   assert (norm(diff([sum(diag(A)),sum(diag(flipud(A))),sum(A),sum(A')])),0);
 %! endfor
 
 %!assert (isempty (magic (0)))
 %!assert (magic (1), 1)
 
-%% Test input validation
+## Test input validation
 %!error magic ()
 %!error magic (1, 2)
 %!error <N must be a positive integer not equal to 2> magic (1.5)
 %!error <N must be a positive integer not equal to 2> magic (-1)
 %!error <N must be a positive integer not equal to 2> magic (2)
 
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -75,16 +75,16 @@ endfunction
 
 %!assert (pascal (3,-1), [1,0,0;1,1,0;1,2,1])
 %!assert (pascal (3,0), [1,1,1;1,2,3;1,3,6])
 %!assert (pascal (3,0), pascal (3))
 %!assert (pascal (3,1), [1,0,0;1,-1,0;1,-2,1])
 %!assert (pascal (3,2), [1,1,1;-2,-1,0;1,0,0])
 %!assert (pascal (0,2), [])
 
-%% Test input validation
+## Test input validation
 %!error pascal ()
 %!error pascal (1,2,3)
 %!error <N and T must be scalars> pascal ([1 2])
 %!error <N and T must be scalars> pascal (1, [1 2])
 %!error <expecting T to be> pascal (3,-2)
 %!error <expecting T to be> pascal (3,4)
 
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -120,15 +120,15 @@ function retval = toeplitz (c, r)
 
 endfunction
 
 
 %!assert (toeplitz (1), [1])
 %!assert (toeplitz ([1, 2, 3], [1; -3; -5]), [1, -3, -5; 2, 1, -3; 3, 2, 1])
 %!assert (toeplitz ([1, 2, 3], [1; -3i; -5i]), [1, -3i, -5i; 2, 1, -3i; 3, 2, 1])
 
-%% Test input validation
+## Test input validation
 %!error toeplitz ()
 %!error toeplitz (1, 2, 3)
 %!error <C must be a vector> toeplitz ([1, 2; 3, 4])
 %!error <C and R must be vectors> toeplitz ([1, 2; 3, 4], 1)
 %!error <C and R must be vectors> toeplitz (1, [1, 2; 3, 4])
 
diff --git a/scripts/special-matrix/wilkinson.m b/scripts/special-matrix/wilkinson.m
--- a/scripts/special-matrix/wilkinson.m
+++ b/scripts/special-matrix/wilkinson.m
@@ -47,15 +47,15 @@ endfunction
 
 
 %!assert (wilkinson (0), [])
 %!assert (wilkinson (1), 0)
 %!assert (wilkinson (2), [0.5,1;1,0.5])
 %!assert (wilkinson (3), [1,1,0;1,0,1;0,1,1])
 %!assert (wilkinson (4), [1.5,1,0,0;1,0.5,1,0;0,1,0.5,1;0,0,1,1.5])
 
-%% Test input validation
+## Test input validation
 %!error wilkinson ()
 %!error wilkinson (1,2)
 %!error <N must be a non-negative integer> wilkinson (ones (2))
 %!error <N must be a non-negative integer> wilkinson (-1)
 %!error <N must be a non-negative integer> wilkinson (1.5)
 
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -70,16 +70,16 @@ endfunction
 %!assert (center (single ([1,2,3])), single ([-1,0,1]))
 %!assert (center (int8 ([1,2,3])), [-1,0,1])
 %!assert (center (logical ([1, 0, 0, 1])), [0.5, -0.5, -0.5, 0.5])
 %!assert (center (ones (3,2,0,2)), zeros (3,2,0,2))
 %!assert (center (ones (3,2,0,2, "single")), zeros (3,2,0,2, "single"))
 %!assert (center (magic (3)), [3,-4,1;-2,0,2;-1,4,-3])
 %!assert (center ([1 2 3; 6 5 4], 2), [-1 0 1; 1 0 -1])
 
-%% Test input validation
+## Test input validation
 %!error center ()
 %!error center (1, 2, 3)
 %!error center (1, ones (2,2))
 %!error center (1, 1.5)
 %!error center (1, 0)
 %!error center (1, 3)
 
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -46,12 +46,12 @@ function y = cloglog (x)
 
 endfunction
 
 
 %!assert (cloglog (0), -Inf)
 %!assert (cloglog (1), Inf)
 %!assert (cloglog (1/e), 0)
 
-%% Test input validation
+## Test input validation
 %!error cloglog ()
 %!error cloglog (1, 2)
 
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
--- a/scripts/statistics/base/corr.m
+++ b/scripts/statistics/base/corr.m
@@ -98,15 +98,15 @@ endfunction
 %! y = single ([3:-1:1]');
 %! assert (corr (x, y), single (-1), 5*eps);
 %! assert (corr (x, flipud (y)), single (1), 5*eps);
 %! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps);
 
 %!assert (corr (5), 1)
 %!assert (corr (single (5)), single (1))
 
-%% Test input validation
+## Test input validation
 %!error corr ()
 %!error corr (1, 2, 3)
 %!error corr ([1; 2], ["A", "B"])
 %!error corr (ones (2,2,2))
 %!error corr (ones (2,2), ones (2,2,2))
 
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -156,17 +156,17 @@ endfunction
 
 %!test
 %! x = [1:5];
 %! c = cov (x, 0);
 %! assert (c, 2.5);
 %! c = cov (x, 1);
 %! assert (c, 2);
 
-%% Test input validation
+## Test input validation
 %!error cov ()
 %!error cov (1, 2, 3, 4)
 %!error cov ([1; 2], ["A", "B"])
 %!error cov (ones (2,2,2))
 %!error cov (ones (2,2), ones (2,2,2))
 %!error cov (1, 3)
 %!error cov (ones (2,2), ones (3,2))
 
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -77,17 +77,17 @@ function [beta, v, r] = gls (y, x, o)
   endif
 
   [rx, cx] = size (x);
   [ry, cy] = size (y);
   [ro, co] = size (o);
   if (rx != ry)
     error ("gls: number of rows of X and Y must be equal");
   endif
-  if (!issquare (o) || ro != ry*cy)
+  if (! issquare (o) || ro != ry*cy)
     error ("gls: matrix O must be square matrix with rows = rows (Y) * cols (Y)");
   endif
 
   if (isinteger (x))
     x = double (x);
   endif
   if (isinteger (y))
     y = double (y);
@@ -124,17 +124,17 @@ endfunction
 
 %!test
 %! x = [1:5]';
 %! y = 3*x + 2;
 %! x = [x, ones(5,1)];
 %! o = diag (ones (5,1));
 %! assert (gls (y,x,o), [3; 2], 50*eps);
 
-%% Test input validation
+## Test input validation
 %!error gls ()
 %!error gls (1)
 %!error gls (1, 2)
 %!error gls (1, 2, 3, 4)
 %!error gls ([true, true], [1, 2], ones (2))
 %!error gls ([1, 2], [true, true], ones (2))
 %!error gls ([1, 2], [1, 2], true (2))
 %!error gls (ones (2,2,2), ones (2,2), ones (4,4))
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -43,31 +43,31 @@
 ## @end deftypefn
 
 function [n, idx] = histc (x, edges, dim)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  if (!isreal (x))
+  if (! isreal (x))
     error ("histc: X argument must be real-valued, not complex");
   endif
 
   num_edges = numel (edges);
   if (num_edges == 0)
     error ("histc: EDGES must not be empty");
   endif
 
-  if (!isreal (edges))
+  if (! isreal (edges))
     error ("histc: EDGES must be real-valued, not complex");
   else
     ## Make sure 'edges' is sorted
     edges = edges(:);
-    if (!issorted (edges) || edges(1) > edges(end))
+    if (! issorted (edges) || edges(1) > edges(end))
       warning ("histc: edge values not sorted on input");
       edges = sort (edges);
     endif
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin < 3)
@@ -104,23 +104,23 @@ function [n, idx] = histc (x, edges, dim
     endfor
     idx2 = cell (length (sz) - dim);
     for k = 1:length (idx2)
       idx2{k} = 1:sz(k+dim);
     endfor
 
     ## Compute the histograms
     for k = 1:num_edges-1
-      b = (edges (k) <= x & x < edges (k+1));
+      b = (edges(k) <= x & x < edges(k+1));
       n(idx1{:}, k, idx2{:}) = sum (b, dim);
       if (nargout > 1)
         idx(b) = k;
       endif
     endfor
-    b = (x == edges (end));
+    b = (x == edges(end));
     n(idx1{:}, num_edges, idx2{:}) = sum (b, dim);
     if (nargout > 1)
       idx(b) = num_edges;
     endif
 
   else
 
     ## This is the O(M*log(N) + N) algorithm.
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -80,19 +80,20 @@ function y = iqr (x, dim)
   endfor
 
 endfunction
 
 
 %!assert (iqr (1:101), 50)
 %!assert (iqr (single (1:101)), single (50))
 
-%%!test
-%%! x = [1:100];
-%%! n = iqr (x, 0:10);
-%%! assert (n, [repmat(100, 1, 10), 1]);
+## FIXME: iqr throws horrible error when running across a dimension that is 1.
+%!test
+%! x = [1:100]';
+%! assert (iqr (x, 1), 50);
+%! assert (iqr (x', 2), 50);
 
 %!error iqr ()
 %!error iqr (1, 2, 3)
 %!error iqr (1)
 %!error iqr (['A'; 'B'])
 %!error iqr (1:10, 3)
 
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -119,17 +119,17 @@ endfunction
 %! x = [1:2:10];
 %! y = [100:10:149];
 %! assert (kendall (x,y), 1, 5*eps);
 %! assert (kendall (x,fliplr (y)), -1, 5*eps);
 
 %!assert (kendall (logical (1)), 1)
 %!assert (kendall (single (1)), single (1))
 
-%% Test input validation
+## Test input validation
 %!error kendall ()
 %!error kendall (1, 2, 3)
 %!error kendall (['A'; 'B'])
 %!error kendall (ones (2,1), ['A'; 'B'])
 %!error kendall (ones (2,2,2))
 %!error kendall (ones (2,2), ones (2,2,2))
 %!error kendall (ones (2,2), ones (3,2))
 
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -87,17 +87,17 @@ function y = kurtosis (x, flag, dim)
 
   if (! (isnumeric (x) || islogical (x)))
     error ("kurtosis: X must be a numeric vector or matrix");
   endif
 
   if (nargin < 2 || isempty (flag))
     flag = 1;  # default: do not use the "bias corrected" version
   else
-    if ((! isscalar (flag)) || (flag != 0 && flag != 1))
+    if (! isscalar (flag) || (flag != 0 && flag != 1))
       error ("kurtosis: FLAG must be 0 or 1");
     endif
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin < 3)
     ## Find the first non-singleton dimension.
@@ -154,17 +154,17 @@ endfunction
 %! unwind_protect
 %!   lastwarn ("");  # clear last warning
 %!   kurtosis (1);
 %!   assert (lastwarn (), "");
 %! unwind_protect_cleanup
 %!   warning (wstate, "Octave:divide-by-zero");
 %! end_unwind_protect
 
-%% Test input validation
+## Test input validation
 %!error kurtosis ()
 %!error kurtosis (1, 2, 3)
 %!error <X must be a numeric vector or matrix> kurtosis (['A'; 'B'])
 %!error <FLAG must be 0 or 1> kurtosis (1, 2)
 %!error <FLAG must be 0 or 1> kurtosis (1, [1 0])
 %!error <DIM must be an integer> kurtosis (1, [], ones (2,2))
 %!error <DIM must be an integer> kurtosis (1, [], 1.5)
 %!error <DIM must be .* a valid dimension> kurtosis (1, [], 0)
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -49,12 +49,12 @@ endfunction
 
 
 %!test
 %! p = [0.01:0.01:0.99];
 %! assert (logit (p), log (p ./ (1-p)), 25*eps);
 
 %!assert (logit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, +Inf, NaN])
 
-%% Test input validation
+## Test input validation
 %!error logit ()
 %!error logit (1, 2)
 
diff --git a/scripts/statistics/base/lscov.m b/scripts/statistics/base/lscov.m
--- a/scripts/statistics/base/lscov.m
+++ b/scripts/statistics/base/lscov.m
@@ -108,16 +108,17 @@ function [x, stdx, mse, S] = lscov (A, b
       S = nan (p, p, k);
       for i = 1:k
         S(:, :, i) = mse(i) * s;
       endfor
     endif
   endif
 endfunction
 
+
 %!test
 %! ## Longley data from the NIST Statistical Reference Dataset
 %! Z = [  60323    83.0   234289   2356     1590    107608  1947
 %!        61122    88.5   259426   2325     1456    108632  1948
 %!        60171    88.2   258054   3682     1616    109773  1949
 %!        61187    89.5   284599   3351     1650    110929  1950
 %!        63221    96.2   328975   2099     3099    112075  1951
 %!        63639    98.1   346999   1932     3594    113270  1952
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -65,17 +65,17 @@ function retval = mahalanobis (x, y)
 
   winv = inv (w);
 
   retval = (xm - ym) * winv * (xm - ym)';
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error mahalanobis ()
 %!error mahalanobis (1, 2, 3)
 %!error mahalanobis ('A', 'B')
 %!error mahalanobis ([1, 2], ['A', 'B'])
 %!error mahalanobis (ones (2,2,2))
 %!error mahalanobis (ones (2,2), ones (2,2,2))
 %!error mahalanobis (ones (2,2), ones (2,3))
 
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -140,17 +140,17 @@ endfunction
 
 %!assert (mean (magic (3), 1), [5, 5, 5])
 %!assert (mean (magic (3), 2), [5; 5; 5])
 %!assert (mean ([2 8], "g"), 4)
 %!assert (mean ([4 4 2], "h"), 3)
 %!assert (mean (logical ([1 0 1 1])), 0.75)
 %!assert (mean (single ([1 0 1 1])), single (0.75))
 
-%% Test input validation
+## Test input validation
 %!error mean ()
 %!error mean (1, 2, 3, 4)
 %!error mean ({1:5})
 %!error mean (1, 2, 3)
 %!error mean (1, ones (2,2))
 %!error mean (1, 1.5)
 %!error mean (1, 0)
 %!error mean (1, 3)
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -73,17 +73,17 @@ function y = meansq (x, dim)
 endfunction
 
 
 %!assert (meansq (1:5), 11)
 %!assert (meansq (single (1:5)), single (11))
 %!assert (meansq (magic (4)), [94.5, 92.5, 92.5, 94.5])
 %!assert (meansq (magic (4), 2), [109.5; 77.5; 77.5; 109.5])
 
-%% Test input validation
+## Test input validation
 %!error meansq ()
 %!error meansq (1, 2, 3)
 %!error meansq (['A'; 'B'])
 %!error meansq (1, ones (2,2))
 %!error meansq (1, 1.5)
 %!error meansq (1, 0)
 %!error meansq (1, 3)
 
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -97,27 +97,27 @@ endfunction
 %! assert (median (x) == median (x2) && median (x) == 3.5);
 %! assert (median (y) == median (y2) && median (y) == 4);
 %! assert (median ([x2, 2*x2]), [3.5, 7]);
 %! assert (median ([y2, 3*y2]), [4, 12]);
 
 %!assert (median (single ([1,2,3])), single (2))
 %!assert (median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN])
 
-%% Test multidimensional arrays (bug #35679)
+## Test multidimensional arrays (bug #35679)
 %!shared a, b, x, y
 %! rand ("seed", 2);
 %! a = rand (2,3,4,5);
 %! b = rand (3,4,6,5);
 %! x = sort (a, 4);
 %! y = sort (b, 3);
 %!assert (median (a, 4), x(:, :, :, 3));
 %!assert (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2);
 
-%% Test input validation
+## Test input validation
 %!error median ()
 %!error median (1, 2, 3)
 %!error median ({1:5})
 %!error median (['A'; 'B'])
 %!error median (1, ones (2,2))
 %!error median (1, 1.5)
 %!error median (1, 0)
 
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -150,17 +150,17 @@ endfunction
 %! [m, f, c] = mode (x, 3);
 %! assert (reshape (m, [3, 3]), [1 2 1; 1 2 1; 1 2 1]);
 %! assert (reshape (f, [3, 3]), [1 2 1; 1 2 1; 1 2 1]);
 %! c = reshape (c, [3, 3]);
 %! assert (c{1}, [1; 2; 3]);
 %! assert (c{2}, [1; 2; 3]);
 %! assert (c{3}, [1; 2; 3]);
 
-%% Test input validation
+## Test input validation
 %!error mode ()
 %!error mode (1, 2, 3)
 %!error mode ({1 2 3})
 %!error mode (['A'; 'B'])
 %!error mode (1, ones (2,2))
 %!error mode (1, 1.5)
 %!error mode (1, 0)
 %!error mode (1, 3)
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -156,18 +156,17 @@ function m = moment (x, p, opt1, opt2)
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (need_dim)
     ## Find the first non-singleton dimension.
     (dim = find (sz > 1, 1)) || (dim = 1);
   else
-    if (!(isscalar (dim) && dim == fix (dim)) ||
-        !(1 <= dim && dim <= nd))
+    if (! (isscalar (dim) && dim == fix (dim)) || ! (1 <= dim && dim <= nd))
       error ("moment: DIM must be an integer and a valid dimension");
     endif
   endif
 
   n = sz(dim);
 
   if (! any (type == "r"))
     x = center (x, dim);
@@ -187,17 +186,17 @@ endfunction
 %!assert (moment (x,2), meansq (center (x)), eps)
 %!assert (moment (x,1,2), mean (center (x, 2), 2), eps)
 %!assert (moment (x,1,"a"), mean (abs (center (x))), eps)
 %!assert (moment (x,1,"r"), mean (x), eps)
 %!assert (moment (x,1,"ar"), mean (abs (x)), eps)
 
 %!assert (moment (single ([1 2 3]), 1, "r"), single (2))
 
-%% Test input validation
+## Test input validation
 %!error moment ()
 %!error moment (1)
 %!error moment (1, 2, 3, 4, 5)
 %!error <X must be a non-empty numeric matrix> moment (['A'; 'B'], 2)
 %!error <X must be a non-empty numeric matrix> moment (ones (2,0,3), 2)
 %!error <P must be a numeric scalar> moment (1, true)
 %!error <P must be a numeric scalar> moment (1, ones (2,2))
 %!error <expecting TYPE to be a string> moment (1, 2, 3, 4)
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -157,17 +157,17 @@ endfunction
 %! assert (s, [0.2, 0; 0, 0], 2*eps);
 
 %!test
 %! x = [1, 2; 3, 4];
 %! y = [1; 2];
 %! b = ols (x, y);
 %! assert (b, [1.4, 2], 2*eps);
 
-%% Test input validation
+## Test input validation
 %!error ols ()
 %!error ols (1)
 %!error ols (1, 2, 3)
 %!error ols ([true, true], [1, 2])
 %!error ols ([1, 2], [true, true])
 %!error ols (ones (2,2,2), ones (2,2))
 %!error ols (ones (2,2), ones (2,2,2))
 %!error ols (ones (1,2), ones (2,2))
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -73,12 +73,12 @@ function [p, y] = ppplot (x, dist, varar
   if (nargout == 0)
     plot (p, y);
     axis ([0, 1, 0, 1]);
   endif
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error ppplot ()
 %!error ppplot (ones (2,2))
 
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -168,17 +168,17 @@ endfunction
 %! q = prctile (x, pct, 2);
 %! qa = [0.1270; 0.2041; 0.5567; 0.6477; 0.9322];
 %! assert (q, qa, tol);
 %! x(3,3) = NaN;
 %! q = prctile (x, pct, 2);
 %! qa = [0.1270; 0.2041; 0.6437; 0.6477; 0.9322];
 %! assert (q, qa, tol);
 
-%% Test input validation
+## Test input validation
 %!error prctile ()
 %!error prctile (1, 2, 3, 4)
 %!error prctile (['A'; 'B'], 10)
 %!error prctile (1:10, [true, false])
 %!error prctile (1:10, ones (2,2))
 %!error prctile (1, 1, 1.5)
 %!error prctile (1, 1, 0)
 %!error prctile (1, 1, 3)
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -34,12 +34,12 @@ function y = probit (p)
 
   y = stdnormal_inv (p);
 
 endfunction
 
 
 %!assert (probit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, Inf, NaN])
 
-%% Test input validation
+## Test input validation
 %!error probit ()
 %!error probit (1, 2)
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -99,17 +99,18 @@
 ## q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
 ## q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution
 ## @end group
 ## @end smallexample
 ## @seealso{prctile}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
-## Description: Matlab style quantile function of a discrete/continuous distribution
+## Description: Matlab style quantile function of a discrete/continuous
+##              distribution.
 
 function q = quantile (x, p = [], dim, method = 5)
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   if (! (isnumeric (x) || islogical (x)))
@@ -315,17 +316,17 @@ endfunction
 %! sx = [2, 3, 4];
 %! x = rand (sx);
 %! dim = 2;
 %! p = 0.5;
 %! yobs = quantile (x, p, dim);
 %! yexp = median (x, dim);
 %! assert (yobs, yexp);
 
-%% Test input validation
+## Test input validation
 %!error quantile ()
 %!error quantile (1, 2, 3, 4, 5)
 %!error quantile (['A'; 'B'], 10)
 %!error quantile (1:10, [true, false])
 %!error quantile (1:10, ones (2,2))
 %!error quantile (1, 1, 1.5)
 %!error quantile (1, 1, 0)
 %!error quantile (1, 1, 3)
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -51,12 +51,12 @@ endfunction
 
 
 %!assert (range (1:10), 9)
 %!assert (range (single (1:10)), single (9))
 %!assert (range (magic (3)), [5, 8, 5])
 %!assert (range (magic (3), 2), [7; 4; 7])
 %!assert (range (2), 0)
 
-%% Test input validation
+## Test input validation
 %!error range ()
 %!error range (1, 2, 3)
 
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -88,17 +88,17 @@ endfunction
 
 %!assert (ranks (1:2:10), 1:5)
 %!assert (ranks (10:-2:1), 5:-1:1)
 %!assert (ranks ([2, 1, 2, 4]), [2.5, 1, 2.5, 4])
 %!assert (ranks (ones (1, 5)), 3*ones (1, 5))
 %!assert (ranks (1e6*ones (1, 5)), 3*ones (1, 5))
 %!assert (ranks (rand (1, 5), 1), ones (1, 5))
 
-%% Test input validation
+## Test input validation
 %!error ranks ()
 %!error ranks (1, 2, 3)
 %!error ranks ({1, 2})
 %!error ranks (['A'; 'B'])
 %!error ranks (1, 1.5)
 %!error ranks (1, 0)
 %!error ranks (1, 3)
 
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -93,17 +93,17 @@ function retval = run_count (x, n, dim)
 endfunction
 
 
 %!assert (run_count (magic (3), 4), [1,0,1;1,0,1;0,1,0;0,0,0])
 %!assert (run_count (magic (3), 4, 2), [1,0,1;1,0,1;0,1,0;0,0,0]')
 %!assert (run_count (5:-1:1, 5), [5, 0, 0, 0, 0])
 %!assert (run_count (ones (3), 4), [0,0,0;0,0,0;1,1,1;0,0,0])
 
-%% Test input validation
+## Test input validation
 %!error run_count ()
 %!error run_count (1)
 %!error run_count (1, 2, 3, 4)
 %!error run_count ({1, 2}, 3)
 %!error run_count (['A'; 'A'; 'B'], 3)
 %!error run_count (1:5, ones (2,2))
 %!error run_count (1:5, 1.5)
 %!error run_count (1:5, -2)
diff --git a/scripts/statistics/base/runlength.m b/scripts/statistics/base/runlength.m
--- a/scripts/statistics/base/runlength.m
+++ b/scripts/statistics/base/runlength.m
@@ -30,17 +30,17 @@
 ## @end deftypefn
 
 function [count, value] = runlength (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  if (!(isnumeric (x) || islogical (x)) || !isvector (x))
+  if (! (isnumeric (x) || islogical (x)) || ! isvector (x))
     error ("runlength: X must be a numeric vector");
   endif
 
   if (iscolumn (x))
     x = x.';
   endif
 
   idx = [find(x(1:end-1) != x(2:end)), length(x)];
@@ -54,14 +54,14 @@ endfunction
 
 %!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]), [2 1 3 1 4])
 %!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]'), [2 1 3 1 4])
 %!test
 %! [c, v] = runlength ([2 2 0 4 4 4 0 1 1 1 1]);
 %! assert (c, [2 1 3 1 4]);
 %! assert (v, [2 0 4 0 1]);
 
-%% Test input validation
+## Test input validation
 %!error runlength ()
 %!error runlength (1, 2)
 %!error runlength (['A'; 'B'])
 %!error runlength (ones (2,2))
 
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -86,17 +86,17 @@ function y = skewness (x, flag, dim)
 
   if (! (isnumeric (x) || islogical (x)))
     error ("skewness: X must be a numeric vector or matrix");
   endif
 
   if (nargin < 2 || isempty (flag))
     flag = 1;  # default: do not use the "bias corrected" version
   else
-    if ((! isscalar (flag)) || (flag != 0 && flag != 1))
+    if (! isscalar (flag) || (flag != 0 && flag != 1))
       error ("skewness: FLAG must be 0 or 1");
     endif
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin < 3)
     ## Find the first non-singleton dimension.
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -79,17 +79,17 @@ endfunction
 %!test
 %! x = 1:10;
 %! y = exp (x);
 %! assert (spearman (x,y), 1, 5*eps);
 %! assert (spearman (x,-y), -1, 5*eps);
 
 %!assert (spearman ([1 2 3], [-1 1 -2]), -0.5, 5*eps)
 
-%% Test input validation
+## Test input validation
 %!error spearman ()
 %!error spearman (1, 2, 3)
 %!error spearman (['A'; 'B'])
 %!error spearman (ones (1,2), {1, 2})
 %!error spearman (ones (2,2,2))
 %!error spearman (ones (2,2), ones (2,2,2))
 %!error spearman (ones (2,2), ones (3,2))
 
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -82,17 +82,17 @@ endfunction
 %! assert (min (x, [], 2), s(:,1), eps);
 %! assert (median (x, 2), s(:,3), eps);
 %! assert (max (x, [], 2), s(:,5), eps);
 %! assert (mean (x, 2), s(:,6), eps);
 %! assert (std (x, [], 2), s(:,7), eps);
 %! assert (skewness (x, [], 2), s(:,8), eps);
 %! assert (kurtosis (x, [], 2), s(:,9), eps);
 
-%% Test input validation
+## Test input validation
 %!error statistics ()
 %!error statistics (1, 2, 3)
 %!error statistics (['A'; 'B'])
 %!error statistics (1, ones (2,2))
 %!error statistics (1, 1.5)
 %!error statistics (1, 0)
 %!error statistics (1, 3)
 %!error statistics (1)
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -114,14 +114,14 @@ endfunction
 %!assert (std (ones (3, 1, 2), 0, 2), zeros (3, 1, 2));
 %!assert (std ([1 2], 0), sqrt (2)/2, 5*eps);
 %!assert (std ([1 2], 1), 0.5, 5*eps);
 %!assert (std (1), 0);
 %!assert (std (single (1)), single (0));
 %!assert (std ([]), []);
 %!assert (std (ones (1,3,0,2)), ones (1,3,0,2));
 
-%% Test input validation
+## Test input validation
 %!error std ()
 %!error std (1, 2, 3, 4)
 %!error std (['A'; 'B'])
 %!error std (1, -1)
 
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -30,17 +30,17 @@
 
 function [t, v, w] = table (x, y)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 1)
-    if (!isnumeric (x) || !isvector (x))
+    if (! isnumeric (x) || ! isvector (x))
       error ("table: X must be a numeric vector");
     endif
     v = unique (x);
     for i = 1 : length (v)
       t(i) = sum (x == v(i) | isnan (v(i)) * isnan (x));
     endfor
   elseif (nargin == 2)
     if (! (   isvector (x) && isnumeric (x)
@@ -56,17 +56,17 @@ function [t, v, w] = table (x, y)
                       (y == w(j) | isnan (w(j)) * isnan (y)));
       endfor
     endfor
   endif
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error table ()
 %!error table (1, 2, 3)
 %!error table (ones (2))
 %!error table ([true true])
 %!error table (ones (2,1), true (2,1))
 %!error table (true (2,1), ones (2,1))
 %!error table (ones (2,2), ones (2,1))
 %!error table (ones (2,1), ones (2,2))
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -107,15 +107,15 @@ endfunction
 
 
 %!assert (var (13), 0)
 %!assert (var (single (13)), single (0))
 %!assert (var ([1,2,3]), 1)
 %!assert (var ([1,2,3], 1), 2/3, eps)
 %!assert (var ([1,2,3], [], 1), [0,0,0])
 
-%% Test input validation
+## Test input validation
 %!error var ()
 %!error var (1,2,3,4)
 %!error var (['A'; 'B'])
 %!error var (1, -1)
 %!error var ([], 1)
 
diff --git a/scripts/statistics/base/zscore.m b/scripts/statistics/base/zscore.m
--- a/scripts/statistics/base/zscore.m
+++ b/scripts/statistics/base/zscore.m
@@ -90,17 +90,17 @@ endfunction
 
 
 %!assert (zscore ([1,2,3]), [-1,0,1])
 %!assert (zscore (single ([1,2,3])), single ([-1,0,1]))
 %!assert (zscore (int8 ([1,2,3])), [-1,0,1])
 %!assert (zscore (ones (3,2,2,2)), zeros (3,2,2,2))
 %!assert (zscore ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
 
-%% Test input validation
+## Test input validation
 %!error zscore ()
 %!error zscore (1, 2, 3)
 %!error zscore (['A'; 'B'])
 %!error zscore (1, ones (2,2))
 %!error zscore (1, 1.5)
 %!error zscore (1, 1, 0)
 %!error zscore (1, 3)
 
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
--- a/scripts/statistics/distributions/betacdf.m
+++ b/scripts/statistics/distributions/betacdf.m
@@ -28,17 +28,17 @@
 ## Description: CDF of the Beta distribution
 
 function cdf = betacdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betacdf: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("betacdf: X, A, and B must not be complex");
@@ -71,23 +71,23 @@ endfunction
 %! y = [0 0 0.75 1 1];
 %!assert (betacdf (x, ones (1,5), 2*ones (1,5)), y)
 %!assert (betacdf (x, 1, 2*ones (1,5)), y)
 %!assert (betacdf (x, ones (1,5), 2), y)
 %!assert (betacdf (x, [0 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
 %!assert (betacdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
 %!assert (betacdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (betacdf ([x, NaN], 1, 2), [y, NaN])
 %!assert (betacdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
 %!assert (betacdf ([x, NaN], single (1), 2), single ([y, NaN]))
 %!assert (betacdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error betacdf ()
 %!error betacdf (1)
 %!error betacdf (1,2)
 %!error betacdf (1,2,3,4)
 %!error betacdf (ones (3), ones (2), ones (2))
 %!error betacdf (ones (2), ones (3), ones (2))
 %!error betacdf (ones (2), ones (2), ones (3))
 
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -28,17 +28,17 @@
 ## Description: Quantile function of the Beta distribution
 
 function inv = betainv (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betainv: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("betainv: X, A, and B must not be complex");
@@ -53,17 +53,17 @@ function inv = betainv (x, a, b)
   k = (x < 0) | (x > 1) | !(a > 0) | !(b > 0) | isnan (x);
   inv(k) = NaN;
 
   k = (x == 1) & (a > 0) & (b > 0);
   inv(k) = 1;
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
   if (any (k))
-    if (!isscalar (a) || !isscalar (b))
+    if (! isscalar (a) || ! isscalar (b))
       a = a(k);
       b = b(k);
       y = a ./ (a + b);
     else
       y = a / (a + b) * ones (size (k));
     endif
     x = x(k);
 
@@ -83,21 +83,21 @@ function inv = betainv (x, a, b)
     endif
 
     y_old = y;
     for i = 1 : 10000
       h     = (betacdf (y_old, a, b) - x) ./ betapdf (y_old, a, b);
       y_new = y_old - h;
       ind   = find (y_new <= myeps);
       if (any (ind))
-        y_new (ind) = y_old (ind) / 10;
+        y_new(ind) = y_old(ind) / 10;
       endif
       ind = find (y_new >= 1 - myeps);
       if (any (ind))
-        y_new (ind) = 1 - (1 - y_old (ind)) / 10;
+        y_new(ind) = 1 - (1 - y_old(ind)) / 10;
       endif
       h = y_old - y_new;
       if (max (abs (h)) < sqrt (myeps))
         break;
       endif
       y_old = y_new;
     endfor
 
@@ -111,23 +111,23 @@ endfunction
 %! x = [-1 0 0.75 1 2];
 %!assert (betainv (x, ones (1,5), 2*ones (1,5)), [NaN 0 0.5 1 NaN])
 %!assert (betainv (x, 1, 2*ones (1,5)), [NaN 0 0.5 1 NaN])
 %!assert (betainv (x, ones (1,5), 2), [NaN 0 0.5 1 NaN])
 %!assert (betainv (x, [1 0 NaN 1 1], 2), [NaN NaN NaN 1 NaN])
 %!assert (betainv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 1 NaN])
 %!assert (betainv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN 1 NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (betainv ([x, NaN], 1, 2), [NaN 0 0.5 1 NaN NaN])
 %!assert (betainv (single ([x, NaN]), 1, 2), single ([NaN 0 0.5 1 NaN NaN]))
 %!assert (betainv ([x, NaN], single (1), 2), single ([NaN 0 0.5 1 NaN NaN]))
 %!assert (betainv ([x, NaN], 1, single (2)), single ([NaN 0 0.5 1 NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error betainv ()
 %!error betainv (1)
 %!error betainv (1,2)
 %!error betainv (1,2,3,4)
 %!error betainv (ones (3), ones (2), ones (2))
 %!error betainv (ones (2), ones (3), ones (2))
 %!error betainv (ones (2), ones (2), ones (3))
 %!error betainv (i, 2, 2)
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -28,17 +28,17 @@
 ## Description: PDF of the Beta distribution
 
 function pdf = betapdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betapdf: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("betapdf: X, A, and B must not be complex");
@@ -97,31 +97,31 @@ endfunction
 %! y = [0 2 1 0 0];
 %!assert (betapdf (x, ones (1,5), 2*ones (1,5)), y)
 %!assert (betapdf (x, 1, 2*ones (1,5)), y)
 %!assert (betapdf (x, ones (1,5), 2), y)
 %!assert (betapdf (x, [0 NaN 1 1 1], 2), [NaN NaN y(3:5)])
 %!assert (betapdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
 %!assert (betapdf ([x, NaN], 1, 2), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (betapdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
 %!assert (betapdf ([x, NaN], single (1), 2), single ([y, NaN]))
 %!assert (betapdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
-%% Beta (1/2,1/2) == arcsine distribution
+## Beta (1/2,1/2) == arcsine distribution
 %!test
 %! x = rand (10,1);
 %! y = 1./(pi * sqrt (x.*(1-x)));
 %! assert (betapdf (x, 1/2, 1/2), y, 50*eps);
 
-%% Test large input values to betapdf
+## Test large input values to betapdf
 %!assert (betapdf (0.5, 1000, 1000), 35.678, 1e-3)
 
-%% Test input validation
+## Test input validation
 %!error betapdf ()
 %!error betapdf (1)
 %!error betapdf (1,2)
 %!error betapdf (1,2,3,4)
 %!error betapdf (ones (3), ones (2), ones (2))
 %!error betapdf (ones (2), ones (3), ones (2))
 %!error betapdf (ones (2), ones (2), ones (3))
 %!error betapdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the Beta distribution
 
 function rnd = betarnd (a, b, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
       error ("betarnd: A and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (a) || iscomplex (b))
     error ("betarnd: A and B must not be complex");
@@ -61,23 +61,23 @@ function rnd = betarnd (a, b, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("betarnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("betarnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (a) && !isequal (size (a), sz))
+  if (! isscalar (a) && ! isequal (size (a), sz))
     error ("betarnd: A and B must be scalar or of size SZ");
   endif
 
   if (isa (a, "single") || isa (b, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -104,24 +104,24 @@ endfunction
 %!assert (size (betarnd (ones (2,1), 2)), [2, 1])
 %!assert (size (betarnd (ones (2,2), 2)), [2, 2])
 %!assert (size (betarnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (betarnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (betarnd (1, 2, 3)), [3, 3])
 %!assert (size (betarnd (1, 2, [4 1])), [4, 1])
 %!assert (size (betarnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (betarnd (1, 2)), "double")
 %!assert (class (betarnd (single (1), 2)), "single")
 %!assert (class (betarnd (single ([1 1]), 2)), "single")
 %!assert (class (betarnd (1, single (2))), "single")
 %!assert (class (betarnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error betarnd ()
 %!error betarnd (1)
 %!error betarnd (ones (3), ones (2))
 %!error betarnd (ones (2), ones (3))
 %!error betarnd (i, 2)
 %!error betarnd (2, i)
 %!error betarnd (1,2, -1)
 %!error betarnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -29,17 +29,17 @@
 ## Description: CDF of the binomial distribution
 
 function cdf = binocdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (n) || !isscalar (p))
+  if (! isscalar (n) || ! isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("binocdf: X, N, and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n) || iscomplex (p))
     error ("binocdf: X, N, and P must not be complex");
@@ -73,23 +73,23 @@ endfunction
 %! y = [0 1/4 3/4 1 1];
 %!assert (binocdf (x, 2*ones (1,5), 0.5*ones (1,5)), y)
 %!assert (binocdf (x, 2, 0.5*ones (1,5)), y)
 %!assert (binocdf (x, 2*ones (1,5), 0.5), y)
 %!assert (binocdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 1])
 %!assert (binocdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 1])
 %!assert (binocdf ([x(1:2) NaN x(4:5)], 2, 0.5), [y(1:2) NaN y(4:5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (binocdf ([x, NaN], 2, 0.5), [y, NaN])
 %!assert (binocdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
 %!assert (binocdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
 %!assert (binocdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error binocdf ()
 %!error binocdf (1)
 %!error binocdf (1,2)
 %!error binocdf (1,2,3,4)
 %!error binocdf (ones (3), ones (2), ones (2))
 %!error binocdf (ones (2), ones (3), ones (2))
 %!error binocdf (ones (2), ones (2), ones (3))
 %!error binocdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -29,17 +29,17 @@
 ## Description: Quantile function of the binomial distribution
 
 function inv = binoinv (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (n) || !isscalar (p))
+  if (! isscalar (n) || ! isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("binoinv: X, N, and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n) || iscomplex (p))
     error ("binoinv: X, N, and P must not be complex");
@@ -90,23 +90,23 @@ endfunction
 %! x = [-1 0 0.5 1 2];
 %!assert (binoinv (x, 2*ones (1,5), 0.5*ones (1,5)), [NaN 0 1 2 NaN])
 %!assert (binoinv (x, 2, 0.5*ones (1,5)), [NaN 0 1 2 NaN])
 %!assert (binoinv (x, 2*ones (1,5), 0.5), [NaN 0 1 2 NaN])
 %!assert (binoinv (x, 2*[0 -1 NaN 1.1 1], 0.5), [NaN NaN NaN NaN NaN])
 %!assert (binoinv (x, 2, 0.5*[0 -1 NaN 3 1]), [NaN NaN NaN NaN NaN])
 %!assert (binoinv ([x(1:2) NaN x(4:5)], 2, 0.5), [NaN 0 NaN 2 NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (binoinv ([x, NaN], 2, 0.5), [NaN 0 1 2 NaN NaN])
 %!assert (binoinv (single ([x, NaN]), 2, 0.5), single ([NaN 0 1 2 NaN NaN]))
 %!assert (binoinv ([x, NaN], single (2), 0.5), single ([NaN 0 1 2 NaN NaN]))
 %!assert (binoinv ([x, NaN], 2, single (0.5)), single ([NaN 0 1 2 NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error binoinv ()
 %!error binoinv (1)
 %!error binoinv (1,2)
 %!error binoinv (1,2,3,4)
 %!error binoinv (ones (3), ones (2), ones (2))
 %!error binoinv (ones (2), ones (3), ones (2))
 %!error binoinv (ones (2), ones (2), ones (3))
 %!error binoinv (i, 2, 2)
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -88,22 +88,22 @@ endfunction
 %!assert (binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0])
 %!assert (binopdf ([x, NaN], 2, 0.5), [y, NaN], tol)
 
 ## Test Special input values
 %!assert (binopdf (0, 3, 0), 1);
 %!assert (binopdf (2, 2, 1), 1);
 %!assert (binopdf (1, 2, 1), 0);
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (binopdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
 %!assert (binopdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
 %!assert (binopdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error binopdf ()
 %!error binopdf (1)
 %!error binopdf (1,2)
 %!error binopdf (1,2,3,4)
 %!error binopdf (ones (3), ones (2), ones (2))
 %!error binopdf (ones (2), ones (3), ones (2))
 %!error binopdf (ones (2), ones (2), ones (3))
 %!error binopdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -40,17 +40,17 @@
 ## Description: Random deviates from the binomial distribution
 
 function rnd = binornd (n, p, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (n) || !isscalar (p))
+  if (! isscalar (n) || ! isscalar (p))
     [retval, n, p] = common_size (n, p);
     if (retval > 0)
       error ("binornd: N and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (n) || iscomplex (p))
     error ("binornd: N and P must not be complex");
@@ -62,23 +62,23 @@ function rnd = binornd (n, p, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("binornd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("binornd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (n) && !isequal (size (n), sz))
+  if (! isscalar (n) && ! isequal (size (n), sz))
     error ("binornd: N and P must be scalar or of size SZ");
   endif
 
   if (isa (n, "single") || isa (p, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -124,24 +124,24 @@ endfunction
 %!assert (size (binornd (2*ones (2,1), 1/2)), [2, 1])
 %!assert (size (binornd (2*ones (2,2), 1/2)), [2, 2])
 %!assert (size (binornd (2, 1/2*ones (2,1))), [2, 1])
 %!assert (size (binornd (2, 1/2*ones (2,2))), [2, 2])
 %!assert (size (binornd (2, 1/2, 3)), [3, 3])
 %!assert (size (binornd (2, 1/2, [4 1])), [4, 1])
 %!assert (size (binornd (2, 1/2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (binornd (2, 0.5)), "double")
 %!assert (class (binornd (single (2), 0.5)), "single")
 %!assert (class (binornd (single ([2 2]), 0.5)), "single")
 %!assert (class (binornd (2, single (0.5))), "single")
 %!assert (class (binornd (2, single ([0.5 0.5]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error binornd ()
 %!error binornd (1)
 %!error binornd (ones (3), ones (2))
 %!error binornd (ones (2), ones (3))
 %!error binornd (i, 2)
 %!error binornd (2, i)
 %!error binornd (1,2, -1)
 %!error binornd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -30,34 +30,34 @@
 ## Description: CDF of the Cauchy distribution
 
 function cdf = cauchy_cdf (x, location = 0, scale = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (location) || !isscalar (scale))
+  if (! isscalar (location) || ! isscalar (scale))
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
       error ("cauchy_cdf: X, LOCATION, and SCALE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (location) || iscomplex (scale))
     error ("cauchy_cdf: X, LOCATION, and SCALE must not be complex");
   endif
 
   if (isa (x, "single") || isa (location, "single") || isa (scale, "single"));
     cdf = NaN (size (x), "single");
   else
     cdf = NaN (size (x));
   endif
 
-  k = !isinf (location) & (scale > 0) & (scale < Inf);
+  k = ! isinf (location) & (scale > 0) & (scale < Inf);
   if (isscalar (location) && isscalar (scale))
     cdf = 0.5 + atan ((x - location) / scale) / pi;
   else
     cdf(k) = 0.5 + atan ((x(k) - location(k)) ./ scale(k)) / pi;
   endif
 
 endfunction
 
@@ -67,23 +67,23 @@ endfunction
 %! y = 1/pi * atan ((x-1) / 2) + 1/2;
 %!assert (cauchy_cdf (x, ones (1,5), 2*ones (1,5)), y)
 %!assert (cauchy_cdf (x, 1, 2*ones (1,5)), y)
 %!assert (cauchy_cdf (x, ones (1,5), 2), y)
 %!assert (cauchy_cdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
 %!assert (cauchy_cdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
 %!assert (cauchy_cdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (cauchy_cdf ([x, NaN], 1, 2), [y, NaN])
 %!assert (cauchy_cdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
 %!assert (cauchy_cdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
 %!assert (cauchy_cdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error cauchy_cdf ()
 %!error cauchy_cdf (1,2)
 %!error cauchy_cdf (1,2,3,4)
 %!error cauchy_cdf (ones (3), ones (2), ones (2))
 %!error cauchy_cdf (ones (2), ones (3), ones (2))
 %!error cauchy_cdf (ones (2), ones (2), ones (3))
 %!error cauchy_cdf (i, 2, 2)
 %!error cauchy_cdf (2, i, 2)
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -30,34 +30,34 @@
 ## Description: Quantile function of the Cauchy distribution
 
 function inv = cauchy_inv (x, location = 0, scale = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (location) || !isscalar (scale))
+  if (! isscalar (location) || ! isscalar (scale))
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
       error ("cauchy_inv: X, LOCATION, and SCALE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (location) || iscomplex (scale))
     error ("cauchy_inv: X, LOCATION, and SCALE must not be complex");
   endif
 
   if (isa (x, "single") || isa (location, "single") || isa (scale, "single"))
     inv = NaN (size (x), "single");
   else
     inv = NaN (size (x));
   endif
 
-  ok = !isinf (location) & (scale > 0) & (scale < Inf);
+  ok = ! isinf (location) & (scale > 0) & (scale < Inf);
 
   k = (x == 0) & ok;
   inv(k) = -Inf;
 
   k = (x == 1) & ok;
   inv(k) = Inf;
 
   k = (x > 0) & (x < 1) & ok;
@@ -74,23 +74,23 @@ endfunction
 %! x = [-1 0 0.5 1 2];
 %!assert (cauchy_inv (x, ones (1,5), 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
 %!assert (cauchy_inv (x, 1, 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
 %!assert (cauchy_inv (x, ones (1,5), 2), [NaN -Inf 1 Inf NaN], eps)
 %!assert (cauchy_inv (x, [1 -Inf NaN Inf 1], 2), [NaN NaN NaN NaN NaN])
 %!assert (cauchy_inv (x, 1, 2*[1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
 %!assert (cauchy_inv ([x(1:2) NaN x(4:5)], 1, 2), [NaN -Inf NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (cauchy_inv ([x, NaN], 1, 2), [NaN -Inf 1 Inf NaN NaN], eps)
 %!assert (cauchy_inv (single ([x, NaN]), 1, 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
 %!assert (cauchy_inv ([x, NaN], single (1), 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
 %!assert (cauchy_inv ([x, NaN], 1, single (2)), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error cauchy_inv ()
 %!error cauchy_inv (1,2)
 %!error cauchy_inv (1,2,3,4)
 %!error cauchy_inv (ones (3), ones (2), ones (2))
 %!error cauchy_inv (ones (2), ones (3), ones (2))
 %!error cauchy_inv (ones (2), ones (2), ones (3))
 %!error cauchy_inv (i, 2, 2)
 %!error cauchy_inv (2, i, 2)
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -30,34 +30,34 @@
 ## Description: PDF of the Cauchy distribution
 
 function pdf = cauchy_pdf (x, location = 0, scale = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (location) || !isscalar (scale))
+  if (! isscalar (location) || ! isscalar (scale))
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
       error ("cauchy_pdf: X, LOCATION, and SCALE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (location) || iscomplex (scale))
     error ("cauchy_pdf: X, LOCATION, and SCALE must not be complex");
   endif
 
   if (isa (x, "single") || isa (location, "single") || isa (scale, "single"))
     pdf = NaN (size (x), "single");
   else
     pdf = NaN (size (x));
   endif
 
-  k = !isinf (location) & (scale > 0) & (scale < Inf);
+  k = ! isinf (location) & (scale > 0) & (scale < Inf);
   if (isscalar (location) && isscalar (scale))
     pdf = ((1 ./ (1 + ((x - location) / scale) .^ 2))
               / pi / scale);
   else
     pdf(k) = ((1 ./ (1 + ((x(k) - location(k)) ./ scale(k)) .^ 2))
               / pi ./ scale(k));
   endif
 
@@ -69,27 +69,27 @@ endfunction
 %! y = 1/pi * ( 2 ./ ((x-1).^2 + 2^2) );
 %!assert (cauchy_pdf (x, ones (1,5), 2*ones (1,5)), y)
 %!assert (cauchy_pdf (x, 1, 2*ones (1,5)), y)
 %!assert (cauchy_pdf (x, ones (1,5), 2), y)
 %!assert (cauchy_pdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
 %!assert (cauchy_pdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
 %!assert (cauchy_pdf ([x, NaN], 1, 2), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (cauchy_pdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
 %!assert (cauchy_pdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
 %!assert (cauchy_pdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
 
-%% Cauchy (0,1) == Student's T distribution with 1 DOF
+## Cauchy (0,1) == Student's T distribution with 1 DOF
 %!test
 %! x = rand (10, 1);
 %! assert (cauchy_pdf (x, 0, 1), tpdf (x, 1), eps);
 
-%% Test input validation
+## Test input validation
 %!error cauchy_pdf ()
 %!error cauchy_pdf (1,2)
 %!error cauchy_pdf (1,2,3,4)
 %!error cauchy_pdf (ones (3), ones (2), ones (2))
 %!error cauchy_pdf (ones (2), ones (3), ones (2))
 %!error cauchy_pdf (ones (2), ones (2), ones (3))
 %!error cauchy_pdf (i, 2, 2)
 %!error cauchy_pdf (2, i, 2)
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (location, scale, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (location) || !isscalar (scale))
+  if (! isscalar (location) || ! isscalar (scale))
     [retval, location, scale] = common_size (location, scale);
     if (retval > 0)
       error ("cauchy_rnd: LOCATION and SCALE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (location) || iscomplex (scale))
     error ("cauchy_rnd: LOCATION and SCALE must not be complex");
@@ -61,65 +61,66 @@ function rnd = cauchy_rnd (location, sca
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("cauchy_rnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("cauchy_rnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (location) && !isequal (size (location), sz))
+  if (! isscalar (location) && ! isequal (size (location), sz))
     error ("cauchy_rnd: LOCATION and SCALE must be scalar or of size SZ");
   endif
 
   if (isa (location, "single") || isa (scale, "single"))
     cls = "single";
   else
     cls = "double";
   endif
 
   if (isscalar (location) && isscalar (scale))
-    if (!isinf (location) && (scale > 0) && (scale < Inf))
+    if (! isinf (location) && (scale > 0) && (scale < Inf))
       rnd = location - cot (pi * rand (sz, cls)) * scale;
     else
       rnd = NaN (sz, cls);
     endif
   else
     rnd = NaN (sz, cls);
 
-    k = !isinf (location) & (scale > 0) & (scale < Inf);
-    rnd(k) = location(k)(:) - cot (pi * rand (sum (k(:)), 1, cls)) .* scale(k)(:);
+    k = ! isinf (location) & (scale > 0) & (scale < Inf);
+    rnd(k) = location(k)(:) ...
+             - cot (pi * rand (sum (k(:)), 1, cls)) .* scale(k)(:);
   endif
 
 endfunction
 
 
 %!assert (size (cauchy_rnd (1,2)), [1, 1])
 %!assert (size (cauchy_rnd (ones (2,1), 2)), [2, 1])
 %!assert (size (cauchy_rnd (ones (2,2), 2)), [2, 2])
 %!assert (size (cauchy_rnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (cauchy_rnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (cauchy_rnd (1, 2, 3)), [3, 3])
 %!assert (size (cauchy_rnd (1, 2, [4 1])), [4, 1])
 %!assert (size (cauchy_rnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (cauchy_rnd (1, 2)), "double")
 %!assert (class (cauchy_rnd (single (1), 2)), "single")
 %!assert (class (cauchy_rnd (single ([1 1]), 2)), "single")
 %!assert (class (cauchy_rnd (1, single (2))), "single")
 %!assert (class (cauchy_rnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error cauchy_rnd ()
 %!error cauchy_rnd (1)
 %!error cauchy_rnd (ones (3), ones (2))
 %!error cauchy_rnd (ones (2), ones (3))
 %!error cauchy_rnd (i, 2)
 %!error cauchy_rnd (2, i)
 %!error cauchy_rnd (1,2, -1)
 %!error cauchy_rnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
--- a/scripts/statistics/distributions/chi2cdf.m
+++ b/scripts/statistics/distributions/chi2cdf.m
@@ -28,17 +28,17 @@
 ## Description: CDF of the chi-square distribution
 
 function cdf = chi2cdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (n))
+  if (! isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("chi2cdf: X and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n))
     error ("chi2cdf: X and N must not be complex");
@@ -52,22 +52,22 @@ endfunction
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0, 1 - exp(-x(2:end)/2)];
 %!assert (chi2cdf (x, 2*ones (1,5)), y, eps)
 %!assert (chi2cdf (x, 2), y, eps)
 %!assert (chi2cdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
 %!assert (chi2cdf ([x(1:2) NaN x(4:5)], 2), [y(1:2) NaN y(4:5)], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (chi2cdf ([x, NaN], 2), [y, NaN], eps)
 %!assert (chi2cdf (single ([x, NaN]), 2), single ([y, NaN]), eps ("single"))
 %!assert (chi2cdf ([x, NaN], single (2)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error chi2cdf ()
 %!error chi2cdf (1)
 %!error chi2cdf (1,2,3)
 %!error chi2cdf (ones (3), ones (2))
 %!error chi2cdf (ones (2), ones (3))
 %!error chi2cdf (i, 2)
 %!error chi2cdf (2, i)
 
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
--- a/scripts/statistics/distributions/chi2inv.m
+++ b/scripts/statistics/distributions/chi2inv.m
@@ -28,17 +28,17 @@
 ## Description: Quantile function of the chi-square distribution
 
 function inv = chi2inv (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (n))
+  if (! isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("chi2inv: X and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n))
     error ("chi2inv: X and N must not be complex");
@@ -51,22 +51,22 @@ endfunction
 
 %!shared x
 %! x = [-1 0 0.3934693402873666 1 2];
 %!assert (chi2inv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], 5*eps)
 %!assert (chi2inv (x, 2), [NaN 0 1 Inf NaN], 5*eps)
 %!assert (chi2inv (x, 2*[0 1 NaN 1 1]), [NaN 0 NaN Inf NaN], 5*eps)
 %!assert (chi2inv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], 5*eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (chi2inv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], 5*eps)
 %!assert (chi2inv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
 %!assert (chi2inv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error chi2inv ()
 %!error chi2inv (1)
 %!error chi2inv (1,2,3)
 %!error chi2inv (ones (3), ones (2))
 %!error chi2inv (ones (2), ones (3))
 %!error chi2inv (i, 2)
 %!error chi2inv (2, i)
 
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
--- a/scripts/statistics/distributions/chi2pdf.m
+++ b/scripts/statistics/distributions/chi2pdf.m
@@ -28,17 +28,17 @@
 ## Description: PDF of the chi-square distribution
 
 function pdf = chi2pdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (n))
+  if (! isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("chi2pdf: X and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n))
     error ("chi2pdf: X and N must not be complex");
@@ -52,21 +52,21 @@ endfunction
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1/2 * exp(-x(2:5)/2)];
 %!assert (chi2pdf (x, 2*ones (1,5)), y)
 %!assert (chi2pdf (x, 2), y)
 %!assert (chi2pdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
 %!assert (chi2pdf ([x, NaN], 2), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (chi2pdf (single ([x, NaN]), 2), single ([y, NaN]))
 %!assert (chi2pdf ([x, NaN], single (2)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error chi2pdf ()
 %!error chi2pdf (1)
 %!error chi2pdf (1,2,3)
 %!error chi2pdf (ones (3), ones (2))
 %!error chi2pdf (ones (2), ones (3))
 %!error chi2pdf (i, 2)
 %!error chi2pdf (2, i)
 
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -50,23 +50,23 @@ function rnd = chi2rnd (n, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("chi2rnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 2)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("chi2rnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (n) && !isequal (size (n), sz))
+  if (! isscalar (n) && ! isequal (size (n), sz))
     error ("chi2rnd: N must be scalar or of size SZ");
   endif
 
   if (iscomplex (n))
     error ("chi2rnd: N must not be complex");
   endif
 
   if (isa (n, "single"))
@@ -93,22 +93,22 @@ endfunction
 
 %!assert (size (chi2rnd (2)), [1, 1])
 %!assert (size (chi2rnd (ones (2,1))), [2, 1])
 %!assert (size (chi2rnd (ones (2,2))), [2, 2])
 %!assert (size (chi2rnd (1, 3)), [3, 3])
 %!assert (size (chi2rnd (1, [4 1])), [4, 1])
 %!assert (size (chi2rnd (1, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (chi2rnd (2)), "double")
 %!assert (class (chi2rnd (single (2))), "single")
 %!assert (class (chi2rnd (single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error chi2rnd ()
 %!error chi2rnd (ones (3), ones (2))
 %!error chi2rnd (ones (2), ones (3))
 %!error chi2rnd (i)
 %!error chi2rnd (1, -1)
 %!error chi2rnd (1, ones (2))
 %!error chi2rnd (1, [2 -1 2])
 %!error chi2rnd (ones (2,2), 3)
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -43,36 +43,36 @@ function cdf = discrete_cdf (x, v, p)
   p = p(:) / sum (p);   # Reshape and normalize probability vector
 
   if (isa (x, "single") || isa (v, "single") || isa (p, "single"));
     cdf = NaN (size (x), "single");
   else
     cdf = NaN (size (x));
   endif
 
-  k = !isnan (x);
+  k = ! isnan (x);
   [vs, vi] = sort (v);
   cdf(k) = [0 ; cumsum(p(vi))](lookup (vs, x(k)) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! p = 1/length(v) * ones (1, length(v));
 %! y = [0 0.1 0.6 1 1];
 %!assert (discrete_cdf ([x, NaN], v, p), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (discrete_cdf (single ([x, NaN]), v, p), single ([y, NaN]), 2*eps ("single"))
 %!assert (discrete_cdf ([x, NaN], single (v), p), single ([y, NaN]), 2*eps ("single"))
 %!assert (discrete_cdf ([x, NaN], v, single (p)), single ([y, NaN]), 2*eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error discrete_cdf ()
 %!error discrete_cdf (1)
 %!error discrete_cdf (1,2)
 %!error discrete_cdf (1,2,3,4)
 %!error discrete_cdf (1, ones (2), ones (2,1))
 %!error discrete_cdf (1, [1 ; NaN], ones (2,1))
 %!error discrete_cdf (1, ones (2,1), ones (1,1))
 %!error discrete_cdf (1, ones (2,1), [1 -1])
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -72,22 +72,22 @@ endfunction
 
 %!shared x,v,p,y
 %! x = [-1 0 0.1 0.5 1 2];
 %! v = 0.1:0.2:1.9;
 %! p = 1/length(v) * ones (1, length(v));
 %! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
 %!assert (discrete_inv ([x, NaN], v, p), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (discrete_inv (single ([x, NaN]), v, p), single ([y, NaN]), eps ("single"))
 %!assert (discrete_inv ([x, NaN], single (v), p), single ([y, NaN]), eps ("single"))
 %!assert (discrete_inv ([x, NaN], v, single (p)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error discrete_inv ()
 %!error discrete_inv (1)
 %!error discrete_inv (1,2)
 %!error discrete_inv (1,2,3,4)
 %!error discrete_inv (1, ones (2), ones (2,1))
 %!error discrete_inv (1, ones (2,1), ones (1,1))
 %!error discrete_inv (1, ones (2,1), [1 NaN])
 %!error discrete_inv (1, ones (2,1), [1 -1])
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -47,36 +47,36 @@ function pdf = discrete_pdf (x, v, p)
   p = [0 ; p(:)/sum(p)];
 
   if (isa (x, "single") || isa (v, "single") || isa (p, "single"))
     pdf = NaN (size (x), "single");
   else
     pdf = NaN (size (x));
   endif
 
-  k = !isnan (x);
+  k = ! isnan (x);
   [vs, vi] = sort (v(:));
   pdf(k) = p([0 ; vi](lookup (vs, x(k), 'm') + 1) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! p = 1/length (v) * ones (1, length (v));
 %! y = [0 0.1 0.1 0.1 0];
 %!assert (discrete_pdf ([x, NaN], v, p), [y, NaN], 5*eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (discrete_pdf (single ([x, NaN]), v, p), single ([y, NaN]), 5*eps ("single"))
 %!assert (discrete_pdf ([x, NaN], single (v), p), single ([y, NaN]), 5*eps ("single"))
 %!assert (discrete_pdf ([x, NaN], v, single (p)), single ([y, NaN]), 5*eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error discrete_pdf ()
 %!error discrete_pdf (1)
 %!error discrete_pdf (1,2)
 %!error discrete_pdf (1,2,3,4)
 %!error discrete_pdf (1, ones (2), ones (2,1))
 %!error discrete_pdf (1, [1 ; NaN], ones (2,1))
 %!error discrete_pdf (1, ones (2,1), ones (1,1))
 %!error discrete_pdf (1, ones (2,1), [1 -1])
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -60,45 +60,45 @@ function rnd = discrete_rnd (v, p, varar
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("discrete_rnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("discrete_rnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
   rnd = v(lookup (cumsum (p(1:end-1)) / sum (p), rand (sz)) + 1);
   rnd = reshape (rnd, sz);
 
 endfunction
 
 
 %!assert (size (discrete_rnd (1:2, 1:2, 3)), [3, 3])
 %!assert (size (discrete_rnd (1:2, 1:2, [4 1])), [4, 1])
 %!assert (size (discrete_rnd (1:2, 1:2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (discrete_rnd (1:2, 1:2)), "double")
 %!assert (class (discrete_rnd (single (1:2), 1:2)), "single")
 ## FIXME: Maybe this should work, maybe it shouldn't.
 #%!assert(class (discrete_rnd (1:2, single(1:2))), "single");
 
-%% Test input validation
+## Test input validation
 %!error discrete_rnd ()
 %!error discrete_rnd (1)
 %!error discrete_rnd (1:2,1:2, -1)
 %!error discrete_rnd (1:2,1:2, ones (2))
 %!error discrete_rnd (1:2,1:2, [2 -1 2])
 %!error discrete_rnd (1:2,1:2, 1, ones (2))
 %!error discrete_rnd (1:2,1:2, 1, -1)
-%% test v,p verification
+## test v,p verification
 %!error discrete_rnd (1, ones (2), ones (2,1))
 %!error discrete_rnd (1, ones (2,1), ones (1,1))
 %!error discrete_rnd (1, ones (2,1), [1 -1])
 %!error discrete_rnd (1, ones (2,1), [1 NaN])
 %!error discrete_rnd (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -44,19 +44,19 @@ endfunction
 
 %!shared x,v,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! y = [0 0.1 0.6 1 1];
 %!assert (empirical_cdf (x, v), y, eps)
 %!assert (empirical_cdf ([x(1) NaN x(3:5)], v), [0 NaN 0.6 1 1], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (empirical_cdf ([x, NaN], v), [y, NaN], eps)
 %!assert (empirical_cdf (single ([x, NaN]), v), single ([y, NaN]), eps)
 %!assert (empirical_cdf ([x, NaN], single (v)), single ([y, NaN]), eps)
 
-%% Test input validation
+## Test input validation
 %!error empirical_cdf ()
 %!error empirical_cdf (1)
 %!error empirical_cdf (1,2,3)
 %!error empirical_cdf (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -43,19 +43,19 @@ endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0 0.1 0.5 1 2];
 %! v = 0.1:0.2:1.9;
 %! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
 %!assert (empirical_inv (x, v), y, eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (empirical_inv ([x, NaN], v), [y, NaN], eps)
 %!assert (empirical_inv (single ([x, NaN]), v), single ([y, NaN]), eps)
 %!assert (empirical_inv ([x, NaN], single (v)), single ([y, NaN]), eps)
 
-%% Test input validation
+## Test input validation
 %!error empirical_inv ()
 %!error empirical_inv (1)
 %!error empirical_inv (1,2,3)
 %!error empirical_inv (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -52,21 +52,21 @@ endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! y = [0 0.1 0.1 0.1 0];
 %!assert (empirical_pdf (x, v), y)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (empirical_pdf (single (x), v), single (y))
 %!assert (empirical_pdf (x, single (v)), single (y))
 
-%% Test distribution with ties
+## Test distribution with ties
 %!assert (empirical_pdf (2, [1 2 3 2]), 0.5)
 
-%% Test input validation
+## Test input validation
 %!error empirical_pdf ()
 %!error empirical_pdf (1)
 %!error empirical_pdf (1,2,3)
 %!error empirical_inv (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -52,18 +52,17 @@ function rnd = empirical_rnd (data, vara
 
 endfunction
 
 
 %!assert (size (empirical_rnd (ones (3, 1))), [3, 1])
 %!assert (size (empirical_rnd (1:2, [4 1])), [4, 1])
 %!assert (size (empirical_rnd (1:2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (empirical_rnd (1:2, 1)), "double")
 %!assert (class (empirical_rnd (single (1:2), 1)), "single")
 
-%% Test input validation
+## Test input validation
 %!error empirical_rnd ()
 %!error empirical_rnd (ones (2), 1)
-%% test data verification
 %!error empirical_rnd (ones (2), 1, 1)
 
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -30,17 +30,17 @@
 ## Description: CDF of the exponential distribution
 
 function cdf = expcdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (lambda))
+  if (! isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("expcdf: X and LAMBDA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (lambda))
     error ("expcdf: X and LAMBDA must not be complex");
@@ -70,22 +70,22 @@ endfunction
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1 - exp(-x(2:end)/2)];
 %!assert (expcdf (x, 2*ones (1,5)), y)
 %!assert (expcdf (x, 2), y)
 %!assert (expcdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (expcdf ([x, NaN], 2), [y, NaN])
 %!assert (expcdf (single ([x, NaN]), 2), single ([y, NaN]))
 %!assert (expcdf ([x, NaN], single (2)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error expcdf ()
 %!error expcdf (1)
 %!error expcdf (1,2,3)
 %!error expcdf (ones (3), ones (2))
 %!error expcdf (ones (2), ones (3))
 %!error expcdf (i, 2)
 %!error expcdf (2, i)
 
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -27,28 +27,28 @@
 ## Description: Quantile function of the exponential distribution
 
 function inv = expinv (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (lambda))
+  if (! isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("expinv: X and LAMBDA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (lambda))
     error ("expinv: X and LAMBDA must not be complex");
   endif
 
-  if (!isscalar (x))
+  if (! isscalar (x))
     sz = size (x);
   else
     sz = size (lambda);
   endif
 
   if (iscomplex (x) || iscomplex (lambda))
     error ("expinv: X and LAMBDA must not be complex");
   endif
@@ -74,22 +74,22 @@ endfunction
 
 %!shared x
 %! x = [-1 0 0.3934693402873666 1 2];
 %!assert (expinv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], eps)
 %!assert (expinv (x, 2), [NaN 0 1 Inf NaN], eps)
 %!assert (expinv (x, 2*[1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
 %!assert (expinv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (expinv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], eps)
 %!assert (expinv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), eps)
 %!assert (expinv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), eps)
 
-%% Test input validation
+## Test input validation
 %!error expinv ()
 %!error expinv (1)
 %!error expinv (1,2,3)
 %!error expinv (ones (3), ones (2))
 %!error expinv (ones (2), ones (3))
 %!error expinv (i, 2)
 %!error expinv (2, i)
 
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -27,17 +27,17 @@
 ## Description: PDF of the exponential distribution
 
 function pdf = exppdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (lambda))
+  if (! isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("exppdf: X and LAMBDA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (lambda))
     error ("exppdf: X and LAMBDA must not be complex");
@@ -64,21 +64,21 @@ endfunction
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = gampdf (x, 1, 2);
 %!assert (exppdf (x, 2*ones (1,5)), y)
 %!assert (exppdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
 %!assert (exppdf ([x, NaN], 2), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (exppdf (single ([x, NaN]), 2), single ([y, NaN]))
 %!assert (exppdf ([x, NaN], single (2)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error exppdf ()
 %!error exppdf (1)
 %!error exppdf (1,2,3)
 %!error exppdf (ones (3), ones (2))
 %!error exppdf (ones (2), ones (3))
 %!error exppdf (i, 2)
 %!error exppdf (2, i)
 
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -50,23 +50,23 @@ function rnd = exprnd (lambda, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("exprnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 2)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("exprnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (lambda) && !isequal (size (lambda), sz))
+  if (! isscalar (lambda) && ! isequal (size (lambda), sz))
     error ("exprnd: LAMBDA must be scalar or of size SZ");
   endif
 
   if (iscomplex (lambda))
     error ("exprnd: LAMBDA must not be complex");
   endif
 
   if (isa (lambda, "single"))
@@ -93,22 +93,22 @@ endfunction
 
 %!assert (size (exprnd (2)), [1, 1])
 %!assert (size (exprnd (ones (2,1))), [2, 1])
 %!assert (size (exprnd (ones (2,2))), [2, 2])
 %!assert (size (exprnd (1, 3)), [3, 3])
 %!assert (size (exprnd (1, [4 1])), [4, 1])
 %!assert (size (exprnd (1, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (exprnd (1)), "double")
 %!assert (class (exprnd (single (1))), "single")
 %!assert (class (exprnd (single ([1 1]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error exprnd ()
 %!error exprnd (1, -1)
 %!error exprnd (1, ones (2))
 %!error exprnd (i)
 %!error exprnd (1, [2 -1 2])
 %!error exprnd (1, 2, -1)
 %!error exprnd (1, 2, ones (2))
 %!error exprnd (ones (2,2), 3)
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -28,17 +28,17 @@
 ## Description: CDF of the F distribution
 
 function cdf = fcdf (x, m, n)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (m) || !isscalar (n))
+  if (! isscalar (m) || ! isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
       error ("fcdf: X, M, and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (m) || iscomplex (n))
     error ("fcdf: X, M, and N must not be complex");
@@ -71,23 +71,23 @@ endfunction
 %! y = [0 0 1/3 1/2 2/3 1];
 %!assert (fcdf (x, 2*ones (1,6), 2*ones (1,6)), y, eps)
 %!assert (fcdf (x, 2, 2*ones (1,6)), y, eps)
 %!assert (fcdf (x, 2*ones (1,6), 2), y, eps)
 %!assert (fcdf (x, [0 NaN Inf 2 2 2], 2), [NaN NaN NaN y(4:6)], eps)
 %!assert (fcdf (x, 2, [0 NaN Inf 2 2 2]), [NaN NaN NaN y(4:6)], eps)
 %!assert (fcdf ([x(1:2) NaN x(4:6)], 2, 2), [y(1:2) NaN y(4:6)], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (fcdf ([x, NaN], 2, 2), [y, NaN], eps)
 %!assert (fcdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
 %!assert (fcdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
 %!assert (fcdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error fcdf ()
 %!error fcdf (1)
 %!error fcdf (1,2)
 %!error fcdf (1,2,3,4)
 %!error fcdf (ones (3), ones (2), ones (2))
 %!error fcdf (ones (2), ones (3), ones (2))
 %!error fcdf (ones (2), ones (2), ones (3))
 %!error fcdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -28,17 +28,17 @@
 ## Description: Quantile function of the F distribution
 
 function inv = finv (x, m, n)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (m) || !isscalar (n))
+  if (! isscalar (m) || ! isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
       error ("finv: X, M, and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (m) || iscomplex (n))
     error ("finv: X, M, and N must not be complex");
@@ -68,23 +68,23 @@ endfunction
 %! x = [-1 0 0.5 1 2];
 %!assert (finv (x, 2*ones (1,5), 2*ones (1,5)), [NaN 0 1 Inf NaN])
 %!assert (finv (x, 2, 2*ones (1,5)), [NaN 0 1 Inf NaN])
 %!assert (finv (x, 2*ones (1,5), 2), [NaN 0 1 Inf NaN])
 %!assert (finv (x, [2 -Inf NaN Inf 2], 2), [NaN NaN NaN NaN NaN])
 %!assert (finv (x, 2, [2 -Inf NaN Inf 2]), [NaN NaN NaN NaN NaN])
 %!assert (finv ([x(1:2) NaN x(4:5)], 2, 2), [NaN 0 NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (finv ([x, NaN], 2, 2), [NaN 0 1 Inf NaN NaN])
 %!assert (finv (single ([x, NaN]), 2, 2), single ([NaN 0 1 Inf NaN NaN]))
 %!assert (finv ([x, NaN], single (2), 2), single ([NaN 0 1 Inf NaN NaN]))
 %!assert (finv ([x, NaN], 2, single (2)), single ([NaN 0 1 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error finv ()
 %!error finv (1)
 %!error finv (1,2)
 %!error finv (1,2,3,4)
 %!error finv (ones (3), ones (2), ones (2))
 %!error finv (ones (2), ones (3), ones (2))
 %!error finv (ones (2), ones (2), ones (3))
 %!error finv (i, 2, 2)
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -28,17 +28,17 @@
 ## Description: PDF of the F distribution
 
 function pdf = fpdf (x, m, n)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (m) || !isscalar (n))
+  if (! isscalar (m) || ! isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
       error ("fpdf: X, M, and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (m) || iscomplex (n))
     error ("fpdf: X, M, and N must not be complex");
@@ -64,39 +64,39 @@ function pdf = fpdf (x, m, n)
     pdf(k) = (exp ((m(k)/2 - 1) .* log (tmp)
                    - ((m(k) + n(k)) / 2) .* log (1 + tmp))
               .* (m(k) ./ n(k)) ./ beta (m(k)/2, n(k)/2));
   endif
 
 endfunction
 
 
-%% F (x, 1, m) == T distribution (sqrt (x), m) / sqrt (x)
+## F (x, 1, m) == T distribution (sqrt (x), m) / sqrt (x)
 %!test
 %! x = rand (10,1);
 %! x = x(x > 0.1 & x < 0.9);
 %! y = tpdf (sqrt (x), 2) ./ sqrt (x);
 %! assert (fpdf (x, 1, 2), y, 5*eps);
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0 0 4/9 1/4 1/9];
 %!assert (fpdf (x, 2*ones (1,5), 2*ones (1,5)), y, eps)
 %!assert (fpdf (x, 2, 2*ones (1,5)), y, eps)
 %!assert (fpdf (x, 2*ones (1,5), 2), y, eps)
 %!assert (fpdf (x, [0 NaN Inf 2 2], 2), [NaN NaN NaN y(4:5)], eps)
 %!assert (fpdf (x, 2, [0 NaN Inf 2 2]), [NaN NaN NaN y(4:5)], eps)
 %!assert (fpdf ([x, NaN], 2, 2), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (fpdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
 %!assert (fpdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
 %!assert (fpdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error fpdf ()
 %!error fpdf (1)
 %!error fpdf (1,2)
 %!error fpdf (1,2,3,4)
 %!error fpdf (ones (3), ones (2), ones (2))
 %!error fpdf (ones (2), ones (3), ones (2))
 %!error fpdf (ones (2), ones (2), ones (3))
 %!error fpdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the F distribution
 
 function rnd = frnd (m, n, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (m) || !isscalar (n))
+  if (! isscalar (m) || ! isscalar (n))
     [retval, m, n] = common_size (m, n);
     if (retval > 0)
       error ("frnd: M and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (m) || iscomplex (n))
     error ("frnd: M and N must not be complex");
@@ -61,23 +61,23 @@ function rnd = frnd (m, n, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("frnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("frnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (m) && !isequal (size (m), sz))
+  if (! isscalar (m) && ! isequal (size (m), sz))
     error ("frnd: M and N must be scalar or of size SZ");
   endif
 
   if (isa (m, "single") || isa (n, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -102,24 +102,24 @@ endfunction
 %!assert (size (frnd (ones (2,1), 2)), [2, 1])
 %!assert (size (frnd (ones (2,2), 2)), [2, 2])
 %!assert (size (frnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (frnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (frnd (1, 2, 3)), [3, 3])
 %!assert (size (frnd (1, 2, [4 1])), [4, 1])
 %!assert (size (frnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (frnd (1, 2)), "double")
 %!assert (class (frnd (single (1), 2)), "single")
 %!assert (class (frnd (single ([1 1]), 2)), "single")
 %!assert (class (frnd (1, single (2))), "single")
 %!assert (class (frnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error frnd ()
 %!error frnd (1)
 %!error frnd (ones (3), ones (2))
 %!error frnd (ones (2), ones (3))
 %!error frnd (i, 2)
 %!error frnd (2, i)
 %!error frnd (1,2, -1)
 %!error frnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -28,17 +28,17 @@
 ## Description: CDF of the Gamma distribution
 
 function cdf = gamcdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("gamcdf: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("gamcdf: X, A, and B must not be complex");
@@ -68,21 +68,21 @@ endfunction
 %! y = [0, gammainc(x(2:end), 1)];
 %!assert (gamcdf (x, ones (1,6), ones (1,6)), y)
 %!assert (gamcdf (x, 1, ones (1,6)), y)
 %!assert (gamcdf (x, ones (1,6), 1), y)
 %!assert (gamcdf (x, [0 -Inf NaN Inf 1 1], 1), [NaN NaN NaN NaN y(5:6)])
 %!assert (gamcdf (x, 1, [0 -Inf NaN Inf 1 1]), [NaN NaN NaN NaN y(5:6)])
 %!assert (gamcdf ([x(1:2) NaN x(4:6)], 1, 1), [y(1:2) NaN y(4:6)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (gamcdf ([x, NaN], 1, 1), [y, NaN])
 %!assert (gamcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error gamcdf ()
 %!error gamcdf (1)
 %!error gamcdf (1,2)
 %!error gamcdf (1,2,3,4)
 %!error gamcdf (ones (3), ones (2), ones (2))
 %!error gamcdf (ones (2), ones (3), ones (2))
 %!error gamcdf (ones (2), ones (2), ones (3))
 %!error gamcdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -28,17 +28,17 @@
 ## Description: Quantile function of the Gamma distribution
 
 function inv = gaminv (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("gaminv: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("gaminv: X, A, and B must not be complex");
@@ -54,17 +54,17 @@ function inv = gaminv (x, a, b)
        | !(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf));
   inv(k) = NaN;
 
   k = (x == 1) & (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
   inv(k) = Inf;
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (a < Inf) & (b > 0) & (b < Inf));
   if (any (k))
-    if (!isscalar (a) || !isscalar (b))
+    if (! isscalar (a) || ! isscalar (b))
       a = a(k);
       b = b(k);
       y = a .* b;
     else
       y = a * b * ones (size (k));
     endif
     x = x(k);
 
@@ -80,17 +80,17 @@ function inv = gaminv (x, a, b)
     endif
 
     y_old = y;
     for i = 1 : 100
       h     = (gamcdf (y_old, a, b) - x) ./ gampdf (y_old, a, b);
       y_new = y_old - h;
       ind   = find (y_new <= myeps);
       if (any (ind))
-        y_new (ind) = y_old (ind) / 10;
+        y_new(ind) = y_old(ind) / 10;
         h = y_old - y_new;
       endif
       if (max (abs (h)) < sqrt (myeps))
         break;
       endif
       y_old = y_new;
     endfor
 
@@ -104,23 +104,23 @@ endfunction
 %! x = [-1 0 0.63212055882855778 1 2];
 %!assert (gaminv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
 %!assert (gaminv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
 %!assert (gaminv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
 %!assert (gaminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
 %!assert (gaminv (x, 1, [1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
 %!assert (gaminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (gaminv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
 %!assert (gaminv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 %!assert (gaminv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 %!assert (gaminv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error gaminv ()
 %!error gaminv (1)
 %!error gaminv (1,2)
 %!error gaminv (1,2,3,4)
 %!error gaminv (ones (3), ones (2), ones (2))
 %!error gaminv (ones (2), ones (3), ones (2))
 %!error gaminv (ones (2), ones (2), ones (3))
 %!error gaminv (i, 2, 2)
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -28,17 +28,17 @@
 ## Description: PDF of the Gamma distribution
 
 function pdf = gampdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("gampdf: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("gampdf: X, A, and B must not be complex");
@@ -79,22 +79,22 @@ endfunction
 %! y = [0 exp(-x(2:end))];
 %!assert (gampdf (x, ones (1,5), ones (1,5)), y)
 %!assert (gampdf (x, 1, ones (1,5)), y)
 %!assert (gampdf (x, ones (1,5), 1), y)
 %!assert (gampdf (x, [0 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN y(5)])
 %!assert (gampdf (x, 1, [0 -Inf NaN Inf 1]), [NaN NaN NaN 0 y(5)])
 %!assert (gampdf ([x, NaN], 1, 1), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (gampdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
 %!assert (gampdf ([x, NaN], single (1), 1), single ([y, NaN]))
 %!assert (gampdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error gampdf ()
 %!error gampdf (1)
 %!error gampdf (1,2)
 %!error gampdf (1,2,3,4)
 %!error gampdf (ones (3), ones (2), ones (2))
 %!error gampdf (ones (2), ones (3), ones (2))
 %!error gampdf (ones (2), ones (2), ones (3))
 %!error gampdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamrnd (a, b, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
       error ("gamrnd: A and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (a) || iscomplex (b))
     error ("gamrnd: A and B must not be complex");
@@ -61,23 +61,23 @@ function rnd = gamrnd (a, b, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("gamrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("gamrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (a) && !isequal (size (a), sz))
+  if (! isscalar (a) && ! isequal (size (a), sz))
     error ("gamrnd: A and B must be scalar or of size SZ");
   endif
 
   if (isa (a, "single") || isa (b, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -102,24 +102,24 @@ endfunction
 %!assert (size (gamrnd (ones (2,1), 2)), [2, 1])
 %!assert (size (gamrnd (ones (2,2), 2)), [2, 2])
 %!assert (size (gamrnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (gamrnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (gamrnd (1, 2, 3)), [3, 3])
 %!assert (size (gamrnd (1, 2, [4 1])), [4, 1])
 %!assert (size (gamrnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (gamrnd (1, 2)), "double")
 %!assert (class (gamrnd (single (1), 2)), "single")
 %!assert (class (gamrnd (single ([1 1]), 2)), "single")
 %!assert (class (gamrnd (1, single (2))), "single")
 %!assert (class (gamrnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error gamrnd ()
 %!error gamrnd (1)
 %!error gamrnd (ones (3), ones (2))
 %!error gamrnd (ones (2), ones (3))
 %!error gamrnd (i, 2)
 %!error gamrnd (2, i)
 %!error gamrnd (1,2, -1)
 %!error gamrnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -30,17 +30,17 @@
 ## Description: CDF of the geometric distribution
 
 function cdf = geocdf (x, p)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (p))
+  if (! isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
       error ("geocdf: X and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (p))
     error ("geocdf: X and P must not be complex");
@@ -71,22 +71,22 @@ endfunction
 %!shared x,y
 %! x = [-1 0 1 Inf];
 %! y = [0 0.5 0.75 1];
 %!assert (geocdf (x, 0.5*ones (1,4)), y)
 %!assert (geocdf (x, 0.5), y)
 %!assert (geocdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
 %!assert (geocdf ([x(1:2) NaN x(4)], 0.5), [y(1:2) NaN y(4)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (geocdf ([x, NaN], 0.5), [y, NaN])
 %!assert (geocdf (single ([x, NaN]), 0.5), single ([y, NaN]))
 %!assert (geocdf ([x, NaN], single (0.5)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error geocdf ()
 %!error geocdf (1)
 %!error geocdf (1,2,3)
 %!error geocdf (ones (3), ones (2))
 %!error geocdf (ones (2), ones (3))
 %!error geocdf (i, 2)
 %!error geocdf (2, i)
 
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -30,17 +30,17 @@
 ## Description: Quantile function of the geometric distribution
 
 function inv = geoinv (x, p)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (p))
+  if (! isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
       error ("geoinv: X and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (p))
     error ("geoinv: X and P must not be complex");
@@ -67,22 +67,22 @@ endfunction
 
 %!shared x
 %! x = [-1 0 0.75 1 2];
 %!assert (geoinv (x, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
 %!assert (geoinv (x, 0.5), [NaN 0 1 Inf NaN])
 %!assert (geoinv (x, 0.5*[1 -1 NaN 4 1]), [NaN NaN NaN NaN NaN])
 %!assert (geoinv ([x(1:2) NaN x(4:5)], 0.5), [NaN 0 NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (geoinv ([x, NaN], 0.5), [NaN 0 1 Inf NaN NaN])
 %!assert (geoinv (single ([x, NaN]), 0.5), single ([NaN 0 1 Inf NaN NaN]))
 %!assert (geoinv ([x, NaN], single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error geoinv ()
 %!error geoinv (1)
 %!error geoinv (1,2,3)
 %!error geoinv (ones (3), ones (2))
 %!error geoinv (ones (2), ones (3))
 %!error geoinv (i, 2)
 %!error geoinv (2, i)
 
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -30,17 +30,17 @@
 ## Description: PDF of the geometric distribution
 
 function pdf = geopdf (x, p)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (p))
+  if (! isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
       error ("geopdf: X and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (p))
     error ("geopdf: X and P must not be complex");
@@ -68,21 +68,21 @@ endfunction
 %!shared x,y
 %! x = [-1 0 1 Inf];
 %! y = [0, 1/2, 1/4, NaN];
 %!assert (geopdf (x, 0.5*ones (1,4)), y)
 %!assert (geopdf (x, 0.5), y)
 %!assert (geopdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
 %!assert (geopdf ([x, NaN], 0.5), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (geopdf (single ([x, NaN]), 0.5), single ([y, NaN]), 5*eps ("single"))
 %!assert (geopdf ([x, NaN], single (0.5)), single ([y, NaN]), 5*eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error geopdf ()
 %!error geopdf (1)
 %!error geopdf (1,2,3)
 %!error geopdf (ones (3), ones (2))
 %!error geopdf (ones (2), ones (3))
 %!error geopdf (i, 2)
 %!error geopdf (2, i)
 
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -53,23 +53,23 @@ function rnd = geornd (p, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("geornd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 2)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("geornd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (p) && !isequal (size (p), sz))
+  if (! isscalar (p) && ! isequal (size (p), sz))
     error ("geornd: P must be scalar or of size SZ");
   endif
 
   if (iscomplex (p))
     error ("geornd: P must not be complex");
   endif
 
   if (isa (p, "single"))
@@ -103,24 +103,24 @@ endfunction
 
 %!assert (size (geornd (0.5)), [1, 1])
 %!assert (size (geornd (0.5*ones (2,1))), [2, 1])
 %!assert (size (geornd (0.5*ones (2,2))), [2, 2])
 %!assert (size (geornd (0.5, 3)), [3, 3])
 %!assert (size (geornd (0.5, [4 1])), [4, 1])
 %!assert (size (geornd (0.5, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (geornd (0.5)), "double")
 %!assert (class (geornd (single (0.5))), "single")
 %!assert (class (geornd (single ([0.5 0.5]))), "single")
 %!assert (class (geornd (single (0))), "single")
 %!assert (class (geornd (single (1))), "single")
 
-%% Test input validation
+## Test input validation
 %!error geornd ()
 %!error geornd (ones (3), ones (2))
 %!error geornd (ones (2), ones (3))
 %!error geornd (i)
 %!error geornd (1, -1)
 %!error geornd (1, ones (2))
 %!error geornd (1, [2 -1 2])
 %!error geornd (ones (2,2), 2, 3)
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -34,28 +34,29 @@
 ## Description: CDF of the hypergeometric distribution
 
 function cdf = hygecdf (x, t, m, n)
 
   if (nargin != 4)
     print_usage ();
   endif
 
-  if (!isscalar (t) || !isscalar (m) || !isscalar (n))
+  if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
     [retval, x, t, m, n] = common_size (x, t, m, n);
     if (retval > 0)
       error ("hygecdf: X, T, M, and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (t) || iscomplex (m) || iscomplex (n))
     error ("hygecdf: X, T, M, and N must not be complex");
   endif
 
-  if (isa (x, "single") || isa (t, "single") || isa (m, "single") || isa (n, "single"))
+  if (isa (x, "single") || isa (t, "single")
+      || isa (m, "single") || isa (n, "single"))
     cdf = NaN (size (x), "single");
   else
     cdf = NaN (size (x));
   endif
 
   ok = ((t >= 0) & (m >= 0) & (n > 0) & (m <= t) & (n <= t) &
         (t == fix (t)) & (m == fix (m)) & (n == fix (n)));
 
@@ -81,24 +82,24 @@ endfunction
 %!assert (hygecdf (x, 4, 2, 2*ones (1,5)), y, eps)
 %!assert (hygecdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [y(1) NaN NaN NaN y(5)], eps)
 %!assert (hygecdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [y(1) NaN NaN NaN y(5)], eps)
 %!assert (hygecdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
 %!assert (hygecdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [y(1) NaN NaN NaN y(5)], eps)
 %!assert (hygecdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
 %!assert (hygecdf ([x(1:2) NaN x(4:5)], 4, 2, 2), [y(1:2) NaN y(4:5)], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (hygecdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
 %!assert (hygecdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]), eps ("single"))
 %!assert (hygecdf ([x, NaN], single (4), 2, 2), single ([y, NaN]), eps ("single"))
 %!assert (hygecdf ([x, NaN], 4, single (2), 2), single ([y, NaN]), eps ("single"))
 %!assert (hygecdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error hygecdf ()
 %!error hygecdf (1)
 %!error hygecdf (1,2)
 %!error hygecdf (1,2,3)
 %!error hygecdf (1,2,3,4,5)
 %!error hygecdf (ones (2), ones (3), 1, 1)
 %!error hygecdf (1, ones (2), ones (3), 1)
 %!error hygecdf (1, 1, ones (2), ones (3))
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -34,28 +34,29 @@
 ## Description: Random deviates from the hypergeometric distribution
 
 function inv = hygeinv (x, t, m, n)
 
   if (nargin != 4)
     print_usage ();
   endif
 
-  if (!isscalar (t) || !isscalar (m) || !isscalar (n))
+  if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
     [retval, x, t, m, n] = common_size (x, t, m, n);
     if (retval > 0)
       error ("hygeinv: X, T, M, and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (t) || iscomplex (m) || iscomplex (n))
     error ("hygeinv: X, T, M, and N must not be complex");
   endif
 
-  if (isa (x, "single") || isa (t, "single") || isa (m, "single") || isa (n, "single"))
+  if (isa (x, "single") || isa (t, "single")
+      || isa (m, "single") || isa (n, "single"))
     inv = NaN (size (x), "single");
   else
     inv = NaN (size (x));
   endif
 
   ok = ((t >= 0) & (m >= 0) & (n > 0) & (m <= t) & (n <= t) &
         (t == fix (t)) & (m == fix (m)) & (n == fix (n)));
 
@@ -86,24 +87,24 @@ endfunction
 %!assert (hygeinv (x, 4, 2, 2*ones (1,5)), [NaN 0 1 2 NaN])
 %!assert (hygeinv (x, 4*[1 -1 NaN 1.1 1], 2, 2), [NaN NaN NaN NaN NaN])
 %!assert (hygeinv (x, 4, 2*[1 -1 NaN 1.1 1], 2), [NaN NaN NaN NaN NaN])
 %!assert (hygeinv (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
 %!assert (hygeinv (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [NaN NaN NaN NaN NaN])
 %!assert (hygeinv (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
 %!assert (hygeinv ([x(1:2) NaN x(4:5)], 4, 2, 2), [NaN 0 NaN 2 NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (hygeinv ([x, NaN], 4, 2, 2), [NaN 0 1 2 NaN NaN])
 %!assert (hygeinv (single ([x, NaN]), 4, 2, 2), single ([NaN 0 1 2 NaN NaN]))
 %!assert (hygeinv ([x, NaN], single (4), 2, 2), single ([NaN 0 1 2 NaN NaN]))
 %!assert (hygeinv ([x, NaN], 4, single (2), 2), single ([NaN 0 1 2 NaN NaN]))
 %!assert (hygeinv ([x, NaN], 4, 2, single (2)), single ([NaN 0 1 2 NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error hygeinv ()
 %!error hygeinv (1)
 %!error hygeinv (1,2)
 %!error hygeinv (1,2,3)
 %!error hygeinv (1,2,3,4,5)
 %!error hygeinv (ones (2), ones (3), 1, 1)
 %!error hygeinv (1, ones (2), ones (3), 1)
 %!error hygeinv (1, 1, ones (2), ones (3))
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -33,28 +33,29 @@
 ## Description: PDF of the hypergeometric distribution
 
 function pdf = hygepdf (x, t, m, n)
 
   if (nargin != 4)
     print_usage ();
   endif
 
-  if (!isscalar (t) || !isscalar (m) || !isscalar (n))
+  if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
     [retval, x, t, m, n] = common_size (x, t, m, n);
     if (retval > 0)
       error ("hygepdf: X, T, M, and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (t) || iscomplex (m) || iscomplex (n))
     error ("hygepdf: X, T, M, and N must not be complex");
   endif
 
-  if (isa (x, "single") || isa (t, "single") || isa (m, "single") || isa (n, "single"))
+  if (isa (x, "single") || isa (t, "single")
+      || isa (m, "single") || isa (n, "single"))
     pdf = zeros (size (x), "single");
   else
     pdf = zeros (size (x));
   endif
 
   ## everything in nel gives NaN
   nel = (isnan (x) | (t < 0) | (m < 0) | (n <= 0) | (m > t) | (n > t) |
         (t != fix (t)) | (m != fix (m)) | (n != fix (n)));
@@ -85,23 +86,23 @@ endfunction
 %!assert (hygepdf (x, 4, 2, 2*ones (1,5)), y)
 %!assert (hygepdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [0 NaN NaN NaN 0])
 %!assert (hygepdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [0 NaN NaN NaN 0])
 %!assert (hygepdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
 %!assert (hygepdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [0 NaN NaN NaN 0])
 %!assert (hygepdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
 %!assert (hygepdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (hygepdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]))
 %!assert (hygepdf ([x, NaN], single (4), 2, 2), single ([y, NaN]))
 %!assert (hygepdf ([x, NaN], 4, single (2), 2), single ([y, NaN]))
 %!assert (hygepdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error hygepdf ()
 %!error hygepdf (1)
 %!error hygepdf (1,2)
 %!error hygepdf (1,2,3)
 %!error hygepdf (1,2,3,4,5)
 %!error hygepdf (1, ones (3), ones (2), ones (2))
 %!error hygepdf (1, ones (2), ones (3), ones (2))
 %!error hygepdf (1, ones (2), ones (2), ones (3))
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -61,23 +61,23 @@ function rnd = hygernd (t, m, n, varargi
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("hygernd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 4)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("hygernd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (t) && !isequal (size (t), sz))
+  if (! isscalar (t) && ! isequal (size (t), sz))
     error ("hygernd: T, M, and N must be scalar or of size SZ");
   endif
 
   if (isa (t, "single") || isa (m, "single") || isa (n, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -124,17 +124,17 @@ endfunction
 %!assert (class (hygernd (4,2,2)), "double")
 %!assert (class (hygernd (single (4),2,2)), "single")
 %!assert (class (hygernd (single ([4 4]),2,2)), "single")
 %!assert (class (hygernd (4,single (2),2)), "single")
 %!assert (class (hygernd (4,single ([2 2]),2)), "single")
 %!assert (class (hygernd (4,2,single (2))), "single")
 %!assert (class (hygernd (4,2,single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error hygernd ()
 %!error hygernd (1)
 %!error hygernd (1,2)
 %!error hygernd (ones (3), ones (2), ones (2), 2)
 %!error hygernd (ones (2), ones (3), ones (2), 2)
 %!error hygernd (ones (2), ones (2), ones (3), 2)
 %!error hygernd (i, 2, 2)
 %!error hygernd (2, i, 2)
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -82,14 +82,14 @@ function cdf = kolmogorov_smirnov_cdf (x
     odd = find (rem (k, 2) == 1);
     A(odd,:) = -A(odd,:);
     cdf(ind) = 1 + 2 * sum (A);
   endif
 
 endfunction
 
 
-%% Test input validation
+## Test input validation
 %!error kolmogorov_smirnov_cdf ()
 %!error kolmogorov_smirnov_cdf (1,2,3)
 %!error kolmogorov_smirnov_cdf (1, ones (2))
 %!error kolmogorov_smirnov_cdf ([], 1)
 
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -41,16 +41,16 @@ function cdf = laplace_cdf (x)
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
 %! y = [0, 1/4, 1/2, 3/4, 1];
 %!assert (laplace_cdf ([x, NaN]), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (laplace_cdf (single ([x, NaN])), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error laplace_cdf ()
 %!error laplace_cdf (1,2)
 %!error laplace_cdf (i)
 
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -48,17 +48,17 @@ function inv = laplace_inv (x)
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (laplace_inv (x), [NaN -Inf 0 Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (laplace_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
 %!assert (laplace_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error laplace_inv ()
 %!error laplace_inv (1,2)
 %!error laplace_inv (i)
 
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -41,16 +41,16 @@ function pdf = laplace_pdf (x)
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
 %! y = [0, 1/4, 1/2, 1/4, 0];
 %!assert (laplace_pdf ([x, NaN]), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (laplace_pdf (single ([x, NaN])), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error laplace_pdf ()
 %!error laplace_pdf (1,2)
 %!error laplace_pdf (i)
 
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -43,32 +43,32 @@ function rnd = laplace_rnd (varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1}(:)';
     else
       error ("laplace_rnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 1)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("laplace_rnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
   tmp = rand (sz);
   rnd = (tmp < 1/2) .* log (2 * tmp) - (tmp > 1/2) .* log (2 * (1 - tmp));
 
 endfunction
 
 
 %!assert (size (laplace_rnd (3)), [3, 3])
 %!assert (size (laplace_rnd ([4 1])), [4, 1])
 %!assert (size (laplace_rnd (4,1)), [4, 1])
 
-%% Test input validation
+## Test input validation
 %!error laplace_rnd ()
 %!error laplace_rnd (-1)
 %!error laplace_rnd (ones (2))
 %!error laplace_rnd ([2 -1 2])
 %!error laplace_rnd (1, ones (2))
 %!error laplace_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -41,16 +41,16 @@ function cdf = logistic_cdf (x)
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(3) 0 log(3) Inf];
 %! y = [0, 1/4, 1/2, 3/4, 1];
 %!assert (logistic_cdf ([x, NaN]), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (logistic_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error logistic_cdf ()
 %!error logistic_cdf (1,2)
 %!error logistic_cdf (i)
 
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -53,17 +53,17 @@ function inv = logistic_inv (x)
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (logistic_inv (x), [NaN -Inf 0 Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (logistic_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
 %!assert (logistic_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error logistic_inv ()
 %!error logistic_inv (1,2)
 %!error logistic_inv (i)
 
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -41,16 +41,16 @@ function pdf = logistic_pdf (x)
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(4) 0 log(4) Inf];
 %! y = [0, 0.16, 1/4, 0.16, 0];
 %!assert (logistic_pdf ([x, NaN]), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (logistic_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error logistic_pdf ()
 %!error logistic_pdf (1,2)
 %!error logistic_pdf (i)
 
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -43,31 +43,31 @@ function rnd = logistic_rnd (varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("logistic_rnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 1)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("logistic_rnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
   rnd = - log (1 ./ rand (sz) - 1);
 
 endfunction
 
 
 %!assert (size (logistic_rnd (3)), [3, 3])
 %!assert (size (logistic_rnd ([4 1])), [4, 1])
 %!assert (size (logistic_rnd (4,1)), [4, 1])
 
-%% Test input validation
+## Test input validation
 %!error logistic_rnd ()
 %!error logistic_rnd (-1)
 %!error logistic_rnd (ones (2))
 %!error logistic_rnd ([2 -1 2])
 %!error logistic_rnd (1, ones (2))
 %!error logistic_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -33,17 +33,17 @@
 ## Description: CDF of the log normal distribution
 
 function cdf = logncdf (x, mu = 0, sigma = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
       error ("logncdf: X, MU, and SIGMA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
     error ("logncdf: X, MU, and SIGMA must not be complex");
@@ -76,23 +76,23 @@ endfunction
 %! y = [0, 0, 0.5, 1/2+1/2*erf(1/2), 1];
 %!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y, eps)
 %!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y, eps)
 %!assert (logncdf (x, zeros (1,5), sqrt(2)), y, eps)
 %!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)], eps)
 %!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)], eps)
 %!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN], eps)
 %!assert (logncdf (single ([x, NaN]), 0, sqrt(2)), single ([y, NaN]), eps ("single"))
 %!assert (logncdf ([x, NaN], single (0), sqrt(2)), single ([y, NaN]), eps ("single"))
 %!assert (logncdf ([x, NaN], 0, single (sqrt(2))), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error logncdf ()
 %!error logncdf (1,2)
 %!error logncdf (1,2,3,4)
 %!error logncdf (ones (3), ones (2), ones (2))
 %!error logncdf (ones (2), ones (3), ones (2))
 %!error logncdf (ones (2), ones (2), ones (3))
 %!error logncdf (i, 2, 2)
 %!error logncdf (2, i, 2)
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
--- a/scripts/statistics/distributions/logninv.m
+++ b/scripts/statistics/distributions/logninv.m
@@ -33,17 +33,17 @@
 ## Description: Quantile function of the log normal distribution
 
 function inv = logninv (x, mu = 0, sigma = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
       error ("logninv: X, MU, and SIGMA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
     error ("logninv: X, MU, and SIGMA must not be complex");
@@ -75,23 +75,23 @@ endfunction
 %! x = [-1 0 0.5 1 2];
 %!assert (logninv (x, ones (1,5), ones (1,5)), [NaN 0 e Inf NaN])
 %!assert (logninv (x, 1, ones (1,5)), [NaN 0 e Inf NaN])
 %!assert (logninv (x, ones (1,5), 1), [NaN 0 e Inf NaN])
 %!assert (logninv (x, [1 1 NaN 0 1], 1), [NaN 0 NaN Inf NaN])
 %!assert (logninv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
 %!assert (logninv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (logninv ([x, NaN], 1, 1), [NaN 0 e Inf NaN NaN])
 %!assert (logninv (single ([x, NaN]), 1, 1), single ([NaN 0 e Inf NaN NaN]))
 %!assert (logninv ([x, NaN], single (1), 1), single ([NaN 0 e Inf NaN NaN]))
 %!assert (logninv ([x, NaN], 1, single (1)), single ([NaN 0 e Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error logninv ()
 %!error logninv (1,2)
 %!error logninv (1,2,3,4)
 %!error logninv (ones (3), ones (2), ones (2))
 %!error logninv (ones (2), ones (3), ones (2))
 %!error logninv (ones (2), ones (2), ones (3))
 %!error logninv (i, 2, 2)
 %!error logninv (2, i, 2)
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
--- a/scripts/statistics/distributions/lognpdf.m
+++ b/scripts/statistics/distributions/lognpdf.m
@@ -33,17 +33,17 @@
 ## Description: PDF of the log normal distribution
 
 function pdf = lognpdf (x, mu = 0, sigma = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
       error ("lognpdf: X, MU, and SIGMA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
     error ("lognpdf: X, MU, and SIGMA must not be complex");
@@ -73,22 +73,22 @@ endfunction
 %! y = [0, 0, 1/(e*sqrt(2*pi)) * exp(-1/2), 0];
 %!assert (lognpdf (x, zeros (1,4), ones (1,4)), y, eps)
 %!assert (lognpdf (x, 0, ones (1,4)), y, eps)
 %!assert (lognpdf (x, zeros (1,4), 1), y, eps)
 %!assert (lognpdf (x, [0 1 NaN 0], 1), [0 0 NaN y(4)], eps)
 %!assert (lognpdf (x, 0, [0 NaN Inf 1]), [NaN NaN NaN y(4)], eps)
 %!assert (lognpdf ([x, NaN], 0, 1), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (lognpdf (single ([x, NaN]), 0, 1), single ([y, NaN]), eps ("single"))
 %!assert (lognpdf ([x, NaN], single (0), 1), single ([y, NaN]), eps ("single"))
 %!assert (lognpdf ([x, NaN], 0, single (1)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error lognpdf ()
 %!error lognpdf (1,2)
 %!error lognpdf (1,2,3,4)
 %!error lognpdf (ones (3), ones (2), ones (2))
 %!error lognpdf (ones (2), ones (3), ones (2))
 %!error lognpdf (ones (2), ones (2), ones (3))
 %!error lognpdf (i, 2, 2)
 %!error lognpdf (2, i, 2)
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the log normal distribution
 
 function rnd = lognrnd (mu, sigma, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, mu, sigma] = common_size (mu, sigma);
     if (retval > 0)
       error ("lognrnd: MU and SIGMA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (mu) || iscomplex (sigma))
     error ("lognrnd: MU and SIGMA must not be complex");
@@ -61,23 +61,23 @@ function rnd = lognrnd (mu, sigma, varar
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("lognrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("lognrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (mu) && !isequal (size (mu), sz))
+  if (! isscalar (mu) && ! isequal (size (mu), sz))
     error ("lognrnd: MU and SIGMA must be scalar or of size SZ");
   endif
 
   if (isa (mu, "single") || isa (sigma, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -102,24 +102,24 @@ endfunction
 %!assert (size (lognrnd (ones (2,1), 2)), [2, 1])
 %!assert (size (lognrnd (ones (2,2), 2)), [2, 2])
 %!assert (size (lognrnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (lognrnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (lognrnd (1, 2, 3)), [3, 3])
 %!assert (size (lognrnd (1, 2, [4 1])), [4, 1])
 %!assert (size (lognrnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (lognrnd (1, 2)), "double")
 %!assert (class (lognrnd (single (1), 2)), "single")
 %!assert (class (lognrnd (single ([1 1]), 2)), "single")
 %!assert (class (lognrnd (1, single (2))), "single")
 %!assert (class (lognrnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error lognrnd ()
 %!error lognrnd (1)
 %!error lognrnd (ones (3), ones (2))
 %!error lognrnd (ones (2), ones (3))
 %!error lognrnd (i, 2)
 %!error lognrnd (2, i)
 %!error lognrnd (1,2, -1)
 %!error lognrnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -35,17 +35,17 @@
 ## Description: CDF of the Pascal (negative binomial) distribution
 
 function cdf = nbincdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (n) || !isscalar (p))
+  if (! isscalar (n) || ! isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("nbincdf: X, N, and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n) || iscomplex (p))
     error ("nbincdf: X, N, and P must not be complex");
@@ -80,23 +80,23 @@ endfunction
 %! y = [0 1/2 3/4 7/8 1];
 %!assert (nbincdf (x, ones (1,5), 0.5*ones (1,5)), y)
 %!assert (nbincdf (x, 1, 0.5*ones (1,5)), y)
 %!assert (nbincdf (x, ones (1,5), 0.5), y)
 %!assert (nbincdf ([x(1:3) 0 x(5)], [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN nbinpdf(0,1.5,0.5) NaN], eps)
 %!assert (nbincdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
 %!assert (nbincdf ([x(1:2) NaN x(4:5)], 1, 0.5), [y(1:2) NaN y(4:5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (nbincdf ([x, NaN], 1, 0.5), [y, NaN])
 %!assert (nbincdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
 %!assert (nbincdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
 %!assert (nbincdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error nbincdf ()
 %!error nbincdf (1)
 %!error nbincdf (1,2)
 %!error nbincdf (1,2,3,4)
 %!error nbincdf (ones (3), ones (2), ones (2))
 %!error nbincdf (ones (2), ones (3), ones (2))
 %!error nbincdf (ones (2), ones (2), ones (3))
 %!error nbincdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -35,17 +35,17 @@
 ## Description: Quantile function of the Pascal distribution
 
 function inv = nbininv (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (n) || !isscalar (p))
+  if (! isscalar (n) || ! isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("nbininv: X, N, and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n) || iscomplex (p))
     error ("nbininv: X, N, and P must not be complex");
@@ -103,23 +103,23 @@ endfunction
 %!assert (nbininv (x, ones (1,5), 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
 %!assert (nbininv (x, 1, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
 %!assert (nbininv (x, ones (1,5), 0.5), [NaN 0 1 Inf NaN])
 %!assert (nbininv (x, [1 0 NaN Inf 1], 0.5), [NaN NaN NaN NaN NaN])
 %!assert (nbininv (x, [1 0 1.5 Inf 1], 0.5), [NaN NaN 2 NaN NaN])
 %!assert (nbininv (x, 1, 0.5*[1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
 %!assert (nbininv ([x(1:2) NaN x(4:5)], 1, 0.5), [NaN 0 NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (nbininv ([x, NaN], 1, 0.5), [NaN 0 1 Inf NaN NaN])
 %!assert (nbininv (single ([x, NaN]), 1, 0.5), single ([NaN 0 1 Inf NaN NaN]))
 %!assert (nbininv ([x, NaN], single (1), 0.5), single ([NaN 0 1 Inf NaN NaN]))
 %!assert (nbininv ([x, NaN], 1, single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error nbininv ()
 %!error nbininv (1)
 %!error nbininv (1,2)
 %!error nbininv (1,2,3,4)
 %!error nbininv (ones (3), ones (2), ones (2))
 %!error nbininv (ones (2), ones (3), ones (2))
 %!error nbininv (ones (2), ones (2), ones (3))
 %!error nbininv (i, 2, 2)
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -35,17 +35,17 @@
 ## Description: PDF of the Pascal (negative binomial) distribution
 
 function pdf = nbinpdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (n) || !isscalar (p))
+  if (! isscalar (n) || ! isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("nbinpdf: X, N, and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n) || iscomplex (p))
     error ("nbinpdf: X, N, and P must not be complex");
@@ -78,22 +78,22 @@ endfunction
 %! y = [0 1/2 1/4 1/8 NaN];
 %!assert (nbinpdf (x, ones (1,5), 0.5*ones (1,5)), y)
 %!assert (nbinpdf (x, 1, 0.5*ones (1,5)), y)
 %!assert (nbinpdf (x, ones (1,5), 0.5), y)
 %!assert (nbinpdf (x, [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN 1.875*0.5^1.5/4 NaN], eps)
 %!assert (nbinpdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
 %!assert (nbinpdf ([x, NaN], 1, 0.5), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (nbinpdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
 %!assert (nbinpdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
 %!assert (nbinpdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error nbinpdf ()
 %!error nbinpdf (1)
 %!error nbinpdf (1,2)
 %!error nbinpdf (1,2,3,4)
 %!error nbinpdf (ones (3), ones (2), ones (2))
 %!error nbinpdf (ones (2), ones (3), ones (2))
 %!error nbinpdf (ones (2), ones (2), ones (3))
 %!error nbinpdf (i, 2, 2)
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = nbinrnd (n, p, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (n) || !isscalar (p))
+  if (! isscalar (n) || ! isscalar (p))
     [retval, n, p] = common_size (n, p);
     if (retval > 0)
       error ("nbinrnd: N and P must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (n) || iscomplex (p))
     error ("nbinrnd: N and P must not be complex");
@@ -61,23 +61,23 @@ function rnd = nbinrnd (n, p, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("nbinrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("nbinrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (n) && !isequal (size (n), sz))
+  if (! isscalar (n) && ! isequal (size (n), sz))
     error ("nbinrnd: N and P must be scalar or of size SZ");
   endif
 
   if (isa (n, "single") || isa (p, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -107,24 +107,24 @@ endfunction
 %!assert (size (nbinrnd (2*ones (2,1), 1/2)), [2, 1])
 %!assert (size (nbinrnd (2*ones (2,2), 1/2)), [2, 2])
 %!assert (size (nbinrnd (2, 1/2*ones (2,1))), [2, 1])
 %!assert (size (nbinrnd (2, 1/2*ones (2,2))), [2, 2])
 %!assert (size (nbinrnd (2, 1/2, 3)), [3, 3])
 %!assert (size (nbinrnd (2, 1/2, [4 1])), [4, 1])
 %!assert (size (nbinrnd (2, 1/2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (nbinrnd (2, 1/2)), "double")
 %!assert (class (nbinrnd (single (2), 1/2)), "single")
 %!assert (class (nbinrnd (single ([2 2]), 1/2)), "single")
 %!assert (class (nbinrnd (2, single (1/2))), "single")
 %!assert (class (nbinrnd (2, single ([1/2 1/2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error nbinrnd ()
 %!error nbinrnd (1)
 %!error nbinrnd (ones (3), ones (2))
 %!error nbinrnd (ones (2), ones (3))
 %!error nbinrnd (i, 2)
 %!error nbinrnd (2, i)
 %!error nbinrnd (1,2, -1)
 %!error nbinrnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -31,17 +31,17 @@
 ## Description: CDF of the normal distribution
 
 function cdf = normcdf (x, mu = 0, sigma = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
       error ("normcdf: X, MU, and SIGMA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
     error ("normcdf: X, MU, and SIGMA must not be complex");
@@ -75,23 +75,23 @@ endfunction
 %! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
 %!assert (normcdf (x, ones (1,4), ones (1,4)), y)
 %!assert (normcdf (x, 1, ones (1,4)), y)
 %!assert (normcdf (x, ones (1,4), 1), y)
 %!assert (normcdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
 %!assert (normcdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
 %!assert (normcdf ([x(1:2) NaN x(4)], 1, 1), [y(1:2) NaN y(4)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (normcdf ([x, NaN], 1, 1), [y, NaN])
 %!assert (normcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
 %!assert (normcdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
 %!assert (normcdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error normcdf ()
 %!error normcdf (1,2)
 %!error normcdf (1,2,3,4)
 %!error normcdf (ones (3), ones (2), ones (2))
 %!error normcdf (ones (2), ones (3), ones (2))
 %!error normcdf (ones (2), ones (2), ones (3))
 %!error normcdf (i, 2, 2)
 %!error normcdf (2, i, 2)
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -31,17 +31,17 @@
 ## Description: Quantile function of the normal distribution
 
 function inv = norminv (x, mu = 0, sigma = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
       error ("norminv: X, MU, and SIGMA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
     error ("norminv: X, MU, and SIGMA must not be complex");
@@ -50,17 +50,17 @@ function inv = norminv (x, mu = 0, sigma
   if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
     inv = NaN (size (x), "single");
   else
     inv = NaN (size (x));
   endif
 
   if (isscalar (mu) && isscalar (sigma))
     if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
-      inv =  mu + sigma * stdnormal_inv (x);
+      inv = mu + sigma * stdnormal_inv (x);
     endif
   else
     k = isfinite (mu) & (sigma > 0) & (sigma < Inf);
     inv(k) = mu(k) + sigma(k) .* stdnormal_inv (x(k));
   endif
 
 endfunction
 
@@ -69,23 +69,23 @@ endfunction
 %! x = [-1 0 0.5 1 2];
 %!assert (norminv (x, ones (1,5), ones (1,5)), [NaN -Inf 1 Inf NaN])
 %!assert (norminv (x, 1, ones (1,5)), [NaN -Inf 1 Inf NaN])
 %!assert (norminv (x, ones (1,5), 1), [NaN -Inf 1 Inf NaN])
 %!assert (norminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
 %!assert (norminv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
 %!assert (norminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN -Inf NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (norminv ([x, NaN], 1, 1), [NaN -Inf 1 Inf NaN NaN])
 %!assert (norminv (single ([x, NaN]), 1, 1), single ([NaN -Inf 1 Inf NaN NaN]))
 %!assert (norminv ([x, NaN], single (1), 1), single ([NaN -Inf 1 Inf NaN NaN]))
 %!assert (norminv ([x, NaN], 1, single (1)), single ([NaN -Inf 1 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error norminv ()
 %!error norminv (1,2)
 %!error norminv (1,2,3,4)
 %!error norminv (ones (3), ones (2), ones (2))
 %!error norminv (ones (2), ones (3), ones (2))
 %!error norminv (ones (2), ones (2), ones (3))
 %!error norminv (i, 2, 2)
 %!error norminv (2, i, 2)
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -31,17 +31,17 @@
 ## Description: PDF of the normal distribution
 
 function pdf = normpdf (x, mu = 0, sigma = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, x, mu, sigma] = common_size (x, mu, sigma);
     if (retval > 0)
       error ("normpdf: X, MU, and SIGMA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
     error ("normpdf: X, MU, and SIGMA must not be complex");
@@ -58,39 +58,39 @@ function pdf = normpdf (x, mu = 0, sigma
       pdf = stdnormal_pdf ((x - mu) / sigma) / sigma;
     else
       pdf = NaN (size (x), class (pdf));
     endif
   else
     k = isinf (mu) | !(sigma > 0) | !(sigma < Inf);
     pdf(k) = NaN;
 
-    k = !isinf (mu) & (sigma > 0) & (sigma < Inf);
+    k = ! isinf (mu) & (sigma > 0) & (sigma < Inf);
     pdf(k) = stdnormal_pdf ((x(k) - mu(k)) ./ sigma(k)) ./ sigma(k);
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 1 2 Inf];
 %! y = 1/sqrt(2*pi)*exp (-(x-1).^2/2);
 %!assert (normpdf (x, ones (1,4), ones (1,4)), y)
 %!assert (normpdf (x, 1, ones (1,4)), y)
 %!assert (normpdf (x, ones (1,4), 1), y)
 %!assert (normpdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
 %!assert (normpdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
 %!assert (normpdf ([x, NaN], 1, 1), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (normpdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
 %!assert (normpdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
 %!assert (normpdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error normpdf ()
 %!error normpdf (1,2)
 %!error normpdf (1,2,3,4)
 %!error normpdf (ones (3), ones (2), ones (2))
 %!error normpdf (ones (2), ones (3), ones (2))
 %!error normpdf (ones (2), ones (2), ones (3))
 %!error normpdf (i, 2, 2)
 %!error normpdf (2, i, 2)
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the normal distribution
 
 function rnd = normrnd (mu, sigma, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (mu) || !isscalar (sigma))
+  if (! isscalar (mu) || ! isscalar (sigma))
     [retval, mu, sigma] = common_size (mu, sigma);
     if (retval > 0)
       error ("normrnd: mu and sigma must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (mu) || iscomplex (sigma))
     error ("normrnd: MU and SIGMA must not be complex");
@@ -61,35 +61,35 @@ function rnd = normrnd (mu, sigma, varar
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("normrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("normrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (mu) && !isequal (size (mu), sz))
+  if (! isscalar (mu) && ! isequal (size (mu), sz))
     error ("normrnd: mu and sigma must be scalar or of size SZ");
   endif
 
   if (isa (mu, "single") || isa (sigma, "single"))
     cls = "single";
   else
     cls = "double";
   endif
 
   if (isscalar (mu) && isscalar (sigma))
     if (isfinite (mu) && (sigma >= 0) && (sigma < Inf))
-      rnd =  mu + sigma * randn (sz, cls);
+      rnd = mu + sigma * randn (sz, cls);
     else
       rnd = NaN (sz, cls);
     endif
   else
     rnd = mu + sigma .* randn (sz, cls);
     k = ! isfinite (mu) | !(sigma > 0) | !(sigma < Inf);
     rnd(k) = NaN;
   endif
@@ -101,24 +101,24 @@ endfunction
 %!assert (size (normrnd (ones (2,1), 2)), [2, 1])
 %!assert (size (normrnd (ones (2,2), 2)), [2, 2])
 %!assert (size (normrnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (normrnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (normrnd (1, 2, 3)), [3, 3])
 %!assert (size (normrnd (1, 2, [4 1])), [4, 1])
 %!assert (size (normrnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (normrnd (1, 2)), "double")
 %!assert (class (normrnd (single (1), 2)), "single")
 %!assert (class (normrnd (single ([1 1]), 2)), "single")
 %!assert (class (normrnd (1, single (2))), "single")
 %!assert (class (normrnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error normrnd ()
 %!error normrnd (1)
 %!error normrnd (ones (3), ones (2))
 %!error normrnd (ones (2), ones (3))
 %!error normrnd (i, 2)
 %!error normrnd (2, i)
 %!error normrnd (1,2, -1)
 %!error normrnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -28,17 +28,17 @@
 ## Description: CDF of the Poisson distribution
 
 function cdf = poisscdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (lambda))
+  if (! isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("poisscdf: X and LAMBDA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (lambda))
     error ("poisscdf: X and LAMBDA must not be complex");
@@ -69,22 +69,22 @@ endfunction
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0, gammainc(1, (x(2:4) +1), "upper"), 1];
 %!assert (poisscdf (x, ones (1,5)), y)
 %!assert (poisscdf (x, 1), y)
 %!assert (poisscdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
 %!assert (poisscdf ([x(1:2) NaN Inf x(5)], 1), [y(1:2) NaN 1 y(5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (poisscdf ([x, NaN], 1), [y, NaN])
 %!assert (poisscdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
 %!assert (poisscdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error poisscdf ()
 %!error poisscdf (1)
 %!error poisscdf (1,2,3)
 %!error poisscdf (ones (3), ones (2))
 %!error poisscdf (ones (2), ones (3))
 %!error poisscdf (i, 2)
 %!error poisscdf (2, i)
 
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -28,17 +28,17 @@
 ## Description: Quantile function of the Poisson distribution
 
 function inv = poissinv (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (lambda))
+  if (! isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("poissinv: X and LAMBDA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (lambda))
     error ("poissinv: X and LAMBDA must not be complex");
@@ -82,22 +82,22 @@ endfunction
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (poissinv (x, ones (1,5)), [NaN 0 1 Inf NaN])
 %!assert (poissinv (x, 1), [NaN 0 1 Inf NaN])
 %!assert (poissinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN])
 %!assert (poissinv ([x(1:2) NaN x(4:5)], 1), [NaN 0 NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (poissinv ([x, NaN], 1), [NaN 0 1 Inf NaN NaN])
 %!assert (poissinv (single ([x, NaN]), 1), single ([NaN 0 1 Inf NaN NaN]))
 %!assert (poissinv ([x, NaN], single (1)), single ([NaN 0 1 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error poissinv ()
 %!error poissinv (1)
 %!error poissinv (1,2,3)
 %!error poissinv (ones (3), ones (2))
 %!error poissinv (ones (2), ones (3))
 %!error poissinv (i, 2)
 %!error poissinv (2, i)
 
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -27,17 +27,17 @@
 ## Description: PDF of the Poisson distribution
 
 function pdf = poisspdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (lambda))
+  if (! isscalar (lambda))
     [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("poisspdf: X and LAMBDA must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (lambda))
     error ("poisspdf: X and LAMBDA must not be complex");
@@ -65,21 +65,21 @@ endfunction
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0, exp(-1)*[1 1 0.5], 0];
 %!assert (poisspdf (x, ones (1,5)), y, eps)
 %!assert (poisspdf (x, 1), y, eps)
 %!assert (poisspdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
 %!assert (poisspdf ([x, NaN], 1), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (poisspdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
 %!assert (poisspdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error poisspdf ()
 %!error poisspdf (1)
 %!error poisspdf (1,2,3)
 %!error poisspdf (ones (3), ones (2))
 %!error poisspdf (ones (2), ones (3))
 %!error poisspdf (i, 2)
 %!error poisspdf (2, i)
 
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -50,23 +50,23 @@ function rnd = poissrnd (lambda, varargi
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("poissrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 2)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("poissrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (lambda) && !isequal (size (lambda), sz))
+  if (! isscalar (lambda) && ! isequal (size (lambda), sz))
     error ("poissrnd: LAMBDA must be scalar or of size SZ");
   endif
 
   if (iscomplex (lambda))
     error ("poissrnd: LAMBDA must not be complex");
   endif
 
   if (isa (lambda, "single"))
@@ -93,22 +93,22 @@ endfunction
 
 %!assert (size (poissrnd (2)), [1, 1])
 %!assert (size (poissrnd (ones (2,1))), [2, 1])
 %!assert (size (poissrnd (ones (2,2))), [2, 2])
 %!assert (size (poissrnd (1, 3)), [3, 3])
 %!assert (size (poissrnd (1, [4 1])), [4, 1])
 %!assert (size (poissrnd (1, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (poissrnd (2)), "double")
 %!assert (class (poissrnd (single (2))), "single")
 %!assert (class (poissrnd (single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error poissrnd ()
 %!error poissrnd (1, -1)
 %!error poissrnd (1, ones (2))
 %!error poissrnd (1, 2, ones (2))
 %!error poissrnd (i)
 %!error poissrnd (1, 2, -1)
 %!error poissrnd (1, [2 -1 2])
 %!error poissrnd (ones (2,2), 3)
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -42,16 +42,16 @@ function cdf = stdnormal_cdf (x)
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
 %!assert (stdnormal_cdf ([x, NaN]), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (stdnormal_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error stdnormal_cdf ()
 %!error stdnormal_cdf (1,2)
 %!error stdnormal_cdf (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -41,17 +41,17 @@ function inv = stdnormal_inv (x)
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (stdnormal_inv (x), [NaN -Inf 0 Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (stdnormal_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
 %!assert (stdnormal_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error stdnormal_inv ()
 %!error stdnormal_inv (1,2)
 %!error stdnormal_inv (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -42,16 +42,16 @@ function pdf = stdnormal_pdf (x)
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = 1/sqrt(2*pi)*exp (-x.^2/2);
 %!assert (stdnormal_pdf ([x, NaN]), [y, NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (stdnormal_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error stdnormal_pdf ()
 %!error stdnormal_pdf (1,2)
 %!error stdnormal_pdf (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -44,31 +44,31 @@ function rnd = stdnormal_rnd (varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("stdnormal_rnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 1)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("stdnormal_rnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
   rnd = randn (sz);
 
 endfunction
 
 
 %!assert (size (stdnormal_rnd (3)), [3, 3])
 %!assert (size (stdnormal_rnd ([4 1])), [4, 1])
 %!assert (size (stdnormal_rnd (4,1)), [4, 1])
 
-%% Test input validation
+## Test input validation
 %!error stdnormal_rnd ()
 %!error stdnormal_rnd (-1)
 %!error stdnormal_rnd (ones (2))
 %!error stdnormal_rnd ([2 -1 2])
 %!error stdnormal_rnd (1, ones (2))
 %!error stdnormal_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -29,34 +29,34 @@
 ## Description: CDF of the t distribution
 
 function cdf = tcdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (n))
+  if (! isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("tcdf: X and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n))
     error ("tcdf: X and N must not be complex");
   endif
 
   if (isa (x, "single") || isa (n, "single"))
     cdf = zeros (size (x), "single");
   else
     cdf = zeros (size (x));
   endif
 
-  k = !isinf (x) & (n > 0);
+  k = ! isinf (x) & (n > 0);
 
   xx = x .^ 2;
   x_big_abs = (xx > n);
 
   ## deal with the case "abs(x) big"
   kk = k & x_big_abs;
   if (isscalar (n))
     cdf(kk) = betainc (n ./ (n + xx(kk)), n/2, 1/2) / 2;
@@ -89,22 +89,22 @@ endfunction
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = [0 1/2 3/4 1];
 %!assert (tcdf (x, ones (1,4)), y, eps)
 %!assert (tcdf (x, 1), y, eps)
 %!assert (tcdf (x, [0 1 NaN 1]), [NaN 1/2 NaN 1], eps)
 %!assert (tcdf ([x(1:2) NaN x(4)], 1), [y(1:2) NaN y(4)], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (tcdf ([x, NaN], 1), [y, NaN], eps)
 %!assert (tcdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
 %!assert (tcdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error tcdf ()
 %!error tcdf (1)
 %!error tcdf (1,2,3)
 %!error tcdf (ones (3), ones (2))
 %!error tcdf (ones (2), ones (3))
 %!error tcdf (i, 2)
 %!error tcdf (2, i)
 
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -33,17 +33,17 @@
 ## Description: Quantile function of the t distribution
 
 function inv = tinv (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (n))
+  if (! isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("tinv: X and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n))
     error ("tinv: X and N must not be complex");
@@ -87,22 +87,22 @@ endfunction
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (tinv (x, ones (1,5)), [NaN -Inf 0 Inf NaN])
 %!assert (tinv (x, 1), [NaN -Inf 0 Inf NaN], eps)
 %!assert (tinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
 %!assert (tinv ([x(1:2) NaN x(4:5)], 1), [NaN -Inf NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (tinv ([x, NaN], 1), [NaN -Inf 0 Inf NaN NaN], eps)
 %!assert (tinv (single ([x, NaN]), 1), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
 %!assert (tinv ([x, NaN], single (1)), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error tinv ()
 %!error tinv (1)
 %!error tinv (1,2,3)
 %!error tinv (ones (3), ones (2))
 %!error tinv (ones (2), ones (3))
 %!error tinv (i, 2)
 %!error tinv (2, i)
 
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -28,17 +28,17 @@
 ## Description: PDF of the t distribution
 
 function pdf = tpdf (x, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (n))
+  if (! isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("tpdf: X and N must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (n))
     error ("tpdf: X and N must not be complex");
@@ -72,22 +72,22 @@ endfunction
 
 %!shared x,y
 %! x = [-Inf 0 0.5 1 Inf];
 %! y = 1./(pi * (1 + x.^2));
 %!assert (tpdf (x, ones (1,5)), y, eps)
 %!assert (tpdf (x, 1), y, eps)
 %!assert (tpdf (x, [0 NaN 1 1 1]), [NaN NaN y(3:5)], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (tpdf ([x, NaN], 1), [y, NaN], eps)
 %!assert (tpdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
 %!assert (tpdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error tpdf ()
 %!error tpdf (1)
 %!error tpdf (1,2,3)
 %!error tpdf (ones (3), ones (2))
 %!error tpdf (ones (2), ones (3))
 %!error tpdf (i, 2)
 %!error tpdf (2, i)
 
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -50,23 +50,23 @@ function rnd = trnd (n, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("trnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 2)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("trnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (n) && !isequal (size (n), sz))
+  if (! isscalar (n) && ! isequal (size (n), sz))
     error ("trnd: N must be scalar or of size SZ");
   endif
 
   if (iscomplex (n))
     error ("trnd: N must not be complex");
   endif
 
   if (isa (n, "single"))
@@ -80,35 +80,36 @@ function rnd = trnd (n, varargin)
       rnd = randn (sz, cls) ./ sqrt (2*randg (n/2, sz, cls) / n);
     else
       rnd = NaN (sz, cls);
     endif
   else
     rnd = NaN (sz, cls);
 
     k = (n > 0) & (n < Inf);
-    rnd(k) = randn (sum (k(:)), 1, cls) ./ sqrt (2*randg (n(k)/2, cls) ./ n(k))(:);
+    rnd(k) = randn (sum (k(:)), 1, cls) ...
+             ./ sqrt (2*randg (n(k)/2, cls) ./ n(k))(:);
   endif
 
 endfunction
 
 
 %!assert (size (trnd (2)), [1, 1])
 %!assert (size (trnd (ones (2,1))), [2, 1])
 %!assert (size (trnd (ones (2,2))), [2, 2])
 %!assert (size (trnd (1, 3)), [3, 3])
 %!assert (size (trnd (1, [4 1])), [4, 1])
 %!assert (size (trnd (1, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (trnd (1)), "double")
 %!assert (class (trnd (single (1))), "single")
 %!assert (class (trnd (single ([1 1]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error trnd ()
 %!error trnd (1, -1)
 %!error trnd (1, ones (2))
 %!error trnd (i)
 %!error trnd (1, [2 -1 2])
 %!error trnd (1, 2, ones (2))
 %!error trnd (1, 2, -1)
 %!error trnd (ones (2,2), 3)
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
--- a/scripts/statistics/distributions/unidcdf.m
+++ b/scripts/statistics/distributions/unidcdf.m
@@ -68,22 +68,22 @@ endfunction
 %!shared x,y
 %! x = [0 1 2.5 10 11];
 %! y = [0, 0.1 0.2 1.0 1.0];
 %!assert (unidcdf (x, 10*ones (1,5)), y)
 %!assert (unidcdf (x, 10), y)
 %!assert (unidcdf (x, 10*[0 1 NaN 1 1]), [NaN 0.1 NaN y(4:5)])
 %!assert (unidcdf ([x(1:2) NaN Inf x(5)], 10), [y(1:2) NaN 1 y(5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (unidcdf ([x, NaN], 10), [y, NaN])
 %!assert (unidcdf (single ([x, NaN]), 10), single ([y, NaN]))
 %!assert (unidcdf ([x, NaN], single (10)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error unidcdf ()
 %!error unidcdf (1)
 %!error unidcdf (1,2,3)
 %!error unidcdf (ones (3), ones (2))
 %!error unidcdf (ones (2), ones (3))
 %!error unidcdf (i, 2)
 %!error unidcdf (2, i)
 
diff --git a/scripts/statistics/distributions/unidinv.m b/scripts/statistics/distributions/unidinv.m
--- a/scripts/statistics/distributions/unidinv.m
+++ b/scripts/statistics/distributions/unidinv.m
@@ -60,22 +60,22 @@ endfunction
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (unidinv (x, 10*ones (1,5)), [NaN NaN 5 10 NaN], eps)
 %!assert (unidinv (x, 10), [NaN NaN 5 10 NaN], eps)
 %!assert (unidinv (x, 10*[0 1 NaN 1 1]), [NaN NaN NaN 10 NaN], eps)
 %!assert (unidinv ([x(1:2) NaN x(4:5)], 10), [NaN NaN NaN 10 NaN], eps)
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (unidinv ([x, NaN], 10), [NaN NaN 5 10 NaN NaN], eps)
 %!assert (unidinv (single ([x, NaN]), 10), single ([NaN NaN 5 10 NaN NaN]), eps)
 %!assert (unidinv ([x, NaN], single (10)), single ([NaN NaN 5 10 NaN NaN]), eps)
 
-%% Test input validation
+## Test input validation
 %!error unidinv ()
 %!error unidinv (1)
 %!error unidinv (1,2,3)
 %!error unidinv (ones (3), ones (2))
 %!error unidinv (ones (2), ones (3))
 %!error unidinv (i, 2)
 %!error unidinv (2, i)
 
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
--- a/scripts/statistics/distributions/unidpdf.m
+++ b/scripts/statistics/distributions/unidpdf.m
@@ -67,21 +67,21 @@ endfunction
 %!shared x,y
 %! x = [-1 0 1 2 10 11];
 %! y = [0 0 0.1 0.1 0.1 0];
 %!assert (unidpdf (x, 10*ones (1,6)), y)
 %!assert (unidpdf (x, 10), y)
 %!assert (unidpdf (x, 10*[0 NaN 1 1 1 1]), [NaN NaN y(3:6)])
 %!assert (unidpdf ([x, NaN], 10), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (unidpdf (single ([x, NaN]), 10), single ([y, NaN]))
 %!assert (unidpdf ([x, NaN], single (10)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error unidpdf ()
 %!error unidpdf (1)
 %!error unidpdf (1,2,3)
 %!error unidpdf (ones (3), ones (2))
 %!error unidpdf (ones (2), ones (3))
 %!error unidpdf (i, 2)
 %!error unidpdf (2, i)
 
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -50,23 +50,23 @@ function rnd = unidrnd (n, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("unidrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 2)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("unidrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (n) && !isequal (size (n), sz))
+  if (! isscalar (n) && ! isequal (size (n), sz))
     error ("unidrnd: N must be scalar or of size SZ");
   endif
 
   if (iscomplex (n))
     error ("unidrnd: N must not be complex");
   endif
 
   if (isa (n, "single"))
@@ -92,20 +92,20 @@ endfunction
 
 
 %!assert (size (unidrnd (2)), [1, 1])
 %!assert (size (unidrnd (ones (2,1))), [2, 1])
 %!assert (size (unidrnd (ones (2,2))), [2, 2])
 %!assert (size (unidrnd (10, [4 1])), [4, 1])
 %!assert (size (unidrnd (10, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (unidrnd (2)), "double")
 %!assert (class (unidrnd (single (2))), "single")
 %!assert (class (unidrnd (single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error unidrnd ()
 %!error unidrnd (10, [1;2;3])
 %!error unidrnd (10, 2, ones (2))
 %!error unidrnd (10*ones (2), 2, 1)
 %!error unidrnd (i)
 
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -31,17 +31,17 @@
 ## Description: CDF of the uniform distribution
 
 function cdf = unifcdf (x, a = 0, b = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("unifcdf: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("unifcdf: X, A, and B must not be complex");
@@ -74,23 +74,23 @@ endfunction
 %! y = [0 0 0.5 1 1];
 %!assert (unifcdf (x, ones (1,5), 2*ones (1,5)), y)
 %!assert (unifcdf (x, 1, 2*ones (1,5)), y)
 %!assert (unifcdf (x, ones (1,5), 2), y)
 %!assert (unifcdf (x, [2 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
 %!assert (unifcdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
 %!assert (unifcdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (unifcdf ([x, NaN], 1, 2), [y, NaN])
 %!assert (unifcdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
 %!assert (unifcdf ([x, NaN], single (1), 2), single ([y, NaN]))
 %!assert (unifcdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error unifcdf ()
 %!error unifcdf (1,2)
 %!error unifcdf (1,2,3,4)
 %!error unifcdf (ones (3), ones (2), ones (2))
 %!error unifcdf (ones (2), ones (3), ones (2))
 %!error unifcdf (ones (2), ones (2), ones (3))
 %!error unifcdf (i, 2, 2)
 %!error unifcdf (2, i, 2)
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -31,17 +31,17 @@
 ## Description: Quantile function of the uniform distribution
 
 function inv = unifinv (x, a = 0, b = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("unifinv: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("unifinv: X, A, and B must not be complex");
@@ -67,23 +67,23 @@ endfunction
 %! x = [-1 0 0.5 1 2];
 %!assert (unifinv (x, ones (1,5), 2*ones (1,5)), [NaN 1 1.5 2 NaN])
 %!assert (unifinv (x, 1, 2*ones (1,5)), [NaN 1 1.5 2 NaN])
 %!assert (unifinv (x, ones (1,5), 2), [NaN 1 1.5 2 NaN])
 %!assert (unifinv (x, [1 2 NaN 1 1], 2), [NaN NaN NaN 2 NaN])
 %!assert (unifinv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 2 NaN])
 %!assert (unifinv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 1 NaN 2 NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (unifinv ([x, NaN], 1, 2), [NaN 1 1.5 2 NaN NaN])
 %!assert (unifinv (single ([x, NaN]), 1, 2), single ([NaN 1 1.5 2 NaN NaN]))
 %!assert (unifinv ([x, NaN], single (1), 2), single ([NaN 1 1.5 2 NaN NaN]))
 %!assert (unifinv ([x, NaN], 1, single (2)), single ([NaN 1 1.5 2 NaN NaN]))
 
-%% Test input validation
+## Test input validation
 %!error unifinv ()
 %!error unifinv (1,2)
 %!error unifinv (1,2,3,4)
 %!error unifinv (ones (3), ones (2), ones (2))
 %!error unifinv (ones (2), ones (3), ones (2))
 %!error unifinv (ones (2), ones (2), ones (3))
 %!error unifinv (i, 2, 2)
 %!error unifinv (2, i, 2)
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -30,17 +30,17 @@
 ## Description: PDF of the uniform distribution
 
 function pdf = unifpdf (x, a = 0, b = 1)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("unifpdf: X, A, and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (a) || iscomplex (b))
     error ("unifpdf: X, A, and B must not be complex");
@@ -70,22 +70,22 @@ endfunction
 %! y = [0 1 1 1 0];
 %!assert (unifpdf (x, ones (1,5), 2*ones (1,5)), y)
 %!assert (unifpdf (x, 1, 2*ones (1,5)), y)
 %!assert (unifpdf (x, ones (1,5), 2), y)
 %!assert (unifpdf (x, [2 NaN 1 1 1], 2), [NaN NaN y(3:5)])
 %!assert (unifpdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
 %!assert (unifpdf ([x, NaN], 1, 2), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (unifpdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
 %!assert (unifpdf (single ([x, NaN]), single (1), 2), single ([y, NaN]))
 %!assert (unifpdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error unifpdf ()
 %!error unifpdf (1,2)
 %!error unifpdf (1,2,3,4)
 %!error unifpdf (ones (3), ones (2), ones (2))
 %!error unifpdf (ones (2), ones (3), ones (2))
 %!error unifpdf (ones (2), ones (2), ones (3))
 %!error unifpdf (i, 2, 2)
 %!error unifpdf (2, i, 2)
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the uniform distribution
 
 function rnd = unifrnd (a, b, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (a) || !isscalar (b))
+  if (! isscalar (a) || ! isscalar (b))
     [retval, a, b] = common_size (a, b);
     if (retval > 0)
       error ("unifrnd: A and B must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (a) || iscomplex (b))
     error ("unifrnd: A and B must not be complex");
@@ -61,40 +61,40 @@ function rnd = unifrnd (a, b, varargin)
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("unifrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("unifrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (a) && !isequal (size (a), sz))
+  if (! isscalar (a) && ! isequal (size (a), sz))
     error ("unifrnd: A and B must be scalar or of size SZ");
   endif
 
   if (isa (a, "single") || isa (b, "single"))
     cls = "single";
   else
     cls = "double";
   endif
 
   if (isscalar (a) && isscalar (b))
     if ((-Inf < a) && (a < b) && (b < Inf))
-      rnd =  a + (b - a) * rand (sz, cls);
+      rnd = a + (b - a) * rand (sz, cls);
     else
       rnd = NaN (sz, cls);
     endif
   else
-    rnd =  a + (b - a) .* rand (sz, cls);
+    rnd = a + (b - a) .* rand (sz, cls);
 
     k = !(-Inf < a) | !(a < b) | !(b < Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
@@ -102,24 +102,24 @@ endfunction
 %!assert (size (unifrnd (ones (2,1), 2)), [2, 1])
 %!assert (size (unifrnd (ones (2,2), 2)), [2, 2])
 %!assert (size (unifrnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (unifrnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (unifrnd (1, 2, 3)), [3, 3])
 %!assert (size (unifrnd (1, 2, [4 1])), [4, 1])
 %!assert (size (unifrnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (unifrnd (1, 2)), "double")
 %!assert (class (unifrnd (single (1), 2)), "single")
 %!assert (class (unifrnd (single ([1 1]), 2)), "single")
 %!assert (class (unifrnd (1, single (2))), "single")
 %!assert (class (unifrnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error unifrnd ()
 %!error unifrnd (1)
 %!error unifrnd (ones (3), ones (2))
 %!error unifrnd (ones (2), ones (3))
 %!error unifrnd (i, 2)
 %!error unifrnd (2, i)
 %!error unifrnd (1,2, -1)
 %!error unifrnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -45,17 +45,17 @@
 ## Description: CDF of the Weibull distribution
 
 function cdf = wblcdf (x, scale = 1, shape = 1)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (!isscalar (shape) || !isscalar (scale))
+  if (! isscalar (shape) || ! isscalar (scale))
     [retval, x, shape, scale] = common_size (x, shape, scale);
     if (retval > 0)
       error ("wblcdf: X, SCALE, and SHAPE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (scale) || iscomplex (shape))
     error ("wblcdf: X, SCALE, and SHAPE must not be complex");
@@ -90,23 +90,23 @@ endfunction
 %! y = [0, 1-exp(-x(2:4)), 1];
 %!assert (wblcdf (x, ones (1,5), ones (1,5)), y)
 %!assert (wblcdf (x, 1, ones (1,5)), y)
 %!assert (wblcdf (x, ones (1,5), 1), y)
 %!assert (wblcdf (x, [0 1 NaN Inf 1], 1), [NaN 0 NaN NaN 1])
 %!assert (wblcdf (x, 1, [0 1 NaN Inf 1]), [NaN 0 NaN NaN 1])
 %!assert (wblcdf ([x(1:2) NaN x(4:5)], 1, 1), [y(1:2) NaN y(4:5)])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (wblcdf ([x, NaN], 1, 1), [y, NaN])
 %!assert (wblcdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
 %!assert (wblcdf ([x, NaN], single (1), 1), single ([y, NaN]))
 %!assert (wblcdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error wblcdf ()
 %!error wblcdf (1,2,3,4)
 %!error wblcdf (ones (3), ones (2), ones (2))
 %!error wblcdf (ones (2), ones (3), ones (2))
 %!error wblcdf (ones (2), ones (2), ones (3))
 %!error wblcdf (i, 2, 2)
 %!error wblcdf (2, i, 2)
 %!error wblcdf (2, 2, i)
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -32,17 +32,17 @@
 ## Description: Quantile function of the Weibull distribution
 
 function inv = wblinv (x, scale = 1, shape = 1)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (!isscalar (scale) || !isscalar (shape))
+  if (! isscalar (scale) || ! isscalar (shape))
     [retval, x, scale, shape] = common_size (x, scale, shape);
     if (retval > 0)
       error ("wblinv: X, SCALE, and SHAPE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (scale) || iscomplex (shape))
     error ("wblinv: X, SCALE, and SHAPE must not be complex");
@@ -76,23 +76,23 @@ endfunction
 %! x = [-1 0 0.63212055882855778 1 2];
 %!assert (wblinv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
 %!assert (wblinv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
 %!assert (wblinv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
 %!assert (wblinv (x, [1 -1 NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
 %!assert (wblinv (x, 1, [1 -1 NaN Inf 1]), [NaN NaN NaN NaN NaN])
 %!assert (wblinv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (wblinv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
 %!assert (wblinv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 %!assert (wblinv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 %!assert (wblinv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 
-%% Test input validation
+## Test input validation
 %!error wblinv ()
 %!error wblinv (1,2,3,4)
 %!error wblinv (ones (3), ones (2), ones (2))
 %!error wblinv (ones (2), ones (3), ones (2))
 %!error wblinv (ones (2), ones (2), ones (3))
 %!error wblinv (i, 2, 2)
 %!error wblinv (2, i, 2)
 %!error wblinv (2, 2, i)
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -44,17 +44,17 @@
 ## Description: PDF of the Weibull distribution
 
 function pdf = wblpdf (x, scale = 1, shape = 1)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (!isscalar (scale) || !isscalar (shape))
+  if (! isscalar (scale) || ! isscalar (shape))
     [retval, x, scale, shape] = common_size (x, scale, shape);
     if (retval > 0)
       error ("wblpdf: X, SCALE, and SHAPE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (x) || iscomplex (scale) || iscomplex (shape))
     error ("wblpdf: X, SCALE, and SHAPE must not be complex");
@@ -90,22 +90,22 @@ endfunction
 %! y = [0, exp(-x(2:4)), NaN];
 %!assert (wblpdf (x, ones (1,5), ones (1,5)), y)
 %!assert (wblpdf (x, 1, ones (1,5)), y)
 %!assert (wblpdf (x, ones (1,5), 1), y)
 %!assert (wblpdf (x, [0 NaN Inf 1 1], 1), [NaN NaN NaN y(4:5)])
 %!assert (wblpdf (x, 1, [0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
 %!assert (wblpdf ([x, NaN], 1, 1), [y, NaN])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (wblpdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
 %!assert (wblpdf ([x, NaN], single (1), 1), single ([y, NaN]))
 %!assert (wblpdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
-%% Test input validation
+## Test input validation
 %!error wblpdf ()
 %!error wblpdf (1,2,3,4)
 %!error wblpdf (ones (3), ones (2), ones (2))
 %!error wblpdf (ones (2), ones (3), ones (2))
 %!error wblpdf (ones (2), ones (2), ones (3))
 %!error wblpdf (i, 2, 2)
 %!error wblpdf (2, i, 2)
 %!error wblpdf (2, 2, i)
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -39,17 +39,17 @@
 ## Description: Random deviates from the Weibull distribution
 
 function rnd = wblrnd (scale, shape, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
-  if (!isscalar (scale) || !isscalar (shape))
+  if (! isscalar (scale) || ! isscalar (shape))
     [retval, scale, shape] = common_size (scale, shape);
     if (retval > 0)
       error ("wblrnd: SCALE and SHAPE must be of common size or scalars");
     endif
   endif
 
   if (iscomplex (scale) || iscomplex (shape))
     error ("wblrnd: SCALE and SHAPE must not be complex");
@@ -61,23 +61,23 @@ function rnd = wblrnd (scale, shape, var
     if (isscalar (varargin{1}) && varargin{1} >= 0)
       sz = [varargin{1}, varargin{1}];
     elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
       sz = varargin{1};
     else
       error ("wblrnd: dimension vector must be row vector of non-negative integers");
     endif
   elseif (nargin > 3)
-    if (any (cellfun (@(x) (!isscalar (x) || x < 0), varargin)))
+    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
       error ("wblrnd: dimensions must be non-negative integers");
     endif
     sz = [varargin{:}];
   endif
 
-  if (!isscalar (scale) && !isequal (size (scale), sz))
+  if (! isscalar (scale) && ! isequal (size (scale), sz))
     error ("wblrnd: SCALE and SHAPE must be scalar or of size SZ");
   endif
 
   if (isa (scale, "single") || isa (shape, "single"))
     cls = "single";
   else
     cls = "double";
   endif
@@ -102,24 +102,24 @@ endfunction
 %!assert (size (wblrnd (ones (2,1), 2)), [2, 1])
 %!assert (size (wblrnd (ones (2,2), 2)), [2, 2])
 %!assert (size (wblrnd (1, 2*ones (2,1))), [2, 1])
 %!assert (size (wblrnd (1, 2*ones (2,2))), [2, 2])
 %!assert (size (wblrnd (1, 2, 3)), [3, 3])
 %!assert (size (wblrnd (1, 2, [4 1])), [4, 1])
 %!assert (size (wblrnd (1, 2, 4, 1)), [4, 1])
 
-%% Test class of input preserved
+## Test class of input preserved
 %!assert (class (wblrnd (1, 2)), "double")
 %!assert (class (wblrnd (single (1), 2)), "single")
 %!assert (class (wblrnd (single ([1 1]), 2)), "single")
 %!assert (class (wblrnd (1, single (2))), "single")
 %!assert (class (wblrnd (1, single ([2 2]))), "single")
 
-%% Test input validation
+## Test input validation
 %!error wblrnd ()
 %!error wblrnd (1)
 %!error wblrnd (ones (3), ones (2))
 %!error wblrnd (ones (2), ones (3))
 %!error wblrnd (i, 2)
 %!error wblrnd (2, i)
 %!error wblrnd (1,2, -1)
 %!error wblrnd (1,2, ones (2))
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
--- a/scripts/statistics/distributions/wienrnd.m
+++ b/scripts/statistics/distributions/wienrnd.m
@@ -37,17 +37,17 @@ function retval = wienrnd (t, d, n)
     d = 1;
     n = 1000;
   elseif (nargin == 2)
     n = 1000;
   elseif (nargin > 3)
     print_usage ();
   endif
 
-  if (!isscalar (t) || !isscalar (d) || !isscalar (n))
+  if (! isscalar (t) || ! isscalar (d) || ! isscalar (n))
     error ("wienrnd: T, D and N must all be positive integers");
   endif
 
   retval = randn (n * t, d);
   retval = cumsum (retval) / sqrt (n);
 
   retval = [((1: n*t)' / n), retval];
 
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -99,17 +99,17 @@ function [theta, beta, dev, dl, d2l, p] 
 
   ## initial calculations
   x = -x;
   tol = 1e-6; incr = 10; decr = 2;
   ymin = min (y); ymax = max (y); yrange = ymax - ymin;
   z  = (y * ones (1, yrange)) == ((y * 0 + 1) * (ymin : (ymax - 1)));
   z1 = (y * ones (1, yrange)) == ((y * 0 + 1) * ((ymin + 1) : ymax));
   z  = z(:, any (z));
-  z1 = z1 (:, any(z1));
+  z1 = z1(:, any(z1));
   [mz, nz] = size (z);
 
   ## starting values
   if (nargin < 3)
     print = 0;
   endif;
   if (nargin < 4)
     beta = zeros (nx, 1);
@@ -152,18 +152,18 @@ function [theta, beta, dev, dl, d2l, p] 
       disp ("Deviance"); disp (dev);
       disp ("First derivative"); disp (dl');
       disp ("Eigenvalues of second derivative"); disp (eig (d2l)');
     endif
   endwhile
 
   ## tidy up output
 
-  theta = tb (1 : nz, 1);
-  beta  = tb ((nz + 1) : (nz + nx), 1);
+  theta = tb(1 : nz, 1);
+  beta  = tb((nz + 1) : (nz + nx), 1);
 
   if (print >= 1)
     printf ("\n");
     printf ("Logistic Regression Results:\n");
     printf ("\n");
     printf ("Number of Iterations: %d\n", iter);
     printf ("Deviance:             %f\n", dev);
     printf ("Parameter Estimates:\n");
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -41,17 +41,17 @@
 ## printed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: One-way analysis of variance (ANOVA)
 
 function [pval, f, df_b, df_w] = anova (y, g)
 
-  if ((nargin < 1) || (nargin > 2))
+  if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (nargin == 1)
     if (isvector (y))
       error ("anova: for 'anova (Y)', Y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -39,16 +39,16 @@ function [pval, chisq, df] = chisquare_t
   endif
 
   [r, s] = size (x);
   df = (r - 1) * (s - 1);
   n = sum (sum (x));
   y = sum (x')' * sum (x) / n;
   x = (x - y) .^2 ./ y;
   chisq = sum (sum (x));
-  pval  = 1 - chi2cdf (chisq, df);
+  pval = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -62,47 +62,47 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Adapted-by: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for zero correlation
 
 function t = cor_test (x, y, alt, method)
 
-  if ((nargin < 2) || (nargin > 4))
+  if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
-  if (!isvector (x) || !isvector (y) || length (x) != length (y))
+  if (! isvector (x) || ! isvector (y) || length (x) != length (y))
     error ("cor_test: X and Y must be vectors of the same length");
   endif
 
   if (nargin < 3)
     alt = "!=";
   elseif (! ischar (alt))
     error ("cor_test: ALT must be a string");
   endif
 
   if (nargin < 4)
     method = "pearson";
   elseif (! ischar (method))
     error ("cor_test: METHOD must be a string");
   endif
 
   n = length (x);
-  m = method (1);
+  m = method(1);
 
   if (m == "p")
     r = corr (x, y);
     df = n - 2;
     t.method = "Pearson's product moment correlation";
     t.params = df;
     t.stat = sqrt (df) .* r / sqrt (1 - r.^2);
     t.dist = "t";
-    cdf  = tcdf (t.stat, df);
+    cdf = tcdf (t.stat, df);
   elseif (m == "k")
     tau = kendall (x, y);
     t.method = "Kendall's rank correlation tau";
     t.params = [];
     t.stat = tau / sqrt ((2 * (2*n+5)) / (9*n*(n-1)));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   elseif (m == "s")
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -63,16 +63,16 @@ function [pval, f, df_num, df_den] = f_t
   endif
 
   df_num = q;
   df_den = T - k;
 
   [b, v] = ols (y, x);
   diff   = rr * b - r;
   f      = diff' * inv (rr * inv (x' * x) * rr') * diff / (q * v);
-  pval  = 1 - fcdf (f, df_num, df_den);
+  pval   = 1 - fcdf (f, df_num, df_den);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -71,17 +71,17 @@ function [pval, ks] = kolmogorov_smirnov
     try
       f = str2func (sprintf ("%s_cdf", dist));
     catch
       error ("kolmogorov_smirnov_test: no %scdf or %s_cdf function found",
              dist, dist);
     end_try_catch
   end_try_catch
 
-  alt  = "!=";
+  alt = "!=";
 
   args{1} = s;
   nvargs = numel (varargin);
   if (nvargs > 0)
     if (ischar (varargin{end}))
       alt = varargin{end};
       args(2:nvargs) = varargin(1:end-1);
     else
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -48,17 +48,17 @@ function manova (x, g)
   endif
 
   if (isvector (x))
     error ("manova: X must not be a vector");
   endif
 
   [n, p] = size (x);
 
-  if (!isvector (g) || (length (g) != n))
+  if (! isvector (g) || (length (g) != n))
     error ("manova: G must be a vector of length rows (X)");
   endif
 
   s = sort (g);
   i = find (s (2:n) > s(1:(n-1)));
   k = length (i) + 1;
 
   if (k == 1)
@@ -80,19 +80,19 @@ function manova (x, g)
   n_b = k - 1;
 
   SSW = SST - SSB;
   n_w = n - k;
 
   l = real (eig (SSB / SSW));
 
   if (isa (l, "single"))
-    l (l < eps ("single")) = 0;
+    l(l < eps ("single")) = 0;
   else
-    l (l < eps) = 0;
+    l(l < eps) = 0;
   endif
 
   ## Wilks' Lambda
   ## =============
 
   Lambda = prod (1 ./ (1 + l));
 
   delta = n_w + n_b - (p + n_b + 1) / 2;
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -37,17 +37,17 @@
 function [pval, chisq, df] = mcnemar_test (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (min (size (x)) > 1) && issquare (x))
     error ("mcnemar_test: X must be a square matrix of size > 1");
-  elseif (! (all (all (x >= 0)) && all (all (x == fix (x)))))
+  elseif (! (all ((x(:) >= 0)) && all (x(:) == fix (x(:)))))
     error ("mcnemar_test: all entries of X must be non-negative integers");
   endif
 
   r = rows (x);
   df = r * (r - 1) / 2;
   if (r == 2)
     num = max (abs (x - x') - 1, 0) .^ 2;
   else
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -37,32 +37,32 @@
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compare two proportions
 
 function [pval, z] = prop_test_2 (x1, n1, x2, n2, alt)
 
-  if ((nargin < 4) || (nargin > 5))
-        print_usage ();
+  if (nargin < 4 || nargin > 5)
+    print_usage ();
   endif
 
   ## Could do sanity checking on x1, n1, x2, n2 here
 
-  p1  = x1 / n1;
-  p2  = x2 / n2;
-  pc  = (x1 + x2) / (n1 + n2);
+  p1 = x1 / n1;
+  p2 = x2 / n2;
+  pc = (x1 + x2) / (n1 + n2);
 
-  z   = (p1 - p2) / sqrt (pc * (1 - pc) * (1/n1 + 1/n2));
+  z  = (p1 - p2) / sqrt (pc * (1 - pc) * (1/n1 + 1/n2));
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 4)
-    alt  = "!=";
+    alt = "!=";
   endif
 
   if (! ischar (alt))
     error ("prop_test_2: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -39,33 +39,33 @@
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Sign test
 
 function [pval, b, n] = sign_test (x, y, alt)
 
-  if ((nargin < 2) || (nargin > 3))
+  if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
     error ("sign_test: X and Y must be vectors of the same length");
   endif
 
   n   = length (x);
   x   = reshape (x, 1, n);
   y   = reshape (y, 1, n);
   n   = sum (x != y);
   b   = sum (x > y);
   cdf = binocdf (b, n, 1/2);
 
   if (nargin == 2)
-    alt  = "!=";
+    alt = "!=";
   endif
 
   if (! ischar (alt))
     error ("sign_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -38,34 +38,34 @@
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Student's one-sample t test
 
 function [pval, t, df] = t_test (x, m, alt)
 
-  if ((nargin < 2) || (nargin > 3))
+  if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! isvector (x))
     error ("t_test: X must be a vector");
   endif
   if (! isscalar (m))
     error ("t_test: M must be a scalar");
   endif
 
   n   = length (x);
   df  = n - 1;
   t   = sqrt (n) * (sum (x) / n - m) / std (x);
   cdf = tcdf (t, df);
 
   if (nargin == 2)
-    alt  = "!=";
+    alt = "!=";
   endif
 
   if (! ischar (alt))
     error ("t_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -38,18 +38,18 @@
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Student's two-sample t test
 
 function [pval, t, df] = t_test_2 (x, y, alt)
 
-  if ((nargin < 2) || (nargin > 3))
-        print_usage ();
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("t_test_2: both X and Y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -65,17 +65,17 @@ function [pval, t, df] = t_test_regressi
   elseif (! ischar (alt))
     error ("t_test_regression: ALT must be a string");
   endif
 
   [T, k] = size (x);
   if (! (isvector (y) && (length (y) == T)))
     error ("t_test_regression: Y must be a vector of length rows (X)");
   endif
-  s      = size (rr);
+  s = size (rr);
   if (! ((max (s) == k) && (min (s) == 1)))
     error ("t_test_regression: RR must be a vector of length columns (X)");
   endif
 
   rr     = reshape (rr, 1, k);
   y      = reshape (y, T, 1);
   [b, v] = ols (y, x);
   df     = T - k;
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -40,34 +40,34 @@
 ## This implementation is still incomplete---for small sample sizes,
 ## the normal approximation is rather bad ...
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Mann-Whitney U-test
 
 function [pval, z] = u_test (x, y, alt)
 
-  if ((nargin < 2) || (nargin > 3))
+  if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("u_test: both X and Y must be vectors");
   endif
 
-  n_x  = length (x);
-  n_y  = length (y);
-  r    = ranks ([(reshape (x, 1, n_x)), (reshape (y, 1, n_y))]);
-  z    = (sum (r(1 : n_x)) - n_x * (n_x + n_y + 1) / 2) ...
-           / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
+  n_x = length (x);
+  n_y = length (y);
+  r   = ranks ([(reshape (x, 1, n_x)), (reshape (y, 1, n_y))]);
+  z   = (sum (r(1 : n_x)) - n_x * (n_x + n_y + 1) / 2) ...
+          / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
 
-  cdf  = stdnormal_cdf (z);
+  cdf = stdnormal_cdf (z);
 
   if (nargin == 2)
-    alt  = "!=";
+    alt = "!=";
   endif
 
   if (! ischar (alt))
     error ("u_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -38,31 +38,31 @@
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: F test to compare two variances
 
 function [pval, f, df_num, df_den] = var_test (x, y, alt)
 
-  if ((nargin < 2) || (nargin > 3))
+  if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("var_test: both X and Y must be vectors");
   endif
 
   df_num = length (x) - 1;
   df_den = length (y) - 1;
   f      = var (x) / var (y);
   cdf    = fcdf (f, df_num, df_den);
 
   if (nargin == 2)
-    alt  = "!=";
+    alt = "!=";
   endif
 
   if (! ischar (alt))
     error ("var_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -37,17 +37,17 @@
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Welch two-sample t test
 
 function [pval, t, df] = welch_test (x, y, alt)
 
-  if ((nargin < 2) || (nargin > 3))
+  if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("welch_test: both X and Y must be vectors");
   endif
 
   n_x  = length (x);
@@ -57,17 +57,17 @@ function [pval, t, df] = welch_test (x, 
   v_x  = sumsq (x - mu_x) / (n_x * (n_x - 1));
   v_y  = sumsq (y - mu_y) / (n_y * (n_y - 1));
   c    = v_x / (v_x + v_y);
   df   = 1 / (c^2 / (n_x - 1) + (1 - c)^2 / (n_y - 1));
   t    = (mu_x - mu_y) / sqrt (v_x + v_y);
   cdf  = tcdf (t, df);
 
   if (nargin == 2)
-    alt  = "!=";
+    alt = "!=";
   endif
 
   if (! ischar (alt))
     error ("welch_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -38,17 +38,17 @@
 ## along with some information.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for mean of a normal sample with known variance
 
 function [pval, z] = z_test (x, m, v, alt)
 
-  if ((nargin < 3) || (nargin > 4))
+  if (nargin < 3 || nargin > 4)
     print_usage ();
   endif
 
   if (! isvector (x))
     error ("z_test: X must be a vector");
   endif
   if (! isscalar (m))
     error ("z_test: M must be a scalar");
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -38,17 +38,17 @@
 ## along with some information.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compare means of two normal samples with known variances
 
 function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
 
-  if ((nargin < 4) || (nargin > 5))
+  if (nargin < 4 || nargin > 5)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("z_test_2: both X and Y must be vectors");
   elseif (! (isscalar (v_x) && (v_x > 0)
              && isscalar (v_y) && (v_y > 0)))
     error ("z_test_2: both V_X and V_Y must be positive scalars");
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -117,20 +117,20 @@ function out = base2dec (s, base)
 endfunction
 
 
 %!assert (base2dec ("11120", 3), 123)
 %!assert (base2dec ("yyyzx", "xyz"), 123)
 %!assert (base2dec ("-1", 2), NaN)
 %!assert (base2dec ({"A1", "1A"}, 16), [161; 26])
 
-%% Bug #35621
+## Bug #35621
 %!assert (base2dec (["0"; "1"], 2), [0; 1])
 
-%%Test input validation
+## Test input validation
 %!error base2dec ()
 %!error base2dec ("11120")
 %!error base2dec ("11120", 3, 4)
 %!error base2dec ("11120", "1231")
 %!error base2dec ("11120", "12 3")
 %!error base2dec ("11120", ones (2))
 %!error base2dec ("11120", 37)
 
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -62,13 +62,13 @@ endfunction
 
 %!assert (bin2dec ("0000"), 0)
 %!assert (bin2dec ("1110"), 14)
 %!assert (bin2dec ("11111111111111111111111111111111111111111111111111111"), 2^53-1)
 %!assert (bin2dec ({"1110", "1111"}), [14; 15])
 %!assert (bin2dec ("1 0 1"), 5)
 %!assert (bin2dec (char ("1 0 1", "   1111")), [5; 15])
 
-%%Test input validation
+## Test input validation
 %!error bin2dec ()
 %!error bin2dec (1)
 %!error bin2dec ("1", 2)
 
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -51,15 +51,15 @@ function s = blanks (n)
 endfunction
 
 
 ## There really isn't that much to test here
 %!assert (blanks (0), "")
 %!assert (blanks (5), "     ")
 %!assert (blanks (10), "          ")
 
-%% Test input validation
+## Test input validation
 %!error blanks ()
 %!error blanks (1, 2)
 %!error blanks (ones (2))
 %!error blanks (2.1)
 %!error blanks (-2)
 
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -58,12 +58,12 @@ endfunction
 ## 1d
 %!assert (cstrcat ("ab ", "ab "), "ab ab ")
 ## 2d
 %!assert (cstrcat (["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
 
 %!assert (cstrcat ("foo", "bar"), "foobar")
 %!assert (cstrcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])
 
-%% Test input validation
+## Test input validation
 %!error cstrcat ()
 %!error cstrcat (1, 2)
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -153,17 +153,17 @@ endfunction
 %!assert (dec2base (uint64 (2)^63-1, 16), "7FFFFFFFFFFFFFFF")
 %!assert (dec2base ([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"])
 %!assert (dec2base ({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"])
 
 %!test
 %! a = 0:3;
 %! assert (dec2base (!a, 2, 1), ["1"; "0"; "0"; "0"])
 
-%%Test input validation
+## Test input validation
 %!error dec2base ()
 %!error dec2base (1)
 %!error dec2base (1, 2, 3, 4)
 %!error dec2base ("A")
 %!error dec2base (2i)
 %!error dec2base (-1)
 %!error dec2base (1.1)
 %!error dec2base (1, "ABA")
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -52,12 +52,12 @@ function b = dec2bin (d, len)
 
 endfunction
 
 
 %!assert (dec2bin (14), "1110")
 %!assert (dec2bin (14, 6), "001110")
 %!assert (dec2bin ({1, 2; 3, 4}), ["001"; "011"; "010"; "100"])
 
-%%Test input validation
+## Test input validation
 %!error dec2bin ()
 %!error dec2bin (1, 2, 3)
 
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -52,12 +52,12 @@ function h = dec2hex (d, len)
 
 endfunction
 
 
 %!assert (dec2hex (2748), "ABC")
 %!assert (dec2hex (2748, 5), "00ABC")
 %!assert (dec2hex ({2748, 2746}), ["ABC"; "ABA"])
 
-%% Test input validation
+## Test input validation
 %!error dec2hex ()
 %!error dec2hex (1, 2, 3)
 
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -73,19 +73,19 @@ function v = findstr (s, t, overlap = tr
   elseif (l_t == 2)
     ## length two target: find first at i and second at i+1
     v = find (s(1:l_s-1) == t(1) & s(2:l_s) == t(2));
 
   else
     ## length three or more: match the first three by find then go through
     ## the much smaller list to determine which of them are real matches
     limit = l_s - l_t + 1;
-    v = find (s(1:limit) == t(1)
+    v = find (  s(1:limit)   == t(1)
               & s(2:limit+1) == t(2)
-              & s (3:limit+2) == t(3));
+              & s(3:limit+2) == t(3));
   endif
 
   ## Need to search the index vector if our find was too short
   ## (target length > 3), or if we don't allow overlaps.  Note though
   ## that there cannot be any overlaps if the first character in the
   ## target is different from the remaining characters in the target,
   ## so a single character, two different characters, or first character
   ## different from the second two don't need to be searched.
@@ -131,13 +131,13 @@ function v = findstr (s, t, overlap = tr
 
 endfunction
 
 
 %!assert (findstr ("abababa", "a"), [1, 3, 5, 7])
 %!assert (findstr ("abababa", "aba"), [1, 3, 5])
 %!assert (findstr ("aba", "abababa", 0), [1, 5])
 
-%% Test input validation
+## Test input validation
 %!error findstr ()
 %!error findstr ("foo", "bar", 3, 4)
 %!error <must have only one non-singleton dimension> findstr (["AB" ; "CD"], "C")
 
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -53,13 +53,13 @@ function d = hex2dec (s)
 endfunction
 
 
 %!assert (hex2dec ("0000"), 0)
 %!assert (hex2dec ("1FFFFFFFFFFFFF"), 2^53-1)
 %!assert (hex2dec (["12b"; "12B"]), [299; 299])
 %!assert (hex2dec ({"A1", "1A"}), [161; 26])
 
-%%Test input validation
+## Test input validation
 %!error hex2dec ()
 %!error hex2dec (1)
 %!error hex2dec ("1", 2)
 
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -103,15 +103,15 @@ endfunction
 %!test
 %! str = char ("Hello", "World", "Goodbye", "World");
 %! assert (index (str, "o"), [5; 2; 2; 2]);
 %! assert (index (str, "o", "last"), [5; 2; 3; 2]);
 %! str = cellstr (str);
 %! assert (index (str, "o"), [5; 2; 2; 2]);
 %! assert (index (str, "o", "last"), [5; 2; 3; 2]);
 
-%% Test input validation
+## Test input validation
 %!error index ()
 %!error index ("a")
 %!error index ("a", "b", "first", "d")
 %!error index (1, "bar")
 %!error index ("foo", "bar", 3)
 
diff --git a/scripts/strings/isstrprop.m b/scripts/strings/isstrprop.m
--- a/scripts/strings/isstrprop.m
+++ b/scripts/strings/isstrprop.m
@@ -122,14 +122,14 @@ endfunction
 
 %!assert (isstrprop ("abc123", "alpha"), logical ([1, 1, 1, 0, 0, 0]))
 %!assert (isstrprop ("abc123", "digit"), logical ([0, 0, 0, 1, 1, 1]))
 %!assert (isstrprop ("Hello World", "wspace"), isspace ("Hello World"))
 %!assert (isstrprop ("Hello World", "graphic"), isgraph ("Hello World"))
 %!assert (isstrprop (char ("AbC", "123"), "upper"), logical ([1 0 1; 0 0 0]))
 %!assert (isstrprop ({"AbC", "123"}, "lower"), {logical([0 1 0]), logical([0 0 0])})
 
-%%Input Validation
+## Test input validation
 %!error isstrprop ()
 %!error isstrprop ("abc123")
 %!error isstrprop ("abc123", "alpha", "alpha")
 %!error <invalid string property> isstrprop ("abc123", "foo")
 
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -138,15 +138,15 @@ endfunction
 %!assert (mat2str (single (pi), 5, "class"), "single(3.1416)")
 %!assert (mat2str ([-1/3 + i/7; 1/3 - i/7], [4 2]), "[-0.3333+0.14i;0.3333-0.14i]")
 %!assert (mat2str ([-1/3 +i/7; 1/3 -i/7], [4 2]), "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]")
 %!assert (mat2str (int16 ([1 -1]), "class"), "int16([1 -1])")
 %!assert (mat2str (true), "true")
 %!assert (mat2str (false), "false")
 %!assert (mat2str (logical (eye (2))), "[true false;false true]")
 
-%% Test input validation
+## Test input validation
 %!error mat2str ()
 %!error mat2str (1,2,3,4)
 %!error mat2str (["Hello"])
 %!error <X must be two dimensional> mat2str (ones (3,3,2))
 %!error <N must have only 1 or 2 elements> mat2str (ones (3,3), [1 2 3])
 
diff --git a/scripts/strings/ostrsplit.m b/scripts/strings/ostrsplit.m
--- a/scripts/strings/ostrsplit.m
+++ b/scripts/strings/ostrsplit.m
@@ -103,16 +103,16 @@ endfunction
 
 %!assert (ostrsplit ("road to hell", " "), {"road", "to", "hell"})
 %!assert (ostrsplit ("road to^hell", " ^"), {"road", "to", "hell"})
 %!assert (ostrsplit ("road   to--hell", " -", true), {"road", "to", "hell"})
 %!assert (ostrsplit (["a,bc";",de"], ","), {"a", "bc", char(ones(1,0)), "de "})
 %!assert (ostrsplit (["a,bc";",de"], ",", true), {"a", "bc", "de "})
 %!assert (ostrsplit (["a,bc";",de"], ", ", true), {"a", "bc", "de"})
 
-%% Test input validation
+## Test input validation
 %!error ostrsplit ()
 %!error ostrsplit ("abc")
 %!error ostrsplit ("abc", "b", true, 4)
 %!error <S and SEP must be string values> ostrsplit (123, "b")
 %!error <S and SEP must be string values> ostrsplit ("abc", 1)
 %!error <STRIP_EMPTY must be a scalar value> ostrsplit ("abc", "def", ones (3,3))
 
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -73,15 +73,15 @@ function y = regexptranslate (op, s)
   endif
 
 endfunction
 
 
 %!assert (regexptranslate ("wildcard", "/a*b?c."), "/a.*b.c\\.")
 %!assert (regexptranslate ("escape", '$.?[abc]'), '\$\.\?\[abc\]')
 
-%% Test input validation
+## Test input validation
 %!error <Invalid call to regexptranslate> regexptranslate ()
 %!error <Invalid call to regexptranslate> regexptranslate ("wildcard")
 %!error <Invalid call to regexptranslate> regexptranslate ("a", "b", "c")
 %!error <invalid operation> regexptranslate ("foo", "abc")
 %!error <operation OP must be a string> regexptranslate (10, "abc")
 
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -56,13 +56,13 @@ endfunction
 %!assert (rindex ("foobarbaz", "o"), 3)
 
 %!test
 %! str = char ("Hello", "World", "Goodbye", "World");
 %! assert (rindex (str, "o"), [5; 2; 3; 2]);
 %! str = cellstr (str);
 %! assert (rindex (str, "o"), [5; 2; 3; 2]);
 
-%% Test input validation
+## Test input validation
 %!error rindex ()
 %!error rindex ("foo")
 %!error rindex ("foo", "bar", "last")
 
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -72,13 +72,13 @@ endfunction
 %!assert (str2num ("[1, 2; 3, 4]"), [1, 2; 3, 4])
 
 %!test
 %! [x, state] = str2num ("pi");
 %! assert (state);
 %! [x, state] = str2num ("Hello World");
 %! assert (! state);
 
-%% Test input validation
+## Test input validation
 %!error str2num ()
 %!error str2num ("string", 1)
 %!error <S must be a string> str2num ({"string"})
 
diff --git a/scripts/strings/strchr.m b/scripts/strings/strchr.m
--- a/scripts/strings/strchr.m
+++ b/scripts/strings/strchr.m
@@ -67,14 +67,14 @@ function varargout = strchr (str, chars,
 
 endfunction
 
 
 %!assert (strchr ("Octave is the best software", ""), zeros (1,0))
 %!assert (strchr ("Octave is the best software", "best"), [3, 6, 9, 11, 13, 15, 16, 17, 18, 20, 23, 27])
 %!assert (strchr ("Octave is the best software", "software"), [3, 4, 6, 9, 11, 13, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27])
 
-%% Test input validation
+## Test input validation
 %!error strchr ()
 %!error strchr (1)
 %!error <STR argument must be a string> strchr (1, "aeiou")
 %!error <CHARS argument must be a string> strchr ("aeiou", 1)
 
diff --git a/scripts/strings/strjoin.m b/scripts/strings/strjoin.m
--- a/scripts/strings/strjoin.m
+++ b/scripts/strings/strjoin.m
@@ -35,17 +35,17 @@
 ## sequences are not supported.
 ##
 ## @example
 ## @group
 ## strjoin (@{'Octave','Scilab','Lush','Yorick'@}, '*')
 ##       @result{} 'Octave*Scilab*Lush*Yorick'
 ## @end group
 ## @end example
-## @seealso {strsplit}
+## @seealso{strsplit}
 ## @end deftypefn
 
 ## Author: Muthiah Annamalai <muthiah.annamalai@uta.edu>
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function rval = strjoin (cstr, delimiter)
 
   if (nargin == 1)
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -99,14 +99,14 @@ endfunction
 %!assert (strjust (["a"; "ab"; "abc"; "abcd"]),
 %!        ["   a";"  ab"; " abc"; "abcd"])
 %!assert (strjust ([" a"; "  ab"; "abc"; "abcd"], "left"),
 %!        ["a   "; "ab  "; "abc "; "abcd"])
 %!assert (strjust (["a"; "ab"; "abc"; "abcd"], "CENTER"),
 %!        [" a  "; " ab"; "abc "; "abcd"])
 %!assert (strjust (["";""]), "")
 
-%% Test input validation
+## Test input validation
 %!error <Invalid call to strjust> strjust ()
 %!error <Invalid call to strjust> strjust (["a";"ab"], "center", 1)
 %!error <S must be a string> strjust (ones (3,3))
 %!error <S must be a string> strjust (char (ones (3,3,3)))
 
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -78,17 +78,17 @@
 ##
 ## @item @var{delimitertype} may take the value of @code{simple} or
 ## @code{regularexpression}.  The default is @var{delimitertype} is
 ## @code{simple}.
 ## @end itemize
 ##
 ## Example:
 ##
-## @example
+## @smallexample
 ## strsplit ("a foo b,bar c", ",|\\s|foo|bar", "delimitertype", "regularexpression")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
 ##
@@ -115,17 +115,17 @@
 ##           @{
 ##             [1,1] = a
 ##             [1,2] =
 ##             [1,3] =
 ##             [1,4] = b
 ##             [1,5] =
 ##             [1,6] = c
 ##           @}
-## @end example
+## @end smallexample
 ##
 ## @seealso{ostrsplit, strjoin, strtok, regexp}
 ## @end deftypefn
 
 function [result, matches] = strsplit (str, del, varargin)
 
   args.collapsedelimiters = true;
   args.delimitertype = "default";
@@ -275,20 +275,20 @@ endfunction
 %! [a, m] = strsplit ("a\t \nb", {"\t", " ", "\n"}, "delimitertype", "simple");
 %! assert (a, {"a", "b"})
 %! assert (m, {"\t \n"})
 %!test
 %! [s, m] = strsplit ("hello \t world", 1);
 %! assert (s, {"hello", "world"});
 %! assert (m, {" \t "});
 
-%% Compatibility
+## Compatibility
 %! assert (strsplit ("", "a"), {""})
 %! assert (strsplit ("a", "a"), {"", ""})
 %! assert (strsplit ("aa", "a"), {"", ""})
 %! assert (strsplit ("aaa", "a"), {"", ""})
 
-%% Test input validation
+## Test input validation
 %!error strsplit ()
 %!error strsplit ("abc", "b", true, 4)
 %!error <S and DEL must be string values> strsplit (123, "b")
 %!error <COLLAPSEDELIMITERS must be a scalar value> strsplit ("abc", "def", ones (3,3))
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -147,35 +147,35 @@ endfunction
 %!   printf ("<%s>", s(1));
 %! endwhile
 %! printf ("\n");
 %! % ----------------------------------------------------
 %! % Demonstrates processing of an entire string split on
 %! % a variety of delimiters.  Tokens and delimiters are
 %! % printed one after another in angle brackets.
 
-%% Test the tokens for all cases
+## Test the tokens for all cases
 %!assert (strtok (""), "");             # no string
 %!assert (strtok ("this"), "this");     # no delimiter in string
 %!assert (strtok ("this "), "this");    # delimiter at end
 %!assert (strtok ("this is"), "this");  # delimiter in middle
 %!assert (strtok (" this"), "this");    # delimiter at start
 %!assert (strtok (" this "), "this");   # delimiter at start and end
 %!assert (strtok (" "), ""(1:0));       # delimiter only
 
-%% Test the remainder for all cases
+## Test the remainder for all cases
 %!test [t,r] = strtok (""); assert (r, "");
 %!test [t,r] = strtok ("this"); assert (r, "");
 %!test [t,r] = strtok ("this "); assert (r, " ");
 %!test [t,r] = strtok ("this is"); assert (r, " is");
 %!test [t,r] = strtok (" this"); assert (r, "");
 %!test [t,r] = strtok (" this "); assert (r, " ");
 %!test [t,r] = strtok (" "); assert (r, "");
 
-%% Test all tokens and remainders with cell array input
+## Test all tokens and remainders with cell array input
 %!test
 %! str = {"", "this", "this ", "this is", " this", " this ", " "};
 %! [t, r] = strtok (str);
 %! assert (t{1}, "");
 %! assert (r{1}, "");
 %! assert (t{2}, "this");
 %! assert (r{2}, "");
 %! assert (t{3}, "this");
@@ -184,41 +184,41 @@ endfunction
 %! assert (r{4}, " is");
 %! assert (t{5}, "this");
 %! assert (r{5}, "");
 %! assert (t{6}, "this");
 %! assert (r{6}, " ");
 %! assert (t{7}, "");
 %! assert (r{7}, "");
 
-%% Simple check for 2, 3, and 4 delimeters
+## Simple check for 2, 3, and 4 delimeters
 %!assert (strtok ("this is", "i "), "th")
 %!assert (strtok ("this is", "ij "), "th")
 %!assert (strtok ("this is", "ijk "), "th")
 
-%% Test all cases for 8 delimiters since a different
+## Test all cases for 8 delimiters since a different
 %!# algorithm is used when more than 7 delimiters
 %!assert (strtok ("","jklmnop "), "")
 %!assert (strtok ("this","jklmnop "), "this")
 %!assert (strtok ("this ","jklmnop "), "this")
 %!assert (strtok ("this is","jklmnop "), "this")
 %!assert (strtok (" this","jklmnop "), "this")
 %!assert (strtok (" this ","jklmnop "), "this")
 %!assert (strtok (" ","jklmnop "), ""(1:0))
 
-%% Test 'bad' string orientations
+## Test 'bad' string orientations
 %!assert (strtok (" this ".'), "this".');   # delimiter at start and end
 %!assert (strtok (" this ".',"jkl "), "this".');
 
-%% Test with TAB, LF, VT, FF, and CR
+## Test with TAB, LF, VT, FF, and CR
 %!test
 %! for ch = "\t\n\v\f\r"
 %!   [t, r] = strtok (["beg", ch, "end"]);
 %!   assert (t, "beg");
 %!   assert (r, [ch, "end"]);
 %! endfor
 
-%% Test input validation
+## Test input validation
 %!error strtok ()
 %!error strtok ("a", "b", "c")
 %!error <STR must be a string> strtok (1, "b")
 %!error <STR cannot be a 2-D> strtok (char ("hello", "world"), "l")
 
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -63,16 +63,16 @@ endfunction
 %!assert (strtrunc ({"1", "", "2"}, 1), {"1", "", "2"})
 %!test
 %! cstr = {"line1"; ["line2"; "line3"]; "line4"};
 %! y = strtrunc (cstr, 4);
 %! assert (size (y), [3, 1]);
 %! assert (size (y{2}), [2, 4]);
 %! assert (y{2}, repmat ("line", 2, 1));
 
-%% Test input validation
+## Test input validation
 %!error strtrunc ()
 %!error strtrunc ("abcd")
 %!error strtrunc ("abcd", 4, 5)
 %!error <N must be a positive integer> strtrunc ("abcd", ones (2,2))
 %!error <N must be a positive integer> strtrunc ("abcd", -1)
 %!error <S must be a character string or a cell array of strings> strtrunc (1, 1)
 
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -94,17 +94,17 @@ endfunction
 
 %!assert (substr ("This is a test string", 6, 9), "is a test")
 %!assert (substr ("This is a test string", -11), "test string")
 %!assert (substr ("This is a test string", -11, 4), "test")
 %!assert (substr ("This is a test string", -11, -7), "test")
 %!assert (substr ("This is a test string", 1, -7), "This is a test")
 %!assert (isempty (substr ("This is a test string", 1, 0)))
 
-%% Test input validation
+## Test input validation
 %!error substr ()
 %!error substr ("foo", 2, 3, 4)
 %!error substr (ones (5, 1), 1, 1)
 %!error substr ("foo", ones (2,2))
 %!error substr ("foo", 1, ones (2,2))
 %!error substr ("foo", 0)
 %!error substr ("foo", 5)
 %!error substr ("foo", 1, 5)
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -146,17 +146,17 @@ endfunction
 %!assert (validatestring ("d", strarray), "def")
 
 %!error <'xyz' does not match any> validatestring ("xyz", strarray)
 %!error <DUMMY_TEST: 'xyz' does not> validatestring ("xyz", strarray, "DUMMY_TEST")
 %!error <DUMMY_TEST: DUMMY_VAR does> validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR")
 %!error <DUMMY_TEST: DUMMY_VAR \(argument #5\) does> validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR", 5)
 %!error <'abc' allows multiple unique matches> validatestring ("abc", strarray)
 
-%% Test input validation
+## Test input validation
 %!error validatestring ("xyz")
 %!error validatestring ("xyz", {"xyz"}, "3", "4", 5, 6)
 %!error <invalid number of character inputs> validatestring ("xyz", {"xyz"}, "3", "4", "5")
 %!error <STR must be a character string> validatestring (1, {"xyz"}, "3", "4", 5)
 %!error <STR must be a single row vector> validatestring ("xyz".', {"xyz"}, "3", "4", 5)
 %!error <STRARRAY must be a cellstr> validatestring ("xyz", "xyz", "3", "4", 5)
 %!error <FUNCNAME must be a single row vector> validatestring ("xyz", {"xyz"}, "33".', "4", 5)
 %!error <VARNAME must be a single row vector> validatestring ("xyz", {"xyz"}, "3", "44".', 5)
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -291,22 +291,24 @@ function assert (cond, varargin)
               repmat ({"'Inf' mismatch"}, length (erridx), 1);
           endif
           errseen |= errvec;
 
           ## Check normal values.
           ## Replace exceptional values already checked above by zero.
           A_null_real = real (A);
           B_null_real = real (B);
-          exclude = errseen | ! isfinite (A_null_real) & ! isfinite (B_null_real);
+          exclude = errseen ...
+                    | ! isfinite (A_null_real) & ! isfinite (B_null_real);
           A_null_real(exclude) = 0;
           B_null_real(exclude) = 0;
           A_null_imag = imag (A);
           B_null_imag = imag (B);
-          exclude = errseen | ! isfinite (A_null_imag) & ! isfinite (B_null_imag);
+          exclude = errseen ...
+                    | ! isfinite (A_null_imag) & ! isfinite (B_null_imag);
           A_null_imag(exclude) = 0;
           B_null_imag(exclude) = 0;
           A_null = complex (A_null_real, A_null_imag);
           B_null = complex (B_null_real, B_null_imag);
           if (isscalar (tol))
             mtol = tol * ones (size (A));
           else
             mtol = tol;
@@ -620,20 +622,20 @@ endfunction
 %! tol = [-0.1 0; -0.2 0.3];
 %! try
 %!   assert (x, y, tol);
 %! catch
 %!   errmsg = lasterr ();
 %!   if (sum (errmsg () == "\n") != 6)
 %!     error ("Incorrect number of errors reported");
 %!   endif
-%!   assert (!isempty (regexp (errmsg, '\(1,2\).*Abs err 3 exceeds tol 0\>')));
-%!   assert (!isempty (regexp (errmsg, '\(2,2\).*Abs err 2 exceeds tol 0.3')));
-%!   assert (!isempty (regexp (errmsg, '\(1,1\).*Abs err 1 exceeds tol 0.1')));
-%!   assert (!isempty (regexp (errmsg, '\(2,1\).*Rel err 2 exceeds tol 0.2')));
+%!   assert (! isempty (regexp (errmsg, '\(1,2\).*Abs err 3 exceeds tol 0\>')));
+%!   assert (! isempty (regexp (errmsg, '\(2,2\).*Abs err 2 exceeds tol 0.3')));
+%!   assert (! isempty (regexp (errmsg, '\(1,1\).*Abs err 1 exceeds tol 0.1')));
+%!   assert (! isempty (regexp (errmsg, '\(2,1\).*Rel err 2 exceeds tol 0.2')));
 %! end_try_catch
 
 ## test input validation
 %!error assert ()
 %!error assert (1,2,3,4)
 
 
 ## Convert all error indices into tuple format
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -105,17 +105,17 @@ endfunction
 %!assert (example ("example", 1), "\n example (\"example\");");
 
 %!test
 %! [code, idx] = example ("example");
 %! assert (code, ...
 %!         "\n example (\"example\");\n clf;\n t = 0:0.01:2*pi;\n x = sin (t);\n plot (t,x)");
 %! assert (idx, [1, 23, 73]);
 
-%% Test input validation
+## Test input validation
 %!error example ()
 %!error example ("example", 3, 5)
 %!error <N must be a scalar integer> example ("example", {1})
 %!error <N must be a scalar integer> example ("example", ones (2,2))
 %!error <N must be a scalar integer> example ("example", 1.5)
 %!warning <no function .* found> example ("_%NOT_A_FUNCTION%_");
 %!warning <only 2 examples available for example> example ("example", 10);
 
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -137,20 +137,20 @@ function retval = fail (code, pattern, w
 endfunction
 
 
 %!fail ("[1,2]*[2,3]", "nonconformant")
 %!fail ("fail ('[1,2]*[2;3]', 'nonconformant')", "expected error <nonconformant> but got none")
 %!fail ("fail ('[1,2]*[2,3]', 'usage:')", "expected error <usage:>\nbut got.*nonconformant")
 %!fail ("warning ('test warning')", "warning", "test warning");
 
-##% !fail ("warning ('next test')",'warning','next test');  ## only allowed one warning test?!?
+#%!fail ("warning ('next test')",'warning','next test');  # only allowed one warning test?!?
 
-%% Test that fail() itself will generate an error
+## Test that fail() itself will generate an error
 %!error <expected error> fail ("1")
 %!error <'a' undefined> fail ("a*[2;3]", "nonconformant")
 %!error <expected error .usage:>  fail ("a*[2,3]", "usage:")
 %!error <warning failure> fail ("warning ('warning failure')", "warning", "success")
 
-%% Test input validation
+## Test input validation
 %!error fail ()
 %!error fail (1,2,3,4)
 
diff --git a/scripts/testfun/private/compare_plot_demos.m b/scripts/testfun/private/compare_plot_demos.m
--- a/scripts/testfun/private/compare_plot_demos.m
+++ b/scripts/testfun/private/compare_plot_demos.m
@@ -93,17 +93,18 @@ function compare_plot_demos (varargin)
         delete (["*." arg.fmt]);
       endif
       if (! strcmp (arg.toolkits{n}, "matlab"))
         close all;
         graphics_toolkit (arg.toolkits{n});
         try
           eval (fcn_name);
         catch
-          printf ("Error running plot demos for ""%s"" toolkit\n", arg.toolkits{n});
+          printf ("Error running plot demos for ""%s"" toolkit\n",
+                  arg.toolkits{n});
           disp (lasterror);
         end_try_catch
       endif
       cd (cwd);
     endfor
   unwind_protect_cleanup
     rmpath (cwd);
   end_unwind_protect
diff --git a/scripts/testfun/private/dump_demos.m b/scripts/testfun/private/dump_demos.m
--- a/scripts/testfun/private/dump_demos.m
+++ b/scripts/testfun/private/dump_demos.m
@@ -112,33 +112,33 @@ function dump_all_demos (directory, fid,
     demos = get_demos (fcn);
     for d = 1:numel (demos)
       idx = sprintf ("%02d", d);
       base_fn = sprintf ("%s_%s", fcn, idx);
       fn = sprintf ('%s.%s', base_fn, fmt);
       fprintf (fid, "\ntry\n");
       ## First check if the file already exists, skip demo if found
       fprintf (fid, " if (! exist ('%s', 'file'))\n", fn);
-      ## Invoke the ancient, deprecated random seed
-      ## generators, but there is an initialization mismatch with the more modern
-      ## generators reported here (https://savannah.gnu.org/bugs/?42557).
+      ## Invoke the ancient, deprecated random seed generators, but there is an
+      ## initialization mismatch with the more modern generators reported
+      ## here (https://savannah.gnu.org/bugs/?42557).
       fprintf (fid, "  rand ('seed', 1);\n");
       fprintf (fid, "  tic ();\n");
       fprintf (fid, "  %s\n\n", demos{d});
       fprintf (fid, "  t_plot = toc ();\n");
       fprintf (fid, "  fig = (get (0, 'currentfigure'));\n");
       fprintf (fid, "  if (~ isempty (fig))\n");
       fprintf (fid, "    figure (fig);\n");
       fprintf (fid, "      fprintf ('Printing ""%s"" ... ');\n", fn);
       fprintf (fid, "      tic ();\n");
       fprintf (fid, "      print ('-d%s', '%s');\n", fmt, fn);
       fprintf (fid, "      t_print = toc ();\n");
       fprintf (fid, "      fprintf ('[%%f %%f] done\\n',t_plot, t_print);\n");
       fprintf (fid, "  end\n");
-      # Temporary fix for cruft accumulating in figure window.
+      ## Temporary fix for cruft accumulating in figure window.
       fprintf (fid, "  close ('all');\n");
       fprintf (fid, " else\n");
       fprintf (fid, "   fprintf ('File ""%s"" already exists.\\n');\n", fn);
       fprintf (fid, " end\n");
       fprintf (fid, "catch\n");
       fprintf (fid, "  fprintf ('ERROR in %s: %%s\\n', lasterr ());\n", base_fn);
       fprintf (fid, "  err_fid = fopen ('%s.err', 'w');\n", base_fn);
       fprintf (fid, "  fprintf (err_fid, '%%s', lasterr ());\n");
diff --git a/scripts/testfun/private/html_compare_plot_demos.m b/scripts/testfun/private/html_compare_plot_demos.m
--- a/scripts/testfun/private/html_compare_plot_demos.m
+++ b/scripts/testfun/private/html_compare_plot_demos.m
@@ -40,21 +40,19 @@
 ## @end table
 ##
 ## The template parameter refers to a specially formatted html file
 ## which accompanies this m-file script.
 ##
 ## Additional toolkit description can be added to the column header
 ## with a parameter named equal to the toolkit.  For example:
 ##
-## @example
-## @group
-##   @code{html_compare_plot_demos ({"gnuplot", "fltk"}, "gnuplot", " 4.6 patchlevel 5")}
-## @end group
-## @end example
+## @smallexample
+## @code{html_compare_plot_demos ({"gnuplot", "fltk"}, "gnuplot", " 4.6 patchlevel 5")}
+## @end smallexample
 ##
 ## @seealso{compare_plot_demos, dump_demos, demo}
 ## @end deftypefn
 
 ## Author: Ben Abbott  <bpabbott@mac.com>
 
 function html_compare_plot_demos (toolkits, varargin)
 
@@ -94,29 +92,31 @@ function html_compare_plot_demos (toolki
     ## Create table header
     fprintf (fid, "<table border='1'><tr>\n");
     for t = 1:numel(toolkits)
       ## set default
       column_header = upper (toolkits{t});
       if (isfield (in, toolkits{t}))
         column_header = strcat (column_header, in.(toolkits{t}));
       endif
-      fprintf (fid, '<th>%s <a href="%s/diary.log">diary</a></th>\n', column_header, toolkits{t});
+      fprintf (fid, '<th>%s <a href="%s/diary.log">diary</a></th>\n', ...
+                    column_header, toolkits{t});
     endfor
     fprintf (fid, "</tr>\n");
 
     for m = 1:numel(in.figfiles)
       [~, file] = fileparts (in.figfiles{m});
       fn = strcat (file, ".", in.fmt);
       fprintf (fid, "<tr>\n");
       for k = toolkits
         ffn = fullfile (k{:}, fn);
         fprintf (fid, "  <td>%s<br>", ffn);
         if (exist (ffn, "file"))
-          fprintf (fid, "<img src='%s' style='width: %dpx;'>", ffn, in.column_width);
+          fprintf (fid, "<img src='%s' style='width: %dpx;'>", ...
+                        ffn, in.column_width);
         else
           err_fn = regexprep(ffn, ".png", ".err");
           if (! exist (err_fn, "file"))
             warning("File %s doesn't exist...", err_fn);
           else
             err_fid = fopen (err_fn);
             msg = char (fread (err_fid))';
             fclose (err_fid);
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -343,21 +343,21 @@ function [__order, __test_n, __tnew, __t
     printf ("  asymptotic power: %s\n", order);
     printf ("  approximate time per operation: %s\n", time);
 
   endif
 
 endfunction
 
 
-%% FIXME: Demos with declared functions do not work.  See bug #31815.
-%%        A workaround has been hacked by not declaring the functions
-%%        but using eval to create them in the proper context.
-%%        Unfortunately, we can't remove them from the user's workspace
-%%        because of another bug (#34497).
+## FIXME: Demos with declared functions do not work.  See bug #31815.
+##        A workaround has been hacked by not declaring the functions
+##        but using eval to create them in the proper context.
+##        Unfortunately, we can't remove them from the user's workspace
+##        because of another bug (#34497).
 %!demo
 %! fstr_build_orig = cstrcat (
 %!   "function x = build_orig (n)\n",
 %!   "  ## extend the target vector on the fly\n",
 %!   "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
 %!   "endfunction");
 %! fstr_build = cstrcat (
 %!   "function x = build (n)\n",
@@ -435,12 +435,12 @@ endfunction
 %! assert (fieldnames (order), {"p"; "a"});
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
 %! assert (isnumeric (T_f1));
 %! assert (size (T_f1), size (n));
 %! assert (isnumeric (T_f2));
 %! assert (length (T_f2) > 10);
 
-%% Test input validation
+## Test input validation
 %!error speed ()
 %!error speed (1, 2, 3, 4, 5, 6, 7)
 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -570,17 +570,17 @@ function [__n, __nmax, __nxfail, __nskip
         __msg = [__signal_fail "unknown test type!\n"];
         __code = ""; # skip the code
       endif
 
       ## evaluate code for test, shared, and assert.
       if (! isempty(__code))
         try
           ## FIXME: Must check for embedded test functions, which cause
-          ## segfaults, until issues with subfunctions in functions are resolved.
+          ## segfaults, until issues with subfunctions in functions are fixed.
           embed_func = regexp (__code, '^\s*function ', 'once', 'lineanchors');
           if (isempty (embed_func))
             eval (sprintf ("function %s__test__(%s)\n%s\nendfunction",
                            __shared_r, __shared, __code));
             eval (sprintf ("%s__test__(%s);", __shared_r, __shared));
           else
             error (["Functions embedded in %!test blocks are not allowed.\n", ...
                     "Use the %!function/%!endfunction syntax instead to define shared functions for testing.\n"]);
@@ -815,26 +815,26 @@ endfunction
 %!warning warning ("warning message");   # no pattern
 %!warning <warning message> warning ("warning message");   # with pattern
 
 ## Test 'shared' keyword
 %!shared a                # create a shared variable
 %!test a = 3;             # assign to a shared variable
 %!test assert (a, 3)      # variable should equal 3
 %!shared b,c              # replace shared variables
-%!test assert (!exist ("a", "var"));  # a no longer exists
+%!test assert (! exist ("a", "var"));  # a no longer exists
 %!test assert (isempty (b));   # variables start off empty
 %!shared a,b,c            # recreate a shared variable
 %!test assert (isempty (a));   # value is empty even if it had a previous value
 %!test a=1; b=2; c=3;   # give values to all variables
 %!test assert ([a,b,c], [1,2,3]); # test all of them together
 %!test c=6;               # update a value
 %!test assert ([a,b,c], [1,2,6]); # show that the update sticks
 %!shared                  # clear all shared variables
-%!test assert (!exist ("a", "var")) # show that they are cleared
+%!test assert (! exist ("a", "var")) # show that they are cleared
 %!shared a,b,c            # support for initializer shorthand
 %! a=1; b=2; c=4;
 %!shared                  # clear all shared variables for remainder of tests
 
 ## Test 'function' keyword
 %!function x = __test_a (y)
 %! x = 2*y;
 %!endfunction
@@ -884,17 +884,17 @@ endfunction
 %! assert (0, 1);      # Test fails
 
 ## Test comment block. it can contain anything.
 %!##
 %! it is the "#" as the block type that makes it a comment
 %! and it stays as a comment even through continuation lines
 %! which means that it works well with commenting out whole tests
 
-%% Test test() input validation
+## Test test() input validation
 %!error <NAME must be a string> test (1)
 %!error <second argument must be a string> test ("ls", 1)
 %!error test ([], "normal")
 
 ## All of the following tests should fail.  These tests should
 ## be disabled unless you are developing test() since users don't
 ## like to be presented with expected failures.  I use '% !' to disable.
 % !test   error("---------Failure tests.  Use test('test','verbose',1)");
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -110,17 +110,17 @@ endfunction
 ## multiple inputs and output orientation
 %!assert (addtodate ([d d], [1 13], "month"), [d+31 d+366+31])
 %!assert (addtodate ([d;d], [1;13], "month"), [d+31;d+366+31])
 %!assert (addtodate (d, [1;13], "month"), [d+31;d+366+31])
 %!assert (addtodate (d, [1 13], "month"), [d+31 d+366+31])
 %!assert (addtodate ([d;d+1], 1, "month"), [d+31;d+1+31])
 %!assert (addtodate ([d d+1], 1, "month"), [d+31 d+1+31])
 
-%% Test input validation
+## Test input validation
 %!error addtodate ()
 %!error addtodate (1)
 %!error addtodate (1,2)
 %!error addtodate (1,2,3,4)
 %!error <F must be a single character string> addtodate (1,2,3)
 %!error <F must be a single character string> addtodate (1,2,"month"')
 %!error <Invalid time unit> addtodate (1,2,"abc")
 
diff --git a/scripts/time/calendar.m b/scripts/time/calendar.m
--- a/scripts/time/calendar.m
+++ b/scripts/time/calendar.m
@@ -94,11 +94,11 @@ endfunction
 
 %!demo
 %! ## Calendar for October, 1957
 %! calendar (1957, 10)
 
 %!assert ((calendar(2000,2))'(2:31), [0:29])
 %!assert ((calendar(1957,10))'(2:33), [0:31])
 
-%% Test input validation
+## Test input validation
 %!error calendar (1,2,3)
 
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -113,22 +113,23 @@ function [days, secs] = datenum (year, m
       if (nc >= 5) minute = year(:,5); endif
       if (nc >= 4) hour   = year(:,4); endif
       day   = year(:,3);
       month = year(:,2);
       year  = year(:,1);
     endif
   endif
 
-  if (! (isa (year, "double") && isa (month, "double") && isa (day, "double") &&
-         isa (hour, "double") && isa (minute, "double") && isa (second, "double")))
+  if (! (isa (year, "double") && isa (month, "double")
+         && isa (day, "double") && isa (hour, "double")
+         && isa (minute, "double") && isa (second, "double")))
     error ("datenum: all inputs must be of class double");
   endif
 
-  month(month<1) = 1;  # For compatibility.  Otherwise allow negative months.
+  month(month < 1) = 1;  # For compatibility.  Otherwise allow negative months.
 
   ## Treat fractional months, by converting the fraction to days
   if (floor (month) != month)
     fracmonth = month - floor (month);
     month = floor (month);
     if ((mod (month-1,12) + 1) == 2 &&
         (floor (year/4) - floor (year/100) + floor (year/400)) != 0)
       ## leap year
@@ -203,15 +204,15 @@ endfunction
 ## Test string and cellstr inputs
 %!assert (datenum ("5/19/2001"), 730990)
 %!assert (datenum ({"5/19/2001"}), 730990)
 %!assert (datenum (char ("5/19/2001", "6/6/1944")), [730990; 710189])
 %!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])
 ## Test string input with format string
 %!assert (datenum ("5-19, 2001", "mm-dd, yyyy"), 730990)
 
-%% Test input validation
+## Test input validation
 %!error datenum ()
 %!error datenum (1,2,3,4,5,6,7)
 %!error <expected date vector containing> datenum ([1, 2])
 %!error <expected date vector containing> datenum ([1,2,3,4,5,6,7])
 %!error <all inputs must be of class double> datenum (int32 (2000), int32 (1), int32 (1))
 
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -335,12 +335,12 @@ endfunction
 %!assert (datestr (testtime,30), "20051218T023317")
 %!assert (datestr (testtime,31), "2005-12-18 02:33:17")
 %!assert (datestr (testtime+[0 0 3 0 0 0], "dddd"), "Wednesday")
 ## Test possible bug where input is a vector of datenums that is exactly 6 wide
 %!assert (datestr ([1944, 6, 6, 6, 30, 0], 0), "06-Jun-1944 06:30:00")
 ## Test fractional millisecond time extension
 %!assert (datestr (testtime, "HH:MM:SS:FFF"), "02:33:17:382")
 
-%% Test input validation
+## Test input validation
 %!error datestr ()
 %!error datestr (1, 2, 3, 4)
 
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -120,31 +120,34 @@ function [y, m, d, h, mi, s] = datevec (
     nd = numel (date);
 
     y = m = d = h = mi = s = zeros (nd, 1);
 
     if (f == -1)
       for k = 1:nd
         found = false;
         for l = 1:nfmt
-          [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (std_formats{l});
-          [found y(k) m(k) d(k) h(k) mi(k) s(k)] = __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
+          [f, rY, ry, fy, fm, fd, fh, fmi, fs] = ...
+            __date_vfmt2sfmt__ (std_formats{l});
+          [found y(k) m(k) d(k) h(k) mi(k) s(k)] = ...
+            __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
           if (found)
             break;
           endif
         endfor
         if (! found)
           error ("datevec: none of the standard formats match the DATE string");
         endif
       endfor
     else
       ## Decipher the format string just once for speed.
       [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (f);
       for k = 1:nd
-        [found y(k) m(k) d(k) h(k) mi(k) s(k)] = __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
+        [found y(k) m(k) d(k) h(k) mi(k) s(k)] = ...
+          __date_str2vec__ (date{k}, p, f, rY, ry, fy, fm, fd, fh, fmi, fs);
         if (! found)
           error ("datevec: DATE not parsed correctly with given format");
         endif
       endfor
     endif
 
   else   # datenum input
 
@@ -330,14 +333,14 @@ endfunction
 ## Other tests
 %!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]');
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
 %!assert (double (datevec (int64 (datenum ([2014 6 1])))), datevec (datenum ([2014 6 1])))
 %!assert (double (datevec (int64 (datenum ([2014 6 18])))), datevec (datenum ([2014 6 18])))
 
-%% Test input validation
+## Test input validation
 %!error datevec ()
 %!error datevec (1,2,3,4)
 %!error <none of the standard formats match> datevec ("foobar")
 %!error <DATE not parsed correctly with given format> datevec ("foobar", "%d")
 
diff --git a/scripts/time/eomday.m b/scripts/time/eomday.m
--- a/scripts/time/eomday.m
+++ b/scripts/time/eomday.m
@@ -40,26 +40,25 @@ endfunction
 
 
 %!demo
 %! ## Find leap years in the 20th century
 %! y = 1900:1999;
 %! e = eomday (y, repmat (2, [1, 100]));
 %! y(find (e == 29))
 
-# tests
 %!assert (eomday ([-4:4],2), [29,28,28,28,29,28,28,28,29])
 %!assert (eomday ([-901,901],2), [28,28])
 %!assert (eomday ([-100,100],2), [28,28])
 %!assert (eomday ([-900,900],2), [28,28])
 %!assert (eomday ([-400,400],2), [29,29])
 %!assert (eomday ([-800,800],2), [29,29])
 %!assert (eomday (2001,1:12), [31,28,31,30,31,30,31,31,30,31,30,31])
 %!assert (eomday (1:3,1:3), [31,28,31])
 %!assert (eomday (1:2000,2)', datevec (datenum (1:2000,3,0))(:,3))
 %!assert ([1900:1999](find(eomday(1900:1999,2*ones(1,100))==29)), [1904,1908,1912,1916,1920,1924,1928,1932,1936,1940,1944,1948,1952,1956,1960,1964,1968,1972,1976,1980,1984,1988,1992,1996])
 %!assert (eomday ([2004;2005], [2;2]), [29;28])
 
-%% Test input validation
+## Test input validation
 %!error eomday ()
 %!error eomday (1)
 %!error eomday (1,2,3)
 
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -67,13 +67,13 @@ endfunction
 %! t4 = [1993, 8, 20, 4, 57, 1];
 %! t5 = [1993, 8, 20, 4, 56, 14];
 %!
 %! assert (etime (t2, t1), 86400);
 %! assert (etime (t3, t1), 3600);
 %! assert (etime (t4, t1), 60);
 %! assert (etime (t5, t1), 13);
 
-%% Test input validation
+## Test input validation
 %!error etime ();
 %!error etime (1);
 %!error etime (1, 2, 3);
 
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -88,17 +88,16 @@ endfunction
 %!demo
 %! ## Weekday from datenum input
 %! [n, s] = weekday (728647)
 
 %!demo
 %! ## Weekday of new millennium from datestr input
 %! [n, s] = weekday ("1-Jan-2000")
 
-# tests
 %!assert (weekday (728647), 2)
 ## Test vector inputs for both directions
 %!assert (weekday ([728647 728648]), [2 3])
 %!assert (weekday ([728647;728648]), [2;3])
 ## Test a full week before our reference day
 %!assert (weekday ("19-Dec-1994"), 2)
 %!assert (weekday ("20-Dec-1994"), 3)
 %!assert (weekday ("21-Dec-1994"), 4)
