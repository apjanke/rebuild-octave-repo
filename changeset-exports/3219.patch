# HG changeset patch
# User jwe
# Date 910928676 0
#      Fri Nov 13 03:44:36 1998 +0000
# Node ID 30770ba4457a4808fa8580803f30ed4f6d9e4d5a
# Parent  2c91af0db179df787f7b93215bfe245f81dcfc5b
[project @ 1998-11-13 03:44:31 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,20 @@
+Thu Nov 12 10:42:25 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* emacs/otags: New script from Mario Storti
+	<mstorti@minerva.unl.edu.ar>.
+	* emacs/Makefile.in: Add it to the list of files to distribute and
+	install.
+
+Wed Nov 11 17:26:26 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in (AC_OUTPUT): Add libcruft/amos/Makefile.
+	Delete libcruft/specfun/Makefile.
+
 Mon Nov  9 08:53:03 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makeconf.in (LIBGLOB): Add a place for substitution to occur.
 	(GLOB_INCFLAGS): Define as @GLOB_INCFLAGS@, not @DLFCN_INCFLAGS@.
 	(do-subst-config-vals): Don't forget LIBGLOB.
 	* octave-bug.in (LIBGLOB): Substitute here too, and add it to the
 	list of configuration items to print.
 
diff --git a/doc/interpreter/matrix.texi b/doc/interpreter/matrix.texi
--- a/doc/interpreter/matrix.texi
+++ b/doc/interpreter/matrix.texi
@@ -63,17 +63,17 @@ whether the elements are nonzero.  For e
 @example
 @group
 all (all (rand (5) < 0.9))
      @result{} 0
 @end group
 @end example
 
 @noindent
-tests a random 5 by 5 matrix to see if all of it's elements are less
+tests a random 5 by 5 matrix to see if all of its elements are less
 than 0.9.
 
 Note that in conditional contexts (like the test clause of @code{if} and
 @code{while} statements) Octave treats the test as if you had typed
 @code{all (all (condition))}.
 
 @deftypefn {Function File} {[@var{err}, @var{y1}, ...] =} common_size (@var{x1}, ...)
 Determine if all input arguments are either scalar or of common
diff --git a/emacs/otags b/emacs/otags
--- a/emacs/otags
+++ b/emacs/otags
@@ -12,13 +12,15 @@
 # variables.  :-(
 
 # Tags are also created for lines of the form '###key foobar' so that
 # you can jump to this specific place just by typing `M-. foobar'.
 # Note that tags are not generated for scripts so that you have to add
 # a line by yourself of the form `###key <script-name>' if you want to
 # jump to it.  :-(
 
+# Author: Mario Storti <mstorti@minerva.unl.edu.ar>
+
 etags --lang=none \
       --regex='/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
       --regex='/###key \(.*\)/\1/' \
       --regex='/[ \t]*global[ \t].*/' \
       *.m
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,14 @@
+Wed Nov 11 17:27:35 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makefile.in (CRUFT_DIRS): Add amos.  Delete specfun.
+	* specfun: Delete directory.
+	* amos: New directory
+
 Thu Oct 15 00:43:13 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* ranlib: Update to newer version of randlib.
 	* ranlib/Makefile.in (SPECIAL): Update list.
 
 Thu Sep 24 11:59:02 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* balgen, eispack: Delete directories and unnecesary files.
diff --git a/libcruft/Makefile.in b/libcruft/Makefile.in
--- a/libcruft/Makefile.in
+++ b/libcruft/Makefile.in
@@ -19,18 +19,18 @@ INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 # List of the directories that contain Fortran source.  Simply copying
 # a new .f file into one of these directories is sufficient to have it
 # added to libcruft.a.  If you add a new directory here, you also need
 # generate a new configure script in the top-level directory (edit
 # configure.in and run autoconf).
 
-CRUFT_DIRS = blas dassl fftpack lapack linpack minpack misc odepack \
-	ordered-qz quadpack ranlib slatec-err slatec-fn specfun villad
+CRUFT_DIRS = amos blas dassl fftpack lapack linpack minpack misc odepack \
+	ordered-qz quadpack ranlib slatec-err slatec-fn villad
 
 SUBDIRS = $(CRUFT_DIRS)
 
 DISTFILES = Makefile.in ChangeLog Makerules.in $(SOURCES) STOP.patch
 
 ifeq ($(SHARED_LIBS), true)
   BINDISTLIBS = libcruft/libcruft
   BINDISTFILES = libcruft.$(SHLEXT_VER)
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,21 @@
+Thu Nov 12 17:44:15 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* cmd-edit.h (command_editor::readline): Add new variation that
+	allows EOF information to be passed back to caller.
+
+	* dMatrix.cc (Matrix::read): Do the right thing for EOF when
+	amount of data to read is unspecified.
+
 Tue Nov 10 07:53:15 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* oct-alloc.h (DECLARE_OCTAVE_ALLOCATOR): New macro.
+	(DEFINE_OCTAVE_ALLOCATOR): Ditto.
+
 	* byte-swap.h (swap_bytes, swap_2_bytes, swap_4_bytes, swap_8_bytes): 
 	Add volatile qualifier to void* arg.
 	Cast volatile void* arg to volatile char*.
 
 Mon Nov  9 08:28:31 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* cmd-edit.h (command_editor::do_set_event_hook): New function.
 	(command_editor::do_restore_event_hook): Ditto.
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -69,17 +69,17 @@ public:
   typedef command_editor::completion_fcn completion_fcn;
 
   gnu_readline (void);
 
   ~gnu_readline (void) { }
 
   void do_set_name (const string& n);
 
-  string do_readline (const string& prompt);
+  string do_readline (const string& prompt, bool& eof);
 
   void do_set_input_stream (FILE *f);
 
   FILE *do_get_input_stream (void);
 
   void do_set_output_stream (FILE *f);
 
   FILE *do_get_output_stream (void);
@@ -171,28 +171,32 @@ gnu_readline::do_set_name (const string&
   // Since we've already called rl_initialize, we need to re-read the
   // init file to take advantage of the conditional parsing feature
   // based on rl_readline_name;
 
   rl_re_read_init_file ();
 }
 
 string
-gnu_readline::do_readline (const string& prompt)
+gnu_readline::do_readline (const string& prompt, bool& eof)
 {
   string retval;
 
+  eof = false;
+
   char *line = ::readline (prompt.c_str ());
 
   if (line)
     {
       retval = line;
 
       free (line);
     }
+  else
+    eof = true;
 
   return retval;
 }
 
 void
 gnu_readline::do_set_input_stream (FILE *f)
 {
   rl_instream = f;
@@ -414,17 +418,17 @@ default_command_editor : public command_
 {
 public:
 
   default_command_editor (void)
     : command_editor (), input_stream (stdin), output_stream (stdout) { }
 
   ~default_command_editor (void) { }
 
-  string do_readline (const string& prompt);
+  string do_readline (const string& prompt, bool& eof);
 
   void do_set_input_stream (FILE *f);
 
   FILE *do_get_input_stream (void);
 
   void do_set_output_stream (FILE *f);
 
   FILE *do_get_output_stream (void);
@@ -436,18 +440,20 @@ public:
 private:
 
   FILE *input_stream;
 
   FILE *output_stream;
 };
 
 string
-default_command_editor::do_readline (const string& prompt)
+default_command_editor::do_readline (const string& prompt, bool& eof)
 {
+  eof = false;
+
   fprintf (output_stream, prompt.c_str ());
   fflush (output_stream);
 
   return octave_fgets (input_stream);
 }
 
 void
 default_command_editor::do_set_input_stream (FILE *f)
@@ -519,18 +525,26 @@ command_editor::set_name (const string& 
 {
   if (instance_ok ())
     instance->do_set_name (n);
 }
 
 string
 command_editor::readline (const string& prompt)
 {
+  bool eof;
+
+  return readline (prompt, eof);
+}
+
+string
+command_editor::readline (const string& prompt, bool& eof)
+{
   return (instance_ok ())
-    ? instance->do_readline (prompt) : string ();
+    ? instance->do_readline (prompt, eof) : string ();
 }
 
 void
 command_editor::set_input_stream (FILE *f)
 {
   if (instance_ok ())
     instance->do_set_input_stream (f);
 }
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -42,16 +42,18 @@ public:
   typedef string (*completion_fcn) (const string&, int);
 
   virtual ~command_editor (void) { }
 
   static void set_name (const string& n);
 
   static string readline (const string& prompt);
 
+  static string readline (const string& prompt, bool& eof);
+
   static void set_input_stream (FILE *f);
 
   static FILE *get_input_stream (void);
 
   static void set_output_stream (FILE *f);
 
   static FILE *get_output_stream (void);
 
@@ -115,17 +117,24 @@ private:
 protected:
 
   // To use something other than the GNU readline library, derive a new
   // class from command_editor, overload these functions as
   // necessary, and make instance point to the new class.
 
   virtual void do_set_name (const string&) { }
 
-  virtual string do_readline (const string&) = 0;
+  string do_readline (const string& prompt)
+    {
+      bool eof;
+
+      return do_readline (prompt, eof);
+    }
+
+  virtual string do_readline (const string&, bool&) = 0;
 
   virtual void do_set_input_stream (FILE *) = 0;
 
   virtual FILE *do_get_input_stream (void) = 0;
 
   virtual void do_set_output_stream (FILE *) = 0;
 
   virtual FILE *do_get_output_stream (void) = 0;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2612,17 +2612,17 @@ Matrix::read (istream& is, int nr, int n
 			}
 
 		      data[count++] = tmp;
 		    }
 
 		  if (ok && skip != 0)
 		    is.seekg (skip, ios::cur);
 
-		  if (! ok)
+		  if (! ok || is.eof ())
 		    {
 		      if (is.eof ())
 			{
 			  if (nr > 0)
 			    {
 			      if (count > nr)
 				{
 				  final_nr = nr;
diff --git a/liboctave/oct-alloc.h b/liboctave/oct-alloc.h
--- a/liboctave/oct-alloc.h
+++ b/liboctave/oct-alloc.h
@@ -54,15 +54,28 @@ private:
   // The size of each item on the list (or, if that is smaller than
   // the size of list*, the size of list*.
   size_t item_size;
 
   // How to grow the free list.
   bool grow (void);
 };
 
+#define DECLARE_OCTAVE_ALLOCATOR \
+  public: \
+    void *operator new (size_t size) { return allocator.alloc (size); } \
+    void operator delete (void *p, size_t size) { allocator.free (p, size); } \
+  private: \
+    static octave_allocator allocator;
+
+#define DEFINE_OCTAVE_ALLOCATOR(t) \
+  octave_allocator t::allocator (sizeof (t))
+
+#define DEFINE_OCTAVE_ALLOCATOR2(t, s) \
+  octave_allocator t::allocator (sizeof (t), s)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,79 @@
+Thu Nov 12 11:13:24 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* input.cc (gnu_readline): Check for EOF from command_editor::readline.
+
+	* ov-str-mat.h, ov-str-mat.cc (class octave_char_matrix_str):
+	Get common functions via new derivation scheme.
+	
+	* ov-bool-mat.h, ov-bool-mat.cc (class octave_bool_matrix):
+	Derive from octave_base_matrix and get common functions via derivation.
+	* ov-ch-mat.h, ov-ch-mat.cc (class octave_char_matrix): Ditto.
+	* ov-cx-mat.h, ov-cx-mat.cc (class octave_complex_matrix): Ditto.
+	* ov-re-mat.h, ov-re-mat.cc (class octave_real_matrix): Ditto.
+
+	* ov-base-mat.h, ov-base-mat.cc (class octave_base_matrix): New
+	files  for new class definition.  Put common matrix data type
+	stuff here.
+
+	* ov-list.cc (Fnth): New function.
+
+	* ov-list.cc (octave_list::do_index_op): Allow more complex indexing.
+
+	* oct-obj.cc (octave_value_list::index): New function.
+	(octave_value_list::octve_value_list (Array<octave_value>)):
+	New private constructor.
+
+	* ov-list.cc (Fsplice): Fix docstring to match.
+	* oct-obj.cc (octave_value_list::splice): Allow special case
+	splice (x, length(x)+1, 0, y) to be equivalent to append (x, y).
+
+	* ov-list.cc (Fappend): If an arg is a list, concatenate the lists
+	instead of appending arg as a single element.
+
+Wed Nov 11 14:07:27 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* load-save.cc (get_mat_data_input_line): New function.
+	(get_lines_and_columns): Use it here.
+	(read_mat_ascii_data): And here and do our own reading instead of
+	using Matrix::operator<<.
+
+Tue Nov 10 16:12:25 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* parse.y (make_constant): Initialize retval to 0.
+
+	* toplev.h (clean_up_and_exit (void)): Delete declaration.
+	* toplev.cc (do_octave_atexit): Move guts of clean_up_for_exit
+	here, but ensure that the actions are only executed once.
+	* octave.cc (main): Don't register cleanup_tmp_files with atexit.
+
+	* ov.h, ov.cc (class octave_value): Use DECLARE_OCTAVE_ALLOCATOR
+	and DEFINE_OCTAVE_ALLOCATOR for uniform declaration and definition
+	of allocator functions.  Use DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+	and DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA for uniform declaration
+	and definition of type id functions and data.
+	* ov-usr-fcn.h, ov-usr-fcn.cc (class octave_user_function): Ditto.
+	* ov-scalar.h, ov-scalar.cc (class octave_scalar): Ditto.
+	* ov-re-mat.h ov-re-mat.cc (class octave_matrix): Ditto.
+	* ov-range.h, ov-range.cc (class octave_range): Ditto.
+	* ov-mapper.h, ov-mapper.cc (class octave_mapper): Ditto.
+	* ov-list.h, ov-list.cc (class octave_list): Ditto.
+	* ov-file.h, ov-file.cc (class octave_file): Ditto.
+	* ov-fcn.h, ov-fcn.cc (class octave_function): Ditto.
+	* ov-cx-mat.h, ov-cx-mat.cc (class octave_complex_matrix): Ditto.
+	* ov-complex.h, ov-complex.cc (class octave_complex): Ditto.
+	* ov-ch-mat.h, ov-ch-mat.cc (octave_char_matrix): Ditto.
+	* ov-builtin.h, ov-builtin.cc (class octave_builtin): Ditto.
+	* ov-bool.h, ov-bool.cc (class octave_bool): Ditto.
+	* ov-bool-mat.h, ov-bool-mat.cc (octave_bool_matrix): Ditto.
+
+	* ov.h (DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA): New macro.
+	(DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA): Ditto.
+
 Mon Nov  9 16:12:37 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* pr-output.cc (octave_print_internal): Reorder default args for
 	charMatrix version.
 	(octave_print_internal): New function for boolMatrix.
 
 	* version.h (OCTAVE_STARTUP_MESSAGE): Note that this is a
 	development release.
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -61,17 +61,17 @@ ifeq ($(OCTAVE_LITE), true)
     DLD_STATIC_OBJ := $(DLD_OBJ)
   endif
 else
   DLD_STATIC_OBJ := $(DLD_OBJ)
 endif
 
 OV_INCLUDES := ov-re-mat.h ov-cx-mat.h ov-ch-mat.h \
 	ov-list.h ov-struct.h ov-scalar.h ov-range.h \
-	ov-complex.h ov-va-args.h ov-colon.h ov-base.h \
+	ov-complex.h ov-va-args.h ov-colon.h ov-base.h ov-base-mat.h \
 	ov-str-mat.h ov-bool-mat.h ov-bool.h ov-file.h ov.h \
 	ov-fcn.h ov-builtin.h ov-mapper.h ov-usr-fcn.h ov-typeinfo.h
 
 PT_INCLUDES := pt.h pt-all.h pt-arg-list.h pt-assign.h pt-binop.h \
 	pt-check.h pt-cmd.h pt-colon.h pt-const.h pt-decl.h \
 	pt-except.h pt-exp.h pt-id.h pt-idx.h pt-indir.h \
 	pt-jump.h pt-loop.h pt-mat.h pt-misc.h pt-plot.h \
 	pt-pr-code.h pt-select.h pt-stmt.h pt-unop.h pt-walk.h
@@ -99,17 +99,17 @@ OP_XSRC := op-b-b.cc op-bm-bm.cc op-chm.
 	op-cs-s.cc op-fil-b.cc op-fil-bm.cc op-fil-cm.cc op-fil-cs.cc \
 	op-fil-m.cc op-fil-s.cc op-fil-lis.cc op-fil-rec.cc \
 	op-fil-str.cc op-list.cc op-m-cm.cc op-m-cs.cc op-m-m.cc \
 	op-m-s.cc op-range.cc op-s-cm.cc op-s-cs.cc op-s-m.cc \
 	op-s-s.cc op-str-str.cc
 
 OP_SRC := $(addprefix OPERATORS/, $(OP_XSRC))
 
-OV_SRC := ov-base.cc ov-ch-mat.cc ov-list.cc ov-re-mat.cc \
+OV_SRC := ov-base.cc ov-base-mat.cc ov-ch-mat.cc ov-list.cc ov-re-mat.cc \
 	ov-cx-mat.cc ov-range.cc ov-scalar.cc ov-complex.cc \
 	ov-str-mat.cc ov-struct.cc ov-va-args.cc ov-colon.cc \
 	ov-bool-mat.cc ov-bool.cc ov-file.cc ov.cc ov-fcn.cc \
 	ov-builtin.cc ov-mapper.cc ov-usr-fcn.cc ov-typeinfo.cc
 
 PT_SRC := pt.cc pt-arg-list.cc pt-assign.cc pt-binop.cc pt-check.cc \
 	pt-cmd.cc pt-colon.cc pt-const.cc pt-decl.cc pt-except.cc \
 	pt-exp.cc pt-id.cc pt-idx.cc pt-indir.cc pt-jump.cc \
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -160,19 +160,21 @@ do_input_echo (const string& input_strin
 
 string
 gnu_readline (const string& s, bool force_readline)
 {
   string retval;
 
   if (line_editing || force_readline)
     {
-      retval = command_editor::readline (s);
+      bool eof;
 
-      if (retval.empty ())
+      retval = command_editor::readline (s, eof);
+
+      if (! eof && retval.empty ())
 	retval = "\n";
     }
   else
     {
       if (! s.empty () && (interactive || forced_interactive))
 	{
 	  FILE *stream = command_editor::get_output_stream ();
 
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -98,18 +98,21 @@ octave_value_list::splice (int offset, i
 			   const octave_value_list& lst) const
 { 
   octave_value_list retval;
 
   int len = length ();
 
   if (offset < 0 || offset >= len)
     {
-      error ("octave_value_list::splice: invalid OFFSET");
-      return retval;
+      if (! (rep_length == 0 && offset == len))
+	{
+	  error ("octave_value_list::splice: invalid OFFSET");
+	  return retval;
+	}
     }
 
   if (rep_length < 0 || rep_length + offset > len)
     {
       error ("octave_value_list::splice: invalid LENGTH");
       return retval;
     }
 
@@ -128,16 +131,22 @@ octave_value_list::splice (int offset, i
     retval(k++) = lst(i);
 
   for (int i = offset + rep_length; i < len; i++)
     retval(k++) = elem (i);
 
   return retval;
 }
 
+octave_value_list
+octave_value_list::index (idx_vector& i) const
+{
+  return octave_value_list (data.index (i));
+}
+
 bool
 octave_value_list::all_strings_p (void) const
 {
   int n = length ();
 
   for (int i = 0; i < n; i++)
     if (! elem(i).is_string ())
       return 0;
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -131,16 +131,18 @@ public:
 
   octave_value_list& append (const octave_value_list& lst);
 
   octave_value_list& reverse (void);
 
   octave_value_list splice (int offset, int length,
 			    const octave_value_list& lst) const;
 
+  octave_value_list index (idx_vector& i) const;
+
   bool all_strings_p (void) const;
 
   string_vector make_argv (const string&) const;
 
   void stash_name_tags (const string_vector& nm) { names = nm; }
 
   string_vector name_tags (void) const { return names; }
 
@@ -165,16 +167,19 @@ private:
   //
   //   octave_value_list (n, val);
   //
   // and supply a default value to create a vector-valued
   // octave_value_list.
 
   octave_value_list (int n);
 
+  octave_value_list (const Array<octave_value>& d)
+    : data (d) { }
+
   void maybe_resize (int n)
     {
       if (n >= length ())
 	data.resize (n + 1, Matrix ());
     }
 
   octave_value& elem (int n)
     {
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-base-mat.cc
@@ -0,0 +1,87 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <iostream.h>
+
+#include "ov-base.h"
+#include "ov-base-mat.h"
+
+template <class MT>
+bool
+octave_base_matrix<MT>::print_as_scalar (void) const
+{
+  int nr = rows ();
+  int nc = columns ();
+
+  return (nr == 1 && nc == 1 || (nr == 0 || nc == 0));
+}
+
+template <class MT>
+void
+octave_base_matrix<MT>::print (ostream& os, bool pr_as_read_syntax) const
+{
+  print_raw (os, pr_as_read_syntax);
+  newline (os);
+}
+
+template <class MT>
+void
+octave_base_matrix<MT>::print_raw (ostream& os, bool pr_as_read_syntax) const
+{
+  octave_print_internal (os, matrix, pr_as_read_syntax,
+			 current_print_indent_level ());
+}
+
+template <class MT>
+bool
+octave_base_matrix<MT>::print_name_tag (ostream& os, const string& name) const
+{
+  bool retval = false;
+
+  indent (os);
+
+  if (print_as_scalar ())
+    os << name << " = ";
+  else
+    {
+      os << name << " =";
+      newline (os);
+      newline (os);
+      retval = true;
+    }
+
+  return retval;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
new file mode 100644
--- /dev/null
+++ b/src/ov-base-mat.h
@@ -0,0 +1,102 @@
+/*
+
+Copyright (C) 1998 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_base_matrix_h)
+#define octave_base_matrix_h 1
+
+#if defined (__GNUG__)
+#pragma interface
+#endif
+
+#include <cstdlib>
+
+#include <string>
+
+class ostream;
+
+#include "mx-base.h"
+#include "str-vec.h"
+
+#include "error.h"
+#include "ov-base.h"
+#include "ov-typeinfo.h"
+
+class Octave_map;
+class octave_value_list;
+
+class tree_walker;
+
+// Real matrix values.
+
+template <class MT> class
+octave_base_matrix : public octave_base_value
+{
+public:
+
+  octave_base_matrix (void)
+    : octave_base_value () { }
+
+  octave_base_matrix (const MT& m)
+    : octave_base_value (), matrix (m) { }
+
+  octave_base_matrix (const octave_base_matrix& m)
+    : octave_base_value (), matrix (m.matrix) { }
+
+  ~octave_base_matrix (void) { }
+
+  octave_value *clone (void) { return new octave_base_matrix (*this); }
+
+  int rows (void) const { return matrix.rows (); }
+  int columns (void) const { return matrix.columns (); }
+
+  int length (void) const
+  {
+    int r = rows ();
+    int c = columns ();
+
+    return r > c ? r : c;
+  }
+
+  bool is_defined (void) const { return true; }
+
+  bool is_constant (void) const { return true; }
+
+  virtual bool print_as_scalar (void) const;
+
+  void print (ostream& os, bool pr_as_read_syntax = false) const;
+
+  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+
+  bool print_name_tag (ostream& os, const string& name) const;
+
+protected:
+
+  MT matrix;
+};
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -43,19 +43,17 @@ Software Foundation, 59 Temple Place - S
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-ch-mat.h"
 #include "ov-str-mat.h"
 #include "ov-range.h"
 #include "ov-list.h"
 #include "variables.h"
 
-int octave_base_value::t_id = -1;
-
-const string octave_base_value::t_name ("<unknown type>");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value, "<unknown type>");
 
 octave_value
 octave_base_value::do_index_op (const octave_value_list&)
 {
   string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -79,21 +79,21 @@ public:
   octave_value
   do_struct_elt_index_op (const string& nm, const octave_value_list& idx,
 			  bool silent);
 
   octave_value do_struct_elt_index_op (const string& nm, bool silent);
 
   octave_lvalue struct_elt_ref (octave_value *parent, const string& nm);
 
-  int rows (void) const { reteurn -1; }
+  int rows (void) const { return -1; }
 
-  int columns (void) const { reteurn -1; }
+  int columns (void) const { return -1; }
 
-  int length (void) const { reteurn -1; }
+  int length (void) const { return -1; }
 
   bool is_defined (void) const { return false; }
 
   bool is_real_scalar (void) const { return false; }
 
   bool is_real_matrix (void) const { return false; }
 
   bool is_complex_scalar (void) const { return false; }
@@ -192,32 +192,19 @@ public:
   void convert_to_row_or_column_vector (void);
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
-  // Type id of base value objects, set by register_type().
-  static int t_id;
-
-  // Type name of base value objects, defined in ov-base.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -31,29 +31,29 @@ Software Foundation, 59 Temple Place - S
 #include <iostream.h>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ops.h"
+#include "ov-base.h"
+#include "ov-base-mat.h"
+#include "ov-base-mat.cc"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-re-mat.h"
 #include "pr-output.h"
 
-octave_allocator
-octave_bool_matrix::allocator (sizeof (octave_bool_matrix));
+template class octave_base_matrix<boolMatrix>;
 
-int
-octave_bool_matrix::t_id (-1);
+DEFINE_OCTAVE_ALLOCATOR (octave_bool_matrix);
 
-const string
-octave_bool_matrix::t_name ("bool matrix");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool_matrix, "bool matrix");
 
 static octave_value *
 default_numeric_conversion_function (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_bool_matrix&);
 
   return new octave_matrix (Matrix (v.bool_matrix_value ()));
 }
@@ -207,51 +207,13 @@ octave_bool_matrix::complex_value (bool)
       || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
     retval = matrix (0, 0);
   else
     gripe_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
 
-void
-octave_bool_matrix::print (ostream& os, bool pr_as_read_syntax) const
-{
-  print_raw (os, pr_as_read_syntax);
-  newline (os);
-}
-
-void
-octave_bool_matrix::print_raw (ostream& os, bool pr_as_read_syntax) const
-{
-  Matrix tmp (matrix);
-  octave_print_internal (os, tmp, pr_as_read_syntax,
-			 current_print_indent_level ());
-}
-
-bool
-octave_bool_matrix::print_name_tag (ostream& os, const string& name) const
-{
-  bool retval = false;
-
-  int nr = rows ();
-  int nc = columns ();
-
-  indent (os);
-
-  if (nr == 1 && nc == 1 || (nr == 0 || nc == 0))
-    os << name << " = ";
-  else
-    {
-      os << name << " =";
-      newline (os);
-      newline (os);
-      retval = true;
-    }
-
-  return retval;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -33,74 +33,54 @@ Software Foundation, 59 Temple Place - S
 
 class ostream;
 
 #include "mx-base.h"
 #include "oct-alloc.h"
 
 #include "error.h"
 #include "ov-base.h"
+#include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Character matrix values.
 
 class
-octave_bool_matrix : public octave_base_value
+octave_bool_matrix : public octave_base_matrix<boolMatrix>
 {
 public:
 
   octave_bool_matrix (void)
-    : octave_base_value () { }
+    : octave_base_matrix () { }
 
   octave_bool_matrix (const boolMatrix& bm)
-    : octave_base_value (), matrix (bm) { }
+    : octave_base_matrix (bm) { }
 
   octave_bool_matrix (const octave_bool_matrix& bm)
-    : octave_base_value (), matrix (bm.matrix) { }
+    : octave_base_matrix (bm) { }
 
   ~octave_bool_matrix (void) { }
 
   octave_value *clone (void) { return new octave_bool_matrix (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx);
 
   void assign (const octave_value_list& idx, const boolMatrix& rhs);
 
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
-  int rows (void) const { return matrix.rows (); }
-  int columns (void) const { return matrix.columns (); }
-
-  int length (void) const
-  {
-    int r = rows ();
-    int c = columns ();
-
-    return r > c ? r : c;
-  }
-
-  bool is_defined (void) const { return true; }
-
-  bool is_constant (void) const { return true; }
-
   bool is_bool_matrix (void) const { return true; }
 
   octave_value all (void) const { return matrix.all (); }
   octave_value any (void) const { return matrix.any (); }
 
   bool is_bool_type (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
@@ -128,42 +108,21 @@ public:
     { return matrix; }
 
   boolMatrix bool_matrix_value (bool = false) const
     { return matrix; }
 
   octave_value convert_to_str (void) const
     { return octave_value (matrix); }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
-
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
-
-  bool print_name_tag (ostream& os, const string& name) const;
-
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 protected:
 
-  boolMatrix matrix;
-
-  static octave_allocator allocator;
+  DECLARE_OCTAVE_ALLOCATOR
 
-  // Type id of bool matrix objects, set by register_type().
-  static int t_id;
-
-  // Type name of bool matrix objects, defined in ov-bool-mat.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -35,24 +35,19 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-bool.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 
-octave_allocator
-octave_bool::allocator (sizeof (octave_bool));
+DEFINE_OCTAVE_ALLOCATOR (octave_bool);
 
-int
-octave_bool::t_id (-1);
-
-const string
-octave_bool::t_name ("bool");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool, "bool");
 
 static octave_value *
 default_numeric_conversion_function (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_bool&);
 
   return new octave_scalar (v.bool_value ());
 }
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -61,22 +61,16 @@ public:
 
   octave_bool (const octave_bool& s)
     : octave_base_value (), scalar (s.scalar) { }
 
   ~octave_bool (void) { }
 
   octave_value *clone (void) { return new octave_bool (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int rows (void) const { return 1; }
   int columns (void) const { return 1; }
@@ -126,38 +120,24 @@ public:
   octave_value convert_to_str (void) const;
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   // The value of this scalar.
   bool scalar;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of bool objects, set by register_type().
-  static int t_id;
-
-  // Type name of bool objects, defined in ov-bool.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -28,24 +28,19 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-builtin.h"
 #include "ov.h"
 
-octave_allocator
-octave_builtin::allocator (sizeof (octave_builtin));
+DEFINE_OCTAVE_ALLOCATOR (octave_builtin);
 
-int
-octave_builtin::t_id (-1);
-
-const string
-octave_builtin::t_name ("built-in function");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_builtin, "built-in function");
 
 // Are any of the arguments `:'?
 
 static bool
 any_arg_is_magic_colon (const octave_value_list& args)
 {
   int nargin = args.length ();
 
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -45,52 +45,32 @@ public:
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const string& nm = string (),
 		  const string& ds = string ())
     : octave_function (nm, ds), f (ff) { }
 
   ~octave_builtin (void) { }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_function *function_value (bool) { return this; }
 
   octave_value_list do_index_op (int nargout, const octave_value_list& args);
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   octave_builtin (void);
 
   octave_builtin (const octave_builtin& m);
 
   // A pointer to the actual function.
   fcn f;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of list objects, set by register_type().
-  static int t_id;
-
-  // Type name of list objects, defined in ov-list.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -28,28 +28,28 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <iostream.h>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 
+#include "ov-base.h"
+#include "ov-base-mat.h"
+#include "ov-base-mat.cc"
 #include "ov-ch-mat.h"
 #include "gripes.h"
 #include "pr-output.h"
 
-octave_allocator
-octave_char_matrix::allocator (sizeof (octave_char_matrix));
+template class octave_base_matrix<charMatrix>;
 
-int
-octave_char_matrix::t_id (-1);
+DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix);
 
-const string
-octave_char_matrix::t_name ("char matrix");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix, "char matrix");
 
 bool
 octave_char_matrix::valid_as_scalar_index (void) const
 {
   bool retval = false;
   error ("octave_char_matrix::valid_as_scalar_index(): not implemented");
   return retval;
 }
@@ -109,50 +109,13 @@ octave_char_matrix::complex_value (bool)
       || (Vdo_fortran_indexing && rows () > 0 && columns () > 0))
     retval = matrix (0, 0);
   else
     gripe_invalid_conversion ("character matrix", "complex scalar");
 
   return retval;
 }
 
-void
-octave_char_matrix::print (ostream& os, bool pr_as_read_syntax) const
-{
-  print_raw (os, pr_as_read_syntax);
-  newline (os);
-}
-
-void
-octave_char_matrix::print_raw (ostream& os, bool pr_as_read_syntax) const
-{
-  octave_print_internal (os, matrix, pr_as_read_syntax, false,
-			 current_print_indent_level ());
-}
-
-bool
-octave_char_matrix::print_name_tag (ostream& os, const string& name) const
-{
-  bool retval = false;
-
-  int nr = rows ();
-  int nc = columns ();
-
-  indent (os);
-
-  if (nr == 1 && nc == 1 || (nr == 0 || nc == 0))
-    os << name << " = ";
-  else
-    {
-      os << name << " =";
-      newline (os);
-      newline (os);
-      retval = true;
-    }
-
-  return retval;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -34,76 +34,56 @@ Software Foundation, 59 Temple Place - S
 class ostream;
 
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "ov-base.h"
+#include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Character matrix values.
 
 class
-octave_char_matrix : public octave_base_value
+octave_char_matrix : public octave_base_matrix<charMatrix>
 {
 public:
 
   octave_char_matrix (void)
-    : octave_base_value () { }
+    : octave_base_matrix<charMatrix> () { }
 
   octave_char_matrix (const charMatrix& chm, bool = false)
-    : octave_base_value (), matrix (chm) { }
+    : octave_base_matrix<charMatrix> (chm) { }
 
   octave_char_matrix (char c)
-    : octave_base_value (), matrix (c) { }
+    : octave_base_matrix<charMatrix> (c) { }
 
   octave_char_matrix (const char *s)
-    : octave_base_value (), matrix (s) { }
+    : octave_base_matrix<charMatrix> (s) { }
 
   octave_char_matrix (const string& s)
-    : octave_base_value (), matrix (s) { }
+    : octave_base_matrix<charMatrix> (s) { }
 
   octave_char_matrix (const string_vector& s)
-    : octave_base_value (), matrix (s) { }
+    : octave_base_matrix<charMatrix> (s) { }
 
   octave_char_matrix (const octave_char_matrix& chm)
-    : octave_base_value (), matrix (chm.matrix) { }
+    : octave_base_matrix<charMatrix> (chm) { }
 
   ~octave_char_matrix (void) { }
 
   octave_value *clone (void) { return new octave_char_matrix (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
-  int rows (void) const { return matrix.rows (); }
-  int columns (void) const { return matrix.columns (); }
-
-  int length (void) const
-  {
-    int r = rows ();
-    int c = columns ();
-
-    return r > c ? r : c;
-  }
-
-  bool is_constant (void) const { return true; }
-
-  bool is_defined (void) const { return true; }
-
   bool is_char_matrix (void) const { return true; }
   bool is_real_matrix (void) const { return true; }
 
   octave_value all (void) const { return matrix.all (); }
   octave_value any (void) const { return matrix.any (); }
 
   bool is_real_type (void) const { return true; }
 
@@ -129,42 +109,21 @@ public:
     { return matrix; }
 
   charMatrix char_matrix_value (bool = false) const
     { return matrix; }
 
   octave_value convert_to_str (void) const
     { return octave_value (matrix, true); }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
-
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
-
-  bool print_name_tag (ostream& os, const string& name) const;
-
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 protected:
 
-  charMatrix matrix;
-
-  static octave_allocator allocator;
+  DECLARE_OCTAVE_ALLOCATOR
 
-  // Type id of character matrix objects, set by register_type().
-  static int t_id;
-
-  // Type name of character matrix objects, defined in ov-ch-mat.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-colon.cc b/src/ov-colon.cc
--- a/src/ov-colon.cc
+++ b/src/ov-colon.cc
@@ -29,19 +29,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <iostream.h>
 
 #include "error.h"
 #include "pr-output.h"
 #include "ov-colon.h"
 
-int octave_magic_colon::t_id = -1;
-
-const string octave_magic_colon::t_name ("magic-colon");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_magic_colon, "magic-colon");
 
 void
 octave_magic_colon::print (ostream& os, bool) const
 {
   indent (os);
   print_raw (os);
 }
 
diff --git a/src/ov-colon.h b/src/ov-colon.h
--- a/src/ov-colon.h
+++ b/src/ov-colon.h
@@ -69,32 +69,19 @@ public:
   bool valid_as_scalar_index (void) const { return true; }
 
   bool valid_as_zero_index (void) const { return false; }
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
-  // Type id of magic colon objects, set by register_type().
-  static int t_id;
-
-  // Type name of magic colon objects, defined in ov-colon.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -35,24 +35,19 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "gripes.h"
 #include "pr-output.h"
 
-octave_allocator
-octave_complex::allocator (sizeof (octave_complex));
+DEFINE_OCTAVE_ALLOCATOR (octave_complex);
 
-int
-octave_complex::t_id (-1);
-
-const string
-octave_complex::t_name ("complex scalar");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex, "complex scalar");
 
 octave_value *
 octave_complex::try_narrowing_conversion (void)
 {
   octave_value *retval = 0;
 
   if (imag (scalar) == 0.0)
     retval = new octave_scalar (::real (scalar));
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -61,22 +61,16 @@ public:
 
   octave_complex (const octave_complex& c)
     : octave_base_value (), scalar (c.scalar) { }
 
   ~octave_complex (void) { }
 
   octave_value *clone (void) { return new octave_complex (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx);
 
   int rows (void) const { return 1; }
   int columns (void) const { return 1; }
 
   int length (void) const
@@ -126,36 +120,23 @@ public:
   void decrement (void) { scalar -= 1.0; }
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   Complex scalar;
 
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of complex scalar objects, set in register_type().
-  static int t_id;
-
-  // Type name of complex scalar objects, defined in ov-complex.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -31,42 +31,44 @@ Software Foundation, 59 Temple Place - S
 #include <iostream.h>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ops.h"
+#include "ov-base.h"
+#include "ov-base-mat.h"
+#include "ov-base-mat.cc"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 
-octave_allocator
-octave_complex_matrix::allocator (sizeof (octave_complex_matrix));
+template class octave_base_matrix<ComplexMatrix>;
 
-int
-octave_complex_matrix::t_id (-1);
+DEFINE_OCTAVE_ALLOCATOR (octave_complex_matrix);
 
-const string
-octave_complex_matrix::t_name ("complex matrix");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_matrix, "complex matrix");
 
 octave_complex_matrix::octave_complex_matrix (const ComplexRowVector& v,
 					      int pcv)
-  : octave_base_value (),
-    matrix ((pcv < 0 && Vprefer_column_vectors) || pcv
-	    ? ComplexMatrix (v.transpose ()) : ComplexMatrix (v)) { }
+  : octave_base_matrix<ComplexMatrix> (((pcv < 0 && Vprefer_column_vectors)
+					|| pcv)
+				       ? ComplexMatrix (v.transpose ())
+				       : ComplexMatrix (v)) { }
 
 octave_complex_matrix::octave_complex_matrix (const ComplexColumnVector& v,
 					      int pcv)
-  : octave_base_value (),
-    matrix ((pcv < 0 && Vprefer_column_vectors) || pcv
-	    ? ComplexMatrix (v) : ComplexMatrix (v.transpose ())) { }
+  : octave_base_matrix<ComplexMatrix> (((pcv < 0 && Vprefer_column_vectors)
+					|| pcv)
+				       ? ComplexMatrix (v)
+				       : ComplexMatrix (v.transpose ())) { }
 
 octave_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
   octave_value *retval = 0;
 
   int nr = matrix.rows ();
   int nc = matrix.cols ();
@@ -305,50 +307,13 @@ octave_complex_matrix::complex_value (bo
 }
 
 ComplexMatrix
 octave_complex_matrix::complex_matrix_value (bool) const
 {
   return matrix;
 }
 
-void
-octave_complex_matrix::print (ostream& os, bool pr_as_read_syntax) const
-{
-  print_raw (os, pr_as_read_syntax);
-  newline (os);
-}
-
-void
-octave_complex_matrix::print_raw (ostream& os, bool pr_as_read_syntax) const
-{
-  octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
-}
-
-bool
-octave_complex_matrix::print_name_tag (ostream& os, const string& name) const
-{
-  bool retval = false;
-
-  int nr = rows ();
-  int nc = columns ();
-
-  indent (os);
-
-  if (nr == 1 && nc == 1 || (nr == 0 || nc == 0))
-    os << name << " = ";
-  else
-    {
-      os << name << " =";
-      newline (os);
-      newline (os);
-      retval = true;
-    }
-
-  return retval;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -34,79 +34,59 @@ Software Foundation, 59 Temple Place - S
 class ostream;
 
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "ov-base.h"
+#include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Complex matrix values.
 
 class
-octave_complex_matrix : public octave_base_value
+octave_complex_matrix : public octave_base_matrix<ComplexMatrix>
 {
 public:
 
   octave_complex_matrix (void)
-    : octave_base_value () { }
+    : octave_base_matrix<ComplexMatrix> () { }
 
   octave_complex_matrix (const ComplexMatrix& m)
-    : octave_base_value (), matrix (m) { }
+    : octave_base_matrix<ComplexMatrix> (m) { }
 
   octave_complex_matrix (const ComplexDiagMatrix& d)
-    : octave_base_value (), matrix (d) { }
+    : octave_base_matrix<ComplexMatrix> (d) { }
 
   octave_complex_matrix (const ComplexRowVector& v, int pcv = -1);
 
   octave_complex_matrix (const ComplexColumnVector& v, int pcv = -1);
 
   octave_complex_matrix (const octave_complex_matrix& cm)
-    : octave_base_value (), matrix (cm.matrix) { }
+    : octave_base_matrix<ComplexMatrix> (cm) { }
 
   ~octave_complex_matrix (void) { }
 
   octave_value *clone (void) { return new octave_complex_matrix (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx);
 
   void assign (const octave_value_list& idx, const ComplexMatrix& rhs);
 
   void assign (const octave_value_list& idx, const Matrix& rhs);
 
-  int rows (void) const { return matrix.rows (); }
-  int columns (void) const { return matrix.columns (); }
-
-  int length (void) const
-  {
-    int r = rows ();
-    int c = columns ();
-
-    return r > c ? r : c;
-  }
-
-  bool is_defined (void) const { return true; }
-
-  bool is_constant (void) const { return true; }
-
   bool is_complex_matrix (void) const { return true; }
 
   octave_value all (void) const { return matrix.all (); }
   octave_value any (void) const { return matrix.any (); }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_matrix_type (void) const { return true; }
@@ -130,42 +110,21 @@ public:
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   void increment (void) { matrix += Complex (1.0); }
 
   void decrement (void) { matrix -= Complex (1.0); }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
-
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
-
-  bool print_name_tag (ostream& os, const string& name) const;
-
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
-  ComplexMatrix matrix;
-
-  static octave_allocator allocator;
+  DECLARE_OCTAVE_ALLOCATOR
 
-  // Type id of complex matrix objects, set by register_type().
-  static int t_id;
-
-  // Type name of complex matrix objects, defined in ov-cx-mat.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-fcn.cc b/src/ov-fcn.cc
--- a/src/ov-fcn.cc
+++ b/src/ov-fcn.cc
@@ -26,18 +26,17 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "error.h"
 #include "ov-fcn.h"
 
-octave_allocator
-octave_function::allocator (sizeof (octave_function));
+DEFINE_OCTAVE_ALLOCATOR (octave_function);
 
 octave_function *
 octave_function::clone (void)
 {
   panic_impossible ();
 }
 
 /*
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -48,22 +48,16 @@ public:
     : octave_base_value (), my_name (f.my_name), doc (f.doc) { }
 
   ~octave_function (void) { }
 
   // This should only be called for derived types.
 
   octave_function *clone (void);
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_system_fcn_file (void) { return false; }
 
   virtual string fcn_file_name (void) const { return string (); }
 
@@ -89,18 +83,17 @@ private:
   octave_function (void);
 
   // The name of this function.
   string my_name;
 
   // The help text for this function.
   string doc;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;; Local Variables: ***
 ;; mode: C++ ***
 ;; End: ***
diff --git a/src/ov-file.cc b/src/ov-file.cc
--- a/src/ov-file.cc
+++ b/src/ov-file.cc
@@ -31,24 +31,19 @@ Software Foundation, 59 Temple Place - S
 #include <iostream.h>
 
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-file.h"
 #include "ov-scalar.h"
 #include "unwind-prot.h"
 
-octave_allocator
-octave_file::allocator (sizeof (octave_file));
+DEFINE_OCTAVE_ALLOCATOR (octave_file);
 
-int
-octave_file::t_id (-1);
-
-const string
-octave_file::t_name ("file");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_file, "file");
 
 static octave_value *
 default_numeric_conversion_function (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_file&);
 
   return new octave_scalar (static_cast<double> (v.stream_number ()));
 }
diff --git a/src/ov-file.h b/src/ov-file.h
--- a/src/ov-file.h
+++ b/src/ov-file.h
@@ -57,22 +57,16 @@ public:
 
   octave_file (const octave_file& f)
     : octave_base_value (), stream (f.stream), number (f.number) { }
 
   ~octave_file (void) { }
 
   octave_value *clone (void) { return new octave_file (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   type_conv_fcn numeric_conversion_function (void) const;
 
   double double_value (bool) const { return static_cast<double> (number); }
 
   double scalar_value (bool) const { return static_cast<double> (number); }
 
   octave_stream *stream_value (void) const { return stream; }
 
@@ -83,41 +77,27 @@ public:
   bool is_file (void) const { return true; }
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   // The stream object.
   octave_stream *stream;
 
   // The number of the beast.
   int number;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of list objects, set by register_type().
-  static int t_id;
-
-  // Type name of list objects, defined in ov-list.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -33,45 +33,30 @@ Software Foundation, 59 Temple Place - S
 
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov-list.h"
 #include "unwind-prot.h"
 
-octave_allocator
-octave_list::allocator (sizeof (octave_list));
+DEFINE_OCTAVE_ALLOCATOR (octave_list);
 
-int
-octave_list::t_id (-1);
-
-const string
-octave_list::t_name ("list");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_list, "list");
 
 octave_value
 octave_list::do_index_op (const octave_value_list& idx)
 {
   octave_value retval;
 
   if (idx.length () == 1)
     {
-      int i = idx(0).int_value (true);
-
-      if (! error_state)
-	{
-	  int n = lst.length ();
+      idx_vector i = idx (0).index_vector ();
 
-	  if (i > 0 && i <= n)
-	    retval = lst(i-1);
-	  else
-	    error ("list index = %d out of range", i);
-	}
-      else
-	error ("list index must be an integer");
+      retval = octave_value_list (lst.index (i));
     }
   else
     error ("lists may only be indexed by a single scalar");
 
   return retval;
 }
 
 void
@@ -161,33 +146,83 @@ octave_list::print_name_tag (ostream& os
 DEFUN (list, args, ,
   "list (ARGS)\n\
 \n\
 Create a new list from ARGS.")
 {
   return octave_value (args);
 }
 
+DEFUN (nth, args, ,
+  "nth (LIST, N)\n\
+\n\
+Return the N-th element of LIST.")
+{
+  octave_value retval;
+
+  if (args.length () == 2)
+    {
+      octave_value_list lst = args(0).list_value ();
+
+      if (! error_state)
+	{
+	  int n = args(1).int_value (true);
+
+	  if (! error_state)
+	    {
+	      if (n > 0 && n <= lst.length ())
+		retval = lst(n-1);
+	      else
+		error ("nth: index = %d out of range", n);
+	    }
+	  else
+	    error ("nth: second argument must be an integer");
+	}
+      else
+	error ("nth: first argument must be a list");
+    }
+  else
+    print_usage ("nth");
+
+  return retval;
+}
+
 DEFUN (append, args, ,
-  "append (LIST, ARGS)\n\
+  "append (LIST, ARG, ...)\n\
+\n\
+Return a new list created by appending each ARG to LIST.  If any of\n\
+the arguments to be appended is a list, its elements are appended\n\
+individually.  For example,\n\
 \n\
-Return a new list created by appending ARGS to LIST")
+  x = list (1, 2);\n\
+  y = list (3, 4);\n\
+  append (x, y);\n\
+\n\
+results in the list containing the four elements (1 2 3 4), not a list\n\
+containing the three elements (1 2 (3 4))")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
       octave_value_list tmp = args(0).list_value ();
 
       if (! error_state)
 	{
 	  for (int i = 1; i < nargin; i++)
-	    tmp.append (args(i));
+	    {
+	      octave_value ov = args(i);
+
+	      if (ov.is_list ())
+		tmp.append (ov.list_value ());
+	      else
+		tmp.append (ov);
+	    }
 
 	  retval = tmp;
 	}
     }
   else
     print_usage ("append");
 
   return retval;
@@ -218,17 +253,19 @@ Return a new list created by reversing t
 DEFUN (splice, args, ,
   "splice (LIST_1, OFFSET, LENGTH, LIST_2)\n\
 splice (LIST_1, OFFSET, LENGTH, LIST_2)\n\
 splice (LIST_1, OFFSET, LENGTH)\n\
 splice (LIST_1, OFFSET)\n\
 \n\
 Replace LENGTH elements of LIST_1 beginning at OFFSET with the\n\
 contents of LIST_2 (if any).  If LENGTH is omitted, all elements\n\
-from OFFSET to the end of LIST_1 are replaced.")
+from OFFSET to the end of LIST_1 are replaced.  As a special case, if\n\
+OFFSET is one greater than the length of LIST_1 and LENGTH is 0,\n\
+splice is equivalent to append (LIST_1, LIST_2)")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1 && nargin < 5)
     {
       octave_value_list list_1 = args(0).list_value ();
diff --git a/src/ov-list.h b/src/ov-list.h
--- a/src/ov-list.h
+++ b/src/ov-list.h
@@ -59,22 +59,16 @@ public:
 
   octave_list (const octave_list& l)
     : octave_base_value (), lst (l.lst) { }
 
   ~octave_list (void) { }
 
   octave_value *clone (void) { return new octave_list (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_value do_index_op (const octave_value_list& idx);
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
   int length (void) const { return lst.length (); }
 
   bool is_defined (void) const { return true; }
 
@@ -85,38 +79,24 @@ public:
   octave_value_list list_value (void) const { return lst; }
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   // The list of Octave values.
   octave_value_list lst;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of list objects, set by register_type().
-  static int t_id;
-
-  // Type name of list objects, defined in ov-list.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -29,24 +29,20 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-mapper.h"
 #include "ov.h"
 
-octave_allocator
-octave_mapper::allocator (sizeof (octave_mapper));
+DEFINE_OCTAVE_ALLOCATOR (octave_mapper);
 
-int
-octave_mapper::t_id (-1);
-
-const string
-octave_mapper::t_name ("built-in mapper function");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mapper,
+				     "built-in mapper function");
 
 static bool
 any_element_less_than (const Matrix& a, double val)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
   for (int j = 0; j < nc; j++)
diff --git a/src/ov-mapper.h b/src/ov-mapper.h
--- a/src/ov-mapper.h
+++ b/src/ov-mapper.h
@@ -52,35 +52,20 @@ public:
 		 const string& nm = string (),
 		 const string& ds = string ())
     : octave_function (nm, ds), ch_map_fcn (ch), d_d_map_fcn (dd),
       d_c_map_fcn (dc), c_c_map_fcn (cc),
       lower_limit (ll), upper_limit (ul), flag (f) { }
 
   ~octave_mapper (void) { }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_function *function_value (bool) { return this; }
 
   octave_value_list do_index_op (int nargout, const octave_value_list& args);
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   octave_mapper (void);
 
   octave_mapper (const octave_mapper& m);
 
   octave_value apply (const octave_value& arg) const;
 
@@ -105,24 +90,19 @@ private:
   //   1  =>  this function returns a numeric matrix (any values)
   //   2  =>  this function returns a string array
   //
   // For other mappers, nonzero means that this function can return a
   // complex value for some real arguments.
 
   int flag;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of list objects, set by register_type().
-  static int t_id;
-
-  // Type name of list objects, defined in ov-list.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -35,24 +35,19 @@ Software Foundation, 59 Temple Place - S
 
 #include "gripes.h"
 #include "ops.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 
-octave_allocator
-octave_range::allocator (sizeof (octave_range));
+DEFINE_OCTAVE_ALLOCATOR (octave_range);
 
-int
-octave_range::t_id (-1);
-
-const string
-octave_range::t_name ("range");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_range, "range");
 
 static octave_value *
 default_numeric_conversion_function (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_range&);
 
   return new octave_matrix (v.matrix_value ());
 }
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -76,22 +76,16 @@ public:
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range) { }
 
   ~octave_range (void) { }
 
   octave_value *clone (void) { return new octave_range (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx);
 
   idx_vector index_vector (void) const { return idx_vector (range); }
 
@@ -147,36 +141,23 @@ public:
   octave_value convert_to_str (void) const;
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   Range range;
 
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of range objects, set by register_type ().
-  static int t_id;
-
-  // Type name of scalar objects, defined in ov-range.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -33,39 +33,37 @@ Software Foundation, 59 Temple Place - S
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "ops.h"
+#include "ov-base.h"
+#include "ov-base-mat.h"
+#include "ov-base-mat.cc"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "pr-output.h"
 #include "variables.h"
 
-octave_allocator
-octave_matrix::allocator (sizeof (octave_matrix));
+template class octave_base_matrix<Matrix>;
 
-int
-octave_matrix::t_id (-1);
+DEFINE_OCTAVE_ALLOCATOR (octave_matrix);
 
-const string
-octave_matrix::t_name ("matrix");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_matrix, "matrix");
 
 octave_matrix::octave_matrix (const RowVector& v, int pcv)
-  : octave_base_value (),
-    matrix ((pcv < 0 && Vprefer_column_vectors) || pcv
-	    ? Matrix (v.transpose ()) : Matrix (v)) { }
+  : octave_base_matrix<Matrix> ((pcv < 0 && Vprefer_column_vectors) || pcv
+				? Matrix (v.transpose ()) : Matrix (v)) { }
 
 octave_matrix::octave_matrix (const ColumnVector& v, int pcv)
-  : octave_base_value (),
-    matrix ((pcv < 0 && Vprefer_column_vectors) || pcv
-	    ? Matrix (v) : Matrix (v.transpose ())) { }
+  : octave_base_matrix<Matrix> ((pcv < 0 && Vprefer_column_vectors) || pcv
+			       ? Matrix (v) : Matrix (v.transpose ())) { }
 
 octave_value *
 octave_matrix::try_narrowing_conversion (void)
 {
   octave_value *retval = 0;
 
   int nr = matrix.rows ();
   int nc = matrix.cols ();
@@ -365,50 +363,13 @@ octave_matrix::convert_to_str (void) con
 
 	  retval = octave_value (chm, 1);
 	}
     }
 
   return retval;
 }
 
-void
-octave_matrix::print (ostream& os, bool pr_as_read_syntax) const
-{
-  print_raw (os, pr_as_read_syntax);
-  newline (os);
-}
-
-void
-octave_matrix::print_raw (ostream& os, bool pr_as_read_syntax) const
-{
-  octave_print_internal (os, matrix, pr_as_read_syntax,
-			 current_print_indent_level ());
-}
-
-bool
-octave_matrix::print_name_tag (ostream& os, const string& name) const
-{
-  bool retval = false;
-
-  int nr = rows ();
-  int nc = columns ();
-
-  indent (os);
-
-  if (nr == 1 && nc == 1 || (nr == 0 || nc == 0))
-    os << name << " = ";
-  else
-    {
-      os << name << " =";
-      newline (os);
-      newline (os);
-      retval = true;
-    }
-
-  return retval;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -34,56 +34,51 @@ Software Foundation, 59 Temple Place - S
 class ostream;
 
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "ov-base.h"
+#include "ov-base-mat.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Real matrix values.
 
 class
-octave_matrix : public octave_base_value
+octave_matrix : public octave_base_matrix<Matrix>
 {
 public:
 
   octave_matrix (void)
-    : octave_base_value () { }
+    : octave_base_matrix<Matrix> () { }
 
   octave_matrix (const Matrix& m)
-    : octave_base_value (), matrix (m) { }
+    : octave_base_matrix<Matrix> (m) { }
 
   octave_matrix (const DiagMatrix& d)
-    : octave_base_value (), matrix (d) { }
+    : octave_base_matrix<Matrix> (d) { }
 
   octave_matrix (const RowVector& v, int pcv = -1);
 
   octave_matrix (const ColumnVector& v, int pcv = -1);
 
   octave_matrix (const octave_matrix& m)
-    : octave_base_value (), matrix (m.matrix) { }
+    : octave_base_matrix<Matrix> (m) { }
 
   ~octave_matrix (void) { }
 
   octave_value *clone (void) { return new octave_matrix (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx);
 
   void assign (const octave_value_list& idx, const Matrix& rhs);
 
   void assign_struct_elt (assign_op, const string& elt_nm,
 			  const octave_value& rhs);
@@ -97,31 +92,16 @@ public:
   octave_value
   do_struct_elt_index_op (const string& nm, const octave_value_list& idx,
 			  bool silent);
 
   octave_value do_struct_elt_index_op (const string& nm, bool silent);
 
   octave_lvalue struct_elt_ref (octave_value *parent, const string& nm);
 
-  int rows (void) const { return matrix.rows (); }
-  int columns (void) const { return matrix.columns (); }
-
-  int length (void) const
-  {
-    int r = rows ();
-    int c = columns ();
-
-    return r > c ? r : c;
-  }
-
-  bool is_defined (void) const { return true; }
-
-  bool is_constant (void) const { return true; }
-
   bool is_real_matrix (void) const { return true; }
 
   octave_value all (void) const { return matrix.all (); }
   octave_value any (void) const { return matrix.any (); }
 
   bool is_real_type (void) const { return true; }
 
   bool is_matrix_type (void) const { return true; }
@@ -147,42 +127,21 @@ public:
     { return matrix; }
 
   void increment (void) { matrix += 1.0; }
 
   void decrement (void) { matrix -= 1.0; }
 
   octave_value convert_to_str (void) const;
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
-
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
-
-  bool print_name_tag (ostream& os, const string& name) const;
-
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
-  Matrix matrix;
-
-  static octave_allocator allocator;
+  DECLARE_OCTAVE_ALLOCATOR
 
-  // Type id of matrix objects, set by register_type ().
-  static int t_id;
-
-  // Type name of matrix objects, defined in ov-re-mat.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -35,24 +35,19 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "pr-output.h"
 #include "xdiv.h"
 #include "xpow.h"
 
-octave_allocator
-octave_scalar::allocator (sizeof (octave_scalar));
+DEFINE_OCTAVE_ALLOCATOR (octave_scalar);
 
-int
-octave_scalar::t_id (-1);
-
-const string
-octave_scalar::t_name ("scalar");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_scalar, "scalar");
 
 static inline bool
 valid_scalar_indices (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
     if (! args(i).valid_as_scalar_index ())
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -62,22 +62,16 @@ public:
 
   octave_scalar (const octave_scalar& s)
     : octave_base_value (), scalar (s.scalar) { }
 
   ~octave_scalar (void) { }
 
   octave_value *clone (void) { return new octave_scalar (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_value do_index_op (const octave_value_list& idx);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int rows (void) const { return 1; }
   int columns (void) const { return 1; }
 
   int length (void) const { return 1; }
@@ -122,38 +116,24 @@ public:
   octave_value convert_to_str (void) const;
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   // The value of this scalar.
   double scalar;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
-  // Type id of scalar objects, set by register_type().
-  static int t_id;
-
-  // Type name of scalar objects, defined in ov-scalar.cc.
-  static const string t_name;
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -35,21 +35,19 @@ Software Foundation, 59 Temple Place - S
 
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-re-mat.h"
 #include "ov-str-mat.h"
 #include "gripes.h"
 #include "pr-output.h"
 
-int
-octave_char_matrix_str::t_id (-1);
+DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix_str);
 
-const string
-octave_char_matrix_str::t_name ("string");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_str, "string");
 
 static octave_value *
 default_numeric_conversion_function (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_char_matrix_str&);
 
   Matrix m = v.matrix_value ();
 
@@ -193,47 +191,19 @@ octave_char_matrix_str::all_strings (voi
 
 string
 octave_char_matrix_str::string_value (void) const
 {
   return matrix.row_as_string (0);  // XXX FIXME??? XXX
 }
 
 void
-octave_char_matrix_str::print (ostream& os, bool pr_as_read_syntax) const
-{
-  // indent (os);
-  print_raw (os, pr_as_read_syntax);
-  newline (os);
-}
-
-void
 octave_char_matrix_str::print_raw (ostream& os, bool pr_as_read_syntax) const
 {
-  octave_print_internal (os, matrix, pr_as_read_syntax, true,
-			 current_print_indent_level ());
-}
-
-bool
-octave_char_matrix_str::print_name_tag (ostream& os, const string& name) const
-{
-  bool retval = false;
-
-  indent (os);
-
-  if (rows () <= 1)
-    os << name << " = ";
-  else
-    {
-      os << name << " =";
-      newline (os);
-      newline (os);
-      retval = true;
-    }
-
-  return retval;
+  octave_print_internal (os, matrix, pr_as_read_syntax,
+			 current_print_indent_level (), true);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -98,38 +98,25 @@ public:
   bool valid_as_zero_index (void) const;
 
   Matrix matrix_value (bool = false) const;
 
   string_vector all_strings (void) const;
 
   string string_value (void) const;
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  bool print_as_scalar (void) const { return (rows () <= 1); }
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
-
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
-  // Type id of char_matrix_str objects, set by register_type().
-  static int t_id;
+  DECLARE_OCTAVE_ALLOCATOR
 
-  // Type name of char_matrix_strXX objects, defined in ov-str-mat.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -31,24 +31,19 @@ Software Foundation, 59 Temple Place - S
 #include <iostream.h>
 
 #include "error.h"
 #include "oct-lvalue.h"
 #include "ov-struct.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
-octave_allocator
-octave_struct::allocator (sizeof (octave_struct));
+DEFINE_OCTAVE_ALLOCATOR(octave_struct);
 
-int
-octave_struct::t_id (-1);
-
-const string
-octave_struct::t_name ("struct");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_struct, "struct");
 
 octave_value
 octave_struct::do_struct_elt_index_op (const string& nm,
 				       const octave_value_list& idx,
 				       bool silent)
 {
   // XXX DO_ME XXX
 }
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -62,22 +62,16 @@ public:
 
   octave_struct (const octave_struct& s)
     : octave_base_value (), map (s.map) { }
 
   ~octave_struct (void) { }
 
   octave_value *clone (void) { return new octave_struct (*this); }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_value
   do_struct_elt_index_op (const string& nm, const octave_value_list& idx,
 			  bool silent);
 
   octave_value do_struct_elt_index_op (const string& nm, bool silent);
 
   octave_lvalue struct_elt_ref (octave_value *parent, const string& nm);
 
@@ -90,38 +84,24 @@ public:
   Octave_map map_value (void) const { return map; }
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (ostream& os, const string& name) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   // The associative array used to manage the structure data.
   Octave_map map;
 
-  // For custom memory management.
-  static octave_allocator allocator;
+  DECLARE_OCTAVE_ALLOCATOR
 
-  // Type id of struct objects, set by register_type().
-  static int t_id;
-
-  // Type name of struct objects, defined in ov-struct.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -57,24 +57,20 @@ static bool Vdefine_all_return_values;
 static int Vmax_recursion_depth;
 
 // If TRUE, the last computed value is returned from functions that
 // don't actually define any return variables.
 static bool Vreturn_last_computed_value;
 
 // User defined functions.
 
-octave_allocator
-octave_user_function::allocator (sizeof (octave_user_function));
+DEFINE_OCTAVE_ALLOCATOR (octave_user_function);
 
-int
-octave_user_function::t_id (-1);
-
-const string
-octave_user_function::t_name ("user-defined function");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
+				     "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
   (tree_parameter_list *pl, tree_parameter_list *rl,
    tree_statement_list *cl, symbol_table *st)
   : octave_function (string (), string ()),
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -54,22 +54,16 @@ public:
 
   octave_user_function (tree_parameter_list *pl = 0,
 			tree_parameter_list *rl = 0,
 			tree_statement_list *cl = 0,
 			symbol_table *st = 0);
 
   ~octave_user_function (void);
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   octave_function *function_value (bool) { return this; }
 
   octave_user_function *define_param_list (tree_parameter_list *t);
 
   octave_user_function *define_ret_list (tree_parameter_list *t);
 
   void stash_fcn_file_name (void);
 
@@ -124,25 +118,16 @@ public:
   tree_parameter_list *parameter_list (void) { return param_list; }
 
   tree_parameter_list *return_list (void) { return ret_list; }
 
   tree_statement_list *body (void) { return cmd_list; }
 
   void accept (tree_walker& tw);
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
   octave_user_function (void);
 
   octave_user_function (const octave_user_function& m);
 
   // List of arguments for this function.  These are local variables.
   tree_parameter_list *param_list;
@@ -201,33 +186,28 @@ private:
   symbol_record *argn_sr;
 
   // The symbol record for nargin in the local symbol table.
   symbol_record *nargin_sr;
 
   // The symbol record for nargout in the local symbol table.
   symbol_record *nargout_sr;
 
-  // For custom memory management.
-  static octave_allocator allocator;
-
-  // Type id of list objects, set by register_type().
-  static int t_id;
-
-  // Type name of list objects, defined in ov-list.cc.
-  static const string t_name;
-
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
   void install_automatic_vars (void);
 
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
 			    int nargout);
+
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-va-args.cc b/src/ov-va-args.cc
--- a/src/ov-va-args.cc
+++ b/src/ov-va-args.cc
@@ -29,19 +29,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <iostream.h>
 
 #include "error.h"
 #include "pr-output.h"
 #include "ov-va-args.h"
 
-int octave_all_va_args::t_id = -1;
-
-const string octave_all_va_args::t_name ("va-arg");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_all_va_args, "va-arg");
 
 void
 octave_all_va_args::print (ostream& os, bool) const
 {
   indent (os);
   print (os);
 }
 
diff --git a/src/ov-va-args.h b/src/ov-va-args.h
--- a/src/ov-va-args.h
+++ b/src/ov-va-args.h
@@ -61,32 +61,19 @@ public:
   bool is_defined (void) const { return true; }
 
   bool is_all_va_args (void) const { return true; }
 
   void print (ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
 
-  int type_id (void) const { return t_id; }
-
-  string type_name (void) const { return t_name; }
-
-  static int static_type_id (void) { return t_id; }
-
-  static void register_type (void)
-    { t_id = octave_value_typeinfo::register_type (t_name); }
-
 private:
 
-  // Type id of all_va_arg objects, set by register_type().
-  static int t_id;
-
-  // Type name of all_va_arg objects, defined in ov-va-args.cc.
-  static const string t_name;
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -59,18 +59,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 // We are likely to have a lot of octave_value objects to allocate, so
 // make the grow_size large.
-octave_allocator
-octave_value::allocator (sizeof (octave_value), 1024);
+DEFINE_OCTAVE_ALLOCATOR2(octave_value, 1024);
 
 // If TRUE, allow assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 bool Vdo_fortran_indexing;
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -201,22 +201,16 @@ public:
       if (rep->count > 1)
 	{
 	  --rep->count;
 	  rep = rep->clone ();
 	  rep->count = 1;
 	}
     }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
-
   // Simple assignment.
 
   octave_value& operator = (const octave_value& a)
     {
       if (rep != a.rep)
 	{
 	  if (--rep->count == 0)
 	    delete rep;
@@ -500,18 +494,16 @@ protected:
   void newline (ostream& os) const;
 
   void indent (ostream& os) const;
 
   void reset (void) const;
 
 private:
 
-  static octave_allocator allocator;
-
   union
     {
       octave_value *rep;      // The real representation.
       int count;              // A reference count.
     };
 
   bool convert_and_assign (assign_op, const octave_value_list& idx,
 			   const octave_value& rhs);
@@ -527,16 +519,18 @@ private:
   static bool beginning_of_line;
 
   assign_op unary_op_to_assign_op (unary_op op);
 
   binary_op op_eq_to_binary_op (assign_op op);
 
   void simple_assign (assign_op orig_op, const octave_value_list& idx,
 		      const octave_value& rhs);
+
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #define OV_UNOP_FN(name) \
   inline octave_value \
   name (const octave_value& a) \
   { \
     return do_unary_op (octave_value::name, a); \
   }
@@ -602,16 +596,34 @@ OV_BINOP_FN (el_mul)
 OV_BINOP_FN (el_div)
 OV_BINOP_FN (el_pow)
 OV_BINOP_FN (el_ldiv)
 OV_BINOP_FN (el_and)
 OV_BINOP_FN (el_or)
 
 OV_BINOP_FN (struct_ref)
 
+// T_ID is the type id of struct objects, set by register_type().
+// T_NAME is the type name of struct objects.
+#define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
+  public: \
+    int type_id (void) const { return t_id; } \
+    string type_name (void) const { return t_name; } \
+    static int static_type_id (void) { return t_id; } \
+    static void register_type (void) \
+      { t_id = octave_value_typeinfo::register_type (t_name); } \
+ \
+  private: \
+    static int t_id; \
+    static const string t_name;
+
+#define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n) \
+  int t::t_id (-1); \
+  const string t::t_name (n)
+
 // If TRUE, allow assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 extern bool Vdo_fortran_indexing;
 
 // Should we allow things like:
diff --git a/src/version.h b/src/version.h
--- a/src/version.h
+++ b/src/version.h
@@ -18,31 +18,39 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_version_h)
 #define octave_version_h 1
 
-#define OCTAVE_VERSION "2.1.9"
+#define OCTAVE_VERSION "2.1.10"
 
 #define OCTAVE_COPYRIGHT \
   "Copyright (C) 1996, 1997, 1998 John W. Eaton."
 
 #define OCTAVE_NAME_AND_VERSION \
   "Octave, version " OCTAVE_VERSION " (" TARGET_HOST_TYPE ")"
 
 #define OCTAVE_NAME_VERSION_AND_COPYRIGHT \
   OCTAVE_NAME_AND_VERSION ".\n" OCTAVE_COPYRIGHT "\n\
 This is free software with ABSOLUTELY NO WARRANTY."
 
 #define OCTAVE_STARTUP_MESSAGE \
   OCTAVE_NAME_VERSION_AND_COPYRIGHT "\n\
-For details, type `warranty'."
+For details, type `warranty'.\n\
+\n\
+*** This is a development version of Octave.  Development releases\n\
+*** are provided for people who want to help test, debug, and improve\n\
+*** Octave.\n\
+***\n\
+*** If you want a stable, well-tested version of Octave, you should be\n\
+*** using one of the stable releases (when this development release\n\
+*** was made, the latest stable version was 2.0.13)."
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
