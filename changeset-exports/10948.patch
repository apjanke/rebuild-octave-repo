# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1283888373 -7200
#      Tue Sep 07 21:39:33 2010 +0200
# Node ID 6b50fd2d4ca64f76d57bccc272848b9aea6be630
# Parent  dc74ce93cfc4496b2ada65efe4a71656fb1063a4
Don't create __plotyy_axes__ properties in plotyy if they exist (Bug #30977)

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,13 +1,18 @@
+2010-09-07  David Bateman  <dbateman@free.fr>
+
+	* plot/plotyy.m: Don't add the __plotyy_axes__ property to the
+	axes handles if iit already exists.
+
 2010-09-06  Petr Mikulik <mikulik@physics.muni.cz>
 
 	* geometry/griddata.m: Allow x, y to be vectors, and z a matrix.
 
-2010-07-07  David Bateman  <dbateman@free.fr>
+2010-09-03  David Bateman  <dbateman@free.fr>
 
 	* geometry/delaunay.m: Allow the delaunay function to treat
 	matrices of the same size for compatibility.
 
 2010-09-03  Ben Abbott <bpabbott@mac.com>
 
 	* image/image.m: Matlab compatible axis limits, add demo.
 
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -1348,17 +1348,17 @@ function __go_draw_axes__ (h, plot_strea
       if (nd == 3)
         fputs (plot_stream, "set border 4095;\n");
       else
         fputs (plot_stream, "set border 431;\n");
       endif
     else
       if (nd == 3)
         fputs (plot_stream, "set border 895;\n");
-      else
+      elseif (! isempty (axis_obj.ytick))
         if (strcmpi (axis_obj.yaxislocation, "right"))
           fprintf (plot_stream, "unset ytics; set y2tics %s nomirror\n",
                    axis_obj.tickdir);
           if (strcmpi (axis_obj.xaxislocation, "top"))
             fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
                      axis_obj.tickdir);
             fputs (plot_stream, "set border 12;\n");
           else
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -35,17 +35,18 @@ function [h, varargin, narg] = __plt_get
 
   ## Figure handles are integers, but object handles are non integer,
   ## therefore ignore integer scalars.
   if (nargin > 1 && length (varargin) > 0 && isnumeric (varargin{1}) 
       && numel (varargin{1}) == 1 && ishandle (varargin{1}(1)) 
       && varargin{1}(1) != 0 && ! isfigure (varargin{1}(1)))
     tmp = varargin{1};
     obj = get (tmp);
-    if (strcmp (obj.type, "axes") || strcmp (obj.type, "hggroup"))
+    if ((strcmp (obj.type, "axes") && ! strcmp (obj.tag, "legend")) 
+        || strcmp (obj.type, "hggroup"))
       h = ancestor (tmp, "axes");
       varargin(1) = [];
       if (isempty (varargin))
         varargin = {};
       endif
     else
       error ("%s: expecting first argument to be axes handle", caller);
     endif
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -1,10 +1,9 @@
-## Copyright (C) 2001, 2006, 2007, 2008, 2009 Laurent Mazet
-## Copyright (C) 2006 John W. Eaton
+## Copyright (C) 2010 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,16 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} legend (@var{str1}, @var{str2}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{matstr})
 ## @deftypefnx {Function File} {} legend (@var{cell})
 ## @deftypefnx {Function File} {} legend (@dots{}, "location", @var{pos})
+## @deftypefnx {Function File} {} legend (@dots{}, "orientation", @var{orient})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend ("@var{option}")
 ##
 ## Display a legend for the axes with handle @var{hax}, or the current axes,
 ## using the specified strings as labels.  Legend entries may be specified 
 ## as individual character string arguments, a character array, or a cell
@@ -65,16 +65,20 @@
 ##   left bottom
 ##
 ## @item 
 ##
 ## @item @tab outside @tab
 ##   can be appended to any location string
 ## @end multitable
 ##
+## The optional parameter @var{orient} determines if the key elements
+## are placed vertically or horizontally. The allowed values are "vertical"
+## or "horizontal" with the default being "vertical".
+##
 ## The following customizations are available using @var{option}:
 ##
 ## @table @asis
 ## @item "show"
 ##   Show legend on the plot
 ##
 ## @item "hide"
 ## @itemx "off"
@@ -89,156 +93,679 @@
 ## @item "left"
 ##   Place text to the left of the keys
 ##
 ## @item "right"
 ##   Place text to the right of the keys
 ## @end table
 ## @end deftypefn
 
-function legend (varargin)
+function [hlegend2, hobjects2, hplot2, text_strings2] = legend (varargin)
 
-  [ca, varargin, nargin] = __plt_get_axis_arg__ ("legend", varargin{:});
-  nargs = nargin;
+  [ca, varargin, nargs] = __plt_get_axis_arg__ (true, "legend", varargin{:});
+  if (isnan (ca))
+    fig = get (0, "currentfigure");
+    if (isempty (fig))
+      ca = gca ();
+      fig = get (ca, "parent");
+    else
+      ca = get (fig, "children");
+      ca ( ! strcmp (get (get (fig, "children"), "type"), "axes")) = [];
+      ca_pos = get (get (fig, "currentaxes"), "position");
+      ca_outpos = get (get (fig, "currentaxes"), "outerposition");
+      for i = numel (ca) : -1 : 1
+        if (! all (ca_pos, get (ca(i), "position") )
+            || ! all (ca_outpos, get (ca(i), "outerposition")))
+          ca(i) = [];
+        endif
+      endfor
+    endif
+  else
+    fig = get (ca, "parent");
+  endif
 
   if (all (ishandle (varargin{1})))
     kids = flipud (varargin{1}(:));
     varargin(1) = [];
     nargs = numel (varargin);
   else
-    kids = get (ca, "children");
+    kids = get (fig, "children");
+    kids (strcmp (get (kids, "tag"), "legend")) = [];
+    if (isscalar (kids))
+      kids = get(kids, "children")(:);
+    else
+      kids = [get(kids, "children"){:}](:);
+    endif
   endif
   nkids = numel (kids);
 
+  position = "northeast";
+  orientation = "vertical";
   if (nargs > 0)
     pos = varargin{nargs};
     if (isnumeric (pos) && isscalar (pos) && round (pos) == pos)
       if (pos >= -1 && pos <= 4)
-        set (ca, "keypos", pos);
+        position = {"northeastoutside", "best", "northeast",
+                    "northwest", "southwest", "southeast"} (pos + 2);
         nargs--;
       else
         error ("legend: invalid position specified");
       endif
     endif
   endif
   
-  if (nargs > 1)
+  while (nargs > 1)
     pos = varargin{nargs-1};
     str = varargin{nargs};
     if (strcmpi (pos, "location")  && ischar (str))
-      set (ca, "keypos", str);
+      position = lower (str);
+      nargs -= 2;
+    elseif (strcmpi (pos, "orientation")  && ischar (str))
+      orientation = lower (str);
       nargs -= 2;
+    else
+      break;
     endif
+  endwhile
+
+  ## Validate the orientation 
+  switch (orientation)
+    case {"vertical", "horizontal"}
+    otherwise
+      error ("legend: unrecognized legend orientation");
+  endswitch
+
+  ## Validate the position type is valid
+  outside = false;
+  inout = findstr (position, "outside");
+  if (! isempty (inout))
+    outside = true;
+    position = position(1:inout-1);
+  else
+    outside = false;
   endif
 
-  k = 1;
-  turn_on_legend = false;
+  switch (position)
+    case {"north", "south", "east", "west", "northeast", "northwest", ...
+          "southeast", "southwest"}
+    case "best"
+      warning ("legend: 'Best' not yet implemented for location specifier\n");
+      position = "northeast";
+    otherwise
+      error ("legend: unrecognized legend position");
+  endswitch
+
+  show = "create";
+  textpos = "default";
+  reverse = false;
+  box = "default";
+
+  hlegend = [];
+  fkids = get (fig, "children");
+  for i = 1 : numel(fkids)
+    if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes") 
+        && (strcmp (get (fkids (i), "tag"), "legend")))
+      udata = get (fkids (i), "userdata");
+      if (! isempty (intersect (udata.handle, ca)))
+        hlegend = fkids (i);
+        break;
+      endif
+    endif
+  endfor
 
   if (nargs == 1)
     arg = varargin{1};
     if (ischar (arg))
       if (rows (arg) == 1)
         str = tolower (deblank (arg));
         switch (str)
           case {"off", "hide"}
-            set (ca, "key", "off");
+            show = "off";
             nargs--;
           case "show"
-            set (ca, "key", "on");
+            show = "on";
             nargs--;
           case "toggle"
-            val = get (ca, "key");
-            if (strcmpi (val, "on"))
-              set (ca, "key", "off");
+            if (isempty (hlegend) || strcmp (get (hlegend, "visible"), "off"))
+              show = "on";
             else
-              set (ca, "key", "on");
+              show = "off";
             endif
             nargs--;
           case "boxon"
-            set (ca, "key", "on", "keybox", "on");
+            box = "on";
             nargs--;
           case "boxoff"
-            set (ca, "keybox", "off");
+            box = "off";
             nargs--;
           case "left"
-            set (ca, "keyreverse", "off")
+            textpos = "left";
+            reverse = false;
             nargs--;
           case "right"
-            set (ca, "keyreverse", "on")
+            textpos = "right";
+            reverse = true;
             nargs--;
           otherwise
         endswitch
       else
         varargin = cellstr (arg);
         nargs = numel (varargin);
       endif
     elseif (iscellstr (arg))
       varargin = arg;
       nargs = numel (varargin);
     else
       error ("legend: expecting argument to be a character string");
     endif
   endif
 
-  if (nargs > 0)
-    have_data = false;
-    for k = 1:nkids
-      typ = get (kids(k), "type");
-      if (strcmp (typ, "line") || strcmp (typ, "surface")
-          || strcmp (typ, "patch") || strcmp (typ, "hggroup"))
-        have_data = true;
-        break;
+  if (strcmp (show, "off"))
+    if (! isempty (hlegend))
+      set (hlegend, "visible", "off");
+      set (get (hlegend, "children"), "visible", "off");
+      hlegend = [];
+    endif
+    hobjects = [];
+    hplots  = [];
+    text_strings = {};
+  elseif (strcmp (show, "on"))
+    if (! isempty (hlegend))
+      set (hlegend, "visible", "on");
+      set (get (hlegend, "children"), "visible", "on");
+    else
+      hobjects = [];
+      hplots  = [];
+      text_strings = {};
+    endif
+  elseif (strcmp (box, "on"))
+    if (! isempty (hlegend))
+      set (hlegend, "visible", "on", "box", "on");
+    endif
+  elseif (strcmp (box, "off"))
+    if (! isempty (hlegend))
+      set (hlegend, "box", "off", "visible", "off");
+    endif
+  else
+    hobjects = [];
+    hplots  = [];
+    text_strings = {};
+
+    if (nargs > 0)
+      have_data = false;
+      for k = 1:nkids
+        typ = get (kids(k), "type");
+        if (strcmp (typ, "line") || strcmp (typ, "surface")
+            || strcmp (typ, "patch") || strcmp (typ, "hggroup"))
+          have_data = true;
+          break;
+        endif
+      endfor
+
+      if (! have_data)
+        warning ("legend: plot data is empty; setting key labels has no effect");
+      endif
+    endif
+
+    if (strcmp (textpos, "default"))
+      warned = false;
+      k = nkids;
+      for i = 1 : nargs
+        arg = varargin{i};
+        if (ischar (arg))
+          typ = get (kids(k), "type");
+          while (k > 0
+                 && ! (strcmp (typ, "line") || strcmp (typ, "surface")
+                       || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
+            typ = get (kids(--k), "type");
+          endwhile
+          if (k > 0)
+            if (strcmp (get (kids(k), "type"), "hggroup"))
+              hgkids = get (kids(k), "children");
+              for j = 1 : length (hgkids)
+                hgobj = get (hgkids (j));
+                if (isfield (hgobj, "displayname"))
+                  set (hgkids(j), "displayname", arg);
+                  hplots = [hplots, hgkids(j)];
+                  text_strings = {text_strings{:}, arg};
+                  break;
+                endif
+              endfor
+            else
+              set (kids(k), "displayname", arg);
+              hplots = [hplots, kids(k)];
+              text_strings = {text_strings{:}, arg};
+            endif
+
+            if (--k == 0)
+              break;
+            endif
+          elseif (! warned)
+            warned = true;
+            warning ("legend: ignoring extra labels");
+          endif
+        else
+          error ("legend: expecting argument to be a character string");
+        endif
+      endfor
+    else
+      k = nkids;
+      while (k > 0)
+        typ = get (kids(k), "type");
+        while (k > 0
+               && ! (strcmp (typ, "line") || strcmp (typ, "surface")
+                     || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
+          typ = get (kids(--k), "type");
+        endwhile
+        if (k > 0)
+          if (strcmp (get (kids(k), "type"), "hggroup"))
+            hgkids = get (kids(k), "children");
+            for j = 1 : length (hgkids)
+              hgobj = get (hgkids (j));
+              if (isfield (hgobj, "displayname") 
+                  && ! isempty (hgobj.displayname))
+                hplots = [hplots, hgkids(j)];
+                text_strings = {text_strings{:}, hbobj.displayname};
+                break;
+              endif
+            endfor
+          else
+            if (! isempty (get (kids (k), "displayname")))
+              hplots = [hplots, kids(k)];
+              text_strings = {text_strings{:}, get(kids (k), "displayname")};
+            endif
+          endif
+          if (--k == 0)
+            break;
+          endif
+        endif
+      endwhile
+    endif
+
+    if (isempty (hplots))
+      if (! isempty (hlegend))
+        fkids = get (fig, "children");
+        delete (fkids (fkids == hlegend));
+        hlegend = [];
+        hobjects = [];
+        hplots  = [];
+        text_strings = {};
+      endif
+    else
+      ## Delete the old legend if it exists
+      if (! isempty (hlegend))
+        fkids = get (fig, "children");
+        delete (fkids (fkids == hlegend));
       endif
-    endfor
-    if (! have_data)
-      warning ("legend: plot data is empty; setting key labels has no effect");
+      
+      ## Force the figure to be drawn here, so that the figure position
+      ## is updated correctly before reading it
+      drawnow ();
+
+      ## Get axis size and fontsize in points.  
+      ## Rely on listener to handle coversion.
+      units = get (ca(1), "units");
+      fontunits = get (ca(1), "fontunits");
+      unwind_protect
+        set (ca(1), "units", "points");
+        set (ca(1), "fontunits", "points");
+        ca_pos = get (ca(1), "position");
+        ca_outpos = get (ca(1), "outerposition");
+        ca_fontsize = get (ca(1), "fontsize");
+      unwind_protect_cleanup
+        set (ca(1), "units", units);
+        set (ca(1), "fontunits", fontunits);
+      end_unwind_protect
+
+      ## Padding between legend entries horizontally and vertically
+      xpadding = 1.2;
+      ypadding = 1.2;
+
+      ## Length of line segments in the legend in points
+      linelength = 15;
+
+      ## Create the axis first
+      ## FIXME hlegend should inherit properties from "ca"
+      curaxes = get (fig, "currentaxes");
+      unwind_protect
+        hlegend = axes ("tag", "legend", "userdata", struct ("handle", ca),
+                        "box", "off", "outerposition", [0, 0, 0, 0],
+                        "xtick", [], "ytick", [], "xticklabel", "",
+                        "yticklabel", "", "zticklabel", "", 
+                        "xlim", [0, 1], "ylim", [0, 1], "visible", "off",
+                        "activepositionproperty", "position");
+
+        ## Add text label to the axis first, checking their extents
+        nentries = numel (hplots);
+        texthandle = [];
+        maxwidth = 0;
+        maxheight = 0;
+        for k = 1 : nentries
+          if (reverse)
+            texthandle = [texthandle, text(0, 0, text_strings {k}, 
+                                           "horizontalalignment", "left")];
+          else
+            texthandle = [texthandle, text(0, 0, text_strings {k},
+                                           "horizontalalignment", "right")];
+          endif
+          units = get (texthandle (end), "units");
+          unwind_protect
+            set (texthandle (end), "units", "points");
+            extents = get (texthandle (end), "extent");
+            ## FIXME fudge for gnuplot as the text extents are calculated from
+            ## the FreeType text render rather than from gnuplot itself. Your
+            ## luck will vary depending on the terminals that are used.
+            if (strcmp (get (fig, "__backend__"), "gnuplot"))
+              extents = [1,1,1.1,1] .* extents;
+              linelength = 20;
+            endif
+            maxwidth = max (maxwidth, extents (3));
+            maxheight = max (maxheight, extents (4));
+          unwind_protect_cleanup
+            set (texthandle (end), "units", units);
+          end_unwind_protect
+        endfor
+
+        num1 = nentries;
+        if (strcmp (orientation, "vertical"))
+          height = nentries * ypadding * maxheight;
+          if (outside)
+            if (height > ca_pos (4))
+              ## Avoid shrinking the height of the axis to zero if outside
+              num1 = ca_pos(4) / maxheight / ypadding / 2;
+            endif
+          else
+            if (height > 0.9 * ca_pos (4))
+              num1 = 0.9 * ca_pos(4) / maxheight / ypadding;
+            endif
+          endif
+        else
+          width = nentries * ypadding * maxwidth;
+          if (outside)
+            if (width > ca_pos (3))
+              ## Avoid shrinking the width of the axis to zero if outside
+              num1 = ca_pos(3) / maxwidth / ypadding / 2;
+            endif
+          else
+            if (width > 0.9 * ca_pos (3))
+              num1 = 0.9 * ca_pos(3) / maxwidth / ypadding;
+            endif
+          endif
+        endif
+        num2 = ceil (nentries / num1);
+
+        xstep = xpadding * (maxwidth + linelength);
+        xpad = (xpadding - 1) * (maxwidth + linelength);
+        if (reverse)
+          xoffset = xpad / 3;
+          txoffset = 2 * xpad / 3 + linelength;
+        else
+          xoffset = 2 * xpad / 3 + maxwidth;
+          txoffset = xpad / 3 + maxwidth;
+        endif
+        ystep = ypadding * maxheight;
+        ypad = (ypadding - 1) * maxheight;
+        yoffset = ystep / 2;
+
+        ## Place the legend in the desired position
+        if (strcmp (orientation, "vertical"))
+          lpos = [0, 0, num2 * xstep, num1 * ystep];
+        else
+          lpos = [0, 0, num1 * xstep, num2 * ystep];
+        endif
+        switch(position)
+          case "north"
+            if (outside)
+              lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ...
+                      ca_outpos(2) + ca_outpos(4) - lpos(4), lpos(3), lpos(4)];
+
+              new_pos = [ca_pos(1), ca_pos(2), ca_pos(3), ca_pos(4) - lpos(4)];
+              new_outpos = [ca_outpos(1), ca_outpos(2), ca_outpos(3), ...
+                            ca_outpos(4) - lpos(4)];
+            else
+              ca_pos
+              lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ...
+                      ca_pos(2) + ca_pos(4) - lpos(4) - ypad, lpos(3), lpos(4)];
+            endif
+          case "south"
+            if (outside)
+              lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ca_outpos(2), ...
+                      lpos(3), lpos(4)];
+              new_pos = [ca_pos(1), ca_pos(2) + lpos(4), ca_pos(3), ...
+                         ca_pos(4) - lpos(4)];
+              new_outpos = [ca_outpos(1), ca_outpos(2) + lpos(4), ...
+                            ca_outpos(3), ca_outpos(4) - lpos(4)];
+            else
+              lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ...
+                      ca_pos(2) + ypad, lpos(3), lpos(4)];
+            endif
+          case "east"
+            if (outside)
+              lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3), ...
+                      ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, lpos(3), lpos(4)];
+              new_pos = [ca_pos(1), ca_pos(2), ca_pos(3) - lpos(3), ca_pos(4)];
+              new_outpos = [ca_outpos(1), ca_outpos(2), ...
+                            ca_outpos(3) - lpos(3), ca_outpos(4)];
+            else
+              lpos = [ca_pos(1) + ca_pos(3) - lpos(3) - ypad, ...
+                      ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, lpos(3), lpos(4)];
+            endif
+          case "west"
+            if (outside)
+              lpos = [ca_outpos(1), ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, ...
+                      lpos(3), lpos(4)];
+              new_pos = [ca_pos(1) + lpos(3), ca_pos(2), ...
+                         ca_pos(3) - lpos(3), ca_pos(4)];
+              new_outpos = [ca_outpos(1) + lpos(3), ca_outpos(2), ...
+                            ca_outpos(3) - lpos(3), ca_outpos(4)];
+            else
+              lpos = [ca_pos(1) +  ypad, ...
+                      ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, lpos(3), lpos(4)];
+            endif
+          case "northeast"
+            if (outside)
+              lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3), ...
+                      ca_outpos(2) + ca_outpos(4) - lpos(4), lpos(3), lpos(4)];
+              new_pos = [ca_pos(1), ca_pos(2), ca_pos(3) - lpos(3), ...
+                         ca_pos(4) - lpos(4)];
+              new_outpos = [ca_outpos(1), ca_outpos(2), ...
+                            ca_outpos(3) - lpos(3), ca_outpos(4) - lpos(4)];
+            else
+              lpos = [ca_pos(1) + ca_pos(3) - lpos(3) - ypad, ...
+                      ca_pos(2) + ca_pos(4) - lpos(4) - ypad, lpos(3), lpos(4)];
+            endif
+          case "northwest"
+            if (outside)
+              lpos = [ca_outpos(1), ca_outpos(2) + ca_outpos(4) - lpos(4), ...
+                      lpos(3), lpos(4)];
+              new_pos = [ca_pos(1) + lpos(3), ca_pos(2), ...
+                         ca_pos(3) - lpos(3), ca_pos(4) - lpos(4)];
+              new_outpos = [ca_outpos(1) + lpos(3), ca_outpos(2), ...
+                            ca_outpos(3) - lpos(3), ca_outpos(4) - lpos(4)];
+            else
+              lpos = [ca_pos(1) + ypad, ...
+                      ca_pos(2) + ca_pos(4) - lpos(4) - ypad, lpos(3), lpos(4)];
+            endif
+          case "southeast"
+            if (outside)
+              lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3), ca_outpos(2), 
+                      lpos(3), lpos(4)];
+              new_pos = [ca_pos(1), ca_pos(2) + lpos(4), ...
+                         ca_pos(3) - lpos(3), ca_pos(4) - lpos(4)];
+              new_outpos = [ca_outpos(1), ca_outpos(2) + lpos(4), ...
+                            ca_outpos(3) - lpos(3), ca_outpos(4) - lpos(4)];
+            else
+              lpos = [ca_pos(1) + ca_pos(3) - lpos(3) - ypad, ...
+                      ca_pos(2) + ypad, lpos(3), lpos(4)];
+            endif
+          case "southwest"
+            if (outside)
+              lpos = [ca_outpos(1), ca_outpos(2), 0, lpos(3), lpos(4)];
+              new_pos = [ca_pos(1) +lpos(3), ca_pos(2) + lpos(4), ...
+                         ca_pos(3) - lpos(3), ca_pos(4) - lpos(4)];
+              new_outpos = [ca_outpos(1) + lpos(3), ca_outpos(2) + lpos(4), ...
+                            ca_outpos(3) - lpos(3), ca_outpos(4) - lpos(4)];
+            else
+              lpos = [ca_pos(1) + ypad, ca_pos(2) + ypad, lpos(3), lpos(4)];
+            endif
+        endswitch
+
+        units = get (hlegend, "units");
+        unwind_protect
+          set (hlegend, "units", "points");
+          set (hlegend, "position", lpos, "outerposition", lpos);
+        unwind_protect_cleanup
+          set (hlegend, "units", units);
+        end_unwind_protect
+
+        ## Now write the line segments and place the text objects correctly
+        xk = 0;
+        yk = 0;
+        for k = 1 : numel (hplots)
+          hobjects = [hobjects, texthandle (k)];
+          color = get (hplots (k), "color");
+          style = get (hplots (k), "linestyle");
+          if (! strcmp (style, "none"))
+            l1 = line ("xdata", ([xoffset, xoffset + linelength] + xk * xstep) / lpos(3),
+                       "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4), 
+                       "color", color, "linestyle", style);
+            hobjects = [hobjects, l1];
+          endif
+          marker = get (hplots (k), "marker");
+          if (! strcmp (marker, "none"))
+            l1 = line ("xdata", (xoffset + 0.5 * linelength  + xk * xstep) / lpos(3),
+                       "ydata", (lpos(4) - yoffset - yk * ystep) / lpos(4), 
+                       "color", color, "marker", marker,
+	               "markeredgecolor", get (hplots (k), "markeredgecolor"),
+	               "markerfacecolor", get (hplots (k), "markerfacecolor"),
+	               "markersize", get (hplots (k), "markersize"));
+            hobjects = [hobjects, l1];
+          endif
+          set (texthandle (k), "position", [(txoffset + xk * xstep) / lpos(3), ...
+                                            (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
+
+          if (strcmp (orientation, "vertical"))
+            yk++;
+            if (yk > num1)
+              yk = 0;
+              xk++;
+            endif
+          else
+            xk++;
+            if (xk > num1)
+              xk = 0;
+              yk++;
+            endif
+          endif
+        endfor
+
+        ## Add an invisible text object to original axis
+        ## that when it is destroyed will remove the legend
+        t1 = text (0, 0, "", "parent", ca(1), "tag", "legend", 
+                   "handlevisibility", "off", "visible", "off",
+                   "xliminclude", "off", "yliminclude", "off");
+        set (t1, "deletefcn", {@deletelegend1, hlegend});
+
+        ## Resize the axis the legend is attached to if the
+        ## legend is "outside" the plot and create listener to 
+        ## resize axis to original size if the legend is deleted, 
+        ## hidden or shown
+        if (outside)
+          for i = 1 : numel (ca)
+            units = get (ca(i), "units");
+            unwind_protect
+              set (ca(i), "units", "points");
+              set (ca (i), "position", new_pos, "outerposition", new_outpos);
+            unwind_protect_cleanup
+              set (ca(i), "units", units);
+            end_unwind_protect
+          endfor
+
+          set (hlegend, "deletefcn", {@deletelegend2, ca, ...
+                                      ca_pos, ca_outpos, t1});
+          addlistener (hlegend, "visible", {@hideshowlegend, ca, ...
+                                            ca_pos, new_pos, ...
+                                            ca_outpos, new_outpos});
+        else
+          set (hlegend, "deletefcn", {@deletelegend2, ca, [], [], t1});
+        endif
+      unwind_protect_cleanup
+        set (fig, "currentaxes", curaxes);
+      end_unwind_protect
     endif
   endif
 
-  warned = false;
-  k = nkids;
-  for i = 1:nargs
-    arg = varargin{i};
-    if (ischar (arg))
-      typ = get (kids(k), "type");
-      while (k > 1
-             && ! (strcmp (typ, "line") || strcmp (typ, "surface")
-                   || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
-        typ = get (kids(--k), "type");
-      endwhile
-      if (k > 0)
-        if (strcmp (get (kids(k), "type"), "hggroup"))
-          hgkids = get (kids(k), "children");
-          for j = 1 : length (hgkids)
-            hgobj = get (hgkids (j));
-            if (isfield (hgobj, "keylabel"))
-              set (hgkids(j), "keylabel", arg);
-              break;
-            endif
-          endfor
+  if (nargout > 0)
+    hlegend2 = hlegend2;
+    hobjects2 = hobjects;
+    hplot2 = hplots;
+    text_strings2 = text_strings;
+  endif
+
+endfunction
+
+function hideshowlegend (h, d, ca, pos1, pos2, outpos1, outpos2)
+  isvisible = strcmp (get (h, "visible"), "off");
+  if (! isvisible)
+    kids = get (h, "children");
+    for i = 1 : numel (kids)
+      if (! strcmp (get (kids(i), "visible"), "off"))
+        isvisible = true;
+        break;
+      endif
+    endfor
+  endif
+
+  for i = 1 : numel (ca)
+    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
+        strcmp (get (ca(i), "beingdeleted"), "off"))
+      units = get (ca(i), "units");
+      unwind_protect
+        set (ca(i), "units", "points");
+        if (isvisible)
+          set (ca(i), "position", pos2, "outerposition", outpos2);
         else
-          set (kids(k), "keylabel", arg);
-        endif
-        turn_on_legend = true;
-        if (--k == 0)
-          break;
+          set (ca(i), "position", pos1, "outerposition", outpos1);
         endif
-      elseif (! warned)
-        warned = true;
-        warning ("legend: ignoring extra labels");
-      endif
-    else
-      error ("legend: expecting argument to be a character string");
+      unwind_protect_cleanup
+        set (ca(i), "units", units);
+      end_unwind_protect
     endif
   endfor
+endfunction
 
-  if (turn_on_legend)
-    set (ca, "key", "on");
+function deletelegend1 (h, d, ca)
+  if (ishandle (ca) && strcmp (get (ca, "type"), "axes") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
+      strcmp (get (ca, "beingdeleted"), "off"))
+    delete (ca);
   endif
+endfunction
 
+function deletelegend2 (h, d, ca, pos, outpos, t1)
+  for i = 1 : numel (ca)
+    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes") && 
+      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
+        strcmp (get (ca(i), "beingdeleted"), "off"))
+      if (!isempty (pos) && !isempty(outpos))
+        units = get (ca(i), "units");
+        unwind_protect
+          set (ca(i), "units", "points");
+          set (ca(i), "position", pos, "outerposition", outpos, "deletefcn", "");
+        unwind_protect_cleanup
+          set (ca(i), "units", units);
+        end_unwind_protect
+      endif
+      if (i == 1)
+        set (t1, "deletefcn", "");
+        delete (t1);
+      endif
+    endif
+  endfor
 endfunction
 
 %!demo
 %! clf
 %! plot(1:10, 1:10, 1:10, fliplr(1:10));
 %! title("incline is blue and decline is green");
 %! legend({"I'm blue", "I'm green"}, "location", "east")
 
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -190,19 +190,26 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   addlistener (ax(1), "plotboxaspectratiomode", {@update_position, ax(2)});
   addlistener (ax(2), "plotboxaspectratiomode", {@update_position, ax(1)});
 
   ## Tag the plotyy axes, so we can use that information
   ## not to mirror the y axis tick marks
   set (ax, "tag", "plotyy")
 
   ## Store the axes handles for the sister axes.
-  addproperty ("__plotyy_axes__", ax(1), "data", ax);
-  addproperty ("__plotyy_axes__", ax(2), "data", ax);
-
+  try 
+    addproperty ("__plotyy_axes__", ax(1), "data", ax);
+  catch
+    set (ax(1), "__plotyy_axes__", ax);
+  end_try_catch
+  try 
+    addproperty ("__plotyy_axes__", ax(2), "data", ax);
+  catch
+    set (ax(2), "__plotyy_axes__", ax);
+  end_try_catch
 endfunction
 
 %!demo
 %! clf
 %! x = 0:0.1:2*pi; 
 %! y1 = sin (x);
 %! y2 = exp (x - 1);
 %! ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -2547,16 +2547,75 @@ base_graphics_object::values_as_struct (
 }
 
 // ---------------------------------------------------------------------
 
 #include "graphics-props.cc"
 
 // ---------------------------------------------------------------------
 
+octave_value
+root_figure::properties::get_monitorpositions (void) const
+{
+  Matrix sz = screensize.get ().matrix_value ().extract_n (0, 2, 1, 2);
+  return convert_position (monitorpositions.get ().matrix_value (), 
+                           "pixels", get_units (), sz);
+
+}
+
+void 
+root_figure::properties::set_monitorpositions (const octave_value& val)
+{
+  if (! error_state)
+    {
+      Matrix sz = screensize.get ().matrix_value ().extract_n (0, 2, 1, 2);
+      Matrix pos = convert_position (val.matrix_value (), get_units (), "pixels", sz);
+
+      if (monitorpositions.set (octave_value (pos), true))
+        {
+          mark_modified ();
+        }
+    }
+}
+
+octave_value
+root_figure::properties::get_pointerlocation (void) const
+{
+  Matrix sz = screensize.get ().matrix_value ().extract_n (0, 2, 1, 2);
+  Matrix pos = pointerpositions.get ().matrix_value ();
+  pos.resize (1, 4);
+  return convert_position (pos, "pixels", get_units (), sz).extract_n (0, 0, 1, 2);
+}
+
+void 
+root_figure::properties::set_pointerlocation (const octave_value& val)
+{
+  if (! error_state)
+    {
+      Matrix sz = screensize.get ().matrix_value ().extract_n (0, 2, 1, 2);
+      Matrix pos1 = val.matrix_value ();
+      pos1.resize (1, 4);
+      Matrix pos2 = convert_position (pos1, get_units (), "pixels", sz).extract_n (0, 0, 1, 2);
+
+      if (pointerlocation.set (octave_value (pos2), true))
+        {
+          mark_modified ();
+        }
+    }
+}
+
+octave_value
+root_figure::properties::get_screensize (void) const
+{
+  Matrix sz = screensize.get ().matrix_value ().extract_n (0, 2, 1, 2);
+  Matrix sz2 (sz);
+  sz2.resize (1, 4);
+  return convert_position (sz2, "pixels", get_units (), sz).extract_n (0, 0, 1, 2);
+}
+
 void
 root_figure::properties::set_currentfigure (const octave_value& v)
 {
   graphics_handle val (v);
 
   if (error_state)
     return;
 
@@ -2745,17 +2804,17 @@ figure::properties::set_visible (const o
 }
 
 Matrix
 figure::properties::get_boundingbox (bool) const
 {
   Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
   Matrix pos;
 
-  pos = convert_position (get_position ().matrix_value (), get_units (),
+  pos = convert_position (position.get ().matrix_value (), get_units (),
                           "pixels", screen_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = screen_size(1) - pos(1) - pos(3);
 
   return pos;
 }
@@ -2769,40 +2828,99 @@ figure::properties::set_boundingbox (con
   pos(1) = screen_size(1) - pos(1) - pos(3);
   pos(1)++;
   pos(0)++;
   pos = convert_position (pos, "pixels", get_units (), screen_size);
 
   set_position (pos);
 }
 
+octave_value
+figure::properties::get_position (void) const
+{
+  Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
+  return convert_position (position.get ().matrix_value (), 
+                           "pixels", get_units (), screen_size);
+}
+
 void
 figure::properties::set_position (const octave_value& v)
 {
   if (! error_state)
     {
       Matrix old_bb, new_bb;
 
       old_bb = get_boundingbox ();
-      position = v;
+      Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
+      position = convert_position (v.matrix_value (), get_units (), 
+                                   "pixels", screen_size);
       new_bb = get_boundingbox ();
 
       if (old_bb != new_bb)
         {
           if (old_bb(2) != new_bb(2) || old_bb(3) != new_bb(3))
             {
               execute_resizefcn ();
               update_boundingbox ();
             }
         }
 
       mark_modified ();
     }
 }
 
+octave_value
+figure::properties::get_paperposition (void) const
+{
+  Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
+  return convert_position (paperposition.get ().matrix_value (), 
+                           "inches", get_paperunits (), screen_size);
+}
+
+void 
+figure::properties::set_paperposition (const octave_value& val)
+{
+  if (! error_state)
+    {
+      Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
+      Matrix pos =  convert_position (val.matrix_value (), get_paperunits (), 
+                                      "inches", screen_size);
+      if (paperposition.set (octave_value (pos), true))
+        {
+          mark_modified ();
+        }
+    }
+}
+
+octave_value
+figure::properties::get_papersize (void) const
+{
+  Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
+  Matrix sz = papersize.get ().matrix_value ();
+  sz. resize (1, 4);
+  return convert_position (sz, "inches", get_paperunits (), screen_size). extract_n (0, 0, 1, 2);
+}
+
+void 
+figure::properties::set_papersize (const octave_value& val)
+{
+  if (! error_state)
+    {
+      Matrix screen_size = xget (0, "screensize").matrix_value ().extract_n (0, 2, 1, 2);
+      Matrix sz = val.matrix_value ();
+      sz. resize (1, 4);
+
+      Matrix pos =  convert_position (sz, get_paperunits (), "inches", screen_size). extract_n (0, 0, 1, 2);
+      if (papersize.set (octave_value (pos), true))
+        {
+          mark_modified ();
+        }
+    }
+}
+
 std::string
 figure::properties::get_title (void) const
 {
   if (is_numbertitle ())
     {
       std::ostringstream os;
       std::string nm = get_name ();
 
@@ -3668,16 +3786,71 @@ axes::properties::get_boundingbox (bool 
 
   pos(0)--;
   pos(1)--;
   pos(1) = parent_bb(3) - pos(1) - pos(3);
 
   return pos;
 }
 
+octave_value 
+axes::properties::get_outerposition (void) const 
+{ 
+  graphics_object obj = gh_manager::get_object (get_parent ());
+  Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
+  return convert_position (outerposition.get ().matrix_value (),
+                           "normalized", get_units (), 
+                           parent_bb.extract_n (0, 2, 1, 2));
+}
+    
+void 
+axes::properties::set_outerposition (const octave_value& val)
+{
+  if (! error_state)
+    {
+      graphics_object obj = gh_manager::get_object (get_parent ());
+      Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
+      Matrix pos = convert_position (val.matrix_value(), get_units (), 
+                                     "normalized",
+                                     parent_bb.extract_n (0, 2, 1, 2));
+      if (outerposition.set (octave_value (pos), true))
+        {
+          update_outerposition ();
+          mark_modified ();
+        }
+    }
+}
+
+octave_value 
+axes::properties::get_position (void) const
+{ 
+  graphics_object obj = gh_manager::get_object (get_parent ());
+  Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
+  return convert_position (position.get ().matrix_value (), 
+                           "normalized", get_units (), 
+                           parent_bb.extract_n (0, 2, 1, 2));
+}
+
+void 
+axes::properties::set_position (const octave_value& val)
+{
+  if (! error_state)
+    {
+      graphics_object obj = gh_manager::get_object (get_parent ());
+      Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
+      Matrix pos = convert_position (val.matrix_value (), get_units (), "normalized",
+                                     parent_bb.extract_n (0, 2, 1, 2));
+      if (position.set (octave_value (pos), true))
+        {
+          update_position ();
+          mark_modified ();
+        }
+    }
+}
+
 ColumnVector
 graphics_xform::xform_vector (double x, double y, double z)
 {
   return ::xform_vector (x, y, z);
 }
 
 Matrix
 graphics_xform::xform_eye (void)
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -2458,23 +2458,23 @@ public:
       array_property commandwindowsize r , Matrix (1, 2, 0)
       handle_property currentfigure S , graphics_handle ()
       bool_property diary , "off"
       string_property diaryfile , "diary"
       bool_property echo , "off"
       radio_property format , "+|bank|bit|debug|hex|long|longe|longeng|longg|native-bit|native-hex|rational|{short}|shorte|shorteng|shortg"
       radio_property formatspacing , "{loose}|compact"
       string_property language , "ascii"
-      array_property monitorpositions , Matrix (1, 4, 0)
-      array_property pointerlocation , Matrix (1, 2, 0)
+      array_property monitorpositions SG , Matrix (1, 4, 0)
+      array_property pointerlocation SG , Matrix (1, 2, 0)
       double_property pointerwindow , 0.0
       double_property recursionlimit , 256.0
       double_property screendepth r , default_screendepth ()
       double_property screenpixelsperinch r , default_screenpixelsperinch ()
-      array_property screensize r , default_screensize ()
+      array_property screensize Gr , default_screensize ()
       bool_property showhiddenhandles , "off"
       radio_property units U , "inches|centimeters|normalized|points|{pixels}"
     END_PROPERTIES
 
   private:
     std::list<graphics_handle> cbo_stack;
   };
 
@@ -2658,24 +2658,24 @@ public:
       bool_property inverthardcopy , "off"
       callback_property keypressfcn , Matrix ()
       callback_property keyreleasefcn , Matrix ()
       radio_property menubar , "none|{figure}"
       double_property mincolormap , 64
       string_property name , ""
       bool_property numbertitle , "on"
       radio_property paperunits , "{inches}|centimeters|normalized|points"
-      array_property paperposition , default_figure_paperposition ()
+      array_property paperposition SG , default_figure_paperposition ()
       radio_property paperpositionmode , "auto|{manual}"
-      array_property papersize , default_figure_papersize ()
+      array_property papersize SG , default_figure_papersize ()
       radio_property papertype , "{usletter}|uslegal|a0|a1|a2|a3|a4|a5|b0|b1|b2|b3|b4|b5|arch-a|arch-b|arch-c|arch-d|arch-e|a|b|c|d|e|tabloid|<custom>"
       radio_property pointer , "crosshair|fullcrosshair|{arrow}|ibeam|watch|topl|topr|botl|botr|left|top|right|bottom|circle|cross|fleur|custom|hand"
       array_property pointershapecdata , Matrix (16, 16, 0)
       array_property pointershapehotspot , Matrix (1, 2, 0)
-      array_property position S , default_figure_position ()
+      array_property position SG , default_figure_position ()
       radio_property renderer , "{painters}|zbuffer|opengl|none"
       radio_property renderermode , "{auto}|manual"
       bool_property resize , "on"
       callback_property resizefcn , Matrix ()
       radio_property selectiontype , "{normal}|open|alt|extend"
       radio_property toolbar , "none|{auto}|figure"
       radio_property units , "inches|centimeters|normalized|points|{pixels}|characters"
       callback_property windowbuttondownfcn , Matrix ()
@@ -2929,17 +2929,17 @@ public:
     void delete_text_child (handle_property& h);
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     // properties which are not in matlab: interpreter
 
     BEGIN_PROPERTIES (axes)
-      array_property position u , default_axes_position ()
+      array_property position uSG , default_axes_position ()
       bool_property box , "on"
       bool_property key , "off"
       bool_property keybox , "off"
       bool_property keyreverse , "off"
       any_property keypos , 1
       array_property colororder , default_colororder ()
       array_property dataaspectratio m , Matrix (1, 3, 1.0)
       radio_property dataaspectratiomode , "{auto}|manual"
@@ -2991,17 +2991,17 @@ public:
       radio_property xdir u , "{normal}|reverse"
       radio_property ydir u , "{normal}|reverse"
       radio_property zdir u , "{normal}|reverse"
       radio_property yaxislocation , "{left}|right|zero"
       radio_property xaxislocation , "{bottom}|top|zero"
       array_property view u , Matrix ()
       bool_property __hold_all__ h , "off"
       radio_property nextplot , "new|add|replacechildren|{replace}"
-      array_property outerposition u , default_axes_outerposition ()
+      array_property outerposition uSG , default_axes_outerposition ()
       radio_property activepositionproperty , "{outerposition}|position"
       color_property ambientlightcolor , color_values (1, 1, 1)
       array_property cameraposition m , Matrix (1, 3, 0.0)
       array_property cameratarget m , Matrix (1, 3, 0.0)
       array_property cameraupvector m , Matrix ()
       double_property cameraviewangle m , 10.0
       radio_property camerapositionmode , "{auto}|manual"
       radio_property cameratargetmode , "{auto}|manual"
