# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1492028990 14400
#      Wed Apr 12 16:29:50 2017 -0400
# Node ID 209e749363a2b38d295da78633e056fe8d701e12
# Parent  1ae9f4c1f48a9549bdd424b1f90d855579c8ac85
safe cast between SuiteSparse_long and octave_idx_type pointers (bug #50510)

* oct-sparse.cc: New file.
* liboctave/util/module.mk: Update.

* oct-sparse.h, oct-sparse.cc (octave::suitesparse_integer): New typedef.
(octave::to_suitesparse_intptr, octave::to_octave_idx_type_ptr):
New functions.

* amd.cc, ccolamd.cc, colamd.cc, dmperm.cc, symbfact.cc, CSparse.cc,
dSparse.cc, sparse-dmsolve.cc, sparse-lu.cc, sparse-qr.cc: Use new
functions and typedef to avoid conflicts between pointers to
octave_idx_type and SuiteSparse_long on systems where they are
equivalent types but have incompatible definitions (long long int *
vs. long int *, for example, when both are 64-bits wide).

diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -79,50 +79,50 @@ The author of the code itself is Timothy
 #if defined (HAVE_AMD)
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_idx_type n_row, n_col;
-  const octave_idx_type *ridx, *cidx;
+  const octave::suitesparse_integer *ridx, *cidx;
   SparseMatrix sm;
   SparseComplexMatrix scm;
 
   if (args(0).is_sparse_type ())
     {
       if (args(0).is_complex_type ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
-          ridx = scm.xridx ();
-          cidx = scm.xcidx ();
+          ridx = octave::to_suitesparse_intptr (scm.xridx ());
+          cidx = octave::to_suitesparse_intptr (scm.xcidx ());
         }
       else
         {
           sm = args(0).sparse_matrix_value ();
           n_row = sm.rows ();
           n_col = sm.cols ();
-          ridx = sm.xridx ();
-          cidx = sm.xcidx ();
+          ridx = octave::to_suitesparse_intptr (sm.xridx ());
+          cidx = octave::to_suitesparse_intptr (sm.xcidx ());
         }
     }
   else
     {
       if (args(0).is_complex_type ())
         sm = SparseMatrix (real (args(0).complex_matrix_value ()));
       else
         sm = SparseMatrix (args(0).matrix_value ());
 
       n_row = sm.rows ();
       n_col = sm.cols ();
-      ridx = sm.xridx ();
-      cidx = sm.xcidx ();
+      ridx = octave::to_suitesparse_intptr (sm.xridx ());
+      cidx = octave::to_suitesparse_intptr (sm.xcidx ());
     }
 
   if (n_row != n_col)
     err_square_matrix_required ("amd", "S");
 
   OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
   AMD_NAME (_defaults) (Control);
   if (nargin > 1)
@@ -135,30 +135,30 @@ The author of the code itself is Timothy
       if (tmp.is_defined ())
         Control[AMD_DENSE] = tmp.double_value ();
 
       tmp = arg1.getfield ("aggressive");
       if (tmp.is_defined ())
         Control[AMD_AGGRESSIVE] = tmp.double_value ();
     }
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, P, n_col);
   Matrix xinfo (AMD_INFO, 1);
   double *Info = xinfo.fortran_vec ();
 
   // FIXME: how can we manage the memory allocation of amd
   //        in a cleaner manner?
   SUITESPARSE_ASSIGN_FPTR (malloc_func, amd_malloc, malloc);
   SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
   SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
   SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
   SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
 
-  octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
-                                              Control, Info);
+  octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P, Control,
+                                              Info);
 
   if (result == AMD_OUT_OF_MEMORY)
     error ("amd: out of memory");
   else if (result == AMD_INVALID)
     error ("amd: matrix S is corrupted");
 
   Matrix Pout (1, n_col);
   for (octave_idx_type i = 0; i < n_col; i++)
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -243,41 +243,41 @@ ccolamd, csymamd, amd, colamd, symamd, a
       n_row = sm.rows ();
       n_col = sm.cols ();
       nnz = sm.nnz ();
       ridx = sm.xridx ();
       cidx = sm.xcidx ();
     }
 
   // Allocate workspace for ccolamd
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, p, n_col+1);
   for (octave_idx_type i = 0; i < n_col+1; i++)
     p[i] = cidx[i];
 
   octave_idx_type Alen = CCOLAMD_NAME (_recommended) (nnz, n_row, n_col);
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, A, Alen);
   for (octave_idx_type i = 0; i < nnz; i++)
     A[i] = ridx[i];
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, stats, CCOLAMD_STATS);
 
   if (nargin > 2)
     {
       NDArray in_cmember = args(2).array_value ();
       octave_idx_type cslen = in_cmember.numel ();
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
+      OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, cmember, cslen);
       for (octave_idx_type i = 0; i < cslen; i++)
         // convert cmember from 1-based to 0-based
-        cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
+        cmember[i] = static_cast<octave::suitesparse_integer>(in_cmember(i) - 1);
 
       if (cslen != n_col)
         error ("ccolamd: CMEMBER must be of length equal to #cols of A");
 
       // Order the columns (destroys A)
-      if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
+      if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats,cmember))
         {
           CCOLAMD_NAME (_report) (stats);
 
           error ("ccolamd: internal error!");
         }
     }
   else
     {
@@ -486,43 +486,47 @@ ccolamd, csymamd, amd, colamd, symamd, a
       ridx = sm.xridx ();
       cidx = sm.xcidx ();
     }
 
   if (n_row != n_col)
     err_square_matrix_required ("csymamd", "S");
 
   // Allocate workspace for symamd
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, perm, n_col+1);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, stats, CCOLAMD_STATS);
 
   if (nargin > 2)
     {
       NDArray in_cmember = args(2).array_value ();
       octave_idx_type cslen = in_cmember.numel ();
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
+      OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, cmember, cslen);
       for (octave_idx_type i = 0; i < cslen; i++)
         // convert cmember from 1-based to 0-based
         cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
       if (cslen != n_col)
         error ("csymamd: CMEMBER must be of length equal to #cols of A");
 
-      if (! CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
-                             &calloc, &free, cmember, -1))
+      if (! CSYMAMD_NAME () (n_col,
+                             octave::to_suitesparse_intptr (ridx),
+                             octave::to_suitesparse_intptr (cidx),
+                             perm, knobs, stats, &calloc, &free, cmember, -1))
         {
           CSYMAMD_NAME (_report)(stats);
 
           error ("csymamd: internal error!");
         }
     }
   else
     {
-      if (! CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
-                             &calloc, &free, 0, -1))
+      if (! CSYMAMD_NAME () (n_col,
+                             octave::to_suitesparse_intptr (ridx),
+                             octave::to_suitesparse_intptr (cidx),
+                             perm, knobs, stats, &calloc, &free, 0, -1))
         {
           CSYMAMD_NAME (_report)(stats);
 
           error ("csymamd: internal error!");
         }
     }
 
   // return the permutation vector
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -365,27 +365,27 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       n_row = sm.rows ();
       n_col = sm.cols ();
       nnz = sm.nnz ();
       ridx = sm.xridx ();
       cidx = sm.xcidx ();
     }
 
   // Allocate workspace for colamd
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, p, n_col+1);
   for (octave_idx_type i = 0; i < n_col+1; i++)
     p[i] = cidx[i];
 
   octave_idx_type Alen = COLAMD_NAME (_recommended) (nnz, n_row, n_col);
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, A, Alen);
   for (octave_idx_type i = 0; i < nnz; i++)
     A[i] = ridx[i];
 
   // Order the columns (destroys A)
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, stats, COLAMD_STATS);
   if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
     {
       COLAMD_NAME (_report)(stats);
 
       error ("colamd: internal error!");
     }
 
   // column elimination tree post-ordering (reuse variables)
@@ -575,18 +575,20 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       cidx = sm.xcidx ();
     }
 
   if (n_row != n_col)
     err_square_matrix_required ("symamd", "S");
 
   // Allocate workspace for symamd
   OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
-  if (! SYMAMD_NAME () (n_col, ridx, cidx, perm,
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, stats, COLAMD_STATS);
+  if (! SYMAMD_NAME () (n_col, octave::to_suitesparse_intptr (ridx),
+                        octave::to_suitesparse_intptr (cidx),
+                        octave::to_suitesparse_intptr (perm),
                         knobs, stats, &calloc, &free))
     {
       SYMAMD_NAME (_report)(stats);
 
       error ("symamd: internal error!");
     }
 
   // column elimination tree post-ordering
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #  define CXSPARSE_NAME(name) cs_dl ## name
 #else
 #  define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
 #if defined (HAVE_CXSPARSE)
 
 static RowVector
-put_int (octave_idx_type *p, octave_idx_type n)
+put_int (octave::suitesparse_integer *p, octave_idx_type n)
 {
   RowVector ret (n);
   for (octave_idx_type i = 0; i < n; i++)
     ret.xelem (i) = p[i] + 1;
   return ret;
 }
 
 static octave_value_list
@@ -66,30 +66,30 @@ dmperm_internal (bool rank, const octave
   csm.n = nc;
   csm.x = 0;
   csm.nz = -1;
 
   if (arg.is_real_type ())
     {
       m = arg.sparse_matrix_value ();
       csm.nzmax = m.nnz ();
-      csm.p = m.xcidx ();
-      csm.i = m.xridx ();
+      csm.p = octave::to_suitesparse_intptr (m.xcidx ());
+      csm.i = octave::to_suitesparse_intptr (m.xridx ());
     }
   else
     {
       cm = arg.sparse_complex_matrix_value ();
       csm.nzmax = cm.nnz ();
-      csm.p = cm.xcidx ();
-      csm.i = cm.xridx ();
+      csm.p = octave::to_suitesparse_intptr (cm.xcidx ());
+      csm.i = octave::to_suitesparse_intptr (cm.xridx ());
     }
 
   if (nargout <= 1 || rank)
     {
-      octave_idx_type *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
+      octave::suitesparse_integer *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
       if (rank)
         {
           octave_idx_type r = 0;
           for (octave_idx_type i = 0; i < nc; i++)
             if (jmatch[nr+i] >= 0)
               r++;
           retval(0) = static_cast<double>(r);
         }
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -193,20 +193,20 @@ Cholesky@tie{}factorization as determine
       ch = toupper (str[0]);
       if (ch != 'L')
         error ("symbfact: unrecognized MODE \"%s\"", str.c_str ());
     }
 
   if (A->stype && A->nrow != A->ncol)
     err_square_matrix_required ("symbfact", "S");
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Parent, n);
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Post, n);
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, ColCount, n);
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, First, n);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, Parent, n);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, Post, n);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, ColCount, n);
+  OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, First, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Level, n);
 
   cholmod_common Common;
   cholmod_common *cm = &Common;
   CHOLMOD_NAME(start) (cm);
 
   double spu = octave_sparse_params::get_key ("spumoni");
   if (spu == 0.)
@@ -250,18 +250,18 @@ Cholesky@tie{}factorization as determine
     }
 
   if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
     {
       err_msg = "symbfact: postorder failed";
       goto cleanup;
     }
 
-  CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0,
-                              ColCount, First, Level, cm);
+  CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0, ColCount, First,
+                              octave::to_suitesparse_intptr (Level), cm);
 
   if (cm->status < CHOLMOD_OK)
     {
       err_msg = "symbfact: matrix corrupted";
       goto cleanup;
     }
 
   if (nargout > 4)
@@ -302,17 +302,17 @@ Cholesky@tie{}factorization as determine
       for (octave_idx_type j = 0 ; j < n ; j++)
         {
           L.xcidx(j) = lnz;
           lnz += ColCount[j];
         }
       L.xcidx(n) = lnz;
 
       // create a copy of the column pointers
-      octave_idx_type *W = First;
+      octave::suitesparse_integer *W = First;
       for (octave_idx_type j = 0 ; j < n ; j++)
         W[j] = L.xcidx (j);
 
       // get workspace for computing one row of L
       cholmod_sparse *R
         = CHOLMOD_NAME(allocate_sparse) (n, 1, n, false, true,
                                          0, CHOLMOD_PATTERN, cm);
       octave_idx_type *Rp = static_cast<octave_idx_type *> (R->p);
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1109,26 +1109,30 @@ SparseComplexMatrix::determinant (octave
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
-      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
+      UMFPACK_ZNAME (report_matrix) (nr, nc,
+                                     octave::to_suitesparse_intptr (Ap),
+                                     octave::to_suitesparse_intptr (Ai),
                                      reinterpret_cast<const double *> (Ax),
                                      0, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = UMFPACK_ZNAME (qsymbolic)
-                   (nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0,
-                    0, &Symbolic, control, info);
+      int status = UMFPACK_ZNAME (qsymbolic) (nr, nc,
+                                              octave::to_suitesparse_intptr (Ap),
+                                              octave::to_suitesparse_intptr (Ai),
+                                              reinterpret_cast<const double *> (Ax),
+                                              0, 0, &Symbolic, control, info);
 
       if (status < 0)
         {
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
@@ -1136,17 +1140,18 @@ SparseComplexMatrix::determinant (octave
             ("SparseComplexMatrix::determinant symbolic factorization failed");
         }
       else
         {
           UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status
-            = UMFPACK_ZNAME (numeric) (Ap, Ai,
+            = UMFPACK_ZNAME (numeric) (octave::to_suitesparse_intptr (Ap),
+                                       octave::to_suitesparse_intptr (Ai),
                                        reinterpret_cast<const double *> (Ax),
                                        0, Symbolic, &Numeric, control, info);
           UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
@@ -5542,24 +5547,28 @@ SparseComplexMatrix::factorize (octave_i
   UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
+  UMFPACK_ZNAME (report_matrix) (nr, nc,
+                                 octave::to_suitesparse_intptr (Ap),
+                                 octave::to_suitesparse_intptr (Ai),
                                  reinterpret_cast<const double *> (Ax),
                                  0, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
+  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc,
+                                          octave::to_suitesparse_intptr (Ap),
+                                          octave::to_suitesparse_intptr (Ai),
                                           reinterpret_cast<const double *> (Ax),
                                           0, 0, &Symbolic, control, info);
 
   if (status < 0)
     {
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
@@ -5569,17 +5578,18 @@ SparseComplexMatrix::factorize (octave_i
       (*current_liboctave_error_handler)
         ("SparseComplexMatrix::solve symbolic factorization failed");
       err = -1;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
-      status = UMFPACK_ZNAME (numeric) (Ap, Ai,
+      status = UMFPACK_ZNAME (numeric) (octave::to_suitesparse_intptr (Ap),
+                                        octave::to_suitesparse_intptr (Ai),
                                         reinterpret_cast<const double *> (Ax),
                                         0, Symbolic, &Numeric, control, info);
       UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
@@ -5818,30 +5828,32 @@ SparseComplexMatrix::fsolve (MatrixType 
               OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
               retval.resize (b_nr, b_nc);
               Complex *Xx = retval.fortran_vec ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
 #if defined (UMFPACK_SEPARATE_SPLIT)
-                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai,
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
                                                   0,
                                                   reinterpret_cast<double *> (&Xx[iidx]),
                                                   0,
                                                   &Bx[iidx], Bz, Numeric,
                                                   control, info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
-                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai,
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
                                                   0,
                                                   reinterpret_cast<double *> (&Xx[iidx]),
                                                   0,
                                                   reinterpret_cast<const double *> (Bz),
                                                   0, Numeric,
                                                   control, info);
 #endif
@@ -6096,29 +6108,32 @@ SparseComplexMatrix::fsolve (MatrixType 
               retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
 #if defined (UMFPACK_SEPARATE_SPLIT)
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
-                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai,
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
                                                   0,
                                                   reinterpret_cast<double *> (Xx),
                                                   0,
                                                   Bx, Bz, Numeric, control,
                                                   info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
-                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai,
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
                                                   0,
                                                   reinterpret_cast<double *> (Xx),
                                                   0,
                                                   reinterpret_cast<double *> (Bz),
                                                   0,
                                                   Numeric, control,
                                                   info);
@@ -6360,17 +6375,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               const Complex *Bx = b.fortran_vec ();
 
               retval.resize (b_nr, b_nc);
               Complex *Xx = retval.fortran_vec ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
                   status =
-                    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai,
+                    UMFPACK_ZNAME (solve) (UMFPACK_A,
+                                           octave::to_suitesparse_intptr (Ap),
+                                           octave::to_suitesparse_intptr (Ai),
                                            reinterpret_cast<const double *> (Ax),
                                            0,
                                            reinterpret_cast<double *> (&Xx[iidx]),
                                            0,
                                            reinterpret_cast<const double *> (&Bx[iidx]),
                                            0, Numeric, control, info);
 
                   if (status < 0)
@@ -6614,18 +6631,19 @@ SparseComplexMatrix::fsolve (MatrixType 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 
               retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b(i,j);
 
-                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai,
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
                                                   0,
                                                   reinterpret_cast<double *> (Xx),
                                                   0,
                                                   reinterpret_cast<double *> (Bx),
                                                   0, Numeric, control, info);
 
                   if (status < 0)
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1185,22 +1185,27 @@ SparseMatrix::determinant (octave_idx_ty
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const double *Ax = data ();
 
-      UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
+      UMFPACK_DNAME (report_matrix) (nr, nc,
+                                     octave::to_suitesparse_intptr (Ap),
+                                     octave::to_suitesparse_intptr (Ai),
+                                     Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai,
+      int status = UMFPACK_DNAME (qsymbolic) (nr, nc,
+                                              octave::to_suitesparse_intptr (Ap),
+                                              octave::to_suitesparse_intptr (Ai),
                                               Ax, 0, &Symbolic, control, info);
 
       if (status < 0)
         {
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           UMFPACK_DNAME (free_symbolic) (&Symbolic);
@@ -1208,17 +1213,19 @@ SparseMatrix::determinant (octave_idx_ty
           (*current_liboctave_error_handler)
             ("SparseMatrix::determinant symbolic factorization failed");
         }
       else
         {
           UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
-          status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
+          status = UMFPACK_DNAME (numeric) (octave::to_suitesparse_intptr (Ap),
+                                            octave::to_suitesparse_intptr (Ai),
+                                            Ax, Symbolic,
                                             &Numeric, control, info);
           UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               UMFPACK_DNAME (report_status) (control, status);
@@ -5730,23 +5737,28 @@ SparseMatrix::factorize (octave_idx_type
   UMFPACK_DNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const double *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
+  UMFPACK_DNAME (report_matrix) (nr, nc,
+                                 octave::to_suitesparse_intptr (Ap),
+                                 octave::to_suitesparse_intptr (Ai),
+                                 Ax, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
-                                          &Symbolic, control, info);
+  int status = UMFPACK_DNAME (qsymbolic) (nr, nc,
+                                          octave::to_suitesparse_intptr (Ap),
+                                          octave::to_suitesparse_intptr (Ai),
+                                          Ax, 0, &Symbolic, control, info);
 
   if (status < 0)
     {
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
@@ -5754,18 +5766,19 @@ SparseMatrix::factorize (octave_idx_type
       (*current_liboctave_error_handler)
         ("SparseMatrix::solve symbolic factorization failed");
       err = -1;
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
-      status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-                                        &Numeric, control, info);
+      status = UMFPACK_DNAME (numeric) (octave::to_suitesparse_intptr (Ap),
+                                        octave::to_suitesparse_intptr (Ai),
+                                        Ax, Symbolic, &Numeric, control, info);
       UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
@@ -5996,20 +6009,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
               double *control = Control.fortran_vec ();
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
               const double *Ax = data ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
-                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai, Ax, &result[iidx],
-                                                  &Bx[iidx], Numeric, control,
-                                                  info);
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
+                                                  Ax, &result[iidx], &Bx[iidx],
+                                                  Numeric, control, info);
                   if (status < 0)
                     {
                       UMFPACK_DNAME (report_status) (control, status);
 
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
@@ -6245,18 +6259,20 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
               retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
-                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai, Ax, Xx, Bx, Numeric,
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
+                                                  Ax, Xx, Bx, Numeric,
                                                   control, info);
                   if (status < 0)
                     {
                       UMFPACK_DNAME (report_status) (control, status);
 
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
@@ -6500,21 +6516,25 @@ SparseMatrix::fsolve (MatrixType &mattyp
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b(i,j);
                       Bx[i] = c.real ();
                       Bz[i] = c.imag ();
                     }
 
-                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai, Ax, Xx, Bx, Numeric,
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
+                                                  Ax, Xx, Bx, Numeric,
                                                   control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-                                                       Ap, Ai, Ax, Xz, Bz,
+                                                       octave::to_suitesparse_intptr (Ap),
+                                                       octave::to_suitesparse_intptr (Ai),
+                                                       Ax, Xz, Bz,
                                                        Numeric, control, info);
 
                   if (status < 0 || status2 < 0)
                     {
                       UMFPACK_DNAME (report_status) (control, status);
 
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
@@ -6762,21 +6782,25 @@ SparseMatrix::fsolve (MatrixType &mattyp
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b(i,j);
                       Bx[i] = c.real ();
                       Bz[i] = c.imag ();
                     }
 
-                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                                  Ai, Ax, Xx, Bx, Numeric,
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A,
+                                                  octave::to_suitesparse_intptr (Ap),
+                                                  octave::to_suitesparse_intptr (Ai),
+                                                  Ax, Xx, Bx, Numeric,
                                                   control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-                                                       Ap, Ai, Ax, Xz, Bz,
+                                                       octave::to_suitesparse_intptr (Ap),
+                                                       octave::to_suitesparse_intptr (Ai),
+                                                       Ax, Xz, Bz,
                                                        Numeric, control, info);
 
                   if (status < 0 || status2 < 0)
                     {
                       UMFPACK_DNAME (report_status) (control, status);
 
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -384,22 +384,22 @@ dmsolve (const ST &a, const T &b, octave
       csm.m = nr;
       csm.n = nc;
       csm.x = 0;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
 
       // Cast away const on A, with full knowledge that CSparse won't touch it.
       // Prevents the methods below making a copy of the data.
-      csm.p = const_cast<octave_idx_type *>(a.cidx ());
-      csm.i = const_cast<octave_idx_type *>(a.ridx ());
+      csm.p = const_cast<octave::suitesparse_integer *>(octave::to_suitesparse_intptr (a.cidx ()));
+      csm.i = const_cast<octave::suitesparse_integer *>(octave::to_suitesparse_intptr (a.ridx ()));
 
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm, 0);
-      octave_idx_type *p = dm->p;
-      octave_idx_type *q = dm->q;
+      octave_idx_type *p = octave::to_octave_idx_type_ptr (dm->p);
+      octave_idx_type *q = octave::to_octave_idx_type_ptr (dm->q);
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, pinv, nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         pinv[p[i]] = i;
 
       RT btmp;
       dmsolve_permute (btmp, b, pinv);
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -145,54 +145,65 @@ namespace octave
       UMFPACK_DNAME (free_symbolic) (Symbolic);
     }
 
     template <>
     inline octave_idx_type
     umfpack_get_lunz<double>
     (octave_idx_type *lnz, octave_idx_type *unz, void *Numeric)
     {
-      octave_idx_type ignore1, ignore2, ignore3;
+      suitesparse_integer ignore1, ignore2, ignore3;
 
-      return UMFPACK_DNAME (get_lunz) (lnz, unz, &ignore1, &ignore2,
-                                       &ignore3, Numeric);
+      return UMFPACK_DNAME (get_lunz) (to_suitesparse_intptr (lnz),
+                                       to_suitesparse_intptr (unz),
+                                       &ignore1, &ignore2, &ignore3, Numeric);
     }
 
     template <>
     inline octave_idx_type
     umfpack_get_numeric<double>
     (octave_idx_type *Lp, octave_idx_type *Lj, double *Lx,
      octave_idx_type *Up, octave_idx_type *Ui, double *Ux,
      octave_idx_type *p, octave_idx_type *q, double *Dx,
      octave_idx_type *do_recip, double *Rs, void *Numeric)
     {
-      return UMFPACK_DNAME (get_numeric) (Lp, Lj, Lx, Up, Ui, Ux, p, q, Dx,
-                                          do_recip, Rs, Numeric);
+      return UMFPACK_DNAME (get_numeric) (to_suitesparse_intptr (Lp),
+                                          to_suitesparse_intptr (Lj),
+                                          Lx, to_suitesparse_intptr (Up),
+                                          to_suitesparse_intptr (Ui), Ux,
+                                          to_suitesparse_intptr (p),
+                                          to_suitesparse_intptr (q), Dx,
+                                          to_suitesparse_intptr (do_recip),
+                                          Rs, Numeric);
     }
 
     template <>
     inline octave_idx_type
     umfpack_numeric<double>
     (const octave_idx_type *Ap, const octave_idx_type *Ai,
      const double *Ax, void *Symbolic, void **Numeric,
      const double *Control, double *Info)
     {
-      return UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, Numeric, Control,
-                                      Info);
+      return UMFPACK_DNAME (numeric) (to_suitesparse_intptr (Ap),
+                                      to_suitesparse_intptr (Ai),
+                                      Ax, Symbolic, Numeric, Control, Info);
     }
 
     template <>
     inline octave_idx_type
     umfpack_qsymbolic<double>
     (octave_idx_type n_row, octave_idx_type n_col, const octave_idx_type *Ap,
      const octave_idx_type *Ai, const double *Ax,
      const octave_idx_type *Qinit, void **Symbolic,
      const double *Control, double *Info)
     {
-      return UMFPACK_DNAME (qsymbolic) (n_row, n_col, Ap, Ai, Ax, Qinit,
+      return UMFPACK_DNAME (qsymbolic) (n_row, n_col,
+                                        to_suitesparse_intptr (Ap),
+                                        to_suitesparse_intptr (Ai), Ax,
+                                        to_suitesparse_intptr (Qinit),
                                         Symbolic, Control, Info);
     }
 
     template <>
     inline void
     umfpack_report_control<double> (const double *Control)
     {
       UMFPACK_DNAME (report_control) (Control);
@@ -207,33 +218,35 @@ namespace octave
 
     template <>
     inline void
     umfpack_report_matrix<double>
     (octave_idx_type n_row, octave_idx_type n_col, const octave_idx_type *Ap,
      const octave_idx_type *Ai, const double *Ax, octave_idx_type col_form,
      const double *Control)
     {
-      UMFPACK_DNAME (report_matrix) (n_row, n_col, Ap, Ai, Ax,
+      UMFPACK_DNAME (report_matrix) (n_row, n_col,
+                                     to_suitesparse_intptr (Ap),
+                                     to_suitesparse_intptr (Ai), Ax,
                                      col_form, Control);
     }
 
     template <>
     inline void
     umfpack_report_numeric<double> (void *Numeric, const double *Control)
     {
       UMFPACK_DNAME (report_numeric) (Numeric, Control);
     }
 
     template <>
     inline void
     umfpack_report_perm<double>
     (octave_idx_type np, const octave_idx_type *Perm, const double *Control)
     {
-      UMFPACK_DNAME (report_perm) (np, Perm, Control);
+      UMFPACK_DNAME (report_perm) (np, to_suitesparse_intptr (Perm), Control);
     }
 
     template <>
     inline void
     umfpack_report_status<double> (double *Control, octave_idx_type status)
     {
       UMFPACK_DNAME (report_status) (Control, status);
     }
@@ -268,62 +281,71 @@ namespace octave
       UMFPACK_ZNAME (free_symbolic) (Symbolic);
     }
 
     template <>
     inline octave_idx_type
     umfpack_get_lunz<Complex>
     (octave_idx_type *lnz, octave_idx_type *unz, void *Numeric)
     {
-      octave_idx_type ignore1, ignore2, ignore3;
+      suitesparse_integer ignore1, ignore2, ignore3;
 
-      return UMFPACK_ZNAME (get_lunz) (lnz, unz, &ignore1, &ignore2,
-                                       &ignore3, Numeric);
+      return UMFPACK_ZNAME (get_lunz) (to_suitesparse_intptr (lnz),
+                                       to_suitesparse_intptr (unz),
+                                       &ignore1, &ignore2, &ignore3, Numeric);
     }
 
     template <>
     inline octave_idx_type
     umfpack_get_numeric<Complex>
     (octave_idx_type *Lp, octave_idx_type *Lj, Complex *Lz,
      octave_idx_type *Up, octave_idx_type *Ui, Complex *Uz,
      octave_idx_type *p, octave_idx_type *q, double *Dz,
      octave_idx_type *do_recip, double *Rs, void *Numeric)
     {
-      return UMFPACK_ZNAME (get_numeric) (Lp, Lj,
+      return UMFPACK_ZNAME (get_numeric) (to_suitesparse_intptr (Lp),
+                                          to_suitesparse_intptr (Lj),
                                           reinterpret_cast<double *> (Lz),
-                                          0, Up, Ui,
+                                          0, to_suitesparse_intptr (Up),
+                                          to_suitesparse_intptr (Ui),
                                           reinterpret_cast<double *> (Uz),
-                                          0, p, q,
+                                          0, to_suitesparse_intptr (p),
+                                          to_suitesparse_intptr (q),
                                           reinterpret_cast<double *> (Dz),
-                                          0, do_recip, Rs, Numeric);
+                                          0, to_suitesparse_intptr (do_recip),
+                                          Rs, Numeric);
     }
 
     template <>
     inline octave_idx_type
     umfpack_numeric<Complex>
     (const octave_idx_type *Ap, const octave_idx_type *Ai,
      const Complex *Az, void *Symbolic, void **Numeric,
      const double *Control, double *Info)
     {
-      return UMFPACK_ZNAME (numeric) (Ap, Ai,
+      return UMFPACK_ZNAME (numeric) (to_suitesparse_intptr (Ap),
+                                      to_suitesparse_intptr (Ai),
                                       reinterpret_cast<const double *> (Az),
                                       0, Symbolic, Numeric, Control, Info);
     }
 
     template <>
     inline octave_idx_type
     umfpack_qsymbolic<Complex>
     (octave_idx_type n_row, octave_idx_type n_col,
      const octave_idx_type *Ap, const octave_idx_type *Ai,
      const Complex *Az, const octave_idx_type *Qinit,
      void **Symbolic, const double *Control, double *Info)
     {
-      return UMFPACK_ZNAME (qsymbolic) (n_row, n_col, Ap, Ai,
+      return UMFPACK_ZNAME (qsymbolic) (n_row, n_col,
+                                        to_suitesparse_intptr (Ap),
+                                        to_suitesparse_intptr (Ai),
                                         reinterpret_cast<const double *> (Az),
-                                        0, Qinit, Symbolic, Control, Info);
+                                        0, to_suitesparse_intptr (Qinit),
+                                        Symbolic, Control, Info);
     }
 
     template <>
     inline void
     umfpack_report_control<Complex> (const double *Control)
     {
       UMFPACK_ZNAME (report_control) (Control);
     }
@@ -337,34 +359,36 @@ namespace octave
 
     template <>
     inline void
     umfpack_report_matrix<Complex>
     (octave_idx_type n_row, octave_idx_type n_col,
      const octave_idx_type *Ap, const octave_idx_type *Ai,
      const Complex *Az, octave_idx_type col_form, const double *Control)
     {
-      UMFPACK_ZNAME (report_matrix) (n_row, n_col, Ap, Ai,
+      UMFPACK_ZNAME (report_matrix) (n_row, n_col,
+                                     to_suitesparse_intptr (Ap),
+                                     to_suitesparse_intptr (Ai),
                                      reinterpret_cast<const double *> (Az),
                                      0, col_form, Control);
     }
 
     template <>
     inline void
     umfpack_report_numeric<Complex> (void *Numeric, const double *Control)
     {
       UMFPACK_ZNAME (report_numeric) (Numeric, Control);
     }
 
     template <>
     inline void
     umfpack_report_perm<Complex>
     (octave_idx_type np, const octave_idx_type *Perm, const double *Control)
     {
-      UMFPACK_ZNAME (report_perm) (np, Perm, Control);
+      UMFPACK_ZNAME (report_perm) (np, to_suitesparse_intptr (Perm), Control);
     }
 
     template <>
     inline void
     umfpack_report_status<Complex> (double *Control, octave_idx_type status)
     {
       UMFPACK_ZNAME (report_status) (Control, status);
     }
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -179,18 +179,18 @@ namespace octave
 
       CXSPARSE_DNAME () A;
 
       A.nzmax = a.nnz ();
       A.m = nrows;
       A.n = ncols;
       // Cast away const on A, with full knowledge that CSparse won't touch it
       // Prevents the methods below making a copy of the data.
-      A.p = const_cast<octave_idx_type *>(a.cidx ());
-      A.i = const_cast<octave_idx_type *>(a.ridx ());
+      A.p = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.cidx ()));
+      A.i = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.ridx ()));
       A.x = const_cast<double *>(a.data ());
       A.nz = -1;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       S = CXSPARSE_DNAME (_sqr) (order, &A, 1);
       N = CXSPARSE_DNAME (_qr) (&A, S);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -945,18 +945,18 @@ namespace octave
 
       CXSPARSE_ZNAME () A;
 
       A.nzmax = a.nnz ();
       A.m = nrows;
       A.n = ncols;
       // Cast away const on A, with full knowledge that CSparse won't touch it
       // Prevents the methods below making a copy of the data.
-      A.p = const_cast<octave_idx_type *>(a.cidx ());
-      A.i = const_cast<octave_idx_type *>(a.ridx ());
+      A.p = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.cidx ()));
+      A.i = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.ridx ()));
       A.x = const_cast<cs_complex_t *> (
               reinterpret_cast<const cs_complex_t *> (a.data ()));
       A.nz = -1;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
       N = CXSPARSE_ZNAME (_qr) (&A, S);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
diff --git a/liboctave/util/module.mk b/liboctave/util/module.mk
--- a/liboctave/util/module.mk
+++ b/liboctave/util/module.mk
@@ -63,16 +63,17 @@ UTIL_SRC = \
   liboctave/util/lo-utils.cc \
   liboctave/util/oct-base64.cc \
   liboctave/util/oct-glob.cc \
   liboctave/util/oct-inttypes.cc \
   liboctave/util/oct-locbuf.cc \
   liboctave/util/oct-mutex.cc \
   liboctave/util/oct-string.cc \
   liboctave/util/oct-shlib.cc \
+  liboctave/util/oct-sparse.cc \
   liboctave/util/pathsearch.cc \
   liboctave/util/lo-regexp.cc \
   liboctave/util/singleton-cleanup.cc \
   liboctave/util/sparse-sort.cc \
   liboctave/util/sparse-util.cc \
   liboctave/util/str-vec.cc \
   liboctave/util/unwind-prot.cc \
   liboctave/util/url-transfer.cc \
diff --git a/liboctave/util/oct-sparse.cc b/liboctave/util/oct-sparse.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/util/oct-sparse.cc
@@ -0,0 +1,80 @@
+/*
+
+Copyright (C) 2017 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include "lo-error.h"
+#include "oct-sparse.h"
+
+#if (defined (HAVE_AMD) || defined (HAVE_CCOLAMD)               \
+     || defined (HAVE_CHOLMOD) || defined (HAVE_COLAMD)         \
+     || defined (HAVE_CXSPARSE) || defined (HAVE_UMFPACK))
+
+static inline void
+check_suitesparse_integer_size (void)
+{
+  // FIXME: maybe it would be better to make this a configure check and
+  // disable suitesparse if it fails?
+
+  if (sizeof (octave::suitesparse_integer) != sizeof (octave_idx_type))
+    (*current_liboctave_error_handler)
+      ("size of suitesparse integer does not match octave_idx_type!");
+}
+
+namespace octave
+{
+  suitesparse_integer *
+  to_suitesparse_intptr (octave_idx_type *i)
+  {
+    check_suitesparse_integer_size ();
+
+    return reinterpret_cast<suitesparse_integer *> (i);
+  }
+
+  const suitesparse_integer *
+  to_suitesparse_intptr (const octave_idx_type *i)
+  {
+    check_suitesparse_integer_size ();
+
+    return reinterpret_cast<const suitesparse_integer *> (i);
+  }
+
+  octave_idx_type*
+  to_octave_idx_type_ptr (suitesparse_integer *i)
+  {
+    check_suitesparse_integer_size ();
+
+    return reinterpret_cast<octave_idx_type *> (i);
+  }
+
+  const octave_idx_type*
+  to_octave_idx_type_ptr (const suitesparse_integer *i)
+  {
+    check_suitesparse_integer_size ();
+
+    return reinterpret_cast<const octave_idx_type *> (i);
+  }
+}
+
+#endif
diff --git a/liboctave/util/oct-sparse.h b/liboctave/util/oct-sparse.h
--- a/liboctave/util/oct-sparse.h
+++ b/liboctave/util/oct-sparse.h
@@ -151,9 +151,35 @@ along with Octave; see the file COPYING.
 #    define UMFPACK_DNAME(name) umfpack_dl_ ## name
 #    define UMFPACK_ZNAME(name) umfpack_zl_ ## name
 #  else
 #    define UMFPACK_DNAME(name) umfpack_di_ ## name
 #    define UMFPACK_ZNAME(name) umfpack_zi_ ## name
 #  endif
 #endif
 
+#if (defined (HAVE_AMD) || defined (HAVE_CCOLAMD)               \
+     || defined (HAVE_CHOLMOD) || defined (HAVE_COLAMD)         \
+     || defined (HAVE_CXSPARSE) || defined (HAVE_UMFPACK))
+
+namespace octave
+{
+#  if defined (OCTAVE_ENABLE_64)
+  typedef SuiteSparse_long suitesparse_integer;
+#  else
+  typedef int suitesparse_integer;
+#  endif
+
+  extern suitesparse_integer *
+  to_suitesparse_intptr (octave_idx_type *i);
+
+  extern const suitesparse_integer *
+  to_suitesparse_intptr (const octave_idx_type *i);
+
+  extern octave_idx_type*
+  to_octave_idx_type_ptr (suitesparse_integer *i);
+
+  extern const octave_idx_type*
+  to_octave_idx_type_ptr (const suitesparse_integer *i);
+}
+
 #endif
+#endif
