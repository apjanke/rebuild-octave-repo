# HG changeset patch
# User jwe
# Date 1051551608 0
#      Mon Apr 28 17:40:08 2003 +0000
# Node ID 13619163e1597366b06db6edd4553c0df2effa10
# Parent  f92093e0ff788f5c893de9110a974b80307d5635
[project @ 2003-04-28 17:40:07 by jwe]

diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -236,32 +236,16 @@ extern int fclose (FILE *);
   START_WARNING (); fprintf (stderr, str, e1); END_WARNING ()
 #define WARNING2(str, e1, e2)						\
   START_WARNING (); fprintf (stderr, str, e1, e2); END_WARNING ()
 #define WARNING3(str, e1, e2, e3)					\
   START_WARNING (); fprintf (stderr, str, e1, e2, e3); END_WARNING ()
 #define WARNING4(str, e1, e2, e3, e4)					\
   START_WARNING (); fprintf (stderr, str, e1, e2, e3, e4); END_WARNING ()
 
-/* I find this easier to read.  */
-#define STREQ(s1, s2) (strcmp (s1, s2) == 0)
-#define STRNEQ(s1, s2, n) (strncmp (s1, s2, n) == 0)
-
-/* Support for FAT/ISO-9660 filesystems.  Theoretically this should be
-   done at runtime, per filesystem, but that's painful to program.  */
-#ifdef MONOCASE_FILENAMES
-#define FILESTRCASEEQ(s1, s2) (strcasecmp (s1, s2) == 0)
-#define FILESTRNCASEEQ(s1, s2, l) (strncasecmp (s1, s2, l) == 0)
-#define FILECHARCASEEQ(c1, c2) (toupper (c1) == toupper (c2))
-#else
-#define FILESTRCASEEQ STREQ
-#define FILESTRNCASEEQ STRNEQ
-#define FILECHARCASEEQ(c1, c2) ((c1) == (c2))
-#endif
-
 /* (Re)Allocate N items of type T using xmalloc/xrealloc.  */
 #define XTALLOC(n, t) ((t *) xmalloc ((n) * sizeof (t)))
 #define XTALLOC1(t) XTALLOC (1, t)
 #define XRETALLOC(addr, n, t) ((addr) = (t *) xrealloc (addr, (n) * sizeof(t)))
 
 extern "C" char *xbasename (const char *name);
 
 #ifndef WIN32
@@ -275,16 +259,22 @@ int dir_links (const char *fn);
 static void str_llist_add (str_llist_type *l, const std::string& str);
 
 static void str_llist_float (str_llist_type *l, str_llist_elt_type *mover);
 
 static std::string kpse_var_expand (const std::string& src);
 
 #include <ctime> /* for `time' */
 
+bool
+kpse_is_env_sep (char c)
+{
+  return IS_ENV_SEP (c);
+}
+
 /* xmalloc.c: malloc with error checking.  */
 
 static void *
 xmalloc (unsigned size)
 {
   void *new_mem = (void *) malloc (size);
 
   if (new_mem == NULL)
@@ -401,35 +391,26 @@ struct hash_element_type
 /* The usual arrangement of buckets initialized to null.  */
 
 struct hash_table_type
 {
   hash_element_type **buckets;
   unsigned size;
 };
 
-/* The hash function.  We go for simplicity here.  */
-
-/* All our hash tables are related to filenames.  */
-#ifdef MONOCASE_FILENAMES
-#define TRANSFORM(x) toupper (x)
-#else
-#define TRANSFORM(x) (x)
-#endif
-
 static unsigned
 hash (hash_table_type table, const std::string& key)
 {
   unsigned n = 0;
 
   /* Our keys aren't often anagrams of each other, so no point in
      weighting the characters.  */
   size_t len = key.length ();
   for (size_t i = 0; i < len; i++)
-    n = (n + n + TRANSFORM (key[i])) % table.size;
+    n = (n + n + key[i]) % table.size;
 
   return n;
 }
 
 static hash_table_type
 hash_create (unsigned size)
 {
   /* hash_table_type ret; changed into "static ..." to work around gcc
@@ -480,17 +461,17 @@ static string_vector
 hash_lookup (hash_table_type table, const std::string& key)
 {
   hash_element_type *p;
   string_vector ret;
   unsigned n = hash (table, key);
 
   /* Look at everything in this bucket.  */
   for (p = table.buckets[n]; p != NULL; p = p->next)
-    if (FILESTRCASEEQ (key.c_str (), p->key.c_str ()))
+    if (key == p->key)
       ret.append (p->value);
 
 #ifdef KPSE_DEBUG
   if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
     {
       DEBUGF1 ("hash_lookup (%s) =>", key.c_str ());
       if (ret.empty ())
         fputs (" (nil)\n", stderr);
@@ -817,64 +798,64 @@ dir_list_search (str_llist_type *dirs, c
 static string_vector
 absolute_search (const std::string& name)
 {
   string_vector ret_list;
   std::string found = kpse_readable_file (name);
 
   /* Add `found' to the return list even if it's null; that tells
      the caller we didn't find anything.  */
-  ret_list.append (std::string (found));
+  ret_list.append (found);
 
   return ret_list;
 }
 
 /* This is the hard case -- look for NAME in PATH.  If ALL is false,
    return the first file found.  Otherwise, search all elements of PATH.  */
 
 static string_vector
-path_search (const std::string& path_arg, const std::string& name,
+path_search (const std::string& path, const std::string& name,
 	     bool must_exist, bool all)
 {
-  char *elt;
   string_vector ret_list;
   bool done = false;
 
-  const char *path = path_arg.c_str ();
-
-  for (elt = kpse_path_element (path); !done && elt;
-       elt = kpse_path_element (NULL))
+  for (kpse_path_iterator pi (path); ! done && pi != NPOS; pi++)
     {
+      std::string elt = *pi;
+
       string_vector found;
       bool allow_disk_search = true;
 
-      if (*elt == '!' && *(elt + 1) == '!')
+      if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
 	{
 	  /* Those magic leading chars in a path element means don't
 	     search the disk for this elt.  And move past the magic to
 	     get to the name.  */
 	  allow_disk_search = false;
-	  elt += 2;
+	  elt = elt.substr (2);
 	}
 
       /* Do not touch the device if present */
       if (NAME_BEGINS_WITH_DEVICE (elt))
 	{
-	  while (IS_DIR_SEP (*(elt + 2)) && IS_DIR_SEP (*(elt + 3)))
+	  while (elt.length () > 3
+		 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
 	    {
-	      *(elt + 2) = *(elt + 1);
-	      *(elt + 1) = *elt;
-	      elt++;
+	      elt[2] = elt[1];
+	      elt[1] = elt[0];
+	      elt = elt.substr (1);
 	    }
 	}
       else
 	{
 	  /* We never want to search the whole disk.  */
-	  while (IS_DIR_SEP (*elt) && IS_DIR_SEP (*(elt + 1)))
-	    elt++;
+	  while (elt.length () > 1
+		 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
+	    elt = elt.substr (1);
 	}
 
       /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
 	 (search), also tests first_search, and does the resetting.  */
       found = first_search
 	? string_vector () : kpse_db_search (name, elt, all);
 
       /* Search the filesystem if (1) the path spec allows it, and either
@@ -982,59 +963,59 @@ kpse_all_path_search (const std::string&
   return search (path, name, true, true);
 }
 
 /* This is the hard case -- look in each element of PATH for each
    element of NAMES.  If ALL is false, return the first file found.
    Otherwise, search all elements of PATH.  */
 
 static string_vector
-path_find_first_of (const std::string& path_arg, const string_vector& names,
+path_find_first_of (const std::string& path, const string_vector& names,
 		    bool must_exist, bool all)
 {
-  char *elt;
   string_vector ret_list;
   bool done = false;
 
-  const char *path = path_arg.c_str ();
-
-  for (elt = kpse_path_element (path); !done && elt;
-       elt = kpse_path_element (NULL))
+  for (kpse_path_iterator pi (path); ! done && pi != NPOS; pi++)
     {
+      std::string elt = *pi;
+
       str_llist_type *dirs;
       str_llist_elt_type *dirs_elt;
       string_vector found;
       bool allow_disk_search = true;
 
-      if (*elt == '!' && *(elt + 1) == '!')
+      if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
 	{
 	  /* Those magic leading chars in a path element means don't
 	     search the disk for this elt.  And move past the magic to
 	     get to the name.  */
 
 	  allow_disk_search = false;
-	  elt += 2;
+	  elt = elt.substr (2);
 	}
 
       /* Do not touch the device if present */
 
       if (NAME_BEGINS_WITH_DEVICE (elt))
 	{
-	  while (IS_DIR_SEP (*(elt + 2)) && IS_DIR_SEP (*(elt + 3)))
+	  while (elt.length () > 3
+		 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
 	    {
-	      *(elt + 2) = *(elt + 1);
-	      *(elt + 1) = *elt;
-	      elt++;
+	      elt[2] = elt[1];
+	      elt[1] = elt[0];
+	      elt = elt.substr (1);
 	    }
 	}
       else
 	{
 	  /* We never want to search the whole disk.  */
-	  while (IS_DIR_SEP (*elt) && IS_DIR_SEP (*(elt + 1)))
-	    elt++;
+	  while (elt.length () > 1
+		 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
+	    elt = elt.substr (1);
 	}
 
       /* We have to search one directory at a time.  */
       dirs = kpse_element_dirs (elt);
       for (dirs_elt = *dirs; dirs_elt; dirs_elt = STR_LLIST_NEXT (*dirs_elt))
 	{
 	  const std::string dir = STR_LLIST (*dirs_elt);
 
@@ -1281,199 +1262,205 @@ kpse_tilde_expand (const std::string& na
 std::string
 kpse_expand (const std::string& s)
 {
   std::string var_expansion = kpse_var_expand (s);
   return kpse_tilde_expand (var_expansion);
 }
 
 /* Forward declarations of functions from the original expand.c  */
-static char **brace_expand (const char *);
+static char **brace_expand (const std::string&);
 static void free_array (char **);
 
 /* If $KPSE_DOT is defined in the environment, prepend it to any relative
    path components. */
 
 static std::string
 kpse_expand_kpse_dot (const std::string& path)
 {
   std::string ret;
-  char *elt;
   std::string kpse_dot = octave_env::getenv ("KPSE_DOT");
 
   if (kpse_dot.empty ())
     return path;
 
-  char *tmp = xstrdup (path.c_str ());
-
-  for (elt = kpse_path_element (tmp); elt; elt = kpse_path_element (NULL))
+  for (kpse_path_iterator pi (path); pi != NPOS; pi++)
     {
+      std::string elt = *pi;
+
       /* We assume that the !! magic is only used on absolute components.
 	 Single "." get special treatment, as does "./" or its  equivalent.  */
 
-      if (kpse_absolute_p (elt, false) || (elt[0] == '!' && elt[1] == '!'))
-	ret += std::string (elt) + ENV_SEP_STRING;
-      else if (elt[0] == '.' && elt[1] == 0)
-	ret += std::string (kpse_dot) + ENV_SEP_STRING;
-      else if (elt[0] == '.' && IS_DIR_SEP (elt[1]))
-	ret += std::string (kpse_dot) + (elt + 1) + ENV_SEP_STRING;
+      size_t elt_len = elt.length ();
+
+      if (kpse_absolute_p (elt, false)
+	  || (elt_len > 1 && elt[0] == '!' && elt[1] == '!'))
+	ret += elt + ENV_SEP_STRING;
+      else if (elt_len == 1 && elt[0] == '.')
+	ret += kpse_dot + ENV_SEP_STRING;
+      else if (elt_len > 1 && elt[0] == '.' && IS_DIR_SEP (elt[1]))
+	ret += kpse_dot + elt.substr (1) + ENV_SEP_STRING;
       else
-	ret += std::string (kpse_dot) + DIR_SEP_STRING + elt + ENV_SEP_STRING;
+	ret += kpse_dot + DIR_SEP_STRING + elt + ENV_SEP_STRING;
     }
 
   int len = ret.length ();
 
   if (len > 0)
     ret.resize (len - 1);
 
   return ret;
 }
 
 /* Do brace expansion on ELT; then do variable and ~ expansion on each
    element of the result; then do brace expansion again, in case a
    variable definition contained braces (e.g., $TEXMF).  Return a
    string comprising all of the results separated by ENV_SEP_STRING.  */
 
 static std::string
-kpse_brace_expand_element (const char *elt)
+kpse_brace_expand_element (const std::string& elt)
 {
   unsigned i;
   char **expansions = brace_expand (elt);
   std::string ret;
 
   for (i = 0; expansions[i]; i++)
     {
       /* Do $ and ~ expansion on each element.  */
       std::string x = kpse_expand (expansions[i]);
 
       if (x != expansions[i])
 	{
 	  /* If we did any expansions, do brace expansion again.  Since
 	     recursive variable definitions are not allowed, this recursion
 	     must terminate.  (In practice, it's unlikely there will ever be
 	     more than one level of recursion.)  */
-	  x = kpse_brace_expand_element (x.c_str ());
+	  x = kpse_brace_expand_element (x);
 	}
 
       ret += x + ENV_SEP_STRING;
     }
 
   free_array (expansions);
 
   ret.resize (ret.length () - 1);
 
   return ret;
 }
 
 /* Be careful to not waste all the memory we allocate for each element.  */
 
 std::string
-kpse_brace_expand (const char *path)
+kpse_brace_expand (const std::string& path_arg)
 {
-  char *elt;
-  unsigned len;
+  const char *path = path_arg.c_str ();
+
   /* Must do variable expansion first because if we have
        foo = .:~
        TEXINPUTS = $foo
      we want to end up with TEXINPUTS = .:/home/karl.
      Since kpse_path_element is not reentrant, we must get all
      the path elements before we start the loop.  */
   std::string tmp = kpse_var_expand (path);
-  const char *xpath = tmp.c_str ();
+
   std::string ret;
 
-  for (elt = kpse_path_element (xpath); elt; elt = kpse_path_element (NULL))
+  for (kpse_path_iterator pi (tmp); pi != NPOS; pi++)
     {
+      std::string elt = *pi;
+
       /* Do brace expansion first, so tilde expansion happens in {~ka,~kb}.  */
       std::string expansion = kpse_brace_expand_element (elt);
       ret += expansion + ENV_SEP_STRING;
     }
 
   /* Waste the last byte by overwriting the trailing env_sep with a null.  */
-  len = ret.length ();
+  size_t len = ret.length ();
 
   if (len > 0)
     ret.resize (len - 1);
 
   return kpse_expand_kpse_dot (ret);
 }
 
 /* Expand all special constructs in a path, and include only the actually
    existing directories in the result. */
 std::string
 kpse_path_expand (const std::string& path_arg)
 {
   std::string ret;
-  char *elt;
   unsigned len;
 
   const char *path = path_arg.c_str ();
 
   len = 0;
 
   /* Expand variables and braces first.  */
   std::string tmp = kpse_brace_expand (path);
 
-  const char *xpath = tmp.c_str ();
-
   /* Now expand each of the path elements, printing the results */
-  for (elt = kpse_path_element (xpath); elt; elt = kpse_path_element (NULL))
+  for (kpse_path_iterator pi (tmp); pi != NPOS; pi++)
     {
+      std::string elt = *pi;
+
       str_llist_type *dirs;
 
       /* Skip and ignore magic leading chars.  */
-      if (*elt == '!' && *(elt + 1) == '!')
-	elt += 2;
+      if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
+	elt = elt.substr (2);
 
       /* Do not touch the device if present */
       if (NAME_BEGINS_WITH_DEVICE (elt))
 	{
-	  while (IS_DIR_SEP (*(elt + 2)) && IS_DIR_SEP (*(elt + 3)))
+	  while (elt.length () > 3
+		 && IS_DIR_SEP (elt[2]) && IS_DIR_SEP (elt[3]))
 	    {
-	      *(elt + 2) = *(elt + 1);
-	      *(elt + 1) = *elt;
-	      elt++;
+	      elt[2] = elt[1];
+	      elt[1] = elt[0];
+	      elt = elt.substr (1);
 	    }
 	}
       else
 	{
 	  /* We never want to search the whole disk.  */
-	  while (IS_DIR_SEP (*elt) && IS_DIR_SEP (*(elt + 1)))
-	    elt++;
+	  while (elt.length () > 1
+		 && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
+	    elt = elt.substr (1);
 	}
 
-    /* Search the disk for all dirs in the component specified.
-       Be faster to check the database, but this is more reliable.  */
-    dirs = kpse_element_dirs (elt);
-
-    if (dirs && *dirs)
-      {
-	str_llist_elt_type *dir;
-
-	for (dir = *dirs; dir; dir = STR_LLIST_NEXT (*dir))
-	  {
-	    const std::string thedir = STR_LLIST (*dir);
-	    unsigned dirlen = thedir.length ();
-
-	    /* Retain trailing slash if that's the root directory.  */
-	    if (dirlen == 1 || (dirlen == 3 && NAME_BEGINS_WITH_DEVICE (thedir)
-				&& IS_DIR_SEP (thedir[2])))
-	      {
-		ret += thedir + ENV_SEP_STRING;
-		len += dirlen + 1;
-		ret[len - 1] = ENV_SEP;
-	      }
-	    else
-	      {
-		ret += thedir;
-		len += dirlen;
-		ret [len - 1] = ENV_SEP;
-	      }
-	  }
-      }
+      /* Search the disk for all dirs in the component specified.
+	 Be faster to check the database, but this is more reliable.  */
+      dirs = kpse_element_dirs (elt);
+
+      if (dirs && *dirs)
+	{
+	  str_llist_elt_type *dir;
+
+	  for (dir = *dirs; dir; dir = STR_LLIST_NEXT (*dir))
+	    {
+	      const std::string thedir = STR_LLIST (*dir);
+	      unsigned dirlen = thedir.length ();
+
+	      /* Retain trailing slash if that's the root directory.  */
+	      if (dirlen == 1
+		  || (dirlen == 3 && NAME_BEGINS_WITH_DEVICE (thedir)
+		      && IS_DIR_SEP (thedir[2])))
+		{
+		  ret += thedir + ENV_SEP_STRING;
+		  len += dirlen + 1;
+		  ret[len - 1] = ENV_SEP;
+		}
+	      else
+		{
+		  ret += thedir;
+		  len += dirlen;
+		  ret [len - 1] = ENV_SEP;
+		}
+	    }
+	}
     }
 
   /* Get rid of trailing ':', if any. */
   if (len != 0)
     ret[len - 1] = 0;
 
   return ret;
 }
@@ -1553,24 +1540,26 @@ copy_array (char **array)
     new_array[i] = xstrdup (array[i]);
   new_array[i] = (char *)NULL;
 
   return (new_array);
 }
 
 /* Return an array of strings; the brace expansion of TEXT. */
 static char **
-brace_expand (const char *text)
+brace_expand (const std::string& text_arg)
 {
   register int start;
   char *preamble, *amble;
   const char *postamble;
   char **tack, **result;
   int i, c;
 
+  const char *text = text_arg.c_str ();
+
   /* Find the text of the preamble. */
   i = 0;
   c = brace_gobbler (text, &i, '{');
 
   preamble = (char *) xmalloc (i + 1);
   strncpy (preamble, text, i);
   preamble[i] = 0;
 
@@ -1804,18 +1793,17 @@ typedef struct
   std::string type;	     /* Human-readable description.  */
   std::string path;	     /* The search path to use.  */
   std::string raw_path;	     /* Pre-$~ (but post-default) expansion.  */
   std::string path_source;   /* Where the path started from.  */
   std::string override_path; /* From client environment variable.  */
   std::string client_path;   /* E.g., from dvips's config.ps.  */
   std::string cnf_path;	     /* From texmf.cnf.  */
   std::string default_path;  /* If all else fails.  */
-  const char **suffix;	     /* For kpse_find_file to check for/append.  */
-  const char **alt_suffix;   /* More suffixes to check for.  */
+  string_vector suffix;	     /* For kpse_find_file to check for/append.  */
   bool suffix_search_only;   /* Only search with a suffix?  */
   std::string program;	     /* ``mktexpk'', etc.  */
   std::string program_args;  /* Args to `program'.  */
   bool program_enabled_p;    /* Invoke `program'?  */
   kpse_src_type program_enable_level; /* Who said to invoke `program'.  */
   bool binmode;		     /* The files must be opened in binary mode. */
 } kpse_format_info_type;
 
@@ -1826,17 +1814,17 @@ static kpse_format_info_type kpse_format
 #define DB_ENVS "TEXMFDBS"
 
 /* And EXPAND_DEFAULT calls kpse_expand_default on try_path and the
    present info->path.  */
 #define EXPAND_DEFAULT(try_path, source_string)			\
   if (! try_path.empty ())					\
     {								\
       info->raw_path = try_path;				\
-      info->path = kpse_expand_default (try_path.c_str (), (info->path).c_str ());	\
+      info->path = kpse_expand_default (try_path, info->path);	\
       info->path_source = source_string;			\
     }
 
 /* Find the final search path to use for the format entry INFO, given
    the compile-time default (DEFAULT_PATH), and the environment
    variables to check (the remaining arguments, terminated with NULL).
    We set the `path' and `path_source' members of INFO.  The
    `client_path' member must already be set upon entry.  */
@@ -1893,43 +1881,20 @@ init_path (kpse_format_info_type *info, 
 
   if (var)
     {
       std::string val = octave_env::getenv (var);
       EXPAND_DEFAULT (val, concat (var, " environment variable"));
     }
 
   EXPAND_DEFAULT (info->override_path, "application override variable");
-  std::string tmp = kpse_brace_expand ((info->path).c_str ());
+  std::string tmp = kpse_brace_expand (info->path);
   info->path = tmp;
 }
 
-/* Some file types have more than one suffix.  */
-
-static void
-add_suffixes (const char ***list, ...)
-{
-  const char *s;
-  unsigned count = 0;
-  va_list ap;
-
-  va_start (ap, list);
-
-  while ((s = va_arg (ap, char *)) != NULL)
-    {
-      count++;
-      XRETALLOC (*list, count + 1, const char *);
-      (*list)[count - 1] = s;
-    }
-
-  va_end (ap);
-
-  (*list)[count] = NULL;
-}
-
 static std::string
 remove_dbonly (const std::string& path)
 {
   std::string ret = path;
   size_t path_len = path.length ();
 
   size_t i = 0, j = 0;
 
@@ -1957,17 +1922,17 @@ static std::string
 kpse_init_format (void)
 {
   /* If we get called twice, don't redo all the work.  */
   if (! kpse_format_info.path.empty ())
     return kpse_format_info.path;
 
   kpse_format_info.type = "ls-R";
   init_path (&kpse_format_info, DEFAULT_TEXMFDBS, DB_ENVS, NULL);
-  add_suffixes (&kpse_format_info.suffix, "ls-R", NULL);
+  kpse_format_info.suffix.append (std::string ("ls-R"));
   kpse_format_info.path = remove_dbonly (kpse_format_info.path);
 
 #ifdef KPSE_DEBUG
 #define MAYBE(member) \
   (kpse_format_info.member.empty () \
     ? "(none)" : kpse_format_info.member.c_str ())
 
   /* Describe the monster we've created.  */
@@ -1987,46 +1952,33 @@ kpse_init_format (void)
       DEBUGF1 ("  application config file path = %s\n", MAYBE (client_path));
 
       DEBUGF1 ("  texmf.cnf path = %s\n", MAYBE (cnf_path));
 
       DEBUGF1 ("  compile-time path = %s\n", MAYBE (default_path));
 
       DEBUGF  ("  default suffixes =");
 
-      if (kpse_format_info.suffix)
+      if (! kpse_format_info.suffix.empty ())
 	{
-	  const char **ext;
-	  for (ext = kpse_format_info.suffix; ext && *ext; ext++)
+	  string_vector tmp = kpse_format_info.suffix;
+	  int len = tmp.length ();
+	  for (int i = 0; i < len; i++)
 	    {
-	      fprintf (stderr, " %s", *ext);
+	      fprintf (stderr, " %s", tmp[i].c_str ());
 	    }
 	  putc ('\n', stderr);
 	}
       else
 	{
 	  fputs (" (none)\n", stderr);
 	}
 
       DEBUGF  ("  other suffixes =");
 
-      if (kpse_format_info.alt_suffix)
-	{
-	  const char **alt;
-	  for (alt = kpse_format_info.alt_suffix; alt && *alt; alt++)
-	    {
-	      fprintf (stderr, " %s", *alt);
-	    }
-	  putc ('\n', stderr);
-	}
-      else
-	{
-	  fputs (" (none)\n", stderr);
-	}
-
       DEBUGF1 ("  search only with suffix = %d\n",
 	       kpse_format_info.suffix_search_only);
 
       DEBUGF1 ("  runtime generation program = %s\n", MAYBE (program));
 
       DEBUGF1 ("  extra program args = %s\n", MAYBE (program_args));
 
       DEBUGF1 ("  program enabled = %d\n",
@@ -2193,17 +2145,17 @@ db_build (hash_table_type *table, const 
 
       if (file_count == 0)
 	{
 	  WARNING1 ("kpathsea: No usable entries in %s", db_filename.c_str ());
 	  WARNING ("kpathsea: See the manual for how to generate ls-R");
 	  db_file = NULL;
 	}
       else
-	db_dir_list.append (std::string (top_dir));
+	db_dir_list.append (top_dir);
 
 #ifdef KPSE_DEBUG
       if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
 	{
 	  /* Don't make this a debugging bit, since the output is so
 	     voluminous, and being able to specify -1 is too useful.
 	     Instead, let people who want it run the program under
 	     a debugger and change the variable that way.  */
@@ -2223,24 +2175,24 @@ db_build (hash_table_type *table, const 
   return db_file != NULL;
 }
 
 /* Insert FNAME into the hash table.  This is for files that get built
    during a run.  We wouldn't want to reread all of ls-R, even if it got
    rebuilt.  */
 
 void
-kpse_db_insert (const char *passed_fname)
+kpse_db_insert (const std::string& passed_fname)
 {
   /* We might not have found ls-R, or even had occasion to look for it
      yet, so do nothing if we have no hash table.  */
   if (db.buckets)
     {
       const char *dir_part;
-      char *fname = xstrdup (passed_fname);
+      char *fname = xstrdup (passed_fname.c_str ());
       char *baseptr = xbasename (fname);
       const char *file_part = xstrdup (baseptr);
 
       *baseptr = '\0';  /* Chop off the filename.  */
       dir_part = fname; /* That leaves the dir, with the trailing /.  */
 
       hash_insert (&db, file_part, dir_part);
     }
@@ -2256,17 +2208,17 @@ match (const std::string& filename_arg, 
   const char *filename = filename_arg.c_str ();
   const char *path_elt = path_elt_arg.c_str ();
 
   const char *original_filename = filename;
   bool matched = false;
 
   for (; *filename && *path_elt; filename++, path_elt++)
     {
-      if (FILECHARCASEEQ (*filename, *path_elt)) /* normal character match */
+      if (*filename == *path_elt) /* normal character match */
 	;
 
       else if (IS_DIR_SEP (*path_elt)  /* at // */
 	       && original_filename < filename && IS_DIR_SEP (path_elt[-1]))
 	{
 	  while (IS_DIR_SEP (*path_elt))
 	    path_elt++; /* get past second and any subsequent /'s */
 
@@ -2279,18 +2231,17 @@ match (const std::string& filename_arg, 
 	      break;
 	    }
 	  else
 	    {
 	      /* Intermediate //, have to match rest of PATH_ELT.  */
 	      for (; !matched && *filename; filename++)
 		{
 		  /* Try matching at each possible character.  */
-		  if (IS_DIR_SEP (filename[-1])
-		      && FILECHARCASEEQ (*filename, *path_elt))
+		  if (IS_DIR_SEP (filename[-1]) && *filename == *path_elt)
 		    matched = match (filename, path_elt);
 		}
 
 	      /* Prevent filename++ when *filename='\0'. */
 	      break;
 	    }
 	}
       else
@@ -2337,17 +2288,17 @@ elt_in_db (const std::string& db_dir, co
 {
   bool found = false;
 
   size_t db_dir_len = db_dir.length ();
   size_t path_elt_len = path_elt.length ();
 
   size_t i = 0;
 
-  while (! found && FILECHARCASEEQ (db_dir[i], path_elt[i]))
+  while (! found && db_dir[i] == path_elt[i])
     {
       i++;
       /* If we've matched the entire db directory, it's good.  */
       if (i == db_dir_len)
 	found = true;
 
     /* If we've reached the end of PATH_ELT, but not the end of the db
        directory, it's no good.  */
@@ -2487,58 +2438,52 @@ kpse_init_db (void)
       alias_db.buckets = NULL;
     }
 }
 
 /* Avoid doing anything if this PATH_ELT is irrelevant to the databases. */
 
 string_vector
 kpse_db_search (const std::string& name_arg,
-		const std::string& orig_path_elt_arg, bool all)
+		const std::string& orig_path_elt, bool all)
 {
-  const char *last_slash;
-  char *path_elt;
   bool done;
   string_vector ret;
   string_vector aliases;
   bool relevant = false;
 
-  const char *name = name_arg.c_str ();
-  const char *orig_path_elt = orig_path_elt_arg.c_str ();
+  std::string name = name_arg;
 
   /* If we failed to build the database (or if this is the recursive
      call to build the db path), quit.  */
   if (db.buckets == NULL)
     return ret;
 
   /* When tex-glyph.c calls us looking for, e.g., dpi600/cmr10.pk, we
      won't find it unless we change NAME to just `cmr10.pk' and append
      `/dpi600' to PATH_ELT.  We are justified in using a literal `/'
      here, since that's what tex-glyph.c unconditionally uses in
      DPI_BITMAP_SPEC.  But don't do anything if the / begins NAME; that
      should never happen.  */
-  last_slash = strrchr (name, '/');
-  if (last_slash && last_slash != name)
+  std::string path_elt;
+  size_t last_slash = name.rfind ('/');
+  if (last_slash != NPOS && last_slash != 0)
     {
-      unsigned len = last_slash - name + 1;
-      char *dir_part = (char *) xmalloc (len);
-      strncpy (dir_part, name, len - 1);
-      dir_part[len - 1] = 0;
-      path_elt = concat3 (orig_path_elt, "/", dir_part);
-      name = last_slash + 1;
+      std::string dir_part = name.substr (0, last_slash);
+      name = name.substr (last_slash + 1);
     }
   else
-    path_elt = (char *) orig_path_elt;
+    path_elt = orig_path_elt;
 
   /* Don't bother doing any lookups if this `path_elt' isn't covered by
      any of database directories.  We do this not so much because the
      extra couple of hash lookups matter -- they don't -- but rather
      because we want to return NULL in this case, so path_search can
      know to do a disk search.  */
-  for (int e = 0; !relevant && e < db_dir_list.length (); e++)
+  for (int e = 0; ! relevant && e < db_dir_list.length (); e++)
     relevant = elt_in_db (db_dir_list[e], path_elt);
 
   if (! relevant)
     return ret;
 
   /* If we have aliases for this name, use them.  */
   if (alias_db.buckets)
     aliases = hash_lookup (alias_db, name);
@@ -2566,17 +2511,17 @@ kpse_db_search (const std::string& name_
       int db_dirs_len = db_dirs.length ();
       for (int j = 0; j < db_dirs_len && !done; j++)
 	{
 	  std::string db_file = db_dirs[j] + atry;
 	  bool matched = match (db_file, path_elt);
 
 #ifdef KPSE_DEBUG
 	  if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-	    DEBUGF3 ("db:match (%s,%s) = %d\n", db_file.c_str (), path_elt, matched);
+	    DEBUGF3 ("db:match (%s,%s) = %d\n", db_file.c_str (), path_elt.c_str (), matched);
 #endif
 
 	  /* We got a hit in the database.  Now see if the file actually
 	     exists, possibly under an alias.  */
 	  if (matched)
 	    {
 	      std::string found;
 	      std::string tmp = kpse_readable_file (db_file);
@@ -2610,75 +2555,64 @@ kpse_db_search (const std::string& name_
 
 		  if (! (all || found.empty ()))
 		    done = true;
 		}
 	    }
 	}
     }
 
-  /* If we had to break up NAME, free the temporary PATH_ELT.  */
-  if (path_elt != orig_path_elt)
-    free (path_elt);
-
   return ret;
 }
 
 /* kdefault.c: Expand extra colons.  */
 
 /* Check for leading colon first, then trailing, then doubled, since
    that is fastest.  Usually it will be leading or trailing.  */
 
-char *
-kpse_expand_default (const char *path, const char *fallback)
+std::string
+kpse_expand_default (const std::string& path, const std::string& fallback)
 {
-  unsigned path_length;
-  char *expansion;
-
-  /* The default path better not be null.  */
-  assert (fallback);
-
-  if (path == NULL)
-    expansion = xstrdup (fallback);
+  std::string expansion;
+
+  size_t path_len = path.length ();
+
+  if (path_len == 0)
+    expansion = fallback;
 
   /* Solitary or leading :?  */
-  else if (IS_ENV_SEP (*path))
+  else if (IS_ENV_SEP (path[0]))
     {
-      expansion = path[1] == 0 ? xstrdup (fallback) : concat (fallback, path);
+      expansion = path_len == 1 ? fallback : fallback + path;
     }
 
   /* Sorry about the assignment in the middle of the expression, but
      conventions were made to be flouted and all that.  I don't see the
      point of calling strlen twice or complicating the logic just to
      avoid the assignment (especially now that I've pointed it out at
      such great length).  */
-  else if (path[(path_length = strlen (path)) - 1] == ENV_SEP)
-    expansion = concat (path, fallback);
+  else if (IS_ENV_SEP (path[path_len-1]))
+    expansion = path + fallback;
 
   /* OK, not leading or trailing.  Check for doubled.  */
   else
     {
-      const char *loc;
-
       /* What we'll return if we find none.  */
-      expansion = xstrdup (path);
-
-      for (loc = path; *loc; loc++)
+      expansion = path;
+
+      for (size_t i = 0; i < path_len; i++)
         {
-          if (IS_ENV_SEP (loc[0]) && IS_ENV_SEP (loc[1]))
-            { /* We have a doubled colon.  */
-              expansion = (char *) xmalloc (path_length + strlen (fallback) + 1);
+          if (i + 1 < path_len
+	      && IS_ENV_SEP (path[i]) && IS_ENV_SEP (path[i+1]))
+            {
+	      /* We have a doubled colon.  */
 
               /* Copy stuff up to and including the first colon.  */
-              strncpy (expansion, path, loc - path + 1);
-              expansion[loc - path + 1] = 0;
-
               /* Copy in FALLBACK, and then the rest of PATH.  */
-              strcat (expansion, fallback);
-              strcat (expansion, loc + 1);
+	      expansion = path.substr (0, i+1) + fallback + path.substr (i+1);
 
 	      break;
             }
         }
     }
 
   return expansion;
 }
@@ -2762,17 +2696,17 @@ cache (const char *key, str_llist_type *
 
 static str_llist_type *
 cached (const char *key)
 {
   unsigned p;
 
   for (p = 0; p < cache_length; p++)
     {
-      if (FILESTRCASEEQ (the_cache[p].key, key))
+      if (! strcmp (the_cache[p].key, key))
         return the_cache[p].value;
     }
 
   return NULL;
 }
 
 /* Handle the magic path constructs.  */
 
@@ -2949,18 +2883,20 @@ expand_elt (str_llist_type *str_list_ptr
 
   /* When we reach the end of ELT, it will be a normal filename.  */
   checked_dir_list_add (str_list_ptr, elt);
 }
 
 /* Here is the entry point.  Returns directory list for ELT.  */
 
 str_llist_type *
-kpse_element_dirs (const char *elt)
+kpse_element_dirs (const std::string& elt_arg)
 {
+  const char *elt = elt_arg.c_str ();
+
   str_llist_type *ret;
 
   /* If given nothing, return nothing.  */
   if (! elt || !*elt)
     return NULL;
 
   /* If we've already cached the answer for ELT, return it.  */
   ret = cached (elt);
@@ -2991,88 +2927,16 @@ kpse_element_dirs (const char *elt)
       putc ('\n', stderr);
       fflush (stderr);
     }
 #endif /* KPSE_DEBUG */
 
   return ret;
 }
 
-/* path-elt.c: Return the stuff between colons.  */
-
-/* The static (but dynamically allocated) area we return the answer in,
-   and how much we've currently allocated for it.  */
-static char *elt = NULL;
-static unsigned elt_alloc = 0;
-
-/* The path we're currently working on.  */
-static const char *path = NULL;
-
-/* Upon entry, the static `path' is at the first (and perhaps last)
-   character of the return value, or else NULL if we're at the end (or
-   haven't been called).  I make no provision for caching the results;
-   thus, we parse the same path over and over, on every lookup.  If that
-   turns out to be a significant lose, it can be fixed, but I'm guessing
-   disk accesses overwhelm everything else.  If ENV_P is true, use
-   IS_ENV_SEP; else use IS_DIR_SEP.  */
-
-char *
-kpse_path_element (const char *passed_path)
-{
-  const char *p;
-  char *ret;
-  int brace_level;
-  unsigned len;
-
-  if (passed_path)
-    path = passed_path;
-  /* Check if called with NULL, and no previous path (perhaps we reached
-     the end).  */
-  else if (! path)
-    return NULL;
-
-  /* OK, we have a non-null `path' if we get here.  */
-  assert (path);
-  p = path;
-
-  /* Find the next colon not enclosed by braces (or the end of the path).  */
-  brace_level = 0;
-  while (*p != 0  && ! (brace_level == 0 && IS_ENV_SEP (*p)))
-    {
-      if (*p == '{')
-	++brace_level;
-      else if (*p == '}')
-	--brace_level;
-
-      ++p;
-    }
-
-  /* Return the substring starting at `path'.  */
-  len = p - path;
-
-  /* Make sure we have enough space (including the null byte).  */
-  if (len + 1 > elt_alloc)
-    {
-      elt_alloc = len + 1;
-      elt = (char *) xrealloc (elt, elt_alloc);
-    }
-
-  strncpy (elt, path, len);
-  elt[len] = 0;
-  ret = elt;
-
-  /* If we are at the end, return NULL next time.  */
-  if (path[len] == 0)
-    path = NULL;
-  else
-    path += len + 1;
-
-  return ret;
-}
-
 #ifndef WIN32
 void
 xclosedir (DIR *d)
 {
 #ifdef CLOSEDIR_VOID
   closedir (d);
 #else
   int ret = closedir (d);
diff --git a/liboctave/kpse.h b/liboctave/kpse.h
--- a/liboctave/kpse.h
+++ b/liboctave/kpse.h
@@ -35,39 +35,83 @@ struct str_llist_elt
 };
 typedef struct str_llist_elt str_llist_elt_type;
 typedef struct str_llist_elt *str_llist_type;
 
 #define STR_LLIST(sl) ((sl).str)
 #define STR_LLIST_MOVED(sl) ((sl).moved)
 #define STR_LLIST_NEXT(sl) ((sl).next)
 
-/* If PATH is non-null, return its first element (as defined by
-   IS_ENV_SEP).  If it's NULL, return the next element in the previous
-   path, a la strtok.  Leading, trailing, or doubled colons result in
-   the empty string.  When at the end of PATH, return NULL.  In any
-   case, return a pointer to an area that may be overwritten on
-   subsequent calls.  */
-extern char *kpse_path_element (const char *path);
+extern bool kpse_is_env_sep (char c);
+
+class kpse_path_iterator
+{
+public:
+
+  kpse_path_iterator (const std::string& p)
+    : path (p), b (0), e (0), len (path.length ()) { set_end (); }
+
+  kpse_path_iterator (const kpse_path_iterator& pi)
+    : path (pi.path), b (pi.b), e (pi.e), len (pi.len) { }
+
+  kpse_path_iterator operator ++ (int)
+    {
+      kpse_path_iterator retval (*this);
+      next ();
+      return retval;
+    }
+
+  std::string operator * (void) { return path.substr (b, e-b); }
+
+  bool operator != (const size_t sz) { return b != sz; }
+
+private:
 
-/* Like `kpse_path_element', but for filename components (using
-   IS_DIR_SEP).  Uses same area as `kpse_path_element'.  */
-extern char *kpse_filename_component (const char *path);
+  const std::string& path;
+  size_t b;
+  size_t e;
+  size_t len;
+
+  void set_end (void)
+    {
+      e = b + 1;
+
+      if (e >= len)
+	b = e = NPOS;
+      else
+	{
+	  /* Find the next colon not enclosed by braces (or the end of
+	     the path).  */
 
+	  int brace_level = 0;
+	  while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
+	    e++;
+	}
+    }
+
+  void next (void)
+    {
+      b = e + 1;
+
+      if (b >= len)
+	b = e = NPOS;
+      else
+	set_end ();
+    }
+};
 
 /* Given a path element ELT, return a pointer to a NULL-terminated list
    of the corresponding (existing) directory or directories, with
    trailing slashes, or NULL.  If ELT is the empty string, check the
    current working directory.
    
    It's up to the caller to expand ELT.  This is because this routine is
    most likely only useful to be called from `kpse_path_search', which
    has already assumed expansion has been done.  */
-extern str_llist_type *kpse_element_dirs (const char *elt);
-
+extern str_llist_type *kpse_element_dirs (const std::string& elt);
 
 /* Call `kpse_expand' on NAME.  If the result is an absolute or
    explicitly relative filename, check whether it is a readable
    (regular) file.
    
    Otherwise, look in each of the directories specified in PATH (also do
    tilde and variable expansion on elements in PATH), using a prebuilt
    db (see db.h) if it's relevant for a given path element.
@@ -80,17 +124,16 @@ extern str_llist_type *kpse_element_dirs
    The caller must expand PATH. This is because it makes more sense to
    do this once, in advance, instead of for every search using it.
    
    In any case, return the complete filename if found, otherwise NULL.  */
 extern std::string kpse_path_search (const std::string& path,
 				     const std::string& name,
 				     bool must_exist);
 
-
 /* Like `kpse_path_search' with MUST_EXIST true, but return a list of
    all the filenames (or NULL if none), instead of taking the first.  */
 extern string_vector kpse_all_path_search (const std::string& path,
 					   const std::string&  name);
 
 /* Search each element of PATH for each element in the list of NAMES.
    Return the first one found.  */
 extern std::string kpse_path_find_first_of (const std::string& path,
@@ -109,31 +152,32 @@ extern string_vector kpse_all_path_find_
    is always in fresh memory, even if no expansions were done.  */
 extern std::string kpse_expand (const std::string& s);
 
 /* Do brace expansion and call `kpse_expand' on each element of the
    result; return the final expansion (always in fresh memory, even if
    no expansions were done).  We don't call `kpse_expand_default'
    because there is a whole sequence of defaults to run through; see
    `kpse_init_format'.  */
-extern std::string kpse_brace_expand (const char *path);
+extern std::string kpse_brace_expand (const std::string& path);
 
 /* Do brace expansion and call `kpse_expand' on each argument of the
    result, then expand any `//' constructs.  The final expansion (always
    in fresh memory) is a path of all the existing directories that match
    the pattern. */
 extern std::string kpse_path_expand (const std::string& path);
 
 /* default.h: Declare default path expander.  */
 
 /* Replace a leading or trailing or doubled : in PATH with DFLT.  If
    no extra colons, return PATH.  Only one extra colon is replaced.
    DFLT may not be NULL.  */
 
-extern char *kpse_expand_default (const char *path, const char *dflt);
+extern std::string kpse_expand_default (const std::string& path,
+					const std::string& dflt);
 
 /* db.h: lookups in an externally built db file.  */
 
 /* Initialize the database.  Until this is called, no ls-R matches will
    be found.  */
 extern void kpse_init_db (void);
 
 /* Return list of matches for NAME in the ls-R file matching PATH_ELT.  If
@@ -141,14 +185,14 @@ extern void kpse_init_db (void);
    the first.  If no matches, return a pointer to an empty list.  If no
    databases can be read, or PATH_ELT is not in any of the databases,
    return NULL.  */
 extern string_vector kpse_db_search (const std::string& name,
 				     const std::string& path_elt, bool all);
 
 /* Insert the filename FNAME into the database.
    Called by mktexpk et al.  */
-extern void kpse_db_insert (const char *fname);
+extern void kpse_db_insert (const std::string& fname);
 
 extern unsigned int kpathsea_debug;
 
 #endif /* not KPATHSEA_PATHSEARCH_H */
 
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -55,18 +55,17 @@ dir_path::all_directories (void)
       int len = pv.length ();
 
       int nmax = len > 32 ? len : 32;
 
       retval.resize (len);
 
       for (int i = 0; i < len; i++)
 	{
-	  str_llist_type *elt_dirs
-	    = kpse_element_dirs (pv[i].c_str ());
+	  str_llist_type *elt_dirs = kpse_element_dirs (pv[i]);
 
 	  if (elt_dirs)
 	    {
 	      str_llist_elt_type *dir;
 
 	      for (dir = *elt_dirs; dir; dir = STR_LLIST_NEXT (*dir))
 		{
 		  const std::string elt_dir = STR_LLIST (*dir);
@@ -116,53 +115,45 @@ dir_path::find_all_first_of (const strin
     ? kpse_all_path_find_first_of (p, names) : string_vector ();
 }
 
 void
 dir_path::init (void)
 {
   if (! octave_kpathsea_initialized)
     {
-      char *s = getenv ("KPATHSEA_DEBUG");
+      std::string val = octave_env::getenv ("KPATHSEA_DEBUG");
 
-      if (s)
-	kpathsea_debug |= atoi (s);
+      if (! val.empty ())
+	kpathsea_debug |= atoi (val.c_str ());
 
       octave_kpathsea_initialized = true;
     }
 
   if (p_default.empty ())
     p = kpse_path_expand (p_orig);
   else
     {
-      char *t2
-	= kpse_expand_default (p_orig.c_str (), p_default.c_str ());
+      std::string s = kpse_expand_default (p_orig, p_default);
 
-      p = kpse_path_expand (t2);
-
-      if (t2)
-	free (t2);
+      p = kpse_path_expand (s);
     }
 
   int count = 0;
-  char *path_elt = kpse_path_element (p.c_str ());
-  while (path_elt)
-    {
-      path_elt = kpse_path_element (0);
-      count++;
-    }
+  for (kpse_path_iterator pi (p); pi != NPOS; pi++)
+    count++;
 
   pv.resize (count);
 
-  path_elt = kpse_path_element (p.c_str ());
+  kpse_path_iterator pi (p);
 
   for (int i = 0; i < count; i++)
     {
-      pv[i] = path_elt;
-      path_elt = kpse_path_element (0);
+      pv[i] = *pi++;
+      std::cerr << pv[i] << std::endl;
     }
 
   initialized = true;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
