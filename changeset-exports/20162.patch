# HG changeset patch
# User Rik <rik@octave.org>
# Date 1430697611 25200
#      Sun May 03 17:00:11 2015 -0700
# Branch stable
# Node ID 2645f9ef8c88528cc0fec18a43670086f9517211
# Parent  03b9d17a2d95b008c87be2c8621eccd8bc69b077
doc: Update more docstrings to have one sentence summary as first line.
Reviewed specfun, special-matrix, testfun, and time script directories.

* scripts/specfun/expint.m, scripts/specfun/isprime.m,
scripts/specfun/legendre.m, scripts/specfun/primes.m,
scripts/specfun/reallog.m, scripts/specfun/realsqrt.m,
scripts/special-matrix/gallery.m, scripts/special-matrix/hadamard.m,
scripts/special-matrix/hankel.m, scripts/special-matrix/hilb.m,
scripts/special-matrix/invhilb.m, scripts/special-matrix/magic.m,
scripts/special-matrix/pascal.m, scripts/special-matrix/rosser.m,
scripts/special-matrix/toeplitz.m, scripts/special-matrix/vander.m,
scripts/special-matrix/wilkinson.m, scripts/testfun/assert.m,
scripts/testfun/demo.m, scripts/testfun/example.m, scripts/testfun/fail.m,
scripts/testfun/rundemos.m, scripts/testfun/runtests.m,
scripts/testfun/speed.m, scripts/time/asctime.m, scripts/time/calendar.m,
scripts/time/clock.m, scripts/time/ctime.m, scripts/time/datenum.m,
scripts/time/datestr.m, scripts/time/datevec.m, scripts/time/etime.m,
scripts/time/is_leap_year.m, scripts/time/now.m, scripts/time/weekday.m:
Update more docstrings to have one sentence summary as first line.

diff --git a/scripts/specfun/expint.m b/scripts/specfun/expint.m
--- a/scripts/specfun/expint.m
+++ b/scripts/specfun/expint.m
@@ -36,17 +36,17 @@
 ##           /
 ##          x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## Note: For compatibility, this functions uses the @sc{matlab} definition
 ## of the exponential integral.  Most other sources refer to this particular
-## value as @math{E_1 (x)}, and the exponential integral is
+## value as @math{E_1 (x)}, and the exponential integral as
 ## @tex
 ## $$
 ## {\rm Ei} (x) = - \int_{-x}^\infty {e^{-t} \over t} dt.
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -14,18 +14,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isprime (@var{x})
-## Return a logical array which is true where the elements of @var{x} are
-## prime numbers and false where they are not.
+## Return a logical array which is true where the elements of @var{x} are prime
+## numbers and false where they are not.
 ##
 ## A prime number is conventionally defined as a positive integer greater than
 ## 1 (e.g., 2, 3, @dots{}) which is divisible only by itself and 1.  Octave
 ## extends this definition to include both negative integers and complex
 ## values.  A negative integer is prime if its positive counterpart is prime.
 ## This is equivalent to @code{isprime (abs (x))}.
 ##
 ## If @code{class (@var{x})} is complex, then primality is tested in the domain
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -18,18 +18,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{l} =} legendre (@var{n}, @var{x})
 ## @deftypefnx {Function File} {@var{l} =} legendre (@var{n}, @var{x}, @var{normalization})
 ## Compute the Legendre function of degree @var{n} and order
 ## @var{m} = 0 @dots{} @var{n}.
 ##
-## The value @var{n} must be a real non-negative integer.  @var{x} is a
-## vector with real-valued elements in the range [-1, 1].
+## The value @var{n} must be a real non-negative integer.
+##
+## @var{x} is a vector with real-valued elements in the range [-1, 1].
 ##
 ## The optional argument @var{normalization} may be one of @qcode{"unnorm"},
 ## @qcode{"sch"}, or @qcode{"norm"}.  The default if no normalization is given
 ## is @qcode{"unnorm"}.
 ##
 ## When the optional argument @var{normalization} is @qcode{"unnorm"}, compute
 ## the Legendre function of degree @var{n} and order @var{m} and return all
 ## values for @var{m} = 0 @dots{} @var{n}.  The return value has one dimension
@@ -83,20 +84,20 @@
 ## ------------------------------------
 ## m=0 | -1.00000 | -0.47250 | -0.08000
 ## m=1 |  0.00000 | -1.99420 | -1.98000
 ## m=2 |  0.00000 | -2.56500 | -4.32000
 ## m=3 |  0.00000 | -1.24229 | -3.24000
 ## @end group
 ## @end example
 ##
-## When the optional argument @code{normalization} is @qcode{"sch"},
-## compute the Schmidt semi-normalized associated Legendre function.
-## The Schmidt semi-normalized associated Legendre function is related
-## to the unnormalized Legendre functions by the following:
+## When the optional argument @code{normalization} is @qcode{"sch"}, compute
+## the Schmidt semi-normalized associated Legendre function.  The Schmidt
+## semi-normalized associated Legendre function is related to the unnormalized
+## Legendre functions by the following:
 ##
 ## For Legendre functions of degree @var{n} and order 0:
 ##
 ## @tex
 ## $$
 ## SP^0_n (x) = P^0_n (x)
 ## $$
 ## @end tex
@@ -126,20 +127,20 @@
 ##   m      m         m    2(n-m)! 0.5
 ## SP(x) = P(x) * (-1)  * [-------]
 ##   n      n              (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
-## When the optional argument @var{normalization} is @qcode{"norm"},
-## compute the fully normalized associated Legendre function.
-## The fully normalized associated Legendre function is related
-## to the unnormalized Legendre functions by the following:
+## When the optional argument @var{normalization} is @qcode{"norm"}, compute
+## the fully normalized associated Legendre function.  The fully normalized
+## associated Legendre function is related to the unnormalized Legendre
+## functions by the following:
 ##
 ## For Legendre functions of degree @var{n} and order @var{m}
 ##
 ## @tex
 ## $$
 ## NP^m_n (x) = P^m_n (x)(-1)^m\biggl({(n+0.5)(n-m)!\over{(n+m)!}}\biggl)^{0.5}
 ## $$
 ## @end tex
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -15,33 +15,31 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} primes (@var{n})
 ## Return all primes up to @var{n}.
 ##
-## The output data class (double, single, uint32, etc.) is the same as
-## the input class of @var{n}.  The algorithm used is the Sieve of
-## Eratosthenes.
+## The output data class (double, single, uint32, etc.) is the same as the
+## input class of @var{n}.  The algorithm used is the Sieve of Eratosthenes.
 ##
-## Notes: If you need a specific number of primes you can use the
-## fact that the distance from one prime to the next is, on average,
-## proportional to the logarithm of the prime.  Integrating, one finds
-## that there are about @math{k} primes less than
+## Notes: If you need a specific number of primes you can use the fact that the
+## distance from one prime to the next is, on average, proportional to the
+## logarithm of the prime.  Integrating, one finds that there are about
+## @math{k} primes less than
 ## @tex
 ## $k \log (5 k)$.
 ## @end tex
 ## @ifnottex
 ## k*log (5*k).
 ## @end ifnottex
 ##
-## See also @code{list_primes} if you need a specific number @var{n} of
-## primes.
+## See also @code{list_primes} if you need a specific number @var{n} of primes.
 ## @seealso{list_primes, isprime}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Author: Francesco Potort√¨
 ## Author: Dirk Laurie
 
 function p = primes (n)
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} reallog (@var{x})
 ## Return the real-valued natural logarithm of each element of @var{x}.
 ##
-## If any element results in a complex return value @code{reallog} aborts
-## and issues an error.
+## If any element results in a complex return value @code{reallog} aborts and
+## issues an error.
 ## @seealso{log, realpow, realsqrt}
 ## @end deftypefn
 
 function y = reallog (x)
 
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} realsqrt (@var{x})
 ## Return the real-valued square root of each element of @var{x}.
 ##
-## If any element results in a complex return value @code{realsqrt} aborts
-## and issues an error.
+## If any element results in a complex return value @code{realsqrt} aborts and
+## issues an error.
 ## @seealso{sqrt, realpow, reallog}
 ## @end deftypefn
 
 function y = realsqrt (x)
 
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -152,19 +152,19 @@
 ## @deftypefnx {Function File} {@var{a} =} gallery ("integerdata", @dots{}, "@var{class}")
 ## Create a matrix with random integers in the range [1, @var{imax}].
 ## If @var{imin} is given then the integers are in the range
 ## [@var{imin}, @var{imax}].
 ##
 ## The second input is a matrix of dimensions describing the size of the output.
 ## The dimensions can also be input as comma-separated arguments.
 ##
-## The input @var{j} is an integer index in the range [0, 2^32-1].  The
-## values of the output matrix are always exactly the same
-## (reproducibility) for a given size input and @var{j} index.
+## The input @var{j} is an integer index in the range [0, 2^32-1].  The values
+## of the output matrix are always exactly the same (reproducibility) for a
+## given size input and @var{j} index.
 ##
 ## The final optional argument determines the class of the resulting matrix.
 ## Possible values for @var{class}: @qcode{"uint8"}, @qcode{"uint16"},
 ## @qcode{"uint32"}, @qcode{"int8"}, @qcode{"int16"}, int32", @qcode{"single"},
 ## @qcode{"double"}.  The default is @qcode{"double"}.
 ##
 ## @end deftypefn
 ##
@@ -176,17 +176,17 @@
 ##
 ## @deftypefn {Function File} {@var{a} =} gallery ("invol", @var{n})
 ## Create an involutory matrix.
 ##
 ## @end deftypefn
 ##
 ## @deftypefn  {Function File} {@var{a} =} gallery ("ipjfact", @var{n})
 ## @deftypefnx {Function File} {@var{a} =} gallery ("ipjfact", @var{n}, @var{k})
-## Create an Hankel matrix with factorial elements.
+## Create a Hankel matrix with factorial elements.
 ##
 ## @end deftypefn
 ##
 ## @deftypefn  {Function File} {@var{a} =} gallery ("jordbloc", @var{n})
 ## @deftypefnx {Function File} {@var{a} =} gallery ("jordbloc", @var{n}, @var{lambda})
 ## Create a Jordan block.
 ##
 ## @end deftypefn
@@ -252,19 +252,19 @@
 ## @deftypefnx {Function File} {@var{a} =} gallery ("normaldata", @var{M}, @var{N}, @dots{}, @var{j})
 ## @deftypefnx {Function File} {@var{a} =} gallery ("normaldata", @dots{}, "@var{class}")
 ## Create a matrix with random samples from the standard normal distribution
 ## (mean = 0, std = 1).
 ##
 ## The first input is a matrix of dimensions describing the size of the output.
 ## The dimensions can also be input as comma-separated arguments.
 ##
-## The input @var{j} is an integer index in the range [0, 2^32-1].  The
-## values of the output matrix are always exactly the same
-## (reproducibility) for a given size input and @var{j} index.
+## The input @var{j} is an integer index in the range [0, 2^32-1].  The values
+## of the output matrix are always exactly the same (reproducibility) for a
+## given size input and @var{j} index.
 ##
 ## The final optional argument determines the class of the resulting matrix.
 ## Possible values for @var{class}: @qcode{"single"}, @qcode{"double"}.
 ## The default is @qcode{"double"}.
 ##
 ## @end deftypefn
 ##
 ## @deftypefn  {Function File} {@var{q} =} gallery ("orthog", @var{n})
@@ -375,19 +375,19 @@
 ## @deftypefnx {Function File} {@var{a} =} gallery ("uniformdata", @var{M}, @var{N}, @dots{}, @var{j})
 ## @deftypefnx {Function File} {@var{a} =} gallery ("uniformdata", @dots{}, "@var{class}")
 ## Create a matrix with random samples from the standard uniform distribution
 ## (range [0,1]).
 ##
 ## The first input is a matrix of dimensions describing the size of the output.
 ## The dimensions can also be input as comma-separated arguments.
 ##
-## The input @var{j} is an integer index in the range [0, 2^32-1].  The
-## values of the output matrix are always exactly the same
-## (reproducibility) for a given size input and @var{j} index.
+## The input @var{j} is an integer index in the range [0, 2^32-1].  The values
+## of the output matrix are always exactly the same (reproducibility) for a
+## given size input and @var{j} index.
 ##
 ## The final optional argument determines the class of the resulting matrix.
 ## Possible values for @var{class}: @qcode{"single"}, @qcode{"double"}.
 ## The default is @qcode{"double"}.
 ##
 ## @end deftypefn
 ##
 ## @deftypefn  {Function File} {@var{a} =} gallery ("wathen", @var{nx}, @var{ny})
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -16,20 +16,21 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hadamard (@var{n})
-## Construct a Hadamard matrix (@nospell{Hn}) of size @var{n}-by-@var{n}.  The
-## size @var{n} must be of the form @math{2^k * p} in which
-## p is one of 1, 12, 20 or 28.  The returned matrix is normalized,
-## meaning @w{@code{Hn(:,1) == 1}} and @w{@code{Hn(1,:) == 1}}.
+## Construct a Hadamard matrix (@nospell{Hn}) of size @var{n}-by-@var{n}.
+##
+## The size @var{n} must be of the form @math{2^k * p} in which p is one of
+## 1, 12, 20 or 28.  The returned matrix is normalized, meaning
+## @w{@code{Hn(:,1) == 1}} and @w{@code{Hn(1,:) == 1}}.
 ##
 ## Some of the properties of Hadamard matrices are:
 ##
 ## @itemize @bullet
 ## @item
 ## @code{kron (Hm, Hn)} is a Hadamard matrix of size @var{m}-by-@var{n}.
 ##
 ## @item
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -15,23 +15,24 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hankel (@var{c})
 ## @deftypefnx {Function File} {} hankel (@var{c}, @var{r})
 ## Return the Hankel matrix constructed from the first column @var{c}, and
-## (optionally) the last row @var{r}.  If the last element of @var{c} is
-## not the same as the first element of @var{r}, the last element of
-## @var{c} is used.  If the second argument is omitted, it is assumed to
-## be a vector of zeros with the same size as @var{c}.
+## (optionally) the last row @var{r}.
 ##
-## A Hankel matrix formed from an m-vector @var{c}, and an n-vector
-## @var{r}, has the elements
+## If the last element of @var{c} is not the same as the first element of
+## @var{r}, the last element of @var{c} is used.  If the second argument is
+## omitted, it is assumed to be a vector of zeros with the same size as @var{c}.
+##
+## A Hankel matrix formed from an m-vector @var{c}, and an n-vector @var{r},
+## has the elements
 ## @tex
 ## $$
 ## H(i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -13,35 +13,36 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hilb (@var{n})
-## Return the Hilbert matrix of order @var{n}.  The @math{i,j} element
-## of a Hilbert matrix is defined as
+## Return the Hilbert matrix of order @var{n}.
+##
+## The @math{i,j} element of a Hilbert matrix is defined as
 ## @tex
 ## $$
 ## H(i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## H(i, j) = 1 / (i + j - 1)
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## Hilbert matrices are close to being singular which make them difficult to
-## invert with numerical routines.
-## Comparing the condition number of a random matrix 5x5 matrix with that of
-## a Hilbert matrix of order 5 reveals just how difficult the problem is.
+## invert with numerical routines.  Comparing the condition number of a random
+## matrix 5x5 matrix with that of a Hilbert matrix of order 5 reveals just how
+## difficult the problem is.
 ##
 ## @example
 ## @group
 ## cond (rand (5))
 ##    @result{} 14.392
 ## cond (hilb (5))
 ##    @result{} 4.7661e+05
 ## @end group
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -13,18 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} invhilb (@var{n})
-## Return the inverse of the Hilbert matrix of order @var{n}.  This can be
-## computed exactly using
+## Return the inverse of the Hilbert matrix of order @var{n}.
+##
+## This can be computed exactly using
 ## @tex
 ## $$\eqalign{
 ##   A_{ij} &= -1^{i+j} (i+j-1)
 ##              \left( \matrix{n+i-1 \cr n-j } \right)
 ##              \left( \matrix{n+j-1 \cr n-i } \right)
 ##              \left( \matrix{i+j-2 \cr i-2 } \right)^2 \cr
 ##          &= { p(i)p(j) \over (i+j-1) }
 ## }$$
@@ -55,20 +56,20 @@
 ## @group
 ##              k  /k+n-1\   /n\
 ##     p(k) = -1  (       ) (   )
 ##                 \ k-1 /   \k/
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## The validity of this formula can easily be checked by expanding
-## the binomial coefficients in both formulas as factorials.  It can
-## be derived more directly via the theory of Cauchy matrices.
-## See @nospell{J. W. Demmel}, @cite{Applied Numerical Linear Algebra}, p. 92.
+## The validity of this formula can easily be checked by expanding the binomial
+## coefficients in both formulas as factorials.  It can be derived more
+## directly via the theory of Cauchy matrices.  See @nospell{J. W. Demmel},
+## @cite{Applied Numerical Linear Algebra}, p. 92.
 ##
 ## Compare this with the numerical calculation of @code{inverse (hilb (n))},
 ## which suffers from the ill-conditioning of the Hilbert matrix, and the
 ## finite precision of your computer's floating point arithmetic.
 ## @seealso{hilb}
 ## @end deftypefn
 
 ## Author: Dirk Laurie <dlaurie@na-net.ornl.gov>
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -14,19 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} magic (@var{n})
 ##
-## Create an @var{n}-by-@var{n} magic square.  A magic square is an arrangement
-## of the integers @code{1:n^2} such that the row sums, column sums, and
-## diagonal sums are all equal to the same value.
+## Create an @var{n}-by-@var{n} magic square.
+##
+## A magic square is an arrangement of the integers @code{1:n^2} such that the
+## row sums, column sums, and diagonal sums are all equal to the same value.
 ##
 ## Note: @var{n} must be greater than 2 for the magic square to exist.
 ## @end deftypefn
 
 function A = magic (n)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -15,25 +15,31 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pascal (@var{n})
 ## @deftypefnx {Function File} {} pascal (@var{n}, @var{t})
-## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.  @var{t}
-## defaults to 0.  Return the pseudo-lower triangular Cholesky@tie{}factor of
-## the Pascal matrix if @code{@var{t} = 1} (The sign of some columns may be
-## negative).  This matrix is its own inverse, that is @code{pascal (@var{n},
-## 1) ^ 2 == eye (@var{n})}.  If @code{@var{t} = -1}, return the true
-## Cholesky@tie{}factor with strictly positive values on the diagonal.  If
-## @code{@var{t} = 2}, return a transposed and permuted version of @code{pascal
-## (@var{n}, 1)}, which is the cube root of the identity matrix.  That is,
-## @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
+## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.
+##
+## The default value of @var{t} is 0.
+##
+## When @code{@var{t} = 1}, return the pseudo-lower triangular
+## Cholesky@tie{}factor of the Pascal matrix (The sign of some columns may be
+## negative).  This matrix is its own inverse, that is
+## @code{pascal (@var{n}, 1) ^ 2 == eye (@var{n})}.
+##
+## If @code{@var{t} = -1}, return the true Cholesky@tie{}factor with strictly
+## positive values on the diagonal.
+##
+## If @code{@var{t} = 2}, return a transposed and permuted version of
+## @code{pascal (@var{n}, 1)}, which is the cube root of the identity matrix.
+## That is, @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
 ##
 ## @seealso{chol}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = pascal (n, t = 0)
diff --git a/scripts/special-matrix/rosser.m b/scripts/special-matrix/rosser.m
--- a/scripts/special-matrix/rosser.m
+++ b/scripts/special-matrix/rosser.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rosser ()
-## Return the Rosser matrix.  This is a difficult test case used to evaluate
-## eigenvalue algorithms.
+## Return the Rosser matrix.
 ##
+## This is a difficult test case used to evaluate eigenvalue algorithms.
 ## @seealso{wilkinson, eig}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = rosser ()
 
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -16,20 +16,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} toeplitz (@var{c})
 ## @deftypefnx {Function File} {} toeplitz (@var{c}, @var{r})
 ## Return the Toeplitz matrix constructed from the first column @var{c},
-## and (optionally) the first row @var{r}.  If the first element of @var{r}
-## is not the same as the first element of @var{c}, the first element of
-## @var{c} is used.  If the second argument is omitted, the first row is
-## taken to be the same as the first column.
+## and (optionally) the first row @var{r}.
+##
+## If the first element of @var{r} is not the same as the first element of
+## @var{c}, the first element of @var{c} is used.  If the second argument is
+## omitted, the first row is taken to be the same as the first column.
 ##
 ## A square Toeplitz matrix has the form:
 ## @tex
 ## $$
 ## \left[\matrix{c_0    & r_1     & r_2      & \cdots & r_n\cr
 ##               c_1    & c_0     & r_1      & \cdots & r_{n-1}\cr
 ##               c_2    & c_1     & c_0      & \cdots & r_{n-2}\cr
 ##               \vdots & \vdots  & \vdots   & \ddots & \vdots\cr
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -16,18 +16,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} vander (@var{c})
 ## @deftypefnx {Function File} {} vander (@var{c}, @var{n})
 ## Return the Vandermonde matrix whose next to last column is @var{c}.
-## If @var{n} is specified, it determines the number of columns;
-## otherwise, @var{n} is taken to be equal to the length of @var{c}.
+##
+## If @var{n} is specified, it determines the number of columns; otherwise,
+## @var{n} is taken to be equal to the length of @var{c}.
 ##
 ## A Vandermonde matrix has the form:
 ## @tex
 ## $$
 ## \left[\matrix{c_1^{n-1}  & \cdots & c_1^2  & c_1    & 1      \cr
 ##               c_2^{n-1}  & \cdots & c_2^2  & c_2    & 1      \cr
 ##               \vdots     & \ddots & \vdots & \vdots & \vdots \cr
 ##               c_n^{n-1}  & \cdots & c_n^2  & c_n    & 1      }\right]
diff --git a/scripts/special-matrix/wilkinson.m b/scripts/special-matrix/wilkinson.m
--- a/scripts/special-matrix/wilkinson.m
+++ b/scripts/special-matrix/wilkinson.m
@@ -13,20 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wilkinson (@var{n})
-## Return the Wilkinson matrix of order @var{n}.  Wilkinson matrices are
-## symmetric and tridiagonal with pairs of nearly, but not exactly, equal
-## eigenvalues.  They are useful in testing the behavior and performance
-## of eigenvalue solvers.
+## Return the Wilkinson matrix of order @var{n}.
+##
+## Wilkinson matrices are symmetric and tridiagonal with pairs of nearly, but
+## not exactly, equal eigenvalues.  They are useful in testing the behavior and
+## performance of eigenvalue solvers.
 ##
 ## @seealso{rosser, eig}
 ## @end deftypefn
 
 ## Author: Peter Ekberg
 ##         (peda)
 
 function retval = wilkinson (n)
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -28,37 +28,45 @@
 ##
 ## @code{assert} can be called in three different ways.
 ##
 ## @table @code
 ## @item  assert (@var{cond})
 ## @itemx assert (@var{cond}, @var{errmsg})
 ## @itemx assert (@var{cond}, @var{errmsg}, @dots{})
 ## @itemx assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
-## Called with a single argument @var{cond}, @code{assert} produces an
-## error if @var{cond} is false (numeric zero).  Any additional arguments are
-## passed to the @code{error} function for processing.
+## Called with a single argument @var{cond}, @code{assert} produces an error if
+## @var{cond} is false (numeric zero).
+##
+## Any additional arguments are passed to the @code{error} function for
+## processing.
 ##
 ## @item assert (@var{observed}, @var{expected})
-## Produce an error if observed is not the same as expected.  Note that
-## @var{observed} and @var{expected} can be scalars, vectors, matrices,
-## strings, cell arrays, or structures.
+## Produce an error if observed is not the same as expected.
+##
+## Note that @var{observed} and @var{expected} can be scalars, vectors,
+## matrices, strings, cell arrays, or structures.
 ##
 ## @item assert (@var{observed}, @var{expected}, @var{tol})
 ## Produce an error if observed is not the same as expected but equality
 ## comparison for numeric data uses a tolerance @var{tol}.
+## 
 ## If @var{tol} is positive then it is an absolute tolerance which will produce
 ## an error if @code{abs (@var{observed} - @var{expected}) > abs (@var{tol})}.
+## 
 ## If @var{tol} is negative then it is a relative tolerance which will produce
 ## an error if @code{abs (@var{observed} - @var{expected}) >
 ## abs (@var{tol} * @var{expected})}.
+##
 ## If @var{expected} is zero @var{tol} will always be interpreted as an
-## absolute tolerance.  If @var{tol} is not scalar its dimensions must agree
-## with those of @var{observed} and @var{expected} and tests are performed on
-## an element-by-element basis.
+## absolute tolerance.
+##
+## If @var{tol} is not scalar its dimensions must agree with those of
+## @var{observed} and @var{expected} and tests are performed on an
+## element-by-element basis.
 ## @end table
 ## @seealso{fail, test, error, isequal}
 ## @end deftypefn
 
 function assert (cond, varargin)
 
   if (nargin == 0)
     print_usage ();
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -18,16 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} demo @var{name}
 ## @deftypefnx {Command} {} demo @var{name} @var{n}
 ## @deftypefnx {Function File} {} demo ("@var{name}")
 ## @deftypefnx {Function File} {} demo ("@var{name}", @var{n})
 ##
 ## Run example code block @var{n} associated with the function @var{name}.
+##
 ## If @var{n} is not specified, all examples are run.
 ##
 ## The preferred location for example code blocks is embedded within the script
 ## m-file immediately following the code that it exercises.  Alternatively,
 ## the examples may be stored in a file with the same name but no extension
 ## located on Octave's load path.  To separate examples from regular script
 ## code all lines are prefixed by @code{%!}.  Each example must also be
 ## introduced by the keyword @qcode{"demo"} flush left to the prefix with no
@@ -56,30 +57,29 @@
 ## initialization code.  Alternatively, all demos can be combined into a single
 ## large demo with the code
 ##
 ## @example
 ## %! input ("Press <enter> to continue: ", "s");
 ## @end example
 ##
 ## @noindent
-## between the sections, but this usage is discouraged.  Other techniques
-## to avoid multiple initialization blocks include using multiple plots
-## with a new @code{figure} command between each plot, or using @code{subplot}
-## to put multiple plots in the same window.
+## between the sections, but this usage is discouraged.  Other techniques to
+## avoid multiple initialization blocks include using multiple plots with a new
+## @code{figure} command between each plot, or using @code{subplot} to put
+## multiple plots in the same window.
 ##
-## Finally, because @code{demo} evaluates within a function context it is
-## not possible to define new functions within the code.  Anonymous functions
-## make a good substitute in most instances.  If function blocks
-## @strong{must} be used then the code @code{eval (example ("function", n))}
-## will allow Octave to see them.  This has its own problems, however, as
-## @code{eval} only evaluates one line or statement at a time.  In this case
-## the function declaration must be wrapped with
-## @qcode{"if 1 <demo stuff> endif"} where @qcode{"if"} is on the same line
-## as @qcode{"demo"}.  For example:
+## Finally, because @code{demo} evaluates within a function context it is not
+## possible to define new functions within the code.  Anonymous functions make
+## a good substitute in most instances.  If function blocks @strong{must} be
+## used then the code @code{eval (example ("function", n))} will allow Octave
+## to see them.  This has its own problems, however, as @code{eval} only
+## evaluates one line or statement at a time.  In this case the function
+## declaration must be wrapped with @qcode{"if 1 <demo stuff> endif"} where
+## @qcode{"if"} is on the same line as @qcode{"demo"}.  For example:
 ##
 ## @example
 ## @group
 ## %!demo if 1
 ## %!  function y = f(x)
 ## %!    y = x;
 ## %!  endfunction
 ## %!  f(3)
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -19,18 +19,19 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} example @var{name}
 ## @deftypefnx {Command} {} example @var{name} @var{n}
 ## @deftypefnx {Function File} {} example ("@var{name}")
 ## @deftypefnx {Function File} {} example ("@var{name}", @var{n})
 ## @deftypefnx {Function File} {[@var{s}, @var{idx}] =} example (@dots{})
 ##
 ## Display the code for example @var{n} associated with the function
-## @var{name}, but do not run it.  If @var{n} is not specified, all examples
-## are displayed.
+## @var{name}, but do not run it.
+##
+## If @var{n} is not specified, all examples are displayed.
 ##
 ## When called with output arguments, the examples are returned in the form of
 ## a string @var{s}, with @var{idx} indicating the ending position of the
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
 ## @end deftypefn
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -48,18 +48,18 @@
 ## @group
 ##           expected <@var{pattern}>
 ##           but got <text of actual error>
 ## @end group
 ## @end example
 ##
 ## The angle brackets are not part of the output.
 ##
-## When called with the @qcode{"warning"} option @code{fail} will produce
-## an error if executing the code produces no warning.
+## When called with the @qcode{"warning"} option @code{fail} will produce an
+## error if executing the code produces no warning.
 ## @seealso{assert, error}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function retval = fail (code, pattern, warning_pattern)
 
   if (nargin < 1 || nargin > 3)
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -19,18 +19,18 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} rundemos ()
 ## @deftypefnx {Function File} {} rundemos (@var{directory})
 ## Execute built-in demos for all m-files in the specified @var{directory}.
 ##
 ## Demo blocks in any C++ source files (@file{*.cc}) will also be executed
 ## for use with dynamically linked oct-file functions.
 ##
-## If no directory is specified, operate on all directories in Octave's
-## search path for functions.
+## If no directory is specified, operate on all directories in Octave's search
+## path for functions.
 ## @seealso{demo, runtests, path}
 ## @end deftypefn
 
 ## Author: jwe
 
 function rundemos (directory)
 
   if (nargin == 0)
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -19,18 +19,18 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} runtests ()
 ## @deftypefnx {Function File} {} runtests (@var{directory})
 ## Execute built-in tests for all m-files in the specified @var{directory}.
 ##
 ## Test blocks in any C++ source files (@file{*.cc}) will also be executed
 ## for use with dynamically linked oct-file functions.
 ##
-## If no directory is specified, operate on all directories in Octave's
-## search path for functions.
+## If no directory is specified, operate on all directories in Octave's search
+## path for functions.
 ## @seealso{rundemos, test, path}
 ## @end deftypefn
 
 ## Author: jwe
 
 function runtests (directory)
 
   if (nargin == 0)
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -16,108 +16,106 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} speed (@var{f}, @var{init}, @var{max_n}, @var{f2}, @var{tol})
 ## @deftypefnx {Function File} {[@var{order}, @var{n}, @var{T_f}, @var{T_f2}] =} speed (@dots{})
 ##
 ## Determine the execution time of an expression (@var{f}) for various input
-## values (@var{n}).  The @var{n} are log-spaced from 1 to @var{max_n}.  For
-## each @var{n}, an initialization expression (@var{init}) is computed to
-## create any data needed for the test.  If a second expression (@var{f2}) is
-## given then the execution times of the two expressions are compared.  When
-## called without output arguments the results are printed to stdout and
-## displayed graphically.
+## values (@var{n}).
+##
+## The @var{n} are log-spaced from 1 to @var{max_n}.  For each @var{n}, an
+## initialization expression (@var{init}) is computed to create any data needed
+## for the test.  If a second expression (@var{f2}) is given then the
+## execution times of the two expressions are compared.  When called without
+## output arguments the results are printed to stdout and displayed
+## graphically.
 ##
 ## @table @code
 ## @item @var{f}
 ## The code expression to evaluate.
 ##
 ## @item @var{max_n}
 ## The maximum test length to run.  The default value is 100.  Alternatively,
 ## use @code{[min_n, max_n]} or specify the @var{n} exactly with
 ## @code{[n1, n2, @dots{}, nk]}.
 ##
 ## @item @var{init}
-## Initialization expression for function argument values.  Use @var{k}
-## for the test number and @var{n} for the size of the test.  This should
-## compute values for all variables used by @var{f}.  Note that @var{init} will
-## be evaluated first for @math{k = 0}, so things which are constant throughout
+## Initialization expression for function argument values.  Use @var{k} for
+## the test number and @var{n} for the size of the test.  This should compute
+## values for all variables used by @var{f}.  Note that @var{init} will be
+## evaluated first for @math{k = 0}, so things which are constant throughout
 ## the test series can be computed once.  The default value is
 ## @code{@var{x} = randn (@var{n}, 1)}.
 ##
 ## @item @var{f2}
 ## An alternative expression to evaluate, so that the speed of two
 ## expressions can be directly compared.  The default is @code{[]}.
 ##
 ## @item @var{tol}
 ## Tolerance used to compare the results of expression @var{f} and expression
 ## @var{f2}.  If @var{tol} is positive, the tolerance is an absolute one.
 ## If @var{tol} is negative, the tolerance is a relative one.  The default is
 ## @code{eps}.  If @var{tol} is @code{Inf}, then no comparison will be made.
 ##
 ## @item @var{order}
-## The time complexity of the expression @math{O(a*n^p)}.  This
-## is a structure with fields @code{a} and @code{p}.
+## The time complexity of the expression @math{O(a*n^p)}.  This is a
+## structure with fields @code{a} and @code{p}.
 ##
 ## @item @var{n}
 ## The values @var{n} for which the expression was calculated @strong{AND}
 ## the execution time was greater than zero.
 ##
 ## @item @var{T_f}
 ## The nonzero execution times recorded for the expression @var{f} in seconds.
 ##
 ## @item @var{T_f2}
 ## The nonzero execution times recorded for the expression @var{f2} in seconds.
 ## If required, the mean time ratio is simply @code{mean (T_f ./ T_f2)}.
 ##
 ## @end table
 ##
-## The slope of the execution time graph shows the approximate
-## power of the asymptotic running time @math{O(n^p)}.  This
-## power is plotted for the region over which it is approximated
-## (the latter half of the graph).  The estimated power is not
-## very accurate, but should be sufficient to determine the
-## general order of an algorithm.  It should indicate if, for
-## example, the implementation is unexpectedly @math{O(n^2)}
-## rather than @math{O(n)} because it extends a vector each
-## time through the loop rather than pre-allocating storage.
-## In the current version of Octave, the following is not the
-## expected @math{O(n)}.
+## The slope of the execution time graph shows the approximate power of the
+## asymptotic running time @math{O(n^p)}.  This power is plotted for the
+## region over which it is approximated (the latter half of the graph).  The
+## estimated power is not very accurate, but should be sufficient to
+## determine the general order of an algorithm.  It should indicate if, for
+## example, the implementation is unexpectedly @math{O(n^2)} rather than
+## @math{O(n)} because it extends a vector each time through the loop rather
+## than pre-allocating storage.  In the current version of Octave, the
+## following is not the expected @math{O(n)}.
 ##
 ## @example
 ## speed ("for i = 1:n, y@{i@} = x(i); endfor", "", [1000, 10000])
 ## @end example
 ##
 ## @noindent
 ## But it is if you preallocate the cell array @code{y}:
 ##
 ## @example
 ## @group
 ## speed ("for i = 1:n, y@{i@} = x(i); endfor", ...
 ##        "x = rand (n, 1); y = cell (size (x));", [1000, 10000])
 ## @end group
 ## @end example
 ##
-## An attempt is made to approximate the cost of individual
-## operations, but it is wildly inaccurate.  You can improve the
-## stability somewhat by doing more work for each @code{n}.  For
-## example:
+## An attempt is made to approximate the cost of individual operations, but
+## it is wildly inaccurate.  You can improve the stability somewhat by doing
+## more work for each @code{n}.  For example:
 ##
 ## @example
 ## speed ("airy(x)", "x = rand (n, 10)", [10000, 100000])
 ## @end example
 ##
-## When comparing two different expressions (@var{f}, @var{f2}), the slope
-## of the line on the speedup ratio graph should be larger than 1 if the new
+## When comparing two different expressions (@var{f}, @var{f2}), the slope of
+## the line on the speedup ratio graph should be larger than 1 if the new
 ## expression is faster.  Better algorithms have a shallow slope.  Generally,
-## vectorizing an algorithm will not change the slope of the execution
-## time graph, but will shift it relative to the original.  For
-## example:
+## vectorizing an algorithm will not change the slope of the execution time
+## graph, but will shift it relative to the original.  For example:
 ##
 ## @example
 ## @group
 ## speed ("sum (x)", "", [10000, 100000], ...
 ##        "v = 0; for i = 1:length (x), v += x(i); endfor")
 ## @end group
 ## @end example
 ##
@@ -130,22 +128,22 @@
 ## @group
 ## speed ("xcorr (x, n)", "x = rand (128, 1);", 100,
 ##        "xcorr_orig (x, n)", -100*eps)
 ## speed ("xcorr (x, 15)", "x = rand (20+n, 1);", 100,
 ##        "xcorr_orig (x, n)", -100*eps)
 ## @end group
 ## @end example
 ##
-## Assuming one of the two versions is in xcorr_orig, this
-## would compare their speed and their output values.  Note that the
-## FFT version is not exact, so one must specify an acceptable tolerance on
-## the comparison @code{100*eps}.  In this case, the comparison should be
-## computed relatively, as @code{abs ((@var{x} - @var{y}) ./ @var{y})} rather
-## than absolutely as @code{abs (@var{x} - @var{y})}.
+## Assuming one of the two versions is in xcorr_orig, this would compare their
+## speed and their output values.  Note that the FFT version is not exact, so
+## one must specify an acceptable tolerance on the comparison @code{100*eps}.
+## In this case, the comparison should be computed relatively, as
+## @code{abs ((@var{x} - @var{y}) ./ @var{y})} rather than absolutely as
+## @code{abs (@var{x} - @var{y})}.
 ##
 ## Type @kbd{example ("speed")} to see some real examples or
 ## @kbd{demo ("speed")} to run them.
 ## @end deftypefn
 
 ## FIXME: consider two dimensional speedup surfaces for functions like kron.
 function [__order, __test_n, __tnew, __torig] = speed (__f1, __init, __max_n = 100, __f2 = "", __tol = eps)
 
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -14,17 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} asctime (@var{tm_struct})
 ## Convert a time structure to a string using the following
-## format: @qcode{"ddd mmm mm HH:MM:SS yyyy"}.  For example:
+## format: @qcode{"ddd mmm mm HH:MM:SS yyyy"}.
+##
+## For example:
 ##
 ## @example
 ## @group
 ## asctime (localtime (time ()))
 ##      @result{} "Mon Feb 17 01:15:06 1997"
 ## @end group
 ## @end example
 ##
diff --git a/scripts/time/calendar.m b/scripts/time/calendar.m
--- a/scripts/time/calendar.m
+++ b/scripts/time/calendar.m
@@ -18,18 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{c} =} calendar ()
 ## @deftypefnx {Function File} {@var{c} =} calendar (@var{d})
 ## @deftypefnx {Function File} {@var{c} =} calendar (@var{y}, @var{m})
 ## @deftypefnx {Function File} {} calendar (@dots{})
 ## Return the current monthly calendar in a 6x7 matrix.
 ##
-## If @var{d} is specified, return the calendar for the month containing
-## the date @var{d}, which must be a serial date number or a date string.
+## If @var{d} is specified, return the calendar for the month containing the
+## date @var{d}, which must be a serial date number or a date string.
 ##
 ## If @var{y} and @var{m} are specified, return the calendar for year @var{y}
 ## and month @var{m}.
 ##
 ## If no output arguments are specified, print the calendar on the screen
 ## instead of returning a matrix.
 ## @seealso{datenum, datestr}
 ## @end deftypefn
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -13,32 +13,33 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} clock ()
-## Return the current local date and time as a date vector.  The date vector
-## contains the following fields: current year, month (1-12), day (1-31),
-## hour (0-23), minute (0-59), and second (0-61).  The seconds field has
-## a fractional part after the decimal point for extended accuracy.
+## Return the current local date and time as a date vector.
+##
+## The date vector contains the following fields: current year, month (1-12),
+## day (1-31), hour (0-23), minute (0-59), and second (0-61).  The seconds
+## field has a fractional part after the decimal point for extended accuracy.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## fix (clock ())
 ##      @result{} [ 1993, 8, 20, 4, 56, 1 ]
 ## @end group
 ## @end example
 ##
-## The function clock is more accurate on systems that have the
-## @code{gettimeofday} function.
+## @code{clock} is more accurate on systems that have the @code{gettimeofday}
+## function.
 ## @seealso{now, date, datevec}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = clock ()
 
   tm = localtime (time ());
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -15,17 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ctime (@var{t})
 ## Convert a value returned from @code{time} (or any other non-negative
 ## integer), to the local time and return a string of the same form as
-## @code{asctime}.  The function @code{ctime (time)} is equivalent to
+## @code{asctime}.
+##
+## The function @code{ctime (time)} is equivalent to
 ## @code{asctime (localtime (time))}.  For example:
 ##
 ## @example
 ## @group
 ## ctime (time ())
 ##    @result{} "Mon Feb 17 01:15:06 1997"
 ## @end group
 ## @end example
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -70,25 +70,19 @@
 ##
 ## @item
 ## Days before the beginning of the month go to the previous month.
 ##
 ## @item
 ## Days can be fractional.
 ## @end itemize
 ##
-## @strong{Caution:} this function does not attempt to handle Julian
-## calendars so dates before October 15, 1582 are wrong by as much
-## as eleven days.  Also, be aware that only Roman Catholic countries
-## adopted the calendar in 1582.  It took until 1924 for it to be
-## adopted everywhere.  See the Wikipedia entry on the Gregorian
-## calendar for more details.
+## @strong{Caution:} this function does not attempt to handle Julian calendars so dates before October 15, 1582 are wrong by as much as eleven days.  Also, be aware that only Roman Catholic countries adopted the calendar in 1582.  It took until 1924 for it to be adopted everywhere.  See the Wikipedia entry on the Gregorian calendar for more details.
 ##
-## @strong{Warning:} leap seconds are ignored.  A table of leap seconds
-## is available on the Wikipedia entry for leap seconds.
+## @strong{Warning:} leap seconds are ignored.  A table of leap seconds is available on the Wikipedia entry for leap seconds.
 ## @seealso{datestr, datevec, now, clock, date}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
 ## Author: pkienzle <pkienzle@users.sf.net>
 
 function [days, secs] = datenum (year, month = [], day = [], hour = 0, minute = 0, second = 0)
 
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -16,26 +16,28 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{str} =} datestr (@var{date})
 ## @deftypefnx {Function File} {@var{str} =} datestr (@var{date}, @var{f})
 ## @deftypefnx {Function File} {@var{str} =} datestr (@var{date}, @var{f}, @var{p})
 ## Format the given date/time according to the format @code{f} and return
-## the result in @var{str}.  @var{date} is a serial date number (see
-## @code{datenum}) or a date vector (see @code{datevec}).  The value of
-## @var{date} may also be a string or cell array of strings.
+## the result in @var{str}.
+##
+## @var{date} is a serial date number (see @code{datenum}) or a date vector
+## (see @code{datevec}).  The value of @var{date} may also be a string or cell
+## array of strings.
 ##
-## @var{f} can be an integer which corresponds to one of the codes in
-## the table below, or a date format string.
+## @var{f} can be an integer which corresponds to one of the codes in the table
+## below, or a date format string.
 ##
-## @var{p} is the year at the start of the century in which two-digit years
-## are to be interpreted in.  If not specified, it defaults to the current
-## year minus 50.
+## @var{p} is the year at the start of the century in which two-digit years are
+## to be interpreted in.  If not specified, it defaults to the current year
+## minus 50.
 ##
 ## For example, the date 730736.65149 (2000-09-07 15:38:09.0934) would be
 ## formatted as follows:
 ##
 ## @multitable @columnfractions 0.1 0.45 0.35
 ## @headitem Code @tab Format @tab Example
 ## @item 0 @tab dd-mmm-yyyy HH:MM:SS    @tab 07-Sep-2000 15:38:09
 ## @item 1 @tab dd-mmm-yyyy             @tab 07-Sep-2000
@@ -89,19 +91,18 @@
 ## @item      @tab and not padded with zeros otherwise          @tab 9:00 AM
 ## @item MM   @tab Minute of hour (padded with zeros)           @tab 10:05
 ## @item SS   @tab Second of minute (padded with zeros)         @tab 10:05:03
 ## @item FFF  @tab Milliseconds of second (padded with zeros)   @tab 10:05:03.012
 ## @item AM   @tab Use 12-hour time format                      @tab 11:30 AM
 ## @item PM   @tab Use 12-hour time format                      @tab 11:30 PM
 ## @end multitable
 ##
-## If @var{f} is not specified or is @code{-1}, then use 0, 1 or 16,
-## depending on whether the date portion or the time portion of
-## @var{date} is empty.
+## If @var{f} is not specified or is @code{-1}, then use 0, 1 or 16, depending
+## on whether the date portion or the time portion of @var{date} is empty.
 ##
 ## If @var{p} is nor specified, it defaults to the current year minus 50.
 ##
 ## If a matrix or cell array of dates is given, a column vector of date strings
 ## is returned.
 ##
 ## @seealso{datenum, datevec, date, now, clock}
 ## @end deftypefn
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -26,24 +26,24 @@
 ## @code{datestr}) into a date vector.
 ##
 ## A date vector is a row vector with six members, representing the year,
 ## month, day, hour, minute, and seconds respectively.
 ##
 ## @var{f} is the format string used to interpret date strings
 ## (see @code{datestr}).  If @var{date} is a string, but no format is
 ## specified, then a relatively slow search is performed through various
-## formats.  It is always preferable to specify the format string @var{f}
-## if it is known.  Formats which do not specify a particular time component
-## will have the value set to zero.  Formats which do not specify a date will
+## formats.  It is always preferable to specify the format string @var{f} if it
+## is known.  Formats which do not specify a particular time component will
+## have the value set to zero.  Formats which do not specify a date will
 ## default to January 1st of the current year.
 ##
 ## @var{p} is the year at the start of the century to which two-digit years
-## will be referenced.  If not specified, it defaults to the current year
-## minus 50.
+## will be referenced.  If not specified, it defaults to the current year minus
+## 50.
 ## @seealso{datenum, datestr, clock, now, date}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Modified: bdenney <bill@givebillmoney.com>
 ## Created: 10 October 2001 (CVS)
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -14,29 +14,31 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} etime (@var{t2}, @var{t1})
 ## Return the difference in seconds between two time values returned from
-## @code{clock} (@math{@var{t2} - @var{t1}}).  For example:
+## @code{clock} (@math{@var{t2} - @var{t1}}).
+##
+## For example:
 ##
 ## @example
 ## @group
 ## t0 = clock ();
 ## # many computations later@dots{}
 ## elapsed_time = etime (clock (), t0);
 ## @end group
 ## @end example
 ##
 ## @noindent
-## will set the variable @code{elapsed_time} to the number of seconds since
-## the variable @code{t0} was set.
+## will set the variable @code{elapsed_time} to the number of seconds since the
+## variable @code{t0} was set.
 ## @seealso{tic, toc, clock, cputime, addtodate}
 ## @end deftypefn
 
 ## Author: jwe
 
 function secs = etime (t2, t1)
 
   if (nargin != 2)
diff --git a/scripts/time/is_leap_year.m b/scripts/time/is_leap_year.m
--- a/scripts/time/is_leap_year.m
+++ b/scripts/time/is_leap_year.m
@@ -14,18 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} is_leap_year ()
 ## @deftypefnx {Function File} {} is_leap_year (@var{year})
-## Return true if @var{year} is a leap year and false otherwise.  If no
-## year is specified, @code{is_leap_year} uses the current year.
+## Return true if @var{year} is a leap year and false otherwise.
+##
+## If no year is specified, @code{is_leap_year} uses the current year.
+##
 ## For example:
 ##
 ## @example
 ## @group
 ## is_leap_year (2000)
 ##    @result{} 1
 ## @end group
 ## @end example
diff --git a/scripts/time/now.m b/scripts/time/now.m
--- a/scripts/time/now.m
+++ b/scripts/time/now.m
@@ -19,18 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {t =} now ()
 ## Return the current local date/time as a serial day number
 ## (see @code{datenum}).
 ##
 ## The integral part, @code{floor (now)} corresponds to the number of days
 ## between today and Jan 1, 0000.
 ##
-## The fractional part, @code{rem (now, 1)} corresponds to the current
-## time.
+## The fractional part, @code{rem (now, 1)} corresponds to the current time.
 ## @seealso{clock, date, datenum}
 ## @end deftypefn
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Created: 10 October 2001 (CVS)
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function t = now ()
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -15,23 +15,24 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{n}, @var{s}] =} weekday (@var{d})
 ## @deftypefnx {Function File} {[@var{n}, @var{s}] =} weekday (@var{d}, @var{format})
 ## Return the day of the week as a number in @var{n} and as a string in @var{s}.
+##
 ## The days of the week are numbered 1--7 with the first day being Sunday.
 ##
 ## @var{d} is a serial date number or a date string.
 ##
-## If the string @var{format} is not present or is equal to @qcode{"short"} then
-## @var{s} will contain the abbreviated name of the weekday.  If @var{format}
-## is @qcode{"long"} then @var{s} will contain the full name.
+## If the string @var{format} is not present or is equal to @qcode{"short"}
+## then @var{s} will contain the abbreviated name of the weekday.  If
+## @var{format} is @qcode{"long"} then @var{s} will contain the full name.
 ##
 ## Table of return values based on @var{format}:
 ##
 ## @multitable @columnfractions .06 .13 .16
 ## @headitem @var{n} @tab @qcode{"short"} @tab @qcode{"long"}
 ## @item 1 @tab Sun @tab Sunday
 ## @item 2 @tab Mon @tab Monday
 ## @item 3 @tab Tue @tab Tuesday
