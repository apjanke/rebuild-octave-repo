# HG changeset patch
# User Kai Habel <kai.habel@gmx.de>
# Date 1287998803 -7200
#      Mon Oct 25 11:26:43 2010 +0200
# Node ID f0e9befd6a1c90e858838470736e0e283aef4364
# Parent  92a7c136ab350f2362b3a78ed24e802706072afb
add uimenu graphic object to fltk backend

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2010-10-25  Kai Habel  <kai.habel@gmx.de>
+
+	* NEWS: Add uimenu.
+
 2010-10-24  Rik  <octave@nomad.inbox5.com>
 
 	* NEWS: Update deprecated function list for version 3.4.
 
 2010-10-22  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.am (EXTRA_DIST): Include bootstrap and bootstrap.conf
 	in the list.
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -434,18 +434,18 @@ Summary of important user-visible change
 
  ** New graphics functions:
 
       addlistener         ezcontour   gcbo         refresh  
       addproperty         ezcontourf  ginput       refreshdata
       allchild            ezmesh      gtext        specular
       available_backends  ezmeshc     intwarning   surfl
       backend             ezplot      ishghandle   trisurf
-      cla                 ezplot3     isocolors    waitforbuttonpress
-      clabel              ezpolar     isonormals  
+      cla                 ezplot3     isocolors    uimenu
+      clabel              ezpolar     isonormals   waitforbuttonpress
       comet               ezsurf      isosurface  
       dellistener         findall     linkprop   
       diffuse             gcbf        plotmatrix
 
  ** New experimental OpenGL/FLTK based plotting system.
 
     An experimental plotting system based on OpenGL and the FLTK
     toolkit is now part of Octave.  This backend is disabled by
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,52 @@
+2010-10-25  Kai Habel  <kai.habel@gmx.de>
+
+	* gl-render.cc (opengl_renderer::draw ): Ignore uimenu objects here.
+	* graphics.h.in (class OCTINTERP_API uimenu): New graphics object.
+	* graphics.cc (lookup_object_name): Add uimenu here.
+	(make_graphics_object_from_type): Likewise.
+	(property_list::set): Likewise.
+	(property_list::lookup): Likewise.
+	(root_figure::init_factory_properties): Likewise.
+	(__go_uimenu__): New function.
+	* DLD-Functions/fltk-backend.cc (OpenGL_fltk::resize ): Make public.
+	(script_cb): New function.
+	(fltk_uimenu): New class.
+	(fltk_uimenu::items_to_show): New function.
+	(fltk_uimenu::show): New function.
+	(fltk_uimenu::hide): New function.
+	(fltk_uimenu::is_visible): New function.
+	(fltk_uimenu::find_index_by_name): New function.
+	(fltk_uimenu::find_uimenu_children): New function.
+	(fltk_uimenu::update_submenu): New function.
+	(fltk_uimenu::delete_entry): New function.
+	(fltk_uimenu::update_accelerator): New function.
+	(fltk_uimenu::update_callback): New function.
+	(fltk_uimenu::update_enable): New function.
+	(fltk_uimenu::update_foregroundcolor): New function.
+	(fltk_uimenu::update_seperator): New function.
+	(fltk_uimenu::update_visible): New function.
+	(fltk_uimenu::add_entry): New function.
+	(fltk_uimenu::add_to_menu): New function.
+	(fltk_uimenu::remove_from_menu): New function.
+	(plot_window::plot_window): Initialize fltk_uimenu object.
+	(plot_window::~plot_window): Delete fltk_uimenu object.
+	(plot_window::show_menubar): New function.
+	(plot_window::hide_menubar): New function.
+	(plot_window::uimenu_update): New function.
+	(plot_window::handle): Do not evaluate FLTK events when 
+	figure is deleted.
+	(figure_manager::uimenu_update): New function.
+	(figure_manager::toggle_menubar_visibility): New functions.
+	(figure_manager::do_toggle_menubar_visibility): New function.
+	(figure_manager::do_uimenu_update): New function.
+	(fltk_backend::uimenu_set_fltk_label): New function.
+	(fltk_backend::update): Add figure and uimenu updates.
+
 2010-10-24  Rik  <octave@nomad.inbox5.com>
 
 	* miscellaneous/compare_versions.m, plot/ylabel.m, plot/ylim.m, 
 	  plot/zlabel.m, plot/zlim.m: Docstring improvements.
 
 2010-10-24  Rik  <octave@nomad.inbox5.com>
 
 	* specfun/module.mk, deprecated/module.mk, deprecated/betai.m, 
diff --git a/scripts/plot/__go_draw_figure__.m b/scripts/plot/__go_draw_figure__.m
--- a/scripts/plot/__go_draw_figure__.m
+++ b/scripts/plot/__go_draw_figure__.m
@@ -90,16 +90,18 @@ function __go_draw_figure__ (h, plot_str
                 ## their original values.
                 set (kids(i), "units", orig_axes_units);
                 set (kids(i), "position", orig_axes_position);
                 bg_is_set = false;
                 if (fg_is_set)
                   fputs (plot_stream, "unset obj 2\n");
                 endif
               end_unwind_protect
+            case "uimenu"
+              ## ignore uimenu objects
             otherwise
               error ("__go_draw_figure__: unknown object class, %s", type);
           endswitch
         endfor
         fputs (plot_stream, "\nunset multiplot;\n");
       else
         fputs (plot_stream, "\nreset; clear;\n");
         fflush (plot_stream);
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -156,16 +156,17 @@ plot_FCN_FILES = \
   plot/subplot.m \
   plot/surf.m \
   plot/surface.m \
   plot/surfc.m \
   plot/surfl.m \
   plot/surfnorm.m \
   plot/text.m \
   plot/title.m \
+  plot/uimenu.m \
   plot/view.m \
   plot/waitforbuttonpress.m \
   plot/whitebg.m \
   plot/xlabel.m \
   plot/xlim.m \
   plot/ylabel.m \
   plot/ylim.m \
   plot/zlabel.m \
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/uimenu.m
@@ -0,0 +1,106 @@
+## Copyright (C) 2010 Kai Habel
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} uimenu (@var{property}, @var{value}, @dots{})
+## @deftypefnx {Function File} {} uimenu (@var{h}, @var{property}, @var{value}, @dots{})
+## Create an uimenu object and return a handle to it. If @var{h} is ommited then
+## a top level menu entry for the current figure is created. If @var{h} is given then a 
+## submenu relative to @var{h} is created.
+## 
+## Uimenu objects have the following specific properties:
+##
+## @table @code
+## @item "accelerator"
+## A string containg the key combination together with CTRL to execute this
+## menu entry (e.g. "x" for CTRL+x).
+##
+## @item "callback"
+## Is the function called when this menu entry is executed. It can be either a 
+## function string (e.g. "myfun"), a function handle (e.g. @@myfun) or a cell
+## array containing the function handle and arguments for the callback
+## function (e.g. @{@@myfun, arg1, arg2@}).
+##
+## @item "checked"
+## Can be set "on" or "off". Sets a mark at this menu entry.
+##
+## @item "enable"
+## Can be set "on" or "off". If disabled the menu entry cannot be selected and it is
+## grayed out.
+## 
+## @item "foregroundcolor"
+## A color value setting the text color for this menu entry.
+##
+## @item "label"
+## A string containing the label for this menu entry. A "&"-symbol can be used to mark
+## the "accelerator" character (e.g. "E&xit")
+##
+## @item "position"
+## An scalar value containing the relative menu position. The entry with the lowest
+## value is at the first position starting from left or top.
+##
+## @item "separator"
+## Can be set "on" or "off". If enabled it draws a separator line above the current 
+## position. It is ignored for top level entries.
+##
+##
+## @end table
+##
+## Examples:
+##
+## @example
+## @group
+## f = uimenu("label", "&File", "accelerator", "f");
+## e = uimenu("label", "&Edit", "accelerator", "e");
+## uimenu(f, "label", "Close", "accelerator", "q", "callback", "close (gcf)");
+## uimenu(e, "label", "Toggle &Grid", "accelerator", "g", "callback", "grid (gca)");
+## @end group
+## @end example
+## @seealso{figure}
+## @end deftypefn
+
+## Author: Kai Habel
+
+function hui = uimenu (varargin)
+
+  args = varargin;
+  if (nargin == 0)
+    h = gcf ();
+  elseif (nargin == 1)
+    if (ishandle (args{1}))
+      h = args{1};
+      args(1) = [];
+    else
+      error ("expected handle as first argument");
+    endif
+  else
+    if (ishandle (args{1}))
+      h = args{1};
+      args(1) = [];
+    else
+      h = gcf ();
+    endif
+  endif
+  
+  tmp = __go_uimenu__ (h, args{:});
+
+  if (nargout > 0)
+    hui = tmp;
+  endif
+
+endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,16 @@
+2010-10-25  Kai Habel  <kai.habel@gmx.de>
+
+	* plot/uimenu.m: New function
+	* plot/__go_draw_figure__.m: Ignore uimenu objects for gnuplot
+	backend
+	* plot/module.mk (plot_FCN_FILES): Add it to the list.
+
+
 2010-10-24  Rik  <octave@nomad.inbox5.com>
 
 	* DLD-FUNCTIONS/tril.cc, syscalls.cc: Docstring improvements.
 
 2010-10-24  Rik  <octave@nomad.inbox5.com>
 
 	* variables.cc: Deprecate is_global function
 
diff --git a/src/DLD-FUNCTIONS/fltk_backend.cc b/src/DLD-FUNCTIONS/fltk_backend.cc
--- a/src/DLD-FUNCTIONS/fltk_backend.cc
+++ b/src/DLD-FUNCTIONS/fltk_backend.cc
@@ -36,21 +36,25 @@ To initialize:
 #if defined (HAVE_FLTK)
 
 #include <map>
 #include <set>
 #include <sstream>
 #include <iostream>
 
 #include <FL/Fl.H>
-#include <FL/Fl_Window.H>
-#include <FL/Fl_Output.H>
+#include <FL/Fl_Box.H>
 #include <FL/Fl_Button.H>
-#include <FL/Fl_Box.H>
+#include <FL/Fl_Choice.H>
 #include <FL/Fl_Gl_Window.H>
+#include <FL/Fl_Menu_Bar.H>
+#include <FL/Fl_Menu_Button.H>
+#include <FL/Fl_Output.H>
+#include <Fl/Fl_File_Chooser.H>
+#include <FL/Fl_Window.H>
 #include <FL/fl_ask.H>
 #include <FL/fl_draw.H>
 #include <FL/gl.h>
 
 #include "cmd-edit.h"
 #include "lo-ieee.h"
 
 #include "defun-dld.h"
@@ -76,16 +80,18 @@ g - toggle grid\n\
 \n\
 Mouse\n\
 left drag - pan\n\
 mouse wheel - zoom\n\
 right drag - rectangle zoom\n\
 left double click - autoscale\n\
 ";
 
+graphics_object xget_ancestor (const graphics_object& go_arg,
+                                      const std::string& type);
 
 class OpenGL_fltk : public Fl_Gl_Window
 {
 public:
   OpenGL_fltk (int xx, int yy, int ww, int hh, double num)
     : Fl_Gl_Window (xx, yy, ww, hh, 0), number (num), renderer (),
       in_zoom (false), zoom_box (),  print_fid (-1)
   {
@@ -106,16 +112,23 @@ public:
   void set_zoom_box (const Matrix& zb) { zoom_box = zb; }
   
   void print (const int fid, const std::string& term)
   {
     print_fid  = fid;
     print_term  = term;
   }
 
+  void resize (int xx, int yy, int ww, int hh)
+  {
+    Fl_Gl_Window::resize (xx, yy, ww, hh);
+    setup_viewport (ww, hh);
+    redraw ();
+  }
+  
 private:
   double number;
   opengl_renderer renderer;
   bool in_zoom;
   // (x1,y1,x2,y2)
   Matrix zoom_box;
 
   int print_fid;
@@ -147,23 +160,16 @@ private:
       {
         renderer.draw (gh_manager::lookup (number));
 
         if (zoom ())
           overlay ();
       }
   }
 
-  void resize (int xx, int yy, int ww, int hh)
-  {
-    Fl_Gl_Window::resize (xx, yy, ww, hh);
-    setup_viewport (ww, hh);
-    redraw ();
-  }
-
   void zoom_box_vertex (void)
   {
     glVertex2d (zoom_box(0), h () - zoom_box(1));
     glVertex2d (zoom_box(0), h () - zoom_box(3));
     glVertex2d (zoom_box(2), h () - zoom_box(3));
     glVertex2d (zoom_box(2), h () - zoom_box(1));
     glVertex2d (zoom_box(0), h () - zoom_box(1));
   }
@@ -214,28 +220,405 @@ private:
 
     return retval;
   }
 };
 
 // Parameter controlling how fast we zoom when using the scrool wheel.
 static double wheel_zoom_speed = 0.05;
 
+void script_cb(Fl_Widget*, void* data)
+  {
+    static_cast<uimenu::properties*> (data)->execute_callback ();
+  }
+  
+
+class fltk_uimenu
+{
+public:
+  fltk_uimenu (int xx, int yy, int ww, int hh)
+    {
+      menubar = new
+        Fl_Menu_Bar(xx, yy, ww, hh);
+    }
+
+  int items_to_show (void)
+    {
+      //returns the number of visible menu items
+      int len = menubar->size ();
+      int n = 0;
+      for (int t = 0; t < len; t++ )
+        {
+          const Fl_Menu_Item *m = static_cast<const Fl_Menu_Item*>(&(menubar->menu ()[t]));
+          if ((m->label () != NULL) && m->visible ())
+            n++;
+        }
+
+      return n;
+    }
+
+  void show (void)
+    {
+      menubar->show ();
+    }
+
+  void hide (void)
+    {
+      menubar->hide ();
+    }
+
+   bool is_visible (void)
+    {
+      return menubar->visible ();
+    }
+
+  int find_index_by_name (std::string findname)
+    {
+      // This function is derived from Greg Ercolano's function
+      // int GetIndexByName(...), see:
+      // http://seriss.com/people/erco/fltk/#Menu_ChangeLabel
+      // He agreed via PM that it can be included in octave using GPLv3
+      // Kai Habel (14.10.2010)
+
+      std::string menupath;
+      for (int t = 0; t < menubar->size (); t++ )
+        {
+          Fl_Menu_Item *m = const_cast<Fl_Menu_Item*>(&(menubar->menu ()[t]));
+          if (m->submenu ())
+            {
+              // item has submenu
+              if (!menupath.empty ())
+                menupath += "/";
+              menupath += m->label ();
+
+              if (menupath.compare (findname) == 0 )
+                return (t);
+            }
+          else
+            {
+              // End of submenu? Pop back one level.
+              if (m->label () == NULL)
+                {
+                  std::size_t idx = menupath.find_last_of ("/");
+                  if (idx != std::string::npos)
+                    menupath.erase (idx);
+                  else
+                    menupath.clear ();
+                  continue;
+                }   
+              // Menu item?
+              std::string itempath = menupath;
+              if (!itempath.empty ())
+                itempath += "/";              
+              itempath += m->label ();
+
+              if (itempath.compare (findname) == 0)
+                return (t);
+            }
+        }
+      return (-1);
+    }
+
+  template <class T>
+  Matrix find_uimenu_children (T& prop) const
+    {
+      octave_idx_type k = 0;
+      
+      Matrix uimenu_childs = prop.get_children ();
+      Matrix pos = Matrix (uimenu_childs.numel (), 1);
+      
+      for (octave_idx_type ii = 0; ii < uimenu_childs.numel (); ii++)
+      {
+        graphics_handle kid = uimenu_childs (ii);
+        
+        if (gh_manager::is_handle_visible (kid))
+          {  
+            graphics_object kidgo = gh_manager::get_object (kid);
+            if (kidgo.isa ("uimenu"))
+              {
+                uimenu_childs(k) = uimenu_childs(ii);
+                pos(k++) =
+                  dynamic_cast<uimenu::properties&> (kidgo.get_properties ()).get_position ();
+                std::string lbl =
+                  dynamic_cast<uimenu::properties&> (kidgo.get_properties ()).get_fltk_label ();
+              }
+          }
+      }
+      
+      uimenu_childs.resize (k, 1);    
+      pos.resize (k, 1);
+      Matrix retval = Matrix (k, 1);
+      // Don't know if this is the best method to sort.
+      // Can we avoid the for loop?
+      Array<octave_idx_type> sidx = pos.sort_rows_idx (DESCENDING);
+      for (octave_idx_type ii = 0; ii < k; ii++)
+        retval(ii) = uimenu_childs (sidx(ii));
+       
+      return retval;
+    }
+    
+  void update_submenu (uimenu::properties& uimenup)
+    {
+      Matrix uimenu_ch = find_uimenu_children (uimenup);
+
+      if (uimenu_ch.numel () > 0) 
+        {
+          std::string fltk_label = uimenup.get_fltk_label ();
+          int idx = find_index_by_name (fltk_label.c_str ());
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(&menubar->menu () [idx]);
+          menubar->mode(idx, item->flags|FL_SUBMENU);
+        }
+    }
+
+  void delete_entry(uimenu::properties& uimenup)
+    {
+      std::string fltk_label = uimenup.get_fltk_label ();
+      int idx = find_index_by_name (fltk_label.c_str ());
+
+      if (idx >= 0)
+        menubar->remove (idx);
+    }
+
+  void update_accelerator (uimenu::properties& uimenup)
+    {
+      std::string fltk_label = uimenup.get_fltk_label ();
+      if (!fltk_label.empty ())
+        {
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          std::string acc = uimenup.get_accelerator ();
+          if (acc.length () > 0)
+            {
+              int key = FL_CTRL + acc[0];
+              item->shortcut (key);
+            }
+        }
+    }
+
+  void update_callback (uimenu::properties& uimenup)
+    {
+      std::string fltk_label = uimenup.get_fltk_label ();
+      if (!fltk_label.empty ())
+        {
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          if (!uimenup.get_callback ().is_empty ())
+            item->callback(static_cast<Fl_Callback*>(script_cb), //callback
+                          static_cast<void*>(&uimenup));        //callback data
+          else
+            item->callback(NULL, static_cast<void*>(0));
+        }
+    }
+            
+  void update_enable (uimenu::properties& uimenup)
+    {
+      std::string fltk_label = uimenup.get_fltk_label ();
+      if (!fltk_label.empty ())
+        {
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          if (uimenup.is_enable ())
+            item->activate ();
+          else
+            item->deactivate ();
+        }
+    }
+
+  void update_foregroundcolor (uimenu::properties& uimenup)
+    {
+      std::string fltk_label = uimenup.get_fltk_label ();
+      if (!fltk_label.empty ())
+        {
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          Matrix rgb = uimenup.get_foregroundcolor_rgb ();
+          item->labelcolor(fl_rgb_color(static_cast<uchar>(floor (rgb(0)*255)),
+                                        static_cast<uchar>(floor (rgb(1)*255)),
+                                        static_cast<uchar>(floor (rgb(2)*255))));
+        }
+    }
+
+  void update_seperator (uimenu::properties& uimenup)
+    {
+      // Matlab places the separator before the current
+      // menu entry, while fltk places it after. So we need to find
+      // the previous item in this menu/submenu. (Kai)
+      std::string fltk_label = uimenup.get_fltk_label ();
+      if (!fltk_label.empty ())
+        {
+          int itemflags = 0, idx;
+          int curr_idx = find_index_by_name(fltk_label.c_str ());
+
+          for (idx = curr_idx - 1; idx >= 0; idx--)
+            { 
+              Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(&menubar->menu () [idx]);
+              itemflags = item->flags;
+              if (item->label () != NULL)
+                break;
+            }
+
+          if (uimenup.is_separator ())
+            {
+              if (idx >= 0 && !(itemflags & FL_SUBMENU))
+                menubar->mode (idx, itemflags | FL_MENU_DIVIDER);
+            }
+          else
+            menubar->mode (idx, itemflags & (~FL_MENU_DIVIDER));
+        }
+    }
+
+  void update_visible (uimenu::properties& uimenup)
+    {
+      std::string fltk_label = uimenup.get_fltk_label ();
+      if (!fltk_label.empty ())
+        {
+          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
+          if (uimenup.is_visible ())
+            item->show ();
+          else
+            item->hide ();
+        }
+    }
+    
+  void add_entry (uimenu::properties& uimenup)
+    {
+
+      std::string fltk_label = uimenup.get_fltk_label ();
+      
+      if (!fltk_label.empty ())
+        {
+          bool item_added = false;
+          do
+            {  
+              const Fl_Menu_Item* item = menubar->find_item(fltk_label.c_str ());
+              
+              if (item == NULL)
+                {
+                  Matrix uimenu_ch = find_uimenu_children (uimenup);
+                  int len = uimenu_ch.numel ();
+                  int flags = 0;
+                  if (len > 0) 
+                    flags = FL_SUBMENU;
+                  if ((len == 0) && (uimenup.is_checked ()))
+                    flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
+                  menubar->add(fltk_label.c_str (), 0, 0, 0, flags);      
+                  item_added = true;
+                }
+              else
+                {
+                  //avoid duplicate menulabels
+                  std::size_t idx1 = fltk_label.find_last_of ("(");
+                  std::size_t idx2 = fltk_label.find_last_of (")");
+                  int len = idx2 - idx1;
+                  int val = 1;
+                  if (len > 0)
+                    {
+                      std::string valstr = fltk_label.substr (idx1 + 1, len - 1);
+                      fltk_label.erase(idx1, len + 1);
+                      val = atoi (valstr.c_str ());
+                      if ((val > 0) && (val < 99))
+                        val++;
+                    }
+                  std::ostringstream valstream;
+                  valstream << val;
+                  fltk_label += "(" + valstream.str () + ")";
+                }
+            }
+          while (!item_added);
+          uimenup.set_fltk_label (fltk_label);
+        }
+    }  
+
+  void add_to_menu (uimenu::properties& uimenup)
+    {
+      Matrix kids = find_uimenu_children (uimenup);
+      int len = kids.length ();
+      std::string fltk_label = uimenup.get_fltk_label ();
+      
+      add_entry (uimenup);
+      update_foregroundcolor (uimenup);
+      update_callback (uimenup);
+      update_accelerator (uimenup);
+      update_enable (uimenup);
+      update_visible (uimenup);
+      update_seperator (uimenup);
+
+      for (octave_idx_type ii = 0; ii < len; ii++)
+        {
+          graphics_handle kid = kids (len - (ii + 1));
+          graphics_object kgo = gh_manager::get_object (kid);
+          uimenu::properties& kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
+          if (kgo.valid_object ())
+            add_to_menu (kprop);
+        }
+      
+      
+    }
+
+  void add_to_menu (figure::properties& figp)
+    {
+      Matrix kids = find_uimenu_children (figp);
+      int len = kids.length ();
+      menubar->clear ();      
+      for (octave_idx_type ii = 0; ii < len; ii++)
+        {
+          graphics_handle kid = kids (len - (ii + 1));
+          graphics_object kgo = gh_manager::get_object (kid);
+          uimenu::properties& kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
+          if (kgo.valid_object ())
+            add_to_menu (kprop);
+        }
+    }
+
+  template <class T_prop>
+  void remove_from_menu (T_prop& prop)
+    {
+      Matrix kids;
+      std::string type = prop.get_type ();
+      kids = find_uimenu_children (prop);    
+      int len = kids.length ();
+
+      for (octave_idx_type ii = 0; ii < len; ii++)
+        {
+          graphics_handle kid = kids (len - (ii + 1));
+          graphics_object kgo = gh_manager::get_object (kid);
+          uimenu::properties kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
+          if (kgo.valid_object ())
+            remove_from_menu (kprop);
+        }
+
+      if (type.compare("uimenu") == 0)
+        delete_entry(dynamic_cast<uimenu::properties&>(prop));
+      else if (type.compare("figure") == 0)
+        menubar->clear ();
+    }
+
+  ~fltk_uimenu()
+    {
+      delete menubar;
+    }
+    
+private:
+  Fl_Menu_Bar* menubar;
+};
+
 class plot_window : public Fl_Window
 {
+  friend class fltk_uimenu;
 public:
   plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp)
     : Fl_Window (xx, yy, ww, hh, "octave"), window_label (), shift (0),
       ndim (2), fp (xfp), canvas (0), autoscale (0), togglegrid (0),
       panzoom (0), rotate (0), help (0), status (0)
   {
     callback (window_close, static_cast<void*> (this));
 
     begin ();
     {
+      
+      uimenu = new
+        fltk_uimenu(0, 0, ww, menu_h);
+      uimenu->hide ();
+      
       canvas = new
         OpenGL_fltk (0, 0, ww , hh - status_h, number ());
 
       bottom = new 
         Fl_Box (0, 
                 hh - status_h, 
                 ww, 
                 status_h);
@@ -303,56 +686,158 @@ public:
       status->textsize (10);
       status->box (FL_ENGRAVED_BOX);
 
       // This allows us to have a valid OpenGL context right away.
       canvas->mode (FL_DEPTH | FL_DOUBLE );
       if (fp.is_visible ())
         {
           show ();
-          canvas->show ();
-          canvas->make_current ();
+	  if (fp.get_currentaxes ().ok())
+	    show_canvas ();
+	  else
+            hide_canvas ();
         }
     }
     end ();
 
     status->show ();
     autoscale->show ();
     togglegrid->show ();
     panzoom->show ();
     rotate->show ();
 
     set_name ();
     resizable (canvas);
     size_range (4*status_h, 2*status_h);
     gui_mode = (ndim == 3 ? rotate_zoom : pan_zoom);
+    uimenu->add_to_menu (fp);
+    if (uimenu->items_to_show ())
+      show_menubar ();
+    else
+      hide_menubar ();
   }
 
   ~plot_window (void)
   {
     canvas->hide ();
     status->hide ();
+    uimenu->hide ();
     this->hide ();
     delete canvas;
     delete status;
+    delete uimenu;
   }
 
   // FIXME -- this could change.
   double number (void) { return fp.get___myhandle__ ().value (); }
 
   void print (const int fid, const std::string& term)
   {
     canvas->print (fid, term);
 
     // Print immediately so the output file will exist when the drawnow
     // command is done.
     mark_modified ();
     Fl::wait (fltk_maxtime);
   }
 
+  void show_menubar (void)
+  {
+    int dm = menu_h;
+    if (uimenu->is_visible ())
+      dm = 0;
+    canvas->resize (canvas->x (),
+                    canvas->y () + dm,
+                    canvas->w (),
+                    canvas->h () - dm);
+    uimenu->show ();
+    mark_modified ();
+  }
+  
+  void hide_menubar (void)
+  {
+    int dm = menu_h;
+    if (!uimenu->is_visible ())
+      dm = 0;
+    canvas->resize (canvas->x (),
+                    canvas->y () - dm,
+                    canvas->w (),
+                    canvas->h () + dm);
+    uimenu->hide ();
+    mark_modified (); 
+  }
+  
+  void uimenu_update(graphics_handle gh, int id)
+  {
+    graphics_object uimenu_obj = gh_manager::get_object (gh);
+    
+    if (uimenu_obj.valid_object () && uimenu_obj.isa ("uimenu"))
+      {
+        uimenu::properties& uimenup =
+          dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
+        std::string fltk_label = uimenup.get_fltk_label();
+        graphics_object fig = xget_ancestor(uimenu_obj,"figure");
+        figure::properties& figp =
+          dynamic_cast<figure::properties&> (fig.get_properties ());
+        
+        switch(id)
+          {
+            case base_properties::BEINGDELETED:
+              uimenu->remove_from_menu (uimenup);
+              break;
+            case base_properties::VISIBLE:
+              uimenu->update_visible (uimenup);
+              break;
+            case uimenu::properties::ACCELERATOR:
+              uimenu->update_accelerator (uimenup);
+              break;
+            case uimenu::properties::CALLBACK:
+              uimenu->update_callback (uimenup);
+              break;
+            case uimenu::properties::CHECKED:
+              uimenu->add_to_menu (figp);//rebuilding entire menu
+              break;
+            case uimenu::properties::ENABLE:
+              uimenu->update_enable (uimenup);
+              break;
+            case uimenu::properties::FOREGROUNDCOLOR:
+              uimenu->update_foregroundcolor (uimenup);
+              break;
+            case uimenu::properties::LABEL:
+              uimenu->add_to_menu (figp);//rebuilding entire menu
+              break;
+            case uimenu::properties::POSITION:
+              uimenu->add_to_menu (figp);//rebuilding entire menu
+              break;
+            case uimenu::properties::SEPARATOR:
+              uimenu->update_seperator (uimenup);
+              break;
+          }
+          
+          if (uimenu->items_to_show ())
+            show_menubar ();
+          else
+            hide_menubar ();
+          
+          mark_modified();
+      }
+  }
+
+  void show_canvas (void)
+  {
+    canvas->show ();
+    canvas->make_current ();
+  }
+  
+  void hide_canvas (void)
+  {
+    canvas->hide ();
+  }
+  
   void mark_modified (void)
   {
     damage (FL_DAMAGE_ALL);
     canvas->damage (FL_DAMAGE_ALL);
     ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
     if (ndim == 3)
       rotate->activate ();
@@ -377,38 +862,41 @@ private:
   // Mod keys status
   int shift;
 
   // Number of dimensions, 2 or 3.
   int ndim;
 
   // Interactive Mode
   enum { pan_zoom, rotate_zoom } gui_mode;
-  
+ 
   // Figure properties.
   figure::properties& fp;
 
   // Status area height.
   static const int status_h = 20;
 
+  // Menu height
+  static const int menu_h = 20;
+
   // Window callback.
   static void window_close (Fl_Widget*, void* data)
   {
     octave_value_list args;
     args(0) = static_cast<plot_window*> (data)->number ();
     feval ("close", args);
   }
 
   // Button callbacks.
   static void button_callback (Fl_Widget* ww, void* data)
   {
-    static_cast<plot_window*> (data)->button_press (ww);
+    static_cast<plot_window*> (data)->button_press (ww, data);
   }
 
-  void button_press (Fl_Widget* widg)
+  void button_press (Fl_Widget* widg, void*)
   {
     if (widg == autoscale)
       axis_auto ();
 
     if (widg == togglegrid)
       toggle_grid ();
     
     if (widg == panzoom)
@@ -416,16 +904,17 @@ private:
     
     if (widg == rotate && ndim == 3)
       gui_mode = rotate_zoom;
 
     if (widg == help)
       fl_message ("%s", help_text);
   }
 
+  fltk_uimenu* uimenu;
   OpenGL_fltk* canvas;
   Fl_Box*    bottom;
   Fl_Button* autoscale;
   Fl_Button* togglegrid;
   Fl_Button* panzoom;
   Fl_Button* rotate;
   Fl_Button* help;
   Fl_Output* status;
@@ -437,17 +926,19 @@ private:
     args(1) = "auto";
     feval ("axis", args);
     mark_modified ();
   }
 
   void toggle_grid (void)
   {
     octave_value_list args;
-    args(0) = fp.get_currentaxes ().as_octave_value ();
+    if (fp.get_currentaxes ().ok ())
+      args(0) = fp.get_currentaxes ().as_octave_value ();
+    
     feval ("grid", args);
     mark_modified ();
   }
   
   void pixel2pos 
   (graphics_handle ax, int px, int py, double& xx, double& yy) const
   {
     pixel2pos ( gh_manager::get_object (ax), px, py, xx, yy);
@@ -534,25 +1025,28 @@ private:
     
          status->value (cbuf.str ().c_str ());
          status->redraw ();
        }
   }
   
   void set_currentpoint (int px, int py)
   {
-    Matrix pos (1,2,0);
-    pos(0) = px;
-    pos(1) = h () - status_h - py;
-    fp.set_currentpoint (pos);
+    if (!fp.is_beingdeleted ())
+      {
+        Matrix pos (1,2,0);
+        pos(0) = px;
+        pos(1) = h () - status_h - menu_h - py;
+        fp.set_currentpoint (pos);
+      }
   }
 
   void set_axes_currentpoint (graphics_object ax, int px, int py)
   {
-    if (ax)
+    if (ax.valid_object ())
       {
         axes::properties& ap = 
           dynamic_cast<axes::properties&> (ax.get_properties ());
     
         double xx, yy;
         pixel2pos (ax, px, py, xx, yy);
 
         Matrix pos (2,3,0);
@@ -610,261 +1104,271 @@ private:
   void resize (int xx,int yy,int ww,int hh)
   {
     Fl_Window::resize (xx, yy, ww, hh);
 
     Matrix pos (1,4,0);
     pos(0) = xx;
     pos(1) = yy;
     pos(2) = ww;
-    pos(3) = hh - status_h;
+    pos(3) = hh - status_h - menu_h;
 
     fp.set_position (pos);
   }
 
   void draw (void)
   {
     Matrix pos = fp.get_position ().matrix_value ();
-    Fl_Window::resize (pos(0), pos(1) , pos(2), pos(3) + status_h);
+    Fl_Window::resize (pos(0), pos(1) , pos(2), pos(3) + status_h + menu_h);
 
     return Fl_Window::draw ();
   }
 
   int handle (int event)
   {
     static int px0,py0;
     static graphics_object ax0;
 
+    graphics_handle gh;
+
+    graphics_object fig = gh_manager::get_object (fp.get___myhandle__ ());
     int retval = Fl_Window::handle (event);
 
     // We only handle events which are in the canvas area.
-    if (Fl::event_y () >= h() - status_h)
+    if (!Fl::event_inside(canvas))
       return retval;
 
-    switch (event)
+    if (!fp.is_beingdeleted ())
       {
-      case FL_KEYDOWN:
-        {
-          int key = Fl::event_key ();
+        switch (event)
+          {
+          case FL_KEYDOWN:
+            {
+              int key = Fl::event_key ();
 
-          shift |= key2shift (key);
-          int key_a = key2ascii (key);
-          if (key_a && fp.get_keypressfcn ().is_defined ()) 
-            {
-              octave_scalar_map evt;
-              evt.assign ("Character", key_a);
-              evt.assign ("Key", std::tolower (key_a));
-              evt.assign ("Modifier", modifier2cell ());
-              fp.execute_keypressfcn (evt);
+              shift |= key2shift (key);
+              int key_a = key2ascii (key);
+              if (key_a && fp.get_keypressfcn ().is_defined ()) 
+                {
+                  Octave_map evt;
+                  evt.assign ("Character", octave_value (key_a));
+                  evt.assign ("Key", octave_value (std::tolower (key_a)));
+                  evt.assign ("Modifier", octave_value (modifier2cell ()));
+                  fp.execute_keypressfcn (evt);
+                }
+              switch (key)
+                {
+                case 'a':
+                case 'A':
+                  axis_auto ();
+                break;
+
+                case 'g':
+                case 'G':
+                  toggle_grid ();
+                break;
+
+                case 'p':
+                case 'P':
+                  gui_mode = pan_zoom;
+                break;
+
+                case 'r':
+                case 'R':
+                  gui_mode = rotate_zoom;
+                break;
+                }
             }
-          switch (key)
-            {
-            case 'a':
-            case 'A':
-              axis_auto ();
-            break;
-
-            case 'g':
-            case 'G':
-              toggle_grid ();
-            break;
-
-            case 'p':
-            case 'P':
-              gui_mode = pan_zoom;
             break;
 
-            case 'r':
-            case 'R':
-              if (ndim == 3)
-                gui_mode = rotate_zoom;
-              else
-                gui_mode = pan_zoom;
-            break;
-            }
-        }
-        break;
+          case FL_KEYUP:
+            {
+              int key = Fl::event_key ();
 
-      case FL_KEYUP:
-        {
-          int key = Fl::event_key ();
-
-          shift &= (~key2shift (key));
-          int key_a = key2ascii (key);
-          if (key_a && fp.get_keyreleasefcn ().is_defined ())
-            {
-              octave_scalar_map evt;
-              evt.assign ("Character", key_a);
-              evt.assign ("Key", std::tolower (key_a));
-              evt.assign ("Modifier", modifier2cell ());
-              fp.execute_keyreleasefcn (evt);
+              shift &= (~key2shift (key));
+              int key_a = key2ascii (key);
+              if (key_a && fp.get_keyreleasefcn ().is_defined ())
+                {
+                  Octave_map evt;
+                  evt.assign ("Character", octave_value (key_a));
+                  evt.assign ("Key", octave_value (std::tolower (key_a)));
+                  evt.assign ("Modifier", octave_value (modifier2cell ()));
+                  fp.execute_keyreleasefcn (evt);
+                }
             }
-        }
-        break;
+            break;
 
-      case FL_MOVE:
-        pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y ()),
-                      Fl::event_x (), Fl::event_y ());
-        break;
+          case FL_MOVE:
+            pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y ()),
+                          Fl::event_x (), Fl::event_y ());
+            break;
 
-      case FL_PUSH:
-        px0 = Fl::event_x ();
-        py0 = Fl::event_y ();
-        ax0 = gh_manager::get_object (pixel2axes_or_ca (px0, py0));
-
-        set_currentpoint (Fl::event_x (), Fl::event_y ());
-        set_axes_currentpoint (ax0, px0, py0);
-        fp.execute_windowbuttondownfcn ();
-        
+          case FL_PUSH:
+            px0 = Fl::event_x ();
+            py0 = Fl::event_y ();
 
-        if (Fl::event_button () == 1 || Fl::event_button () == 3)
-          return 1;
-        break;
+            set_currentpoint (Fl::event_x (), Fl::event_y ());
+            
+            gh = pixel2axes_or_ca (px0, py0);
 
-      case FL_DRAG:
-        if (fp.get_windowbuttonmotionfcn ().is_defined ())
-          {
-            set_currentpoint (Fl::event_x (), Fl::event_y ());
-            fp.execute_windowbuttonmotionfcn ();
-          }
-        
-        if (Fl::event_button () == 1)
-          {
-            if (ax0 && ax0.isa ("axes"))
+            if (gh.ok ())
               {
-                if (gui_mode == pan_zoom)
-                  pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
-                else
-                  view2status (ax0);
-                axes::properties& ap = 
-                  dynamic_cast<axes::properties&> (ax0.get_properties ());
+                ax0 = gh_manager::get_object (gh);
+                set_axes_currentpoint (ax0, px0, py0);
+              }
               
-                double x0, y0, x1, y1;
-                Matrix pos = fp.get_position ().matrix_value ();
-                pixel2pos (ax0, px0, py0, x0, y0);
-                pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
-                
-                if (gui_mode == pan_zoom)
-                  ap.translate_view (x0 - x1, y0 - y1);
-                else if (gui_mode == rotate_zoom)
-                  {
-                    double daz, del;
-                    daz = (Fl::event_x () - px0) / pos(2) * 360;
-                    del = (Fl::event_y () - py0) / pos(3) * 360;
-                    ap.rotate_view (del, daz);
-                  }
+            fp.execute_windowbuttondownfcn ();
 
-                px0 = Fl::event_x ();
-                py0 = Fl::event_y ();
-                mark_modified ();
-              }
-            return 1;
-          }
-        else if (Fl::event_button () == 3)
-          {
-            pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
-            Matrix zoom_box (1,4,0);
-            zoom_box (0) = px0;
-            zoom_box (1) = py0;
-            zoom_box (2) =  Fl::event_x ();
-            zoom_box (3) =  Fl::event_y ();
-            canvas->set_zoom_box (zoom_box);
-            canvas->zoom (true);
-            canvas->redraw ();
-          }
+            if (Fl::event_button () == 1 || Fl::event_button () == 3)
+              return 1;
+
+            break;
 
-        break;
-
-      case FL_MOUSEWHEEL:
-        {
-          graphics_object ax = 
-            gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (), 
-                                                      Fl::event_y ()));                                                                      
-          if (ax && ax.isa ("axes"))
-            {
-              axes::properties& ap = 
-                dynamic_cast<axes::properties&> (ax.get_properties ());
-              
-              // Determine if we're zooming in or out.
-              const double factor = 
-                (Fl::event_dy () > 0) ? 1.0 + wheel_zoom_speed : 1.0 - wheel_zoom_speed;
-              
-              // Get the point we're zooming about.
-              double x1, y1;
-              pixel2pos (ax, Fl::event_x (), Fl::event_y (), x1, y1);
-              
-              ap.zoom_about_point (x1, y1, factor, false);
-              mark_modified ();
-            }
-        }
-      return 1;
-
-      case FL_RELEASE:
-        if (fp.get_windowbuttonupfcn ().is_defined ())
-          {
-            set_currentpoint (Fl::event_x (), Fl::event_y ());
-            fp.execute_windowbuttonupfcn ();
-          }
-       
-        if (Fl::event_button () == 1)
-          {
-            if ( Fl::event_clicks () == 1)
+          case FL_DRAG:
+            if (fp.get_windowbuttonmotionfcn ().is_defined ())
+              {
+                set_currentpoint (Fl::event_x (), Fl::event_y ());
+                fp.execute_windowbuttonmotionfcn ();
+              }
+            
+            if (Fl::event_button () == 1)
               {
                 if (ax0 && ax0.isa ("axes"))
                   {
-                    axes::properties& ap =
+                    if (gui_mode == pan_zoom)
+                      pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
+                    else
+                      view2status (ax0);
+                    axes::properties& ap = 
                       dynamic_cast<axes::properties&> (ax0.get_properties ());
-                    ap.set_xlimmode("auto");
-                    ap.set_ylimmode("auto");
-                    ap.set_zlimmode("auto");
-                    mark_modified ();
-                  }
-              }
-          }
-        if (Fl::event_button () == 3)
-          {
-            // End of drag -- zoom.
-            if (canvas->zoom ())
-              {
-                canvas->zoom (false);
-                double x0,y0,x1,y1;
-                if (ax0 && ax0.isa ("axes"))
-                  {
-                    axes::properties& ap =
-                      dynamic_cast<axes::properties&> (ax0.get_properties ());
+                  
+                    double x0, y0, x1, y1;
+                    Matrix pos = fp.get_position ().matrix_value ();
                     pixel2pos (ax0, px0, py0, x0, y0);
                     pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
-                    Matrix xl (1,2,0);
-                    Matrix yl (1,2,0);
-                    if (x0 < x1)
+                    
+                    if (gui_mode == pan_zoom)
+                      ap.translate_view (x0 - x1, y0 - y1);
+                    else if (gui_mode == rotate_zoom)
                       {
-                        xl(0) = x0;
-                        xl(1) = x1;
-                      }
-                    else
-                      {
-                        xl(0) = x1;
-                        xl(1) = x0;
+                        double daz, del;
+                        daz = (Fl::event_x () - px0) / pos(2) * 360;
+                        del = (Fl::event_y () - py0) / pos(3) * 360;
+                        ap.rotate_view (del, daz);
                       }
-                    if (y0 < y1)
-                      {
-                        yl(0) = y0;
-                        yl(1) = y1;
-                      }
-                    else
-                      {
-                        yl(0) = y1;
-                        yl(1) = y0;
-                      }
-                    ap.zoom (xl, yl);
+
+                    px0 = Fl::event_x ();
+                    py0 = Fl::event_y ();
                     mark_modified ();
                   }
+                return 1;
               }
+            else if (Fl::event_button () == 3)
+              {
+                pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
+                Matrix zoom_box (1,4,0);
+                zoom_box (0) = px0;
+                zoom_box (1) = py0;
+                zoom_box (2) =  Fl::event_x ();
+                zoom_box (3) =  Fl::event_y ();
+                canvas->set_zoom_box (zoom_box);
+                canvas->zoom (true);
+                canvas->redraw ();
+              }
+
+            break;
+
+          case FL_MOUSEWHEEL:
+            {
+              graphics_object ax = 
+                gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (), 
+                                                          Fl::event_y ()));                                                                      
+              if (ax && ax.isa ("axes"))
+                {
+                  axes::properties& ap = 
+                    dynamic_cast<axes::properties&> (ax.get_properties ());
+                  
+                  // Determine if we're zooming in or out.
+                  const double factor = 
+                    (Fl::event_dy () > 0) ? 1.0 + wheel_zoom_speed : 1.0 - wheel_zoom_speed;
+                  
+                  // Get the point we're zooming about.
+                  double x1, y1;
+                  pixel2pos (ax, Fl::event_x (), Fl::event_y (), x1, y1);
+                  
+                  ap.zoom_about_point (x1, y1, factor, false);
+                  mark_modified ();
+                }
+            }
+          return 1;
+
+          case FL_RELEASE:
+            if (fp.get_windowbuttonupfcn ().is_defined ())
+              {
+                set_currentpoint (Fl::event_x (), Fl::event_y ());
+                fp.execute_windowbuttonupfcn ();
+              }
+          
+            if (Fl::event_button () == 1)
+              {
+                if ( Fl::event_clicks () == 1)
+                  {
+                    if (ax0 && ax0.isa ("axes"))
+                      {
+                        axes::properties& ap =
+                          dynamic_cast<axes::properties&> (ax0.get_properties ());
+                        ap.set_xlimmode("auto");
+                        ap.set_ylimmode("auto");
+                        ap.set_zlimmode("auto");
+                        mark_modified ();
+                      }
+                  }
+              }
+            if (Fl::event_button () == 3)
+              {
+                // End of drag -- zoom.
+                if (canvas->zoom ())
+                  {
+                    canvas->zoom (false);
+                    double x0,y0,x1,y1;
+                    if (ax0 && ax0.isa ("axes"))
+                      {
+                        axes::properties& ap =
+                          dynamic_cast<axes::properties&> (ax0.get_properties ());
+                        pixel2pos (ax0, px0, py0, x0, y0);
+                        pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
+                        Matrix xl (1,2,0);
+                        Matrix yl (1,2,0);
+                        if (x0 < x1)
+                          {
+                            xl(0) = x0;
+                            xl(1) = x1;
+                          }
+                        else
+                          {
+                            xl(0) = x1;
+                            xl(1) = x0;
+                          }
+                        if (y0 < y1)
+                          {
+                            yl(0) = y0;
+                            yl(1) = y1;
+                          }
+                        else
+                          {
+                            yl(0) = y1;
+                            yl(1) = y0;
+                          }
+                        ap.zoom (xl, yl);
+                        mark_modified ();
+                      }
+                  }
+              }
+            break;
           }
-        break;
       }
 
     return retval;
   }
 };
 
 class figure_manager
 {
@@ -958,17 +1462,40 @@ public:
     return get_size (hnd2idx (gh));
   }
 
   static void print (const graphics_handle& gh , const int fid,  const std::string& term)
   {
     if (instance_ok ())
       instance->do_print (hnd2idx(gh), fid, term);
   }
+  
+  static void uimenu_update (const graphics_handle& figh, const graphics_handle& uimenuh, const int id)
+  {
+    if (instance_ok ())
+      instance->do_uimenu_update (hnd2idx(figh), uimenuh, id);
+  }
+  
+  static void update_canvas (const graphics_handle& gh, const graphics_handle& ca)
+  {
+    if (instance_ok ())
+      instance->do_update_canvas (hnd2idx(gh), ca);
+  }
+  
+  static void toggle_menubar_visibility (int fig_idx, bool menubar_is_figure)
+  {
+    if (instance_ok ())
+      instance->do_toggle_menubar_visibility (fig_idx, menubar_is_figure);
+  }
 
+  static void toggle_menubar_visibility (std::string fig_idx_str, bool menubar_is_figure)
+  {
+    toggle_menubar_visibility (str2idx (fig_idx_str), menubar_is_figure);
+  }
+  
 private:
 
   static figure_manager *instance;
 
   figure_manager (void) { }
 
   // No copying!
   figure_manager (const figure_manager&);
@@ -1023,16 +1550,30 @@ private:
           win->second->show ();
         else
           win->second->hide ();
 
         win->second->redraw ();
       }
   }
 
+  void do_toggle_menubar_visibility (int fig_idx, bool menubar_is_figure)
+  {
+    wm_iterator win;
+    if ((win = windows.find (fig_idx)) != windows.end ())
+      {
+	if (menubar_is_figure)
+          win->second->show_menubar ();
+        else
+          win->second->hide_menubar ();
+	
+        win->second->redraw ();
+      }
+  }
+  
   void do_mark_modified (int idx)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
         win->second->mark_modified ();
       }
   }
@@ -1064,16 +1605,38 @@ private:
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
         win->second->print (fid, term);
       }
   }
 
+  void do_uimenu_update (int idx, graphics_handle gh, int id)
+  {
+    wm_iterator win;
+    if ((win = windows.find (idx)) != windows.end ())
+      {
+        win->second->uimenu_update (gh, id);
+      }
+  }
+  
+  void do_update_canvas (int idx, graphics_handle ca)
+  {
+    wm_iterator win;
+    if ((win = windows.find (idx)) != windows.end ())
+      {
+        if (ca.ok ())
+          win->second->show_canvas ();
+        else
+          win->second->hide_canvas ();
+      }
+  }
+  
+  
   // FIXME -- default size should be configurable.
   void default_size (int& x, int& y, int& w, int& h)
   {
     x = 0;
     y = 0;
     w = 640;
     h = 480;
   }
@@ -1187,40 +1750,74 @@ public:
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
 
         if (! ov.is_empty ())
           figure_manager::delete_window (ov.string_value ());
       }
   }
 
+  void uimenu_set_fltk_label(graphics_object uimenu_obj)
+  {
+    if (uimenu_obj.valid_object ())
+      {
+        uimenu::properties& uimenup =
+          dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
+        std::string fltk_label = uimenup.get_label ();  
+        graphics_object go = gh_manager::get_object (uimenu_obj.get_parent ());
+        if (go.isa ("uimenu"))
+          fltk_label = dynamic_cast<const uimenu::properties&> (go.get_properties ()).get_fltk_label ()
+                     + "/"
+                     + fltk_label;
+        else if (go.isa ("figure"))
+          ;
+        else
+          error("unexpected parent object\n");
+        
+        uimenup.set_fltk_label(fltk_label);
+      }
+  }
+  
   void update (const graphics_object& go, int id)
   {
     if (go.isa ("figure"))
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
         
         if (! ov.is_empty ())
           {
             const figure::properties& fp =
               dynamic_cast<const figure::properties&> (go.get_properties ());
             
             switch (id)
               {
-              case base_properties::VISIBLE:
-                figure_manager::toggle_window_visibility (ov.string_value (), fp.is_visible ());
-                break;
-
-              case figure::properties::NAME:
-              case figure::properties::NUMBERTITLE:
-                figure_manager::set_name (ov.string_value ());
-                break;
+                case base_properties::VISIBLE:
+                  figure_manager::toggle_window_visibility (ov.string_value (), fp.is_visible ());
+                  break;
+                case figure::properties::MENUBAR:
+		  figure_manager::toggle_menubar_visibility (ov.string_value (), fp.menubar_is("figure"));
+                  break;
+                case figure::properties::NAME:
+		case figure::properties::CURRENTAXES:
+                  figure_manager::update_canvas (go.get_handle (), fp.get_currentaxes ());
+                  break;
+                case figure::properties::NUMBERTITLE:
+                  figure_manager::set_name (ov.string_value ());
+                  break;
               }
           }
       }
+    else if (go.isa ("uimenu"))
+      {
+        if (id == uimenu::properties::LABEL)
+          uimenu_set_fltk_label (go);
+        
+        graphics_object fig = xget_ancestor(go,"figure");
+        figure_manager::uimenu_update(fig.get_handle (), go.get_handle (), id);
+      }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
     figure_manager::mark_modified (go.get_handle ());
 
     __fltk_redraw__ ();
   }
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -549,16 +549,18 @@ opengl_renderer::draw (const graphics_ob
   else if (go.isa ("patch"))
     draw_patch (dynamic_cast<const patch::properties&> (props));
   else if (go.isa ("hggroup"))
     draw_hggroup (dynamic_cast<const hggroup::properties&> (props));
   else if (go.isa ("text"))
     draw_text (dynamic_cast<const text::properties&> (props));
   else if (go.isa ("image"))
     draw_image (dynamic_cast<const image::properties&> (props));
+  else if (go.isa ("uimenu"))
+    ;
   else
     warning ("opengl_renderer: cannot render object of type `%s'",
              props.graphics_object_name ().c_str ());
 }
 
 void
 opengl_renderer::draw_figure (const figure::properties& props)
 {
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #include "ov-fcn-handle.h"
 #include "parse.h"
 #include "toplev.h"
 #include "txt-eng-ft.h"
 #include "unwind-prot.h"
 
 // forward declarations
 static octave_value xget (const graphics_handle& h, const caseless_str& name);
-static graphics_object xget_ancestor (const graphics_object& go_arg,
+graphics_object xget_ancestor (const graphics_object& go_arg,
                                       const std::string& type);
 
 static void
 gripe_set_invalid (const std::string& pname)
 {
   error ("set: invalid value for %s property", pname.c_str ());
 }
 
@@ -536,17 +536,17 @@ convert_text_position (const Matrix& pos
 static Matrix
 screen_size_pixels (void)
 {
   graphics_object obj = gh_manager::get_object (0);
   Matrix sz = obj.get ("screensize").matrix_value ();
   return convert_position (sz, obj.get ("units").string_value (), "pixels", sz.extract_n (0, 2, 1, 2)).extract_n (0, 2, 1, 2);
 }
 
-static graphics_object
+graphics_object
 xget_ancestor (const graphics_object& go_arg, const std::string& type)
 {
   graphics_object go = go_arg;
 
   do
     {
       if (go.valid_object ())
         {
@@ -722,17 +722,17 @@ lookup_object_name (const caseless_str& 
           pfx = name.substr (0, 5);
 
           if (pfx.compare ("image") || pfx.compare ("patch"))
             offset = 5;
           else if (len >= 6)
             {
               pfx = name.substr (0, 6);
 
-              if (pfx.compare ("figure"))
+              if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len >= 7)
                 {
                   pfx = name.substr (0, 7);
 
                   if (pfx.compare ("surface") || pfx.compare ("hggroup"))
                     offset = 7;
                 }
@@ -768,17 +768,18 @@ make_graphics_object_from_type (const ca
   else if (type.compare ("image"))
     go = new image (h, p);
   else if (type.compare ("patch"))
     go = new patch (h, p);
   else if (type.compare ("surface"))
     go = new surface (h, p);
   else if (type.compare ("hggroup"))
     go = new hggroup (h, p);
-
+  else if (type.compare ("uimenu"))
+    go = new uimenu (h, p);
   return go;
 }
 
 // ---------------------------------------------------------------------
 
 bool
 base_property::set (const octave_value& v, bool do_run )
 {
@@ -1411,17 +1412,17 @@ property_list::set (const caseless_str& 
           pfx = name.substr (0, 5);
 
           if (pfx.compare ("image") || pfx.compare ("patch"))
             offset = 5;
           else if (len > 6)
             {
               pfx = name.substr (0, 6);
 
-              if (pfx.compare ("figure"))
+              if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len > 7)
                 {
                   pfx = name.substr (0, 7);
 
                   if (pfx.compare ("surface") || pfx.compare ("hggroup"))
                     offset = 7;
                 }
@@ -1449,16 +1450,18 @@ property_list::set (const caseless_str& 
           else if (pfx == "patch")
             has_property = patch::properties::has_core_property (pname);
           else if (pfx == "figure")
             has_property = figure::properties::has_core_property (pname);
           else if (pfx == "surface")
             has_property = surface::properties::has_core_property (pname);
           else if (pfx == "hggroup")
             has_property = hggroup::properties::has_core_property (pname);
+	  else if (pfx == "uimenu")
+            has_property = uimenu::properties::has_core_property (pname);
 
           if (has_property)
             {
               bool remove = false;
               if (val.is_string ())
                 {
                   caseless_str tval = val.string_value ();
 
@@ -1507,17 +1510,17 @@ property_list::lookup (const caseless_st
           pfx = name.substr (0, 5);
 
           if (pfx.compare ("image") || pfx.compare ("patch"))
             offset = 5;
           else if (len > 6)
             {
               pfx = name.substr (0, 6);
 
-              if (pfx.compare ("figure"))
+              if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len > 7)
                 {
                   pfx = name.substr (0, 7);
 
                   if (pfx.compare ("surface") || pfx.compare ("hggroup"))
                     offset = 7;
                 }
@@ -5451,16 +5454,17 @@ root_figure::init_factory_properties (vo
   plist_map["figure"] = figure::properties::factory_defaults ();
   plist_map["axes"] = axes::properties::factory_defaults ();
   plist_map["line"] = line::properties::factory_defaults ();
   plist_map["text"] = text::properties::factory_defaults ();
   plist_map["image"] = image::properties::factory_defaults ();
   plist_map["patch"] = patch::properties::factory_defaults ();
   plist_map["surface"] = surface::properties::factory_defaults ();
   plist_map["hggroup"] = hggroup::properties::factory_defaults ();
+  plist_map["uimenu"] = uimenu::properties::factory_defaults ();
 
   return plist_map;
 }
 
 // ---------------------------------------------------------------------
 
 DEFUN (ishandle, args, ,
   "-*- texinfo -*-\n\
@@ -6022,16 +6026,25 @@ DEFUN (__go_hggroup__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_hggroup__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (hggroup);
 }
 
+DEFUN (__go_uimenu__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __go_uimenu__ (@var{parent})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  GO_BODY (uimenu);
+}
+
 DEFUN (__go_delete__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_delete__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::autolock guard;
 
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -3850,16 +3850,74 @@ public:
 
   bool valid_object (void) const { return true; }
   
   void update_axis_limits (const std::string& axis_type);
 };
 
 // ---------------------------------------------------------------------
 
+class OCTINTERP_API uimenu : public base_graphics_object
+{
+public:
+  class OCTINTERP_API properties : public base_properties
+  {
+  public:
+    void remove_child (const graphics_handle& h)
+      {
+        base_properties::remove_child (h);
+      }
+
+    void adopt (const graphics_handle& h)
+      {
+        base_properties::adopt (h);
+      }
+
+    // See the genprops.awk script for an explanation of the
+    // properties declarations.
+
+    BEGIN_PROPERTIES (uimenu)
+      string_property accelerator , ""
+      callback_property callback , Matrix()
+      bool_property checked , "off"
+      bool_property enable , "on"
+      color_property foregroundcolor , color_values (0, 0, 0)
+      string_property label , ""
+      double_property position , 9
+      bool_property separator , "off"
+      string_property fltk_label h , ""
+    END_PROPERTIES
+
+  protected:
+    void init (void)
+      { }
+  };
+
+private:
+  properties xproperties;
+
+public:
+  uimenu (const graphics_handle& mh, const graphics_handle& p)
+    : base_graphics_object (), xproperties (mh, p)
+  {
+    xproperties.override_defaults (*this);
+  }
+
+  ~uimenu (void) { xproperties.delete_children (); }
+
+  base_properties& get_properties (void) { return xproperties; }
+
+  const base_properties& get_properties (void) const { return xproperties; }
+
+  bool valid_object (void) const { return true; }
+  
+};
+
+// ---------------------------------------------------------------------
+
 octave_value
 get_property_from_handle (double handle, const std::string &property,
                           const std::string &func);
 bool
 set_property_in_handle (double handle, const std::string &property,
                         const octave_value &arg, const std::string &func);
 
 // ---------------------------------------------------------------------
