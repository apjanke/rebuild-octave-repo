# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1340055910 18000
#      Mon Jun 18 16:45:10 2012 -0500
# Node ID 466cb8673653902599c8552b3ad2c5c9ae54e7ee
# Parent  609dcc297db5b0644e2c06c67851b8be908dc37c
# Parent  1230d5d58d2d1796be72d127f306449e4488b913
maint: periodic merge of default to jit

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-f9813bce2c06a6130a68db4478d1b16ddadaf276 gnulib
+33f823397dbb0edb57503f2f6dad2362456bc6a9 gnulib
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -69,21 +69,20 @@ Summary of important user-visible change
     It now accepts string inputs in the following numerical formats: 12, 21,
     22, 26, 29, 31.  This is undocumented, but verifiable, Matlab behavior.
     In addition, the default for formats which do not specify a date is
     January 1st of the current year.  The previous default was the current day,
     month, and year.  This may produce changes in existing scripts.
 
  ** Other new functions added in 3.8.0:
 
-      colorcube   splinefit
-      lines       tetramesh
-      rgbplot     shrinkfaces
-      findfigs
-
+      colorcube   lines         splinefit
+      erfcinv     rgbplot       tetramesh
+      findfigs    shrinkfaces
+      
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    strerror
       autocov    fstat                 krylovb      values  
       betai      gammai                perror               
diff --git a/build-aux/mkinstalldirs b/build-aux/mkinstalldirs
--- a/build-aux/mkinstalldirs
+++ b/build-aux/mkinstalldirs
@@ -76,19 +76,19 @@ esac
 # from a parallel make.  We use --version in the probe to restrict
 # ourselves to GNU mkdir, which is thread-safe.
 case $dirmode in
   '')
     if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
       echo "mkdir -p -- $*"
       exec mkdir -p -- "$@"
     else
-      # On NextStep and OpenStep, the 'mkdir' command does not
+      # On NextStep and OpenStep, the `mkdir' command does not
       # recognize any option.  It will interpret all options as
-      # directories to create, and then abort because '.' already
+      # directories to create, and then abort because `.' already
       # exists.
       test -d ./-p && rmdir ./-p
       test -d ./--version && rmdir ./--version
     fi
     ;;
   *)
     if mkdir -m "$dirmode" -p --version . >/dev/null 2>&1 &&
        test ! -d ./--version; then
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -649,16 +649,18 @@ AC_SUBST(F77_FLOAT_STORE_FLAG)
 ])
 
 OCTAVE_IEEE754_DATA_FORMAT
 
 OCTAVE_CXX_BITWISE_OP_TEMPLATES
 OCTAVE_CXX_COMPLEX_SETTERS
 OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS
 
+OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL
+
 ### Check for the QHull library
 
 OCTAVE_CHECK_LIBRARY(qhull, QHull,
   [Qhull library not found -- this will result in loss of functionality of some geometry functions.],
   [libqhull/libqhull.h qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
   [warn_qhull=
    OCTAVE_CHECK_QHULL_VERSION
    OCTAVE_CHECK_QHULL_OK([TEXINFO_QHULL="@set HAVE_QHULL"
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -266,16 +266,18 @@ cos (pi/2)
 @DOCSTRING(erf)
 
 @DOCSTRING(erfc)
 
 @DOCSTRING(erfcx)
 
 @DOCSTRING(erfinv)
 
+@DOCSTRING(erfcinv)
+
 @DOCSTRING(gamma)
 
 @DOCSTRING(gammainc)
 
 @DOCSTRING(legendre)
 
 @anchor{doc-gammaln}
 @DOCSTRING(lgamma)
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -97,16 +97,17 @@ Ryan Hinton
 Roman Hodek
 A. Scottedward Hodel
 Richard Allan Holcombe
 Tom Holroyd
 David Hoover
 Kurt Hornik
 Christopher Hulbert
 Cyril Humbert
+John Hunt
 Teemu Ikonen
 Alan W. Irwin
 Geoff Jacobsen
 Mats Jansson
 Cai Jianming
 Steven G. Johnson
 Heikki Junes
 Matthias Jüschke
@@ -152,16 +153,17 @@ Massimo Lorenzin
 Emil Lucretiu
 Hoxide Ma
 James Macnicol
 Jens-Uwe Mager
 Colin Macdonald
 Rob Mahurin
 Ricardo Marranita
 Orestes Mas
+Axel Mathéi
 Makoto Matsumoto
 Tatsuro Matsuoka
 Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
 Júlio Hoffimann Mendes
 Thorsten Meyer
@@ -212,16 +214,17 @@ Joshua Redstone
 Lukas Reichlin
 Michael Reifenberger
 Anthony Richardson
 Jason Riedy
 E. Joshua Rigler
 Petter Risholm
 Matthew W. Roberts
 Andrew Ross
+Fabio Rossi
 Mark van Rossum
 Joe Rothweiler
 Kevin Ruland
 Kristian Rumberg
 Ryan Rusaw
 Olli Saarela
 Toni Saarela
 Juhani Saastamoinen
diff --git a/libcruft/misc/lo-error.c b/libcruft/misc/lo-error.c
--- a/libcruft/misc/lo-error.c
+++ b/libcruft/misc/lo-error.c
@@ -105,18 +105,18 @@ liboctave_fatal (const char *fmt, ...)
   va_end (args);
 
   exit (1);
 }
 
 void
 liboctave_fatal_with_id (const char *id, const char *fmt, ...)
 {
+  va_list args;
   (void) id; /*unused*/
-  va_list args;
   va_start (args, fmt);
   verror ("fatal", fmt, args);
   va_end (args);
 
   exit (1);
 }
 
 void
@@ -126,14 +126,14 @@ liboctave_warning (const char *fmt, ...)
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
 
 void
 liboctave_warning_with_id (const char *id, const char *fmt, ...)
 {
+  va_list args;
   (void) id; /*unused*/
-  va_list args;
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
diff --git a/libcruft/slatec-fn/derf.f b/libcruft/slatec-fn/derf.f
--- a/libcruft/slatec-fn/derf.f
+++ b/libcruft/slatec-fn/derf.f
@@ -64,17 +64,17 @@ C***FIRST EXECUTABLE STATEMENT  DERF
       ENDIF
       FIRST = .FALSE.
 C
       Y = ABS(X)
       IF (Y.GT.1.D0) GO TO 20
 C
 C ERF(X) = 1.0 - ERFC(X)  FOR  -1.0 .LE. X .LE. 1.0
 C
-      IF (Y.LE.SQEPS) DERF = 2.0D0*X*X/SQRTPI
+      IF (Y.LE.SQEPS) DERF = 2.0D0*X/SQRTPI
       IF (Y.GT.SQEPS) DERF = X*(1.0D0 + DCSEVL (2.D0*X*X-1.D0,
      1  ERFCS, NTERF))
       RETURN
 C
 C ERF(X) = 1.0 - ERFC(X) FOR ABS(X) .GT. 1.0
 C
  20   IF (Y.LE.XBIG) DERF = SIGN (1.0D0-DERFC(Y), X)
       IF (Y.GT.XBIG) DERF = SIGN (1.0D0, X)
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -3216,16 +3216,86 @@ double erfinv (double x)
   return do_erfinv (x, true);
 }
 
 float erfinv (float x)
 {
   return do_erfinv (x, false);
 }
 
+static double do_erfcinv (double x, bool refine)
+{
+  // Coefficients of rational approximation.
+  static const double a[] =
+    { -2.806989788730439e+01,  1.562324844726888e+02,
+      -1.951109208597547e+02,  9.783370457507161e+01,
+      -2.168328665628878e+01,  1.772453852905383e+00 };
+  static const double b[] =
+    { -5.447609879822406e+01,  1.615858368580409e+02,
+      -1.556989798598866e+02,  6.680131188771972e+01,
+      -1.328068155288572e+01 };
+  static const double c[] =
+    { -5.504751339936943e-03, -2.279687217114118e-01,
+      -1.697592457770869e+00, -1.802933168781950e+00,
+       3.093354679843505e+00,  2.077595676404383e+00 };
+  static const double d[] =
+    {  7.784695709041462e-03,  3.224671290700398e-01,
+       2.445134137142996e+00,  3.754408661907416e+00 };
+
+  static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
+  static const double pi = 3.14159265358979323846;
+  static const double pbreak = 0.95150;
+  double y;
+
+  // Select case.
+  if (x <= 1+pbreak && x >= 1-pbreak)
+    {
+      // Middle region.
+      const double q = 0.5*(1-x), r = q*q;
+      const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
+      const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
+      y = yn / yd;
+    }
+  else if (x < 2.0 && x > 0.0)
+    {
+      // Tail region.
+      const double q = x < 1 ? sqrt (-2*log (0.5*x)) : sqrt (-2*log (0.5*(2-x)));
+      const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
+      const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
+      y = yn / yd;
+      if (x < 1-pbreak)
+        y *= -1;
+    }
+  else if (x == 0.0)
+    return octave_Inf;
+  else if (x == 2.0)
+    return -octave_Inf;
+  else
+    return octave_NaN;
+
+  if (refine)
+    {
+      // One iteration of Halley's method gives full precision.
+      double u = (erf (y) - (1-x)) * spi2 * exp (y*y);
+      y -= u / (1 + y*u);
+    }
+
+  return y;
+}
+
+double erfcinv (double x)
+{
+  return do_erfcinv (x, true);
+}
+
+float erfcinv (float x)
+{
+  return do_erfcinv (x, false);
+}
+
 // Implementation based on the Fortran code by W.J.Cody
 // see http://www.netlib.org/specfun/erf.
 // Templatized and simplified workflow.
 
 // FIXME: Maybe this should be globally visible.
 static inline float erfc (float x) { return erfcf (x); }
 
 template <class T>
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -588,12 +588,15 @@ inline float gammainc (float x, float a)
 }
 
 extern OCTAVE_API Complex rc_log1p (double);
 extern OCTAVE_API FloatComplex rc_log1p (float);
 
 extern OCTAVE_API double erfinv (double x);
 extern OCTAVE_API float erfinv (float x);
 
+extern OCTAVE_API double erfcinv (double x);
+extern OCTAVE_API float erfcinv (float x);
+
 extern OCTAVE_API double erfcx (double x);
 extern OCTAVE_API float erfcx (float x);
 
 #endif
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -153,16 +153,35 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#in
 [[std::complex<double> x; x.real () = 1.0; x.imag () = 1.0;]])],
 octave_cv_cxx_complex_reference_accessors=yes, octave_cv_cxx_complex_reference_accessors=no)])
 if test $octave_cv_cxx_complex_reference_accessors = yes; then
 AC_DEFINE(HAVE_CXX_COMPLEX_REFERENCE_ACCESSORS,1,[Define if C++ complex class has T& real (void) and T& imag (void) methods])
 fi
 AC_LANG_POP(C++)
 ])
 dnl
+dnl See if the Carbon Framework defines CGDisplayBitsPerPixel.
+dnl
+AC_DEFUN([OCTAVE_CARBON_CGDISPLAYBITSPERPIXEL],
+[AC_CACHE_CHECK([whether CGDisplayBitsPerPixel is defined in the Carbon Framework],
+octave_cv_carbon_cgdisplaybitsperpixel,
+[AC_LANG_PUSH(C++)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <Carbon/Carbon.h>
+]], [[
+CGDirectDisplayID display = CGMainDisplayID ();
+size_t depth = CGDisplayBitsPerPixel (display);
+]])],
+octave_cv_carbon_cgdisplaybitsperpixel=yes, octave_cv_carbon_cgdisplaybitsperpixel=no)])
+if test $octave_cv_carbon_cgdisplaybitsperpixel = yes; then
+AC_DEFINE(HAVE_CARBON_CGDISPLAYBITSPERPIXEL,1,[Define if Carbon Framework has CGDisplayBitsPerPixel])
+fi
+AC_LANG_POP(C++)
+])
+dnl
 dnl The following test is from Karl Berry's Kpathseach library.  I'm
 dnl including it here in case we someday want to make the use of
 dnl kpathsea optional.
 dnl
 dnl Some BSD putenv's, e.g., FreeBSD, do malloc/free's on the environment.
 dnl This test program is due to Mike Hibler <mike@cs.utah.edu>.
 dnl We don't actually need to run this if we don't have putenv, but it
 dnl doesn't hurt.
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -45,17 +45,17 @@ function [text, status] = get_first_help
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (!ischar (name))
     error ("get_first_help_sentence: NAME must be a string");
   endif
 
-  if (!isnumeric (max_len) || max_len <= 0 || max_len != fix (max_len))
+  if (! isnumeric (max_len) || max_len <= 0 || max_len != fix (max_len))
     error ("get_first_help_sentence: MAX_LEN must be positive integer");
   endif
 
   ## First, we get the raw help text
   [help_text, format] = get_help_text (name);
 
   ## Then, we take action depending on the format
   switch (lower (format))
@@ -75,70 +75,73 @@ function [text, status] = get_first_help
 
   if (nargout <= 1 && status != 0)
     warning ("get_first_help_sentence: couldn't run makeinfo on '%s'", name);
   endif
 endfunction
 
 ## This function extracts the first sentence from a plain text help text
 function [text, status] = first_sentence_plain_text (help_text, max_len)
-  ## Extract first line by searching for a period or a double line-end.
-  period_idx = find (help_text == '.', 1);
-  line_end_idx = strfind (help_text, "\n\n");
-  text = help_text (1:min ([period_idx(:); line_end_idx(:); max_len; length(help_text)]));
+  ## Extract first line by searching for a period followed by a space class
+  ## character (to support periods in numbers or words) ...
+  period_idx = regexp (help_text, '\.\s', "once");
+  ## ... or a double end-of-line (we subtract 1 because we are not interested
+  ## in capturing the first newline).
+  line_end_idx = regexp (help_text, "\n\n", "once") - 1;
+  text = help_text (1:min ([period_idx; line_end_idx; max_len; length(help_text)]));
   status = 0;
 endfunction
 
 ## This function extracts the first sentence from a Texinfo help text.
 ## The function works by removing @def* from the texinfo text. After this, we
 ## render the text to plain text using makeinfo, and then extract the first line.
 function [text, status] = first_sentence_texinfo (help_text, max_len)
-  ## Lines ending with "@\n" are continuation lines, so they should be concatenated
-  ## with the following line.
+  ## Lines ending with "@\n" are continuation lines, so they should be
+  ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
 
   ## Find, and remove, lines that start with @def. This should remove things
   ## such as @deftypefn, @deftypefnx, @defvar, etc.
   keep = true (size (help_text));
   def_idx = strfind (help_text, "@def");
-  if (!isempty (def_idx))
+  if (! isempty (def_idx))
     endl_idx = find (help_text == "\n");
     for k = 1:length (def_idx)
-      endl = endl_idx (find (endl_idx > def_idx (k), 1));
+      endl = endl_idx (find (endl_idx > def_idx(k), 1));
       if (isempty (endl))
-        keep (def_idx (k):end) = false;
+        keep (def_idx(k) : end) = false;
       else
-        keep (def_idx (k):endl) = false;
+        keep (def_idx(k) : endl) = false;
       endif
     endfor
 
     ## Remove the @end ... that corresponds to the @def we removed above
-    def1 = def_idx (1);
+    def1 = def_idx(1);
     space_idx = find (help_text == " ");
     space_idx = space_idx (find (space_idx > def1, 1));
     bracket_idx = find (help_text == "{" | help_text == "}");
     bracket_idx = bracket_idx (find (bracket_idx > def1, 1));
     if (isempty (space_idx) && isempty (bracket_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
     sep_idx = min (space_idx, bracket_idx);
-    def_type = help_text (def1+1:sep_idx-1);
+    def_type = help_text(def1+1:sep_idx-1);
 
     end_idx = strfind (help_text, sprintf ("@end %s", def_type));
     if (isempty (end_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
-    endl = endl_idx (find (endl_idx > end_idx, 1));
+    endl = endl_idx(find (endl_idx > end_idx, 1));
     if (isempty (endl))
-      keep (end_idx:end) = false;
+      keep(end_idx:end) = false;
     else
-      keep (end_idx:endl) = false;
+      keep(end_idx:endl) = false;
     endif
 
-    help_text = help_text (keep);
+    help_text = help_text(keep);
   endif
 
   ## Run makeinfo to generate plain text
   [help_text, status] = __makeinfo__ (help_text, "plain text");
 
   ## Extract first line with plain text method.
   text = first_sentence_plain_text (help_text, max_len);
 endfunction
@@ -154,13 +157,13 @@ function [text, status] = first_sentence
 endfunction
 
 
 %!assert (get_first_help_sentence ('get_first_help_sentence'), "Return the first sentence of a function's help text.")
 
 %% Test input validation
 %!error get_first_help_sentence ()
 %!error get_first_help_sentence (1, 2, 3)
-%!error get_first_help_sentence (1)
-%!error get_first_help_sentence ('ls', 'a')
-%!error get_first_help_sentence ('ls', 0)
-%!error get_first_help_sentence ('ls', 80.1)
+%!error <NAME must be a string> get_first_help_sentence (1)
+%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", "a")
+%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 0)
+%!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 80.1)
 
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -164,17 +164,16 @@ function list = missing_functions ()
   "dither",
   "docopt",
   "docsearch",
   "dragrect",
   "dynamicprops",
   "echodemo",
   "ellipj",
   "ellipke",
-  "erfcinv",
   "errordlg",
   "evalc",
   "exifread",
   "expint",
   "export2wsdlg",
   "figurepalette",
   "filebrowser",
   "fill3",
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -157,17 +157,17 @@ function h = colorbar (varargin)
       endif
     endif
 
     ctext = text (0, 0, "", "tag", "colorbar","visible", "off",
                   "handlevisibility", "off", "xliminclude", "off",
                   "yliminclude", "off", "zliminclude", "off",
                   "deletefcn", {@deletecolorbar, cax, obj});
 
-    set (cax, "deletefcn", {@resetaxis, obj});
+    set (cax, "deletefcn", {@resetaxis, ax, obj});
 
     addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical});
     addlistener (ax, "plotboxaspectratio", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "plotboxaspectratiomode", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "dataaspectratio", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "dataaspectratiomode", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "position", {@update_colorbar_axis, cax, obj});
 
@@ -190,23 +190,25 @@ function deletecolorbar (h, d, hc, orig_
         && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       set (ancestor (h, "axes"), "position", orig_props.position, ...
                             "outerposition", orig_props.outerposition, ...
                     "activepositionproperty", orig_props.activepositionproperty);
     endif
   endif
 endfunction
 
-function resetaxis (h, d, orig_props)
-  if (ishandle (h) && strcmp (get (h, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
-      && ishandle (get (h, "axes")))
-     set (get (h, "axes"), "position", orig_props.position, ...
-                           "outerposition", orig_props.outerposition, ...
-                   "activepositionproperty", orig_props.activepositionproperty);
+function resetaxis (cax, d, ax, orig_props)
+  if (ishandle (ax) && strcmp (get (ax, "type"), "axes"))
+    dellistener (ax, "position")
+    units = get (ax, "units");
+    set (ax, "units", orig_props.units)
+    set (ax, "position", orig_props.position, ...
+             "outerposition", orig_props.outerposition, ...
+             "activepositionproperty", orig_props.activepositionproperty);
+    set (ax, "units", units)
   endif
 endfunction
 
 function update_colorbar_clim (h, d, hi, vert)
   if (ishandle (h) && strcmp (get (h, "type"), "image")
       && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
     clen = rows (get (get (h, "parent"), "colormap"));
     cext = get (h, "clim");
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -69,18 +69,28 @@
 ## @item -portrait
 ## @itemx -landscape
 ##   Specify the orientation of the plot for printed output.  For
 ## non-printed output the aspect ratio of the output corresponds to
 ## the plot area defined by the "paperposition" property in the
 ## orientation specified.  This options is equivalent to changing
 ## the figure's "paperorientation" property.
 ##
+## @item -TextAlphaBits=@var{n}
+## @itemx -GraphicsAlphaBits=@var{n}
+##   Octave is able to produce output for various printers, bitmaps, and
+## vector formats by using ghostscript.
+## For bitmap and printer output antialiasing is applied using
+## ghostscript's TextAlphaBits and GraphicsAlphaBits options.
+## The default number of bits for each is 4.
+## Allowed values, for @var{N}, are 1, 2, or 4.
+##
 ## @item -d@var{device}
-##   Output device, where @var{device} is one of:
+##   The available output format is specified by the option @var{device},
+##   and is one of:
 ##
 ##   @table @code
 ##   @item ps
 ##   @itemx ps2
 ##   @itemx psc
 ##   @itemx psc2
 ##     Postscript (level 1 and 2, mono and color).  The FLTK graphics
 ##     toolkit generates Postscript level 3.0.
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -27,16 +27,18 @@
 function [gs_cmd, cleanup_cmd] = __ghostscript__ (varargin);
 
   opts.binary = "";
   opts.source = "-";
   opts.output = "-";
   opts.device = "";
   opts.epscrop = false;
   opts.antialiasing  = false;
+  opts.antialiasing_textalphabits = 4;,
+  opts.antialiasing_graphicsalphabits = 4;
   opts.resolution = 150;
   opts.papersize = "";
   opts.pageoffset = [0 0];
   opts.debug = false;
   opts.level = [];
   opts.prepend = "";
 
   offsetfile = "";
@@ -65,17 +67,19 @@ function [gs_cmd, cleanup_cmd] = __ghost
   gs_opts = sprintf ("-dQUIET -dNOPAUSE -dBATCH -dSAFER -sDEVICE=%s", opts.device);
 
   if (! isempty (opts.level) && ismember (opts.level, [1, 2, 3]))
     gs_opts = sprintf ("%s -dLanguageLevel=%d", gs_opts, round (opts.level));
   endif
 
   if (opts.antialiasing && isempty (strfind (opts.device, "write")))
     ## Apply anti-aliasing to all bitmap formats/devices
-    gs_opts = sprintf ("%s -dTextAlphaBits=4 -dGraphicsAlphaBits=4", gs_opts);
+    gs_opts = sprintf ("%s -dTextAlphaBits=%d -dGraphicsAlphaBits=%d",
+                       gs_opts, opts.antialiasing_textalphabits,
+                       opts.antialiasing_graphicsalphabits);
     gs_opts = sprintf ("%s -r%dx%d", gs_opts, [1, 1] * opts.resolution);
   elseif (any (strcmp (opts.device, {"pswrite", "ps2write", "pdfwrite"})))
     gs_opts = sprintf ("%s -dEmbedAllFonts=true", gs_opts);
     if (strcmp (opts.device, "pdfwrite"))
       ## Optimize for loading
       gs_opts = sprintf ("%s -dOptimize=true", gs_opts);
     endif
   endif
@@ -130,17 +134,17 @@ function [gs_cmd, cleanup_cmd] = __ghost
     endif
   endif
 
   if (isempty (opts.binary))
     error ("print:no_ghostscript", "__ghostscript__.m: ghostscript is required.");
   elseif (isempty (opts.output))
     cmd = sprintf ("%s %s", opts.binary, gs_opts);
   else
-    cmd = sprintf ("%s %s -sOutputFile=%s", opts.binary, gs_opts, opts.output);
+    cmd = sprintf ("%s %s -sOutputFile=\"%s\"", opts.binary, gs_opts, opts.output);
   endif
   if (! isempty (opts.prepend)
       && any (strcmpi (opts.device, {"pswrite", "ps2write", "pdfwrite"})))
     ## FIXME - Fonts get may be mangled when appending ps/ps2.
     ##         See "How to concatenate several PS files" at the link,
     ##         http://en.wikibooks.org/wiki/PostScript_FAQ
     cmd = sprintf ("%s %s", cmd, opts.prepend);
     if (isempty (cleanup_cmd))
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -44,16 +44,18 @@ function arg_st = __print_parse_opts__ (
   arg_st.ghostscript.device = "";
   arg_st.ghostscript.epscrop = true;
   arg_st.ghostscript.level = [];
   arg_st.ghostscript.output = "";
   arg_st.ghostscript.papersize = "";
   arg_st.ghostscript.pageoffset = [];
   arg_st.ghostscript.resolution = 150;
   arg_st.ghostscript.antialiasing = false;
+  arg_st.ghostscript.antialiasing_textalphabits = 4;
+  arg_st.ghostscript.antialiasing_graphicsalphabits = 4;
   arg_st.loose = false;
   arg_st.lpr_binary = __quote_path__ (__find_binary__ ("lpr"));
   arg_st.name = "";
   arg_st.orientation = "";
   arg_st.pstoedit_binary = __quote_path__ (__find_binary__ ("pstoedit"));
   arg_st.preview = "";
   arg_st.printer = "";
   arg_st.send_to_printer = false;
@@ -113,16 +115,30 @@ function arg_st = __print_parse_opts__ (
       elseif (length (arg) > 2 && arg(1:2) == "-P")
         arg_st.printer = arg;
       elseif (strncmp (arg, "-EPSTOOL:", 9))
         arg_st.epstool_binary = arg{10:end};
       elseif (strncmp (arg, "-FIG2DEV:", 9))
         arg_st.fig2dev_binary = arg{10:end};
       elseif (strncmp (arg, "-PSTOEDIT:", 9))
         arg_st.pstoedit_binary = arg{10:end};
+      elseif (strncmpi (arg, "-textalphabits=", 15))
+        n = find (arg == "=");
+        if (! isempty (n) && n == numel (arg) - 1 && ismember (arg(end), "124"))
+          arg_st.ghostscript.antialiasing_textalphabits = str2num (arg(end));
+        else
+          error ("print: improper syntax, or value, for TextAlphaBits")
+        endif
+      elseif (strncmpi (arg, "-graphicsalphabits=", 19))
+        n = find (arg == "=");
+        if (! isempty (n) && n == numel (arg) - 1 && ismember (arg(end), "124"))
+          arg_st.ghostscript.antialiasing_graphicsalphabits = str2num (arg(end));
+        else
+          error ("print: improper syntax, or value, for GraphicsAlphaBits")
+        endif
       elseif ((length (arg) > 2) && arg(1:2) == "-G")
         arg_st.ghostscript.binary = file_in_path (getenv ("PATH"), arg(3:end));
         if (isempty (arg_st.ghostscript.binary))
           error ("print: Ghostscript binary ""%s"" could not be located",
                  arg(3:end));
         else
           arg_st.ghostscript_binary = __quote_path__ (arg_st.ghostscript_binary);
         endif
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -27,17 +27,17 @@
 ## @item @var{rtol} is the relative tolerance,
 ## if not given or set to [] the default value 1e-6 is used.
 ##
 ## @item @var{maxit} is the maximum number of outer iterations,
 ## if not given or set to [] the default value
 ## @code{min (10, numel (b) / restart)} is used.
 ##
 ## @item @var{x0} is the initial guess,
-## if not given or set to [] the default value @code{zeros(size (b))} is used.
+## if not given or set to [] the default value @code{zeros (size (b))} is used.
 ##
 ## @item @var{m} is the restart parameter,
 ## if not given or set to [] the default value @code{numel (b)} is used.
 ## @end itemize
 ##
 ## Argument @var{A} can be passed as a matrix, function handle, or
 ## inline function @code{f} such that @code{f(x) = A*x}.
 ##
@@ -52,32 +52,32 @@
 ##
 ## @table @asis
 ## @item 0 : iteration converged to within the specified tolerance
 ##
 ## @item 1 : maximum number of iterations exceeded
 ##
 ## @item 2 : unused, but skipped for compatibility
 ##
-## @item 3 : algorithm reached stagnation
+## @item 3 : algorithm reached stagnation (no change between iterations)
 ## @end table
 ##
 ## @item @var{relres} is the final value of the relative residual.
 ##
 ## @item @var{iter} is a vector containing the number of outer iterations and
 ## total iterations performed.
 ##
 ## @item @var{resvec} is a vector containing the relative residual at each
 ## iteration.
 ## @end itemize
 ##
 ## @seealso{bicg, bicgstab, cgs, pcg}
 ## @end deftypefn
 
-function [x, flag, presn, it, resids] = gmres (A, b, restart, rtol, maxit, M1, M2, x0)
+function [x, flag, relres, it, resvec] = gmres (A, b, restart, rtol, maxit, M1, M2, x0)
 
   if (nargin < 2 || nargin > 8)
     print_usage ();
   endif
 
   if (ischar (A))
     Ax = str2func (A);
   elseif (ismatrix (A))
@@ -137,20 +137,20 @@ function [x, flag, presn, it, resids] = 
 
   B = zeros (restart + 1, 1);
   V = zeros (rows (x), restart);
   H = zeros (restart + 1, restart);
 
   ## begin loop
   iter = 1;
   restart_it  = restart + 1;
-  resids      = zeros (maxit, 1);
-  resids(1)   = presn;
+  resvec      = zeros (maxit, 1);
+  resvec(1)   = presn;
   prec_b_norm = norm (Pm1x (b), 2);
-  flag        = 1;
+  flag        = 1;  # Default flag is maximum # of iterations exceeded
 
   while (iter <= maxit * restart && presn > rtol * prec_b_norm)
 
     ## restart
     if (restart_it > restart)
       restart_it = 1;
       x_old = x;
       prec_res = Pm1x (b - Ax (x_old));
@@ -169,52 +169,69 @@ function [x, flag, presn, it, resids] = 
 
     little_res = B(1:restart_it+1) - ...
         H(1:restart_it+1, 1:restart_it) * Y(1:restart_it);
 
     presn = norm (little_res, 2);
 
     x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
 
-    resids(iter) = presn;
+    resvec(iter) = presn;
     if (norm (x - x_old, inf) <= eps)
-      flag = 3;
-      break
+      flag = 3;  # Stagnation: no change between iterations
+      break;
     endif
 
     restart_it++ ;
     iter++;
   endwhile
 
-  if (presn > rtol * prec_b_norm)
-    flag = 0;
+  if (nargout > 1)
+    ## Calculate extra outputs as requested
+    relres = presn / prec_b_norm;
+    if (relres <= rtol)
+      flag = 0;  # Converged to solution within tolerance
+    endif
+
+    resvec = resvec(1:iter-1);
+    it = [ceil(iter / restart), rem(iter, restart)];
   endif
 
-  resids = resids(1:iter-1);
-  it = [ceil(iter / restart), rem(iter, restart)];
-
 endfunction
 
 
+%!demo
+%! dim = 20;
+%! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
+%! b = ones (dim, 1);
+%! [x, flag, relres, iter, resvec] = gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b)
+
 %!shared A, b, dim
 %! dim = 100;
 %!test
 %! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
 %! b = ones (dim, 1);
 %! x = gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %!
 %!test
 %! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag (diag (A)) \ x, [], b);
 %! assert(x, A\b, 1e-7*norm (x, Inf));
 %!
 %!test
 %! A = spdiags ([[1./(2:2:2*(dim-1)) 0]; 1./(1:2:2*dim-1); [0 1./(2:2:2*(dim-1))]]', -1:1, dim, dim);
 %! A = A'*A;
 %! b = rand (dim, 1);
-%! [x, resids] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag (A), [], []);
+%! [x, resvec] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag (A), [], []);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) diag (diag (A)) \ x, [], []);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %!test
 %! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x./diag(A), [], []);
 %! assert (x, A\b, 1e-7*norm (x, Inf));
 
+
+%!error gmres (1)
+%!error gmres (1,2,3,4,5,6,7,8,9)
+%!error <A must be> gmres ({1},2)
+%!error <A must be a function or matrix> gmres ({1},2)
+%!error <M1 must be a function or matrix> gmres (1,2,3,4,5,{6})
+%!error <M2 must be a function or matrix> gmres (1,2,3,4,5,6,{7})
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -69,25 +69,25 @@ function cdf = logncdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 e Inf];
 %! y = [0, 0, 0.5, 1/2+1/2*erf(1/2), 1];
-%!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y)
-%!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y)
-%!assert (logncdf (x, zeros (1,5), sqrt(2)), y)
-%!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)])
-%!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
-%!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)])
+%!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y, eps)
+%!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y, eps)
+%!assert (logncdf (x, zeros (1,5), sqrt(2)), y, eps)
+%!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)], eps)
+%!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)], eps)
+%!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)], eps)
 
 %% Test class of input preserved
-%!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN])
+%!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN], eps)
 %!assert (logncdf (single ([x, NaN]), 0, sqrt(2)), single ([y, NaN]), eps ("single"))
 %!assert (logncdf ([x, NaN], single (0), sqrt(2)), single ([y, NaN]), eps ("single"))
 %!assert (logncdf ([x, NaN], 0, single (sqrt(2))), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logncdf ()
 %!error logncdf (1,2)
 %!error logncdf (1,2,3,4)
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -32,17 +32,17 @@ function inv = stdnormal_inv (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   if (iscomplex (x))
     error ("stdnormal_inv: X must not be complex");
   endif
 
-  inv = sqrt (2) * erfinv (2 * x - 1);
+  inv = - sqrt (2) * erfcinv (2 * x);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
 %!assert (stdnormal_inv (x), [NaN -Inf 0 Inf NaN])
 
diff --git a/src/display.cc b/src/display.cc
--- a/src/display.cc
+++ b/src/display.cc
@@ -36,16 +36,33 @@ along with Octave; see the file COPYING.
 
 #include "singleton-cleanup.h"
 
 #include "display.h"
 #include "error.h"
 
 display_info *display_info::instance = 0;
 
+#if defined (HAVE_FRAMEWORK_CARBON) && ! defined (HAVE_CARBON_CGDISPLAYBITSPERPIXEL)
+// FIXME - This will only work for MacOS > 10.5. For earlier versions
+// this code is not needed (use CGDisplayBitsPerPixel instead).
+size_t DisplayBitsPerPixel (CGDirectDisplayID display)
+{
+  CGDisplayModeRef mode = CGDisplayCopyDisplayMode (display);
+  CFStringRef pixelEncoding = CGDisplayModeCopyPixelEncoding (mode);
+
+  if (CFStringCompare (pixelEncoding, CFSTR (IO32BitDirectPixels), 0) == 0)
+    return 32;
+  else if (CFStringCompare (pixelEncoding, CFSTR (IO16BitDirectPixels), 0) == 0)
+    return 16;
+  else 
+    return 8;
+}
+#endif
+
 void
 display_info::init (bool query)
 {
   if (query)
     {
 #if defined (OCTAVE_USE_WINDOWS_API)
 
       HDC hdc = GetDC (0);
@@ -67,26 +84,31 @@ display_info::init (bool query)
         warning ("no graphical display found");
 
 #elif defined (HAVE_FRAMEWORK_CARBON)
 
       CGDirectDisplayID display = CGMainDisplayID ();
 
       if (display)
         {
+#  if defined (HAVE_CARBON_CGDISPLAYBITSPERPIXEL)
+          // For MacOS < 10.7 use the line below
           dp = CGDisplayBitsPerPixel (display);
+#  else
+          // For MacOS > 10.5 use the line below
+          dp = DisplayBitsPerPixel (display);
+#  endif
 
           ht = CGDisplayPixelsHigh (display);
           wd = CGDisplayPixelsWide (display);
 
           CGSize sz_mm = CGDisplayScreenSize (display);
-
-          // On modern Mac systems (>= 10.5) CGSize is a struct keeping 2
-          // CGFloat values, but the CGFloat typedef is not present on
-          // older systems, so use double instead.
+          // For MacOS >= 10.6, CGSize is a struct keeping 2 CGFloat values,
+          // but the CGFloat typedef is not present on older systems,
+          // so use double instead.
           double ht_mm = sz_mm.height;
           double wd_mm = sz_mm.width;
 
           rx = wd * 25.4 / wd_mm;
           ry = ht * 25.4 / ht_mm;
         }
       else
         warning ("no graphical display found");
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -139,60 +139,60 @@ Logical 'not equals' operator.\n\
 @deftypefn {Operator} {} \"\n\
 String delimiter.\n\
 @end deftypefn"),
 
   pair_type ("#",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #\n\
 Begin comment character.\n\
-@seealso{%, #@{}\n\
+@seealso{%, #@\\{}\n\
 @end deftypefn"),
 
   pair_type ("%",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %\n\
 Begin comment character.\n\
-@seealso{#, %@{}\n\
+@seealso{#, %@\\{}\n\
 @end deftypefn"),
 
   pair_type ("#{",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@{}.\n\
 It is possible to nest block comments.\n\
-@seealso{%@{, #@}, #}\n\
+@seealso{%@\\{, #@\\}, #}\n\
 @end deftypefn"),
 
   pair_type ("%{",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@{}.\n\
 It is possible to nest block comments.\n\
-@seealso{#@{, %@}, %}\n\
+@seealso{#@\\{, %@\\}, %}\n\
 @end deftypefn"),
 
   pair_type ("#}",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@}}.\n\
 It is possible to nest block comments.\n\
-@seealso{%@}, #@{, #}\n\
+@seealso{%@\\}, #@\\{, #}\n\
 @end deftypefn"),
 
   pair_type ("%}",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@}}.\n\
 It is possible to nest block comments.\n\
-@seealso{#@}, %@{, %}\n\
+@seealso{#@\\}, %@\\{, %}\n\
 @end deftypefn"),
 
   pair_type ("...",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ...\n\
 Continuation marker.  Joins current line with following line.\n\
 @end deftypefn"),
 
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -542,17 +542,17 @@ Compute the error function,\n\
               2        /\n\
 erf (z) = --------- *  | e^(-t^2) dt\n\
           sqrt (pi)    /\n\
                     t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
-@seealso{erfc, erfcx, erfinv}\n\
+@seealso{erfc, erfcx, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erf ();
   else
     print_usage ();
 
@@ -591,57 +591,95 @@ erf (z) = --------- *  | e^(-t^2) dt\n\
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Compute the inverse error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
 erf (@var{y}) == @var{x}\n\
 @end example\n\
-@seealso{erf, erfc, erfcx}\n\
+@seealso{erf, erfc, erfcx, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfinv ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 ## middle region
 %!assert (erf (erfinv ([-0.9 -0.3 0 0.4 0.8])), [-0.9 -0.3 0 0.4 0.8], eps)
-%!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), 1e-8)
+%!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), eps ("single"))
 ## tail region
 %!assert (erf (erfinv ([-0.999 -0.99 0.9999 0.99999])), [-0.999 -0.99 0.9999 0.99999], eps)
-%!assert (erf (erfinv (single ([-0.999 -0.99 0.9999 0.99999]))), single ([-0.999 -0.99 0.9999 0.99999]), 1e-8)
+%!assert (erf (erfinv (single ([-0.999 -0.99 0.9999 0.99999]))), single ([-0.999 -0.99 0.9999 0.99999]), eps ("single"))
 ## backward - loss of accuracy
 %!assert (erfinv (erf ([-3 -1 -0.4 0.7 1.3 2.8])), [-3 -1 -0.4 0.7 1.3 2.8], -1e-12)
 %!assert (erfinv (erf (single ([-3 -1 -0.4 0.7 1.3 2.8]))), single ([-3 -1 -0.4 0.7 1.3 2.8]), -1e-4)
 ## exceptional
 %!assert (erfinv ([-1, 1, 1.1, -2.1]), [-Inf, Inf, NaN, NaN])
 %!error erfinv (1+2i)
 
 %!error erfinv ()
 %!error erfinv (1, 2)
 */
 
+DEFUN (erfcinv, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} erfcinv (@var{x})\n\
+Compute the inverse complementary error function, i.e., @var{y} such that\n\
+\n\
+@example\n\
+erfc (@var{y}) == @var{x}\n\
+@end example\n\
+@seealso{erfc, erf, erfcx, erfinv}\n\
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).erfcinv ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+## middle region
+%!assert (erfc (erfcinv ([1.9 1.3 1 0.6 0.2])), [1.9 1.3 1 0.6 0.2], eps)
+%!assert (erfc (erfcinv (single ([1.9 1.3 1 0.6 0.2]))), single ([1.9 1.3 1 0.6 0.2]), eps ("single"))
+## tail region
+%!assert (erfc (erfcinv ([0.001 0.01 1.9999 1.99999])), [0.001 0.01 1.9999 1.99999], eps)
+%!assert (erfc (erfcinv (single ([0.001 0.01 1.9999 1.99999]))), single ([0.001 0.01 1.9999 1.99999]), eps ("single"))
+## backward - loss of accuracy
+%!assert (erfcinv (erfc ([-3 -1 -0.4 0.7 1.3 2.8])), [-3 -1 -0.4 0.7 1.3 2.8], -1e-12)
+%!assert (erfcinv (erfc (single ([-3 -1 -0.4 0.7 1.3 2.8]))), single ([-3 -1 -0.4 0.7 1.3 2.8]), -1e-4)
+## exceptional
+%!assert (erfcinv ([2, 0, -0.1, 2.1]), [-Inf, Inf, NaN, NaN])
+%!error erfcinv (1+2i)
+
+%!error erfcinv ()
+%!error erfcinv (1, 2)
+*/
+
 DEFUN (erfc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Compute the complementary error function,\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{1 - erf (@var{z})}}.\n\
 @end ifnottex\n\
-@seealso{erfcx, erf, erfinv}\n\
+@seealso{erfcinv, erfcx, erf, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfc ();
   else
     print_usage ();
 
@@ -668,17 +706,17 @@ Compute the scaled complementary error f
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 exp (z^2) * erfc (x)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
-@seealso{erfc, erf, erfinv}\n\
+@seealso{erfc, erf, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfcx ();
   else
     print_usage ();
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1186,16 +1186,17 @@ octave_base_value::get_umap_name (unary_
       "atanh",
       "cbrt",
       "ceil",
       "conj",
       "cos",
       "cosh",
       "erf",
       "erfinv",
+      "erfcinv",
       "erfc",
       "exp",
       "expm1",
       "finite",
       "fix",
       "floor",
       "gamma",
       "imag",
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -683,16 +683,17 @@ public:
       umap_atanh,
       umap_cbrt,
       umap_ceil,
       umap_conj,
       umap_cos,
       umap_cosh,
       umap_erf,
       umap_erfinv,
+      umap_erfcinv,
       umap_erfc,
       umap_erfcx,
       umap_exp,
       umap_expm1,
       umap_finite,
       umap_fix,
       umap_floor,
       umap_gamma,
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -286,16 +286,17 @@ octave_float_scalar::map (unary_mapper_t
       SCALAR_MAPPER (angle, ::arg);
       SCALAR_MAPPER (arg, ::arg);
       SCALAR_MAPPER (asin, rc_asin);
       SCALAR_MAPPER (asinh, ::asinhf);
       SCALAR_MAPPER (atan, ::atanf);
       SCALAR_MAPPER (atanh, rc_atanh);
       SCALAR_MAPPER (erf, ::erff);
       SCALAR_MAPPER (erfinv, ::erfinv);
+      SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, ::erfcf);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, ::cbrtf);
       SCALAR_MAPPER (ceil, ::ceilf);
       SCALAR_MAPPER (cos, ::cosf);
       SCALAR_MAPPER (cosh, ::coshf);
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -779,16 +779,17 @@ octave_float_matrix::map (unary_mapper_t
       ARRAY_MAPPER (angle, float, ::arg);
       ARRAY_MAPPER (arg, float, ::arg);
       RC_ARRAY_MAPPER (asin, FloatComplex, rc_asin);
       ARRAY_MAPPER (asinh, float, ::asinhf);
       ARRAY_MAPPER (atan, float, ::atanf);
       RC_ARRAY_MAPPER (atanh, FloatComplex, rc_atanh);
       ARRAY_MAPPER (erf, float, ::erff);
       ARRAY_MAPPER (erfinv, float, ::erfinv);
+      ARRAY_MAPPER (erfcinv, float, ::erfcinv);
       ARRAY_MAPPER (erfc, float, ::erfcf);
       ARRAY_MAPPER (erfcx, float, ::erfcx);
       ARRAY_MAPPER (gamma, float, xgamma);
       RC_ARRAY_MAPPER (lgamma, FloatComplex, rc_lgamma);
       ARRAY_MAPPER (cbrt, float, ::cbrtf);
       ARRAY_MAPPER (ceil, float, ::ceilf);
       ARRAY_MAPPER (cos, float, ::cosf);
       ARRAY_MAPPER (cosh, float, ::coshf);
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -902,16 +902,17 @@ octave_matrix::map (unary_mapper_t umap)
       ARRAY_MAPPER (angle, double, ::arg);
       ARRAY_MAPPER (arg, double, ::arg);
       RC_ARRAY_MAPPER (asin, Complex, rc_asin);
       ARRAY_MAPPER (asinh, double, ::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       RC_ARRAY_MAPPER (atanh, Complex, rc_atanh);
       ARRAY_MAPPER (erf, double, ::erf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
+      ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, ::erfc);
       ARRAY_MAPPER (erfcx, double, ::erfcx);
       ARRAY_MAPPER (gamma, double, xgamma);
       RC_ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, ::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -905,16 +905,17 @@ octave_sparse_matrix::map (unary_mapper_
       ARRAY_MAPPER (angle, double, ::arg);
       ARRAY_MAPPER (arg, double, ::arg);
       ARRAY_MAPPER (asin, Complex, rc_asin);
       ARRAY_MAPPER (asinh, double, ::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       ARRAY_MAPPER (atanh, Complex, rc_atanh);
       ARRAY_MAPPER (erf, double, ::erf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
+      ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, ::erfc);
       ARRAY_MAPPER (gamma, double, xgamma);
       ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, ::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -302,16 +302,17 @@ octave_scalar::map (unary_mapper_t umap)
       SCALAR_MAPPER (angle, ::arg);
       SCALAR_MAPPER (arg, ::arg);
       SCALAR_MAPPER (asin, rc_asin);
       SCALAR_MAPPER (asinh, ::asinh);
       SCALAR_MAPPER (atan, ::atan);
       SCALAR_MAPPER (atanh, rc_atanh);
       SCALAR_MAPPER (erf, ::erf);
       SCALAR_MAPPER (erfinv, ::erfinv);
+      SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, ::erfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, ::cbrt);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (cos, ::cos);
       SCALAR_MAPPER (cosh, ::cosh);
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1115,16 +1115,17 @@ public:
   MAPPER_FORWARD (atanh)
   MAPPER_FORWARD (cbrt)
   MAPPER_FORWARD (ceil)
   MAPPER_FORWARD (conj)
   MAPPER_FORWARD (cos)
   MAPPER_FORWARD (cosh)
   MAPPER_FORWARD (erf)
   MAPPER_FORWARD (erfinv)
+  MAPPER_FORWARD (erfcinv)
   MAPPER_FORWARD (erfc)
   MAPPER_FORWARD (erfcx)
   MAPPER_FORWARD (exp)
   MAPPER_FORWARD (expm1)
   MAPPER_FORWARD (finite)
   MAPPER_FORWARD (fix)
   MAPPER_FORWARD (floor)
   MAPPER_FORWARD (gamma)
