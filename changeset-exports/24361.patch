# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1511763125 18000
#      Mon Nov 27 01:12:05 2017 -0500
# Node ID 8bcfddad15ecc016ca63ea7b1e22f8bfa4eb8ae0
# Parent  ff4717c3223febcd67fbfa223c0f9842da62ba13
use shared_ptr to manage symbol_scope objects

* symscope.h, symscope.cc (symbol_scope_rep): New class, renamed and
adapted from symbol_scope.
(symbol_scope): New class to manage symbol_scope_rep with shared_ptr.
Change all uses of pointers ot symbol_scope objects to be symbol_scope
objects or, in a few cases, pointers to symbol_scope_rep objects
instead.

diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -2523,34 +2523,34 @@ main_window::save_workspace_callback (co
   Fsave (ovl (file));
 }
 
 void
 main_window::load_workspace_callback (const std::string& file)
 {
   Fload (ovl (file));
 
-  octave::symbol_scope *scope
+  octave::symbol_scope scope
    = octave::__get_current_scope__ ("main_window::load_workspace_callback");
 
   if (scope)
-    octave_link::set_workspace (true, scope->workspace_info ());
+    octave_link::set_workspace (true, scope.workspace_info ());
 }
 
 void
 main_window::rename_variable_callback (const main_window::name_pair& names)
 {
-  octave::symbol_scope *scope
+  octave::symbol_scope scope
     = octave::__get_current_scope__ ("main_window::rename_variable_callback");
 
   if (scope)
     {
-      scope->rename (names.first, names.second);
-
-      octave_link::set_workspace (true, scope->workspace_info ());
+      scope.rename (names.first, names.second);
+
+      octave_link::set_workspace (true, scope.workspace_info ());
     }
 
   // FIXME: if this action fails, do we need a way to display that info
   // in the GUI?
 }
 
 void
 main_window::command_window_undo_callback (void)
@@ -2699,21 +2699,21 @@ main_window::configure_shortcuts (void)
                                   "main_news:release_notes");
   shortcut_manager::set_shortcut (m_current_news_action,
                                   "main_news:community_news");
 }
 
 void
 main_window::force_refresh_workspace (void)
 {
-  octave::symbol_scope *scope
+  octave::symbol_scope scope
    = octave::__get_current_scope__ ("main_window::load_workspace_callback");
 
   if (scope)
-    octave_link::set_workspace (true, scope->workspace_info (), false);
+    octave_link::set_workspace (true, scope.workspace_info (), false);
 }
 
 QList<octave_dock_widget *>
 main_window::dock_widget_list (void)
 {
   QList<octave_dock_widget *> list = QList<octave_dock_widget *> ();
   list.append (static_cast<octave_dock_widget *> (m_command_window));
   list.append (static_cast<octave_dock_widget *> (m_history_window));
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -406,20 +406,20 @@ void
 workspace_view::handle_contextmenu_copy_value (void)
 {
   QModelIndex index = m_view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
-      octave::symbol_scope *scope
+      octave::symbol_scope scope
         = octave::__get_current_scope__ ("workspace_view::handle_contextmenu_copy_value");
 
-      octave_value val = scope ? scope->varval (var_name.toStdString ()) : 0;
+      octave_value val = scope ? scope.varval (var_name.toStdString ()) : 0;
       std::ostringstream buf;
       val.print_raw (buf, true);
 
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText (QString::fromStdString (buf.str ()));
     }
 }
 
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -355,17 +355,17 @@ namespace octave
   call_stack::push (octave_function *fcn)
   {
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
     push (fcn, symtab.current_scope (), symtab.current_context ());
   }
 
   void
-  call_stack::push (octave_function *fcn, symbol_scope *scope,
+  call_stack::push (octave_function *fcn, const symbol_scope& scope,
                     symbol_table::context_id context)
   {
     size_t prev_frame = curr_frame;
     curr_frame = cs.size ();
     cs.push_back (stack_frame (fcn, scope, context, prev_frame));
 
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
@@ -389,17 +389,17 @@ namespace octave
 
         symtab.set_scope_and_context (elt.m_scope, elt.m_context);
 
         if (verbose)
           octave_stdout << "stopped in " << elt.fcn_name ()
                         << " at line " << elt.m_line
                         << " column " << elt.m_column
                         << " [" << elt.fcn_file_name () << "] "
-                        << " (scope = " << elt.m_scope
+                        << " (scope = " << elt.m_scope.get_rep_ptr ()
                         << "[context = " << elt.m_context << "])"
                         << std::endl;
       }
 
     return retval;
   }
 
   bool
@@ -580,17 +580,17 @@ namespace octave
     Cell& column = retval.contents (3);
     Cell& scope = retval.contents (4);
     Cell& context = retval.contents (5);
 
     octave_idx_type k = 0;
 
     for (const auto& frm : frames)
       {
-        scope(k)   = frm.m_scope;
+        scope(k)   = frm.m_scope.get_rep_ptr ();
         context(k) = frm.m_context;
         file(k)    = frm.fcn_file_name ();
         name(k)    = frm.fcn_name (print_subfn);
         line(k)    = frm.m_line;
         column(k)  = frm.m_column;
 
         k++;
       }
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -47,17 +47,17 @@ namespace octave
 
     class stack_frame
     {
     public:
 
       friend class call_stack;
 
       stack_frame (octave_function *fcn = nullptr,
-                   symbol_scope *scope = nullptr,
+                   const symbol_scope& scope = symbol_scope (),
                    symbol_table::context_id context = 0, size_t prev = 0)
         : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
           m_context (context), m_prev (prev)
       { }
 
       stack_frame (const stack_frame& elt)
         : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
           m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
@@ -73,17 +73,17 @@ namespace octave
 
       bool operator == (const stack_frame& rhs) const;
 
     private:
 
       octave_function *m_fcn;
       int m_line;
       int m_column;
-      symbol_scope *m_scope;
+      symbol_scope m_scope;
       symbol_table::context_id m_context;
       size_t m_prev;
     };
 
     typedef std::deque<stack_frame>::iterator iterator;
     typedef std::deque<stack_frame>::const_iterator const_iterator;
 
     typedef std::deque<stack_frame>::reverse_iterator reverse_iterator;
@@ -119,20 +119,20 @@ namespace octave
     }
 
     size_t current_frame (void) const { return curr_frame; }
 
     size_t size (void) const { return cs.size (); }
 
     size_t num_user_code_frames (octave_idx_type& curr_user_frame) const;
 
-    symbol_scope *current_scope (void) const
+    symbol_scope current_scope (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
-              ? cs[curr_frame].m_scope : nullptr);
+              ? cs[curr_frame].m_scope : symbol_scope ());
     }
 
     symbol_table::context_id current_context (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
               ? cs[curr_frame].m_context : 0);
     }
 
@@ -168,25 +168,25 @@ namespace octave
 
     // Column number in current function that we are debugging.
     int debug_user_code_column (void) const;
 
     // Return TRUE if all elements on the call stack are scripts.
     bool all_scripts (void) const;
 
     void push (octave_function *fcn);
-    void push (octave_function *fcn, symbol_scope *scope,
+    void push (octave_function *fcn, const symbol_scope& scope,
                symbol_table::context_id context);
 
     void push (void)
     {
       push (nullptr);
     }
 
-    void push (symbol_scope *scope, symbol_table::context_id context)
+    void push (const symbol_scope& scope, symbol_table::context_id context)
     {
       push (nullptr, scope, context);
     }
 
     void set_location (int l, int c)
     {
       if (! cs.empty ())
         {
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1563,27 +1563,27 @@ disable escape sequence expansion use a 
           else
             old_warning_options = octave_map (warning_query (arg2));
 
           octave::symbol_table& symtab = interp.get_symbol_table ();
 
           if (nargin == 3 && argv[3] == "local"
               && ! symtab.at_top_level ())
             {
-              octave::symbol_scope *scope
+              octave::symbol_scope scope
                 = symtab.require_current_scope ("warning");
 
               octave_scalar_map val = warning_query (arg2);
 
               octave_value curr_state = val.contents ("state");
 
               // FIXME: this might be better with a dictionary object.
 
               octave_value curr_warning_states
-                = scope->varval (".saved_warning_states.");
+                = scope.varval (".saved_warning_states.");
 
               octave_map m;
 
               if (curr_warning_states.is_defined ())
                 m = curr_warning_states.map_value ();
               else
                 {
                   string_vector fields (2);
@@ -1621,17 +1621,17 @@ disable escape sequence expansion use a 
 
                   ids(nel) = arg2;
                   states(nel) = curr_state;
                 }
 
               m.contents ("identifier") = ids;
               m.contents ("state") = states;
 
-              scope->force_assign (".saved_warning_states.", m);
+              scope.force_assign (".saved_warning_states.", m);
 
               // Now ignore the "local" argument and continue to
               // handle the current setting.
               nargin--;
             }
 
           if (nargin >= 2 && arg2 == "all")
             {
diff --git a/libinterp/corefcn/fcn-info.cc b/libinterp/corefcn/fcn-info.cc
--- a/libinterp/corefcn/fcn-info.cc
+++ b/libinterp/corefcn/fcn-info.cc
@@ -369,39 +369,39 @@ namespace octave
   }
 
   octave_value
   fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
                                  bool local_funcs)
   {
     if (local_funcs)
       {
-        symbol_scope *curr_scope
+        symbol_scope curr_scope
           = __get_current_scope__ ("fcn_info::fcn_info_rep::xfind");
 
         octave_user_function *current_fcn
-          = curr_scope ? curr_scope->function () : nullptr;
+          = curr_scope ? curr_scope.function () : nullptr;
 
         // Local function.
 
         if (current_fcn)
           {
             std::string fcn_file = current_fcn->fcn_file_name ();
 
             // For anonymous functions we look at the parent scope so that if
             // they were defined within class methods and use local functions
             // (helper functions) we can still use those anonymous functions
 
             if (current_fcn->is_anonymous_function ())
               {
                 if (fcn_file.empty ()
-                    && curr_scope->parent_scope () != nullptr
-                    && curr_scope->parent_scope ()->function () != nullptr)
+                    && curr_scope.parent_scope ()
+                    && curr_scope.parent_scope ()->function () != nullptr)
                   fcn_file
-                    = curr_scope->parent_scope ()->function ()->fcn_file_name();
+                    = curr_scope.parent_scope ()->function ()->fcn_file_name();
               }
 
             if (! fcn_file.empty ())
               {
                 str_val_iterator r = local_functions.find (fcn_file);
 
                 if (r != local_functions.end ())
                   {
@@ -587,20 +587,20 @@ namespace octave
 
     // Command-line function.
 
     if (cmdline_function.is_defined ())
       return cmdline_function;
 
     // Private function.
 
-    symbol_scope *curr_scope
+    symbol_scope curr_scope
       = __get_current_scope__ ("fcn_info::fcn_info_rep::x_builtin_find");
 
-    octave_user_function *current_fcn = curr_scope ? curr_scope->function () : nullptr;
+    octave_user_function *current_fcn = curr_scope ? curr_scope.function () : nullptr;
 
     if (current_fcn)
       {
         std::string dir_name = current_fcn->dir_name ();
 
         if (! dir_name.empty ())
           {
             str_val_iterator q = private_functions.find (dir_name);
@@ -654,17 +654,17 @@ namespace octave
       }
 
     // Subfunction.  I think it only makes sense to check for
     // subfunctions if we are currently executing a function defined
     // from a .m file.
 
     if (curr_scope)
       {
-        octave_value val = curr_scope->find_subfunction (name);
+        octave_value val = curr_scope.find_subfunction (name);
 
         if (val.is_defined ())
           return val;
       }
 
     return octave_value ();
   }
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -489,18 +489,18 @@ namespace octave
     octave_user_code *curr_fcn = cs.caller_user_code ();
 
     if (! curr_fcn)
       return retval;
 
     // All subfunctions are listed in the top-level function of this file.
     while (curr_fcn->is_subfunction ())
       {
-        symbol_scope *pscope = curr_fcn->parent_fcn_scope ();
-        curr_fcn = pscope->function ();
+        symbol_scope pscope = curr_fcn->parent_fcn_scope ();
+        curr_fcn = pscope.function ();
       }
 
     // Get subfunctions.
     const std::list<std::string> names = curr_fcn->subfunction_names ();
 
     size_t sz = names.size ();
     retval.resize (sz);
 
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -74,26 +74,26 @@ namespace octave
 
   symbol_table& __get_symbol_table__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_symbol_table ();
   }
 
-  symbol_scope *__get_current_scope__ (const std::string& who)
+  symbol_scope __get_current_scope__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_current_scope ();
   }
 
-  symbol_scope *__require_current_scope__ (const std::string& who)
+  symbol_scope __require_current_scope__ (const std::string& who)
   {
-    symbol_scope *scope = __get_current_scope__ (who);
+    symbol_scope scope = __get_current_scope__ (who);
 
     if (! scope)
       error ("%s: symbol table scope missing", who.c_str ());
 
     return scope;
   }
 
   tree_evaluator& __get_evaluator__ (const std::string& who)
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -46,20 +46,19 @@ namespace octave
   extern dynamic_loader& __get_dynamic_loader__ (const std::string& who);
 
   extern help_system& __get_help_system__ (const std::string& who);
 
   extern load_path& __get_load_path__ (const std::string& who);
 
   extern symbol_table& __get_symbol_table__ (const std::string& who);
 
-  extern symbol_scope *__get_current_scope__ (const std::string& who);
+  extern symbol_scope __get_current_scope__ (const std::string& who);
 
-  extern symbol_scope *
-  __require_current_scope__ (const std::string& who);
+  extern symbol_scope __require_current_scope__ (const std::string& who);
 
   extern tree_evaluator& __get_evaluator__ (const std::string& who);
 
   extern call_stack& __get_call_stack__ (const std::string& who);
 
   extern cdef_manager& __get_cdef_manager__ (const std::string& who);
 
   extern gtk_manager& __get_gtk_manager__ (const std::string& who);
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -534,22 +534,22 @@ namespace octave
   interpreter::~interpreter (void)
   {
     cleanup ();
   }
 
   void interpreter::intern_nargin (octave_idx_type nargs)
   {
     // FIXME: should this explicitly be top_scope?
-    symbol_scope *scope = m_symbol_table.current_scope ();
+    symbol_scope scope = m_symbol_table.current_scope ();
 
     if (scope)
       {
-        scope->assign (".nargin.", nargs);
-        scope->mark_hidden (".nargin.");
+        scope.assign (".nargin.", nargs);
+        scope.mark_hidden (".nargin.");
       }
   }
 
   // Read the history file unless a command-line option inhibits that.
 
   void interpreter::initialize_history (bool read_history_file)
   {
     if (! m_history_initialized)
@@ -1172,26 +1172,26 @@ namespace octave
     return m_stream_list;
   }
 
   url_handle_manager& interpreter::get_url_handle_manager (void)
   {
     return m_url_handle_manager;
   }
 
-  symbol_scope *
+  symbol_scope
   interpreter::get_current_scope (void)
   {
     return m_symbol_table.current_scope ();
   }
 
-  symbol_scope *
+  symbol_scope
   interpreter::require_current_scope (const std::string& who)
   {
-    symbol_scope *scope = get_current_scope ();
+    symbol_scope scope = get_current_scope ();
 
     if (! scope)
       error ("%s: symbol table scope missing", who.c_str ());
 
     return scope;
   }
 
   call_stack& interpreter::get_call_stack (void)
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -162,18 +162,18 @@ namespace octave
       return m_load_path;
     }
 
     symbol_table& get_symbol_table (void)
     {
       return m_symbol_table;
     }
 
-    symbol_scope * get_current_scope (void);
-    symbol_scope * require_current_scope (const std::string& who);
+    symbol_scope get_current_scope (void);
+    symbol_scope require_current_scope (const std::string& who);
 
     call_stack& get_call_stack (void);
 
     profiler& get_profiler (void);
 
     tree_evaluator& get_evaluator (void);
 
     stream_list& get_stream_list (void);
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -116,19 +116,19 @@ strip_trailing_separators (const std::st
 static std::string
 find_private_file (const std::string& fname)
 {
   std::string retval;
 
   // Look in private directory corresponding to current function (if
   // any).
 
-  octave::symbol_scope *scope = octave::__get_current_scope__ ("find_private_file");
-
-  octave_user_function *curr_fcn = scope ? scope->function () : nullptr;
+  octave::symbol_scope scope = octave::__get_current_scope__ ("find_private_file");
+
+  octave_user_function *curr_fcn = scope ? scope.function () : nullptr;
 
   if (curr_fcn)
     {
       // Even for private functions, dir_name doesn't contain the
       // "private" directory component so we append it here in all
       // cases.
 
       std::string dir_name = curr_fcn->dir_name ();
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -143,27 +143,27 @@ err_file_open (const std::string& fcn, c
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
                          bool global, const std::string& /*doc*/)
 {
   octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_loaded_variable");
 
-  octave::symbol_scope *scope
+  octave::symbol_scope scope
     = symtab.require_current_scope ("install_loaded_variable");
 
   if (global)
     {
-      scope->clear_variable (name);
-      scope->mark_global (name);
+      scope.clear_variable (name);
+      scope.mark_global (name);
       symtab.global_assign (name, val);
     }
   else
-    scope->assign (name, val);
+    scope.assign (name, val);
 }
 
 // Return TRUE if NAME matches one of the given globbing PATTERNS.
 
 static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
                   int num_pat, const std::string& name)
 {
@@ -1005,21 +1005,21 @@ save_fields (std::ostream& os, const oct
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.
 
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
            load_save_format fmt, bool save_as_floats)
 {
-  octave::symbol_scope *scope = octave::__require_current_scope__ ("save_vars");
+  octave::symbol_scope scope = octave::__require_current_scope__ ("save_vars");
 
-  octave::symbol_record::context_id context = scope->current_context ();
+  octave::symbol_record::context_id context = scope.current_context ();
 
-  std::list<octave::symbol_record> vars = scope->glob (pattern);
+  std::list<octave::symbol_record> vars = scope.glob (pattern);
 
   size_t saved = 0;
 
   for (const auto& var : vars)
     {
       do_save (os, var, context, fmt, save_as_floats);
 
       saved++;
@@ -1276,26 +1276,26 @@ save_vars (const string_vector& argv, in
     }
   else if (argv[argv_idx] == "-struct")
     {
       if (++argv_idx >= argc)
         error ("save: missing struct name");
 
       std::string struct_name = argv[argv_idx];
 
-      octave::symbol_scope *scope = octave::__get_current_scope__ ("save_vars");
+      octave::symbol_scope scope = octave::__get_current_scope__ ("save_vars");
 
       octave_value struct_var;
 
       if (scope)
         {
-          if (! scope->is_variable (struct_name))
+          if (! scope.is_variable (struct_name))
             error ("save: no such variable: '%s'", struct_name.c_str ());
 
-          struct_var = scope->varval (struct_name);
+          struct_var = scope.varval (struct_name);
         }
 
       if (! struct_var.isstruct () || struct_var.numel () != 1)
         error ("save: '%s' is not a scalar structure", struct_name.c_str ());
 
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
 
       ++argv_idx;
@@ -1330,21 +1330,21 @@ save_vars (const string_vector& argv, in
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
 
-  octave::symbol_scope *top_scope = symtab.top_scope ();
+  octave::symbol_scope top_scope = symtab.top_scope ();
 
-  octave::symbol_record::context_id context = top_scope->current_context ();
+  octave::symbol_record::context_id context = top_scope.current_context ();
 
-  std::list<octave::symbol_record> vars = top_scope->all_variables ();
+  std::list<octave::symbol_record> vars = top_scope.all_variables ();
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
       octave_value val = var.varval (context);
 
       if (val.is_defined ())
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -973,21 +973,21 @@ read_mat5_binary_element (std::istream& 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             octave::symbol_table& symtab
               = octave::__get_symbol_table__ ("read_mat5_binary_element");
 
             octave::symbol_scope local_scope;
 
-            symtab.set_scope (&local_scope);
+            symtab.set_scope (local_scope);
 
             octave::call_stack& cs
               = octave::__get_call_stack__ ("read_mat5_binary_element");
-            cs.push (&local_scope, 0);
+            cs.push (local_scope, 0);
             frame.add_method (cs, &octave::call_stack::pop);
 
             if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
                 for (octave_map::iterator p0 = m2.begin () ;
                      p0 != m2.end (); p0++)
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3471,20 +3471,20 @@ mexGetVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexGetVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          octave::symbol_scope *scope
+          octave::symbol_scope scope
             = octave::__require_current_scope__ ("mexGetVariable");
 
-          val = scope->varval (name);
+          val = scope.varval (name);
         }
       else
         mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
 
   if (val.is_defined ())
     {
       retval = mex_context->make_value (val);
@@ -3542,20 +3542,20 @@ mexPutVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexPutVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          octave::symbol_scope *scope
+          octave::symbol_scope scope
             = octave::__require_current_scope__ ("mexPutVariable");
 
-          scope->assign (name, mxArray::as_octave_value (ptr));
+          scope.assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
   return 0;
 }
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -66,19 +66,19 @@ void
 octave_link::set_workspace (void)
 {
   if (enabled ())
     {
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_link::set_workspace");
 
       std::list<workspace_element> workspace_info;
-      octave::symbol_scope *scope = symtab.current_scope ();
+      octave::symbol_scope scope = symtab.current_scope ();
       if (scope)
-        workspace_info = scope->workspace_info ();
+        workspace_info = scope.workspace_info ();
 
       instance->do_set_workspace (symtab.at_top_level (),
                                   instance->debugging, workspace_info);
     }
 }
 
 // OBJ should be an object of a class that is derived from the base
 // class octave_link, or 0 to disconnect the link.  It is the
diff --git a/libinterp/corefcn/symrec.cc b/libinterp/corefcn/symrec.cc
--- a/libinterp/corefcn/symrec.cc
+++ b/libinterp/corefcn/symrec.cc
@@ -55,17 +55,17 @@ namespace octave
         t_fwd_rep->init_persistent ();
         return;
       }
 
     mark_persistent ();
   }
 
   symbol_record::symbol_record_rep *
-  symbol_record::symbol_record_rep::dup (symbol_scope *new_scope) const
+  symbol_record::symbol_record_rep::dup (symbol_scope_rep *new_scope) const
   {
     // FIXME: is this the right thing do to?
     if (auto t_fwd_rep = m_fwd_rep.lock ())
       return t_fwd_rep->dup (new_scope);
 
     static const context_id FIXME_CONTEXT = 0;
 
     return new symbol_record_rep (m_name, varval (FIXME_CONTEXT),
diff --git a/libinterp/corefcn/symrec.h b/libinterp/corefcn/symrec.h
--- a/libinterp/corefcn/symrec.h
+++ b/libinterp/corefcn/symrec.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 
 class octave_user_function;
 
 #include "ov.h"
 #include "ovl.h"
 
 namespace octave
 {
-  class symbol_scope;
+  class symbol_scope_rep;
 
   class symbol_record
   {
   public:
 
     typedef size_t context_id;
 
     // generic variable
@@ -73,18 +73,18 @@ namespace octave
     static const unsigned int added_static = 128;
 
   private:
 
     class symbol_record_rep
     {
     public:
 
-      symbol_record_rep (const std::string& nm,
-                         const octave_value& v, unsigned int sc)
+      symbol_record_rep (const std::string& nm, const octave_value& v,
+                         unsigned int sc)
         : m_storage_class (sc), m_name (nm), m_fwd_scope (nullptr),
           m_fwd_rep (), m_value_stack (), m_valid (true)
       {
         m_value_stack.push_back (v);
       }
 
       // No copying!
 
@@ -487,17 +487,17 @@ namespace octave
           {
             t_fwd_rep->invalidate ();
             return;
           }
 
         m_valid = false;
       }
 
-      void bind_fwd_rep (symbol_scope *fwd_scope,
+      void bind_fwd_rep (symbol_scope_rep *fwd_scope,
                          const std::shared_ptr<symbol_record_rep>& fwd_rep)
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
           {
             t_fwd_rep->bind_fwd_rep (fwd_scope, fwd_rep);
             return;
           }
 
@@ -512,31 +512,31 @@ namespace octave
             t_fwd_rep->unbind_fwd_rep ();
             return;
           }
 
         m_fwd_scope = nullptr;
         m_fwd_rep.reset ();
       }
 
-      symbol_record_rep * dup (symbol_scope *new_scope) const;
+      symbol_record_rep * dup (symbol_scope_rep *new_scope) const;
 
       octave_value dump (context_id context) const;
 
       std::string name (void) const { return m_name; }
 
       void rename (const std::string& new_name) { m_name = new_name; }
 
     private:
 
       unsigned int m_storage_class;
 
       std::string m_name;
 
-      symbol_scope *m_fwd_scope;
+      symbol_scope_rep *m_fwd_scope;
 
       std::weak_ptr<symbol_record_rep> m_fwd_rep;
 
       std::deque<octave_value> m_value_stack;
 
       bool m_valid;
     };
 
@@ -549,17 +549,17 @@ namespace octave
     { }
 
     symbol_record (const symbol_record& sr) = default;
 
     symbol_record& operator = (const symbol_record& sr) = default;
 
     ~symbol_record (void) = default;
 
-    symbol_record dup (symbol_scope *sid) const
+    symbol_record dup (symbol_scope_rep *sid) const
     {
       return symbol_record (m_rep->dup (sid));
     }
 
     std::string name (void) const { return m_rep->name (); }
 
     void rename (const std::string& new_name) { m_rep->rename (new_name); }
 
@@ -657,17 +657,17 @@ namespace octave
     void unmark_added_static (void) { m_rep->unmark_added_static (); }
 
     void init_persistent (void) { m_rep->init_persistent (); }
 
     void invalidate (void) { m_rep->invalidate (); }
 
     unsigned int storage_class (void) const { return m_rep->storage_class (); }
 
-    void bind_fwd_rep (symbol_scope *fwd_scope, const symbol_record& sr)
+    void bind_fwd_rep (symbol_scope_rep *fwd_scope, const symbol_record& sr)
     {
       m_rep->bind_fwd_rep (fwd_scope, sr.m_rep);
     }
 
     void unbind_fwd_rep (void) { m_rep->unbind_fwd_rep (); }
 
     octave_value dump (context_id context) const
     {
diff --git a/libinterp/corefcn/symscope.cc b/libinterp/corefcn/symscope.cc
--- a/libinterp/corefcn/symscope.cc
+++ b/libinterp/corefcn/symscope.cc
@@ -35,23 +35,24 @@ along with Octave; see the file COPYING.
 #include "symrec.h"
 #include "symscope.h"
 #include "symtab.h"
 #include "utils.h"
 
 namespace octave
 {
   octave_value
-  symbol_scope::find (const std::string& name, const octave_value_list& args,
-                      bool skip_variables, bool local_funcs)
+  symbol_scope_rep::find (const std::string& name,
+                          const octave_value_list& args,
+                          bool skip_variables, bool local_funcs)
   {
     // Variable.
 
     symbol_table& symtab
-      = __get_symbol_table__ ("symbol_scope::find");
+      = __get_symbol_table__ ("symbol_scope_rep::find");
 
     if (! skip_variables)
       {
         table_iterator p = m_symbols.find (name);
 
         if (p != m_symbols.end ())
           {
             symbol_record sr = p->second;
@@ -79,17 +80,17 @@ namespace octave
         if (fcn.is_defined ())
           return fcn;
       }
 
     return symtab.fcn_table_find (name, args, local_funcs);
   }
 
   symbol_record&
-  symbol_scope::insert (const std::string& name, bool force_add)
+  symbol_scope_rep::insert (const std::string& name, bool force_add)
   {
     table_iterator p = m_symbols.find (name);
 
     if (p == m_symbols.end ())
       {
         symbol_record ret (name);
 
         if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
@@ -102,17 +103,17 @@ namespace octave
             return m_symbols[name] = ret;
           }
       }
     else
       return p->second;
   }
 
   std::list<workspace_element>
-  symbol_scope::workspace_info (void) const
+  symbol_scope_rep::workspace_info (void) const
   {
     std::list<workspace_element> retval;
 
     for (const auto& nm_sr : m_symbols)
       {
         std::string nm = nm_sr.first;
         symbol_record sr = nm_sr.second;
 
@@ -156,94 +157,94 @@ namespace octave
               }
           }
       }
 
     return retval;
   }
 
   octave_value
-  symbol_scope::dump (void) const
+  symbol_scope_rep::dump (void) const
   {
     std::map<std::string, octave_value> m
       = {{ "name", m_name },
          { "symbols", dump_symbols_map () },
          { "subfunctions", dump_function_map (m_subfunctions) }};
 
     return octave_value (m);
   }
 
   octave_value
-  symbol_scope::dump_symbols_map (void) const
+  symbol_scope_rep::dump_symbols_map (void) const
   {
     std::map<std::string, octave_value> info_map;
 
     for (const auto& nm_sr : m_symbols)
       {
         std::string nm = nm_sr.first;
         const symbol_record& sr = nm_sr.second;
         info_map[nm] = sr.dump (m_context);
       }
 
     return octave_value (info_map);
   }
 
   void
-  symbol_scope::install_subfunction (const std::string& name,
-                                     const octave_value& fval, bool is_nested)
+  symbol_scope_rep::install_subfunction (const std::string& name,
+                                         const octave_value& fval,
+                                         bool is_nested)
   {
     m_subfunctions[name] = fval;
 
     // This can be simpler once the scope object is stored in the function
     // object...
     octave_user_function *fcn = fval.user_function_value ();
 
-    symbol_scope *fcn_scope = fcn->scope ();
+    symbol_scope fcn_scope = fcn->scope ();
 
-    fcn_scope->set_parent (this);
+    fcn_scope.set_parent (this);
 
     if (is_nested)
       {
         m_children.push_back (fcn_scope);
 
         fcn->mark_as_nested_function ();
 
-        fcn_scope->m_is_nested = true;
+        fcn_scope.mark_nested ();
       }
-
   }
 
   octave_value
-  symbol_scope::find_subfunction (const std::string& name) const
+  symbol_scope_rep::find_subfunction (const std::string& name) const
   {
     subfunctions_const_iterator p = m_subfunctions.find (name);
 
     if (p != m_subfunctions.end ())
       return p->second;
 
     if (m_parent)
       return m_parent->find_subfunction (name);
 
     return octave_value ();
   }
 
   void
-  symbol_scope::mark_subfunctions_in_scope_as_private (const std::string& class_name)
+  symbol_scope_rep::mark_subfunctions_in_scope_as_private (const std::string& class_name)
   {
     for (auto& nm_sf : m_subfunctions)
       {
         octave_function *fcn = nm_sf.second.function_value ();
 
         if (fcn)
           fcn->mark_as_private_function (class_name);
       }
   }
 
   void
-  symbol_scope::set_parent (symbol_scope *p)
+  symbol_scope_rep::set_parent (symbol_scope_rep *p)
   {
     m_parent = p;
 
     if (m_parent)
       {
         // If m_parent is the top-level scope, there will be no parent
         // function.
 
@@ -255,17 +256,17 @@ namespace octave
 
             if (parent_fcn)
               m_parent_fcn = octave_value (parent_fcn, true);
           }
       }
   }
 
   void
-  symbol_scope::update_nest (void)
+  symbol_scope_rep::update_nest (void)
   {
     if (m_parent)
       {
         // fix bad symbol_records
         for (auto& nm_sr : m_symbols)
           {
             symbol_record& ours = nm_sr.second;
 
@@ -281,22 +282,23 @@ namespace octave
         m_is_static = true;
       }
     else if (m_children.size ())
       {
         // Parents of nested functions have static scopes.
         m_is_static = true;
       }
 
-    for (auto& symtab_p : m_children)
-      symtab_p->update_nest ();
+    for (auto& scope_obj : m_children)
+      scope_obj.update_nest ();
   }
 
   bool
-  symbol_scope::look_nonlocal (const std::string& name, symbol_record& result)
+  symbol_scope_rep::look_nonlocal (const std::string& name,
+                                   symbol_record& result)
   {
     table_iterator p = m_symbols.find (name);
     if (p == m_symbols.end ())
       {
         if (m_is_nested && m_parent)
           return m_parent->look_nonlocal (name, result);
       }
     else if (! p->second.is_automatic ())
@@ -304,22 +306,22 @@ namespace octave
         result.bind_fwd_rep (this, p->second);
         return true;
       }
 
     return false;
   }
 
   void
-  symbol_scope::bind_script_symbols (symbol_scope *curr_scope)
+  symbol_scope_rep::bind_script_symbols (symbol_scope_rep *curr_scope)
   {
     for (auto& nm_sr : m_symbols)
       nm_sr.second.bind_fwd_rep (curr_scope,
                                  curr_scope->find_symbol (nm_sr.first));
   }
 
   void
-  symbol_scope::unbind_script_symbols (void)
+  symbol_scope_rep::unbind_script_symbols (void)
   {
     for (auto& nm_sr : m_symbols)
       nm_sr.second.unbind_fwd_rep ();
   }
 }
diff --git a/libinterp/corefcn/symscope.h b/libinterp/corefcn/symscope.h
--- a/libinterp/corefcn/symscope.h
+++ b/libinterp/corefcn/symscope.h
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #define octave_symscope_h 1
 
 #include "octave-config.h"
 
 #include <deque>
 #include <limits>
 #include <list>
 #include <map>
+#include <memory>
 #include <set>
 #include <string>
 
 #include "glob-match.h"
 #include "lo-regexp.h"
 #include "oct-refcount.h"
 
 class tree_argument_list;
@@ -42,66 +43,69 @@ class octave_user_function;
 
 #include "ov.h"
 #include "ovl.h"
 #include "symrec.h"
 #include "workspace-element.h"
 
 namespace octave
 {
-  class symbol_scope
+  class symbol_scope;
+
+  class symbol_scope_rep
   {
   public:
 
     typedef symbol_record::context_id context_id;
 
     typedef std::map<std::string, symbol_record>::const_iterator
     table_const_iterator;
     typedef std::map<std::string, symbol_record>::iterator
     table_iterator;
 
     typedef std::map<std::string, octave_value>::const_iterator
     subfunctions_const_iterator;
     typedef std::map<std::string, octave_value>::iterator
     subfunctions_iterator;
 
-    symbol_scope (const std::string& name = "")
+    symbol_scope_rep (const std::string& name = "")
       : m_name (name), m_symbols (), m_subfunctions (),
         m_fcn (nullptr), m_parent (nullptr), m_parent_fcn (),
         m_children (), m_is_nested (false),
         m_is_static (false), m_context (0)
     { }
 
     // No copying!
 
-    symbol_scope (const symbol_scope&) = delete;
+    symbol_scope_rep (const symbol_scope&) = delete;
 
-    symbol_scope& operator = (const symbol_scope&) = delete;
+    symbol_scope_rep& operator = (const symbol_scope&) = delete;
 
-    ~symbol_scope (void) = default;
+    ~symbol_scope_rep (void) = default;
 
     void insert_symbol_record (const symbol_record& sr)
     {
       m_symbols[sr.name ()] = sr;
     }
 
     bool is_nested (void) const { return m_is_nested; }
 
     void mark_nested (void) { m_is_nested = true; }
 
     bool is_static (void) const { return m_is_static; }
 
     void mark_static (void) { m_is_static = true; }
 
-    symbol_scope * parent_scope (void) const { return m_parent; }
+    symbol_scope_rep * parent_scope_rep (void) const { return m_parent; }
+
     octave_value parent_fcn (void) const { return m_parent_fcn; }
 
-    symbol_scope * dup (void) const
+    symbol_scope_rep * dup (void) const
     {
-      symbol_scope *new_sid = new symbol_scope (m_name);
+      symbol_scope_rep *new_sid = new symbol_scope_rep (m_name);
 
       for (const auto& nm_sr : m_symbols)
         new_sid->insert_symbol_record (nm_sr.second.dup (new_sid));
 
       new_sid->m_parent = m_parent;
       new_sid->m_parent_fcn = m_parent_fcn;
 
       return new_sid;
@@ -116,55 +120,54 @@ namespace octave
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         return insert (name);
       else
         return p->second;
     }
 
-    void inherit_internal (symbol_scope& donor_scope)
+    void inherit_internal (symbol_scope_rep& donor_scope_rep)
     {
       for (auto& nm_sr : m_symbols)
         {
           symbol_record& sr = nm_sr.second;
 
           if (! (sr.is_automatic () || sr.is_formal ()))
             {
               std::string nm = sr.name ();
 
               if (nm != "__retval__")
                 {
-                  octave_value val = donor_scope.varval (nm);
+                  octave_value val = donor_scope_rep.varval (nm);
 
                   if (val.is_defined ())
                     {
                       sr.assign (val, m_context);
 
                       sr.mark_inherited ();
                     }
                 }
             }
         }
     }
 
-    void inherit (symbol_scope *donor_scope)
+    void inherit (symbol_scope_rep *donor_scope_rep)
     {
-      while (donor_scope)
+      while (donor_scope_rep)
         {
-          inherit_internal (*donor_scope);
+          inherit_internal (*donor_scope_rep);
 
-          if (donor_scope->is_nested ())
-            donor_scope = donor_scope->parent_scope ();
+          if (donor_scope_rep->is_nested ())
+            donor_scope_rep = parent_scope_rep ();
           else
             break;
         }
     }
 
-
     octave_value
     find (const std::string& name, const octave_value_list& args,
           bool skip_variables, bool local_funcs);
 
     symbol_record&
     insert (const std::string& name, bool force_add = false);
 
     void rename (const std::string& old_name, const std::string& new_name)
@@ -460,17 +463,17 @@ namespace octave
     }
 
     void unlock_subfunctions (void)
     {
       for (auto& nm_sf : m_subfunctions)
         nm_sf.second.unlock ();
     }
 
-    std::map<std::string, octave_value> subfunctions (void)
+    std::map<std::string, octave_value> subfunctions (void) const
     {
       return m_subfunctions;
     }
 
     void erase_subfunctions (void)
     {
       m_subfunctions.clear ();
     }
@@ -499,26 +502,28 @@ namespace octave
     std::string name (void) const { return m_name; }
 
     void cache_name (const std::string& name) { m_name = name; }
 
     octave_user_function *function (void) { return m_fcn; }
 
     void set_function (octave_user_function *fcn) { m_fcn = fcn; }
 
-    void set_parent (symbol_scope *p);
+    void set_parent (symbol_scope_rep *p);
 
     void update_nest (void);
 
     bool look_nonlocal (const std::string& name, symbol_record& result);
 
-    void bind_script_symbols (symbol_scope *curr_scope);
+    void bind_script_symbols (symbol_scope_rep *curr_scope);
 
     void unbind_script_symbols (void);
 
+    octave_value dump_symbols_map (void) const;
+
   private:
 
     // Name for this scope (usually the corresponding filename of the
     // function corresponding to the scope).
     std::string m_name;
 
     // Map from symbol names to symbol info.
     std::map<std::string, symbol_record> m_symbols;
@@ -529,27 +534,412 @@ namespace octave
     // The list of subfunctions (if any) in the order they appear in
     // the function file.
     std::list<std::string> m_subfunction_names;
 
     // The associated user code (may be null).
     octave_user_function *m_fcn;
 
     // Parent of nested function (may be null).
-    symbol_scope *m_parent;
+    symbol_scope_rep *m_parent;
     octave_value m_parent_fcn;
 
     // Child nested functions.
-    std::vector<symbol_scope*> m_children;
+    std::vector<symbol_scope> m_children;
 
     // If true, then this scope belongs to a nested function.
     bool m_is_nested;
 
     // If true then no variables can be added.
     bool m_is_static;
 
     context_id m_context;
+  };
 
-    octave_value dump_symbols_map (void) const;
+  class symbol_scope
+  {
+  public:
+
+    typedef symbol_record::context_id context_id;
+
+    symbol_scope (const std::string& name = "")
+      : m_rep (new symbol_scope_rep (name))
+    { }
+
+    symbol_scope (const symbol_scope&) = default;
+
+    symbol_scope& operator = (const symbol_scope&) = default;
+
+    ~symbol_scope (void) = default;
+
+    bool is_valid (void) const { return bool (m_rep); }
+
+    explicit operator bool () const { return bool (m_rep); }
+
+    void insert_symbol_record (const symbol_record& sr)
+    {
+      m_rep->insert_symbol_record (sr);
+    }
+
+    bool is_nested (void) const
+    {
+      return m_rep->is_nested ();
+    }
+
+    void mark_nested (void)
+    {
+      m_rep->mark_nested ();
+    }
+
+    bool is_static (void) const
+    {
+      return m_rep->is_static ();
+    }
+
+    void mark_static (void)
+    {
+      m_rep->mark_static ();
+    }
+
+    symbol_scope_rep * parent_scope (void) const
+    {
+      return m_rep->parent_scope_rep ();
+    }
+
+    octave_value parent_fcn (void) const
+    {
+      return m_rep->parent_fcn ();
+    }
+
+    symbol_scope dup (void) const
+    {
+      return symbol_scope (m_rep->dup ());
+    }
+
+    void set_context (context_id context)
+    {
+      m_rep->set_context (context);
+    }
+
+    context_id current_context (void) const
+    {
+      return m_rep->current_context ();
+    }
+
+    symbol_record find_symbol (const std::string& name)
+    {
+      return m_rep->find_symbol (name);
+    }
+
+    void inherit (const symbol_scope& donor_scope)
+    {
+      m_rep->inherit (donor_scope.get_rep ());
+    }
+
+    octave_value
+    find (const std::string& name, const octave_value_list& args,
+          bool skip_variables, bool local_funcs)
+    {
+      return m_rep->find (name, args, skip_variables, local_funcs);
+    }
+
+    symbol_record&
+    insert (const std::string& name, bool force_add = false)
+    {
+      return m_rep->insert (name, force_add);
+    }
+
+    void rename (const std::string& old_name, const std::string& new_name)
+    {
+      m_rep->rename (old_name, new_name);
+    }
+
+    void assign (const std::string& name, const octave_value& value,
+                 bool force_add)
+    {
+      m_rep->assign (name, value, force_add);
+    }
+
+    void assign (const std::string& name,
+                 const octave_value& value = octave_value ())
+    {
+      m_rep->assign (name, value);
+    }
+
+    void force_assign (const std::string& name, const octave_value& value)
+    {
+      m_rep->force_assign (name, value);
+    }
+
+    octave_value varval (const std::string& name) const
+    {
+      return m_rep->varval (name);
+    }
+
+    bool is_variable (const std::string& name) const
+    {
+      return m_rep->is_variable (name);
+    }
+
+    void push_context (void)
+    {
+      m_rep->push_context ();
+    }
+
+    void pop_context (void)
+    {
+      m_rep->pop_context ();
+    }
+
+    void refresh (void)
+    {
+      m_rep->refresh ();
+    }
+
+    void clear_variables (void)
+    {
+      m_rep->clear_variables ();
+    }
+
+    void clear_objects (void)
+    {
+      m_rep->clear_objects ();
+    }
+
+    void clear_variable (const std::string& name)
+    {
+      m_rep->clear_variable (name);
+    }
+
+    void clear_variable_pattern (const std::string& pat)
+    {
+      m_rep->clear_variable_pattern (pat);
+    }
+
+    void clear_variable_regexp (const std::string& pat)
+    {
+      m_rep->clear_variable_regexp (pat);
+    }
+
+    void mark_automatic (const std::string& name)
+    {
+      m_rep->mark_automatic (name);
+    }
+
+    void mark_hidden (const std::string& name)
+    {
+      m_rep->mark_hidden (name);
+    }
+
+    void mark_global (const std::string& name)
+    {
+      m_rep->mark_global (name);
+    }
+
+    std::list<symbol_record>
+    all_variables (bool defined_only = true,
+                   unsigned int exclude = symbol_record::hidden) const
+    {
+      return m_rep->all_variables (defined_only, exclude);
+    }
+
+    std::list<symbol_record>
+    glob (const std::string& pattern, bool vars_only = false) const
+    {
+      return m_rep->glob (pattern, vars_only);
+    }
+
+    std::list<symbol_record>
+    regexp (const std::string& pattern, bool vars_only = false) const
+    {
+      return m_rep->regexp (pattern, vars_only);
+    }
+
+    std::list<std::string> variable_names (void)
+    {
+      return m_rep->variable_names ();
+    }
+
+    bool is_local_variable (const std::string& name) const
+    {
+      return m_rep->is_local_variable (name);
+    }
+
+    bool is_global (const std::string& name) const
+    {
+      return m_rep->is_global (name);
+    }
+
+    void install_subfunction (const std::string& name,
+                              const octave_value& fval,
+                              bool is_nested = false)
+    {
+      m_rep->install_subfunction (name, fval, is_nested);
+    }
+
+    void install_nestfunction (const std::string& name,
+                               const octave_value& fval)
+    {
+      m_rep->install_nestfunction (name, fval);
+    }
+
+    octave_value find_subfunction (const std::string& name) const
+    {
+      return m_rep->find_subfunction (name);
+    }
+
+    void lock_subfunctions (void)
+    {
+      m_rep->lock_subfunctions ();
+    }
+
+    void unlock_subfunctions (void)
+    {
+      m_rep->unlock_subfunctions ();
+    }
+
+    std::map<std::string, octave_value> subfunctions (void) const
+    {
+      return m_rep->subfunctions ();
+    }
+
+    void erase_subfunctions (void)
+    {
+      m_rep->erase_subfunctions ();
+    }
+
+    void mark_subfunctions_in_scope_as_private (const std::string& class_name)
+    {
+      m_rep->mark_subfunctions_in_scope_as_private (class_name);
+    }
+
+    bool has_subfunctions (void) const
+    {
+      return m_rep->has_subfunctions ();
+    }
+
+    void stash_subfunction_names (const std::list<std::string>& names)
+    {
+      m_rep->stash_subfunction_names (names);
+    }
+
+    std::list<std::string> subfunction_names (void) const
+    {
+      return m_rep->subfunction_names ();
+    }
+
+    std::list<workspace_element> workspace_info (void) const
+    {
+      return m_rep->workspace_info ();
+    }
+
+    octave_value dump (void) const
+    {
+      return m_rep->dump ();
+    }
+
+    std::string name (void) const
+    {
+      return m_rep->name ();
+    }
+
+    void cache_name (const std::string& name)
+    {
+      m_rep->cache_name (name);
+    }
+
+    octave_user_function *function (void)
+    {
+      return m_rep->function ();
+    }
+
+    void set_function (octave_user_function *fcn)
+    {
+      m_rep->set_function (fcn);
+    }
+
+    void set_parent (const symbol_scope& p)
+    {
+      m_rep->set_parent (p.get_rep ());
+    }
+
+    void set_parent (symbol_scope_rep *p)
+    {
+      m_rep->set_parent (p);
+    }
+
+    void update_nest (void)
+    {
+      m_rep->update_nest ();
+    }
+
+    bool look_nonlocal (const std::string& name, symbol_record& result)
+    {
+      return m_rep->look_nonlocal (name, result);
+    }
+
+    void bind_script_symbols (const symbol_scope& curr_scope)
+    {
+      m_rep->bind_script_symbols (curr_scope.get_rep ());
+    }
+
+    void unbind_script_symbols (void)
+    {
+      m_rep->unbind_script_symbols ();
+    }
+
+    symbol_scope_rep * get_rep (void) const
+    {
+      return m_rep.get ();
+    }
+
+    friend bool operator == (const symbol_scope& a, const symbol_scope& b)
+    {
+      return a.m_rep == b.m_rep;
+    }
+
+    friend bool operator != (const symbol_scope& a, const symbol_scope& b)
+    {
+      return a.m_rep != b.m_rep;
+    }
+
+    friend bool operator < (const symbol_scope& a, const symbol_scope& b)
+    {
+      return a.m_rep < b.m_rep;
+    }
+
+    friend bool operator <= (const symbol_scope& a, const symbol_scope& b)
+    {
+      return a.m_rep <= b.m_rep;
+    }
+
+    friend bool operator >= (const symbol_scope& a, const symbol_scope& b)
+    {
+      return a.m_rep >= b.m_rep;
+    }
+
+    friend bool operator > (const symbol_scope& a, const symbol_scope& b)
+    {
+      return a.m_rep > b.m_rep;
+    }
+
+    symbol_scope_rep * get_rep_ptr (void) const { return m_rep.get (); }
+
+  private:
+
+    std::shared_ptr<symbol_scope_rep> m_rep;
+
+    // NEW_REP must be dynamically allocated or nullptr.
+    symbol_scope (symbol_scope_rep *new_rep) : m_rep (new_rep) { }
+
+    octave_value dump_symbols_map (void) const
+    {
+      return m_rep->dump_symbols_map ();
+    }
+
+    symbol_scope_rep * parent_scope_rep (void) const
+    {
+      return m_rep->parent_scope_rep ();
+    }
   };
 }
 
 #endif
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -290,23 +290,23 @@ namespace octave
       }
 
     return retval;
   }
 
   void
   symbol_table::clear_global (const std::string& name)
   {
-    m_global_scope->clear_variable (name);
+    m_global_scope.clear_variable (name);
   }
 
   void
   symbol_table::clear_global_pattern (const std::string& pattern)
   {
-    m_global_scope->clear_variable_pattern (pattern);
+    m_global_scope.clear_variable_pattern (pattern);
   }
 
   // Insert INF_CLASS in the set of class names that are considered
   // inferior to SUP_CLASS.  Return FALSE if INF_CLASS is currently
   // marked as superior to SUP_CLASS.
 
   bool
   symbol_table::set_class_relationship (const std::string& sup_class,
@@ -349,17 +349,17 @@ namespace octave
     return (q != inferior_classes.end ());
   }
 
   octave_value
   symbol_table::find (const std::string& name, const octave_value_list& args,
                       bool skip_variables, bool local_funcs)
   {
     return (m_current_scope
-            ? m_current_scope->find (name, args, skip_variables, local_funcs)
+            ? m_current_scope.find (name, args, skip_variables, local_funcs)
             : octave_value ());
   }
 
   octave_value
   symbol_table::builtin_find (const std::string& name)
   {
     fcn_table_iterator p = m_fcn_table.find (name);
 
@@ -426,17 +426,17 @@ namespace octave
       {
         size_t pos = name.find_first_of ('>');
 
         if (pos == std::string::npos)
           retval = find (name, args, true, local_funcs);
         else
           {
             std::string fcn_scope = name.substr (0, pos);
-            symbol_scope *stored_scope = m_current_scope;
+            symbol_scope stored_scope = m_current_scope;
             m_current_scope = m_top_scope;
             octave_value parent = find_function (name.substr (0, pos),
                                                  octave_value_list (), false);
 
             if (parent.is_defined ())
               {
                 octave_function *parent_fcn = parent.function_value ();
 
@@ -465,17 +465,17 @@ namespace octave
 
     std::string full_name = '@' + dispatch_type +
       sys::file_ops::dir_sep_str () + name;
     size_t pos = full_name.find_first_of ('>');
 
     if (pos != std::string::npos)
       {
         std::string fcn_scope = full_name.substr (0, pos);
-        symbol_scope *stored_scope = m_current_scope;
+        symbol_scope stored_scope = m_current_scope;
         m_current_scope = m_top_scope;
         octave_value parent = find_function (full_name.substr (0, pos),
                                              octave_value_list (), false);
         if (parent.is_defined ())
           {
             octave_function *parent_fcn = parent.function_value ();
 
             if (parent_fcn)
@@ -640,19 +640,19 @@ DEFMETHOD (__current_scope__, interp, , 
            doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{scope}, @var{context}]} __current_scope__ ()
 Return the current scope and context as integers.
 @seealso{__dump_symtab_info__}
 @end deftypefn */)
 {
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
-  octave::symbol_scope *scope = symtab.current_scope ();
+  octave::symbol_scope scope = symtab.current_scope ();
 
-  std::string nm = scope ? scope->name () : "<unknown>";
+  std::string nm = scope ? scope.name () : "<unknown>";
 
   return ovl (nm, symtab.current_context ());
 }
 
 DEFMETHOD (__dump_symtab_info__, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn  {} {} __dump_symtab_info__ ()
 @deftypefnx {} {} __dump_symtab_info__ (@var{function})
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -56,146 +56,142 @@ namespace octave
     typedef octave::symbol_record symbol_record;
     typedef octave::symbol_scope scope;
     typedef octave::fcn_info fcn_info;
 
     typedef scope::context_id context_id;
 
     symbol_table (void)
       : m_fcn_table (), m_class_precedence_table (),
-        m_parent_map (), m_global_scope (new scope ("global scope")),
-        m_top_scope (new symbol_scope ("top scope")),
-        m_current_scope (m_top_scope)
+        m_parent_map (), m_global_scope ("global scope"),
+        m_top_scope ("top scope"), m_current_scope (m_top_scope)
       { }
 
     // No copying!
 
     symbol_table (const symbol_table&) = delete;
 
     symbol_table& operator = (const symbol_table&) = delete;
 
-    ~symbol_table (void)
-      {
-        delete m_top_scope;
-        delete m_global_scope;
-      }
+    ~symbol_table (void) = default;
 
-    symbol_scope *global_scope (void) { return m_global_scope; }
-    symbol_scope *top_scope (void) { return m_top_scope; }
+    symbol_scope global_scope (void) { return m_global_scope; }
+    symbol_scope top_scope (void) { return m_top_scope; }
 
-    symbol_scope *current_scope (void) { return m_current_scope; }
+    symbol_scope current_scope (void) { return m_current_scope; }
 
-    symbol_scope *require_current_scope (const std::string& who)
+    symbol_scope require_current_scope (const std::string& who)
     {
       if (! m_current_scope)
         error ("%s: missing scope", who.c_str ());
 
       return m_current_scope;
     }
 
     context_id current_context (void) const
     {
-      return m_current_scope ? m_current_scope->current_context () : 0;
+      return m_current_scope ? m_current_scope.current_context () : 0;
     }
 
-    void set_scope (symbol_scope *sid)
+    void set_scope (const symbol_scope& sid)
     {
       set_scope_and_context (sid, 0);
     }
 
-    void set_scope_and_context (symbol_scope *sid, context_id context)
+    void set_scope_and_context (const symbol_scope& sid, context_id context)
     {
       if (sid == m_global_scope)
         error ("can't set scope to global");
 
       m_current_scope = sid;
 
       if (m_current_scope)
-        m_current_scope->set_context (context);
+        m_current_scope.set_context (context);
     }
 
-    symbol_record find_symbol (const std::string& name, symbol_scope *sid)
+    symbol_record find_symbol (const std::string& name, symbol_scope& sid)
     {
-      return sid ? sid->find_symbol (name) : symbol_record ();
+      return sid ? sid.find_symbol (name) : symbol_record ();
     }
 
     symbol_record find_symbol (const std::string& name)
     {
       return find_symbol (name, m_current_scope);
     }
 
     symbol_record find_global_symbol (const std::string& name)
     {
       symbol_record sym = find_symbol (name, m_global_scope);
 
       sym.mark_global ();
 
       return sym;
     }
 
-    void inherit (symbol_scope *recipient_scope, symbol_scope *donor_scope)
+    void
+    inherit (symbol_scope& recipient_scope, const symbol_scope& donor_scope)
     {
       if (recipient_scope)
-        recipient_scope->inherit (donor_scope);
+        recipient_scope.inherit (donor_scope);
     }
 
-    void inherit (symbol_scope *recipient_scope)
+    void inherit (symbol_scope& recipient_scope)
     {
       inherit (recipient_scope, m_current_scope);
     }
 
     bool at_top_level (void) { return m_current_scope == m_top_scope; }
 
     // Find a value corresponding to the given name in the table.
     octave_value
       find (const std::string& name,
             const octave_value_list& args = octave_value_list (),
             bool skip_variables = false,
             bool local_funcs = true);
 
     void assign (const std::string& name, const octave_value& value, bool force_add)
     {
       if (m_current_scope)
-        m_current_scope->assign (name, value, force_add);
+        m_current_scope.assign (name, value, force_add);
     }
 
     void assign (const std::string& name,
                  const octave_value& value = octave_value ())
     {
       if (m_current_scope)
-        m_current_scope->assign (name, value);
+        m_current_scope.assign (name, value);
     }
 
     octave_value varval (const std::string& name) const
     {
       return (m_current_scope
-              ? m_current_scope->varval (name) : octave_value ());
+              ? m_current_scope.varval (name) : octave_value ());
     }
 
     void global_assign (const std::string& name,
                         const octave_value& value = octave_value ())
     {
-      m_global_scope->assign (name, value);
+      m_global_scope.assign (name, value);
     }
 
     octave_value global_varval (const std::string& name) const
     {
-      return m_global_scope->varval (name);
+      return m_global_scope.varval (name);
     }
 
     void
       top_level_assign (const std::string& name,
                         const octave_value& value = octave_value ())
     {
-      m_top_scope->assign (name, value);
+      m_top_scope.assign (name, value);
     }
 
     octave_value top_level_varval (const std::string& name) const
     {
-      return m_top_scope->varval (name);
+      return m_top_scope.varval (name);
     }
 
     bool
       is_built_in_function_name (const std::string& name)
     {
       octave_value val = find_built_in_function (name);
 
       return val.is_defined ();
@@ -365,20 +361,18 @@ namespace octave
           finfo.install_built_in_function (fcn);
 
           m_fcn_table[name] = finfo;
         }
     }
 
     void clear_all (bool force = false)
     {
-      if (m_current_scope)
-        m_current_scope->clear_variables ();
-
-      m_global_scope->clear_variables ();
+      m_current_scope.clear_variables ();
+      m_global_scope.clear_variables ();
 
       clear_functions (force);
     }
 
     void clear_global (const std::string& name);
 
     void clear_global_pattern (const std::string& pattern);
 
@@ -399,17 +393,17 @@ namespace octave
       clear_user_function (name);
     }
 
     void clear_symbol (const std::string& name)
     {
       // FIXME: are we supposed to do both here?
 
       if (m_current_scope)
-        m_current_scope->clear_variable (name);
+        m_current_scope.clear_variable (name);
 
       clear_function (name);
     }
 
     void clear_function_pattern (const std::string& pat)
     {
       glob_match pattern (pat);
 
@@ -424,17 +418,17 @@ namespace octave
         }
     }
 
     void clear_symbol_pattern (const std::string& pat)
     {
       // FIXME: are we supposed to do both here?
 
       if (m_current_scope)
-        m_current_scope->clear_variable_pattern (pat);
+        m_current_scope.clear_variable_pattern (pat);
 
       clear_function_pattern (pat);
     }
 
     void clear_user_function (const std::string& name)
     {
       fcn_table_iterator p = m_fcn_table.find (name);
 
@@ -506,42 +500,42 @@ namespace octave
         }
       else
         error ("install_built_in_dispatch: '%s' is undefined", name.c_str ());
     }
 
     std::list<symbol_record> glob (const std::string& pattern)
     {
       return (m_current_scope
-              ? m_current_scope->glob (pattern) : std::list<symbol_record> ());
+              ? m_current_scope.glob (pattern) : std::list<symbol_record> ());
     }
 
     std::list<symbol_record> glob_global_variables (const std::string& pattern)
     {
-      return m_global_scope->glob (pattern);
+      return m_global_scope.glob (pattern);
     }
 
     std::list<symbol_record>
     regexp_global_variables (const std::string& pattern)
     {
-      return m_global_scope->regexp (pattern);
+      return m_global_scope.regexp (pattern);
     }
 
     std::list<symbol_record> glob_variables (const string_vector& patterns)
     {
       std::list<symbol_record> retval;
 
       if (! m_current_scope)
         return retval;
 
       size_t len = patterns.numel ();
 
       for (size_t i = 0; i < len; i++)
         {
-          std::list<symbol_record> tmp = m_current_scope->glob (patterns[i]);
+          std::list<symbol_record> tmp = m_current_scope.glob (patterns[i]);
 
           retval.insert (retval.begin (), tmp.begin (), tmp.end ());
         }
 
       return retval;
     }
 
     std::list<symbol_record> regexp_variables (const string_vector& patterns)
@@ -550,17 +544,17 @@ namespace octave
 
       if (! m_current_scope)
         return retval;
 
       size_t len = patterns.numel ();
 
       for (size_t i = 0; i < len; i++)
         {
-          std::list<symbol_record> tmp = m_current_scope->regexp (patterns[i]);
+          std::list<symbol_record> tmp = m_current_scope.regexp (patterns[i]);
 
           retval.insert (retval.begin (), tmp.begin (), tmp.end ());
         }
 
       return retval;
     }
 
     std::list<std::string> user_function_names (void)
@@ -576,29 +570,29 @@ namespace octave
       if (! retval.empty ())
         retval.sort ();
 
       return retval;
     }
 
     std::list<std::string> global_variable_names (void)
     {
-      return m_global_scope->variable_names ();
+      return m_global_scope.variable_names ();
     }
 
     std::list<std::string> top_level_variable_names (void)
     {
       return (m_top_scope
-              ? m_top_scope->variable_names () : std::list<std::string> ());
+              ? m_top_scope.variable_names () : std::list<std::string> ());
     }
 
     std::list<std::string> variable_names (void)
     {
       return (m_current_scope
-              ? m_current_scope->variable_names () : std::list<std::string> ());
+              ? m_current_scope.variable_names () : std::list<std::string> ());
     }
 
     std::list<std::string> built_in_function_names (void)
     {
       std::list<std::string> retval;
 
       for (const auto& nm_finfo : m_fcn_table)
         {
@@ -662,17 +656,17 @@ namespace octave
             retval.insert (retval.end (), parents.begin (), parents.end ());
         }
 
       return retval;
     }
 
     octave_user_function * get_curr_fcn (void)
     {
-      return m_current_scope ? m_current_scope->function () : nullptr;
+      return m_current_scope ? m_current_scope.function () : nullptr;
     }
 
     void cleanup (void);
 
     fcn_info * get_fcn_info (const std::string& name)
     {
       fcn_table_iterator p = m_fcn_table.find (name);
       return p != m_fcn_table.end () ? &p->second : nullptr;
@@ -708,20 +702,20 @@ namespace octave
     // Map from class names to parent class names.
     std::map<std::string, std::list<std::string>> m_parent_map;
 
     typedef std::map<std::string, std::list<std::string>>::const_iterator
       const_parent_map_iterator;
     typedef std::map<std::string, std::list<std::string>>::iterator
       parent_map_iterator;
 
-    symbol_scope *m_global_scope;
-    symbol_scope *m_top_scope;
+    symbol_scope m_global_scope;
+    symbol_scope m_top_scope;
 
-    symbol_scope *m_current_scope;
+    symbol_scope m_current_scope;
 
     octave_value dump_fcn_table_map (void) const;
   };
 
   extern bool out_of_date_check (octave_value& function,
                                  const std::string& dispatch_type = "",
                                  bool check_relative = true);
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -199,19 +199,19 @@ get_struct_elts (const std::string& text
 
 static inline bool
 is_variable (octave::symbol_table& symtab, const std::string& name)
 {
   bool retval = false;
 
   if (! name.empty ())
     {
-      octave::symbol_scope *scope = symtab.current_scope ();
-
-      octave_value val = scope ? scope->varval (name) : octave_value ();
+      octave::symbol_scope scope = symtab.current_scope ();
+
+      octave_value val = scope ? scope.varval (name) : octave_value ();
 
       retval = val.is_defined ();
     }
 
   return retval;
 }
 
 string_vector
@@ -323,21 +323,21 @@ static octave_value
 do_isglobal (octave::symbol_table& symtab, const octave_value_list& args)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     error ("isglobal: NAME must be a string");
 
-  octave::symbol_scope *scope = symtab.current_scope ();
+  octave::symbol_scope scope = symtab.current_scope ();
 
   std::string name = args(0).string_value ();
 
-  return scope && scope->is_global (name);
+  return scope && scope.is_global (name);
 }
 
 DEFMETHOD (isglobal, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {} isglobal (@var{name})
 Return true if @var{name} is a globally visible variable.
 
 For example:
@@ -384,19 +384,19 @@ symbol_exist (octave::interpreter& inter
   if (! (search_any || search_var || search_dir || search_file ||
          search_builtin || search_class))
     error (R"(exist: unrecognized type argument "%s")", type.c_str ());
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (search_any || search_var)
     {
-      octave::symbol_scope *scope = symtab.current_scope ();
-
-      octave_value val = scope ? scope->varval (name) : octave_value ();
+      octave::symbol_scope scope = symtab.current_scope ();
+
+      octave_value val = scope ? scope.varval (name) : octave_value ();
 
       if (val.is_constant () || val.isobject ()
           || val.is_function_handle ()
           || val.is_anonymous_function ()
           || val.is_inline_function ())
         return 1;
 
       if (search_var)
@@ -1651,19 +1651,19 @@ do_who (octave::interpreter& interp, int
           std::string nm = argv[i + 1];
 
           octave::unwind_protect frame;
 
           // Set up temporary scope.
 
           octave::symbol_scope tmp_scope;
 
-          symtab.set_scope (&tmp_scope);
-
-          cs.push (&tmp_scope, 0);
+          symtab.set_scope (tmp_scope);
+
+          cs.push (tmp_scope, 0);
           frame.add_method (cs, &octave::call_stack::pop);
 
           octave::feval ("load", octave_value (nm), 0);
 
           std::string newmsg = "Variables in the file " + nm + ":\n\n";
 
           retval = do_who (interp, i, argv, return_list, verbose, newmsg);
 
@@ -1692,19 +1692,19 @@ do_who (octave::interpreter& interp, int
     {
       pats.resize (++npats);
       pats[0] = "*";
     }
 
   symbol_info_list symbol_stats;
   std::list<std::string> symbol_names;
 
-  octave::symbol_scope *scope = symtab.current_scope ();
-
-  octave::symbol_record::context_id context = scope->current_context ();
+  octave::symbol_scope scope = symtab.current_scope ();
+
+  octave::symbol_record::context_id context = scope.current_context ();
 
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
         {
           std::list<octave::symbol_record> tmp
@@ -1735,17 +1735,17 @@ do_who (octave::interpreter& interp, int
                   // expressions based on global values if the variable is
                   // global in the current scope because we currently have
                   // no way of looking up the base value in the global
                   // scope and then evaluating the arguments in the
                   // current scope.
 
                   std::string base_name = pat.substr (0, pos);
 
-                  if (scope && scope->is_variable (base_name))
+                  if (scope && scope.is_variable (base_name))
                     {
                       octave::symbol_record sr
                         = symtab.find_symbol (base_name);
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
@@ -2101,32 +2101,32 @@ do_clear_functions (octave::symbol_table
     }
 }
 
 static void
 do_clear_globals (octave::symbol_table& symtab,
                   const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
-  octave::symbol_scope *scope = symtab.current_scope ();
+  octave::symbol_scope scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   if (idx == argc)
     {
       string_vector gvars = symtab.global_variable_names ();
 
       int gcount = gvars.numel ();
 
       for (int i = 0; i < gcount; i++)
         {
           std::string name = gvars[i];
 
-          scope->clear_variable (name);
+          scope.clear_variable (name);
           symtab.clear_global (name);
         }
     }
   else
     {
       if (exclusive)
         {
           string_vector gvars = symtab.global_variable_names ();
@@ -2134,85 +2134,85 @@ do_clear_globals (octave::symbol_table& 
           int gcount = gvars.numel ();
 
           for (int i = 0; i < gcount; i++)
             {
               std::string name = gvars[i];
 
               if (! name_matches_any_pattern (name, argv, argc, idx))
                 {
-                  scope->clear_variable (name);
+                  scope.clear_variable (name);
                   symtab.clear_global (name);
                 }
             }
         }
       else
         {
           while (idx < argc)
             {
               std::string pattern = argv[idx++];
 
-              scope->clear_variable_pattern (pattern);
+              scope.clear_variable_pattern (pattern);
               symtab.clear_global_pattern (pattern);
             }
         }
     }
 }
 
 static void
 do_clear_variables (octave::symbol_table& symtab,
                     const string_vector& argv, int argc, int idx,
                     bool exclusive = false, bool have_regexp = false)
 {
-  octave::symbol_scope *scope = symtab.current_scope ();
+  octave::symbol_scope scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   if (idx == argc)
-    scope->clear_variables ();
+    scope.clear_variables ();
   else
     {
       if (exclusive)
         {
-          string_vector lvars = scope->variable_names ();
+          string_vector lvars = scope.variable_names ();
 
           int lcount = lvars.numel ();
 
           for (int i = 0; i < lcount; i++)
             {
               std::string nm = lvars[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx, have_regexp))
-                scope->clear_variable (nm);
+                scope.clear_variable (nm);
             }
         }
       else
         {
           if (have_regexp)
             while (idx < argc)
-              scope->clear_variable_regexp (argv[idx++]);
+              scope.clear_variable_regexp (argv[idx++]);
           else
             while (idx < argc)
-              scope->clear_variable_pattern (argv[idx++]);
+              scope.clear_variable_pattern (argv[idx++]);
         }
     }
 }
 
 static void
 do_clear_symbols (octave::symbol_table& symtab,
                   const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
   if (idx == argc)
     {
-      octave::symbol_scope *scope = symtab.current_scope ();
+      octave::symbol_scope scope = symtab.current_scope ();
 
       if (scope)
-        scope->clear_variables ();
+        scope.clear_variables ();
     }
   else
     {
       if (exclusive)
         {
           // FIXME: is this really what we want, or do we
           // somehow want to only clear the functions that are not
           // shadowed by local variables?  It seems that would be a
@@ -2230,47 +2230,47 @@ do_clear_symbols (octave::symbol_table& 
 }
 
 static void
 do_matlab_compatible_clear (octave::symbol_table& symtab,
                             const string_vector& argv, int argc, int idx)
 {
   // This is supposed to be mostly Matlab compatible.
 
-  octave::symbol_scope *scope = symtab.current_scope ();
+  octave::symbol_scope scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   for (; idx < argc; idx++)
     {
       if (argv[idx] == "all"
-          && ! scope->is_local_variable ("all"))
+          && ! scope.is_local_variable ("all"))
         {
           symtab.clear_all ();
         }
       else if (argv[idx] == "functions"
-               && ! scope->is_local_variable ("functions"))
+               && ! scope.is_local_variable ("functions"))
         {
           do_clear_functions (symtab, argv, argc, ++idx);
         }
       else if (argv[idx] == "global"
-               && ! scope->is_local_variable ("global"))
+               && ! scope.is_local_variable ("global"))
         {
           do_clear_globals (symtab, argv, argc, ++idx);
         }
       else if (argv[idx] == "variables"
-               && ! scope->is_local_variable ("variables"))
+               && ! scope.is_local_variable ("variables"))
         {
-          scope->clear_variables ();
+          scope.clear_variables ();
         }
       else if (argv[idx] == "classes"
-               && ! scope->is_local_variable ("classes"))
+               && ! scope.is_local_variable ("classes"))
         {
-          scope->clear_objects ();
+          scope.clear_objects ();
           octave_class::clear_exemplar_map ();
           symtab.clear_all ();
         }
       else
         {
           symtab.clear_symbol_pattern (argv[idx]);
         }
     }
@@ -2379,17 +2379,17 @@ without the dash as well.
       bool clear_functions = false;
       bool clear_globals = false;
       bool clear_variables = false;
       bool clear_objects = false;
       bool exclusive = false;
       bool have_regexp = false;
       bool have_dash_option = false;
 
-      octave::symbol_scope *scope = symtab.current_scope ();
+      octave::symbol_scope scope = symtab.current_scope ();
 
       while (++idx < argc)
         {
           if (argv[idx] == "-all" || argv[idx] == "-a")
             {
               CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
               have_dash_option = true;
@@ -2468,17 +2468,17 @@ without the dash as well.
                 }
               else if (clear_variables)
                 {
                   do_clear_variables (symtab, argv, argc, idx, exclusive);
                 }
               else if (clear_objects)
                 {
                   if (scope)
-                    scope->clear_objects ();
+                    scope.clear_objects ();
                   octave_class::clear_exemplar_map ();
                   symtab.clear_all ();
                 }
               else
                 {
                   do_clear_symbols (symtab, argv, argc, idx, exclusive);
                 }
             }
@@ -2619,19 +2619,19 @@ DEFMETHOD (__varval__, interp, args, ,
 Return the value of the variable @var{name} directly from the symbol table.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__varval__: first argument must be a variable name");
 
-  octave::symbol_scope *scope = interp.get_current_scope ();
-
-  return scope ? scope->varval (args(0).string_value ()) : octave_value ();
+  octave::symbol_scope scope = interp.get_current_scope ();
+
+  return scope ? scope.varval (args(0).string_value ()) : octave_value ();
 }
 
 static std::string Vmissing_component_hook;
 
 DEFUN (missing_component_hook, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} missing_component_hook ()
 @deftypefnx {} {@var{old_val} =} missing_component_hook (@var{new_val})
@@ -2710,38 +2710,38 @@ clear_function (const std::string& nm)
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_function");
 
   symtab.clear_function (nm);
 }
 
 void
 clear_variable (const std::string& nm)
 {
-  octave::symbol_scope *scope
+  octave::symbol_scope scope
     = octave::__get_current_scope__ ("clear_variable");
 
   if (scope)
-    scope->clear_variable (nm);
+    scope.clear_variable (nm);
 }
 
 void
 clear_symbol (const std::string& nm)
 {
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_symbol");
 
   symtab.clear_symbol (nm);
 }
 
 octave_value
 lookup_function_handle (const std::string& nm)
 {
-  octave::symbol_scope *scope
+  octave::symbol_scope scope
     = octave::__get_current_scope__ ("lookup_function_handle");
 
-  octave_value val = scope ? scope->varval (nm) : octave_value ();
+  octave_value val = scope ? scope.varval (nm) : octave_value ();
 
   return val.is_function_handle () ? val : octave_value ();
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("get_global_value");
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1108,20 +1108,20 @@ public:
         if (! is_direct_superclass (cls, ctx))
           error ("`%s' is not a direct superclass of `%s'",
                  cname.c_str (), ctx.get_name ().c_str ());
 
         if (! is_constructed_object (mname))
           error ("cannot call superclass constructor with variable `%s'",
                  mname.c_str ());
 
-        octave::symbol_scope *scope
+        octave::symbol_scope scope
           = octave::__require_current_scope__ ("octave_classdef_superclass_ref::call");
 
-        octave_value sym = scope->varval (mname);
+        octave_value sym = scope.varval (mname);
 
         cls.run_constructor (to_cdef_ref (sym), idx);
 
         retval(0) = sym;
       }
     else
       {
         if (mname != meth_name)
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -82,20 +82,20 @@ const std::string octave_fcn_handle::ano
 octave_fcn_handle::octave_fcn_handle (const octave_value& f,
                                       const std::string& n)
   : fcn (f), nm (n), has_overloads (false)
 {
   octave_user_function *uf = fcn.user_function_value (true);
 
   if (uf && nm != anonymous)
     {
-      octave::symbol_scope *uf_scope = uf->scope ();
+      octave::symbol_scope uf_scope = uf->scope ();
 
       if (uf_scope)
-        uf_scope->cache_name (nm);
+        uf_scope.cache_name (nm);
     }
 
   if (uf && uf->is_nested_function () && ! uf->is_subfunction ())
     error ("handles to nested functions are not yet supported");
 }
 
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
@@ -348,22 +348,22 @@ octave_fcn_handle::save_ascii (std::ostr
       os << "\n";
 
       if (fcn.is_undefined ())
         return false;
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      octave::symbol_scope *f_scope = f->scope ();
       octave::symbol_record::context_id context = 0;
+      octave::symbol_scope f_scope = f->scope ();
       if (f_scope)
         {
-          vars = f_scope->all_variables ();
-          context = f_scope->current_context ();
+          vars = f_scope.all_variables ();
+          context = f_scope.current_context ();
         }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
 
@@ -406,20 +406,20 @@ octave_fcn_handle::parse_anon_fcn_handle
       if (fh)
         {
           fcn = fh->fcn;
 
           octave_user_function *uf = fcn.user_function_value (true);
 
           if (uf)
             {
-              octave::symbol_scope *uf_scope = uf->scope ();
+              octave::symbol_scope uf_scope = uf->scope ();
 
               if (uf_scope)
-                uf_scope->cache_name (nm);
+                uf_scope.cache_name (nm);
             }
         }
       else
         success = false;
     }
   else
     success = false;
 
@@ -470,22 +470,22 @@ octave_fcn_handle::load_ascii (std::istr
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_ascii");
 
       octave::symbol_scope local_scope (buf);
 
-      symtab.set_scope (&local_scope);
+      symtab.set_scope (local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_ascii");
 
-      cs.push (&local_scope, 0);
+      cs.push (local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       octave_idx_type len = 0;
 
       if (extract_keyword (is, "length", len, true) && len >= 0)
         {
           if (len > 0)
             {
@@ -529,22 +529,22 @@ octave_fcn_handle::save_binary (std::ost
       std::ostringstream nmbuf;
 
       if (fcn.is_undefined ())
         return false;
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      octave::symbol_scope *f_scope = f->scope ();
+      octave::symbol_scope f_scope = f->scope ();
       octave::symbol_record::context_id context = 0;
       if (f_scope)
         {
-          vars = f_scope->all_variables ();
-          context = f_scope->current_context ();
+          vars = f_scope.all_variables ();
+          context = f_scope.current_context ();
         }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << ' ' << varlen;
       else
         nmbuf << nm;
@@ -640,22 +640,22 @@ octave_fcn_handle::load_binary (std::ist
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_binary");
 
       octave::symbol_scope local_scope (ctmp2);
 
-      symtab.set_scope (&local_scope);
+      symtab.set_scope (local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_binary");
 
-      cs.push (&local_scope, 0);
+      cs.push (local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       if (len > 0)
         {
           for (octave_idx_type i = 0; i < len; i++)
             {
               octave_value t2;
               bool dummy;
@@ -789,22 +789,22 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           return false;
         }
 
       H5Dclose (data_hid);
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      octave::symbol_scope *f_scope = f->scope ();
+      octave::symbol_scope f_scope = f->scope ();
       octave::symbol_record::context_id context = 0;
       if (f_scope)
         {
-          vars = f_scope->all_variables ();
-          context = f_scope->current_context ();
+          vars = f_scope.all_variables ();
+          context = f_scope.current_context ();
         }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
 
@@ -1146,22 +1146,22 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
 
       octave::symbol_scope local_scope (fcn_tmp);
 
-      symtab.set_scope (&local_scope);
+      symtab.set_scope (local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_hdf5");
 
-      cs.push (&local_scope, 0);
+      cs.push (local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       if (len > 0 && success)
         {
           hsize_t num_obj = 0;
 #if defined (HAVE_HDF5_18)
           data_hid = H5Gopen (group_hid, "symbol table", octave_H5P_DEFAULT);
 #else
@@ -1766,22 +1766,22 @@ particular output format.
 
   if (fh_nm == octave_fcn_handle::anonymous)
     {
       m.setfield ("file", nm);
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *fu = fh->user_function_value ();
-      octave::symbol_scope *fu_scope = fu->scope ();
+      octave::symbol_scope fu_scope = fu->scope ();
       octave::symbol_record::context_id context = 0;
       if (fu_scope)
         {
-          vars = fu_scope->all_variables ();
-          context = fu_scope->current_context ();
+          vars = fu_scope.all_variables ();
+          context = fu_scope.current_context ();
         }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
           for (const auto& symrec : vars)
@@ -1992,20 +1992,20 @@ octave_fcn_binder::maybe_binder (const o
                   octave::tree_identifier *id = (elt ? elt->ident () : nullptr);
                   if (id && ! id->is_black_hole ())
                     arginmap[id->name ()] = npar;
                 }
             }
 
           if (arg_list && arg_list->length () > 0)
             {
-              octave::symbol_scope *scope = tw->get_current_scope ();
+              octave::symbol_scope scope = tw->get_current_scope ();
 
               octave::symbol_record::context_id context
-                = scope->current_context ();
+                = scope.current_context ();
 
               bool bad = false;
               int nargs = arg_list->length ();
               octave_value_list arg_template (nargs);
               std::vector<int> arg_mask (nargs);
 
               // Verify that each argument is either a named param, a constant,
               // or a defined identifier.
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -99,17 +99,17 @@ octave_fcn_inline::octave_fcn_inline (co
             {
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("octave_fcn_inline");
 
               octave_function *curr_fcn = cs.current ();
 
               if (curr_fcn)
                 {
-                  octave::symbol_scope *parent_scope
+                  octave::symbol_scope parent_scope
                     = curr_fcn->parent_fcn_scope ();
 
                   if (! parent_scope)
                     parent_scope = curr_fcn->scope ();
 
                   uf->stash_parent_fcn_scope (parent_scope);
                 }
             }
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -75,22 +75,22 @@ public:
 
   virtual std::string src_file_name (void) const { return ""; }
 
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return ""; }
 
-  virtual octave::symbol_scope * parent_fcn_scope (void) const
-  { return nullptr; }
+  virtual octave::symbol_scope parent_fcn_scope (void) const
+  { return octave::symbol_scope (); }
 
   virtual void mark_fcn_file_up_to_date (const octave::sys::time&) { }
 
-  virtual octave::symbol_scope * scope (void) { return nullptr; }
+  virtual octave::symbol_scope scope (void) { return octave::symbol_scope (); }
 
   virtual octave::sys::time time_parsed (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual octave::sys::time time_checked (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -59,17 +59,16 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 #include "ov-fcn-handle.h"
 
 // Whether to optimize subsasgn method calls.
 static bool Voptimize_subsasgn_calls = true;
 
 octave_user_code::~octave_user_code (void)
 {
-  delete m_scope;
   delete m_file_info;
 }
 
 void
 octave_user_code::get_file_info (void)
 {
   std::string file_name = fcn_file_name ();
 
@@ -129,30 +128,30 @@ octave_user_script::octave_user_script (
   : octave_user_code (), cmd_list (nullptr), file_name (),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::octave_user_script
   (const std::string& fnm, const std::string& nm,
-   octave::symbol_scope *scope, octave::tree_statement_list *cmds,
+   const octave::symbol_scope& scope, octave::tree_statement_list *cmds,
    const std::string& ds)
   : octave_user_code (nm, scope, ds), cmd_list (cmds), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 {
   if (cmd_list)
     cmd_list->mark_as_script_body ();
 }
 
 octave_user_script::octave_user_script
   (const std::string& fnm, const std::string& nm,
-   octave::symbol_scope *scope, const std::string& ds)
+   const octave::symbol_scope& scope, const std::string& ds)
   : octave_user_code (nm, scope, ds), cmd_list (nullptr), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::~octave_user_script (void)
 {
@@ -202,17 +201,17 @@ octave_user_script::call (octave::tree_e
       octave::tree_evaluator::statement_context = octave::tree_evaluator::script;
 
       octave::profiler& profiler = tw.get_profiler ();
 
       octave::profiler::enter<octave_user_script> block (profiler, *this);
 
       frame.add_method (m_scope,
                         &octave::symbol_scope::unbind_script_symbols);
-      m_scope->bind_script_symbols (tw.get_current_scope ());
+      m_scope.bind_script_symbols (tw.get_current_scope ());
 
       if (tw.echo ())
         tw.push_echo_state (frame, octave::tree_evaluator::ECHO_SCRIPTS,
                             file_name);
 
       cmd_list->accept (tw);
 
       if (octave::tree_return_command::returning)
@@ -236,39 +235,39 @@ octave_user_script::accept (octave::tree
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
                                      "user-defined function",
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
-  (octave::symbol_scope *scope, octave::tree_parameter_list *pl,
+  (const octave::symbol_scope& scope, octave::tree_parameter_list *pl,
    octave::tree_parameter_list *rl, octave::tree_statement_list *cl)
   : octave_user_code ("", scope, ""),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
     anonymous_function (false), nested_function (false),
     class_constructor (none), class_method (false),
-    parent_scope (nullptr)
+    parent_scope ()
 #if defined (HAVE_LLVM)
     , jit_info (0)
 #endif
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
 
   if (m_scope)
-    m_scope->set_function (this);
+    m_scope.set_function (this);
 }
 
 octave_user_function::~octave_user_function (void)
 {
   // FIXME: shouldn't this happen automatically when deleting cmd_list?
   if (cmd_list)
     cmd_list->remove_all_breakpoints (file_name);
 
@@ -356,17 +355,17 @@ octave_user_function::maybe_relocate_end
             f->maybe_relocate_end_internal ();
         }
     }
 
   maybe_relocate_end_internal ();
 }
 
 void
-octave_user_function::stash_parent_fcn_scope (octave::symbol_scope *ps)
+octave_user_function::stash_parent_fcn_scope (const octave::symbol_scope& ps)
 {
   parent_scope = ps;
 }
 
 std::string
 octave_user_function::profiler_name (void) const
 {
   std::ostringstream result;
@@ -411,17 +410,17 @@ octave_user_function::mark_as_system_fcn
     }
   else
     system_fcn_file = false;
 }
 
 void
 octave_user_function::erase_subfunctions (void)
 {
-  m_scope->erase_subfunctions ();
+  m_scope.erase_subfunctions ();
 }
 
 bool
 octave_user_function::takes_varargs (void) const
 {
   return (param_list && param_list->takes_varargs ());
 }
 
@@ -429,55 +428,55 @@ bool
 octave_user_function::takes_var_return (void) const
 {
   return (ret_list && ret_list->takes_varargs ());
 }
 
 void
 octave_user_function::mark_as_private_function (const std::string& cname)
 {
-  m_scope->mark_subfunctions_in_scope_as_private (cname);
+  m_scope.mark_subfunctions_in_scope_as_private (cname);
 
   octave_function::mark_as_private_function (cname);
 }
 
 void
 octave_user_function::lock_subfunctions (void)
 {
-  m_scope->lock_subfunctions ();
+  m_scope.lock_subfunctions ();
 }
 
 void
 octave_user_function::unlock_subfunctions (void)
 {
-  m_scope->unlock_subfunctions ();
+  m_scope.unlock_subfunctions ();
 }
 
 std::map<std::string, octave_value>
 octave_user_function::subfunctions (void) const
 {
-  return m_scope->subfunctions ();
+  return m_scope.subfunctions ();
 }
 
 bool
 octave_user_function::has_subfunctions (void) const
 {
-  return m_scope->has_subfunctions ();
+  return m_scope.has_subfunctions ();
 }
 
 void
 octave_user_function::stash_subfunction_names (const std::list<std::string>& names)
 {
-  m_scope->stash_subfunction_names (names);
+  m_scope.stash_subfunction_names (names);
 }
 
 std::list<std::string>
 octave_user_function::subfunction_names (void) const
 {
-  return m_scope->subfunction_names ();
+  return m_scope.subfunction_names ();
 }
 
 octave_value_list
 octave_user_function::all_va_args (const octave_value_list& args)
 {
   octave_value_list retval;
 
   octave_idx_type n = args.length () - num_named_args;
@@ -544,34 +543,34 @@ octave_user_function::call (octave::tree
   curr_unwind_protect_frame = &frame;
 
   frame.protect_var (Vtrack_line_num);
   Vtrack_line_num = true;    // update source line numbers, even if debugging
   frame.add_method (cs, &octave::call_stack::pop);
 
   if (call_depth > 0 && ! is_anonymous_function ())
     {
-      m_scope->push_context ();
+      m_scope.push_context ();
 
 #if 0
       std::cerr << name () << " scope: " << m_scope
                 << " call depth: " << call_depth
-                << " context: " << m_scope->current_context () << std::endl;
+                << " context: " << m_scope.current_context () << std::endl;
 #endif
 
       frame.add_method (m_scope, &octave::symbol_scope::pop_context);
     }
 
   string_vector arg_names = _args.name_tags ();
 
   if (param_list && ! param_list->varargs_only ())
     {
 #if 0
       std::cerr << "defining param list, scope: " << m_scope
-                << ", context: " << m_scope->current_context () << std::endl;
+                << ", context: " << m_scope.current_context () << std::endl;
 #endif
       tw.define_parameter_list_from_arg_vector (param_list, args);
     }
 
   // For classdef constructor, pre-populate the output arguments
   // with the pre-initialized object instance, extracted above.
 
   if (is_classdef_constructor ())
@@ -661,17 +660,17 @@ octave_user_function::call (octave::tree
   // Copy return values out.
 
   if (ret_list && ! is_special_expr ())
     {
       Cell varargout;
 
       if (ret_list->takes_varargs ())
         {
-          octave_value varargout_varval = m_scope->varval ("varargout");
+          octave_value varargout_varval = m_scope.varval ("varargout");
 
           if (varargout_varval.is_defined ())
             varargout = varargout_varval.xcell_value ("varargout must be a cell array object");
         }
 
       retval = tw.convert_return_list_to_const_vector (ret_list, nargout, varargout);
     }
 
@@ -754,18 +753,18 @@ octave_user_function::dump (void) const
        { "call_depth", call_depth },
        { "num_named_args", num_named_args },
        { "subfunction", subfunction },
        { "inline_function", inline_function },
        { "anonymous_function", anonymous_function },
        { "nested_function", nested_function },
        { "ctor_type", ctor_type_str () },
        { "class_method", class_method },
-       { "parent_scope", parent_scope ? parent_scope->name () : "0x0" },
-       { "scope_info", m_scope ? m_scope->dump () : "0x0" }};
+       { "parent_scope", parent_scope ? parent_scope.name () : "0x0" },
+       { "scope_info", m_scope ? m_scope.dump () : "0x0" }};
 
   return octave_value (m);
 }
 
 void
 octave_user_function::print_code_function_header (const std::string& prefix)
 {
   octave::tree_print_code tpc (octave_stdout, prefix);
@@ -789,54 +788,54 @@ octave_user_function::bind_automatic_var
   if (! arg_names.empty ())
     {
       // It is better to save this in the hidden variable .argn. and
       // then use that in the inputname function instead of using argn,
       // which might be redefined in a function.  Keep the old argn name
       // for backward compatibility of functions that use it directly.
 
       charMatrix chm (arg_names, tw.string_fill_char ());
-      m_scope->force_assign ("argn", chm);
-      m_scope->force_assign (".argn.", Cell (arg_names));
+      m_scope.force_assign ("argn", chm);
+      m_scope.force_assign (".argn.", Cell (arg_names));
 
-      m_scope->mark_hidden (".argn.");
+      m_scope.mark_hidden (".argn.");
 
-      m_scope->mark_automatic ("argn");
-      m_scope->mark_automatic (".argn.");
+      m_scope.mark_automatic ("argn");
+      m_scope.mark_automatic (".argn.");
     }
 
-  m_scope->force_assign (".nargin.", nargin);
-  m_scope->force_assign (".nargout.", nargout);
+  m_scope.force_assign (".nargin.", nargin);
+  m_scope.force_assign (".nargout.", nargout);
 
-  m_scope->mark_hidden (".nargin.");
-  m_scope->mark_hidden (".nargout.");
+  m_scope.mark_hidden (".nargin.");
+  m_scope.mark_hidden (".nargout.");
 
-  m_scope->mark_automatic (".nargin.");
-  m_scope->mark_automatic (".nargout.");
+  m_scope.mark_automatic (".nargin.");
+  m_scope.mark_automatic (".nargout.");
 
-  m_scope->force_assign (".saved_warning_states.", octave_value ());
+  m_scope.force_assign (".saved_warning_states.", octave_value ());
 
-  m_scope->mark_automatic (".saved_warning_states.");
-  m_scope->mark_automatic (".saved_warning_states.");
+  m_scope.mark_automatic (".saved_warning_states.");
+  m_scope.mark_automatic (".saved_warning_states.");
 
   if (takes_varargs ())
-    m_scope->assign ("varargin", va_args.cell_value ());
+    m_scope.assign ("varargin", va_args.cell_value ());
 
   Matrix ignored_fcn_outputs = tw.ignored_fcn_outputs ();
 
-  m_scope->force_assign (".ignored.", ignored_fcn_outputs);
+  m_scope.force_assign (".ignored.", ignored_fcn_outputs);
 
-  m_scope->mark_hidden (".ignored.");
-  m_scope->mark_automatic (".ignored.");
+  m_scope.mark_hidden (".ignored.");
+  m_scope.mark_automatic (".ignored.");
 }
 
 void
 octave_user_function::restore_warning_states (void)
 {
-  octave_value val = m_scope->varval (".saved_warning_states.");
+  octave_value val = m_scope.varval (".saved_warning_states.");
 
   if (val.is_defined ())
     {
       // Fail spectacularly if .saved_warning_states. is not an
       // octave_map (or octave_scalar_map) object.
 
       if (! val.isstruct ())
         panic_impossible ();
@@ -927,18 +926,18 @@ Programming Note: @code{nargin} does not
       octave::tree_parameter_list *param_list = fcn->parameter_list ();
 
       retval = (param_list ? param_list->length () : 0);
       if (fcn->takes_varargs ())
         retval = -1 - retval;
     }
   else
     {
-      octave::symbol_scope *scope = symtab.require_current_scope ("nargin");
-      retval = scope->varval (".nargin.");
+      octave::symbol_scope scope = symtab.require_current_scope ("nargin");
+      retval = scope.varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
 
@@ -1053,18 +1052,18 @@ returns -1 for all anonymous functions.
       if (fcn->takes_var_return ())
         retval = -1 - retval;
     }
   else
     {
       if (symtab.at_top_level ())
         error ("nargout: invalid call at top level");
 
-      octave::symbol_scope *scope = symtab.require_current_scope ("nargout");
-      retval = scope->varval (".nargout.");
+      octave::symbol_scope scope = symtab.require_current_scope ("nargout");
+      retval = scope.varval (".nargout.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
 
@@ -1126,22 +1125,22 @@ element-by-element and a logical array i
   if (args.length () != 1)
     print_usage ();
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (symtab.at_top_level ())
     error ("isargout: invalid call at top level");
 
-  octave::symbol_scope *scope = symtab.require_current_scope ("isargout");
+  octave::symbol_scope scope = symtab.require_current_scope ("isargout");
 
-  int nargout1 = scope->varval (".nargout.").int_value ();
+  int nargout1 = scope.varval (".nargout.").int_value ();
 
   Matrix ignored;
-  octave_value tmp = scope->varval (".ignored.");
+  octave_value tmp = scope.varval (".ignored.");
   if (tmp.is_defined ())
     ignored = tmp.matrix_value ();
 
   if (args(0).is_scalar_type ())
     {
       double k = args(0).double_value ();
 
       return ovl (isargout1 (nargout1, ignored, k));
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -56,26 +56,26 @@ namespace octave
 }
 
 class
 octave_user_code : public octave_function
 {
 protected:
 
   octave_user_code (const std::string& nm,
-                    octave::symbol_scope *scope = nullptr,
+                    const octave::symbol_scope& scope = octave::symbol_scope (),
                     const std::string& ds = "")
     : octave_function (nm, ds), m_scope (scope), m_file_info (nullptr),
       curr_unwind_protect_frame (nullptr)
   { }
 
 public:
 
   octave_user_code (void)
-    : octave_function (), m_scope (nullptr), m_file_info (nullptr),
+    : octave_function (), m_scope (), m_file_info (nullptr),
       curr_unwind_protect_frame (nullptr)
   { }
 
   // No copying!
 
   octave_user_code (const octave_user_code& f) = delete;
 
   octave_user_code& operator = (const octave_user_code& f) = delete;
@@ -92,28 +92,28 @@ public:
 
   std::string get_code_line (size_t line);
 
   std::deque<std::string> get_code_lines (size_t line, size_t num_lines);
 
   void cache_function_text (const std::string& text,
                             const octave::sys::time& timestamp);
 
-  octave::symbol_scope *scope (void) { return m_scope; }
+  octave::symbol_scope scope (void) { return m_scope; }
 
   virtual std::map<std::string, octave_value> subfunctions (void) const;
 
   virtual octave::tree_statement_list * body (void) = 0;
 
 protected:
 
   void get_file_info (void);
 
   // Our symbol table scope.
-  octave::symbol_scope *m_scope;
+  octave::symbol_scope m_scope;
 
   // Cached text of function or script code with line offsets
   // calculated.
   octave::file_info *m_file_info;
 
   // pointer to the current unwind_protect frame of this function.
   octave::unwind_protect *curr_unwind_protect_frame;
 };
@@ -123,22 +123,22 @@ protected:
 class
 octave_user_script : public octave_user_code
 {
 public:
 
   octave_user_script (void);
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-                      octave::symbol_scope *scope = nullptr,
+                      const octave::symbol_scope& scope = octave::symbol_scope (),
                       octave::tree_statement_list *cmds = nullptr,
                       const std::string& ds = "");
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-                      octave::symbol_scope *scope = nullptr,
+                      const octave::symbol_scope& scope = octave::symbol_scope (),
                       const std::string& ds = "");
 
   // No copying!
 
   octave_user_script (const octave_user_script& f) = delete;
 
   octave_user_script& operator = (const octave_user_script& f) = delete;
 
@@ -202,17 +202,17 @@ private:
 
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
-  octave_user_function (octave::symbol_scope *scope = nullptr,
+  octave_user_function (const octave::symbol_scope& scope = octave::symbol_scope (),
                         octave::tree_parameter_list *pl = nullptr,
                         octave::tree_parameter_list *rl = nullptr,
                         octave::tree_statement_list *cl = nullptr);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn) = delete;
 
@@ -255,17 +255,17 @@ public:
 
   int ending_line (void) const { return end_location_line; }
   int ending_column (void) const { return end_location_column; }
 
   void maybe_relocate_end (void);
 
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
-  void stash_parent_fcn_scope (octave::symbol_scope *ps);
+  void stash_parent_fcn_scope (const octave::symbol_scope& ps);
 
   void stash_leading_comment (octave::comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave::comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave::sys::time& t)
@@ -275,17 +275,17 @@ public:
   }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   std::string profiler_name (void) const;
 
   std::string parent_fcn_name (void) const { return parent_name; }
 
-  octave::symbol_scope *
+  octave::symbol_scope
   parent_fcn_scope (void) const { return parent_scope; }
 
   octave::sys::time time_parsed (void) const { return t_parsed; }
 
   octave::sys::time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
@@ -476,17 +476,17 @@ private:
 
   // Enum describing whether this function is the constructor for class object.
   class_ctor_type class_constructor;
 
   // TRUE means this function is a method for a class.
   bool class_method;
 
   // The scope of the parent function, if any.
-  octave::symbol_scope *parent_scope;
+  octave::symbol_scope parent_scope;
 
 #if defined (HAVE_LLVM)
   octave::jit_function_info *jit_info;
 #endif
 
   void maybe_relocate_end_internal (void);
 
   void print_code_function_header (const std::string& prefix);
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -64,27 +64,27 @@ namespace octave
       void clear (void);
 
       bool empty (void) const { return frame_stack.empty (); }
 
       size_t size (void) const { return frame_stack.size (); }
 
       void pop (void);
 
-      void push (symbol_scope *scope)
+      void push (const symbol_scope& scope)
       {
         frame_stack.push_front (scope);
       }
 
-      symbol_scope *curr_scope (void) const;
-      symbol_scope *parent_scope (void) const;
+      symbol_scope curr_scope (void) const;
+      symbol_scope parent_scope (void) const;
 
     private:
 
-      std::deque<symbol_scope*> frame_stack;
+      std::deque<symbol_scope> frame_stack;
     };
 
     // Track nesting of square brackets, curly braces, and parentheses.
 
     class bbp_nesting_level
     {
     private:
 
@@ -597,17 +597,17 @@ namespace octave
     void xunput (char c, char *buf);
 
     void xunput (char c);
 
     bool looking_at_space (void);
 
     bool inside_any_object_index (void);
 
-    bool is_variable (const std::string& name, symbol_scope *scope);
+    bool is_variable (const std::string& name, const symbol_scope& scope);
 
     int is_keyword_token (const std::string& s);
 
     bool fq_identifier_contains_keyword (const std::string& s);
 
     bool whitespace_is_significant (void);
 
     void handle_number (void);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2074,54 +2074,48 @@ debug information as it processes an exp
 }
 
 namespace octave
 {
   void
   lexical_feedback::symbol_table_context::clear (void)
   {
     while (! frame_stack.empty ())
-      {
-        symbol_scope *scope = curr_scope ();
-
-        delete scope;
-
-        frame_stack.pop_front ();
-      }
+      frame_stack.pop_front ();
   }
 
   void
   lexical_feedback::symbol_table_context::pop (void)
   {
     if (empty ())
       panic_impossible ();
 
     frame_stack.pop_front ();
   }
 
-  symbol_scope *
+  symbol_scope
   lexical_feedback::symbol_table_context::curr_scope (void) const
   {
     if (empty ())
       {
-        symbol_scope *scope
+        symbol_scope scope
           = __get_current_scope__ ("lexical_feedback::symbol_table_context::curr_scope");
 
         return scope;
       }
     else
       return frame_stack.front ();
   }
 
-  symbol_scope *
+  symbol_scope
   lexical_feedback::symbol_table_context::parent_scope (void) const
   {
     size_t sz = size ();
 
-    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : nullptr);
+    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : symbol_scope ());
   }
 
   lexical_feedback::~lexical_feedback (void)
   {
     tokens.clear ();
   }
 
   void
@@ -2517,19 +2511,19 @@ namespace octave
           }
       }
 
     return retval;
   }
 
   bool
   base_lexer::is_variable (const std::string& name,
-                           symbol_scope *scope)
+                           const symbol_scope& scope)
   {
-    return ((scope && scope->is_variable (name))
+    return ((scope && scope.is_variable (name))
             || (pending_local_variables.find (name)
                 != pending_local_variables.end ()));
   }
 
   // Handle keywords.  Return -1 if the keyword should be ignored.
 
   int
   base_lexer::is_keyword_token (const std::string& s)
@@ -3151,19 +3145,19 @@ namespace octave
 
         // The call to is_keyword_token set at_beginning_of_statement.
 
         return kw_token;
       }
 
     // Find the token in the symbol table.
 
-    symbol_scope *scope = symtab_context.curr_scope ();
-
-    symbol_record sr = (scope ? scope->insert (ident) : symbol_record (ident));
+    symbol_scope scope = symtab_context.curr_scope ();
+
+    symbol_record sr = (scope ? scope.insert (ident) : symbol_record (ident));
 
     token *tok = new token (NAME, sr, input_line_number, current_input_column);
 
     // The following symbols are handled specially so that things like
     //
     //   pi +1
     //
     // are parsed as an addition expression instead of as a command-style
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -1280,18 +1280,17 @@ push_fcn_symtab : // empty
                     $$ = 0;
 
                     parser.m_curr_fcn_depth++;
 
                     if (parser.m_max_fcn_depth < parser.m_curr_fcn_depth)
                       parser.m_max_fcn_depth = parser.m_curr_fcn_depth;
 
                     // Will get a real name later.
-                    lexer.symtab_context.push (new octave::symbol_scope ("parser:push_fcn_symtab"));
-
+                    lexer.symtab_context.push (octave::symbol_scope ("parser:push_fcn_symtab"));
                     parser.m_function_scopes.push (lexer.symtab_context.curr_scope ());
 
                     if (! lexer.reading_script_file
                         && parser.m_curr_fcn_depth == 1
                         && ! parser.m_parsing_subfunctions)
                       parser.m_primary_fcn_scope
                         = lexer.symtab_context.curr_scope ();
 
@@ -1311,17 +1310,17 @@ push_fcn_symtab : // empty
 param_list_beg  : '('
                   {
                     $$ = 0;
                     lexer.looking_at_parameter_list = true;
 
                     if (lexer.looking_at_function_handle)
                       {
                         // Will get a real name later.
-                        lexer.symtab_context.push (new octave::symbol_scope ("parser:param_lsit_beg"));
+                        lexer.symtab_context.push (octave::symbol_scope ("parser:param_lsit_beg"));
                         lexer.looking_at_function_handle--;
                         lexer.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
@@ -1449,17 +1448,17 @@ parsing_local_fcns
                   { parser.m_parsing_local_functions = true; }
                 ;
 
 push_script_symtab : // empty
                   {
                     $$ = 0;
 
                     // Will get a real name later.
-                    lexer.symtab_context.push (new octave::symbol_scope ("parser:push_script_symtab"));
+                    lexer.symtab_context.push (octave::symbol_scope ("parser:push_script_symtab"));
                   }
                 ;
 
 begin_file      : push_script_symtab INPUT_FILE
                   { $$ = 0; }
                 ;
 
 file            : begin_file opt_nl opt_list END_OF_INPUT
@@ -1470,17 +1469,16 @@ file            : begin_file opt_nl opt_
                       {
                         // Delete the dummy statement_list we created
                         // after parsing the function.  Any function
                         // definitions found in the file have already
                         // been stored in the symbol table or in
                         // base_parser::m_primary_fcn_ptr.
 
                         // Unused symbol table context.
-                        delete lexer.symtab_context.curr_scope ();
                         lexer.symtab_context.pop ();
 
                         delete $3;
                       }
                     else
                       {
                         octave::tree_statement *end_of_script
                           = parser.make_end ("endscript", true,
@@ -1493,17 +1491,16 @@ file            : begin_file opt_nl opt_
                     $$ = nullptr;
                   }
                 | begin_file opt_nl classdef parsing_local_fcns opt_sep opt_fcn_list END_OF_INPUT
                   {
                     YYUSE ($2);
                     YYUSE ($5);
 
                     // Unused symbol table context.
-                    delete lexer.symtab_context.curr_scope ();
                     lexer.symtab_context.pop ();
 
                     parser.finish_classdef_file ($3, $6);
 
                     $$ = nullptr;
                   }
                 ;
 
@@ -1536,19 +1533,19 @@ fcn_name        : identifier
                         parser.bison_error ("duplicate subfunction or nested function name",
                                             $1->line (), $1->column ());
 
                         delete $1;
 
                         YYABORT;
                       }
 
-                    octave::symbol_scope *curr_scope
+                    octave::symbol_scope curr_scope
                       = lexer.symtab_context.curr_scope ();
-                    curr_scope->cache_name (id);
+                    curr_scope.cache_name (id);
 
                     lexer.parsed_function_name.top () = true;
                     lexer.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
@@ -1644,17 +1641,17 @@ classdef_beg    : CLASSDEF
                   {
                     if (! lexer.reading_classdef_file)
                       {
                         parser.bison_error ("classdef must appear inside a file containing only a class definition");
                         YYABORT;
                       }
 
                     // Create invalid parent scope.
-                    lexer.symtab_context.push (nullptr);
+                    lexer.symtab_context.push (octave::symbol_scope ());
                     lexer.parsing_classdef = true;
                     $$ = $1;
                   }
                 ;
 
 classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
                     YYUSE ($6);
@@ -2098,17 +2095,17 @@ namespace octave
 
   void
   base_parser::parent_scope_info::push (const value_type& elt)
   {
     m_info.push_back (elt);
   }
 
   void
-  base_parser::parent_scope_info::push (symbol_scope *scope)
+  base_parser::parent_scope_info::push (const symbol_scope& scope)
   {
     push (value_type (scope, ""));
   }
 
   void
   base_parser::parent_scope_info::pop (void)
   {
     m_info.pop_back ();
@@ -2151,20 +2148,20 @@ namespace octave
       return false;
 
     if (size () > 0)
       m_info.back().second = name;
 
     return true;
   }
 
-  symbol_scope *
+  symbol_scope
   base_parser::parent_scope_info::parent_scope (void) const
   {
-    return size () > 1 ? m_info[size()-2].first : nullptr;
+    return size () > 1 ? m_info[size()-2].first : symbol_scope ();
   }
 
   std::string
   base_parser::parent_scope_info::parent_name (void) const
   {
     return m_info[size()-2].second;
   }
 
@@ -2173,17 +2170,17 @@ namespace octave
     m_info.clear ();
     m_all_names.clear ();
   }
 
   base_parser::base_parser (base_lexer& lxr)
     : m_endfunction_found (false), m_autoloading (false),
       m_fcn_file_from_relative_lookup (false),
       m_parsing_subfunctions (false), m_parsing_local_functions (false),
-      m_max_fcn_depth (0), m_curr_fcn_depth (0), m_primary_fcn_scope (nullptr),
+      m_max_fcn_depth (0), m_curr_fcn_depth (0), m_primary_fcn_scope (),
       m_curr_class_name (), m_curr_package_name (), m_function_scopes (),
       m_primary_fcn_ptr (nullptr), m_subfunction_names (),
       m_classdef_object (nullptr), m_stmt_list (nullptr), m_lexer (lxr),
       m_parser_state (yypstate_new ())
   { }
 
   base_parser::~base_parser (void)
   {
@@ -2207,17 +2204,17 @@ namespace octave
   {
     m_endfunction_found = false;
     m_autoloading = false;
     m_fcn_file_from_relative_lookup = false;
     m_parsing_subfunctions = false;
     m_parsing_local_functions = false;
     m_max_fcn_depth = 0;
     m_curr_fcn_depth = 0;
-    m_primary_fcn_scope = nullptr;
+    m_primary_fcn_scope = symbol_scope ();
     m_curr_class_name = "";
     m_curr_package_name = "";
     m_function_scopes.clear ();
     m_primary_fcn_ptr  = nullptr;
     m_subfunction_names.clear ();
     m_classdef_object = nullptr;
 
     delete m_stmt_list;
@@ -2445,24 +2442,24 @@ namespace octave
   tree_anon_fcn_handle *
   base_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
                                      tree_expression *expr)
   {
     // FIXME: need to get these from the location of the @ symbol.
     int l = m_lexer.input_line_number;
     int c = m_lexer.current_input_column;
 
-    symbol_scope *fcn_scope = m_lexer.symtab_context.curr_scope ();
-    symbol_scope *parent_scope = m_lexer.symtab_context.parent_scope ();
+    symbol_scope fcn_scope = m_lexer.symtab_context.curr_scope ();
+    symbol_scope parent_scope = m_lexer.symtab_context.parent_scope ();
 
     m_lexer.symtab_context.pop ();
 
     expr->set_print_flag (false);
 
-    fcn_scope->mark_static ();
+    fcn_scope.mark_static ();
 
     tree_anon_fcn_handle *retval
       = new tree_anon_fcn_handle (param_list, expr, fcn_scope,
                                   parent_scope, l, c);
 
     std::ostringstream buf;
 
     tree_print_code tpc (buf);
@@ -2475,17 +2472,17 @@ namespace octave
     else if (m_lexer.input_from_terminal ())
       buf << ": *terminal input*";
     else if (m_lexer.input_from_eval_string ())
       buf << ": *eval string*";
     buf << ": line: " << l << " column: " << c;
 
     std::string scope_name = buf.str ();
 
-    fcn_scope->cache_name (scope_name);
+    fcn_scope.cache_name (scope_name);
 
     // FIXME: Stash the filename.  This does not work and produces
     // errors when executed.
     //retval->stash_file_name (m_lexer.fcn_file_name);
 
     return retval;
   }
 
@@ -3264,19 +3261,19 @@ namespace octave
   base_parser::make_script (tree_statement_list *cmds,
                             tree_statement *end_script)
   {
     if (! cmds)
       cmds = new tree_statement_list ();
 
     cmds->append (end_script);
 
-    symbol_scope *script_scope = m_lexer.symtab_context.curr_scope ();
-
-    script_scope->cache_name (m_lexer.fcn_file_full_name);
+    symbol_scope script_scope = m_lexer.symtab_context.curr_scope ();
+
+    script_scope.cache_name (m_lexer.fcn_file_full_name);
 
     octave_user_script *script
       = new octave_user_script (m_lexer.fcn_file_full_name,
                                 m_lexer.fcn_file_name, script_scope,
                                 cmds, m_lexer.help_text);
 
     m_lexer.symtab_context.pop ();
     m_lexer.help_text = "";
@@ -3479,47 +3476,47 @@ namespace octave
       {
         std::string nm = fcn->name ();
         std::string file = fcn->fcn_file_name ();
 
         std::string tmp = nm;
         if (! file.empty ())
           tmp += ": " + file;
 
-        symbol_scope *fcn_scope = fcn->scope ();
-        fcn_scope->cache_name (tmp);
+        symbol_scope fcn_scope = fcn->scope ();
+        fcn_scope.cache_name (tmp);
 
         if (lc)
           fcn->stash_leading_comment (lc);
 
         fcn->define_ret_list (ret_list);
 
         if (m_curr_fcn_depth > 1 || m_parsing_subfunctions)
           {
             fcn->stash_fcn_location (l, c);
 
             octave_value ov_fcn (fcn);
 
             if (m_endfunction_found && m_function_scopes.size () > 1)
               {
-                symbol_scope *pscope = m_function_scopes.parent_scope ();
-
-                pscope->install_nestfunction (nm, ov_fcn);
+                symbol_scope pscope = m_function_scopes.parent_scope ();
+
+                pscope.install_nestfunction (nm, ov_fcn);
               }
             else
               {
                 fcn->mark_as_subfunction ();
                 m_subfunction_names.push_back (nm);
 
-                m_primary_fcn_scope->install_subfunction (nm, ov_fcn);
+                m_primary_fcn_scope.install_subfunction (nm, ov_fcn);
                }
           }
 
         if (m_curr_fcn_depth == 1)
-          fcn_scope->update_nest ();
+          fcn_scope.update_nest ();
 
         if (! m_lexer.reading_fcn_file && m_curr_fcn_depth == 1)
           {
             // We are either reading a script file or defining a function
             // at the command line, so this definition creates a
             // tree_function object that is placed in the parse tree.
             // Otherwise, it is just inserted in the symbol table,
             // either as a subfunction or nested function (see above),
@@ -3809,17 +3806,17 @@ namespace octave
 
         if (mname.find_first_of (".") == std::string::npos
             && mname != "delete"
             && mname != m_curr_class_name)
           {
             // Create a dummy function that is used until the real method
             // is loaded.
 
-            retval = new octave_user_function (nullptr, pl);
+            retval = new octave_user_function (symbol_scope (), pl);
 
             retval->stash_function_name (mname);
 
             int l = id->line ();
             int c = id->column ();
 
             retval->stash_fcn_location (l, c);
           }
@@ -5416,20 +5413,20 @@ namespace octave
 
                     if (silent)
                       expr->set_print_flag (false);
 
                     bool do_bind_ans = false;
 
                     if (expr->is_identifier ())
                       {
-                        octave::symbol_scope *scope = tw.get_current_scope ();
+                        octave::symbol_scope scope = tw.get_current_scope ();
 
                         octave::symbol_record::context_id context
-                          = scope->current_context ();
+                          = scope.current_context ();
 
                         tree_identifier *id
                           = dynamic_cast<tree_identifier *> (expr);
 
                         do_bind_ans = (! id->is_variable (context));
                       }
                     else
                       do_bind_ans = (! expr->is_assignment_expression ());
@@ -5666,20 +5663,20 @@ may be either @qcode{"base"} or @qcode{"
     {
       // Put the check here so that we don't slow down assignments
       // generally.  Any that go through Octave's parser should have
       // already been checked.
 
       if (octave::is_keyword (nm))
         error ("assignin: invalid assignment to keyword '%s'", nm.c_str ());
 
-      octave::symbol_scope *scope = interp.get_current_scope ();
+      octave::symbol_scope scope = interp.get_current_scope ();
 
       if (scope)
-        scope->assign (nm, args(2));
+        scope.assign (nm, args(2));
     }
   else
     error ("assignin: invalid variable name in argument VARNAME");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -96,17 +96,17 @@ namespace octave
   class base_parser
   {
   private:
 
     class parent_scope_info
     {
     public:
 
-      typedef std::pair<symbol_scope*, std::string> value_type;
+      typedef std::pair<symbol_scope, std::string> value_type;
 
       typedef std::deque<value_type>::iterator iterator;
       typedef std::deque<value_type>::const_iterator const_iterator;
 
       typedef std::deque<value_type>::reverse_iterator reverse_iterator;
       typedef std::deque<value_type>::const_reverse_iterator const_reverse_iterator;
 
       parent_scope_info (void) = default;
@@ -116,25 +116,25 @@ namespace octave
       parent_scope_info& operator = (const parent_scope_info&) = default;
 
       ~parent_scope_info (void) = default;
 
       size_t size (void) const;
 
       void push (const value_type& elt);
 
-      void push (symbol_scope *id);
+      void push (const symbol_scope& id);
 
       void pop (void);
 
       bool name_ok (const std::string& name);
 
       bool name_current_scope (const std::string& name);
 
-      symbol_scope *parent_scope (void) const;
+      symbol_scope parent_scope (void) const;
 
       std::string parent_name (void) const;
 
       void clear (void);
 
     private:
 
       std::deque<value_type> m_info;
@@ -443,17 +443,17 @@ namespace octave
     // = 1 inside the primary function or a subfunction.
     // > 1 means we are looking at a function definition that seems to be
     //     inside a function.  Note that the function still might not be a
     //     nested function.
     int m_curr_fcn_depth;
 
     // Scope where we install all subfunctions and nested functions.  Only
     // used while reading function files.
-    symbol_scope *m_primary_fcn_scope;
+    symbol_scope m_primary_fcn_scope;
 
     // Name of the current class when we are parsing class methods or
     // constructors.
     std::string m_curr_class_name;
 
     // Name of the current package when we are parsing an element contained
     // in a package directory (+-directory).
     std::string m_curr_package_name;
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -87,47 +87,50 @@ namespace octave
   tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle& anon_fh)
   {
     // FIXME: should CMD_LIST be limited to a single expression?
     // I think that is what Matlab does.
 
     tree_parameter_list *param_list = anon_fh.parameter_list ();
     tree_expression *expr = anon_fh.expression ();
 
-    symbol_scope *af_scope = anon_fh.scope ();
+    symbol_scope af_scope = anon_fh.scope ();
 
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
-    symbol_scope *af_parent_scope
-      = anon_fh.has_parent_scope () ? symtab.current_scope () : nullptr;
-
-    symbol_scope *new_scope = af_scope ? af_scope->dup () : nullptr;
+    symbol_scope af_parent_scope;
+    if (anon_fh.has_parent_scope ())
+      af_parent_scope = symtab.current_scope ();
+
+    symbol_scope new_scope;
+    if (af_scope)
+      new_scope = af_scope.dup ();
 
     if (new_scope && af_parent_scope)
-      new_scope->inherit (af_parent_scope);
+      new_scope.inherit (af_parent_scope);
 
     tree_parameter_list *param_list_dup
-      = param_list ? param_list->dup (*new_scope) : nullptr;
+      = param_list ? param_list->dup (new_scope) : nullptr;
 
     tree_parameter_list *ret_list = nullptr;
 
     tree_statement_list *stmt_list = nullptr;
 
     if (expr)
       {
-        tree_expression *expr_dup = expr->dup (*new_scope);
+        tree_expression *expr_dup = expr->dup (new_scope);
         tree_statement *stmt = new tree_statement (expr_dup, nullptr);
         stmt_list = new tree_statement_list (stmt);
       }
 
     octave_user_function *af
       = new octave_user_function (new_scope, param_list_dup, ret_list,
                                   stmt_list);
 
-    new_scope->set_parent (af_parent_scope);
+    new_scope.set_parent (af_parent_scope);
 
     octave_function *curr_fcn = m_call_stack.current ();
 
     if (curr_fcn)
       {
         // FIXME: maybe it would be better to just stash curr_fcn
         // instead of individual bits of info about it?
 
@@ -577,19 +580,19 @@ namespace octave
     octave_idx_type vlen = varargout.numel ();
     int len = ret_list->length ();
 
     // Special case.  Will do a shallow copy.
     if (len == 0)
       return varargout;
     else if (nargout <= len)
       {
-        symbol_scope *scope = get_current_scope ();
-
-        symbol_record::context_id context = scope->current_context ();
+        symbol_scope scope = get_current_scope ();
+
+        symbol_record::context_id context = scope.current_context ();
 
         octave_value_list retval (nargout);
 
         int i = 0;
 
         for (tree_decl_elt *elt : *ret_list)
           {
             if (elt->is_defined (context))
@@ -668,17 +671,17 @@ namespace octave
           }
         else
           return val.is_equal (label_value);
       }
 
     return false;
   }
 
-  symbol_scope *
+  symbol_scope
   tree_evaluator::get_current_scope (void)
   {
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
     return symtab.current_scope ();
   }
 
   void
@@ -1024,31 +1027,31 @@ namespace octave
 
         symbol_table& symtab = m_interpreter.get_symbol_table ();
 
         symtab.install_cmdline_function (nm, fcn);
 
         // Make sure that any variable with the same name as the new
         // function is cleared.
 
-        symbol_scope *scope = symtab.current_scope ();
+        symbol_scope scope = symtab.current_scope ();
 
         if (scope)
-          scope->assign (nm);
+          scope.assign (nm);
       }
   }
 
   void
   tree_evaluator::visit_identifier (tree_identifier& expr)
   {
     octave_value_list retval;
 
-    symbol_scope *scope = get_current_scope ();
-
-    symbol_record::context_id context = scope->current_context ();
+    symbol_scope scope = get_current_scope ();
+
+    symbol_record::context_id context = scope.current_context ();
 
     symbol_record sym = expr.symbol ();
 
     octave_value val = sym.find (context);
 
     if (val.is_defined ())
       {
         // GAGME -- this would be cleaner if we required
@@ -1151,20 +1154,20 @@ static void
 final_index_error (octave::index_exception& e,
                    const octave::tree_expression *expr)
 {
   std::string extra_message;
 
   // FIXME: make this a member function for direct access to symbol
   // table and scope?
 
-  octave::symbol_scope *scope
+  octave::symbol_scope scope
     = octave::__require_current_scope__ ("final_index_error");
 
-  octave::symbol_record::context_id context = scope->current_context ();
+  octave::symbol_record::context_id context = scope.current_context ();
 
   if (expr->is_identifier ()
       && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
@@ -1283,19 +1286,19 @@ namespace octave
     octave_value base_expr_val;
 
     tree_expression *expr = idx_expr.expression ();
 
     if (expr->is_identifier () && type[beg] == '(')
       {
         tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-        symbol_scope *scope = get_current_scope ();
-
-        symbol_record::context_id context = scope->current_context ();
+        symbol_scope scope = get_current_scope ();
+
+        symbol_record::context_id context = scope.current_context ();
 
         if (! id->is_variable (context))
           {
             octave_value_list first_args;
 
             tree_argument_list *al = *p_args;
 
             if (al && al->length () > 0)
@@ -2273,19 +2276,19 @@ namespace octave
                 // FIXME: it seems that we should just have to
                 // evaluate the expression and that should take care of
                 // everything, binding ans as necessary?
 
                 bool do_bind_ans = false;
 
                 if (expr->is_identifier ())
                   {
-                    symbol_scope *scope = get_current_scope ();
-
-                    symbol_record::context_id context = scope->current_context ();
+                    symbol_scope scope = get_current_scope ();
+
+                    symbol_record::context_id context = scope.current_context ();
 
                     tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
                     do_bind_ans = (! id->is_variable (context));
                   }
                 else
                   do_bind_ans = (! expr->is_assignment_expression ());
 
@@ -2733,19 +2736,19 @@ namespace octave
           {
             octave_value_list lst = val.list_value ();
 
             for (octave_idx_type i = 0; i < lst.length (); i++)
               bind_ans (lst(i), print);
           }
         else
           {
-            symbol_scope *scope = get_current_scope ();
-
-            scope->force_assign (ans, val);
+            symbol_scope scope = get_current_scope ();
+
+            scope.force_assign (ans, val);
 
             if (print)
               {
                 octave_value_list args = ovl (val);
                 args.stash_name_tags (string_vector (ans));
                 feval ("display", args);
               }
           }
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -308,17 +308,17 @@ namespace octave
 
     bool switch_case_label_matches (tree_switch_case *expr,
                                     const octave_value& val);
 
     call_stack& get_call_stack (void) { return m_call_stack; }
 
     profiler& get_profiler (void) { return m_profiler; }
 
-    symbol_scope *get_current_scope (void);
+    symbol_scope get_current_scope (void);
 
     int max_recursion_depth (void) const { return m_max_recursion_depth; }
 
     int max_recursion_depth (int n)
     {
       int val = m_max_recursion_depth;
       m_max_recursion_depth = n;
       return val;
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -54,45 +54,47 @@ namespace octave
 
     return new_fh;
   }
 
   tree_anon_fcn_handle::~tree_anon_fcn_handle (void)
   {
     delete m_parameter_list;
     delete m_expression;
-    delete m_scope;
   }
 
   tree_expression *
   tree_anon_fcn_handle::dup (symbol_scope&) const
   {
     tree_parameter_list *param_list = parameter_list ();
     tree_expression *expr = expression ();
 
-    symbol_scope *af_scope = m_scope;
-    symbol_scope *af_parent_scope = m_parent_scope;
+    symbol_scope af_scope = m_scope;
+    symbol_scope af_parent_scope = m_parent_scope;
 
     symbol_table& symtab
       = __get_symbol_table__ ("tree_anon_fcn_handle::dup");
 
-    symbol_scope *new_scope = af_scope ? af_scope->dup () : nullptr;
+    symbol_scope new_scope;
+
+    if (af_scope)
+      new_scope = af_scope.dup ();
 
     // FIXME: why should we inherit from the current scope here?  That
     // doesn't seem right, but with the way things work now it appears
     // to be required for bug-31371.tst to pass.
 
     if (new_scope)
       symtab.inherit (new_scope);
 
     // FIXME: if new scope is nullptr, then we are in big trouble here...
 
     tree_anon_fcn_handle *new_afh = new
-      tree_anon_fcn_handle (param_list ? param_list->dup (*new_scope) : nullptr,
-                            expr ? expr->dup (*new_scope) : nullptr,
+      tree_anon_fcn_handle (param_list ? param_list->dup (new_scope) : nullptr,
+                            expr ? expr->dup (new_scope) : nullptr,
                             new_scope, af_parent_scope, line (), column ());
 
     new_afh->copy_base (*this);
 
     return new_afh;
   }
 }
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -87,23 +87,23 @@ namespace octave
   };
 
   class tree_anon_fcn_handle : public tree_expression
   {
   public:
 
     tree_anon_fcn_handle (int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (nullptr),
-        m_expression (nullptr), m_scope (nullptr), m_parent_scope (nullptr),
+        m_expression (nullptr), m_scope (), m_parent_scope (),
         m_file_name ()
     { }
 
     tree_anon_fcn_handle (tree_parameter_list *pl, tree_expression *ex,
-                          symbol_scope *scope,
-                          symbol_scope *parent_scope,
+                          const symbol_scope& scope,
+                          const symbol_scope& parent_scope,
                           int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (pl), m_expression (ex),
         m_scope (scope), m_parent_scope (parent_scope), m_file_name ()
     { }
 
     // No copying!
 
     tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
@@ -118,21 +118,21 @@ namespace octave
 
     tree_parameter_list * parameter_list (void) const
     {
       return m_parameter_list;
     }
 
     tree_expression * expression (void) const { return m_expression; }
 
-    symbol_scope *scope (void) const { return m_scope; }
+    symbol_scope scope (void) const { return m_scope; }
 
-    symbol_scope *parent_scope (void) const { return m_parent_scope; }
+    symbol_scope parent_scope (void) const { return m_parent_scope; }
 
-    bool has_parent_scope (void) const { return m_parent_scope; }
+    bool has_parent_scope (void) const { return m_parent_scope.is_valid (); }
 
     tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw) { tw.visit_anon_fcn_handle (*this); }
 
     void stash_file_name (const std::string& file) { m_file_name = file; }
 
     std::string file_name (void) const { return m_file_name; }
@@ -141,20 +141,20 @@ namespace octave
 
     // Inputs parameters.
     tree_parameter_list *m_parameter_list;
 
     // Function body, limited to a single expression.
     tree_expression *m_expression;
 
     // Function scope.
-    symbol_scope *m_scope;
+    symbol_scope m_scope;
 
-    // Parent scope, or 0 if none.
-    symbol_scope *m_parent_scope;
+    // Parent scope, or an invalid scope if none.
+    symbol_scope m_parent_scope;
 
     // Filename where the handle was defined.
     std::string m_file_name;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -35,21 +35,21 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 namespace octave
 {
   // Symbols from the symbol table.
 
   class tree_evaluator;
 
-  void tree_identifier::link_to_global (symbol_scope *global_scope,
+  void tree_identifier::link_to_global (const symbol_scope& global_scope,
                                         const symbol_record& global_sym)
   {
     if (! sym.is_global ())
-      sym.bind_fwd_rep (global_scope, global_sym);
+      sym.bind_fwd_rep (global_scope.get_rep (), global_sym);
   }
 
   void
   tree_identifier::eval_undefined_error (void)
   {
     int l = line ();
     int c = column ();
 
@@ -65,19 +65,19 @@ namespace octave
   }
 
   octave_lvalue
   tree_identifier::lvalue (tree_evaluator *tw)
   {
     if (sym.is_added_static ())
       static_workspace_error ();
 
-    symbol_scope *scope = tw->get_current_scope ();
+    symbol_scope scope = tw->get_current_scope ();
 
-    return octave_lvalue (sym, scope->current_context ());
+    return octave_lvalue (sym, scope.current_context ());
   }
 
   tree_identifier *
   tree_identifier::dup (symbol_scope& scope) const
   {
     // The new tree_identifier object contains a symbol_record
     // entry from the duplicated scope.
 
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -100,17 +100,17 @@ namespace octave
 
     octave_value
     do_lookup (symbol_record::context_id context,
                const octave_value_list& args = octave_value_list ())
     {
       return sym.find (context, args);
     }
 
-    void link_to_global (symbol_scope *global_scope,
+    void link_to_global (const symbol_scope& global_scope,
                          const symbol_record& global_sym);
 
     void mark_persistent (void) { sym.init_persistent (); }
 
     void mark_as_formal_parameter (void) { sym.mark_formal (); }
 
     // We really need to know whether this symbol referst to a variable
     // or a function, but we may not know that yet.
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -792,17 +792,17 @@ void
       {
         // stolen from octave::tree_evaluator::visit_statement
         bool do_bind_ans = false;
 
         if (expr->is_identifier ())
           {
             tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-            do_bind_ans = (! id->is_variable (scope->current_context ()));
+            do_bind_ans = (! id->is_variable (scope.current_context ()));
           }
         else
           do_bind_ans = (! expr->is_assignment_expression ());
 
         jit_value *expr_result = visit (expr);
 
         if (do_bind_ans)
           do_assign ("ans", expr_result, expr->print_result ());
@@ -1083,17 +1083,17 @@ void
         block->append (factory.create<jit_cond_branch> (check, tail, body));
       }
 
     blocks.push_back (tail);
     block = tail;
   }
 
   void
-  jit_convert::initialize (symbol_scope *s)
+  jit_convert::initialize (const symbol_scope& s)
   {
     scope = s;
     iterator_count = 0;
     for_bounds_count = 0;
     short_count = 0;
     jit_instruction::reset_ids ();
 
     entry_block = factory.create<jit_block> ("body");
@@ -1139,17 +1139,17 @@ void
     symbol_record record = symtab.find_symbol (vname, scope);
     if (record.is_persistent () || record.is_global ())
       throw jit_fail_exception ("Persistent and global not yet supported");
 
     if (converting_function)
       return create_variable (vname, jit_typeinfo::get_any (), false);
     else
       {
-        octave_value val = record.varval (scope->current_context ());
+        octave_value val = record.varval (scope.current_context ());
         if (val.is_undefined ())
           val = symtab.find_function (vname);
 
         jit_type *type = jit_typeinfo::type_of (val);
         bounds.push_back (type_bound (type, vname));
 
         return create_variable (vname, type);
       }
@@ -2675,25 +2675,25 @@ void
             obv->grab ();
 
             real_arguments[i] = obv;
           }
       }
 
     function (&real_arguments[0]);
 
-    symbol_table& symtab = __get_symbol_table__ ("jit_info::execute");
+    symbol_scope scope = __require_current_scope__ ("jit_info::execute");
 
     for (size_t i = 0; i < arguments.size (); ++i)
       {
         const std::string& name = arguments[i].first;
 
         // do not store for loop bounds temporary
         if (name.size () && name[0] != '#')
-          symtab.assign (arguments[i].first, real_arguments[i]);
+          scope.assign (arguments[i].first, real_arguments[i]);
       }
 
     octave_quit ();
 
     return true;
   }
 
   bool
@@ -2798,19 +2798,19 @@ void
 
   octave_value
   jit_info::find (const vmap& extra_vars, const std::string& vname) const
   {
     vmap::const_iterator iter = extra_vars.find (vname);
 
     if (iter == extra_vars.end ())
       {
-        symbol_scope *scope = __require_current_scope__ ("jit_convert::find");
-
-        return scope->varval (vname);
+        symbol_scope scope = __require_current_scope__ ("jit_convert::find");
+
+        return scope.varval (vname);
       }
     else
       return *iter->second;
   }
 }
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -174,17 +174,17 @@ namespace octave
     void visit_do_until_command (tree_do_until_command&);
   private:
     std::vector<std::pair<std::string, bool>> arguments;
     type_bound_vector bounds;
 
     bool converting_function;
 
     // the scope of the function we are converting, or the current scope
-    symbol_scope *scope;
+    symbol_scope scope;
 
     jit_factory factory;
 
     // used instead of return values from visit_* functions
     jit_value *result;
 
     jit_block *entry_block;
 
@@ -199,17 +199,17 @@ namespace octave
     std::vector<jit_magic_end::context> end_context;
 
     size_t iterator_count;
     size_t for_bounds_count;
     size_t short_count;
 
     variable_map vmap;
 
-    void initialize (symbol_scope *s);
+    void initialize (const symbol_scope& s);
 
     jit_call * create_checked_impl (jit_call *ret);
 
     // get an existing vairable.  If the variable does not exist, it will not be
     // created
     jit_variable * find_variable (const std::string& vname) const;
 
     // get a variable, create it if it does not exist.  The type will default to
