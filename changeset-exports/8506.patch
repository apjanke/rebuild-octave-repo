# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1231865760 18000
#      Tue Jan 13 11:56:00 2009 -0500
# Node ID bc982528de112088df95e3b922a8be5dcdea1faa
# Parent  124dd27bedaea8193fb79e80d47f4cb99ae48ddb
comment style fixes

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,23 @@
+2009-01-13  John W. Eaton  <jwe@octave.org>
+
+	* audio/wavread.m, general/__splinen__.m, general/bicubic.m,
+	general/rat.m, linear-algebra/expm.m, linear-algebra/krylov.m,
+	linear-algebra/onenormest.m, miscellaneous/edit.m,
+	optimization/__dogleg__.m, pkg/pkg.m, plot/__errplot__.m,
+	plot/__go_draw_axes__.m, plot/__stem__.m, plot/findobj.m,
+	set/ismember.m, signal/arma_rnd.m, signal/freqz.m, signal/stft.m,
+	sparse/pcg.m, sparse/sprandsym.m, sparse/treelayout.m,
+	specfun/factor.m, specfun/nchoosek.m, specfun/primes.m,
+	statistics/base/quantile.m, statistics/base/values.m,
+	strings/findstr.m, strings/str2double.m, strings/strrep.m,
+	testfun/assert.m, testfun/fail.m, testfun/speed.m, testfun/test.m,
+	time/datestr.m, time/datevec.m: Comment style fixes.
+
 2009-01-13  Daniel J Sebald  <daniel.sebald@ieee.org>
 
 	* set/unique.m: Fix for vertical array inputs.
 
 2009-01-12  John W. Eaton  <jwe@octave.org>
 
 	* optimization/fzero.m, optimization/fsolve.m: Style fixes.
 	Use strcmpi to compare options.
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -56,76 +56,76 @@ function [y, samples_per_sec, bits_per_s
   endif
 
   # open file for binary reading
   [fid, msg] = fopen (filename, "rb");
   if (fid < 0)
     error ("wavread: %s", msg);
   endif
   
-  ## check for RIFF/WAVE header
+  ## Check for RIFF/WAVE header.
   ck_id = char (fread (fid, 4))';
   fseek (fid, 4, SEEK_CUR);
   wave_id = char (fread (fid, 4))';
   if (ck_id != "RIFF" || wave_id != "WAVE")
     fclose (fid);
     error ("wavread: file contains no RIFF/WAVE signature");
   endif
   
-  ## find format chunk within the next 256 (4*64) bytes
+  ## Find format chunk within the next 256 (4*64) bytes.
   i = 1;
   while (true)
     if (char (fread (fid, 4))' == "fmt ");
       break;
     endif
     if (i++ == 64)
       fclose (fid);
       error ("wavread: file contains no format chunk");
     endif
   endwhile
 
-  ## format chunk size
+  ## Format chunk size.
   ck_size = fread (fid, 1, "uint32", 0, BYTEORDER);         
   
-  ## sample format code
+  ## Sample format code.
   format_tag = fread (fid, 1, "uint16", 0, BYTEORDER);
   if (format_tag != FORMAT_PCM && format_tag != FORMAT_IEEE_FLOAT)
     fclose (fid);
     error ("wavread: sample format %#x is not supported", format_tag);
   endif
 
-  ## number of interleaved channels  
+  ## Number of interleaved channels.
   channels = fread (fid, 1, "uint16", 0, BYTEORDER);
 
-  ## sample rate
+  ## Sample rate.
   samples_per_sec = fread (fid, 1, "uint32", 0, BYTEORDER);
 
-  ## bits per sample
+  ## Bits per sample.
   fseek (fid, 6, SEEK_CUR);
   bits_per_sample = fread (fid, 1, "uint16", 0, BYTEORDER);
 
-  ## ignore the rest of the chunk
+  ## Ignore the rest of the chunk.
   fseek (fid, ck_size-16, SEEK_CUR);
   
-  ## find data chunk
+  ## Find data chunk.
   i = 1;
   while (true)
     if (char (fread (fid, 4))' == "data")
       break;
     endif
     if (i++ == 64)
       fclose (fid);
       error ("wavread: file contains no data chunk");
     endif
   endwhile
 
-  ## data chunk size
+  ## Data chunk size.
   ck_size = fread (fid, 1, "uint32", 0, BYTEORDER);
   
-  ## determine sample data type
+  ## Determine sample data type.
   if (format_tag == FORMAT_PCM)
     switch (bits_per_sample)
       case 8
         format = "uint8";
       case 16 
         format = "int16";
       case 24
 	format = "uint8";
@@ -144,70 +144,70 @@ function [y, samples_per_sec, bits_per_s
         format = "float64";
       otherwise
         fclose (fid);
         error ("wavread: %d bits sample resolution is not supported with IEEE float",
 	       bits_per_sample);
     endswitch
   endif
   
-  ## parse arguments
+  ## Parse arguments.
   if (nargin == 1)
     length = 8 * ck_size / bits_per_sample;
   else
     if (size (param, 2) == 1)
-      ## number of samples is given
+      ## Number of samples is given.
       length = param * channels;
     elseif (size (param, 2) == 2)
-      ## sample range is given
+      ## Sample range is given.
       if (fseek (fid, (param(1)-1) * channels * (bits_per_sample/8), SEEK_CUR) < 0)
         warning ("wavread: seeking failed");
       endif
       length = (param(2)-param(1)+1) * channels;
     elseif (size (param, 2) == 4 && char (param) == "size")
-      ## size of the file is requested
+      ## Size of the file is requested.
       fclose (fid);
       y = [ck_size/channels/(bits_per_sample/8), channels];
       return
     else
       fclose (fid);
       error ("wavread: invalid argument 2");
     endif
   endif
 
-  ## read samples and close file
+  ## Read samples and close file.
   if (bits_per_sample == 24)
     length *= 3;
   endif
   [yi, n] = fread (fid, length, format, 0, BYTEORDER);
   fclose (fid);
 
-  ## check data
+  ## Check data.
   if (mod (numel (yi), channels) != 0)
     error ("wavread: data in %s doesn't match the number of channels",
 	   filename);
   endif
 
   if (bits_per_sample == 24)
     yi = reshape (yi, 3, rows(yi)/3)';
     yi(yi(:,3) >= 128, 3) -= 256;
     yi = yi * [1; 256; 65536];
   endif
 
   if (format_tag == FORMAT_PCM)
-    ## normalize samples
+    ## Normalize samples.
     switch (bits_per_sample)
       case 8
         yi = (yi - 128)/127;
       case 16
         yi /= 32767;
       case 24
 		yi /= 8388607;
       case 32
         yi /= 2147483647;
     endswitch
   endif
   
-  ## deinterleave
+  ## Deinterleave.
   nr = numel (yi) / channels;
   y = reshape (yi, channels, nr)';
   
 endfunction
diff --git a/scripts/general/__splinen__.m b/scripts/general/__splinen__.m
--- a/scripts/general/__splinen__.m
+++ b/scripts/general/__splinen__.m
@@ -24,17 +24,18 @@
 ## @end deftypefn
 
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
   if (nargin != 5)
     error ("Incorrect number of arguments");
   endif
-  isvec = @(x) numel (x) == length (x);   # ND isvector function
+  ## ND isvector function.
+  isvec = @(x) numel (x) == length (x);
   if (!iscell (x) || length(x) < ndims(y) || any (! cellfun (isvec, x)) ||
       !iscell (xi) || length(xi) < ndims(y) || any (! cellfun (isvec, xi)))
     error ("%s: non gridded data or dimensions inconsistent", f);
   endif
   yi = y;
   for i = length(x):-1:1
     yi = permute (spline (x{i}, yi, xi{i}), [length(x),1:length(x)-1]);
   endfor
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -83,22 +83,22 @@ function F = bicubic (X, Y, Z, XI, YI, e
       endif
     elseif (size_equal (X, Y) && size_equal (X, Z))
       X = X(1,:);
       Y = Y(:,1);
     else
       error ("X, Y and Z must be martrices of same size");
     endif
     
-    ## mark values outside the lookup table
+    ## Mark values outside the lookup table.
     xfirst_ind = find (XI < X(1));
     xlast_ind  = find (XI > X(cz));    
     yfirst_ind = find (YI < Y(1));
     ylast_ind  = find (YI > Y(rz));
-    ## set value outside the table preliminary to min max index   
+    ## Set value outside the table preliminary to min max index.
     XI(xfirst_ind) = X(1);
     XI(xlast_ind) = X(cz);
     YI(yfirst_ind) = Y(1);
     YI(ylast_ind) = Y(rz);
 
 
     X = reshape (X, 1, cz);
     X(cz) *= 1 + sign (X(cz))*myeps;
@@ -115,17 +115,17 @@ function F = bicubic (X, Y, Z, XI, YI, e
     if (Y(rz) == 0) 
       Y(rz) = myeps;
     endif; 
     YI = reshape (YI, length (YI), 1);
     [m, i] = sort ([Y; YI]);
     o = cumsum (i <= rz);
     yidx = o([find( i> rz)]);
     
-    ## set s and t used follow codes
+    ## Set s and t used follow codes.
     s = xidx + ((XI .- X(xidx))./(X(xidx+1) .- X(xidx)));
     t = yidx + ((YI - Y(yidx))./(Y(yidx+1) - Y(yidx)));
   else
     print_usage ();
   endif
   
   if (rz < 3 || cz < 3)
     error ("Z at least a 3 by 3 matrices");
@@ -147,17 +147,17 @@ function F = bicubic (X, Y, Z, XI, YI, e
 
   p = zeros (size (Z) + 2);
   p(2:rz+1,2:cz+1) = Z;
   p(1,:)      =    (6*(1-a))*p(2,:)    -3*p(3,:)   + (6*a-2)*p(4,:);
   p(rz+2,:)   =    (6*(1-a))*p(rz+1,:) -3*p(rz,:)  + (6*a-2)*p(rz-1,:);
   p(:,1)      =    (6*(1-a))*p(:,2)    -3*p(:,3)   + (6*a-2)*p(:,4);
   p(:,cz+2)   =    (6*(1-a))*p(:,cz+1)  -3*p(:,cz) + (6*a-2)*p(:,cz-1);
 
-  ## calculte the C1(t) C2(t) C3(t) C4(t) and C1(s) C2(s) C3(s) C4(s)
+  ## Calculte the C1(t) C2(t) C3(t) C4(t) and C1(s) C2(s) C3(s) C4(s).
   t2= t.*t;
   t3= t2.*t;
 
   ct0=     -a .* t3 +     (2 * a) .* t2 - a .* t ;      # -a G0
   ct1 = (2-a) .* t3 +      (-3+a) .* t2          + 1 ;  # F0 - a G1
   ct2 = (a-2) .* t3 + (-2 *a + 3) .* t2 + a .* t ;      # F1 + a G0
   ct3 =     a .* t3 -           a .* t2;                # a G1
   t = [];t2=[]; t3=[];
@@ -183,17 +183,17 @@ function F = bicubic (X, Y, Z, XI, YI, e
   for i = 1:lent
     it = indt(i);
     int = [it, it+1, it+2, it+3];
     F(i,:) = [ct0(i),ct1(i),ct2(i),ct3(i)] * ...
 	(p(int,inds) .* cs0 + p(int,inds+1) .* cs1 + ...
 	 p(int,inds+2) .* cs2 + p(int,inds+3) .* cs3);
   endfor
 
-  ## set points outside the table to extrapval
+  ## Set points outside the table to extrapval.
   if (! (isempty (xfirst_ind) && isempty (xlast_ind)))
     F(:, [xfirst_ind, xlast_ind]) = extrapval;
   endif
   if (! (isempty (yfirst_ind) && isempty (ylast_ind)))
     F([yfirst_ind; ylast_ind], :) = extrapval;
   endif
 
 endfunction
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -37,81 +37,84 @@
 function [n,d] = rat(x,tol)
 
   if (nargin != [1,2] || nargout > 2)
     print_usage ();
   endif
 
   y = x(:);
 
-  ## replace inf with 0 while calculating ratios
+  ## Replace Inf with 0 while calculating ratios.
   y(isinf(y)) = 0;
 
   ## default norm
   if (nargin < 2)
     tol = 1e-6 * norm(y,1);
   endif
 
   ## First step in the approximation is the integer portion
-  n = round(y);  # first element in the continued fraction
+
+  ## First element in the continued fraction.
+  n = round(y);
   d = ones(size(y));
   frac = y-n;
   lastn = ones(size(y));
   lastd = zeros(size(y));
 
   nd = ndims(y);
   nsz = numel (y);
   steps = zeros([nsz, 0]);
 
-  ## grab new factors until all continued fractions converge
+  ## Grab new factors until all continued fractions converge.
   while (1)
-    ## determine which fractions have not yet converged
+    ## Determine which fractions have not yet converged.
     idx = find(abs (y-n./d) >= tol);
     if (isempty(idx))
       if (isempty (steps))
 	steps = NaN .* ones (nsz, 1);
       endif
       break;
     endif
 
-    ## grab the next step in the continued fraction
+    ## Grab the next step in the continued fraction.
     flip = 1./frac(idx);
-    step = round(flip); # next element in the continued fraction
+    ## Next element in the continued fraction.
+    step = round(flip);
 
     if (nargout < 2)
       tsteps = NaN .* ones (nsz, 1);
       tsteps (idx) = step;
       steps = [steps, tsteps];
     endif
 
     frac(idx) = flip-step;
 
-    ## update the numerator/denominator
+    ## Update the numerator/denominator.
     nextn = n;
     nextd = d;
     n(idx) = n(idx).*step + lastn(idx);
     d(idx) = d(idx).*step + lastd(idx);
     lastn = nextn;
     lastd = nextd;
   endwhile
 
   if (nargout == 2)
-    ## move the minus sign to the top
+    ## Move the minus sign to the top.
     n = n.*sign(d);
     d = abs(d);
 
-    ## return the same shape as you receive
+    ## Return the same shape as you receive.
     n = reshape(n, size(x));
     d = reshape(d, size(x));
 
-    ## use 1/0 for Inf
+    ## Use 1/0 for Inf.
     n(isinf(x)) = sign(x(isinf(x)));
     d(isinf(x)) = 0;
 
-    ## reshape the output
+    ## Reshape the output.
     n = reshape (n, size (x));
     d = reshape (d, size (x));
   else
     n = "";
     nsteps = size(steps, 2);
     for i = 1: nsz
       s = [int2str(y(i))," "];
       j = 1;
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -103,56 +103,58 @@
 
 function r = expm (a)
 
   if (! ismatrix (a) || ! issquare (a))
     error ("expm requires a square matrix")
   endif
 
   n = rows (a);
-  # trace reduction
+  ## Trace reduction.
   a(a == -Inf) = -realmax;
   trshift = trace (a) / length (a);
   if (trshift > 0)
     a -= trshift*eye (n);
   endif
-  # balancing
+  ## Balancing.
   [p, d, aa] = balance (a);
-  # FIXME: can we both permute and scale at once? Or should we rather do this:
-  # [p, xx, aa] = balance (a, "noscal");
-  # [xx, d, aa] = balance (aa, "noperm");
+  ## FIXME: can we both permute and scale at once? Or should we rather do
+  ## this:
+  ##
+  ##   [p, xx, aa] = balance (a, "noscal");
+  ##   [xx, d, aa] = balance (aa, "noperm");
   [f, e] = log2 (norm (aa, "inf"));
   s = max (0, e);
   s = min (s, 1023);
   aa *= 2^(-s);
 
-  # Pade approximation for exp(A)
+  ## Pade approximation for exp(A).
   c = [5.0000000000000000e-1,...
        1.1666666666666667e-1,...
        1.6666666666666667e-2,...
        1.6025641025641026e-3,...
        1.0683760683760684e-4,...
        4.8562548562548563e-6,...
        1.3875013875013875e-7,...
        1.9270852604185938e-9];
 
   a2 = aa^2;
   id = eye (n);
   x = (((c(8) * a2 + c(6) * id) * a2 + c(4) * id) * a2 + c(2) * id) * a2 + id;
   y = (((c(7) * a2 + c(5) * id) * a2 + c(3) * id) * a2 + c(1) * id) * aa;
 
   r = (x - y) \ (x + y);
 
-  # Undo scaling by repeated squaring
-  for k = 1:s 
+  ## Undo scaling by repeated squaring.
+  for k = 1:s
     r ^= 2;
   endfor
 
-  # inverse balancing
+  ## inverse balancing.
   ds = diag (s);
   r = ds * r / ds;
   r = r(p, p);
-  # inverse trace reduction
+  ## Inverse trace reduction.
   if (trshift >0)
     r *= exp (trshift);
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -63,21 +63,23 @@ function [Uret, H, nu] = krylov (A, V, k
     defeps = 1e-6
   else
     defeps = 1e-12;
   endif
 
   if (nargin < 3 || nargin > 5)
     print_usage ();
   elseif (nargin < 5)
-    pflg = 0;        # default permutation flag
+    ## Default permutation flag.
+    pflg = 0;
   endif
 
   if(nargin < 4)
-    eps1 = defeps;    # default tolerance parameter
+    ## Default tolerance parameter.
+    eps1 = defeps;
   endif
 
   if (isempty (eps1))
     eps1 = defeps;
   endif
 
   na = issquare (A);
   if (! na)
@@ -91,137 +93,137 @@ function [Uret, H, nu] = krylov (A, V, k
   endif
 
   if (! isscalar (k))
     error ("krylov: third argument must be a scalar integer");
   endif
 
   Vnrm = norm (V, Inf);
 
-  ## check for trivial solution
+  ## check for trivial solution.
   if (Vnrm == 0)
     Uret = [];
     H = [];
     nu = 0;
     return;
   endif
 
-  # identify trivial null space
+  ## Identify trivial null space.
   abm = max (abs ([A, V]'));
   zidx = find (abm == 0);
 
-  # set up vector of pivot points
+  ## Set up vector of pivot points.
   pivot_vec = 1:na;
 
   iter = 0;
   alpha = [];
   nh = 0;
   while (length(alpha) < na) && (columns(V) > 0) && (iter < k)
     iter++;
 
-    ## get orthogonal basis of V
+    ## Get orthogonal basis of V.
     jj = 1;
     while (jj <= columns (V) && length (alpha) < na)
-      ## index of next Householder reflection
+      ## Index of next Householder reflection.
       nu = length(alpha)+1;
 
       short_pv = pivot_vec(nu:na);
       q = V(:,jj);
       short_q = q(short_pv);
 
       if (norm (short_q) < eps1)
-	## insignificant column; delete
+	## Insignificant column; delete.
         nv = columns (V);
         if (jj != nv)
           [V(:,jj), V(:,nv)] = swap (V(:,jj), V(:,nv));
 	  ## FIXME -- H columns should be swapped too.  Not done
 	  ## since Block Hessenberg structure is lost anyway.
         endif
         V = V(:,1:(nv-1));
-	## one less reflection
+	## One less reflection.
         nu--;
       else
-	## new householder reflection
+	## New householder reflection.
         if (pflg)
-          ## locate max magnitude element in short_q
+          ## Locate max magnitude element in short_q.
           asq = abs (short_q);
           maxv = max (asq);
           maxidx = find (asq == maxv, 1);
           pivot_idx = short_pv(maxidx);
 
-	  ## see if need to change the pivot list
+	  ## See if need to change the pivot list.
           if (pivot_idx != pivot_vec(nu))
             swapidx = maxidx + (nu-1);
             [pivot_vec(nu), pivot_vec(swapidx)] = ...
 		swap (pivot_vec(nu), pivot_vec(swapidx));
           endif
         endif
 
-	## isolate portion of vector for reflection
+	## Isolate portion of vector for reflection.
         idx = pivot_vec(nu:na);
         jdx = pivot_vec(1:nu);
 
         [hv, av, z] = housh (q(idx), 1, 0);
         alpha(nu) = av;
         U(idx,nu) = hv;
 
-        # reduce V per the reflection
+        ## Reduce V per the reflection.
         V(idx,:) = V(idx,:) - av*hv*(hv' * V(idx,:));
         if(iter > 1)
-	  ## FIXME -- not done correctly for block case
+	  ## FIXME -- not done correctly for block case.
           H(nu,nu-1) = V(pivot_vec(nu),jj);
         endif
 
-        ## advance to next column of V
+        ## Advance to next column of V.
         jj++;
       endif
     endwhile
 
-    ## check for oversize V (due to full rank)
+    ## Check for oversize V (due to full rank).
     if ((columns (V) > na) && (length (alpha) == na))
-      ## trim to size
+      ## Trim to size.
       V = V(:,1:na);
     elseif (columns(V) > na)
       krylov_V = V
       krylov_na = na
       krylov_length_alpha = length (alpha)
       error ("This case should never happen; submit a bug report");
     endif
 
     if (columns (V) > 0)
-      ## construct next Q and multiply
+      ## Construct next Q and multiply.
       Q = zeros (size (V));
       for kk = 1:columns (Q)
         Q(pivot_vec(nu-columns(Q)+kk),kk) = 1;
       endfor
 
-      ## apply Householder reflections
+      ## Apply Householder reflections.
       for ii = nu:-1:1
         idx = pivot_vec(ii:na);
         hv = U(idx,ii);
         av = alpha(ii);
         Q(idx,:) = Q(idx,:) - av*hv*(hv'*Q(idx,:));
       endfor
     endif
 
-    ## multiply to get new vector;
+    ## Multiply to get new vector.
     V = A*Q;
-    ## project off of previous vectors
+    ## Project off of previous vectors.
     nu = length (alpha);
     for i = 1:nu
       hv = U(:,i);
       av = alpha(i);
       V = V - av*hv*(hv'*V);
       H(i,nu-columns(V)+(1:columns(V))) = V(pivot_vec(i),:);
     endfor
 
   endwhile
 
-  ## Back out complete U matrix
-  ## back out U matrix ;
+  ## Back out complete U matrix.
+  ## back out U matrix.
   j1 = columns (U);
   for i = j1:-1:1;
     idx = pivot_vec(i:na);
     hv = U(idx,i);
     av = alpha(i);
     U(:,i) = zeros (na, 1);
     U(idx(1),i) = 1;
     U(idx,i:j1) = U(idx,i:j1)-av*hv*(hv'*U(idx,i:j1));
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -126,19 +126,24 @@ function [est, v, w, iter] = onenormest 
     endif
     issing = isa (varargin {3}, "single");
   endif
 
   ## Initial test vectors X.
   X = rand (n, t);
   X = X ./ (ones (n,1) * sum (abs (X), 1));
 
-  been_there = zeros (n, 1); # Track if a vertex has been visited.
-  est_old = 0; # To check if the estimate has increased.
-  S = zeros (n, t); # Normalized vector of signs.  The normalization is 
+  ## Track if a vertex has been visited.
+  been_there = zeros (n, 1);
+
+  ## To check if the estimate has increased.
+  est_old = 0;
+
+  ## Normalized vector of signs.
+  S = zeros (n, t);
 
   if (issing)
     myeps = eps ("single");
     X = single (X);
   else
     myeps = eps;
   endif
 
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -143,17 +143,18 @@ function ret = edit (file, state)
   persistent FUNCTION = struct ("EDITOR", cstrcat (EDITOR (), " %s"),
   				"HOME", fullfile (default_home, "octave"),
   				"AUTHOR", default_user(1),
   				"EMAIL",  [],
   				"LICENSE",  "GPL",
   				"MODE", "sync",
   				"EDITINPLACE", false);
 
-  mlock; # make sure the state variables survive "clear functions"
+  ## Make sure the state variables survive "clear functions".
+  mlock;
 
   if (nargin == 2)
     switch (toupper (file))
     case "EDITOR"
       FUNCTION.EDITOR = state;
     case "HOME"
       if (! isempty (state) && state(1) == "~")
 	state = [ default_home, state(2:end) ];
diff --git a/scripts/optimization/__dogleg__.m b/scripts/optimization/__dogleg__.m
--- a/scripts/optimization/__dogleg__.m
+++ b/scripts/optimization/__dogleg__.m
@@ -22,39 +22,39 @@
 ## Minimize norm(r*x-b) subject to the constraint norm(d.*x) <= delta,
 ## x being a convex combination of the gauss-newton and scaled gradient.
 ## @end deftypefn
 
 ## TODO: error checks
 ## TODO: handle singularity, or leave it up to mldivide?
 
 function x = __dogleg__ (r, b, d, delta)
-  # get Gauss-Newton direction
+  ## Get Gauss-Newton direction.
   x = r \ b;
   xn = norm (d .* x);
   if (xn > delta)
-    # GN is too big, get scaled gradient
+    ## GN is too big, get scaled gradient.
     s = (r' * b) ./ d;
     sn = norm (s);
     if (sn > 0)
-      # normalize and rescale 
+      ## Normalize and rescale.
       s = (s / sn) ./ d;
-      # get the line minimizer in s direction
+      ## Get the line minimizer in s direction.
       tn = norm (r*s);
       snm = (sn / tn) / tn;
       if (snm < delta)
-        # get the dogleg path minimizer 
+	## Get the dogleg path minimizer.
         bn = norm (b);
         dxn = delta/xn; snmd = snm/delta;
         t = (bn/sn) * (bn/xn) * snmd;
         t -= dxn * snmd^2 - sqrt ((t-dxn)^2 + (1-dxn^2)*(1-snmd^2));
         alpha = dxn*(1-snmd^2) / t;
       else
         alpha = 0;
       endif
     else
       snm = 0;
     endif
-    # form the appropriate convex combination
+    ## Form the appropriate convex combination.
     x = alpha * x + ((1-alpha) * min (snm, delta)) * s;
   endif
 endfunction
 
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -533,148 +533,148 @@ function build (files, handle_deps, auto
       unlink (buildlist);
     endif
   end_unwind_protect
 endfunction
 
 function install (files, handle_deps, autoload, prefix, archprefix, verbose, 
 		  local_list, global_list, global_install)
 
-  # Check that the directory in prefix exist. If it doesn't: create it!
+  ## Check that the directory in prefix exist. If it doesn't: create it!
   if (! exist (prefix, "dir"))
     warning ("creating installation directory %s", prefix);
     [status, msg] = mkdir (prefix);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
 
-  ## Get the list of installed packages
+  ## Get the list of installed packages.
   [local_packages, global_packages] = installed_packages (local_list, 
 							  global_list);
 
   installed_pkgs_lst = {local_packages{:}, global_packages{:}};        
 
   if (global_install)
     packages = global_packages;
   else
     packages = local_packages;
   endif
 
-  ## Uncompress the packages and read the DESCRIPTION files
+  ## Uncompress the packages and read the DESCRIPTION files.
   tmpdirs = packdirs = descriptions = {};
   try
-    ## Warn about non existent files 
+    ## Warn about non existent files.
     for i = 1:length (files)
       if (isempty (glob(files{i}))) 
 	warning ("file %s does not exist", files{i});
       endif
     endfor
 
-    ## Unpack the package files and read the DESCRIPTION files
+    ## Unpack the package files and read the DESCRIPTION files.
     files = glob (files);
     packages_to_uninstall = [];
     for i = 1:length (files)
       tgz = files{i};
 
       if (exist (tgz, "file"))
-	## Create a temporary directory 
+	## Create a temporary directory.
 	tmpdir = tmpnam ();
 	tmpdirs{end+1} = tmpdir;
         if (verbose)
 	  printf ("mkdir (%s)\n", tmpdir);
 	endif
 	[status, msg] = mkdir (tmpdir);
 	if (status != 1)
 	  error ("couldn't create temporary directory: %s", msg);
 	endif
 
-	## Uncompress the package
+	## Uncompress the package.
 	if (verbose)
 	  printf ("untar (%s, %s)\n", tgz, tmpdir);
 	endif
 	untar (tgz, tmpdir);
 
-	## Get the name of the directories produced by tar
+	## Get the name of the directories produced by tar.
 	[dirlist, err, msg] = readdir (tmpdir);
 	if (err)
 	  error ("couldn't read directory produced by tar: %s", msg);
 	endif
 
 	if (length (dirlist) > 3)
 	  error ("bundles of packages are not allowed")
 	endif
       endif
 
-      ## The filename pointed to an uncompressed package to begin with
+      ## The filename pointed to an uncompressed package to begin with.
       if (exist (tgz, "dir"))
 	dirlist = {".", "..", tgz};
       endif
 
       if (exist (tgz, "file") || exist (tgz, "dir"))
-	## the two first entries of dirlist are "." and ".."
+	## The two first entries of dirlist are "." and "..".
 	if (exist (tgz, "file"))
 	  packdir = fullfile (tmpdir, dirlist{3});
 	else
 	  packdir = fullfile (pwd(), dirlist{3});
 	endif
 	packdirs{end+1} = packdir;
 	
-	## Make sure the package contains necessary files
+	## Make sure the package contains necessary files.
 	verify_directory (packdir);
 	
-	## Read the DESCRIPTION file
+	## Read the DESCRIPTION file.
 	filename = fullfile (packdir, "DESCRIPTION");
 	desc = get_description (filename);
 	
-	## Verify that package name corresponds with filename
+	## Verify that package name corresponds with filename.
 	[dummy, nm] = fileparts (tgz); 
 	if ((length (nm) >= length (desc.name))
 	    && ! strcmp (desc.name, nm(1:length(desc.name))))
 	  error ("package name '%s' doesn't correspond to its filename '%s'", 
 		 desc.name, nm);
 	endif
 	
-	## Set default installation directory
+	## Set default installation directory.
 	desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
 	
-	## Set default architectire dependent installation directory
+	## Set default architectire dependent installation directory.
 	desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
 							 desc.version));
 	
-	## Save desc
+	## Save desc.
 	descriptions{end+1} = desc;
 	
 	## Are any of the new packages already installed?
 	## If so we'll remove the old version.
 	for j = 1:length (packages)
 	  if (strcmp (packages{j}.name, desc.name))
 	    packages_to_uninstall(end+1) = j;
 	  endif
 	endfor
       endif
     endfor
   catch
-    ## Something went wrong, delete tmpdirs
+    ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
     rethrow (lasterror ());
   end_try_catch
 
-  ## Check dependencies
+  ## Check dependencies.
   if (handle_deps)
     ok = true;
     error_text = "";
     for i = 1:length (descriptions)
       desc = descriptions{i};
       idx2 = complement (i, 1:length(descriptions));
       if (global_install)
 	## Global installation is not allowed to have dependencies on locally
-	## installed packages
+	## installed packages.
 	idx1 = complement (packages_to_uninstall, 
 			   1:length(global_packages));
 	pseudo_installed_packages = {global_packages{idx1}, ...
 				     descriptions{idx2}};
       else
 	idx1 = complement (packages_to_uninstall, 
 			   1:length(local_packages));
 	pseudo_installed_packages = {local_packages{idx1}, ... 
@@ -695,75 +695,75 @@ function install (files, handle_deps, au
     endfor
 
     ## Did we find any unsatisfied dependencies?
     if (! ok)
       error ("the following dependencies where unsatisfied:\n  %s", error_text);
     endif
   endif
 
-  ## Prepare each package for installation
+  ## Prepare each package for installation.
   try
     for i = 1:length (descriptions)
       desc = descriptions{i};
       pdir = packdirs{i};
       prepare_installation (desc, pdir);
       configure_make (desc, pdir, verbose);
     endfor
   catch
-    ## Something went wrong, delete tmpdirs
+    ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
     rethrow (lasterror ());
   end_try_catch
 
-  ## Uninstall the packages that will be replaced
+  ## Uninstall the packages that will be replaced.
   try
     for i = packages_to_uninstall
       if (global_install)
 	uninstall ({global_packages{i}.name}, false, verbose, local_list, 
 		   global_list, global_install);
       else
 	uninstall ({local_packages{i}.name}, false, verbose, local_list, 
 		   global_list, global_install);
       endif
     endfor
   catch
-    ## Something went wrong, delete tmpdirs
+    ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
     rethrow (lasterror ());
   end_try_catch
 
-  ## Install each package
+  ## Install each package.
   try
     for i = 1:length (descriptions)
       desc = descriptions{i};
       pdir = packdirs{i};
       copy_files (desc, pdir, global_install);
       create_pkgadddel (desc, pdir, "PKG_ADD", global_install);
       create_pkgadddel (desc, pdir, "PKG_DEL", global_install);
       finish_installation (desc, pdir, global_install)
     endfor
   catch
-    ## Something went wrong, delete tmpdirs
+    ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
     for i = 1:length (descriptions)
       rm_rf (descriptions{i}.dir);
       rm_rf (getarchdir (descriptions{i}));
     endfor
     rethrow (lasterror ());
   end_try_catch
 
   ## Check if the installed directory is empty. If it is remove it
-  ## from the list
+  ## from the list.
   for i = length (descriptions):-1:1
     if (dirempty (descriptions{i}.dir, {"packinfo", "doc"}) &&
 	dirempty (getarchdir (descriptions{i})))
       warning ("package %s is empty\n", descriptions{i}.name);
       rm_rf (descriptions{i}.dir);
       rm_rf (getarchdir (descriptions{i}));
       descriptions(i) = [];
     endif
@@ -774,55 +774,55 @@ function install (files, handle_deps, au
   for i = length (descriptions):-1:1
     if (autoload > 0 || (autoload == 0 && isautoload (descriptions(i))))
       fclose (fopen (fullfile (descriptions{i}.dir, "packinfo", 
 			       ".autoload"), "wt"));
       descriptions{i}.autoload = 1;
     endif
   endfor
 
-  ## Add the packages to the package list
+  ## Add the packages to the package list.
   try
     if (global_install)
       idx = complement (packages_to_uninstall, 1:length(global_packages));
       global_packages = save_order ({global_packages{idx}, descriptions{:}});
       save (global_list, "global_packages");
       installed_pkgs_lst = {local_packages{:}, global_packages{:}};
     else
       idx = complement (packages_to_uninstall, 1:length(local_packages));
       local_packages = save_order ({local_packages{idx}, descriptions{:}});
       save (local_list, "local_packages");
       installed_pkgs_lst = {local_packages{:}, global_packages{:}};
     endif
   catch
-    ## Something went wrong, delete tmpdirs
+    ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
     for i = 1:length (descriptions)
       rm_rf (descriptions{i}.dir);
     endfor
     if (global_install)
       printf ("error: couldn't append to %s\n", global_list);
     else
       printf ("error: couldn't append to %s\n", local_list);
     endif
     rethrow (lasterror ());
   end_try_catch
 
-  ## All is well, let's clean up
+  ## All is well, let's clean up.
   for i = 1:length (tmpdirs)
     [status, msg] = rm_rf (tmpdirs{i});
     if (status != 1)
       warning ("couldn't clean up after my self: %s\n", msg);
     endif
   endfor
 
   ## Add the newly installed packages to the path, so the user
-  ## can begin using them. Only load them if they are marked autoload
+  ## can begin using them. Only load them if they are marked autoload.
   if (length (descriptions) > 0)
     idx = [];
     for i = 1:length (descriptions)
       if (isautoload (descriptions(i)))
 	nm = descriptions{i}.name;
 	for j = 1:length (installed_pkgs_lst)
 	  if (strcmp (nm, installed_pkgs_lst{j}.name))
 	    idx (end + 1) = j;
@@ -833,17 +833,17 @@ function install (files, handle_deps, au
     endfor
     load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
 				    global_install);
   endif
 endfunction
 
 function uninstall (pkgnames, handle_deps, verbose, local_list, 
 		    global_list, global_install)
-  ## Get the list of installed packages
+  ## Get the list of installed packages.
   [local_packages, global_packages] = installed_packages(local_list, 
 							 global_list);
   if (global_install)
     installed_pkgs_lst = {local_packages{:}, global_packages{:}};
   else
     installed_pkgs_lst = local_packages;
   endif
 
@@ -854,42 +854,42 @@ function uninstall (pkgnames, handle_dep
     if (any (strcmp (cur_name, pkgnames)))
       delete_idx(end+1) = i;
     endif
   endfor
 
   ## Are all the packages that should be uninstalled already installed?
   if (length (delete_idx) != length (pkgnames))
     if (global_install)
-      ## Try again for a locally installed package
+      ## Try again for a locally installed package.
       installed_pkgs_lst = local_packages;
 
       num_packages = length (installed_pkgs_lst);
       delete_idx = [];
       for i = 1:num_packages
 	cur_name = installed_pkgs_lst{i}.name;
 	if (any (strcmp (cur_name, pkgnames)))
 	  delete_idx(end+1) = i;
 	endif
       endfor
       if (length (delete_idx) != length (pkgnames))
-	## FIXME: We should have a better error message
+	## FIXME: We should have a better error message.
 	warning ("some of the packages you want to uninstall are not installed");
       endif
     else
-      ## FIXME: We should have a better error message
+      ## FIXME: We should have a better error message.
       warning ("some of the packages you want to uninstall are not installed.");
     endif
   endif
 
-  ## Compute the packages that will remain installed
+  ## Compute the packages that will remain installed.
   idx = complement (delete_idx, 1:num_packages);
   remaining_packages = {installed_pkgs_lst{idx}};
 
-  ## Check dependencies
+  ## Check dependencies.
   if (handle_deps)
     error_text = "";
     for i = 1:length (remaining_packages)
       desc = remaining_packages{i};
       bad_deps = get_unsatisfied_deps (desc, remaining_packages);
 
       ## Will the uninstallation break any dependencies?
       if (! isempty (bad_deps))
@@ -902,27 +902,27 @@ function uninstall (pkgnames, handle_dep
       endif
     endfor
 
     if (! isempty (error_text))
       error ("the following dependencies where unsatisfied:\n  %s", error_text);
     endif
   endif
 
-  ## Delete the directories containing the packages
+  ## Delete the directories containing the packages.
   for i = delete_idx
     desc = installed_pkgs_lst{i};
     ## If an 'on_uninstall.m' exist, call it!
     if (exist (fullfile (desc.dir, "packinfo", "on_uninstall.m"), "file"))
       wd = pwd ();
       cd (fullfile (desc.dir, "packinfo"));
       on_uninstall (desc);
       cd (wd);
     endif
-    ## Do the actual deletion
+    ## Do the actual deletion.
     if (desc.loaded)
       rmpath (desc.dir);
       if (exist (getarchdir (desc)))
 	rmpath (getarchdir (desc));
       endif
     endif
     if (exist (desc.dir, "dir"))
       [status, msg] = rm_rf (desc.dir);
@@ -936,17 +936,17 @@ function uninstall (pkgnames, handle_dep
       if (dirempty (desc.archprefix))
 	rm_rf (desc.archprefix);
       endif
     else
       warning ("directory %s previously lost", desc.dir);
     endif
   endfor
 
-  ## Write a new ~/.octave_packages
+  ## Write a new ~/.octave_packages.
   if (global_install)
     if (length (remaining_packages) == 0)
       unlink (global_list);
     else
       global_packages = save_order (remaining_packages);
       save (global_list, "global_packages");
     endif
   else
@@ -958,17 +958,17 @@ function uninstall (pkgnames, handle_dep
     endif
   endif
 
 endfunction
 
 function [pkg_desc_list, flag] = describe (pkgnames, verbose, 
 					   local_list, global_list)
 
-  ## Get the list of installed packages
+  ## Get the list of installed packages.
   installed_pkgs_lst = installed_packages(local_list, global_list);
   num_packages = length (installed_pkgs_lst);
   
 
   describe_all = false;
   if (any (strcmp ("all", pkgnames)))
     describe_all = true;
     flag(1:num_packages) = {"Not Loaded"};
@@ -1012,21 +1012,19 @@ function [pkg_desc_list, flag] = describ
 				 pkg_desc_list{i}.provides,  
 				 pkg_desc_list{i}.description,
 				 flag{i}, verbose);
     endfor
   endif
 
 endfunction
 
-##########################################################
-##        A U X I L I A R Y    F U N C T I O N S        ##
-##########################################################
+## AUXILIARY FUNCTIONS
 
-## This function reads an INDEX file
+## Read an INDEX file.
 function [pkg_idx_struct] = parse_pkg_idx (packdir)
 
   index_file = fullfile (packdir, "packinfo", "INDEX");
 
   if (! exist (index_file, "file"))
     error ("could not find any INDEX file in directory %s, try 'pkg rebuild all' to generate missing INDEX files", packdir);
   endif    
 
@@ -1048,26 +1046,26 @@ function [pkg_idx_struct] = parse_pkg_id
 
   while (! feof (fid) || line != -1)
     if (! any (! isspace (line)) || line(1) == "#" || any (line == "="))
       ## Comments,  blank lines or comments about unimplemented 
       ## functions: do nothing
       ## FIXME: probably comments and pointers to external functions
       ## could be treated better when printing to screen?
     elseif (! isempty (strfind (line, ">>")))
-      ## Skip package name and description as they are in
-      ## DESCRIPTION already
+      ## Skip package name and description as they are in DESCRIPTION
+      ## already.
     elseif (! isspace (line(1)))
-      ## Category
+      ## Category.
       if (! isempty (pkg_idx_struct{cat_num}.functions))
 	pkg_idx_struct{++cat_num}.functions = {};
       endif
       pkg_idx_struct{cat_num}.category = deblank (line);
     else
-      ## Function names
+      ## Function names.
       while (any (! isspace (line)))
 	[fun_name, line] = strtok (line);
 	pkg_idx_struct{cat_num}.functions{end+1} = deblank (fun_name);
       endwhile
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
@@ -1192,33 +1190,33 @@ function prepare_installation (desc, pac
       pre_install (desc); 
       cd (wd);
     catch
       cd (wd);
       rethrow (lasterror ());
     end_try_catch
   endif
 
-  ## If the directory "inst" doesn't exist, we create it
+  ## If the directory "inst" doesn't exist, we create it.
   inst_dir = fullfile (packdir, "inst");
   if (! exist (inst_dir, "dir"))
     [status, msg] = mkdir (inst_dir);
     if (status != 1)
       rm_rf (desc.dir);
       error ("the 'inst' directory did not exist and could not be created: %s", 
 	     msg);
     endif
   endif
 endfunction
 
 function configure_make (desc, packdir, verbose)   
-  ## Perform ./configure, make, make install in "src"
+  ## Perform ./configure, make, make install in "src".
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
-    ## configure
+    ## Configure.
     if (exist (fullfile (src, "configure"), "file"))
       flags = "";
       if (isempty (getenv ("CC")))
         flags = cstrcat (flags, " CC=\"", octave_config_info ("CC"), "\"");
       endif
       if (isempty (getenv ("CXX")))
         flags = cstrcat (flags, " CXX=\"", octave_config_info ("CXX"), "\"");
       endif
@@ -1234,34 +1232,35 @@ function configure_make (desc, packdir, 
 	rm_rf (desc.dir);
 	error ("the configure script returned the following error: %s", output);
       elseif (verbose)
 	printf("%s", output);
       endif
 
     endif
 
-    ## make
+    ## Make.
     if (exist (fullfile (src, "Makefile"), "file"))
       [status, output] = shell (cstrcat ("export INSTALLDIR=\"", desc.dir,
 					 "\"; make -C '", src, "'"));
       if (status != 0)
 	rm_rf (desc.dir);
 	error ("'make' returned the following error: %s", output);
       elseif (verbose)
 	printf("%s", output);
       endif
     endif
 
-    ## Copy files to "inst" and "inst/arch" (this is instead of 'make install')
+    ## Copy files to "inst" and "inst/arch" (this is instead of 'make
+    ## install').
     files = fullfile (src, "FILES");
     instdir = fullfile (packdir, "inst");
     archdir = fullfile (packdir, "inst", getarch ());
 
-    ## Get file names
+    ## Get file names.
     if (exist (files, "file"))
       [fid, msg] = fopen (files, "r");
       if (fid < 0)
 	error ("couldn't open %s: %s", files, msg);
       endif
       filenames = char (fread (fid))';
       fclose (fid);
       if (filenames(end) == "\n")
@@ -1282,26 +1281,26 @@ function configure_make (desc, packdir, 
       oct = dir (fullfile (src, "*.oct"));
       mex = dir (fullfile (src, "*.mex"));
 
       filenames = cellfun (@(x) fullfile (src, x),
 			   {m.name, oct.name, mex.name},
 			   "UniformOutput", false);
     endif
 
-    ## Split into architecture dependent and independent files
+    ## Split into architecture dependent and independent files.
     if (isempty (filenames))
       idx = [];
     else
       idx = cellfun (@is_architecture_dependent, filenames);
     endif
     archdependent = filenames (idx);
     archindependent = filenames (!idx);
 
-    ## Copy the files
+    ## Copy the files.
     if (! all (isspace ([filenames{:}])))
 	if (! exist (instdir, "dir")) 
 	  mkdir (instdir);
 	endif
 	if (! all (isspace ([archindependent{:}])))
 	  if (verbose)
 	    printf ("copyfile");
 	    printf (" %s", archindependent{:});
@@ -1365,47 +1364,47 @@ function create_pkgadddel (desc, packdir
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
     archpkg = instpkg;
     archfid = instfid;
   endif
 
   if (archfid >= 0 && instfid >= 0)
-    ## Search all dot-m files for PKG commands
+    ## Search all dot-m files for PKG commands.
     lst = dir (fullfile (packdir, "inst", "*.m"));
     for i = 1:length (lst)
       nam = fullfile (packdir, "inst", lst(i).name);
       fwrite (instfid, extract_pkg (nam, ['^[#%][#%]* *' nm ': *(.*)$']));
     endfor
 
-    ## Search all C++ source files for PKG commands
+    ## Search all C++ source files for PKG commands.
     lst = dir (fullfile (packdir, "src", "*.cc"));
     for i = 1:length (lst)
       nam = fullfile (packdir, "src", lst(i).name);
       fwrite (archfid, extract_pkg (nam, ['^//* *' nm ': *(.*)$']));
       fwrite (archfid, extract_pkg (nam, ['^/\** *' nm ': *(.*) *\*/$']));
     endfor
 
-    ## Add developer included PKG commands
+    ## Add developer included PKG commands.
     packdirnm = fullfile (packdir, nm);
     if (exist (packdirnm, "file"))
       fid = fopen (packdirnm, "rt");
       if (fid >= 0)
         while (! feof (fid))
           ln = fgets (fid);
           if (ln > 0)
             fwrite (archfid, ln);
           endif
         endwhile
         fclose (fid);
       endif
     endif
 
-    ## If the files is empty remove it
+    ## If the files is empty remove it.
     fclose (instfid);
     t = dir (instpkg);
     if (t.bytes <= 0)
       unlink (instpkg);
     endif
 
     if (instfid != archfid)
       fclose (archfid);
@@ -1413,39 +1412,39 @@ function create_pkgadddel (desc, packdir
       if (t.bytes <= 0)
         unlink (archpkg);
       endif
     endif
   endif
 endfunction
 
 function copy_files (desc, packdir, global_install)
-  ## Create the installation directory
+  ## Create the installation directory.
   if (! exist (desc.dir, "dir"))
     [status, output] = mkdir (desc.dir);
     if (status != 1)
       error ("couldn't create installation directory %s : %s", 
       desc.dir, output);
     endif
   endif
 
   octfiledir = getarchdir (desc);
 
-  ## Copy the files from "inst" to installdir
+  ## Copy the files from "inst" to installdir.
   instdir = fullfile (packdir, "inst");
   if (! dirempty (instdir))
     [status, output] = copyfile (fullfile (instdir, "*"), desc.dir);
     if (status != 1)
       rm_rf (desc.dir);
       error ("couldn't copy files to the installation directory");
     endif
     if (exist (fullfile (desc.dir, getarch ()), "dir") &&
 	! strcmp (fullfile (desc.dir, getarch ()), octfiledir))
       if (! exist (octfiledir, "dir"))
-        ## Can be required to create upto three levels of dirs
+        ## Can be required to create upto three levels of dirs.
         octm1 = fileparts (octfiledir);
         if (! exist (octm1, "dir"))
           octm2 = fileparts (octm1);
           if (! exist (octm2, "dir"))
             octm3 = fileparts (octm2);
             if (! exist (octm3, "dir"))
               [status, output] = mkdir (octm3);
               if (status != 1)
@@ -1483,42 +1482,42 @@ function copy_files (desc, packdir, glob
         rm_rf (desc.dir);
         rm_rf (octfiledir);
         error ("couldn't copy files to the installation directory");
       endif
     endif
 
   endif
 
-  ## Create the "packinfo" directory
+  ## Create the "packinfo" directory.
   packinfo = fullfile (desc.dir, "packinfo");
   [status, msg] = mkdir (packinfo);
   if (status != 1)
     rm_rf (desc.dir);
     rm_rf (octfiledir);
     error ("couldn't create packinfo directory: %s", msg);
   endif
 
-  ## Copy DESCRIPTION
+  ## Copy DESCRIPTION.
   [status, output] = copyfile (fullfile (packdir, "DESCRIPTION"), packinfo);
   if (status != 1)
     rm_rf (desc.dir);
     rm_rf (octfiledir);
     error ("couldn't copy DESCRIPTION: %s", output);
   endif
 
-  ## Copy COPYING
+  ## Copy COPYING.
   [status, output] = copyfile (fullfile (packdir, "COPYING"), packinfo);
   if (status != 1)
     rm_rf (desc.dir);
     rm_rf (octfiledir);
     error ("couldn't copy COPYING: %s", output);
   endif
 
-  ## If the file ChangeLog exists, copy it
+  ## If the file ChangeLog exists, copy it.
   changelog_file = fullfile (packdir, "ChangeLog");
   if (exist (changelog_file, "file"))
     [status, output] = copyfile (changelog_file, packinfo);
     if (status != 1)
       rm_rf (desc.dir);
       rm_rf (octfiledir);
       error ("couldn't copy ChangeLog file: %s", output);
     endif
@@ -1550,23 +1549,23 @@ function copy_files (desc, packdir, glob
     [status, output] = copyfile (fon_uninstall, packinfo);
     if (status != 1)
       rm_rf (desc.dir);
       rm_rf (octfiledir);
       error ("couldn't copy on_uninstall.m: %s", output);
     endif
   endif
 
-  ## Is there a doc/ directory that needs to be installed
+  ## Is there a doc/ directory that needs to be installed?
   docdir = fullfile (packdir, "doc");
   if (exist (docdir, "dir") && ! dirempty (docdir))
     [status, output] = copyfile (docdir, desc.dir);
   endif
 
-  ## Is there a bin/ directory that needs to be installed
+  ## Is there a bin/ directory that needs to be installed?
   ## FIXME: Need to treat architecture dependent files in bin/
   bindir = fullfile (packdir, "bin");
   if (exist (bindir, "dir") && ! dirempty (bindir))
     [status, output] = copyfile (bindir, desc.dir);
   endif
 endfunction
 
 function finish_installation (desc, packdir, global_install)
@@ -1591,29 +1590,29 @@ function verify_directory (dir)
   needed_files = {"COPYING", "DESCRIPTION"};
   for f = needed_files
     if (! exist (fullfile (dir, f{1}), "file"))
       error ("package is missing file: %s", f{1});
     endif
   endfor
 endfunction
 
-## Parse the DESCRIPTION file
+## Parse the DESCRIPTION file.
 function desc = get_description (filename)
   [fid, msg] = fopen (filename, "r");
   if (fid == -1)
     error ("the DESCRIPTION file %s could not be read: %s", filename, msg);
   endif
 
   desc = struct ();
 
   line = fgetl (fid);
   while (line != -1)
     if (line(1) == "#")
-      ## Comments, do nothing
+      ## Comments, do nothing.
     elseif (isspace(line(1)))
       ## Continuation lines
       if (exist ("keyword", "var") && isfield (desc, keyword))
 	desc.(keyword) = cstrcat (desc.(keyword), " ", rstrip(line));
       endif
     else
       ## Keyword/value pair
       colon = find (line == ":");
@@ -1629,17 +1628,17 @@ function desc = get_description (filenam
 	endif
 	desc.(keyword) = value;
       endif
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
 
-  ## Make sure all is okay
+  ## Make sure all is okay.
   needed_fields = {"name", "version", "date", "title", ...
 		   "author", "maintainer", "description"};
   for f = needed_fields
     if (! isfield (desc, f{1}))
       error ("description is missing needed field %s", f{1});
     endif
   endfor
   desc.version = fix_version (desc.version);
@@ -1647,17 +1646,17 @@ function desc = get_description (filenam
     desc.depends = fix_depends (desc.depends);
   else
     desc.depends = "";
   endif
   desc.name = tolower (desc.name);
 endfunction
 
 ## Make sure the version string v is a valid x.y.z version string
-## Examples: "0.1" => "0.1.0", "monkey" => error(...)
+## Examples: "0.1" => "0.1.0", "monkey" => error(...).
 function out = fix_version (v)
   dots = find (v == ".");
   if (length (dots) == 1)
     major = str2num (v(1:dots-1));
     minor = str2num (v(dots+1:end));
     if (length (major) != 0 && length (minor) != 0)
       out = sprintf ("%d.%d.0", major, minor);
       return;
@@ -1676,23 +1675,23 @@ endfunction
 
 ## Make sure the depends field is of the right format.
 ## This function returns a cell of structures with the following fields:
 ##   package, version, operator
 function deps_cell = fix_depends (depends)
   deps = split_by (tolower (depends), ",");
   deps_cell = cell (1, length (deps));
 
-  ## For each dependency
+  ## For each dependency.
   for i = 1:length (deps)
     dep = deps{i};
     lpar = find (dep == "(");
     rpar = find (dep == ")");
     ## Does the dependency specify a version
-    ## Example: package(>= version)
+    ## Example: package(>= version).
     if (length (lpar) == 1 && length (rpar) == 1)
       package = tolower (strip (dep(1:lpar-1)));
       sub = dep(lpar(1)+1:rpar(1)-1);
       parts = split_by (sub, " ");
       idx = [];
       for r = 1:size (parts, 1)
 	if (length (parts{r}) > 0)
 	  idx(end+1) = r;
@@ -1706,51 +1705,52 @@ function deps_cell = fix_depends (depend
       operator = parts{idx(1)};
       if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
 	error ("unsupported operator: %s", operator);
       endif
       version  = fix_version (parts{idx(2)});
 
   ## If no version is specified for the dependency
   ## we say that the version should be greater than 
-  ## or equal to 0.0.0
+  ## or equal to "0.0.0".
   else
     package = tolower (strip (dep));
     operator = ">=";
     version  = "0.0.0";
   endif
   deps_cell{i} = struct ("package", package, "operator", operator,
 			 "version", version);
   endfor
 endfunction
 
 ## Strip the text of spaces from the right
-## Example: "  hello world  " => "  hello world" (FIXME: is this the same as deblank?)
+## Example: "  hello world  " => "  hello world"
+## FIXME -- is this the same as deblank?
 function text = rstrip (text)
   chars = find (! isspace (text));
   if (length (chars) > 0)
     ## FIXME: shouldn't it be text = text(1:chars(end));
     text = text (chars(1):end);
   else
     text = "";
   endif
 endfunction
 
-## Strip the text of spaces from the left and the right
+## Strip the text of spaces from the left and the right.
 ## Example: "  hello world  " => "hello world"
 function text = strip (text)
   chars = find (! isspace (text));
   if (length (chars) > 0)
     text = text(chars(1):chars(end));
   else
     text = "";
   endif
 endfunction
 
-## Split the text into a cell array of strings by sep
+## Split the text into a cell array of strings by sep.
 ## Example: "A, B" => {"A", "B"} (with sep = ",")
 function out = split_by (text, sep)
   text_matrix = split (text, sep);
   num_words = size (text_matrix, 1);
   out = cell (num_words, 1);
   for i = 1:num_words
     out{i} = strip (text_matrix(i, :));
   endfor
@@ -1762,17 +1762,17 @@ endfunction
 ##   'index_file' is the name (including path) of resulting INDEX file.
 function write_index (desc, dir, index_file, global_install)
   ## Get names of functions in dir
   [files, err, msg] = readdir (dir);
   if (err)
     error ("couldn't read directory %s: %s", dir, msg);
   endif
 
-  ## Check for architecture dependent files
+  ## Check for architecture dependent files.
   tmpdir = getarchdir (desc);
   if (exist (tmpdir, "dir"))
     [files2, err, msg] = readdir (tmpdir);
     if (err)
       error ("couldn't read directory %s: %s", tmpdir, msg);
     endif
     files = [files; files2];    
   endif
@@ -1792,40 +1792,40 @@ function write_index (desc, dir, index_f
   if (! isfield (desc, "categories"))
     error ("the DESCRIPTION file must have a Categories field, when no INDEX file is given");
   endif
   categories = split_by (desc.categories, ",");
   if (length (categories) < 1)
       error ("the Category field is empty");
   endif
 
-  ## Write INDEX
+  ## Write INDEX.
   fid = fopen (index_file, "w");
   if (fid == -1)
     error ("couldn't open %s for writing.", index_file);
   endif
   fprintf (fid, "%s >> %s\n", desc.name, desc.title);
   fprintf (fid, "%s\n", categories{1});
   fprintf (fid, "  %s\n", functions{:});
   fclose (fid);
 endfunction
 
 function bad_deps = get_unsatisfied_deps (desc, installed_pkgs_lst)
   bad_deps = {};
 
-  ## For each dependency
+  ## For each dependency.
   for i = 1:length (desc.depends)
     dep = desc.depends{i};
 
     ## Is the current dependency Octave?
     if (strcmp (dep.package, "octave"))
       if (! compare_versions (OCTAVE_VERSION, dep.version, dep.operator))
         bad_deps{end+1} = dep;
       endif
-    ## Is the current dependency not Octave?
+      ## Is the current dependency not Octave?
     else
       ok = false;
       for i = 1:length (installed_pkgs_lst)
 	cur_name = installed_pkgs_lst{i}.name;
 	cur_version = installed_pkgs_lst{i}.version;
 	if (strcmp (dep.package, cur_name)
 	    && compare_versions (cur_version, dep.version, dep.operator))
 	  ok = true;
@@ -1835,31 +1835,31 @@ function bad_deps = get_unsatisfied_deps
       if (! ok)
         bad_deps{end+1} = dep;
       endif
     endif
   endfor
 endfunction
 
 function [out1, out2] = installed_packages (local_list, global_list)
-  ## Get the list of installed packages
+  ## Get the list of installed packages.
   try
     local_packages = load (local_list).local_packages;
   catch
     local_packages = {};
   end_try_catch
   try
     global_packages = load (global_list).global_packages;
   catch
     global_packages = {};
   end_try_catch
   installed_pkgs_lst = {local_packages{:}, global_packages{:}};
 
   ## Eliminate duplicates in the installed package list.
-  ## Locally installed packages take precedence
+  ## Locally installed packages take precedence.
   dup = [];
   for i = 1:length (installed_pkgs_lst)
     if (find (dup, i))
       continue;
     endif
     for j = (i+1):length (installed_pkgs_lst)
       if (find (dup, j))
 	continue;
@@ -1868,17 +1868,17 @@ function [out1, out2] = installed_packag
 	dup = [dup, j];
       endif
     endfor
   endfor
   if (! isempty(dup))
     installed_pkgs_lst(dup) = [];
   endif  
 
-  ## Now check if the package is loaded
+  ## Now check if the package is loaded.
   tmppath = strrep (path(), "\\", "/");
   for i = 1:length (installed_pkgs_lst)
     if (findstr (tmppath, strrep (installed_pkgs_lst{i}.dir, "\\", "/")))
       installed_pkgs_lst{i}.loaded = true;
     else
       installed_pkgs_lst{i}.loaded = false;
     endif
   endfor
@@ -1902,24 +1902,24 @@ function [out1, out2] = installed_packag
     out1 = local_packages;
     out2 = global_packages;
     return;
   elseif (nargout == 1)
     out1 = installed_pkgs_lst;
     return;
   endif
 
-  ## We shouldn't return something, so we'll print something
+  ## We shouldn't return something, so we'll print something.
   num_packages = length (installed_pkgs_lst);
   if (num_packages == 0)
     printf ("no packages installed.\n");
     return;
   endif
 
-  ## Compute the maximal lengths of name, version, and dir
+  ## Compute the maximal lengths of name, version, and dir.
   h1 = "Package Name";
   h2 = "Version";
   h3 = "Installation directory";
   max_name_length = length (h1); 
   max_version_length = length (h2);
   names = cell (num_packages, 1); 
   for i = 1:num_packages
     max_name_length = max (max_name_length,
@@ -1932,25 +1932,25 @@ function [out1, out2] = installed_packag
 					     max_version_length - 7;
   if (max_dir_length < 20)
      max_dir_length = Inf;
   endif
 
   h1 = postpad (h1, max_name_length + 1, " ");
   h2 = postpad (h2, max_version_length, " ");;
 
-  ## Print a header
+  ## Print a header.
   header = sprintf("%s | %s | %s\n", h1, h2, h3);
   printf (header);
   tmp = sprintf (repmat ("-", 1, length(header)-1));
   tmp(length(h1)+2) = "+";
   tmp(length(h1)+length(h2)+5) = "+";
   printf ("%s\n", tmp);
 
-  ## Print the packages
+  ## Print the packages.
   format = sprintf ("%%%ds %%1s| %%%ds | %%s\n", max_name_length,
 		    max_version_length);
   [dummy, idx] = sort (names);
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
@@ -1971,102 +1971,103 @@ function [out1, out2] = installed_packag
     printf (format, cur_name, cur_loaded, cur_version, cur_dir);
   endfor
 endfunction
 
 function load_packages (files, handle_deps, local_list, global_list)
   installed_pkgs_lst = installed_packages (local_list, global_list);
   num_packages = length (installed_pkgs_lst);
 
-  ## Read package names and installdirs into a more convenient format
+  ## Read package names and installdirs into a more convenient format.
   pnames = pdirs = cell (1, num_packages);
   for i = 1:num_packages
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
   endfor
 
-  ## load all
+  ## Load all.
   if (length (files) == 1 && strcmp (files{1}, "all"))
     idx = [1:length(installed_pkgs_lst)];
-  ## load auto
+  ## Load auto.
   elseif (length (files) == 1 && strcmp (files{1}, "auto")) 
     idx = [];
     for i = 1:length (installed_pkgs_lst)
       if (exist (fullfile (pdirs{i}, "packinfo", ".autoload"), "file"))
 	idx (end + 1) = i;
       endif
     endfor
-  ## load package_name1 ...
+  ## Load package_name1 ...
   else
     idx = [];
     for i = 1:length (files)
       idx2 = find (strcmp (pnames, files{i}));
       if (! any (idx2))
 	  error ("package %s is not installed", files{i});
       endif
       idx (end + 1) = idx2;
     endfor
   endif
 
-  ## Load the packages, but take care of the ordering of dependencies
+  ## Load the packages, but take care of the ordering of dependencies.
   load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst, true);
 endfunction
 
 function unload_packages (files, handle_deps, local_list, global_list)
   installed_pkgs_lst = installed_packages (local_list, global_list);
   num_packages = length (installed_pkgs_lst);
 
-  ## Read package names and installdirs into a more convenient format
+  ## Read package names and installdirs into a more convenient format.
   pnames = pdirs = cell (1, num_packages);
   for i = 1:num_packages
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
     pdeps{i} = installed_pkgs_lst{i}.depends;
   endfor
 
-  ## Get the current octave path
+  ## Get the current octave path.
   p = split_by (path(), pathsep ());
 
-  ## unload all
   if (length (files) == 1 && strcmp (files{1}, "all"))
-      dirs = pdirs;
-      desc = installed_pkgs_lst;
-  ## unload package_name1 ...
+    ## Unload all.
+    dirs = pdirs;
+    desc = installed_pkgs_lst;
   else
+    ## Unload package_name1 ...
     dirs = {};
     desc = {};
     for i = 1:length (files)
       idx = strcmp (pnames, files{i});
       if (! any (idx))
 	error ("package %s is not installed", files{i});
       endif
 	dirs{end+1} = pdirs{idx};
         desc{end+1} = installed_pkgs_lst{idx};
       endfor
   endif
 
-  ## Check for architecture dependent directories
+  ## Check for architecture dependent directories.
   archdirs = {};
   for i = 1:length (dirs)
     tmpdir = getarchdir (desc{i});
     if (exist (tmpdir, "dir"))
       archdirs{end+1} = dirs{i};
       archdirs{end+1} = tmpdir;
     else
       archdirs{end+1} = dirs{i};
     endif
   endfor
 
-  ## Unload the packages
+  ## Unload the packages.
   for i = 1:length (archdirs)
     d = archdirs{i};
     idx = strcmp (p, d);
     if (any (idx))
       rmpath (d);
-      ## FIXME: We should also check if we need to remove items from EXEC_PATH
+      ## FIXME: We should also check if we need to remove items from
+      ## EXEC_PATH.
     endif
   endfor
 endfunction
 
 function [status_out, msg_out] = rm_rf (dir)
   if (exist (dir))
     crr = confirm_recursive_rmdir ();
     unwind_protect
@@ -2182,17 +2183,17 @@ function newdesc = save_order (desc)
       endfor
       if (! isempty (tmpdesc))					     
         newdesc = {newdesc{:}, save_order(tmpdesc){:}, desc{i}};
       else
         newdesc{end+1} = desc{i};
       endif
     endif
   endfor
-  ## Eliminate the duplicates
+  ## Eliminate the duplicates.
   idx = [];
   for i = 1 : length (newdesc)
     for j = (i + 1) : length (newdesc)
       if (strcmp (newdesc{i}.name, newdesc{j}.name))
         idx (end + 1) = j;
       endif
     endfor
   endfor
@@ -2214,22 +2215,22 @@ function load_packages_and_dependencies 
     if (exist (tmpdir, "dir"))
       dirs{end + 1} = tmpdir;
       if (exist (fullfile (dirs{end}, "bin"), "dir"))
         execpath = cstrcat (fullfile (dirs{end}, "bin"), ":", execpath);
       endif
     endif
   endfor
 
-  ## Load the packages
+  ## Load the packages.
   if (length (dirs) > 0)
     addpath (dirs{:});
   endif
 
-  ## Add the binaries to exec_path
+  ## Add the binaries to exec_path.
   if (! strcmp (EXEC_PATH, execpath))
     EXEC_PATH (execpath);
   endif
 endfunction
 
 function idx = load_package_dirs (lidx, idx, handle_deps, installed_pkgs_lst)
   for i = lidx
     if (isfield (installed_pkgs_lst{i}, "loaded") &&
diff --git a/scripts/plot/__errplot__.m b/scripts/plot/__errplot__.m
--- a/scripts/plot/__errplot__.m
+++ b/scripts/plot/__errplot__.m
@@ -59,23 +59,23 @@ function h = __errplot__ (fstr, p, a1, a
 			       {"x", "y", "l", "u", "xl", "xu"});
 
     if (isempty (fmt.color))
       hl = __line__ (hg, "color", __next_line_color__ ());
     else
       hl = __line__ (hg, "color", fmt.color);
     endif
 
-    ## FIXME
-    ## Note the below adds the errorbar data directly as ldata, etc 
-    ## properties of the line objects, as gnuplot can handle this.
-    ## Matlab has the errorbar part of the plot as a special line object
-    ## with embedded NaNs that draws the three segments of the bar
-    ## separately. Should we duplicate Matlab's behavior and stop using the
-    ## ldata, etc properties of the line objects that are Octace specific?
+    ## FIXME -- note the code below adds the errorbar data directly as
+    ## ldata, etc properties of the line objects, as gnuplot can handle
+    ## this.  Matlab has the errorbar part of the plot as a special line
+    ## object with embedded NaNs that draws the three segments of the
+    ## bar separately.  Should we duplicate Matlab's behavior and stop
+    ## using the ldata, etc. properties of the line objects that are
+    ## Octace specific?
 
     switch (nargin - 2)
       case 1
 	error ("error plot requires 2, 3, 4 or 6 columns");
       case 2
 	set (hl, "xdata", (1:len)');
 	set (hl, "ydata", a1(:,i));
 	set (hl, "ldata", a2(:,i));
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -925,48 +925,48 @@ function __go_draw_axes__ (h, plot_strea
  	    fprintf (plot_stream,
  		     "set label \"%s\" at %s %.15g,%.15g %s rotate by %f %s %s front %s;\n",
  		     undo_string_escapes (label), units,
  		     lpos(1), lpos(2), halign, angle, fontspec,
 		     __do_enhanced_option__ (enhanced, obj), colorspec);
 	  endif
 
         case "hggroup"
-	  # push group children into the kid list
+	  ## Push group children into the kid list.
 	  if (isempty (kids))
 	    kids = obj.children;
 	  elseif (! isempty (obj.children))
 	    kids = [obj.children; kids];
 	  endif
 
 	otherwise
 	  error ("__go_draw_axes__: unknown object class, %s",
 		 obj.type);
       endswitch
 
     endwhile
 
     ## This is need to prevent warnings for rotations in 3D plots, while
-    ## allowing colorbars with contours..
+    ## allowing colorbars with contours.
     if (nd == 2 || (data_idx > 1 && !view_map))
       fputs (plot_stream, "set pm3d implicit;\n");
     else
       fputs (plot_stream, "set pm3d explicit;\n");
     endif
 
     if (isnan(hidden_removal) || hidden_removal)
       fputs (plot_stream, "set hidden3d;\n");
     else
       fputs (plot_stream, "unset hidden3d;\n");
     endif
 
     have_data = (! (isempty (data) || all (cellfun (@isempty, data))));
 
     ## Note we don't use the [xy]2range of gnuplot as we don't use the
-    ## dual axis plotting features of gnuplot
+    ## dual axis plotting features of gnuplot.
     if (isempty (xlim))
       return;
     endif
     if (strcmpi (axis_obj.xdir, "reverse"))
       xdir = "reverse";
     else
       xdir = "noreverse";
     endif
@@ -1096,18 +1096,18 @@ function __go_draw_axes__ (h, plot_strea
 	  pos = "left top";
 	case "southeast"
 	  pos = "right bottom";
 	case "southwest"
 	  pos = "left bottom";
 	case "best" 
 	  pos = "";
 	  warning ("legend: 'Best' not yet implemented for location specifier.\n");
-	  ## least conflict with data in plot
-	  ## least unused space outside plot
+	  ## Least conflict with data in plot.
+	  ## Least unused space outside plot.
 	otherwise
 	  pos = "";
       endswitch
       fprintf (plot_stream, "set key %s %s %s %s;\n", inout, pos, box, reverse);
     else
       fputs (plot_stream, "unset key;\n");
     endif
 
@@ -1173,17 +1173,17 @@ function __go_draw_axes__ (h, plot_strea
 	  __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i), 
 				  have_cdata(i));
 	endif
       endfor
     else
       fputs (plot_stream, "plot \"-\";\nInf Inf\ne\n");
     endif
 
-    ## Needed to allow mouse rotation with pcolor
+    ## Needed to allow mouse rotation with pcolor.
     if (view_map)
       fputs (plot_stream, "unset view;\n");
     endif
 
     fflush (plot_stream);
 
   else
     print_usage ();
@@ -1692,23 +1692,23 @@ function str = __tex2enhanced__ (str, fn
 	    		  str(s(i) + length (flds{j}) + 1:end));
 	    break;
 	  endif
 	endfor
       endif
     endif
   endfor
 
-  ## Prepend @ to things  things like _0^x or _{-100}^{100} for alignment
-  ## But need to put the shorter of the two arguments first. Carful of 
-  ## nested {} and unprinted characters when defining shortest.. Don't 
-  ## have to worry about things like ^\theta as they are already converted to
-  ## ^{/Symbol q}.
+  ## Prepend @ to things  things like _0^x or _{-100}^{100} for
+  ## alignment But need to put the shorter of the two arguments first.
+  ## Carful of nested {} and unprinted characters when defining
+  ## shortest.. Don't have to worry about things like ^\theta as they
+  ## are already converted to ^{/Symbol q}.
 
-  ## FIXME.. This is a mess... Is it worth it just for a "@" character?
+  ## FIXME -- This is a mess... Is it worth it just for a "@" character?
 
   [s, m] = regexp(str,'[_\^]','start','matches');
   i = 1;
   p = 0;
   while (i < length (s))
     if (i < length(s))
       if (str(s(i) + p + 1) == "{")
 	s1 = strfind(str(s(i) + p + 2:end),'{');
@@ -1740,36 +1740,36 @@ function str = __tex2enhanced__ (str, fn
 		li++;
 	      else
 		si++;
 	      endif
 	    endwhile
 	    l2 = l2 (min (length(l2), si));
 	    if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
 		length_string(str(s(i+1)+p+2:s(i+1)+p+l2-1)))
-	      ## shortest already first!
+	      ## Shortest already first!
 	      str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
 	    else
-	      ## Have to swap sub/super-script to get shortest first
+	      ## Have to swap sub/super-script to get shortest first.
 	      str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
 			    str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
 	    endif
 	  else
-	    ## Have to swap sub/super-script to get shortest first
+	    ## Have to swap sub/super-script to get shortest first.
 	    str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
 			  str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
 	  endif
           i += 2;
 	  p ++;
 	else
 	  i++;
 	endif
       else
 	if (s(i+1) == s(i) + 2)
-	  ## shortest already first!
+	  ## Shortest already first!
 	  str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
 	  p ++;
           i += 2;
 	else
 	  i ++;
 	endif
       endif
     else
diff --git a/scripts/plot/__stem__.m b/scripts/plot/__stem__.m
--- a/scripts/plot/__stem__.m
+++ b/scripts/plot/__stem__.m
@@ -102,17 +102,17 @@ function h = __stem__ (have_z, varargin)
 	  set (h_baseline, "handlevisibility", "off");
 	  set (h_baseline, "xliminclude", "off");
 	  addlistener (ax, "xlim", @update_xlim);
 	  addlistener (h_baseline, "ydata", @update_baseline);
 	  addlistener (h_baseline, "visible", @update_baseline);
 	endif
       endif
 
-      ## Setup the hggroup and listeners
+      ## Setup the hggroup and listeners.
       addproperty ("showbaseline", hg, "radio", "{on}|off");
       addproperty ("basevalue", hg, "data", 0);
       addproperty ("baseline", hg, "data", h_baseline);
 
       if (!have_z)
 	addlistener (hg, "showbaseline", @show_baseline);
 	addlistener (hg, "basevalue", @move_baseline); 
       endif
@@ -154,71 +154,77 @@ function h = __stem__ (have_z, varargin)
   unwind_protect_cleanup
     set (ax, "nextplot", hold_state);
     axes (oldax);
   end_unwind_protect
 endfunction
 
 function [x, y, z, dofill, lc, ls, mc, ms, newargs] = check_stem_arg (have_z, varargin)
 
+  ## FIXME -- there seems to be a lot of duplicated code in this
+  ## function.  It seems like it should be possible to simplify things
+  ## by combining some of the nearly identical code sections into
+  ## additional subfunctions.
+
   if (have_z)
     caller = "stem3";
   else
     caller = "stem";
   endif
 
-  ## Remove prop/val pairs from data to consider
+  ## Remove prop/val pairs from data to consider.
   i = 2;
   newargs = {};
   while (i < length (varargin))
     if (ischar (varargin{i}) && !(strcmpi ("fill", varargin{i})
 				  || strcmpi ("filled", varargin{i})))
       newargs{end + 1} = varargin{i};
       newargs{end + 1} = varargin{i + 1};
       nargin = nargin - 2;
       varargin(i:i+1) = [];
     else
       i++;
     endif
   endwhile
 
-  ## set specifiers to default values
+  ## set specifiers to default values.
   [lc, ls, mc, ms] = set_default_values ();
   dofill = 0;
   fill_2 = 0;
   linespec_2 = 0;
   z = [];
 
-  ## check input arguments
+  ## Check input arguments.
   if (nargin == 2)
     if (have_z)
       z = varargin{1};
       x = 1:rows (z);
       y = 1:columns (z);
     else
       y = varargin{1};
       if (isvector (y))
 	x = 1:length (y);
       elseif (ismatrix (y))
 	x = 1:rows (y);
       else 
 	error ("stem: Y must be a matrix");
       endif # in each case, x & y will be defined
     endif
   elseif (nargin == 3)
-    ## several possibilities
+    ## Several possibilities
+    ##
     ## 1. the real y data
     ## 2. 'filled'
     ## 3. line spec
     if (ischar (varargin{2}))
-      ## only 2. or 3. possible
+      ## Only 2. or 3. possible.
       if (strcmpi ("fill", varargin{2}) || strcmpi ("filled", varargin{2}))
 	dofill = 1;
       else
-	## parse the linespec
+	## Parse the linespec.
 	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
       endif
       if (have_z)
 	z = varargin{1};
 	x = 1:rows (z);
 	y = 1:columns (z);
       else
 	y = varargin{1};
@@ -229,37 +235,38 @@ function [x, y, z, dofill, lc, ls, mc, m
 	else
 	  error ("stem: Y must be a matrix");
 	endif # in each case, x & y will be defined
       endif
     else
       if (have_z)
 	error ("stem3: must define X, Y and Z");
       else
-	## must be the real y data
+	## Must be the real y data.
 	x = varargin{1};
 	y = varargin{2};
 	if (! (ismatrix (x) && ismatrix (y)))
 	  error ("stem: X and Y must be matrices");
 	endif
       endif
     endif
   elseif (nargin == 4)
-    ## again several possibilities
+    ## Again, several possibilities:
+    ##
     ## arg2 1. real y
     ## arg2 2. 'filled' or linespec
     ## arg3 1. real z
     ## arg3 2. 'filled' or linespec
     if (ischar (varargin{2}))
-      ## only arg2 2. / arg3 1. & arg3 3. are possible
+      ## Only arg2 2. / arg3 1. & arg3 3. are possible.
       if (strcmpi ("fill", varargin{2}) || strcmpi ("filled", varargin{2}))
 	dofill = 1;
-	fill_2 = 1; # be sure, no second "fill" is in the arguments
+	fill_2 = 1; # Be sure, no second "fill" is in the arguments.
       else
-	## must be a linespec
+	## Must be a linespec.
 	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
 	linespec_2 = 1;
       endif
       if (have_z)
 	z = varargin{1};
 	x = 1:rows (z);
 	y = 1:columns (z);
       else
@@ -276,41 +283,41 @@ function [x, y, z, dofill, lc, ls, mc, m
       if (have_z)
 	x = varargin{1};
 	y = varargin{2};
 	z = varargin{3};
 	if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
 	  error ("stem3: X, Y and Z must be matrices");
 	endif
       else
-	## must be the real y data
+	## must be the real y data.
 	x = varargin{1};
 	y = varargin{2};
 	if (! (ismatrix (x) && ismatrix (y)))
 	  error ("stem: X and Y must be matrices");
 	endif
       endif
     endif # if ischar(varargin{2})
     if (! have_z)
-      ## varargin{3} must be char
-      ## check for "fill
+      ## varargin{3} must be char.
+      ## Check for "fill.
       if ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
 	  && fill_2)
 	error ("stem: duplicate fill argument");
       elseif (strcmpi ("fill", varargin{3}) && linespec_2)
-	## must be "fill"
+	## Must be "fill".
 	dofill = 1;
 	fill_2 = 1;
       elseif ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
 	  && !linespec_2)
-	## must be "fill"
+	## Must be "fill".
 	dofill = 1;
 	fill_2 = 1;
       elseif (! linespec_2)
-	## must be linespec
+	## Must be linespec.
 	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
 	linespec_2 = 1;
       endif
     endif
   elseif (nargin == 5)
     if (have_z)
       x = varargin{1};
       y = varargin{2};
@@ -324,76 +331,76 @@ function [x, y, z, dofill, lc, ls, mc, m
       if (! (ismatrix (x) && ismatrix (y)))
 	error ("stem: X and Y must be matrices");
       endif
     endif
 
     if (! have_z)
       if (strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
 	dofill = 1;
-	fill_2 = 1; # be sure, no second "fill" is in the arguments
+	fill_2 = 1; # Be sure, no second "fill" is in the arguments.
       else
-	## must be a linespec
+	## Must be a linespec.
 	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
 	linespec_2 = 1;
       endif
     endif
 
-    ## check for "fill" ..
+    ## Check for "fill".
     if ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
 	&& fill_2)
       error ("%s: duplicate fill argument", caller);
     elseif ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
 	&& linespec_2)
-      ## must be "fill"
+      ## Must be "fill".
       dofill = 1;
       fill_2 = 1;
     elseif (!strcmpi (varargin{4}, "fill") && !strcmpi (varargin{4}, "filled")
 	&& !linespec_2)
-      ## must be linespec
+      ## Must be linespec.
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
       linespec_2 = 1;
     endif
   elseif (nargin == 6 && have_z)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
       error ("stem3: X, Y and Z must be matrices");
     endif
 
     if (strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
       dofill = 1;
       fill_2 = 1; # be sure, no second "fill" is in the arguments
     else
-      ## must be a linespec
+      ## Must be a linespec.
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
       linespec_2 = 1;
     endif
 
     ## check for "fill" ..
     if ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
 	&& fill_2)
       error ("stem3: duplicate fill argument");
     elseif ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
 	&& linespec_2)
-      ## must be "fill"
+      ## Must be "fill".
       dofill = 1;
       fill_2 = 1;
     elseif (!strcmpi (varargin{5}, "fill") && !strcmpi (varargin{5}, "filled")
 	    && !linespec_2)
-      ## must be linespec
+      ## Must be linespec.
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{5});
       linespec_2 = 1;
     endif
   else
     error ("%s: incorrect number of arguments", caller);
   endif
 
-  ## Check sizes of x, y and z
+  ## Check sizes of x, y and z.
   if (have_z)
     if (!size_equal (x, y, z))
       error ("stem3: inconsistent size of x, y and z");
     else
       x = x(:);
       y = y(:);
       z = z(:);
     endif
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -134,17 +134,18 @@ function h = findobj (varargin)
 	  property(np) = 1;
 	  pname{np} = args{na};
 	  na = na + 1;
 	  pvalue{np} = [];
 	  np = np + 1;
 	else
 	  error ("findobj: inconsistent number of arguments");
 	endif
-      elseif (! strcmp (args{na}(1), "-")) # parameter/value pairs
+      elseif (! strcmp (args{na}(1), "-"))
+	## Parameter/value pairs.
 	if (na + 1 <= numel (args))
 	  pname{np} = args{na};
 	  na = na + 1;
 	  pvalue{np} = args{na};
 	  na = na + 1;
 	  if (na <= numel(args))
 	    if (ischar (args{na}))
 	      if strcmpi(args{na}, "-and")
@@ -166,31 +167,31 @@ function h = findobj (varargin)
 	  else
 	    logicaloperator{np} = "and";
 	  endif
 	  np = np + 1;
 	else
 	  error ("findobj: inconsistent number of arguments");
 	endif
       else
-	## this is sloppy ... but works like matlab
+	## This is sloppy ... but works like Matlab.
 	if strcmpi(args{na}, "-not")
 	  h = [];
 	  return
 	endif
 	na = na + 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
   endwhile
 
   numpairs = np - 1;
   
-  ## load all objects which qualify for being searched
+  ## Load all objects which qualify for being searched.
   idepth = 0;
   h = handles;
   while (numel (handles) && ! (idepth >= depth))
     children = [];
     for n = 1 : numel (handles)
       children = union (children, get(handles(n), "children"));
     endfor 
     handles = children;
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -179,30 +179,32 @@ function [tf, a_idx] = ismember (a, s, r
     print_usage ();
   endif
 
 endfunction
 
 function [tf, a_idx] = cell_ismember (a, s)
   if (nargin == 2)
     if (ischar (a) && iscellstr (s)) 
-      if (isempty (a)) # Work around bug in 'cellstr' 
+      if (isempty (a))
+	## Work around bug in cellstr.
         a = {''};
       else
         a = cellstr (a);
       endif
     elseif (iscellstr (a) && ischar (s))
-      if (isempty (s)) # Work around bug in 'cellstr' 
+      if (isempty (s))
+	## Work around bug in cellstr.
         s = {''};
       else
         s = cellstr (s);
       endif
     endif 
     if (iscellstr (a) && iscellstr (s))
-      ## Do the actual work
+      ## Do the actual work.
       if (isempty (a) || isempty (s))
         tf = zeros (size (a), "logical");
         a_idx = zeros (size (a)); 
       elseif (numel (s) == 1) 
         tf = strcmp (a, s);
         a_idx = double (tf);
       elseif (numel (a) == 1) 
         f = find (strcmp (a, s), 1); 
@@ -225,17 +227,17 @@ function [tf, a_idx] = cell_ismember (a,
         a_idx(tf) = sidx(idx(tf));
       endif
     else
       error ("cell_ismember: arguments must be cell arrays of character strings");
     endif
   else
     print_usage ();
   endif
-  ## Resize result to the original size of 'a' 
+  ## Resize result to the original size of A.
   size_a = size (a);
   tf = reshape (tf, size_a); 
   a_idx = reshape (a_idx, size_a); 
 endfunction
 
 %!assert (ismember ({''}, {'abc', 'def'}), false);
 %!assert (ismember ('abc', {'abc', 'def'}), true);
 %!assert (isempty (ismember ([], [1, 2])), true);
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -61,17 +61,18 @@ function x = arma_rnd (a, b, v, t, n)
   endif
 
   ar = length (a);
   br = length (b);
 
   a = reshape (a, ar, 1);
   b = reshape (b, br, 1);
 
-  a = [1; -a];                        # apply our notational convention
+  ## Apply our notational convention.
+  a = [1; -a];
   b = [1; b];
 
   n = min (n, ar + br);
 
   e = sqrt (v) * randn (t + n, 1);
 
   x = filter (b, a, e);
   x = x(n + 1 : t + n);
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -112,19 +112,21 @@ function [h_r, f_r] = freqz (b, a, n, re
     else 
       Fs = 2*pi; 
     endif
   endif
 
   a = a(:);
   b = b(:);
 
-  if (! isscalar (n)) ## Explicit frequency vector given
+  if (! isscalar (n))
+    ## Explicit frequency vector given
     w = f = n;
-    if (nargin == 4)  ## Sampling rate Fs was specified
+    if (nargin == 4)
+      ## Sampling rate Fs was specified
       w = 2*pi*f/Fs;
     endif
     k = max (length (b), length (a));
     hb = polyval (postpad (b, k), exp (j*w));
     ha = polyval (postpad (a, k), exp (j*w));
   elseif (strcmp (region, "whole"))
     f = Fs * (0:n-1)' / n;
     ## polyval(fliplr(P),exp(jw)) is O(p n) and fft(x) is O(n log(n)),
@@ -137,20 +139,22 @@ function [h_r, f_r] = freqz (b, a, n, re
   else
     f = Fs/2 * (0:n-1)' / n;
     hb = fft (postpad (b, 2*n))(1:n);
     ha = fft (postpad (a, 2*n))(1:n);
   endif
 
   h = hb ./ ha;
 
-  if (nargout != 0), # return values and don't plot
+  if (nargout != 0)
+    ## Return values and don't plot.
     h_r = h;
     f_r = f;
-  else             # plot and don't return values
+  else
+    ## Plot and don't return values.
     freqz_plot (f, h);
   endif
 
 endfunction
 
 %!test # correct values and fft-polyval consistency
 %! # butterworth filter, order 2, cutoff pi/2 radians
 %! b = [0.292893218813452  0.585786437626905  0.292893218813452];
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -51,17 +51,17 @@
 ## synthesis function.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Short-term Fourier transform
 
 function [Y, c] = stft(X, win, inc, coef, w_type)
 
-  ## default values of unspecified arguments
+  ## Default values of unspecified arguments.
   if (nargin < 5)
     w_type = 1;
     if (nargin < 4)
       coef = 64;
       if (nargin < 3)
         inc = 24;
         if (nargin < 2)
           win = 80;
@@ -79,17 +79,17 @@ function [Y, c] = stft(X, win, inc, coef
       else
         error ("stft: unknown window type `%s'", w_type);
       endif
     endif
   else
     print_usage ();
   endif
 
-  ## check whether X is a vector
+  ## Check whether X is a vector.
   [nr, nc] = size (X);
   if (nc != 1)
     if (nr == 1)
       X = X';
       nr = nc;
     else
       error ("stft: X must be a vector");
     endif
@@ -98,25 +98,28 @@ function [Y, c] = stft(X, win, inc, coef
   num_coef = 2 * coef;
   if (win > num_coef)
     win = num_coef;
     printf ("stft: window size adjusted to %f\n", win);
   endif
   num_win = fix ((nr - win) / inc);
 
   ## compute the window coefficients
-  if (w_type == 3)              # rectangular window
+  if (w_type == 3)
+    ## Rectangular window.
     WIN_COEF = ones (win, 1);
-  elseif (w_type == 2)          # Hamming window
+  elseif (w_type == 2)
+    ## Hamming window.
     WIN_COEF = hamming (win);
-  else                          # Hanning window
+  else
+    ## Hanning window.
     WIN_COEF = hanning (win);
   endif
 
-  ## create a matrix Z whose columns contain the windowed time-slices
+  ## Create a matrix Z whose columns contain the windowed time-slices.
   Z = zeros (num_coef, num_win + 1);
   start = 1;
   for i = 0:num_win
     Z(1:win, i+1) = X(start:start+win-1) .* WIN_COEF;
     start = start + inc;
   endfor
 
   Y = fft (Z);
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -247,23 +247,26 @@ endif
   endif
 
   preconditioned_residual_out = false;
   if (nargout > 5)
     T = zeros (maxit, maxit);
     preconditioned_residual_out = true;
   endif
 
-  matrix_positive_definite = true;	# assume A is positive definite
+  ## Assume A is positive definite.
+  matrix_positive_definite = true;
 
   p = zeros (size (b));
   oldtau = 1; 
-  if (isnumeric (A))			# is A a matrix?
+  if (isnumeric (A))
+    ## A is a matrix.
     r = b - A*x; 
-  else					# then A should be a function!
+  else
+    ## A should be a function.
     r = b - feval (A, x, varargin{:});
   endif
 
   resvec(1,1) = norm (r);
   alpha = 1;
   iter = 2;
 
   while (resvec (iter-1,1) > tol * resvec (1,1) && iter < maxit)
@@ -285,24 +288,28 @@ endif
     else
       z = y;
     endif
     tau = z' * r; 
     resvec (iter-1,2) = sqrt (tau);
     beta = tau / oldtau;
     oldtau = tau;
     p = z + beta * p;
-    if (isnumeric (A))		# is A a matrix?
+    if (isnumeric (A))
+      ## A is a matrix.
       w = A * p;
-    else			# then A should be a function!
+    else
+      ## A should be a function.
       w = feval (A, p, varargin{:});
     endif
-    oldalpha = alpha; 		# needed only for eigest
+    ## Needed only for eigest.
+    oldalpha = alpha;
     alpha = tau / (p'*w);
-    if (alpha <= 0.0) # negative matrix?
+    if (alpha <= 0.0)
+      ## Negative matrix.
       matrix_positive_definite = false;
     endif
     x += alpha * p;
     r -= alpha * w;
     if (nargout > 5 && iter > 2)
       T(iter-1:iter, iter-1:iter) = T(iter-1:iter, iter-1:iter) + ...
 	  [1 sqrt(beta); sqrt(beta) beta]./oldalpha;
       ## EVS = eig(T(2:iter-1,2:iter-1));
@@ -322,18 +329,18 @@ endif
       else
 	eigest = [NaN, NaN];
 	warning ("pcg: eigenvalue estimate failed: iteration converged too fast.");
       endif
     else
       eigest = [NaN, NaN];
     endif
 
-    ## apply the preconditioner once more and finish with the precond
-    ## residual
+    ## Apply the preconditioner once more and finish with the precond
+    ## residual.
     if (existM1)
       if(isnumeric (M1))
 	y = M1 \ r;
       else
 	y = feval (M1, r, varargin{:});
       endif
     else
       y = r;
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -44,17 +44,19 @@ function S = sprandsym (n, d)
     n1 = m1 + rem (n, 2);
     mn1 = m1*n1;
     k1 = round (d*mn1);
     idx1 = unique (fix (rand (min (k1*1.01, k1+10), 1) * mn1)) + 1; 
     ## idx contains random numbers in [1,mn] generate 1% or 10 more
     ## random values than necessary in order to reduce the probability
     ## that there are less than k distinct values; maybe a better
     ## strategy could be used but I don't think it's worth the price.
-    k1 = min (length (idx1), k1);  # actual number of entries in S
+
+    ## Actual number of entries in S.
+    k1 = min (length (idx1), k1);
     j1 = floor ((idx1(1:k1)-1)/m1);
     i1 = idx1(1:k1) - j1*m1;
 
     n2 = ceil (n/2);
     nn2 = n2*n2;
     k2 = round (d*nn2);
     idx2 = unique (fix (rand (min (k2*1.01, k1+10), 1) * nn2)) + 1; 
     k2 = min (length (idx2), k2);
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -28,63 +28,62 @@
 
 function [XCoordinate, YCoordinate, Height, s] = treelayout (Tree, Permutation)
   if (nargin < 1 || nargin > 2 || nargout > 4)
     print_usage ();
   elseif (! isvector (Tree) || rows (Tree) != 1 || ! isnumeric (Tree) 
         ||  any (Tree > length (Tree)) || any (Tree < 0) )
     error ("treelayout: the first input argument must be a vector of predecessors");
   else
-    ## make it a row vector
+    ## Make it a row vector.
     Tree = Tree(:)';
 
-    ## the count of nodes of the graph
+    ## The count of nodes of the graph.
     NodNumber = length (Tree);
-    ## the number of children
+    ## The number of children.
     ChildNumber = zeros (1, NodNumber + 1);
 
-
-    ## checking vector of predecessors
+    ## Checking vector of predecessors.
     for i = 1 : NodNumber
       if (Tree (i) < i)
-	## this part of graph was checked before
+	## This part of graph was checked before.
         continue;
       endif
 
-      ## Try to find cicle in this part of graph
-      ## we use modified Floyd's cycle-finding algorithm
+      ## Try to find cicle in this part of graph using modified Floyd's
+      ## cycle-finding algorithm.
       tortoise = Tree (i);
       hare = Tree (tortoise);
 
       while (tortoise != hare)
-	## we end after find a cicle or when we reach a checked part of graph
+	## End after finding a cicle or reaching a checked part of graph.
 
         if (hare < i)
-          ## this part of graph was checked before
+          ## This part of graph was checked before.
           break
         endif
 
         tortoise = Tree (tortoise);
-	## hare will move faster than tortoise so in cicle hare
-	## must reach tortoise
+	## Hare will move faster than tortoise so in cicle hare must
+	## reach tortoise.
         hare = Tree (Tree (hare));
 
       endwhile
 
       if (tortoise == hare)
-	## if hare reach tortoise we find cicle
+	## If hare reach tortoise we found circle.
         error ("treelayout: vector of predecessors has bad format");
       endif
 
     endfor
-    ## vector of predecessors has right format
+    ## Vector of predecessors has right format.
 
     for i = 1:NodNumber
       ## VecOfChild is helping vector which is used to speed up the
-      ## choose of descendant nodes
+      ## choice of descendant nodes.
 
       ChildNumber (Tree (i) + 1) = ChildNumber (Tree (i) + 1) + 1;
     endfor
 
     Pos = 1;
     for i = 1 : NodNumber + 1
       Start (i) = Pos;
       Help (i) = Pos;
@@ -96,108 +95,107 @@ function [XCoordinate, YCoordinate, Heig
       for i = 1 : NodNumber
         VecOfChild (Help (Tree (i) + 1)) = i;  
         Help (Tree (i) + 1) = Help (Tree (i) + 1) + 1;
       endfor
     else
       VecOfChild = Permutation;
     endif
 
-
-    ## the number of "parent" (actual) node (it's descendants will be
-    ## browse in the next iteration)
+    ## The number of "parent" (actual) node (it's descendants will be
+    ## browse in the next iteration).
     ParNumber = 0;
 
-    ## the x-coordinate of the left most descendant of "parent node"
-    ## this value is increased in each leaf		
+    ## The x-coordinate of the left most descendant of "parent node"
+    ## this value is increased in each leaf.
     LeftMost = 0;
 
-    ## the level of "parent" node (root level is NodNumber)
+    ## The level of "parent" node (root level is NodNumber).
     Level = NodNumber;
 
-    ## NodNumber - Max is the height of this graph
+    ## NodNumber - Max is the height of this graph.
     Max = NodNumber;
 
-    ## main stack - each item consists of two numbers - the number of
+    ## Main stack - each item consists of two numbers - the number of
     ## node and the number it's of parent node on the top of stack
-    ## there is "parent node"
+    ## there is "parent node".
     St = [-1, 0];
 
-    #number of vertices s in the top-level separator
+    ## Number of vertices s in the top-level separator.
     s = 0;
-    # flag which says if we are in top level separator
+    ## Flag which says if we are in top level separator.
     topLevel = 1;
-    ## the top of the stack
+    ## The top of the stack.
     while (ParNumber != -1)
       if (Start(ParNumber + 1) < Stop(ParNumber + 1))
         idx = VecOfChild (Start (ParNumber + 1) : Stop (ParNumber + 1) - 1);
       else
         idx = zeros (1, 0);
       endif
 
-      ## add to idx the vector of parent descendants
+      ## Add to idx the vector of parent descendants.
       St = [St ; [idx', ones(fliplr(size(idx))) * ParNumber]];
 
-      # we are in top level separator when we have one children
-      ## and the flag is 1
+      ## We are in top level separator when we have one child and the
+      ## flag is 1
       if (columns(idx) == 1 && topLevel ==1 )
         s += 1;
       else
-        # we arent in top level separator now
+        # We aren't in top level separator now.
         topLevel = 0;
       endif
-      ## if there is not any descendant of "parent node":
+      ## If there is not any descendant of "parent node":
       if (St(end,2) != ParNumber)
        LeftMost = LeftMost + 1;
        XCoordinateR(ParNumber) = LeftMost;           
        Max = min (Max, Level);
        if ((length(St) > 1) && (find((shift(St,1)-St) == 0) >1) 
 	   && St(end,2) != St(end-1,2))
-	  ## return to the nearest branching the position to return
+	  ## Return to the nearest branching the position to return
 	  ## position is the position on the stack, where should be
           ## started further search (there are two nodes which has the
-          ## same parent node)
+          ## same parent node).
 
           Position = (find ((shift (St(:, 2), 1) - St(:, 2)) == 0))(end)+1;
           ParNumberVec = St(Position : end, 2);
 
-          ## the vector of removed nodes (the content of stack form
-          ## position to end)
+          ## The vector of removed nodes (the content of stack form
+          ## position to end).
 
           Level = Level + length(ParNumberVec);
 
-	  ## the level have to be decreased
+	  ## The level have to be decreased.
 
           XCoordinateR(ParNumberVec) = LeftMost;
           St(Position:end, :) = [];
         endif	
 
-        ## remove the next node from "searched branch"
+        ## Remove the next node from "searched branch".
 
         St(end, :) = [];
-	## choose new "parent node"
+	## Choose new "parent node".
         ParNumber = St(end, 1);
-	## if there is another branch start to search it
+	## If there is another branch start to search it.
 	if (ParNumber != -1)
           YCoordinate(ParNumber) = Level;	
           XCoordinateL(ParNumber) = LeftMost + 1;
 	endif
       else
 
-        ## there were descendants of "parent nod" choose the last of
-        ## them and go on through it
+        ## There were descendants of "parent nod" choose the last of
+        ## them and go on through it.
         Level--;
         ParNumber = St(end, 1);
         YCoordinate(ParNumber) = Level;     
         XCoordinateL(ParNumber) = LeftMost+1;
       endif
     endwhile
 
-    ## calculate the x coordinates (the known values are the position
-    ## of most left and most right descendants)
+    ## Calculate the x coordinates (the known values are the position
+    ## of most left and most right descendants).
     XCoordinate = (XCoordinateL + XCoordinateR) / 2;
 
     Height = NodNumber - Max - 1;
   endif
 endfunction
 
 %!demo
 %! % Compute a simple tree layout 
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -41,43 +41,44 @@ function [x, m] = factor (n)
   if (nargin < 1)
     print_usage ();
   endif
 
   if (! isscalar (n) || n != fix (n))
     error ("factor: n must be a scalar integer");
   endif
 
-  ## special case of no primes less than sqrt(n)
+  ## Special case of no primes less than sqrt(n).
   if (n < 4)
     x = n;
     m = 1;
     return;
   endif 
 
   x = [];
   ## There is at most one prime greater than sqrt(n), and if it exists,
   ## it has multiplicity 1, so no need to consider any factors greater
   ## than sqrt(n) directly. [If there were two factors p1, p2 > sqrt(n),
   ## then n >= p1*p2 > sqrt(n)*sqrt(n) == n. Contradiction.]
   p = primes (sqrt (n));
   while (n > 1)
-    ## find prime factors in remaining n
+    ## Find prime factors in remaining n.
     q = n ./ p;
     p = p (q == fix (q));
     if (isempty (p))
-      p = n;  # can't be reduced further, so n must itself be a prime.
+      ## Can't be reduced further, so n must itself be a prime.
+      p = n;
     endif
     x = [x, p];
-    ## reduce n
+    ## Reduce n.
     n = n / prod (p);
   endwhile
   x = sort (x);
 
-  ## determine muliplicity
+  ## Determine muliplicity.
   if (nargout > 1)
     idx = find ([0, x] != [x, 0]);
     x = x(idx(1:length(idx)-1));
     m = diff (idx);
   endif
 
 endfunction
 
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -71,46 +71,47 @@ function A = nchoosek (v, k)
   if ((isscalar(v) && v < k) || k < 0
       || k != round(k) || any (v < 0 || v != round(v)))
     error ("nchoosek: args are nonnegative integers with V not less than K");
   endif
 
   n = length (v);
 
   if (n == 1)
-    k = min (k, v-k);		# improve precision at next step
+    ## Improve precision at next step.
+    k = min (k, v-k);
     A = round (prod ((v-k+1:v)./(1:k)));
     if (A*2*k*eps >= 0.5)
       warning ("nchoosek", "nchoosek: possible loss of precision");
     endif
   elseif (k == 0)
     A = [];
   elseif (k == 1)
     A = v(:);
   elseif (k == n)
     A = v(:).';
   elseif (k > n)
     A = zeros (0, k, class (v));
   else
     p = cell (1, k);
-    # hack: do the op in the smallest integer class possible to avoid moving
-    # too much data.
+    ## Hack: do the op in the smallest integer class possible to avoid
+    ## moving too much data.
     if (n < intmax ("uint8"))
       cl = "uint8";
     elseif (n < intmax ("uint16"))
       cl = "uint16";
     elseif (n < intmax ("uint32"))
       cl = "uint32";
     else
-      # This would exhaust memory anyway.
+      ## This would exhaust memory anyway.
       cl = "double";
     endif
      
-    # Use a generalized Pascal triangle. Traverse backwards to keep
-    # alphabetical order.
+    ## Use a generalized Pascal triangle. Traverse backwards to keep
+    ## alphabetical order.
     for i = 1:k
       p{i} = zeros (0, i, cl);
     endfor
     s = ones (1, 1, cl);
     p{1} = n*s;
     for j = n-1:-1:1
       for i = k:-1:2
 	q = p{i-1};
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -39,38 +39,38 @@ function x = primes (p)
     print_usage ();
   endif
 
   if (! isscalar (p))
     error ("primes: n must be a scalar");
   endif
 
   if (p > 100000)
-    ## optimization: 1/6 less memory, and much faster (asymptotically)
+    ## Optimization: 1/6 less memory, and much faster (asymptotically)
     ## 100000 happens to be the cross-over point for Paul's machine;
     ## below this the more direct code below is faster.  At the limit
     ## of memory in Paul's machine, this saves .7 seconds out of 7 for
     ## p=3e6.  Hardly worthwhile, but Dirk reports better numbers.
     lenm = floor ((p+1)/6);       # length of the 6n-1 sieve
     lenp = floor ((p-1)/6);       # length of the 6n+1 sieve
     sievem = ones (1, lenm);      # assume every number of form 6n-1 is prime
     sievep = ones (1, lenp);      # assume every number of form 6n+1 is prime
 
-    for i = 1:(sqrt(p)+1)/6         # check up to sqrt(p)
+    for i = 1:(sqrt(p)+1)/6       # check up to sqrt(p)
       if (sievem(i))              # if i is prime, eliminate multiples of i
         sievem(7*i-1:6*i-1:lenm) = 0;
         sievep(5*i-1:6*i-1:lenp) = 0;
       endif                       # if i is prime, eliminate multiples of i
       if (sievep(i))
         sievep(7*i+1:6*i+1:lenp) = 0;
         sievem(5*i+1:6*i+1:lenm) = 0;
       endif
     endfor
     x = sort([2, 3, 6*find(sievem)-1, 6*find(sievep)+1]);
-  elseif (p > 352) # nothing magical about 352; just has to be greater than 2
+  elseif (p > 352)                # nothing magical about 352; must be >2
     len = floor ((p-1)/2);        # length of the sieve
     sieve = ones (1, len);        # assume every odd number is prime
     for i = 1:(sqrt(p)-1)/2       # check up to sqrt(p)
       if (sieve(i))               # if i is prime, eliminate multiples of i
         sieve(3*i+1:2*i+1:len) = 0; # do it
       endif
     endfor
     x = [2, 1+2*find(sieve)];     # primes remaining after sieve
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -99,37 +99,37 @@ function q = quantile (x, p, dim, method
   if (nargin < 4)
     method = 5;
   endif
 
   if (dim > ndims(x))
     error ("quantile: invalid dimension.")
   endif
 
-  # Set the permutation vector.
+  ## Set the permutation vector.
   perm = 1:ndims(x);
   perm(1) = dim;
   perm(dim) = 1;
 
-  # Permute dim to the 1st index.
+  ## Permute dim to the 1st index.
   x = permute (x, perm);
 
-  # Save the size of the permuted x N-d array.
+  ## Save the size of the permuted x N-d array.
   sx = size (x);
 
-  # Reshape to a 2-d array.
+  ## Reshape to a 2-d array.
   x = reshape (x, [sx(1), prod(sx(2:end))]);
 
-  # Calculate the quantiles.
+  ## Calculate the quantiles.
   q = __quantile__ (x, p, method);
 
-  # Return the shape to the original N-d array.
+  ## Return the shape to the original N-d array.
   q = reshape (q, [numel(p), sx(2:end)]);
 
-  # Permute the 1st index back to dim.
+  ## Permute the 1st index back to dim.
   q = ipermute (q, perm);
 
 endfunction
 
 %!test
 %! p = 0.5;
 %! x = sort (rand (11));
 %! q = quantile (x, p);
diff --git a/scripts/statistics/base/values.m b/scripts/statistics/base/values.m
--- a/scripts/statistics/base/values.m
+++ b/scripts/statistics/base/values.m
@@ -35,17 +35,18 @@ function v = values (x)
     print_usage ();
   endif
 
   if (! (isvector (x)))
     error ("values: x must be a vector");
   endif
 
   i = any (isnan (x));
-  x = x(find(!isnan (x)));      # HACK!
+  ## HACK!
+  x = x(find(!isnan (x)));
   n = length (x);
   x = reshape (x, n, 1);
   s = sort (x);
   v = s([1; (find (s(2:n) > s(1:n-1)) + 1)]);
   if (i)
     v = [v; NaN];
   endif
 
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -101,36 +101,38 @@ function v = findstr (s, t, overlap)
     ## determine which ones to keep
     keep = zeros (size (v));
     ind = 0:l_t-1;
     if (overlap)
       for idx = 1:length (v)
 	keep(idx) = all (s(v(idx) + ind) == t);
       endfor
     else
-      next = 1; # first possible position for next non-overlapping match
+      ## First possible position for next non-overlapping match.
+      next = 1;
       for idx = 1:length (v)
 	if (v(idx) >= next && s(v(idx) + ind) == t)
 	  keep(idx) = 1;
-	  next = v(idx) + l_t; # skip to the next possible match position
+	  ## Skip to the next possible match position.
+	  next = v(idx) + l_t;
 	else
 	  keep(idx) = 0;
 	endif
       endfor
     endif
     if (! isempty (v))
       v = v(find (keep));
     endif
   endif
 
   if (isempty (v))
     v = [];
   endif
 
-  ## Always return a column vector, because that's what the old one did
+  ## Always return a column vector, because that's what the old one did.
   if (rows (v) > 1) 
     v = v.';
   endif
 
 endfunction
 
 %!assert ((findstr ("abababa", "a") == [1, 3, 5, 7]
 %! && findstr ("abababa", "aba") == [1, 3, 5]
diff --git a/scripts/strings/str2double.m b/scripts/strings/str2double.m
--- a/scripts/strings/str2double.m
+++ b/scripts/strings/str2double.m
@@ -82,119 +82,119 @@
 ## Author: Alois Schloegl <a.schloegl@ieee.org>
 ## Adapted-by: jwe
 
 function [num, status, strarray] = str2double (s, cdelim, rdelim, ddelim)
 
   ## digits, sign, exponent,NaN,Inf
   ## valid_char = '0123456789eE+-.nNaAiIfF';
 
-  ## valid delimiters
+  ## Valid delimiters.
   valid_delim = char (sort ([0, 9:14, 32:34, abs("()[]{},;:\"|/")]));
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   if (nargin < 2)
-    ## column delimiter
+    ## Column delimiter.
     cdelim = char ([9, 32, abs(",")]);
   else
-    ## make unique cdelim
+    ## Make unique cdelim.
     cdelim = char (sort (cdelim(:)));
     tmp = [1; 1+find(diff(abs(cdelim))>0)];
     cdelim = cdelim(tmp)';
   endif
 
   if (nargin < 3)
-    ## row delimiter
+    ## Row delimiter.
     rdelim = char ([0, 10, 13, abs(";")]);
   else
-    ## make unique rdelim
+    ## Make unique rdelim.
     rdelim = char (sort (rdelim(:)));
     tmp = [1; 1+find(diff(abs(rdelim))>0)];
     rdelim = rdelim(tmp)';
   endif
 
   if (nargin < 4)
     ddelim = ".";
   elseif (length (ddelim) != 1)
     error ("decimal delimiter must be exactly one character");
   endif
 
-  ## check if RDELIM and CDELIM are distinct
+  ## Check if RDELIM and CDELIM are distinct.
 
   delim = sort (abs ([cdelim, rdelim, ddelim]));
   tmp   = [1, 1+find(diff(delim)>0)];
   delim = delim(tmp);
   ## [length(delim),length(cdelim),length(rdelim)]
   if (length (delim) < (length(cdelim) + length(rdelim))+1)
     ## length (ddelim) must be one.
     error ("row, column and decimal delimiter are not distinct");
   endif
 
-  ## check if delimiters are valid
+  ## Check if delimiters are valid.
   tmp  = sort (abs ([cdelim, rdelim]));
   flag = zeros (size (tmp));
-  k1 = 1;
-  k2 = 1;
-  while (k1 <= length (tmp) && k2 <= length (valid_delim)),
-    if (tmp(k1) == valid_delim(k2))
-      flag(k1) = 1;
-      k1++;
-    elseif (tmp(k1) < valid_delim(k2))
-      k1++;
-    elseif (tmp(k1) > valid_delim(k2))
-      k2++;
+  curr_row = 1;
+  curr_col = 1;
+  while (curr_row <= length (tmp) && curr_col <= length (valid_delim)),
+    if (tmp(curr_row) == valid_delim(curr_col))
+      flag(curr_row) = 1;
+      curr_row++;
+    elseif (tmp(curr_row) < valid_delim(curr_col))
+      curr_row++;
+    elseif (tmp(curr_row) > valid_delim(curr_col))
+      curr_col++;
     endif
   endwhile
   if (! all (flag))
     error ("invalid delimiters!");
   endif
 
-  ## various input parameters
+  ## Various input parameters.
 
   if (isnumeric (s))
     if (all (s < 256) && all (s >= 0))
       s = char (s);
     else
       error ("str2double: input variable must be a string");
     endif
   endif
 
   if (isempty (s))
     num = [];
     status = 0;
     return;
   elseif (iscell (s))
     strarray = s;
   elseif (ischar (s) && all (size (s) > 1))
-    ## char array transformed into a string.
+    ## Char array transformed into a string.
     for k = 1:size (s, 1)
       tmp = find (! isspace (s(k,:)));
       strarray{k,1} = s(k,min(tmp):max(tmp));
     endfor
   elseif (ischar (s)),
     num = [];
     status = 0;
     strarray = {};
-    ## add stop sign; makes sure last digit is not skipped
+    ## Add stop sign; makes sure last digit is not skipped.
     s(end+1) = rdelim(1);
     RD = zeros (size (s));
     for k = 1:length (rdelim),
       RD = RD | (s == rdelim(k));
     endfor
     CD = RD;
     for k = 1:length (cdelim),
       CD = CD | (s==cdelim(k));
     endfor
 
-    k1 = 1; # current row
-    k2 = 0; # current column
-    k3 = 0; # current element
+    curr_row = 1;
+    curr_col = 0;
+    curr_elt = 0;
 
     sl = length (s);
     ix = 1;
     ## while (ix < sl) & any(abs(s(ix))==[rdelim,cdelim]),
     while (ix < sl && CD(ix))
       ix++;
     endwhile
     ta = ix;
@@ -203,81 +203,81 @@ function [num, status, strarray] = str2d
       if (ix == sl)
         te = sl;
       endif
       ## if any(abs(s(ix))==[cdelim(1),rdelim(1)]),
       if (CD(ix))
         te = ix - 1;
       endif
       if (! isempty (te))
-        k2++;
-        k3++;
-        strarray{k1,k2} = s(ta:te);
-        ## strarray{k1,k2} = [ta,te];
+        curr_col++;
+        curr_elt++;
+        strarray{curr_row,curr_col} = s(ta:te);
+        ## strarray{curr_row,curr_col} = [ta,te];
 
         flag = 0;
         ## while any(abs(s(ix))==[cdelim(1),rdelim(1)]) & (ix < sl),
         while (CD(ix) && ix < sl)
           flag = flag | RD(ix);
           ix++;
         endwhile
 
         if (flag)
-          k2 = 0;
-          k1++;
+          curr_col = 0;
+          curr_row++;
         endif
         ta = ix;
         te = [];
       endif
       ix++;
     endwhile
   else
     error ("str2double: invalid input argument");
   endif
 
   [nr, nc]= size (strarray);
   status = zeros (nr, nc);
   num = repmat (NaN, nr, nc);
 
-  for k1 = 1:nr
-    for k2 = 1:nc
-      t = strarray{k1,k2};
+  for curr_row = 1:nr
+    for curr_col = 1:nc
+      t = strarray{curr_row,curr_col};
       if (length (t) == 0)
-	## return error code
-	status(k1,k2) = -1;
-	num(k1,k2) = NaN;
+	## Return error code.
+	status(curr_row,curr_col) = -1;
+	num(curr_row,curr_col) = NaN;
       else
-	## get mantisse
+	## Get mantisse.
 	g = 0;
 	v = 1;
 	if (t(1) == "-")
 	  v = -1;
 	  l = min (2, length(t));
 	elseif (t(1) == "+")
 	  l = min (2, length (t));
 	else
 	  l = 1;
 	endif
 
 	if (strcmpi (t(l:end), "inf"))
-	  num(k1,k2) = v*Inf;
+	  num(curr_row,curr_col) = v*Inf;
 	elseif (strcmpi (t(l:end), "NaN"));
-	  num(k1,k2) = NaN;
+	  num(curr_row,curr_col) = NaN;
 	else
 	  if (ddelim == ".")
 	    t(t==ddelim) = ".";
 	  endif
 	  [v, tmp2, c] = sscanf(char(t), "%f %s", "C");
 	  ## [v,c,em,ni] = sscanf(char(t),"%f %s");
 	  ## c = c * (ni>length(t));
 	  if (c == 1),
-	    num(k1,k2) = v;
+	    num(curr_row,curr_col) = v;
 	  else
-	    num(k1,k2) = NaN;
-	    status(k1,k2) = -1;
+	    num(curr_row,curr_col) = NaN;
+	    status(curr_row,curr_col) = -1;
 	  endif
 	endif
       endif
     endfor
   endfor
 
 endfunction
 
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -47,43 +47,49 @@ function t = strrep (s, x, y)
     t = s;
     return;
   endif
 
   ind = findstr (s, x, 0);
 
   if (length(ind) == 0)
     t = s;
-  elseif (length(y) > 0)      # replacement
+  elseif (length(y) > 0)
+    ## Replacement.
+    ##
     ## Copy the parts of s that aren't being replaced.  This is done
     ## with an index vector, with jumps where each search string
     ## is found.  For a jump of 0 (target length == replacement length)
     ## the index is just cumsum ( ones (length (s))).  For non-zero
     ## jumps, add the jump size to the ones vector at each found position.
     jump = length(y) - length(x);
-    if (jump > 0)     # s expands
+    if (jump > 0)
+      ## S expands.
       di = ones(size(s));
       di(ind) = 1 + jump * ones (length (ind), 1);
       t(cumsum (di)) = s;
     elseif (jump < 0) # s contracts
       di = ones (jump * length (ind) + length (s), 1);
       di (ind + jump * [0:length(ind)-1]) = 1 - jump * ones(length(ind), 1);
       t = s (cumsum (di));
-    else              # s stays the same length
+    else
+      ## S stays the same length.
       t = s;
     endif
     ## Now, substitute a copy of the replacement string whereever the
     ## search string was found.  Note that we must first update the
     ## target positions to account for any expansion or contraction
     ## of s that may have occurred.
     ind = ind + jump * [0:length(ind)-1];
     repeat = [1:length(y)]' * ones (1, length (ind));
     dest = ones (length (y), 1) * ind + repeat - 1;
     t(dest) = y(repeat);
-  else                        # deletion
+  else
+    ## Deletion.
+    ##
     ## Build an index vector of all locations where the target was found
     ## in the search string, and zap them. 
     t = toascii (s);
     repeat = [1:length(x)]' * ones (1, length (ind));
     delete = ones (length (x), 1) * ind + repeat - 1;
     t(delete) = [];
     t = char (t);
   endif
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -62,17 +62,18 @@ function assert (cond, varargin)
   for i = 2:rows (argn)
     in = cstrcat (in, ",", deblank (argn(i,:)));
   endfor
   in = cstrcat ("(", in, ")");
 
   if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
     if (! isnumeric (cond) || ! all (cond(:)))
       if (nargin == 1)
-	error ("assert %s failed", in); # say which elements failed?
+	## Say which elements failed?
+	error ("assert %s failed", in);
       else
 	error (varargin{:});
       endif
     endif  
   else
     if (nargin < 2 || nargin > 3)
       print_usage ();
     endif
@@ -139,33 +140,34 @@ function assert (cond, varargin)
 	    || any (size (cond) != size (expected)))
       iserror = 1;
       coda = "Dimensions don't match";
 
     elseif (tol == 0 && ! strcmp (typeinfo (cond), typeinfo (expected)))
       iserror = 1;
       coda = cstrcat ("Type ", typeinfo (cond), " != ", typeinfo (expected));
 
-    else # numeric
+    else
+      ## Numeric.
       A = cond(:);
       B = expected(:);
-      ## Check exceptional values
+      ## Check exceptional values.
       if (any (isna (A) != isna (B)))
 	iserror = 1;
 	coda = "NAs don't match";
       elseif (any (isnan (A) != isnan (B)))
 	iserror = 1;
 	coda = "NaNs don't match";
 ### Try to avoid problems comparing strange values like Inf+NaNi.
       elseif (any (isinf (A) != isinf (B))
 	      || any (A(isinf (A) & ! isnan (A)) != B(isinf (B) & ! isnan (B))))
 	iserror = 1;
 	coda = "Infs don't match";
       else
-	## Check normal values
+	## Check normal values.
 	A = A(finite (A));
 	B = B(finite (B));
 	if (tol == 0)
           err = any (A != B);
 	  errtype = "values do not match";
 	elseif (tol >= 0)
 	  err = max (abs (A - B));
 	  errtype = "maximum absolute error %g exceeds tolerance %g";
@@ -183,18 +185,18 @@ function assert (cond, varargin)
 	endif
       endif
     endif
 
     if (! iserror)
       return;
     endif
 
-    ## pretty print the "expected but got" info,
-    ## trimming leading and trailing "\n"
+    ## Pretty print the "expected but got" info, trimming leading and
+    ## trailing "\n".
     str = disp (expected);
     idx = find (str != "\n");
     if (! isempty (idx))
       str = str(idx(1):idx(end));
     endif
     str2 = disp (cond);
     idx = find (str2 != "\n");
     if (! isempty (idx))
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -70,61 +70,67 @@ function ret = fail (code, pattern, warn
   endif
 
   ## allow assert(fail())
   if (nargout)
     ret = 1;
   endif  
 
   if (test_warning)
-    ## perform the warning test
-    lastwarn ();  # clear old warnings
-    state = warning ("query", "quiet"); # make sure warnings are turned on
+    ## Perform the warning test.
+    ## Clear old warnings.
+    lastwarn ();
+    ## Make sure warnings are turned on.
+    state = warning ("query", "quiet");
     warning ("on", "quiet");
     try
       ## printf("lastwarn before %s: %s\n",code,lastwarn);
       evalin ("caller", sprintf ("%s;", code));
       ## printf("lastwarn after %s: %s\n",code,lastwarn);
-      err = lastwarn ();  # retrieve new warnings
+      ## Retrieve new warnings.
+      err = lastwarn ();
       warning (state.state, "quiet");
       if (isempty (err))
         msg = sprintf ("expected warning <%s> but got none", pattern); 
       else
-        err([1:9, end]) = [];  # transform "warning: ...\n" to "..."
+	## Transform "warning: ...\n" to "...".
+        err([1:9, end]) = [];
         if (! isempty (regexp (err, pattern, "once")))
 	  return;
 	endif
         msg = sprintf ("expected warning <%s>\nbut got <%s>", pattern, err);
       endif
     catch
       warning (state.state, "quiet");
       err = lasterr;
-      err([1:7, end]) = [];  # transform "error: ...\n", to "..."
+      ## Transform "error: ...\n", to "...".
+      err([1:7, end]) = [];
       msg = sprintf ("expected warning <%s> but got error <%s>", pattern, err);
     end_try_catch
       
   else
-    ## perform the error test
+    ## Perform the error test.
     try
       evalin ("caller", sprintf ("%s;", code));
       msg = sprintf ("expected error <%s> but got none", pattern);
     catch
       err = lasterr ();
       if (strcmp (err(1:7), "error:"))
          err([1:6, end]) = []; # transform "error: ...\n", to "..."
       endif
       if (! isempty (regexp (err, pattern, "once")))
 	return;
       endif
       msg = sprintf ("expected error <%s>\nbut got <%s>", pattern, err);
     end_try_catch
   endif
 
-  ## if we get here, then code didn't fail or error didn't match
+  ## If we get here, then code didn't fail or error didn't match.
   error (msg);
+
 endfunction
 
 %!fail ('[1,2]*[2,3]','nonconformant')
 %!fail ("fail('[1,2]*[2;3]','nonconformant')","expected error <nonconformant> but got none")
 %!fail ("fail('[1,2]*[2,3]','usage:')","expected error <usage:>\nbut got.*nonconformant")
 %!fail ("warning('test warning')",'warning','test warning');
 
 %!# fail ("warning('next test')",'warning','next test');  ## only allowed one warning test?!?
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -164,47 +164,48 @@ function [__order, __test_n, __tnew, __t
   endif
 
   if (nargin < 5 || isempty (__tol))
     __tol = eps;
   endif
 
   __numtests = 15;
 
-  ## Let user specify range of n
+  ## Let user specify range of n.
   if (isscalar (__max_n))
     __min_n = 1;
     assert (__max_n > __min_n);
     __test_n = logspace (0, log10 (__max_n), __numtests);
   elseif (length (__max_n) == 2)
     __min_n = __max_n(1);
     __max_n = __max_n(2);
     assert (__min_n >= 1);
     __test_n = logspace (log10 (__min_n), log10 (__max_n), __numtests);
   else
     __test_n = __max_n;
   endif
-  __test_n = unique (round (__test_n)); # Force n to be an integer
+  ## Force n to be an integer.
+  __test_n = unique (round (__test_n));
   assert (__test_n >= 1);
 
   __torig = __tnew = zeros (size (__test_n));
 
   disp (cstrcat ("testing ", __f1, "\ninit: ", __init));
 
-  ## make sure the functions are freshly loaded by evaluating them at
+  ## Make sure the functions are freshly loaded by evaluating them at
   ## test_n(1); first have to initialize the args though.
   n = 1;
   k = 0;
   eval (cstrcat (__init, ";"));
   if (! isempty (__f2))
     eval (cstrcat (__f2, ";"));
   endif
   eval (cstrcat (__f1, ";"));
 
-  ## run the tests
+  ## Run the tests.
   for k = 1:length (__test_n)
     n = __test_n(k);
     eval (cstrcat (__init, ";"));
     
     printf ("n%i=%i  ",k, n);
     fflush (stdout);
     eval (cstrcat ("__t=time();", __f1, "; __v1=ans; __t = time()-__t;"));
     if (__t < 0.25)
@@ -222,29 +223,29 @@ function [__order, __test_n, __tnew, __t
       endif
       __torig(k) = __t;
       if (! isinf(__tol))
       	assert (__v1, __v2, __tol);
       endif
     endif
   endfor
   
-  ## Drop times of zero
+  ## Drop times of zero.
   if (! isempty (__f2))
     zidx = (__tnew < 100*eps |  __torig < 100*eps);
     __test_n(zidx) = [];
     __tnew(zidx) = [];
     __torig(zidx) = [];
   else
     zidx = (__tnew < 100*eps);
     __test_n(zidx) = [];
     __tnew(zidx) = [];
   endif
 
-  ## Approximate time complexity and return it if requested
+  ## Approximate time complexity and return it if requested.
   tailidx = ceil(length(__test_n)/2):length(__test_n);
   p = polyfit (log (__test_n(tailidx)), log (__tnew(tailidx)), 1);
   if (nargout > 0) 
     __order.p = p(1);
     __order.a = exp (p(2));
   endif
 
   ## Plot the data if no output is requested.
@@ -292,17 +293,17 @@ function [__order, __test_n, __tnew, __t
   if (doplot)
 
     ## Plot time complexity approximation (using milliseconds).
     order = sprintf ("O(n^%g)", round (10*p(1))/10);
     v = polyval (p, log (__test_n(tailidx)));
 
     loglog (__test_n(tailidx), exp(v)*1000, sprintf ("b;%s;", order)); 
 
-    ## Get base time to 1 digit of accuracy
+    ## Get base time to 1 digit of accuracy.
     dt = exp (p(2));
     dt = floor (dt/10^floor(log10(dt)))*10^floor(log10(dt));
     if (log10 (dt) >= -0.5)
       time = sprintf ("%g s", dt);
     elseif (log10 (dt) >= -3.5)
       time = sprintf ("%g ms", dt*1e3);
     elseif (log10 (dt) >= -6.5)
       time = sprintf ("%g us", dt*1e6);
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -71,17 +71,17 @@
 ## FIXME: * Consider using keyword fail rather then error?  This allows us
 ## to make a functional form of error blocks, which means we
 ## can include them in test sections which means that we can use
 ## octave flow control for both kinds of tests.
 
 ## PKG_ADD: mark_as_command test
 
 function [__ret1, __ret2, __ret3, __ret4] = test (__name, __flag, __fid)
-  ## information from test will be introduced by "key" 
+  ## Information from test will be introduced by "key".
   persistent __signal_fail =  "!!!!! ";
   persistent __signal_empty = "????? ";
   persistent __signal_block = "  ***** ";
   persistent __signal_file =  ">>>>> ";
   persistent __signal_skip = "----- ";
 
   __xfail = 0;
   __xskip = 0;
@@ -96,17 +96,17 @@ function [__ret1, __ret2, __ret3, __ret4
       || (! ischar (__name) && ! isempty (__name)) || ! ischar (__flag))
     print_usage ();
   endif
   if (isempty (__name) && (nargin != 3 || ! strcmp (__flag, "explain")))
     print_usage ();
   endif
   __batch = (! isempty (__fid));
 
-  ## decide if error messages should be collected
+  ## Decide if error messages should be collected.
   __close_fid = 0;
   if (__batch)
     if (ischar (__fid))
       __fid = fopen (__fid, "wt");
       if (__fid < 0)
 	error ("could not open log file");
       endif
       __close_fid = 1;
@@ -149,17 +149,17 @@ function [__ret1, __ret2, __ret3, __ret4
     if (__close_fid)
       fclose(__fid);
     endif
     return;
   else
     error ("test unknown flag '%s'", __flag);
   endif
 
-  ## locate the file to test
+  ## Locate the file to test.
   __file = file_in_loadpath (__name, "all");
   if (isempty (__file))
     __file = file_in_loadpath (cstrcat (__name, ".m"), "all");
   endif
   if (isempty (__file))
     __file = file_in_loadpath (cstrcat (__name, ".cc"), "all");
   endif
   if (iscell (__file))
@@ -182,17 +182,17 @@ function [__ret1, __ret2, __ret3, __ret4
       endif
     endif
     if (__close_fid)
       fclose(__fid);
     endif
     return;
   endif
 
-  ## grab the test code from the file
+  ## Grab the test code from the file.
   __body = __extract_test_code (__file);
 
   if (isempty (__body))
     if (__grabdemo)
       __ret1 = "";
       __ret2 = [];
     else
       fprintf (__fid, "%s%s has no tests available\n", __signal_empty, __file);
@@ -201,71 +201,73 @@ function [__ret1, __ret2, __ret3, __ret4
 	__ret1 = __ret2 = 0;
       endif
     endif
     if (__close_fid)
       fclose(__fid);
     endif
     return;
   else
-    ## add a dummy comment block to the end for ease of indexing
+    ## Add a dummy comment block to the end for ease of indexing.
     if (__body (length(__body)) == "\n")
       __body = sprintf ("\n%s#", __body); 
     else
       __body = sprintf ("\n%s\n#", __body); 
     endif
   endif
 
-  ## chop it up into blocks for evaluation
+  ## Chop it up into blocks for evaluation.
   __lineidx = find (__body == "\n");
   __blockidx = __lineidx(find (! isspace (__body(__lineidx+1))))+1;
 
-  ## ready to start tests ... if in batch mode, tell us what is happening
+  ## Ready to start tests ... if in batch mode, tell us what is happening.
   if (__verbose)
     disp (cstrcat ( __signal_file, __file));
   endif
 
-  ## assume all tests will pass
+  ## Assume all tests will pass.
   __all_success = 1;
 
-  ## process each block separately, initially with no shared variables
+  ## Process each block separately, initially with no shared variables.
   __tests = __successes = 0;
   __shared = " ";
   __shared_r = " ";
   __clear = "";
   for __i = 1:length(__blockidx)-1
 
-    ## extract the block
+    ## Extract the block.
     __block = __body(__blockidx(__i):__blockidx(__i+1)-2);
 
-    ## let the user/logfile know what is happening
+    ## Let the user/logfile know what is happening.
     if (__verbose)
       fprintf (__fid, "%s%s\n", __signal_block, __block);
       fflush (__fid);
     endif
 
-    ## split __block into __type and __code
+    ## Split __block into __type and __code.
     __idx = find (! isletter (__block));
     if (isempty (__idx))
       __type = __block;
       __code = "";
     else
       __type = __block(1:__idx(1)-1);
       __code = __block(__idx(1):length(__block));
     endif
 
-    ## assume the block will succeed;
+    ## Assume the block will succeed.
     __success = 1;
     __msg = [];
 
-    ## DEMO
+### DEMO
+
     ## If in __grabdemo mode, then don't process any other block type.
     ## So that the other block types don't have to worry about
     ## this __grabdemo mode, the demo block processor grabs all block
     ## types and skips those which aren't demo blocks.
+
     __isdemo = strcmp (__type, "demo");
     if (__grabdemo || __isdemo)
       __istest = 0;
 
       if (__grabdemo && __isdemo)
 	if (isempty(__demo_code))
 	  __demo_code = __code;
 	  __demo_idx = [1, length(__demo_code)+1];
@@ -282,63 +284,67 @@ function [__ret1, __ret2, __ret3, __ret4
 	  input ("Press <enter> to continue: ", "s");
       	catch
 	  __success = 0;
 	  __msg = sprintf ("%sdemo failed\n%s",  __signal_fail, __error_text__);
       	end_try_catch
       	clear __test__;
 
       endif
-      __code = ""; # code already processed
+      ## Code already processed.
+      __code = "";
       
-    ## SHARED
-    elseif strcmp (__type, "shared")
+### SHARED
+
+    elseif (strcmp (__type, "shared"))
       __istest = 0;
 
-      ## separate initialization code from variables
+      ## Separate initialization code from variables.
       __idx = find (__code == "\n");
       if (isempty (__idx))
 	__vars = __code;
 	__code = "";
       else
       	__vars = __code (1:__idx(1)-1);
       	__code = __code (__idx(1):length(__code));
       endif
       
-      ## strip comments off the variables
+      ## Strip comments off the variables.
       __idx = find (__vars == "%" | __vars == "#");
       if (! isempty (__idx))
 	__vars = __vars(1:__idx(1)-1);
       endif
       
-      ## assign default values to variables
+      ## Assign default values to variables.
       try
 	__vars = deblank (__vars);
 	if (! isempty (__vars))
 	  eval (cstrcat (strrep (__vars, ",", "=[];"), "=[];"));
 	  __shared = __vars;
 	  __shared_r = cstrcat ("[ ", __vars, "] = ");
       	else
 	  __shared = " ";
 	  __shared_r = " ";
       	endif
       catch
-	__code = "";  # couldn't declare, so don't initialize
+	## Couldn't declare, so don't initialize.
+	__code = "";
 	__success = 0;
 	__msg = sprintf ("%sshared variable initialization failed\n",
 		         __signal_fail);
       end_try_catch
 
-      ## clear shared function definitions
+      ## Clear shared function definitions.
       eval (__clear, "");
       __clear = "";
       
-      ## initialization code will be evaluated below
+      ## Initialization code will be evaluated below.
     
-    ## FUNCTION
+### FUNCTION
+
     elseif (strcmp (__type, "function"))
       __istest = 0;
       persistent __fn = 0;
       __name_position = function_name (__block);
       if (isempty (__name_position))
         __success = 0;
         __msg = sprintf ("%stest failed: missing function name\n",
 			 __signal_fail);
@@ -351,24 +357,26 @@ function [__ret1, __ret2, __ret3, __ret4
         catch
           __success = 0;
           __msg = sprintf ("%stest failed: syntax error\n%s",
 			   __signal_fail, __error_text__);
         end_try_catch
       endif
       __code = "";
       
+### ASSERT/FAIL
 
-    ## ASSERT/FAIL
     elseif (strcmp (__type, "assert") || strcmp (__type, "fail"))
       __istest = 1;
-      __code = __block; # put the keyword back on the code
-      ## the code will be evaluated below as a test block
+      ## Put the keyword back on the code.
+      __code = __block;
+      ## The code will be evaluated below as a test block.
       
-    ## ERROR/WARNING
+### ERROR/WARNING
+
     elseif (strcmp (__type, "error") || strcmp(__type, "warning"))
       __istest = 1;
       __warning = strcmp (__type, "warning");
       [__pattern, __code] = getpattern (__code);
       try
       	eval (sprintf ("function __test__(%s)\n%s\nendfunction",
 		       __shared, __code));
       catch
@@ -410,44 +418,50 @@ function [__ret1, __ret2, __ret3, __ret4
             __msg = sprintf ("%sexpected <%s> but got %s\n",
 			     __signal_fail, __pattern, __err);
           else
 	    __success = 1;
           endif
       	end_try_catch
       	clear __test__;
       endif
-      __code = ""; # code already processed
+      ## Code already processed.
+      __code = "";
       
-    ## TESTIF
+### TESTIF
+
     elseif (strcmp (__type, "testif"))
       [__e, __feat] = regexp (__code, '^\s*([^\s]+)', 'end', 'tokens');
       if (isempty (findstr (octave_config_info ("DEFS"), __feat{1}{1})))
         __xskip++;
 	__success = 0;
 	__istest = 0;
-	__code = ""; # skip the code
+	## Skip the code.
+	__code = "";
 	__msg = sprintf ("%sskipped test\n", __signal_skip);
       else
         __istest = 1;
 	__code = __code(__e + 1 : end);
       endif
 
-    ## TEST
+### TEST
+
     elseif (strcmp (__type, "test") || strcmp (__type, "xtest"))
       __istest = 1;
-      ## code will be evaluated below
-      
-    ## comment block
+      ## Code will be evaluated below.
+
+### Comment block.
+
     elseif (strcmp (__block(1:1), "#"))
       __istest = 0;
       __code = ""; # skip the code
 
+### Unknown block.
+
     else
-    ## unknown block
       __istest = 1;
       __success = 0;
       __msg = sprintf ("%sunknown test type!\n", __signal_fail);
       __code = ""; # skip the code
     endif
 
     ## evaluate code for test, shared, and assert.
     if (! isempty(__code))
@@ -465,36 +479,36 @@ function [__ret1, __ret2, __ret3, __ret4
         endif
 	if (isempty (__error_text__))
 	  error ("empty error text, probably Ctrl-C --- aborting"); 
 	endif
       end_try_catch
       clear __test__;
     endif
     
-    ## All done.  Remember if we were successful and print any messages
+    ## All done.  Remember if we were successful and print any messages.
     if (! isempty (__msg))
-      ## make sure the user knows what caused the error
+      ## Make sure the user knows what caused the error.
       if (! __verbose)
       	fprintf (__fid, "%s%s\n", __signal_block, __block);
 	fflush (__fid);
       endif
       fputs (__fid, __msg);
       fflush (__fid);
-      ## show the variable context
+      ## Show the variable context.
       if (! strcmp (__type, "error") && ! strcmp (__type, "testif")
 	  && ! all (__shared == " "))
 	fputs (__fid, "shared variables ");
 	eval (sprintf ("fdisp(__fid,bundle(%s));", __shared)); 
 	fflush (__fid);
       endif
     endif
     if (__success == 0)
       __all_success = 0;
-      	## stop after one error if not in batch mode
+      ## Stop after one error if not in batch mode.
       if (! __batch)
     	if (nargout > 0)
 	  __ret1 = __ret2 = 0;
 	endif
 	if (__close_fid)
 	  fclose(__fid);
 	endif
       	return;
@@ -527,80 +541,80 @@ function [__ret1, __ret2, __ret3, __ret4
   else
     __ret1 = __successes;
     __ret2 = __tests;
     __ret3 = __xfail;
     __ret4 = __xskip;
   endif
 endfunction
 
-## create structure with fieldnames the name of the input variables
+## Create structure with fieldnames the name of the input variables.
 function s = varstruct (varargin)
   for i = 1:nargin
     s.(deblank (argn(i,:))) = varargin{i};
   endfor
 endfunction
 
-## find [start,end] of fn in 'function [a,b] = fn'
+## Find [start,end] of fn in 'function [a,b] = fn'.
 function pos = function_name (def)
   pos = [];
 
-  ## Find the end of the name
+  ## Find the end of the name.
   right = find (def == "(", 1);
   if (isempty (right))
     return;
   endif
   right = find (def(1:right-1) != " ", 1, "last");
 
-  ## Find the beginning of the name
+  ## Find the beginning of the name.
   left = max ([find(def(1:right)==" ", 1, "last"), ...
 	       find(def(1:right)=="=", 1, "last")]);
   if (isempty (left))
     return;
   endif
   left++;
 
-  ## Return the end points of the name
+  ## Return the end points of the name.
   pos = [left, right];
 endfunction
 
-## strip <pattern> from '<pattern> code'
+## Strip <pattern> from '<pattern> code'.
 function [pattern, rest] = getpattern (str)
   pattern = ".";
   rest = str; 
   str = trimleft (str);
   if (! isempty (str) && str(1) == "<")
     close = index (str, ">");
     if (close)
       pattern = str(2:close-1);
       rest = str(close+1:end);
     endif
   endif
 endfunction
 
-## strip '.*prefix:' from '.*prefix: msg\n' and strip trailing blanks
+## Strip '.*prefix:' from '.*prefix: msg\n' and strip trailing blanks.
 function msg = trimerr (msg, prefix)
   idx = index (msg, cstrcat (prefix, ":"));
   if (idx > 0)
     msg(1:idx+length(prefix)) = [];
   endif
   msg = trimleft (deblank (msg));
 endfunction
 
-## strip leading blanks from string
+## Strip leading blanks from string.
 function str = trimleft (str)
   idx = find (isspace (str));
   leading = find (idx == 1:length(idx));
   if (! isempty (leading))
     str = str(leading(end)+1:end);
   endif
 endfunction
 
-## make a structure out of the named variables
-## (based on Etienne Grossmann's tar function)
+## Make a structure out of the named variables
+## (based on Etienne Grossmann's tar function).
 function s = bundle (varargin)
   for i = 1:nargin
     s.(deblank (argn(i,:))) = varargin{i};
   endfor
 endfunction
 
 function body = __extract_test_code (nm)
   fid = fopen (nm, "rt");
@@ -614,17 +628,17 @@ function body = __extract_test_code (nm)
           body = cstrcat (body, ln(3:end));
         endif
       endif
     endwhile
     fclose (fid);
   endif
 endfunction
 
-## Test for test for missing features
+### Test for test for missing features
 %!testif OCTAVE_SOURCE
 %! ## This test should be run
 %! assert (true);
 
 ### Disable this test to avoid spurious skipped test for "make check"
 % !testif HAVE_FOOBAR
 % ! ## missing feature. Fail if this test is run
 % ! error("Failed missing feature test");
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -182,17 +182,17 @@ function retval = datestr (date, f, p)
   endif
 
   if (ischar (date))
     t = date;
     date = cell (1);
     date{1} = t;
   endif
 
-  # guess, so we might be wrong
+  ## Guess, so we might be wrong.
   if (iscell (date) || columns (date) != 6)
     v = datevec (date, p);
   else
     v = [];
     if (columns (date) == 6)
       ## Make sure that the input really is a datevec.
       maxdatevec = [Inf, 12, 31, 23, 59, 60];
       for i = 1:numel (maxdatevec)
@@ -208,17 +208,17 @@ function retval = datestr (date, f, p)
     endif
   endif
 
   for i = 1:(rows (v))
 
     if (isempty (f) || f == -1)
       if (v(i,4:6) == 0)
         f = 1;
-      #elseif (v(i,1:3) == [0, 1, 1])
+	## elseif (v(i,1:3) == [0, 1, 1])
       elseif (v(i,1:3) == [-1, 12, 31])
         f = 16;
       else
         f = 0;
       endif
     endif
 
     if (isnumeric (f))
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -68,17 +68,17 @@ function [y, m, d, h, mi, s] = datevec (
     std_formats{++nfmt} = "dd mmm yyyy";
     std_formats{++nfmt} = "mmm dd yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm dd yyyy";
     std_formats{++nfmt} = "dd.mmm.yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd.mmm.yyyy";
     std_formats{++nfmt} = "mmm.dd.yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm.dd.yyyy";
 
-   # custom formats
+    ## Custom formats.
     std_formats{++nfmt} = "mmmyy";                  # 12
     std_formats{++nfmt} = "mm/dd/yyyy HH:MM";
   endif
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
@@ -181,35 +181,36 @@ function [y, m, d, h, mi, s] = datevec (
   if (nargout <= 1)
     y = [y, m, d, h, mi, s];
   endif
 
 ### endfunction
 
 function [f, rY, ry, fy, fm, fd, fh, fmi, fs] = __date_vfmt2sfmt__ (f)
 
-  # Play safe with percent signs
+  ## Play safe with percent signs.
   f = strrep(f, "%", "%%");
 
-  ## dates to lowercase (note: we cannot convert MM to mm)
+  ## Dates to lowercase (note: we cannot convert MM to mm).
   f = strrep (f, "YYYY", "yyyy");
   f = strrep (f, "YY", "yy");
   f = strrep (f, "QQ", "qq");
   f = strrep (f, "MMMM", "mmmm");
   f = strrep (f, "MMM", "mmm");
   f = strrep (f, "DDDD", "dddd");
   f = strrep (f, "DDD", "ddd");
   f = strrep (f, "DD", "dd");
-  ## times to uppercase (also cannot convert mm to MM)
+  ## Times to uppercase (also cannot convert mm to MM).
   f = strrep (f, "hh", "HH");
   f = strrep (f, "ss", "SS");
   f = strrep (f, "pm", "PM");
   f = strrep (f, "am", "AM");
 
-  ## right now, the format string may only contain these tokens:
+  ## Right now, the format string may only contain these tokens:
+  ##
   ## yyyy   4 digit year
   ## yy     2 digit year
   ## mmmm   month name, full
   ## mmm    month name, abbreviated
   ## mm     month number
   ## dddd   weekday name, full
   ## ddd    weekday name, abbreviated
   ## dd     date
@@ -220,42 +221,42 @@ function [f, rY, ry, fy, fm, fd, fh, fmi
   ## AM     AM/PM
 
   if (! isempty (strfind (f, "PM")) || ! isempty (strfind (f, "AM")))
     ampm = true;
   else
     ampm = false;
   endif
 
-  # date part
+  ## Date part.
   f = strrep (f, "yyyy", "%Y");
   f = strrep (f, "yy", "%y");
   f = strrep (f, "mmmm", "%B");
   f = strrep (f, "mmm", "%b");
   f = strrep (f, "mm", "%m");
   f = strrep (f, "dddd", "%A");
   f = strrep (f, "ddd", "%a");
   f = strrep (f, "dd", "%d");
 
-  # time part
+  ## Time part.
   if (ampm)
     f = strrep (f, "HH", "%I");
     f = strrep (f, "PM", "%p");
     f = strrep (f, "AM", "%p");
   else
     f = strrep (f, "HH", "%H");
   endif
   f = strrep (f, "MM", "%M");
   f = strrep (f, "SS", "%S");
 
   rY = rindex (f, "%Y");
   ry = rindex (f, "%y");
 
-  # check whether we need to give default values
-  # possible error when string contains "%%"
+  ## Check whether we need to give default values.
+  ## Possible error when string contains "%%".
   fy = rY || ry;
   fm = index (f, "%m") || index (f, "%b") || index (f, "%B");
   fd = index (f, "%d") || index (f, "%a") || index (f, "%A");
   fh = index (f, "%H") || index (f, "%I");
   fmi = index (f, "%M");
   fs = index (f, "%S");
 
 ### endfunction
@@ -275,25 +276,25 @@ function [found, y, m, d, h, mi, s] = __
         y -= 1900;
       endif
       y += p - mod (p, 100);
       if (y < p)
         y += 100;
       endif
     endif
     if (! fy && ! fm && ! fd)
-      tvm = localtime (time ());  ## tvm: this very moment
-      y = tvm.year + 1900;
-      m = tvm.mon + 1;
-      d = tvm.mday;
+      tmp = localtime (time ());
+      y = tmp.year + 1900;
+      m = tmp.mon + 1;
+      d = tmp.mday;
     elseif (! fy && fm && fd)
-      tvm = localtime (time ());  ## tvm: this very moment
-      y = tvm.year + 1900;
+      tmp = localtime (time ());
+      y = tmp.year + 1900;
     elseif (fy && fm && ! fd)
-      tvm = localtime (time ());  ## tvm: this very moment
+      tmp = localtime (time ());
       d = 1;
     endif
     if (! fh && ! fmi && ! fs)
       h = mi = s = 0;
     elseif (fh && fmi && ! fs)
       s = 0;
     endif
   else
