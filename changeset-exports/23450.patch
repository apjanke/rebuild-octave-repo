# HG changeset patch
# User Rik <rik@octave.org>
# Date 1493339590 25200
#      Thu Apr 27 17:33:10 2017 -0700
# Node ID 855122b993daa68b53a680a664ec32165bc00b75
# Parent  c763214a82603262a0ee08a419c609b8a2d4c257
maint: Wrap tertiary operator in parentheses "(COND ? x : y)".

* Canvas.cc, color-picker.cc, dialog.cc, marker.cc, main-window.cc, Cell.cc,
__magick_read__.cc, __pchip_deriv__.cc, __qp__.cc, bsxfun.cc, call-stack.cc,
cellfun.cc, data.cc, defaults.cc, det.cc, eig.cc, error.cc, file-io.cc,
filter.cc, find.cc, gammainc.cc, gcd.cc, gl-render.cc, graphics.cc,
graphics.in.h, help.cc, hex2num.cc, inv.cc, load-save.cc, lookup.cc,
ls-mat4.cc, ls-mat5.cc, ls-oct-binary.cc, ls-oct-text.cc, lu.cc, max.cc,
mex.cc, oct-hist.cc, oct-map.cc, oct-procbuf.cc, oct-stream.cc, pr-output.cc,
rand.cc, regexp.cc, schur.cc, str2double.cc, strfns.cc, symtab.cc, sysdep.cc,
tril.cc, variables.cc, xdiv.cc, audiodevinfo.cc, audioread.cc, colamd.cc,
gzip.cc, ov-base-diag.cc, ov-base-mat.h, ov-base-scalar.h, ov-class.cc,
ov-classdef.cc, ov-fcn-handle.cc, ov-range.cc, ov-range.h, ov-struct.cc,
ov-usr-fcn.cc, ov.cc, octave.cc, op-class.cc, pt-eval.cc, pt-funcall.cc,
pt-idx.cc, pt-jit.cc, pt-stmt.cc, version.cc, Array-util.cc, Array.cc,
CDiagMatrix.cc, CMatrix.cc, CNDArray.cc, CSparse.cc, Range.cc, Sparse.cc,
chNDArray.cc, dDiagMatrix.cc, dMatrix.cc, dNDArray.cc, dSparse.cc,
dim-vector.cc, fCDiagMatrix.cc, fCMatrix.cc, fCNDArray.cc, fDiagMatrix.cc,
fMatrix.cc, fNDArray.cc, idx-vector.cc, idx-vector.h, Faddeeva.cc, DASPK.cc,
DASRT.cc, DASSL.cc, EIG.cc, fEIG.cc, gsvd.cc, lo-specfun.cc, oct-rand.cc,
qr.cc, qrp.cc, randgamma.cc, schur.cc, svd.cc, Sparse-diag-op-defs.h,
mx-inlines.cc, oct-env.cc, cmd-edit.cc, kpse.cc, oct-inttypes.h, oct-sort.cc:
Wrap tertiary operator in parentheses "(COND ? x : y)".

diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -809,17 +809,17 @@ namespace QtHandles
             graphics_object obj = gh_manager::get_object (m_handle);
 
             graphics_object figObj (obj.get_ancestor ("figure"));
 
             std::string zm = zoom_mode (figObj);
 
             if (m_mouseAnchor == event->pos ())
               {
-                double factor = m_clickMode ? 2.0 : 0.5;
+                double factor = (m_clickMode ? 2.0 : 0.5);
 
                 ColumnVector p1 = ap.pixel2coord (event->x (), event->y ());
 
                 ap.zoom_about_point (zm, p1(0), p1(1), factor);
               }
             else if (m_mouseMode == ZoomInMode)
               {
                 ColumnVector p0 = ap.pixel2coord (m_mouseAnchor.x (),
@@ -978,17 +978,17 @@ namespace QtHandles
                   ap.zoom (mode, factor);
                 }
                 break;
 
               case PanMode:
                 {
                   axes::properties& ap = Utils::properties<axes> (axesObj);
 
-                  double factor = event->delta () > 0 ? 0.1 : -0.1;
+                  double factor = (event->delta () > 0 ? 0.1 : -0.1);
 
                   ap.pan (mode, factor);
                 }
                 break;
 
               default:
                 redrawFigure = false;
                 break;
diff --git a/libgui/src/color-picker.cc b/libgui/src/color-picker.cc
--- a/libgui/src/color-picker.cc
+++ b/libgui/src/color-picker.cc
@@ -56,17 +56,17 @@ color_picker::select_color ()
 // draw the button with the actual color (using a stylesheet)
 void color_picker::update_button ()
 {
   // Is this the right place to look for a "foreground" color that would
   // provide a reasonable border for the color swatches?
   QWidget *p = parentWidget ();
 
   QString bordercolor
-    = p ? p->palette ().text ().color ().name () : QString ("#000000");
+    = (p ? p->palette ().text ().color ().name () : QString ("#000000"));
 
   QString css = QString ("background-color: %1; border: 1px solid %2;")
                 .arg (_color.name ())
                 .arg (bordercolor);
 
   setStyleSheet (css);
   repaint ();
 }
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -147,17 +147,17 @@ MessageDialog::MessageDialog (const QStr
   else if (qsicon == "warn")
     eicon = QMessageBox::Warning;
   else if (qsicon == "help")
     eicon = QMessageBox::Information;
   else if (qsicon == "quest")
     eicon = QMessageBox::Question;
   setIcon (eicon);
 
-  int N = qsbutton.size () < role.size () ? qsbutton.size () : role.size ();
+  int N = (qsbutton.size () < role.size () ? qsbutton.size () : role.size ());
   if (N == 0)
     addButton (QMessageBox::Ok);
   else
     {
       for (int i = 0; i < N; i++)
         {
           // Interpret the button role string, because enumeration
           // QMessageBox::ButtonRole can't be made to pass through a signal.
diff --git a/libgui/src/m-editor/marker.cc b/libgui/src/m-editor/marker.cc
--- a/libgui/src/m-editor/marker.cc
+++ b/libgui/src/m-editor/marker.cc
@@ -147,18 +147,19 @@ marker::handle_marker_line_deleted (int 
   // different line rather than remove it from the margin.  I (DJS) will
   // lobby for such a signal.
   if (_mhandle == mhandle)
     {
       if (_marker_type == breakpoint || _marker_type == debugger_position)
         {
           int editor_linenr = _edit_area->markerLine (_mhandle);
           _edit_area->markerDeleteHandle (_mhandle);
-          _marker_type = _marker_type == breakpoint ? unsure_breakpoint
-                                                    : unsure_debugger_position;
+          _marker_type = (_marker_type == breakpoint
+                          ? unsure_breakpoint
+                          : unsure_debugger_position);
           _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
         }
     }
 }
 
 
 void
 marker::handle_marker_line_undeleted (int mhandle)
@@ -170,16 +171,17 @@ marker::handle_marker_line_undeleted (in
   // lobby for such a signal.
   if (_mhandle == mhandle)
     {
       if (_marker_type == unsure_breakpoint
           || _marker_type == unsure_debugger_position)
         {
           int editor_linenr = _edit_area->markerLine (_mhandle);
           _edit_area->markerDeleteHandle (_mhandle);
-          _marker_type = _marker_type == unsure_breakpoint ? breakpoint
-                                                           : debugger_position;
+          _marker_type = (_marker_type == unsure_breakpoint
+                          ? breakpoint
+                          : debugger_position);
           _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
         }
     }
 }
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -947,17 +947,17 @@ main_window::browse_for_directory (void)
   focus_command_window ();
 }
 
 void
 main_window::set_current_working_directory (const QString& dir)
 {
   // Change to dir if it is an existing directory.
 
-  QString xdir = dir.isEmpty () ? "." : dir;
+  QString xdir = (dir.isEmpty () ? "." : dir);
 
   QFileInfo fileInfo (xdir);
 
   if (fileInfo.exists () && fileInfo.isDir ())
     octave_link::post_event (this, &main_window::change_directory_callback,
                              xdir.toStdString ());
 }
 
diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -96,17 +96,17 @@ Cell::Cell (const dim_vector& dv, const 
   : Array<octave_value> (dv, Matrix ())
 {
   octave_idx_type n = sv.numel ();
 
   if (n > 0)
     {
       octave_idx_type m = numel ();
 
-      octave_idx_type len = n > m ? m : n;
+      octave_idx_type len = (n > m ? m : n);
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string s = sv[i];
 
           if (trim)
             {
               size_t pos = s.find_last_not_of (' ');
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -996,17 +996,17 @@ init_enconde_image (const octave_idx_typ
 
 template <typename T>
 static void
 encode_indexed_images (std::vector<Magick::Image>& imvec,
                        const T& img,
                        const Matrix& cmap)
 {
   typedef typename T::element_type P;
-  const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type nFrames   = (img.ndims () < 4 ? 1 : img.dims ()(3));
   const octave_idx_type nRows     = img.rows ();
   const octave_idx_type nCols     = img.columns ();
   const octave_idx_type cmap_size = cmap.rows ();
   const octave_idx_type bitdepth  = bitdepth_from_class<T> ();
 
   // There is no colormap object, we need to build a new one for each frame,
   // even if it's always the same.  We can least get a vector for the Colors.
   std::vector<Magick::ColorRGB> colormap;
@@ -1063,17 +1063,17 @@ encode_indexed_images (std::vector<Magic
       m_img.syncPixels ();
       imvec.push_back (m_img);
     }
 }
 
 static void
 encode_bool_image (std::vector<Magick::Image>& imvec, const boolNDArray& img)
 {
-  const octave_idx_type nFrames = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type nFrames = (img.ndims () < 4 ? 1 : img.dims ()(3));
   const octave_idx_type nRows   = img.rows ();
   const octave_idx_type nCols   = img.columns ();
 
   // The initialized image will be black, this is for the other pixels
   const Magick::Color white ("white");
 
   const bool *img_fvec = img.fortran_vec ();
   octave_idx_type img_idx = 0;
@@ -1113,18 +1113,18 @@ encode_bool_image (std::vector<Magick::I
 }
 
 template <typename T>
 static void
 encode_uint_image (std::vector<Magick::Image>& imvec,
                    const T& img, const T& alpha)
 {
   typedef typename T::element_type P;
-  const octave_idx_type channels = img.ndims () < 3 ? 1 : img.dims ()(2);
-  const octave_idx_type nFrames  = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type channels = (img.ndims () < 3 ? 1 : img.dims ()(2));
+  const octave_idx_type nFrames  = (img.ndims () < 4 ? 1 : img.dims ()(3));
   const octave_idx_type nRows    = img.rows ();
   const octave_idx_type nCols    = img.columns ();
   const octave_idx_type bitdepth = bitdepth_from_class<T> ();
 
   Magick::ImageType type;
   const bool has_alpha = ! alpha.is_empty ();
   switch (channels)
     {
diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -64,18 +64,18 @@ Undocumented internal function.
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
             error ("__pchip_deriv__: X and Y dimension mismatch");
 
           FloatMatrix dmat (nyr, nyc);
 
           F77_INT ierr;
-          const F77_INT incfd = rows ? octave::to_f77_int (nyr) : 1;
-          volatile const octave_idx_type inc = rows ? 1 : nyr;
+          const F77_INT incfd = (rows ? octave::to_f77_int (nyr) : 1);
+          volatile const octave_idx_type inc = (rows ? 1 : nyr);
           volatile octave_idx_type k = 0;
 
           for (volatile octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
             {
               F77_XFCN (pchim, PCHIM, (nx, xvec.data (),
                                        ymat.data () + k * inc,
                                        dmat.fortran_vec () + k * inc,
                                        incfd, ierr));
@@ -102,18 +102,18 @@ Undocumented internal function.
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
             error ("__pchip_deriv__: X and Y dimension mismatch");
 
           Matrix dmat (nyr, nyc);
 
           F77_INT ierr;
-          const F77_INT incfd = rows ? octave::to_f77_int (nyr) : 1;
-          volatile const octave_idx_type inc = rows ? 1 : nyr;
+          const F77_INT incfd = (rows ? octave::to_f77_int (nyr) : 1);
+          volatile const octave_idx_type inc = (rows ? 1 : nyr);
           volatile octave_idx_type k = 0;
 
           for (volatile octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
             {
               F77_XFCN (dpchim, DPCHIM, (nx, xvec.data (),
                                          ymat.data () + k * inc,
                                          dmat.fortran_vec () + k * inc,
                                          incfd, ierr));
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -53,17 +53,17 @@ null (const Matrix& A, octave_idx_type& 
 
       ColumnVector s = S.extract_diag ();
 
       Matrix V = A_svd.right_singular_matrix ();
 
       octave_idx_type A_nr = A.rows ();
       octave_idx_type A_nc = A.cols ();
 
-      octave_idx_type tmp = A_nr > A_nc ? A_nr : A_nc;
+      octave_idx_type tmp = (A_nr > A_nc ? A_nr : A_nc);
 
       double tol = tmp * s(0) * std::numeric_limits<double>::epsilon ();
 
       octave_idx_type n = s.numel ();
 
       for (octave_idx_type i = 0; i < n; i++)
         {
           if (s(i) > tol)
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -391,19 +391,19 @@ dimensionality as the other array.
           error ("bsxfun: dimensions of A and B must match");
 
       // Find the size of the output
       dim_vector dvc;
       dvc.resize (nd);
 
       for (octave_idx_type i = 0; i < nd; i++)
         dvc(i) = (dva(i) < 1 ? dva(i)
-                  : (dvb(i) < 1 ? dvb(i)
-                     : (dva(i) > dvb(i)
-                        ? dva(i) : dvb(i))));
+                             : (dvb(i) < 1 ? dvb(i)
+                                           : (dva(i) > dvb(i) ? dva(i)
+                                                              : dvb(i))));
 
       if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
         {
           octave_value_list inputs (2);
           inputs(0) = A;
           inputs(1) = B;
           retval = func.do_multi_index_op (1, inputs);
         }
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -368,17 +368,17 @@ namespace octave
   std::list<call_stack::stack_frame>
   call_stack::do_backtrace_frames (size_t nskip,
                                    octave_idx_type& curr_user_frame) const
   {
     std::list<call_stack::stack_frame> retval;
 
     size_t user_code_frames = do_num_user_code_frames (curr_user_frame);
 
-    size_t nframes = nskip <= user_code_frames ? user_code_frames - nskip : 0;
+    size_t nframes = (nskip <= user_code_frames ? user_code_frames - nskip : 0);
 
     // Our list is reversed.
     curr_user_frame = nframes - curr_user_frame - 1;
 
     if (nframes > 0)
       {
         for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
           {
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1845,31 +1845,31 @@ mat2cell_mismatch (const dim_vector& dv,
                    const Array<octave_idx_type> *d, int nd)
 {
   for (int i = 0; i < nd; i++)
     {
       octave_idx_type s = 0;
       for (octave_idx_type j = 0; j < d[i].numel (); j++)
         s += d[i](j);
 
-      octave_idx_type r = i < dv.ndims () ? dv(i) : 1;
+      octave_idx_type r = (i < dv.ndims () ? dv(i) : 1);
 
       if (s != r)
         error ("mat2cell: mismatch on dimension %d (%d != %d)", i+1, r, s);
     }
 
   return false;
 }
 
 template <typename container>
 static void
 prepare_idx (container *idx, int idim, int nd,
              const Array<octave_idx_type>* d)
 {
-  octave_idx_type nidx = idim < nd ? d[idim].numel () : 1;
+  octave_idx_type nidx = (idim < nd ? d[idim].numel () : 1);
   if (nidx == 1)
     idx[0] = idx_vector::colon;
   else
     {
       octave_idx_type l = 0;
       for (octave_idx_type i = 0; i < nidx; i++)
         {
           octave_idx_type u = l + d[idim](i);
@@ -1889,17 +1889,17 @@ do_mat2cell_2d (const Array2D& a, const 
   NoAlias<Cell> retval;
   assert (nd == 1 || nd == 2);
   assert (a.ndims () == 2);
 
   if (mat2cell_mismatch (a.dims (), d, nd))
     return retval;
 
   octave_idx_type nridx = d[0].numel ();
-  octave_idx_type ncidx = nd == 1 ? 1 : d[1].numel ();
+  octave_idx_type ncidx = (nd == 1 ? 1 : d[1].numel ());
   retval.clear (nridx, ncidx);
 
   int ivec = -1;
   if (a.rows () > 1 && a.cols () == 1 && ncidx == 1)
     ivec = 0;
   else if (a.rows () == 1 && nridx == 1 && nd == 2)
     ivec = 1;
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1853,17 +1853,17 @@ do_cat (const octave_value_list& xargs, 
         {
           if (all_real_p)
             retval = do_single_type_concat<FloatNDArray> (args, dim);
           else
             retval = do_single_type_concat<FloatComplexNDArray> (args, dim);
         }
       else if (result_type == "char")
         {
-          char type = all_dq_strings_p ? '"' : '\'';
+          char type = (all_dq_strings_p ? '"' : '\'');
 
           if (! all_strings_p)
             warn_implicit_conversion ("Octave:num-to-str",
                                       "numeric", result_type);
           else
             octave::maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
           charNDArray result = do_single_type_concat<charNDArray> (args, dim);
@@ -6173,18 +6173,18 @@ This function is equivalent to the opera
 or @w{@code{base : increment : limit}}.
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  return (nargin == 2) ? do_colon_op (args(0), args(1))
-                       : do_colon_op (args(0), args(1), args(2));
+  return (nargin == 2 ? do_colon_op (args(0), args(1))
+                      : do_colon_op (args(0), args(1), args(2)));
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} tic ()
 @deftypefnx {} {@var{id} =} tic ()
@@ -7254,37 +7254,37 @@ do_merge (const Array<bool>& mask,
 
   if (tscl)
     {
       if (fscl)
         {
           T ts = tv[0];
           T fs = fv[0];
           for (octave_idx_type i = 0; i < n; i++)
-            rv[i] = mv[i] ? ts : fs;
+            rv[i] = (mv[i] ? ts : fs);
         }
       else
         {
           T ts = tv[0];
           for (octave_idx_type i = 0; i < n; i++)
-            rv[i] = mv[i] ? ts : fv[i];
+            rv[i] = (mv[i] ? ts : fv[i]);
         }
     }
   else
     {
       if (fscl)
         {
           T fs = fv[0];
           for (octave_idx_type i = 0; i < n; i++)
-            rv[i] = mv[i] ? tv[i] : fs;
+            rv[i] = (mv[i] ? tv[i] : fs);
         }
       else
         {
           for (octave_idx_type i = 0; i < n; i++)
-            rv[i] = mv[i] ? tv[i] : fv[i];
+            rv[i] = (mv[i] ? tv[i] : fv[i]);
         }
     }
 
   return retval;
 }
 
 #define MAKE_INT_BRANCH(INTX)                                           \
   else if (tval.is_ ## INTX ## _type () && fval.is_ ## INTX ## _type ()) \
@@ -7329,17 +7329,17 @@ converted to logical.
   if (! (args(0).is_bool_type () || args(0).is_numeric_type ()))
     error ("merge: first argument must be logical or numeric");
 
   octave_value retval;
 
   octave_value mask_val = args(0);
 
   if (mask_val.is_scalar_type ())
-    retval = mask_val.is_true () ? args(1) : args(2);
+    retval = (mask_val.is_true () ? args(1) : args(2));
   else
     {
       boolNDArray mask = mask_val.bool_array_value ();
 
       octave_value tval = args(1);
       octave_value fval = args(2);
 
       if (tval.is_double_type () && fval.is_double_type ())
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -118,17 +118,17 @@ subst_octave_home (const std::string& s)
   return retval;
 }
 
 static void
 set_octave_home (void)
 {
   std::string oh = octave::sys::env::getenv ("OCTAVE_HOME");
 
-  Voctave_home = oh.empty () ? std::string (OCTAVE_PREFIX) : oh;
+  Voctave_home = (oh.empty () ? std::string (OCTAVE_PREFIX) : oh);
 }
 
 static void
 set_default_info_dir (void)
 {
   Vinfo_dir = subst_octave_home (OCTAVE_INFODIR);
 }
 
@@ -308,43 +308,43 @@ static void
 set_default_doc_cache_file (void)
 {
   if (Vdoc_cache_file.empty ())
     {
       std::string def_file = subst_octave_home (OCTAVE_DOC_CACHE_FILE);
 
       std::string env_file = octave::sys::env::getenv ("OCTAVE_DOC_CACHE_FILE");
 
-      Vdoc_cache_file = env_file.empty () ? def_file : env_file;
+      Vdoc_cache_file = (env_file.empty () ? def_file : env_file);
     }
 }
 
 static void
 set_default_texi_macros_file (void)
 {
   if (Vtexi_macros_file.empty ())
     {
       std::string def_file = subst_octave_home (OCTAVE_TEXI_MACROS_FILE);
 
       std::string env_file = octave::sys::env::getenv ("OCTAVE_TEXI_MACROS_FILE");
 
-      Vtexi_macros_file = env_file.empty () ? def_file : env_file;
+      Vtexi_macros_file = (env_file.empty () ? def_file : env_file);
     }
 }
 
 static void
 set_default_info_file (void)
 {
   if (Vinfo_file.empty ())
     {
       std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
 
       std::string oct_info_file = octave::sys::env::getenv ("OCTAVE_INFO_FILE");
 
-      Vinfo_file = oct_info_file.empty () ? std_info_file : oct_info_file;
+      Vinfo_file = (oct_info_file.empty () ? std_info_file : oct_info_file);
     }
 }
 
 static void
 set_default_info_prog (void)
 {
   if (Vinfo_program.empty ())
     {
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -132,34 +132,34 @@ For that, use any of the condition numbe
       if (arg.is_real_type ())
         {
           octave_idx_type info;
           float rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           FloatMatrix m = arg.float_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_matrix);
-          MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
+          MatrixType mtype = (rep ? rep -> matrix_type () : MatrixType ());
           FloatDET det = m.determinant (mtype, info, rcond);
-          retval(0) = info == -1 ? 0.0f : det.value ();
+          retval(0) = (info == -1 ? 0.0f : det.value ());
           retval(1) = rcond;
           if (rep)
             rep->matrix_type (mtype);
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           float rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_complex_matrix);
-          MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
+          MatrixType mtype = (rep ? rep -> matrix_type () : MatrixType ());
           FloatComplexDET det = m.determinant (mtype, info, rcond);
-          retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
+          retval(0) = (info == -1 ? FloatComplex (0.0) : det.value ());
           retval(1) = rcond;
           if (rep)
             rep->matrix_type (mtype);
         }
     }
   else
     {
       if (arg.is_real_type ())
@@ -167,55 +167,55 @@ For that, use any of the condition numbe
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               DET det = m.determinant (info, rcond);
-              retval(0) = info == -1 ? 0.0 : det.value ();
+              retval(0) = (info == -1 ? 0.0 : det.value ());
               retval(1) = rcond;
             }
           else
             {
               Matrix m = arg.matrix_value ();
 
               MAYBE_CAST (rep, octave_matrix);
-              MatrixType mtype = rep ? rep -> matrix_type ()
-                                     : MatrixType ();
+              MatrixType mtype = (rep ? rep -> matrix_type ()
+                                      : MatrixType ());
               DET det = m.determinant (mtype, info, rcond);
-              retval(0) = info == -1 ? 0.0 : det.value ();
+              retval(0) = (info == -1 ? 0.0 : det.value ());
               retval(1) = rcond;
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               ComplexDET det = m.determinant (info, rcond);
-              retval(0) = info == -1 ? Complex (0.0) : det.value ();
+              retval(0) = (info == -1 ? Complex (0.0) : det.value ());
               retval(1) = rcond;
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               MAYBE_CAST (rep, octave_complex_matrix);
-              MatrixType mtype = rep ? rep -> matrix_type ()
-                                     : MatrixType ();
+              MatrixType mtype = (rep ? rep -> matrix_type ()
+                                      : MatrixType ());
               ComplexDET det = m.determinant (mtype, info, rcond);
-              retval(0) = info == -1 ? Complex (0.0) : det.value ();
+              retval(0) = (info == -1 ? Complex (0.0) : det.value ());
               retval(1) = rcond;
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else
         err_wrong_type_arg ("det", arg);
     }
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -183,17 +183,17 @@ The eigenvalues returned by @code{eig} a
     {
       if (balance_flag)
         error ("eig: invalid \"balance\" option for generalized eigenvalue problem");
       if (no_balance_flag)
         error ("eig: invalid \"nobalance\" option for generalized eigenvalue problem");
     }
 
   // Default is to balance
-  const bool balance = no_balance_flag ? false : true;
+  const bool balance = (no_balance_flag ? false : true);
   const bool force_qz = qz_flag;
 
 
   Matrix tmp_a, tmp_b;
   ComplexMatrix ctmp_a, ctmp_b;
   FloatMatrix ftmp_a, ftmp_b;
   FloatComplexMatrix fctmp_a, fctmp_b;
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -730,17 +730,17 @@ warning_1 (const char *id, const char *f
     {
       // Handle this warning as an error.
 
       error_1 (std::cerr, "error", id, fmt, args);
     }
   else if (warn_opt == 1)
     {
       bool fmt_suppresses_backtrace = false;
-      size_t fmt_len = fmt ? strlen (fmt) : 0;
+      size_t fmt_len = (fmt ? strlen (fmt) : 0);
       fmt_suppresses_backtrace = (fmt_len > 0 && fmt[fmt_len-1] == '\n');
 
       if (fmt_suppresses_backtrace && fmt_len > 1)
         {
           // Strip newline before issuing warning
           std::string tmp_fmt (fmt, fmt_len - 1);
           vwarning ("warning", id, tmp_fmt.c_str (), args);
         }
@@ -858,17 +858,17 @@ make_stack_frame_list (const octave_map&
   octave_idx_type nel = name.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       error_stack_frame frame;
 
       frame.name = name(i).string_value ();
       frame.line = line(i).int_value ();
-      frame.column = have_column ? column(i).int_value () : -1;
+      frame.column = (have_column ? column(i).int_value () : -1);
 
       frames.push_back (frame);
     }
 
   return frames;
 }
 
 static void
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -979,17 +979,17 @@ expanded even when the template string i
         tmp_args(i-1) = args(i);
     }
 
   // NOTE: Call to os.error must precede next call to ostr which might reset it.
   retval(2) = os.printf (fmt_arg, tmp_args, who);
   retval(1) = os.error ();
 
   std::string result = ostr->str ();
-  char type = fmt_arg.is_sq_string () ? '\'' : '"';
+  char type = (fmt_arg.is_sq_string () ? '\'' : '"');
 
   retval(0) = (result.empty () ? octave_value (charMatrix (1, 0), type)
                                : octave_value (result, type));
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -43,17 +43,17 @@ MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si,
         int dim = 0)
 {
   MArray<T> y;
 
   octave_idx_type a_len = a.numel ();
   octave_idx_type b_len = b.numel ();
 
-  octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
+  octave_idx_type ab_len = (a_len > b_len ? a_len : b_len);
 
   // FIXME: The two lines below should be unecessary because
   //        this template is called with a and b as column vectors
   //        already.  However the a.resize line is currently (2011/04/26)
   //        necessary to stop bug #33164.
   b.resize (dim_vector (ab_len, 1), 0.0);
   if (a_len > 1)
     a.resize (dim_vector (ab_len, 1), 0.0);
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -44,17 +44,17 @@ find_nonzero_elem_idx (const Array<T>& n
 
   Array<octave_idx_type> idx;
   if (n_to_find >= 0)
     idx = nda.find (n_to_find, direction == -1);
   else
     idx = nda.find ();
 
   // The maximum element is always at the end.
-  octave_idx_type iext = idx.is_empty () ? 0 : idx.xelem (idx.numel () - 1) + 1;
+  octave_idx_type iext = (idx.is_empty () ? 0 : idx.xelem (idx.numel () - 1) + 1);
 
   switch (nargout)
     {
     default:
     case 3:
       retval(2) = Array<T> (nda.index (idx_vector (idx)));
       // Fall through!
 
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -109,85 +109,85 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
       if (x_arg.is_scalar_type ())
         {
           float x = x_arg.float_value ();
 
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0f - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0f - octave::math::gammainc (x, a));
             }
           else
             {
               FloatNDArray a = a_arg.float_array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0f - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0f - octave::math::gammainc (x, a));
             }
         }
       else
         {
           FloatNDArray x = x_arg.float_array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0f - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0f - octave::math::gammainc (x, a));
             }
           else
             {
               FloatNDArray a = a_arg.float_array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0f - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0f - octave::math::gammainc (x, a));
             }
         }
     }
   else
     {
       if (x_arg.is_scalar_type ())
         {
           double x = x_arg.double_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0 - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0 - octave::math::gammainc (x, a));
             }
           else
             {
               NDArray a = a_arg.array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0 - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0 - octave::math::gammainc (x, a));
             }
         }
       else
         {
           NDArray x = x_arg.array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0 - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0 - octave::math::gammainc (x, a));
             }
           else
             {
               NDArray a = a_arg.array_value ();
 
-              retval = lower ? octave::math::gammainc (x, a)
-                             : 1.0 - octave::math::gammainc (x, a);
+              retval = (lower ? octave::math::gammainc (x, a)
+                              : 1.0 - octave::math::gammainc (x, a));
             }
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -140,18 +140,18 @@ extended_gcd (double a, double b, double
       lx = xx;
       xx = tx;
 
       double ty = ly - qq*yy;
       ly = yy;
       yy = ty;
     }
 
-  x = a >= 0 ? lx : -lx;
-  y = b >= 0 ? ly : -ly;
+  x = (a >= 0 ? lx : -lx);
+  y = (b >= 0 ? ly : -ly);
 
   return aa;
 }
 
 template <typename FP>
 static std::complex<FP>
 extended_gcd (const std::complex<FP>& a, const std::complex<FP>& b,
               std::complex<FP>& x, std::complex<FP>& y)
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1483,20 +1483,22 @@ namespace octave
                             zpTick, zpTick, 0.,
                             (is_origin_low ? -1. : 1.) *
                             octave::math::signum (ypTick-ypTickN)*fy*xticklen,
                             0., 0, ! is_origin && mirror);
 
         // tick texts
         if (xticklabels.numel () > 0)
           {
-            int halign = (xstate == AXE_HORZ_DIR ? 1 :
-                          (xyzSym || is_origin_low ? 0 : 2));
-            int valign = (xstate == AXE_VERT_DIR ? 1 :
-                          (x2Dtop || is_origin_low ? 0 : 2));
+            int halign = (xstate == AXE_HORZ_DIR
+                          ? 1
+                          : (xyzSym || is_origin_low ? 0 : 2));
+            int valign = (xstate == AXE_VERT_DIR
+                          ? 1
+                          : (x2Dtop || is_origin_low ? 0 : 2));
 
             if (tick_along_z)
               render_ticktexts (xticks, xticklabels, x_min, x_max,
                                 is_origin ? y_axis_pos : ypTick,
                                 zpTick +
                                 (is_origin_low ? -1. : 1.) *
                                 octave::math::signum (zpTick-zpTickN)*fz*xtickoffset,
                                 0, halign, valign, wmax, hmax);
@@ -1663,20 +1665,22 @@ namespace octave
                             zpTick, zpTick,
                             (is_origin_low ? -1. : 1.) *
                             octave::math::signum (xPlaneN-xPlane)*fx*yticklen,
                             0., 0., 1, ! is_origin && mirror);
 
         // tick texts
         if (yticklabels.numel () > 0)
           {
-            int halign = (ystate == AXE_HORZ_DIR ? 1 :
-                          (! xyzSym || y2Dright || is_origin_low ? 0 : 2));
-            int valign = (ystate == AXE_VERT_DIR ? 1 :
-                          (is_origin_low ? 0 : 2));
+            int halign = (ystate == AXE_HORZ_DIR
+                          ? 1
+                          : (! xyzSym || y2Dright || is_origin_low ? 0 : 2));
+            int valign = (ystate == AXE_VERT_DIR
+                          ? 1
+                          : (is_origin_low ? 0 : 2));
 
             if (tick_along_z)
               render_ticktexts (yticks, yticklabels, y_min, y_max,
                                 is_origin ? x_axis_pos : xpTick,
                                 zpTick +
                                 (is_origin_low ? -1. : 1.) *
                                 octave::math::signum (zpTick-zpTickN)*fz*ytickoffset,
                                 1, halign, valign, wmax, hmax);
@@ -2249,17 +2253,17 @@ namespace octave
     int el_mode = (props.edgelighting_is ("none") ? 0 :
                    (props.edgelighting_is ("flat") ? 1 : 2));
     int ea_mode = (props.edgealpha_is_double () ? 0 :
                    (props.edgealpha_is ("flat") ? 1 : 2));
     int bfl_mode = (props.backfacelighting_is ("lit") ? 0 :
                     (props.backfacelighting_is ("reverselit") ? 1 : 2));
 
     Matrix fcolor = (fc_mode == TEXTURE ? Matrix (1, 3, 1.0)
-                     : props.get_facecolor_rgb ());
+                                        : props.get_facecolor_rgb ());
     Matrix ecolor = props.get_edgecolor_rgb ();
 
     float as = props.get_ambientstrength ();
     float ds = props.get_diffusestrength ();
     float ss = props.get_specularstrength ();
     float se = props.get_specularexponent () * 5; // to fit Matlab
     float scr = props.get_specularcolorreflectance ();
     float cb[4] = { 0.0, 0.0, 0.0, 1.0 };
@@ -2325,18 +2329,18 @@ namespace octave
                     for (int i = 0; i < 3; i++)
                       cb[i] = ss * (scr + (1-scr) * fcolor(i));
                     glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                   }
               }
 
             if ((fl_mode > 0) && (num_lights > 0))
               glEnable (GL_LIGHTING);
-            glShadeModel ((fc_mode == INTERP || fl_mode == GOURAUD) ? GL_SMOOTH
-                          : GL_FLAT);
+            glShadeModel ((fc_mode == INTERP || fl_mode == GOURAUD)
+                          ? GL_SMOOTH : GL_FLAT);
             set_polygon_offset (true, 1);
             if (fc_mode == TEXTURE)
               glEnable (GL_TEXTURE_2D);
 
             for (int i = 1; i < zc; i++)
               {
                 if (y_mat)
                   {
@@ -2529,18 +2533,18 @@ namespace octave
                     for (int i = 0; i < 3; i++)
                       cb[i] = ss * (scr + (1-scr) * ecolor(i));
                     glMaterialfv (LIGHT_MODE, GL_SPECULAR, cb);
                   }
               }
 
             if ((el_mode > 0) && (num_lights > 0))
               glEnable (GL_LIGHTING);
-            glShadeModel ((ec_mode == INTERP || el_mode == GOURAUD) ? GL_SMOOTH
-                          : GL_FLAT);
+            glShadeModel ((ec_mode == INTERP || el_mode == GOURAUD)
+                          ? GL_SMOOTH : GL_FLAT);
 
             set_linestyle (props.get_linestyle (), false,
                            props.get_linewidth ());
             set_linewidth (props.get_linewidth ());
             set_linecap ("butt");
             set_linejoin ("miter");
 
             // Mesh along Y-axis
@@ -2801,19 +2805,19 @@ namespace octave
                     if (! octave::math::finite (c(j,i)))
                       continue;  // Skip NaNs in color data
 
                     for (int k = 0; k < 3; k++)
                       cc(k) = c(j,i,k);
                   }
 
                 Matrix lc = (do_edge ? (mecolor.is_empty () ? cc : mecolor)
-                             : Matrix ());
+                                     : Matrix ());
                 Matrix fc = (do_face ? (mfcolor.is_empty () ? cc : mfcolor)
-                             : Matrix ());
+                                     : Matrix ());
 
                 draw_marker (x(j1,i), y(j,i1), z(j,i), lc, fc);
               }
           }
 
         end_marker ();
       }
 
@@ -3274,19 +3278,19 @@ namespace octave
                   cc.resize (1, 3);
                   if (has_markerfacecolor)
                     cc(0) = c(i,0), cc(1) = c(i,1), cc(2) = c(i,2);
                   else
                     cc(0) = c(idx,0), cc(1) = c(idx,1), cc(2) = c(idx,2);
                 }
 
               Matrix lc = (do_edge ? (mecolor.is_empty () ? cc : mecolor)
-                           : Matrix ());
+                                   : Matrix ());
               Matrix fc = (do_face ? (mfcolor.is_empty () ? cc : mfcolor)
-                           : Matrix ());
+                                   : Matrix ());
 
               draw_marker (v(idx,0), v(idx,1), (has_z ? v(idx,2) : 0), lc, fc);
             }
 
         end_marker ();
       }
 
 #else
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1824,18 +1824,18 @@ property::create (const std::string& nam
   else if (type.compare ("double"))
     {
       double dv = (args.length () > 0 ? args(0).double_value () : 0.0);
 
       retval = property (new double_property (name, h, dv));
     }
   else if (type.compare ("handle"))
     {
-      double hv = args.length () > 0 ? args(0).double_value ()
-                                     : octave::numeric_limits<double>::NaN ();
+      double hv = (args.length () > 0 ? args(0).double_value ()
+                                      : octave::numeric_limits<double>::NaN ());
 
       graphics_handle gh (hv);
 
       retval = property (new handle_property (name, h, gh));
     }
   else if (type.compare ("boolean"))
     {
       retval = property (new bool_property (name, h, false));
@@ -5560,17 +5560,17 @@ axes::properties::update_camera (void)
   if (cameraviewanglemode_is ("auto"))
     {
       double af;
 
       // FIXME: was this really needed?  When compared to Matlab, it
       // does not seem to be required.  Need investigation with concrete
       // graphics toolkit to see results visually.
       if (false && dowarp)
-        af = 1.0 / (xM > yM ? xM : yM);
+        af = (1.0 / (xM > yM ? xM : yM));
       else
         {
           if ((bb(2)/bb(3)) > (xM/yM))
             af = 1.0 / yM;
           else
             af = 1.0 / xM;
         }
       v_angle = 2 * (180.0 / M_PI) * atan (1 / (2 * af * norm (F)));
@@ -5749,17 +5749,17 @@ axes::properties::update_axes_layout (vo
   fz = (z_max - z_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
 
   octave::unwind_protect frame;
   frame.protect_var (updating_axes_layout);
   updating_axes_layout = true;
 
   xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   zSign = (zd*(zPlane-zPlaneN) <= 0);
-  xyzSym = zSign ? xySym : ! xySym;
+  xyzSym = (zSign ? xySym : ! xySym);
   xpTick = (zSign ? xPlaneN : xPlane);
   ypTick = (zSign ? yPlaneN : yPlane);
   zpTick = (zSign ? zPlane : zPlaneN);
   xpTickN = (zSign ? xPlane : xPlaneN);
   ypTickN = (zSign ? yPlane : yPlaneN);
   zpTickN = (zSign ? zPlaneN : zPlane);
 
   // 2D mode
@@ -6472,18 +6472,18 @@ axes::properties::update_font (std::stri
 }
 
 // The INTERNAL flag defines whether position or outerposition is used.
 
 Matrix
 axes::properties::get_boundingbox (bool internal,
                                    const Matrix& parent_pix_size) const
 {
-  Matrix pos = internal ? get_position ().matrix_value ()
-                        : get_outerposition ().matrix_value ();
+  Matrix pos = (internal ? get_position ().matrix_value ()
+                         : get_outerposition ().matrix_value ());
   Matrix parent_size (parent_pix_size);
 
   if (parent_size.is_empty ())
     {
       graphics_object go = gh_manager::get_object (get_parent ());
 
       if (go.valid_object ())
         parent_size =
@@ -7172,17 +7172,17 @@ axes::properties::calc_ticks_and_lims (a
     }
   else
     tmp_ticks = ticks.get ().matrix_value ();
 
   octave_idx_type n_ticks = tmp_ticks.numel ();
   if (n_ticks < 2)
     return;
 
-  int n = is_logscale ? 8 : 4;
+  int n = (is_logscale ? 8 : 4);
   Matrix tmp_mticks (1, n * (n_ticks - 1));
 
   for (int i = 0; i < n_ticks-1; i++)
     {
       double d = (tmp_ticks(i+1) - tmp_ticks(i)) / (n + 1);
       for (int j = 0; j < n; j++)
         tmp_mticks(n*i+j) = tmp_ticks(i) + d * (j+1);
     }
@@ -8189,17 +8189,17 @@ axes::properties::unzoom (void)
 
       update_view ();
     }
 }
 
 void
 axes::properties::clear_zoom_stack (bool do_unzoom)
 {
-  size_t items_to_leave_on_stack = do_unzoom ? 7 : 0;
+  size_t items_to_leave_on_stack = (do_unzoom ? 7 : 0);
 
   while (zoom_stack.size () > items_to_leave_on_stack)
     zoom_stack.pop_front ();
 
   if (do_unzoom)
     unzoom ();
 }
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -192,18 +192,21 @@ class scaler
 public:
   scaler (void) : rep (new base_scaler ()) { }
 
   scaler (const scaler& s) : rep (s.rep->clone ()) { }
 
   scaler (const std::string& s)
     : rep (s == "log"
            ? new log_scaler ()
-           : (s == "neglog" ? new neg_log_scaler ()
-              : (s == "linear" ? new lin_scaler () : new base_scaler ())))
+           : (s == "neglog"
+              ? new neg_log_scaler ()
+              : (s == "linear"
+                 ? new lin_scaler ()
+                 : new base_scaler ())))
   { }
 
   ~scaler (void) { delete rep; }
 
   Matrix scale (const Matrix& m) const
   { return rep->scale (m); }
 
   NDArray scale (const NDArray& m) const
@@ -1438,17 +1441,17 @@ public:
     p->maxval = maxval;
 
     return p;
   }
 
 protected:
   bool do_set (const octave_value& v)
   {
-    octave_value tmp = v.is_sparse_type () ? v.full_value () : v;
+    octave_value tmp = (v.is_sparse_type () ? v.full_value () : v);
 
     if (! validate (tmp))
       error ("invalid value for array property \"%s\"",
              get_name ().c_str ());
 
     // FIXME: should we check for actual data change?
     if (! is_equal (tmp))
       {
@@ -4774,28 +4777,28 @@ public:
 
   private:
     void update_position (void)
     {
       Matrix pos = get_data_position ();
       Matrix lim;
 
       lim = Matrix (1, 3, pos(0));
-      lim(2) = lim(2) <= 0 ? octave::numeric_limits<double>::Inf () : lim(2);
+      lim(2) = (lim(2) <= 0 ? octave::numeric_limits<double>::Inf () : lim(2));
       set_xlim (lim);
 
       lim = Matrix (1, 3, pos(1));
-      lim(2) = lim(2) <= 0 ? octave::numeric_limits<double>::Inf () : lim(2);
+      lim(2) = (lim(2) <= 0 ? octave::numeric_limits<double>::Inf () : lim(2));
       set_ylim (lim);
 
       if (pos.numel () == 3)
         {
           lim = Matrix (1, 3, pos(2));
-          lim(2) = lim(2) <= 0 ? octave::numeric_limits<double>::Inf ()
-                               : lim(2);
+          lim(2) = (lim(2) <= 0 ? octave::numeric_limits<double>::Inf ()
+                                : lim(2));
           set_zliminclude ("on");
           set_zlim (lim);
         }
       else
         set_zliminclude ("off");
     }
 
     void update_text_extent (void);
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -808,18 +808,18 @@ Undocumented internal function.
 // FIXME: Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
       const int dir_len = dir.size ();
       const int filename_len = filename.size ();
-      const int max_allowed_seps = octave::sys::file_ops::is_dir_sep (dir[dir_len-1]) ? 0
-                                                                         : 1;
+      const int max_allowed_seps =
+        (octave::sys::file_ops::is_dir_sep (dir[dir_len-1]) ? 0 : 1);
 
       int num_seps = 0;
       for (int i = dir_len; i < filename_len; i++)
         if (octave::sys::file_ops::is_dir_sep (filename[i]))
           num_seps++;
 
       return (num_seps <= max_allowed_seps);
     }
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -69,17 +69,17 @@ hex2num (const std::string& hex, void *n
 
   if (nc > nchars)
     error ("hex2num: S must be no more than %d characters", nchars);
 
   size_t j = 0;
 
   for (size_t i = 0; i < nbytes; i++)
     {
-      size_t k = swap_bytes ? nbytes - i - 1 : i;
+      size_t k = (swap_bytes ? nbytes - i - 1 : i);
 
       unsigned char ch1 = (j < nc) ? hex[j++] : '0';
       unsigned char ch2 = (j < nc) ? hex[j++] : '0';
 
       cp[k] = (hex2nibble (ch1) << 4) + hex2nibble (ch2);
     }
 }
 
@@ -224,17 +224,17 @@ static inline void
 num2hex (const void *p, size_t n, char *hex, bool swap_bytes)
 {
   const unsigned char *cp = reinterpret_cast<const unsigned char *> (p);
 
   size_t k = 0;
 
   for (size_t i = 0; i < n; i++)
     {
-      size_t j = swap_bytes ? n - i - 1 : i;
+      size_t j = (swap_bytes ? n - i - 1 : i);
 
       unsigned char ch = cp[j];
 
       hex[k++] = nibble2hex ((ch >> 4) & 0xF);
       hex[k++] = nibble2hex (ch & 0xF);
     }
 }
 
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -177,17 +177,17 @@ sparse matrix if possible.
       else
         err_wrong_type_arg ("inv", arg);
     }
 
   octave_value_list retval (nargout > 1 ? 2 : 1);
 
   retval(0) = result;
   if (nargout > 1)
-    retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
+    retval(1) = (isfloat ? octave_value (frcond) : octave_value (rcond));
 
   bool rcond_plus_one_eq_one = false;
 
   if (isfloat)
     {
       volatile float xrcond = frcond;
       rcond_plus_one_eq_one = xrcond + 1.0F == 1.0F;
     }
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1632,17 +1632,17 @@ the file @file{data} in Octave's binary 
 
       i++;
 
       // Matlab v7 files are always compressed
       if (format == LS_MAT7_BINARY)
         use_zlib = false;
 
       std::ios::openmode mode
-        = append ? (std::ios::app | std::ios::ate) : std::ios::out;
+        = (append ? (std::ios::app | std::ios::ate) : std::ios::out);
 
       if (format == LS_BINARY
 #if defined (HAVE_HDF5)
           || format == LS_HDF5
 #endif
           || format == LS_MAT_BINARY
           || format == LS_MAT5_BINARY
           || format == LS_MAT7_BINARY)
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -342,18 +342,18 @@ at most n-1).
       else if (match_idx)
         {
           NDArray ridx (idx.dims ());
           if (match_idx)
             {
               for (octave_idx_type i = 0; i < nval; i++)
                 {
                   octave_idx_type j = idx.xelem (i);
-                  ridx.xelem (i) = (j != 0 && str_y(i) == str_table(j-1)) ? j
-                                                                          : 0;
+                  ridx.xelem (i) = (j != 0 && str_y(i) == str_table(j-1) ? j
+                                                                         : 0);
                 }
             }
 
           retval = ridx;
         }
       else
         retval = idx;
     }
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -323,17 +323,17 @@ read_mat_binary_data (std::istream& is, 
 
             for (octave_idx_type i = 0; i < nr - 1; i++)
               data.xelem (i) = Complex (dtmp[i], ctmp[i]);
             read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
 
             SparseComplexMatrix smc = SparseComplexMatrix (data, r, c,
                                                            nr_new, nc_new);
 
-            tc = order ? smc.transpose () : smc;
+            tc = (order ? smc.transpose () : smc);
           }
         else
           {
             octave_idx_type nr_new, nc_new;
             Array<double> data (dim_vector (1, nr - 1));
             Array<octave_idx_type> c (dim_vector (1, nr - 1));
             Array<octave_idx_type> r (dim_vector (1, nr - 1));
             OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
@@ -347,17 +347,17 @@ read_mat_binary_data (std::istream& is, 
               c.xelem (i) = dtmp[i] - 1;
             nc_new = dtmp[nr - 1];
             read_mat_binary_data (is, data.fortran_vec (), prec, nr - 1,
                                   swap, flt_fmt);
             read_mat_binary_data (is, dtmp, prec, 1, swap, flt_fmt);
 
             SparseMatrix sm = SparseMatrix (data, r, c, nr_new, nc_new);
 
-            tc = order ? sm.transpose () : sm;
+            tc = (order ? sm.transpose () : sm);
           }
       }
     else
       {
         Matrix re (nr, nc);
 
         read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
 
@@ -375,20 +375,20 @@ read_mat_binary_data (std::istream& is, 
               error ("load: reading imaginary matrix data for '%s'", name);
 
             ComplexMatrix ctmp (nr, nc);
 
             for (octave_idx_type j = 0; j < nc; j++)
               for (octave_idx_type i = 0; i < nr; i++)
                 ctmp (i,j) = Complex (re(i,j), im(i,j));
 
-            tc = order ? ctmp.transpose () : ctmp;
+            tc = (order ? ctmp.transpose () : ctmp);
           }
         else
-          tc = order ? re.transpose () : re;
+          tc = (order ? re.transpose () : re);
 
         if (type == 1)
           tc = tc.convert_to_str (false, true, '\'');
       }
 
     return retval;
   }
 }
@@ -417,28 +417,28 @@ save_mat_binary_data (std::ostream& os, 
   int32_t nc = tc.columns ();
 
   if (tc.is_sparse_type ())
     {
       len = tc.nnz ();
       uint32_t nnz = len + 1;
       os.write (reinterpret_cast<char *> (&nnz), 4);
 
-      uint32_t iscmplx = tc.is_complex_type () ? 4 : 3;
+      uint32_t iscmplx = (tc.is_complex_type () ? 4 : 3);
       os.write (reinterpret_cast<char *> (&iscmplx), 4);
 
       uint32_t tmp = 0;
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
   else
     {
       os.write (reinterpret_cast<char *> (&nr), 4);
       os.write (reinterpret_cast<char *> (&nc), 4);
 
-      int32_t imag = tc.is_complex_type () ? 1 : 0;
+      int32_t imag = (tc.is_complex_type () ? 1 : 0);
       os.write (reinterpret_cast<char *> (&imag), 4);
 
       len = nr * nc;
     }
 
   // LEN includes the terminating character, and the file is also
   // supposed to include it.
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2583,17 +2583,17 @@ save_mat5_binary_element (std::ostream& 
           write_mat5_array (os, ::real (m_cmplx), save_as_floats);
           write_mat5_array (os, ::imag (m_cmplx), save_as_floats);
         }
     }
   else if (tc.is_map () || tc.is_inline_function () || tc.is_object ())
     {
       if (tc.is_inline_function () || tc.is_object ())
         {
-          std::string classname = tc.is_object () ? tc.class_name () : "inline";
+          std::string classname = (tc.is_object () ? tc.class_name () : "inline");
           size_t namelen = classname.length ();
 
           if (namelen > max_namelen)
             namelen = max_namelen; // Truncate names if necessary
 
           int paddedlength = PAD (namelen);
 
           write_mat5_tag (os, miINT8, namelen);
diff --git a/libinterp/corefcn/ls-oct-binary.cc b/libinterp/corefcn/ls-oct-binary.cc
--- a/libinterp/corefcn/ls-oct-binary.cc
+++ b/libinterp/corefcn/ls-oct-binary.cc
@@ -173,17 +173,17 @@ read_binary_data (std::istream& is, bool
     tdoc[doc_len] = '\0';
     if (! is.read (reinterpret_cast<char *> (tdoc), doc_len))
       error ("load: trouble reading binary file '%s'", filename.c_str ());
     doc = tdoc;
   }
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     error ("load: trouble reading binary file '%s'", filename.c_str ());
-  global = tmp ? 1 : 0;
+  global = (tmp ? 1 : 0);
 
   tmp = 0;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     error ("load: trouble reading binary file '%s'", filename.c_str ());
 
   // All cases except 255 kept for backwards compatibility
   switch (tmp)
     {
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -263,17 +263,17 @@ read_text_data (std::istream& is, const 
 
   std::string typ;
   size_t pos = tag.rfind (' ');
 
   if (pos != std::string::npos)
     {
       global = SUBSTRING_COMPARE_EQ (tag, 0, 6, "global");
 
-      typ = global ? tag.substr (7) : tag;
+      typ = (global ? tag.substr (7) : tag);
     }
   else
     typ = tag;
 
   // Special case for backward compatibility.  A small bit of cruft
   if (SUBSTRING_COMPARE_EQ (typ, 0, 12, "string array"))
     tc = charMatrix ();
   else
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -609,17 +609,17 @@ factorization from scratch.
 
   if (nargin != 4 && nargin != 5)
     print_usage ();
 
   bool pivoted = (nargin == 5);
 
   octave_value argl = args(0);
   octave_value argu = args(1);
-  octave_value argp = pivoted ? args(2) : octave_value ();
+  octave_value argp = (pivoted ? args(2) : octave_value ());
   octave_value argx = args(2 + pivoted);
   octave_value argy = args(3 + pivoted);
 
   if (! (argl.is_numeric_type () && argu.is_numeric_type ()
          && argx.is_numeric_type () && argy.is_numeric_type ()
          && (! pivoted || argp.is_perm_matrix ())))
     error ("luupdate: L, U, X, and Y must be numeric");
 
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -238,17 +238,17 @@ do_minmax_body (const octave_value_list&
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   octave_value_list retval (nargout > 1 ? 2 : 1);
 
-  const char *func = ismin ? "min" : "max";
+  const char *func = (ismin ? "min" : "max");
 
   if (nargin == 3 || nargin == 1)
     {
       octave_value arg = args(0);
       int dim = -1;
       if (nargin == 3)
         {
           dim = args(2).int_value (true) - 1;
@@ -912,17 +912,17 @@ static octave_value_list
 do_cumminmax_body (const octave_value_list& args,
                    int nargout, bool ismin)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  const char *func = ismin ? "cummin" : "cummax";
+  const char *func = (ismin ? "cummin" : "cummax");
 
   octave_value arg = args(0);
   int dim = -1;
   if (nargin == 2)
     {
       dim = args(1).int_value (true) - 1;
 
       if (dim < 0)
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -120,17 +120,17 @@ calc_single_subscript_internal (mwSize n
     case 1:
       retval = subs[0];
       break;
 
     default:
       {
         // Both nsubs and ndims should be at least 2 here.
 
-        mwSize n = nsubs <= ndims ? nsubs : ndims;
+        mwSize n = (nsubs <= ndims ? nsubs : ndims);
 
         retval = subs[--n];
 
         while (--n >= 0)
           retval = dims[n] * retval + subs[n];
       }
       break;
     }
@@ -1671,17 +1671,17 @@ private:
     for (int i = 0; i < nfields; i++)
       fields[i] = mxArray::strsave (val.fields[i]);
 
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel * nfields; i++)
       {
         mxArray *ptr = val.data[i];
-        data[i] = ptr ? ptr->dup () : 0;
+        data[i] = (ptr ? ptr->dup () : 0);
       }
   }
 
 public:
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
@@ -1911,17 +1911,17 @@ private:
       data (static_cast<mxArray **> (mxArray::malloc (get_number_of_elements ()
                                                       * sizeof (mxArray *))))
   {
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel; i++)
       {
         mxArray *ptr = val.data[i];
-        data[i] = ptr ? ptr->dup () : 0;
+        data[i] = (ptr ? ptr->dup () : 0);
       }
   }
 
 public:
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
@@ -3092,17 +3092,17 @@ call_mex (bool have_fmex, void *f, const
 
   volatile int nargout = nargout_arg;
 
   int nargin = args.length ();
   OCTAVE_LOCAL_BUFFER (mxArray *, argin, nargin);
   for (int i = 0; i < nargin; i++)
     argin[i] = 0;
 
-  int nout = nargout == 0 ? 1 : nargout;
+  int nout = (nargout == 0 ? 1 : nargout);
   OCTAVE_LOCAL_BUFFER (mxArray *, argout, nout);
   for (int i = 0; i < nout; i++)
     argout[i] = 0;
 
   octave::unwind_protect_safe frame;
 
   // Save old mex pointer.
   frame.protect_var (mex_context);
@@ -3220,17 +3220,17 @@ mexCallMATLAB (int nargout, mxArray *arg
 }
 
 mxArray *
 mexCallMATLABWithTrap (int nargout, mxArray *argout[], int nargin,
                        mxArray *argin[], const char *fname)
 {
   mxArray *mx = NULL;
 
-  int old_flag = mex_context ? mex_context->trap_feval_error : 0;
+  int old_flag = (mex_context ? mex_context->trap_feval_error : 0);
   mexSetTrapFlag (1);
   if (mexCallMATLAB (nargout, argout, nargin, argin, fname))
     {
       const char *field_names[] = {"identifier", "message", "case", "stack"};
       mx = mxCreateStructMatrix (1, 1, 4, field_names);
       mxSetFieldByNumber (mx, 0, 0, mxCreateString ("Octave:MEX"));
       std::string msg = "mexCallMATLABWithTrap: function call <"
                         + std::string (fname) + "> failed";
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -93,17 +93,17 @@ default_history_size (void)
 
   std::string env_size = octave::sys::env::getenv ("OCTAVE_HISTSIZE");
 
   if (! env_size.empty ())
     {
       int val;
 
       if (sscanf (env_size.c_str (), "%d", &val) == 1)
-        size = val > 0 ? val : 0;
+        size = (val > 0 ? val : 0);
     }
 
   return size;
 }
 
 static std::string
 default_history_timestamp_format (void)
 {
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -1159,17 +1159,17 @@ octave_map::assign (const octave_value_l
 }
 
 void
 octave_map::assign (const octave_value_list& idx, const std::string& k,
                     const Cell& rhs)
 {
   Cell tmp;
   iterator p = seek (k);
-  Cell& ref = p != end () ? contents (p) : tmp;
+  Cell& ref = (p != end () ? contents (p) : tmp);
 
   if (&ref == &tmp)
     ref = Cell (dimensions);
 
   ref.assign (idx, rhs);
 
   if (ref.dims () != dimensions)
     {
diff --git a/libinterp/corefcn/oct-procbuf.cc b/libinterp/corefcn/oct-procbuf.cc
--- a/libinterp/corefcn/oct-procbuf.cc
+++ b/libinterp/corefcn/oct-procbuf.cc
@@ -68,17 +68,17 @@ static octave_procbuf *octave_procbuf_li
 octave_procbuf *
 octave_procbuf::open (const char *command, int mode)
 {
 #if defined (__CYGWIN__) || defined (__MINGW32__) || defined (_MSC_VER)
 
   if (is_open ())
     return 0;
 
-  f = octave_popen (command, (mode & std::ios::in) ? "r" : "w");
+  f = (octave_popen (command, (mode & std::ios::in) ? "r" : "w"));
 
   if (! f)
     return 0;
 
   // Oops... popen doesn't return the associated pid, so fake it for now
 
   proc_pid = 1;
 
@@ -147,17 +147,17 @@ octave_procbuf::open (const char *comman
   octave_close_wrapper (child_end);
 
   if (proc_pid < 0)
     {
       octave_close_wrapper (parent_end);
       return 0;
     }
 
-  f = ::fdopen (parent_end, (mode & std::ios::in) ? "r" : "w");
+  f = (::fdopen (parent_end, (mode & std::ios::in) ? "r" : "w"));
 
   if (mode & std::ios::out)
     ::setvbuf (f, 0, _IOLBF, BUFSIZ);
 
   open_p = true;
 
   next = octave_procbuf_list;
   octave_procbuf_list = this;
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2710,18 +2710,19 @@ namespace octave
     // convert return value to Cell array
     Array<octave_idx_type> ra_idx (dim_vector (1,2));
 
     // (err & 1) means "error, and no columns read this row
     // FIXME: This may redundant now that done_after=0 says the same
     if (err & 1)
       done_after = out.size () + 1;
 
-    int valid_rows = (row == ntimes) ? ntimes
-      : (((err & 1) && (err & 8)) ? row : row+1);
+    int valid_rows = (row == ntimes
+                      ? ntimes
+                      : ((err & 1) && (err & 8)) ? row : row+1);
     dim_vector dv (valid_rows, 1);
 
     ra_idx(0) = 0;
     int i = 0;
     if (! collect_output)
       {
         retval = Cell (dim_vector (1, out.size ()));
         for (auto& col : out)
@@ -2970,18 +2971,18 @@ namespace octave
                 char *pos = is.tellg ();
                 std::ios::iostate state = is.rdstate ();
 
                 is.get ();
                 ch2 = is.get ();
                 if (ch2 == 'f')
                   {
                     inf = true;
-                    re = (ch == '+') ? octave::numeric_limits<double>::Inf ()
-                      : -octave::numeric_limits<double>::Inf ();
+                    re = (ch == '+' ? octave::numeric_limits<double>::Inf ()
+                                    : -octave::numeric_limits<double>::Inf ());
                     value = 0;
                   }
                 else
                   {
                     is.clear (state);
                     is.seekg (pos);   // reset to position before look-ahead
                   }
               }
@@ -3844,17 +3845,17 @@ namespace octave
     char *look = is.read (&tmp[0], tmp.size (), pos);
 
     is.clear ();
     is.seekg (pos);              // reset to position before look-ahead
                                  // FIXME: pos may be corrupted by is.read
 
     int i;
     int (*compare)(const char *, const char *, size_t);
-    compare = case_sensitive ? strncmp : strncasecmp;
+    compare = (case_sensitive ? strncmp : strncasecmp);
 
     for (i = 0; i < targets.numel (); i++)
       {
         std::string s = targets (i).string_value ();
         if (! (*compare) (s.c_str (), look, s.size ()))
           {
             is.read (&tmp[0], s.size (), pos); // read just the right amount
             break;
@@ -4417,17 +4418,17 @@ namespace octave
   else                                          \
     is.setstate (std::ios::failbit);            \
 }                                               \
   while (0)
 
 #define BEGIN_C_CONVERSION()                                            \
   is.unsetf (std::ios::skipws);                                         \
                                                                         \
-  int width = elt->width ? elt->width : 1;                              \
+  int width = (elt->width ? elt->width : 1);                            \
                                                                         \
   std::string tmp (width, '\0');                                        \
                                                                         \
   int c = std::istream::traits_type::eof ();                            \
   int n = 0;                                                            \
                                                                         \
   while (is && n < width                                                \
          && (c = is.get ()) != std::istream::traits_type::eof ())       \
@@ -5510,18 +5511,18 @@ do_printf_string (std::ostream& os, cons
     ::error ("%s: internal error handling format", who.c_str ());
 
   std::string flags = elt->flags;
 
   bool left = flags.find ('-') != std::string::npos;
 
   size_t len = arg.length ();
 
-  size_t fw = nsa > 0 ? sa_1 : (elt->fw == -1 ? len : elt->fw);
-  size_t prec = nsa > 1 ? sa_2 : (elt->prec == -1 ? len : elt->prec);
+  size_t fw = (nsa > 0 ? sa_1 : (elt->fw == -1 ? len : elt->fw));
+  size_t prec = (nsa > 1 ? sa_2 : (elt->prec == -1 ? len : elt->prec));
 
   os << std::setw (fw)
      << (left ? std::left : std::right)
      << (prec < len ? arg.substr (0, prec) : arg);
 
   return len > fw ? len : fw;
 }
 
@@ -5646,17 +5647,17 @@ namespace octave
               tval = (lo_ieee_is_NA (dval) ? "NA" : "NaN");
           }
 
         retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2, tval, who);
       }
     else
       {
         static std::string llmod
-          = sizeof (long) == sizeof (int64_t) ? "l" : "ll";
+          = (sizeof (long) == sizeof (int64_t) ? "l" : "ll");
 
         char type = elt->type;
 
         switch (type)
           {
           case 'd': case 'i': case 'c':
             if (ok_for_signed_int_conv (val))
               {
@@ -5886,17 +5887,17 @@ namespace octave
     return retval;
   }
 
   // Return current error message for this stream.
 
   std::string
   base_stream::error (bool clear_err, int& err_num)
   {
-    err_num = fail ? -1 : 0;
+    err_num = (fail ? -1 : 0);
 
     std::string tmp = errmsg;
 
     if (clear_err)
       clear ();
 
     return tmp;
   }
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -175,17 +175,17 @@ public:
   float_format& uppercase (void) { up = std::ios::uppercase; return *this; }
   float_format& lowercase (void) { up = 0; return *this; }
 
   float_format& precision (int p) { prec = p; return *this; }
 
   float_format& width (int w) { fw = w; return *this; }
 
   float_format& trailing_zeros (bool tz = true)
-  { sp = tz ? std::ios::showpoint : 0; return *this; }
+  { sp = (tz ? std::ios::showpoint : 0); return *this; }
 
   friend std::ostream& operator << (std::ostream& os,
                                     const pr_engineering_float& pef);
 
   friend std::ostream& operator << (std::ostream& os,
                                     const pr_formatted_float& pff);
 
   friend std::ostream& operator << (std::ostream& os,
@@ -568,17 +568,17 @@ set_real_format (int digits, bool inf_or
 
   if (rat_format)
     {
       fw = 0;
       rd = 0;
     }
   else if (bank_format)
     {
-      fw = digits < 0 ? 5 : digits + 4;
+      fw = (digits < 0 ? 5 : digits + 4);
       if (inf_or_nan && fw < 5)
         fw = 5;
       rd = 2;
     }
   else if (hex_format)
     {
       fw = 2 * sizeof (double);
       rd = 0;
@@ -595,22 +595,22 @@ set_real_format (int digits, bool inf_or
         fw = 4;
       rd = fw;
     }
   else
     {
       if (digits > 0)
         {
           ld = digits;
-          rd = prec > digits ? prec - digits : prec;
+          rd = (prec > digits ? prec - digits : prec);
         }
       else
         {
           ld = 1;
-          rd = prec > digits ? prec - digits : prec;
+          rd = (prec > digits ? prec - digits : prec);
         }
 
       fw = 1 + ld + 1 + rd;
       if (inf_or_nan && fw < 4)
         fw = 4;
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
@@ -660,17 +660,17 @@ set_format (double d, int& fw)
 
   if (free_format)
     return;
 
   bool inf_or_nan = (octave::math::isinf (d) || octave::math::isnan (d));
 
   bool int_only = (! inf_or_nan && octave::math::x_nint (d) == d);
 
-  double d_abs = d < 0.0 ? -d : d;
+  double d_abs = (d < 0.0 ? -d : d);
 
   int digits = (inf_or_nan || d_abs == 0.0) ? 0 : num_digits (d_abs);
 
   set_real_format (digits, inf_or_nan, int_only, fw);
 }
 
 static inline void
 set_format (double d)
@@ -691,18 +691,18 @@ set_real_matrix_format (int x_max, int x
 
   if (rat_format)
     {
       fw = 9;
       rd = 0;
     }
   else if (bank_format)
     {
-      int digits = x_max > x_min ? x_max : x_min;
-      fw = digits <= 0 ? 5 : digits + 4;
+      int digits = (x_max > x_min ? x_max : x_min);
+      fw = (digits <= 0 ? 5 : digits + 4);
       if (inf_or_nan && fw < 5)
         fw = 5;
       rd = 2;
     }
   else if (hex_format)
     {
       fw = 2 * sizeof (double);
       rd = 0;
@@ -716,54 +716,54 @@ set_real_matrix_format (int x_max, int x
     {
       rd = prec;
       fw = rd + 2;
       if (inf_or_nan && fw < 4)
         fw = 4;
     }
   else if (int_or_inf_or_nan)
     {
-      int digits = x_max > x_min ? x_max : x_min;
-      fw = digits <= 0 ? 2 : digits + 1;
+      int digits = (x_max > x_min ? x_max : x_min);
+      fw = (digits <= 0 ? 2 : digits + 1);
       if (inf_or_nan && fw < 4)
         fw = 4;
       rd = fw;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
         {
           ld_max = x_max;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max++;
         }
       else
         {
           ld_max = 1;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max = -x_max + 1;
         }
 
       int ld_min, rd_min;
       if (x_min > 0)
         {
           ld_min = x_min;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min++;
         }
       else
         {
           ld_min = 1;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min = -x_min + 1;
         }
 
-      ld = ld_max > ld_min ? ld_max : ld_min;
-      rd = rd_max > rd_min ? rd_max : rd_min;
+      ld = (ld_max > ld_min ? ld_max : ld_min);
+      rd = (rd_max > rd_min ? rd_max : rd_min);
 
       fw = 1 + ld + 1 + rd;
       if (inf_or_nan && fw < 4)
         fw = 4;
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
@@ -817,19 +817,19 @@ set_format (const Matrix& m, int& fw, do
   bool inf_or_nan = m.any_element_is_inf_or_nan ();
 
   bool int_or_inf_or_nan = m.all_elements_are_int_or_inf_or_nan ();
 
   Matrix m_abs = m.abs ();
   double max_abs = pr_max_internal (m_abs);
   double min_abs = pr_min_internal (m_abs);
 
-  int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
-
-  int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
+  int x_max = (max_abs == 0.0 ? 0 : num_digits (max_abs));
+
+  int x_min = (min_abs == 0.0 ? 0 : num_digits (min_abs));
 
   scale = (x_max == 0 || int_or_inf_or_nan)
           ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_real_matrix_format (x_max, x_min, inf_or_nan, int_or_inf_or_nan, fw);
 }
 
 static void
@@ -848,17 +848,17 @@ set_complex_format (int x_max, int x_min
       i_fw = 0;
       r_fw = 0;
       rd = 0;
     }
   else if (bank_format)
     {
       int digits = r_x;
       i_fw = 0;
-      r_fw = digits <= 0 ? 5 : digits + 4;
+      r_fw = (digits <= 0 ? 5 : digits + 4);
       if (inf_or_nan && r_fw < 5)
         r_fw = 5;
       rd = 2;
     }
   else if (hex_format)
     {
       r_fw = 2 * sizeof (double);
       i_fw = 2 * sizeof (double);
@@ -867,58 +867,58 @@ set_complex_format (int x_max, int x_min
   else if (bit_format)
     {
       r_fw = 8 * sizeof (double);
       i_fw = 8 * sizeof (double);
       rd = 0;
     }
   else if (inf_or_nan || int_only)
     {
-      int digits = x_max > x_min ? x_max : x_min;
-      i_fw = digits <= 0 ? 1 : digits;
+      int digits = (x_max > x_min ? x_max : x_min);
+      i_fw = (digits <= 0 ? 1 : digits);
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
         {
           i_fw = 3;
           r_fw = 4;
         }
       rd = r_fw;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
         {
           ld_max = x_max;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max++;
         }
       else
         {
           ld_max = 1;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max = -x_max + 1;
         }
 
       int ld_min, rd_min;
       if (x_min > 0)
         {
           ld_min = x_min;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min++;
         }
       else
         {
           ld_min = 1;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min = -x_min + 1;
         }
 
-      ld = ld_max > ld_min ? ld_max : ld_min;
-      rd = rd_max > rd_min ? rd_max : rd_min;
+      ld = (ld_max > ld_min ? ld_max : ld_min);
+      rd = (rd_max > rd_min ? rd_max : rd_min);
 
       i_fw = ld + 1 + rd;
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
         {
           i_fw = 3;
           r_fw = 4;
         }
@@ -997,18 +997,18 @@ set_format (const Complex& c, int& r_fw,
   double rp = c.real ();
   double ip = c.imag ();
 
   bool inf_or_nan = (octave::math::isinf (c) || octave::math::isnan (c));
 
   bool int_only = (octave::math::x_nint (rp) == rp
                    && octave::math::x_nint (ip) == ip);
 
-  double r_abs = rp < 0.0 ? -rp : rp;
-  double i_abs = ip < 0.0 ? -ip : ip;
+  double r_abs = (rp < 0.0 ? -rp : rp);
+  double i_abs = (ip < 0.0 ? -ip : ip);
 
   int r_x = (! octave::math::finite (rp)
              || r_abs == 0.0) ? 0 : num_digits (r_abs);
 
   int i_x = (! octave::math::finite (ip)
              || i_abs == 0.0) ? 0 : num_digits (i_abs);
 
   int x_max, x_min;
@@ -1049,19 +1049,19 @@ set_complex_matrix_format (int x_max, in
   if (rat_format)
     {
       i_fw = 9;
       r_fw = 9;
       rd = 0;
     }
   else if (bank_format)
     {
-      int digits = r_x_max > r_x_min ? r_x_max : r_x_min;
+      int digits = (r_x_max > r_x_min ? r_x_max : r_x_min);
       i_fw = 0;
-      r_fw = digits <= 0 ? 5 : digits + 4;
+      r_fw = (digits <= 0 ? 5 : digits + 4);
       if (inf_or_nan && r_fw < 5)
         r_fw = 5;
       rd = 2;
     }
   else if (hex_format)
     {
       r_fw = 2 * sizeof (double);
       i_fw = 2 * sizeof (double);
@@ -1081,58 +1081,58 @@ set_complex_matrix_format (int x_max, in
       if (inf_or_nan && i_fw < 3)
         {
           i_fw = 3;
           r_fw = 4;
         }
     }
   else if (int_or_inf_or_nan)
     {
-      int digits = x_max > x_min ? x_max : x_min;
-      i_fw = digits <= 0 ? 1 : digits;
+      int digits = (x_max > x_min ? x_max : x_min);
+      i_fw = (digits <= 0 ? 1 : digits);
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
         {
           i_fw = 3;
           r_fw = 4;
         }
       rd = r_fw;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
         {
           ld_max = x_max;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max++;
         }
       else
         {
           ld_max = 1;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max = -x_max + 1;
         }
 
       int ld_min, rd_min;
       if (x_min > 0)
         {
           ld_min = x_min;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min++;
         }
       else
         {
           ld_min = 1;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min = -x_min + 1;
         }
 
-      ld = ld_max > ld_min ? ld_max : ld_min;
-      rd = rd_max > rd_min ? rd_max : rd_min;
+      ld = (ld_max > ld_min ? ld_max : ld_min);
+      rd = (rd_max > rd_min ? rd_max : rd_min);
 
       i_fw = ld + 1 + rd;
       r_fw = i_fw + 1;
       if (inf_or_nan && i_fw < 3)
         {
           i_fw = 3;
           r_fw = 4;
         }
@@ -1221,26 +1221,26 @@ set_format (const ComplexMatrix& cm, int
   Matrix r_m_abs = rp.abs ();
   double r_max_abs = pr_max_internal (r_m_abs);
   double r_min_abs = pr_min_internal (r_m_abs);
 
   Matrix i_m_abs = ip.abs ();
   double i_max_abs = pr_max_internal (i_m_abs);
   double i_min_abs = pr_min_internal (i_m_abs);
 
-  int r_x_max = r_max_abs == 0.0 ? 0 : num_digits (r_max_abs);
-
-  int r_x_min = r_min_abs == 0.0 ? 0 : num_digits (r_min_abs);
-
-  int i_x_max = i_max_abs == 0.0 ? 0 : num_digits (i_max_abs);
-
-  int i_x_min = i_min_abs == 0.0 ? 0 : num_digits (i_min_abs);
-
-  int x_max = r_x_max > i_x_max ? r_x_max : i_x_max;
-  int x_min = r_x_min > i_x_min ? r_x_min : i_x_min;
+  int r_x_max = (r_max_abs == 0.0 ? 0 : num_digits (r_max_abs));
+
+  int r_x_min = (r_min_abs == 0.0 ? 0 : num_digits (r_min_abs));
+
+  int i_x_max = (i_max_abs == 0.0 ? 0 : num_digits (i_max_abs));
+
+  int i_x_min = (i_min_abs == 0.0 ? 0 : num_digits (i_min_abs));
+
+  int x_max = (r_x_max > i_x_max ? r_x_max : i_x_max);
+  int x_min = (r_x_min > i_x_min ? r_x_min : i_x_min);
 
   scale = (x_max == 0 || int_or_inf_or_nan)
           ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_complex_matrix_format (x_max, x_min, r_x_max, r_x_min, inf_or_nan,
                              int_or_inf_or_nan, r_fw, i_fw);
 }
 
@@ -1255,73 +1255,73 @@ set_range_format (int x_max, int x_min, 
 
   if (rat_format)
     {
       fw = 9;
       rd = 0;
     }
   else if (bank_format)
     {
-      int digits = x_max > x_min ? x_max : x_min;
-      fw = digits < 0 ? 5 : digits + 4;
+      int digits = (x_max > x_min ? x_max : x_min);
+      fw = (digits < 0 ? 5 : digits + 4);
       rd = 2;
     }
   else if (hex_format)
     {
       fw = 2 * sizeof (double);
       rd = 0;
     }
   else if (bit_format)
     {
       fw = 8 * sizeof (double);
       rd = 0;
     }
   else if (all_ints)
     {
-      int digits = x_max > x_min ? x_max : x_min;
+      int digits = (x_max > x_min ? x_max : x_min);
       fw = digits + 1;
       rd = fw;
     }
   else if (Vfixed_point_format && ! print_g)
     {
       rd = prec;
       fw = rd + 3;
     }
   else
     {
       int ld_max, rd_max;
       if (x_max > 0)
         {
           ld_max = x_max;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max++;
         }
       else
         {
           ld_max = 1;
-          rd_max = prec > x_max ? prec - x_max : prec;
+          rd_max = (prec > x_max ? prec - x_max : prec);
           x_max = -x_max + 1;
         }
 
       int ld_min, rd_min;
       if (x_min > 0)
         {
           ld_min = x_min;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min++;
         }
       else
         {
           ld_min = 1;
-          rd_min = prec > x_min ? prec - x_min : prec;
+          rd_min = (prec > x_min ? prec - x_min : prec);
           x_min = -x_min + 1;
         }
 
-      ld = ld_max > ld_min ? ld_max : ld_min;
-      rd = rd_max > rd_min ? rd_max : rd_min;
+      ld = (ld_max > ld_min ? ld_max : ld_min);
+      rd = (rd_max > rd_min ? rd_max : rd_min);
 
       fw = ld + rd + 3;
     }
 
   if (! (rat_format || bank_format || hex_format || bit_format)
       && (print_e
           || print_eng || print_g
           || (! Vfixed_point_format && fw > Voutput_max_field_width)))
@@ -1373,22 +1373,22 @@ set_format (const Range& r, int& fw, dou
     {
       double tmp = r_max;
       r_max = r_min;
       r_min = tmp;
     }
 
   bool all_ints = r.all_elements_are_ints ();
 
-  double max_abs = r_max < 0.0 ? -r_max : r_max;
-  double min_abs = r_min < 0.0 ? -r_min : r_min;
-
-  int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
-
-  int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
+  double max_abs = (r_max < 0.0 ? -r_max : r_max);
+  double min_abs = (r_min < 0.0 ? -r_min : r_min);
+
+  int x_max = (max_abs == 0.0 ? 0 : num_digits (max_abs));
+
+  int x_min = (min_abs == 0.0 ? 0 : num_digits (min_abs));
 
   scale = (x_max == 0 || all_ints)
           ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_range_format (x_max, x_min, all_ints, fw);
 }
 
 union equiv
@@ -1783,17 +1783,17 @@ octave_print_internal (std::ostream& os,
 
       if (pr_as_read_syntax)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_idx_type col = 0;
               while (col < nc)
                 {
-                  octave_idx_type lim = col + inc < nc ? col + inc : nc;
+                  octave_idx_type lim = (col + inc < nc ? col + inc : nc);
 
                   for (octave_idx_type j = col; j < lim; j++)
                     {
                       octave_quit ();
 
                       if (i == 0 && j == 0)
                         os << "[ ";
                       else
@@ -1824,17 +1824,17 @@ octave_print_internal (std::ostream& os,
       else
         {
           octave_preserve_stream_state stream_state (os);
 
           pr_scale_header (os, scale);
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   os << std::setw (extra_indent) << "";
 
@@ -1919,17 +1919,17 @@ octave_print_internal (std::ostream& os,
 
       if (pr_as_read_syntax)
         {
           os << "diag (";
 
           octave_idx_type col = 0;
           while (col < nc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               for (octave_idx_type j = col; j < lim; j++)
                 {
                   octave_quit ();
 
                   if (j == 0)
                     os << "[ ";
                   else
@@ -1968,17 +1968,17 @@ octave_print_internal (std::ostream& os,
           {
             std::ostringstream tmp_oss;
             pr_float (tmp_oss, 0.0, fw, scale);
             zero_fw = tmp_oss.str ().length ();
           }
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   os << std::setw (extra_indent) << "";
 
@@ -2201,17 +2201,17 @@ octave_print_internal (std::ostream& os,
 
       if (pr_as_read_syntax)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_idx_type col = 0;
               while (col < nc)
                 {
-                  octave_idx_type lim = col + inc < nc ? col + inc : nc;
+                  octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
                   for (octave_idx_type j = col; j < lim; j++)
                     {
                       octave_quit ();
 
                       if (i == 0 && j == 0)
                         os << "[ ";
                       else
@@ -2242,17 +2242,17 @@ octave_print_internal (std::ostream& os,
       else
         {
           octave_preserve_stream_state stream_state (os);
 
           pr_scale_header (os, scale);
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   os << std::setw (extra_indent) << "";
 
@@ -2339,17 +2339,17 @@ octave_print_internal (std::ostream& os,
 
       if (pr_as_read_syntax)
         {
           os << "diag (";
 
           octave_idx_type col = 0;
           while (col < nc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               for (octave_idx_type j = col; j < lim; j++)
                 {
                   octave_quit ();
 
                   if (j == 0)
                     os << "[ ";
                   else
@@ -2388,17 +2388,17 @@ octave_print_internal (std::ostream& os,
           {
             std::ostringstream tmp_oss;
             pr_complex (tmp_oss, Complex (0.0), r_fw, i_fw, scale);
             zero_fw = tmp_oss.str ().length ();
           }
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   os << std::setw (extra_indent) << "";
 
@@ -2487,17 +2487,17 @@ octave_print_internal (std::ostream& os,
           Array<octave_idx_type> pvec = m.col_perm_vec ();
 
           os << "eye (";
           os << ":, ";
 
           octave_idx_type col = 0;
           while (col < nc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               for (octave_idx_type j = col; j < lim; j++)
                 {
                   octave_quit ();
 
                   if (j == 0)
                     os << "[ ";
                   else
@@ -2525,17 +2525,17 @@ octave_print_internal (std::ostream& os,
           octave_preserve_stream_state stream_state (os);
 
           os << "Permutation Matrix\n";
           if (! Vcompact_format)
             os << "\n";
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
-              octave_idx_type lim = col + inc < nc ? col + inc : nc;
+              octave_idx_type lim = (col +inc < nc ? col + inc : nc);
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   os << std::setw (extra_indent) << "";
 
@@ -2715,17 +2715,17 @@ octave_print_internal (std::ostream& os,
           if (max_width < 0)
             max_width = 0;
 
           pr_scale_header (os, scale);
 
           octave_idx_type col = 0;
           while (col < num_elem)
             {
-              octave_idx_type lim = col + inc < num_elem ? col + inc : num_elem;
+              octave_idx_type lim = (col +inc < num_elem ? col + inc : num_elem);
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
               os << std::setw (extra_indent) << "";
 
               for (octave_idx_type i = col; i < lim; i++)
                 {
@@ -3323,17 +3323,18 @@ octave_print_internal_template (std::ost
             {
               octave_preserve_stream_state stream_state (os);
 
               octave_idx_type n_rows = page.rows ();
               octave_idx_type n_cols = page.cols ();
 
               for (octave_idx_type col = 0; col < n_cols; col += inc)
                 {
-                  octave_idx_type lim = col + inc < n_cols ? col + inc : n_cols;
+                  octave_idx_type lim = (col +inc < n_cols ? col + inc
+                                                           : n_cols);
 
                   pr_col_num_header (os, total_width, max_width, lim, col,
                                      extra_indent);
 
                   for (octave_idx_type ii = 0; ii < n_rows; ii++)
                     {
                       os << std::setw (extra_indent) << "";
 
@@ -3492,17 +3493,17 @@ formatted output in a string.
   octave_value arg = args(0);
 
   if (nargout == 0)
     arg.print (octave_stdout);
   else
     {
       std::ostringstream buf;
       arg.print (buf);
-      retval = octave_value (buf.str (), arg.is_dq_string () ? '"' : '\'');
+      retval = (octave_value (buf.str (), arg.is_dq_string () ? '"' : '\''));
     }
 
   return retval;
 }
 
 DEFUN (fdisp, args, ,
        classes: cell char double function_handle int8 int16 int32 int64 logical single struct uint8 uint16 uint32 uint64
        doc: /* -*- texinfo -*-
@@ -4107,17 +4108,17 @@ format and format spacing.
 
       string_vector argv = args.make_argv ("format");
 
       set_format_style (argc, argv);
     }
   else
     {
       if (nargout >= 2)
-        retval(1) = Vcompact_format ? "compact" : "loose";
+        retval(1) = (Vcompact_format ? "compact" : "loose");
 
       retval(0) = format_string;
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -166,17 +166,17 @@ do_rand (const octave_value_list& args, 
             dims.resize (n);
 
             octave_idx_type base = octave::math::nint_big (r.base ());
             octave_idx_type incr = octave::math::nint_big (r.inc ());
 
             for (octave_idx_type i = 0; i < n; i++)
               {
                 // Negative dimensions treated as zero for Matlab compatibility
-                dims(i) = base >= 0 ? base : 0;
+                dims(i) = (base >= 0 ? base : 0);
                 base += incr;
               }
 
             goto gen_matrix;
           }
         else if (tmp.is_matrix_type ())
           {
             Array<int> iv;
@@ -193,17 +193,17 @@ do_rand (const octave_value_list& args, 
             octave_idx_type len = iv.numel ();
 
             dims.resize (len);
 
             for (octave_idx_type i = 0; i < len; i++)
               {
                 // Negative dimensions treated as zero for Matlab compatibility
                 octave_idx_type elt = iv(i);
-                dims(i) = elt >=0 ? elt : 0;
+                dims(i) = (elt >=0 ? elt : 0);
               }
 
             goto gen_matrix;
           }
         else
           err_wrong_type_arg ("rand", tmp);
       }
       break;
@@ -253,17 +253,17 @@ do_rand (const octave_value_list& args, 
             for (int i = 0; i < nargin; i++)
               {
                 octave_idx_type elt =
                   args(idx+i).xidx_type_value (
                     "%s: dimension must be a scalar or array of integers",
                     fcn);
 
                 // Negative dimensions treated as zero for Matlab compatibility
-                dims(i) = elt >= 0 ? elt : 0;
+                dims(i) = (elt >= 0 ? elt : 0);
               }
 
             goto gen_matrix;
           }
       }
       break;
     }
 
@@ -1091,17 +1091,17 @@ likely.
   // Quick and dirty heuristic to decide if we allocate or not the
   // whole vector for tracking the truncated shuffle.
   bool short_shuffle = m < n/5;
 
   // Generate random numbers.
   NDArray r = octave_rand::nd_array (dim_vector (1, m));
   double *rvec = r.fortran_vec ();
 
-  octave_idx_type idx_len = short_shuffle ? m : n;
+  octave_idx_type idx_len = (short_shuffle ? m : n);
   Array<octave_idx_type> idx;
   try
     {
       idx = Array<octave_idx_type> (dim_vector (1, idx_len));
     }
   catch (const std::bad_alloc&)
     {
       // Looks like n is too big and short_shuffle is false.
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -381,19 +381,19 @@ octregexp (const octave_value_list& args
         }
     }
   retval(5) = nmap;
 
   if (options.once ())
     {
       octave::regexp::match_data::const_iterator p = rx_lst.begin ();
 
-      retval(4) = sz ? p->tokens () : Cell ();
-      retval(3) = sz ? p->match_string () : "";
-      retval(2) = sz ? p->token_extents () : Matrix ();
+      retval(4) = (sz ? p->tokens () : Cell ());
+      retval(3) = (sz ? p->match_string () : "");
+      retval(2) = (sz ? p->token_extents () : Matrix ());
 
       if (sz)
         {
           double start = p->start ();
           double end = p->end ();
 
           Cell split (dim_vector (1, 2));
           split(0) = buffer.substr (0, start-1);
@@ -843,17 +843,17 @@ are zero or more @qcode{'b'} characters 
 @end deftypefn */)
 {
   if (args.length () < 2)
     print_usage ();
 
   octave_value_list retval;
 
   if (args(0).is_cell () || args(1).is_cell ())
-    retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexp");
+    retval = (octcellregexp (args, (nargout > 0 ? nargout : 1), "regexp"));
   else
     retval = octregexp (args, nargout, "regexp");
 
   return retval;
 }
 
 /*
 ## PCRE_ERROR_MATCHLIMIT test
@@ -1417,18 +1417,17 @@ function.
               if (rep.numel () != 1)
                 new_args(2) = rep(j);
               new_args(0) = octregexprep (new_args, "regexprep");
             }
 
           ret(i) = new_args(0);
         }
 
-      retval = args(0).is_cell () ? ovl (ret)
-                                  : ovl (ret(0));
+      retval = (args(0).is_cell () ? ovl (ret) : ovl (ret(0)));
     }
   else
     retval = octregexprep (args, "regexprep");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -144,17 +144,17 @@ in control (see @code{are} and @code{dar
     }
   else if (ord == "complex")
     {
       force_complex = true;
       ord = "";
     }
   else
     {
-      char ord_char = ord.empty () ? 'U' : ord[0];
+      char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
           && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
         {
           warning ("schur: incorrect ordered schur argument '%s'",
                    ord.c_str ());
           return ovl ();
         }
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -136,17 +136,17 @@ extract_num (std::istringstream& is, dou
       // possible infinity.
       is.get ();
       c = is.peek ();
 
       if (is.eof ())
         {
           // just 'i' and string is finished.  Return immediately.
           imag = true;
-          num = negative ? -1.0 : 1.0;
+          num = (negative ? -1.0 : 1.0);
           return is;
         }
       else
         {
           if (std::tolower (c) != 'n')
             imag = true;
           is.unget ();
         }
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -350,17 +350,17 @@ do_strcmp_fun (const octave_value& arg0,
       octave_idx_type r = str.numel ();
 
       if (r == 0 || r == 1)
         {
           // Broadcast the string.
 
           boolNDArray output (cell_val.dims (), false);
 
-          std::string s = r == 0 ? "" : str[0];
+          std::string s = (r == 0 ? "" : str[0]);
 
           if (cell_val.is_cellstr ())
             {
               const Array<std::string> cellstr = cell_val.cellstr_value ();
               for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                 output(i) = str_op (cellstr(i), s, n);
             }
           else
@@ -745,17 +745,17 @@ Convert byte stream @var{native_bytes} t
   if (nargin != 2)
     print_usage ();
 
   if (args(0).is_string ())
     return ovl (args(0));
 
   std::string tmp = args(1).xstring_value ("CODEPAGE must be a string");
   const char *codepage
-    = tmp.empty () ? octave_locale_charset_wrapper () : tmp.c_str ();
+    = (tmp.empty () ? octave_locale_charset_wrapper () : tmp.c_str ());
 
   charNDArray native_bytes = args(0).char_array_value ();
 
   const char *src = native_bytes.data ();
   size_t srclen = native_bytes.numel ();
 
   size_t length;
   uint8_t *utf8_str = 0;
@@ -791,17 +791,17 @@ Convert UTF-8 string @var{utf8_str} to b
 {
   int nargin = args.length ();
 
   if (nargin != 2)
     print_usage ();
 
   std::string tmp = args(1).xstring_value ("CODEPAGE must be a string");
   const char *codepage
-    = tmp.empty () ? octave_locale_charset_wrapper () : tmp.c_str ();
+    = (tmp.empty () ? octave_locale_charset_wrapper () : tmp.c_str ());
 
   charNDArray utf8_str = args(0).xchar_array_value ("UTF8_STR must be a string");
 
   const uint8_t *src = reinterpret_cast<const uint8_t *> (utf8_str.data ());
   size_t srclen = utf8_str.numel ();
 
   size_t length;
   char *native_bytes = 0;
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -598,17 +598,17 @@ static builtin_type_t (*build_sup_table 
            || (btyp_isarray (ityp)
                && (! btyp_isarray (jtyp)
                    || (btyp_isinteger (jtyp) && ! btyp_isinteger (ityp))
                    || ((ityp == btyp_double || ityp == btyp_complex
                         || ityp == btyp_char)
                        && (jtyp == btyp_float
                            || jtyp == btyp_float_complex)))));
 
-        sup_table[i][j] = use_j ? jtyp : ityp;
+        sup_table[i][j] = (use_j ? jtyp : ityp);
       }
 
   return sup_table;
 }
 
 std::string
 get_dispatch_type (const octave_value_list& args,
                    builtin_type_t& builtin_type)
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -405,17 +405,17 @@ raw_mode (bool on, bool wait)
         s.c_oflag &= ~(OCRNL);
 #endif
 #if defined (ONOCR)
         s.c_oflag &= ~(ONOCR);
 #endif
 #if defined (ONLRET)
         s.c_oflag &= ~(ONLRET);
 #endif
-        s.c_cc[VMIN] = wait ? 1 : 0;
+        s.c_cc[VMIN] = (wait ? 1 : 0);
         s.c_cc[VTIME] = 0;
       }
     else
       {
         // Restore saved modes.
 
         s = save_term;
       }
@@ -448,17 +448,17 @@ raw_mode (bool on, bool wait)
         s.c_oflag &= ~(OCRNL);
 #endif
 #if defined (ONOCR)
         s.c_oflag &= ~(ONOCR);
 #endif
 #if defined (ONLRET)
         s.c_oflag &= ~(ONLRET);
 #endif
-        s.c_cc[VMIN] = wait ? 1 : 0;
+        s.c_cc[VMIN] = (wait ? 1 : 0);
       }
     else
       {
         // Restore saved modes.
 
         s = save_term;
       }
 
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -286,36 +286,36 @@ do_trilu (const std::string& name,
         idx_tmp.push_back (ov_idx);
         ov_idx(1) = static_cast<double> (nc);
         tmp = tmp.resize (dim_vector (0,0));
         tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
         tmp = tmp.resize (dims);
 
         if (lower)
           {
-            octave_idx_type st = nc < nr + k ? nc : nr + k;
+            octave_idx_type st = (nc < nr + k ? nc : nr + k);
 
             for (octave_idx_type j = 1; j <= st; j++)
               {
-                octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
+                octave_idx_type nr_limit = (1 > j - k ? 1 : j - k);
                 ov_idx(1) = static_cast<double> (j);
                 ov_idx(0) = Range (nr_limit, nr);
                 std::list<octave_value_list> idx;
                 idx.push_back (ov_idx);
 
                 tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
               }
           }
         else
           {
-            octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
+            octave_idx_type st = (k + 1 > 1 ? k + 1 : 1);
 
             for (octave_idx_type j = st; j <= nc; j++)
               {
-                octave_idx_type nr_limit = nr < j - k ? nr : j - k;
+                octave_idx_type nr_limit = (nr < j - k ? nr : j - k);
                 ov_idx(1) = static_cast<double> (j);
                 ov_idx(0) = Range (1, nr_limit);
                 std::list<octave_value_list> idx;
                 idx.push_back (ov_idx);
 
                 tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
               }
           }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1587,18 +1587,19 @@ public:
               }
             else if (param.modifier == 'c')
               error ("whos_line_format: modifier 'c' not available for command '%c'",
                      param.command);
 
             // What happens if whos_line_format contains negative numbers
             // at param_length positions?
             param.balance = (b < 0 ? 0 : param.balance);
-            param.first_parameter_length = (b < 0 ? 0 :
-                                            param.first_parameter_length);
+            param.first_parameter_length = (b < 0
+                                            ? 0
+                                            : param.first_parameter_length);
             param.parameter_length = (a < 0
                                       ? 0
                                       : (param.parameter_length
                                          < param_length(pos_s)
                                          ? param_length(pos_s)
                                          : param.parameter_length));
 
             // Parameter will not be pushed into parameter list if ...
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -53,23 +53,23 @@ solve_singularity_warning (double rcond)
 {
   octave::warn_singular_matrix (rcond);
 }
 
 template <typename T1, typename T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
-  octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
+  octave_idx_type a_nr = (blas_trans == blas_no_trans ? a.rows () : a.cols ());
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
-      octave_idx_type a_nc = blas_trans == blas_no_trans ? a.cols ()
-                                                         : a.rows ();
+      octave_idx_type a_nc = (blas_trans == blas_no_trans ? a.cols ()
+                                                          : a.rows ());
       octave_idx_type b_nc = b.cols ();
 
       octave::err_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
@@ -794,17 +794,17 @@ dmm_leftdiv_impl (const DMT& d, const MT
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
   T *xx = x.fortran_vec ();
 
   for (octave_idx_type j = 0; j < n; j++)
     {
       for (octave_idx_type i = 0; i < l; i++)
-        xx[i] = dd[i] != S () ? aa[i] / dd[i] : T ();
+        xx[i] = (dd[i] != S () ? aa[i] / dd[i] : T ());
       for (octave_idx_type i = l; i < m; i++)
         xx[i] = T ();
       aa += k; xx += m;
     }
 
   return x;
 }
 
@@ -873,17 +873,17 @@ dmdm_div_impl (const MT& a, const DMT& d
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
   T *xx = x.fortran_vec ();
 
   for (octave_idx_type i = 0; i < lk; i++)
-    xx[i] = dd[i] != S () ? aa[i] / dd[i] : T ();
+    xx[i] = (dd[i] != S () ? aa[i] / dd[i] : T ());
   for (octave_idx_type i = lk; i < l; i++)
     xx[i] = T ();
 
   return x;
 }
 
 // Right division functions.
 //
@@ -948,17 +948,17 @@ dmdm_leftdiv_impl (const DMT& d, const M
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
   T *xx = x.fortran_vec ();
 
   for (octave_idx_type i = 0; i < lk; i++)
-    xx[i] = dd[i] != S () ? aa[i] / dd[i] : T ();
+    xx[i] = (dd[i] != S () ? aa[i] / dd[i] : T ());
   for (octave_idx_type i = lk; i < l; i++)
     xx[i] = T ();
 
   return x;
 }
 
 // Left division functions.
 //
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -163,17 +163,17 @@ recording using those parameters.
         {
           warning ("Octave:invalid-audio-device",
                    "invalid audio device ID = %d", i);
           continue;
         }
 
       const PaHostApiInfo *api_info = Pa_GetHostApiInfo (device_info->hostApi);
 
-      const char *driver = api_info ? api_info->name : "";
+      const char *driver = (api_info ? api_info->name : "");
 
       char name[128];
       sprintf (name, "%s (%s)", device_info->name, driver);
 
       if (device_info->maxInputChannels != 0)
         {
           input_name(idx_i) = name;
           input_driver_version(idx_i) = driver;
@@ -873,17 +873,17 @@ audioplayer::init_fn (void)
 
   const PaDeviceInfo *device_info = Pa_GetDeviceInfo (device);
 
   if (! device_info)
     warning ("Octave:invalid-default-audio-device",
              "invalid default audio device ID = %d", device);
 
   output_parameters.suggestedLatency
-    = device_info ? device_info->defaultHighOutputLatency : -1;
+    = (device_info ? device_info->defaultHighOutputLatency : -1);
 
   output_parameters.hostApiSpecificStreamInfo = 0;
 }
 
 void
 audioplayer::init (void)
 {
   // FIXME: Both of these variables are unused.
@@ -917,17 +917,17 @@ audioplayer::init (void)
 
   const PaDeviceInfo *device_info = Pa_GetDeviceInfo (device);
 
   if (! device_info)
     warning ("Octave:invalid-default-audio-device",
              "invalid default audio device ID = %d", device);
 
   output_parameters.suggestedLatency
-    = device_info ? device_info->defaultHighOutputLatency : -1;
+    = (device_info ? device_info->defaultHighOutputLatency : -1);
 
   output_parameters.hostApiSpecificStreamInfo = 0;
 }
 
 void
 audioplayer::set_y (const octave_value& y_arg)
 {
   if (y_arg.is_int8_type ())
@@ -1509,17 +1509,17 @@ audiorecorder::init (void)
 
   const PaDeviceInfo *device_info = Pa_GetDeviceInfo (device);
 
   if (! device_info)
     warning ("Octave:invalid-default-audio-device",
              "invalid default audio device ID = %d", device);
 
   input_parameters.suggestedLatency
-    = device_info ? device_info->defaultHighInputLatency : -1;
+    = (device_info ? device_info->defaultHighInputLatency : -1);
 
   input_parameters.hostApiSpecificStreamInfo = 0;
 }
 
 void
 audiorecorder::set_fs (int fs_arg)
 {
   fs = fs_arg;
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -103,18 +103,18 @@ is stored in the audio file.
 
   if ((nargin == 2 && ! args(1).is_string ()) || nargin == 3)
     {
       RowVector range = args(1).row_vector_value ();
 
       if (range.numel () != 2)
         error ("audioread: invalid specification for range of frames");
 
-      double dstart = octave::math::isinf (range(0)) ? info.frames : range(0);
-      double dend = octave::math::isinf (range(1)) ? info.frames : range(1);
+      double dstart = (octave::math::isinf (range(0)) ? info.frames : range(0));
+      double dend = (octave::math::isinf (range(1)) ? info.frames : range(1));
 
       if (dstart < 1 || dstart > dend || dend > info.frames
           || octave::math::x_nint (dstart) != dstart
           || octave::math::x_nint (dend) != dend)
         error ("audioread: invalid specification for range of frames");
 
       start = dstart - 1;
       end = dend;
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -57,18 +57,18 @@ symetree (const octave_idx_type *ridx, c
     for (octave_idx_type k = 0 ; k < n ; k++)
       Pinv[P[k]] = k;
 
   for (octave_idx_type k = 0 ; k < n ; k++)
     {
       // L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k)
       Parent[k] = n ;                // parent of k is not yet known
       Flag[k] = k ;                  // mark node k as visited
-      octave_idx_type kk = (P) ? P[k]  // kth original, or permuted, column
-                               : (k);
+      octave_idx_type kk = (P ? P[k]  // kth original, or permuted, column
+                              : (k));
       octave_idx_type p2 = cidx[kk+1];
       for (octave_idx_type p = cidx[kk] ; p < p2 ; p++)
         {
           // A (i,k) is nonzero (original or permuted A)
           octave_idx_type i = (Pinv) ? (Pinv[ridx[p]]) : (ridx[p]);
           if (i < k)
             {
               // follow path from i to root of etree, stop at flagged node
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -413,17 +413,17 @@ namespace octave
           {
             m_strm->avail_in = std::fread (buf_in, sizeof (buf_in[0]),
                                            buf_len, m_source.m_fp);
 
             if (std::ferror (m_source.m_fp))
               throw std::runtime_error ("failed to read source file");
 
             m_strm->next_in = buf_in;
-            flush = std::feof (m_source.m_fp) ? Z_FINISH : Z_NO_FLUSH;
+            flush = (std::feof (m_source.m_fp) ? Z_FINISH : Z_NO_FLUSH);
 
             // If deflate returns Z_OK and with zero avail_out, it must be
             // called again after making room in the output buffer because
             // there might be more output pending.
             do
               {
                 m_strm->avail_out = buf_len;
                 m_strm->next_out = buf_out;
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -483,17 +483,17 @@ octave_base_diag<DMT, MT>::load_ascii (s
 {
   octave_idx_type r = 0;
   octave_idx_type c = 0;
 
   if (! extract_keyword (is, "rows", r, true)
       || ! extract_keyword (is, "columns", c, true))
     error ("load: failed to extract number of rows and columns");
 
-  octave_idx_type l = r < c ? r : c;
+  octave_idx_type l = (r < c ? r : c);
   MT tmp (l, 1);
   is >> tmp;
 
   if (! is)
     error ("load: failed to load diagonal matrix constant");
 
   // This is a little tricky, as we have the Matrix type, but
   // not ColumnVector type.  We need to help the compiler get
diff --git a/libinterp/octave-value/ov-base-mat.h b/libinterp/octave-value/ov-base-mat.h
--- a/libinterp/octave-value/ov-base-mat.h
+++ b/libinterp/octave-value/ov-base-mat.h
@@ -185,17 +185,17 @@ public:
 
 protected:
 
   MT matrix;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
   {
     delete idx_cache;
-    idx_cache = idx ? new idx_vector (idx) : 0;
+    idx_cache = (idx ? new idx_vector (idx) : 0);
     return idx;
   }
 
   void clear_cached_info (void) const
   {
     delete typ; typ = 0;
     delete idx_cache; idx_cache = 0;
   }
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -80,17 +80,17 @@ public:
   bool is_defined (void) const { return true; }
 
   dim_vector dims (void) const;
 
   octave_idx_type numel (void) const { return 1; }
 
   int ndims (void) const { return 2; }
 
-  octave_idx_type nnz (void) const { return (scalar != ST ()) ? 1 : 0; }
+  octave_idx_type nnz (void) const { return (scalar != ST () ? 1 : 0); }
 
   octave_value permute (const Array<int>&, bool = false) const;
 
   octave_value reshape (const dim_vector& new_dims) const;
 
   size_t byte_size (void) const { return sizeof (ST); }
 
   octave_value all (int = 0) const { return (scalar != ST ()); }
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -377,18 +377,18 @@ octave_class::subsref (const std::string
               {
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list key_idx = *++p;
 
                 Cell tmp = dotref (key_idx);
 
                 Cell t = tmp.index (idx.front ());
 
-                retval(0) = (t.numel () == 1) ? t(0)
-                                              : octave_value (t, true);
+                retval(0) = (t.numel () == 1 ? t(0)
+                                             : octave_value (t, true));
 
                 // We handled two index elements, so tell
                 // next_subsref to skip both of them.
                 skip++;
               }
             else
               retval(0) = octave_value (map.index (idx.front ()),
                                         c_name, parent_list);
@@ -1196,17 +1196,17 @@ octave_class::load_ascii (std::istream& 
 
           // recurse to read cell elements
           std::string nm
             = read_text_data (is, "", dummy, t2, j);
 
           if (! is)
             break;
 
-          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
+          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
 
           m.assign (nm, tcell);
         }
 
       if (! is)
         error ("load: failed to load class");
 
       c_name = classname;
@@ -1320,17 +1320,17 @@ octave_class::load_binary (std::istream&
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, "",
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
-          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
+          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
 
           m.assign (nm, tcell);
         }
 
       if (is)
         {
           map = m;
 
@@ -1568,17 +1568,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = hdf5_h5g_iterate (group_hid, name, &current_item,
                                          &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
-      Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
+      Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
 
       m.assign (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -66,17 +66,17 @@ err_method_access (const std::string& fr
          from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
 }
 
 OCTAVE_NORETURN static
 void
 err_property_access (const std::string& from, const cdef_property& prop,
                      bool is_set = false)
 {
-  octave_value acc = prop.get (is_set ? "SetAccess" : "GetAccess");
+  octave_value acc = (prop.get (is_set ? "SetAccess" : "GetAccess"));
   std::string acc_s;
 
   if (acc.is_string ())
     acc_s = acc.string_value ();
   else
     acc_s = "class-restricted";
 
   if (is_set)
@@ -3104,17 +3104,17 @@ cdef_method::cdef_method_rep::meta_subsr
   (const std::string& type, const std::list<octave_value_list>& idx,
    int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
-      retval = execute (idx.front (), type.length () > 1 ? 1 : nargout, true);
+      retval = (execute (idx.front (), type.length () > 1 ? 1 : nargout, true));
       break;
 
     default:
       error ("invalid meta.method indexing");
       break;
     }
 
   if (type.length () > 1 && idx.size () > 1 && ! retval.empty ())
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -377,17 +377,17 @@ octave_fcn_handle::save_ascii (std::ostr
                                     false, 0))
                 return ! os.fail ();
             }
         }
     }
   else
     {
       octave_function *f = function_value ();
-      std::string fnm = f ? f->fcn_file_name () : "";
+      std::string fnm = (f ? f->fcn_file_name () : "");
 
       os << "# octaveroot: " << OCTAVE_EXEC_PREFIX << "\n";
       if (! fnm.empty ())
         os << "# path: " << fnm << "\n";
       os << nm << "\n";
     }
 
   return true;
@@ -551,17 +551,17 @@ octave_fcn_handle::save_binary (std::ost
             }
         }
     }
   else
     {
       std::ostringstream nmbuf;
 
       octave_function *f = function_value ();
-      std::string fnm = f ? f->fcn_file_name () : "";
+      std::string fnm = (f ? f->fcn_file_name () : "");
 
       nmbuf << nm << "\n" << OCTAVE_EXEC_PREFIX << "\n" << fnm;
 
       std::string buf_str = nmbuf.str ();
       int32_t tmp = buf_str.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (buf_str.c_str (), buf_str.length ());
     }
@@ -846,17 +846,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Gclose (data_hid);
         }
     }
   else
     {
       std::string octaveroot = OCTAVE_EXEC_PREFIX;
 
       octave_function *f = function_value ();
-      std::string fpath = f ? f->fcn_file_name () : "";
+      std::string fpath = (f ? f->fcn_file_name () : "");
 
       H5Sclose (space_hid);
       hdims[0] = 1;
       hdims[1] = octaveroot.length ();
       space_hid = H5Screate_simple (0 , hdims, 0);
       if (space_hid < 0)
         {
           H5Tclose (type_hid);
@@ -1712,17 +1712,17 @@ particular output format.
 @seealso{func2str, str2func}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_fcn_handle *fh = args(0).fcn_handle_value ("functions: FCN_HANDLE argument must be a function handle object");
 
-  octave_function *fcn = fh ? fh->function_value () : 0;
+  octave_function *fcn = (fh ? fh->function_value () : 0);
 
   if (! fcn)
     error ("functions: FCN_HANDLE is not a valid function handle object");
 
   octave_scalar_map m;
 
   std::string fh_nm = fh->fcn_name ();
 
@@ -1924,17 +1924,17 @@ octave_fcn_binder::octave_fcn_binder (co
 
 octave_fcn_handle *
 octave_fcn_binder::maybe_binder (const octave_value& f,
                                  octave::tree_evaluator *tw)
 {
   octave_fcn_handle *retval = 0;
 
   octave_user_function *usr_fcn = f.user_function_value (false);
-  octave::tree_parameter_list *param_list = usr_fcn ? usr_fcn->parameter_list () : 0;
+  octave::tree_parameter_list *param_list = (usr_fcn ? usr_fcn->parameter_list () : 0);
 
   octave::tree_statement_list *cmd_list = 0;
   octave::tree_expression *body_expr = 0;
 
   if (usr_fcn)
     {
       cmd_list = usr_fcn->body ();
       if (cmd_list)
@@ -1969,17 +1969,17 @@ octave_fcn_binder::maybe_binder (const o
           std::map<std::string, int> arginmap;
           int npar = 0;
 
           if (param_list)
             {
               for (auto& param_p : *param_list)
                 {
                   octave::tree_decl_elt *elt = param_p;
-                  octave::tree_identifier *id = elt ? elt->ident () : 0;
+                  octave::tree_identifier *id = (elt ? elt->ident () : 0);
                   if (id && ! id->is_black_hole ())
                     arginmap[id->name ()] = npar;
                 }
             }
 
           if (arg_list && arg_list->length () > 0)
             {
               bool bad = false;
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -649,17 +649,17 @@ octave_range::save_hdf5 (octave_hdf5_id 
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   Range r = range_value ();
   double range_vals[3];
   range_vals[0] = r.base ();
-  range_vals[1] = r.inc () != 0 ? r.limit () : r.numel ();
+  range_vals[1] = (r.inc () != 0 ? r.limit () : r.numel ());
   range_vals[2] = r.inc ();
 
   if (H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL,
                 octave_H5P_DEFAULT, range_vals)
       >= 0)
     {
       octave_idx_type nel = r.numel ();
       retval = hdf5_add_scalar_attr (data_hid, H5T_NATIVE_IDX,
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -303,17 +303,17 @@ public:
 
 private:
 
   Range range;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
   {
     delete idx_cache;
-    idx_cache = idx ? new idx_vector (idx) : 0;
+    idx_cache = (idx ? new idx_vector (idx) : 0);
     return idx;
   }
 
   void clear_cached_info (void) const
   {
     delete idx_cache; idx_cache = 0;
   }
 
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -735,17 +735,17 @@ octave_struct::load_ascii (std::istream&
 
           // recurse to read cell elements
           std::string nm
             = read_text_data (is, "", dummy, t2, j);
 
           if (! is)
             break;
 
-          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
+          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
 
           m.setfield (nm, tcell);
         }
 
       if (! is)
         error ("load: failed to load structure");
 
       map = m;
@@ -848,17 +848,17 @@ octave_struct::load_binary (std::istream
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, "",
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
-          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
+          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
 
           m.setfield (nm, tcell);
         }
 
       if (! is)
         error ("load: failed to load structure");
 
       map = m;
@@ -949,17 +949,17 @@ octave_struct::load_hdf5 (octave_hdf5_id
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = hdf5_h5g_iterate (loc_id, name, &current_item,
                                          &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
-      Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
+      Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
 
       m.setfield (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
@@ -1973,26 +1973,26 @@ A(1)
 
   int dim = 0;
 
   if (nargin == 3)
     {
       if (! args(2).is_real_scalar ())
         error ("cell2struct: DIM must be a real scalar");
 
-      dim = nargin == 2 ? 0 : args(2).int_value () - 1;
+      dim = (nargin == 2 ? 0 : args(2).int_value () - 1);
     }
 
   if (dim < 0)
     error ("cell2struct: DIM must be a valid dimension");
 
   const Cell vals = args(0).cell_value ();
   const Array<std::string> fields = args(1).cellstr_value ();
 
-  octave_idx_type ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
+  octave_idx_type ext = (vals.ndims () > dim ? vals.dims ()(dim) : 1);
 
   if (ext != fields.numel ())
     error ("cell2struct: number of FIELDS does not match dimension");
 
   int nd = std::max (dim+1, vals.ndims ());
   // result dimensions.
   dim_vector rdv = vals.dims ().redim (nd);
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -861,17 +861,17 @@ Programming Note: @code{nargin} does not
 
           std::string type = fcn_val->type_name ();
           error ("nargin: number of input arguments unavailable for %s objects",
                  type.c_str ());
         }
 
       octave::tree_parameter_list *param_list = fcn->parameter_list ();
 
-      retval = param_list ? param_list->length () : 0;
+      retval = (param_list ? param_list->length () : 0);
       if (fcn->takes_varargs ())
         retval = -1 - retval;
     }
   else
     {
       retval = symbol_table::varval (".nargin.");
 
       if (retval.is_undefined ())
@@ -980,17 +980,17 @@ returns -1 for all anonymous functions.
 
           std::string type = fcn_val->type_name ();
           error ("nargout: number of output arguments unavailable for %s objects",
                  type.c_str ());
         }
 
       octave::tree_parameter_list *ret_list = fcn->return_list ();
 
-      retval = ret_list ? ret_list->length () : 0;
+      retval = (ret_list ? ret_list->length () : 0);
 
       if (fcn->takes_var_return ())
         retval = -1 - retval;
     }
   else
     {
       if (symbol_table::at_top_level ())
         error ("nargout: invalid call at top level");
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2610,17 +2610,17 @@ do_colon_op (const octave_value& base, c
           Range r (m_base(0), m_limit(0), m_increment(0));
 
           // For compatibility with Matlab, don't allow the range used in
           // a FOR loop expression to be converted to a Matrix.
 
           retval = octave_value (r, is_for_cmd_expr);
 
           if (result_is_str)
-            retval = retval.convert_to_str (false, true, dq_str ? '"' : '\'');
+            retval = (retval.convert_to_str (false, true, dq_str ? '"' : '\''));
         }
     }
 
   return retval;
 }
 
 void
 octave_value::print_info (std::ostream& os, const std::string& prefix) const
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -341,30 +341,30 @@ namespace octave
       }
 
     symbol_table::assign (".nargin.", nargs);
     symbol_table::mark_hidden (".nargin.");
   }
 
   void application::interactive (bool arg)
   {
-    interpreter *interp = instance ? instance->m_interpreter : 0;
+    interpreter *interp = (instance ? instance->m_interpreter : 0);
 
     if (interp)
       interp->interactive (arg);
   }
 
   bool application::forced_interactive (void)
   {
     return instance ? instance->m_options.forced_interactive () : false;
   }
 
   bool application::interactive (void)
   {
-    interpreter *interp = instance ? instance->m_interpreter : 0;
+    interpreter *interp = (instance ? instance->m_interpreter : 0);
 
     return interp ? interp->interactive () : false;
   }
 
   application::~application (void)
   {
     // Delete interpreter if it still exists.
 
diff --git a/libinterp/operators/op-class.cc b/libinterp/operators/op-class.cc
--- a/libinterp/operators/op-class.cc
+++ b/libinterp/operators/op-class.cc
@@ -74,17 +74,17 @@ DEF_CLASS_UNOP (ctranspose)
 
 #define DEF_CLASS_BINOP(name) \
   static octave_value                                                   \
   oct_binop_ ## name (const octave_value& a1, const octave_value& a2)   \
   {                                                                     \
     octave_value retval;                                                \
                                                                         \
     std::string dispatch_type                                           \
-      = a1.is_object () ? a1.class_name () : a2.class_name ();          \
+      = (a1.is_object () ? a1.class_name () : a2.class_name ());        \
                                                                         \
     octave_value meth = symbol_table::find_method (#name, dispatch_type); \
                                                                         \
     if (meth.is_undefined ())                                           \
       error ("%s method not defined for %s class", #name,               \
              dispatch_type.c_str ());                                   \
                                                                         \
     octave_value_list args;                                             \
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -423,17 +423,17 @@ namespace octave
     (tree_parameter_list *param_list, const std::string& warnfor,
      int nargout, const octave_value& val)
   {
     bool warned = false;
 
     int count = 0;
 
     octave_value tmp = symbol_table::varval (".ignored.");
-    const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
+    const Matrix ignored = (tmp.is_defined () ? tmp.matrix_value () : Matrix ());
 
     octave_idx_type k = 0;
 
     for (tree_decl_elt *elt : *param_list)
       {
         if (++count > nargout)
           break;
 
@@ -1146,17 +1146,17 @@ namespace octave
     if (expr->is_identifier () && type[0] == '(')
       {
         tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
         if (! (id->is_variable () || args.empty ()))
           {
             tree_argument_list *al = *(args.begin ());
 
-            size_t n = al ? al->length () : 0;
+            size_t n = (al ? al->length () : 0);
 
             if (n > 0)
               {
                 string_vector anm = *(arg_nm.begin ());
                 have_args = true;
                 first_args = al -> convert_to_const_vector (this);
                 first_args.stash_name_tags (anm);
 
@@ -1217,17 +1217,17 @@ namespace octave
 
             if (split)
               {
                 try
                   {
                     octave_value_list tmp_list
                       =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
 
-                    tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
+                    tmp = (tmp_list.length () ? tmp_list(0) : octave_value ());
                     tmpi = i;
                     idx.clear ();
 
                     if (tmp.is_cs_list ())
                       err_indexed_cs_list ();
 
                     if (tmp.is_function ())
                       {
@@ -1290,17 +1290,17 @@ namespace octave
         retval = tmp.subsref (type.substr (tmpi, n - tmpi), idx, nargout,
                               lvalue_list);
       }
     catch (octave::index_exception& e)  // range problems, bad index type, etc.
       {
         final_index_error (e, expr);
       }
 
-    octave_value val = retval.length () ? retval(0) : octave_value ();
+    octave_value val = (retval.length () ? retval(0) : octave_value ());
 
     if (val.is_function ())
       {
         octave_function *fcn = val.function_value (true);
 
         if (fcn)
           {
             octave_value_list empty_args;
@@ -1372,17 +1372,17 @@ namespace octave
           {
             if (all_real_p)
               retval = do_single_type_concat<FloatNDArray> (dv, tmp);
             else
               retval = do_single_type_concat<FloatComplexNDArray> (dv, tmp);
           }
         else if (result_type == "char")
           {
-            char type = all_dq_strings_p ? '"' : '\'';
+            char type = (all_dq_strings_p ? '"' : '\'');
 
             if (! all_strings_p)
               warn_implicit_conversion ("Octave:num-to-str",
                                         "numeric", result_type);
             else
               maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
             charNDArray result (dv, Vstring_fill_char);
@@ -1474,17 +1474,17 @@ namespace octave
                 if (! all_empty_p)
                   ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
               }
 
             // Now, extract the values from the individual elements and
             // insert them in the result matrix.
 
             int dv_len = dv.ndims ();
-            octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
+            octave_idx_type ntmp = (dv_len > 1 ? dv_len : 2);
             Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
 
             for (tm_row_const& row : tmp)
               {
                 octave_quit ();
 
                 for (auto& elt : row)
                   {
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -45,17 +45,17 @@ namespace octave
   {
     if (pr_orig_text)
       {
         os << original_text ();
       }
     else
       {
         octave_function *fp = fcn.function_value ();
-        std::string nm = fp ? fp->name () : std::string ("<invalid-function>");
+        std::string nm = (fp ? fp->name () : std::string ("<invalid-function>"));
 
         os << nm << " (";
 
         octave_idx_type n = args.length ();
         for (octave_idx_type i = 0; i < n; i++)
           {
             args(i).print_raw (os, pr_as_read_syntax);
 
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -387,17 +387,17 @@ namespace octave
 
   tree_index_expression *
   tree_index_expression::dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const
   {
     tree_index_expression *new_idx_expr
       = new tree_index_expression (line (), column ());
 
-    new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
+    new_idx_expr->expr = (expr ? expr->dup (scope, context) : 0);
 
     std::list<tree_argument_list *> new_args;
 
     for (const tree_argument_list *elt : args)
       new_args.push_back (elt ? elt->dup (scope, context) : 0);
 
     new_idx_expr->args = new_args;
 
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -1225,18 +1225,18 @@ jit_convert::resolve (tree_index_express
       jit_magic_end::context ctx (factory, object, idx, narg);
       end_context.push_back (ctx);
       call_args[idx + 1] = visit (*iter);
     }
 
   if (extra_arg)
     call_args[call_args.size () - 1] = extra_arg;
 
-  const jit_operation& fres = lhs ? jit_typeinfo::paren_subsasgn ()
-                                  : jit_typeinfo::paren_subsref ();
+  const jit_operation& fres = (lhs ? jit_typeinfo::paren_subsasgn ()
+                                   : jit_typeinfo::paren_subsref ());
 
   return create_checked (fres, call_args);
 }
 
 jit_value *
 jit_convert::do_assign (tree_expression *exp, jit_value *rhs, bool artificial)
 {
   if (! exp)
@@ -2496,18 +2496,18 @@ jit_info::compile (tree_jit& tjit, tree&
       function = reinterpret_cast<jited_function> (void_fn);
     }
 }
 
 octave_value
 jit_info::find (const vmap& extra_vars, const std::string& vname) const
 {
   vmap::const_iterator iter = extra_vars.find (vname);
-  return iter == extra_vars.end () ? symbol_table::varval (vname)
-                                   : *iter->second;
+  return (iter == extra_vars.end () ? symbol_table::varval (vname)
+                                    : *iter->second);
 }
 
 #endif
 
 DEFUN (jit_failcnt, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} jit_failcnt ()
 @deftypefnx {} {@var{old_val} =} jit_failcnt (@var{new_val})
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -168,21 +168,21 @@ namespace octave
   }
 
   tree_statement *
   tree_statement::dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const
   {
     tree_statement *new_stmt = new tree_statement ();
 
-    new_stmt->cmd = cmd ? cmd->dup (scope, context) : 0;
+    new_stmt->cmd = (cmd ? cmd->dup (scope, context) : 0);
 
-    new_stmt->expr = expr ? expr->dup (scope, context) : 0;
+    new_stmt->expr = (expr ? expr->dup (scope, context) : 0);
 
-    new_stmt->comm = comm ? comm->dup () : 0;
+    new_stmt->comm = (comm ? comm->dup () : 0);
 
     return new_stmt;
   }
 
   // Create a "breakpoint" tree-walker, and get it to "walk" this statement list
   // (FIXME: What does that do???)
   int
   tree_statement_list::set_breakpoint (int line, const std::string& condition)
diff --git a/libinterp/version.cc b/libinterp/version.cc
--- a/libinterp/version.cc
+++ b/libinterp/version.cc
@@ -74,33 +74,33 @@ octave_name_version_and_copyright (void)
 
   return "GNU Octave, version " OCTAVE_VERSION "\n" OCTAVE_COPYRIGHT;
 }
 
 std::string
 octave_name_version_copyright_copying_and_warranty
   (bool html, const std::string& extra_info)
 {
-  std::string br = html ? "<br>\n" : "\n";
-  std::string sep = html ? "\n</p>\n<p>\n" : "\n\n";
+  std::string br = (html ? "<br>\n" : "\n");
+  std::string sep = (html ? "\n</p>\n<p>\n" : "\n\n");
 
   return octave_name_version_and_copyright ()
          + br
          + "This is free software; see the source code for copying conditions."
          + br
          + octave_warranty_statement (extra_info)
          + sep
          + "Octave was configured for \"" OCTAVE_CANONICAL_HOST_TYPE "\".";
 }
 
 std::string
 octave_name_version_copyright_copying_warranty_and_bugs
   (bool html, const std::string& extra_info)
 {
-  std::string sep = html ? "\n</p>\n<p>\n" : "\n\n";
+  std::string sep = (html ? "\n</p>\n<p>\n" : "\n\n");
 
   std::string msg;
 
   if (html)
     msg = "<p>\n";
 
   msg += octave_name_version_copyright_copying_and_warranty (html, extra_info)
          + sep
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -490,18 +490,18 @@ zero_dims_inquire (const idx_vector& i, 
   if (icol && jcol && rhdv.ndims () == 2)
     {
       rdv(0) = rhdv(0);
       rdv(1) = rhdv(1);
     }
   else if (rhdv.ndims () == 2
            && ! i.is_scalar () && ! j.is_scalar ())
     {
-      rdv(0) = icol ? rhdv(0) : i.extent (0);
-      rdv(1) = jcol ? rhdv(1) : j.extent (0);
+      rdv(0) = (icol ? rhdv(0) : i.extent (0));
+      rdv(1) = (jcol ? rhdv(1) : j.extent (0));
     }
   else
     {
       dim_vector rhdv0 = rhdv;
       rhdv0.chop_all_singletons ();
       int k = 0;
       rdv(0) = i.extent (0);
       if (icol)
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -1540,17 +1540,17 @@ Array<T>::delete_elements (const Array<i
           bool empty_assignment = false;
 
           int num_non_colon_indices = 0;
 
           int nd = ndims ();
 
           for (int i = 0; i < ial; i++)
             {
-              octave_idx_type dim_len = i >= nd ? 1 : dimensions(i);
+              octave_idx_type dim_len = (i >= nd ? 1 : dimensions(i));
 
               if (ia(i).length (dim_len) == 0)
                 {
                   empty_assignment = true;
                   break;
                 }
 
               if (! ia(i).is_colon_equiv (dim_len))
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -391,17 +391,17 @@ operator * (const ComplexDiagMatrix& a, 
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
-  octave_idx_type lenm = len < a_nc ? len : a_nc;
+  octave_idx_type lenm = (len < a_nc ? len : a_nc);
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
   for (octave_idx_type i = lenm; i < len; i++)
     c.dgxelem (i) = 0.0;
 
   return c;
 }
@@ -418,17 +418,17 @@ operator * (const DiagMatrix& a, const C
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
-  octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
+  octave_idx_type len = (a_nr < b_nc ? a_nr : b_nc);
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       double a_element = a.elem (i, i);
       Complex b_element = b.elem (i, i);
 
       c.elem (i, i) = a_element * b_element;
     }
@@ -448,17 +448,17 @@ operator * (const ComplexDiagMatrix& a, 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
-  octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
+  octave_idx_type len = (a_nr < b_nc ? a_nr : b_nc);
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       Complex a_element = a.elem (i, i);
       Complex b_element = b.elem (i, i);
 
       c.elem (i, i) = a_element * b_element;
     }
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -999,17 +999,17 @@ ComplexMatrix::fourier (void) const
   size_t nc = cols ();
 
   ComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -1028,17 +1028,17 @@ ComplexMatrix::ifourier (void) const
   size_t nc = cols ();
 
   ComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -1178,17 +1178,17 @@ ComplexMatrix::fourier2d (void) const
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -1246,17 +1246,17 @@ ComplexMatrix::ifourier2d (void) const
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -2435,17 +2435,17 @@ ComplexMatrix::lssolve (const ComplexMat
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = ComplexMatrix (n, b_nc, Complex (0.0, 0.0));
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
 
       if (m != n)
         {
           retval = ComplexMatrix (maxmn, nrhs);
 
           for (F77_INT j = 0; j < nrhs; j++)
             for (F77_INT i = 0; i < m; i++)
@@ -2658,17 +2658,17 @@ ComplexMatrix::lssolve (const ComplexCol
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
 
       if (m != n)
         {
           retval = ComplexColumnVector (maxmn);
 
           for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
@@ -3054,30 +3054,30 @@ ComplexMatrix::row_min (Array<octave_idx
           double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? tmp_min.real ()
-                                      : std::abs (tmp_min);
+                  abs_min = (real_only ? tmp_min.real ()
+                                       : std::abs (tmp_min));
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              double abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp < abs_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3129,30 +3129,30 @@ ComplexMatrix::row_max (Array<octave_idx
           double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? tmp_max.real ()
-                                      : std::abs (tmp_max);
+                  abs_max = (real_only ? tmp_max.real ()
+                                       : std::abs (tmp_max));
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              double abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp > abs_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
@@ -3204,30 +3204,30 @@ ComplexMatrix::column_min (Array<octave_
           double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? tmp_min.real ()
-                                      : std::abs (tmp_min);
+                  abs_min = (real_only ? tmp_min.real ()
+                                       : std::abs (tmp_min));
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              double abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp < abs_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3279,30 +3279,30 @@ ComplexMatrix::column_max (Array<octave_
           double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? tmp_max.real ()
-                                      : std::abs (tmp_max);
+                  abs_max = (real_only ? tmp_max.real ()
+                                       : std::abs (tmp_max));
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              double abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp > abs_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -300,18 +300,18 @@ ComplexNDArray::fourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -349,18 +349,18 @@ ComplexNDArray::ifourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -398,18 +398,18 @@ ComplexNDArray::fourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -446,18 +446,18 @@ ComplexNDArray::ifourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -244,17 +244,17 @@ SparseComplexMatrix::max (Array<octave_i
               if (octave::math::isnan (abs_max) || abs_tmp > abs_max)
                 {
                   idx_j = ridx (i);
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
 
-          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_max) ? 0 : idx_j);
           if (abs_max != 0.)
             nel++;
         }
 
       result = SparseComplexMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
@@ -401,17 +401,17 @@ SparseComplexMatrix::min (Array<octave_i
               if (octave::math::isnan (abs_min) || abs_tmp < abs_min)
                 {
                   idx_j = ridx (i);
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
 
-          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_min) ? 0 : idx_j);
           if (abs_min != 0.)
             nel++;
         }
 
       result = SparseComplexMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -234,18 +234,18 @@ Range::sort_internal (Array<octave_idx_t
       || (! ascending && rng_base < rng_limit && rng_inc > 0.0))
     {
       std::swap (rng_base, rng_limit);
       rng_inc = -rng_inc;
       clear_cache ();
       reverse = true;
     }
 
-  octave_idx_type tmp = reverse ? nel - 1 : 0;
-  octave_idx_type stp = reverse ? -1 : 1;
+  octave_idx_type tmp = (reverse ? nel - 1 : 0);
+  octave_idx_type stp = (reverse ? -1 : 1);
 
   for (octave_idx_type i = 0; i < nel; i++, tmp += stp)
     psidx[i] = tmp;
 
 }
 
 Matrix
 Range::diag (octave_idx_type k) const
@@ -293,17 +293,17 @@ Range::sort (Array<octave_idx_type>& sid
 sortmode
 Range::is_sorted (sortmode mode) const
 {
   if (rng_numel > 1 && rng_inc > 0)
     mode = (mode == DESCENDING) ? UNSORTED : ASCENDING;
   else if (rng_numel > 1 && rng_inc < 0)
     mode = (mode == ASCENDING) ? UNSORTED : DESCENDING;
   else
-    mode = mode ? mode : ASCENDING;
+    mode = (mode ? mode : ASCENDING);
 
   return mode;
 }
 
 void
 Range::set_base (double b)
 {
   if (rng_base != b)
@@ -483,18 +483,18 @@ tfloor (double x, double ct)
 
   if (x < 0.0)
     q = 1.0 - ct;
 
   double rmax = q / (2.0 - ct);
 
   double t1 = 1.0 + std::floor (x);
   t1 = (ct / q) * (t1 < 0.0 ? -t1 : t1);
-  t1 = rmax < t1 ? rmax : t1;
-  t1 = ct > t1 ? ct : t1;
+  t1 = (rmax < t1 ? rmax : t1);
+  t1 = (ct > t1 ? ct : t1);
   t1 = std::floor (x + t1);
 
   if (x <= 0.0 || (t1 - x) < rmax)
     return t1;
   else
     return t1 - 1.0;
 }
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -1423,17 +1423,17 @@ Sparse<T>::index (const idx_vector& idx,
       retval = tmp.index (idx);
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
       // then want to make a dense matrix with sparse representation.
       // Ok, we'll do it, but you deserve what you get!!
-      retval = Sparse<T> (idx_dims(0), idx_dims(1), nz ? data (0) : T ());
+      retval = (Sparse<T> (idx_dims(0), idx_dims(1), nz ? data (0) : T ()));
     }
   else if (nc == 1)
     {
       // Sparse column vector.
       octave_idx_type lb, ub;
 
       if (idx.is_scalar ())
         {
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -45,17 +45,17 @@ charNDArray::charNDArray (char c)
   resize1 (n);
 
   elem (0) = c;
 }
 
 charNDArray::charNDArray (const char *s)
   : Array<char> ()
 {
-  octave_idx_type n = s ? strlen (s) : 0;
+  octave_idx_type n = (s ? strlen (s) : 0);
 
   resize1 (n);
 
   for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 charNDArray::charNDArray (const std::string& s)
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -287,17 +287,17 @@ operator * (const DiagMatrix& a, const D
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   DiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
-  octave_idx_type lenm = len < a_nc ? len : a_nc;
+  octave_idx_type lenm = (len < a_nc ? len : a_nc);
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
   for (octave_idx_type i = lenm; i < len; i++)
     c.dgxelem (i) = 0.0;
 
   return c;
 }
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -696,17 +696,17 @@ Matrix::fourier (void) const
   size_t nc = cols ();
 
   ComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -725,17 +725,17 @@ Matrix::ifourier (void) const
   size_t nc = cols ();
 
   ComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -873,17 +873,17 @@ Matrix::fourier2d (void) const
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -941,17 +941,17 @@ Matrix::ifourier2d (void) const
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -2091,17 +2091,17 @@ Matrix::lssolve (const Matrix& b, octave
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = Matrix (n, b_nc, 0.0);
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
       if (m != n)
         {
           retval = Matrix (maxmn, nrhs, 0.0);
 
           for (F77_INT j = 0; j < nrhs; j++)
             for (F77_INT i = 0; i < m; i++)
               retval.elem (i, j) = b.elem (i, j);
@@ -2310,17 +2310,17 @@ Matrix::lssolve (const ColumnVector& b, 
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = ColumnVector (n, 0.0);
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
 
       if (m != n)
         {
           retval = ColumnVector (maxmn, 0.0);
 
           for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
@@ -2616,17 +2616,17 @@ Matrix::row_min (Array<octave_idx_type>&
               else if (tmp < tmp_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (i) = tmp_min;
-          idx_arg.elem (i) = octave::math::isnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (i) = (octave::math::isnan (tmp_min) ? 0 : idx_j);
         }
     }
 
   return result;
 }
 
 ColumnVector
 Matrix::row_max (void) const
@@ -2671,17 +2671,17 @@ Matrix::row_max (Array<octave_idx_type>&
               else if (tmp > tmp_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (i) = tmp_max;
-          idx_arg.elem (i) = octave::math::isnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (i) = (octave::math::isnan (tmp_max) ? 0 : idx_j);
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_min (void) const
@@ -2726,17 +2726,17 @@ Matrix::column_min (Array<octave_idx_typ
               else if (tmp < tmp_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (j) = tmp_min;
-          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_i;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_min) ? 0 : idx_i);
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_max (void) const
@@ -2781,17 +2781,17 @@ Matrix::column_max (Array<octave_idx_typ
               else if (tmp > tmp_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (j) = tmp_max;
-          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_i;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_max) ? 0 : idx_i);
         }
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const Matrix& a)
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -341,18 +341,18 @@ NDArray::fourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -390,18 +390,18 @@ NDArray::ifourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -439,18 +439,18 @@ NDArray::fourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -487,18 +487,18 @@ NDArray::ifourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -237,17 +237,17 @@ SparseMatrix::max (Array<octave_idx_type
               else if (octave::math::isnan (tmp_max) || tmp > tmp_max)
                 {
                   idx_j = ridx (i);
                   tmp_max = tmp;
                 }
 
             }
 
-          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_max) ? 0 : idx_j);
           if (tmp_max != 0.)
             nel++;
         }
 
       result = SparseMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
@@ -388,17 +388,17 @@ SparseMatrix::min (Array<octave_idx_type
               else if (octave::math::isnan (tmp_min) || tmp < tmp_min)
                 {
                   idx_j = ridx (i);
                   tmp_min = tmp;
                 }
 
             }
 
-          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_min) ? 0 : idx_j);
           if (tmp_min != 0.)
             nel++;
         }
 
       result = SparseMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
diff --git a/liboctave/array/dim-vector.cc b/liboctave/array/dim-vector.cc
--- a/liboctave/array/dim-vector.cc
+++ b/liboctave/array/dim-vector.cc
@@ -60,17 +60,17 @@ dim_vector::chop_all_singletons (void)
     {
       if (rep[i] != 1)
         rep[j++] = rep[i];
     }
 
   if (j == 1)
     rep[1] = 1;
 
-  rep[-1] = j > 2 ? j : 2;
+  rep[-1] = (j > 2 ? j : 2);
 }
 
 std::string
 dim_vector::str (char sep) const
 {
   std::ostringstream buf;
 
   for (int i = 0; i < ndims (); i++)
@@ -182,17 +182,17 @@ dim_vector::squeeze (void) const
 // 2. A is 0x0, in which case B is the result
 // 3. B is 0x0, in which case A is the result
 
 bool
 dim_vector::concat (const dim_vector& dvb, int dim)
 {
   int orig_nd = ndims ();
   int ndb = dvb.ndims ();
-  int new_nd = dim < ndb ? ndb : dim + 1;
+  int new_nd = (dim < ndb ? ndb : dim + 1);
   if (new_nd > orig_nd)
     resize (new_nd, 1);
   else
     new_nd = orig_nd;
 
   make_unique ();
 
   bool match = true;
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -395,17 +395,17 @@ operator * (const FloatComplexDiagMatrix
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
-  octave_idx_type lenm = len < a_nc ? len : a_nc;
+  octave_idx_type lenm = (len < a_nc ? len : a_nc);
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
   for (octave_idx_type i = lenm; i < len; i++)
     c.dgxelem (i) = 0.0f;
 
   return c;
 }
@@ -422,17 +422,17 @@ operator * (const FloatDiagMatrix& a, co
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
-  octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
+  octave_idx_type len = (a_nr < b_nc ? a_nr : b_nc);
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       float a_element = a.elem (i, i);
       FloatComplex b_element = b.elem (i, i);
 
       c.elem (i, i) = a_element * b_element;
     }
@@ -452,17 +452,17 @@ operator * (const FloatComplexDiagMatrix
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
-  octave_idx_type len = a_nr < b_nc ? a_nr : b_nc;
+  octave_idx_type len = (a_nr < b_nc ? a_nr : b_nc);
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       FloatComplex a_element = a.elem (i, i);
       FloatComplex b_element = b.elem (i, i);
 
       c.elem (i, i) = a_element * b_element;
     }
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1001,17 +1001,17 @@ FloatComplexMatrix::fourier (void) const
   size_t nc = cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -1030,17 +1030,17 @@ FloatComplexMatrix::ifourier (void) cons
   size_t nc = cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -1180,17 +1180,17 @@ FloatComplexMatrix::fourier2d (void) con
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -1247,17 +1247,17 @@ FloatComplexMatrix::ifourier2d (void) co
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -2456,17 +2456,17 @@ FloatComplexMatrix::lssolve (const Float
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = FloatComplexMatrix (n, b_nc, FloatComplex (0.0, 0.0));
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
 
       if (m != n)
         {
           retval = FloatComplexMatrix (maxmn, nrhs);
 
           for (F77_INT j = 0; j < nrhs; j++)
             for (F77_INT i = 0; i < m; i++)
@@ -2682,17 +2682,17 @@ FloatComplexMatrix::lssolve (const Float
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = FloatComplexColumnVector (n, FloatComplex (0.0, 0.0));
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
 
       if (m != n)
         {
           retval = FloatComplexColumnVector (maxmn);
 
           for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
@@ -3081,30 +3081,30 @@ FloatComplexMatrix::row_min (Array<octav
           float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? tmp_min.real ()
-                                      : std::abs (tmp_min);
+                  abs_min = (real_only ? tmp_min.real ()
+                                       : std::abs (tmp_min));
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              float abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp < abs_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3156,30 +3156,30 @@ FloatComplexMatrix::row_max (Array<octav
           float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? tmp_max.real ()
-                                      : std::abs (tmp_max);
+                  abs_max = (real_only ? tmp_max.real ()
+                                       : std::abs (tmp_max));
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              float abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp > abs_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
@@ -3231,30 +3231,30 @@ FloatComplexMatrix::column_min (Array<oc
           float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? tmp_min.real ()
-                                      : std::abs (tmp_min);
+                  abs_min = (real_only ? tmp_min.real ()
+                                       : std::abs (tmp_min));
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              float abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp < abs_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3306,30 +3306,30 @@ FloatComplexMatrix::column_max (Array<oc
           float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? tmp_max.real ()
-                                      : std::abs (tmp_max);
+                  abs_max = (real_only ? tmp_max.real ()
+                                       : std::abs (tmp_max));
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
+              float abs_tmp = (real_only ? tmp.real () : std::abs (tmp));
 
               if (abs_tmp > abs_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -298,18 +298,18 @@ FloatComplexNDArray::fourier2d (void) co
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -346,18 +346,18 @@ FloatComplexNDArray::ifourier2d (void) c
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -394,18 +394,18 @@ FloatComplexNDArray::fourierNd (void) co
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -441,18 +441,18 @@ FloatComplexNDArray::ifourierNd (void) c
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -287,17 +287,17 @@ operator * (const FloatDiagMatrix& a, co
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   FloatDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
-  octave_idx_type lenm = len < a_nc ? len : a_nc;
+  octave_idx_type lenm = (len < a_nc ? len : a_nc);
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
   for (octave_idx_type i = lenm; i < len; i++)
     c.dgxelem (i) = 0.0f;
 
   return c;
 }
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -703,17 +703,17 @@ FloatMatrix::fourier (void) const
   size_t nc = cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -732,17 +732,17 @@ FloatMatrix::ifourier (void) const
   size_t nc = cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   size_t npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -880,17 +880,17 @@ FloatMatrix::fourier2d (void) const
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -947,17 +947,17 @@ FloatMatrix::ifourier2d (void) const
 
   F77_INT nr = octave::to_f77_int (rows ());
   F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
@@ -2115,17 +2115,17 @@ FloatMatrix::lssolve (const FloatMatrix&
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = FloatMatrix (n, b_nc, 0.0);
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
       if (m != n)
         {
           retval = FloatMatrix (maxmn, nrhs, 0.0);
 
           for (F77_INT j = 0; j < nrhs; j++)
             for (F77_INT i = 0; i < m; i++)
               retval.elem (i, j) = b.elem (i, j);
@@ -2332,17 +2332,17 @@ FloatMatrix::lssolve (const FloatColumnV
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = FloatColumnVector (n, 0.0);
   else
     {
       volatile F77_INT minmn = (m < n ? m : n);
-      F77_INT maxmn = m > n ? m : n;
+      F77_INT maxmn = (m > n ? m : n);
       rcon = -1.0;
 
       if (m != n)
         {
           retval = FloatColumnVector (maxmn, 0.0);
 
           for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
@@ -2623,17 +2623,17 @@ FloatMatrix::row_min (Array<octave_idx_t
               else if (tmp < tmp_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (i) = tmp_min;
-          idx_arg.elem (i) = octave::math::isnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (i) = (octave::math::isnan (tmp_min) ? 0 : idx_j);
         }
     }
 
   return result;
 }
 
 FloatColumnVector
 FloatMatrix::row_max (void) const
@@ -2678,17 +2678,17 @@ FloatMatrix::row_max (Array<octave_idx_t
               else if (tmp > tmp_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (i) = tmp_max;
-          idx_arg.elem (i) = octave::math::isnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (i) = (octave::math::isnan (tmp_max) ? 0 : idx_j);
         }
     }
 
   return result;
 }
 
 FloatRowVector
 FloatMatrix::column_min (void) const
@@ -2733,17 +2733,17 @@ FloatMatrix::column_min (Array<octave_id
               else if (tmp < tmp_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (j) = tmp_min;
-          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_i;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_min) ? 0 : idx_i);
         }
     }
 
   return result;
 }
 
 FloatRowVector
 FloatMatrix::column_max (void) const
@@ -2788,17 +2788,17 @@ FloatMatrix::column_max (Array<octave_id
               else if (tmp > tmp_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (j) = tmp_max;
-          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_i;
+          idx_arg.elem (j) = (octave::math::isnan (tmp_max) ? 0 : idx_i);
         }
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatMatrix& a)
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -297,18 +297,18 @@ FloatNDArray::fourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -345,18 +345,18 @@ FloatNDArray::ifourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -393,18 +393,18 @@ FloatNDArray::fourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
@@ -440,18 +440,18 @@ FloatNDArray::ifourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (dim_vector (npts, 1));
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany :
-                 (howmany > stride ? stride : howmany));
+      howmany = (stride == 1 ? howmany
+                             : (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -1208,17 +1208,17 @@ idx_vector::unmask (void) const
       octave_idx_type ext = r->extent (0);
       octave_idx_type len = r->length (0);
       octave_idx_type *idata = new octave_idx_type [len];
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (data[i])
           idata[j++] = i;
 
-      ext = len > 0 ? idata[len - 1] + 1 : 0;
+      ext = (len > 0 ? idata[len - 1] + 1 : 0);
 
       return new idx_vector_rep (idata, len, ext, r->orig_dimensions (),
                                  DIRECT);
     }
   else
     return *this;
 }
 
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -936,17 +936,17 @@ public:
             for (i = 0, j = start; i < len && body (j); i++, j += step) ;
           ret = i;
         }
         break;
 
       case class_scalar:
         {
           idx_scalar_rep *r = dynamic_cast<idx_scalar_rep *> (rep);
-          ret = body (r->get_data ()) ? 1 : 0;
+          ret = (body (r->get_data ()) ? 1 : 0);
         }
         break;
 
       case class_vector:
         {
           idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
           const octave_idx_type *data = r->get_data ();
           octave_idx_type i;
diff --git a/liboctave/external/Faddeeva/Faddeeva.cc b/liboctave/external/Faddeeva/Faddeeva.cc
--- a/liboctave/external/Faddeeva/Faddeeva.cc
+++ b/liboctave/external/Faddeeva/Faddeeva.cc
@@ -410,18 +410,18 @@ double FADDEEVA_RE(erfc)(double x)
 {
 #if !defined(__cplusplus)
   return erfc(x); // C99 supplies erfc in math.h
 #elif (__cplusplus >= 201103L) || defined(HAVE_ERFC)
   return ::erfc(x); // C++11 supplies std::erfc in cmath
 #else
   if (x*x > 750) // underflow
     return (x >= 0 ? 0.0 : 2.0);
-  return x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x) 
-    : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x);
+  return (x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x) 
+                 : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x));
 #endif
 }
 
 // erfc(z) = 1 - erf(z)
 cmplx FADDEEVA(erfc)(cmplx z, double relerr)
 {
   double x = creal(z), y = cimag(z);
 
@@ -714,17 +714,17 @@ cmplx FADDEEVA(w)(cmplx z, double relerr
        (They only use this expansion for rho >= 1, but rho a little less
         than 1 seems okay too.)
        Instead, I did my own fit to a slightly different function
        that avoids the hypotenuse calculation, using NLopt to minimize
        the sum of the squares of the errors in nu with the constraint
        that the estimated nu be >= minimum nu to attain machine precision.
        I also separate the regions where nu == 2 and nu == 1. */
     const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
-    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
+    double xs = (y < 0 ? -creal(z) : creal(z)); // compute for -z if y < 0
     if (x + ya > 4000) { // nu <= 2
       if (x + ya > 1e7) { // nu == 1, w(z) = i/sqrt(pi) / z
         // scale to avoid overflow
         if (x > ya) {
           double yax = ya / xs; 
           double denom = ispi / (xs + yax*ya);
           ret = C(denom*yax, denom);
         }
@@ -765,17 +765,17 @@ cmplx FADDEEVA(w)(cmplx z, double relerr
       return 2.0*cexp(C((ya-xs)*(xs+ya), 2*xs*y)) - ret;
     }
     else
       return ret;
   }
 #else // !USE_CONTINUED_FRACTION
   if (x + ya > 1e7) { // w(z) = i/sqrt(pi) / z, to machine precision
     const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
-    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
+    double xs = (y < 0 ? -creal(z) : creal(z)); // compute for -z if y < 0
     // scale to avoid overflow
     if (x > ya) {
       double yax = ya / xs; 
       double denom = ispi / (xs + yax*ya);
       ret = C(denom*yax, denom);
     }
     else {
       double xya = xs / ya;
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -204,17 +204,17 @@ DASPK::do_integrate (double tout)
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: no user supplied RHS subroutine!");
 
           integration_error = true;
           return retval;
         }
 
-      info(4) = user_jac ? 1 : 0;
+      info(4) = (user_jac ? 1 : 0);
 
       DAEFunc::reset = false;
 
       octave_idx_type eiq = enforce_inequality_constraints ();
       octave_idx_type ccic = compute_consistent_initial_condition ();
       octave_idx_type eavfet = exclude_algebraic_variables_from_error_test ();
 
       liw = 40 + n;
@@ -359,17 +359,17 @@ DASPK::do_integrate (double tout)
                     lid = 40;
                   else if (eiq == 1 || eiq == 3)
                     lid = 40 + n;
                   else
                     (*current_liboctave_error_handler)
                       ("daspk: invalid value for eiq: %d", eiq);
 
                   for (F77_INT i = 0; i < n; i++)
-                    iwork(lid+i) = av(i) ? -1 : 1;
+                    iwork(lid+i) = (av(i) ? -1 : 1);
                 }
               else
                 {
                   // FIXME: Should this be a warning?
                   (*current_liboctave_error_handler)
                     ("daspk: algebraic variables size mismatch");
                   integration_error = true;
                   return retval;
@@ -404,17 +404,17 @@ DASPK::do_integrate (double tout)
                 lid = 40;
               else if (eiq == 1 || eiq == 3)
                 lid = 40 + n;
               else
                 (*current_liboctave_error_handler)
                   ("daspk: invalid value for eiq: %d", eiq);
 
               for (F77_INT i = 0; i < n; i++)
-                iwork(lid+i) = av(i) ? -1 : 1;
+                iwork(lid+i) = (av(i) ? -1 : 1);
             }
         }
 
       if (use_initial_condition_heuristics ())
         {
           Array<double> ich = initial_condition_heuristics ();
 
           if (ich.numel () == 6)
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -238,17 +238,17 @@ DASRT::integrate (double tout)
         {
           (*current_liboctave_error_handler)
             ("dasrt: no user supplied RHS subroutine!");
 
           integration_error = true;
           return;
         }
 
-      info(4) = user_jsub ? 1 : 0;
+      info(4) = (user_jsub ? 1 : 0);
 
       DAEFunc::reset = false;
 
       jroot.resize (dim_vector (ng, 1), 1);
 
       DAERTFunc::reset = false;
 
       // DASRT_options
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -186,17 +186,17 @@ DASSL::do_integrate (double tout)
         {
           (*current_liboctave_error_handler)
             ("dassl: no user supplied RHS subroutine!");
 
           integration_error = true;
           return retval;
         }
 
-      info(4) = user_jac ? 1 : 0;
+      info(4) = (user_jac ? 1 : 0);
 
       DAEFunc::reset = false;
 
       // DASSL_options
 
       double hmax = maximum_step_size ();
       if (hmax >= 0.0)
         {
@@ -238,20 +238,20 @@ DASSL::do_integrate (double tout)
               (*current_liboctave_error_handler)
                 ("dassl: invalid value for maximum order: %d", maxord);
               integration_error = true;
               return retval;
             }
         }
 
       F77_INT enc = octave::to_f77_int (enforce_nonnegativity_constraints ());
-      info(9) = enc ? 1 : 0;
+      info(9) = (enc ? 1 : 0);
 
       F77_INT ccic = octave::to_f77_int (compute_consistent_initial_condition ());
-      info(10) = ccic ? 1 : 0;
+      info(10) = (ccic ? 1 : 0);
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
       F77_INT abs_tol_len = octave::to_f77_int (abs_tol.numel ());
       F77_INT rel_tol_len = octave::to_f77_int (rel_tol.numel ());
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -52,21 +52,21 @@ EIG::init (const Matrix& a, bool calc_re
   double *tmp_data = atmp.fortran_vec ();
 
   Array<double> wr (dim_vector (n, 1));
   double *pwr = wr.fortran_vec ();
 
   Array<double> wi (dim_vector (n, 1));
   double *pwi = wi.fortran_vec ();
 
-  F77_INT tnvr = calc_rev ? n : 0;
+  F77_INT tnvr = (calc_rev ? n : 0);
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
-  F77_INT tnvl = calc_lev ? n : 0;
+  F77_INT tnvl = (calc_lev ? n : 0);
   Matrix vl (tnvl, tnvl);
   double *pvl = vl.fortran_vec ();
 
   F77_INT lwork = -1;
   double dummy_work;
 
   F77_INT ilo;
   F77_INT ihi;
@@ -119,19 +119,19 @@ EIG::init (const Matrix& a, bool calc_re
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dgeevx");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dgeevx failed to converge");
 
   lambda.resize (n);
-  F77_INT nvr = calc_rev ? n : 0;
+  F77_INT nvr = (calc_rev ? n : 0);
   v.resize (nvr, nvr);
-  F77_INT nvl = calc_lev ? n : 0;
+  F77_INT nvl = (calc_lev ? n : 0);
   w.resize (nvl, nvl);
 
   for (F77_INT j = 0; j < n; j++)
     {
       if (wi.elem (j) == 0.0)
         {
           lambda.elem (j) = Complex (wr.elem (j));
           for (F77_INT i = 0; i < nvr; i++)
@@ -211,18 +211,18 @@ EIG::symmetric_init (const Matrix& a, bo
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dsyev failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
-  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = (calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ());
+  w = (calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ());
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const ComplexMatrix& a, bool calc_rev, bool calc_lev, bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
@@ -241,21 +241,21 @@ EIG::init (const ComplexMatrix& a, bool 
   F77_INT info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
   ComplexColumnVector wr (n);
   Complex *pw = wr.fortran_vec ();
 
-  F77_INT nvr = calc_rev ? n : 0;
+  F77_INT nvr = (calc_rev ? n : 0);
   ComplexMatrix vrtmp (nvr, nvr);
   Complex *pvr = vrtmp.fortran_vec ();
 
-  F77_INT nvl = calc_lev ? n : 0;
+  F77_INT nvl = (calc_lev ? n : 0);
   ComplexMatrix vltmp (nvl, nvl);
   Complex *pvl = vltmp.fortran_vec ();
 
   F77_INT lwork = -1;
   Complex dummy_work;
 
   F77_INT lrwork = 2*n;
   Array<double> rwork (dim_vector (lrwork, 1));
@@ -371,18 +371,18 @@ EIG::hermitian_init (const ComplexMatrix
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zheev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zheev failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
-  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = (calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ());
+  w = (calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ());
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const Matrix& a, const Matrix& b, bool calc_rev, bool calc_lev,
            bool force_qz)
 {
@@ -428,21 +428,21 @@ EIG::init (const Matrix& a, const Matrix
   double *par = ar.fortran_vec ();
 
   Array<double> ai (dim_vector (n, 1));
   double *pai = ai.fortran_vec ();
 
   Array<double> beta (dim_vector (n, 1));
   double *pbeta = beta.fortran_vec ();
 
-  F77_INT tnvr = calc_rev ? n : 0;
+  F77_INT tnvr = (calc_rev ? n : 0);
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
-  F77_INT tnvl = calc_lev ? n : 0;
+  F77_INT tnvl = (calc_lev ? n : 0);
   Matrix vl (tnvl, tnvl);
   double *pvl = vl.fortran_vec ();
 
   F77_INT lwork = -1;
   double dummy_work;
 
   F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
@@ -471,20 +471,20 @@ EIG::init (const Matrix& a, const Matrix
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dggev failed to converge");
 
   lambda.resize (n);
-  F77_INT nvr = calc_rev ? n : 0;
+  F77_INT nvr = (calc_rev ? n : 0);
   v.resize (nvr, nvr);
 
-  F77_INT nvl = calc_lev ? n : 0;
+  F77_INT nvl = (calc_lev ? n : 0);
   w.resize (nvl, nvl);
 
   for (F77_INT j = 0; j < n; j++)
     {
       if (ai.elem (j) == 0.0)
         {
           lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j));
           for (F77_INT i = 0; i < nvr; i++)
@@ -578,18 +578,18 @@ EIG::symmetric_init (const Matrix& a, co
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dsygv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dsygv failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
-  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = (calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ());
+  w = (calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ());
 
   return info;
 }
 
 octave_idx_type
 EIG::init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_rev,
            bool calc_lev, bool force_qz)
 {
@@ -632,21 +632,21 @@ EIG::init (const ComplexMatrix& a, const
   Complex *btmp_data = btmp.fortran_vec ();
 
   ComplexColumnVector alpha (n);
   Complex *palpha = alpha.fortran_vec ();
 
   ComplexColumnVector beta (n);
   Complex *pbeta = beta.fortran_vec ();
 
-  F77_INT nvr = calc_rev ? n : 0;
+  F77_INT nvr = (calc_rev ? n : 0);
   ComplexMatrix vrtmp (nvr, nvr);
   Complex *pvr = vrtmp.fortran_vec ();
 
-  F77_INT nvl = calc_lev ? n : 0;
+  F77_INT nvl = (calc_lev ? n : 0);
   ComplexMatrix vltmp (nvl, nvl);
   Complex *pvl = vltmp.fortran_vec ();
 
   F77_INT lwork = -1;
   Complex dummy_work;
 
   F77_INT lrwork = 8*n;
   Array<double> rwork (dim_vector (lrwork, 1));
@@ -760,13 +760,13 @@ EIG::hermitian_init (const ComplexMatrix
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zhegv failed to converge");
 
   lambda = ComplexColumnVector (wr);
-  v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
-  w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
+  v = (calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ());
+  w = (calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ());
 
   return info;
 }
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -53,21 +53,21 @@ FloatEIG::init (const FloatMatrix& a, bo
   float *tmp_data = atmp.fortran_vec ();
 
   Array<float> wr (dim_vector (n, 1));
   float *pwr = wr.fortran_vec ();
 
   Array<float> wi (dim_vector (n, 1));
   float *pwi = wi.fortran_vec ();
 
-  volatile F77_INT nvr = calc_rev ? n : 0;
+  volatile F77_INT nvr = (calc_rev ? n : 0);
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
-  volatile F77_INT nvl = calc_lev ? n : 0;
+  volatile F77_INT nvl = (calc_lev ? n : 0);
   FloatMatrix vl (nvl, nvl);
   float *pvl = vl.fortran_vec ();
 
   F77_INT lwork = -1;
   float dummy_work;
 
   F77_INT ilo;
   F77_INT ihi;
@@ -209,18 +209,18 @@ FloatEIG::symmetric_init (const FloatMat
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in ssyev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("ssyev failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = (calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
+  w = (calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, bool calc_rev, bool calc_lev,
                 bool balance)
 {
@@ -240,21 +240,21 @@ FloatEIG::init (const FloatComplexMatrix
   F77_INT info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
 
   FloatComplexColumnVector wr (n);
   FloatComplex *pw = wr.fortran_vec ();
 
-  F77_INT nvr = calc_rev ? n : 0;
+  F77_INT nvr = (calc_rev ? n : 0);
   FloatComplexMatrix vrtmp (nvr, nvr);
   FloatComplex *pvr = vrtmp.fortran_vec ();
 
-  F77_INT nvl = calc_lev ? n : 0;
+  F77_INT nvl = (calc_lev ? n : 0);
   FloatComplexMatrix vltmp (nvl, nvl);
   FloatComplex *pvl = vltmp.fortran_vec ();
 
   F77_INT lwork = -1;
   FloatComplex dummy_work;
 
   F77_INT lrwork = 2*n;
   Array<float> rwork (dim_vector (lrwork, 1));
@@ -369,18 +369,18 @@ FloatEIG::hermitian_init (const FloatCom
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in cheev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("cheev failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = (calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
+  w = (calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, const FloatMatrix& b, bool calc_rev,
                 bool calc_lev, bool force_qz)
 {
@@ -425,21 +425,21 @@ FloatEIG::init (const FloatMatrix& a, co
   float *par = ar.fortran_vec ();
 
   Array<float> ai (dim_vector (n, 1));
   float *pai = ai.fortran_vec ();
 
   Array<float> beta (dim_vector (n, 1));
   float *pbeta = beta.fortran_vec ();
 
-  volatile F77_INT nvr = calc_rev ? n : 0;
+  volatile F77_INT nvr = (calc_rev ? n : 0);
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
-  volatile F77_INT nvl = calc_lev ? n : 0;
+  volatile F77_INT nvl = (calc_lev ? n : 0);
   FloatMatrix vl (nvl, nvl);
   float *pvl = vl.fortran_vec ();
 
   F77_INT lwork = -1;
   float dummy_work;
 
   F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
@@ -574,18 +574,18 @@ FloatEIG::symmetric_init (const FloatMat
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in ssygv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("ssygv failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = (calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
+  w = (calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
                 bool calc_rev, bool calc_lev, bool force_qz)
 {
@@ -628,21 +628,21 @@ FloatEIG::init (const FloatComplexMatrix
   FloatComplex *btmp_data = btmp.fortran_vec ();
 
   FloatComplexColumnVector alpha (n);
   FloatComplex *palpha = alpha.fortran_vec ();
 
   FloatComplexColumnVector beta (n);
   FloatComplex *pbeta = beta.fortran_vec ();
 
-  F77_INT nvr = calc_rev ? n : 0;
+  F77_INT nvr = (calc_rev ? n : 0);
   FloatComplexMatrix vrtmp (nvr, nvr);
   FloatComplex *pvr = vrtmp.fortran_vec ();
 
-  F77_INT nvl = calc_lev ? n : 0;
+  F77_INT nvl = (calc_lev ? n : 0);
   FloatComplexMatrix vltmp (nvl, nvl);
   FloatComplex *pvl = vltmp.fortran_vec ();
 
   F77_INT lwork = -1;
   FloatComplex dummy_work;
 
   F77_INT lrwork = 8*n;
   Array<float> rwork (dim_vector (lrwork, 1));
@@ -753,13 +753,13 @@ FloatEIG::hermitian_init (const FloatCom
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zhegv failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
-  v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
-  w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
+  v = (calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
+  w = (calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ());
 
   return info;
 }
diff --git a/liboctave/numeric/gsvd.cc b/liboctave/numeric/gsvd.cc
--- a/liboctave/numeric/gsvd.cc
+++ b/liboctave/numeric/gsvd.cc
@@ -265,17 +265,17 @@ namespace octave
       P *v = left_smB.fortran_vec ();
 
       if (! (jobq == 'N' || jobq == 'O'))
         right_sm.resize (nrow_q, n);
 
       P *q = right_sm.fortran_vec ();
 
       F77_INT lwork = 3*n;
-      lwork = lwork > m ? lwork : m;
+      lwork = (lwork > m ? lwork : m);
       lwork = (lwork > p ? lwork : p) + n;
 
       T work (lwork, 1);
       real_matrix alpha (n, 1);
       real_matrix beta (n, 1);
 
       std::vector<F77_INT> iwork (n);
 
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -2001,17 +2001,17 @@ namespace octave
     airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
       double ar = 0.0;
       double ai = 0.0;
 
       double zr = z.real ();
       double zi = z.imag ();
 
-      F77_INT id = deriv ? 1 : 0;
+      F77_INT id = (deriv ? 1 : 0);
       F77_INT nz, t_ierr;
 
       F77_FUNC (zairy, ZAIRY) (zr, zi, id, 2, ar, ai, nz, t_ierr);
 
       ierr = t_ierr;
 
       if (! scaled)
         {
@@ -2036,17 +2036,17 @@ namespace octave
     biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
       double ar = 0.0;
       double ai = 0.0;
 
       double zr = z.real ();
       double zi = z.imag ();
 
-      F77_INT id = deriv ? 1 : 0;
+      F77_INT id = (deriv ? 1 : 0);
       F77_INT t_ierr;
 
       F77_FUNC (zbiry, ZBIRY) (zr, zi, id, 2, ar, ai, t_ierr);
 
       ierr = t_ierr;
 
       if (! scaled)
         {
@@ -2136,17 +2136,17 @@ namespace octave
     }
 
     FloatComplex
     airy (const FloatComplex& z, bool deriv, bool scaled,
           octave_idx_type& ierr)
     {
       FloatComplex a;
 
-      F77_INT id = deriv ? 1 : 0;
+      F77_INT id = (deriv ? 1 : 0);
       F77_INT nz, t_ierr;
 
       F77_FUNC (cairy, CAIRY) (F77_CONST_CMPLX_ARG (&z), id, 2,
                                F77_CMPLX_ARG (&a), nz, t_ierr);
 
       ierr = t_ierr;
 
       float ar = a.real ();
@@ -2172,17 +2172,17 @@ namespace octave
     }
 
     FloatComplex
     biry (const FloatComplex& z, bool deriv, bool scaled,
           octave_idx_type& ierr)
     {
       FloatComplex a;
 
-      F77_INT id = deriv ? 1 : 0;
+      F77_INT id = (deriv ? 1 : 0);
       F77_INT t_ierr;
 
       F77_FUNC (cbiry, CBIRY) (F77_CONST_CMPLX_ARG (&z), id, 2,
                                F77_CMPLX_ARG (&a), t_ierr);
 
       ierr = t_ierr;
 
       float ar = a.real ();
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -96,17 +96,17 @@ octave_rand::do_seed (void)
   return u.d;
 }
 
 static int32_t
 force_to_fit_range (int32_t i, int32_t lo, int32_t hi)
 {
   assert (hi > lo && lo >= 0 && hi > lo);
 
-  i = i > 0 ? i : -i;
+  i = (i > 0 ? i : -i);
 
   if (i < lo)
     i = lo;
   else if (i > hi)
     i = i % hi;
 
   return i;
 }
@@ -153,17 +153,17 @@ octave_rand::do_state (const std::string
 
 void
 octave_rand::do_state (const ColumnVector& s, const std::string& d)
 {
   use_old_generators = false;
 
   int old_dist = current_distribution;
 
-  int new_dist = d.empty () ? current_distribution : get_dist_id (d);
+  int new_dist = (d.empty () ? current_distribution : get_dist_id (d));
 
   ColumnVector saved_state;
 
   if (old_dist != new_dist)
     saved_state = get_internal_state ();
 
   set_internal_state (s);
 
@@ -175,17 +175,17 @@ octave_rand::do_state (const ColumnVecto
 
 void
 octave_rand::do_reset (const std::string& d)
 {
   use_old_generators = false;
 
   int old_dist = current_distribution;
 
-  int new_dist = d.empty () ? current_distribution : get_dist_id (d);
+  int new_dist = (d.empty () ? current_distribution : get_dist_id (d));
 
   ColumnVector saved_state;
 
   if (old_dist != new_dist)
     saved_state = get_internal_state ();
 
   oct_init_by_entropy ();
   rand_states[new_dist] = get_internal_state ();
@@ -652,17 +652,17 @@ double2uint32 (double d)
 
   return u;
 }
 
 void
 octave_rand::set_internal_state (const ColumnVector& s)
 {
   octave_idx_type len = s.numel ();
-  octave_idx_type n = len < MT_N + 1 ? len : MT_N + 1;
+  octave_idx_type n = (len < MT_N + 1 ? len : MT_N + 1);
 
   OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
 
   for (octave_idx_type i = 0; i < n; i++)
     tmp[i] = double2uint32 (s.elem (i));
 
   if (len == MT_N + 1 && tmp[MT_N] <= MT_N && tmp[MT_N] > 0)
     oct_set_state (tmp);
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -382,31 +382,31 @@ namespace octave
       F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<Matrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
-              F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
+              F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
               for (F77_INT i = limit + 1; i < m; i++)
                 afact.elem (i, j) *= tau[j];
             }
 
           r = afact;
         }
       else
         {
           // Attempt to minimize copying.
           if (m >= n)
             {
               // afact will become q.
               q = afact;
-              F77_INT k = qr_type == qr<Matrix>::economy ? n : m;
+              F77_INT k = (qr_type == qr<Matrix>::economy ? n : m);
               r = Matrix (k, n);
               for (F77_INT j = 0; j < n; j++)
                 {
                   F77_INT i = 0;
                   for (; i <= j; i++)
                     r.xelem (i, j) = afact.xelem (i, j);
                   for (; i < k; i++)
                     r.xelem (i, j) = 0;
@@ -446,17 +446,17 @@ namespace octave
 
     template <>
     void
     qr<Matrix>::init (const Matrix& a, type qr_type)
     {
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
       F77_INT info = 0;
 
       Matrix afact = a;
       if (m > n && qr_type == qr<Matrix>::std)
         afact.resize (m, m);
 
@@ -682,17 +682,17 @@ namespace octave
           F77_INT ldq = octave::to_f77_int (q.rows ());
           F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, w, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               F77_INT js_elt = octave::to_f77_int (js(ii));
-              F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii,
+              F77_XFCN (dqrdec, DQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr,
                                          js_elt + 1, w));
             }
 
           if (k < m)
             {
               q.resize (m, k - nj);
@@ -796,31 +796,31 @@ namespace octave
       F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<FloatMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
-              F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
+              F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
               for (F77_INT i = limit + 1; i < m; i++)
                 afact.elem (i, j) *= tau[j];
             }
 
           r = afact;
         }
       else
         {
           // Attempt to minimize copying.
           if (m >= n)
             {
               // afact will become q.
               q = afact;
-              F77_INT k = qr_type == qr<FloatMatrix>::economy ? n : m;
+              F77_INT k = (qr_type == qr<FloatMatrix>::economy ? n : m);
               r = FloatMatrix (k, n);
               for (F77_INT j = 0; j < n; j++)
                 {
                   F77_INT i = 0;
                   for (; i <= j; i++)
                     r.xelem (i, j) = afact.xelem (i, j);
                   for (; i < k; i++)
                     r.xelem (i, j) = 0;
@@ -860,17 +860,17 @@ namespace octave
 
     template <>
     void
     qr<FloatMatrix>::init (const FloatMatrix& a, type qr_type)
     {
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatMatrix afact = a;
       if (m > n && qr_type == qr<FloatMatrix>::std)
         afact.resize (m, m);
 
@@ -1098,17 +1098,17 @@ namespace octave
           F77_INT ldq = octave::to_f77_int (q.rows ());
           F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, w, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               F77_INT js_elt = octave::to_f77_int (js(ii));
-              F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii,
+              F77_XFCN (sqrdec, SQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr,
                                          js_elt + 1, w));
             }
 
           if (k < m)
             {
               q.resize (m, k - nj);
@@ -1214,31 +1214,31 @@ namespace octave
       F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<ComplexMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
-              F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
+              F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
               for (F77_INT i = limit + 1; i < m; i++)
                 afact.elem (i, j) *= tau[j];
             }
 
           r = afact;
         }
       else
         {
           // Attempt to minimize copying.
           if (m >= n)
             {
               // afact will become q.
               q = afact;
-              F77_INT k = qr_type == qr<ComplexMatrix>::economy ? n : m;
+              F77_INT k = (qr_type == qr<ComplexMatrix>::economy ? n : m);
               r = ComplexMatrix (k, n);
               for (F77_INT j = 0; j < n; j++)
                 {
                   F77_INT i = 0;
                   for (; i <= j; i++)
                     r.xelem (i, j) = afact.xelem (i, j);
                   for (; i < k; i++)
                     r.xelem (i, j) = 0;
@@ -1284,17 +1284,17 @@ namespace octave
 
     template <>
     void
     qr<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
     {
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
       F77_INT info = 0;
 
       ComplexMatrix afact = a;
       if (m > n && qr_type == qr<ComplexMatrix>::std)
         afact.resize (m, m);
 
@@ -1539,17 +1539,17 @@ namespace octave
           F77_INT ldq = octave::to_f77_int (q.rows ());
           F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, rw, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               F77_INT js_elt = octave::to_f77_int (js(ii));
-              F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii,
+              F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                          ldq,
                                          F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                          ldr, js_elt + 1, rw));
             }
 
           if (k < m)
             {
@@ -1660,31 +1660,31 @@ namespace octave
       F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<FloatComplexMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
-              F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
+              F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
               for (F77_INT i = limit + 1; i < m; i++)
                 afact.elem (i, j) *= tau[j];
             }
 
           r = afact;
         }
       else
         {
           // Attempt to minimize copying.
           if (m >= n)
             {
               // afact will become q.
               q = afact;
-              F77_INT k = qr_type == qr<FloatComplexMatrix>::economy ? n : m;
+              F77_INT k = (qr_type == qr<FloatComplexMatrix>::economy ? n : m);
               r = FloatComplexMatrix (k, n);
               for (F77_INT j = 0; j < n; j++)
                 {
                   F77_INT i = 0;
                   for (; i <= j; i++)
                     r.xelem (i, j) = afact.xelem (i, j);
                   for (; i < k; i++)
                     r.xelem (i, j) = 0;
@@ -1728,17 +1728,17 @@ namespace octave
 
     template <>
     void
     qr<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
     {
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatComplexMatrix afact = a;
       if (m > n && qr_type == qr<FloatComplexMatrix>::std)
         afact.resize (m, m);
 
@@ -1978,17 +1978,17 @@ namespace octave
           F77_INT ldq = octave::to_f77_int (q.rows ());
           F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, rw, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               F77_INT js_elt = octave::to_f77_int (js(ii));
-              F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii,
+              F77_XFCN (cqrdec, CQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                          F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                          js_elt + 1, rw));
             }
 
           if (k < m)
             {
               q.resize (m, k - nj);
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -48,17 +48,17 @@ namespace octave
     void
     qrp<Matrix>::init (const Matrix& a, type qr_type)
     {
       assert (qr_type != qr<Matrix>::raw);
 
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
       F77_INT info = 0;
 
       Matrix afact = a;
       if (m > n && qr_type == qr<Matrix>::std)
         afact.resize (m, m);
 
@@ -116,17 +116,17 @@ namespace octave
     void
     qrp<FloatMatrix>::init (const FloatMatrix& a, type qr_type)
     {
       assert (qr_type != qr<FloatMatrix>::raw);
 
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatMatrix afact = a;
       if (m > n && qr_type == qr<FloatMatrix>::std)
         afact.resize (m, m);
 
@@ -184,17 +184,17 @@ namespace octave
     void
     qrp<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
     {
       assert (qr_type != qr<ComplexMatrix>::raw);
 
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
       F77_INT info = 0;
 
       ComplexMatrix afact = a;
       if (m > n && qr_type == qr<ComplexMatrix>::std)
         afact.resize (m, m);
 
@@ -260,17 +260,17 @@ namespace octave
     void
     qrp<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
     {
       assert (qr_type != qr<FloatComplexMatrix>::raw);
 
       F77_INT m = octave::to_f77_int (a.rows ());
       F77_INT n = octave::to_f77_int (a.cols ());
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatComplexMatrix afact = a;
       if (m > n && qr_type == qr<FloatComplexMatrix>::std)
         afact.resize (m, m);
 
diff --git a/liboctave/numeric/randgamma.cc b/liboctave/numeric/randgamma.cc
--- a/liboctave/numeric/randgamma.cc
+++ b/liboctave/numeric/randgamma.cc
@@ -91,17 +91,17 @@ Dirichlet(a1,...,ak) for ai > 0
 #define RNOR oct_randn()
 #define REXP oct_rande()
 
 void
 oct_fill_randg (double a, octave_idx_type n, double *r)
 {
   octave_idx_type i;
   /* If a < 1, start by generating gamma (1+a) */
-  const double d =  (a < 1. ? 1.+a : a) - 1./3.;
+  const double d = (a < 1. ? 1.+a : a) - 1./3.;
   const double c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
         r[i] = octave::numeric_limits<double>::NaN ();
       return;
@@ -146,17 +146,17 @@ oct_randg (double a)
 #define RNOR oct_float_randn()
 #define REXP oct_float_rande()
 
 void
 oct_fill_float_randg (float a, octave_idx_type n, float *r)
 {
   octave_idx_type i;
   /* If a < 1, start by generating gamma(1+a) */
-  const float d =  (a < 1. ? 1.+a : a) - 1./3.;
+  const float d = (a < 1. ? 1.+a : a) - 1./3.;
   const float c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
         r[i] = octave::numeric_limits<float>::NaN ();
       return;
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -116,17 +116,17 @@ namespace octave
       char sense = 'N';
       char sort = 'N';
 
       if (calc_unitary)
         jobvs = 'V';
       else
         jobvs = 'N';
 
-      char ord_char = ord.empty () ? 'U' : ord[0];
+      char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
       volatile double_selector selector = 0;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
@@ -203,17 +203,17 @@ namespace octave
       char sense = 'N';
       char sort = 'N';
 
       if (calc_unitary)
         jobvs = 'V';
       else
         jobvs = 'N';
 
-      char ord_char = ord.empty () ? 'U' : ord[0];
+      char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
       volatile float_selector selector = 0;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
@@ -290,17 +290,17 @@ namespace octave
       char sense = 'N';
       char sort = 'N';
 
       if (calc_unitary)
         jobvs = 'V';
       else
         jobvs = 'N';
 
-      char ord_char = ord.empty () ? 'U' : ord[0];
+      char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
       volatile complex_selector selector = 0;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
@@ -398,17 +398,17 @@ namespace octave
       char sense = 'N';
       char sort = 'N';
 
       if (calc_unitary)
         jobvs = 'V';
       else
         jobvs = 'N';
 
-      char ord_char = ord.empty () ? 'U' : ord[0];
+      char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
       volatile float_complex_selector selector = 0;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -311,17 +311,17 @@ namespace octave
               break;
             }
           return;
         }
 
       T atmp = a;
       P *tmp_data = atmp.fortran_vec ();
 
-      F77_INT min_mn = m < n ? m : n;
+      F77_INT min_mn = (m < n ? m : n);
 
       char jobu = 'A';
       char jobv = 'A';
 
       F77_INT ncol_u = m;
       F77_INT nrow_vt = n;
       F77_INT nrow_s = m;
       F77_INT ncol_s = n;
diff --git a/liboctave/operators/Sparse-diag-op-defs.h b/liboctave/operators/Sparse-diag-op-defs.h
--- a/liboctave/operators/Sparse-diag-op-defs.h
+++ b/liboctave/operators/Sparse-diag-op-defs.h
@@ -72,17 +72,17 @@ RT do_mul_sm_dm (const SM& a, const DM& 
   const octave_idx_type nc = d.cols ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nc)
     octave::err_nonconformant ("operator *", a_nr, a_nc, nr, nc);
 
-  const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
+  const octave_idx_type mnc = (nc < a_nc ? nc: a_nc);
   RT r (a_nr, nc, a.cidx (mnc));
 
   for (octave_idx_type j = 0; j < mnc; ++j)
     {
       const typename DM::element_type s = d.dgelem (j);
       const octave_idx_type colend = a.cidx (j+1);
       r.xcidx (j) = a.cidx (j);
       for (octave_idx_type k = a.cidx (j); k < colend; ++k)
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -386,26 +386,26 @@ mx_inline_xmax (size_t n, T *r, T x, con
 #define DEFMINMAXSPEC(T, F, OP)                                 \
   template <>                                                   \
   inline void F<T> (size_t n, T *r, const T *x, T y) throw ()   \
   {                                                             \
     if (octave::math::isnan (y))                                \
       std::memcpy (r, x, n * sizeof (T));                       \
     else                                                        \
       for (size_t i = 0; i < n; i++)                            \
-        r[i] = (x[i] OP y) ? x[i] : y;                          \
+        r[i] = (x[i] OP y ? x[i] : y);                          \
   }                                                             \
   template <>                                                   \
   inline void F<T> (size_t n, T *r, T x, const T *y) throw ()   \
   {                                                             \
     if (octave::math::isnan (x))                                \
       std::memcpy (r, y, n * sizeof (T));                       \
     else                                                        \
       for (size_t i = 0; i < n; i++)                            \
-        r[i] = (y[i] OP x) ? y[i] : x;                          \
+        r[i] = (y[i] OP x ? y[i] : x);                          \
   }
 
 DEFMINMAXSPEC (double, mx_inline_xmin, <=)
 DEFMINMAXSPEC (double, mx_inline_xmax, >=)
 DEFMINMAXSPEC (float, mx_inline_xmin, <=)
 DEFMINMAXSPEC (float, mx_inline_xmax, >=)
 
 // Let the compiler decide which pow to use, whichever best matches the
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -488,31 +488,31 @@ namespace octave
         }
 #endif
 
       if (hd.empty ())
         {
           octave::sys::password pw = octave::sys::password::getpwuid (
                                        octave::sys::getuid ());
 
-          hd = pw ? pw.dir () : std::string (octave::sys::file_ops::dir_sep_str ());
+          hd = (pw ? pw.dir () : std::string (octave::sys::file_ops::dir_sep_str ()));
         }
 
       return hd;
     }
 
     std::string
     env::do_get_user_name (void) const
     {
       if (user_name.empty ())
         {
           octave::sys::password pw = octave::sys::password::getpwuid (
                                        octave::sys::getuid ());
 
-          user_name = pw ? pw.name () : std::string ("unknown");
+          user_name = (pw ? pw.name () : std::string ("unknown"));
         }
 
       return user_name;
     }
 
     std::string
     env::do_get_host_name (void) const
     {
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -440,50 +440,50 @@ namespace octave
   }
 
   void
   gnu_readline::do_set_completion_function (completion_fcn f)
   {
     completion_function = f;
 
     rl_attempted_completion_fcn_ptr fp
-      = f ? gnu_readline::command_completer : 0;
+      = (f ? gnu_readline::command_completer : 0);
 
     ::octave_rl_set_completion_function (fp);
   }
 
   void
   gnu_readline::do_set_quoting_function (quoting_fcn f)
   {
     quoting_function = f;
 
     rl_quoting_fcn_ptr fp
-      = f ? gnu_readline::command_quoter : 0;
+      = (f ? gnu_readline::command_quoter : 0);
 
     ::octave_rl_set_quoting_function (fp);
   }
 
   void
   gnu_readline::do_set_dequoting_function (dequoting_fcn f)
   {
     dequoting_function = f;
 
     rl_dequoting_fcn_ptr fp
-      = f ? gnu_readline::command_dequoter : 0;
+      = (f ? gnu_readline::command_dequoter : 0);
 
     ::octave_rl_set_dequoting_function (fp);
   }
 
   void
   gnu_readline::do_set_char_is_quoted_function (char_is_quoted_fcn f)
   {
     char_is_quoted_function = f;
 
     rl_char_is_quoted_fcn_ptr fp
-      = f ? gnu_readline::command_char_is_quoted : 0;
+      = (f ? gnu_readline::command_char_is_quoted : 0);
 
     ::octave_rl_set_char_is_quoted_function (fp);
   }
 
   void
   gnu_readline::do_set_user_accept_line_function (user_accept_line_fcn f)
   {
     user_accept_line_function = f;
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -709,30 +709,30 @@ kpse_tilde_expand (const std::string& na
 
       std::string user = name.substr (1, c-1);
 
       /* We only need the cast here for (deficient) systems
          which do not declare 'getpwnam' in <pwd.h>.  */
       octave::sys::password p = octave::sys::password::getpwnam (user);
 
       /* If no such user, just use '.'.  */
-      std::string home = p ? p.dir () : std::string (".");
+      std::string home = (p ? p.dir () : std::string ("."));
 
       if (home.empty ())
         home = ".";
 
       /* handle leading // */
       if (home.length () > 1 && IS_DIR_SEP (home[0]) && IS_DIR_SEP (home[1]))
         home = home.substr (1);
 
       /* If HOME ends in /, omit the / after ~user. */
       if (name.length () > c && IS_DIR_SEP (home[home.length () - 1]))
         c++;
 
-      expansion = name.length () > c ? home : home + name.substr (c);
+      expansion = (name.length () > c ? home : home + name.substr (c));
     }
 #else /* not HAVE_PWD_H */
   expansion = name;
 #endif /* not HAVE_PWD_H */
 
   return expansion;
 }
 
@@ -1142,17 +1142,17 @@ kpse_expand_default (const std::string& 
   size_t path_len = path.length ();
 
   if (path_len == 0)
     expansion = fallback;
 
   /* Solitary or leading :?  */
   else if (IS_ENV_SEP (path[0]))
     {
-      expansion = path_len == 1 ? fallback : fallback + path;
+      expansion = (path_len == 1 ? fallback : fallback + path);
     }
 
   /* Sorry about the assignment in the middle of the expression, but
      conventions were made to be flouted and all that.  I don't see the
      point of calling strlen twice or complicating the logic just to
      avoid the assignment (especially now that I've pointed it out at
      such great length).  */
   else if (IS_ENV_SEP (path[path_len-1]))
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -70,17 +70,17 @@ inline bool xisnan (long double x) { ret
 #endif
 
 #endif
 
 // FIXME: we define this by our own because some compilers, such as
 // MSVC, do not provide std::abs (int64_t) and std::abs (uint64_t).  In
 // the future, it should go away in favor of std::abs.
 template <typename T>
-inline T octave_int_abs (T x) { return x >= 0 ? x : -x; }
+inline T octave_int_abs (T x) { return (x >= 0 ? x : -x); }
 
 // Query for an integer type of certain sizeof, and signedness.
 template <int qsize, bool qsigned>
 struct query_integer_type
 {
 public:
   static const bool registered = false;
   typedef void type; // Void shall result in a compile-time error if we
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -1414,18 +1414,18 @@ octave_sort<T>::sort (T *data, octave_id
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             return;
           if (descending)
             std::reverse (data + lo, data + lo + n);
           /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
-              const octave_idx_type force = nremaining <= minrun ? nremaining
-                                                                 : minrun;
+              const octave_idx_type force = (nremaining <= minrun ? nremaining
+                                                                  : minrun);
               binarysort (data + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
           ms->pending[ms->n].base = lo;
           ms->pending[ms->n].len = n;
           ms->n++;
@@ -1474,18 +1474,18 @@ octave_sort<T>::sort (T *data, octave_id
           if (descending)
             {
               std::reverse (data + lo, data + lo + n);
               std::reverse (idx + lo, idx + lo + n);
             }
           /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
-              const octave_idx_type force = nremaining <= minrun ? nremaining
-                                                                 : minrun;
+              const octave_idx_type force = (nremaining <= minrun ? nremaining
+                                                                  : minrun);
               binarysort (data + lo, idx + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
           ms->pending[ms->n].base = lo;
           ms->pending[ms->n].len = n;
           ms->n++;
