# HG changeset patch
# User dbateman
# Date 1114779865 0
#      Fri Apr 29 13:04:25 2005 +0000
# Node ID 22994a5730f9d67861a6e067d3e130997c11c548
# Parent  84b72a402b86d3823964b41681752be5ff920c44
[project @ 2005-04-29 13:04:24 by dbateman]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2005-04-29  David Bateman  <dbateman@free.fr>
+
+	* configure.in: Add UMFPACK_LONG_IDX
+
 2005-04-21  John W. Eaton  <jwe@octave.org>
 
 	* configure.in (AC_CONFIG_FILES): Remove install-octave from the list.
 	(AH_BOTTOM): Define SIZEOF_OCTAVE_IDX_TYPE.
 
 2005-04-14  John W. Eaton  <jwe@octave.org>
 
 	* mkoctfile.in: Only perform link step if we have some object files.
diff --git a/PROJECTS b/PROJECTS
--- a/PROJECTS
+++ b/PROJECTS
@@ -108,18 +108,18 @@ Sparse Matrices:
 ---------------
 
   * Sparse Cholesky factorization for Fchol function and also for the 
     in built polymorphic solvers.
 
   * QR factorization functions, also for use in lssolve functions. Write
     svds function based on this. Write sprank function based on svds.
 
-  * Once dmperm is implemented, use the technique to detect permuted
-    triangular matrices. Test the permuted triangular matrix solver code
+  * Once dmperm is implemented, perhaps use the technique to detect permuted
+    triangular matrices with permutations in both rows and cols.
 
   * Sparse inverse function, based on Andy's code from octave-forge.
 
   * Implement fourth argument to the sprand and sprandn that the leading
     brand implements.
 
   * Sparse logical indexing in idx_vector class so that something like
     "a=sprandn(1e6,1e6,1e-6); a(a<1) = 0" won't cause a memory overflow.
@@ -155,17 +155,18 @@ Sparse Matrices:
 
     The fact is that this doesn't make sense in any case as the assign
     function makes another copy of the sparse matrix. So although spalloc
     might easily be made to have the correct behaviour, the first assign
     will cause the matrix to be resized !!! There seems to be no simple
     way to treat this but a complete rewrite of the sparse assignment
     functions...
 
-  * Port the sparse testing code into the DejaGNU testing code.
+  * Port the sparse testing code into the DejaGNU testing code. Add tests
+    for spkron, matrix_type, luinc..
 
   * Treat the dispatching of the splu, spdet, functions, etc within octave
     itself. This either means that classes need implementing or at the
     minimum the octave-forge dispatch function is implemented within octave
 
   * Other missing Functions
       - eigs
       - dmperm      Tim Davis is apparently working on something
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.474 $)
+AC_REVISION($Revision: 1.475 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -155,16 +155,17 @@ if $USE_64_BIT_IDX_T; then
   AC_CHECK_SIZEOF(void *)
   AC_CHECK_SIZEOF(int)
   AC_CHECK_SIZEOF(long)
   if test $ac_cv_sizeof_void_p -eq 8; then
     if test $ac_cv_sizeof_int -eq 8; then
       OCTAVE_IDX_TYPE=int
     elif test $ac_cv_sizeof_long -eq 8; then
       OCTAVE_IDX_TYPE=long
+      AC_DEFINE(UMFPACK_LONG_IDX, 1, [Define to 1 to use long int versions of UMFPACK])
     else
       AC_MSG_WARN([no suitable type found for octave_idx_type so disabling 64-bit features])    
       USE_64_BIT_IDX_T=false
     fi
   else
     warn_64_bit="pointers are not 64-bits wide so disabling 64-bit features"
     AC_MSG_WARN($warn_64_bit)
     USE_64_BIT_IDX_T=false
diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,13 @@
+2005-04-29  David Bateman  <dbateman@free.fr>
+
+	* interpreter/sparse.txi: Add matrix_type, spkron, and document changes
+	in solve code
+
 2005-03-14  David Bateman  <dbateman@free.fr>
 
 	* interpreter/sparse.txi: Add luinc function.
 
 2005-03-09  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (bin-dist): Delete target.
 	(BINDISTSUBDIRS): Delete variable.
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -410,19 +410,20 @@ Someone who knows more about this than m
 
 WRITE ME
 
 @node Sparse Linear Algebra, Iterative Techniques, Graph Theory, Sparse Matrices
 @section Linear Algebra on Sparse Matrices
 
 @sc{Octave} includes a poly-morphic solver for sparse matrices, where 
 the exact solver used to factorize the matrix, depends on the properties
-of the sparse matrix, itself. As the cost of determining the matrix type
-is small relative to the cost of factorizing the matrix itself, the matrix
-type is re-determined each time it is used in a linear equation.
+of the sparse matrix, itself. The cost of determining the matrix type
+is small relative to the cost of factorizing the matrix itself, but in any
+case the matrix type is cached once it is calculated, so that it is not
+re-determined each time it is used in a linear equation.
 
 The selection tree for how the linear equation is solve is
 
 @enumerate 1
 @item If the matrix is not square go to 9.
 
 @item If the matrix is diagonal, solve directly and goto 9
 
@@ -451,21 +452,19 @@ continue, else goto 4b.
 @item if the above failed or the matrix is not hermitian with a positive
       real diagonal use Gaussian elimination with pivoting using 
       @sc{Lapack} xGBTRF, and goto 9.
 @end enumerate
 
 @item If the matrix is upper or lower triangular perform a sparse forward
 or backward subsitution, and goto 9
 
-@item If the matrix is a permuted upper or lower triangular matrix, perform
-a sparse forward or backward subsitution, and goto 9
-
-FIXME: Detection of permuted triangular matrices not written yet, and so
-       the code itself is not tested either
+@item If the matrix is a upper triangular matrix with column permutations
+or lower triangular matrix with row permutations, perform a sparse forward 
+or backward subsitution, and goto 9
 
 @item If the matrix is hermitian with a real positive diagonal, attempt
 sparse Cholesky factorization.
 
 FIXME: Detection of positive definite matrices written and tested, but 
    Cholesky factorization isn't yet written
 
 @item If the sparse Cholesky factorization failed or the matrix is not
@@ -489,16 +488,22 @@ stability problems in the solution and f
 to be used. However, for narrow banded matrices, the cost of
 calculating the condition number is significant, and can in fact exceed
 the cost of factoring the matrix. Therefore the condition number is
 not calculated for banded matrices, and therefore unless the factorization
 is exactly singular, these numerical instabilities won't be detected.
 In cases where, this might be a problem the user is recommended to disable
 the banded solvers as above, at a significant cost in terms of speed.
 
+The user can force the type of the matrix with the @code{matrix_type}
+function. This overcomes the cost of discovering the type of the matrix.
+However, it should be noted incorrectly identifying the type of the matrix
+will lead to unpredictable results, and so @code{matrix_type} should be
+use dwith care.
+
 @node Iterative Techniques, Oct-Files, Sparse Linear Algebra, Sparse Matrices
 @section Iterative Techniques applied to sparse matrices
 
 WRITE ME
 
 @node Oct-Files, License, Iterative Techniques, Sparse Matrices
 @section Using Sparse Matrices in Oct-files
 
@@ -960,36 +965,40 @@ Returns the elimination tree for the mat
 @end table
 @subsubsection Sparse matrix reordering
 @table @asis
 @item colamd
 Column approximate minimum degree permutation.
 @item colperm
 Returns the column permutations such that the columns of `S (:, P)' are ordered in terms of increase number of non-zero elements.
 @item dmperm
-Perfrom a Deulmage-Mendelsohn permutation on the sparse matrix S.
+Perform a Deulmage-Mendelsohn permutation on the sparse matrix S.
 @item symamd
 For a symmetric positive definite matrix S, returns the permutation vector p such that `S (P, P)' tends to have a sparser Cholesky factor than S.
 @item symrcm
 Returns the Reverse Cuthill McKee reordering of the sparse matrix S.
 @end table
 @subsubsection Linear algebra
 @table @asis
 @item cholinc
 @emph{Not implemented}
 @item condest
 @emph{Not implemented}
 @item eigs
 @emph{Not implemented}
+@item matrix_type
+Identify the matrix type or mark a matrix as a particular type.
 @item normest
 @emph{Not implemented}
 @item spdet
 Compute the determinant of sparse matrix A using UMFPACK.
 @item spinv
 Compute the inverse of the square matrix A.
+@item spkron
+Form the kronecker product of two sparse matrices.
 @item splu
 Compute the LU decomposition of the sparse matrix A, using subroutines from UMFPACK.
 @item sprank
 @emph{Not implemented}
 @item svds
 @emph{Not implemented}
 @end table
 @subsubsection Iterative techniques
@@ -1061,16 +1070,18 @@ Return a sparse matrix with M rows and N
 		matrix S.
 * etree::	Returns the elimination tree for the matrix S.
 * full::	returns a full storage matrix from a sparse one See also:
 		sparse
 * issparse::	Return 1 if the value of the expression EXPR is a sparse
 		matrix.
 * luinc::	Produce the incomplete LU factorization of the sparse 
 		A.
+* matrix_type:: Identify the matrix type or mark a matrix as a particular
+		type.
 * nnz:: 	returns number of non zero elements in SM See also: sparse
 * nonzeros::	Returns a vector of the non-zero values of the sparse
 		matrix S
 * nzmax::	Returns the amount of storage allocated to the sparse
 		matrix SM.
 * spalloc::	Returns an empty sparse matrix of size R-by-C.
 * sparse::	SPARSE: create a sparse matrix
 * spatan2::	Compute atan (Y / X) for corresponding sparse matrix
@@ -1084,16 +1095,17 @@ Return a sparse matrix with M rows and N
 * spdiag::	Return a diagonal matrix with the sparse vector V on
 		diagonal K.
 * spdiags::	A generalization of the function `spdiag'.
 * speye::	Returns a sparse identity matrix.
 * spfind::	SPFIND: a sparse version of the find operator 1.
 * spfun::	Compute `f(X)' for the non-zero values of X This results in
 		a sparse matrix with the same structure as X.
 * spinv::	Compute the inverse of the square matrix A.
+* spkron::	Form the kronecker product of two sparse matrices.
 * splu::	Compute the LU decomposition of the sparse matrix A, using
 		subroutines from UMFPACK.
 * spmax::	For a vector argument, return the maximum value.
 * spmin::	For a vector argument, return the minimum value.
 * spones::	Replace the non-zero entries of X with ones.
 * spparms::	Sets or displays the parameters used by the sparse solvers
 		and factorization functions.
 * spprod::	Product of elements along dimension DIM.
@@ -1142,22 +1154,27 @@ Return a sparse matrix with M rows and N
 
 @DOCSTRING(full)
 
 @node issparse, luinc, full, Function Reference
 @subsubsection issparse
 
 @DOCSTRING(issparse)
 
-@node luinc, nnz, issparse, Function Reference
+@node luinc, matrix_type, issparse, Function Reference
 @subsubsection luinc
 
 @DOCSTRING(luinc)
 
-@node nnz, nonzeros, luinc, Function Reference
+@node matrix_type, nnz, luinc, Function Reference
+@subsubsection matrix_type
+
+@DOCSTRING(matrix_type)
+
+@node nnz, nonzeros, matrix_type, Function Reference
 @subsubsection nnz
 
 @DOCSTRING(nnz)
 
 @node nonzeros, nzmax, nnz, Function Reference
 @subsubsection nonzeros
 
 @DOCSTRING(nonzeros)
@@ -1222,22 +1239,27 @@ Return a sparse matrix with M rows and N
 
 @DOCSTRING(spfind)
 
 @node spfun, spinv, spfind, Function Reference
 @subsubsection spfun
 
 @DOCSTRING(spfun)
 
-@node spinv, splu, spfun, Function Reference
+@node spinv, spkron, spfun, Function Reference
 @subsubsection spinv
 
 @DOCSTRING(spinv)
 
-@node splu, spmax, spinv, Function Reference
+@node spkron, splu, spinv, Function Reference
+@subsubsection spkron
+
+@DOCSTRING(spkron)
+
+@node splu, spmax, spkron, Function Reference
 @subsubsection splu
 
 @DOCSTRING(splu)
 
 @node spmax, spmin, splu, Function Reference
 @subsubsection spmax
 
 @DOCSTRING(spmax)
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -93,17 +93,17 @@ extern "C"
   F77_RET_T
   F77_FUNC (zgttrs, ZGTTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
 			     const octave_idx_type&, const Complex*, const Complex*,
 			     const Complex*, const Complex*, const octave_idx_type*,
 			     Complex *, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
+  F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, double*, Complex*,
 			   Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
 			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseMatrix& a)
@@ -644,17 +644,17 @@ SparseComplexMatrix::determinant (octave
     }
   else
     {
       err = 0;
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
-      umfpack_zi_defaults (control);
+      UMFPACK_ZNAME (defaults) (control);
 
       double tmp = Voctave_sparse_controls.get_key ("spumoni");
       if (!xisnan (tmp))
 	Control (UMFPACK_PRL) = tmp;
 
       tmp = Voctave_sparse_controls.get_key ("piv_tol");
       if (!xisnan (tmp))
 	{
@@ -665,86 +665,86 @@ SparseComplexMatrix::determinant (octave
       // Set whether we are allowed to modify Q or not
       tmp = Voctave_sparse_controls.get_key ("autoamd");
       if (!xisnan (tmp))
 	Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
-      umfpack_zi_report_control (control);
+      UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
-      umfpack_zi_report_matrix (nr, nc, Ap, Ai, 
-				X_CAST (const double *, Ax), 
-				NULL, 1, control);
+      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
+				    X_CAST (const double *, Ax), 
+				    NULL, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = umfpack_zi_qsymbolic 
+      int status = UMFPACK_ZNAME (qsymbolic) 
 	(nr, nc, Ap, Ai, X_CAST (const double *, Ax), NULL, 
 	 NULL, &Symbolic, control, info);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexMatrix::determinant symbolic factorization failed");
 
-	  umfpack_zi_report_status (control, status);
-	  umfpack_zi_report_info (control, info);
-
-	  umfpack_zi_free_symbolic (&Symbolic) ;
+	  UMFPACK_ZNAME (report_status) (control, status);
+	  UMFPACK_ZNAME (report_info) (control, info);
+
+	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 	}
       else
 	{
-	  umfpack_zi_report_symbolic (Symbolic, control);
+	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
-	  status = umfpack_zi_numeric (Ap, Ai, X_CAST (const double *, Ax), 
-				       NULL, Symbolic, &Numeric,
-				       control, info) ;
-	  umfpack_zi_free_symbolic (&Symbolic) ;
+	  status = UMFPACK_ZNAME (numeric) (Ap, Ai,
+				       X_CAST (const double *, Ax), NULL,
+				       Symbolic, &Numeric, control, info) ;
+	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
 	  rcond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseComplexMatrix::determinant numeric factorization failed");
 
-	      umfpack_zi_report_status (control, status);
-	      umfpack_zi_report_info (control, info);
-
-	      umfpack_zi_free_numeric (&Numeric);
+	      UMFPACK_ZNAME (report_status) (control, status);
+	      UMFPACK_ZNAME (report_info) (control, info);
+
+	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
 	  else
 	    {
-	      umfpack_zi_report_numeric (Numeric, control);
+	      UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
 	      Complex d[2];
 	      double d_exponent;
 
-	      status = umfpack_zi_get_determinant 
+	      status = UMFPACK_ZNAME (get_determinant) 
 		(X_CAST (double *, &d[0]), NULL, &d_exponent,
 		 Numeric, info);
 	      d[1] = d_exponent;
 
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseComplexMatrix::determinant error calculating determinant");
 		  
-		  umfpack_zi_report_status (control, status);
-		  umfpack_zi_report_info (control, info);
+		  UMFPACK_ZNAME (report_status) (control, status);
+		  UMFPACK_ZNAME (report_info) (control, info);
 		  
-		  umfpack_zi_free_numeric (&Numeric);
+		  UMFPACK_ZNAME (free_numeric) (&Numeric);
 		}
 	      else
 		retval = ComplexDET (d);
 	    }
 	}
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
@@ -1047,74 +1047,72 @@ SparseComplexMatrix::utsolve (SparseType
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (b.rows (), b.cols ());
+	      retval.resize (nr, b_cols);
+	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
 	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
+		    retval (perm[i], j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(iidx); 
+			       i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = ridx(i);
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
@@ -1264,48 +1262,49 @@ SparseComplexMatrix::utsolve (SparseType
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
+	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+	      for (octave_idx_type i = 0; i < nr; i++)
+		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -1316,45 +1315,46 @@ SparseComplexMatrix::utsolve (SparseType
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (work[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(iidx); 
+			       i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = ridx(i);
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
@@ -1521,75 +1521,72 @@ SparseComplexMatrix::utsolve (SparseType
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (b.rows (), b.cols ());
+	      retval.resize (nr, b_nc);
+	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
-
+		    retval (perm[i], j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(iidx); 
+			       i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = ridx(i);
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
@@ -1739,48 +1736,49 @@ SparseComplexMatrix::utsolve (SparseType
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
+	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+	      for (octave_idx_type i = 0; i < nr; i++)
+		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(kidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -1791,45 +1789,46 @@ SparseComplexMatrix::utsolve (SparseType
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (work[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(iidx); 
+			       i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = ridx(i);
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += std::abs(work[i]);
@@ -1998,79 +1997,97 @@ SparseComplexMatrix::ltsolve (SparseType
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
+		    work[perm[i]] = b(i,j);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
-
+		    retval (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2216,47 +2233,54 @@ SparseComplexMatrix::ltsolve (SparseType
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
+		    work[perm[b.ridx(i)]] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -2267,51 +2291,63 @@ SparseComplexMatrix::ltsolve (SparseType
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2477,79 +2513,97 @@ SparseComplexMatrix::ltsolve (SparseType
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
+		    work[perm[i]] = b(i,j);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
-
+		    retval (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2696,47 +2750,54 @@ SparseComplexMatrix::ltsolve (SparseType
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseComplexMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
+		    work[perm[b.ridx(i)]] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -2747,51 +2808,63 @@ SparseComplexMatrix::ltsolve (SparseType
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  Complex tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2937,45 +3010,45 @@ SparseComplexMatrix::trisolve (SparseTyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
 
 	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
-		  D[j] = data(ii++);
+		  D[j] = std::real(data(ii++));
 		  DL[j] = data(ii);
 		  ii += 2;
 		}
-	      D[nc-1] = data(ii);
+	      D[nc-1] = std::real(data(ii));
 	    }
 	  else
 	    {
 	      D[0] = 0.;
 	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		}
 
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
-		      D[j] = data(i);
+		      D[j] = std::real(data(i));
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		  }
 	    }
 	      
 	  octave_idx_type b_nc = b.cols();
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
@@ -3027,17 +3100,17 @@ SparseComplexMatrix::trisolve (SparseTyp
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  octave_idx_type b_nc = b.cols();
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 
 	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
@@ -3124,17 +3197,17 @@ SparseComplexMatrix::trisolve (SparseTyp
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgttrf");
@@ -3233,48 +3306,47 @@ SparseComplexMatrix::trisolve (SparseTyp
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
-      // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
 
 	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
-		  D[j] = data(ii++);
+		  D[j] = std::real(data(ii++));
 		  DL[j] = data(ii);
 		  ii += 2;
 		}
-	      D[nc-1] = data(ii);
+	      D[nc-1] = std::real(data(ii));
 	    }
 	  else
 	    {
 	      D[0] = 0.;
 	      for (octave_idx_type i = 0; i < nr - 1; i++)
 		{
 		  D[i+1] = 0.;
 		  DL[i] = 0.;
 		}
 
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
-		      D[j] = data(i);
+		      D[j] = std::real (data(i));
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		  }
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols();
 	  rcond = 1.;
@@ -3330,17 +3402,17 @@ SparseComplexMatrix::trisolve (SparseTyp
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  octave_idx_type b_nr = b.rows();
 	  octave_idx_type b_nc = b.cols();
 	  rcond = 1.;
 
 	  retval = ComplexMatrix (b);
@@ -3430,17 +3502,17 @@ SparseComplexMatrix::trisolve (SparseTyp
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgttrf");
@@ -4452,78 +4524,79 @@ SparseComplexMatrix::factorize (octave_i
   // The return values
   void *Numeric;
   err = 0;
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
-  umfpack_zi_defaults (control);
+  UMFPACK_ZNAME (defaults) (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   tmp = Voctave_sparse_controls.get_key ("piv_tol");
   if (!xisnan (tmp))
     {
       Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
       Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = Voctave_sparse_controls.get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
-  umfpack_zi_report_control (control);
+  UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  umfpack_zi_report_matrix (nr, nc, Ap, Ai, X_CAST (const double *, Ax), 
-			    NULL, 1, control);
+  UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
+			    X_CAST (const double *, Ax), NULL, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = umfpack_zi_qsymbolic (nr, nc, Ap, Ai, 
+  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
 				     X_CAST (const double *, Ax), 
 				     NULL, NULL, &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	("SparseComplexMatrix::solve symbolic factorization failed");
       err = -1;
 
-      umfpack_zi_report_status (control, status);
-      umfpack_zi_report_info (control, info);
-
-      umfpack_zi_free_symbolic (&Symbolic) ;
+      UMFPACK_ZNAME (report_status) (control, status);
+      UMFPACK_ZNAME (report_info) (control, info);
+
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
-      umfpack_zi_report_symbolic (Symbolic, control);
-
-      status = umfpack_zi_numeric (Ap, Ai, X_CAST (const double *, Ax), NULL,
+      UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
+
+      status = UMFPACK_ZNAME (numeric) (Ap, Ai,
+				   X_CAST (const double *, Ax), NULL, 
 				   Symbolic, &Numeric, control, info) ;
-      umfpack_zi_free_symbolic (&Symbolic) ;
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
 #ifdef HAVE_LSSOLVE
       rcond = Info (UMFPACK_RCOND);
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix || 
 	  rcond_plus_one == 1.0 || xisnan (rcond))
 	{
-	  umfpack_zi_report_numeric (Numeric, control);
+	  UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
 	  err = -2;
 
 	  if (sing_handler)
 	    sing_handler (rcond);
 	  else
 	    (*current_liboctave_error_handler)
 	      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
@@ -4532,29 +4605,29 @@ SparseComplexMatrix::factorize (octave_i
 	}
       else
 #endif 
 	if (status < 0)
 	  {
 	    (*current_liboctave_error_handler) 
 	      ("SparseComplexMatrix::solve numeric factorization failed");
 
-	    umfpack_zi_report_status (control, status);
-	    umfpack_zi_report_info (control, info);
+	    UMFPACK_ZNAME (report_status) (control, status);
+	    UMFPACK_ZNAME (report_info) (control, info);
 	      
 	    err = -1;
 	  }
 	else
 	  {
-	    umfpack_zi_report_numeric (Numeric, control);
+	    UMFPACK_ZNAME (report_numeric) (Numeric, control);
 	  }
     }
 
   if (err != 0)
-    umfpack_zi_free_numeric (&Numeric);
+    UMFPACK_ZNAME (free_numeric) (&Numeric);
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 ComplexMatrix
@@ -4615,43 +4688,43 @@ SparseComplexMatrix::fsolve (SparseType 
 	      OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
 	      retval.resize (b_nr, b_nc);
 	      Complex *Xx = retval.fortran_vec ();
 
 	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 #ifdef UMFPACK_SEPARATE_SPLIT
-		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
-					     X_CAST (const double *, Ax), 
+		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+					     Ai, X_CAST (const double *, Ax), 
 					     NULL,
 					     X_CAST (double *, &Xx[iidx]), 
 					     NULL,
 					     &Bx[iidx], Bz, Numeric, 
 					     control, info);
 #else
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
-		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
-					     X_CAST (const double *, Ax), 
+		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+					     Ai, X_CAST (const double *, Ax), 
 					     NULL,
 					     X_CAST (double *, &Xx[iidx]), 
 					     NULL,
 					     X_CAST (const double *, Bz),
 					     NULL, Numeric, 
 					     control, info);
 #endif
 
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
-		      umfpack_zi_report_status (control, status);
+		      UMFPACK_ZNAME (report_status) (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 		}
 
 #ifndef HAVE_LSSOLVE
@@ -4668,19 +4741,19 @@ SparseComplexMatrix::fsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 
 		}
 #endif
 
-	      umfpack_zi_report_info (control, info);
-
-	      umfpack_zi_free_numeric (&Numeric);
+	      UMFPACK_ZNAME (report_info) (control, info);
+
+	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4757,40 +4830,40 @@ SparseComplexMatrix::fsolve (SparseType 
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 
 #ifdef UMFPACK_SEPARATE_SPLIT
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b.elem (i, j);
 
-		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
-					     X_CAST (const double *, Ax),
+		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+					     Ai, X_CAST (const double *, Ax),
 					     NULL,
 					     X_CAST (double *, Xx), NULL, 
 					     Bx, Bz, Numeric, control, 
 					     info);
 #else
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
-		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
+		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
 					     X_CAST (const double *, Ax),
 					     NULL,
 					     X_CAST (double *, Xx), NULL, 
 					     X_CAST (double *, Bz), NULL,
 					     Numeric, control, 
 					     info);
 #endif
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
-		      umfpack_zi_report_status (control, status);
+		      UMFPACK_ZNAME (report_status) (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
@@ -4828,19 +4901,19 @@ SparseComplexMatrix::fsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 
 		}
 #endif
 
-	      umfpack_zi_report_info (control, info);
-
-	      umfpack_zi_free_numeric (&Numeric);
+	      UMFPACK_ZNAME (report_info) (control, info);
+
+	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4899,28 +4972,28 @@ SparseComplexMatrix::fsolve (SparseType 
 	      const Complex *Bx = b.fortran_vec ();
 
 	      retval.resize (b_nr, b_nc);
 	      Complex *Xx = retval.fortran_vec ();
 	      
 	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 		  status = 
-		    umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
+		    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
 				      X_CAST (const double *, Ax), 
 				      NULL, X_CAST (double *, &Xx[iidx]), 
 				      NULL, X_CAST (const double *, &Bx[iidx]), 
 				      NULL, Numeric, control, info);
 		  
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
-		      umfpack_zi_report_status (control, status);
+		      UMFPACK_ZNAME (report_status) (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 		}
 
 #ifndef HAVE_LSSOLVE
@@ -4937,19 +5010,19 @@ SparseComplexMatrix::fsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 
 		}
 #endif
 
-	      umfpack_zi_report_info (control, info);
-
-	      umfpack_zi_free_numeric (&Numeric);
+	      UMFPACK_ZNAME (report_info) (control, info);
+
+	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -5017,28 +5090,28 @@ SparseComplexMatrix::fsolve (SparseType 
 	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b (i,j);
 
-		  status = umfpack_zi_solve (UMFPACK_A, Ap, Ai, 
-					     X_CAST (const double *, Ax), 
+		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
+					     Ai, X_CAST (const double *, Ax), 
 					     NULL, X_CAST (double *, Xx), 
 					     NULL, X_CAST (double *, Bx), 
 					     NULL, Numeric, control, info);
 		  
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
-		      umfpack_zi_report_status (control, status);
+		      UMFPACK_ZNAME (report_status) (control, status);
 		  
 		      err = -1;
 
 		      break;
 		    }
 
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
@@ -5076,19 +5149,19 @@ SparseComplexMatrix::fsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 
 		}
 #endif
 
-	      umfpack_zi_report_info (control, info);
-
-	      umfpack_zi_free_numeric (&Numeric);
+	      UMFPACK_ZNAME (report_info) (control, info);
+
+	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -5119,17 +5192,17 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 			    double& rcond, 
 			    solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
@@ -5173,17 +5246,17 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
 			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
@@ -5227,17 +5300,17 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
@@ -5282,17 +5355,17 @@ SparseComplexMatrix::solve (SparseType &
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
 			    octave_idx_type& err, double& rcond,
 			    solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -418,15 +418,21 @@ SPARSE_SMS_BOOL_OP_DECLS (SparseComplexM
 SPARSE_SSM_CMP_OP_DECLS (Complex, SparseComplexMatrix)
 SPARSE_SSM_BOOL_OP_DECLS (Complex, SparseComplexMatrix)
 
 SPARSE_SMSM_CMP_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix)
 SPARSE_SMSM_BOOL_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix)
 
 SPARSE_FORWARD_DEFS (MSparse, SparseComplexMatrix, ComplexMatrix, Complex)
 
+#ifdef UMFPACK_LONG_IDX
+#define UMFPACK_ZNAME(name) umfpack_zl_ ## name
+#else
+#define UMFPACK_ZNAME(name) umfpack_zi_ ## name
+#endif
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,48 @@
+2005-04-29  David Bateman  <dbateman@free.fr>
+
+	* dSparse.cc (trisolve): Diagonal passed to lapack zptsv is type double.
+	Correct indexing for upper diagonal elements for sparse tridiagonal.
+	* CSparse.cc (trisolve): ditto.
+
+	* CSparse.h (UMFPACK_ZNAME): Define macro to pick version of UMFPACK for
+	64-bit.
+	* CSparse.cc (UMFPACK_ZNAME): Replace all umfpack_zi_* with 
+	UMFPACK_ZNAME(*).
+	* SparseCmplxLU.cc (UMFPACK_ZNAME): ditto
+
+	* dSparse.h (UMFPACK_DNAME): Define macro to pick version of UMFPACK for
+	64-bit.
+	* dSparse.cc (UMFPACK_DNAME): Replace all umfpack_di_* with 
+	UMFPACK_DNAME(*).
+	* SparsedbleLU.cc (UMFPACK_DNAME): ditto
+
+	* dSparse.cc (ltsolve, utsolve): Correct permuted upper/lower triangular
+	back/forward substitution code.
+	* CSparse.cc (ltsolve, utsolve): ditto.
+
+	* dSparse.cc (solve): Use mattype.type (false) to force messaging from
+	spparms("spumoni",1).
+	* CSparse.cc (solve): ditto
+
+	* SparseType.cc (SparseType(void)): Print info for spparms("spumoni",1).
+	(SparseType(const matrix_type), SparseType(const matrix_type, const
+	octave_idx_type, const octave_idx_type*), SparseType(const matrix_type,
+	const octave_idx_type, const octave_idx_type)): New constructors.
+	(SparseType (const SparseMatrix&), SparseType (SparseComplexMatrix&)):
+	Detect row permuted lower triangular and column permuted upper triangular
+	matrices. Remove one of the permutation vectors..
+
+	* SparseType.h: Simplify the permutation code.
+	(SparseType(const matrix_type), SparseType
+	(const matrix_type, const octave_idx_type, const octave_idx_type*), 
+	SparseType(const matrix_type, const octave_idx_type, 
+	const octave_idx_type)): Declarations.
+	
 2005-04-25  John W. Eaton  <jwe@octave.org>
 
 	* str-vec.cc (string_vector::delete_c_str_vec): Correctly free
 	array and its contents.
 
 2005-04-22  John W. Eaton  <jwe@octave.org>
 
 	* oct-rl-edit.c (octave_rl_set_terminal_name): Don't cast away
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -50,17 +50,17 @@ SparseComplexLU::SparseComplexLU (const 
 {
 #ifdef HAVE_UMFPACK
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
-  umfpack_zi_defaults (control);
+  UMFPACK_ZNAME (defaults) (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   if (piv_thres >= 0.)
     {
       piv_thres = (piv_thres > 1. ? 1. : piv_thres);
       Control (UMFPACK_SYM_PIVOT_TOLERANCE) = piv_thres;
@@ -79,146 +79,146 @@ SparseComplexLU::SparseComplexLU (const 
   // Set whether we are allowed to modify Q or not
   tmp = Voctave_sparse_controls.get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU 
   Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
-  umfpack_zi_report_control (control);
+  UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = a.cidx ();
   const octave_idx_type *Ai = a.ridx ();
   const Complex *Ax = a.data ();
 
-  umfpack_zi_report_matrix (nr, nc, Ap, Ai, X_CAST (const double *, Ax), 
-			    NULL, 1, control);
+  UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
+			    X_CAST (const double *, Ax), NULL, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = umfpack_zi_qsymbolic (nr, nc, Ap, Ai, 
+  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
 				     X_CAST (const double *, Ax), NULL, NULL,
 				     &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
-      umfpack_zi_report_status (control, status);
-      umfpack_zi_report_info (control, info);
+      UMFPACK_ZNAME (report_status) (control, status);
+      UMFPACK_ZNAME (report_info) (control, info);
 
-      umfpack_zi_free_symbolic (&Symbolic) ;
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
-      umfpack_zi_report_symbolic (Symbolic, control);
+      UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
-      status = umfpack_zi_numeric (Ap, Ai, X_CAST (const double *, Ax), NULL,
+      status = UMFPACK_ZNAME (numeric) (Ap, Ai,
+				   X_CAST (const double *, Ax), NULL, 
 				   Symbolic, &Numeric, control, info) ;
-      umfpack_zi_free_symbolic (&Symbolic) ;
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
-	  umfpack_zi_report_status (control, status);
-	  umfpack_zi_report_info (control, info);
+	  UMFPACK_ZNAME (report_status) (control, status);
+	  UMFPACK_ZNAME (report_info) (control, info);
 
-	  umfpack_zi_free_numeric (&Numeric);
+	  UMFPACK_ZNAME (free_numeric) (&Numeric);
 	}
       else
 	{
-	  umfpack_zi_report_numeric (Numeric, control);
+	  UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
-	  int lnz, unz, ignore1, ignore2, ignore3;
-	  status = umfpack_zi_get_lunz (&lnz, &unz, &ignore1, &ignore2,
-					&ignore3, Numeric) ;
+	  octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+	  status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz, &ignore1,
+					&ignore2, &ignore3, Numeric) ;
 	  
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-	      umfpack_zi_report_status (control, status);
-	      umfpack_zi_report_info (control, info);
+	      UMFPACK_ZNAME (report_status) (control, status);
+	      UMFPACK_ZNAME (report_info) (control, info);
 
-	      umfpack_zi_free_numeric (&Numeric);
+	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
 	  else
 	    {
-	      int n_inner = (nr < nc ? nr : nc);
+	      octave_idx_type n_inner = (nr < nc ? nr : nc);
 
 	      if (lnz < 1)
-		Lfact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nr,
+		Lfact = SparseComplexMatrix (n_inner, nr,
 					     static_cast<octave_idx_type> (1));
 	      else
-		Lfact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nr,
-					     static_cast<octave_idx_type> (lnz));
+		Lfact = SparseComplexMatrix (n_inner, nr, lnz);
 
 	      octave_idx_type *Ltp = Lfact.cidx ();
 	      octave_idx_type *Ltj = Lfact.ridx ();
 	      Complex *Ltx = Lfact.data ();
 
 	      if (unz < 1)
-		Ufact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nc,
+		Ufact = SparseComplexMatrix (n_inner, nc,
 					     static_cast<octave_idx_type> (1));
 	      else
-		Ufact = SparseComplexMatrix (static_cast<octave_idx_type> (n_inner), nc, unz);
+		Ufact = SparseComplexMatrix (n_inner, nc, unz);
 
 	      octave_idx_type *Up = Ufact.cidx ();
 	      octave_idx_type *Uj = Ufact.ridx ();
 	      Complex *Ux = Ufact.data ();
 	      
 	      P.resize (nr);
-	      int *p = P.fortran_vec ();
+	      octave_idx_type *p = P.fortran_vec ();
 
 	      Q.resize (nc);
-	      int *q = Q.fortran_vec ();
+	      octave_idx_type *q = Q.fortran_vec ();
 
-	      int do_recip;
-	      status = umfpack_zi_get_numeric (Ltp, Ltj, X_CAST (double *, Ltx),
-					       NULL, Up, Uj,
+	      octave_idx_type do_recip;
+	      status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
+					       X_CAST (double *, Ltx), NULL, Up, Uj,
 					       X_CAST (double *, Ux), NULL, p, 
 					       q, NULL, NULL, &do_recip,
 					       NULL, Numeric) ;
 
-	      umfpack_zi_free_numeric (&Numeric) ;
+	      UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
 	      if (status < 0 || do_recip)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-		  umfpack_zi_report_status (control, status);
+		  UMFPACK_ZNAME (report_status) (control, status);
 		}
 	      else
 		{
 		  Lfact = Lfact.transpose ();
 
-		  umfpack_zi_report_matrix (nr, n_inner, Lfact.cidx (), 
-					    Lfact.ridx (), 
+		  UMFPACK_ZNAME (report_matrix) (nr, n_inner,
+					    Lfact.cidx (), Lfact.ridx (), 
 					    X_CAST (double *, Lfact.data()), 
 					    NULL, 1, control);
 
-		  umfpack_zi_report_matrix (n_inner, nc, Ufact.cidx (), 
-					    Ufact.ridx (), 
+		  UMFPACK_ZNAME (report_matrix) (n_inner, nc,
+					    Ufact.cidx (), Ufact.ridx (), 
 					    X_CAST (double *, Ufact.data()), 
 					    NULL, 1, control);
-		  umfpack_zi_report_perm (nr, p, control);
-		  umfpack_zi_report_perm (nc, q, control);
+		  UMFPACK_ZNAME (report_perm) (nr, p, control);
+		  UMFPACK_ZNAME (report_perm) (nc, q, control);
 		}
 
-	      umfpack_zi_report_info (control, info);
+	      UMFPACK_ZNAME (report_info) (control, info);
 	    }
 	}
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
 
@@ -234,17 +234,17 @@ SparseComplexLU::SparseComplexLU (const 
   else
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
-      umfpack_zi_defaults (control);
+      UMFPACK_ZNAME (defaults) (control);
 
       double tmp = Voctave_sparse_controls.get_key ("spumoni");
       if (!xisnan (tmp))
 	Control (UMFPACK_PRL) = tmp;
       if (piv_thres >= 0.)
 	{
 	  piv_thres = (piv_thres > 1. ? 1. : piv_thres);
 	  Control (UMFPACK_SYM_PIVOT_TOLERANCE) = piv_thres;
@@ -271,168 +271,164 @@ SparseComplexLU::SparseComplexLU (const 
 	  tmp = Voctave_sparse_controls.get_key ("autoamd");
 	  if (!xisnan (tmp))
 	    Control (UMFPACK_FIXQ) = tmp;
 	}
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
-      umfpack_zi_report_control (control);
+      UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const Complex *Ax = a.data ();
 
-      umfpack_zi_report_matrix (nr, nc, Ap, Ai, 
+      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
 				X_CAST (const double *, Ax), NULL,
 				1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
       // needed
       do {
-	OCTAVE_LOCAL_BUFFER (int, qinit, nc);
+	OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
-	for (int i = 0; i < nc; i++)
-	  qinit [i] = static_cast<int> (Qinit (i));
+	for (octave_idx_type i = 0; i < nc; i++)
+	  qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
-	status = umfpack_zi_qsymbolic (nr, nc, Ap, Ai, 
+	status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
 				       X_CAST (const double *, Ax),
 				       NULL, qinit, &Symbolic, control, 
 				       info);
       } while (0);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
-	  umfpack_zi_report_status (control, status);
-	  umfpack_zi_report_info (control, info);
+	  UMFPACK_ZNAME (report_status) (control, status);
+	  UMFPACK_ZNAME (report_info) (control, info);
 
-	  umfpack_zi_free_symbolic (&Symbolic) ;
+	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 	}
       else
 	{
-	  umfpack_zi_report_symbolic (Symbolic, control);
+	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
-	  status = umfpack_zi_numeric (Ap, Ai, 
+	  status = UMFPACK_ZNAME (numeric) (Ap, Ai, 
 				       X_CAST (const double *, Ax), NULL,
 				       Symbolic, &Numeric, control, info) ;
-	  umfpack_zi_free_symbolic (&Symbolic) ;
+	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
 	  cond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
-	      umfpack_zi_report_status (control, status);
-	      umfpack_zi_report_info (control, info);
+	      UMFPACK_ZNAME (report_status) (control, status);
+	      UMFPACK_ZNAME (report_info) (control, info);
 
-	      umfpack_zi_free_numeric (&Numeric);
+	      UMFPACK_ZNAME (free_numeric) (&Numeric);
 	    }
 	  else
 	    {
-	      umfpack_zi_report_numeric (Numeric, control);
+	      UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
-	      int lnz, unz, ignore1, ignore2, ignore3;
-	      status = umfpack_zi_get_lunz (&lnz, &unz, &ignore1, 
-					    &ignore2, &ignore3, Numeric);
+	      octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+	      status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz,
+					    &ignore1, &ignore2, &ignore3, Numeric);
 	  
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-		  umfpack_zi_report_status (control, status);
-		  umfpack_zi_report_info (control, info);
+		  UMFPACK_ZNAME (report_status) (control, status);
+		  UMFPACK_ZNAME (report_info) (control, info);
 
-		  umfpack_zi_free_numeric (&Numeric);
+		  UMFPACK_ZNAME (free_numeric) (&Numeric);
 		}
 	      else
 		{
-		  int n_inner = (nr < nc ? nr : nc);
+		  octave_idx_type n_inner = (nr < nc ? nr : nc);
 
 		  if (lnz < 1)
-		    Lfact = SparseComplexMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nr,
+		    Lfact = SparseComplexMatrix (n_inner, nr,
 		       static_cast<octave_idx_type> (1));
 		  else
-		    Lfact = SparseComplexMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nr,
-		       static_cast<octave_idx_type> (lnz));
+		    Lfact = SparseComplexMatrix (n_inner, nr, lnz);
 
 		  octave_idx_type *Ltp = Lfact.cidx ();
 		  octave_idx_type *Ltj = Lfact.ridx ();
 		  Complex *Ltx = Lfact.data ();
 
 		  if (unz < 1)
-		    Ufact = SparseComplexMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nc,
+		    Ufact = SparseComplexMatrix (n_inner, nc,
 		       static_cast<octave_idx_type> (1));
 		  else
-		    Ufact = SparseComplexMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nc, unz);
+		    Ufact = SparseComplexMatrix  (n_inner, nc, unz);
 
 		  octave_idx_type *Up = Ufact.cidx ();
 		  octave_idx_type *Uj = Ufact.ridx ();
 		  Complex *Ux = Ufact.data ();
 	      
 		  P.resize (nr);
-		  int *p = P.fortran_vec ();
+		  octave_idx_type *p = P.fortran_vec ();
 
 		  Q.resize (nc);
-		  int *q = Q.fortran_vec ();
+		  octave_idx_type *q = Q.fortran_vec ();
 
-		  int do_recip;
+		  octave_idx_type do_recip;
 		  status = 
-		    umfpack_zi_get_numeric (Ltp, Ltj, 
+		    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
 					    X_CAST (double *, Ltx),
 					    NULL, Up, Uj,
 					    X_CAST (double *, Ux), 
 					    NULL, p, q, NULL, NULL, 
 					    &do_recip, NULL, Numeric) ;
 
-		  umfpack_zi_free_numeric (&Numeric) ;
+		  UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
 		  if (status < 0 || do_recip)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
-		      umfpack_zi_report_status (control, status);
+		      UMFPACK_ZNAME (report_status) (control, 
+								     status);
 		    }
 		  else
 		    {
 		      Lfact = Lfact.transpose ();
 
-		      umfpack_zi_report_matrix (nr, n_inner, 
+		      UMFPACK_ZNAME (report_matrix) (nr, n_inner, 
 						Lfact.cidx (), 
 						Lfact.ridx (), 
 						X_CAST (double *, Lfact.data()), 
 						NULL, 1, control);
 
-		      umfpack_zi_report_matrix (n_inner, nc, 
+		      UMFPACK_ZNAME (report_matrix) (n_inner, nc, 
 						Ufact.cidx (), 
 						Ufact.ridx (), 
 						X_CAST (double *, Ufact.data()), 
 						NULL, 1, control);
-		      umfpack_zi_report_perm (nr, p, control);
-		      umfpack_zi_report_perm (nc, q, control);
+		      UMFPACK_ZNAME (report_perm) (nr, p, control);
+		      UMFPACK_ZNAME (report_perm) (nc, q, control);
 		    }
 
-		  umfpack_zi_report_info (control, info);
+		  UMFPACK_ZNAME (report_info) (control, info);
 		}
 	    }
 	}
 
       if (udiag)
 	(*current_liboctave_error_handler) 
 	  ("Option udiag of incomplete LU not implemented");   
     }
diff --git a/liboctave/SparseType.cc b/liboctave/SparseType.cc
--- a/liboctave/SparseType.cc
+++ b/liboctave/SparseType.cc
@@ -19,46 +19,53 @@ Free Software Foundation, Inc., 51 Frank
 Boston, MA 02110-1301, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <vector>
+
 #include "SparseType.h"
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-spparms.h"
 
 // XXX FIXME XXX There is a large code duplication here
 
+SparseType::SparseType (void) : typ (SparseType::Unknown), nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+} 
+
 SparseType::SparseType (const SparseType &a) : typ (a.typ), 
     sp_bandden (a.sp_bandden), bandden (a.bandden), 
     upper_band (a.upper_band), lower_band (a.lower_band), 
     dense (a.dense), nperm (a.nperm)
 { 
   if (nperm != 0)
     {
-      row_perm = new octave_idx_type [nperm];
-      col_perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	{
-	  row_perm[i] = a.row_perm[i];
-	  col_perm[i] = a.col_perm[i];
-	}
+	perm[i] = a.perm[i];
     }
 }
 
 SparseType::SparseType (const SparseMatrix &a)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
   octave_idx_type nnz = a.nnz ();
 
+  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+    (*current_liboctave_warning_handler) 
+      ("Calculating Sparse Matrix Type");
+
   nperm = 0;
 
   if (nrows != ncols)
     typ = SparseType::Rectangular;
   else
     {
       sp_bandden = Voctave_sparse_controls.get_key ("bandden");
       bool maybe_hermitian = false;
@@ -172,18 +179,86 @@ SparseType::SparseType (const SparseMatr
 		maybe_hermitian = true;
 	    }
 
 	  if (typ == Full)
 	    {
 	      // Search for a permuted triangular matrix, and test if
 	      // permutation is singular
 
-	      // XXX FIXME XXX Write this test based on dmperm
-	      
+	      // XXX FIXME XXX Perhaps this should be based on a dmperm algorithm
+	      bool found = false;
+
+	      nperm = nrows;
+	      perm = new octave_idx_type [nperm];
+
+	      for (octave_idx_type i = 0; i < nperm; i++)
+		{
+		  found = false;
+
+		  for (octave_idx_type j = 0; j < ncols; j++)
+		    {
+
+		      if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+			  a.ridx(a.cidx(j+1)-1) == i)
+			{
+			  perm [i] = j;
+			  found = true;
+			  break;
+			}
+		    }
+
+		  if (!found)
+		    break;
+		}
+
+	      if (found)
+		typ = SparseType::Permuted_Upper;
+	      else
+		{
+		  OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
+
+		  for (octave_idx_type i = 0; i < nperm; i++)
+		    {
+		      perm [i] = -1;
+		      tmp [i] = -1;
+		    }
+
+		  for (octave_idx_type j = 0; j < ncols; j++)
+		    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		      perm [a.ridx(i)] = j;
+  
+		  found = true;
+		  for (octave_idx_type i = 0; i < nperm; i++)
+		    if (perm[i] == -1)
+		      {
+			found = false;
+			break;
+		      }
+		    else
+		      {
+			tmp[perm[i]] = 1;
+		      }
+
+		  if (found)
+		    for (octave_idx_type i = 0; i < nperm; i++)
+		      if (tmp[i] == -1)
+			{
+			  found = false;
+			  break;
+			}
+
+		  if (found)
+		    typ = SparseType::Permuted_Lower;
+		  else
+		    {
+		      delete [] perm;
+		      nperm = 0;
+		    }
+		}
 	    }
 	}
 
       if (maybe_hermitian && (typ == Full || typ == Tridiagonal || 
 			      typ == Banded))
 	{
 	  // Check for symmetry, with positive real diagonal, which
 	  // has a very good chance of being symmetric positive
@@ -248,16 +323,20 @@ SparseType::SparseType (const SparseMatr
 }
 
 SparseType::SparseType (const SparseComplexMatrix &a)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
   octave_idx_type nnz = a.nnz ();
 
+  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
+    (*current_liboctave_warning_handler) 
+      ("Calculating Sparse Matrix Type");
+
   nperm = 0;
 
   if (nrows != ncols)
     typ = SparseType::Rectangular;
   else
     {
       sp_bandden = Voctave_sparse_controls.get_key ("bandden");
       bool maybe_hermitian = false;
@@ -371,18 +450,86 @@ SparseType::SparseType (const SparseComp
 		maybe_hermitian = true;
 	    }
 
 	  if (typ == Full)
 	    {
 	      // Search for a permuted triangular matrix, and test if
 	      // permutation is singular
 
-	      // XXX FIXME XXX Write this test based on dmperm
-	      
+	      // XXX FIXME XXX Perhaps this should be based on a dmperm algorithm
+	      bool found = false;
+
+	      nperm = nrows;
+	      perm = new octave_idx_type [nperm];
+
+	      for (octave_idx_type i = 0; i < nperm; i++)
+		{
+		  found = false;
+
+		  for (octave_idx_type j = 0; j < ncols; j++)
+		    {
+
+		      if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+			  a.ridx(a.cidx(j+1)-1) == i)
+			{
+			  perm [i] = j;
+			  found = true;
+			  break;
+			}
+		    }
+
+		  if (!found)
+		    break;
+		}
+
+	      if (found)
+		typ = SparseType::Permuted_Upper;
+	      else
+		{
+		  OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
+
+		  for (octave_idx_type i = 0; i < nperm; i++)
+		    {
+		      perm [i] = -1;
+		      tmp [i] = -1;
+		    }
+
+		  for (octave_idx_type j = 0; j < ncols; j++)
+		    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		      perm [a.ridx(i)] = j;
+  
+		  found = true;
+		  for (octave_idx_type i = 0; i < nperm; i++)
+		    if (perm[i] == -1)
+		      {
+			found = false;
+			break;
+		      }
+		    else
+		      {
+			tmp[perm[i]] = 1;
+		      }
+
+		  if (found)
+		    for (octave_idx_type i = 0; i < nperm; i++)
+		      if (tmp[i] == -1)
+			{
+			  found = false;
+			  break;
+			}
+
+		  if (found)
+		    typ = SparseType::Permuted_Lower;
+		  else
+		    {
+		      delete [] perm;
+		      nperm = 0;
+		    }
+		}
 	    }
 	}
 
       if (maybe_hermitian && (typ == Full || typ == Tridiagonal || 
 			      typ == Banded))
 	{
 	  // Check for symmetry, with positive real diagonal, which
 	  // has a very good chance of being symmetric positive
@@ -441,22 +588,69 @@ SparseType::SparseType (const SparseComp
 		typ = Banded_Hermitian;
 	      else
 		typ = Tridiagonal_Hermitian;
 	    }
 	}
     }
 }
 
+SparseType::SparseType (const matrix_type t) : typ (SparseType::Unknown), 
+					       nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+
+  if (t == SparseType::Full || t == SparseType::Diagonal ||
+      t == SparseType::Permuted_Diagonal || t == SparseType::Upper ||
+      t == SparseType::Lower || t == SparseType::Tridiagonal ||
+      t == SparseType::Tridiagonal_Hermitian || t == SparseType::Rectangular)
+    typ = t;
+  else
+    (*current_liboctave_warning_handler) ("Invalid sparse matrix type");
+}
+
+SparseType::SparseType (const matrix_type t, const octave_idx_type np,
+			const octave_idx_type *p) : typ (SparseType::Unknown), 
+					       nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+
+  if (t == SparseType::Permuted_Upper || t == SparseType::Permuted_Lower)
+    {
+      typ = t;
+      nperm = np;
+      perm = new octave_idx_type [nperm];
+      for (octave_idx_type i = 0; i < nperm; i++)
+	perm[i] = p[i];
+    }
+  else
+    (*current_liboctave_warning_handler) ("Invalid sparse matrix type");
+}
+
+SparseType::SparseType (const matrix_type t, const octave_idx_type ku,
+			const octave_idx_type kl) : typ (SparseType::Unknown), 
+					       nperm (0)
+{
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+
+  if (t == SparseType::Banded || t == SparseType::Banded_Hermitian)
+    {
+      typ = t;
+      upper_band = ku;
+      lower_band = kl;
+    }
+  else
+    (*current_liboctave_warning_handler) ("Invalid sparse matrix type"); 
+}
+
 SparseType::~SparseType (void) 
 { 
   if (nperm != 0)
     {
-      delete [] row_perm; 
-      delete [] col_perm; 
+      delete [] perm; 
     }
 }
 
 SparseType& 
 SparseType::operator = (const SparseType& a)
 {
   if (this != &a)
     {
@@ -465,65 +659,76 @@ SparseType::operator = (const SparseType
       bandden = a.bandden;
       upper_band = a.upper_band;
       lower_band = a.lower_band;
       dense = a.dense;
       nperm = a.nperm;
 
       if (nperm != 0)
 	{
-	  row_perm = new octave_idx_type [nperm];
-	  col_perm = new octave_idx_type [nperm];
+	  perm = new octave_idx_type [nperm];
 	  for (octave_idx_type i = 0; i < nperm; i++)
-	    {
-	      row_perm[i] = a.row_perm[i];
-	      col_perm[i] = a.col_perm[i];
-	    }
+	    perm[i] = a.perm[i];
+	}
     }
 
+  return *this;
+}
+
+int
+SparseType::type (bool quiet)
+{
+  if (typ != SparseType::Unknown && 
+      sp_bandden == Voctave_sparse_controls.get_key ("bandden"))
+    {
+      if (!quiet &&
+	  Voctave_sparse_controls.get_key ("spumoni") != 0.)
+  	(*current_liboctave_warning_handler) 
+  	  ("Using Cached Sparse Matrix Type");
+      
+      return typ;
     }
-  return *this;
+
+  if (typ != SparseType::Unknown && 
+      Voctave_sparse_controls.get_key ("spumoni") != 0.)
+    (*current_liboctave_warning_handler) 
+      ("Invalidating Sparse Matrix Type");
+
+  typ = SparseType::Unknown;
+
+  return typ;
 }
 
 int
 SparseType::type (const SparseMatrix &a)
 {
   if (typ != SparseType::Unknown && 
       sp_bandden == Voctave_sparse_controls.get_key ("bandden"))
     {
       if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
   	(*current_liboctave_warning_handler) 
   	  ("Using Cached Sparse Matrix Type");
       
       return typ;
     }
 
-  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
-      ("Calculating Sparse Matrix Type");
-
-
   SparseType tmp_typ (a);
   typ = tmp_typ.typ;
   sp_bandden = tmp_typ.sp_bandden;
   bandden = tmp_typ.bandden;
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      row_perm = new octave_idx_type [nperm];
-      col_perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	{
-	  row_perm[i] = tmp_typ.row_perm[i];
-	  col_perm[i] = tmp_typ.col_perm[i];
-	}
+	perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
 SparseType::type (const SparseComplexMatrix &a)
 {
@@ -532,39 +737,30 @@ SparseType::type (const SparseComplexMat
     {
       if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
   	(*current_liboctave_warning_handler) 
   	  ("Using Cached Sparse Matrix Type");
       
       return typ;
     }
 
-  if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
-      ("Calculating Sparse Matrix Type");
-
-
   SparseType tmp_typ (a);
   typ = tmp_typ.typ;
   sp_bandden = tmp_typ.sp_bandden;
   bandden = tmp_typ.bandden;
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      row_perm = new octave_idx_type [nperm];
-      col_perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
-	{
-	  row_perm[i] = tmp_typ.row_perm[i];
-	  col_perm[i] = tmp_typ.col_perm[i];
-	}
+	perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 void
 SparseType::info (void) const
 {
@@ -588,21 +784,21 @@ SparseType::info (void) const
       else if (typ == SparseType::Permuted_Upper)
 	(*current_liboctave_warning_handler) 
 	  ("Permuted Upper Triangular Sparse Matrix");
       else if (typ == SparseType::Permuted_Lower)
 	(*current_liboctave_warning_handler) 
 	  ("Permuted Lower Triangular Sparse Matrix");
       else if (typ == SparseType::Banded)
 	(*current_liboctave_warning_handler) 
-	  ("Banded Sparse Matrix %g-1-%g (Density %g)", lower_band, 
+	  ("Banded Sparse Matrix %d-1-%d (Density %f)", lower_band, 
 	   upper_band, bandden);
       else if (typ == SparseType::Banded_Hermitian)
 	(*current_liboctave_warning_handler) 
-	  ("Banded Hermitian/Symmetric Sparse Matrix %g-1-%g (Density %g)", 
+	  ("Banded Hermitian/Symmetric Sparse Matrix %d-1-%d (Density %f)", 
 	   lower_band, upper_band, bandden);
       else if (typ == SparseType::Hermitian)
 	(*current_liboctave_warning_handler) 
 	  ("Hermitian/Symmetric Sparse Matrix");
       else if (typ == SparseType::Tridiagonal)
 	(*current_liboctave_warning_handler) 
 	  ("Tridiagonal Sparse Matrix");
       else if (typ == SparseType::Tridiagonal_Hermitian)
@@ -644,26 +840,22 @@ SparseType::mark_as_unsymmetric (void)
 	   typ == SparseType::Banded_Hermitian)
     typ = SparseType::Banded;
   else if (typ == SparseType::Full || typ == SparseType::Hermitian || 
 	   typ == SparseType::Unknown)
     typ = SparseType::Full;
 }
 
 void
-SparseType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *pr, const octave_idx_type *pc)
+SparseType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
 {
   nperm = np;
-  row_perm = new octave_idx_type [nperm];
-  col_perm = new octave_idx_type [nperm];
+  perm = new octave_idx_type [nperm];
   for (octave_idx_type i = 0; i < nperm; i++)
-    {
-      row_perm[i] = pr[i];
-      col_perm[i] = pc[i];
-    }
+    perm[i] = p[i];
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     typ = SparseType::Permuted_Diagonal;
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     typ = SparseType::Permuted_Upper;
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
     typ = SparseType::Permuted_Lower;
   else
@@ -672,50 +864,39 @@ SparseType::mark_as_permuted (const octa
 }
 
 void
 SparseType::mark_as_unpermuted (void)
 {
   if (nperm)
     {
       nperm = 0;
-      delete [] row_perm;
-      delete [] col_perm;
+      delete [] perm;
     }
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     typ = SparseType::Diagonal;
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     typ = SparseType::Upper;
   else if (typ == SparseType::Lower || typ == SparseType::Permuted_Lower)
     typ = SparseType::Lower;
 }
 
 SparseType
 SparseType::transpose (void) const
 {
   SparseType retval (*this);
   if (typ == SparseType::Upper)
-    retval.typ = Lower;
+    retval.typ = SparseType::Lower;
   else if (typ == SparseType::Permuted_Upper)
-    {
-      octave_idx_type *tmp = retval.row_perm;
-      retval.row_perm = retval.col_perm;
-      retval.col_perm = tmp;
-      retval.typ = Lower;
-    }
+    retval.typ = SparseType::Permuted_Lower;
   else if (typ == SparseType::Lower)
     retval.typ = Upper;
-  else if (typ == SparseType::Permuted_Upper)
-    {
-      octave_idx_type *tmp = retval.row_perm;
-      retval.row_perm = retval.col_perm;
-      retval.col_perm = tmp;
-      retval.typ = Upper;
-    }
+  else if (typ == SparseType::Permuted_Lower)
+    retval.typ = Permuted_Upper;
   else if (typ == SparseType::Banded)
     {
       retval.upper_band = lower_band;
       retval.lower_band = upper_band;
     }
 
   return retval;
 }
diff --git a/liboctave/SparseType.h b/liboctave/SparseType.h
--- a/liboctave/SparseType.h
+++ b/liboctave/SparseType.h
@@ -42,29 +42,37 @@ public:
     Banded,
     Hermitian,
     Banded_Hermitian,
     Tridiagonal,
     Tridiagonal_Hermitian,
     Rectangular
   };
 
-  SparseType (void) : typ (Unknown), nperm (0) { }
+  SparseType (void);
     
   SparseType (const SparseType &a);
 
   SparseType (const SparseMatrix &a);
 
   SparseType (const SparseComplexMatrix &a);
 
+  SparseType (const matrix_type t);
+
+  SparseType (const matrix_type t, const octave_idx_type np,
+	      const octave_idx_type *p);
+
+  SparseType (const matrix_type t, const octave_idx_type ku, 
+	      const octave_idx_type kl);
+
   ~SparseType (void);
 
   SparseType& operator = (const SparseType& a);
 
-  int type (void) const { return typ; }
+  int type (bool quiet = true);
 
   int type (const SparseMatrix &a);
 
   int type (const SparseComplexMatrix &a);
 
   double band_density (void) const { return bandden; }
 
   int nupper (void) const { return upper_band; }
@@ -95,24 +103,24 @@ public:
   bool is_rectangular (void) const { return (typ == Rectangular); }
 
   bool is_known (void) const { return (typ != Unknown); }
 
   bool is_unknown (void) const { return (typ == Unknown); }
 
   void info (void) const;
 
-  octave_idx_type * triangular_row_perm (void) const { return row_perm; }
+  octave_idx_type * triangular_perm (void) const { return perm; }
 
-  octave_idx_type * triangular_col_perm (void) const { return col_perm; }
-
-  void invaldate_type (void) { typ = Unknown; }
+  void invalidate_type (void) { typ = Unknown; }
 
   void mark_as_diagonal (void) { typ = Diagonal; }
 
+  void mark_as_permuted_diagonal (void) { typ = Permuted_Diagonal; }
+
   void mark_as_upper_triangular (void) { typ = Upper; }
 
   void mark_as_lower_triangular (void) { typ = Lower; }
 
   void mark_as_tridiagonal (void) {typ = Tridiagonal; }
 
   void mark_as_banded (const octave_idx_type ku, const octave_idx_type kl)
     { typ = Banded; upper_band = ku; lower_band = kl; }
@@ -124,34 +132,33 @@ public:
   void mark_as_dense (void) { dense = true; }
 
   void mark_as_not_dense (void) { dense = false; }
 
   void mark_as_symmetric (void);
 
   void mark_as_unsymmetric (void);
 
-  void mark_as_permuted (const octave_idx_type np, const octave_idx_type *pr, const octave_idx_type *pc);
+  void mark_as_permuted (const octave_idx_type np, const octave_idx_type *p);
 
   void mark_as_unpermuted (void);
 
   SparseType transpose (void) const;
 
 private:
   void type (int new_typ) { typ = static_cast<matrix_type>(new_typ); }
 
   matrix_type typ;
   double sp_bandden;
   double bandden;
   octave_idx_type upper_band;
   octave_idx_type lower_band;
   bool dense;
   octave_idx_type nperm;
-  octave_idx_type *row_perm;
-  octave_idx_type *col_perm;
+  octave_idx_type *perm;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -49,17 +49,17 @@ SparseLU::SparseLU (const SparseMatrix& 
 {
 #ifdef HAVE_UMFPACK
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
-  umfpack_di_defaults (control);
+  UMFPACK_DNAME (defaults) (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
   if (piv_thres >= 0.)
     {
       piv_thres = (piv_thres > 1. ? 1. : piv_thres);
@@ -79,141 +79,139 @@ SparseLU::SparseLU (const SparseMatrix& 
   // Set whether we are allowed to modify Q or not
   tmp = Voctave_sparse_controls.get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU 
   Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
-  umfpack_di_report_control (control);
+  UMFPACK_DNAME (report_control) (control);
 
   const octave_idx_type *Ap = a.cidx ();
   const octave_idx_type *Ai = a.ridx ();
   const double *Ax = a.data ();
 
-  umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
+  UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = umfpack_di_qsymbolic (nr, nc, Ap, Ai, Ax, NULL,
+  int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, NULL,
 				     &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	    ("SparseLU::SparseLU symbolic factorization failed");
 
-      umfpack_di_report_status (control, status);
-      umfpack_di_report_info (control, info);
+      UMFPACK_DNAME (report_status) (control, status);
+      UMFPACK_DNAME (report_info) (control, info);
 
-      umfpack_di_free_symbolic (&Symbolic) ;
+      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
-      umfpack_di_report_symbolic (Symbolic, control);
+      UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
-      status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric,
-				   control, info) ;
-      umfpack_di_free_symbolic (&Symbolic) ;
+      status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, 
+				   &Numeric, control, info) ;
+      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseLU::SparseLU numeric factorization failed");
 
-	  umfpack_di_report_status (control, status);
-	  umfpack_di_report_info (control, info);
+	  UMFPACK_DNAME (report_status) (control, status);
+	  UMFPACK_DNAME (report_info) (control, info);
 
-	  umfpack_di_free_numeric (&Numeric);
+	  UMFPACK_DNAME (free_numeric) (&Numeric);
 	}
       else
 	{
-	  umfpack_di_report_numeric (Numeric, control);
+	  UMFPACK_DNAME (report_numeric) (Numeric, control);
 
-	  int lnz, unz, ignore1, ignore2, ignore3;
-	  status = umfpack_di_get_lunz (&lnz, &unz, &ignore1, &ignore2,
-					&ignore3, Numeric) ;
+	  octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+	  status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1,
+					&ignore2, &ignore3, Numeric) ;
 	  
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseLU::SparseLU extracting LU factors failed");
 
-	      umfpack_di_report_status (control, status);
-	      umfpack_di_report_info (control, info);
+	      UMFPACK_DNAME (report_status) (control, status);
+	      UMFPACK_DNAME (report_info) (control, info);
 
-	      umfpack_di_free_numeric (&Numeric);
+	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 	  else
 	    {
-	      int n_inner = (nr < nc ? nr : nc);
+	      octave_idx_type n_inner = (nr < nc ? nr : nc);
 
 	      if (lnz < 1)
-		Lfact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nr,
+		Lfact = SparseMatrix (n_inner, nr,
 				      static_cast<octave_idx_type> (1));
 	      else
-		Lfact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nr,
-				      static_cast<octave_idx_type> (lnz));
+		Lfact = SparseMatrix (n_inner, nr, lnz);
 
 	      octave_idx_type *Ltp = Lfact.cidx ();
 	      octave_idx_type *Ltj = Lfact.ridx ();
 	      double *Ltx = Lfact.data ();
 
 	      if (unz < 1)
-		Ufact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nc,
+		Ufact = SparseMatrix (n_inner, nc,
 				      static_cast<octave_idx_type> (1));
 	      else
-		Ufact = SparseMatrix (static_cast<octave_idx_type> (n_inner), nc,
-				      static_cast<octave_idx_type> (unz));
+		Ufact = SparseMatrix (n_inner, nc, unz);
 
 	      octave_idx_type *Up = Ufact.cidx ();
 	      octave_idx_type *Uj = Ufact.ridx ();
 	      double *Ux = Ufact.data ();
 
 	      P.resize (nr);
-	      int *p = P.fortran_vec ();
+	      octave_idx_type *p = P.fortran_vec ();
 
 	      Q.resize (nc);
-	      int *q = Q.fortran_vec ();
+	      octave_idx_type *q = Q.fortran_vec ();
 
-	      int do_recip;
-	      status = umfpack_di_get_numeric (Ltp, Ltj, Ltx, Up, Uj,
-					       Ux, p, q, (double *) NULL,
+	      octave_idx_type do_recip;
+	      status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
+					       Up, Uj, Ux, p, q, (double *) NULL,
 					       &do_recip, (double *) NULL, 
 					       Numeric) ;
 
-	      umfpack_di_free_numeric (&Numeric) ;
+	      UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
 	      if (status < 0 || do_recip)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseLU::SparseLU extracting LU factors failed");
 
-		  umfpack_di_report_status (control, status);
+		  UMFPACK_DNAME (report_status) (control, status);
 		}
 	      else
 		{
 		  Lfact = Lfact.transpose ();
 
-		  umfpack_di_report_matrix (nr, n_inner, Lfact.cidx (), 
-					    Lfact.ridx (), Lfact.data (),
-					    1, control);
-		  umfpack_di_report_matrix (n_inner, nc, Ufact.cidx (), 
-					    Ufact.ridx (), Ufact.data (),
-					    1, control);
-		  umfpack_di_report_perm (nr, p, control);
-		  umfpack_di_report_perm (nc, q, control);
+		  UMFPACK_DNAME (report_matrix) (nr, n_inner, 
+					    Lfact.cidx (), Lfact.ridx (),
+					    Lfact.data (), 1, control);
+		  UMFPACK_DNAME (report_matrix) (n_inner, nc, 
+					    Ufact.cidx (), Ufact.ridx (),
+					    Ufact.data (), 1, control);
+		  UMFPACK_DNAME (report_perm) (nr, p, control);
+		  UMFPACK_DNAME (report_perm) (nc, q, control);
 		}
 
-	      umfpack_di_report_info (control, info);
+	      UMFPACK_DNAME (report_info) (control, info);
 	    }
 	}
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
 
@@ -228,17 +226,17 @@ SparseLU::SparseLU (const SparseMatrix& 
   else
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
-      umfpack_di_defaults (control);
+      UMFPACK_DNAME (defaults) (control);
 
       double tmp = Voctave_sparse_controls.get_key ("spumoni");
       if (!xisnan (tmp))
 	Control (UMFPACK_PRL) = tmp;
       if (piv_thres >= 0.)
 	{
 	  piv_thres = (piv_thres > 1. ? 1. : piv_thres);
 	  Control (UMFPACK_SYM_PIVOT_TOLERANCE) = piv_thres;
@@ -266,160 +264,155 @@ SparseLU::SparseLU (const SparseMatrix& 
 	  tmp = Voctave_sparse_controls.get_key ("autoamd");
 	  if (!xisnan (tmp))
 	    Control (UMFPACK_FIXQ) = tmp;
 	}
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
-      umfpack_di_report_control (control);
+      UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const double *Ax = a.data ();
 
-      umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
+      UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, 
+						     control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not needed
       do {
-	OCTAVE_LOCAL_BUFFER (int, qinit, nc);
+	OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
-	for (int i = 0; i < nc; i++)
-	  qinit [i] = static_cast<int> (Qinit (i));
+	for (octave_idx_type i = 0; i < nc; i++)
+	  qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
-	status = umfpack_di_qsymbolic (nr, nc, Ap, Ai, Ax, qinit,
-				       &Symbolic, control, info);
+	status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 
+				       qinit, &Symbolic, control, info);
       } while (0);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseLU::SparseLU symbolic factorization failed");
 
-	  umfpack_di_report_status (control, status);
-	  umfpack_di_report_info (control, info);
+	  UMFPACK_DNAME (report_status) (control, status);
+	  UMFPACK_DNAME (report_info) (control, info);
 
-	  umfpack_di_free_symbolic (&Symbolic) ;
+	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 	}
       else
 	{
-	  umfpack_di_report_symbolic (Symbolic, control);
+	  UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
-	  status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric,
-				       control, info) ;
-	  umfpack_di_free_symbolic (&Symbolic) ;
+	  status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
+				       &Numeric, control, info) ;
+	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
 	  cond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseLU::SparseLU numeric factorization failed");
 
-	      umfpack_di_report_status (control, status);
-	      umfpack_di_report_info (control, info);
+	      UMFPACK_DNAME (report_status) (control, status);
+	      UMFPACK_DNAME (report_info) (control, info);
 
-	      umfpack_di_free_numeric (&Numeric);
+	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 	  else
 	    {
-	      umfpack_di_report_numeric (Numeric, control);
+	      UMFPACK_DNAME (report_numeric) (Numeric, control);
 
-	      int lnz, unz, ignore1, ignore2, ignore3;
-	      status = umfpack_di_get_lunz (&lnz, &unz, &ignore1, &ignore2,
-					    &ignore3, Numeric) ;
+	      octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
+	      status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1, &ignore2,
+						 &ignore3, Numeric) ;
 	  
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseLU::SparseLU extracting LU factors failed");
 
-		  umfpack_di_report_status (control, status);
-		  umfpack_di_report_info (control, info);
+		  UMFPACK_DNAME (report_status) (control, status);
+		  UMFPACK_DNAME (report_info) (control, info);
 
-		  umfpack_di_free_numeric (&Numeric);
+		  UMFPACK_DNAME (free_numeric) (&Numeric);
 		}
 	      else
 		{
-		  int n_inner = (nr < nc ? nr : nc);
+		  octave_idx_type n_inner = (nr < nc ? nr : nc);
 
 		  if (lnz < 1)
-		    Lfact = SparseMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nr,
-		       static_cast<octave_idx_type> (1));
+		    Lfact = SparseMatrix (n_inner, nr,
+					  static_cast<octave_idx_type> (1));
 		  else
-		    Lfact = SparseMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nr,
-		       static_cast<octave_idx_type> (lnz));
+		    Lfact = SparseMatrix (n_inner, nr, lnz);
 
 		  octave_idx_type *Ltp = Lfact.cidx ();
 		  octave_idx_type *Ltj = Lfact.ridx ();
 		  double *Ltx = Lfact.data ();
 
 		  if (unz < 1)
-		    Ufact = SparseMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nc,
-		       static_cast<octave_idx_type> (1));
+		    Ufact = SparseMatrix (n_inner, nc,
+					  static_cast<octave_idx_type> (1));
 		  else
-		    Ufact = SparseMatrix 
-		      (static_cast<octave_idx_type> (n_inner), nc,
-		       static_cast<octave_idx_type> (unz));
+		    Ufact = SparseMatrix (n_inner, nc, unz);
 
 		  octave_idx_type *Up = Ufact.cidx ();
 		  octave_idx_type *Uj = Ufact.ridx ();
 		  double *Ux = Ufact.data ();
 
 		  P.resize (nr);
-		  int *p = P.fortran_vec ();
+		  octave_idx_type *p = P.fortran_vec ();
 
 		  Q.resize (nc);
-		  int *q = Q.fortran_vec ();
+		  octave_idx_type *q = Q.fortran_vec ();
 
-		  int do_recip;
-		  status = umfpack_di_get_numeric (Ltp, Ltj, Ltx, Up, Uj,
-						   Ux, p, q, 
+		  octave_idx_type do_recip;
+		  status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
+						   Ltx, Up, Uj, Ux, p, q, 
 						   (double *) NULL,
 						   &do_recip, 
 						   (double *) NULL, 
 						   Numeric) ;
 
-		  umfpack_di_free_numeric (&Numeric) ;
+		  UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
 		  if (status < 0 || do_recip)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseLU::SparseLU extracting LU factors failed");
 
-		      umfpack_di_report_status (control, status);
+		      UMFPACK_DNAME (report_status) (control, status);
 		    }
 		  else
 		    {
 		      Lfact = Lfact.transpose ();
-		      umfpack_di_report_matrix (nr, n_inner, 
+		      UMFPACK_DNAME (report_matrix) (nr, n_inner, 
 						Lfact.cidx (), 
 						Lfact.ridx (), 
 						Lfact.data (),
 						1, control);
-		      umfpack_di_report_matrix (n_inner, nc, 
+		      UMFPACK_DNAME (report_matrix) (n_inner, nc, 
 						Ufact.cidx (), 
 						Ufact.ridx (), 
 						Ufact.data (),
 						1, control);
-		      umfpack_di_report_perm (nr, p, control);
-		      umfpack_di_report_perm (nc, q, control);
+		      UMFPACK_DNAME (report_perm) (nr, p, control);
+		      UMFPACK_DNAME (report_perm) (nc, q, control);
 		    }
 
-		  umfpack_di_report_info (control, info);
+		  UMFPACK_DNAME (report_info) (control, info);
 		}
 	    }
 	}
 
       if (udiag)
 	(*current_liboctave_error_handler) 
 	  ("Option udiag of incomplete LU not implemented");   
     }
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -101,17 +101,17 @@ extern "C"
   F77_RET_T
   F77_FUNC (dgttrs, DGTTRS) (F77_CONST_CHAR_ARG_DECL, const octave_idx_type&,
 			     const octave_idx_type&, const double*, const double*,
 			     const double*, const double*, const octave_idx_type*,
 			     double *, const octave_idx_type&, octave_idx_type&
 			     F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
+  F77_FUNC (zptsv, ZPTSV) (const octave_idx_type&, const octave_idx_type&, double*, Complex*,
 			   Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
 			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 
 }
 
@@ -730,17 +730,17 @@ SparseMatrix::determinant (octave_idx_ty
     }
   else
     {
       err = 0;
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
-      umfpack_di_defaults (control);
+      UMFPACK_DNAME (defaults) (control);
 
       double tmp = Voctave_sparse_controls.get_key ("spumoni");
       if (!xisnan (tmp))
 	Control (UMFPACK_PRL) = tmp;
 
       tmp = Voctave_sparse_controls.get_key ("piv_tol");
       if (!xisnan (tmp))
 	{
@@ -751,79 +751,79 @@ SparseMatrix::determinant (octave_idx_ty
       // Set whether we are allowed to modify Q or not
       tmp = Voctave_sparse_controls.get_key ("autoamd");
       if (!xisnan (tmp))
 	Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU 
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
-      umfpack_di_report_control (control);
+      UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const double *Ax = data ();
 
-      umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
+      UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = umfpack_di_qsymbolic (nr, nc, Ap, Ai, Ax, NULL,
-					 &Symbolic, control, info);
+      int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, 
+					 Ax, NULL, &Symbolic, control, info);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseMatrix::determinant symbolic factorization failed");
 
-	  umfpack_di_report_status (control, status);
-	  umfpack_di_report_info (control, info);
-
-	  umfpack_di_free_symbolic (&Symbolic) ;
+	  UMFPACK_DNAME (report_status) (control, status);
+	  UMFPACK_DNAME (report_info) (control, info);
+
+	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 	}
       else
 	{
-	  umfpack_di_report_symbolic (Symbolic, control);
+	  UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
-	  status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric,
-				       control, info) ;
-	  umfpack_di_free_symbolic (&Symbolic) ;
+	  status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, 
+				       &Numeric, control, info) ;
+	  UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
 	  rcond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseMatrix::determinant numeric factorization failed");
 
-	      umfpack_di_report_status (control, status);
-	      umfpack_di_report_info (control, info);
-
-	      umfpack_di_free_numeric (&Numeric);
+	      UMFPACK_DNAME (report_status) (control, status);
+	      UMFPACK_DNAME (report_info) (control, info);
+
+	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 	  else
 	    {
-	      umfpack_di_report_numeric (Numeric, control);
+	      UMFPACK_DNAME (report_numeric) (Numeric, control);
 
 	      double d[2];
 
-	      status = umfpack_di_get_determinant (&d[0], &d[1], Numeric,
-						   info);
+	      status = UMFPACK_DNAME (get_determinant) (&d[0],
+						   &d[1], Numeric, info);
 
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseMatrix::determinant error calculating determinant");
 		  
-		  umfpack_di_report_status (control, status);
-		  umfpack_di_report_info (control, info);
-
-		  umfpack_di_free_numeric (&Numeric);
+		  UMFPACK_DNAME (report_status) (control, status);
+		  UMFPACK_DNAME (report_info) (control, info);
+
+		  UMFPACK_DNAME (free_numeric) (&Numeric);
 		}
 	      else
 		retval = DET (d);
 	    }
 	}
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
@@ -1126,74 +1126,71 @@ SparseMatrix::utsolve (SparseType &matty
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (b.rows (), b.cols ());
+	      retval.resize (nr, b_cols);
+	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-		(*current_liboctave_warning_handler)
-		  ("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
 
 	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  double tmp = work[k] / data(cidx(kidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
+		    retval (perm[i], j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
+			  double tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = ridx(i);
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
@@ -1342,48 +1339,49 @@ SparseMatrix::utsolve (SparseType &matty
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
+	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+	      for (octave_idx_type i = 0; i < nr; i++)
+		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  double tmp = work[k] / data(cidx(kidx+1)-1);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -1394,45 +1392,45 @@ SparseMatrix::utsolve (SparseType &matty
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (work[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
+			  double tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
+			      octave_idx_type idx2 = ridx(i);
 			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
 		      atmp += fabs(work[i]);
@@ -1598,85 +1596,81 @@ SparseMatrix::utsolve (SparseType &matty
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (b.rows (), b.cols ());
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      retval.resize (nr, b_nc);
+	      octave_idx_type *perm = mattype.triangular_perm ();
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
+		    cwork[i] = b(i,j);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+			  cwork[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
-
+		    retval (perm[i], j) = cwork[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
+	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      for (octave_idx_type i = 0; i < nr; i++)
-		work2[i] = 0.;
+		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work2[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work2[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
-			  work2[iidx] = tmp;
+			  double tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work2[idx2] = work2[idx2] - tmp * data(i);
+			      octave_idx_type idx2 = ridx(i);
+			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
-		      atmp += fabs(work2[i]);
-		      work2[i] = 0.;
+		      atmp += fabs(work[i]);
+		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
@@ -1817,107 +1811,108 @@ SparseMatrix::utsolve (SparseType &matty
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      octave_idx_type *perm = mattype.triangular_perm ();
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
+	      for (octave_idx_type i = 0; i < nr; i++)
+		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = 0.;
+		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
+		    cwork[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      octave_idx_type kidx = perm[k];
+
+		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(iidx+1)-1) != iidx)
+			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
+			  Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+			  cwork[k] = tmp;
+			  for (octave_idx_type i = cidx(kidx); 
+			       i < cidx(kidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      octave_idx_type iidx = ridx(i);
+			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
+		    if (cwork[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (cwork[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = cwork[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
-	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
 	      // Calculation of 1-norm of inv(*this)
+	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      for (octave_idx_type i = 0; i < nr; i++)
-		work2[i] = 0.;
+		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work2[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work2[iidx] != 0.)
+		      octave_idx_type iidx = perm[k];
+
+		      if (work[k] != 0.)
 			{
-			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
-			  work2[iidx] = tmp;
+			  double tmp = work[k] / data(cidx(iidx+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(iidx); i < cidx(iidx+1)-1; i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work2[idx2] = work2[idx2] - tmp * data(i);
+			      octave_idx_type idx2 = ridx(i);
+			      work[idx2] = work[idx2] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
-		      atmp += fabs(work2[i]);
-		      work2[i] = 0.;
+		      atmp += fabs(work[i]);
+		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
@@ -2079,79 +2074,97 @@ SparseMatrix::ltsolve (SparseType &matty
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-		(*current_liboctave_warning_handler)
-		  ("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_cols; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
+		    work[perm[i]] = b(i,j);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  double tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
-
+		    retval (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  double tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2297,47 +2310,54 @@ SparseMatrix::ltsolve (SparseType &matty
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-		(*current_liboctave_warning_handler)
-		  ("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
+		    work[perm[b.ridx(i)]] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  double tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
@@ -2348,51 +2368,63 @@ SparseMatrix::ltsolve (SparseType &matty
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
 	      for (octave_idx_type i = 0; i < nr; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  double tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  double tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2556,84 +2588,102 @@ SparseMatrix::ltsolve (SparseType &matty
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      retval.resize (b.rows (), b.cols ());
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = b(i,j);
+		    cwork[perm[i]] = b(i,j);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  Complex tmp = cwork[k] / data(mini);
+			  cwork[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (i, j) = work[p_perm[i]];
-
+		    retval (i, j) = cwork[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
+	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      for (octave_idx_type i = 0; i < nr; i++)
-		work2[i] = 0.;
+		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work2[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work2[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
-			  work2[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  double tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work2[idx2] = work2[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
-		      atmp += fabs(work2[i]);
-		      work2[i] = 0.;
+		      atmp += fabs(work[i]);
+		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      retval = b;
@@ -2776,107 +2826,126 @@ SparseMatrix::ltsolve (SparseType &matty
 	  octave_idx_type b_nz = b.nnz ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      octave_idx_type *p_perm = mattype.triangular_row_perm ();
-	      octave_idx_type *q_perm = mattype.triangular_col_perm ();
-
-	      (*current_liboctave_warning_handler)
-		("SparseMatrix::solve XXX FIXME XXX permuted triangular code not tested");
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
+	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = 0.;
+		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
+		    cwork[perm[b.ridx(i)]] = b.data(i);
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-		      if (work[iidx] != 0.)
+		      if (cwork[k] != 0.)
 			{
-			  if (ridx(cidx(iidx)) != iidx)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  if (minr != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[iidx] / data(cidx(iidx+1)-1);
-			  work[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  Complex tmp = cwork[k] / data(mini);
+			  cwork[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work[idx2] = 
-				work[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
+		    if (cwork[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
 		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[p_perm[i]] != 0.)
+		    if (cwork[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[p_perm[i]];
+			retval.xdata(ii++) = cwork[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
+	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      for (octave_idx_type i = 0; i < nr; i++)
-		work2[i] = 0.;
+		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work2[q_perm[j]] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = 0; k < nr; k++)
 		    {
-		      octave_idx_type iidx = q_perm[k];
-
-		      if (work2[iidx] != 0.)
+		      if (work[k] != 0.)
 			{
-			  double tmp = work2[iidx] / data(cidx(iidx+1)-1);
-			  work2[iidx] = tmp;
-			  for (octave_idx_type i = cidx(iidx)+1; i < cidx(iidx+1); i++)
+			  octave_idx_type minr = nr;
+			  octave_idx_type mini = 0;
+
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+			    if (perm[ridx(i)] < minr)
+			      {
+				minr = perm[ridx(i)];
+				mini = i;
+			      }
+
+			  double tmp = work[k] / data(mini);
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    {
-			      octave_idx_type idx2 = q_perm[ridx(i)];
-			      work2[idx2] = work2[idx2] - tmp * data(i);
+			      if (i == mini)
+				continue;
+
+			      octave_idx_type iidx = perm[ridx(i)];
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
 		  double atmp = 0;
-		  for (octave_idx_type i = 0; i < j+1; i++)
+		  for (octave_idx_type i = j; i < nr; i++)
 		    {
-		      atmp += fabs(work2[i]);
-		      work2[i] = 0.;
+		      atmp += fabs(work[i]);
+		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
@@ -3110,17 +3179,17 @@ SparseMatrix::trisolve (SparseType &matt
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  octave_idx_type b_nc = b.cols();
 	  retval = b;
 	  double *result = retval.fortran_vec ();
 
 	  F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result, 
@@ -3206,17 +3275,17 @@ SparseMatrix::trisolve (SparseType &matt
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgttrf");
@@ -3314,20 +3383,19 @@ SparseMatrix::trisolve (SparseType &matt
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
       
-      // Note can't treat symmetric case as there is no dpttrf function
       if (typ == SparseType::Tridiagonal_Hermitian)
 	{
-	  OCTAVE_LOCAL_BUFFER (Complex, D, nr);
+	  OCTAVE_LOCAL_BUFFER (double, D, nr);
 	  OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
 	  if (mattype.is_dense ())
 	    {
 	      octave_idx_type ii = 0;
 
 	      for (octave_idx_type j = 0; j < nc-1; j++)
 		{
@@ -3411,17 +3479,17 @@ SparseMatrix::trisolve (SparseType &matt
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  octave_idx_type b_nr = b.rows();
 	  octave_idx_type b_nc = b.cols();
 	  rcond = 1.;
 
 	  retval = b;
@@ -3511,17 +3579,17 @@ SparseMatrix::trisolve (SparseType &matt
 	      for (octave_idx_type j = 0; j < nc; j++)
 		for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		  {
 		    if (ridx(i) == j)
 		      D[j] = data(i);
 		    else if (ridx(i) == j + 1)
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
-		      DU[j] = data(i);
+		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in dgttrf");
@@ -3559,17 +3627,16 @@ SparseMatrix::trisolve (SparseType &matt
 
 		      for (octave_idx_type i = 0; i < b_nr; i++)
 			{
 			  Complex c = b (i,j);
 			  Bx[i] = std::real (c);
 			  Bz[i] = std::imag (c);
 			}
 
-
 		      F77_XFCN (dgttrs, DGTTRS, 
 				(F77_CONST_CHAR_ARG2 (&job, 1),
 				 nr, 1, DL, D, DU, DU2, pipvt, 
 				 Bx, b_nr, err
 				 F77_CHAR_ARG_LEN (1)));
 		    
 		      if (f77_exception_encountered)
 			{
@@ -4677,76 +4744,76 @@ SparseMatrix::factorize (octave_idx_type
   // The return values
   void *Numeric;
   err = 0;
 
 #ifdef HAVE_UMFPACK
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
-  umfpack_di_defaults (control);
+  UMFPACK_DNAME (defaults) (control);
 
   double tmp = Voctave_sparse_controls.get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   tmp = Voctave_sparse_controls.get_key ("piv_tol");
   if (!xisnan (tmp))
     {
       Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
       Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = Voctave_sparse_controls.get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
-  umfpack_di_report_control (control);
+  UMFPACK_DNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const double *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  umfpack_di_report_matrix (nr, nc, Ap, Ai, Ax, 1, control);
+  UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = umfpack_di_qsymbolic (nr, nc, Ap, Ai, Ax, NULL,
+  int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, NULL,
 				     &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	("SparseMatrix::solve symbolic factorization failed");
       err = -1;
 
-      umfpack_di_report_status (control, status);
-      umfpack_di_report_info (control, info);
-
-      umfpack_di_free_symbolic (&Symbolic) ;
+      UMFPACK_DNAME (report_status) (control, status);
+      UMFPACK_DNAME (report_info) (control, info);
+
+      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
-      umfpack_di_report_symbolic (Symbolic, control);
-
-      status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric,
-				   control, info) ;
-      umfpack_di_free_symbolic (&Symbolic) ;
+      UMFPACK_DNAME (report_symbolic) (Symbolic, control);
+
+      status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
+				   &Numeric, control, info) ;
+      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
 #ifdef HAVE_LSSOLVE
       rcond = Info (UMFPACK_RCOND);
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix || 
 	  rcond_plus_one == 1.0 || xisnan (rcond))
 	{
-	  umfpack_di_report_numeric (Numeric, control);
+	  UMFPACK_DNAME (report_numeric) (Numeric, control);
 
 	  err = -2;
 
 	  if (sing_handler)
 	    sing_handler (rcond);
 	  else
 	    (*current_liboctave_error_handler)
 	      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
@@ -4755,29 +4822,29 @@ SparseMatrix::factorize (octave_idx_type
 	}
       else
 #endif 
 	if (status < 0)
 	  {
 	    (*current_liboctave_error_handler) 
 	      ("SparseMatrix::solve numeric factorization failed");
 
-	    umfpack_di_report_status (control, status);
-	    umfpack_di_report_info (control, info);
+	    UMFPACK_DNAME (report_status) (control, status);
+	    UMFPACK_DNAME (report_info) (control, info);
 	      
 	    err = -1;
 	  }
 	else
 	  {
-	    umfpack_di_report_numeric (Numeric, control);
+	    UMFPACK_DNAME (report_numeric) (Numeric, control);
 	  }
     }
 
   if (err != 0)
-    umfpack_di_free_numeric (&Numeric);
+    UMFPACK_DNAME (free_numeric) (&Numeric);
 
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
@@ -4831,25 +4898,25 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      double *control = Control.fortran_vec ();
 	      double *info = Info.fortran_vec ();
 	      const octave_idx_type *Ap = cidx ();
 	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
-		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, 
-					     &result[iidx], &Bx[iidx],
+		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
+					     Ai, Ax, &result[iidx], &Bx[iidx],
 					     Numeric, control, info);
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseMatrix::solve solve failed");
 
-		      umfpack_di_report_status (control, status);
+		      UMFPACK_DNAME (report_status) (control, status);
 		      
 		      err = -1;
 		  
 		      break;
 		    }
 		}
 
 #ifndef HAVE_LSSOLVE
@@ -4866,19 +4933,19 @@ SparseMatrix::fsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 	      
 		}
 #endif
 		
-	      umfpack_di_report_info (control, info);
+	      UMFPACK_DNAME (report_info) (control, info);
 		
-	      umfpack_di_free_numeric (&Numeric);
+	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4946,25 +5013,25 @@ SparseMatrix::fsolve (SparseType &mattyp
 
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b.elem (i, j);
 
-		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, Xx,
-					     Bx, Numeric, control, 
+		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
+					     Ai, Ax, Xx, Bx, Numeric, control, 
 					     info);
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseMatrix::solve solve failed");
 
-		      umfpack_di_report_status (control, status);
+		      UMFPACK_DNAME (report_status) (control, status);
 		  
 		      err = -1;
 
 		      break;
 		    }
 	      
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
@@ -5002,19 +5069,19 @@ SparseMatrix::fsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 
 		}
 #endif
 
-	      umfpack_di_report_info (control, info);
-
-	      umfpack_di_free_numeric (&Numeric);
+	      UMFPACK_DNAME (report_info) (control, info);
+
+	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -5083,29 +5150,29 @@ SparseMatrix::fsolve (SparseType &mattyp
 		{
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      Complex c = b (i,j);
 		      Bx[i] = std::real (c);
 		      Bz[i] = std::imag (c);
 		    }
 
-		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, 
-					     Xx, Bx, Numeric, control, 
+		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
+					     Ai, Ax, Xx, Bx, Numeric, control, 
 					     info);
-		  int status2 = umfpack_di_solve (UMFPACK_A, Ap, Ai, 
-						  Ax, Xz, Bz, Numeric, 
+		  int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
+						  Ap, Ai, Ax, Xz, Bz, Numeric, 
 						  control, info) ;
 
 		  if (status < 0 || status2 < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseMatrix::solve solve failed");
 
-		      umfpack_di_report_status (control, status);
+		      UMFPACK_DNAME (report_status) (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    retval (i, j) = Complex (Xx[i], Xz[i]);
@@ -5125,19 +5192,19 @@ SparseMatrix::fsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 
 		}
 #endif
 
-	      umfpack_di_report_info (control, info);
-
-	      umfpack_di_free_numeric (&Numeric);
+	      UMFPACK_DNAME (report_info) (control, info);
+
+	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -5212,29 +5279,29 @@ SparseMatrix::fsolve (SparseType &mattyp
 		{
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
 		      Complex c = b (i,j);
 		      Bx[i] = std::real (c);
 		      Bz[i] = std::imag (c);
 		    }
 
-		  status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, Xx,
-					     Bx, Numeric, control, 
+		  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
+					     Ai, Ax, Xx, Bx, Numeric, control, 
 					     info);
-		  int status2 = umfpack_di_solve (UMFPACK_A, Ap, Ai, 
-						  Ax, Xz, Bz, Numeric, 
+		  int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
+						  Ap, Ai, Ax, Xz, Bz, Numeric, 
 						  control, info) ;
 
 		  if (status < 0 || status2 < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseMatrix::solve solve failed");
 
-		      umfpack_di_report_status (control, status);
+		      UMFPACK_DNAME (report_status) (control, status);
 		      
 		      err = -1;
 
 		      break;
 		    }
 
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
@@ -5272,19 +5339,19 @@ SparseMatrix::fsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
 		       rcond);
 
 		}
 #endif
 
-	      umfpack_di_report_info (control, info);
-
-	      umfpack_di_free_numeric (&Numeric);
+	      UMFPACK_DNAME (report_info) (control, info);
+
+	      UMFPACK_DNAME (free_numeric) (&Numeric);
 	    }
 #else
 	  (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 	}
       else if (typ != SparseType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -5314,17 +5381,17 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		     double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
@@ -5368,17 +5435,17 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
@@ -5422,17 +5489,17 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const ComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
@@ -5476,17 +5543,17 @@ SparseMatrix::solve (SparseType &mattype
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (SparseType &mattype, const SparseComplexMatrix& b, 
 		     octave_idx_type& err, double& rcond,
 		     solve_singularity_handler sing_handler) const
 {
-  int typ = mattype.type ();
+  int typ = mattype.type (false);
 
   if (typ == SparseType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == SparseType::Diagonal || typ == SparseType::Permuted_Diagonal)
     return dsolve (mattype, b, err, rcond, sing_handler);
   else if (typ == SparseType::Upper || typ == SparseType::Permuted_Upper)
     return utsolve (mattype, b, err, rcond, sing_handler);
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -399,15 +399,21 @@ SPARSE_SMS_BOOL_OP_DECLS (SparseMatrix, 
 SPARSE_SSM_CMP_OP_DECLS (double, SparseMatrix)
 SPARSE_SSM_BOOL_OP_DECLS (double, SparseMatrix)
 
 SPARSE_SMSM_CMP_OP_DECLS (SparseMatrix, SparseMatrix)
 SPARSE_SMSM_BOOL_OP_DECLS (SparseMatrix, SparseMatrix)
 
 SPARSE_FORWARD_DEFS (MSparse, SparseMatrix, Matrix, double)
 
+#ifdef UMFPACK_LONG_IDX
+#define UMFPACK_DNAME(name) umfpack_dl_ ## name
+#else
+#define UMFPACK_DNAME(name) umfpack_di_ ## name
+#endif
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/sparse-base-lu.h b/liboctave/sparse-base-lu.h
--- a/liboctave/sparse-base-lu.h
+++ b/liboctave/sparse-base-lu.h
@@ -55,31 +55,31 @@ public:
   lu_type L (void) const { return Lfact; }
 
   lu_type U (void) const { return Ufact; }
 
   p_type Pc (void) const;
 
   p_type Pr (void) const;
 
-  MArray<int> row_perm (void) const { return P; }
+  const octave_idx_type * row_perm (void) const { return P.fortran_vec (); }
 
-  MArray<int> col_perm (void) const { return Q; }
+  const octave_idx_type * col_perm (void) const { return Q.fortran_vec (); }
 
   double rcond (void) const { return cond; }
 
 protected:
 
   lu_type Lfact;
   lu_type Ufact;
 
   double cond;
 
-  MArray<int> P;
-  MArray<int> Q;
+  MArray<octave_idx_type> P;
+  MArray<octave_idx_type> Q;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,49 @@
+2005-04-29  David Bateman  <dbateman@free.fr>
+
+	* Makefile.in: Add matrix_type.cc and spkron.cc to DLD_XSRC
+
+	* ls.mat.cc (read_mat5_binary_element): Allow for endian change for 
+	compressed data elements.
+
+	* ov-base-sparse.cc (assign): Invalidate matrix type.
+
+	* ov-base-sparse.cc (SparseType sparse_type (void), 
+	SparseType sparse_type (const SparseType&): Functions to read and set
+	sparse matrix type.
+
+	* ov-bool-sparse.cc (load_binary): Remove third argument
+	(load_hdf5): Cast hsize_t comparisions with int to avoid warning
+	* ov-cx-sparse.cc (load_hdf5): ditto
+	* ov-re-sparse.cc (load_hdf5): ditto
+
+	* ov-re-sparse.cc (convert_to_str_internal): Add third argument for string
+	type.
+	* ov-re-sparse.h (convert_to_str_internal): Adject declaration.
+
+	* sparse-xdiv.cc (xdiv, xleftdiv): Pass SparseType as third argument, use
+	it and return it to allow caching of type.
+	* sparse-xdiv.h (xdiv, xleftdiv): Change declarations for third argument
+	of type SparseType.
+
+	* DLD-FUNCTIONS/luinc.cc (Fluinc): use type_name and not class_name to
+	test for real/complex sparse matrices. Set matrix type
+
+	* DLD-FUNCTIONS/splu.cc (Fsplu): Set matrix type.
+
+	* OPERATORS/op-cm-scm.cc, OPERATORS/op-cm-sm.cc, OPERATORS/op-cs-scm.cc, 
+	OPERATORS/op-cs-sm.cc, OPERATORS/op-m-scm.cc, OPERATORS/op-m-sm.cc, 
+	OPERATORS/op-s-scm.cc, OPERATORS/op-s-sm.cc, OPERATORS/op-scm-cm.cc, 
+	OPERATORS/op-scm-cs.cc, OPERATORS/op-scm-m.cc, OPERATORS/op-scm-s.cc, 
+	OPERATORS/op-scm-scm.cc, OPERATORS/op-scm-sm.cc, OPERATORS/op-sm-cm.cc, 
+	OPERATORS/op-sm-cs.cc, OPERATORS/op-sm-m.cc, OPERATORS/op-sm-s.cc, 
+	OPERATORS/op-sm-scm.cc, OPERATORS/op-sm-sm.cc (div, ldiv): Pass and
+	recache SparseType wirh xdiv/xleftdiv.
+
 2005-04-29  John W. Eaton  <jwe@octave.org>
 
 	* file-io.cc (maybe_warn_interface_change): Delete function.
 	(fopen_mode_to_ios_mode): Don't call it.
 
 2005-04-27  John W. Eaton  <jwe@octave.org>
 
 	* ov-fcn-handle.cc (octave_fcn_handle::subsref):
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -25,16 +25,17 @@ Boston, MA 02110-1301, USA.
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "oct-map.h"
 
+#include "SparseType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 DEFUN_DLD (luinc, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, '0')\n\
@@ -141,19 +142,20 @@ are the same as for @dfn{lu}.\n\
 	droptol = args(1).double_value ();
 
       // XXX FIXME XXX Add code for zero-level factorization
       if (zero_level)
 	error ("luinc: zero-level factorization not implemented");
 
       if (!error_state)
 	{
-	  if (args(0).class_name () == "sparse") 
+	  if (args(0).type_name () == "sparse matrix") 
 	    {
 	      SparseMatrix sm = args(0).sparse_matrix_value ();
+	      octave_idx_type sm_nr = sm.rows ();
 	      octave_idx_type sm_nc = sm.cols ();
 	      ColumnVector Qinit (sm_nc);
 
 	      for (octave_idx_type i = 0; i < sm_nc; i++)
 		Qinit (i) = i;
 
 	      if (! error_state)
 		{
@@ -163,51 +165,59 @@ are the same as for @dfn{lu}.\n\
 		    case 1:
 		    case 2:
 		      {
 			SparseLU fact (sm, Qinit, thresh, true, droptol,
 				       milu, udiag);
 
 			SparseMatrix P = fact.Pr ();
 			SparseMatrix L = P.transpose () * fact.L ();
-			retval(1) = fact.U ();
-			retval(0) = L;
+			retval(1) = octave_value (fact.U (),
+				  SparseType (SparseType::Upper));
+			retval(0) = octave_value (L, SparseType 
+						  (SparseType::Permuted_Lower, 
+						   sm_nr, fact.row_perm ()));
 		      }
 		      break;
 
 		    case 3:
 		      {
 			SparseLU fact (sm, Qinit, thresh, true, droptol,
 				       milu, udiag);
 
 			retval(2) = fact.Pr ();
-			retval(1) = fact.U ();
-			retval(0) = fact.L ();
+			retval(1) = octave_value (fact.U (),
+				  SparseType (SparseType::Upper));
+			retval(0) = octave_value (fact.L (),
+				  SparseType (SparseType::Lower));
 		      }
 		      break;
 
 		    case 4:
 		    default:
 		      {
 			SparseLU fact (sm, Qinit, thresh, false, droptol,
 				       milu, udiag);
 
 			retval(3) = fact.Pc ();
 			retval(2) = fact.Pr ();
-			retval(1) = fact.U ();
-			retval(0) = fact.L ();
+			retval(1) = octave_value (fact.U (),
+				  SparseType (SparseType::Upper));
+			retval(0) = octave_value (fact.L (),
+				  SparseType (SparseType::Lower));
 		      }
 		      break;
 		    }
 		}
 	    }
-	  else if (args(0).class_name () == "sparse complex") 
+	  else if (args(0).type_name () == "sparse complex matrix") 
 	    {
 	      SparseComplexMatrix sm = 
 		args(0).sparse_complex_matrix_value ();
+	      octave_idx_type sm_nr = sm.rows ();
 	      octave_idx_type sm_nc = sm.cols ();
 	      ColumnVector Qinit (sm_nc);
 
 	      for (octave_idx_type i = 0; i < sm_nc; i++)
 		Qinit (i) = i;
 
 	      if (! error_state)
 		{
@@ -217,42 +227,49 @@ are the same as for @dfn{lu}.\n\
 		    case 1:
 		    case 2:
 		      {
 			SparseComplexLU fact (sm, Qinit, thresh, true, 
 					      droptol, milu, udiag);
 
 			SparseMatrix P = fact.Pr ();
 			SparseComplexMatrix L = P.transpose () * fact.L ();
-			retval(1) = fact.U ();
-			retval(0) = L;
+			retval(1) = octave_value (fact.U (),
+				  SparseType (SparseType::Upper));
+			retval(0) = octave_value (L, SparseType 
+						  (SparseType::Permuted_Lower, 
+						   sm_nr, fact.row_perm ()));
 		      }
 		      break;
 
 		    case 3:
 		      {
 			SparseComplexLU fact (sm, Qinit, thresh, true,
 					      droptol, milu, udiag);
 
 			retval(2) = fact.Pr ();
-			retval(1) = fact.U ();
-			retval(0) = fact.L ();
+			retval(1) = octave_value (fact.U (),
+				  SparseType (SparseType::Upper));
+			retval(0) = octave_value (fact.L (),
+				  SparseType (SparseType::Lower));
 		      }
 		      break;
 
 		    case 4:
 		    default:
 		      {
 			SparseComplexLU fact (sm, Qinit, thresh, false,
 					      droptol, milu, udiag);
 
 			retval(3) = fact.Pc ();
 			retval(2) = fact.Pr ();
-			retval(1) = fact.U ();
-			retval(0) = fact.L ();
+			retval(1) = octave_value (fact.U (),
+				  SparseType (SparseType::Upper));
+			retval(0) = octave_value (fact.L (),
+				  SparseType (SparseType::Lower));
 		      }
 		      break;
 		    }
 		}
 	    }
 	  else
 	    error ("luinc: first argument must be sparse");
 	}
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -234,57 +234,68 @@ be square.\n\
 	    case 1:
 	    case 2:
 	      {
 		SparseLU fact (m, Qinit, thres, true);
 
 		SparseMatrix P = fact.Pr ();
 		SparseMatrix L = P.transpose () * fact.L ();
 		if (have_Qinit)
-		  retval(1) = fact.U () * fact.Pc ().transpose ();
+		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
+		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
 		else
-		  retval(1) = fact.U ();
+		  retval(1) = octave_value (fact.U (), 
+					    SparseType (SparseType::Upper));
 
-		retval(0) = L;
+		retval(0) = octave_value (L,
+		  SparseType (SparseType::Permuted_Lower, nr, fact.row_perm ()));
 	      }
 	      break;
 
 	    case 3:
 	      {
 		SparseLU fact (m, Qinit, thres, true);
 
 		retval(2) = fact.Pr ();
 		if (have_Qinit)
-		  retval(1) = fact.U () * fact.Pc ().transpose ();
+		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
+		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
 		else
-		  retval(1) = fact.U ();
-		retval(0) = fact.L ();
+		  retval(1) = octave_value (fact.U (), 
+					    SparseType (SparseType::Upper));
+
+		retval(0) = octave_value (fact.L (), 
+					  SparseType (SparseType::Lower));
 	      }
 	      break;
 
 	    case 4:
 	    default:
 	      {
 		if (have_Qinit)
 		  {
 		    SparseLU fact (m, Qinit, thres, false);
 
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
-		    retval(1) = fact.U ();
-		    retval(0) = fact.L ();
+		    retval(1) = octave_value (fact.U (), 
+					      SparseType (SparseType::Upper));
+		    retval(0) = octave_value (fact.L (), 
+					      SparseType (SparseType::Lower));
 		  }
 		else
 		  {
 		    SparseLU fact (m, thres);
 
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
-		    retval(1) = fact.U ();
-		    retval(0) = fact.L ();
+		    retval(1) = octave_value (fact.U (), 
+					      SparseType (SparseType::Upper));
+		    retval(0) = octave_value (fact.L (), 
+					      SparseType (SparseType::Lower));
 		  }
 	      }
 	      break;
 	    }
 	}
     }
   else if (arg.is_complex_type ())
     {
@@ -307,56 +318,68 @@ be square.\n\
 	    case 2:
 	      {
 		SparseComplexLU fact (m, Qinit, thres, true);
 
 		SparseMatrix P = fact.Pr ();
 		SparseComplexMatrix L = P.transpose () * fact.L ();
 
 		if (have_Qinit)
-		  retval(1) = fact.U () * fact.Pc ().transpose ();
+		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
+		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
 		else
-		  retval(1) = fact.U ();
-		retval(0) = L;
+		  retval(1) = octave_value (fact.U (), 
+					    SparseType (SparseType::Upper));
+
+		retval(0) = octave_value (L,
+		  SparseType (SparseType::Permuted_Lower, nr, fact.row_perm ()));
 	      }
 	      break;
 
 	    case 3:
 	      {
 		SparseComplexLU fact (m, Qinit, thres, true);
 
 		retval(2) = fact.Pr ();
 		if (have_Qinit)
-		  retval(1) = fact.U () * fact.Pc ().transpose ();
+		  retval(1) = octave_value (fact.U () * fact.Pc ().transpose (),
+		    SparseType (SparseType::Permuted_Upper, nc, fact.col_perm ()));
 		else
-		  retval(1) = fact.U ();
-		retval(0) = fact.L ();
+		  retval(1) = octave_value (fact.U (), 
+					    SparseType (SparseType::Upper));
+
+		retval(0) = octave_value (fact.L (), 
+					  SparseType (SparseType::Lower));
 	      }
 	      break;
 
 	    case 4:
 	    default:
 	      {
 		if (have_Qinit)
 		  {
 		    SparseComplexLU fact (m, Qinit, thres, false);
-
+		    
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
-		    retval(1) = fact.U ();
-		    retval(0) = fact.L ();
+		    retval(1) = octave_value (fact.U (), 
+					      SparseType (SparseType::Upper));
+		    retval(0) = octave_value (fact.L (), 
+					      SparseType (SparseType::Lower));
 		  }
 		else
 		  {
 		    SparseComplexLU fact (m, thres);
 
 		    retval(3) = fact.Pc ();
 		    retval(2) = fact.Pr ();
-		    retval(1) = fact.U ();
-		    retval(0) = fact.L ();
+		    retval(1) = octave_value (fact.U (), 
+					      SparseType (SparseType::Upper));
+		    retval(0) = octave_value (fact.L (), 
+					      SparseType (SparseType::Lower));
 		  }
 	      }
 	      break;
 	    }
 	}
     }
   else
     {
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -42,20 +42,20 @@ endif
 OPT_HANDLERS := DASPK-opts.cc DASRT-opts.cc DASSL-opts.cc \
 	LSODE-opts.cc NLEqn-opts.cc Quad-opts.cc
 
 DLD_XSRC := balance.cc besselj.cc betainc.cc cellfun.cc chol.cc colamd.cc \
 	colloc.cc daspk.cc dasrt.cc dassl.cc det.cc dispatch.cc \
 	eig.cc expm.cc fft.cc fft2.cc fftn.cc fftw_wisdom.cc \
 	filter.cc find.cc fsolve.cc gammainc.cc gcd.cc getgrent.cc \
 	getpwent.cc getrusage.cc givens.cc hess.cc inv.cc kron.cc \
-	lpsolve.cc lsode.cc lu.cc luinc.cc minmax.cc pinv.cc qr.cc \
-	quad.cc qz.cc rand.cc schur.cc sort.cc sparse.cc spdet.cc \
-	splu.cc spparms.cc sqrtm.cc svd.cc syl.cc time.cc gplot.l \
-	__glpk__.cc __qp__.cc
+	lpsolve.cc lsode.cc lu.cc luinc.cc matrix_type.cc minmax.cc \
+	pinv.cc qr.cc quad.cc qz.cc rand.cc schur.cc sort.cc sparse.cc \
+	spdet.cc spkron.cc splu.cc spparms.cc sqrtm.cc svd.cc syl.cc \
+	time.cc gplot.l __glpk__.cc __qp__.cc
 
 DLD_SRC := $(addprefix DLD-FUNCTIONS/, $(DLD_XSRC))
 
 DLD_OBJ_1 := $(patsubst %.l, %.o, $(DLD_XSRC))
 DLD_OBJ := $(patsubst %.cc, %.o, $(DLD_OBJ_1))
 
 ifeq ($(ENABLE_DYNAMIC_LINKING), true)
   OCT_FILES := $(patsubst %.o, %.oct, $(DLD_OBJ))
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -50,21 +50,25 @@ DEFBINOP (mul, complex_matrix, sparse_co
   
   ComplexMatrix tmp (v2.complex_matrix_value ());
 
   return octave_value ( v1.complex_matrix_value() * tmp);
 }
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_matrix&, octave_sparse_complex_matrix&);
   
-  return xdiv (v1.complex_matrix_value (), 
-	       v2.sparse_complex_matrix_value ());
+  SparseType typ = v2.sparse_type ();
+
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+			    v2.sparse_complex_matrix_value (), typ);
+
+  v2.sparse_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -50,20 +50,25 @@ DEFBINOP (mul, complex_matrix, sparse_ma
   
   Matrix tmp (v2.matrix_value ());
 
   return octave_value (v1.complex_matrix_value() * tmp);
 }
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
-		   const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_matrix&, octave_sparse_matrix&);
   
-  return xdiv (v1.complex_matrix_value (), v2.sparse_matrix_value ());
+  SparseType typ = v2.sparse_type ();
+
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+			    v2.sparse_matrix_value (), typ);
+
+  v2.sparse_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -40,23 +40,25 @@ Boston, MA 02110-1301, USA.
 // complex scalar by sparse complex matrix ops.
 
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, 
-		   const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_complex&, octave_sparse_complex_matrix&);
 
+  SparseType typ = v2.sparse_type ();
   ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
   SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
+  ComplexMatrix ret = xdiv (m1, m2, typ);
+  v2.sparse_type (typ);
 
-  return xdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP (pow, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, 
 		   const octave_sparse_complex_matrix&);
   return xpow (v1.complex_value (), v2.complex_matrix_value ());
 }
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -42,22 +42,25 @@ Boston, MA 02110-1301, USA.
 // complex by sparse matrix ops.
 
 DEFBINOP_OP (add, complex, sparse_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_complex&, octave_sparse_matrix&);
 
+  SparseType typ = v2.sparse_type ();
   ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
   SparseMatrix m2 = v2.sparse_matrix_value ();
+  ComplexMatrix ret = xdiv (m1, m2, typ);
+  v2.sparse_type (typ);
 
-  return xdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP (pow, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
   return xpow (v1.complex_value (), v2.matrix_value ());
 }
 
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -51,20 +51,25 @@ DEFBINOP (mul, matrix, sparse_complex_ma
   
   ComplexMatrix tmp (v2.complex_matrix_value ());
 
   return octave_value ( v1.matrix_value() * tmp);
 }
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, 
-		   const octave_sparse_complex_matrix&);
-  
-  return xdiv (v1.matrix_value (), v2.sparse_complex_matrix_value ());
+  CAST_BINOP_ARGS (const octave_matrix&, octave_sparse_complex_matrix&);
+
+  SparseType typ = v2.sparse_type ();
+
+  ComplexMatrix ret = xdiv (v1.matrix_value (), 
+			    v2.sparse_complex_matrix_value (), typ);
+
+  v2.sparse_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -49,19 +49,23 @@ DEFBINOP (mul, matrix, sparse_matrix)
   
   Matrix tmp (v2.matrix_value ());
 
   return octave_value ( v1.matrix_value() * tmp);
 }
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
-  
-  return xdiv (v1.matrix_value (), v2.sparse_matrix_value ());
+  CAST_BINOP_ARGS (const octave_matrix&, octave_sparse_matrix&);
+  SparseType typ = v2.sparse_type ();
+
+  Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
+
+  v2.sparse_type (typ);
+  return ret;
 }
 
 DEFBINOPX (pow, matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -43,23 +43,25 @@ Boston, MA 02110-1301, USA.
 // scalar by sparse complex matrix ops.
 
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, 
-		   const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_scalar&, octave_sparse_complex_matrix&);
 
+  SparseType typ = v2.sparse_type ();
   Matrix m1 = Matrix (1, 1, v1.scalar_value ());
   SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
+  ComplexMatrix ret = xdiv (m1, m2, typ);
+  v2.sparse_type (typ);
 
-  return xdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP (pow, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, 
 		   const octave_sparse_complex_matrix&);
   return xpow (v1.scalar_value (), v2.complex_matrix_value ());
 }
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -39,22 +39,25 @@ Boston, MA 02110-1301, USA.
 // scalar by sparse matrix ops.
 
 DEFBINOP_OP (add, scalar, sparse_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_scalar&, octave_sparse_matrix&);
 
+  SparseType typ = v2.sparse_type ();
   Matrix m1 = Matrix (1, 1, v1.double_value ());
   SparseMatrix m2 = v2.sparse_matrix_value ();
+  Matrix ret = xdiv (m1, m2, typ);
+  v2.sparse_type (typ);
 
-  return xdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP (pow, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
   return xpow (v1.scalar_value (), v2.matrix_value ());
 }
 
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -64,21 +64,24 @@ DEFBINOP (div, sparse_complex_matrix, co
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex_matrix&);
-  
-  return xleftdiv (v1.sparse_complex_matrix_value (), 
-		   v2.complex_matrix_value ());
+  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex_matrix&);
+  SparseType typ = v1.sparse_type ();
+
+  ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+				v2.complex_matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -67,23 +67,25 @@ DEFBINOP (pow, sparse_complex_matrix, co
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.scalar_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_complex&);
+  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex&);
 
+  SparseType typ = v1.sparse_type ();
   SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
   ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
+  ComplexMatrix ret = xleftdiv (m1, m2, typ);
+  v1.sparse_type (typ);
 
-  return xleftdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, complex, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, complex, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, complex, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -52,33 +52,38 @@ DEFBINOP (mul, sparse_complex_matrix, ma
   ComplexMatrix tmp (v1.complex_matrix_value ());
 
   return octave_value ( tmp * v2.matrix_value());
 }
 
 DEFBINOP (div, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_matrix&);
+                   const octave_matrix&);
   
   return xdiv (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_matrix&);
+  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_matrix&);
   
-  return xleftdiv (v1.sparse_complex_matrix_value (), v2.matrix_value ());
+  SparseType typ = v1.sparse_type ();
+
+  ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+				v2.matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -75,23 +75,25 @@ DEFBINOP (pow, sparse_complex_matrix, sc
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_complex_matrix_value (), tmp);
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   const octave_scalar&);
+  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_scalar&);
 
+  SparseType typ = v1.sparse_type ();
   SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
   Matrix m2 = Matrix (1, 1, v2.scalar_value ());
+  ComplexMatrix ret = xleftdiv (m1, m2, typ);
+  v1.sparse_type (typ);
 
-  return xleftdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, scalar, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, scalar, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, scalar, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, scalar, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -52,25 +52,27 @@ Boston, MA 02110-1301, USA.
 
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
-
-  return octave_value (v.sparse_complex_matrix_value().transpose ());
+  return octave_value 
+    (v.sparse_complex_matrix_value().transpose (),
+     v.sparse_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
-
-  return octave_value (v.sparse_complex_matrix_value().hermitian ());
+  return octave_value 
+    (v.sparse_complex_matrix_value().hermitian (),
+     v.sparse_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
 
   return octave_value (v.complex_matrix_value () .increment ());
@@ -86,25 +88,46 @@ DEFUNOP (decr, sparse_complex_matrix)
 
 // complex matrix by complex matrix ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
-DEFBINOP_FN (div, sparse_complex_matrix, sparse_complex_matrix, xdiv)
+DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+		   octave_sparse_complex_matrix&);
+  SparseType typ = v2.sparse_type ();
+  SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
+				  v2.sparse_complex_matrix_value (), typ);
+  
+  v2.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, sparse_complex_matrix, sparse_complex_matrix, xleftdiv)
+DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
+{
+  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, 
+		   const octave_sparse_complex_matrix&);
+  SparseType typ = v1.sparse_type ();
+
+  SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+				      v2.sparse_complex_matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_complex_matrix, mx_el_ne)
 
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -39,25 +39,44 @@ Boston, MA 02110-1301, USA.
 
 // sparse complex matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
-DEFBINOP_FN (div, sparse_complex_matrix, sparse_matrix, xdiv)
+DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
+{
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, octave_sparse_matrix&);
+  SparseType typ = v2.sparse_type ();
+  SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
+				  v2.sparse_matrix_value (), typ);
+  
+  v2.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, sparse_complex_matrix, sparse_matrix, xleftdiv)
+DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
+{
+  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_sparse_matrix&);
+  SparseType typ = v1.sparse_type ();
+
+  SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+				      v2.sparse_matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_matrix, mx_el_ne)
 
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -64,20 +64,24 @@ DEFBINOP (div, sparse_matrix, complex_ma
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, 
-		   const octave_complex_matrix&);
-  
-  return xleftdiv (v1.sparse_matrix_value (), v2.complex_matrix_value ());
+  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex_matrix&);
+  SparseType typ = v1.sparse_type ();
+
+  ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
+				v2.complex_matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -67,22 +67,25 @@ DEFBINOP (div, sparse_matrix, complex)
 DEFBINOP (pow, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
+  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex&);
 
+  SparseType typ = v1.sparse_type ();
   SparseMatrix m1 = v1.sparse_matrix_value ();
   ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
+  ComplexMatrix ret = xleftdiv (m1, m2, typ);
+  v1.sparse_type (typ);
 
-  return xleftdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, complex, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, complex, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -62,22 +62,26 @@ DEFBINOP (div, sparse_matrix, matrix)
 DEFBINOPX (pow, sparse_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
-  
-  return xleftdiv (v1.sparse_matrix_value (), v2.matrix_value ());
+  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_matrix&);
+  SparseType typ = v1.sparse_type ();
+
+  Matrix ret = xleftdiv (v1.sparse_matrix_value (), 
+			       v2.matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
 }
 
-
 DEFBINOP_FN (lt, sparse_matrix, matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, matrix, product)
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -69,22 +69,25 @@ DEFBINOP (pow, sparse_matrix, scalar)
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_matrix_value (), tmp);
   else
     return xpow (v1.matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
+  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_scalar&);
 
+  SparseType typ = v1.sparse_type ();
   SparseMatrix m1 = v1.sparse_matrix_value ();
   Matrix m2 = Matrix (1, 1, v2.scalar_value ());
+  Matrix ret = xleftdiv (m1, m2, typ);
+  v1.sparse_type (typ);
 
-  return xleftdiv (m1, m2);
+  return ret;
 }
 
 DEFBINOP_FN (lt, sparse_matrix, scalar, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, scalar, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, scalar, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, scalar, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -39,25 +39,44 @@ Boston, MA 02110-1301, USA.
 
 // sparse matrix by sparse complex matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
-DEFBINOP_FN (div, sparse_matrix, sparse_complex_matrix, xdiv)
+DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, octave_sparse_complex_matrix&);
+  SparseType typ = v2.sparse_type ();
+  SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (), 
+				  v2.sparse_complex_matrix_value (), typ);
+  
+  v2.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, sparse_matrix, sparse_complex_matrix, xleftdiv)
+DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
+{
+  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_sparse_complex_matrix&);
+  SparseType typ = v1.sparse_type ();
+
+  SparseComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
+				      v2.sparse_complex_matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, sparse_complex_matrix, mx_el_ne)
 
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -39,34 +39,54 @@ Boston, MA 02110-1301, USA.
 
 DEFUNOP_OP (not, sparse_matrix, !)
 DEFUNOP_OP (uplus, sparse_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_matrix, -)
 
 DEFUNOP (transpose, sparse_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_matrix&);
-  return octave_value (v.sparse_matrix_value().transpose ());
+  return octave_value (v.sparse_matrix_value().transpose (),
+		       v.sparse_type ().transpose ());
 }
 
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
-DEFBINOP_FN (div, sparse_matrix, sparse_matrix, xdiv)
+DEFBINOP (div, sparse_matrix, sparse_matrix)
+{
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, octave_sparse_matrix&);
+  SparseType typ = v2.sparse_type ();
+  SparseMatrix ret = xdiv (v1.sparse_matrix_value (), 
+			   v2.sparse_matrix_value (), typ);
+  
+  v2.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-DEFBINOP_FN (ldiv, sparse_matrix, sparse_matrix, xleftdiv)
+DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
+{
+  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_sparse_matrix&);
+  SparseType typ = v1.sparse_type ();
+
+  SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
+			       v2.sparse_matrix_value (), typ);
+
+  v1.sparse_type (typ);
+  return ret;
+}
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, sparse_matrix, mx_el_ne)
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1146,16 +1146,20 @@ parse_save_options (const string_vector 
 	{
 	  save_builtins = true;
 	}
 #ifdef HAVE_ZLIB
       else if (argv[i] == "-zip" || argv[i] == "-z")
 	{
 	  use_zlib  = true;
 	}
+      else if (argv[i] == "-nozip" || argv[i] == "-nz")
+	{
+	  use_zlib  = false;
+	}
 #endif
       else
 	break;
     }
 
   return i;
 }
 
@@ -1502,17 +1506,23 @@ values to be saved can be represented in
 @item -save-builtins\n\
 Force Octave to save the values of built-in variables too.  By default,\n\
 Octave does not save built-in variables.\n\
 \n\
 @item -zip\n\
 @itemx -z\n\
 Use the gzip algorithm to compress the file. This works equally on files that\n\
 are compressed with gzip outside of octave, and gzip can equally be used to\n\
-convert the files for backward compatibility"
+convert the files for backward compatibility."
+
+HAVE_ZLIB_HELP_STRING
+
+"@item -nozip\n\
+@itemx -nz\n\
+Disable the use of the file compression."
 
 HAVE_ZLIB_HELP_STRING
 
 "@end table\n\
 \n\
 The list of variables to save may include wildcard patterns containing\n\
 the following special characters:\n\
 @table @code\n\
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -436,16 +436,19 @@ read_mat5_binary_element (std::istream& 
       // We uncompress the first 8 bytes of the header to get the buffer length
       // This will fail with an error Z_MEM_ERROR
       uLongf destLen = 8;
       OCTAVE_LOCAL_BUFFER (unsigned int, tmp, 2);
       if (uncompress (X_CAST (Bytef *, tmp), &destLen, 
 		      X_CAST (Bytef *, inbuf), element_length) !=  Z_MEM_ERROR)
 	{
 	  // Why should I have to initialize outbuf as I'll just overwrite!!
+	  if (swap)
+	    swap_bytes<4> (tmp, 2);
+
 	  destLen = tmp[1] + 8;
 	  std::string outbuf (destLen, ' '); 
 
 	  int err = uncompress (X_CAST (Bytef *, outbuf.c_str ()), &destLen, 
 			    X_CAST ( Bytef *, inbuf), element_length);
 	  //if (uncompress (X_CAST (Bytef *, outbuf.c_str ()), &destLen, 
 	  //		  X_CAST ( Bytef *, inbuf), element_length) != Z_OK)
 
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -183,16 +183,19 @@ void
 octave_base_sparse<T>::assign (const octave_value_list& idx, const T& rhs)
 {
   octave_idx_type len = idx.length ();
 
   for (octave_idx_type i = 0; i < len; i++)
     matrix.set_index (idx(i).index_vector ());
 
   ::assign (matrix, rhs);
+
+  // Invalidate matrix type.
+  typ.invalidate_type ();
 }
 
 
 template <class T>
 bool 
 octave_base_sparse<T>::is_true (void) const
 {
   bool retval = false;
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -112,16 +112,20 @@ octave_base_sparse : public octave_base_
     { return T (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv) const
     { T retval (matrix); retval.resize (dv); return retval; }
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
+  SparseType sparse_type (void) const { return typ; }
+  SparseType sparse_type (const SparseType& _typ) 
+    { SparseType ret = typ; typ = _typ; return ret; }
+
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -244,17 +244,17 @@ octave_sparse_bool_matrix::save_binary (
    
   os.write (htmp, nz);
 
   return true;
 }
 
 bool
 octave_sparse_bool_matrix::load_binary (std::istream& is, bool swap,
-					oct_mach_info::float_format fmt)
+					oct_mach_info::float_format /* fmt */)
 {
   FOUR_BYTE_INT nz, nc, nr, tmp;
   if (! is.read (X_CAST (char *, &tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
@@ -591,17 +591,18 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nc + 1 || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nc + 1 || 
+      static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   int *itmp = m.xcidx ();
@@ -626,17 +627,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nz || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nz || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
@@ -661,17 +662,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nz || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nz || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   hbool_t htmp[nz];
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -645,17 +645,18 @@ octave_sparse_complex_matrix::load_hdf5 
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nc + 1 || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nc + 1 || 
+      static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   int *itmp = m.xcidx ();
@@ -680,17 +681,17 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nz || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nz || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
@@ -727,17 +728,17 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nz || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nz || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   Complex *ctmp = m.xdata ();
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -179,26 +179,26 @@ octave_sparse_matrix::streamoff_array_va
 	    break;
 	  }
       }
 
   return retval;
 }
 
 octave_value
-octave_sparse_matrix::convert_to_str_internal (bool, bool) const
+octave_sparse_matrix::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
   dim_vector dv = dims ();
   octave_idx_type nel = dv.numel ();
 
   if (nel == 0)
     {
       char s = '\0';
-      retval = octave_value (&s);
+      retval = octave_value (&s, type);
     }
   else
     {
       octave_idx_type nr = matrix.rows ();
       octave_idx_type nc = matrix.cols ();
       charNDArray chm (dv, static_cast<char> (0));
 	  
       bool warned = false;
@@ -233,17 +233,17 @@ octave_sparse_matrix::convert_to_str_int
 			  warned = true;
 			}
 		    }
 
 		  chm (matrix.ridx(i) + j * nr) = 
 		    static_cast<char> (ival);
 		}
 	  }
-      retval = octave_value (chm, 1);
+      retval = octave_value (chm, true, type);
     }
 
   return retval;
 }
 
 bool 
 octave_sparse_matrix::save_binary (std::ostream& os, bool&save_as_floats)
 {
@@ -363,17 +363,18 @@ octave_sparse_matrix::load_binary (std::
       if (swap)
 	swap_bytes<4> (&tmp);
       m.xridx(i) = tmp;
     }
 
   if (! is.read (X_CAST (char *, &tmp), 1))
     return false;
   
-  read_doubles (is, m.xdata(), X_CAST (save_type, tmp), nz, swap, fmt);
+  double *re = m.xdata ();
+  read_doubles (is, re, X_CAST (save_type, tmp), nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
   matrix = m;
 
   return true;
 }
 
@@ -673,17 +674,18 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nc + 1 || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nc + 1 || 
+      static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   int *itmp = m.xcidx ();
@@ -708,17 +710,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nz || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nz || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
@@ -743,17 +745,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (hdims[0] != nz || hdims[1] != 1)
+  if (static_cast<int> (hdims[0]) != nz || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   double *dtmp = m.xdata ();
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -108,17 +108,17 @@ public:
   SparseMatrix sparse_matrix_value (bool = false) const
     { return matrix; }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
     { return SparseComplexMatrix (matrix); }
 
   streamoff_array streamoff_array_value (void) const;
 
-  octave_value convert_to_str_internal (bool pad, bool force) const;
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
 #if 0
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 #endif
 
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -122,234 +122,274 @@ INSTANTIATE_MX_DIV_CONFORM (ComplexMatri
 //                   +--   +---+----+----+----+
 //   sparse matrix         | 1 |  3 |  5 |  7 |
 //                         +---+----+----+----+
 //   sparse complex_matrix | 2 |  4 |  6 |  8 |
 //                         +---+----+----+----+
 
 // -*- 1 -*-
 Matrix
-xdiv (const Matrix& a, const SparseMatrix& b)
+xdiv (const Matrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
-      Matrix result = btmp.solve (atmp, info, rcond, 
+      Matrix result = btmp.solve (btyp, atmp, info, rcond, 
 				  solve_singularity_warning);
 
       if (result_ok (info))
-	return Matrix (result.transpose ());
+	{
+	  typ = btyp.transpose ();
+	  return Matrix (result.transpose ());
+	}
     }
 
   octave_idx_type rank;
   Matrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xdiv (const Matrix& a, const SparseComplexMatrix& b)
+xdiv (const Matrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   Matrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
-	return result.hermitian ();
+	{
+	  typ = btyp.transpose ();
+	  return result.hermitian ();
+	}
     }
 
   octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.hermitian ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const SparseMatrix& b)
+xdiv (const ComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
-	return result.hermitian ();
+	{
+	  typ = btyp.transpose ();
+	  return result.hermitian ();
+	}
     }
 
   octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.hermitian ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b)
+xdiv (const ComplexMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   ComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
-	return result.hermitian ();
+	{
+	  typ = btyp.transpose ();
+	  return result.hermitian ();
+	}
     }
 
   octave_idx_type rank;
   ComplexMatrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.hermitian ();
 }
 
 // -*- 5 -*-
 SparseMatrix
-xdiv (const SparseMatrix& a, const SparseMatrix& b)
+xdiv (const SparseMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
-      SparseMatrix result = btmp.solve (atmp, info, rcond, 
+      SparseMatrix result = btmp.solve (btyp, atmp, info, rcond, 
 					solve_singularity_warning);
 
       if (result_ok (info))
-	return SparseMatrix (result.transpose ());
+	{
+	  typ = btyp.transpose ();
+	  return SparseMatrix (result.transpose ());
+	}
     }
 
   octave_idx_type rank;
   SparseMatrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.transpose ();
 }
 
 // -*- 6 -*-
 SparseComplexMatrix
-xdiv (const SparseMatrix& a, const SparseComplexMatrix& b)
+xdiv (const SparseMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseComplexMatrix btmp = b.hermitian ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
-	return result.hermitian ();
+	{
+	  typ = btyp.transpose ();
+	  return result.hermitian ();
+	}
     }
 
   octave_idx_type rank;
   SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.hermitian ();
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
-xdiv (const SparseComplexMatrix& a, const SparseMatrix& b)
+xdiv (const SparseComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseMatrix btmp = b.transpose ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
-	return result.hermitian ();
+	{
+	  typ = btyp.transpose ();
+	  return result.hermitian ();
+	}
     }
 
   octave_idx_type rank;
   SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.hermitian ();
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
-xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
+xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
+  SparseType btyp = typ.transpose ();
 
   octave_idx_type info;
   if (btmp.rows () == btmp.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
-	= btmp.solve (atmp, info, rcond, solve_singularity_warning);
+	= btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
-	return result.hermitian ();
+	{
+	  typ = btyp.transpose ();
+	  return result.hermitian ();
+	}
     }
 
   octave_idx_type rank;
   SparseComplexMatrix result = btmp.lssolve (atmp, info, rank);
+  typ = btyp.transpose ();
 
   return result.hermitian ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
 //            +--   +---+----+
@@ -447,189 +487,190 @@ x_el_div (const Complex a, const SparseC
 //                         +---+----+
 //   sparse matrix         | 3 |  7 |
 //                         +---+----+
 //   sparse complex_matrix | 4 |  8 |
 //                         +---+----+
 
 // -*- 1 -*-
 Matrix
-xleftdiv (const SparseMatrix& a, const Matrix& b)
+xleftdiv (const SparseMatrix& a, const Matrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       Matrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xleftdiv (const SparseMatrix& a, const ComplexMatrix& b)
+xleftdiv (const SparseMatrix& a, const ComplexMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 3 -*-
 SparseMatrix
-xleftdiv (const SparseMatrix& a, const SparseMatrix& b)
+xleftdiv (const SparseMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseMatrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 4 -*-
 SparseComplexMatrix
-xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b)
+xleftdiv (const SparseMatrix& a, const SparseComplexMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 5 -*-
 ComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const Matrix& b)
+xleftdiv (const SparseComplexMatrix& a, const Matrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 6 -*-
 ComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b)
+xleftdiv (const SparseComplexMatrix& a, const ComplexMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       ComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 7 -*-
 SparseComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b)
+xleftdiv (const SparseComplexMatrix& a, const SparseMatrix& b, SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
+xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, 
+	  SparseType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
 
       SparseComplexMatrix result
-	= a.solve (b, info, rcond, solve_singularity_warning);
+	= a.solve (typ, b, info, rcond, solve_singularity_warning);
 
       if (result_ok (info))
 	return result;
     }
 
   octave_idx_type rank;
   return a.lssolve (b, info, rank);
 }
diff --git a/src/sparse-xdiv.h b/src/sparse-xdiv.h
--- a/src/sparse-xdiv.h
+++ b/src/sparse-xdiv.h
@@ -19,53 +19,61 @@ Free Software Foundation, Inc., 51 Frank
 Boston, MA 02110-1301, USA.
 
 */
 
 #if !defined (octave_sparse_xdiv_h)
 #define octave_sparse_xdiv_h 1
 
 #include "oct-cmplx.h"
+#include "SparseType.h"
 
 class SparseMatrix;
 class SparseComplexMatrix;
 
-extern Matrix xdiv (const Matrix& a, const SparseMatrix& b);
-extern ComplexMatrix xdiv (const Matrix& a, const SparseComplexMatrix& b);
-extern ComplexMatrix xdiv (const ComplexMatrix& a, const SparseMatrix& b);
+extern Matrix xdiv (const Matrix& a, const SparseMatrix& b, SparseType &typ);
+extern ComplexMatrix xdiv (const Matrix& a, const SparseComplexMatrix& b,
+			   SparseType &typ);
+extern ComplexMatrix xdiv (const ComplexMatrix& a, const SparseMatrix& b,
+			   SparseType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, 
-			   const SparseComplexMatrix& b);
+			   const SparseComplexMatrix& b, SparseType &typ);
 
-extern SparseMatrix xdiv (const SparseMatrix& a, const SparseMatrix& b);
+extern SparseMatrix xdiv (const SparseMatrix& a, const SparseMatrix& b,
+			  SparseType &typ);
 extern SparseComplexMatrix xdiv (const SparseMatrix& a, 
-				 const SparseComplexMatrix& b);
+				 const SparseComplexMatrix& b, SparseType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const SparseMatrix& b);
+				 const SparseMatrix& b, SparseType &typ);
 extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
-				 const SparseComplexMatrix& b);
+				 const SparseComplexMatrix& b, SparseType &typ);
 
 extern Matrix x_el_div (double a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (double a, const SparseComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, 
 			       const SparseComplexMatrix& b);
 
-extern Matrix xleftdiv (const SparseMatrix& a, const Matrix& b);
-extern ComplexMatrix xleftdiv (const SparseMatrix& a, const ComplexMatrix& b);
-extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, const Matrix& b);
+extern Matrix xleftdiv (const SparseMatrix& a, const Matrix& b, 
+			SparseType& typ);
+extern ComplexMatrix xleftdiv (const SparseMatrix& a, const ComplexMatrix& b,
+			       SparseType &typ);
+extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, const Matrix& b,
+			       SparseType &typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-			       const ComplexMatrix& b);
+			       const ComplexMatrix& b, SparseType &typ);
 
-extern SparseMatrix xleftdiv (const SparseMatrix& a, const SparseMatrix& b);
+extern SparseMatrix xleftdiv (const SparseMatrix& a, const SparseMatrix& b,
+			      SparseType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseMatrix& a, 
-				     const SparseComplexMatrix& b);
+				     const SparseComplexMatrix& b, SparseType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-				     const SparseMatrix& b);
+				     const SparseMatrix& b, SparseType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
-				     const SparseComplexMatrix& b);
+				     const SparseComplexMatrix& b, SparseType &typ);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
