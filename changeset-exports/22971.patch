# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1482949130 18000
#      Wed Dec 28 13:18:50 2016 -0500
# Node ID d244af1d0bc7a21b8927f4cea8e21cd596ef73ac
# Parent  023026207910301014eb80c1aec8b90f2f95c816
use F77_INT instead of octave_idx_type for liboctave Matrix classes

* dMatrix.cc, fMatrix.cc, CMartrix.cc, fCMatrix.cc: Use F77_INT
instead of octave_idx_type for integer data passed to Fortran
subroutines.

diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -754,41 +754,45 @@ ComplexMatrix::inverse (MatrixType &matt
 }
 
 ComplexMatrix
 ComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
                          double& rcon, bool force, bool calc_cond) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
+  F77_INT tmp_info = 0;
+
   F77_XFCN (ztrtri, ZTRTRI,(F77_CONST_CHAR_ARG2 (&uplo, 1),
                             F77_CONST_CHAR_ARG2 (&udiag, 1),
-                            nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, info
+                            nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, tmp_info
                             F77_CHAR_ARG_LEN (1)
                             F77_CHAR_ARG_LEN (1)));
 
+  info = tmp_info;
+
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
-      octave_idx_type ztrcon_info = 0;
+      F77_INT ztrcon_info = 0;
       char job = '1';
 
       OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
       OCTAVE_LOCAL_BUFFER (double, rwork, nr);
 
       F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
@@ -809,80 +813,90 @@ ComplexMatrix::tinverse (MatrixType &mat
 }
 
 ComplexMatrix
 ComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
                          double& rcon, bool force, bool calc_cond) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
-  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-  octave_idx_type *pipvt = ipvt.fortran_vec ();
+  Array<F77_INT> ipvt (dim_vector (nr, 1));
+  F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   Array<Complex> z (dim_vector (1, 1));
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
 
   // Query the optimum work array size.
 
+  F77_INT tmp_info = 0;
+
   F77_XFCN (zgetri, ZGETRI, (nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                             F77_DBLE_CMPLX_ARG (z.fortran_vec ()), lwork, info));
-
-  lwork = static_cast<octave_idx_type> (octave::math::real (z(0)));
+                             F77_DBLE_CMPLX_ARG (z.fortran_vec ()), lwork,
+                             tmp_info));
+
+  info = tmp_info;
+
+  lwork = static_cast<F77_INT> (octave::math::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   Complex *pz = z.fortran_vec ();
 
   info = 0;
+  tmp_info = 0;
 
   // Calculate (always, see bug #45577) the norm of the matrix, for later use.
   double anorm =
     retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
   // and bug #46330, segfault with matrices containing Inf & NaN
   if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
     info = -1;
   else
-    F77_XFCN (zgetrf, ZGETRF, (nc, nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                               info));
+    {
+      F77_XFCN (zgetrf, ZGETRF, (nc, nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                                 tmp_info));
+
+      info = tmp_info;
+    }
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
       // Now calculate the condition number for non-singular matrix.
-      octave_idx_type zgecon_info = 0;
+      F77_INT zgecon_info = 0;
       char job = '1';
       Array<double> rz (dim_vector (2 * nc, 1));
       double *prz = rz.fortran_vec ();
       F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
                                  rcon, F77_DBLE_CMPLX_ARG (pz), prz, zgecon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (zgecon_info != 0)
         info = -1;
     }
 
   if ((info == -1 && ! force) || octave::math::isinf (anorm))
     retval = *this;  // Restore contents.
   else
     {
-      octave_idx_type zgetri_info = 0;
+      F77_INT zgetri_info = 0;
 
       F77_XFCN (zgetri, ZGETRI, (nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
                                  F77_DBLE_CMPLX_ARG (pz), lwork, zgetri_info));
 
       if (zgetri_info != 0)
         info = -1;
     }
 
@@ -1073,27 +1087,28 @@ ComplexMatrix::ifourier2d (void) const
 
 ComplexMatrix
 ComplexMatrix::fourier (void) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -1115,27 +1130,28 @@ ComplexMatrix::fourier (void) const
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -1158,43 +1174,43 @@ ComplexMatrix::ifourier (void) const
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
@@ -1204,98 +1220,98 @@ ComplexMatrix::fourier2d (void) const
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
                                F77_DBLE_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier2d (void) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_DBLE_CMPLX_ARG (pwsave));
     }
 
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
+  for (F77_INT j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
                                F77_DBLE_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
 #endif
 
@@ -1327,18 +1343,18 @@ ComplexMatrix::determinant (MatrixType& 
                             octave_idx_type& info, double& rcon,
                             bool calc_cond) const
 {
   ComplexDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1346,81 +1362,93 @@ ComplexMatrix::determinant (MatrixType& 
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
   else if (typ == MatrixType::Rectangular)
     typ = MatrixType::Full;
 
   if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      for (octave_idx_type i = 0; i < nc; i++)
+      for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       double anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
+      F77_INT tmp_info = 0;
+
       char job = 'L';
       F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                 F77_DBLE_CMPLX_ARG (tmp_data), nr, info
+                                 F77_DBLE_CMPLX_ARG (tmp_data), nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
-                                     rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
+                                     rcon, F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             rcon = 0.0;
 
-          for (octave_idx_type i = 0; i < nc; i++)
+          for (F77_INT i = 0; i < nc; i++)
             retval *= atmp (i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
+      Array<F77_INT> ipvt (dim_vector (nr, 1));
+      F77_INT *pipvt = ipvt.fortran_vec ();
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       info = 0;
 
       // Calculate (always, see bug #45577) the norm of the matrix, for later use.
       double anorm = xnorm (*this, 1);
 
+      F77_INT tmp_info = 0;
+
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (octave::math::isnan (anorm))
         info = -1;
       else
-        F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                                   info));
+        {
+          F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                                   tmp_info));
+
+          info = tmp_info;
+        }
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
           info = -1;
           retval = ComplexDET ();
         }
@@ -1432,28 +1460,30 @@ ComplexMatrix::determinant (MatrixType& 
               char job = '1';
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
-                                         rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
+                                         rcon, F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
                                          F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
             }
 
           if (info != 0)
             {
               info = -1;
               retval = ComplexDET ();
             }
           else
             {
-              for (octave_idx_type i = 0; i < nc; i++)
+              for (F77_INT i = 0; i < nc; i++)
                 {
                   Complex c = atmp(i,i);
                   retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
@@ -1466,18 +1496,18 @@ ComplexMatrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
 ComplexMatrix::rcond (MatrixType &mattype) const
 {
   double rcon = octave::numeric_limits<double>::NaN ();
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<double>::Inf ();
   else
     {
@@ -1485,17 +1515,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
         {
           const Complex *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
@@ -1513,17 +1543,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
             rcon = 0;
         }
       else if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const Complex *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
@@ -1544,17 +1574,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           double anorm = -1.0;
 
           if (typ == MatrixType::Hermitian)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
               char job = 'L';
 
               ComplexMatrix atmp = *this;
               Complex *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
                       row(static_cast<octave_idx_type>(0)).max();
 
@@ -1583,23 +1613,23 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
 
               ComplexMatrix atmp = *this;
               Complex *tmp_data = atmp.fortran_vec ();
 
-              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-              octave_idx_type *pipvt = ipvt.fortran_vec ();
+              Array<F77_INT> ipvt (dim_vector (nr, 1));
+              F77_INT *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                         row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
@@ -1640,78 +1670,86 @@ ComplexMatrix::rcond (MatrixType &mattyp
 ComplexMatrix
 ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      octave_idx_type b_nc = b.cols ();
       rcon = 1.;
       info = 0;
 
       if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const Complex *tmp_data = fortran_vec ();
 
       retval = b;
       Complex *result = retval.fortran_vec ();
 
       char uplo = 'U';
       char trans = get_blas_char (transt);
       char dia = 'N';
 
+      F77_INT tmp_info = 0;
+
       F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&trans, 1),
                                  F77_CONST_CHAR_ARG2 (&dia, 1),
                                  nr, b_nc, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr,
-                                 F77_DBLE_CMPLX_ARG (result), nr, info
+                                 F77_DBLE_CMPLX_ARG (result), nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (calc_cond)
         {
           char norm = '1';
           uplo = 'U';
           dia = 'N';
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr, rcon,
-                                     F77_DBLE_CMPLX_ARG (pz), prz, info
+                                     F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
@@ -1730,78 +1768,86 @@ ComplexMatrix::utsolve (MatrixType &matt
 ComplexMatrix
 ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      octave_idx_type b_nc = b.cols ();
       rcon = 1.;
       info = 0;
 
       if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const Complex *tmp_data = fortran_vec ();
 
       retval = b;
       Complex *result = retval.fortran_vec ();
 
       char uplo = 'L';
       char trans = get_blas_char (transt);
       char dia = 'N';
 
+      F77_INT tmp_info = 0;
+
       F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&trans, 1),
                                  F77_CONST_CHAR_ARG2 (&dia, 1),
                                  nr, b_nc, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr,
-                                 F77_DBLE_CMPLX_ARG (result), nr, info
+                                 F77_DBLE_CMPLX_ARG (result), nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (calc_cond)
         {
           char norm = '1';
           uplo = 'L';
           dia = 'N';
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr, rcon,
-                                     F77_DBLE_CMPLX_ARG (pz), prz, info
+                                     F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
@@ -1820,25 +1866,28 @@ ComplexMatrix::ltsolve (MatrixType &matt
 ComplexMatrix
 ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != nc || nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != nc || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || b.cols () == 0)
-    retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
+  if (nr == 0 || b_nc == 0)
+    retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
@@ -1846,20 +1895,24 @@ ComplexMatrix::fsolve (MatrixType &matty
           info = 0;
           char job = 'L';
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
+          F77_INT tmp_info = 0;
+
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     F77_DBLE_CMPLX_ARG (tmp_data), nr, info
+                                     F77_DBLE_CMPLX_ARG (tmp_data), nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
@@ -1870,19 +1923,21 @@ ComplexMatrix::fsolve (MatrixType &matty
                 {
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
-                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
+                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1894,58 +1949,64 @@ ComplexMatrix::fsolve (MatrixType &matty
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
-
                   F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, F77_DBLE_CMPLX_ARG (tmp_data), nr,
-                                             F77_DBLE_CMPLX_ARG (result), b.rows (), info
+                                             F77_DBLE_CMPLX_ARG (result), b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
                     .max ();
 
+          F77_INT tmp_info = 0;
+
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
-            F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                                       info));
+            {
+              F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                                         tmp_info));
+
+              info = tmp_info;
+            }
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
@@ -1959,19 +2020,21 @@ ComplexMatrix::fsolve (MatrixType &matty
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
-                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
+                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1983,32 +2046,32 @@ ComplexMatrix::fsolve (MatrixType &matty
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
-
                   char job = 'N';
                   F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, F77_DBLE_CMPLX_ARG (tmp_data), nr,
-                                             pipvt, F77_DBLE_CMPLX_ARG (result), b.rows (), info
+                                             pipvt, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
 
       if (octave::math::isinf (anorm))
         {
-          retval = ComplexMatrix (b.rows (), b.cols (), Complex (0, 0));
+          retval = ComplexMatrix (b_nr, b_nc, Complex (0, 0));
           mattype.mark_as_full ();
         }
     }
 
   return retval;
 }
 
 ComplexMatrix
@@ -2355,150 +2418,162 @@ ComplexMatrix::lssolve (const ComplexMat
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nrhs = b.cols ();
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
-
-  if (m != b.rows ())
+  F77_INT nrhs = to_f77_int (b.cols ());
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (m == 0 || n == 0 || b.cols () == 0)
-    retval = ComplexMatrix (n, b.cols (), Complex (0.0, 0.0));
+  if (m == 0 || n == 0 || b_nc == 0)
+    retval = ComplexMatrix (n, b_nc, Complex (0.0, 0.0));
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
         {
           retval = ComplexMatrix (maxmn, nrhs);
 
-          for (octave_idx_type j = 0; j < nrhs; j++)
-            for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT j = 0; j < nrhs; j++)
+            for (F77_INT i = 0; i < m; i++)
               retval.elem (i, j) = b.elem (i, j);
         }
       else
         retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
       Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<Complex> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
-      octave_idx_type mnthr;
+      F77_INT mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
       double anorm = 0.0;
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
+      F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs
                                + std::max ((smlsiz+1)*(smlsiz+1),
                                            n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
                                  F77_DBLE_CMPLX_ARG (pretval), maxmn,
-                                 ps, rcon, rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
-                                 lwork, prwork, piwork, info));
+                                 ps, rcon, tmp_rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
+                                 lwork, prwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
         {
-          octave_idx_type addend = m;
+          F77_INT addend = m;
 
           if (2*m-4 > addend)
             addend = 2*m-4;
 
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
-          const octave_idx_type lworkaround = 4*m + m*m + addend;
+          const F77_INT lworkaround = 4*m + m*m + addend;
 
           if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
-          octave_idx_type lworkaround = 2*m + m*nrhs;
+          F77_INT lworkaround = 2*m + m*nrhs;
 
           if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
+      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       anorm = xnorm (*this, 1);
 
       if (octave::math::isinf (anorm) || octave::math::isnan (anorm))
         {
           rcon = 0.0;
           octave::warn_singular_matrix ();
           retval = Matrix (n, m, 0.0);
         }
       else
         {
           F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data),
                                      m, F77_DBLE_CMPLX_ARG (pretval),
-                                     maxmn, ps, rcon, rank,
+                                     maxmn, ps, rcon, tmp_rank,
                                      F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
-                                     lwork, prwork, piwork, info));
+                                     lwork, prwork, piwork, tmp_info));
+
+          info = tmp_info;
+          rank = tmp_rank;
 
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
 
           retval.resize (n, nrhs);
         }
@@ -2567,101 +2642,112 @@ ComplexMatrix::lssolve (const ComplexCol
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const
 {
   ComplexColumnVector retval;
 
-  octave_idx_type nrhs = 1;
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
-
-  if (m != b.numel ())
+  F77_INT nrhs = 1;
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
+
+  F77_INT b_nel = to_f77_int (b.numel ());
+
+  if (m != b_nel)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (m == 0 || n == 0 || b.cols () == 0)
+  if (m == 0 || n == 0)
     retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
         {
           retval = ComplexColumnVector (maxmn);
 
-          for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
         }
       else
         retval = b;
 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       Complex *pretval = retval.fortran_vec ();
       Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<Complex> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("ZGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
+      F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
                                  F77_DBLE_CMPLX_ARG (pretval), maxmn,
-                                 ps, rcon, rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
-                                 lwork, prwork, piwork, info));
-
-      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
+                                 ps, rcon, tmp_rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
+                                 lwork, prwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
+
+      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
-      rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
+      rwork.resize (dim_vector (static_cast<F77_INT> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
                                  F77_DBLE_CMPLX_ARG (pretval),
-                                 maxmn, ps, rcon, rank,
+                                 maxmn, ps, rcon, tmp_rank,
                                  F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
-                                 prwork, piwork, info));
+                                 prwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
 
@@ -2688,21 +2774,21 @@ operator * (const ComplexColumnVector& a
   return a * tmp;
 }
 
 ComplexMatrix
 operator * (const ComplexColumnVector& v, const ComplexRowVector& a)
 {
   ComplexMatrix retval;
 
-  octave_idx_type len = v.numel ();
+  F77_INT len = to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.numel ();
+      F77_INT a_len = (a.numel ());
 
       retval = ComplexMatrix (len, a_len);
       Complex *c = retval.fortran_vec ();
 
       F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, F77_CONST_DBLE_CMPLX_ARG (v.data ()), len,
                                F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, 0.0, F77_DBLE_CMPLX_ARG (c), len
@@ -3319,21 +3405,21 @@ Sylvester (const ComplexMatrix& a, const
 
   ComplexMatrix ub = bs.unitary_matrix ();
   ComplexMatrix sch_b = bs.schur_matrix ();
 
   ComplexMatrix cx = ua.hermitian () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the solution.
 
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type b_nr = b.rows ();
+  F77_INT a_nr = to_f77_int (a.rows ());
+  F77_INT b_nr = to_f77_int (b.rows ());
 
   double scale;
-  octave_idx_type info;
+  F77_INT info;
 
   Complex *pa = sch_a.fortran_vec ();
   Complex *pb = sch_b.fortran_vec ();
   Complex *px = cx.fortran_vec ();
 
   F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, F77_DBLE_CMPLX_ARG (pa), a_nr, F77_DBLE_CMPLX_ARG (pb),
@@ -3403,30 +3489,30 @@ xgemm (const ComplexMatrix& a, const Com
 {
   ComplexMatrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
   bool cja = transa == blas_conj_trans;
   bool cjb = transb == blas_conj_trans;
 
-  octave_idx_type a_nr = tra ? a.cols () : a.rows ();
-  octave_idx_type a_nc = tra ? a.rows () : a.cols ();
-
-  octave_idx_type b_nr = trb ? b.cols () : b.rows ();
-  octave_idx_type b_nc = trb ? b.rows () : b.cols ();
+  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = ComplexMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      octave_idx_type lda = a.rows ();
+      F77_INT lda = to_f77_int (a.rows ());
 
       // FIXME: looking at the reference BLAS, it appears that it
       // should not be necessary to initialize the output matrix if
       // BETA is 0 in the call to ZHERK, but ATLAS appears to
       // use the result matrix before zeroing the elements.
 
       retval = ComplexMatrix (a_nr, b_nc, 0.0);
       Complex *c = retval.fortran_vec ();
@@ -3435,41 +3521,41 @@ xgemm (const ComplexMatrix& a, const Com
       if (cja || cjb)
         {
           F77_XFCN (zherk, ZHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
-          for (octave_idx_type j = 0; j < a_nr; j++)
-            for (octave_idx_type i = 0; i < j; i++)
+          for (F77_INT j = 0; j < a_nr; j++)
+            for (F77_INT i = 0; i < j; i++)
               retval.xelem (j,i) = octave::math::conj (retval.xelem (i,j));
         }
       else
         {
           F77_XFCN (zsyrk, ZSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
-          for (octave_idx_type j = 0; j < a_nr; j++)
-            for (octave_idx_type i = 0; i < j; i++)
+          for (F77_INT j = 0; j < a_nr; j++)
+            for (F77_INT i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
 
     }
   else
     {
-      octave_idx_type lda = a.rows ();
-      octave_idx_type tda = a.cols ();
-      octave_idx_type ldb = b.rows ();
-      octave_idx_type tdb = b.cols ();
+      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT tda = to_f77_int (a.cols ());
+      F77_INT ldb = to_f77_int (b.rows ());
+      F77_INT tdb = to_f77_int (b.cols ());
 
       retval = ComplexMatrix (a_nr, b_nc, 0.0);
       Complex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -466,45 +466,49 @@ Matrix::inverse (MatrixType &mattype, oc
 }
 
 Matrix
 Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   bool force, bool calc_cond) const
 {
   Matrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
   double *tmp_data = retval.fortran_vec ();
 
+  F77_INT tmp_info = 0;
+
   F77_XFCN (dtrtri, DTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                              F77_CONST_CHAR_ARG2 (&udiag, 1),
-                             nr, tmp_data, nr, info
+                             nr, tmp_data, nr, tmp_info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
+  info = tmp_info;
+
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
-      octave_idx_type dtrcon_info = 0;
+      F77_INT dtrcon_info = 0;
       char job = '1';
 
       OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
+      OCTAVE_LOCAL_BUFFER (F77_INT, iwork, nr);
 
       F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
                                  nr, tmp_data, nr, rcon,
                                  work, iwork, dtrcon_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
@@ -521,76 +525,81 @@ Matrix::tinverse (MatrixType &mattype, o
 }
 
 Matrix
 Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   bool force, bool calc_cond) const
 {
   Matrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
-  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-  octave_idx_type *pipvt = ipvt.fortran_vec ();
+  Array<F77_INT> ipvt (dim_vector (nr, 1));
+  F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
   double *tmp_data = retval.fortran_vec ();
 
   Array<double> z (dim_vector (1, 1));
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
+
+  F77_INT tmp_info = 0;
 
   // Query the optimum work array size.
   F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
-                             z.fortran_vec (), lwork, info));
-
-  lwork = static_cast<octave_idx_type> (z(0));
+                             z.fortran_vec (), lwork, tmp_info));
+
+  lwork = static_cast<F77_INT> (z(0));
   lwork = (lwork < 2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   double *pz = z.fortran_vec ();
 
   info = 0;
+  tmp_info = 0;
 
   // Calculate the norm of the matrix, for later use.
   double anorm = 0;
   if (calc_cond)
     anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
             .max ();
 
-  F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+  F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, tmp_info));
+
+  info = tmp_info;
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
-      octave_idx_type dgecon_info = 0;
+      F77_INT dgecon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       char job = '1';
-      Array<octave_idx_type> iz (dim_vector (nc, 1));
-      octave_idx_type *piz = iz.fortran_vec ();
+      Array<F77_INT> iz (dim_vector (nc, 1));
+      F77_INT *piz = iz.fortran_vec ();
       F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nc, tmp_data, nr, anorm,
                                  rcon, pz, piz, dgecon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (dgecon_info != 0)
         info = -1;
     }
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
   else
     {
-      octave_idx_type dgetri_info = 0;
+      F77_INT dgetri_info = 0;
 
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
                                  pz, lwork, dgetri_info));
 
       if (dgetri_info != 0)
         info = -1;
     }
 
@@ -771,27 +780,28 @@ Matrix::ifourier2d (void) const
 
 ComplexMatrix
 Matrix::fourier (void) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -813,27 +823,28 @@ Matrix::fourier (void) const
 
 ComplexMatrix
 Matrix::ifourier (void) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -856,43 +867,43 @@ Matrix::ifourier (void) const
   return retval;
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
@@ -902,98 +913,98 @@ Matrix::fourier2d (void) const
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
                                F77_DBLE_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier2d (void) const
 {
   ComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
   retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_DBLE_CMPLX_ARG (pwsave));
     }
 
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
+  for (F77_INT j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<Complex> tmp (dim_vector (npts, 1));
   Complex *prow = tmp.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
                                F77_DBLE_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
 #endif
 
@@ -1023,18 +1034,18 @@ DET
 Matrix::determinant (MatrixType& mattype,
                      octave_idx_type& info, double& rcon, bool calc_cond) const
 {
   DET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1042,110 +1053,121 @@ Matrix::determinant (MatrixType& mattype
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
   else if (typ == MatrixType::Rectangular)
     typ = MatrixType::Full;
 
   if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      for (octave_idx_type i = 0; i < nc; i++)
+      for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
+      F77_INT tmp_info = 0;
+
       char job = 'L';
       F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                 tmp_data, nr, info
+                                 tmp_data, nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
           Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, tmp_data, nr, anorm,
-                                     rcon, pz, piz, info
+                                     rcon, pz, piz, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             rcon = 0.0;
 
-          for (octave_idx_type i = 0; i < nc; i++)
+          for (F77_INT i = 0; i < nc; i++)
             retval *= atmp (i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
+      Array<F77_INT> ipvt (dim_vector (nr, 1));
+      F77_INT *pipvt = ipvt.fortran_vec ();
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       info = 0;
+      F77_INT tmp_info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
-      F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+      F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, tmp_info));
+
+      info = tmp_info;
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
           info = -1;
           retval = DET ();
         }
       else
         {
           if (calc_cond)
             {
               // Now calc the condition number for non-singular matrix.
               char job = '1';
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (dim_vector (nc, 1));
-              octave_idx_type *piz = iz.fortran_vec ();
+              Array<F77_INT> iz (dim_vector (nc, 1));
+              F77_INT *piz = iz.fortran_vec ();
 
               F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nc, tmp_data, nr, anorm,
-                                         rcon, pz, piz, info
+                                         rcon, pz, piz, tmp_info
                                          F77_CHAR_ARG_LEN (1)));
             }
 
+          info = tmp_info;
+
           if (info != 0)
             {
               info = -1;
               retval = DET ();
             }
           else
             {
-              for (octave_idx_type i = 0; i < nc; i++)
+              for (F77_INT i = 0; i < nc; i++)
                 {
                   double c = atmp(i,i);
                   retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
@@ -1158,18 +1180,18 @@ Matrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
 Matrix::rcond (MatrixType &mattype) const
 {
   double rcon = octave::numeric_limits<double>::NaN ();
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<double>::Inf ();
   else
     {
@@ -1177,25 +1199,25 @@ Matrix::rcond (MatrixType &mattype) cons
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
         {
           const double *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
           Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
@@ -1205,25 +1227,25 @@ Matrix::rcond (MatrixType &mattype) cons
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const double *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
           Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
@@ -1236,17 +1258,17 @@ Matrix::rcond (MatrixType &mattype) cons
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           double anorm = -1.0;
 
           if (typ == MatrixType::Hermitian)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
               char job = 'L';
 
               Matrix atmp = *this;
               double *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
                       row(static_cast<octave_idx_type>(0)).max();
 
@@ -1259,47 +1281,47 @@ Matrix::rcond (MatrixType &mattype) cons
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else
                 {
                   Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nc, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
 
               Matrix atmp = *this;
               double *tmp_data = atmp.fortran_vec ();
 
-              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-              octave_idx_type *pipvt = ipvt.fortran_vec ();
+              Array<F77_INT> ipvt (dim_vector (nr, 1));
+              F77_INT *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                         row(static_cast<octave_idx_type>(0)).max ();
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (dim_vector (nc, 1));
-              octave_idx_type *piz = iz.fortran_vec ();
+              Array<F77_INT> iz (dim_vector (nc, 1));
+              F77_INT *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
@@ -1325,78 +1347,86 @@ Matrix::rcond (MatrixType &mattype) cons
 
 Matrix
 Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = Matrix (nc, b.cols (), 0.0);
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = Matrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      octave_idx_type b_nc = b.cols ();
       rcon = 1.;
       info = 0;
 
       if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const double *tmp_data = fortran_vec ();
 
       retval = b;
       double *result = retval.fortran_vec ();
 
       char uplo = 'U';
       char trans = get_blas_char (transt);
       char dia = 'N';
 
+      F77_INT tmp_info = 0;
+
       F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&trans, 1),
                                  F77_CONST_CHAR_ARG2 (&dia, 1),
                                  nr, b_nc, tmp_data, nr,
-                                 result, nr, info
+                                 result, nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (calc_cond)
         {
           char norm = '1';
           uplo = 'U';
           dia = 'N';
 
           Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
-                                     pz, piz, info
+                                     pz, piz, tmp_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
@@ -1414,78 +1444,86 @@ Matrix::utsolve (MatrixType &mattype, co
 
 Matrix
 Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = Matrix (nc, b.cols (), 0.0);
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = Matrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      octave_idx_type b_nc = b.cols ();
       rcon = 1.;
       info = 0;
 
       if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const double *tmp_data = fortran_vec ();
 
       retval = b;
       double *result = retval.fortran_vec ();
 
       char uplo = 'L';
       char trans = get_blas_char (transt);
       char dia = 'N';
 
+      F77_INT tmp_info = 0;
+
       F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&trans, 1),
                                  F77_CONST_CHAR_ARG2 (&dia, 1),
                                  nr, b_nc, tmp_data, nr,
-                                 result, nr, info
+                                 result, nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (calc_cond)
         {
           char norm = '1';
           uplo = 'L';
           dia = 'N';
 
           Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
-                                     pz, piz, info
+                                     pz, piz, tmp_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
@@ -1503,18 +1541,18 @@ Matrix::ltsolve (MatrixType &mattype, co
 
 Matrix
 Matrix::fsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
                 bool calc_cond) const
 {
   Matrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
@@ -1529,43 +1567,49 @@ Matrix::fsolve (MatrixType &mattype, con
           info = 0;
           char job = 'L';
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
+          F77_INT tmp_info = 0;
+
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+                                     tmp_data, nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nc, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
-                                             rcon, pz, piz, info
+                                             rcon, pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1577,50 +1621,57 @@ Matrix::fsolve (MatrixType &mattype, con
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
 
                   F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows (), info
+                                             result, b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
-
-          F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
+
+          F77_INT tmp_info = 0;
+
+          F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, tmp_info));
+
+          info = tmp_info;
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
@@ -1634,19 +1685,21 @@ Matrix::fsolve (MatrixType &mattype, con
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm,
-                                             rcon, pz, piz, info
+                                             rcon, pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1658,23 +1711,26 @@ Matrix::fsolve (MatrixType &mattype, con
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
 
                   char job = 'N';
                   F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows (), info
+                                             pipvt, result, b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -2015,144 +2071,156 @@ Matrix::lssolve (const Matrix& b, octave
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
                  octave_idx_type& rank, double &rcon) const
 {
   Matrix retval;
 
-  octave_idx_type nrhs = b.cols ();
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
-
-  if (m != b.rows ())
+  F77_INT nrhs = to_f77_int (b.cols ());
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (m == 0 || n == 0 || b.cols () == 0)
-    retval = Matrix (n, b.cols (), 0.0);
+  if (m == 0 || n == 0 || b_nc == 0)
+    retval = Matrix (n, b_nc, 0.0);
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
       if (m != n)
         {
           retval = Matrix (maxmn, nrhs, 0.0);
 
-          for (octave_idx_type j = 0; j < nrhs; j++)
-            for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT j = 0; j < nrhs; j++)
+            for (F77_INT i = 0; i < m; i++)
               retval.elem (i, j) = b.elem (i, j);
         }
       else
         retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
       Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<double> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
-      octave_idx_type mnthr;
+      F77_INT mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
       double anorm = 0.0;
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
-                                 lwork, piwork, info));
+                                 ps, rcon, tmp_rank, work.fortran_vec (),
+                                 lwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for DGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
         {
-          const octave_idx_type wlalsd
+          const F77_INT wlalsd
             = 9*m + 2*m*smlsiz + 8*m*nlvl + m*nrhs + (smlsiz+1)*(smlsiz+1);
 
-          octave_idx_type addend = m;
+          F77_INT addend = m;
 
           if (2*m-4 > addend)
             addend = 2*m-4;
 
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
           if (wlalsd > addend)
             addend = wlalsd;
 
-          const octave_idx_type lworkaround = 4*m + m*m + addend;
+          const F77_INT lworkaround = 4*m + m*m + addend;
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
-          octave_idx_type lworkaround
+          F77_INT lworkaround
             = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<octave_idx_type> (work(0));
+      lwork = static_cast<F77_INT> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       anorm = xnorm (*this, 1);
 
       if (octave::math::isinf (anorm) || octave::math::isnan (anorm))
         {
           rcon = 0.0;
           octave::warn_singular_matrix ();
           retval = Matrix (n, m, 0.0);
         }
       else
         {
           F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-                                     maxmn, ps, rcon, rank,
+                                     maxmn, ps, rcon, tmp_rank,
                                      work.fortran_vec (), lwork,
-                                     piwork, info));
+                                     piwork, tmp_info));
+
+          info = tmp_info;
+          rank = tmp_rank;
 
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
 
           retval.resize (n, nrhs);
         }
@@ -2223,89 +2291,100 @@ Matrix::lssolve (const ColumnVector& b, 
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info,
                  octave_idx_type& rank, double &rcon) const
 {
   ColumnVector retval;
 
-  octave_idx_type nrhs = 1;
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
-
-  if (m != b.numel ())
+  F77_INT nrhs = 1;
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
+
+  F77_INT b_nel = to_f77_int (b.numel ());
+
+  if (m != b_nel)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = ColumnVector (n, 0.0);
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
         {
           retval = ColumnVector (maxmn, 0.0);
 
-          for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
         }
       else
         retval = b;
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       double *pretval = retval.fortran_vec ();
       Array<double> s (dim_vector (minmn, 1));
       double *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<double> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("DGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
-                                 lwork, piwork, info));
-
-      lwork = static_cast<octave_idx_type> (work(0));
+                                 ps, rcon, tmp_rank, work.fortran_vec (),
+                                 lwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
+
+      lwork = static_cast<F77_INT> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-                                 maxmn, ps, rcon, rank,
+                                 maxmn, ps, rcon, tmp_rank,
                                  work.fortran_vec (), lwork,
-                                 piwork, info));
+                                 piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
         }
@@ -2392,21 +2471,21 @@ Matrix::operator -= (const DiagMatrix& a
 
 // column vector by row vector -> matrix operations
 
 Matrix
 operator * (const ColumnVector& v, const RowVector& a)
 {
   Matrix retval;
 
-  octave_idx_type len = v.numel ();
+  F77_INT len = to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.numel ();
+      F77_INT a_len = to_f77_int (a.numel ());
 
       retval = Matrix (len, a_len);
       double *c = retval.fortran_vec ();
 
       F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -2785,21 +2864,21 @@ Sylvester (const Matrix& a, const Matrix
 
   Matrix ub = bs.unitary_matrix ();
   Matrix sch_b = bs.schur_matrix ();
 
   Matrix cx = ua.transpose () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the solution.
 
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type b_nr = b.rows ();
+  F77_INT a_nr = to_f77_int (a.rows ());
+  F77_INT b_nr = to_f77_int (b.rows ());
 
   double scale;
-  octave_idx_type info;
+  F77_INT info;
 
   double *pa = sch_a.fortran_vec ();
   double *pb = sch_b.fortran_vec ();
   double *px = cx.fortran_vec ();
 
   F77_XFCN (dtrsyl, DTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
@@ -2852,30 +2931,30 @@ Matrix
 xgemm (const Matrix& a, const Matrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   Matrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
 
-  octave_idx_type a_nr = tra ? a.cols () : a.rows ();
-  octave_idx_type a_nc = tra ? a.rows () : a.cols ();
-
-  octave_idx_type b_nr = trb ? b.cols () : b.rows ();
-  octave_idx_type b_nc = trb ? b.rows () : b.cols ();
+  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = Matrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      octave_idx_type lda = a.rows ();
+      F77_INT lda = to_f77_int (a.rows ());
 
       retval = Matrix (a_nr, b_nc);
       double *c = retval.fortran_vec ();
 
       const char ctra = get_blas_trans_arg (tra);
       F77_XFCN (dsyrk, DSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                F77_CONST_CHAR_ARG2 (&ctra, 1),
                                a_nr, a_nc, 1.0,
@@ -2884,20 +2963,20 @@ xgemm (const Matrix& a, const Matrix& b,
                                F77_CHAR_ARG_LEN (1)));
       for (int j = 0; j < a_nr; j++)
         for (int i = 0; i < j; i++)
           retval.xelem (j,i) = retval.xelem (i,j);
 
     }
   else
     {
-      octave_idx_type lda = a.rows ();
-      octave_idx_type tda = a.cols ();
-      octave_idx_type ldb = b.rows ();
-      octave_idx_type tdb = b.cols ();
+      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT tda = to_f77_int (a.cols ());
+      F77_INT ldb = to_f77_int (b.rows ());
+      F77_INT tdb = to_f77_int (b.cols ());
 
       retval = Matrix (a_nr, b_nc);
       double *c = retval.fortran_vec ();
 
       if (b_nc == 1)
         {
           if (a_nr == 1)
             F77_FUNC (xddot, XDDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -757,41 +757,45 @@ FloatComplexMatrix::inverse (MatrixType 
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
                               float& rcon, bool force, bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
+  F77_INT tmp_info = 0;
+
   F77_XFCN (ctrtri, CTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                              F77_CONST_CHAR_ARG2 (&udiag, 1),
-                             nr, F77_CMPLX_ARG (tmp_data), nr, info
+                             nr, F77_CMPLX_ARG (tmp_data), nr, tmp_info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
+  info = tmp_info;
+
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
-      octave_idx_type ztrcon_info = 0;
+      F77_INT ztrcon_info = 0;
       char job = '1';
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
       OCTAVE_LOCAL_BUFFER (float, rwork, nr);
 
       F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
@@ -812,79 +816,89 @@ FloatComplexMatrix::tinverse (MatrixType
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
                               float& rcon, bool force, bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
-  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-  octave_idx_type *pipvt = ipvt.fortran_vec ();
+  Array<F77_INT> ipvt (dim_vector (nr, 1));
+  F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   Array<FloatComplex> z (dim_vector (1, 1));
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
 
   // Query the optimum work array size.
 
+  F77_INT tmp_info = 0;
+
   F77_XFCN (cgetri, CGETRI, (nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
-                             F77_CMPLX_ARG (z.fortran_vec ()), lwork, info));
-
-  lwork = static_cast<octave_idx_type> (octave::math::real (z(0)));
+                             F77_CMPLX_ARG (z.fortran_vec ()), lwork,
+                             tmp_info));
+
+  info = tmp_info;
+
+  lwork = static_cast<F77_INT> (octave::math::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   FloatComplex *pz = z.fortran_vec ();
 
   info = 0;
+  tmp_info = 0;
 
   // Calculate (always, see bug #45577) the norm of the matrix, for later use.
   float anorm =
     retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
   // and bug #46330, segfault with matrices containing Inf & NaN
   if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
     info = -1;
   else
-    F77_XFCN (cgetrf, CGETRF, (nc, nc, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
+    {
+      F77_XFCN (cgetrf, CGETRF, (nc, nc, F77_CMPLX_ARG (tmp_data), nr, pipvt, tmp_info));
+
+      info = tmp_info;
+    }
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
       // Now calculate the condition number for non-singular matrix.
-      octave_idx_type zgecon_info = 0;
+      F77_INT zgecon_info = 0;
       char job = '1';
       Array<float> rz (dim_vector (2 * nc, 1));
       float *prz = rz.fortran_vec ();
       F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
                                  rcon, F77_CMPLX_ARG (pz), prz, zgecon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (zgecon_info != 0)
         info = -1;
     }
 
   if ((info == -1 && ! force) || octave::math::isinf (anorm))
     retval = *this;  // Restore contents.
   else
     {
-      octave_idx_type zgetri_info = 0;
+      F77_INT zgetri_info = 0;
 
       F77_XFCN (cgetri, CGETRI, (nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
                                  F77_CMPLX_ARG (pz), lwork, zgetri_info));
 
       if (zgetri_info != 0)
         info = -1;
     }
 
@@ -1075,27 +1089,28 @@ FloatComplexMatrix::ifourier2d (void) co
 
 FloatComplexMatrix
 FloatComplexMatrix::fourier (void) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -1117,27 +1132,28 @@ FloatComplexMatrix::fourier (void) const
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier (void) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -1160,43 +1176,43 @@ FloatComplexMatrix::ifourier (void) cons
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
@@ -1206,96 +1222,96 @@ FloatComplexMatrix::fourier2d (void) con
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_CMPLX_ARG (pwsave));
     }
 
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
+  for (F77_INT j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
     }
 
   return retval;
 }
 
 #endif
 
@@ -1327,18 +1343,18 @@ FloatComplexMatrix::determinant (MatrixT
                                  octave_idx_type& info, float& rcon,
                                  bool calc_cond) const
 {
   FloatComplexDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1346,80 +1362,92 @@ FloatComplexMatrix::determinant (MatrixT
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
   else if (typ == MatrixType::Rectangular)
     typ = MatrixType::Full;
 
   if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      for (octave_idx_type i = 0; i < nc; i++)
+      for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       float anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
+      F77_INT tmp_info = 0;
+
       char job = 'L';
       F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                 F77_CMPLX_ARG (tmp_data), nr, info
+                                 F77_CMPLX_ARG (tmp_data), nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, F77_CMPLX_ARG (tmp_data), nr, anorm,
-                                     rcon, F77_CMPLX_ARG (pz), prz, info
+                                     rcon, F77_CMPLX_ARG (pz), prz, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             rcon = 0.0;
 
-          for (octave_idx_type i = 0; i < nc; i++)
+          for (F77_INT i = 0; i < nc; i++)
             retval *= atmp (i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
+      Array<F77_INT> ipvt (dim_vector (nr, 1));
+      F77_INT *pipvt = ipvt.fortran_vec ();
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       info = 0;
 
       // Calculate (always, see bug #45577) the norm of the matrix, for later use.
       float anorm = xnorm (*this, 1);
 
+      F77_INT tmp_info = 0;
+
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (octave::math::isnan (anorm))
         info = -1;
       else
-        F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
+        {
+          F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, tmp_info));
+
+          info = tmp_info;
+        }
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
           info = -1;
           retval = FloatComplexDET ();
         }
@@ -1431,28 +1459,30 @@ FloatComplexMatrix::determinant (MatrixT
               char job = '1';
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
-                                         rcon, F77_CMPLX_ARG (pz), prz, info
+                                         rcon, F77_CMPLX_ARG (pz), prz, tmp_info
                                          F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
             }
 
           if (info != 0)
             {
               info = -1;
               retval = FloatComplexDET ();
             }
           else
             {
-              for (octave_idx_type i = 0; i < nc; i++)
+              for (F77_INT i = 0; i < nc; i++)
                 {
                   FloatComplex c = atmp(i,i);
                   retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
@@ -1465,18 +1495,18 @@ FloatComplexMatrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
 FloatComplexMatrix::rcond (MatrixType &mattype) const
 {
   float rcon = octave::numeric_limits<float>::NaN ();
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<float>::Inf ();
   else
     {
@@ -1484,17 +1514,17 @@ FloatComplexMatrix::rcond (MatrixType &m
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
         {
           const FloatComplex *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
@@ -1512,17 +1542,17 @@ FloatComplexMatrix::rcond (MatrixType &m
             rcon = 0;
         }
       else if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const FloatComplex *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
@@ -1543,17 +1573,17 @@ FloatComplexMatrix::rcond (MatrixType &m
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           float anorm = -1.0;
 
           if (typ == MatrixType::Hermitian)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
               char job = 'L';
 
               FloatComplexMatrix atmp = *this;
               FloatComplex *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
                       row(static_cast<octave_idx_type>(0)).max();
 
@@ -1582,23 +1612,23 @@ FloatComplexMatrix::rcond (MatrixType &m
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
 
               FloatComplexMatrix atmp = *this;
               FloatComplex *tmp_data = atmp.fortran_vec ();
 
-              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-              octave_idx_type *pipvt = ipvt.fortran_vec ();
+              Array<F77_INT> ipvt (dim_vector (nr, 1));
+              F77_INT *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                         row(static_cast<octave_idx_type>(0)).max ();
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
@@ -1638,32 +1668,34 @@ FloatComplexMatrix::rcond (MatrixType &m
 FloatComplexMatrix
 FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler,
                              bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
-          octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
@@ -1671,45 +1703,51 @@ FloatComplexMatrix::utsolve (MatrixType 
 
               retval = b;
               FloatComplex *result = retval.fortran_vec ();
 
               char uplo = 'U';
               char trans = get_blas_char (transt);
               char dia = 'N';
 
+              F77_INT tmp_info = 0;
+
               F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                          F77_CONST_CHAR_ARG2 (&trans, 1),
                                          F77_CONST_CHAR_ARG2 (&dia, 1),
                                          nr, b_nc, F77_CONST_CMPLX_ARG (tmp_data), nr,
-                                         F77_CMPLX_ARG (result), nr, info
+                                         F77_CMPLX_ARG (result), nr, tmp_info
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)));
 
+              info = tmp_info;
+
               if (calc_cond)
                 {
                   char norm = '1';
                   uplo = 'U';
                   dia = 'N';
 
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                              F77_CONST_CHAR_ARG2 (&uplo, 1),
                                              F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, F77_CONST_CMPLX_ARG (tmp_data), nr, rcon,
-                                             F77_CMPLX_ARG (pz), prz, info
+                                             F77_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1732,32 +1770,34 @@ FloatComplexMatrix::utsolve (MatrixType 
 FloatComplexMatrix
 FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler,
                              bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
-          octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
@@ -1765,45 +1805,51 @@ FloatComplexMatrix::ltsolve (MatrixType 
 
               retval = b;
               FloatComplex *result = retval.fortran_vec ();
 
               char uplo = 'L';
               char trans = get_blas_char (transt);
               char dia = 'N';
 
+              F77_INT tmp_info = 0;
+
               F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                          F77_CONST_CHAR_ARG2 (&trans, 1),
                                          F77_CONST_CHAR_ARG2 (&dia, 1),
                                          nr, b_nc, F77_CONST_CMPLX_ARG (tmp_data), nr,
-                                         F77_CMPLX_ARG (result), nr, info
+                                         F77_CMPLX_ARG (result), nr, tmp_info
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)));
 
+              info = tmp_info;
+
               if (calc_cond)
                 {
                   char norm = '1';
                   uplo = 'L';
                   dia = 'N';
 
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                              F77_CONST_CHAR_ARG2 (&uplo, 1),
                                              F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, F77_CONST_CMPLX_ARG (tmp_data), nr, rcon,
-                                             F77_CMPLX_ARG (pz), prz, info
+                                             F77_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1826,25 +1872,28 @@ FloatComplexMatrix::ltsolve (MatrixType 
 FloatComplexMatrix
 FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon,
                             solve_singularity_handler sing_handler,
                             bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != nc || nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != nc || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || b.cols () == 0)
-    retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
+  if (nr == 0 || b_nc == 0)
+    retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
@@ -1852,20 +1901,24 @@ FloatComplexMatrix::fsolve (MatrixType &
           info = 0;
           char job = 'L';
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
+          F77_INT tmp_info = 0;
+
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     F77_CMPLX_ARG (tmp_data), nr, info
+                                     F77_CMPLX_ARG (tmp_data), nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
@@ -1876,19 +1929,21 @@ FloatComplexMatrix::fsolve (MatrixType &
                 {
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, F77_CMPLX_ARG (tmp_data), nr, anorm,
-                                             rcon, F77_CMPLX_ARG (pz), prz, info
+                                             rcon, F77_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1900,57 +1955,63 @@ FloatComplexMatrix::fsolve (MatrixType &
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
-
                   F77_XFCN (cpotrs, CPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, F77_CMPLX_ARG (tmp_data), nr,
-                                             F77_CMPLX_ARG (result), b.rows (), info
+                                             F77_CMPLX_ARG (result), b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
                     .max ();
 
+          F77_INT tmp_info = 0;
+
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
-            F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
+            {
+              F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, tmp_info));
+
+              info = tmp_info;
+            }
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
@@ -1964,19 +2025,21 @@ FloatComplexMatrix::fsolve (MatrixType &
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
-                                             rcon, F77_CMPLX_ARG (pz), prz, info
+                                             rcon, F77_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1988,32 +2051,32 @@ FloatComplexMatrix::fsolve (MatrixType &
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
-
                   char job = 'N';
                   F77_XFCN (cgetrs, CGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, F77_CMPLX_ARG (tmp_data), nr,
-                                             pipvt, F77_CMPLX_ARG (result), b.rows (), info
+                                             pipvt, F77_CMPLX_ARG (result), b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
 
       if (octave::math::isinf (anorm))
         {
-          retval = FloatComplexMatrix (b.rows (), b.cols (),
+          retval = FloatComplexMatrix (b_nr, b_nc,
                                        FloatComplex (0, 0));
           mattype.mark_as_full ();
         }
     }
 
   return retval;
 }
 
@@ -2372,150 +2435,162 @@ FloatComplexMatrix::lssolve (const Float
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                              octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nrhs = b.cols ();
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
-
-  if (m != b.rows ())
+  F77_INT nrhs = to_f77_int (b.cols ());
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (m == 0 || n == 0 || b.cols () == 0)
-    retval = FloatComplexMatrix (n, b.cols (), FloatComplex (0.0, 0.0));
+  if (m == 0 || n == 0 || b_nc == 0)
+    retval = FloatComplexMatrix (n, b_nc, FloatComplex (0.0, 0.0));
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
         {
           retval = FloatComplexMatrix (maxmn, nrhs);
 
-          for (octave_idx_type j = 0; j < nrhs; j++)
-            for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT j = 0; j < nrhs; j++)
+            for (F77_INT i = 0; i < m; i++)
               retval.elem (i, j) = b.elem (i, j);
         }
       else
         retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
       Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<FloatComplex> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
-      octave_idx_type mnthr;
+      F77_INT mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
       float anorm = 0.0;
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
+      F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs
                                + std::max ((smlsiz+1)*(smlsiz+1),
                                            n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
                                  F77_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, rank, F77_CMPLX_ARG (work.fortran_vec ()),
-                                 lwork, prwork, piwork, info));
+                                 lwork, prwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
         {
-          octave_idx_type addend = m;
+          F77_INT addend = m;
 
           if (2*m-4 > addend)
             addend = 2*m-4;
 
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
-          const octave_idx_type lworkaround = 4*m + m*m + addend;
+          const F77_INT lworkaround = 4*m + m*m + addend;
 
           if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
-          octave_idx_type lworkaround = 2*m + m*nrhs;
+          F77_INT lworkaround = 2*m + m*nrhs;
 
           if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
+      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       anorm = xnorm (*this, 1);
 
       if (octave::math::isinf (anorm) || octave::math::isnan (anorm))
         {
           rcon = 0.0;
           octave::warn_singular_matrix ();
           retval = Matrix (n, m, 0.0);
         }
       else
         {
           F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data),
                                      m, F77_CMPLX_ARG (pretval),
-                                     maxmn, ps, rcon, rank,
+                                     maxmn, ps, rcon, tmp_rank,
                                      F77_CMPLX_ARG (work.fortran_vec ()),
-                                     lwork, prwork, piwork, info));
+                                     lwork, prwork, piwork, tmp_info));
+
+          info = tmp_info;
+          rank = tmp_rank;
 
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
 
           retval.resize (n, nrhs);
         }
@@ -2587,101 +2662,112 @@ FloatComplexMatrix::lssolve (const Float
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b,
                              octave_idx_type& info,
                              octave_idx_type& rank, float& rcon) const
 {
   FloatComplexColumnVector retval;
 
-  octave_idx_type nrhs = 1;
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
-
-  if (m != b.numel ())
+  F77_INT nrhs = 1;
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
+
+  F77_INT b_nel = to_f77_int (b.numel ());
+
+  if (m != b_nel)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (m == 0 || n == 0 || b.cols () == 0)
+  if (m == 0 || n == 0)
     retval = FloatComplexColumnVector (n, FloatComplex (0.0, 0.0));
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
         {
           retval = FloatComplexColumnVector (maxmn);
 
-          for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
         }
       else
         retval = b;
 
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       FloatComplex *pretval = retval.fortran_vec ();
       Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask ZGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<FloatComplex> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("CGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
+      F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
                                  F77_CMPLX_ARG (pretval), maxmn,
-                                 ps, rcon, rank, F77_CMPLX_ARG (work.fortran_vec ()),
-                                 lwork, prwork, piwork, info));
-
-      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
+                                 ps, rcon, tmp_rank, F77_CMPLX_ARG (work.fortran_vec ()),
+                                 lwork, prwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
+
+      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
-      rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
+      rwork.resize (dim_vector (static_cast<F77_INT> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
                                  F77_CMPLX_ARG (pretval),
-                                 maxmn, ps, rcon, rank,
+                                 maxmn, ps, rcon, tmp_rank,
                                  F77_CMPLX_ARG (work.fortran_vec ()), lwork,
-                                 prwork, piwork, info));
+                                 prwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
 
@@ -2708,21 +2794,21 @@ operator * (const FloatComplexColumnVect
   return a * tmp;
 }
 
 FloatComplexMatrix
 operator * (const FloatComplexColumnVector& v, const FloatComplexRowVector& a)
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type len = v.numel ();
+  F77_INT len = to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.numel ();
+      F77_INT a_len = to_f77_int (a.numel ());
 
       retval = FloatComplexMatrix (len, a_len);
       FloatComplex *c = retval.fortran_vec ();
 
       F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, F77_CONST_CMPLX_ARG (v.data ()), len,
                                F77_CONST_CMPLX_ARG (a.data ()), 1, 0.0, F77_CMPLX_ARG (c), len
@@ -2733,18 +2819,18 @@ operator * (const FloatComplexColumnVect
   return retval;
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 FloatComplexMatrix&
 FloatComplexMatrix::operator += (const FloatDiagMatrix& a)
 {
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = rows ();
+  F77_INT nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     octave::err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
@@ -3341,21 +3427,21 @@ Sylvester (const FloatComplexMatrix& a, 
   FloatComplexMatrix ub = bs.unitary_matrix ();
   FloatComplexMatrix sch_b = bs.schur_matrix ();
 
   FloatComplexMatrix cx = ua.hermitian () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type b_nr = b.rows ();
+  F77_INT a_nr = to_f77_int (a.rows ());
+  F77_INT b_nr = to_f77_int (b.rows ());
 
   float scale;
-  octave_idx_type info;
+  F77_INT info;
 
   FloatComplex *pa = sch_a.fortran_vec ();
   FloatComplex *pb = sch_b.fortran_vec ();
   FloatComplex *px = cx.fortran_vec ();
 
   F77_XFCN (ctrsyl, CTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, F77_CMPLX_ARG (pa), a_nr, F77_CMPLX_ARG (pb),
@@ -3425,30 +3511,30 @@ xgemm (const FloatComplexMatrix& a, cons
 {
   FloatComplexMatrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
   bool cja = transa == blas_conj_trans;
   bool cjb = transb == blas_conj_trans;
 
-  octave_idx_type a_nr = tra ? a.cols () : a.rows ();
-  octave_idx_type a_nc = tra ? a.rows () : a.cols ();
-
-  octave_idx_type b_nr = trb ? b.cols () : b.rows ();
-  octave_idx_type b_nc = trb ? b.rows () : b.cols ();
+  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      octave_idx_type lda = a.rows ();
+      F77_INT lda = to_f77_int (a.rows ());
 
       // FIXME: looking at the reference BLAS, it appears that it
       // should not be necessary to initialize the output matrix if
       // BETA is 0 in the call to CHERK, but ATLAS appears to
       // use the result matrix before zeroing the elements.
 
       retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       FloatComplex *c = retval.fortran_vec ();
@@ -3457,41 +3543,41 @@ xgemm (const FloatComplexMatrix& a, cons
       if (cja || cjb)
         {
           F77_XFCN (cherk, CHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_CMPLX_ARG (a.data ()), lda, 0.0, F77_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
-          for (octave_idx_type j = 0; j < a_nr; j++)
-            for (octave_idx_type i = 0; i < j; i++)
+          for (F77_INT j = 0; j < a_nr; j++)
+            for (F77_INT i = 0; i < j; i++)
               retval.xelem (j,i) = octave::math::conj (retval.xelem (i,j));
         }
       else
         {
           F77_XFCN (csyrk, CSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_CMPLX_ARG (a.data ()), lda, 0.0, F77_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
-          for (octave_idx_type j = 0; j < a_nr; j++)
-            for (octave_idx_type i = 0; i < j; i++)
+          for (F77_INT j = 0; j < a_nr; j++)
+            for (F77_INT i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
 
     }
   else
     {
-      octave_idx_type lda = a.rows ();
-      octave_idx_type tda = a.cols ();
-      octave_idx_type ldb = b.rows ();
-      octave_idx_type tdb = b.cols ();
+      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT tda = to_f77_int (a.cols ());
+      F77_INT ldb = to_f77_int (b.rows ());
+      F77_INT tdb = to_f77_int (b.cols ());
 
       retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       FloatComplex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -472,45 +472,49 @@ FloatMatrix::inverse (MatrixType &mattyp
 }
 
 FloatMatrix
 FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                        bool force, bool calc_cond) const
 {
   FloatMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
   float *tmp_data = retval.fortran_vec ();
 
+  F77_INT tmp_info = 0;
+
   F77_XFCN (strtri, STRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                              F77_CONST_CHAR_ARG2 (&udiag, 1),
-                             nr, tmp_data, nr, info
+                             nr, tmp_data, nr, tmp_info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
+  info = tmp_info;
+
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
-      octave_idx_type dtrcon_info = 0;
+      F77_INT dtrcon_info = 0;
       char job = '1';
 
       OCTAVE_LOCAL_BUFFER (float, work, 3 * nr);
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
+      OCTAVE_LOCAL_BUFFER (F77_INT, iwork, nr);
 
       F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
                                  nr, tmp_data, nr, rcon,
                                  work, iwork, dtrcon_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
@@ -527,76 +531,82 @@ FloatMatrix::tinverse (MatrixType &matty
 }
 
 FloatMatrix
 FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                        bool force, bool calc_cond) const
 {
   FloatMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
-  Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-  octave_idx_type *pipvt = ipvt.fortran_vec ();
+  Array<F77_INT> ipvt (dim_vector (nr, 1));
+  F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
   float *tmp_data = retval.fortran_vec ();
 
   Array<float> z(dim_vector (1, 1));
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
+
+  F77_INT tmp_info = 0;
 
   // Query the optimum work array size.
   F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
-                             z.fortran_vec (), lwork, info));
-
-  lwork = static_cast<octave_idx_type> (z(0));
+                             z.fortran_vec (), lwork, tmp_info));
+
+  info = tmp_info;
+
+  lwork = static_cast<F77_INT> (z(0));
   lwork = (lwork < 2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   float *pz = z.fortran_vec ();
 
   info = 0;
 
   // Calculate the norm of the matrix, for later use.
   float anorm = 0;
   if (calc_cond)
     anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
             .max ();
 
-  F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+  F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, tmp_info));
+
+  info = tmp_info;
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
-      octave_idx_type dgecon_info = 0;
+      F77_INT dgecon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       char job = '1';
-      Array<octave_idx_type> iz (dim_vector (nc, 1));
-      octave_idx_type *piz = iz.fortran_vec ();
+      Array<F77_INT> iz (dim_vector (nc, 1));
+      F77_INT *piz = iz.fortran_vec ();
       F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nc, tmp_data, nr, anorm,
                                  rcon, pz, piz, dgecon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (dgecon_info != 0)
         info = -1;
     }
 
   if (info == -1 && ! force)
     retval = *this; // Restore matrix contents.
   else
     {
-      octave_idx_type dgetri_info = 0;
+      F77_INT dgetri_info = 0;
 
       F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
                                  pz, lwork, dgetri_info));
 
       if (dgetri_info != 0)
         info = -1;
     }
 
@@ -777,27 +787,28 @@ FloatMatrix::ifourier2d (void) const
 
 FloatComplexMatrix
 FloatMatrix::fourier (void) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -819,27 +830,28 @@ FloatMatrix::fourier (void) const
 
 FloatComplexMatrix
 FloatMatrix::ifourier (void) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  octave_idx_type nsamples;
+
+  F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = nr > nc ? nr : nc;
+      npts = to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = nr;
+      npts = F77_INT (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -862,43 +874,43 @@ FloatMatrix::ifourier (void) const
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::fourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
@@ -908,96 +920,96 @@ FloatMatrix::fourier2d (void) const
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  octave_idx_type npts, nsamples;
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
   else
     {
       npts = nr;
       nsamples = nc;
     }
 
-  octave_idx_type nn = 4*npts+15;
+  F77_INT nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
   retval = FloatComplexMatrix (*this);
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
                                F77_CMPLX_ARG (pwsave));
     }
 
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
+  for (F77_INT j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
 
   Array<FloatComplex> tmp (dim_vector (npts, 1));
   FloatComplex *prow = tmp.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
-  for (octave_idx_type j = 0; j < nsamples; j++)
+  for (F77_INT j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
       F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
 
-      for (octave_idx_type i = 0; i < npts; i++)
+      for (F77_INT i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
     }
 
   return retval;
 }
 
 #endif
 
@@ -1029,18 +1041,18 @@ FloatMatrix::determinant (MatrixType& ma
                           octave_idx_type& info, float& rcon,
                           bool calc_cond) const
 {
   FloatDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1048,110 +1060,121 @@ FloatMatrix::determinant (MatrixType& ma
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
   else if (typ == MatrixType::Rectangular)
     typ = MatrixType::Full;
 
   if (typ == MatrixType::Lower || typ == MatrixType::Upper)
     {
-      for (octave_idx_type i = 0; i < nc; i++)
+      for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
+      F77_INT tmp_info = 0;
+
       char job = 'L';
       F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                 tmp_data, nr, info
+                                 tmp_data, nr, tmp_info
                                  F77_CHAR_ARG_LEN (1)));
 
+      info = tmp_info;
+
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
           Array<float> z (dim_vector (3 * nc, 1));
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, tmp_data, nr, anorm,
-                                     rcon, pz, piz, info
+                                     rcon, pz, piz, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           if (info != 0)
             rcon = 0.0;
 
-          for (octave_idx_type i = 0; i < nc; i++)
+          for (F77_INT i = 0; i < nc; i++)
             retval *= atmp (i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
     {
-      Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-      octave_idx_type *pipvt = ipvt.fortran_vec ();
+      Array<F77_INT> ipvt (dim_vector (nr, 1));
+      F77_INT *pipvt = ipvt.fortran_vec ();
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       info = 0;
+      F77_INT tmp_info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
-      F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+      F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, tmp_info));
+
+      info = tmp_info;
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
           info = -1;
           retval = FloatDET ();
         }
       else
         {
           if (calc_cond)
             {
               // Now calc the condition number for non-singular matrix.
               char job = '1';
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (dim_vector (nc, 1));
-              octave_idx_type *piz = iz.fortran_vec ();
+              Array<F77_INT> iz (dim_vector (nc, 1));
+              F77_INT *piz = iz.fortran_vec ();
 
               F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nc, tmp_data, nr, anorm,
-                                         rcon, pz, piz, info
+                                         rcon, pz, piz, tmp_info
                                          F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
             }
 
           if (info != 0)
             {
               info = -1;
               retval = FloatDET ();
             }
           else
             {
-              for (octave_idx_type i = 0; i < nc; i++)
+              for (F77_INT i = 0; i < nc; i++)
                 {
                   float c = atmp(i,i);
                   retval *= (ipvt(i) != (i+1)) ? -c : c;
                 }
             }
         }
     }
 
@@ -1164,18 +1187,18 @@ FloatMatrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
 FloatMatrix::rcond (MatrixType &mattype) const
 {
   float rcon = octave::numeric_limits<float>::NaN ();
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<float>::Inf ();
   else
     {
@@ -1183,25 +1206,25 @@ FloatMatrix::rcond (MatrixType &mattype)
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
       if (typ == MatrixType::Upper)
         {
           const float *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'U';
           char dia = 'N';
 
           Array<float> z (dim_vector (3 * nc, 1));
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
@@ -1211,25 +1234,25 @@ FloatMatrix::rcond (MatrixType &mattype)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const float *tmp_data = fortran_vec ();
-          octave_idx_type info = 0;
+          F77_INT info = 0;
           char norm = '1';
           char uplo = 'L';
           char dia = 'N';
 
           Array<float> z (dim_vector (3 * nc, 1));
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
 
           F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
@@ -1242,17 +1265,17 @@ FloatMatrix::rcond (MatrixType &mattype)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           float anorm = -1.0;
 
           if (typ == MatrixType::Hermitian)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
               char job = 'L';
 
               FloatMatrix atmp = *this;
               float *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
                       row(static_cast<octave_idx_type>(0)).max();
 
@@ -1265,47 +1288,47 @@ FloatMatrix::rcond (MatrixType &mattype)
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
               else
                 {
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nc, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
-              octave_idx_type info = 0;
+              F77_INT info = 0;
 
               FloatMatrix atmp = *this;
               float *tmp_data = atmp.fortran_vec ();
 
-              Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-              octave_idx_type *pipvt = ipvt.fortran_vec ();
+              Array<F77_INT> ipvt (dim_vector (nr, 1));
+              F77_INT *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                         row(static_cast<octave_idx_type>(0)).max ();
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
-              Array<octave_idx_type> iz (dim_vector (nc, 1));
-              octave_idx_type *piz = iz.fortran_vec ();
+              Array<F77_INT> iz (dim_vector (nc, 1));
+              F77_INT *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
@@ -1332,32 +1355,34 @@ FloatMatrix::rcond (MatrixType &mattype)
 FloatMatrix
 FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b,
                       octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = FloatMatrix (nc, b.cols (), 0.0);
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = FloatMatrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
-          octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
@@ -1365,45 +1390,51 @@ FloatMatrix::utsolve (MatrixType &mattyp
 
               retval = b;
               float *result = retval.fortran_vec ();
 
               char uplo = 'U';
               char trans = get_blas_char (transt);
               char dia = 'N';
 
+              F77_INT tmp_info = 0;
+
               F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                          F77_CONST_CHAR_ARG2 (&trans, 1),
                                          F77_CONST_CHAR_ARG2 (&dia, 1),
                                          nr, b_nc, tmp_data, nr,
-                                         result, nr, info
+                                         result, nr, tmp_info
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)));
 
+              info = tmp_info;
+
               if (calc_cond)
                 {
                   char norm = '1';
                   uplo = 'U';
                   dia = 'N';
 
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nc, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                              F77_CONST_CHAR_ARG2 (&uplo, 1),
                                              F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
-                                             pz, piz, info
+                                             pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1427,32 +1458,34 @@ FloatMatrix::utsolve (MatrixType &mattyp
 FloatMatrix
 FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b,
                       octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || nc == 0 || b.cols () == 0)
-    retval = FloatMatrix (nc, b.cols (), 0.0);
+  if (nr == 0 || nc == 0 || b_nc == 0)
+    retval = FloatMatrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
-          octave_idx_type b_nc = b.cols ();
           rcon = 1.;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
@@ -1460,45 +1493,51 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 
               retval = b;
               float *result = retval.fortran_vec ();
 
               char uplo = 'L';
               char trans = get_blas_char (transt);
               char dia = 'N';
 
+              F77_INT tmp_info = 0;
+
               F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                          F77_CONST_CHAR_ARG2 (&trans, 1),
                                          F77_CONST_CHAR_ARG2 (&dia, 1),
                                          nr, b_nc, tmp_data, nr,
-                                         result, nr, info
+                                         result, nr, tmp_info
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)));
 
+              info = tmp_info;
+
               if (calc_cond)
                 {
                   char norm = '1';
                   uplo = 'L';
                   dia = 'N';
 
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nc, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                              F77_CONST_CHAR_ARG2 (&uplo, 1),
                                              F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
-                                             pz, piz, info
+                                             pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1521,25 +1560,28 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 FloatMatrix
 FloatMatrix::fsolve (MatrixType &mattype, const FloatMatrix& b,
                      octave_idx_type& info,
                      float& rcon, solve_singularity_handler sing_handler,
                      bool calc_cond) const
 {
   FloatMatrix retval;
 
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  if (nr != nc || nr != b.rows ())
+  F77_INT nr = to_f77_int (rows ());
+  F77_INT nc = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (nr != nc || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (nr == 0 || b.cols () == 0)
-    retval = FloatMatrix (nc, b.cols (), 0.0);
+  if (nr == 0 || b_nc == 0)
+    retval = FloatMatrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
@@ -1547,43 +1589,49 @@ FloatMatrix::fsolve (MatrixType &mattype
           info = 0;
           char job = 'L';
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
+          F77_INT tmp_info = 0;
+
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+                                     tmp_data, nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
+          info = tmp_info;
+
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               if (calc_cond)
                 {
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nc, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nc, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
-                                             rcon, pz, piz, info
+                                             rcon, pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1595,50 +1643,54 @@ FloatMatrix::fsolve (MatrixType &mattype
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
-
                   F77_XFCN (spotrs, SPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows (), info
+                                             result, b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
-          Array<octave_idx_type> iz (dim_vector (nc, 1));
-          octave_idx_type *piz = iz.fortran_vec ();
-
-          F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+          Array<F77_INT> iz (dim_vector (nc, 1));
+          F77_INT *piz = iz.fortran_vec ();
+
+          F77_INT tmp_info = 0;
+
+          F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, tmp_info));
+
+          info = tmp_info;
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
@@ -1652,19 +1704,21 @@ FloatMatrix::fsolve (MatrixType &mattype
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm,
-                                             rcon, pz, piz, info
+                                             rcon, pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
+                  info = tmp_info;
+
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
@@ -1676,23 +1730,23 @@ FloatMatrix::fsolve (MatrixType &mattype
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
-
                   char job = 'N';
                   F77_XFCN (sgetrs, SGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows (), info
+                                             pipvt, result, b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
+
+                  info = tmp_info;
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -2042,144 +2096,156 @@ FloatMatrix::lssolve (const FloatMatrix&
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
                       octave_idx_type& rank, float &rcon) const
 {
   FloatMatrix retval;
 
-  octave_idx_type nrhs = b.cols ();
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
-
-  if (m != b.rows ())
+  F77_INT nrhs = to_f77_int (b.cols ());
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
+
+  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
-  if (m == 0 || n == 0 || b.cols () == 0)
-    retval = FloatMatrix (n, b.cols (), 0.0);
+  if (m == 0 || n == 0 || b_nc == 0)
+    retval = FloatMatrix (n, b_nc, 0.0);
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
       if (m != n)
         {
           retval = FloatMatrix (maxmn, nrhs, 0.0);
 
-          for (octave_idx_type j = 0; j < nrhs; j++)
-            for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT j = 0; j < nrhs; j++)
+            for (F77_INT i = 0; i < m; i++)
               retval.elem (i, j) = b.elem (i, j);
         }
       else
         retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
       Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<float> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
-      octave_idx_type mnthr;
+      F77_INT mnthr;
       F77_FUNC (xilaenv, XILAENV) (6, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
       float anorm = 0.0;
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
-                                 lwork, piwork, info));
+                                 ps, rcon, tmp_rank, work.fortran_vec (),
+                                 lwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for DGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
         {
-          const octave_idx_type wlalsd
+          const F77_INT wlalsd
             = 9*m + 2*m*smlsiz + 8*m*nlvl + m*nrhs + (smlsiz+1)*(smlsiz+1);
 
-          octave_idx_type addend = m;
+          F77_INT addend = m;
 
           if (2*m-4 > addend)
             addend = 2*m-4;
 
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
           if (wlalsd > addend)
             addend = wlalsd;
 
-          const octave_idx_type lworkaround = 4*m + m*m + addend;
+          const F77_INT lworkaround = 4*m + m*m + addend;
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
-          octave_idx_type lworkaround
+          F77_INT lworkaround
             = 12*n + 2*n*smlsiz + 8*n*nlvl + n*nrhs + (smlsiz+1)*(smlsiz+1);
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<octave_idx_type> (work(0));
+      lwork = static_cast<F77_INT> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       anorm = xnorm (*this, 1);
 
       if (octave::math::isinf (anorm) || octave::math::isnan (anorm))
         {
           rcon = 0.0;
           octave::warn_singular_matrix ();
           retval = Matrix (n, m, 0.0);
         }
       else
         {
           F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
-                                     maxmn, ps, rcon, rank,
+                                     maxmn, ps, rcon, tmp_rank,
                                      work.fortran_vec (), lwork,
-                                     piwork, info));
+                                     piwork, tmp_info));
+
+          info = tmp_info;
+          rank = tmp_rank;
 
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
 
           retval.resize (n, nrhs);
         }
@@ -2250,89 +2316,98 @@ FloatMatrix::lssolve (const FloatColumnV
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
                       octave_idx_type& rank, float &rcon) const
 {
   FloatColumnVector retval;
 
-  octave_idx_type nrhs = 1;
-
-  octave_idx_type m = rows ();
-  octave_idx_type n = cols ();
+  F77_INT nrhs = 1;
+
+  F77_INT m = to_f77_int (rows ());
+  F77_INT n = to_f77_int (cols ());
 
   if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = FloatColumnVector (n, 0.0);
   else
     {
-      volatile octave_idx_type minmn = (m < n ? m : n);
-      octave_idx_type maxmn = m > n ? m : n;
+      volatile F77_INT minmn = (m < n ? m : n);
+      F77_INT maxmn = m > n ? m : n;
       rcon = -1.0;
 
       if (m != n)
         {
           retval = FloatColumnVector (maxmn, 0.0);
 
-          for (octave_idx_type i = 0; i < m; i++)
+          for (F77_INT i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
         }
       else
         retval = b;
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       float *pretval = retval.fortran_vec ();
       Array<float> s (dim_vector (minmn, 1));
       float *ps = s.fortran_vec ();
 
       // Ask DGELSD what the dimension of WORK should be.
-      octave_idx_type lwork = -1;
+      F77_INT lwork = -1;
 
       Array<float> work (dim_vector (1, 1));
 
-      octave_idx_type smlsiz;
+      F77_INT smlsiz;
       F77_FUNC (xilaenv, XILAENV) (9, F77_CONST_CHAR_ARG2 ("SGELSD", 6),
                                    F77_CONST_CHAR_ARG2 (" ", 1),
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
-      octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
+      F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
-      octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
+      F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
-      Array<octave_idx_type> iwork (dim_vector (liwork, 1));
-      octave_idx_type* piwork = iwork.fortran_vec ();
+      Array<F77_INT> iwork (dim_vector (liwork, 1));
+      F77_INT* piwork = iwork.fortran_vec ();
+
+      F77_INT tmp_info = 0;
+      F77_INT tmp_rank = 0;
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
-                                 lwork, piwork, info));
-
-      lwork = static_cast<octave_idx_type> (work(0));
+                                 ps, rcon, tmp_rank, work.fortran_vec (),
+                                 lwork, piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
+
+      lwork = static_cast<F77_INT> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
-                                 maxmn, ps, rcon, rank,
+                                 maxmn, ps, rcon, tmp_rank,
                                  work.fortran_vec (), lwork,
-                                 piwork, info));
+                                 piwork, tmp_info));
+
+      info = tmp_info;
+      rank = tmp_rank;
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
         }
@@ -2418,21 +2493,21 @@ FloatMatrix::operator -= (const FloatDia
 
 // column vector by row vector -> matrix operations
 
 FloatMatrix
 operator * (const FloatColumnVector& v, const FloatRowVector& a)
 {
   FloatMatrix retval;
 
-  octave_idx_type len = v.numel ();
+  F77_INT len = to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      octave_idx_type a_len = a.numel ();
+      F77_INT a_len = to_f77_int (a.numel ());
 
       retval = FloatMatrix (len, a_len);
       float *c = retval.fortran_vec ();
 
       F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -2798,21 +2873,21 @@ Sylvester (const FloatMatrix& a, const F
   FloatMatrix ub = bs.unitary_matrix ();
   FloatMatrix sch_b = bs.schur_matrix ();
 
   FloatMatrix cx = ua.transpose () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type b_nr = b.rows ();
+  F77_INT a_nr = to_f77_int (a.rows ());
+  F77_INT b_nr = to_f77_int (b.rows ());
 
   float scale;
-  octave_idx_type info;
+  F77_INT info;
 
   float *pa = sch_a.fortran_vec ();
   float *pb = sch_b.fortran_vec ();
   float *px = cx.fortran_vec ();
 
   F77_XFCN (strsyl, STRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
@@ -2860,30 +2935,30 @@ FloatMatrix
 xgemm (const FloatMatrix& a, const FloatMatrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   FloatMatrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
 
-  octave_idx_type a_nr = tra ? a.cols () : a.rows ();
-  octave_idx_type a_nc = tra ? a.rows () : a.cols ();
-
-  octave_idx_type b_nr = trb ? b.cols () : b.rows ();
-  octave_idx_type b_nc = trb ? b.rows () : b.cols ();
+  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = FloatMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      octave_idx_type lda = a.rows ();
+      F77_INT lda = to_f77_int (a.rows ());
 
       retval = FloatMatrix (a_nr, b_nc);
       float *c = retval.fortran_vec ();
 
       const char ctra = get_blas_trans_arg (tra);
       F77_XFCN (ssyrk, SSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                F77_CONST_CHAR_ARG2 (&ctra, 1),
                                a_nr, a_nc, 1.0,
@@ -2892,20 +2967,20 @@ xgemm (const FloatMatrix& a, const Float
                                F77_CHAR_ARG_LEN (1)));
       for (int j = 0; j < a_nr; j++)
         for (int i = 0; i < j; i++)
           retval.xelem (j,i) = retval.xelem (i,j);
 
     }
   else
     {
-      octave_idx_type lda = a.rows ();
-      octave_idx_type tda = a.cols ();
-      octave_idx_type ldb = b.rows ();
-      octave_idx_type tdb = b.cols ();
+      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT tda = to_f77_int (a.cols ());
+      F77_INT ldb = to_f77_int (b.rows ());
+      F77_INT tdb = to_f77_int (b.cols ());
 
       retval = FloatMatrix (a_nr, b_nc);
       float *c = retval.fortran_vec ();
 
       if (b_nc == 1)
         {
           if (a_nr == 1)
             F77_FUNC (xsdot, XSDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
