# HG changeset patch
# User jwe
# Date 950174811 0
#      Thu Feb 10 09:26:51 2000 +0000
# Node ID edcaebe1b81bf86708d6f12a9a9578ef6544c78c
# Parent  fa5817b05b0f699961c130485d9c4a2d90505938
[project @ 2000-02-10 09:26:48 by jwe]

diff --git a/libcruft/lapack/dbdsqr.f b/libcruft/lapack/dbdsqr.f
--- a/libcruft/lapack/dbdsqr.f
+++ b/libcruft/lapack/dbdsqr.f
@@ -1,15 +1,15 @@
       SUBROUTINE DBDSQR( UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U,
      $                   LDU, C, LDC, WORK, INFO )
 *
 *  -- LAPACK routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       CHARACTER          UPLO
       INTEGER            INFO, LDC, LDU, LDVT, N, NCC, NCVT, NRU
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   C( LDC, * ), D( * ), E( * ), U( LDU, * ),
      $                   VT( LDVT, * ), WORK( * )
@@ -90,19 +90,17 @@
 *          On entry, an N-by-NCC matrix C.
 *          On exit, C is overwritten by Q' * C.
 *          C is not referenced if NCC = 0.
 *
 *  LDC     (input) INTEGER
 *          The leading dimension of the array C.
 *          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
 *
-*  WORK    (workspace) DOUBLE PRECISION array, dimension
-*            2*N  if only singular values wanted (NCVT = NRU = NCC = 0)
-*            max( 1, 4*N-4 ) otherwise
+*  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  If INFO = -i, the i-th argument had an illegal value
 *          > 0:  the algorithm did not converge; D and E contain the
 *                elements of a bidiagonal matrix which is orthogonally
 *                similar to the input matrix B;  if INFO = i, i
 *                elements of E have not converged to zero.
diff --git a/libcruft/lapack/dgelss.f b/libcruft/lapack/dgelss.f
--- a/libcruft/lapack/dgelss.f
+++ b/libcruft/lapack/dgelss.f
@@ -1,15 +1,15 @@
       SUBROUTINE DGELSS( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,
      $                   WORK, LWORK, INFO )
 *
 *  -- LAPACK driver routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK
       DOUBLE PRECISION   RCOND
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), S( * ), WORK( * )
 *     ..
@@ -170,33 +170,33 @@
      $               ILAENV( 1, 'DORMQR', 'LT', M, NRHS, N, -1 ) )
          END IF
          IF( M.GE.N ) THEN
 *
 *           Path 1 - overdetermined or exactly determined
 *
 *           Compute workspace needed for DBDSQR
 *
-            BDSPAC = MAX( 1, 5*N-4 )
+            BDSPAC = MAX( 1, 5*N )
             MAXWRK = MAX( MAXWRK, 3*N+( MM+N )*
      $               ILAENV( 1, 'DGEBRD', ' ', MM, N, -1, -1 ) )
             MAXWRK = MAX( MAXWRK, 3*N+NRHS*
      $               ILAENV( 1, 'DORMBR', 'QLT', MM, NRHS, N, -1 ) )
             MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
      $               ILAENV( 1, 'DORGBR', 'P', N, N, N, -1 ) )
             MAXWRK = MAX( MAXWRK, BDSPAC )
             MAXWRK = MAX( MAXWRK, N*NRHS )
             MINWRK = MAX( 3*N+MM, 3*N+NRHS, BDSPAC )
             MAXWRK = MAX( MINWRK, MAXWRK )
          END IF
          IF( N.GT.M ) THEN
 *
 *           Compute workspace needed for DBDSQR
 *
-            BDSPAC = MAX( 1, 5*M-4 )
+            BDSPAC = MAX( 1, 5*M )
             MINWRK = MAX( 3*M+NRHS, 3*M+N, BDSPAC )
             IF( N.GE.MNTHR ) THEN
 *
 *              Path 2a - underdetermined, with many more columns
 *              than rows
 *
                MAXWRK = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1, -1 )
                MAXWRK = MAX( MAXWRK, M*M+4*M+2*M*
diff --git a/libcruft/lapack/dgesvd.f b/libcruft/lapack/dgesvd.f
--- a/libcruft/lapack/dgesvd.f
+++ b/libcruft/lapack/dgesvd.f
@@ -1,15 +1,15 @@
       SUBROUTINE DGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,
      $                   WORK, LWORK, INFO )
 *
 *  -- LAPACK driver routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       CHARACTER          JOBU, JOBVT
       INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   A( LDA, * ), S( * ), U( LDU, * ),
      $                   VT( LDVT, * ), WORK( * )
@@ -110,17 +110,17 @@
 *          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
 *          superdiagonal elements of an upper bidiagonal matrix B
 *          whose diagonal is in S (not necessarily sorted). B
 *          satisfies A = U * B * VT, so it has the same singular values
 *          as A, and singular vectors related by U and VT.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK. LWORK >= 1.
-*          LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).
+*          LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
 *          For good performance, LWORK should generally be larger.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *  INFO    (output) INTEGER
@@ -209,17 +209,17 @@
 *       following subroutine, as returned by ILAENV.)
 *
       IF( INFO.EQ.0 .AND. ( LWORK.GE.1 .OR. LQUERY ) .AND. M.GT.0 .AND.
      $    N.GT.0 ) THEN
          IF( M.GE.N ) THEN
 *
 *           Compute space needed for DBDSQR
 *
-            BDSPAC = MAX( 3*N, 5*N-4 )
+            BDSPAC = 5*N
             IF( M.GE.MNTHR ) THEN
                IF( WNTUN ) THEN
 *
 *                 Path 1 (M much larger than N, JOBU='N')
 *
                   MAXWRK = N + N*ILAENV( 1, 'DGEQRF', ' ', M, N, -1,
      $                     -1 )
                   MAXWRK = MAX( MAXWRK, 3*N+2*N*
@@ -382,17 +382,17 @@
                MAXWRK = MAX( MAXWRK, BDSPAC )
                MINWRK = MAX( 3*N+M, BDSPAC )
                MAXWRK = MAX( MAXWRK, MINWRK )
             END IF
          ELSE
 *
 *           Compute space needed for DBDSQR
 *
-            BDSPAC = MAX( 3*M, 5*M-4 )
+            BDSPAC = 5*M
             IF( N.GE.MNTHR ) THEN
                IF( WNTVN ) THEN
 *
 *                 Path 1t(N much larger than M, JOBVT='N')
 *
                   MAXWRK = M + M*ILAENV( 1, 'DGELQF', ' ', M, N, -1,
      $                     -1 )
                   MAXWRK = MAX( MAXWRK, 3*M+2*M*
diff --git a/libcruft/lapack/dlasq1.f b/libcruft/lapack/dlasq1.f
--- a/libcruft/lapack/dlasq1.f
+++ b/libcruft/lapack/dlasq1.f
@@ -1,14 +1,14 @@
       SUBROUTINE DLASQ1( N, D, E, WORK, INFO )
 *
 *  -- LAPACK routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999 
 *
 *     .. Scalar Arguments ..
       INTEGER            INFO, N
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   D( * ), E( * ), WORK( * )
 *     ..
 *
@@ -21,23 +21,17 @@
 *  denormalization, underflow and overflow. The algorithm was first
 *  presented in
 *
 *  "Accurate singular values and differential qd algorithms" by K. V.
 *  Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
 *  1994,
 *
 *  and the present implementation is described in "An implementation of
-*  dqds", LAPACK technical report.
-*
-*  Note : DLASQ1 works only on machines which follow ieee-754
-*  floating-point standard in their handling of infinities and NaNs.
-*  Normal execution of DLASQ1 may create NaNs and infinities and hence
-*  may abort due to a floating point exception in environments which
-*  do not conform to the ieee standard.
+*  the dqds Algorithm (Positive Case)", LAPACK Working Note.
 *
 *  Arguments
 *  =========
 *
 *  N     (input) INTEGER
 *        The number of rows and columns in the matrix. N >= 0.
 *
 *  D     (input/output) DOUBLE PRECISION array, dimension (N)
@@ -45,40 +39,40 @@
 *        bidiagonal matrix whose SVD is desired. On normal exit,
 *        D contains the singular values in decreasing order.
 *
 *  E     (input/output) DOUBLE PRECISION array, dimension (N)
 *        On entry, elements E(1:N-1) contain the off-diagonal elements
 *        of the bidiagonal matrix whose SVD is desired.
 *        On exit, E is overwritten.
 *
-*  WORK  (workspace) DOUBLE PRECISION array, dimension (2*N)
+*  WORK  (workspace) DOUBLE PRECISION array, dimension (4*N)
 *
 *  INFO  (output) INTEGER
-*        = 0:  successful exit
-*        < 0:  if INFO = -i, the i-th argument had an illegal value
+*        = 0: successful exit
+*        < 0: if INFO = -i, the i-th argument had an illegal value
 *        > 0: the algorithm failed
-*              = 1, a split was marked by a positive value in E
-*              = 2, current block of Z not diagonalized after 30*N
-*                   iterations (in inner while loop)
-*              = 3, termination criterion of outer while loop not met
-*                   (program created more than N unreduced blocks)
+*             = 1, a split was marked by a positive value in E
+*             = 2, current block of Z not diagonalized after 30*N
+*                  iterations (in inner while loop)
+*             = 3, termination criterion of outer while loop not met 
+*                  (program created more than N unreduced blocks)
 *
 *  =====================================================================
 *
 *     .. Parameters ..
       DOUBLE PRECISION   ZERO
       PARAMETER          ( ZERO = 0.0D0 )
 *     ..
 *     .. Local Scalars ..
       INTEGER            I, IINFO
-      DOUBLE PRECISION   EPS, SCALE, SFMIN, SIGMN, SIGMX
+      DOUBLE PRECISION   EPS, SCALE, SAFMIN, SIGMN, SIGMX
 *     ..
 *     .. External Subroutines ..
-      EXTERNAL           DCOPY, DLAS2, DLASCL, DLASQ2, DLASRT, XERBLA
+      EXTERNAL           DLAS2, DLASQ2, DLASRT, XERBLA
 *     ..
 *     .. External Functions ..
       DOUBLE PRECISION   DLAMCH
       EXTERNAL           DLAMCH
 *     ..
 *     .. Intrinsic Functions ..
       INTRINSIC          ABS, MAX, SQRT
 *     ..
@@ -109,48 +103,47 @@
          SIGMX = MAX( SIGMX, ABS( E( I ) ) )
    10 CONTINUE
       D( N ) = ABS( D( N ) )
 *
 *     Early return if SIGMX is zero (matrix is already diagonal).
 *
       IF( SIGMX.EQ.ZERO ) THEN
          CALL DLASRT( 'D', N, D, IINFO )
-         GO TO 50
+         RETURN
       END IF
 *
       DO 20 I = 1, N
          SIGMX = MAX( SIGMX, D( I ) )
    20 CONTINUE
 *
 *     Copy D and E into WORK (in the Z format) and scale (squaring the
 *     input data makes scaling by a power of the radix pointless).
 *
       EPS = DLAMCH( 'Precision' )
-      SFMIN = DLAMCH( 'Safe minimum' )
-      SCALE = SQRT( EPS / SFMIN )
+      SAFMIN = DLAMCH( 'Safe minimum' )
+      SCALE = SQRT( EPS / SAFMIN )
       CALL DCOPY( N, D, 1, WORK( 1 ), 2 )
       CALL DCOPY( N-1, E, 1, WORK( 2 ), 2 )
       CALL DLASCL( 'G', 0, 0, SIGMX, SCALE, 2*N-1, 1, WORK, 2*N-1,
      $             IINFO )
-*
+*         
 *     Compute the q's and e's.
 *
       DO 30 I = 1, 2*N - 1
          WORK( I ) = WORK( I )**2
    30 CONTINUE
       WORK( 2*N ) = ZERO
 *
       CALL DLASQ2( N, WORK, INFO )
 *
       IF( INFO.EQ.0 ) THEN
          DO 40 I = 1, N
             D( I ) = SQRT( WORK( I ) )
    40    CONTINUE
          CALL DLASCL( 'G', 0, 0, SCALE, SIGMX, N, 1, D, N, IINFO )
       END IF
 *
-   50 CONTINUE
       RETURN
 *
 *     End of DLASQ1
 *
       END
diff --git a/libcruft/lapack/dlasq2.f b/libcruft/lapack/dlasq2.f
--- a/libcruft/lapack/dlasq2.f
+++ b/libcruft/lapack/dlasq2.f
@@ -1,109 +1,112 @@
       SUBROUTINE DLASQ2( N, Z, INFO )
 *
-*  -- LAPACK auxiliary routine (version 3.0) --
+*  -- LAPACK routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999 
 *
 *     .. Scalar Arguments ..
       INTEGER            INFO, N
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   Z( * )
 *     ..
 *
 *  Purpose
 *  =======
 *
-*  DLASQ2 computes all the eigenvalues of the symmetric positive
+*  DLASQ2 computes all the eigenvalues of the symmetric positive 
 *  definite tridiagonal matrix associated with the qd array Z to high
 *  relative accuracy are computed to high relative accuracy, in the
 *  absence of denormalization, underflow and overflow.
 *
 *  To see the relation of Z to the tridiagonal matrix, let L be a
 *  unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
 *  let U be an upper bidiagonal matrix with 1's above and diagonal
 *  Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
 *  symmetric tridiagonal to which it is similar.
 *
-*  Note : DLASQ2 works only on machines which follow ieee-754
-*  floating-point standard in their handling of infinities and NaNs.
-*  Normal execution of DLASQ2 may create NaNs and infinities and hence
-*  may abort due to a floating point exception in environments which
-*  do not conform to the ieee standard.
+*  Note : DLASQ2 defines a logical variable, IEEE, which is true
+*  on machines which follow ieee-754 floating-point standard in their
+*  handling of infinities and NaNs, and false otherwise. This variable
+*  is passed to DLASQ3.
 *
 *  Arguments
 *  =========
 *
 *  N     (input) INTEGER
 *        The number of rows and columns in the matrix. N >= 0.
 *
 *  Z     (workspace) DOUBLE PRECISION array, dimension ( 4*N )
 *        On entry Z holds the qd array. On exit, entries 1 to N hold
 *        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
-*        trace, Z( 2*N+2 ) holds the sum of the eigenvalues, Z( 2*N+3 )
-*        holds the iteration count, Z( 2*N+4 ) holds NDIVS/NIN^2, and
-*        Z( 2*N+5 ) holds the percentage of shifts that failed.
+*        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
+*        N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
+*        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
+*        shifts that failed.
 *
 *  INFO  (output) INTEGER
 *        = 0: successful exit
 *        < 0: if the i-th argument is a scalar and had an illegal
 *             value, then INFO = -i, if the i-th argument is an
 *             array and the j-entry had an illegal value, then
 *             INFO = -(i*100+j)
 *        > 0: the algorithm failed
 *              = 1, a split was marked by a positive value in E
 *              = 2, current block of Z not diagonalized after 30*N
 *                   iterations (in inner while loop)
-*              = 3, termination criterion of outer while loop not met
+*              = 3, termination criterion of outer while loop not met 
 *                   (program created more than N unreduced blocks)
 *
 *  Further Details
 *  ===============
 *  Local Variables: I0:N0 defines a current unreduced segment of Z.
 *  The shifts are accumulated in SIGMA. Iteration count is in ITER.
 *  Ping-pong is controlled by PP (alternates between 0 and 1).
 *
 *  =====================================================================
 *
 *     .. Parameters ..
       DOUBLE PRECISION   CBIAS
       PARAMETER          ( CBIAS = 1.50D0 )
-      DOUBLE PRECISION   ZERO, HALF, ONE, TWO, FOUR, TEN, HNDRD
+      DOUBLE PRECISION   ZERO, HALF, ONE, TWO, FOUR, HUNDRD
       PARAMETER          ( ZERO = 0.0D0, HALF = 0.5D0, ONE = 1.0D0,
-     $                   TWO = 2.0D0, FOUR = 4.0D0, TEN = 10.0D0,
-     $                   HNDRD = 100.0D0 )
+     $                     TWO = 2.0D0, FOUR = 4.0D0, HUNDRD = 100.0D0 )
 *     ..
 *     .. Local Scalars ..
-      INTEGER            I0, I4, IINFO, IPN4, ITER, IWHILA, IWHILB, K,
+      LOGICAL            IEEE
+      INTEGER            I0, I4, IINFO, IPN4, ITER, IWHILA, IWHILB, K, 
      $                   N0, NBIG, NDIV, NFAIL, PP, SPLT
-      DOUBLE PRECISION   D, DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, E,
-     $                   EMAX, EMIN, EPS, EPS2, OLDEMN, QMAX, QMIN, S,
-     $                   SIGMA, T, TAU, TEMP, TRACE, ZMAX
+      DOUBLE PRECISION   D, DESIG, DMIN, E, EMAX, EMIN, EPS, OLDEMN, 
+     $                   QMAX, QMIN, S, SAFMIN, SIGMA, T, TEMP, TOL, 
+     $                   TOL2, TRACE, ZMAX
 *     ..
 *     .. External Subroutines ..
-      EXTERNAL           DLASQ3, DLASQ5, DLASRT, XERBLA
+      EXTERNAL           DLASQ3, DLASRT, XERBLA
 *     ..
 *     .. External Functions ..
+      INTEGER            ILAENV
       DOUBLE PRECISION   DLAMCH
-      EXTERNAL           DLAMCH
+      EXTERNAL           DLAMCH, ILAENV
 *     ..
 *     .. Intrinsic Functions ..
-      INTRINSIC          ABS, DBLE, MAX, MIN, SQRT
+      INTRINSIC          DBLE, MAX, MIN, SQRT
 *     ..
 *     .. Executable Statements ..
-*
+*      
 *     Test the input arguments.
 *     (in case DLASQ2 is not called by DLASQ1)
 *
       INFO = 0
-      EPS = DLAMCH( 'Precision' )*TEN
-      EPS2 = EPS**2
+      EPS = DLAMCH( 'Precision' )
+      SAFMIN = DLAMCH( 'Safe minimum' )
+      TOL = EPS*HUNDRD
+      TOL2 = TOL**2
 *
       IF( N.LT.0 ) THEN
          INFO = -1
          CALL XERBLA( 'DLASQ2', 1 )
          RETURN
       ELSE IF( N.EQ.0 ) THEN
          RETURN
       ELSE IF( N.EQ.1 ) THEN
@@ -124,92 +127,104 @@
             CALL XERBLA( 'DLASQ2', 2 )
             RETURN
          ELSE IF( Z( 3 ).GT.Z( 1 ) ) THEN
             D = Z( 3 )
             Z( 3 ) = Z( 1 )
             Z( 1 ) = D
          END IF
          Z( 5 ) = Z( 1 ) + Z( 2 ) + Z( 3 )
-         IF( Z( 2 ).GT.Z( 3 )*EPS2 ) THEN
-            T = HALF*( ( Z( 1 )-Z( 3 ) )+Z( 2 ) )
+         IF( Z( 2 ).GT.Z( 3 )*TOL2 ) THEN
+            T = HALF*( ( Z( 1 )-Z( 3 ) )+Z( 2 ) ) 
             S = Z( 3 )*( Z( 2 ) / T )
             IF( S.LE.T ) THEN
                S = Z( 3 )*( Z( 2 ) / ( T*( ONE+SQRT( ONE+S / T ) ) ) )
             ELSE
                S = Z( 3 )*( Z( 2 ) / ( T+SQRT( T )*SQRT( T+S ) ) )
             END IF
             T = Z( 1 ) + ( S+Z( 2 ) )
             Z( 3 ) = Z( 3 )*( Z( 1 ) / T )
             Z( 1 ) = T
          END IF
          Z( 2 ) = Z( 3 )
          Z( 6 ) = Z( 2 ) + Z( 1 )
-         Z( 7 ) = ZERO
-         Z( 8 ) = ZERO
-         Z( 9 ) = ZERO
          RETURN
       END IF
 *
 *     Check for negative data and compute sums of q's and e's.
 *
       Z( 2*N ) = ZERO
       EMIN = Z( 2 )
       QMAX = ZERO
+      ZMAX = ZERO
       D = ZERO
       E = ZERO
 *
-      DO 10 K = 1, N
+      DO 10 K = 1, 2*( N-1 ), 2
          IF( Z( K ).LT.ZERO ) THEN
             INFO = -( 200+K )
             CALL XERBLA( 'DLASQ2', 2 )
             RETURN
-         ELSE IF( Z( N+K ).LT.ZERO ) THEN
-            INFO = -( 200+N+K )
+         ELSE IF( Z( K+1 ).LT.ZERO ) THEN
+            INFO = -( 200+K+1 )
             CALL XERBLA( 'DLASQ2', 2 )
             RETURN
          END IF
          D = D + Z( K )
-         E = E + Z( N+K )
+         E = E + Z( K+1 )
          QMAX = MAX( QMAX, Z( K ) )
+         EMIN = MIN( EMIN, Z( K+1 ) )
+         ZMAX = MAX( QMAX, ZMAX, Z( K+1 ) )
    10 CONTINUE
-      ZMAX = QMAX
-      DO 20 K = 1, N - 1
-         EMIN = MIN( EMIN, Z( N+K ) )
-         ZMAX = MAX( ZMAX, Z( N+K ) )
-   20 CONTINUE
+      IF( Z( 2*N-1 ).LT.ZERO ) THEN
+         INFO = -( 200+2*N-1 )
+         CALL XERBLA( 'DLASQ2', 2 )
+         RETURN
+      END IF
+      D = D + Z( 2*N-1 )
+      QMAX = MAX( QMAX, Z( 2*N-1 ) )
+      ZMAX = MAX( QMAX, ZMAX )
 *
 *     Check for diagonality.
 *
       IF( E.EQ.ZERO ) THEN
+         DO 20 K = 2, N
+            Z( K ) = Z( 2*K-1 )
+   20    CONTINUE
          CALL DLASRT( 'D', N, Z, IINFO )
          Z( 2*N-1 ) = D
          RETURN
       END IF
 *
       TRACE = D + E
-      I0 = 1
-      N0 = N
 *
 *     Check for zero data.
 *
       IF( TRACE.EQ.ZERO ) THEN
          Z( 2*N-1 ) = ZERO
          RETURN
       END IF
-*
+*         
+*     Check whether the machine is IEEE conformable.
+*         
+      IEEE = ILAENV( 10, 'DLASQ2', 'N', 1, 2, 3, 4 ).EQ.1 .AND.
+     $       ILAENV( 11, 'DLASQ2', 'N', 1, 2, 3, 4 ).EQ.1      
+*         
 *     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...).
 *
       DO 30 K = 2*N, 2, -2
-         Z( 2*K ) = ZERO
-         Z( 2*K-1 ) = Z( K )
-         Z( 2*K-2 ) = ZERO
-         Z( 2*K-3 ) = Z( K-1 )
+         Z( 2*K ) = ZERO 
+         Z( 2*K-1 ) = Z( K ) 
+         Z( 2*K-2 ) = ZERO 
+         Z( 2*K-3 ) = Z( K-1 ) 
    30 CONTINUE
 *
+      I0 = 1
+      N0 = N
+*
 *     Reverse the qd-array, if warranted.
 *
       IF( CBIAS*Z( 4*I0-3 ).LT.Z( 4*N0-3 ) ) THEN
          IPN4 = 4*( I0+N0 )
          DO 40 I4 = 4*I0, 2*( I0+N0-1 ), 4
             TEMP = Z( I4-3 )
             Z( I4-3 ) = Z( IPN4-I4-3 )
             Z( IPN4-I4-3 ) = TEMP
@@ -220,57 +235,49 @@
       END IF
 *
 *     Initial split checking via dqd and Li's test.
 *
       PP = 0
 *
       DO 80 K = 1, 2
 *
-         IF( EMIN.LE.EPS2*QMAX ) THEN
-*
-*           Li's reverse test.
+         D = Z( 4*N0+PP-3 )
+         DO 50 I4 = 4*( N0-1 ) + PP, 4*I0 + PP, -4
+            IF( Z( I4-1 ).LE.TOL2*D ) THEN
+               Z( I4-1 ) = -ZERO
+               D = Z( I4-3 )
+            ELSE
+               D = Z( I4-3 )*( D / ( D+Z( I4-1 ) ) )
+            END IF
+   50    CONTINUE
 *
-            D = Z( 4*N0+PP-3 )
-            DO 50 I4 = 4*( N0-1 ) + PP, 4*I0 + PP, -4
-               IF( Z( I4-1 ).LE.EPS2*D ) THEN
-                  Z( I4-1 ) = -ZERO
-                  D = Z( I4-3 )
-               ELSE
-                  D = Z( I4-3 )*( D / ( D+Z( I4-1 ) ) )
-               END IF
-   50       CONTINUE
-*
-*           dqd maps Z to ZZ plus Li's test.
+*        dqd maps Z to ZZ plus Li's test.
 *
-            EMIN = Z( 4*I0+PP+1 )
-            D = Z( 4*I0+PP-3 )
-            DO 60 I4 = 4*I0 + PP, 4*( N0-1 ) + PP, 4
-               IF( Z( I4-1 ).LE.EPS2*D ) THEN
-                  Z( I4-1 ) = -ZERO
-                  Z( I4-2*PP-2 ) = D
-                  Z( I4-2*PP ) = ZERO
-                  D = Z( I4+1 )
-                  EMIN = ZERO
-               ELSE
-                  Z( I4-2*PP-2 ) = D + Z( I4-1 )
-                  Z( I4-2*PP ) = Z( I4+1 )*( Z( I4-1 ) /
-     $                           Z( I4-2*PP-2 ) )
-                  D = Z( I4+1 )*( D / Z( I4-2*PP-2 ) )
-                  EMIN = MIN( EMIN, Z( I4-2*PP ) )
-               END IF
-   60       CONTINUE
-            Z( 4*N0-PP-2 ) = D
-         ELSE
-            TAU = ZERO
-            CALL DLASQ5( I0, N0, Z, PP, TAU, DMIN, DMIN1, DMIN2, DN,
-     $                   DN1, DN2 )
-*
-            EMIN = Z( 4*N0 )
-         END IF
+         EMIN = Z( 4*I0+PP+1 )
+         D = Z( 4*I0+PP-3 )
+         DO 60 I4 = 4*I0 + PP, 4*( N0-1 ) + PP, 4
+            Z( I4-2*PP-2 ) = D + Z( I4-1 )
+            IF( Z( I4-1 ).LE.TOL2*D ) THEN
+               Z( I4-1 ) = -ZERO
+               Z( I4-2*PP-2 ) = D
+               Z( I4-2*PP ) = ZERO
+               D = Z( I4+1 )
+            ELSE IF( SAFMIN*Z( I4+1 ).LT.Z( I4-2*PP-2 ) .AND.
+     $               SAFMIN*Z( I4-2*PP-2 ).LT.Z( I4+1 ) ) THEN
+               TEMP = Z( I4+1 ) / Z( I4-2*PP-2 )
+               Z( I4-2*PP ) = Z( I4-1 )*TEMP
+               D = D*TEMP
+            ELSE
+               Z( I4-2*PP ) = Z( I4+1 )*( Z( I4-1 ) / Z( I4-2*PP-2 ) )
+               D = Z( I4+1 )*( D / Z( I4-2*PP-2 ) )
+            END IF
+            EMIN = MIN( EMIN, Z( I4-2*PP ) )
+   60    CONTINUE 
+         Z( 4*N0-PP-2 ) = D
 *
 *        Now find qmax.
 *
          QMAX = Z( 4*I0-PP-2 )
          DO 70 I4 = 4*I0 - PP + 2, 4*N0 - PP - 2, 4
             QMAX = MAX( QMAX, Z( I4 ) )
    70    CONTINUE
 *
@@ -279,93 +286,97 @@
          PP = 1 - PP
    80 CONTINUE
 *
       ITER = 2
       NFAIL = 0
       NDIV = 2*( N0-I0 )
 *
       DO 140 IWHILA = 1, N + 1
-         IF( N0.LT.1 )
+         IF( N0.LT.1 ) 
      $      GO TO 150
 *
-*        While array unfinished do
+*        While array unfinished do 
 *
 *        E(N0) holds the value of SIGMA when submatrix in I0:N0
 *        splits from the rest of the array, but is negated.
-*
+*      
          DESIG = ZERO
          IF( N0.EQ.N ) THEN
             SIGMA = ZERO
          ELSE
             SIGMA = -Z( 4*N0-1 )
          END IF
          IF( SIGMA.LT.ZERO ) THEN
             INFO = 1
             RETURN
          END IF
 *
 *        Find last unreduced submatrix's top index I0, find QMAX and
 *        EMIN. Find Gershgorin-type bound if Q's much greater than E's.
 *
-         EMAX = ZERO
-         EMIN = ABS( Z( 4*N0-5 ) )
+         EMAX = ZERO 
+         IF( N0.GT.I0 ) THEN
+            EMIN = ABS( Z( 4*N0-5 ) )
+         ELSE
+            EMIN = ZERO
+         END IF
          QMIN = Z( 4*N0-3 )
          QMAX = QMIN
          DO 90 I4 = 4*N0, 8, -4
             IF( Z( I4-5 ).LE.ZERO )
      $         GO TO 100
             IF( QMIN.GE.FOUR*EMAX ) THEN
                QMIN = MIN( QMIN, Z( I4-3 ) )
                EMAX = MAX( EMAX, Z( I4-5 ) )
             END IF
             QMAX = MAX( QMAX, Z( I4-7 )+Z( I4-5 ) )
             EMIN = MIN( EMIN, Z( I4-5 ) )
    90    CONTINUE
-         I4 = 4
+         I4 = 4 
 *
   100    CONTINUE
          I0 = I4 / 4
 *
 *        Store EMIN for passing to DLASQ3.
 *
          Z( 4*N0-1 ) = EMIN
 *
 *        Put -(initial shift) into DMIN.
 *
          DMIN = -MAX( ZERO, QMIN-TWO*SQRT( QMIN )*SQRT( EMAX ) )
 *
 *        Now I0:N0 is unreduced. PP = 0 for ping, PP = 1 for pong.
 *
-         PP = 0
+         PP = 0 
 *
          NBIG = 30*( N0-I0+1 )
          DO 120 IWHILB = 1, NBIG
-            IF( I0.GT.N0 )
+            IF( I0.GT.N0 ) 
      $         GO TO 130
 *
 *           While submatrix unfinished take a good dqds step.
 *
             CALL DLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,
-     $                   ITER, NDIV )
+     $                   ITER, NDIV, IEEE )
 *
             PP = 1 - PP
 *
 *           When EMIN is very small check for splits.
 *
             IF( PP.EQ.0 .AND. N0-I0.GE.3 ) THEN
-               IF( Z( 4*N0 ).LE.EPS2*QMAX .OR. Z( 4*N0-1 ).LE.EPS2*
-     $             SIGMA ) THEN
+               IF( Z( 4*N0 ).LE.TOL2*QMAX .OR.
+     $             Z( 4*N0-1 ).LE.TOL2*SIGMA ) THEN
                   SPLT = I0 - 1
                   QMAX = Z( 4*I0-3 )
                   EMIN = Z( 4*I0-1 )
                   OLDEMN = Z( 4*I0 )
                   DO 110 I4 = 4*I0, 4*( N0-3 ), 4
-                     IF( Z( I4 ).LE.EPS2*Z( I4-3 ) .OR. Z( I4-1 ).LE.
-     $                   EPS2*SIGMA ) THEN
+                     IF( Z( I4 ).LE.TOL2*Z( I4-3 ) .OR.
+     $                   Z( I4-1 ).LE.TOL2*SIGMA ) THEN
                         Z( I4-1 ) = -SIGMA
                         SPLT = I4 / 4
                         QMAX = ZERO
                         EMIN = Z( I4+3 )
                         OLDEMN = Z( I4+4 )
                      ELSE
                         QMAX = MAX( QMAX, Z( I4+1 ) )
                         EMIN = MIN( EMIN, Z( I4-1 ) )
@@ -387,39 +398,39 @@
 *
   130    CONTINUE
 *
   140 CONTINUE
 *
       INFO = 3
       RETURN
 *
-*     end IWHILA
+*     end IWHILA   
 *
   150 CONTINUE
-*
+*      
 *     Move q's to the front.
-*
+*      
       DO 160 K = 2, N
          Z( K ) = Z( 4*K-3 )
   160 CONTINUE
-*
+*      
 *     Sort and compute sum of eigenvalues.
 *
       CALL DLASRT( 'D', N, Z, IINFO )
 *
       E = ZERO
       DO 170 K = N, 1, -1
          E = E + Z( K )
   170 CONTINUE
 *
 *     Store trace, sum(eigenvalues) and information on performance.
 *
-      Z( 2*N+1 ) = TRACE
+      Z( 2*N+1 ) = TRACE 
       Z( 2*N+2 ) = E
       Z( 2*N+3 ) = DBLE( ITER )
       Z( 2*N+4 ) = DBLE( NDIV ) / DBLE( N**2 )
-      Z( 2*N+5 ) = HNDRD*NFAIL / DBLE( ITER )
+      Z( 2*N+5 ) = HUNDRD*NFAIL / DBLE( ITER )
       RETURN
 *
 *     End of DLASQ2
 *
       END
diff --git a/libcruft/lapack/dlasq3.f b/libcruft/lapack/dlasq3.f
--- a/libcruft/lapack/dlasq3.f
+++ b/libcruft/lapack/dlasq3.f
@@ -1,15 +1,15 @@
       SUBROUTINE DLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,
      $                   ITER, NDIV, IEEE )
 *
 *  -- LAPACK auxiliary routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     December 22, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       LOGICAL            IEEE
       INTEGER            I0, ITER, N0, NDIV, NFAIL, PP
       DOUBLE PRECISION   DESIG, DMIN, QMAX, SIGMA
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   Z( * )
@@ -218,25 +218,25 @@
          ITER = ITER + 1
 *
          IF( DMIN.NE.DMIN ) THEN
 *
 *           Check for NaN: "DMIN.NE.DMIN" 
 *
             Z( 4*N0+PP-1 ) = ZERO
             GO TO 70
-         ELSE IF( Z( 4*N0-PP ).LE.ZERO ) THEN
+         ELSE IF( Z( 4*N0+PP ).LE.ZERO ) THEN
 *
 *           Possible unnecessary underflow in the e's.
 *           Call safe dqd.
 *
             Z( 4*N0+PP-1 ) = ZERO
             DMIN = ZERO
             GO TO 70
-         ELSE IF( DMIN.EQ.ZERO .AND. TAU.EQ.ZERO ) THEN
+         ELSE IF( DMIN.EQ.ZERO .AND. DMIN1.LE.ZERO ) THEN
 *
 *           Possible unnecessary underflow in the d's.
 *           Call safe dqd.
 *
             Z( 4*N0+PP-1 ) = ZERO
             GO TO 70
          END IF
 *
diff --git a/libcruft/lapack/dlasq4.f b/libcruft/lapack/dlasq4.f
--- a/libcruft/lapack/dlasq4.f
+++ b/libcruft/lapack/dlasq4.f
@@ -1,27 +1,28 @@
       SUBROUTINE DLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN,
      $                   DN1, DN2, TAU, TTYPE )
 *
 *  -- LAPACK auxiliary routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       INTEGER            I0, N0, N0IN, PP, TTYPE
       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DN1, DN2, TAU
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   Z( * )
 *     ..
 *
 *  Purpose
 *  =======
-*  DLASQ4 computes an approximation TAU to the smallest eigenvalue
+*
+*  DLASQ4 computes an approximation TAU to the smallest eigenvalue 
 *  using values of d from the previous transform.
 *
 *  I0    (input) INTEGER
 *        First index.
 *
 *  N0    (input) INTEGER
 *        Last index.
 *
@@ -63,45 +64,45 @@
 *  CNST1 = 9/16
 *
 *  =====================================================================
 *
 *     .. Parameters ..
       DOUBLE PRECISION   CNST1, CNST2, CNST3
       PARAMETER          ( CNST1 = 0.5630D0, CNST2 = 1.010D0,
      $                   CNST3 = 1.050D0 )
-      DOUBLE PRECISION   QURTR, THIRD, HALF, ZERO, ONE, TWO, HNDRD
+      DOUBLE PRECISION   QURTR, THIRD, HALF, ZERO, ONE, TWO, HUNDRD
       PARAMETER          ( QURTR = 0.250D0, THIRD = 0.3330D0,
      $                   HALF = 0.50D0, ZERO = 0.0D0, ONE = 1.0D0,
-     $                   TWO = 2.0D0, HNDRD = 100.0D0 )
+     $                   TWO = 2.0D0, HUNDRD = 100.0D0 )
 *     ..
 *     .. Local Scalars ..
       INTEGER            I4, NN, NP
       DOUBLE PRECISION   A2, B1, B2, G, GAM, GAP1, GAP2, S
 *     ..
 *     .. Intrinsic Functions ..
       INTRINSIC          MAX, MIN, SQRT
 *     ..
 *     .. Save statement ..
       SAVE               G
 *     ..
-*     .. Data statements ..
+*     .. Data statement ..
       DATA               G / ZERO /
 *     ..
 *     .. Executable Statements ..
 *
 *     A negative DMIN forces the shift to take that absolute value
 *     TTYPE records the type of shift.
 *
       IF( DMIN.LE.ZERO ) THEN
          TAU = -DMIN
          TTYPE = -1
          RETURN
       END IF
-*
+*       
       NN = 4*N0 + PP
       IF( N0IN.EQ.N0 ) THEN
 *
 *        No eigenvalues deflated.
 *
          IF( DMIN.EQ.DN .OR. DMIN.EQ.DN1 ) THEN
 *
             B1 = SQRT( Z( NN-3 ) )*SQRT( Z( NN-5 ) )
@@ -128,90 +129,99 @@
      $               S = MIN( S, A2-( B1+B2 ) )
                   S = MAX( S, THIRD*DMIN )
                   TTYPE = -3
                END IF
             ELSE
 *
 *              Case 4.
 *
+               TTYPE = -4
+               S = QURTR*DMIN
                IF( DMIN.EQ.DN ) THEN
                   GAM = DN
                   A2 = ZERO
+                  IF( Z( NN-5 ) .GT. Z( NN-7 ) )
+     $               RETURN
                   B2 = Z( NN-5 ) / Z( NN-7 )
                   NP = NN - 9
                ELSE
                   NP = NN - 2*PP
                   B2 = Z( NP-2 )
                   GAM = DN1
+                  IF( Z( NP-4 ) .GT. Z( NP-2 ) )
+     $               RETURN
                   A2 = Z( NP-4 ) / Z( NP-2 )
+                  IF( Z( NN-9 ) .GT. Z( NN-11 ) )
+     $               RETURN
                   B2 = Z( NN-9 ) / Z( NN-11 )
                   NP = NN - 13
                END IF
 *
 *              Approximate contribution to norm squared from I < NN-1.
 *
-               IF( B2.EQ.ZERO )
-     $            GO TO 20
                A2 = A2 + B2
                DO 10 I4 = NP, 4*I0 - 1 + PP, -4
+                  IF( B2.EQ.ZERO )
+     $               GO TO 20
                   B1 = B2
+                  IF( Z( I4 ) .GT. Z( I4-2 ) )
+     $               RETURN
                   B2 = B2*( Z( I4 ) / Z( I4-2 ) )
                   A2 = A2 + B2
-                  IF( HNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )
+                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 ) 
      $               GO TO 20
    10          CONTINUE
    20          CONTINUE
                A2 = CNST3*A2
 *
 *              Rayleigh quotient residual bound.
 *
-               IF( A2.LT.CNST1 ) THEN
-                  S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )
-               ELSE
-                  S = QURTR*GAM
-               END IF
-               TTYPE = -4
+               IF( A2.LT.CNST1 )
+     $            S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )
             END IF
          ELSE IF( DMIN.EQ.DN2 ) THEN
 *
 *           Case 5.
 *
+            TTYPE = -5
+            S = QURTR*DMIN
+*
 *           Compute contribution to norm squared from I > NN-2.
 *
             NP = NN - 2*PP
             B1 = Z( NP-2 )
             B2 = Z( NP-6 )
             GAM = DN2
+            IF( Z( NP-8 ).GT.B2 .OR. Z( NP-4 ).GT.B1 )
+     $         RETURN
             A2 = ( Z( NP-8 ) / B2 )*( ONE+Z( NP-4 ) / B1 )
 *
 *           Approximate contribution to norm squared from I < NN-2.
 *
             IF( N0-I0.GT.2 ) THEN
                B2 = Z( NN-13 ) / Z( NN-15 )
-               IF( B2.EQ.ZERO )
-     $            GO TO 40
                A2 = A2 + B2
                DO 30 I4 = NN - 17, 4*I0 - 1 + PP, -4
+                  IF( B2.EQ.ZERO )
+     $               GO TO 40
                   B1 = B2
+                  IF( Z( I4 ) .GT. Z( I4-2 ) )
+     $               RETURN
                   B2 = B2*( Z( I4 ) / Z( I4-2 ) )
                   A2 = A2 + B2
-                  IF( HNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )
+                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 ) 
      $               GO TO 40
    30          CONTINUE
    40          CONTINUE
                A2 = CNST3*A2
             END IF
 *
-            IF( A2.LT.CNST1 ) THEN
-               S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )
-            ELSE
-               S = QURTR*GAM / ( ONE+A2 )
-            END IF
-            TTYPE = -5
+            IF( A2.LT.CNST1 )
+     $         S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )
          ELSE
 *
 *           Case 6, no information to guide us.
 *
             IF( TTYPE.EQ.-6 ) THEN
                G = G + THIRD*( ONE-G )
             ELSE IF( TTYPE.EQ.-18 ) THEN
                G = QURTR*THIRD
@@ -221,41 +231,45 @@
             S = G*DMIN
             TTYPE = -6
          END IF
 *
       ELSE IF( N0IN.EQ.( N0+1 ) ) THEN
 *
 *        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN.
 *
-         IF( DMIN1.EQ.DN1 .AND. DMIN2.EQ.DN2 ) THEN
+         IF( DMIN1.EQ.DN1 .AND. DMIN2.EQ.DN2 ) THEN 
 *
 *           Cases 7 and 8.
 *
+            TTYPE = -7
+            S = THIRD*DMIN1
+            IF( Z( NN-5 ).GT.Z( NN-7 ) )
+     $         RETURN
             B1 = Z( NN-5 ) / Z( NN-7 )
             B2 = B1
             IF( B2.EQ.ZERO )
      $         GO TO 60
             DO 50 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4
                A2 = B1
+               IF( Z( I4 ).GT.Z( I4-2 ) )
+     $            RETURN
                B1 = B1*( Z( I4 ) / Z( I4-2 ) )
                B2 = B2 + B1
-               IF( HNDRD*MAX( B1, A2 ).LT.B2 )
+               IF( HUNDRD*MAX( B1, A2 ).LT.B2 ) 
      $            GO TO 60
    50       CONTINUE
    60       CONTINUE
             B2 = SQRT( CNST3*B2 )
             A2 = DMIN1 / ( ONE+B2**2 )
             GAP2 = HALF*DMIN2 - A2
             IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN
-               S = MAX( A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ),
-     $             THIRD*DMIN1 )
-               TTYPE = -7
-            ELSE
-               S = MAX( A2*( ONE-CNST2*B2 ), THIRD*DMIN1 )
+               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) )
+            ELSE 
+               S = MAX( S, A2*( ONE-CNST2*B2 ) )
                TTYPE = -8
             END IF
          ELSE
 *
 *           Case 9.
 *
             S = QURTR*DMIN1
             IF( DMIN1.EQ.DN1 )
@@ -264,48 +278,52 @@
          END IF
 *
       ELSE IF( N0IN.EQ.( N0+2 ) ) THEN
 *
 *        Two eigenvalues deflated. Use DMIN2, DN2 for DMIN and DN.
 *
 *        Cases 10 and 11.
 *
-         IF( DMIN2.EQ.DN2 .AND. TWO*Z( NN-5 ).LT.Z( NN-7 ) ) THEN
+         IF( DMIN2.EQ.DN2 .AND. TWO*Z( NN-5 ).LT.Z( NN-7 ) ) THEN 
+            TTYPE = -10
+            S = THIRD*DMIN2
+            IF( Z( NN-5 ).GT.Z( NN-7 ) )
+     $         RETURN
             B1 = Z( NN-5 ) / Z( NN-7 )
             B2 = B1
             IF( B2.EQ.ZERO )
      $         GO TO 80
             DO 70 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4
+               IF( Z( I4 ).GT.Z( I4-2 ) )
+     $            RETURN
                B1 = B1*( Z( I4 ) / Z( I4-2 ) )
                B2 = B2 + B1
-               IF( HNDRD*B1.LT.B2 )
+               IF( HUNDRD*B1.LT.B2 )
      $            GO TO 80
    70       CONTINUE
    80       CONTINUE
             B2 = SQRT( CNST3*B2 )
             A2 = DMIN2 / ( ONE+B2**2 )
             GAP2 = Z( NN-7 ) + Z( NN-9 ) -
      $             SQRT( Z( NN-11 ) )*SQRT( Z( NN-9 ) ) - A2
             IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN
-               S = MAX( A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ),
-     $             THIRD*DMIN2 )
-            ELSE
-               S = MAX( A2*( ONE-CNST2*B2 ), THIRD*DMIN2 )
+               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) )
+            ELSE 
+               S = MAX( S, A2*( ONE-CNST2*B2 ) )
             END IF
-            TTYPE = -10
          ELSE
             S = QURTR*DMIN2
             TTYPE = -11
          END IF
       ELSE IF( N0IN.GT.( N0+2 ) ) THEN
 *
 *        Case 12, more than two eigenvalues deflated. No information.
 *
-         S = ZERO
+         S = ZERO 
          TTYPE = -12
       END IF
 *
       TAU = S
       RETURN
 *
 *     End of DLASQ4
 *
diff --git a/libcruft/lapack/dlasq5.f b/libcruft/lapack/dlasq5.f
--- a/libcruft/lapack/dlasq5.f
+++ b/libcruft/lapack/dlasq5.f
@@ -1,27 +1,30 @@
       SUBROUTINE DLASQ5( I0, N0, Z, PP, TAU, DMIN, DMIN1, DMIN2, DN,
-     $                   DNM1, DNM2 )
+     $                   DNM1, DNM2, IEEE )
 *
 *  -- LAPACK auxiliary routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
+      LOGICAL            IEEE
       INTEGER            I0, N0, PP
       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, TAU
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   Z( * )
 *     ..
 *
 *  Purpose
 *  =======
-*  DLASQ5 computes one dqds transform in ping-pong form.
+*
+*  DLASQ5 computes one dqds transform in ping-pong form, one
+*  version for IEEE machines another for non IEEE machines.
 *
 *  Arguments
 *  =========
 *
 *  I0    (input) INTEGER
 *        First index.
 *
 *  N0    (input) INTEGER
@@ -50,73 +53,144 @@
 *        d(N0), the last value of d.
 *
 *  DNM1  (output) DOUBLE PRECISION
 *        d(N0-1).
 *
 *  DNM2  (output) DOUBLE PRECISION
 *        d(N0-2).
 *
+*  IEEE  (input) LOGICAL
+*        Flag for IEEE or non IEEE arithmetic.
+*
 *  =====================================================================
 *
+*     .. Parameter ..
+      DOUBLE PRECISION   ZERO
+      PARAMETER          ( ZERO = 0.0D0 )
+*     ..
 *     .. Local Scalars ..
       INTEGER            J4, J4P2
       DOUBLE PRECISION   D, EMIN, TEMP
 *     ..
 *     .. Intrinsic Functions ..
       INTRINSIC          MIN
 *     ..
 *     .. Executable Statements ..
 *
       IF( ( N0-I0-1 ).LE.0 )
      $   RETURN
 *
       J4 = 4*I0 + PP - 3
-      EMIN = Z( J4+4 )
+      EMIN = Z( J4+4 ) 
       D = Z( J4 ) - TAU
       DMIN = D
+      DMIN1 = -Z( J4 )
 *
-      IF( PP.EQ.0 ) THEN
-         DO 10 J4 = 4*I0, 4*( N0-3 ), 4
-            Z( J4-2 ) = D + Z( J4-1 )
-            TEMP = Z( J4+1 ) / Z( J4-2 )
-            D = D*TEMP - TAU
-            DMIN = MIN( DMIN, D )
-            Z( J4 ) = Z( J4-1 )*TEMP
-            EMIN = MIN( Z( J4 ), EMIN )
-   10    CONTINUE
+      IF( IEEE ) THEN
+*
+*        Code for IEEE arithmetic.
+*
+         IF( PP.EQ.0 ) THEN
+            DO 10 J4 = 4*I0, 4*( N0-3 ), 4
+               Z( J4-2 ) = D + Z( J4-1 ) 
+               TEMP = Z( J4+1 ) / Z( J4-2 )
+               D = D*TEMP - TAU
+               DMIN = MIN( DMIN, D )
+               Z( J4 ) = Z( J4-1 )*TEMP
+               EMIN = MIN( Z( J4 ), EMIN )
+   10       CONTINUE
+         ELSE
+            DO 20 J4 = 4*I0, 4*( N0-3 ), 4
+               Z( J4-3 ) = D + Z( J4 ) 
+               TEMP = Z( J4+2 ) / Z( J4-3 )
+               D = D*TEMP - TAU
+               DMIN = MIN( DMIN, D )
+               Z( J4-1 ) = Z( J4 )*TEMP
+               EMIN = MIN( Z( J4-1 ), EMIN )
+   20       CONTINUE
+         END IF
+*
+*        Unroll last two steps. 
+*
+         DNM2 = D
+         DMIN2 = DMIN
+         J4 = 4*( N0-2 ) - PP
+         J4P2 = J4 + 2*PP - 1
+         Z( J4-2 ) = DNM2 + Z( J4P2 )
+         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
+         DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU
+         DMIN = MIN( DMIN, DNM1 )
+*
+         DMIN1 = DMIN
+         J4 = J4 + 4
+         J4P2 = J4 + 2*PP - 1
+         Z( J4-2 ) = DNM1 + Z( J4P2 )
+         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
+         DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU
+         DMIN = MIN( DMIN, DN )
+*
       ELSE
-         DO 20 J4 = 4*I0, 4*( N0-3 ), 4
-            Z( J4-3 ) = D + Z( J4 )
-            TEMP = Z( J4+2 ) / Z( J4-3 )
-            D = D*TEMP - TAU
-            DMIN = MIN( DMIN, D )
-            Z( J4-1 ) = Z( J4 )*TEMP
-            EMIN = MIN( Z( J4-1 ), EMIN )
-   20    CONTINUE
+*
+*        Code for non IEEE arithmetic.
+*
+         IF( PP.EQ.0 ) THEN
+            DO 30 J4 = 4*I0, 4*( N0-3 ), 4
+               Z( J4-2 ) = D + Z( J4-1 ) 
+               IF( D.LE.ZERO ) THEN
+                  RETURN
+               ELSE 
+                  Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) )
+                  D = Z( J4+1 )*( D / Z( J4-2 ) ) - TAU
+               END IF
+               DMIN = MIN( DMIN, D )
+               EMIN = MIN( EMIN, Z( J4 ) )
+   30       CONTINUE
+         ELSE
+            DO 40 J4 = 4*I0, 4*( N0-3 ), 4
+               Z( J4-3 ) = D + Z( J4 ) 
+               IF( D.LE.ZERO ) THEN
+                  RETURN
+               ELSE 
+                  Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) )
+                  D = Z( J4+2 )*( D / Z( J4-3 ) ) - TAU
+               END IF
+               DMIN = MIN( DMIN, D )
+               EMIN = MIN( EMIN, Z( J4-1 ) )
+   40       CONTINUE
+         END IF
+*
+*        Unroll last two steps. 
+*
+         DNM2 = D
+         DMIN2 = DMIN
+         J4 = 4*( N0-2 ) - PP
+         J4P2 = J4 + 2*PP - 1
+         Z( J4-2 ) = DNM2 + Z( J4P2 )
+         IF( DNM2.LE.ZERO ) THEN
+            RETURN
+         ELSE
+            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
+            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU
+         END IF
+         DMIN = MIN( DMIN, DNM1 )
+*
+         DMIN1 = DMIN
+         J4 = J4 + 4
+         J4P2 = J4 + 2*PP - 1
+         Z( J4-2 ) = DNM1 + Z( J4P2 )
+         IF( DNM1.LE.ZERO ) THEN
+            RETURN
+         ELSE
+            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
+            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU
+         END IF
+         DMIN = MIN( DMIN, DN )
+*
       END IF
 *
-*     Unroll last two steps.
-*
-      DNM2 = D
-      DMIN2 = DMIN
-      J4 = 4*( N0-2 ) - PP
-      J4P2 = J4 + 2*PP - 1
-      Z( J4-2 ) = DNM2 + Z( J4P2 )
-      Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
-      DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU
-      DMIN = MIN( DMIN, DNM1 )
-*
-      DMIN1 = DMIN
-      J4 = J4 + 4
-      J4P2 = J4 + 2*PP - 1
-      Z( J4-2 ) = DNM1 + Z( J4P2 )
-      Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
-      DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU
-      DMIN = MIN( DMIN, DN )
-*
       Z( J4+2 ) = DN
       Z( 4*N0-PP ) = EMIN
       RETURN
 *
 *     End of DLASQ5
 *
       END
diff --git a/libcruft/lapack/dlasq6.f b/libcruft/lapack/dlasq6.f
--- a/libcruft/lapack/dlasq6.f
+++ b/libcruft/lapack/dlasq6.f
@@ -1,27 +1,29 @@
-      SUBROUTINE DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DNM1,
-     $                   DNM2 )
+      SUBROUTINE DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN,
+     $                   DNM1, DNM2 )
 *
 *  -- LAPACK auxiliary routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       INTEGER            I0, N0, PP
       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   Z( * )
 *     ..
 *
 *  Purpose
 *  =======
-*  DLASQ6 computes one dqds transform in ping-pong form.
+*
+*  DLASQ6 computes one dqd (shift equal to zero) transform in
+*  ping-pong form, with protection against underflow and overflow.
 *
 *  Arguments
 *  =========
 *
 *  I0    (input) INTEGER
 *        First index.
 *
 *  N0    (input) INTEGER
@@ -49,75 +51,98 @@
 *  DNM1  (output) DOUBLE PRECISION
 *        d(N0-1).
 *
 *  DNM2  (output) DOUBLE PRECISION
 *        d(N0-2).
 *
 *  =====================================================================
 *
-*     .. Parameters ..
+*     .. Parameter ..
       DOUBLE PRECISION   ZERO
       PARAMETER          ( ZERO = 0.0D0 )
 *     ..
 *     .. Local Scalars ..
       INTEGER            J4, J4P2
-      DOUBLE PRECISION   D, EMIN, SFMIN, TEMP
+      DOUBLE PRECISION   D, EMIN, SAFMIN, TEMP
 *     ..
-*     .. External Functions ..
+*     .. External Function ..
       DOUBLE PRECISION   DLAMCH
       EXTERNAL           DLAMCH
 *     ..
 *     .. Intrinsic Functions ..
       INTRINSIC          MIN
 *     ..
 *     .. Executable Statements ..
 *
       IF( ( N0-I0-1 ).LE.0 )
      $   RETURN
 *
-      SFMIN = DLAMCH( 'Safe minimum' )
+      SAFMIN = DLAMCH( 'Safe minimum' )
       J4 = 4*I0 + PP - 3
-      EMIN = Z( J4+4 )
+      EMIN = Z( J4+4 ) 
       D = Z( J4 )
       DMIN = D
 *
-      DO 10 J4 = 4*I0 - PP, 4*( N0-3 ) - PP, 4
-         J4P2 = J4 + 2*PP - 1
-         Z( J4-2 ) = D + Z( J4P2 )
-         IF( Z( J4-2 ).EQ.ZERO ) THEN
-            Z( J4 ) = ZERO
-            D = Z( J4P2+2 )
-            DMIN = D
-            EMIN = ZERO
-         ELSE IF( SFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) ) THEN
-            TEMP = Z( J4P2+2 ) / Z( J4-2 )
-            Z( J4 ) = Z( J4P2 )*TEMP
-            D = D*TEMP
-         ELSE
-            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
-            D = Z( J4P2+2 )*( D / Z( J4-2 ) )
-         END IF
-         DMIN = MIN( DMIN, D )
-         EMIN = MIN( EMIN, Z( J4 ) )
-   10 CONTINUE
+      IF( PP.EQ.0 ) THEN
+         DO 10 J4 = 4*I0, 4*( N0-3 ), 4
+            Z( J4-2 ) = D + Z( J4-1 ) 
+            IF( Z( J4-2 ).EQ.ZERO ) THEN
+               Z( J4 ) = ZERO
+               D = Z( J4+1 )
+               DMIN = D
+               EMIN = ZERO
+            ELSE IF( SAFMIN*Z( J4+1 ).LT.Z( J4-2 ) .AND.
+     $               SAFMIN*Z( J4-2 ).LT.Z( J4+1 ) ) THEN
+               TEMP = Z( J4+1 ) / Z( J4-2 )
+               Z( J4 ) = Z( J4-1 )*TEMP
+               D = D*TEMP
+            ELSE 
+               Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) )
+               D = Z( J4+1 )*( D / Z( J4-2 ) )
+            END IF
+            DMIN = MIN( DMIN, D )
+            EMIN = MIN( EMIN, Z( J4 ) )
+   10    CONTINUE
+      ELSE
+         DO 20 J4 = 4*I0, 4*( N0-3 ), 4
+            Z( J4-3 ) = D + Z( J4 ) 
+            IF( Z( J4-3 ).EQ.ZERO ) THEN
+               Z( J4-1 ) = ZERO
+               D = Z( J4+2 )
+               DMIN = D
+               EMIN = ZERO
+            ELSE IF( SAFMIN*Z( J4+2 ).LT.Z( J4-3 ) .AND.
+     $               SAFMIN*Z( J4-3 ).LT.Z( J4+2 ) ) THEN
+               TEMP = Z( J4+2 ) / Z( J4-3 )
+               Z( J4-1 ) = Z( J4 )*TEMP
+               D = D*TEMP
+            ELSE 
+               Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) )
+               D = Z( J4+2 )*( D / Z( J4-3 ) )
+            END IF
+            DMIN = MIN( DMIN, D )
+            EMIN = MIN( EMIN, Z( J4-1 ) )
+   20    CONTINUE
+      END IF
 *
-*     Unroll last two steps.
+*     Unroll last two steps. 
 *
       DNM2 = D
       DMIN2 = DMIN
       J4 = 4*( N0-2 ) - PP
       J4P2 = J4 + 2*PP - 1
       Z( J4-2 ) = DNM2 + Z( J4P2 )
       IF( Z( J4-2 ).EQ.ZERO ) THEN
          Z( J4 ) = ZERO
          DNM1 = Z( J4P2+2 )
          DMIN = DNM1
          EMIN = ZERO
-      ELSE IF( SFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) ) THEN
+      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.
+     $         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN
          TEMP = Z( J4P2+2 ) / Z( J4-2 )
          Z( J4 ) = Z( J4P2 )*TEMP
          DNM1 = DNM2*TEMP
       ELSE
          Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
          DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) )
       END IF
       DMIN = MIN( DMIN, DNM1 )
@@ -126,17 +151,18 @@
       J4 = J4 + 4
       J4P2 = J4 + 2*PP - 1
       Z( J4-2 ) = DNM1 + Z( J4P2 )
       IF( Z( J4-2 ).EQ.ZERO ) THEN
          Z( J4 ) = ZERO
          DN = Z( J4P2+2 )
          DMIN = DN
          EMIN = ZERO
-      ELSE IF( SFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) ) THEN
+      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.
+     $         SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN
          TEMP = Z( J4P2+2 ) / Z( J4-2 )
          Z( J4 ) = Z( J4P2 )*TEMP
          DN = DNM1*TEMP
       ELSE
          Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )
          DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) )
       END IF
       DMIN = MIN( DMIN, DN )
diff --git a/libcruft/lapack/zbdsqr.f b/libcruft/lapack/zbdsqr.f
--- a/libcruft/lapack/zbdsqr.f
+++ b/libcruft/lapack/zbdsqr.f
@@ -1,15 +1,15 @@
       SUBROUTINE ZBDSQR( UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U,
      $                   LDU, C, LDC, RWORK, INFO )
 *
 *  -- LAPACK routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       CHARACTER          UPLO
       INTEGER            INFO, LDC, LDU, LDVT, N, NCC, NCVT, NRU
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   D( * ), E( * ), RWORK( * )
       COMPLEX*16         C( LDC, * ), U( LDU, * ), VT( LDVT, * )
@@ -90,19 +90,17 @@
 *          On entry, an N-by-NCC matrix C.
 *          On exit, C is overwritten by Q' * C.
 *          C is not referenced if NCC = 0.
 *
 *  LDC     (input) INTEGER
 *          The leading dimension of the array C.
 *          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
 *
-*  RWORK   (workspace) DOUBLE PRECISION array, dimension
-*            2*N  if only singular values wanted (NCVT = NRU = NCC = 0)
-*            max( 1, 4*N-4 ) otherwise
+*  RWORK   (workspace) DOUBLE PRECISION array, dimension (4*N)
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  If INFO = -i, the i-th argument had an illegal value
 *          > 0:  the algorithm did not converge; D and E contain the
 *                elements of a bidiagonal matrix which is orthogonally
 *                similar to the input matrix B;  if INFO = i, i
 *                elements of E have not converged to zero.
diff --git a/libcruft/lapack/zgelss.f b/libcruft/lapack/zgelss.f
--- a/libcruft/lapack/zgelss.f
+++ b/libcruft/lapack/zgelss.f
@@ -1,15 +1,15 @@
       SUBROUTINE ZGELSS( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,
      $                   WORK, LWORK, RWORK, INFO )
 *
 *  -- LAPACK driver routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK
       DOUBLE PRECISION   RCOND
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   RWORK( * ), S( * )
       COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )
@@ -87,17 +87,17 @@
 *          LWORK >=  2*min(M,N) + max(M,N,NRHS)
 *          For good performance, LWORK should generally be larger.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
-*  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N)-1)
+*  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N))
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value.
 *          > 0:  the algorithm for computing the SVD failed to converge;
 *                if INFO = i, i off-diagonal elements of an intermediate
 *                bidiagonal form did not converge to zero.
 *
@@ -166,17 +166,17 @@
       MINWRK = 1
       IF( INFO.EQ.0 .AND. ( LWORK.GE.1 .OR. LQUERY ) ) THEN
          MAXWRK = 0
          MM = M
          IF( M.GE.N .AND. M.GE.MNTHR ) THEN
 *
 *           Path 1a - overdetermined, with many more rows than columns
 *
-*           Space needed for ZBDSQR is BDSPAC = 5*N-1
+*           Space needed for ZBDSQR is BDSPAC = 5*N
 *
             MM = N
             MAXWRK = MAX( MAXWRK, N+N*ILAENV( 1, 'ZGEQRF', ' ', M, N,
      $               -1, -1 ) )
             MAXWRK = MAX( MAXWRK, N+NRHS*
      $               ILAENV( 1, 'ZUNMQR', 'LC', M, NRHS, N, -1 ) )
          END IF
          IF( M.GE.N ) THEN
@@ -196,17 +196,17 @@
          END IF
          IF( N.GT.M ) THEN
             MINWRK = 2*M + MAX( NRHS, N )
             IF( N.GE.MNTHR ) THEN
 *
 *              Path 2a - underdetermined, with many more columns
 *              than rows
 *
-*              Space needed for ZBDSQR is BDSPAC = 5*M-1
+*              Space needed for ZBDSQR is BDSPAC = 5*M
 *
                MAXWRK = M + M*ILAENV( 1, 'ZGELQF', ' ', M, N, -1, -1 )
                MAXWRK = MAX( MAXWRK, 3*M+M*M+2*M*
      $                  ILAENV( 1, 'ZGEBRD', ' ', M, M, -1, -1 ) )
                MAXWRK = MAX( MAXWRK, 3*M+M*M+NRHS*
      $                  ILAENV( 1, 'ZUNMBR', 'QLC', M, NRHS, M, -1 ) )
                MAXWRK = MAX( MAXWRK, 3*M+M*M+( M-1 )*
      $                  ILAENV( 1, 'ZUNGBR', 'P', M, M, M, -1 ) )
@@ -216,17 +216,17 @@
                   MAXWRK = MAX( MAXWRK, M*M+2*M )
                END IF
                MAXWRK = MAX( MAXWRK, M+NRHS*
      $                  ILAENV( 1, 'ZUNMLQ', 'LC', N, NRHS, M, -1 ) )
             ELSE
 *
 *              Path 2 - underdetermined
 *
-*              Space needed for ZBDSQR is BDSPAC = 5*M-1
+*              Space needed for ZBDSQR is BDSPAC = 5*M
 *
                MAXWRK = 2*M + ( N+M )*ILAENV( 1, 'ZGEBRD', ' ', M, N,
      $                  -1, -1 )
                MAXWRK = MAX( MAXWRK, 2*M+NRHS*
      $                  ILAENV( 1, 'ZUNMBR', 'QLC', M, NRHS, M, -1 ) )
                MAXWRK = MAX( MAXWRK, 2*M+M*
      $                  ILAENV( 1, 'ZUNGBR', 'P', M, N, M, -1 ) )
                MAXWRK = MAX( MAXWRK, N*NRHS )
diff --git a/libcruft/lapack/zgesvd.f b/libcruft/lapack/zgesvd.f
--- a/libcruft/lapack/zgesvd.f
+++ b/libcruft/lapack/zgesvd.f
@@ -1,15 +1,15 @@
       SUBROUTINE ZGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,
      $                   WORK, LWORK, RWORK, INFO )
 *
 *  -- LAPACK driver routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     June 30, 1999
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       CHARACTER          JOBU, JOBVT
       INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   RWORK( * ), S( * )
       COMPLEX*16         A( LDA, * ), U( LDU, * ), VT( LDVT, * ),
@@ -114,18 +114,17 @@
 *          LWORK >=  2*MIN(M,N)+MAX(M,N).
 *          For good performance, LWORK should generally be larger.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
-*  RWORK   (workspace) DOUBLE PRECISION array, dimension
-*                                  (max(3*min(M,N),5*min(M,N)-4))
+*  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N))
 *          On exit, if INFO > 0, RWORK(1:MIN(M,N)-1) contains the
 *          unconverged superdiagonal elements of an upper bidiagonal
 *          matrix B whose diagonal is in S (not necessarily sorted).
 *          B satisfies A = U * B * VT, so it has the same singular
 *          values as A, and singular vectors related by U and VT.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit.
@@ -216,17 +215,17 @@
 *       CWorkspace refers to complex workspace, and RWorkspace to
 *       real workspace. NB refers to the optimal block size for the
 *       immediately following subroutine, as returned by ILAENV.)
 *
       IF( INFO.EQ.0 .AND. ( LWORK.GE.1 .OR. LQUERY ) .AND. M.GT.0 .AND.
      $    N.GT.0 ) THEN
          IF( M.GE.N ) THEN
 *
-*           Space needed for ZBDSQR is BDSPAC = MAX( 3*N, 5*N-4 )
+*           Space needed for ZBDSQR is BDSPAC = 5*N
 *
             IF( M.GE.MNTHR ) THEN
                IF( WNTUN ) THEN
 *
 *                 Path 1 (M much larger than N, JOBU='N')
 *
                   MAXWRK = N + N*ILAENV( 1, 'ZGEQRF', ' ', M, N, -1,
      $                     -1 )
@@ -378,17 +377,17 @@
                IF( .NOT.WNTVN )
      $            MAXWRK = MAX( MAXWRK, 2*N+( N-1 )*
      $                     ILAENV( 1, 'ZUNGBR', 'P', N, N, N, -1 ) )
                MINWRK = 2*N + M
                MAXWRK = MAX( MINWRK, MAXWRK )
             END IF
          ELSE
 *
-*           Space needed for ZBDSQR is BDSPAC = MAX( 3*M, 5*M-4 )
+*           Space needed for ZBDSQR is BDSPAC = 5*M
 *
             IF( N.GE.MNTHR ) THEN
                IF( WNTVN ) THEN
 *
 *                 Path 1t(N much larger than M, JOBVT='N')
 *
                   MAXWRK = M + M*ILAENV( 1, 'ZGELQF', ' ', M, N, -1,
      $                     -1 )
diff --git a/libcruft/lapack/zhetd2.f b/libcruft/lapack/zhetd2.f
--- a/libcruft/lapack/zhetd2.f
+++ b/libcruft/lapack/zhetd2.f
@@ -1,14 +1,14 @@
       SUBROUTINE ZHETD2( UPLO, N, A, LDA, D, E, TAU, INFO )
 *
 *  -- LAPACK routine (version 3.0) --
 *     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
 *     Courant Institute, Argonne National Lab, and Rice University
-*     September 30, 1994
+*     October 31, 1999
 *
 *     .. Scalar Arguments ..
       CHARACTER          UPLO
       INTEGER            INFO, LDA, N
 *     ..
 *     .. Array Arguments ..
       DOUBLE PRECISION   D( * ), E( * )
       COMPLEX*16         A( LDA, * ), TAU( * )
@@ -192,16 +192,18 @@
                CALL ZAXPY( I, ALPHA, A( 1, I+1 ), 1, TAU, 1 )
 *
 *              Apply the transformation as a rank-2 update:
 *                 A := A - v * w' - w * v'
 *
                CALL ZHER2( UPLO, I, -ONE, A( 1, I+1 ), 1, TAU, 1, A,
      $                     LDA )
 *
+            ELSE
+               A( I, I ) = DBLE( A( I, I ) )
             END IF
             A( I, I+1 ) = E( I )
             D( I+1 ) = A( I+1, I+1 )
             TAU( I ) = TAUI
    10    CONTINUE
          D( 1 ) = A( 1, 1 )
       ELSE
 *
@@ -235,16 +237,18 @@
                CALL ZAXPY( N-I, ALPHA, A( I+1, I ), 1, TAU( I ), 1 )
 *
 *              Apply the transformation as a rank-2 update:
 *                 A := A - v * w' - w * v'
 *
                CALL ZHER2( UPLO, N-I, -ONE, A( I+1, I ), 1, TAU( I ), 1,
      $                     A( I+1, I+1 ), LDA )
 *
+            ELSE
+               A( I+1, I+1 ) = DBLE( A( I+1, I+1 ) )
             END IF
             A( I+1, I ) = E( I )
             D( I ) = A( I, I )
             TAU( I ) = TAUI
    20    CONTINUE
          D( N ) = A( N, N )
       END IF
 *
