# HG changeset patch
# User Rik <rik@octave.org>
# Date 1534052813 25200
#      Sat Aug 11 22:46:53 2018 -0700
# Node ID f5ea7511c40547c4030f4eab94f3fcf87d529375
# Parent  e222da9beaac514e7adfaf3797750632b6f01b34
Avoid calculating norm of matrix when not requested in liboctave Matrix classes.

CMatrix.cc, dMatrix.cc, fCMatrix.cc, fMatrix.cc (norm1): Declare colsum as
RowVector since this is what row() returns.
(finverse): Delete unnecessary assignment to info.
(inverse): Use "0.0" instead of "0." for clarity.
(determinant): Don't initialize anorm variable to 0.  Only calculate rcon if
calc_cond is true.  Cuddle parenthesis with variable to indicate indexing.
(rcond): Use "0.0" instead of "0." for clarity.
(utsolve): Use "1.0" instead of "1." for clarity.
(ltsolve): Use "1.0" instead of "1." for clarity.
(fsolve): Check calc_cond before calling norm1 to calculate norm.
(lssolve): Declare nrhs = b_nc rather than calling b.cols () twice.
Declare anorm and initialize it with call to norm1.
Remove octave::warn_singular_matrix call when norm is Inf which produces double
warning.

diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -711,17 +711,17 @@ ComplexMatrix::column (octave_idx_type i
 }
 
 // Local function to calculate the 1-norm.
 static
 double
 norm1 (const ComplexMatrix& a)
 {
   double anorm = 0.0;
-  ColumnVector colsum = a.abs ().sum ().row (0);
+  RowVector colsum = a.abs ().sum ().row (0);
 
   for (octave_idx_type i = 0; i < colsum.numel (); i++)
     {
       double sum = colsum.xelem (i);
       if (octave::math::isinf (sum) || octave::math::isnan (sum))
         {
           anorm = sum;  // Pass Inf or NaN to output
           break;
@@ -856,18 +856,16 @@ ComplexMatrix::finverse (MatrixType& mat
   // Query the optimum work array size.
 
   F77_INT tmp_info = 0;
 
   F77_XFCN (zgetri, ZGETRI, (nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
                              F77_DBLE_CMPLX_ARG (z.fortran_vec ()), lwork,
                              tmp_info));
 
-  info = tmp_info;
-
   lwork = static_cast<F77_INT> (std::real (z(0)));
   lwork = (lwork < 2 * nc ? 2 * nc : lwork);
   z.resize (dim_vector (lwork, 1));
   Complex *pz = z.fortran_vec ();
 
   info = 0;
   tmp_info = 0;
 
@@ -875,18 +873,18 @@ ComplexMatrix::finverse (MatrixType& mat
   double anorm = norm1 (retval);
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
   // and bug #46330, segfault with matrices containing Inf & NaN
   if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
     info = -1;
   else
     {
-      F77_XFCN (zgetrf, ZGETRF, (nc, nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                                 tmp_info));
+      F77_XFCN (zgetrf, ZGETRF, (nc, nc, F77_DBLE_CMPLX_ARG (tmp_data), nr,
+                                 pipvt, tmp_info));
 
       info = tmp_info;
     }
 
   // Throw away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
@@ -954,23 +952,23 @@ ComplexMatrix::inverse (MatrixType& matt
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.ishermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
-      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.)
+      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.0)
         {
           if (numel () == 1)
-            ret = ComplexMatrix (1, 1, 0.);
+            ret = ComplexMatrix (1, 1, 0.0);
           else
             ret = ComplexMatrix (rows (), columns (),
-                                 Complex (octave::numeric_limits<double>::Inf (), 0.));
+                                 Complex (octave::numeric_limits<double>::Inf (), 0.0));
         }
     }
 
   return ret;
 }
 
 ComplexMatrix
 ComplexMatrix::pseudo_inverse (double tol) const
@@ -1198,17 +1196,17 @@ ComplexMatrix::determinant (MatrixType& 
       for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
-      double anorm = 0;
+      double anorm;
       if (calc_cond)
         anorm = norm1 (*this);
 
       F77_INT tmp_info = 0;
 
       char job = 'L';
       F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  F77_DBLE_CMPLX_ARG (tmp_data), nr, tmp_info
@@ -1219,33 +1217,36 @@ ComplexMatrix::determinant (MatrixType& 
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
-          Array<Complex> z (dim_vector (2 * nc, 1));
-          Complex *pz = z.fortran_vec ();
-          Array<double> rz (dim_vector (nc, 1));
-          double *prz = rz.fortran_vec ();
-
-          F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
-                                     rcon, F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          info = tmp_info;
-
-          if (info != 0)
-            rcon = 0.0;
+          if (calc_cond)
+            {
+              Array<Complex> z (dim_vector (2 * nc, 1));
+              Complex *pz = z.fortran_vec ();
+              Array<double> rz (dim_vector (nc, 1));
+              double *prz = rz.fortran_vec ();
+
+              F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                         rcon, F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
+
+              if (info != 0)
+                rcon = 0.0;
+            }
 
           for (F77_INT i = 0; i < nc; i++)
-            retval *= atmp (i,i);
+            retval *= atmp(i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
@@ -1449,30 +1450,31 @@ ComplexMatrix::rcond (MatrixType& mattyp
               F77_INT info = 0;
 
               ComplexMatrix atmp = *this;
               Complex *tmp_data = atmp.fortran_vec ();
 
               Array<F77_INT> ipvt (dim_vector (nr, 1));
               F77_INT *pipvt = ipvt.fortran_vec ();
 
-              if (anorm < 0.)
+              if (anorm < 0.0)
                 anorm = norm1 (atmp);
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               // Work around bug #45577, LAPACK crashes Octave if norm is NaN
               if (octave::math::isnan (anorm))
                 info = -1;
               else
-                F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                                           info));
+                F77_XFCN (zgetrf, ZGETRF, (nr, nr,
+                                           F77_DBLE_CMPLX_ARG (tmp_data),
+                                           nr, pipvt, info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
               else
                 {
@@ -1516,17 +1518,17 @@ ComplexMatrix::utsolve (MatrixType& matt
     retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      rcon = 1.;
+      rcon = 1.0;
       info = 0;
 
       if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const Complex *tmp_data = fortran_vec ();
 
@@ -1614,17 +1616,17 @@ ComplexMatrix::ltsolve (MatrixType& matt
     retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      rcon = 1.;
+      rcon = 1.0;
       info = 0;
 
       if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const Complex *tmp_data = fortran_vec ();
 
@@ -1709,28 +1711,30 @@ ComplexMatrix::fsolve (MatrixType& matty
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b_nc == 0)
     retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      // Calculate the norm of the matrix, for later use.
-      double anorm = -1.;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      double anorm = -1.0;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
-          anorm = norm1 (atmp);
+          // The norm of the matrix for later use when determining rcon.
+          if (calc_cond)
+            anorm = norm1 (atmp);
 
           F77_INT tmp_info = 0;
 
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      F77_DBLE_CMPLX_ARG (tmp_data), nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
           info = tmp_info;
@@ -1807,29 +1811,29 @@ ComplexMatrix::fsolve (MatrixType& matty
           Complex *tmp_data = atmp.fortran_vec ();
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
-          if (anorm < 0.)
+          if (calc_cond && anorm < 0.0)
             anorm = norm1 (atmp);
 
           F77_INT tmp_info = 0;
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
             {
-              F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
-                                         tmp_info));
+              F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data),
+                                         nr, pipvt, tmp_info));
 
               info = tmp_info;
             }
 
           // Throw away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
@@ -1841,18 +1845,17 @@ ComplexMatrix::fsolve (MatrixType& matty
                 octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for
-                  // non-singular matrix.
+                  // Calculate the condition number for non-singular matrix.
                   char job = '1';
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
                                              rcon, F77_DBLE_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
                   info = tmp_info;
 
@@ -2247,23 +2250,22 @@ ComplexMatrix::lssolve (const ComplexMat
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix retval;
 
-  F77_INT nrhs = octave::to_f77_int (b.cols ());
-
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
   F77_INT b_nr = octave::to_f77_int (b.rows ());
   F77_INT b_nc = octave::to_f77_int (b.cols ());
+  F77_INT nrhs = b_nc;  // alias for code readability
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = ComplexMatrix (n, b_nc, Complex (0.0, 0.0));
   else
@@ -2310,17 +2312,16 @@ ComplexMatrix::lssolve (const ComplexMat
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
-      double anorm = 0.0;
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                        + 3*smlsiz*nrhs
                        + std::max ((smlsiz+1)*(smlsiz+1),
@@ -2375,22 +2376,21 @@ ComplexMatrix::lssolve (const ComplexMat
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<F77_INT> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
-      anorm = norm1 (*this);
+      double anorm = norm1 (*this);
 
       if (octave::math::isinf (anorm))
         {
           rcon = 0.0;
-          octave::warn_singular_matrix ();
           retval = ComplexMatrix (n, b_nc, 0.0);
         }
       else if (octave::math::isnan (anorm))
         {
           rcon = octave::numeric_limits<double>::NaN ();
           retval = ComplexMatrix (n, b_nc,
                                   octave::numeric_limits<double>::NaN ());
         }
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -425,17 +425,17 @@ Matrix::column (octave_idx_type i) const
 }
 
 // Local function to calculate the 1-norm.
 static
 double
 norm1 (const Matrix& a)
 {
   double anorm = 0.0;
-  ColumnVector colsum = a.abs ().sum ().row (0);
+  RowVector colsum = a.abs ().sum ().row (0);
 
   for (octave_idx_type i = 0; i < colsum.numel (); i++)
     {
       double sum = colsum.xelem (i);
       if (octave::math::isinf (sum) || octave::math::isnan (sum))
         {
           anorm = sum;  // Pass Inf or NaN to output
           break;
@@ -568,28 +568,26 @@ Matrix::finverse (MatrixType& mattype, o
   F77_INT lwork = -1;
 
   F77_INT tmp_info = 0;
 
   // Query the optimum work array size.
   F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
                              z.fortran_vec (), lwork, tmp_info));
 
-  info = tmp_info;
-
   lwork = static_cast<F77_INT> (z(0));
   lwork = (lwork < 4 * nc ? 4 * nc : lwork);
   z.resize (dim_vector (lwork, 1));
   double *pz = z.fortran_vec ();
 
   info = 0;
   tmp_info = 0;
 
-  // Calculate the norm of the matrix, for later use.
-  double anorm = 0;
+  // Calculate the norm of the matrix for later use when determining rcon.
+  double anorm;
   if (calc_cond)
     anorm = norm1 (retval);
 
   F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, tmp_info));
 
   info = tmp_info;
 
   // Throw away extra info LAPACK gives so as to not change output.
@@ -659,18 +657,18 @@ Matrix::inverse (MatrixType& mattype, oc
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.ishermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
-      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.
-          && ! (numel () == 1))
+      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.0
+          && (numel () != 1))
         ret = Matrix (rows (), columns (),
                       octave::numeric_limits<double>::Inf ());
     }
 
   return ret;
 }
 
 Matrix
@@ -890,17 +888,18 @@ Matrix::determinant (MatrixType& mattype
       for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
-      double anorm = 0;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      double anorm;
       if (calc_cond)
         anorm = norm1 (*this);
 
       F77_INT tmp_info = 0;
 
       char job = 'L';
       F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  tmp_data, nr, tmp_info
@@ -911,33 +910,36 @@ Matrix::determinant (MatrixType& mattype
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
-          Array<double> z (dim_vector (3 * nc, 1));
-          double *pz = z.fortran_vec ();
-          Array<F77_INT> iz (dim_vector (nc, 1));
-          F77_INT *piz = iz.fortran_vec ();
-
-          F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, tmp_data, nr, anorm,
-                                     rcon, pz, piz, tmp_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          info = tmp_info;
-
-          if (info != 0)
-            rcon = 0.0;
+          if (calc_cond)
+            {
+              Array<double> z (dim_vector (3 * nc, 1));
+              double *pz = z.fortran_vec ();
+              Array<F77_INT> iz (dim_vector (nc, 1));
+              F77_INT *piz = iz.fortran_vec ();
+
+              F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nr, tmp_data, nr, anorm,
+                                         rcon, pz, piz, tmp_info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
+
+              if (info != 0)
+                rcon = 0.0;
+            }
 
           for (F77_INT i = 0; i < nc; i++)
-            retval *= atmp (i,i);
+            retval *= atmp(i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
@@ -946,18 +948,18 @@ Matrix::determinant (MatrixType& mattype
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       Matrix atmp = *this;
       double *tmp_data = atmp.fortran_vec ();
 
       info = 0;
       F77_INT tmp_info = 0;
 
-      // Calculate the norm of the matrix, for later use.
-      double anorm = 0;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      double anorm;
       if (calc_cond)
         anorm = norm1 (*this);
 
       F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, tmp_info));
 
       info = tmp_info;
 
       // Throw away extra info LAPACK gives so as to not change output.
@@ -977,20 +979,20 @@ Matrix::determinant (MatrixType& mattype
               double *pz = z.fortran_vec ();
               Array<F77_INT> iz (dim_vector (nc, 1));
               F77_INT *piz = iz.fortran_vec ();
 
               F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nc, tmp_data, nr, anorm,
                                          rcon, pz, piz, tmp_info
                                          F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
             }
 
-          info = tmp_info;
-
           if (info != 0)
             {
               info = -1;
               retval = DET ();
             }
           else
             {
               for (F77_INT i = 0; i < nc; i++)
@@ -1134,17 +1136,17 @@ Matrix::rcond (MatrixType& mattype) cons
               F77_INT info = 0;
 
               Matrix atmp = *this;
               double *tmp_data = atmp.fortran_vec ();
 
               Array<F77_INT> ipvt (dim_vector (nr, 1));
               F77_INT *pipvt = ipvt.fortran_vec ();
 
-              if (anorm < 0.)
+              if (anorm < 0.0)
                 anorm = norm1 (atmp);
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<F77_INT> iz (dim_vector (nc, 1));
               F77_INT *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
@@ -1195,17 +1197,17 @@ Matrix::utsolve (MatrixType& mattype, co
     retval = Matrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Upper && typ != MatrixType::Upper)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      rcon = 1.;
+      rcon = 1.0;
       info = 0;
 
       if (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const double *tmp_data = fortran_vec ();
 
@@ -1249,16 +1251,17 @@ Matrix::utsolve (MatrixType& mattype, co
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           info = tmp_info;
 
           if (info != 0)
             info = -2;
 
+          // FIXME: Why calculate this, rather than just compare to 0.0?
           volatile double rcond_plus_one = rcon + 1.0;
 
           if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
@@ -1292,17 +1295,17 @@ Matrix::ltsolve (MatrixType& mattype, co
     retval = Matrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ != MatrixType::Permuted_Lower && typ != MatrixType::Lower)
         (*current_liboctave_error_handler) ("incorrect matrix type");
 
-      rcon = 1.;
+      rcon = 1.0;
       info = 0;
 
       if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
 
       const double *tmp_data = fortran_vec ();
 
@@ -1383,28 +1386,30 @@ Matrix::fsolve (MatrixType& mattype, con
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      // Calculate the norm of the matrix, for later use.
-      double anorm = -1.;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      double anorm = -1.0;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
-          anorm = norm1 (atmp);
+          // The norm of the matrix for later use when determining rcon.
+          if (calc_cond)
+            anorm = norm1 (atmp);
 
           F77_INT tmp_info = 0;
 
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
           info = tmp_info;
@@ -1478,17 +1483,17 @@ Matrix::fsolve (MatrixType& mattype, con
           info = 0;
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
-          if (anorm < 0.)
+          if (calc_cond && anorm < 0.0)
             anorm = norm1 (atmp);
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<F77_INT> iz (dim_vector (nc, 1));
           F77_INT *piz = iz.fortran_vec ();
 
           F77_INT tmp_info = 0;
@@ -1509,18 +1514,17 @@ Matrix::fsolve (MatrixType& mattype, con
                 octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for
-                  // non-singular matrix.
+                  // Calculate the condition number for non-singular matrix.
                   char job = '1';
                   F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
                   info = tmp_info;
 
@@ -1904,23 +1908,22 @@ Matrix::lssolve (const Matrix& b, octave
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
                  octave_idx_type& rank, double& rcon) const
 {
   Matrix retval;
 
-  F77_INT nrhs = octave::to_f77_int (b.cols ());
-
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
   F77_INT b_nr = octave::to_f77_int (b.rows ());
   F77_INT b_nc = octave::to_f77_int (b.cols ());
+  F77_INT nrhs = b_nc;  // alias for code readability
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = Matrix (n, b_nc, 0.0);
   else
@@ -1965,17 +1968,16 @@ Matrix::lssolve (const Matrix& b, octave
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
       double tmp = octave::math::log2 (dminmn / dsmlsizp1);
-      double anorm = 0.0;
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2027,22 +2029,21 @@ Matrix::lssolve (const Matrix& b, octave
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<F77_INT> (work(0));
       work.resize (dim_vector (lwork, 1));
 
-      anorm = norm1 (*this);
+      double anorm = norm1 (*this);
 
       if (octave::math::isinf (anorm))
         {
           rcon = 0.0;
-          octave::warn_singular_matrix ();
           retval = Matrix (n, b_nc, 0.0);
         }
       else if (octave::math::isnan (anorm))
         {
           rcon = octave::numeric_limits<double>::NaN ();
           retval = Matrix (n, b_nc, octave::numeric_limits<double>::NaN ());
         }
       else
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -714,17 +714,17 @@ FloatComplexMatrix::column (octave_idx_t
 }
 
 // Local function to calculate the 1-norm.
 static
 float
 norm1 (const FloatComplexMatrix& a)
 {
   float anorm = 0.0;
-  FloatColumnVector colsum = a.abs ().sum ().row (0);
+  FloatRowVector colsum = a.abs ().sum ().row (0);
 
   for (octave_idx_type i = 0; i < colsum.numel (); i++)
     {
       float sum = colsum.xelem (i);
       if (octave::math::isinf (sum) || octave::math::isnan (sum))
         {
           anorm = sum;  // Pass Inf or NaN to output
           break;
@@ -859,18 +859,16 @@ FloatComplexMatrix::finverse (MatrixType
   // Query the optimum work array size.
 
   F77_INT tmp_info = 0;
 
   F77_XFCN (cgetri, CGETRI, (nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
                              F77_CMPLX_ARG (z.fortran_vec ()), lwork,
                              tmp_info));
 
-  info = tmp_info;
-
   lwork = static_cast<F77_INT> (std::real (z(0)));
   lwork = (lwork < 2 * nc ? 2 * nc : lwork);
   z.resize (dim_vector (lwork, 1));
   FloatComplex *pz = z.fortran_vec ();
 
   info = 0;
   tmp_info = 0;
 
@@ -957,23 +955,23 @@ FloatComplexMatrix::inverse (MatrixType&
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.ishermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
-      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.)
+      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.0)
         {
           if (numel () == 1)
-            ret = FloatComplexMatrix (1, 1, 0.);
+            ret = FloatComplexMatrix (1, 1, 0.0);
           else
             ret = FloatComplexMatrix (rows (), columns (),
-                                      FloatComplex (octave::numeric_limits<float>::Inf (), 0.));
+                                      FloatComplex (octave::numeric_limits<float>::Inf (), 0.0));
         }
     }
 
   return ret;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::pseudo_inverse (float tol) const
@@ -1201,17 +1199,17 @@ FloatComplexMatrix::determinant (MatrixT
       for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
-      float anorm = 0;
+      float anorm;
       if (calc_cond)
         anorm = norm1 (*this);
 
       F77_INT tmp_info = 0;
 
       char job = 'L';
       F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  F77_CMPLX_ARG (tmp_data), nr, tmp_info
@@ -1222,33 +1220,36 @@ FloatComplexMatrix::determinant (MatrixT
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
-          Array<FloatComplex> z (dim_vector (2 * nc, 1));
-          FloatComplex *pz = z.fortran_vec ();
-          Array<float> rz (dim_vector (nc, 1));
-          float *prz = rz.fortran_vec ();
-
-          F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, F77_CMPLX_ARG (tmp_data), nr, anorm,
-                                     rcon, F77_CMPLX_ARG (pz), prz, tmp_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          info = tmp_info;
-
-          if (info != 0)
-            rcon = 0.0;
+          if (calc_cond)
+            {
+              Array<FloatComplex> z (dim_vector (2 * nc, 1));
+              FloatComplex *pz = z.fortran_vec ();
+              Array<float> rz (dim_vector (nc, 1));
+              float *prz = rz.fortran_vec ();
+
+              F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nr, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                         rcon, F77_CMPLX_ARG (pz), prz, tmp_info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
+
+              if (info != 0)
+                rcon = 0.0;
+            }
 
           for (F77_INT i = 0; i < nc; i++)
-            retval *= atmp (i,i);
+            retval *= atmp(i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
@@ -1452,29 +1453,30 @@ FloatComplexMatrix::rcond (MatrixType& m
               F77_INT info = 0;
 
               FloatComplexMatrix atmp = *this;
               FloatComplex *tmp_data = atmp.fortran_vec ();
 
               Array<F77_INT> ipvt (dim_vector (nr, 1));
               F77_INT *pipvt = ipvt.fortran_vec ();
 
-              if (anorm < 0.)
+              if (anorm < 0.0)
                 anorm = norm1 (atmp);
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               // Work around bug #45577, LAPACK crashes Octave if norm is NaN
               if (octave::math::isnan (anorm))
                 info = -1;
               else
-                F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
+                F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data),
+                                           nr, pipvt, info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
               else
                 {
@@ -1517,17 +1519,17 @@ FloatComplexMatrix::utsolve (MatrixType&
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
-          rcon = 1.;
+          rcon = 1.0;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
               const FloatComplex *tmp_data = fortran_vec ();
@@ -1619,17 +1621,17 @@ FloatComplexMatrix::ltsolve (MatrixType&
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
-          rcon = 1.;
+          rcon = 1.0;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
               const FloatComplex *tmp_data = fortran_vec ();
@@ -1719,28 +1721,30 @@ FloatComplexMatrix::fsolve (MatrixType& 
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b_nc == 0)
     retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-      // Calculate the norm of the matrix, for later use.
-      float anorm = -1.;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      float anorm = -1.0;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
-          anorm = norm1 (atmp);
+          // The norm of the matrix for later use when determining rcon.
+          if (calc_cond)
+            anorm = norm1 (atmp);
 
           F77_INT tmp_info = 0;
 
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      F77_CMPLX_ARG (tmp_data), nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
           info = tmp_info;
@@ -1817,29 +1821,29 @@ FloatComplexMatrix::fsolve (MatrixType& 
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
-          if (anorm < 0.)
+          if (calc_cond && anorm < 0.0)
             anorm = norm1 (atmp);
 
           F77_INT tmp_info = 0;
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
             {
-              F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt,
-                                         tmp_info));
+              F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data),
+                                         nr, pipvt, tmp_info));
 
               info = tmp_info;
             }
 
           // Throw away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
@@ -1851,18 +1855,17 @@ FloatComplexMatrix::fsolve (MatrixType& 
                 octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for
-                  // non-singular matrix.
+                  // Calculate the condition number for non-singular matrix.
                   char job = '1';
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
                                              rcon, F77_CMPLX_ARG (pz), prz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
                   info = tmp_info;
 
@@ -2273,23 +2276,22 @@ FloatComplexMatrix::lssolve (const Float
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                              octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nrhs = octave::to_f77_int (b.cols ());
-
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
   F77_INT b_nr = octave::to_f77_int (b.rows ());
   F77_INT b_nc = octave::to_f77_int (b.cols ());
+  F77_INT nrhs = b_nc;  // alias for code readability
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = FloatComplexMatrix (n, b_nc, FloatComplex (0.0, 0.0));
   else
@@ -2336,17 +2338,16 @@ FloatComplexMatrix::lssolve (const Float
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
-      float anorm = 0.0;
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                        + 3*smlsiz*nrhs
                        + std::max ((smlsiz+1)*(smlsiz+1),
@@ -2401,22 +2402,21 @@ FloatComplexMatrix::lssolve (const Float
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<F77_INT> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
-      anorm = norm1 (*this);
+      float anorm = norm1 (*this);
 
       if (octave::math::isinf (anorm))
         {
           rcon = 0.0;
-          octave::warn_singular_matrix ();
           retval = FloatComplexMatrix (n, b_nc, 0.0);
         }
       else if (octave::math::isnan (anorm))
         {
           rcon = octave::numeric_limits<float>::NaN ();
           retval = FloatComplexMatrix (n, b_nc,
                                        octave::numeric_limits<float>::NaN ());
         }
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -431,17 +431,17 @@ FloatMatrix::column (octave_idx_type i) 
 }
 
 // Local function to calculate the 1-norm.
 static
 float
 norm1 (const FloatMatrix& a)
 {
   float anorm = 0.0;
-  FloatColumnVector colsum = a.abs ().sum ().row (0);
+  FloatRowVector colsum = a.abs ().sum ().row (0);
 
   for (octave_idx_type i = 0; i < colsum.numel (); i++)
     {
       float sum = colsum.xelem (i);
       if (octave::math::isinf (sum) || octave::math::isnan (sum))
         {
           anorm = sum;  // Pass Inf or NaN to output
           break;
@@ -574,28 +574,26 @@ FloatMatrix::finverse (MatrixType& matty
   F77_INT lwork = -1;
 
   F77_INT tmp_info = 0;
 
   // Query the optimum work array size.
   F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
                              z.fortran_vec (), lwork, tmp_info));
 
-  info = tmp_info;
-
   lwork = static_cast<F77_INT> (z(0));
   lwork = (lwork < 4 * nc ? 4 * nc : lwork);
   z.resize (dim_vector (lwork, 1));
   float *pz = z.fortran_vec ();
 
   info = 0;
   tmp_info = 0;
 
-  // Calculate the norm of the matrix, for later use.
-  float anorm = 0;
+  // Calculate the norm of the matrix for later use when determining rcon.
+  float anorm;
   if (calc_cond)
     anorm = norm1 (retval);
 
   F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, tmp_info));
 
   info = tmp_info;
 
   // Throw away extra info LAPACK gives so as to not change output.
@@ -665,18 +663,18 @@ FloatMatrix::inverse (MatrixType& mattyp
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.ishermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
-      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.
-          && ! (numel () == 1))
+      if ((calc_cond || mattype.ishermitian ()) && rcon == 0.0
+          && (numel () != 1))
         ret = FloatMatrix (rows (), columns (),
                            octave::numeric_limits<float>::Inf ());
     }
 
   return ret;
 }
 
 FloatMatrix
@@ -899,17 +897,18 @@ FloatMatrix::determinant (MatrixType& ma
       for (F77_INT i = 0; i < nc; i++)
         retval *= elem (i,i);
     }
   else if (typ == MatrixType::Hermitian)
     {
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
-      float anorm = 0;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      float anorm;
       if (calc_cond)
         anorm = norm1 (*this);
 
       F77_INT tmp_info = 0;
 
       char job = 'L';
       F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                  tmp_data, nr, tmp_info
@@ -920,33 +919,36 @@ FloatMatrix::determinant (MatrixType& ma
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
-          Array<float> z (dim_vector (3 * nc, 1));
-          float *pz = z.fortran_vec ();
-          Array<F77_INT> iz (dim_vector (nc, 1));
-          F77_INT *piz = iz.fortran_vec ();
-
-          F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, tmp_data, nr, anorm,
-                                     rcon, pz, piz, tmp_info
-                                     F77_CHAR_ARG_LEN (1)));
-
-          info = tmp_info;
-
-          if (info != 0)
-            rcon = 0.0;
+          if (calc_cond)
+            {
+              Array<float> z (dim_vector (3 * nc, 1));
+              float *pz = z.fortran_vec ();
+              Array<F77_INT> iz (dim_vector (nc, 1));
+              F77_INT *piz = iz.fortran_vec ();
+
+              F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+                                         nr, tmp_data, nr, anorm,
+                                         rcon, pz, piz, tmp_info
+                                         F77_CHAR_ARG_LEN (1)));
+
+              info = tmp_info;
+
+              if (info != 0)
+                rcon = 0.0;
+            }
 
           for (F77_INT i = 0; i < nc; i++)
-            retval *= atmp (i,i);
+            retval *= atmp(i,i);
 
           retval = retval.square ();
         }
     }
   else if (typ != MatrixType::Full)
     (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
   if (typ == MatrixType::Full)
@@ -955,18 +957,18 @@ FloatMatrix::determinant (MatrixType& ma
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       FloatMatrix atmp = *this;
       float *tmp_data = atmp.fortran_vec ();
 
       info = 0;
       F77_INT tmp_info = 0;
 
-      // Calculate the norm of the matrix, for later use.
-      float anorm = 0;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      float anorm;
       if (calc_cond)
         anorm = norm1 (*this);
 
       F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, tmp_info));
 
       info = tmp_info;
 
       // Throw away extra info LAPACK gives so as to not change output.
@@ -1143,17 +1145,17 @@ FloatMatrix::rcond (MatrixType& mattype)
               F77_INT info = 0;
 
               FloatMatrix atmp = *this;
               float *tmp_data = atmp.fortran_vec ();
 
               Array<F77_INT> ipvt (dim_vector (nr, 1));
               F77_INT *pipvt = ipvt.fortran_vec ();
 
-              if (anorm < 0.)
+              if (anorm < 0.0)
                 anorm = norm1 (atmp);
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<F77_INT> iz (dim_vector (nc, 1));
               F77_INT *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
@@ -1204,17 +1206,17 @@ FloatMatrix::utsolve (MatrixType& mattyp
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatMatrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper || typ == MatrixType::Upper)
         {
-          rcon = 1.;
+          rcon = 1.0;
           info = 0;
 
           if (typ == MatrixType::Permuted_Upper)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
               const float *tmp_data = fortran_vec ();
@@ -1307,17 +1309,17 @@ FloatMatrix::ltsolve (MatrixType& mattyp
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatMatrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower || typ == MatrixType::Lower)
         {
-          rcon = 1.;
+          rcon = 1.0;
           info = 0;
 
           if (typ == MatrixType::Permuted_Lower)
             (*current_liboctave_error_handler)
               ("permuted triangular matrix not implemented");
           else
             {
               const float *tmp_data = fortran_vec ();
@@ -1407,28 +1409,30 @@ FloatMatrix::fsolve (MatrixType& mattype
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b_nc == 0)
     retval = FloatMatrix (nc, b_nc, 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-      // Calculate the norm of the matrix, for later use.
-      float anorm = -1.;
+      // Calculate the norm of the matrix for later use when determining rcon.
+      float anorm = -1.0;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
-          anorm = norm1 (atmp);
+          // The norm of the matrix for later use when determining rcon.
+          if (calc_cond)
+            anorm = norm1 (atmp);
 
           F77_INT tmp_info = 0;
 
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, tmp_info
                                      F77_CHAR_ARG_LEN (1)));
 
           info = tmp_info;
@@ -1499,17 +1503,17 @@ FloatMatrix::fsolve (MatrixType& mattype
           info = 0;
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
-          if (anorm < 0.0)
+          if (calc_cond && anorm < 0.0)
             anorm = norm1 (atmp);
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<F77_INT> iz (dim_vector (nc, 1));
           F77_INT *piz = iz.fortran_vec ();
 
           F77_INT tmp_info = 0;
@@ -1530,18 +1534,17 @@ FloatMatrix::fsolve (MatrixType& mattype
                 octave::warn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for
-                  // non-singular matrix.
+                  // Calculate the condition number for non-singular matrix.
                   char job = '1';
                   F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
                   info = tmp_info;
 
@@ -1931,23 +1934,22 @@ FloatMatrix::lssolve (const FloatMatrix&
 
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
                       octave_idx_type& rank, float& rcon) const
 {
   FloatMatrix retval;
 
-  F77_INT nrhs = octave::to_f77_int (b.cols ());
-
   F77_INT m = octave::to_f77_int (rows ());
   F77_INT n = octave::to_f77_int (cols ());
 
   F77_INT b_nr = octave::to_f77_int (b.rows ());
   F77_INT b_nc = octave::to_f77_int (b.cols ());
+  F77_INT nrhs = b_nc;  // alias for code readability
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = FloatMatrix (n, b_nc, 0.0);
   else
@@ -1992,17 +1994,16 @@ FloatMatrix::lssolve (const FloatMatrix&
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
       float tmp = octave::math::log2 (dminmn / dsmlsizp1);
-      float anorm = 0.0;
 
       F77_INT nlvl = static_cast<F77_INT> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       F77_INT liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2054,22 +2055,21 @@ FloatMatrix::lssolve (const FloatMatrix&
 
           if (work(0) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<F77_INT> (work(0));
       work.resize (dim_vector (lwork, 1));
 
-      anorm = norm1 (*this);
+      float anorm = norm1 (*this);
 
       if (octave::math::isinf (anorm))
         {
           rcon = 0.0;
-          octave::warn_singular_matrix ();
           retval = FloatMatrix (n, b_nc, 0.0);
         }
       else if (octave::math::isnan (anorm))
         {
           rcon = octave::numeric_limits<float>::NaN ();
           retval = FloatMatrix (n, b_nc,
                                 octave::numeric_limits<float>::NaN ());
         }
