# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1450496376 18000
#      Fri Dec 18 22:39:36 2015 -0500
# Node ID 6eff66fb8a023f9a49a2e8542b1296b4ecf29f70
# Parent  9d9270e2f98fb8f1462643179be4cbb0c74d4928
style fixes for comments

* find-dialog.cc, find-dialog.h, display.cc, error.cc, gl-render.cc,
graphics.cc, graphics.in.h, max.cc, oct-handle.h, oct-obj.h,
oct-stream.cc, oct.h, pr-output.cc, profiler.cc, str2double.cc,
symtab.cc, toplev.cc, toplev.h, xgl2ps.c, zfstream.cc, zfstream.h,
__glpk__.cc, audiodevinfo.cc, colamd.cc, symbfact.cc, ov-classdef.cc,
ov-classdef.h, ov-java.cc, op-int.h, pt-pr-code.cc, pt-walk.h:
Use C++-style comments where possible.

diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -1,9 +1,9 @@
-/****************************************************************************
+/*
 
 Find dialog derived from an example from Qt Toolkit (license below (**))
 
 Copyright (C) 2012-2015 Torsten <ttl@justmail.de>
 Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
  All rights reserved.
  Contact: Nokia Corporation (qt-info@nokia.com)
 
@@ -51,17 +51,18 @@ along with Octave; see the file COPYING.
 ** packaging of this file.  Please review the following information to
 ** ensure the GNU General Public License version 3.0 requirements will be
 ** met: http://www.gnu.org/copyleft/gpl.html.
 **
 ** If you have questions regarding the use of this file, please contact
 ** Nokia at qt-info@nokia.com.
 ** $QT_END_LICENSE$
 **
-****************************************************************************/
+
+*/
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #ifdef HAVE_QSCINTILLA
 
 #include <QtGui>
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -1,9 +1,9 @@
-/****************************************************************************
+/*
 
 Find dialog derived from an example from Qt Toolkit (license below (**))
 
 Copyright (C) 2012-2015 Torsten <ttl@justmail.de>
 Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
  All rights reserved.
  Contact: Nokia Corporation (qt-info@nokia.com)
 
@@ -51,17 +51,18 @@ along with Octave; see the file COPYING.
 ** packaging of this file.  Please review the following information to
 ** ensure the GNU General Public License version 3.0 requirements will be
 ** met: http://www.gnu.org/copyleft/gpl.html.
 **
 ** If you have questions regarding the use of this file, please contact
 ** Nokia at qt-info@nokia.com.
 ** $QT_END_LICENSE$
 **
-****************************************************************************/
+
+*/
 
 #ifndef FIND_DIALOG_H
 #define FIND_DIALOG_H
 
 #include <QDialog>
 #include <Qsci/qsciscintilla.h>
 
 class QCheckBox;
diff --git a/libinterp/corefcn/display.cc b/libinterp/corefcn/display.cc
--- a/libinterp/corefcn/display.cc
+++ b/libinterp/corefcn/display.cc
@@ -67,18 +67,19 @@ display_info::init (bool query)
   if (display)
     {
 #if defined (HAVE_CARBON_CGDISPLAYBITSPERPIXEL)
 
       dp = CGDisplayBitsPerPixel (display);
 
 #else
 
-     /* FIXME: This will only work for MacOS > 10.5. For earlier versions
-        this code is not needed (use CGDisplayBitsPerPixel instead).  */
+      // FIXME: This will only work for MacOS > 10.5. For earlier
+      // versions this code is not needed (use CGDisplayBitsPerPixel
+      // instead).
 
       CGDisplayModeRef mode = CGDisplayCopyDisplayMode (display);
       CFStringRef pixelEncoding = CGDisplayModeCopyPixelEncoding (mode);
 
       if (CFStringCompare (pixelEncoding, CFSTR (IO32BitDirectPixels), 0) == 0)
         dp = 32;
       else if (CFStringCompare (pixelEncoding,
                                 CFSTR (IO16BitDirectPixels), 0) == 0)
@@ -88,19 +89,19 @@ display_info::init (bool query)
 
 #endif
 
       ht = CGDisplayPixelsHigh (display);
       wd = CGDisplayPixelsWide (display);
 
       CGSize sz_mm = CGDisplayScreenSize (display);
 
-      /* For MacOS >= 10.6, CGSize is a struct keeping 2 CGFloat
-         values, but the CGFloat typedef is not present on older
-         systems, so use double instead.  */
+      // For MacOS >= 10.6, CGSize is a struct keeping 2 CGFloat
+      // values, but the CGFloat typedef is not present on older
+      // systems, so use double instead.
 
       double ht_mm = sz_mm.height;
       double wd_mm = sz_mm.width;
 
       rx = wd * 25.4 / wd_mm;
       ry = ht * 25.4 / ht_mm;
 
       dpy_avail = true;
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -2029,17 +2029,18 @@ With two arguments, also set the last me
     }
 
   if (nargin == 0 || nargout > 0)
     return ovl (prev_warning_message, prev_warning_id);
   else
     return ovl ();
 }
 
-/* FIXME: Deprecated in 4.0 and scheduled for removal in 4.4 */
+// FIXME: Deprecated in 4.0 and scheduled for removal in 4.4.
+
 DEFUN (__usage__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} usage (@var{msg})\n\
 Print the message @var{msg}, prefixed by the string @samp{usage: }, and\n\
 set Octave's internal error state such that control will return to the\n\
 top level without evaluating any more commands.  This is useful for\n\
 aborting from functions.\n\
 \n\
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -585,17 +585,17 @@ opengl_renderer::draw (const graphics_ob
     draw_hggroup (dynamic_cast<const hggroup::properties&> (props));
   else if (go.isa ("text"))
     draw_text (dynamic_cast<const text::properties&> (props));
   else if (go.isa ("image"))
     draw_image (dynamic_cast<const image::properties&> (props));
   else if (go.isa ("uimenu") || go.isa ("uicontrol")
            || go.isa ("uicontextmenu") || go.isa ("uitoolbar")
            || go.isa ("uipushtool") || go.isa ("uitoggletool"))
-    /* SKIP */;
+    ; // SKIP
   else if (go.isa ("uipanel"))
     {
       if (toplevel)
         draw_uipanel (dynamic_cast<const uipanel::properties&> (props), go);
     }
   else
     {
       warning ("opengl_renderer: cannot render object of type '%s'",
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -5543,17 +5543,17 @@ axes::properties::update_axes_layout (vo
   xyzSym = zSign ? xySym : !xySym;
   xpTick = (zSign ? xPlaneN : xPlane);
   ypTick = (zSign ? yPlaneN : yPlane);
   zpTick = (zSign ? zPlane : zPlaneN);
   xpTickN = (zSign ? xPlane : xPlaneN);
   ypTickN = (zSign ? yPlane : yPlaneN);
   zpTickN = (zSign ? zPlaneN : zPlane);
 
-  /* 2D mode */
+  // 2D mode
   x2Dtop = false;
   y2Dright = false;
   layer2Dtop = false;
   if (xstate == AXE_HORZ_DIR && ystate == AXE_VERT_DIR)
     {
       if (xaxislocation_is ("top"))
         {
           std::swap (yPlane, yPlaneN);
@@ -8031,20 +8031,20 @@ text::properties::update_text_extent (vo
 
   octave_value string_prop = get_string ();
 
   string_vector sv = string_prop.all_strings ();
 
   renderer.text_to_pixels (sv.join ("\n"), pixels, bbox,
                            halign, valign, get_rotation (),
                            get_interpreter ());
-  /* The bbox is relative to the text's position.
-     We'll leave it that way, because get_position () does not return
-     valid results when the text is first constructed.
-     Conversion to proper coordinates is performed in get_extent. */
+  // The bbox is relative to the text's position.  We'll leave it that
+  // way, because get_position does not return valid results when the
+  // text is first constructed.  Conversion to proper coordinates is
+  // performed in get_extent.
   set_extent (bbox);
 
 #endif
 
   if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel")
       || autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
     update_autopos ("sync");
 }
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1944,17 +1944,17 @@ public:
   OCTINTERP_API static
   property create (const std::string& name, const graphics_handle& parent,
                    const caseless_str& type,
                    const octave_value_list& args);
 
   property clone (void) const
   { return property (rep->clone ()); }
 
-  /*
+#if 0
   const string_property& as_string_property (void) const
     { return *(dynamic_cast<string_property*> (rep)); }
 
   const radio_property& as_radio_property (void) const
     { return *(dynamic_cast<radio_property*> (rep)); }
 
   const color_property& as_color_property (void) const
     { return *(dynamic_cast<color_property*> (rep)); }
@@ -1962,17 +1962,17 @@ public:
   const double_property& as_double_property (void) const
     { return *(dynamic_cast<double_property*> (rep)); }
 
   const bool_property& as_bool_property (void) const
     { return *(dynamic_cast<bool_property*> (rep)); }
 
   const handle_property& as_handle_property (void) const
     { return *(dynamic_cast<handle_property*> (rep)); }
-    */
+#endif
 
 private:
   base_property *rep;
 };
 
 // ---------------------------------------------------------------------
 
 typedef std::pair <std::string, octave_value> pval_pair;
@@ -2519,18 +2519,18 @@ public:
     children.adopt (h.value ());
     children.run_listeners ();
     mark_modified ();
   }
 
   virtual graphics_toolkit get_toolkit (void) const;
 
   virtual Matrix
-  get_boundingbox (bool /*internal*/ = false,
-                   const Matrix& /*parent_pix_size*/ = Matrix ()) const
+  get_boundingbox (bool /* finternal */ = false,
+                   const Matrix& /* parent_pix_size */ = Matrix ()) const
   { return Matrix (1, 4, 0.0); }
 
   virtual void update_boundingbox (void);
 
   virtual void update_autopos (const std::string& elem_type);
 
   virtual void add_listener (const caseless_str&, const octave_value&,
                              listener_mode = POSTSET);
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -338,21 +338,19 @@ do_minmax_body (const octave_value_list&
     {
       octave_value argx = args(0);
       octave_value argy = args(1);
       builtin_type_t xtyp = argx.builtin_type ();
       builtin_type_t ytyp = argy.builtin_type ();
       builtin_type_t rtyp;
       if (xtyp == btyp_char && ytyp == btyp_char)
         rtyp = btyp_char;
-      /*
-      FIXME: This is what should happen when boolNDArray has max()
-      else if (xtyp == btyp_bool && ytyp == btyp_bool)
-        rtyp = btyp_bool;
-      */
+      // FIXME: This is what should happen when boolNDArray has max()
+      // else if (xtyp == btyp_bool && ytyp == btyp_bool)
+      //   rtyp = btyp_bool;
       else
         rtyp = btyp_mixed_numeric (xtyp, ytyp);
 
       switch (rtyp)
         {
         case btyp_double:
           {
             if ((argx.is_sparse_type ()
@@ -399,22 +397,21 @@ do_minmax_body (const octave_value_list&
         MAKE_INT_BRANCH (int64);
         MAKE_INT_BRANCH (uint8);
         MAKE_INT_BRANCH (uint16);
         MAKE_INT_BRANCH (uint32);
         MAKE_INT_BRANCH (uint64);
 
 #undef MAKE_INT_BRANCH
 
-        /*
-        FIXME: This is what should happen when boolNDArray has max()
-        case btyp_bool:
-          retval = do_minmax_bin_op<boolNDArray> (argx, argy, ismin);
-          break;
-        */
+        // FIXME: This is what should happen when boolNDArray has max()
+        // case btyp_bool:
+        //   retval = do_minmax_bin_op<boolNDArray> (argx, argy, ismin);
+        //   break;
+
         default:
           error ("%s: cannot compute %s (%s, %s)", func, func,
                  argx.type_name ().c_str (), argy.type_name ().c_str ());
         }
 
       // FIXME: Delete when boolNDArray has max()
       if (xtyp == btyp_bool && ytyp == btyp_bool)
         retval(0) = retval(0).bool_array_value ();
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
--- a/libinterp/corefcn/oct-handle.h
+++ b/libinterp/corefcn/oct-handle.h
@@ -34,17 +34,17 @@ class octave_handle
 {
 public:
   octave_handle (void) : val (octave_NaN) { }
 
   octave_handle (const octave_value& a)
     : val (octave_NaN)
   {
     if (a.is_empty ())
-      /* do nothing */;
+      ; // do nothing
     else
       {
         try
           {
             val = a.double_value ();
           }
         catch (octave_execution_exception& e)
           {
diff --git a/libinterp/corefcn/oct-obj.h b/libinterp/corefcn/oct-obj.h
--- a/libinterp/corefcn/oct-obj.h
+++ b/libinterp/corefcn/oct-obj.h
@@ -15,16 +15,16 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-////////////////////////////////////////////////////////////////////////////////
-// oct-obj.h was deprecated in version 4.2 and will be removed in version 4.6.
-////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////
+// Note: oct-obj.h was deprecated in version 4.2 and will be removed in
+// version 4.6.
+////////////////////////////////////////////////////////////////////////
 
 #warning oct-obj.h has been deprecated; use ovl.h instead
 
 #include "ovl.h" 
-
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -206,17 +206,17 @@ scanf_format_list::scanf_format_list (co
           type = scanf_format_elt::whitespace_conversion;
 
           width = 0;
           discard = false;
           modifier = '\0';
           *buf << " ";
 
           while (++i < n && isspace (s[i]))
-            /* skip whitespace */;
+            ; // skip whitespace
 
           add_elt_to_list (width, discard, type, modifier, num_elts);
 
           have_more = false;
         }
       else
         {
           type = scanf_format_elt::literal_conversion;
@@ -1125,17 +1125,17 @@ octave_scan_1 (std::istream& is, const s
       is >> std::hex >> ref >> std::dec;
       break;
 
     case 'i':
       {
         int c1 = EOF;
 
         while (is && (c1 = is.get ()) != EOF && isspace (c1))
-          { /* skip whitespace */ }
+          ; // skip whitespace
 
         if (c1 != EOF)
           {
             if (c1 == '0')
               {
                 int c2 = is.peek ();
 
                 if (c2 == 'x' || c2 == 'X')
@@ -1218,17 +1218,17 @@ octave_scan<> (std::istream& is, const s
     {
     case 'e':
     case 'f':
     case 'g':
       {
         int c1 = EOF;
 
         while (is && (c1 = is.get ()) != EOF && isspace (c1))
-          { /* skip whitespace */ }
+          ; // skip whitespace
 
         if (c1 != EOF)
           {
             is.putback (c1);
 
             ref = octave_read_value<double> (is);
           }
       }
diff --git a/libinterp/corefcn/oct.h b/libinterp/corefcn/oct.h
--- a/libinterp/corefcn/oct.h
+++ b/libinterp/corefcn/oct.h
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_oct_h)
 #define octave_oct_h 1
 
 // Things that are often included to create .oct files.
 
-// config.h needs to be first because it includes #defines that can */
+// config.h needs to be first because it includes #defines that can
 // affect other header files.
 
 #include <config.h>
 
 #include "Matrix.h"
 
 #include "oct-locbuf.h"
 #include "defun-dld.h"
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -213,40 +213,43 @@ private:
 
 static int
 calc_scale_exp (const int& x)
 {
   if (! print_eng)
     return x;
   else
     return x - 3*static_cast<int> (x/3);
-  /* The expression above is equivalent to x - (x % 3).
-   * According to the ISO specification for C++ the modulo operator is
-   * compiler dependent if any of the arguments are negative.  Since this
-   * function will need to work on negative arguments, and we want to avoid
-   * portability issues, we re-implement the modulo function to the desired
-   * behavior (truncation).  There may be a gnulib replacement.
-   *
-   * ISO/IEC 14882:2003 : Programming languages -- C++. 5.6.4: ISO, IEC. 2003 .
-   * "the binary % operator yields the remainder from the division of the first
-   * expression by the second. .... If both operands are nonnegative then the
-   * remainder is nonnegative; if not, the sign of the remainder is
-   * implementation-defined".  */
+
+  // The expression above is equivalent to x - (x % 3).
+
+  // According to the ISO specification for C++ the modulo operator is
+  // compiler dependent if any of the arguments are negative.  Since
+  // this function will need to work on negative arguments, and we want
+  // to avoid portability issues, we re-implement the modulo function to
+  // the desired behavior (truncation).  There may be a gnulib
+  // replacement.
+
+  // ISO/IEC 14882:2003 : Programming languages -- C++. 5.6.4: ISO,
+  // IEC. 2003 . "the binary % operator yields the remainder from the
+  // division of the first expression by the second. .... If both
+  // operands are nonnegative then the remainder is nonnegative; if not,
+  // the sign of the remainder is implementation-defined".
 }
 
 static int
 engineering_exponent (const double& x)
 {
   int ex = 0;
   if (x != 0)
     {
       double absval = (x < 0.0 ? -x : x);
       int logabsval = static_cast<int> (gnulib::floor (log10 (absval)));
-      /* Avoid using modulo function with negative arguments for portability.
-       * See extended comment at calc_scale_exp */
+      // Avoid using modulo function with negative arguments for
+      // portability.  See extended comment at calc_scale_exp
       if (logabsval < 0.0)
         ex = logabsval - 2 + ((-logabsval + 2) % 3);
       else
         ex = logabsval - (logabsval % 3);
     }
   return ex;
 }
 
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -125,20 +125,20 @@ profile_data_accumulator::tree_node::bui
   for (child_map::const_iterator i = children.begin ();
        i != children.end (); ++i)
     i->second->build_flat (data);
 }
 
 octave_value
 profile_data_accumulator::tree_node::get_hierarchical (double* total) const
 {
-  /* Note that we don't generate the entry just for this node, but rather
-     a struct-array with entries for all children.  This way, the top-node
-     (for which we don't want a real entry) generates already the final
-     hierarchical profile data.  */
+  // Note that we don't generate the entry just for this node, but
+  // rather a struct-array with entries for all children.  This way, the
+  // top-node (for which we don't want a real entry) generates already
+  // the final hierarchical profile data.
 
   const octave_idx_type n = children.size ();
 
   Cell rv_indices (n, 1);
   Cell rv_times (n, 1);
   Cell rv_totals (n, 1);
   Cell rv_calls (n, 1);
   Cell rv_children (n, 1);
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -405,9 +405,9 @@ risk of using @code{eval} on unknown dat
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
 %!assert (str2double ("-i*NaN - Inf"), complex (-Inf, -NaN))
 %!assert (str2double ({"abc", "4i"}), [NaN + 0i, 4i])
 %!assert (str2double ({2, "4i"}), [NaN + 0i, 4i])
 %!assert (str2double (zeros (3,1,2)), NaN)
 %!assert (str2double (''), NaN)
 %!assert (str2double ([]), NaN)
 %!assert (str2double (char(zeros(3,0))), NaN)
- */
+*/
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1891,9 +1891,9 @@ updated to use some other function.
 %!function x = bar ()
 %!  x = 5;
 %!endfunction
 %!test
 %! assert (bar == 5);
 %! assert (strcmp (which ("bar"), ""));
 %! clear bar;
 %! assert (! strcmp (which ("bar"), ""));
- */
+*/
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1549,17 +1549,17 @@ int debug_new_delete = 0;
 typedef void (*vfp)(void);
 extern vfp __new_handler;
 
 void *
 __builtin_new (size_t sz)
 {
   void *p;
 
-  /* malloc (0) is unpredictable; avoid it.  */
+  // malloc (0) is unpredictable; avoid it.
   if (sz == 0)
     sz = 1;
   p = gnulib::malloc (sz);
   while (p == 0)
     {
       (*__new_handler) ();
       p = gnulib::malloc (sz);
     }
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -201,22 +201,23 @@ public:
     return instance_ok () ? instance->do_current_scope () : 0;
   }
 
   static symbol_table::context_id current_context (void)
   {
     return instance_ok () ? instance->do_current_context () : 0;
   }
 
-  /*
+#if 0
   static stack_frame frame (size_t idx)
   {
     return instance_ok () ? instance->do_frame (idx) : stack_frame ();
   }
-  */
+#endif
+
   // Function at location N on the call stack (N == 0 is current), may
   // be built-in.
   static octave_function *element (size_t n)
   {
     return instance_ok () ? instance->do_element (n) : 0;
   }
 
   // First user-defined function on the stack.
@@ -380,23 +381,25 @@ private:
   }
 
   symbol_table::context_id do_current_context (void) const
   {
     return curr_frame > 0 && curr_frame < cs.size ()
            ? cs[curr_frame].m_context : 0;
   }
 
-  /*  const stack_frame& do_frame (size_t idx)
+#if 0
+  const stack_frame& do_frame (size_t idx)
   {
     static stack_frame foobar;
 
     return idx < cs.size () ? cs[idx] : foobar;
   }
-  */
+#endif
+
   octave_function *do_element (size_t n)
   {
     octave_function *retval = 0;
 
     if (cs.size () > n)
       {
         stack_frame& elt = cs[n];
         retval = elt.m_fcn;
diff --git a/libinterp/corefcn/xgl2ps.c b/libinterp/corefcn/xgl2ps.c
--- a/libinterp/corefcn/xgl2ps.c
+++ b/libinterp/corefcn/xgl2ps.c
@@ -15,20 +15,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-/*
- * Wrapper for "imported" file gl2ps.c so that config.h will be included
- * before any other system or gnulib headers.
- */
+/* Wrapper for "imported" file gl2ps.c so that config.h will be included
+   before any other system or gnulib headers.  */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #if defined (HAVE_OPENGL)
 
 #include "gl2ps.c"
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -46,18 +46,16 @@ along with Octave; see the file COPYING.
 // For BUFSIZ.
 #include <cstdio>
 
 // Internal buffer sizes (default and "unbuffered" versions)
 #define STASHED_CHARACTERS 16
 #define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS)
 #define SMALLBUFSIZE 1
 
-/*****************************************************************************/
-
 // Default constructor
 gzfilebuf::gzfilebuf ()
   : file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
     buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
 {
   // No buffers to start with
   this->disable_buffer ();
 }
@@ -512,18 +510,16 @@ gzfilebuf::seekpos (pos_type sp, std::io
       else
         // flush contents of buffer to file
         overflow ();
     }
 
   return ret;
 }
 
-/*****************************************************************************/
-
 // Default constructor initializes stream buffer
 gzifstream::gzifstream ()
   : std::istream (0), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
 gzifstream::gzifstream (const char* name, std::ios_base::openmode mode)
   : std::istream (0), sb ()
@@ -563,18 +559,16 @@ gzifstream::attach (int fd, std::ios_bas
 // Close file
 void
 gzifstream::close ()
 {
   if (! sb.close ())
     this->setstate (std::ios_base::failbit);
 }
 
-/*****************************************************************************/
-
 // Default constructor initializes stream buffer
 gzofstream::gzofstream ()
   : std::ostream (0), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
 gzofstream::gzofstream (const char* name, std::ios_base::openmode mode)
   : std::ostream (0), sb ()
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -34,18 +34,16 @@ along with Octave; see the file COPYING.
 #define ZFSTREAM_H
 
 #ifdef HAVE_ZLIB
 
 #include <iosfwd>
 
 #include "zlib.h"
 
-/*****************************************************************************/
-
 /**
  *  @brief  Gzipped file stream buffer class.
  *
  *  This class implements basic_filebuf for gzipped files. It doesn't yet
  *  support seeking (allowed by zlib but slow/limited), putback and read/write
  *  access *  (tricky). Otherwise, it attempts to be a drop-in replacement for
  *  the standard file streambuf.
 */
@@ -265,18 +263,16 @@ private:
    *  @brief  True if this object owns stream buffer.
    *
    *  This makes the class responsible for deleting the buffer
    *  upon destruction.
   */
   bool own_buffer;
 };
 
-/*****************************************************************************/
-
 /**
  *  @brief  Gzipped file input stream class.
  *
  *  This class implements ifstream for gzipped files. Seeking and putback
  *  is not supported yet.
 */
 class gzifstream : public std::istream
 {
@@ -354,18 +350,16 @@ public:
 
 private:
   /**
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
-/*****************************************************************************/
-
 /**
  *  @brief  Gzipped file output stream class.
  *
  *  This class implements ofstream for gzipped files. Seeking and putback
  *  is not supported yet.
 */
 class gzofstream : public std::ostream
 {
@@ -443,18 +437,16 @@ public:
 
 private:
   /**
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
-/*****************************************************************************/
-
 /**
  *  @brief  Gzipped file output stream manipulator class.
  *
  *  This class defines a two-argument manipulator for gzofstream. It is used
  *  as base for the setcompression(int,int) manipulator.
 */
 template<typename T1, typename T2>
 class gzomanip2
@@ -475,18 +467,16 @@ private:
   gzofstream&
   (*func)(gzofstream&, T1, T2);
 
   // Arguments for manipulator function
   T1 val1;
   T2 val2;
 };
 
-/*****************************************************************************/
-
 // Manipulator function thunks through to stream buffer
 inline gzofstream&
 setcompression (gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
 {
   (gzs.rdbuf ())->setcompression (l, s);
   return gzs;
 }
 
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -66,43 +66,43 @@ struct control_params
   double toldj;
   double tolpiv;
   double objll;
   double objul;
   double tolint;
   double tolobj;
 };
 
-static jmp_buf mark;  //-- Address for long jump to jump to
+static jmp_buf mark;  // Address for long jump to jump to
 
 int
 glpk (int sense, int n, int m, double *c, int nz, int *rn, int *cn,
       double *a, double *b, char *ctype, int *freeLB, double *lb,
       int *freeUB, double *ub, int *vartype, int isMIP, int lpsolver,
       int save_pb, int scale, const control_params *par,
       double *xmin, double *fmin, int *status,
       double *lambda, double *redcosts, double *time)
 {
   int typx = 0;
   int errnum = 0;
 
   clock_t t_start = clock ();
 
   glp_prob *lp = glp_create_prob ();
 
-  //-- Set the sense of optimization
+  // Set the sense of optimization
   if (sense == 1)
     glp_set_obj_dir (lp, GLP_MIN);
   else
     glp_set_obj_dir (lp, GLP_MAX);
 
   glp_add_cols (lp, n);
   for (int i = 0; i < n; i++)
     {
-      //-- Define type of the structural variables
+      // Define type of the structural variables
       if (! freeLB[i] && ! freeUB[i])
         {
           if (lb[i] != ub[i])
             glp_set_col_bnds (lp, i+1, GLP_DB, lb[i], ub[i]);
           else
             glp_set_col_bnds (lp, i+1, GLP_FX, lb[i], ub[i]);
         }
       else
@@ -125,23 +125,21 @@ glpk (int sense, int n, int m, double *c
       if (isMIP)
         glp_set_col_kind (lp, i+1, vartype[i]);
     }
 
   glp_add_rows (lp, m);
 
   for (int i = 0; i < m; i++)
     {
-      /* If the i-th row has no lower bound (types F,U), the
-         corrispondent parameter will be ignored.
-         If the i-th row has no upper bound (types F,L), the corrispondent
-         parameter will be ignored.
-         If the i-th row is of S type, the i-th LB is used, but
-         the i-th UB is ignored.
-      */
+      // If the i-th row has no lower bound (types F,U), the
+      // corrispondent parameter will be ignored.  If the i-th row has
+      // no upper bound (types F,L), the corrispondent parameter will be
+      // ignored.  If the i-th row is of S type, the i-th LB is used,
+      // but the i-th UB is ignored.
 
       switch (ctype[i])
         {
         case 'F':
           typx = GLP_FR;
           break;
 
         case 'U':
@@ -172,26 +170,26 @@ glpk (int sense, int n, int m, double *c
       static char tmp[] = "outpb.lp";
       if (glp_write_lp (lp, NULL, tmp) != 0)
         {
           error ("__glpk__: unable to write problem");
           longjmp (mark, -1);
         }
     }
 
-  //-- scale the problem data
+  // scale the problem data
   if (!par->presol || lpsolver != 1)
     glp_scale_prob (lp, scale);
 
-  //-- build advanced initial basis (if required)
+  // build advanced initial basis (if required)
   if (lpsolver == 1 && !par->presol)
     glp_adv_basis (lp, 0);
 
-  /* For MIP problems without a presolver, a first pass with glp_simplex
-     is required */
+  // For MIP problems without a presolver, a first pass with glp_simplex
+  // is required
   if ((!isMIP && lpsolver == 1)
       || (isMIP && !par->presol))
     {
       glp_smcp smcp;
       glp_init_smcp (&smcp);
       smcp.msg_lev = par->msglev;
       smcp.meth = par->dual;
       smcp.pricing = par->price;
@@ -256,35 +254,35 @@ glpk (int sense, int n, int m, double *c
 
       if (isMIP)
         {
           for (int i = 0; i < n; i++)
             xmin[i] = glp_mip_col_val (lp, i+1);
         }
       else
         {
-          /* Primal values */
+          // Primal values
           for (int i = 0; i < n; i++)
             {
               if (lpsolver == 1)
                 xmin[i] = glp_get_col_prim (lp, i+1);
               else
                 xmin[i] = glp_ipt_col_prim (lp, i+1);
             }
 
-          /* Dual values */
+          // Dual values
           for (int i = 0; i < m; i++)
             {
               if (lpsolver == 1)
                 lambda[i] = glp_get_row_dual (lp, i+1);
               else
                 lambda[i] = glp_ipt_row_dual (lp, i+1);
             }
 
-          /* Reduced costs */
+          // Reduced costs
           for (int i = 0; i < glp_get_num_cols (lp); i++)
             {
               if (lpsolver == 1)
                 redcosts[i] = glp_get_col_dual (lp, i+1);
               else
                 redcosts[i] = glp_ipt_col_dual (lp, i+1);
             }
         }
@@ -398,46 +396,46 @@ Undocumented internal function.\n\
                   cn(nz) = j + 1;
                   a(nz) = A(i,j);
                 }
             }
         }
 
     }
 
-  //-- 3rd Input. A column array containing the right-hand side value
+  // 3rd Input. A column array containing the right-hand side value
   //               for each constraint in the constraint matrix.
   Matrix B = args(2).xmatrix_value ("__glpk__: invalid value of B");
 
   double *b = B.fortran_vec ();
 
-  //-- 4th Input. An array of length mrowsc containing the lower
-  //--            bound on each of the variables.
+  // 4th Input. An array of length mrowsc containing the lower
+  //            bound on each of the variables.
   Matrix LB = args(3).xmatrix_value ("__glpk__: invalid value of LB");
 
   if (LB.numel () < mrowsc)
     error ("__glpk__: invalid dimensions for LB");
 
   double *lb = LB.fortran_vec ();
 
-  //-- LB argument, default: Free
+  // LB argument, default: Free
   Array<int> freeLB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (lb[i]))
         {
           freeLB(i) = 1;
           lb[i] = -octave_Inf;
         }
       else
         freeLB(i) = 0;
     }
 
-  //-- 5th Input. An array of at least length numcols containing the upper
-  //--            bound on each of the variables.
+  // 5th Input. An array of at least length numcols containing the upper
+  //            bound on each of the variables.
   Matrix UB = args(4).xmatrix_value ("__glpk__: invalid value of UB");
 
   if (UB.numel () < mrowsc)
     error ("__glpk__: invalid dimensions for UB");
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (dim_vector (mrowsc, 1));
@@ -447,161 +445,157 @@ Undocumented internal function.\n\
         {
           freeUB(i) = 1;
           ub[i] = octave_Inf;
         }
       else
         freeUB(i) = 0;
     }
 
-  //-- 6th Input. A column array containing the sense of each constraint
-  //--            in the constraint matrix.
+  // 6th Input. A column array containing the sense of each constraint
+  //            in the constraint matrix.
   charMatrix CTYPE = args(5).char_matrix_value ("__glpk__: invalid value of CTYPE");
 
   char *ctype = CTYPE.fortran_vec ();
 
-  //-- 7th Input. A column array containing the types of the variables.
+  // 7th Input. A column array containing the types of the variables.
   charMatrix VTYPE = args(6).char_matrix_value ("__glpk__: invalid value of VARTYPE");
 
   Array<int> vartype (dim_vector (mrowsc, 1));
   volatile int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
         {
           isMIP = 1;
           vartype(i) = GLP_IV;
         }
       else
         vartype(i) = GLP_CV;
     }
 
-  //-- 8th Input. Sense of optimization.
+  // 8th Input. Sense of optimization.
   volatile int sense;
   double SENSE = args(7).scalar_value ("__glpk__: invalid value of SENSE");
 
   if (SENSE >= 0)
     sense = 1;
   else
     sense = -1;
 
-  //-- 9th Input. A structure containing the control parameters.
+  // 9th Input. A structure containing the control parameters.
   octave_scalar_map PARAM = args(8).xscalar_map_value ("__glpk__: invalid value of PARAM");
 
   control_params par;
 
-  //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-  //-- Integer parameters
-  //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  // Integer parameters
 
-  //-- Level of messages output by the solver
+  // Level of messages output by the solver
   par.msglev = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("msglev", par.msglev);
   if (par.msglev < 0 || par.msglev > 3)
     error ("__glpk__: PARAM.msglev must be 0 (no output) or 1 (error and warning messages only [default]) or 2 (normal output) or 3 (full output)");
 
-  //-- scaling option
+  // scaling option
   volatile int scale = 16;
   OCTAVE_GLPK_GET_INT_PARAM ("scale", scale);
   if (scale < 0 || scale > 128)
     error ("__glpk__: PARAM.scale must either be 128 (automatic selection of scaling options), or a bitwise or of: 1 (geometric mean scaling), 16 (equilibration scaling), 32 (round scale factors to power of two), 64 (skip if problem is well scaled");
 
-  //-- Dual simplex option
+  // Dual simplex option
   par.dual = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("dual", par.dual);
   if (par.dual < 1 || par.dual > 3)
     error ("__glpk__: PARAM.dual must be 1 (use two-phase primal simplex [default]) or 2 (use two-phase dual simplex) or 3 (use two-phase dual simplex, and if it fails, switch to the primal simplex)");
 
-  //-- Pricing option
+  // Pricing option
   par.price = 34;
   OCTAVE_GLPK_GET_INT_PARAM ("price", par.price);
   if (par.price != 17 && par.price != 34)
     error ("__glpk__: PARAM.price must be 17 (textbook pricing) or 34 (steepest edge pricing [default])");
 
-  //-- Simplex iterations limit
+  // Simplex iterations limit
   par.itlim = std::numeric_limits<int>::max ();
   OCTAVE_GLPK_GET_INT_PARAM ("itlim", par.itlim);
 
-  //-- Output frequency, in iterations
+  // Output frequency, in iterations
   par.outfrq = 200;
   OCTAVE_GLPK_GET_INT_PARAM ("outfrq", par.outfrq);
 
-  //-- Branching heuristic option
+  // Branching heuristic option
   par.branch = 4;
   OCTAVE_GLPK_GET_INT_PARAM ("branch", par.branch);
   if (par.branch < 1 || par.branch > 5)
     error ("__glpk__: PARAM.branch must be 1 (first fractional variable) or 2 (last fractional variable) or 3 (most fractional variable) or 4 (heuristic by Driebeck and Tomlin [default]) or 5 (hybrid pseudocost heuristic)");
 
-  //-- Backtracking heuristic option
+  // Backtracking heuristic option
   par.btrack = 4;
   OCTAVE_GLPK_GET_INT_PARAM ("btrack", par.btrack);
   if (par.btrack < 1 || par.btrack > 4)
     error ("__glpk__: PARAM.btrack must be 1 (depth first search) or 2 (breadth first search) or 3 (best local bound) or 4 (best projection heuristic [default]");
 
-  //-- Presolver option
+  // Presolver option
   par.presol = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("presol", par.presol);
   if (par.presol < 0 || par.presol > 1)
     error ("__glpk__: PARAM.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");
 
-  //-- LPsolver option
+  // LPsolver option
   volatile int lpsolver = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("lpsolver", lpsolver);
   if (lpsolver < 1 || lpsolver > 2)
     error ("__glpk__: PARAM.lpsolver must be 1 (simplex method) or 2 (interior point method)");
 
-  //-- Ratio test option
+  // Ratio test option
   par.rtest = 34;
   OCTAVE_GLPK_GET_INT_PARAM ("rtest", par.rtest);
   if (par.rtest != 17 && par.rtest != 34)
     error ("__glpk__: PARAM.rtest must be 17 (standard ratio test) or 34 (Harris' two-pass ratio test [default])");
 
   par.tmlim = std::numeric_limits<int>::max ();
   OCTAVE_GLPK_GET_INT_PARAM ("tmlim", par.tmlim);
 
   par.outdly = 0;
   OCTAVE_GLPK_GET_INT_PARAM ("outdly", par.outdly);
 
-  //-- Save option
+  // Save option
   volatile int save_pb = 0;
   OCTAVE_GLPK_GET_INT_PARAM ("save", save_pb);
   save_pb = save_pb != 0;
 
-  //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-  //-- Real parameters
-  //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  // Real parameters
 
-  //-- Relative tolerance used to check if the current basic solution
-  //-- is primal feasible
+  // Relative tolerance used to check if the current basic solution
+  // is primal feasible
   par.tolbnd = 1e-7;
   OCTAVE_GLPK_GET_REAL_PARAM ("tolbnd", par.tolbnd);
 
-  //-- Absolute tolerance used to check if the current basic solution
-  //-- is dual feasible
+  // Absolute tolerance used to check if the current basic solution
+  // is dual feasible
   par.toldj = 1e-7;
   OCTAVE_GLPK_GET_REAL_PARAM ("toldj", par.toldj);
 
-  //-- Relative tolerance used to choose eligible pivotal elements of
-  //--  the simplex table in the ratio test
+  // Relative tolerance used to choose eligible pivotal elements of
+  //  the simplex table in the ratio test
   par.tolpiv = 1e-10;
   OCTAVE_GLPK_GET_REAL_PARAM ("tolpiv", par.tolpiv);
 
   par.objll = -std::numeric_limits<double>::max ();
   OCTAVE_GLPK_GET_REAL_PARAM ("objll", par.objll);
 
   par.objul = std::numeric_limits<double>::max ();
   OCTAVE_GLPK_GET_REAL_PARAM ("objul", par.objul);
 
   par.tolint = 1e-5;
   OCTAVE_GLPK_GET_REAL_PARAM ("tolint", par.tolint);
 
   par.tolobj = 1e-7;
   OCTAVE_GLPK_GET_REAL_PARAM ("tolobj", par.tolobj);
 
-  //-- Assign pointers to the output parameters
+  // Assign pointers to the output parameters
   ColumnVector xmin (mrowsc, octave_NA);
   double fmin = octave_NA;
   ColumnVector lambda (mrowsA, octave_NA);
   ColumnVector redcosts (mrowsc, octave_NA);
   double time;
   int status;
   volatile int errnum = 0;
 
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -61,19 +61,19 @@ bits_to_format (int bits)
   else if (bits == -1)
     return paFloat32;
   else
     return 0;
 }
 
 #endif
 
-#define NO_PORTAUDIO_MSG\
-  error ("portaudio not found on your system and thus audio functionality is not present");\
-  (void) args;  /*silence compiler warning "unused parameter"*/
+#define NO_PORTAUDIO_MSG \
+  error ("portaudio not found on your system and thus audio functionality is not present"); \
+  (void) args;  /* silence compiler warning "unused parameter" */
 
 DEFUN_DLD (audiodevinfo, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{devinfo} =} audiodevinfo ()\n\
 \n\
 @deftypefnx {} {@var{devs} =} audiodevinfo (@var{io})\n\
 @deftypefnx {} {@var{name} =} audiodevinfo (@var{io}, @var{id})\n\
 @deftypefnx {} {@var{id} =} audiodevinfo (@var{io}, @var{name})\n\
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -144,17 +144,17 @@ tree_postorder (octave_idx_type n, octav
                 octave_idx_type *post)
 {
   // Allocate storage for working arrays and results
   OCTAVE_LOCAL_BUFFER (octave_idx_type, first_kid, n+1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, next_kid, n+1);
 
   // Set up structure describing children
   for (octave_idx_type v = 0; v <= n; first_kid[v++] = -1)
-    /* do nothing */;
+    ; // do nothing
 
   for (octave_idx_type v = n-1; v >= 0; v--)
     {
       octave_idx_type dad = parent[v];
       next_kid[v] = first_kid[dad];
       first_kid[dad] = v;
     }
 
@@ -168,17 +168,17 @@ coletree (const octave_idx_type *ridx, c
           octave_idx_type nr, octave_idx_type nc)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, root, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, pp, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, firstcol, nr);
 
   // Compute firstcol[row] = first nonzero column in row
   for (octave_idx_type row = 0; row < nr; firstcol[row++] = nc)
-    /* do nothing */;
+    ; // do nothing
 
   for (octave_idx_type col = 0; col < nc; col++)
     for (octave_idx_type p = colbeg[col]; p < colend[col]; p++)
       {
         octave_idx_type row = ridx[p];
         if (firstcol[row] > col)
           firstcol[row] = col;
       }
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -269,17 +269,17 @@ factorization as determined by @var{typ}
       for (octave_idx_type j = 0 ; j < n ; j++)
         {
           L.xcidx(j) = lnz;
           lnz += ColCount[j];
         }
       L.xcidx(n) = lnz;
 
 
-      /* create a copy of the column pointers */
+      // create a copy of the column pointers
       octave_idx_type *W = First;
       for (octave_idx_type j = 0 ; j < n ; j++)
         W[j] = L.xcidx (j);
 
       // get workspace for computing one row of L
       cholmod_sparse *R
         = CHOLMOD_NAME (allocate_sparse) (n, 1, n, false, true,
                                           0, CHOLMOD_PATTERN, cm);
@@ -325,17 +325,17 @@ factorization as determined by @var{typ}
     {
       for (octave_idx_type i = 0; i < n; i++)
         tmp(i) = Parent[i] + 1;
       retval(2) = tmp;
     }
 
   if (nargout > 1)
     {
-      /* compute the elimination tree height */
+      // compute the elimination tree height
       octave_idx_type height = 0 ;
       for (int i = 0 ; i < n ; i++)
         height = (height > Level[i] ? height : Level[i]);
       height++ ;
       retval(1) = static_cast<double> (height);
     }
 
   for (octave_idx_type i = 0; i < n; i++)
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -2006,23 +2006,23 @@ public:
   void visit_return_command (tree_return_command&) { }
   void visit_return_list (tree_return_list&) { }
   void visit_try_catch_command (tree_try_catch_command&) { }
   void visit_unwind_protect_command (tree_unwind_protect_command&) { }
   void visit_while_command (tree_while_command&) { }
   void visit_do_until_command (tree_do_until_command&) { }
 
 private:
-  /* The name of the constructor being analyzed */
+  // The name of the constructor being analyzed.
   std::string who;
 
-  /* The name of the first output argument of the constructor */
+  // The name of the first output argument of the constructor.
   std::string obj_name;
 
-  /* The list of superclass constructors that are explicitly called */
+  // The list of superclass constructors that are explicitly called.
   std::list<cdef_class> ctor_list;
 };
 
 void
 cdef_class::cdef_class_rep::install_method (const cdef_method& meth)
 {
   method_map[meth.get_name ()] = meth;
 
@@ -3500,31 +3500,31 @@ cdef_class cdef_class::_meta_package = c
 
 cdef_package cdef_package::_meta = cdef_package ();
 
 void
 install_classdef (void)
 {
   octave_classdef::register_type ();
 
-  /* bootstrap */
+  // bootstrap
   cdef_class handle = make_class ("handle");
   cdef_class meta_class = cdef_class::_meta_class = make_meta_class ("meta.class", handle);
   handle.set_class (meta_class);
   meta_class.set_class (meta_class);
 
-  /* meta classes */
+  // meta classes
   cdef_class meta_property = cdef_class::_meta_property = make_meta_class ("meta.property", handle);
   cdef_class meta_method = cdef_class::_meta_method = make_meta_class ("meta.method", handle);
   cdef_class meta_package = cdef_class::_meta_package = make_meta_class ("meta.package", handle);
 
   cdef_class meta_event = make_meta_class ("meta.event", handle);
   cdef_class meta_dynproperty = make_meta_class ("meta.dynamicproperty", handle);
 
-  /* meta.class properties */
+  // meta.class properties
   meta_class.install_property (make_attribute (meta_class, "Abstract"));
   meta_class.install_property (make_attribute (meta_class, "ConstructOnLoad"));
   meta_class.install_property (make_property  (meta_class, "ContainingPackage"));
   meta_class.install_property (make_property  (meta_class, "Description"));
   meta_class.install_property (make_property  (meta_class, "DetailedDescription"));
   meta_class.install_property (make_property  (meta_class, "Events"));
   meta_class.install_property (make_attribute (meta_class, "HandleCompatible"));
   meta_class.install_property (make_attribute (meta_class, "Hidden"));
@@ -3553,42 +3553,42 @@ install_classdef (void)
   meta_class.install_property
       (make_property (meta_class, "SuperClasses",
                       make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClasses"),
                       "public", Matrix (), "private"));
   meta_class.install_property
       (make_property (meta_class, "SuperClassList",
                       make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClassList"),
                       "public", Matrix (), "private"));
-  /* meta.class methods */
+  // meta.class methods
   meta_class.install_method (make_method (meta_class, "fromName", class_fromName,
                                           "public", true));
   meta_class.install_method (make_method (meta_class, "fevalStatic", class_fevalStatic,
                                           "public", false));
   meta_class.install_method (make_method (meta_class, "getConstant", class_getConstant,
                                           "public", false));
   meta_class.install_method (make_method (meta_class, "eq", class_eq));
   meta_class.install_method (make_method (meta_class, "ne", class_ne));
   meta_class.install_method (make_method (meta_class, "lt", class_lt));
   meta_class.install_method (make_method (meta_class, "le", class_le));
   meta_class.install_method (make_method (meta_class, "gt", class_gt));
   meta_class.install_method (make_method (meta_class, "ge", class_ge));
 
-  /* meta.method properties */
+  // meta.method properties
   meta_method.install_property (make_attribute (meta_method, "Abstract"));
   meta_method.install_property (make_attribute (meta_method, "Access"));
   meta_method.install_property (make_attribute (meta_method, "DefiningClass"));
   meta_method.install_property (make_attribute (meta_method, "Description"));
   meta_method.install_property (make_attribute (meta_method, "DetailedDescription"));
   meta_method.install_property (make_attribute (meta_method, "Hidden"));
   meta_method.install_property (make_attribute (meta_method, "Name"));
   meta_method.install_property (make_attribute (meta_method, "Sealed"));
   meta_method.install_property (make_attribute (meta_method, "Static"));
 
-  /* meta.property properties */
+  // meta.property properties
   meta_property.install_property (make_attribute (meta_property, "Name"));
   meta_property.install_property (make_attribute (meta_property, "Description"));
   meta_property.install_property (make_attribute (meta_property, "DetailedDescription"));
   meta_property.install_property (make_attribute (meta_property, "Abstract"));
   meta_property.install_property (make_attribute (meta_property, "Constant"));
   meta_property.install_property (make_attribute (meta_property, "GetAccess"));
   meta_property.install_property (make_attribute (meta_property, "SetAccess"));
   meta_property.install_property (make_attribute (meta_property, "Dependent"));
@@ -3599,23 +3599,23 @@ install_classdef (void)
   meta_property.install_property (make_attribute (meta_property, "GetMethod"));
   meta_property.install_property (make_attribute (meta_property, "SetMethod"));
   meta_property.install_property (make_attribute (meta_property, "DefiningClass"));
   meta_property.install_property
       (make_property (meta_property, "DefaultValue",
                       make_fcn_handle (property_get_defaultvalue, "meta.property>get.DefaultValue"),
                       "public", Matrix (), "private"));
   meta_property.install_property (make_attribute (meta_property, "HasDefault"));
-  /* meta.property events */
+  // meta.property events
   // FIXME: add events
 
-  /* handle methods */
+  // handle methods
   handle.install_method (make_method (handle, "delete", handle_delete));
 
-  /* meta.package properties */
+  // meta.package properties
   meta_package.install_property (make_attribute (meta_package, "Name"));
   meta_package.install_property (make_property  (meta_package, "ContainingPackage"));
   meta_package.install_property
       (make_property (meta_package, "ClassList",
                       make_fcn_handle (package_get_classes, "meta.package>get.ClassList"),
                       "public", Matrix (), "private"));
   meta_package.install_property
       (make_property (meta_package, "Classes",
@@ -3637,26 +3637,26 @@ install_classdef (void)
       (make_property (meta_package, "Packages",
                       make_fcn_handle (package_get_packages, "meta.package>get.Packages"),
                       "public", Matrix (), "private"));
   meta_package.install_method (make_method (meta_package, "fromName", package_fromName,
                                             "public", true));
   meta_package.install_method (make_method (meta_package, "getAllPackages", package_getAllPackages,
                                             "public", true));
 
-  /* create "meta" package */
+  // create "meta" package
   cdef_package package_meta = cdef_package::_meta = make_package ("meta");
   package_meta.install_class (meta_class,       "class");
   package_meta.install_class (meta_property,    "property");
   package_meta.install_class (meta_method,      "method");
   package_meta.install_class (meta_package,     "package");
   package_meta.install_class (meta_event,       "event");
   package_meta.install_class (meta_dynproperty, "dynproperty");
 
-  /* install built-in classes into the symbol table */
+  // install built-in classes into the symbol table
   symbol_table::install_built_in_function
     ("meta.class", octave_value (meta_class.get_constructor_function ()));
   symbol_table::install_built_in_function
     ("meta.method", octave_value (meta_method.get_constructor_function ()));
   symbol_table::install_built_in_function
     ("meta.property", octave_value (meta_property.get_constructor_function ()));
   symbol_table::install_built_in_function
     ("meta.package", octave_value (meta_package.get_constructor_function ()));
@@ -3809,26 +3809,26 @@ DEFUN (__meta_get_package__, args, , "")
   if (args.length () != 1)
     print_usage ();
 
   std::string cname = args(0).xstring_value ("PACKAGE_NAME must be a string");
 
   return to_ov (lookup_package (cname));
 }
 
-DEFUN (__superclass_reference__, args, /* nargout */,
+DEFUN (__superclass_reference__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __superclass_reference__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (new octave_classdef_superclass_ref (args));
 }
 
-DEFUN (__meta_class_query__, args, /* nargout */,
+DEFUN (__meta_class_query__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __meta_class_query__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
             << args(0).string_value () << ")"
@@ -3838,17 +3838,17 @@ Undocumented internal function.\n\
   if (args.length () != 1)
     print_usage ();
 
   std::string cls = args(0).xstring_value ("CLASS_NAME must be a string");
 
   return to_ov (lookup_class (cls));
 }
 
-DEFUN (metaclass, args, /* nargout */,
+DEFUN (metaclass, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} metaclass (obj)\n\
 Returns the meta.class object corresponding to the class of @var{obj}.\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -163,37 +163,37 @@ public:
   {
     if (--refcount == static_count ())
       destroy ();
   }
 
   virtual dim_vector dims (void) const { return dim_vector (); }
 
 protected:
-  /* reference count */
+  // Reference count
   octave_refcount<octave_idx_type> refcount;
 
 protected:
-  /* Restricted copying */
+  // Restricted copying
   cdef_object_rep (const cdef_object_rep&)
     : refcount (1) { }
 
 private:
-  /* No assignment */
+  // No assignment
   cdef_object_rep& operator = (const cdef_object_rep& );
 
   void gripe_invalid_object (const char *who) const
   { error ("%s: invalid object", who); }
 };
 
 class
 cdef_object
 {
 public:
-  /* FIXME: use a null object */
+  // FIXME: use a null object
   cdef_object (void)
     : rep (new cdef_object_rep ()) { }
 
   cdef_object (const cdef_object& obj)
     : rep (obj.rep)
   {
     rep->refcount++;
   }
@@ -1119,23 +1119,23 @@ public:
 
   cdef_method& operator = (const cdef_method& meth)
   {
     cdef_object::operator= (meth);
 
     return *this;
   }
 
-  /* normal invokation */
+  // normal invocation
   octave_value_list execute (const octave_value_list& args, int nargout,
                              bool do_check_access = true,
                              const std::string& who = std::string ())
   { return get_rep ()->execute (args, nargout, do_check_access, who); }
 
-  /* dot-invokation: object is pushed as 1st argument */
+  // dot-invocation: object is pushed as 1st argument
   octave_value_list execute (const cdef_object& obj,
                              const octave_value_list& args, int nargout,
                              bool do_check_access = true,
                              const std::string& who = std::string ())
   { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
 
   bool check_access (void) const { return get_rep ()->check_access (); }
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -755,17 +755,17 @@ find_octave_class (JNIEnv *jni_env, cons
             }
 
           jclass_ref uicls (jni_env, jni_env->FindClass (class_loader.c_str ()));
 
           if (! uicls)
             {
               jni_env->ExceptionClear ();
 
-              /* Try the netbeans way */
+              // Try the netbeans way
               std::replace (class_loader.begin (), class_loader.end (),
                             '/', '.');
               jclass_ref jcls2 (jni_env, jni_env->FindClass ("org/openide/util/Lookup"));
               jmethodID mID = jni_env->GetStaticMethodID (jcls2, "getDefault", "()Lorg/openide/util/Lookup;");
               jobject_ref lObj (jni_env, jni_env->CallStaticObjectMethod (jcls2, mID));
               mID = jni_env->GetMethodID (jcls2, "lookup",
                                           "(Ljava/lang/Class;)Ljava/lang/Object;");
               jclass_ref cLoaderCls (jni_env, jni_env->FindClass ("java/lang/ClassLoader"));
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -147,35 +147,35 @@ along with Octave; see the file COPYING.
   DEFNDCATOP_FN (TYPE ## _m_m, TYPE ## _matrix, TYPE ## _matrix, TYPE ## _array, TYPE ## _array, concat)
 
 #define OCTAVE_INSTALL_CONCAT_FN(TYPE) \
   INSTALL_CATOP (octave_ ## TYPE ## _scalar, octave_ ## TYPE ## _scalar, TYPE ## _s_s) \
   INSTALL_CATOP (octave_ ## TYPE ## _scalar, octave_ ## TYPE ## _matrix, TYPE ## _s_m) \
   INSTALL_CATOP (octave_ ## TYPE ## _matrix, octave_ ## TYPE ## _scalar, TYPE ## _m_s) \
   INSTALL_CATOP (octave_ ## TYPE ## _matrix, octave_ ## TYPE ## _matrix, TYPE ## _m_m)
 
+// scalar unary ops.
 #define OCTAVE_S_INT_UNOPS(TYPE) \
-  /* scalar unary ops. */  \
  \
   DEFUNOP_OP (s_not, TYPE ## _scalar, !) \
   DEFUNOP_OP (s_uplus, TYPE ## _scalar, /* no-op */) \
   DEFUNOP (s_uminus, TYPE ## _scalar) \
   { \
     CAST_UNOP_ARG (const octave_ ## TYPE ## _scalar &); \
     octave_value retval = octave_value (- v. TYPE ## _scalar_value ()); \
     return retval; \
   } \
   DEFUNOP_OP (s_transpose, TYPE ## _scalar, /* no-op */) \
   DEFUNOP_OP (s_hermitian, TYPE ## _scalar, /* no-op */) \
  \
   DEFNCUNOP_METHOD (s_incr, TYPE ## _scalar, increment) \
   DEFNCUNOP_METHOD (s_decr, TYPE ## _scalar, decrement)
 
+// scalar by scalar ops.
 #define OCTAVE_SS_INT_ARITH_OPS(PFX, T1, T2, T3)        \
-  /* scalar by scalar ops. */ \
  \
   DEFINTBINOP_OP (PFX ## _add, T1 ## scalar, T2 ## scalar, +, T3) \
   DEFINTBINOP_OP (PFX ## _sub, T1 ## scalar, T2 ## scalar, -, T3) \
   DEFINTBINOP_OP (PFX ## _mul, T1 ## scalar, T2 ## scalar, *, T3) \
  \
   DEFBINOP (PFX ## _div, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
@@ -294,18 +294,18 @@ along with Octave; see the file COPYING.
   OCTAVE_SS_INT_CMP_OPS (sfx, TYPE ## _, float_) \
   OCTAVE_SS_INT_CMP_OPS (fxs, float_, TYPE ## _) \
   OCTAVE_SS_INT_BOOL_OPS (ss, TYPE ## _, TYPE ## _, octave_ ## TYPE (0), octave_ ## TYPE (0)) \
   OCTAVE_SS_INT_BOOL_OPS (sx, TYPE ## _, , octave_ ## TYPE (0), 0) \
   OCTAVE_SS_INT_BOOL_OPS (xs, , TYPE ## _, 0, octave_ ## TYPE (0)) \
   OCTAVE_SS_INT_BOOL_OPS (sfx, TYPE ## _, float_, octave_ ## TYPE (0), 0) \
   OCTAVE_SS_INT_BOOL_OPS (fxs, float_, TYPE ## _, 0, octave_ ## TYPE (0))
 
+// scalar by matrix ops.
 #define OCTAVE_SM_INT_ARITH_OPS(PFX, TS, TM, TI) \
-  /* scalar by matrix ops. */ \
  \
   DEFINTNDBINOP_OP (PFX ## _add, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, +, TI) \
   DEFINTNDBINOP_OP (PFX ## _sub, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, -, TI) \
   DEFINTNDBINOP_OP (PFX ## _mul, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, *, TI) \
  \
   /* DEFBINOP (PFX ## _div, TS ## scalar, TM ## matrix) */ \
   /* { */ \
   /* CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); */ \
@@ -451,18 +451,18 @@ along with Octave; see the file COPYING.
   OCTAVE_SM_INT_BOOL_OPS (xm, , TYPE ## _) \
   OCTAVE_SM_INT_BOOL_OPS (smx, TYPE ## _, ) \
   OCTAVE_SM_INT_BOOL_OPS (fxm, float_, TYPE ## _) \
   OCTAVE_SM_INT_BOOL_OPS (smfx, TYPE ## _, float_) \
   OCTAVE_SM_CONV (TYPE ## _, TYPE ## _) \
   OCTAVE_SM_CONV (TYPE ## _, complex_) \
   OCTAVE_SM_CONV (TYPE ## _, float_complex_)
 
+// matrix by scalar ops.
 #define OCTAVE_MS_INT_ARITH_OPS(PFX, TM, TS, TI) \
-  /* matrix by scalar ops. */ \
  \
   DEFINTNDBINOP_OP (PFX ## _add, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, +, TI) \
   DEFINTNDBINOP_OP (PFX ## _sub, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, -, TI) \
   DEFINTNDBINOP_OP (PFX ## _mul, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, *, TI) \
  \
   DEFBINOP (PFX ## _div, TM ## matrix, TS ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
@@ -606,18 +606,18 @@ octave_value elem_xpow (FloatNDArray a, 
   OCTAVE_MS_INT_BOOL_OPS (mxs, , TYPE ## _) \
   OCTAVE_MS_INT_BOOL_OPS (mfx, TYPE ## _, float_) \
   OCTAVE_MS_INT_BOOL_OPS (mfxs, float_, TYPE ## _) \
   OCTAVE_MS_INT_ASSIGN_OPS (ms, TYPE ## _, TYPE ## _, TYPE ## _) \
   OCTAVE_MS_INT_ASSIGNEQ_OPS (mse, TYPE ## _) \
   OCTAVE_MS_INT_ASSIGN_OPS (mx, TYPE ## _, , ) \
   OCTAVE_MS_INT_ASSIGN_OPS (mfx, TYPE ## _, float_, float_)
 
+// matrix unary ops.
 #define OCTAVE_M_INT_UNOPS(TYPE) \
-  /* matrix unary ops. */ \
  \
   DEFNDUNOP_OP (m_not, TYPE ## _matrix, TYPE ## _array, !) \
   DEFNDUNOP_OP (m_uplus, TYPE ## _matrix, TYPE ## _array, /* no-op */) \
   DEFUNOP (m_uminus, TYPE ## _matrix) \
   { \
     CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix &); \
     octave_value retval = octave_value (- v. TYPE ## _array_value ()); \
     return retval; \
@@ -632,18 +632,18 @@ octave_value elem_xpow (FloatNDArray a, 
     else \
       return octave_value (v.TYPE ## _array_value ().transpose ()); \
   } \
  \
   DEFNCUNOP_METHOD (m_incr, TYPE ## _matrix, increment) \
   DEFNCUNOP_METHOD (m_decr, TYPE ## _matrix, decrement) \
   DEFNCUNOP_METHOD (m_changesign, TYPE ## _matrix, changesign)
 
+// matrix by matrix ops.
 #define OCTAVE_MM_INT_ARITH_OPS(PFX, T1, T2, T3)        \
-  /* matrix by matrix ops. */ \
  \
   DEFINTNDBINOP_OP (PFX ## _add, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, +, T3) \
   DEFINTNDBINOP_OP (PFX ## _sub, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, -, T3) \
  \
   /* DEFBINOP_OP (PFX ## _mul, T1 ## matrix, T2 ## matrix, *) */ \
   /* DEFBINOP_FN (PFX ## _div, T1 ## matrix, T2 ## matrix, xdiv) */ \
  \
   DEFBINOPX (PFX ## _pow, T1 ## matrix, T2 ## matrix) \
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -1261,17 +1261,17 @@ tree_print_code::print_comment_elt (cons
 
   std::string comment = elt.text ();
 
   size_t len = comment.length ();
 
   size_t i = 0;
 
   while (i < len && comment[i++] == '\n')
-    ; /* Skip leading new lines. */
+    ; // Skip leading new lines.
   i--;
 
   while (i < len)
     {
       char c = comment[i++];
 
       if (c == '\n')
         {
diff --git a/libinterp/parse-tree/pt-walk.h b/libinterp/parse-tree/pt-walk.h
--- a/libinterp/parse-tree/pt-walk.h
+++ b/libinterp/parse-tree/pt-walk.h
@@ -214,62 +214,62 @@ public:
 
   virtual void
   visit_do_until_command (tree_do_until_command&) = 0;
 
   virtual void
   visit_classdef_attribute (tree_classdef_attribute&) { } /* = 0; */
 
   virtual void
-  visit_classdef_attribute_list (tree_classdef_attribute_list&) { } /* = 0; */
+  visit_classdef_attribute_list (tree_classdef_attribute_list&) { } // = 0;
 
   virtual void
-  visit_classdef_superclass (tree_classdef_superclass&) { } /* = 0; */
+  visit_classdef_superclass (tree_classdef_superclass&) { } // = 0;
 
   virtual void
-  visit_classdef_superclass_list (tree_classdef_superclass_list&) { } /* = 0; */
+  visit_classdef_superclass_list (tree_classdef_superclass_list&) { } // = 0;
 
   virtual void
-  visit_classdef_property (tree_classdef_property&) { } /* = 0; */
+  visit_classdef_property (tree_classdef_property&) { } // = 0;
 
   virtual void
-  visit_classdef_property_list (tree_classdef_property_list&) { } /* = 0; */
+  visit_classdef_property_list (tree_classdef_property_list&) { } // = 0;
 
   virtual void
-  visit_classdef_properties_block (tree_classdef_properties_block&) { } /* = 0; */
+  visit_classdef_properties_block (tree_classdef_properties_block&) { } // = 0;
 
   virtual void
-  visit_classdef_methods_list (tree_classdef_methods_list&) { } /* = 0; */
+  visit_classdef_methods_list (tree_classdef_methods_list&) { } // = 0;
 
   virtual void
-  visit_classdef_methods_block (tree_classdef_methods_block&) { } /* = 0; */
+  visit_classdef_methods_block (tree_classdef_methods_block&) { } // = 0;
 
   virtual void
-  visit_classdef_event (tree_classdef_event&) { } /* = 0; */
+  visit_classdef_event (tree_classdef_event&) { } // = 0;
 
   virtual void
-  visit_classdef_events_list (tree_classdef_events_list&) { } /* = 0; */
+  visit_classdef_events_list (tree_classdef_events_list&) { } // = 0;
 
   virtual void
-  visit_classdef_events_block (tree_classdef_events_block&) { } /* = 0; */
+  visit_classdef_events_block (tree_classdef_events_block&) { } // = 0;
 
   virtual void
-  visit_classdef_enum (tree_classdef_enum&) { } /* = 0; */
+  visit_classdef_enum (tree_classdef_enum&) { } // = 0;
 
   virtual void
-  visit_classdef_enum_list (tree_classdef_enum_list&) { } /* = 0; */
+  visit_classdef_enum_list (tree_classdef_enum_list&) { } // = 0;
 
   virtual void
-  visit_classdef_enum_block (tree_classdef_enum_block&) { } /* = 0; */
+  visit_classdef_enum_block (tree_classdef_enum_block&) { } // = 0;
 
   virtual void
-  visit_classdef_body (tree_classdef_body&) { } /* = 0; */
+  visit_classdef_body (tree_classdef_body&) { } // = 0;
 
   virtual void
-  visit_classdef (tree_classdef&) { } /* = 0; */
+  visit_classdef (tree_classdef&) { } // = 0;
 
 protected:
 
   tree_walker (void) { }
 
   virtual ~tree_walker (void) { }
 
 private:
