# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1450979428 18000
#      Thu Dec 24 12:50:28 2015 -0500
# Node ID 0963ed3890122e4ced86b8cc44102007121bd02b
# Parent  a5b500efca9fcaeeb8183ff609cea8de7ccd0889
maint: invert if/else/error instances.

* ov-bool-mat.cc, ov-cell.cc, ov-class.cc, ov-classdef.cc,
ov-cx-mat.cc, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-perm.cc,
ov-re-mat.cc, ov-str-mat.cc, ov-struct.cc, ov-usr-fcn.cc:
Invert if/else/error instances.

diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -227,76 +227,72 @@ octave_bool_matrix::load_ascii (std::ist
 
   if (! extract_keyword (is, keywords, kw, val, true))
     error ("load: failed to extract number of rows and columns");
 
   if (kw == "ndims")
     {
       int mdims = static_cast<int> (val);
 
-      if (mdims >= 0)
+      if (mdims < 0)
+        error ("load: failed to extract number of dimensions");
+
+      dim_vector dv;
+      dv.resize (mdims);
+
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
+
+      if (! is)
+        error ("load: failed to extract dimensions");
+
+      boolNDArray btmp (dv);
+
+      if (btmp.is_empty ())
+        matrix = btmp;
+      else
         {
-          dim_vector dv;
-          dv.resize (mdims);
-
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+          NDArray tmp(dv);
+          is >> tmp;
 
           if (! is)
-            error ("load: failed to extract dimensions");
-
-          boolNDArray btmp (dv);
-
-          if (btmp.is_empty ())
-            matrix = btmp;
-          else
-            {
-              NDArray tmp(dv);
-              is >> tmp;
+            error ("load: failed to load matrix constant");
 
-              if (! is)
-                error ("load: failed to load matrix constant");
-
-              for (octave_idx_type i = 0; i < btmp.numel (); i++)
-                btmp.elem (i) = (tmp.elem (i) != 0.);
+          for (octave_idx_type i = 0; i < btmp.numel (); i++)
+            btmp.elem (i) = (tmp.elem (i) != 0.);
 
-              matrix = btmp;
-            }
+          matrix = btmp;
         }
-      else
-        error ("load: failed to extract number of dimensions");
     }
   else if (kw == "rows")
     {
       octave_idx_type nr = val;
       octave_idx_type nc = 0;
 
-      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+      if (nr < 0 || ! extract_keyword (is, "columns", nc) || nc < 0)
+        error ("load: failed to extract number of rows and columns");
+
+      if (nr > 0 && nc > 0)
         {
-          if (nr > 0 && nc > 0)
-            {
-              Matrix tmp (nr, nc);
-              is >> tmp;
-              if (! is)
-                error ("load: failed to load matrix constant");
+          Matrix tmp (nr, nc);
+          is >> tmp;
+          if (! is)
+            error ("load: failed to load matrix constant");
 
-              boolMatrix btmp (nr, nc);
-              for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = 0; i < nr; i++)
-                  btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
+          boolMatrix btmp (nr, nc);
+          for (octave_idx_type j = 0; j < nc; j++)
+            for (octave_idx_type i = 0; i < nr; i++)
+              btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
 
-              matrix = btmp;
-            }
-          else if (nr == 0 || nc == 0)
-            matrix = boolMatrix (nr, nc);
-          else
-            panic_impossible ();
+          matrix = btmp;
         }
+      else if (nr == 0 || nc == 0)
+        matrix = boolMatrix (nr, nc);
       else
-        error ("load: failed to extract number of rows and columns");
+        panic_impossible ();
     }
   else
     panic_impossible ();
 
   return success;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -305,25 +305,23 @@ octave_cell::subsasgn (const std::string
               }
             else
               gripe_indexed_cs_list ();
           }
           break;
 
         case '.':
           {
-            if (is_empty ())
-              {
-                // Do nothing; the next branch will handle it.
-              }
-            else
+            if (! is_empty ())
               {
                 std::string nm = type_name ();
                 error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
               }
+
+            // Do nothing; the next branch will handle it.
           }
           break;
 
         default:
           panic_impossible ();
         }
     }
 
@@ -375,32 +373,30 @@ octave_cell::subsasgn (const std::string
 
         count++;
         retval = octave_value (this);
       }
       break;
 
     case '.':
       {
-        if (is_empty ())
-          {
-            // Allow conversion of empty cell array to some other
-            // type in cases like
-            //
-            //  x = {}; x.f = rhs
-
-            octave_value tmp = octave_value::empty_conv (type, rhs);
-
-            return tmp.subsasgn (type, idx, rhs);
-          }
-        else
+        if (! is_empty ())
           {
             std::string nm = type_name ();
             error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
           }
+
+        // Allow conversion of empty cell array to some other
+        // type in cases like
+        //
+        //  x = {}; x.f = rhs
+
+        octave_value tmp = octave_value::empty_conv (type, rhs);
+
+        return tmp.subsasgn (type, idx, rhs);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval;
@@ -776,96 +772,88 @@ octave_cell::load_ascii (std::istream& i
 
   if (! extract_keyword (is, keywords, kw, val, true))
     error ("load: failed to extract number of rows and columns");
 
   if (kw == "ndims")
     {
       int mdims = static_cast<int> (val);
 
-      if (mdims >= 0)
-        {
-          dim_vector dv;
-          dv.resize (mdims);
+      if (mdims < 0)
+        error ("load: failed to extract number of rows and columns");
 
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+      dim_vector dv;
+      dv.resize (mdims);
 
-          Cell tmp(dv);
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
+
+      Cell tmp(dv);
 
-          for (octave_idx_type i = 0; i < dv.numel (); i++)
-            {
-              octave_value t2;
-              bool dummy;
-
-              // recurse to read cell elements
-              std::string nm = read_text_data (is, std::string (),
-                                                dummy, t2, i);
+      for (octave_idx_type i = 0; i < dv.numel (); i++)
+        {
+          octave_value t2;
+          bool dummy;
 
-              if (nm == CELL_ELT_TAG)
-                {
-                  if (is)
-                    tmp.elem (i) = t2;
-                }
-              else
-                error ("load: cell array element had unexpected name");
-            }
+          // recurse to read cell elements
+          std::string nm = read_text_data (is, std::string (),
+                                           dummy, t2, i);
+
+          if (nm != CELL_ELT_TAG)
+            error ("load: cell array element had unexpected name");
 
           if (is)
-            matrix = tmp;
-          else
-            error ("load: failed to load matrix constant");
+            tmp.elem (i) = t2;
         }
-      else
-        error ("load: failed to extract number of rows and columns");
+
+      if (! is)
+        error ("load: failed to load matrix constant");
+
+      matrix = tmp;
     }
   else if (kw == "rows")
     {
       octave_idx_type nr = val;
       octave_idx_type nc = 0;
 
-      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+      if (nr < 0 || ! extract_keyword (is, "columns", nc) || nc < 0)
+        error ("load: failed to extract number of rows and columns for cell array");
+
+      if (nr > 0 && nc > 0)
         {
-          if (nr > 0 && nc > 0)
+          Cell tmp (nr, nc);
+
+          for (octave_idx_type j = 0; j < nc; j++)
             {
-              Cell tmp (nr, nc);
-
-              for (octave_idx_type j = 0; j < nc; j++)
+              for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  for (octave_idx_type i = 0; i < nr; i++)
-                    {
-                      octave_value t2;
-                      bool dummy;
+                  octave_value t2;
+                  bool dummy;
 
-                      // recurse to read cell elements
-                      std::string nm = read_text_data (is, std::string (),
-                                                        dummy, t2, i);
+                  // recurse to read cell elements
+                  std::string nm = read_text_data (is, std::string (),
+                                                   dummy, t2, i);
 
-                      if (nm == CELL_ELT_TAG)
-                        {
-                          if (is)
-                            tmp.elem (i, j) = t2;
-                        }
-                      else
-                        error ("load: cell array element had unexpected name");
-                    }
+                  if (nm != CELL_ELT_TAG)
+                    error ("load: cell array element had unexpected name");
+
+                  if (is)
+                    tmp.elem (i, j) = t2;
                 }
+            }
 
-              if (is)
-                matrix = tmp;
-              else
-                error ("load: failed to load cell element");
-            }
-          else if (nr == 0 || nc == 0)
-            matrix = Cell (nr, nc);
-          else
-            panic_impossible ();
+          if (! is)
+            error ("load: failed to load cell element");
+
+          matrix = tmp;
         }
+      else if (nr == 0 || nc == 0)
+        matrix = Cell (nr, nc);
       else
-        error ("load: failed to extract number of rows and columns for cell array");
+        panic_impossible ();
     }
   else
     panic_impossible ();
 
   return true;
 }
 
 bool
@@ -949,30 +937,28 @@ octave_cell::load_binary (std::istream& 
       octave_value t2;
       bool dummy;
       std::string doc;
 
       // recurse to read cell elements
       std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                          dummy, t2, doc);
 
-      if (nm == CELL_ELT_TAG)
-        {
-          if (is)
-            tmp.elem (i) = t2;
-        }
-      else
+      if (nm != CELL_ELT_TAG)
         error ("load: cell array element had unexpected name");
+
+      if (is)
+        tmp.elem (i) = t2;
     }
 
-  if (is)
-    matrix = tmp;
-  else
+  if (! is)
     error ("load: failed to load matrix constant");
 
+  matrix = tmp;
+
   return true;
 }
 
 void *
 octave_cell::mex_get_data (void) const
 {
   clear_cellstr_cache ();
   return matrix.mex_get_data ();
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -78,133 +78,128 @@ octave_class::octave_class (const octave
   octave_idx_type n = parents.length ();
 
   for (octave_idx_type idx = 0; idx < n; idx++)
     {
       octave_value parent = parents(idx);
 
       if (! parent.is_object ())
         error ("parents must be objects");
-      else
-        {
-          std::string pcnm = parent.class_name ();
 
-          if (find_parent_class (pcnm))
-            error ("duplicate class in parent tree");
-          else
-            {
-              parent_list.push_back (pcnm);
-
-              octave_idx_type nel = map.numel ();
-              octave_idx_type p_nel = parent.numel ();
+      std::string pcnm = parent.class_name ();
 
-              if (nel == 0)
-                {
-                  if (p_nel == 0)
-                    {
-                      // No elements in MAP or the parent class object,
-                      // so just add the field name.
+      if (find_parent_class (pcnm))
+        error ("duplicate class in parent tree");
 
-                      map.assign (pcnm, Cell (map.dims ()));
-                    }
-                  else if (p_nel == 1)
-                    {
-                      if (map.nfields () == 0)
-                        {
-                          // No elements or fields in MAP, but the
-                          // parent is class object with one element.
-                          // Resize to match size of parent class and
-                          // make the parent a field in MAP.
+      parent_list.push_back (pcnm);
 
-                          map.resize (parent.dims ());
+      octave_idx_type nel = map.numel ();
+      octave_idx_type p_nel = parent.numel ();
 
-                          map.assign (pcnm, parent);
-                        }
-                      else
-                        {
-                          // No elements in MAP, but we have at least
-                          // one field.  So don't resize, just add the
-                          // field name.
-
-                          map.assign (pcnm, Cell (map.dims ()));
-                        }
-                    }
-                  else if (map.nfields () == 0)
-                    {
-                      // No elements or fields in MAP and more than one
-                      // element in the parent class object, so we can
-                      // resize MAP to match parent dimsenions, then
-                      // distribute the elements of the parent object to
-                      // the elements of MAP.
-
-                      dim_vector parent_dims = parent.dims ();
+      if (nel == 0)
+        {
+          if (p_nel == 0)
+            {
+              // No elements in MAP or the parent class object,
+              // so just add the field name.
 
-                      map.resize (parent_dims);
-
-                      Cell c (parent_dims);
-
-                      octave_map pmap = parent.map_value ();
-
-                      std::list<std::string> plist
-                        = parent.parent_class_name_list ();
+              map.assign (pcnm, Cell (map.dims ()));
+            }
+          else if (p_nel == 1)
+            {
+              if (map.nfields () == 0)
+                {
+                  // No elements or fields in MAP, but the
+                  // parent is class object with one element.
+                  // Resize to match size of parent class and
+                  // make the parent a field in MAP.
 
-                      for (octave_idx_type i = 0; i < p_nel; i++)
-                        c(i) = octave_value (pmap.index (i), pcnm, plist);
-
-                      map.assign (pcnm, c);
-                    }
-                  else
-                    error ("class: parent class dimension mismatch");
-                }
-              else if (nel == 1 && p_nel == 1)
-                {
-                  // Simple assignment.
+                  map.resize (parent.dims ());
 
                   map.assign (pcnm, parent);
                 }
               else
                 {
-                  if (p_nel == 1)
-                    {
-                      // Broadcast the scalar parent class object to
-                      // each element of MAP.
-
-                      Cell pcell (map.dims (), parent);
-
-                      map.assign (pcnm, pcell);
-                    }
-
-                  else if (nel == p_nel)
-                    {
-                      // FIXME: is there a better way to do this?
+                  // No elements in MAP, but we have at least
+                  // one field.  So don't resize, just add the
+                  // field name.
 
-                      // The parent class object has the same number of
-                      // elements as the map we are using to create the
-                      // new object, so distribute those elements to
-                      // each element of the new object by first
-                      // splitting the elements of the parent class
-                      // object into a cell array with one element per
-                      // cell.  Then do the assignment all at once.
-
-                      Cell c (parent.dims ());
-
-                      octave_map pmap = parent.map_value ();
-
-                      std::list<std::string> plist
-                        = parent.parent_class_name_list ();
-
-                      for (octave_idx_type i = 0; i < p_nel; i++)
-                        c(i) = octave_value (pmap.index (i), pcnm, plist);
-
-                      map.assign (pcnm, c);
-                    }
-                  else
-                    error ("class: parent class dimension mismatch");
+                  map.assign (pcnm, Cell (map.dims ()));
                 }
             }
+          else if (map.nfields () == 0)
+            {
+              // No elements or fields in MAP and more than one
+              // element in the parent class object, so we can
+              // resize MAP to match parent dimsenions, then
+              // distribute the elements of the parent object to
+              // the elements of MAP.
+
+              dim_vector parent_dims = parent.dims ();
+
+              map.resize (parent_dims);
+
+              Cell c (parent_dims);
+
+              octave_map pmap = parent.map_value ();
+
+              std::list<std::string> plist
+                = parent.parent_class_name_list ();
+
+              for (octave_idx_type i = 0; i < p_nel; i++)
+                c(i) = octave_value (pmap.index (i), pcnm, plist);
+
+              map.assign (pcnm, c);
+            }
+          else
+            error ("class: parent class dimension mismatch");
+        }
+      else if (nel == 1 && p_nel == 1)
+        {
+          // Simple assignment.
+
+          map.assign (pcnm, parent);
+        }
+      else
+        {
+          if (p_nel == 1)
+            {
+              // Broadcast the scalar parent class object to
+              // each element of MAP.
+
+              Cell pcell (map.dims (), parent);
+
+              map.assign (pcnm, pcell);
+            }
+          else if (nel == p_nel)
+            {
+              // FIXME: is there a better way to do this?
+
+              // The parent class object has the same number of
+              // elements as the map we are using to create the
+              // new object, so distribute those elements to
+              // each element of the new object by first
+              // splitting the elements of the parent class
+              // object into a cell array with one element per
+              // cell.  Then do the assignment all at once.
+
+              Cell c (parent.dims ());
+
+              octave_map pmap = parent.map_value ();
+
+              std::list<std::string> plist
+                = parent.parent_class_name_list ();
+
+              for (octave_idx_type i = 0; i < p_nel; i++)
+                c(i) = octave_value (pmap.index (i), pcnm, plist);
+
+              map.assign (pcnm, c);
+            }
+          else
+            error ("class: parent class dimension mismatch");
         }
     }
 
   symbol_table::add_to_parent_map (id, parent_list);
 }
 
 octave_base_value *
 octave_class::unique_clone (void)
@@ -259,18 +254,16 @@ static void
 gripe_invalid_index_type (const std::string& nm, char t)
 {
   error ("%s cannot be indexed with %c", nm.c_str (), t);
 }
 
 Cell
 octave_class::dotref (const octave_value_list& idx)
 {
-  Cell retval;
-
   assert (idx.length () == 1);
 
   std::string method_class = get_current_method_class ();
 
   // Find the class in which this method resides before attempting to access
   // the requested field.
 
   octave_base_value *obvp = find_parent_class (method_class);
@@ -279,22 +272,20 @@ octave_class::dotref (const octave_value
     error ("malformed class");
 
   octave_map my_map = (obvp != this) ? obvp->map_value () : map;
 
   std::string nm = idx(0).xstring_value ("invalid index for class");
 
   octave_map::const_iterator p = my_map.seek (nm);
 
-  if (p != my_map.end ())
-    retval = my_map.contents (p);
-  else
+  if (p == my_map.end ())
     error ("class has no member '%s'", nm.c_str ());
 
-  return retval;
+  return my_map.contents (p);
 }
 
 Matrix
 octave_class::size (void)
 {
   if (in_class_method () || called_from_builtin ())
     return octave_base_value::size ();
 
@@ -302,21 +293,21 @@ octave_class::size (void)
   octave_value meth = symbol_table::find_method ("size", class_name ());
 
   if (meth.is_defined ())
     {
       count++;
       octave_value_list args (1, octave_value (this));
 
       octave_value_list lv = feval (meth.function_value (), args, 1);
-      if (lv.length () > 0
-          && lv(0).is_matrix_type () && lv(0).dims ().is_vector ())
-        retval = lv(0).matrix_value ();
-      else
+      if (lv.length () <= 0
+          || ! lv(0).is_matrix_type () || ! lv(0).dims ().is_vector ())
         error ("@%s/size: invalid return value", class_name ().c_str ());
+
+      retval = lv(0).matrix_value ();
     }
   else
     {
       dim_vector dv = dims ();
 
       int nd = dv.length ();
 
       retval.resize (1, nd);
@@ -345,20 +336,20 @@ octave_class::numel (const octave_value_
 
       count++;
       args(0) = octave_value (this);
 
       for (octave_idx_type i = 0; i < idx.length (); i++)
         args(i+1) = idx(i);
 
       octave_value_list lv = feval (meth.function_value (), args, 1);
-      if (lv.length () == 1 && lv(0).is_scalar_type ())
-        retval = lv(0).idx_type_value (true);
-      else
+      if (lv.length () != 1 || ! lv(0).is_scalar_type ())
         error ("@%s/numel: invalid return value", cn.c_str ());
+
+      retval = lv(0).idx_type_value (true);
     }
   else
     retval = octave_base_value::numel (idx);
 
   return retval;
 }
 
 octave_value_list
@@ -803,40 +794,36 @@ octave_class::subsasgn_common (const oct
     }
 
   return retval;
 }
 
 idx_vector
 octave_class::index_vector (bool require_integers) const
 {
-  idx_vector retval;
-
   octave_value meth = symbol_table::find_method ("subsindex", class_name ());
 
   if (! meth.is_defined ())
     error ("no subsindex method defined for class %s",
            class_name ().c_str ());
 
   octave_value_list args;
   args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
   octave_value_list tmp = feval (meth.function_value (), args, 1);
 
   if (tmp(0).is_object ())
     error ("subsindex function must return a valid index vector");
-  else
-    // Index vector returned by subsindex is zero based
-    // (why this inconsistency Mathworks?), and so we must
-    // add one to the value returned as the index_vector method
-    // expects it to be one based.
-    retval = do_binary_op (octave_value::op_add, tmp (0),
-                           octave_value (1.0)).index_vector (require_integers);
 
-  return retval;
+  // Index vector returned by subsindex is zero based
+  // (why this inconsistency Mathworks?), and so we must
+  // add one to the value returned as the index_vector method
+  // expects it to be one based.
+  return do_binary_op (octave_value::op_add, tmp (0),
+                       octave_value (1.0)).index_vector (require_integers);
 }
 
 size_t
 octave_class::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
   size_t retval = 0;
@@ -971,20 +958,20 @@ octave_class::all_strings (bool pad) con
 
   octave_value_list args;
   args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
   octave_value_list tmp = feval (meth.function_value (), args, 1);
 
   if (tmp.length () >= 1)
     {
-      if (tmp(0).is_string ())
-        retval = tmp(0).all_strings (pad);
-      else
+      if (! tmp(0).is_string ())
         error ("cname/char method did not return a string");
+
+      retval = tmp(0).all_strings (pad);
     }
 
   return retval;
 }
 
 
 void
 octave_class::print (std::ostream& os, bool)
@@ -1210,74 +1197,70 @@ octave_class::save_ascii (std::ostream& 
 }
 
 bool
 octave_class::load_ascii (std::istream& is)
 {
   octave_idx_type len = 0;
   std::string classname;
 
-  if (extract_keyword (is, "classname", classname) && classname != "")
+  if (! extract_keyword (is, "classname", classname) || classname.empty ())
+    error ("load: failed to extract name of class");
+
+  if (! extract_keyword (is, "length", len) || len < 0)
+    error ("load: failed to extract number of elements in class");
+
+  if (len > 0)
     {
-      if (extract_keyword (is, "length", len) && len >= 0)
-        {
-          if (len > 0)
-            {
-              octave_map m (map);
-
-              for (octave_idx_type j = 0; j < len; j++)
-                {
-                  octave_value t2;
-                  bool dummy;
+      octave_map m (map);
 
-                  // recurse to read cell elements
-                  std::string nm
-                    = read_text_data (is, std::string (), dummy, t2, j);
-
-                  if (! is)
-                    break;
+      for (octave_idx_type j = 0; j < len; j++)
+        {
+          octave_value t2;
+          bool dummy;
 
-                  Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
+          // recurse to read cell elements
+          std::string nm
+            = read_text_data (is, std::string (), dummy, t2, j);
 
-                  m.assign (nm, tcell);
-                }
+          if (! is)
+            break;
 
-              if (! is)
-                error ("load: failed to load class");
+          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
 
-              c_name = classname;
-              reconstruct_exemplar ();
+          m.assign (nm, tcell);
+        }
 
-              map = m;
+      if (! is)
+        error ("load: failed to load class");
 
-              if (! reconstruct_parents ())
-                warning ("load: unable to reconstruct object inheritance");
+      c_name = classname;
+      reconstruct_exemplar ();
 
-              if (load_path::find_method (classname, "loadobj")
-                  != std::string ())
-                {
-                  octave_value in = new octave_class (*this);
-                  octave_value_list tmp = feval ("loadobj", in, 1);
+      map = m;
+
+      if (! reconstruct_parents ())
+        warning ("load: unable to reconstruct object inheritance");
 
-                  map = tmp(0).map_value ();
-                }
-            }
-          else if (len == 0)
-            {
-              map = octave_map (dim_vector (1, 1));
-              c_name = classname;
-            }
-          else
-            panic_impossible ();
+      if (load_path::find_method (classname, "loadobj")
+          != std::string ())
+        {
+          octave_value in = new octave_class (*this);
+          octave_value_list tmp = feval ("loadobj", in, 1);
+
+          map = tmp(0).map_value ();
         }
-      else
-        error ("load: failed to extract number of elements in class");
+    }
+  else if (len == 0)
+    {
+      map = octave_map (dim_vector (1, 1));
+      c_name = classname;
     }
   else
-    error ("load: failed to extract name of class");
+    panic_impossible ();
 
   return true;
 }
 
 bool
 octave_class::save_binary (std::ostream& os, bool& save_as_floats)
 {
   int32_t classname_len = class_name ().length ();
@@ -1671,48 +1654,44 @@ std::map<std::string, octave_class::exem
 
 bool
 octave_class::exemplar_info::compare (const octave_value& obj) const
 {
 
   if (! obj.is_object ())
     error ("invalid comparison of class exemplar to non-class object");
 
-  if (nfields () == obj.nfields ())
-    {
-      octave_map obj_map = obj.map_value ();
-      string_vector obj_fnames = obj_map.keys ();
-      string_vector fnames = fields ();
+  if (nfields () != obj.nfields ())
+    error ("mismatch in number of fields");
 
-      for (octave_idx_type i = 0; i < nfields (); i++)
-        {
-          if (obj_fnames[i] != fnames[i])
-            error ("mismatch in field names");
-        }
+  octave_map obj_map = obj.map_value ();
+  string_vector obj_fnames = obj_map.keys ();
+  string_vector fnames = fields ();
+
+  for (octave_idx_type i = 0; i < nfields (); i++)
+    {
+      if (obj_fnames[i] != fnames[i])
+        error ("mismatch in field names");
+    }
 
-      if (nparents () == obj.nparents ())
-        {
-          std::list<std::string> obj_parents
-            = obj.parent_class_name_list ();
-          std::list<std::string> pnames = parents ();
+  if (nparents () != obj.nparents ())
+    error ("mismatch in number of parent classes");
 
-          std::list<std::string>::const_iterator p = obj_parents.begin ();
-          std::list<std::string>::const_iterator q = pnames.begin ();
+  std::list<std::string> obj_parents
+    = obj.parent_class_name_list ();
+  std::list<std::string> pnames = parents ();
 
-          while (p != obj_parents.end ())
-            {
-              if (*p++ != *q++)
-                error ("mismatch in parent classes");
-            }
-        }
-      else
-        error ("mismatch in number of parent classes");
+  std::list<std::string>::const_iterator p = obj_parents.begin ();
+  std::list<std::string>::const_iterator q = pnames.begin ();
+
+  while (p != obj_parents.end ())
+    {
+      if (*p++ != *q++)
+        error ("mismatch in parent classes");
     }
-  else
-    error ("mismatch in number of fields");
 
   return true;
 }
 
 DEFUN (class, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{classname} =} class (@var{obj})\n\
 @deftypefnx {} {} class (@var{s}, @var{id})\n\
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -42,16 +42,19 @@ along with Octave; see the file COPYING.
 #include "singleton-cleanup.h"
 #include "symtab.h"
 #include "toplev.h"
 
 #include "Array.cc"
 
 // Define to 1 to enable debugging statements.
 #define DEBUG_TRACE 0
+static void
+gripe_method_access (const std::string& from,
+                     const cdef_method& meth) GCC_ATTR_NORETURN;
 
 static void
 gripe_method_access (const std::string& from, const cdef_method& meth)
 {
   octave_value acc = meth.get ("Access");
   std::string acc_s;
 
   if (acc.is_string ())
@@ -60,16 +63,20 @@ gripe_method_access (const std::string& 
     acc_s = "class-restricted";
 
   error ("%s: method `%s' has %s access and cannot be run in this context",
          from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
 }
 
 static void
 gripe_property_access (const std::string& from, const cdef_property& prop,
+                       bool is_set) GCC_ATTR_NORETURN;
+
+static void
+gripe_property_access (const std::string& from, const cdef_property& prop,
                        bool is_set = false)
 {
   octave_value acc = prop.get (is_set ? "SetAccess" : "GetAccess");
   std::string acc_s;
 
   if (acc.is_string ())
     acc_s = acc.string_value ();
   else
@@ -515,106 +522,93 @@ class_get_inferiorclasses (const octave_
   return retval;
 }
 
 static octave_value_list
 class_fromName (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
-  if (args.length () == 1)
-    {
-      std::string name = args(0).xstring_value ("fromName: CLASS_NAME must be a string");
-
-      retval(0) = to_ov (lookup_class (name));
-    }
-  else
+  if (args.length () != 1)
     error ("fromName: invalid number of parameters");
 
+  std::string name = args(0).xstring_value ("fromName: CLASS_NAME must be a string");
+
+  retval(0) = to_ov (lookup_class (name));
+
   return retval;
 }
 
 static octave_value_list
 class_fevalStatic (const octave_value_list& args, int nargout)
 {
-  octave_value_list retval;
-
-  if (args.length () > 1 && args(0).type_name () == "object")
-    {
-      cdef_class cls (to_cdef (args(0)));
-
-      std::string meth_name = args(1).xstring_value ("fevalStatic: method name must be a string");
-
-      cdef_method meth = cls.find_method (meth_name);
-
-      if (! meth.ok ())
-        error ("fevalStatic: method not found: %s", meth_name.c_str ());
-
-      if (meth.is_static ())
-        retval = meth.execute (args.splice (0, 2), nargout,
-                               true, "fevalStatic");
-      else
-        error ("fevalStatic: method `%s' is not static", meth_name.c_str ());
-    }
-  else
+  if (args.length () <= 1 || args(0).type_name () != "object")
     error ("fevalStatic: first argument must be a meta.class object");
 
-  return retval;
+  cdef_class cls (to_cdef (args(0)));
+
+  std::string meth_name = args(1).xstring_value ("fevalStatic: method name must be a string");
+
+  cdef_method meth = cls.find_method (meth_name);
+
+  if (! meth.ok ())
+    error ("fevalStatic: method not found: %s", meth_name.c_str ());
+
+  if (! meth.is_static ())
+    error ("fevalStatic: method `%s' is not static", meth_name.c_str ());
+
+  return meth.execute (args.splice (0, 2), nargout, true, "fevalStatic");
 }
 
 static octave_value_list
 class_getConstant (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
-  if (args.length () == 2 && args(0).type_name () == "object"
-      && args(0).class_name () == "meta.class")
-    {
-      cdef_class cls = to_cdef (args(0));
-
-      std::string prop_name = args(1).xstring_value ("getConstant: property name must be a string");
-
-      cdef_property prop = cls.find_property (prop_name);
-
-      if (! prop.ok ())
-        error ("getConstant: property not found: %s",
-               prop_name.c_str ());
-
-      if (prop.is_constant ())
-        retval(0) = prop.get_value (true, "getConstant");
-      else
-        error ("getConstant: property `%s' is not constant",
-               prop_name.c_str ());
-    }
-  else
+  if (args.length () != 2 || args(0).type_name () != "object"
+      || args(0).class_name () != "meta.class")
     error ("getConstant: first argument must be a meta.class object");
 
+  cdef_class cls = to_cdef (args(0));
+
+  std::string prop_name = args(1).xstring_value ("getConstant: property name must be a string");
+
+  cdef_property prop = cls.find_property (prop_name);
+
+  if (! prop.ok ())
+    error ("getConstant: property not found: %s",
+           prop_name.c_str ());
+
+  if (! prop.is_constant ())
+    error ("getConstant: property `%s' is not constant",
+           prop_name.c_str ());
+
+  retval(0) = prop.get_value (true, "getConstant");
+
   return retval;
 }
 
 #define META_CLASS_CMP(OP, CLSA, CLSB, FUN) \
 static octave_value_list \
 class_ ## OP (const octave_value_list& args, int /* nargout */) \
 { \
   octave_value_list retval; \
-\
-  if (args.length () == 2 \
-      && args(0).type_name () == "object" \
-      && args(1).type_name () == "object" \
-      && args(0).class_name () == "meta.class" \
-      && args(1).class_name () == "meta.class") \
-    { \
-      cdef_class clsa = to_cdef (args(0)); \
-\
-      cdef_class clsb = to_cdef (args(1)); \
-\
-      retval(0) = FUN (CLSA, CLSB); \
-    } \
-  else \
+ \
+  if (args.length () != 2 \
+      || args(0).type_name () != "object" \
+      || args(1).type_name () != "object" \
+      || args(0).class_name () != "meta.class" \
+      || args(1).class_name () != "meta.class") \
     error (#OP ": invalid arguments"); \
+ \
+  cdef_class clsa = to_cdef (args(0)); \
+ \
+  cdef_class clsb = to_cdef (args(1)); \
+ \
+  retval(0) = FUN (CLSA, CLSB); \
 \
   return retval; \
 }
 
 META_CLASS_CMP (lt, clsb, clsa, is_strict_superclass)
 META_CLASS_CMP (le, clsb, clsa, is_superclass)
 META_CLASS_CMP (gt, clsa, clsb, is_strict_superclass)
 META_CLASS_CMP (ge, clsa, clsb, is_superclass)
@@ -690,22 +684,20 @@ make_class (const std::string& name,
           all_handle_compatible = all_handle_compatible
                                   && it->get ("HandleCompatible").bool_value ();
           has_handle_class = has_handle_class || it->is_handle_class ();
         }
 
       if (has_handle_class && ! all_handle_compatible)
         error ("%s: cannot mix handle and non-HandleCompatible classes",
                name.c_str ());
-      else
-        {
-          cls.put ("HandleCompatible", all_handle_compatible);
-          if (has_handle_class)
-            cls.mark_as_handle_class ();
-        }
+
+      cls.put ("HandleCompatible", all_handle_compatible);
+      if (has_handle_class)
+        cls.mark_as_handle_class ();
     }
 
   if (! name.empty ())
     cdef_manager::register_class (cls);
 
   return cls;
 }
 
@@ -922,20 +914,20 @@ octave_classdef::subsasgn (const std::st
           count++;
           args(0) = octave_value (this);
           args(2) = rhs;
 
           octave_value_list retlist;
 
           retlist = meth.execute (args, 1, true, "subsasgn");
 
-          if (retlist.length () > 0)
-            retval = retlist(0);
-          else
+          if (retlist.length () == 0)
             error ("overloaded method `subsasgn' did not return any value");
+
+          retval = retlist(0);
         }
     }
 
   if (! retval.is_defined ())
     retval = object.subsasgn (type, idx, rhs);
 
   return retval;
 }
@@ -1186,45 +1178,43 @@ public:
         octave_value sym = symbol_table::varval (mname);
 
         cls.run_constructor (to_cdef_ref (sym), idx);
 
         retval(0) = sym;
       }
     else
       {
-        if (mname == meth_name)
-          {
-            if (! is_strict_superclass (cls, ctx))
-              error ("`%s' is not a superclass of `%s'",
-                     cname.c_str (), ctx.get_name ().c_str ());
-
-            // I see 2 possible implementations here:
-            // 1) use cdef_object::subsref with a different class
-            //    context; this avoids duplicating code, but
-            //    assumes the object is always the first argument
-            // 2) lookup the method manually and call
-            //    cdef_method::execute; this duplicates part of
-            //    logic in cdef_object::subsref, but avoid the
-            //    assumption of 1)
-            // Not being sure about the assumption of 1), I
-            // go with option 2) for the time being.
-
-            cdef_method meth = cls.find_method (meth_name, false);
-
-            if (meth.ok ())
-              retval = meth.execute (idx, nargout, true,
-                                     meth_name);
-            else
-              error ("no method `%s' found in superclass `%s'",
-                     meth_name.c_str (), cname.c_str ());
-          }
-        else
+        if (mname != meth_name)
           error ("method name mismatch (`%s' != `%s')",
                  mname.c_str (), meth_name.c_str ());
+
+        if (! is_strict_superclass (cls, ctx))
+          error ("`%s' is not a superclass of `%s'",
+                 cname.c_str (), ctx.get_name ().c_str ());
+
+        // I see 2 possible implementations here:
+        // 1) use cdef_object::subsref with a different class
+        //    context; this avoids duplicating code, but
+        //    assumes the object is always the first argument
+        // 2) lookup the method manually and call
+        //    cdef_method::execute; this duplicates part of
+        //    logic in cdef_object::subsref, but avoid the
+        //    assumption of 1)
+        // Not being sure about the assumption of 1), I
+        // go with option 2) for the time being.
+
+        cdef_method meth = cls.find_method (meth_name, false);
+
+        if (! meth.ok ())
+          error ("no method `%s' found in superclass `%s'",
+                 meth_name.c_str (), cname.c_str ());
+
+        retval = meth.execute (idx, nargout, true,
+                               meth_name);
       }
 
     return retval;
   }
 
 private:
   bool is_constructed_object (const std::string nm)
   {
@@ -1433,46 +1423,44 @@ cdef_object_scalar::subsasgn (const std:
         cdef_property prop = cls.find_property (name);
 
         if (! prop.ok ())
           error ("subsasgn: unknown property: %s", name.c_str ());
 
         if (prop.is_constant ())
           error ("subsasgn: cannot assign constant property: %s",
                  name.c_str ());
+
+        refcount++;
+
+        cdef_object obj (this);
+
+        if (type.length () == 1)
+          {
+            prop.set_value (obj, rhs, true, "subsasgn");
+
+            retval = to_ov (obj);
+          }
         else
           {
-            refcount++;
-
-            cdef_object obj (this);
-
-            if (type.length () == 1)
-              {
-                prop.set_value (obj, rhs, true, "subsasgn");
-
-                retval = to_ov (obj);
-              }
-            else
-              {
-                octave_value val =
-                  prop.get_value (obj, true, "subsasgn");
-
-                std::list<octave_value_list> args (idx);
-
-                args.erase (args.begin ());
-
-                val = val.assign (octave_value::op_asn_eq,
-                                  type.substr (1), args, rhs);
-
-                if (val.class_name () != "object"
-                    || ! to_cdef (val).is_handle_object ())
-                  prop.set_value (obj, val, true, "subsasgn");
-
-                retval = to_ov (obj);
-              }
+            octave_value val =
+              prop.get_value (obj, true, "subsasgn");
+
+            std::list<octave_value_list> args (idx);
+
+            args.erase (args.begin ());
+
+            val = val.assign (octave_value::op_asn_eq,
+                              type.substr (1), args, rhs);
+
+            if (val.class_name () != "object"
+                || ! to_cdef (val).is_handle_object ())
+              prop.set_value (obj, val, true, "subsasgn");
+
+            retval = to_ov (obj);
           }
       }
       break;
 
     case '(':
       {
         refcount++;
 
@@ -1618,61 +1606,59 @@ cdef_object_array::subsasgn (const std::
 
   switch (type[0])
     {
     case '(':
       if (type.length () == 1)
         {
           cdef_object rhs_obj = to_cdef (rhs);
 
-          if (rhs_obj.get_class () == get_class ())
-            {
-              const octave_value_list& ival = idx.front ();
-              bool is_scalar = true;
-              Array<idx_vector> iv (dim_vector (1, ival.length ()));
-
-              for (int i = 0; i < ival.length (); i++)
-                {
-                  try
-                    {
-                      iv(i) = ival(i).index_vector ();
-                    }
-                  catch (index_exception& e)
-                    {
-                      e.set_pos_if_unset (ival.length (), i+1);
-                      throw;   // var name set in pt-idx.cc / pt-assign.cc
-                    }
-
-                  is_scalar = is_scalar && iv(i).is_scalar ();
-                }
-
-              Array<cdef_object> rhs_mat;
-
-              if (! rhs_obj.is_array ())
-                {
-                  rhs_mat = Array<cdef_object> (dim_vector (1, 1));
-                  rhs_mat(0) = rhs_obj;
-                }
-              else
-                rhs_mat = rhs_obj.array_value ();
-
-              octave_idx_type n = array.numel ();
-
-              array.assign (iv, rhs_mat, cdef_object ());
-
-              if (array.numel () > n)
-                fill_empty_values ();
-
-              refcount++;
-              retval = to_ov (cdef_object (this));
-            }
-          else
+          if (rhs_obj.get_class () != get_class ())
             error ("can't assign %s object into array of %s objects.",
                    rhs_obj.class_name ().c_str (),
                    class_name ().c_str ());
+
+          const octave_value_list& ival = idx.front ();
+          bool is_scalar = true;
+          Array<idx_vector> iv (dim_vector (1, ival.length ()));
+
+          for (int i = 0; i < ival.length (); i++)
+            {
+              try
+                {
+                  iv(i) = ival(i).index_vector ();
+                }
+              catch (index_exception& e)
+                {
+                  e.set_pos_if_unset (ival.length (), i+1);
+                  throw;   // var name set in pt-idx.cc / pt-assign.cc
+                }
+
+              is_scalar = is_scalar && iv(i).is_scalar ();
+            }
+
+          Array<cdef_object> rhs_mat;
+
+          if (! rhs_obj.is_array ())
+            {
+              rhs_mat = Array<cdef_object> (dim_vector (1, 1));
+              rhs_mat(0) = rhs_obj;
+            }
+          else
+            rhs_mat = rhs_obj.array_value ();
+
+          octave_idx_type n = array.numel ();
+
+          array.assign (iv, rhs_mat, cdef_object ());
+
+          if (array.numel () > n)
+            fill_empty_values ();
+
+          refcount++;
+          retval = to_ov (cdef_object (this));
         }
       else
         {
           const octave_value_list& ival = idx.front ();
 
           bool is_scalar = true;
 
           Array<idx_vector> iv (dim_vector (1, ival.length ()));
@@ -1724,44 +1710,42 @@ cdef_object_array::subsasgn (const std::
 
           next_idx.erase (next_idx.begin ());
 
           octave_value tmp = obj.subsasgn (type.substr (1), next_idx,
                                            rhs, ignore_copies);
 
           cdef_object robj = to_cdef (tmp);
 
-          if (robj.ok ()
-              && ! robj.is_array ()
-              && robj.get_class () == get_class ())
-            {
-              // Small optimization, when dealing with handle
-              // objects, we don't need to re-assign the result
-              // of subsasgn back into the array.
-
-              if (! robj.is (a(0)))
-                {
-                  Array<cdef_object> rhs_a (dim_vector (1, 1),
-                                            robj);
-
-                  octave_idx_type n = array.numel ();
-
-                  array.assign (iv, rhs_a);
-
-                  if (array.numel () > n)
-                    fill_empty_values ();
-                }
-
-              refcount++;
-
-              retval = to_ov (cdef_object (this));
-            }
-          else
+          if (! robj.ok ()
+              || robj.is_array ()
+              || robj.get_class () != get_class ())
             error ("subasgn: invalid assignment into array of %s "
                    "objects", class_name ().c_str ());
+
+          // Small optimization, when dealing with handle
+          // objects, we don't need to re-assign the result
+          // of subsasgn back into the array.
+
+          if (! robj.is (a(0)))
+            {
+              Array<cdef_object> rhs_a (dim_vector (1, 1),
+                                        robj);
+
+              octave_idx_type n = array.numel ();
+
+              array.assign (iv, rhs_a);
+
+              if (array.numel () > n)
+                fill_empty_values ();
+            }
+
+          refcount++;
+
+          retval = to_ov (cdef_object (this));
         }
       break;
 
     default:
       error ("can't perform indexing operation on array of %s objects",
              class_name ().c_str ());
       break;
     }
@@ -2022,42 +2006,40 @@ cdef_class::cdef_class_rep::install_meth
         {
           octave_user_function *uf = of->user_function_value (true);
 
           if (uf)
             {
               tree_parameter_list *ret_list = uf->return_list ();
               tree_statement_list *body = uf->body ();
 
-              if (ret_list && ret_list->size () == 1)
-                {
-                  std::string obj_name = ret_list->front ()->name ();
-                  ctor_analyzer a (meth.get_name (), obj_name);
-
-                  body->accept (a);
-
-                  std::list<cdef_class> explicit_ctor_list
-                    = a.get_constructor_list ();
-
-                  for (std::list<cdef_class>::const_iterator
-                         it = explicit_ctor_list.begin ();
-                       it != explicit_ctor_list.end ();
-                       ++it)
-                    {
-#if DEBUG_TRACE
-                      std::cerr << "explicit superclass constructor: "
-                                << it->get_name () << std::endl;
-#endif
-
-                      implicit_ctor_list.remove (*it);
-                    }
-                }
-              else
+              if (! ret_list || ret_list->size () != 1)
                 error ("%s: invalid constructor output arguments",
                        meth.get_name ().c_str ());
+
+              std::string obj_name = ret_list->front ()->name ();
+              ctor_analyzer a (meth.get_name (), obj_name);
+
+              body->accept (a);
+
+              std::list<cdef_class> explicit_ctor_list
+                = a.get_constructor_list ();
+
+              for (std::list<cdef_class>::const_iterator
+                     it = explicit_ctor_list.begin ();
+                   it != explicit_ctor_list.end ();
+                   ++it)
+                {
+#if DEBUG_TRACE
+                  std::cerr << "explicit superclass constructor: "
+                            << it->get_name () << std::endl;
+#endif
+
+                  implicit_ctor_list.remove (*it);
+                }
             }
         }
     }
 }
 
 void
 cdef_class::cdef_class_rep::load_all_methods (void)
 {
@@ -2351,61 +2333,61 @@ cdef_class::cdef_class_rep::meta_subsref
 #if DEBUG_TRACE
       std::cerr << "constructor" << std::endl;
 #endif
 
       retval(0) = construct (idx.front ());
       break;
 
     case '.':
-      // Static method, constant (or property?)
+      {
+        // Static method, constant (or property?)
 
 #if DEBUG_TRACE
-      std::cerr << "static method/property" << std::endl;
+        std::cerr << "static method/property" << std::endl;
 #endif
 
-      if (idx.front ().length () == 1)
-        {
-          std::string nm = idx.front ()(0).xstring_value ("invalid meta.class indexing, expected a method or property name");
-
-          cdef_method meth = find_method (nm);
-
-          if (meth.ok ())
-            {
-              if (! meth.is_static ())
-                error ("method `%s' is not static", nm.c_str ());
-
-              octave_value_list args;
-
-              if (type.length () > 1 && idx.size () > 1
-                  && type[1] == '(')
-                {
-                  args = *(++(idx.begin ()));
-                  skip++;
-                }
-
-              retval = meth.execute (args, (type.length () > skip
-                                            ? 1 : nargout), true,
-                                     "meta.class");
-            }
-          else
-            {
-              cdef_property prop = find_property (nm);
-
-              if (! prop.ok ())
-                error ("no such method or property `%s'", nm.c_str ());
-
-              if (prop.is_constant ())
-                retval(0) = prop.get_value (true, "meta.class");
-              else
-                error ("property `%s' is not constant", nm.c_str ());
-            }
-        }
-      else
-        error ("invalid meta.class indexing");
+        if (idx.front ().length () != 1)
+          error ("invalid meta.class indexing");
+
+        std::string nm = idx.front ()(0).xstring_value ("invalid meta.class indexing, expected a method or property name");
+
+        cdef_method meth = find_method (nm);
+
+        if (meth.ok ())
+          {
+            if (! meth.is_static ())
+              error ("method `%s' is not static", nm.c_str ());
+
+            octave_value_list args;
+
+            if (type.length () > 1 && idx.size () > 1
+                && type[1] == '(')
+              {
+                args = *(++(idx.begin ()));
+                skip++;
+              }
+
+            retval = meth.execute (args, (type.length () > skip
+                                          ? 1 : nargout), true,
+                                   "meta.class");
+          }
+        else
+          {
+            cdef_property prop = find_property (nm);
+
+            if (! prop.ok ())
+              error ("no such method or property `%s'", nm.c_str ());
+
+            if (! prop.is_constant ())
+              error ("property `%s' is not constant", nm.c_str ());
+
+            retval(0) = prop.get_value (true, "meta.class");
+          }
+      }
       break;
 
     default:
       error ("invalid meta.class indexing");
       break;
     }
 
   if (type.length () > skip && idx.size () > skip && ! retval.empty ())
@@ -2472,21 +2454,21 @@ cdef_class::cdef_class_rep::run_construc
   if (ctor.ok ())
     {
       octave_value_list ctor_args (args);
       octave_value_list ctor_retval;
 
       ctor_args.prepend (to_ov (obj));
       ctor_retval = ctor.execute (ctor_args, 1, true, "constructor");
 
-      if (ctor_retval.length () == 1)
-        obj = to_cdef (ctor_retval(0));
-      else
+      if (ctor_retval.length () != 1)
         error ("%s: invalid number of output arguments for classdef constructor",
                ctor_name.c_str ());
+
+      obj = to_cdef (ctor_retval(0));
     }
 
   obj.mark_as_constructed (wrap ());
 }
 
 octave_value
 cdef_class::cdef_class_rep::construct (const octave_value_list& args)
 {
@@ -2496,86 +2478,84 @@ cdef_class::cdef_class_rep::construct (c
     return to_ov (obj);
 
   return octave_value ();
 }
 
 cdef_object
 cdef_class::cdef_class_rep::construct_object (const octave_value_list& args)
 {
-  if (! is_abstract ())
+  if (is_abstract ())
+    error ("cannot instantiate object for abstract class `%s'",
+           get_name ().c_str ());
+
+  cdef_object obj;
+
+  if (is_meta_class ())
     {
-      cdef_object obj;
-
-      if (is_meta_class ())
+      // This code path is only used to create empty meta objects
+      // as filler for the empty values within a meta object array.
+
+      cdef_class this_cls = wrap ();
+
+      static cdef_object empty_class;
+
+      if (this_cls == cdef_class::meta_class ())
+        {
+          if (! empty_class.ok ())
+            empty_class = make_class ("", std::list<cdef_class> ());
+          obj = empty_class;
+        }
+      else if (this_cls == cdef_class::meta_property ())
         {
-          // This code path is only used to create empty meta objects
-          // as filler for the empty values within a meta object array.
-
-          cdef_class this_cls = wrap ();
-
-          static cdef_object empty_class;
-
-          if (this_cls == cdef_class::meta_class ())
-            {
-              if (! empty_class.ok ())
-                empty_class = make_class ("", std::list<cdef_class> ());
-              obj = empty_class;
-            }
-          else if (this_cls == cdef_class::meta_property ())
-            {
-              static cdef_property empty_property;
-
-              if (! empty_class.ok ())
-                empty_class = make_class ("", std::list<cdef_class> ());
-              if (! empty_property.ok ())
-                empty_property = make_property (empty_class, "");
-              obj = empty_property;
-            }
-          else if (this_cls == cdef_class::meta_method ())
-            {
-              static cdef_method empty_method;
-
-              if (! empty_class.ok ())
-                empty_class = make_class ("", std::list<cdef_class> ());
-              if (! empty_method.ok ())
-                empty_method = make_method (empty_class, "", octave_value ());
-              obj = empty_method;
-            }
-          else if (this_cls == cdef_class::meta_package ())
-            {
-              static cdef_package empty_package;
-
-              if (! empty_package.ok ())
-                empty_package = make_package ("");
-              obj = empty_package;
-            }
-          else
-            panic_impossible ();
-
-          return obj;
+          static cdef_property empty_property;
+
+          if (! empty_class.ok ())
+            empty_class = make_class ("", std::list<cdef_class> ());
+          if (! empty_property.ok ())
+            empty_property = make_property (empty_class, "");
+          obj = empty_property;
+        }
+      else if (this_cls == cdef_class::meta_method ())
+        {
+          static cdef_method empty_method;
+
+          if (! empty_class.ok ())
+            empty_class = make_class ("", std::list<cdef_class> ());
+          if (! empty_method.ok ())
+            empty_method = make_method (empty_class, "", octave_value ());
+          obj = empty_method;
+        }
+      else if (this_cls == cdef_class::meta_package ())
+        {
+          static cdef_package empty_package;
+
+          if (! empty_package.ok ())
+            empty_package = make_package ("");
+          obj = empty_package;
         }
       else
-        {
-          if (is_handle_class ())
-            obj = cdef_object (new handle_cdef_object ());
-          else
-            obj = cdef_object (new value_cdef_object ());
-          obj.set_class (wrap ());
-
-          initialize_object (obj);
-
-          run_constructor (obj, args);
-
-          return obj;
-        }
+        panic_impossible ();
+
+      return obj;
     }
   else
-    error ("cannot instantiate object for abstract class `%s'",
-           get_name ().c_str ());
+    {
+      if (is_handle_class ())
+        obj = cdef_object (new handle_cdef_object ());
+      else
+        obj = cdef_object (new value_cdef_object ());
+      obj.set_class (wrap ());
+
+      initialize_object (obj);
+
+      run_constructor (obj, args);
+
+      return obj;
+    }
 
   return cdef_object ();
 }
 
 static octave_value
 compute_attribute_value (tree_classdef_attribute* t)
 {
   if (t->expression ())
@@ -2637,21 +2617,21 @@ cdef_class::make_meta_class (tree_classd
           std::string sclass_name = (*it)->class_name ();
 
 #if DEBUG_TRACE
           std::cerr << "superclass: " << sclass_name << std::endl;
 #endif
 
           cdef_class sclass = lookup_class (sclass_name);
 
-          if (! sclass.get ("Sealed").bool_value ())
-            slist.push_back (sclass);
-          else
+          if (sclass.get ("Sealed").bool_value ())
             error ("`%s' cannot inherit from `%s', because it is sealed",
                    full_class_name.c_str (), sclass_name.c_str ());
+
+          slist.push_back (sclass);
         }
     }
 
   retval = ::make_class (full_class_name, slist);
 
   // Package owning this class
 
   if (! t->package_name ().empty ())
@@ -2932,32 +2912,25 @@ cdef_class::get_method_function (const s
 octave_value
 cdef_property::cdef_property_rep::get_value (const cdef_object& obj,
                                              bool do_check_access,
                                              const std::string& who)
 {
   octave_value retval;
 
   if (do_check_access && ! check_get_access ())
-    {
-      gripe_property_access (who, wrap (), false);
-
-      return retval;
-    }
+    gripe_property_access (who, wrap (), false);
 
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
       if (! obj.is_partially_constructed_for (cls))
-        {
-          error ("cannot reference properties of class `%s' for non-constructed object",
-                 cls.get_name ().c_str ());
-          return retval;
-        }
+        error ("cannot reference properties of class `%s' for non-constructed object",
+               cls.get_name ().c_str ());
     }
 
   octave_value get_fcn = get ("GetMethod");
 
   // FIXME: should check whether we're already in get accessor method
 
   if (get_fcn.is_empty () || is_method_executing (get_fcn, obj))
     retval = obj.get (get ("Name").string_value ());
@@ -2975,21 +2948,17 @@ cdef_property::cdef_property_rep::get_va
   return retval;
 }
 
 octave_value
 cdef_property::cdef_property_rep::get_value (bool do_check_access,
                                              const std::string& who)
 {
   if (do_check_access && ! check_get_access ())
-    {
-      gripe_property_access (who, wrap (), false);
-
-      return octave_value ();
-    }
+    gripe_property_access (who, wrap (), false);
 
   return get ("DefaultValue");
 }
 
 bool
 cdef_property::cdef_property_rep::is_recursive_set (const cdef_object& /* obj */) const
 {
   // FIXME: implement
@@ -2998,32 +2967,25 @@ cdef_property::cdef_property_rep::is_rec
 
 void
 cdef_property::cdef_property_rep::set_value (cdef_object& obj,
                                              const octave_value& val,
                                              bool do_check_access,
                                              const std::string& who)
 {
   if (do_check_access && ! check_set_access ())
-    {
-      gripe_property_access (who, wrap (), true);
-
-      return;
-    }
+    gripe_property_access (who, wrap (), true);
 
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
       if (! obj.is_partially_constructed_for (cls))
-        {
-          error ("cannot reference properties of class `%s' for non-constructed object",
-                 cls.get_name ().c_str ());
-          return;
-        }
+        error ("cannot reference properties of class `%s' for non-constructed object",
+               cls.get_name ().c_str ());
     }
 
   octave_value set_fcn = get ("SetMethod");
 
   if (set_fcn.is_empty () || is_method_executing (set_fcn, obj))
     obj.put (get ("Name").string_value (), val);
   else
     {
@@ -3122,72 +3084,60 @@ cdef_method::cdef_method_rep::check_meth
 octave_value_list
 cdef_method::cdef_method_rep::execute (const octave_value_list& args,
                                        int nargout, bool do_check_access,
                                        const std::string& who)
 {
   octave_value_list retval;
 
   if (do_check_access && ! check_access ())
-    {
-      gripe_method_access (who, wrap ());
-
-      return retval;
-    }
-
-  if (! get ("Abstract").bool_value ())
-    {
-      check_method ();
-
-      if (function.is_defined ())
-        retval = execute_ov (function, args, nargout);
-    }
-  else
+    gripe_method_access (who, wrap ());
+
+  if (get ("Abstract").bool_value ())
     error ("%s: cannot execute abstract method",
            get ("Name").string_value ().c_str ());
 
+  check_method ();
+
+  if (function.is_defined ())
+    retval = execute_ov (function, args, nargout);
+
   return retval;
 }
 
 octave_value_list
 cdef_method::cdef_method_rep::execute (const cdef_object& obj,
                                        const octave_value_list& args,
                                        int nargout, bool do_check_access,
                                        const std::string& who)
 {
   octave_value_list retval;
 
   if (do_check_access && ! check_access ())
-    {
-      gripe_method_access (who, wrap ());
-
-      return retval;
-    }
-
-  if (! get ("Abstract").bool_value ())
-    {
-      check_method ();
-
-      if (function.is_defined ())
-        {
-          octave_value_list new_args;
-
-          new_args.resize (args.length () + 1);
-
-          new_args(0) = to_ov (obj);
-          for (int i = 0; i < args.length (); i++)
-            new_args(i+1) = args(i);
-
-          retval = execute_ov (function, new_args, nargout);
-        }
-    }
-  else
+    gripe_method_access (who, wrap ());
+
+  if (get ("Abstract").bool_value ())
     error ("%s: cannot execute abstract method",
            get ("Name").string_value ().c_str ());
 
+  check_method ();
+
+  if (function.is_defined ())
+    {
+      octave_value_list new_args;
+
+      new_args.resize (args.length () + 1);
+
+      new_args(0) = to_ov (obj);
+      for (int i = 0; i < args.length (); i++)
+        new_args(i+1) = args(i);
+
+      retval = execute_ov (function, new_args, nargout);
+    }
+
   return retval;
 }
 
 bool
 cdef_method::cdef_method_rep::is_constructor (void) const
 {
   if (function.is_function())
     return function.function_value ()->is_classdef_constructor ();
@@ -3233,25 +3183,23 @@ lookup_package (const std::string& name)
   return cdef_manager::find_package (name);
 }
 
 static octave_value_list
 package_fromName (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
-  if (args.length () == 1)
-    {
-      std::string name = args(0).xstring_value ("fromName: PACKAGE_NAME must be a string");
-
-      retval(0) = to_ov (lookup_package (name));
-    }
-  else
+  if (args.length () != 1)
     error ("fromName: invalid number of parameters");
 
+  std::string name = args(0).xstring_value ("fromName: PACKAGE_NAME must be a string");
+
+  retval(0) = to_ov (lookup_package (name));
+
   return retval;
 }
 
 static octave_value_list
 package_get_classes (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval (1, Matrix ());
 
@@ -3390,62 +3338,62 @@ cdef_package::cdef_package_rep::meta_sub
   (const std::string& type, const std::list<octave_value_list>& idx,
    int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '.':
-      if (idx.front ().length () == 1)
-        {
-          std::string nm = idx.front ()(0).xstring_value ("invalid meta.package indexing, expected a symbol name");
+      {
+        if (idx.front ().length () != 1)
+          error ("invalid meta.package indexing");
+
+        std::string nm = idx.front ()(0).xstring_value ("invalid meta.package indexing, expected a symbol name");
 
 #if DEBUG_TRACE
-          std::cerr << "meta.package query: " << nm << std::endl;
+        std::cerr << "meta.package query: " << nm << std::endl;
 #endif
 
-          octave_value o = find (nm);
-
-          if (! o.is_defined ())
-            error ("member `%s' in package `%s' does not exist",
-                   nm.c_str (), get_name ().c_str ());
-
-          if (o.is_function ())
-            {
-              octave_function* fcn = o.function_value ();
-
-              // NOTE: the case where the package query is the last
-              // part of this subsref index is handled in the parse
-              // tree, because there is some logic to handle magic
-              // "end" that makes it impossible to execute the
-              // function call at this stage.
-
-              if (type.size () > 1
-                  && ! fcn->is_postfix_index_handled (type[1]))
-                {
-                  octave_value_list tmp_args;
-
-                  retval = o.do_multi_index_op (nargout,
-                                                tmp_args);
-                }
-              else
-                retval(0) = o;
-
-              if (type.size () > 1 && idx.size () > 1)
-                retval = retval(0).next_subsref (nargout, type,
-                                                 idx, 1);
-            }
-          else if (type.size () > 1 && idx.size () > 1)
-            retval = o.next_subsref (nargout, type, idx, 1);
-          else
-            retval(0) = o;
-        }
-      else
-        error ("invalid meta.package indexing");
+        octave_value o = find (nm);
+
+        if (! o.is_defined ())
+          error ("member `%s' in package `%s' does not exist",
+                 nm.c_str (), get_name ().c_str ());
+
+        if (o.is_function ())
+          {
+            octave_function* fcn = o.function_value ();
+
+            // NOTE: the case where the package query is the last
+            // part of this subsref index is handled in the parse
+            // tree, because there is some logic to handle magic
+            // "end" that makes it impossible to execute the
+            // function call at this stage.
+
+            if (type.size () > 1
+                && ! fcn->is_postfix_index_handled (type[1]))
+              {
+                octave_value_list tmp_args;
+
+                retval = o.do_multi_index_op (nargout,
+                                              tmp_args);
+              }
+            else
+              retval(0) = o;
+
+            if (type.size () > 1 && idx.size () > 1)
+              retval = retval(0).next_subsref (nargout, type,
+                                               idx, 1);
+          }
+        else if (type.size () > 1 && idx.size () > 1)
+          retval = o.next_subsref (nargout, type, idx, 1);
+        else
+          retval(0) = o;
+      }
       break;
 
     default:
       error ("invalid meta.package indexing");
       break;
     }
 
   return retval;
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -306,29 +306,23 @@ octave_complex_matrix::diag (octave_idx_
     retval = octave_base_matrix<ComplexNDArray>::diag (k);
 
   return retval;
 }
 
 octave_value
 octave_complex_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
-  octave_value retval;
-
-  if (matrix.ndims () == 2
-      && (matrix.rows () == 1 || matrix.columns () == 1))
-    {
-      ComplexMatrix mat (matrix);
-
-      retval = mat.diag (m, n);
-    }
-  else  // FIXME: Is this ever reachable?
+  if (matrix.ndims () != 2
+      || (matrix.rows () != 1 && matrix.columns () != 1))
     error ("diag: expecting vector argument");
 
-  return retval;
+  ComplexMatrix mat (matrix);
+
+  return mat.diag (m, n);
 }
 
 bool
 octave_complex_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
@@ -369,62 +363,58 @@ octave_complex_matrix::load_ascii (std::
 
   if (! extract_keyword (is, keywords, kw, val, true))
     error ("load: failed to extract number of rows and columns");
 
   if (kw == "ndims")
     {
       int mdims = static_cast<int> (val);
 
-      if (mdims >= 0)
-        {
-          dim_vector dv;
-          dv.resize (mdims);
+      if (mdims < 0)
+        error ("load: failed to extract number of dimensions");
 
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+      dim_vector dv;
+      dv.resize (mdims);
 
-          if (! is)
-            error ("load: failed to read dimensions");
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
 
-          ComplexNDArray tmp(dv);
+      if (! is)
+        error ("load: failed to read dimensions");
 
-          is >> tmp;
+      ComplexNDArray tmp(dv);
 
-          if (is)
-            matrix = tmp;
-          else
-            error ("load: failed to load matrix constant");
-        }
-      else
-        error ("load: failed to extract number of dimensions");
+      is >> tmp;
+
+      if (!is)
+        error ("load: failed to load matrix constant");
+
+      matrix = tmp;
     }
   else if (kw == "rows")
     {
       octave_idx_type nr = val;
       octave_idx_type nc = 0;
 
-      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+      if (nr < 0 || ! extract_keyword (is, "columns", nc) || nc < 0)
+        error ("load: failed to extract number of rows and columns");
+
+      if (nr > 0 && nc > 0)
         {
-          if (nr > 0 && nc > 0)
-            {
-              ComplexMatrix tmp (nr, nc);
-              is >> tmp;
-              if (is)
-                matrix = tmp;
-              else
-                error ("load: failed to load matrix constant");
-            }
-          else if (nr == 0 || nc == 0)
-            matrix = ComplexMatrix (nr, nc);
-          else
-            panic_impossible ();
+          ComplexMatrix tmp (nr, nc);
+          is >> tmp;
+          if (! is)
+            error ("load: failed to load matrix constant");
+
+          matrix = tmp;
         }
+      else if (nr == 0 || nc == 0)
+        matrix = ComplexMatrix (nr, nc);
       else
-        error ("load: failed to extract number of rows and columns");
+        panic_impossible ();
     }
   else
     panic_impossible ();
 
   return success;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -280,29 +280,23 @@ octave_float_complex_matrix::diag (octav
     retval = octave_base_matrix<FloatComplexNDArray>::diag (k);
 
   return retval;
 }
 
 octave_value
 octave_float_complex_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
-  octave_value retval;
-
-  if (matrix.ndims () == 2
-      && (matrix.rows () == 1 || matrix.columns () == 1))
-    {
-      FloatComplexMatrix mat (matrix);
-
-      retval = mat.diag (m, n);
-    }
-  else
+  if (matrix.ndims () != 2
+      || (matrix.rows () != 1 && matrix.columns () != 1))
     error ("diag: expecting vector argument");
 
-  return retval;
+  FloatComplexMatrix mat (matrix);
+
+  return mat.diag (m, n);
 }
 
 bool
 octave_float_complex_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
@@ -343,62 +337,58 @@ octave_float_complex_matrix::load_ascii 
 
   if (! extract_keyword (is, keywords, kw, val, true))
     error ("load: failed to extract number of rows and columns");
 
   if (kw == "ndims")
     {
       int mdims = static_cast<int> (val);
 
-      if (mdims >= 0)
-        {
-          dim_vector dv;
-          dv.resize (mdims);
+      if (mdims < 0)
+        error ("load: failed to extract number of dimensions");
 
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+      dim_vector dv;
+      dv.resize (mdims);
 
-          if (! is)
-            error ("load: failed to read dimensions");
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
 
-          FloatComplexNDArray tmp(dv);
+      if (! is)
+        error ("load: failed to read dimensions");
 
-          is >> tmp;
+      FloatComplexNDArray tmp(dv);
 
-          if (is)
-            matrix = tmp;
-          else
-            error ("load: failed to load matrix constant");
-        }
-      else
-        error ("load: failed to extract number of dimensions");
+      is >> tmp;
+
+      if (! is)
+        error ("load: failed to load matrix constant");
+
+      matrix = tmp;
     }
   else if (kw == "rows")
     {
       octave_idx_type nr = val;
       octave_idx_type nc = 0;
 
-      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+      if (nr < 0 || ! extract_keyword (is, "columns", nc) || nc < 0)
+        error ("load: failed to extract number of rows and columns");
+
+      if (nr > 0 && nc > 0)
         {
-          if (nr > 0 && nc > 0)
-            {
-              FloatComplexMatrix tmp (nr, nc);
-              is >> tmp;
-              if (is)
-                matrix = tmp;
-              else
-                error ("load: failed to load matrix constant");
-            }
-          else if (nr == 0 || nc == 0)
-            matrix = FloatComplexMatrix (nr, nc);
-          else
-            panic_impossible ();
+          FloatComplexMatrix tmp (nr, nc);
+          is >> tmp;
+          if (! is)
+            error ("load: failed to load matrix constant");
+
+          matrix = tmp;
         }
+      else if (nr == 0 || nc == 0)
+        matrix = FloatComplexMatrix (nr, nc);
       else
-        error ("load: failed to extract number of rows and columns");
+        panic_impossible ();
     }
   else
     panic_impossible ();
 
   return success;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -258,29 +258,23 @@ octave_float_matrix::diag (octave_idx_ty
     retval = octave_base_matrix<FloatNDArray>::diag (k);
 
   return retval;
 }
 
 octave_value
 octave_float_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
-  octave_value retval;
-
-  if (matrix.ndims () == 2
-      && (matrix.rows () == 1 || matrix.columns () == 1))
-    {
-      FloatMatrix mat (matrix);
-
-      retval = mat.diag (m, n);
-    }
-  else
+  if (matrix.ndims () != 2
+      || (matrix.rows () != 1 && matrix.columns () != 1))
     error ("diag: expecting vector argument");
 
-  return retval;
+  FloatMatrix mat (matrix);
+
+  return mat.diag (m, n);
 }
 
 octave_value
 octave_float_matrix::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
   dim_vector dv = dims ();
   octave_idx_type nel = dv.numel ();
@@ -370,62 +364,58 @@ octave_float_matrix::load_ascii (std::is
 
   if (! extract_keyword (is, keywords, kw, val, true))
     error ("load: failed to extract number of rows and columns");
 
   if (kw == "ndims")
     {
       int mdims = static_cast<int> (val);
 
-      if (mdims >= 0)
-        {
-          dim_vector dv;
-          dv.resize (mdims);
+      if (mdims < 0)
+        error ("load: failed to extract number of dimensions");
 
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+      dim_vector dv;
+      dv.resize (mdims);
 
-          if (! is)
-            error ("load: failed to read dimensions");
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
 
-          FloatNDArray tmp(dv);
+      if (! is)
+        error ("load: failed to read dimensions");
 
-          is >> tmp;
+      FloatNDArray tmp(dv);
 
-          if (is)
-            matrix = tmp;
-          else
-            error ("load: failed to load matrix constant");
-        }
-      else
-        error ("load: failed to extract number of dimensions");
+      is >> tmp;
+
+      if (! is)
+        error ("load: failed to load matrix constant");
+
+      matrix = tmp;
     }
   else if (kw == "rows")
     {
       octave_idx_type nr = val;
       octave_idx_type nc = 0;
 
-      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+      if (nr < 0 || ! extract_keyword (is, "columns", nc) || nc < 0)
+        error ("load: failed to extract number of rows and columns");
+
+      if (nr > 0 && nc > 0)
         {
-          if (nr > 0 && nc > 0)
-            {
-              FloatMatrix tmp (nr, nc);
-              is >> tmp;
-              if (is)
-                matrix = tmp;
-              else
-                error ("load: failed to load matrix constant");
-            }
-          else if (nr == 0 || nc == 0)
-            matrix = FloatMatrix (nr, nc);
-          else
-            panic_impossible ();
+          FloatMatrix tmp (nr, nc);
+          is >> tmp;
+          if (! is)
+            error ("load: failed to load matrix constant");
+
+          matrix = tmp;
         }
+      else if (nr == 0 || nc == 0)
+        matrix = FloatMatrix (nr, nc);
       else
-        error ("load: failed to extract number of rows and columns");
+        panic_impossible ();
     }
   else
     panic_impossible ();
 
   return success;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -281,36 +281,32 @@ octave_perm_matrix::save_ascii (std::ost
 
 bool
 octave_perm_matrix::load_ascii (std::istream& is)
 {
   octave_idx_type n;
   bool success = true;
   char orient;
 
-  if (extract_keyword (is, "size", n, true)
-      && extract_keyword (is, "orient", orient, true))
-    {
-      bool colp = orient == 'c';
-      ColumnVector tmp (n);
-      is >> tmp;
-      if (! is)
-        error ("load: failed to load permutation matrix constant");
-      else
-        {
-          Array<octave_idx_type> pvec (dim_vector (n, 1));
-          for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
-          matrix = PermMatrix (pvec, colp);
+  if (! extract_keyword (is, "size", n, true)
+      || ! extract_keyword (is, "orient", orient, true))
+    error ("load: failed to extract size & orientation");
 
-          // Invalidate cache. Probably not necessary, but safe.
-          dense_cache = octave_value ();
-        }
-    }
-  else
-    error ("load: failed to extract size & orientation");
+  bool colp = orient == 'c';
+  ColumnVector tmp (n);
+  is >> tmp;
+  if (! is)
+    error ("load: failed to load permutation matrix constant");
+
+  Array<octave_idx_type> pvec (dim_vector (n, 1));
+  for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
+  matrix = PermMatrix (pvec, colp);
+
+  // Invalidate cache. Probably not necessary, but safe.
+  dense_cache = octave_value ();
 
   return success;
 }
 
 bool
 octave_perm_matrix::save_binary (std::ostream& os, bool&)
 {
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -267,29 +267,23 @@ octave_matrix::diag (octave_idx_type k) 
     retval = octave_base_matrix<NDArray>::diag (k);
 
   return retval;
 }
 
 octave_value
 octave_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
-  octave_value retval;
-
-  if (matrix.ndims () == 2
-      && (matrix.rows () == 1 || matrix.columns () == 1))
-    {
-      Matrix mat (matrix);
-
-      retval = mat.diag (m, n);
-    }
-  else
+  if (matrix.ndims () != 2
+      || (matrix.rows () != 1 && matrix.columns () != 1))
     error ("diag: expecting vector argument");
 
-  return retval;
+  Matrix mat (matrix);
+
+  return mat.diag (m, n);
 }
 
 // We override these two functions to allow reshaping both
 // the matrix and the index cache.
 octave_value
 octave_matrix::reshape (const dim_vector& new_dims) const
 {
   if (idx_cache)
@@ -472,62 +466,58 @@ octave_matrix::load_ascii (std::istream&
 
   if (! extract_keyword (is, keywords, kw, val, true))
     error ("load: failed to extract number of rows and columns");
 
   if (kw == "ndims")
     {
       int mdims = static_cast<int> (val);
 
-      if (mdims >= 0)
-        {
-          dim_vector dv;
-          dv.resize (mdims);
+      if (mdims < 0)
+        error ("load: failed to extract number of dimensions");
 
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+      dim_vector dv;
+      dv.resize (mdims);
 
-          if (! is)
-            error ("load: failed to read dimensions");
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
 
-          NDArray tmp(dv);
+      if (! is)
+        error ("load: failed to read dimensions");
 
-          is >> tmp;
+      NDArray tmp(dv);
 
-          if (is)
-            matrix = tmp;
-          else
-            error ("load: failed to load matrix constant");
-        }
-      else
-        error ("load: failed to extract number of dimensions");
+      is >> tmp;
+
+      if (! is)
+        error ("load: failed to load matrix constant");
+
+      matrix = tmp;
     }
   else if (kw == "rows")
     {
       octave_idx_type nr = val;
       octave_idx_type nc = 0;
 
-      if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
+      if (nr < 0 || ! extract_keyword (is, "columns", nc) || nc < 0)
+        error ("load: failed to extract number of rows and columns");
+
+      if (nr > 0 && nc > 0)
         {
-          if (nr > 0 && nc > 0)
-            {
-              Matrix tmp (nr, nc);
-              is >> tmp;
-              if (is)
-                matrix = tmp;
-              else
-                error ("load: failed to load matrix constant");
-            }
-          else if (nr == 0 || nc == 0)
-            matrix = Matrix (nr, nc);
-          else
-            panic_impossible ();
+          Matrix tmp (nr, nc);
+          is >> tmp;
+          if (! is)
+            error ("load: failed to load matrix constant");
+
+          matrix = tmp;
         }
+      else if (nr == 0 || nc == 0)
+        matrix = Matrix (nr, nc);
       else
-        error ("load: failed to extract number of rows and columns");
+        panic_impossible ();
     }
   else
     panic_impossible ();
 
   return success;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -213,66 +213,56 @@ octave_char_matrix_str::complex_array_va
                     complex_array_value);
 }
 
 string_vector
 octave_char_matrix_str::all_strings (bool) const
 {
   string_vector retval;
 
-  if (matrix.ndims () == 2)
-    {
-      charMatrix chm (matrix);
+  if (matrix.ndims () != 2)
+    error ("invalid conversion of charNDArray to string_vector");
 
-      octave_idx_type n = chm.rows ();
+  charMatrix chm (matrix);
 
-      retval.resize (n);
+  octave_idx_type n = chm.rows ();
 
-      for (octave_idx_type i = 0; i < n; i++)
-        retval[i] = chm.row_as_string (i);
-    }
-  else
-    error ("invalid conversion of charNDArray to string_vector");
+  retval.resize (n);
+
+  for (octave_idx_type i = 0; i < n; i++)
+    retval[i] = chm.row_as_string (i);
 
   return retval;
 }
 
 std::string
 octave_char_matrix_str::string_value (bool) const
 {
-  std::string retval;
-
-  if (matrix.ndims () == 2)
-    {
-      charMatrix chm (matrix);
-
-      retval = chm.row_as_string (0);  // FIXME?
-    }
-  else
+  if (matrix.ndims () != 2)
     error ("invalid conversion of charNDArray to string");
 
-  return retval;
+  charMatrix chm (matrix);
+
+  return chm.row_as_string (0);  // FIXME?
 }
 
 Array<std::string>
 octave_char_matrix_str::cellstr_value (void) const
 {
   Array<std::string> retval;
 
-  if (matrix.ndims () == 2)
-    {
-      const charMatrix chm (matrix);
-      octave_idx_type nr = chm.rows ();
-      retval.clear (nr, 1);
-      for (octave_idx_type i = 0; i < nr; i++)
-        retval.xelem (i) = chm.row_as_string (i);
-    }
-  else
+  if (matrix.ndims () != 2)
     error ("cellstr: cannot convert multidimensional arrays");
 
+  const charMatrix chm (matrix);
+  octave_idx_type nr = chm.rows ();
+  retval.clear (nr, 1);
+  for (octave_idx_type i = 0; i < nr; i++)
+    retval.xelem (i) = chm.row_as_string (i);
+
   return retval;
 }
 
 void
 octave_char_matrix_str::print_raw (std::ostream& os,
                                    bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
@@ -346,89 +336,81 @@ octave_char_matrix_str::load_ascii (std:
 
   if (! extract_keyword (is, keywords, kw, val, true))
     error ("load: failed to extract number of rows and columns");
 
   if (kw == "ndims")
     {
       int mdims = val;
 
-      if (mdims >= 0)
-        {
-          dim_vector dv;
-          dv.resize (mdims);
+      if (mdims < 0)
+        error ("load: failed to extract matrix size");
+
+      dim_vector dv;
+      dv.resize (mdims);
 
-          for (int i = 0; i < mdims; i++)
-            is >> dv(i);
+      for (int i = 0; i < mdims; i++)
+        is >> dv(i);
 
-          if (! is)
-            error ("load: failed to read dimensions");
+      if (! is)
+        error ("load: failed to read dimensions");
 
-          charNDArray tmp(dv);
+      charNDArray tmp(dv);
 
-          if (tmp.is_empty ())
-            matrix = tmp;
-          else
-            {
-              char *ftmp = tmp.fortran_vec ();
-
-              skip_preceeding_newline (is);
+      if (tmp.is_empty ())
+        matrix = tmp;
+      else
+        {
+          char *ftmp = tmp.fortran_vec ();
 
-              if (! is.read (ftmp, dv.numel ()) || ! is)
-                error ("load: failed to load string constant");
-              else
-                matrix = tmp;
-            }
+          skip_preceeding_newline (is);
+
+          if (! is.read (ftmp, dv.numel ()) || ! is)
+            error ("load: failed to load string constant");
+
+          matrix = tmp;
         }
-      else
-        error ("load: failed to extract matrix size");
     }
   else if (kw == "elements")
     {
       int elements = val;
 
-      if (elements >= 0)
-        {
-          // FIXME: need to be able to get max length before doing anything.
+      if (elements < 0)
+        error ("load: failed to extract number of string elements");
+
+      // FIXME: need to be able to get max length before doing anything.
 
-          charMatrix chm (elements, 0);
-          int max_len = 0;
-          for (int i = 0; i < elements; i++)
-            {
-              int len;
-              if (extract_keyword (is, "length", len) && len >= 0)
-                {
-                  // Use this instead of a C-style character
-                  // buffer so that we can properly handle
-                  // embedded NUL characters.
-                  charMatrix tmp (1, len);
-                  char *ptmp = tmp.fortran_vec ();
+      charMatrix chm (elements, 0);
+      int max_len = 0;
+      for (int i = 0; i < elements; i++)
+        {
+          int len;
+          if (! extract_keyword (is, "length", len) || len < 0)
+            error ("load: failed to extract string length for element %d",
+                   i+1);
 
-                  if (len > 0 && ! is.read (ptmp, len))
-                    error ("load: failed to load string constant");
-                  else
-                    {
-                      if (len > max_len)
-                        {
-                          max_len = len;
-                          chm.resize (elements, max_len, 0);
-                        }
+          // Use this instead of a C-style character
+          // buffer so that we can properly handle
+          // embedded NUL characters.
+          charMatrix tmp (1, len);
+          char *ptmp = tmp.fortran_vec ();
 
-                      chm.insert (tmp, i, 0);
-                    }
-                }
-              else
-                error ("load: failed to extract string length for element %d",
-                       i+1);
+          if (len > 0 && ! is.read (ptmp, len))
+            error ("load: failed to load string constant");
+
+          if (len > max_len)
+            {
+              max_len = len;
+              chm.resize (elements, max_len, 0);
             }
 
-          matrix = chm;
+          chm.insert (tmp, i, 0);
         }
-      else
-        error ("load: failed to extract number of string elements");
+
+      matrix = chm;
     }
   else if (kw == "length")
     {
       int len = val;
 
       if (len >= 0)
         {
           // This is cruft for backward compatibility,
@@ -436,23 +418,21 @@ octave_char_matrix_str::load_ascii (std:
 
           // Use this instead of a C-style character buffer so
           // that we can properly handle embedded NUL characters.
           charMatrix tmp (1, len);
           char *ptmp = tmp.fortran_vec ();
 
           if (len > 0 && ! is.read (ptmp, len))
             error ("load: failed to load string constant");
-          else
-            {
-              if (is)
-                matrix = tmp;
-              else
-                error ("load: failed to load string constant");
-            }
+
+          if (! is)
+            error ("load: failed to load string constant");
+
+          matrix = tmp;
         }
     }
   else
     panic_impossible ();
 
   return success;
 }
 
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -722,51 +722,49 @@ octave_struct::load_ascii (std::istream&
             is >> dv(i);
 
           success = extract_keyword (is, keywords[1], len);
         }
     }
   else
     success = false;
 
-  if (success && len >= 0)
+  if (! success || len < 0)
+    error ("load: failed to extract number of elements in structure");
+
+  if (len > 0)
     {
-      if (len > 0)
+      octave_map m (dv);
+
+      for (octave_idx_type j = 0; j < len; j++)
         {
-          octave_map m (dv);
-
-          for (octave_idx_type j = 0; j < len; j++)
-            {
-              octave_value t2;
-              bool dummy;
-
-              // recurse to read cell elements
-              std::string nm
-                = read_text_data (is, std::string (), dummy, t2, j);
-
-              if (! is)
-                break;
-
-              Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
-
-              m.setfield (nm, tcell);
-            }
-
-          if (is)
-            map = m;
-          else
-            error ("load: failed to load structure");
+          octave_value t2;
+          bool dummy;
+
+          // recurse to read cell elements
+          std::string nm
+            = read_text_data (is, std::string (), dummy, t2, j);
+
+          if (! is)
+            break;
+
+          Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
+
+          m.setfield (nm, tcell);
         }
-      else if (len == 0)
-        map = octave_map (dv);
-      else
-        panic_impossible ();
+
+      if (! is)
+        error ("load: failed to load structure");
+
+      map = m;
     }
+  else if (len == 0)
+    map = octave_map (dv);
   else
-    error ("load: failed to extract number of elements in structure");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_map m = map_value ();
@@ -861,20 +859,20 @@ octave_struct::load_binary (std::istream
           if (! is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
           m.setfield (nm, tcell);
         }
 
-      if (is)
-        map = m;
-      else
+      if (! is)
         error ("load: failed to load structure");
+
+      map = m;
     }
   else if (len == 0)
     map = octave_map (dv);
   else
     success = false;
 
   return success;
 }
@@ -1363,49 +1361,47 @@ octave_scalar_struct::save_ascii (std::o
 }
 
 bool
 octave_scalar_struct::load_ascii (std::istream& is)
 {
   bool success = true;
   octave_idx_type len = 0;
 
-  if (extract_keyword (is, "length", len) && len >= 0)
+  if (! extract_keyword (is, "length", len) || len < 0)
+    error ("load: failed to extract number of elements in structure");
+
+  if (len > 0)
     {
-      if (len > 0)
+      octave_scalar_map m;
+
+      for (octave_idx_type j = 0; j < len; j++)
         {
-          octave_scalar_map m;
-
-          for (octave_idx_type j = 0; j < len; j++)
-            {
-              octave_value t2;
-              bool dummy;
-
-              // recurse to read cell elements
-              std::string nm
-                = read_text_data (is, std::string (), dummy, t2, j);
-
-              if (! is)
-                break;
-
-              m.setfield (nm, t2);
-            }
-
-          if (is)
-            map = m;
-          else
-            error ("load: failed to load structure");
+          octave_value t2;
+          bool dummy;
+
+          // recurse to read cell elements
+          std::string nm
+            = read_text_data (is, std::string (), dummy, t2, j);
+
+          if (! is)
+            break;
+
+          m.setfield (nm, t2);
         }
-      else if (len == 0)
-        map = octave_scalar_map ();
-      else
-        panic_impossible ();
+
+      if (! is)
+        error ("load: failed to load structure");
+
+      map = m;
     }
+  else if (len == 0)
+    map = octave_scalar_map ();
   else
-    error ("load: failed to extract number of elements in structure");
+    panic_impossible ();
 
   return success;
 }
 
 bool
 octave_scalar_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_map m = map_value ();
@@ -1462,20 +1458,20 @@ octave_scalar_struct::load_binary (std::
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
           m.setfield (nm, t2);
         }
 
-      if (is)
-        map = m;
-      else
+      if (! is)
         error ("load: failed to load structure");
+
+      map = m;
     }
   else if (len == 0)
     map = octave_scalar_map ();
   else
     success = false;
 
   return success;
 }
@@ -2068,20 +2064,20 @@ the named fields.\n\
   octave_value_list fval = Fcellstr (args(1), 1);
 
   Cell fcell = fval(0).cell_value ();
 
   for (int i = 0; i < fcell.numel (); i++)
     {
       std::string key = fcell(i).string_value ();
 
-      if (m.isfield (key))
-        m.rmfield (key);
-      else
+      if (! m.isfield (key))
         error ("rmfield: structure does not contain field %s", key.c_str ());
+
+      m.rmfield (key);
     }
 
   return ovl (m);
 }
 
 /*
 ## test rmfield
 %!shared x
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -121,50 +121,46 @@ octave_user_script::subsref (const std::
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
                                        const octave_value_list& args)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
-  if (args.length () == 0 && nargout == 0)
-    {
-      if (cmd_list)
-        {
-          frame.protect_var (call_depth);
-          call_depth++;
+  if (args.length () != 0 || nargout != 0)
+    error ("invalid call to script %s", file_name.c_str ());
 
-          if (call_depth < Vmax_recursion_depth)
-            {
-              octave_call_stack::push (this);
+  if (cmd_list)
+    {
+      frame.protect_var (call_depth);
+      call_depth++;
 
-              frame.add_fcn (octave_call_stack::pop);
+      if (call_depth >= Vmax_recursion_depth)
+        error ("max_recursion_depth exceeded");
 
-              frame.protect_var (tree_evaluator::statement_context);
-              tree_evaluator::statement_context = tree_evaluator::script;
+      octave_call_stack::push (this);
+
+      frame.add_fcn (octave_call_stack::pop);
 
-              BEGIN_PROFILER_BLOCK (octave_user_script)
-
-                cmd_list->accept (*current_evaluator);
+      frame.protect_var (tree_evaluator::statement_context);
+      tree_evaluator::statement_context = tree_evaluator::script;
 
-              END_PROFILER_BLOCK
+      BEGIN_PROFILER_BLOCK (octave_user_script)
 
-                if (tree_return_command::returning)
-                  tree_return_command::returning = 0;
+        cmd_list->accept (*current_evaluator);
 
-              if (tree_break_command::breaking)
-                tree_break_command::breaking--;
-            }
-          else
-            error ("max_recursion_depth exceeded");
-        }
+      END_PROFILER_BLOCK
+
+      if (tree_return_command::returning)
+        tree_return_command::returning = 0;
+
+      if (tree_break_command::breaking)
+        tree_break_command::breaking--;
     }
-  else
-    error ("invalid call to script %s", file_name.c_str ());
 
   return retval;
 }
 
 void
 octave_user_script::accept (tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
@@ -523,21 +519,21 @@ octave_user_function::do_multi_index_op 
   if (param_list && ! param_list->varargs_only ())
     param_list->define_from_arg_vector (args);
 
   // For classdef constructor, pre-populate the output arguments
   // with the pre-initialized object instance, extracted above.
 
   if (is_classdef_constructor ())
     {
-      if (ret_list)
-        ret_list->define_from_arg_vector (ret_args);
-      else
+      if (! ret_list)
         error ("%s: invalid classdef constructor, no output argument defined",
                dispatch_class ().c_str ());
+
+      ret_list->define_from_arg_vector (ret_args);
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
   if (param_list)
     frame.add_method (param_list, &tree_parameter_list::undefine);
@@ -835,30 +831,28 @@ Programming Note: @code{nargin} does not
         }
 
       octave_function *fcn_val = func.function_value ();
       if (! fcn_val)
         error ("nargin: FCN must be a string or function handle");
 
       octave_user_function *fcn = fcn_val->user_function_value (true);
 
-      if (fcn)
-        {
-          tree_parameter_list *param_list = fcn->parameter_list ();
-
-          retval = param_list ? param_list->length () : 0;
-          if (fcn->takes_varargs ())
-            retval = -1 - retval;
-        }
-      else
+      if (! fcn)
         {
           // Matlab gives up for histc,
           // so maybe it's ok that that we give up somtimes too?
           error ("nargin: nargin information not available for built-in functions");
         }
+
+      tree_parameter_list *param_list = fcn->parameter_list ();
+
+      retval = param_list ? param_list->length () : 0;
+      if (fcn->takes_varargs ())
+        retval = -1 - retval;
     }
   else
     {
       retval = symbol_table::varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
@@ -953,45 +947,41 @@ returns -1 for all anonymous functions.\
         }
 
       octave_function *fcn_val = func.function_value ();
       if (! fcn_val)
         error ("nargout: FCN must be a string or function handle");
 
       octave_user_function *fcn = fcn_val->user_function_value (true);
 
-      if (fcn)
-        {
-          tree_parameter_list *ret_list = fcn->return_list ();
-
-          retval = ret_list ? ret_list->length () : 0;
-
-          if (fcn->takes_var_return ())
-            retval = -1 - retval;
-        }
-      else
+      if (! fcn)
         {
           // JWE said this information is not available (2011-03-10)
           // without making intrusive changes to Octave.
           // Matlab gives up for histc,
           // so maybe it's ok that we give up somtimes too?
           error ("nargout: nargout information not available for built-in functions.");
         }
+
+      tree_parameter_list *ret_list = fcn->return_list ();
+
+      retval = ret_list ? ret_list->length () : 0;
+
+      if (fcn->takes_var_return ())
+        retval = -1 - retval;
     }
   else
     {
-      if (! symbol_table::at_top_level ())
-        {
-          retval = symbol_table::varval (".nargout.");
+      if (symbol_table::at_top_level ())
+        error ("nargout: invalid call at top level");
 
-          if (retval.is_undefined ())
-            retval = 0;
-        }
-      else
-        error ("nargout: invalid call at top level");
+      retval = symbol_table::varval (".nargout.");
+
+      if (retval.is_undefined ())
+        retval = 0;
     }
 
   return retval;
 }
 
 DEFUN (optimize_subsasgn_calls, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} optimize_subsasgn_calls ()\n\
