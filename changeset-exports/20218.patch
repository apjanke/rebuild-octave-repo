# HG changeset patch
# User Rik <rik@octave.org>
# Date 1432442804 25200
#      Sat May 23 21:46:44 2015 -0700
# Node ID b2100e1659ac8c1f3301d87bffa11a7954db6a01
# Parent  b5d2f6954c48dc157761da9041e27dd38cfbbf34
maint: Use cuddled parentheses when indexing dimension_vectors.

* libinterp/corefcn/besselj.cc, libinterp/corefcn/bsxfun.cc,
libinterp/corefcn/data.cc, libinterp/corefcn/dot.cc, libinterp/corefcn/fft.cc,
libinterp/corefcn/fft2.cc, libinterp/corefcn/tril.cc,
libinterp/corefcn/typecast.cc, libinterp/octave-value/ov-base-int.cc,
libinterp/octave-value/ov-base-mat.cc,
libinterp/octave-value/ov-base-sparse.cc,
libinterp/octave-value/ov-bool-mat.cc, libinterp/octave-value/ov-cell.cc,
libinterp/octave-value/ov-cx-mat.cc, libinterp/octave-value/ov-flt-cx-mat.cc,
libinterp/octave-value/ov-flt-re-mat.cc, libinterp/octave-value/ov-lazy-idx.cc,
libinterp/octave-value/ov-re-mat.cc, libinterp/octave-value/ov-str-mat.cc,
libinterp/octave-value/ov-struct.cc, liboctave/array/Array-util.cc,
liboctave/array/Array.cc, liboctave/array/CMatrix.cc,
liboctave/array/CNDArray.cc, liboctave/array/MArray.cc,
liboctave/array/Sparse.cc, liboctave/array/dMatrix.cc,
liboctave/array/dNDArray.cc, liboctave/array/fCMatrix.cc,
liboctave/array/fCNDArray.cc, liboctave/array/fMatrix.cc,
liboctave/array/fNDArray.cc, liboctave/operators/mx-inlines.cc:
maint: Use cuddled parentheses when indexing dimension_vectors.

diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -173,18 +173,18 @@ do_bessel (enum bessel_type type, const 
               else
                 gripe_bessel_arg (fn, "first");
             }
           else
             {
               dim_vector dv0 = args(0).dims ();
               dim_vector dv1 = args(1).dims ();
 
-              bool args0_is_row_vector = (dv0 (1) == dv0.numel ());
-              bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
+              bool args0_is_row_vector = (dv0(1) == dv0.numel ());
+              bool args1_is_col_vector = (dv1(0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
                   FloatRowVector ralpha = args(0).float_row_vector_value ();
 
                   if (! error_state)
                     {
                       FloatComplexColumnVector cx =
@@ -309,18 +309,18 @@ do_bessel (enum bessel_type type, const 
               else
                 gripe_bessel_arg (fn, "first");
             }
           else
             {
               dim_vector dv0 = args(0).dims ();
               dim_vector dv1 = args(1).dims ();
 
-              bool args0_is_row_vector = (dv0 (1) == dv0.numel ());
-              bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
+              bool args0_is_row_vector = (dv0(1) == dv0.numel ());
+              bool args1_is_col_vector = (dv1(0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
                   RowVector ralpha = args(0).row_vector_value ();
 
                   if (! error_state)
                     {
                       ComplexColumnVector cx =
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -232,43 +232,43 @@ maybe_update_column (octave_value& Ac, c
 {
   octave_idx_type nd = dva.length ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
       for (octave_idx_type j = 1; j < nd; j++)
         {
-          if (dva (j) == 1)
+          if (dva(j) == 1)
             idx(j) = octave_value (1);
           else
             idx(j) = octave_value ((i % dvc(j)) + 1);
 
-          i = i / dvc (j);
+          i = i / dvc(j);
         }
 
       Ac = A;
       Ac = Ac.single_subsref ("(", idx);
       return true;
     }
   else
     {
       bool is_changed = false;
       octave_idx_type k = i;
       octave_idx_type k1 = i - 1;
       for (octave_idx_type j = 1; j < nd; j++)
         {
-          if (dva(j) != 1 && k % dvc (j) != k1 % dvc (j))
+          if (dva(j) != 1 && k % dvc(j) != k1 % dvc(j))
             {
               idx (j) = octave_value ((k % dvc(j)) + 1);
               is_changed = true;
             }
 
-          k = k / dvc (j);
-          k1 = k1 / dvc (j);
+          k = k / dvc(j);
+          k1 = k1 / dvc(j);
         }
 
       if (is_changed)
         {
           Ac = A;
           Ac = Ac.single_subsref ("(", idx);
           return true;
         }
@@ -289,33 +289,33 @@ update_index (octave_value_list& idx, co
       for (octave_idx_type j = nd - 1; j > 0; j--)
         idx(j) = octave_value (1.0);
       idx(0) = octave_value (':');
     }
   else
     {
       for (octave_idx_type j = 1; j < nd; j++)
         {
-          idx (j) = octave_value (i % dv (j) + 1);
-          i = i / dv (j);
+          idx (j) = octave_value (i % dv(j) + 1);
+          i = i / dv(j);
         }
     }
 }
 #endif
 
 static void
 update_index (Array<int>& idx, const dim_vector& dv, octave_idx_type i)
 {
   octave_idx_type nd = dv.length ();
 
   idx(0) = 0;
   for (octave_idx_type j = 1; j < nd; j++)
     {
-      idx (j) = i % dv (j);
-      i = i / dv (j);
+      idx(j) = i % dv(j);
+      i = i / dv(j);
     }
 }
 
 DEFUN (bsxfun, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
 The binary singleton expansion function performs broadcasting,\n\
 that is, it applies a binary function @var{f} element-by-element to two\n\
@@ -386,33 +386,33 @@ dimensionality as the other array.\n\
             dvb.resize (nda, 1);
           else if (nda < ndb)
             {
               dva.resize (ndb, 1);
               nd = ndb;
             }
 
           for (octave_idx_type i = 0; i < nd; i++)
-            if (dva (i) != dvb (i) && dva (i) != 1 && dvb (i) != 1)
+            if (dva(i) != dvb(i) && dva(i) != 1 && dvb(i) != 1)
               {
                 error ("bsxfun: dimensions of A and B must match");
                 break;
               }
 
           if (!error_state)
             {
               // Find the size of the output
               dim_vector dvc;
               dvc.resize (nd);
 
               for (octave_idx_type i = 0; i < nd; i++)
-                dvc (i) = (dva (i) < 1 ? dva (i)
-                                       : (dvb (i) < 1 ? dvb (i)
-                                                      : (dva (i) > dvb (i)
-                                                        ? dva (i) : dvb (i))));
+                dvc(i) = (dva(i) < 1 ? dva(i)
+                                     : (dvb(i) < 1 ? dvb(i)
+                                                   : (dva(i) > dvb(i)
+                                                       ? dva(i) : dvb(i))));
 
               if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
                 {
                   octave_value_list inputs;
                   inputs (0) = A;
                   inputs (1) = B;
                   retval = func.do_multi_index_op (1, inputs);
                 }
@@ -422,17 +422,17 @@ dimensionality as the other array.\n\
                   inputs (0) = A.resize (dvc);
                   inputs (1) = B.resize (dvc);
                   retval = func.do_multi_index_op (1, inputs);
                 }
               else
                 {
                   octave_idx_type ncount = 1;
                   for (octave_idx_type i = 1; i < nd; i++)
-                    ncount *= dvc (i);
+                    ncount *= dvc(i);
 
 #define BSXDEF(T) \
                   T result_ ## T; \
                   bool have_ ## T = false;
 
                   BSXDEF(NDArray);
                   BSXDEF(ComplexNDArray);
                   BSXDEF(FloatNDArray);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2046,17 +2046,17 @@ do_cat (const octave_value_list& xargs, 
       else if (result_type == "uint64")
         retval = do_single_type_concat<uint64NDArray> (args, dim);
       else if (result_type == "cell")
         retval = do_single_type_concat<Cell> (args, dim);
       else if (result_type == "struct")
         retval = do_single_type_concat_map (args, dim);
       else
         {
-          dim_vector  dv = args(0).dims ();
+          dim_vector dv = args(0).dims ();
 
           // Default concatenation.
           bool (dim_vector::*concat_rule) (const dim_vector&, int)
             = &dim_vector::concat;
 
           if (dim == -1 || dim == -2)
             {
               concat_rule = &dim_vector::hvcat;
@@ -2110,18 +2110,17 @@ do_cat (const octave_value_list& xargs, 
 
               if (dim >= dv_len)
                 {
                   if (j > 1)
                     error ("%s: indexing error", fname.c_str ());
                   break;
                 }
               else
-                ra_idx (dim) += (dim < dv_tmp.length () ?
-                                 dv_tmp (dim) : 1);
+                ra_idx(dim) += (dim < dv_tmp.length () ? dv_tmp(dim) : 1);
             }
           retval = tmp;
         }
     }
   else
     print_usage ();
 
   return retval;
@@ -4060,18 +4059,18 @@ fill_matrix (const octave_value_list& ar
               break;
 
             case oct_data_conv::dt_single:
               retval = FloatNDArray (dims, val);
               break;
 
             case oct_data_conv::dt_double:
               {
-                if (val == 1 && dims.length () == 2 && dims (0) == 1)
-                  retval = Range (1.0, 0.0, dims (1)); // packed form
+                if (val == 1 && dims.length () == 2 && dims(0) == 1)
+                  retval = Range (1.0, 0.0, dims(1));  // packed form
                 else
                   retval = NDArray (dims, val);
               }
               break;
 
             case oct_data_conv::dt_logical:
               retval = boolNDArray (dims, val);
               break;
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -168,55 +168,55 @@ but avoids forming a temporary array and
               dim_vector dimz;
               if (argx.is_complex_type () || argy.is_complex_type ())
                 {
                   if (argx.is_single_type () || argy.is_single_type ())
                     {
                       FloatComplexNDArray x = argx.float_complex_array_value ();
                       FloatComplexNDArray y = argy.float_complex_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      FloatComplexNDArray z(dimz);
+                      FloatComplexNDArray z (dimz);
                       if (! error_state)
                         F77_XFCN (cdotc3, CDOTC3, (m, n, k,
                                                    x.data (), y.data (),
                                                    z.fortran_vec ()));
                       retval = z;
                     }
                   else
                     {
                       ComplexNDArray x = argx.complex_array_value ();
                       ComplexNDArray y = argy.complex_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      ComplexNDArray z(dimz);
+                      ComplexNDArray z (dimz);
                       if (! error_state)
                         F77_XFCN (zdotc3, ZDOTC3, (m, n, k,
                                                    x.data (), y.data (),
                                                    z.fortran_vec ()));
                       retval = z;
                     }
                 }
               else if (argx.is_float_type () && argy.is_float_type ())
                 {
                   if (argx.is_single_type () || argy.is_single_type ())
                     {
                       FloatNDArray x = argx.float_array_value ();
                       FloatNDArray y = argy.float_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      FloatNDArray z(dimz);
+                      FloatNDArray z (dimz);
                       if (! error_state)
                         F77_XFCN (sdot3, SDOT3, (m, n, k, x.data (), y.data (),
                                                  z.fortran_vec ()));
                       retval = z;
                     }
                   else
                     {
                       NDArray x = argx.array_value ();
                       NDArray y = argy.array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      NDArray z(dimz);
+                      NDArray z (dimz);
                       if (! error_state)
                         F77_XFCN (ddot3, DDOT3, (m, n, k, x.data (), y.data (),
                                                  z.fortran_vec ()));
                       retval = z;
                     }
                 }
               else
                 {
@@ -335,53 +335,53 @@ endfor\n\
       if (match)
         {
           if (argx.is_complex_type () || argy.is_complex_type ())
             {
               if (argx.is_single_type () || argy.is_single_type ())
                 {
                   FloatComplexNDArray x = argx.float_complex_array_value ();
                   FloatComplexNDArray y = argy.float_complex_array_value ();
-                  FloatComplexNDArray z(dimz);
+                  FloatComplexNDArray z (dimz);
                   if (! error_state)
                     F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
                                                x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
               else
                 {
                   ComplexNDArray x = argx.complex_array_value ();
                   ComplexNDArray y = argy.complex_array_value ();
-                  ComplexNDArray z(dimz);
+                  ComplexNDArray z (dimz);
                   if (! error_state)
                     F77_XFCN (zmatm3, ZMATM3, (m, n, k, np,
                                                x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
             }
           else
             {
               if (argx.is_single_type () || argy.is_single_type ())
                 {
                   FloatNDArray x = argx.float_array_value ();
                   FloatNDArray y = argy.float_array_value ();
-                  FloatNDArray z(dimz);
+                  FloatNDArray z (dimz);
                   if (! error_state)
                     F77_XFCN (smatm3, SMATM3, (m, n, k, np,
                                                x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
               else
                 {
                   NDArray x = argx.array_value ();
                   NDArray y = argy.array_value ();
-                  NDArray z(dimz);
+                  NDArray z (dimz);
                   if (! error_state)
                     F77_XFCN (dmatm3, DMATM3, (m, n, k, np,
                                                x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
             }
         }
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -107,19 +107,19 @@ do_fft (const octave_value_list &args, c
           }
 
       // And if the first argument is scalar?
       if (dim < 0)
         dim = 1;
     }
 
   if (n_points < 0)
-    n_points = dims (dim);
+    n_points = dims(dim);
   else
-    dims (dim) = n_points;
+    dims(dim) = n_points;
 
   if (dims.any_zero () || n_points == 0)
     {
       if (arg.is_single_type ())
         return octave_value (FloatNDArray (dims));
       else
         return octave_value (NDArray (dims));
     }
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -91,24 +91,24 @@ do_fft2 (const octave_value_list &args, 
   if (error_state)
     return retval;
 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (n_rows < 0)
-    n_rows = dims (0);
+    n_rows = dims(0);
   else
-    dims (0) = n_rows;
+    dims(0) = n_rows;
 
   if (n_cols < 0)
-    n_cols = dims (1);
+    n_cols = dims(1);
   else
-    dims (1) = n_cols;
+    dims(1) = n_cols;
 
   if (dims.all_zero () || n_rows == 0 || n_cols == 0)
     {
       if (arg.is_single_type ())
         return octave_value (FloatMatrix ());
       else
         return octave_value (Matrix ());
     }
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -213,17 +213,17 @@ do_trilu (const std::string& name,
     print_usage ();
   else
     {
       octave_value arg = args(0);
 
       dim_vector dims = arg.dims ();
       if (dims.length () != 2)
         error ("%s: need a 2-D matrix", name.c_str ());
-      else if (k < -dims (0) || k > dims(1))
+      else if (k < -dims(0) || k > dims(1))
         error ("%s: requested diagonal out of range", name.c_str ());
       else
         {
           switch (arg.builtin_type ())
             {
             case btyp_double:
               if (arg.is_sparse_type ())
                 retval = do_trilu (arg.sparse_matrix_value (), k, lower, pack);
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "unwind-prot.h"
 
 static dim_vector
 get_vec_dims (const dim_vector& old_dims, octave_idx_type n)
 {
   if (old_dims.length () == 2 && old_dims(0) == 1)
     return dim_vector (1, n);
-  else if (old_dims.length () == 2 && old_dims (0) == 0 && old_dims (1) == 0)
+  else if (old_dims.length () == 2 && old_dims(0) == 0 && old_dims(1) == 0)
     return dim_vector ();
   else
     return dim_vector (n, 1);
 }
 
 template <class ArrayType>
 static void
 get_data_and_bytesize (const ArrayType& array,
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -188,17 +188,17 @@ template <class T>
 bool
 octave_base_int_matrix<T>::save_ascii (std::ostream& os)
 {
   dim_vector d = this->dims ();
 
   os << "# ndims: " << d.length () << "\n";
 
   for (int i = 0; i < d.length (); i++)
-    os << " " << d (i);
+    os << " " << d(i);
 
   os << "\n" << this->matrix;
 
   return true;
 }
 
 template <class T>
 bool
@@ -350,17 +350,17 @@ octave_base_int_matrix<T>::save_hdf5 (oc
 
   int rank = dv.length ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
-    hdims[i] = dv (rank-i-1);
+    hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -353,17 +353,17 @@ octave_base_matrix<MT>::assign (const oc
               {
                 // optimize all scalar indices. Don't construct an index array,
                 // but rather calc a scalar index directly.
                 octave_idx_type k = 1;
                 octave_idx_type j = 0;
                 for (octave_idx_type i = 0; i < n_idx; i++)
                   {
                     j += idx_vec(i)(0) * k;
-                    k *= dv (i);
+                    k *= dv(i);
                   }
                 matrix(j) = rhs;
               }
             else
               matrix.assign (idx_vec, mrhs);
           }
       }
       break;
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -389,18 +389,18 @@ bool
 octave_base_sparse<T>::save_ascii (std::ostream& os)
 {
   dim_vector dv = this->dims ();
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   os << "# nnz: "      << nnz () << "\n";
-  os << "# rows: "     << dv (0) << "\n";
-  os << "# columns: "  << dv (1) << "\n";
+  os << "# rows: "     << dv(0) << "\n";
+  os << "# columns: "  << dv(1) << "\n";
 
   os << this->matrix;
 
   return true;
 }
 
 template <class T>
 bool
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -188,17 +188,17 @@ octave_bool_matrix::save_ascii (std::ost
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
-        os << " " << d (i);
+        os << " " << d(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -426,17 +426,17 @@ octave_bool_matrix::save_hdf5 (octave_hd
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   boolNDArray m = bool_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
-    hdims[i] = dv (rank-i-1);
+    hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -762,17 +762,17 @@ bool
 octave_cell::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
-        os << " " << d (i);
+        os << " " << d(i);
       os << "\n";
 
       Cell tmp = cell_value ();
 
       for (octave_idx_type i = 0; i < d.numel (); i++)
         {
           octave_value o_val = tmp.elem (i);
 
@@ -1465,17 +1465,17 @@ c(2,1,:)(:)\n\
 
           octave_idx_type num_fields = m.nfields ();
 
           // The resulting dim_vector should have dimensions:
           // [numel(fields) size(struct)]
           // except if the struct is a column vector.
 
           dim_vector result_dv;
-          if (m_dv (m_dv.length () - 1) == 1)
+          if (m_dv(m_dv.length () - 1) == 1)
             result_dv.resize (m_dv.length ());
           else
             result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
 
           result_dv(0) = num_fields;
 
           for (int i = 1; i < result_dv.length (); i++)
             result_dv(i) = m_dv(i-1);
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -332,17 +332,17 @@ octave_complex_matrix::save_ascii (std::
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       ComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
-        os << " " << d (i);
+        os << " " << d(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -579,17 +579,17 @@ octave_complex_matrix::save_hdf5 (octave
   space_hid = data_hid = type_hid = -1;
   bool retval = true;
   ComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
-    hdims[i] = dv (rank-i-1);
+    hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -306,17 +306,17 @@ octave_float_complex_matrix::save_ascii 
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       FloatComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
-        os << " " << d (i);
+        os << " " << d(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -541,17 +541,17 @@ octave_float_complex_matrix::save_hdf5 (
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
   FloatComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
-    hdims[i] = dv (rank-i-1);
+    hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -333,17 +333,17 @@ octave_float_matrix::save_ascii (std::os
 
   if (d.length () > 2)
     {
       FloatNDArray tmp = float_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i=0; i < d.length (); i++)
-        os << " " << d (i);
+        os << " " << d(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -568,17 +568,17 @@ octave_float_matrix::save_hdf5 (octave_h
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   FloatNDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
-    hdims[i] = dv (rank-i-1);
+    hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -101,31 +101,31 @@ octave_lazy_index::squeeze (void) const
 }
 
 octave_value
 octave_lazy_index::sort (octave_idx_type dim, sortmode mode) const
 {
   const dim_vector odims = index.orig_dimensions ();
   // index_vector can employ a more efficient sorting algorithm.
   if (mode == ASCENDING && odims.length () == 2
-      && (dim >= 0 && dim <= 1) && odims (1-dim) == 1)
+      && (dim >= 0 && dim <= 1) && odims(1-dim) == 1)
     return index_vector ().sorted ();
   else
     return idx_vector (index.as_array ().sort (dim, mode),
                        index.extent (0));
 }
 
 octave_value
 octave_lazy_index::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                          sortmode mode) const
 {
   const dim_vector odims = index.orig_dimensions ();
   // index_vector can employ a more efficient sorting algorithm.
   if (mode == ASCENDING && odims.length () == 2
-      && (dim >= 0 && dim <= 1) && odims (1-dim) == 1)
+      && (dim >= 0 && dim <= 1) && odims(1-dim) == 1)
     return index_vector ().sorted (sidx);
   else
     return idx_vector (index.as_array ().sort (sidx, dim, mode),
                        index.extent (0));
 }
 
 sortmode
 octave_lazy_index::is_sorted (sortmode mode) const
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -435,17 +435,17 @@ octave_matrix::save_ascii (std::ostream&
 
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i=0; i < d.length (); i++)
-        os << " " << d (i);
+        os << " " << d(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -680,17 +680,17 @@ octave_matrix::save_hdf5 (octave_hdf5_id
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   NDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
-    hdims[i] = dv (rank-i-1);
+    hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -287,17 +287,17 @@ bool
 octave_char_matrix_str::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       charNDArray tmp = char_array_value ();
       os << "# ndims: " << d.length () << "\n";
       for (int i=0; i < d.length (); i++)
-        os << " " << d (i);
+        os << " " << d(i);
       os << "\n";
       os.write (tmp.fortran_vec (), d.numel ());
       os << "\n";
     }
   else
     {
       // Keep this case, rather than use generic code above for
       // backward compatiability. Makes load_ascii much more complex!!
@@ -587,17 +587,17 @@ octave_char_matrix_str::save_hdf5 (octav
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   charNDArray m = char_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
-    hdims[i] = dv (rank-i-1);
+    hdims[i] = dv(rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0)
     return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -730,33 +730,33 @@ octave_struct::print_name_tag (std::ostr
     }
 
   return retval;
 }
 
 static bool
 scalar (const dim_vector& dims)
 {
-  return dims.length () == 2 && dims (0) == 1 && dims (1) == 1;
+  return dims.length () == 2 && dims(0) == 1 && dims(1) == 1;
 }
 
 
 bool
 octave_struct::save_ascii (std::ostream& os)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
   const dim_vector dv = dims ();
 
   os << "# ndims: " << dv.length () << "\n";
 
   for (int i = 0; i < dv.length (); i++)
-    os << " " << dv (i);
+    os << " " << dv(i);
   os << "\n";
 
   os << "# length: " << nf << "\n";
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
   string_vector keys = m.fieldnames ();
 
@@ -1456,17 +1456,17 @@ octave_scalar_struct::save_ascii (std::o
 
   octave_idx_type nf = m.nfields ();
 
   const dim_vector dv = dims ();
 
   os << "# ndims: " << dv.length () << "\n";
 
   for (int i = 0; i < dv.length (); i++)
-    os << " " << dv (i);
+    os << " " << dv(i);
   os << "\n";
 
   os << "# length: " << nf << "\n";
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
   string_vector keys = m.fieldnames ();
 
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -84,32 +84,32 @@ get_scalar_idx (Array<octave_idx_type>& 
   int n = idx.length ();
 
   if (n > 0)
     {
       retval = idx(--n);
 
       while (--n >= 0)
         {
-          retval *= dims (n);
+          retval *= dims(n);
 
           retval += idx(n);
         }
     }
   return retval;
 }
 
 octave_idx_type
 num_ones (const Array<octave_idx_type>& ra_idx)
 {
   octave_idx_type retval = 0;
 
   for (octave_idx_type i = 0; i < ra_idx.length (); i++)
     {
-      if (ra_idx (i) == 1)
+      if (ra_idx(i) == 1)
         retval++;
     }
 
   return retval;
 }
 
 bool
 is_scalar (const dim_vector& dim)
@@ -121,17 +121,17 @@ is_scalar (const dim_vector& dim)
   if (n == 0)
     {
       retval = false;
     }
   else
     {
       for (int i = 0; i < n; i ++)
         {
-          if (dim (i) != 1)
+          if (dim(i) != 1)
             {
               retval = false;
 
               break;
             }
         }
     }
   return retval;
@@ -143,17 +143,17 @@ is_vector (const dim_vector& dim)
   int m = 0;
   int n = dim.length ();
 
   if (n == 0)
     m = 2;
   else
     {
       for (int i = 0; i < n; i ++)
-        if (dim (i) > 1)
+        if (dim(i) > 1)
           m++;
         else if (dim(i) < 1)
           m += 2;
     }
 
   return (m < 2);
 }
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -1110,17 +1110,17 @@ Array<T>::index (const Array<idx_vector>
                  bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       int ial = ia.length ();
       dim_vector dv = dimensions.redim (ial);
       dim_vector dvx = dim_vector::alloc (ial);
-      for (int i = 0; i < ial; i++) dvx(i) = ia(i).extent (dv (i));
+      for (int i = 0; i < ial; i++) dvx(i) = ia(i).extent (dv(i));
       if (! (dvx == dv))
         {
           bool all_scalars = true;
           for (int i = 0; i < ial; i++)
             all_scalars = all_scalars && ia(i).is_scalar ();
           if (all_scalars)
             return Array<T> (dim_vector (1, 1), rfv);
           else
@@ -1434,17 +1434,17 @@ Array<T>::delete_elements (int dim, cons
 {
   if (dim < 0 || dim >= ndims ())
     {
       (*current_liboctave_error_handler)
         ("invalid dimension in delete_elements");
       return;
     }
 
-  octave_idx_type n = dimensions (dim);
+  octave_idx_type n = dimensions(dim);
   if (i.is_colon ())
     {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
       if (i.extent (n) != n)
         gripe_del_index_out_of_range (false, i.extent (n), n);
@@ -1589,17 +1589,17 @@ Array<T>::insert (const Array<T>& a, oct
 template <class T>
 Array<T>&
 Array<T>::insert (const Array<T>& a, const Array<octave_idx_type>& ra_idx)
 {
   octave_idx_type n = ra_idx.length ();
   Array<idx_vector> idx (dim_vector (n, 1));
   const dim_vector dva = a.dims ().redim (n);
   for (octave_idx_type k = 0; k < n; k++)
-    idx(k) = idx_vector (ra_idx (k), ra_idx (k) + dva(k));
+    idx(k) = idx_vector (ra_idx(k), ra_idx(k) + dva(k));
 
   assign (idx, a);
 
   return *this;
 }
 
 
 template <class T>
@@ -2528,18 +2528,18 @@ Array<T>::diag (octave_idx_type k) const
   dim_vector dv = dims ();
   octave_idx_type nd = dv.length ();
   Array<T> d;
 
   if (nd > 2)
     (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");
   else
     {
-      octave_idx_type nnr = dv (0);
-      octave_idx_type nnc = dv (1);
+      octave_idx_type nnr = dv(0);
+      octave_idx_type nnc = dv(1);
 
       if (nnr == 0 && nnc == 0)
         ; // do nothing for empty matrix
       else if (nnr != 1 && nnc != 1)
         {
           // Extract diag from matrix
           if (k > 0)
             nnc -= k;
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1315,31 +1315,31 @@ ComplexMatrix::ifourier (void) const
   octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   ComplexMatrix retval (rows (), cols ());
   const Complex *in (data ());
   Complex *out (retval.fortran_vec ());
 
   octave_fftw::fftNd (in, out, 2, dv);
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   ComplexMatrix retval (rows (), cols ());
   const Complex *in (data ());
   Complex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (in, out, 2, dv);
 
   return retval;
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -64,19 +64,19 @@ ComplexNDArray::fourier (int dim) const
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
@@ -95,19 +95,19 @@ ComplexNDArray::ifourier (int dim) const
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
@@ -119,17 +119,17 @@ ComplexNDArray::ifourier (int dim) const
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
@@ -139,17 +139,17 @@ ComplexNDArray::fourier2d (void) const
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (in + i*dist, out + i*dist, 2, dv2);
@@ -760,37 +760,37 @@ ComplexNDArray::insert (const NDArray& a
     {
       Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
 
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
 
       for (int i = 0; i < n; i++)
         {
-          if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
+          if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dimensions(i))
             {
               (*current_liboctave_error_handler)
                 ("Array<T>::insert: range error for insert");
               return *this;
             }
         }
 
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
 
       octave_idx_type n_elt = a.numel ();
 
-      // IS make_unique () NECCESSARY HERE??
+      // IS make_unique () NECESSARY HERE?
 
       for (octave_idx_type i = 0; i < n_elt; i++)
         {
           Array<octave_idx_type> ra_idx = a_ra_idx;
 
-          ra_idx.elem (0) = a_ra_idx (0) + r;
-          ra_idx.elem (1) = a_ra_idx (1) + c;
+          ra_idx.elem (0) = a_ra_idx(0) + r;
+          ra_idx.elem (1) = a_ra_idx(1) + c;
 
           elem (ra_idx) = a.elem (a_ra_idx);
 
           increment_index (a_ra_idx, a_dv);
         }
     }
   else
     (*current_liboctave_error_handler)
diff --git a/liboctave/array/MArray.cc b/liboctave/array/MArray.cc
--- a/liboctave/array/MArray.cc
+++ b/liboctave/array/MArray.cc
@@ -148,17 +148,17 @@ void MArray<T>::idx_add_nd (const idx_ve
     dim = vals.dims ().first_non_singleton ();
   else if (dim > nd)
     nd = dim;
 
   // Check dimensions.
   dim_vector ddv = Array<T>::dims ().redim (nd);
   dim_vector sdv = vals.dims ().redim (nd);
 
-  octave_idx_type ext = idx.extent (ddv (dim));
+  octave_idx_type ext = idx.extent (ddv(dim));
 
   if (ext > ddv(dim))
     {
       ddv(dim) = ext;
       Array<T>::resize (ddv);
       ext = ddv(dim);
     }
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -234,30 +234,30 @@ Sparse<T>::Sparse (const dim_vector& dv)
 template <class T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
 
   // Work in unsigned long long to avoid overflow issues with numel
   unsigned long long a_nel = static_cast<unsigned long long>(a.rows ()) *
                              static_cast<unsigned long long>(a.cols ());
-  unsigned long long dv_nel = static_cast<unsigned long long>(dv (0)) *
-                              static_cast<unsigned long long>(dv (1));
+  unsigned long long dv_nel = static_cast<unsigned long long>(dv(0)) *
+                              static_cast<unsigned long long>(dv(1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
   else
     {
       dim_vector old_dims = a.dims ();
       octave_idx_type new_nzmx = a.nnz ();
-      octave_idx_type new_nr = dv (0);
-      octave_idx_type new_nc = dv (1);
-      octave_idx_type old_nr = old_dims (0);
-      octave_idx_type old_nc = old_dims (1);
+      octave_idx_type new_nr = dv(0);
+      octave_idx_type new_nc = dv(1);
+      octave_idx_type old_nr = old_dims(0);
+      octave_idx_type old_nc = old_dims(1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
       octave_idx_type kk = 0;
       xcidx (0) = 0;
       for (octave_idx_type i = 0; i < old_nc; i++)
         for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)
           {
@@ -1083,17 +1083,17 @@ Sparse<T>::insert (const Sparse<T>& a, c
 {
 
   if (ra_idx.length () != 2)
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
-  return insert (a, ra_idx (0), ra_idx (1));
+  return insert (a, ra_idx(0), ra_idx(1));
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -962,29 +962,29 @@ Matrix::ifourier (void) const
   octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   const double *in = fortran_vec ();
   ComplexMatrix retval (rows (), cols ());
   octave_fftw::fftNd (in, retval.fortran_vec (), 2, dv);
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   ComplexMatrix retval (*this);
   Complex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (out, out, 2, dv);
 
   return retval;
 }
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -105,19 +105,19 @@ NDArray::fourier (int dim) const
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const double *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
@@ -136,19 +136,19 @@ NDArray::ifourier (int dim) const
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   ComplexNDArray retval (*this);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (out + k * stride * n, out + k * stride * n,
@@ -159,17 +159,17 @@ NDArray::ifourier (int dim) const
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   const double *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
@@ -179,17 +179,17 @@ NDArray::fourier2d (void) const
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   ComplexNDArray retval (*this);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (out + i*dist, out + i*dist, 2, dv2);
 
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1322,31 +1322,31 @@ FloatComplexMatrix::ifourier (void) cons
   octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   FloatComplexMatrix retval (rows (), cols ());
   const FloatComplex *in (data ());
   FloatComplex *out (retval.fortran_vec ());
 
   octave_fftw::fftNd (in, out, 2, dv);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   FloatComplexMatrix retval (rows (), cols ());
   const FloatComplex *in (data ());
   FloatComplex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (in, out, 2, dv);
 
   return retval;
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -64,19 +64,19 @@ FloatComplexNDArray::fourier (int dim) c
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
@@ -95,19 +95,19 @@ FloatComplexNDArray::ifourier (int dim) 
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
@@ -119,17 +119,17 @@ FloatComplexNDArray::ifourier (int dim) 
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
@@ -139,17 +139,17 @@ FloatComplexNDArray::fourier2d (void) co
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (in + i*dist, out + i*dist, 2, dv2);
@@ -771,37 +771,37 @@ FloatComplexNDArray::insert (const NDArr
     {
       Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
 
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
 
       for (int i = 0; i < n; i++)
         {
-          if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
+          if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dimensions(i))
             {
               (*current_liboctave_error_handler)
                 ("Array<T>::insert: range error for insert");
               return *this;
             }
         }
 
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
 
       octave_idx_type n_elt = a.numel ();
 
-      // IS make_unique () NECCESSARY HERE??
+      // IS make_unique () NECESSARY HERE?
 
       for (octave_idx_type i = 0; i < n_elt; i++)
         {
           Array<octave_idx_type> ra_idx = a_ra_idx;
 
-          ra_idx.elem (0) = a_ra_idx (0) + r;
-          ra_idx.elem (1) = a_ra_idx (1) + c;
+          ra_idx.elem (0) = a_ra_idx(0) + r;
+          ra_idx.elem (1) = a_ra_idx(1) + c;
 
           elem (ra_idx) = a.elem (a_ra_idx);
 
           increment_index (a_ra_idx, a_dv);
         }
     }
   else
     (*current_liboctave_error_handler)
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -969,29 +969,29 @@ FloatMatrix::ifourier (void) const
   octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::fourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   const float *in = fortran_vec ();
   FloatComplexMatrix retval (rows (), cols ());
   octave_fftw::fftNd (in, retval.fortran_vec (), 2, dv);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier2d (void) const
 {
-  dim_vector dv(rows (), cols ());
+  dim_vector dv (rows (), cols ());
 
   FloatComplexMatrix retval (*this);
   FloatComplex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (out, out, 2, dv);
 
   return retval;
 }
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -63,19 +63,19 @@ FloatNDArray::fourier (int dim) const
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const float *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
@@ -94,19 +94,19 @@ FloatNDArray::ifourier (int dim) const
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
-  octave_idx_type howmany = numel () / dv (dim);
+  octave_idx_type howmany = numel () / dv(dim);
   howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
+  octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv(dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   FloatComplexNDArray retval (*this);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (out + k * stride * n, out + k * stride * n,
@@ -117,17 +117,17 @@ FloatNDArray::ifourier (int dim) const
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   const float *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
@@ -137,17 +137,17 @@ FloatNDArray::fourier2d (void) const
 
 FloatComplexNDArray
 FloatNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
-  dim_vector dv2(dv(0), dv(1));
+  dim_vector dv2 (dv(0), dv(1));
   FloatComplexNDArray retval (*this);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (out + i*dist, out + i*dist, 2, dv2);
 
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -1174,19 +1174,19 @@ get_extent_triplet (const dim_vector& di
   else
     {
       if (dim < 0)
         dim = dims.first_non_singleton ();
 
       // calculate extent triplet.
       l = 1, n = dims(dim), u = 1;
       for (octave_idx_type i = 0; i < dim; i++)
-        l *= dims (i);
+        l *= dims(i);
       for (octave_idx_type i = dim + 1; i < ndims; i++)
-        u *= dims (i);
+        u *= dims(i);
     }
 }
 
 // Appliers.
 // FIXME: is this the best design? C++ gives a lot of options here...
 // maybe it can be done without an explicit parameter?
 
 template <class R, class T>
@@ -1194,17 +1194,17 @@ inline Array<R>
 do_mx_red_op (const Array<T>& src, int dim,
               void (*mx_red_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   // M*b inconsistency: sum ([]) = 0 etc.
   if (dims.length () == 2 && dims(0) == 0 && dims(1) == 0)
-    dims (1) = 1;
+    dims(1) = 1;
 
   get_extent_triplet (dims, dim, l, n, u);
 
   // Reduction operation reduces the array size.
   if (dim < dims.length ()) dims(dim) = 1;
   dims.chop_trailing_singletons ();
 
   Array<R> ret (dims);
@@ -1322,17 +1322,17 @@ do_mx_diff_op (const Array<R>& src, int 
   dim_vector dims = src.dims ();
 
   get_extent_triplet (dims, dim, l, n, u);
   if (dim >= dims.length ())
     dims.resize (dim+1, 1);
 
   if (dims(dim) <= order)
     {
-      dims (dim) = 0;
+      dims(dim) = 0;
       return Array<R> (dims);
     }
   else
     {
       dims(dim) -= order;
     }
 
   Array<R> ret (dims);
