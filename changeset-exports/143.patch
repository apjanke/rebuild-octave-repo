# HG changeset patch
# User jwe
# Date 749702218 0
#      Mon Oct 04 02:36:58 1993 +0000
# Node ID 7849db4b6dbcc1e5934ce60e341146c932d609d7
# Parent  6906d6591452a1f3a8fbbfa6d64dbf674a2b58fc
[project @ 1993-10-04 02:36:45 by jwe]

diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -71,16 +71,139 @@ Matrix_bool_op
   Matrix_GE,
   Matrix_GT,
   Matrix_NE,
   Matrix_AND,
   Matrix_OR, 
 };
 
 /*
+ * Check row and column dimensions for binary matrix operations.
+ */
+static inline int
+m_add_conform (Matrix& a, Matrix& b, int warn)
+{
+  int ar = a.rows ();
+  int ac = a.columns ();
+  int br = b.rows ();
+  int bc = b.columns ();
+
+  int ok = (ar == br && ac == bc);
+
+  if (! ok && warn)
+    gripe_nonconformant (ar, ac, br, bc);
+
+  return ok;
+}
+
+static inline int
+m_add_conform (Matrix& a, ComplexMatrix& b, int warn)
+{
+  int ar = a.rows ();
+  int ac = a.columns ();
+  int br = b.rows ();
+  int bc = b.columns ();
+
+  int ok = (ar == br && ac == bc);
+
+  if (! ok && warn)
+    gripe_nonconformant (ar, ac, br, bc);
+
+  return ok;
+}
+
+static inline int
+m_add_conform (ComplexMatrix& a, Matrix& b, int warn)
+{
+  int ar = a.rows ();
+  int ac = a.columns ();
+  int br = b.rows ();
+  int bc = b.columns ();
+
+  int ok = (ar == br && ac == bc);
+
+  if (! ok && warn)
+    gripe_nonconformant (ar, ac, br, bc);
+
+  return ok;
+}
+
+static inline int
+m_add_conform (ComplexMatrix& a, ComplexMatrix& b, int warn)
+{
+  int ar = a.rows ();
+  int ac = a.columns ();
+  int br = b.rows ();
+  int bc = b.columns ();
+
+  int ok = (ar == br && ac == bc);
+
+  if (! ok && warn)
+    gripe_nonconformant (ar, ac, br, bc);
+
+  return ok;
+}
+
+static inline int
+m_mul_conform (Matrix& a, Matrix& b, int warn)
+{
+  int ac = a.columns ();
+  int br = b.rows ();
+
+  int ok = (ac == br);
+
+  if (! ok && warn)
+    gripe_nonconformant (a.rows (), ac, br, b.columns ());
+
+  return ok;
+}
+
+static inline int
+m_mul_conform (Matrix& a, ComplexMatrix& b, int warn)
+{
+  int ac = a.columns ();
+  int br = b.rows ();
+
+  int ok = (ac == br);
+
+  if (! ok && warn)
+    gripe_nonconformant (a.rows (), ac, br, b.columns ());
+
+  return ok;
+}
+
+static inline int
+m_mul_conform (ComplexMatrix& a, Matrix& b, int warn)
+{
+  int ac = a.columns ();
+  int br = b.rows ();
+
+  int ok = (ac == br);
+
+  if (! ok && warn)
+    gripe_nonconformant (a.rows (), ac, br, b.columns ());
+
+  return ok;
+}
+
+static inline int
+m_mul_conform (ComplexMatrix& a, ComplexMatrix& b, int warn)
+{
+  int ac = a.columns ();
+  int br = b.rows ();
+
+  int ok = (a.columns () == br);
+
+  if (! ok && warn)
+    gripe_nonconformant (a.rows (), ac, br, b.columns ());
+
+  return ok;
+}
+
+/*
  * Stupid binary comparison operations like the ones Matlab provides.
  * One for each type combination, in the order given here:
  *
  *       op2 \ op1:   s   m   cs   cm
  *            +--   +---+---+----+----+
  *   scalar   |     | * | 3 |  * |  9 |
  *                  +---+---+----+----+
  *   matrix         | 1 | 4 |  7 | 10 |
@@ -92,17 +215,19 @@ Matrix_bool_op
  */
 
 /* 1 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, double s, Matrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = s < a.elem (i,j);
 	    break;
@@ -127,26 +252,29 @@ mx_stupid_bool_op (Matrix_bool_op op, do
 	  case Matrix_OR:
 	    t.elem (i,j) = s || a.elem (i,j);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 2 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, double s, ComplexMatrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = s < real (a.elem (i,j));
 	    break;
@@ -171,26 +299,29 @@ mx_stupid_bool_op (Matrix_bool_op op, do
 	  case Matrix_OR:
 	    t.elem (i,j) = s || (a.elem (i,j) != 0.0);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 3 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, double s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = a.elem (i,j) < s;
 	    break;
@@ -215,26 +346,29 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 	  case Matrix_OR:
 	    t.elem (i,j) = a.elem (i,j) || s;
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 4 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, Complex& s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = a.elem (i,j) < real (s);
 	    break;
@@ -259,32 +393,30 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 	  case Matrix_OR:
 	    t.elem (i,j) = a.elem (i,j) || (s != 0.0);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 5 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, Matrix& b)
 {
+  if (! m_add_conform (a, b, 1))
+    return Matrix ();
+     
   int ar = a.rows ();
   int ac = a.columns ();
 
-  if (ar != b.rows () || ac != b.columns ())
-    {
-      gripe_nonconformant ();
-      jump_to_top_level ();
-    }
-     
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
@@ -311,32 +443,30 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 	  case Matrix_OR:
 	    c.elem (i, j) = a.elem (i, j) || b.elem (i, j);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
+
   return c;
 }
 
 /* 6 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, Matrix& a, ComplexMatrix& b)
 {
+  if (! m_add_conform (a, b, 1))
+    return Matrix ();
+     
   int ar = a.rows ();
   int ac = a.columns ();
 
-  if (ar != b.rows () || ac != b.columns ())
-    {
-      gripe_nonconformant ();
-      jump_to_top_level ();
-    }
-     
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
@@ -372,17 +502,19 @@ mx_stupid_bool_op (Matrix_bool_op op, Ma
 }
 
 /* 7 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, Complex& s, Matrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (s) < a.elem (i,j);
 	    break;
@@ -407,26 +539,29 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	  case Matrix_OR:
 	    t.elem (i,j) = (s != 0.0) || a.elem (i,j);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 8 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, Complex& s, ComplexMatrix& a)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (s) < real (a.elem (i,j));
 	    break;
@@ -451,26 +586,29 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	  case Matrix_OR:
 	    t.elem (i,j) = (s != 0.0) || (a.elem (i,j) != 0.0);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 9 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, double s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (a.elem (i,j)) < s;
 	    break;
@@ -495,26 +633,29 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	  case Matrix_OR:
 	    t.elem (i,j) = (a.elem (i,j) != 0.0) || s;
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 10 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, Complex& s)
 {
   int ar = a.rows ();
   int ac = a.columns ();
+
   Matrix t (ar, ac);
+
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
 	    t.elem (i,j) = real (a.elem (i,j)) < real (s);
 	    break;
@@ -539,32 +680,30 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	  case Matrix_OR:
 	    t.elem (i,j) = (a.elem (i,j) != 0.0) || (s != 0.0);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	}
     }
+
   return t;
 }
 
 /* 11 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, Matrix& b)
 {
+  if (! m_add_conform (a, b, 1))
+    return Matrix ();
+     
   int ar = a.rows ();
   int ac = a.columns ();
 
-  if (ar != b.rows () || ac != b.columns ())
-    {
-      gripe_nonconformant ();
-      jump_to_top_level ();
-    }
-     
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
@@ -598,25 +737,22 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
       }
   return c;
 }
 
 /* 12 */
 static Matrix
 mx_stupid_bool_op (Matrix_bool_op op, ComplexMatrix& a, ComplexMatrix& b)
 {
+  if (! m_add_conform (a, b, 1))
+    return Matrix ();
+     
   int ar = a.rows ();
   int ac = a.columns ();
 
-  if (ar != b.rows () || ac != b.columns ())
-    {
-      gripe_nonconformant ();
-      jump_to_top_level ();
-    }
-     
   Matrix c (ar, ac);
 
   for (int j = 0; j < ac; j++)
     for (int i = 0; i < ar; i++)
       {
 	switch (op)
 	  {
 	  case Matrix_LT:
@@ -643,108 +779,35 @@ mx_stupid_bool_op (Matrix_bool_op op, Co
 	  case Matrix_OR:
 	    c.elem (i, j) = (a.elem (i, j) != 0.0) || (b.elem (i, j) != 0.0);
 	    break;
 	  default:
 	    panic_impossible ();
 	    break;
 	  }
       }
+
   return c;
 }
 
 /*
- * Check row and column dimensions for binary matrix operations.
- */
-static inline int
-m_add_conform (Matrix& m1, Matrix& m2, int warn)
-{
-  int ok = (m1.rows () == m2.rows () && m1.columns () == m2.columns ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-static inline int
-m_add_conform (Matrix& m1, ComplexMatrix& m2, int warn)
-{
-  int ok = (m1.rows () == m2.rows () && m1.columns () == m2.columns ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-static inline int
-m_add_conform (ComplexMatrix& m1, Matrix& m2, int warn)
-{
-  int ok = (m1.rows () == m2.rows () && m1.columns () == m2.columns ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-static inline int
-m_add_conform (ComplexMatrix& m1, ComplexMatrix& m2, int warn)
-{
-  int ok = (m1.rows () == m2.rows () && m1.columns () == m2.columns ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-static inline int
-m_mul_conform (Matrix& m1, Matrix& m2, int warn)
-{
-  int ok = (m1.columns () == m2.rows ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-static inline int
-m_mul_conform (Matrix& m1, ComplexMatrix& m2, int warn)
-{
-  int ok = (m1.columns () == m2.rows ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-static inline int
-m_mul_conform (ComplexMatrix& m1, Matrix& m2, int warn)
-{
-  int ok = (m1.columns () == m2.rows ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-static inline int
-m_mul_conform (ComplexMatrix& m1, ComplexMatrix& m2, int warn)
-{
-  int ok = (m1.columns () == m2.rows ());
-  if (!ok && warn)
-    gripe_nonconformant ();
-  return ok;
-}
-
-/*
  * Unary operations.  One for each numeric data type:
  *
  *   scalar
  *   complex_scalar
  *   matrix
  *   complex_matrix
  *
  */
 
 tree_constant
 do_unary_op (double d, tree::expression_type t)
 {
   double result = 0.0;
+
   switch (t)
     {
     case tree::not:
       result = (! d);
       break;
     case tree::uminus:
       result = -d;
       break;
@@ -759,16 +822,17 @@ do_unary_op (double d, tree::expression_
 
   return tree_constant (result);
 }
 
 tree_constant
 do_unary_op (Matrix& a, tree::expression_type t)
 {
   Matrix result;
+
   switch (t)
     {
     case tree::not:
       result = (! a);
       break;
     case tree::uminus:
       result = -a;
       break;
@@ -783,16 +847,17 @@ do_unary_op (Matrix& a, tree::expression
 
   return tree_constant (result);
 }
 
 tree_constant
 do_unary_op (Complex& c, tree::expression_type t)
 {
   Complex result = 0.0;
+
   switch (t)
     {
     case tree::not:
       result = (c == 0.0);
       break;
     case tree::uminus:
       result = -c;
       break;
@@ -809,16 +874,17 @@ do_unary_op (Complex& c, tree::expressio
 
   return tree_constant (result);
 }
 
 tree_constant
 do_unary_op (ComplexMatrix& a, tree::expression_type t)
 {
   ComplexMatrix result;
+
   switch (t)
     {
     case tree::not:
       result = (! a);
       break;
     case tree::uminus:
       result = -a;
       break;
@@ -852,16 +918,17 @@ do_unary_op (ComplexMatrix& a, tree::exp
  *                  +---+---+----+----+
  */
 
 /* 1 */
 tree_constant
 do_binary_op (double a, double b, tree::expression_type t)
 {
   double result = 0.0;
+
   switch (t)
     {
     case tree::add:
       result = a + b;
       break;
     case tree::subtract:
       result = a - b;
       break;
@@ -909,24 +976,28 @@ do_binary_op (double a, double b, tree::
     case tree::or:
       result = (a || b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   return tree_constant (result);
 }
 
 /* 2 */
 tree_constant
 do_binary_op (double a, Matrix& b, tree::expression_type t)
 {
   Matrix result;
+
   switch (t)
     {
     case tree::add:
       result = a + b;
       break;
     case tree::subtract:
       result = a - b;
       break;
@@ -939,18 +1010,17 @@ do_binary_op (double a, Matrix& b, tree:
     case tree::multiply:
     case tree::el_mul:
       result = a * b;
       break;
     case tree::el_div:
       return x_el_div (a, b);
       break;
     case tree::divide:
-      error ("nonconformant right division");
-      return tree_constant ();
+      gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -977,28 +1047,32 @@ do_binary_op (double a, Matrix& b, tree:
     case tree::or:
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   return tree_constant (result);
 }
 
 /* 3 */
 tree_constant
 do_binary_op (double a, Complex& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1059,32 +1133,37 @@ do_binary_op (double a, Complex& b, tree
       result_type = RT_real;
       result = (a || (b != 0.0));
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 4 */
 tree_constant
 do_binary_op (double a, ComplexMatrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1100,18 +1179,17 @@ do_binary_op (double a, ComplexMatrix& b
     case tree::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
     case tree::el_div:
       return x_el_div (a, b);
       break;
     case tree::divide:
-      error ("nonconformant right division");
-      return tree_constant ();
+      gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -1146,28 +1224,33 @@ do_binary_op (double a, ComplexMatrix& b
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 5 */
 tree_constant
 do_binary_op (Matrix& a, double b, tree::expression_type t)
 {
   Matrix result;
+
   switch (t)
     {
     case tree::add:
       result = a + b;
       break;
     case tree::subtract:
       result = a - b;
       break;
@@ -1178,18 +1261,17 @@ do_binary_op (Matrix& a, double b, tree:
     case tree::divide:
     case tree::el_div:
       result = a / b;
       break;
     case tree::el_leftdiv:
       return x_el_div (b, a);
       break;
     case tree::leftdiv:
-      error ("nonconformant left division");
-      return tree_constant ();
+      gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -1216,149 +1298,120 @@ do_binary_op (Matrix& a, double b, tree:
     case tree::or:
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   return tree_constant (result);
 }
 
 /* 6 */
 tree_constant
 do_binary_op (Matrix& a, Matrix& b, tree::expression_type t)
 {
   Matrix result;
 
-  int error_cond = 0;
-
   switch (t)
     {
     case tree::add:
       if (m_add_conform (a, b, 1))
 	result = a + b;
-      else
-	error_cond = 1;
       break;
     case tree::subtract:
       if (m_add_conform (a, b, 1))
 	result = a - b;
-      else
-	error_cond = 1;
       break;
     case tree::el_mul:
       if (m_add_conform (a, b, 1))
 	result = a.product (b);
-      else
-	error_cond = 1;
       break;
     case tree::multiply:
       if (m_mul_conform (a, b, 1))
 	result = a * b;
-      else
-	error_cond = 1;
       break;
     case tree::el_div:
       if (m_add_conform (a, b, 1))
 	result = a.quotient (b);
-      else
-	error_cond = 1;
       break;
     case tree::el_leftdiv:
       if (m_add_conform (a, b, 1))
 	result = b.quotient (a);
-      else
-	error_cond = 1;
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
       error ("can't do A ^ B for A and B both matrices");
-      error_cond = 1;
       break;
     case tree::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
-      else
-	error_cond = 1;
       break;
     case tree::cmp_lt:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
-      else
-	error_cond = 1;
       break;
     case tree::cmp_le:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
-      else
-	error_cond = 1;
       break;
     case tree::cmp_eq:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
-      else
-	error_cond = 1;
       break;
     case tree::cmp_ge:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
-      else
-	error_cond = 1;
       break;
     case tree::cmp_gt:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
-      else
-	error_cond = 1;
       break;
     case tree::cmp_ne:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
-      else
-	error_cond = 1;
       break;
     case tree::and:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
-      else
-	error_cond = 1;
       break;
     case tree::or:
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
-      else
-	error_cond = 1;
       break;
     default:
       panic_impossible ();
       break;
     }
 
-  if (error_cond)
+  if (error_state)
     return tree_constant ();
-  else
-    return tree_constant (result);
+
+  return tree_constant (result);
 }
 
 /* 7 */
 tree_constant
 do_binary_op (Matrix& a, Complex& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1373,18 +1426,17 @@ do_binary_op (Matrix& a, Complex& b, tre
     case tree::el_div:
       result_type = RT_complex;
       complex_result = a / b;
       break;
     case tree::el_leftdiv:
       return x_el_div (b, a);
       break;
     case tree::leftdiv:
-      error ("nonconformant left division");
-      return tree_constant ();
+      gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -1419,169 +1471,148 @@ do_binary_op (Matrix& a, Complex& b, tre
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 8 */
 tree_constant
 do_binary_op (Matrix& a, ComplexMatrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a + b;
-      else
-	return tree_constant ();
       break;
     case tree::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
-      else
-	return tree_constant ();
       break;
     case tree::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a.product (b);
-      else
-	return tree_constant ();
       break;
     case tree::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
-      else
-	return tree_constant ();
       break;
     case tree::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a.quotient (b);
-      else
-	return tree_constant ();
       break;
     case tree::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = b.quotient (a);
-      else
-	return tree_constant ();
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
       error ("can't do A ^ B for A and B both matrices");
-      return tree_constant ();
       break;
     case tree::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_lt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_le:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_eq:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_ge:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_gt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_ne:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::and:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::or:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
-      else
-	return tree_constant ();
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 9 */
 tree_constant
 do_binary_op (Complex& a, double b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1642,32 +1673,37 @@ do_binary_op (Complex& a, double b, tree
       result_type = RT_real;
       result = ((a != 0.0) || b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 10 */
 tree_constant
 do_binary_op (Complex& a, Matrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1683,18 +1719,17 @@ do_binary_op (Complex& a, Matrix& b, tre
     case tree::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
     case tree::el_div:
       return x_el_div (a, b);
       break;
     case tree::divide:
-      error ("nonconformant right division");
-      return tree_constant ();
+      gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -1729,32 +1764,37 @@ do_binary_op (Complex& a, Matrix& b, tre
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 11 */
 tree_constant
 do_binary_op (Complex& a, Complex& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   double result = 0.0;
   Complex complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1815,32 +1855,37 @@ do_binary_op (Complex& a, Complex& b, tr
       result_type = RT_real;
       result = ((a != 0.0) || (b != 0.0));
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 12 */
 tree_constant
 do_binary_op (Complex& a, ComplexMatrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1856,18 +1901,17 @@ do_binary_op (Complex& a, ComplexMatrix&
     case tree::el_mul:
       result_type = RT_complex;
       complex_result = a * b;
       break;
     case tree::el_div:
       return x_el_div (a, b);
       break;
     case tree::divide:
-      error ("nonconformant right division");
-      return tree_constant ();
+      gripe_nonconformant (1, 1, b.rows (), b.columns ());
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -1902,32 +1946,37 @@ do_binary_op (Complex& a, ComplexMatrix&
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 13 */
 tree_constant
 do_binary_op (ComplexMatrix& a, double b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -1942,18 +1991,17 @@ do_binary_op (ComplexMatrix& a, double b
     case tree::el_div:
       result_type = RT_complex;
       complex_result = a / b;
       break;
     case tree::el_leftdiv:
       return x_el_div (b, a);
       break;
     case tree::leftdiv:
-      error ("nonconformant left division");
-      return tree_constant ();
+      gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -1988,169 +2036,148 @@ do_binary_op (ComplexMatrix& a, double b
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 14 */
 tree_constant
 do_binary_op (ComplexMatrix& a, Matrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a + b;
-      else
-	return tree_constant ();
       break;
     case tree::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
-      else
-	return tree_constant ();
       break;
     case tree::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a.product (b);
-      else
-	return tree_constant ();
       break;
     case tree::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
-      else
-	return tree_constant ();
       break;
     case tree::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a.quotient (b);
-      else
-	return tree_constant ();
       break;
     case tree::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a.quotient (b);
-      else
-	return tree_constant ();
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
       error ("can't do A ^ B for A and B both matrices");
-      return tree_constant ();
       break;
     case tree::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_lt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_le:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_eq:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_ge:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_gt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_ne:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::and:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::or:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
-      else
-	return tree_constant ();
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 15 */
 tree_constant
 do_binary_op (ComplexMatrix& a, Complex& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       complex_result = a + b;
       break;
     case tree::subtract:
       result_type = RT_complex;
@@ -2165,18 +2192,17 @@ do_binary_op (ComplexMatrix& a, Complex&
     case tree::el_div:
       result_type = RT_complex;
       complex_result = a / b;
       break;
     case tree::el_leftdiv:
       return x_el_div (b, a);
       break;
     case tree::leftdiv:
-      error ("nonconformant left division");
-      return tree_constant ();
+      gripe_nonconformant (a.rows (), a.columns (), 1, 1);
       break;
     case tree::power:
       return xpow (a, b);
       break;
     case tree::elem_pow:
       return elem_xpow (a, b);
       break;
     case tree::cmp_lt:
@@ -2211,154 +2237,132 @@ do_binary_op (ComplexMatrix& a, Complex&
       result_type = RT_real;
       result = mx_stupid_bool_op (Matrix_OR, a, b);
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /* 16 */
 tree_constant
 do_binary_op (ComplexMatrix& a, ComplexMatrix& b, tree::expression_type t)
 {
   enum RT { RT_unknown, RT_real, RT_complex };
   RT result_type = RT_unknown;
 
   Matrix result;
   ComplexMatrix complex_result;
+
   switch (t)
     {
     case tree::add:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a + b;
-      else
-	return tree_constant ();
       break;
     case tree::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
-      else
-	return tree_constant ();
       break;
     case tree::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a.product (b);
-      else
-	return tree_constant ();
       break;
     case tree::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
-      else
-	return tree_constant ();
       break;
     case tree::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a.quotient (b);
-      else
-	return tree_constant ();
       break;
     case tree::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = b.quotient (a);
-      else
-	return tree_constant ();
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
       error ("can't do A ^ B for A and B both matrices");
-      return tree_constant ();
       break;
     case tree::elem_pow:
       if (m_add_conform (a, b, 1))
 	return elem_xpow (a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_lt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LT, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_le:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_LE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_eq:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_EQ, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_ge:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_gt:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_GT, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::cmp_ne:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_NE, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::and:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_AND, a, b);
-      else
-	return tree_constant ();
       break;
     case tree::or:
       result_type = RT_real;
       if (m_add_conform (a, b, 1))
 	result = mx_stupid_bool_op (Matrix_OR, a, b);
-      else
-	return tree_constant ();
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  if (error_state)
+    return tree_constant ();
+
   assert (result_type != RT_unknown);
+
   if (result_type == RT_real)
     return tree_constant (result);
   else
     return tree_constant (complex_result);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -26,16 +26,19 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 
 #include "error.h"
 
+// Current error state.
+int error_state;
+
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
   if (name != (char *) NULL)
     fprintf (stderr, "%s: ", name);
 
   vfprintf (stderr, fmt, args);
   fprintf (stderr, "\n");
@@ -67,16 +70,19 @@ warning (const char *fmt, ...)
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
 
 void
 error (const char *fmt, ...)
 {
+  if (! error_state)
+    error_state = 1;
+
   va_list args;
   va_start (args, fmt);
   verror ("error", fmt, args);
   va_end (args);
 }
 
 void volatile
 panic (const char *fmt, ...)
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -33,16 +33,19 @@ Software Foundation, 675 Mass Ave, Cambr
 	 __FILE__, __LINE__)
 
 extern void message (const char *name, const char *fmt, ...);
 extern void usage (const char *fmt, ...);
 extern void warning (const char *fmt, ...);
 extern void error (const char *fmt, ...);
 extern void volatile panic (const char *fmt, ...);
 
+// Current error state.
+extern int error_state;
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -42,16 +42,23 @@ gripe_range_invalid (void)
 
 void
 gripe_nonconformant (void)
 {
   error ("nonconformant matrices");
 }
 
 void
+gripe_nonconformant (int r1, int c1, int r2, int c2)
+{
+  error ("nonconformant matrices (op1 is %dx%d, op2 is %dx%d)",
+	 r1, c1, r2, c2);
+}
+
+void
 gripe_empty_arg (const char *name, int is_error)
 {
   if (is_error)
     error ("%s: empty matrix is invalid as an argument", name);
   else
     warning ("%s: argument is empty matrix", name);
 }
 
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -26,16 +26,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
 extern void gripe_string_invalid (void);
 extern void gripe_range_invalid (void);
 extern void gripe_nonconformant (void);
+extern void gripe_nonconformant (int r1, int c1, int r2, int c2);
 extern void gripe_empty_arg (const char *name, int is_error);
 extern void gripe_square_matrix_required (const char *name);
 extern void gripe_user_supplied_eval (const char *name);
 extern void gripe_user_returned_invalid (const char *name);
 
 #endif
 
 /*
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -19,16 +19,64 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_lex_h)
 #define _lex_h 1
 
+// Arrange to get input via readline.
+
+#ifdef YY_INPUT
+#undef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+  if ((result = octave_read (buf, max_size)) < 0) \
+    YY_FATAL_ERROR ("octave_read () in flex scanner failed");
+#endif
+
+// Try to avoid crashing out completely on fatal scanner errors.
+
+#ifdef YY_FATAL_ERROR
+#undef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) \
+  do \
+    { \
+      error (msg); \
+      jump_to_top_level (); \
+    } \
+  while (0)
+#endif
+
+#define DO_COMMA_INSERT_CHECK yyless (do_comma_insert_check ())
+
+#define TOK_RETURN(tok) \
+  do \
+    { \
+      current_input_column += yyleng; \
+      quote_is_transpose = 0; \
+      cant_be_identifier = 0; \
+      convert_spaces_to_comma = 1; \
+      return (tok); \
+    } \
+  while (0)
+
+#define BIN_OP_RETURN(tok,convert) \
+  do \
+    { \
+      yylval.tok_val = new token (input_line_number, current_input_column); \
+      token_stack.push (yylval.tok_val); \
+      current_input_column += yyleng; \
+      quote_is_transpose = 0; \
+      cant_be_identifier = 0; \
+      convert_spaces_to_comma = convert; \
+      return (tok); \
+    } \
+  while (0)
+
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
 
 // Associate a buffer with a new file to read.
 extern YY_BUFFER_STATE create_buffer (FILE *f);
 
 // Report the current buffer.
 extern YY_BUFFER_STATE current_buffer (void);
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -25,62 +25,29 @@ Software Foundation, 675 Mass Ave, Cambr
 %x HELP_FCN
 %s TEXT_FCN
 %s DQSTRING
 %s STRING
 %s MATRIX
 
 %{
 
-// Arrange to get input via readline.
-
-#ifdef YY_INPUT
-#undef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-  if ((result = octave_read (buf, max_size)) < 0) \
-    YY_FATAL_ERROR ("octave_read () in flex scanner failed");
-#endif
-
-// Try to avoid crashing out completely on fatal scanner errors.
-
-#ifdef YY_FATAL_ERROR
-#undef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) \
-  do \
-    { \
-      error (msg); \
-      jump_to_top_level (); \
-    } \
-  while (0)
-#endif
-
 #include "input.h"
-
-// The type of an END token.  This declaration is repeated in parse.y.
-// It must appear before y.tab.h is included.
-enum end_tok_type
-  {
-    simple_end,
-    for_end,
-    function_end,
-    if_end,
-    while_end,
-  };
-
-// The type of a PLOT token.  This declaration is repeated in parse.y.
-// It must appear before y.tab.h is included.
-enum plot_tok_type
-  {
-    two_dee = 2,
-    three_dee = 3,
-  };
+#include "token.h"
 
 #include "SLStack.h"
 
+// Stack to hold tokens so that we can delete them when the parser is
+// reset and avoid growing forever just because we are stashing some
+// information.  This has to appear before lex.h is included, because
+// one of the macros defined there uses token_stack.
+static SLStack <token*> token_stack;
+
 #include "variables.h"
+#include "octave.h"
 #include "symtab.h"
 #include "error.h"
 #include "utils.h"
 #include "tree.h"
 #include "y.tab.h"
 #include "parse.h"
 #include "lex.h"
 
@@ -123,40 +90,16 @@ static int is_keyword (char *s);
 static char *plot_style_token (char *s);
 static symbol_record *lookup_identifier (char *s);
 static void grab_help_text (void);
 static int match_any (char c, char *s);
 static int next_token_is_bin_op (int spc_prev, char *yytext);
 static int next_token_is_postfix_unary_op (int spc_prev, char *yytext);
 static char *strip_trailing_whitespace (char *s);
 
-#define DO_COMMA_INSERT_CHECK yyless (do_comma_insert_check ())
-
-#define RETURN(token) \
-  do \
-    { \
-      current_input_column += yyleng; \
-      quote_is_transpose = 0; \
-      cant_be_identifier = 0; \
-      convert_spaces_to_comma = 1; \
-      return (token); \
-    } \
-  while (0)
-
-#define BIN_OP_RETURN(token) \
-  do \
-    { \
-      current_input_column += yyleng; \
-      quote_is_transpose = 0; \
-      cant_be_identifier = 0; \
-      convert_spaces_to_comma = 0; \
-      return (token); \
-    } \
-  while (0)
-
 %}
 
 D	[0-9]
 S	[ \t]
 N	[\n]
 SN	[ \t\n]
 EL	(\.\.\.)
 Im	[iIjJ]
@@ -177,159 +120,175 @@ EXPON	([DdEe][+-]?{D}+)
 			    }
 
 			  BEGIN COMMENT;
 			  current_input_column += yyleng;
 			}
 
 <COMMENT>\n		{
 			  BEGIN 0;
-			  current_input_column = 0;
+			  current_input_column = 1;
 			  quote_is_transpose = 0;
 			  cant_be_identifier = 0;
 			  convert_spaces_to_comma = 1;
 			  return '\n';
 			}
 
-<COMMENT><<EOF>>	{ RETURN (END_OF_INPUT); }
+<COMMENT><<EOF>>	{ TOK_RETURN (END_OF_INPUT); }
 
 <COMMENT>.*$		{ current_input_column += yyleng; }
 
 <NEW_MATRIX>[^ \t\n]	{
 			  yyless (0);
 			  BEGIN MATRIX;
 			}
 
 <NEW_MATRIX>{SN}*	{
 			  fixup_column_count (yytext);
 			  BEGIN MATRIX;
 			}
 
 <HELP_FCN>\n		|
 <TEXT_FCN>\n		{
 		          BEGIN 0;
-			  current_input_column = 0;
+			  current_input_column = 1;
 			  quote_is_transpose = 0;
 			  cant_be_identifier = 0;
 			  convert_spaces_to_comma = 1;
 			  return '\n';
 			}
 
 <TEXT_FCN>[\;\,]	{
 			  if (doing_set)
 			    {
-			      yylval.string = strsave (yytext);
-			      RETURN (TEXT);
+			      yylval.tok_val = new token (yytext);
+			      token_stack.push (yylval.tok_val);
+			      TOK_RETURN (TEXT);
 			    }
 			  else
 			    {
 			      BEGIN 0;
-			      RETURN (',');
+			      TOK_RETURN (',');
 			    }
 		        }
 
 <HELP_FCN>[^ \t\n]*{S}*	    |
 <TEXT_FCN>[^ \t\n\;\,]*{S}* {
-
-			  static char *tok = (char *) NULL;
-			  delete [] tok;
-			  tok = strip_trailing_whitespace (yytext);
-
-			  yylval.string = strsave (tok);
-			  RETURN (TEXT);
-			}
+			      static char *tok = (char *) NULL;
+			      delete [] tok;
+			      tok = strip_trailing_whitespace (yytext);
+			      yylval.tok_val = new token (tok);
+			      token_stack.push (yylval.tok_val);
+			      TOK_RETURN (TEXT);
+			    }
 
 <TEXT_FCN>\'{QSTR}*[\n\'] {
 			  if (yytext[yyleng-1] == '\n')
 			    {
 			      error ("unterminated string constant");
-			      current_input_column = 0;
+			      current_input_column = 1;
 			      jump_to_top_level ();
 			    }
 			  else
 			    {
+			      static char *tok = (char *) NULL;
+			      delete [] tok;
 			      int off1 = doing_set ? 0 : 1;
 			      int off2 = doing_set ? 0 : 2;
-			      yylval.string = strsave (&yytext[off1]);
-			      yylval.string[yyleng-off2] = '\0';
+			      tok = strsave (&yytext[off1]);
+			      tok[yyleng-off2] = '\0';
+			      do_string_escapes (tok);
+			      yylval.tok_val = new token (tok);
+			      token_stack.push (yylval.tok_val);
 			      current_input_column += yyleng;
 			    }
-			  do_string_escapes (yylval.string);
 			  return TEXT;
 			}
 
 <TEXT_FCN>\"{DQSTR}*[\n\"] {
 			  if (yytext[yyleng-1] == '\n')
 			    {
 			      error ("unterminated string constant");
-			      current_input_column = 0;
+			      current_input_column = 1;
 			      jump_to_top_level ();
 			    }
 			  else
 			    {
+			      static char *tok = (char *) NULL;
+			      delete [] tok;
 			      int off1 = doing_set ? 0 : 1;
 			      int off2 = doing_set ? 0 : 2;
-			      yylval.string = strsave (&yytext[off1]);
-			      yylval.string[yyleng-off2] = '\0';
+			      tok = strsave (&yytext[off1]);
+			      tok[yyleng-off2] = '\0';
+			      do_string_escapes (tok);
+			      yylval.tok_val = new token (tok);
+			      token_stack.push (yylval.tok_val);
 			      current_input_column += yyleng;
 			    }
-			  do_string_escapes (yylval.string);
 			  return TEXT;
 			}
 
 <TEXT_FCN>{S}*		{ current_input_column += yyleng; }
 
 <STRING>{QSTR}*[\n\']	{
 			  if (braceflag)
 			    BEGIN MATRIX;
 			  else
 			    BEGIN 0;
 
 			  if (yytext[yyleng-1] == '\n')
 			    {
 			      error ("unterminated string constant");
-			      current_input_column = 0;
+			      current_input_column = 1;
 			      jump_to_top_level ();
 			    }
 			  else
 			    {
-			      yylval.string = strsave (yytext);
-			      yylval.string[yyleng-1] = '\0';
+			      static char *tok = (char *) NULL;
+			      delete [] tok;
+			      tok = strsave (yytext);
+			      tok[yyleng-1] = '\0';
+			      do_string_escapes (tok);
+			      yylval.tok_val = new token (tok);
+			      token_stack.push (yylval.tok_val);
+			      quote_is_transpose = 1;
+			      cant_be_identifier = 1;
+			      convert_spaces_to_comma = 1;
 			      current_input_column += yyleng;
 			    }
-			  do_string_escapes (yylval.string);
-			  quote_is_transpose = 1;
-			  cant_be_identifier = 1;
-			  convert_spaces_to_comma = 1;
 			  return TEXT;
 			}
 
 
 <DQSTRING>{DQSTR}*[\n\"] {
 			  if (braceflag)
 			    BEGIN MATRIX;
 			  else
 			    BEGIN 0;
 
 			  if (yytext[yyleng-1] == '\n')
 			    {
 			      error ("unterminated string constant");
-			      current_input_column = 0;
+			      current_input_column = 1;
 			      jump_to_top_level ();
 			    }
 			  else
 			    {
-			      yylval.string = strsave (yytext);
-			      yylval.string[yyleng-1] = '\0';
+			      static char *tok = (char *) NULL;
+			      delete [] tok;
+			      tok = strsave (yytext);
+			      tok[yyleng-1] = '\0';
+			      do_string_escapes (tok);
+			      yylval.tok_val = new token (tok);
+			      token_stack.push (yylval.tok_val);
+			      quote_is_transpose = 1;
+			      cant_be_identifier = 1;
+			      convert_spaces_to_comma = 1;
 			      current_input_column += yyleng;
 			    }
-			  do_string_escapes (yylval.string);
-			  quote_is_transpose = 1;
-			  cant_be_identifier = 1;
-			  convert_spaces_to_comma = 1;
 			  return TEXT;
 			}
 
 <MATRIX>{SN}*\]{S}*/==	{
 
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is '='.
 //
@@ -342,34 +301,34 @@ EXPON	([DdEe][+-]?{D}+)
 // It would have been so much easier if the delimiters were simply
 // different for the expression on the left hand side of the equals
 // operator.
 
 			  in_brace_or_paren.pop ();
 			  braceflag--;
 			  if (braceflag == 0)
 			    {
-			      if (!defining_func)
+			      if (! defining_func)
 				promptflag++;
 			      BEGIN 0;
 			    }
 			  fixup_column_count (yytext);
 			  quote_is_transpose = 0;
 			  cant_be_identifier = 0;
 			  convert_spaces_to_comma = 1;
 			  return ']';
 			}
 
 <MATRIX>{SN}*\]{S}*/=	{
 			  in_brace_or_paren.pop ();
 			  braceflag--;
 			  if (braceflag == 0)
 			    {
 			      BEGIN 0;
-			      if (!defining_func)
+			      if (! defining_func)
 				promptflag++;
 			    }
 			  fixup_column_count (yytext);
 			  quote_is_transpose = 0;
 			  cant_be_identifier = 0;
 			  convert_spaces_to_comma = 1;
 			  if (maybe_screwed_again)
 			    return SCREW_TWO;
@@ -379,17 +338,17 @@ EXPON	([DdEe][+-]?{D}+)
 
 <MATRIX>{SN}*\]{S}*	{
 			  fixup_column_count (yytext);
 
 			  in_brace_or_paren.pop ();
 			  braceflag--;
 			  if (braceflag == 0)
 			    {
-			      if (!defining_func)
+			      if (! defining_func)
 				promptflag++;
 			      BEGIN 0;
 			    }
 			  else
 			    {
 			      int c0 = yytext[yyleng-1];
 			      int spc_prev = (c0 == ' ' || c0 == '\t');
 			      int bin_op = next_token_is_bin_op (spc_prev,
@@ -412,27 +371,27 @@ EXPON	([DdEe][+-]?{D}+)
 			    }
 
 			  quote_is_transpose = 1;
 			  cant_be_identifier = 0;
 			  convert_spaces_to_comma = 1;
 			  return ']';
 			}
 
-<MATRIX>{S}*\,{S}*	{ RETURN (','); }
+<MATRIX>{S}*\,{S}*	{ TOK_RETURN (','); }
 
 <MATRIX>{S}+		{
 			  int bin_op = next_token_is_bin_op (1, yytext);
 			  int postfix_un_op
 			    = next_token_is_postfix_unary_op (1, yytext);
 
  			  if (! (postfix_un_op || bin_op)
 			      && in_brace_or_paren.top ()
 			      && convert_spaces_to_comma)
-			    RETURN (',');
+			    TOK_RETURN (',');
 			}
 
 <MATRIX>{SN}*\;{SN}*	|
 <MATRIX>{N}{SN}*	{
 			  fixup_column_count (yytext);
 			  quote_is_transpose = 0;
 			  cant_be_identifier = 0;
 			  convert_spaces_to_comma = 1;
@@ -441,59 +400,69 @@ EXPON	([DdEe][+-]?{D}+)
 
 \]			{
 			  if (! in_brace_or_paren.empty ())
 			    in_brace_or_paren.pop ();
 
 			  if (plotting && ! past_plot_range)
 			    {
 			      in_plot_range = 0;
-			      RETURN (CLOSE_BRACE);
+			      TOK_RETURN (CLOSE_BRACE);
 			    }
 			  else
-			    RETURN (']');
+			    TOK_RETURN (']');
 			}
 
 {D}+{EXPON}?{Im}	|
 {D}+\.{D}*{EXPON}?{Im}	|
 \.{D}+{EXPON}?{Im}	{
-			  int nread = sscanf (yytext, "%lf", &(yylval.number));
+			  double value;
+			  int nread = sscanf (yytext, "%lf", &value);
 			  assert (nread == 1);
 			  quote_is_transpose = 1;
 			  cant_be_identifier = 1;
 			  convert_spaces_to_comma = 1;
 			  if (plotting && ! in_plot_range)
 			    past_plot_range = 1;
+			  yylval.tok_val = new token (value,
+						      input_line_number,
+						      current_input_column);
+			  token_stack.push (yylval.tok_val);
 			  current_input_column += yyleng;
 			  DO_COMMA_INSERT_CHECK;
 			  return IMAG_NUM;
 			}
 
 {D}+{EXPON}?		|
 {D}+\.{D}*{EXPON}?	|
 \.{D}+{EXPON}?		|
 			{
-			  int nread = sscanf (yytext, "%lf", &(yylval.number));
+			  double value;
+			  int nread = sscanf (yytext, "%lf", &value);
 			  assert (nread == 1);
 			  quote_is_transpose = 1;
 			  cant_be_identifier = 1;
 			  convert_spaces_to_comma = 1;
 			  if (plotting && ! in_plot_range)
 			    past_plot_range = 1;
+			  yylval.tok_val = new token (value,
+						      input_line_number,
+						      current_input_column);
+			  token_stack.push (yylval.tok_val);
 			  current_input_column += yyleng;
 			  DO_COMMA_INSERT_CHECK;
 			  return NUM;
 			}
 
 \[{S}*		{
 		  in_brace_or_paren.push (1);
 		  if (plotting && ! past_plot_range)
 		    {
 		      in_plot_range = 1;
-		      RETURN (OPEN_BRACE);
+		      TOK_RETURN (OPEN_BRACE);
 		    }
 
 		  if (do_comma_insert)
 		    {
 		      yyless (0);
 		      do_comma_insert = 0;
 		      quote_is_transpose = 0;
 		      cant_be_identifier = 0;
@@ -501,44 +470,44 @@ EXPON	([DdEe][+-]?{D}+)
 		      return (',');
 		    }
 		  else
 		    {
 		      mlnm.push (1);
 		      braceflag++;
 		      promptflag--;
 		      BEGIN NEW_MATRIX;
-		      RETURN ('[');
+		      TOK_RETURN ('[');
 		    }
 		}
 
 {S}*		{ current_input_column += yyleng; }
 
 {EL}{S}*\n	{
 
 // Line continuation.
 
 		  promptflag--;
-		  current_input_column = 0;
+		  current_input_column = 1;
 		}
 
-<<EOF>>		RETURN (END_OF_INPUT);
+<<EOF>>		TOK_RETURN (END_OF_INPUT);
 
 {IDENT}{S}*	{
 
 // Truncate the token at the first space or tab but don't write
 // directly on yytext.
 
 		  static char *tok = (char *) NULL;
 		  delete [] tok;
 		  tok = strip_trailing_whitespace (yytext);
 
 		  int kw_token = is_keyword (tok);
 		  if (kw_token)
-		    RETURN (kw_token);
+		    TOK_RETURN (kw_token);
 
 		  if (plotting && cant_be_identifier)
 		    {
 		      int plot_option_kw = is_plot_keyword (tok);
 		      if (plot_option_kw)
 			{
 			  quote_is_transpose = 0;
 			  cant_be_identifier = 0;
@@ -551,45 +520,57 @@ EXPON	([DdEe][+-]?{D}+)
 		  if (plotting && ! in_plot_range)
 		    past_plot_range = 1;
 
 		  if (plotting && in_plot_style)
 		    {
 		      char *sty = plot_style_token (&tok[1]);
 		      if (sty != (char *) NULL)
 			{
-			  yylval.string = strsave (sty);
+			  yylval.tok_val = new token (sty);
+			  token_stack.push (yylval.tok_val);
 			  if (in_plot_style)
 			    {
 			      in_plot_style = 0;
-			      RETURN (STYLE);
+			      TOK_RETURN (STYLE);
 			    }
 			}
 		    }
 
 		  cant_be_identifier = 1;
 
 // If we are looking at a text style function, set up to gobble its
 // arguments.  These are also reserved words, but only because it
 // would be very difficult to do anything intelligent with them if
 // they were not reserved.
 
 		  if (is_text_function_name (tok))
 		    {
 		      BEGIN TEXT_FCN;
 
 		      if (strcmp (tok, "clear") == 0)
-			return CLEAR;
+			{
+			  symbol_record *sr =
+			    global_sym_tab->lookup ("clear", 1, 0);
+			  assert (sr != (symbol_record *) NULL);
+			  yylval.tok_val = new token (sr, input_line_number,
+						      current_input_column);
+			  token_stack.push (yylval.tok_val);
+			  return CLEAR;
+			}
 		      else if (strcmp (tok, "help") == 0)
 			BEGIN HELP_FCN;
 		      else if (strcmp (tok, "set") == 0)
 			doing_set = 1;
 		    }
 
-		  yylval.sym_rec = lookup_identifier (tok);
+		  yylval.tok_val = new token (lookup_identifier (tok),
+					      input_line_number,
+					      current_input_column);
+		  token_stack.push (yylval.tok_val);
 
 		  quote_is_transpose = 1;
 		  current_input_column += yyleng;
 		  DO_COMMA_INSERT_CHECK;
 
 		  if (! in_brace_or_paren.empty ()
 		      && in_brace_or_paren.top ())
 		    {
@@ -626,17 +607,17 @@ EXPON	([DdEe][+-]?{D}+)
 // symbol table local to the function. 
 //
 // If we're not defining a function, this should function exactly like
 // the case above.  I suppose it would be nice to avoid duplicating
 // all the code, eh?
 
 		  int kw_token = is_keyword (yytext);
 		  if (kw_token)
-		    RETURN (kw_token);
+		    TOK_RETURN (kw_token);
 
 		  if (plotting && cant_be_identifier)
 		    {
 		      int plot_option_kw = is_plot_keyword (yytext);
 		      if (plot_option_kw)
 			{
 			  quote_is_transpose = 0;
 		  	  convert_spaces_to_comma = 1;
@@ -652,27 +633,38 @@ EXPON	([DdEe][+-]?{D}+)
 // would be very difficult to do anything intelligent with them if
 // they were not reserved.
 
 		  if (is_text_function_name (yytext))
 		    {
 		      BEGIN TEXT_FCN;
 
 		      if (strcmp (yytext, "clear") == 0)
-			return CLEAR;
+			{
+			  symbol_record *sr =
+			    global_sym_tab->lookup ("clear", 1, 0);
+			  assert (sr != (symbol_record *) NULL);
+			  yylval.tok_val = new token (sr, input_line_number,
+						      current_input_column);
+			  token_stack.push (yylval.tok_val);
+			  return CLEAR;
+			}
 		      else if (strcmp (yytext, "help") == 0)
 			BEGIN HELP_FCN;
 		      else if (strcmp (yytext, "set") == 0)
 			doing_set = 1;
 		    }
 
 		  if (defining_func && maybe_screwed)
 		    curr_sym_tab = tmp_local_sym_tab;
 
-		  yylval.sym_rec = lookup_identifier (yytext);
+		  yylval.tok_val = new token (lookup_identifier (yytext),
+					      input_line_number,
+					      current_input_column);
+		  token_stack.push (yylval.tok_val);
 
 		  convert_spaces_to_comma = 1;
 		  current_input_column += yyleng;
 		  if (defining_func && maybe_screwed)
 		    {
 		      return SCREW;
 		    }
 		  else
@@ -681,17 +673,17 @@ EXPON	([DdEe][+-]?{D}+)
 		      DO_COMMA_INSERT_CHECK;
 		      return NAME;
 		    }
 		}
 
 "\n"		{
 		  quote_is_transpose = 0;
 		  cant_be_identifier = 0;
-		  current_input_column = 0;
+		  current_input_column = 1;
 		  convert_spaces_to_comma = 1;
 		  return '\n';
 		}
 
 "'"		{
 		  current_input_column++;
 		  convert_spaces_to_comma = 1;
 
@@ -701,91 +693,91 @@ EXPON	([DdEe][+-]?{D}+)
 		      return QUOTE;
 		    }
 		  else
 		    BEGIN STRING;
 		}
 
 ":"		{
 		  if (plotting && (in_plot_range || in_plot_using))
-		    RETURN (COLON);
+		    BIN_OP_RETURN (COLON, 1);
 		  else
-		    BIN_OP_RETURN (':');
+		    BIN_OP_RETURN (':', 0);
 		}
 
 \"		{ BEGIN DQSTRING; }
-".**"		{ BIN_OP_RETURN (EPOW); }
-".*"		{ BIN_OP_RETURN (EMUL); }
-"./"		{ BIN_OP_RETURN (EDIV); }
-".\\"		{ BIN_OP_RETURN (ELEFTDIV); }
-".^"		{ BIN_OP_RETURN (EPOW); }
-".'"		{ DO_COMMA_INSERT_CHECK; RETURN (TRANSPOSE); }
-"++"		{ DO_COMMA_INSERT_CHECK; RETURN (PLUS_PLUS); }
-"--"		{ DO_COMMA_INSERT_CHECK; RETURN (MINUS_MINUS); }
-"<="		{ BIN_OP_RETURN (EXPR_LE); }
-"=="		{ BIN_OP_RETURN (EXPR_EQ); }
-"~="		{ BIN_OP_RETURN (EXPR_NE); }
-"!="		{ BIN_OP_RETURN (EXPR_NE); }
-"<>"		{ BIN_OP_RETURN (EXPR_NE); }
-">="		{ BIN_OP_RETURN (EXPR_GE); }
-"||"		{ BIN_OP_RETURN (EXPR_OR); }
-"&&"		{ BIN_OP_RETURN (EXPR_AND); }
-"|"		{ BIN_OP_RETURN (EXPR_OR); }
-"&"		{ BIN_OP_RETURN (EXPR_AND); }
+".**"		{ BIN_OP_RETURN (EPOW, 0); }
+".*"		{ BIN_OP_RETURN (EMUL, 0); }
+"./"		{ BIN_OP_RETURN (EDIV, 0); }
+".\\"		{ BIN_OP_RETURN (ELEFTDIV, 0); }
+".^"		{ BIN_OP_RETURN (EPOW, 0); }
+".'"		{ DO_COMMA_INSERT_CHECK; BIN_OP_RETURN (TRANSPOSE, 1); }
+"++"		{ DO_COMMA_INSERT_CHECK; BIN_OP_RETURN (PLUS_PLUS, 1); }
+"--"		{ DO_COMMA_INSERT_CHECK; BIN_OP_RETURN (MINUS_MINUS, 1); }
+"<="		{ BIN_OP_RETURN (EXPR_LE, 0); }
+"=="		{ BIN_OP_RETURN (EXPR_EQ, 0); }
+"~="		{ BIN_OP_RETURN (EXPR_NE, 0); }
+"!="		{ BIN_OP_RETURN (EXPR_NE, 0); }
+"<>"		{ BIN_OP_RETURN (EXPR_NE, 0); }
+">="		{ BIN_OP_RETURN (EXPR_GE, 0); }
+"||"		{ BIN_OP_RETURN (EXPR_OR, 0); }
+"&&"		{ BIN_OP_RETURN (EXPR_AND, 0); }
+"|"		{ BIN_OP_RETURN (EXPR_OR, 0); }
+"&"		{ BIN_OP_RETURN (EXPR_AND, 0); }
 "!"		{
 		  if (plotting && ! in_plot_range)
 		    past_plot_range = 1;
-		  RETURN (EXPR_NOT);
+		  BIN_OP_RETURN (EXPR_NOT, 1);
 		}
 "~"		{
 		  if (plotting && ! in_plot_range)
 		    past_plot_range = 1;
-		  BIN_OP_RETURN (EXPR_NOT);
+		  BIN_OP_RETURN (EXPR_NOT, 0);
 		}
-"<"		{ BIN_OP_RETURN (EXPR_LT); }
-">"		{ BIN_OP_RETURN (EXPR_GT); }
+"<"		{ BIN_OP_RETURN (EXPR_LT, 0); }
+">"		{ BIN_OP_RETURN (EXPR_GT, 0); }
 "+"		{ 
 		  if (plotting && ! in_plot_range)
 		    past_plot_range = 1;
-		  BIN_OP_RETURN ('+');
+		  BIN_OP_RETURN ('+', 0);
 		}
 "-"		{
 		  if (plotting && ! in_plot_range)
 		    past_plot_range = 1;
-		  BIN_OP_RETURN ('-');
+		  BIN_OP_RETURN ('-', 0);
 		}
-"**"		{ BIN_OP_RETURN (POW); }
-"*"		{ BIN_OP_RETURN ('*'); }
-"/"		{ BIN_OP_RETURN ('/'); }
-"\\"		{ BIN_OP_RETURN (LEFTDIV); }
-";"		{ RETURN (';'); }
-","		{ RETURN (','); }
-"^"		{ BIN_OP_RETURN (POW); }
-"="		{ RETURN ('='); }
+"**"		{ BIN_OP_RETURN (POW, 0); }
+"*"		{ BIN_OP_RETURN ('*', 0); }
+"/"		{ BIN_OP_RETURN ('/', 0); }
+"\\"		{ BIN_OP_RETURN (LEFTDIV, 0); }
+";"		{ BIN_OP_RETURN (';', 1); }
+","		{ BIN_OP_RETURN (',', 1); }
+"^"		{ BIN_OP_RETURN (POW, 0); }
+"="		{ BIN_OP_RETURN ('=', 1); }
 "("		{
 		  if (plotting && ! in_plot_range)
 		    past_plot_range = 1;
 		  in_brace_or_paren.push (0);
-		  RETURN ('(');
+		  TOK_RETURN ('(');
 		}
 ")"		{
 		  if (! in_brace_or_paren.empty ())
 		    in_brace_or_paren.pop ();
 		  DO_COMMA_INSERT_CHECK;
 		  current_input_column++;
 		  quote_is_transpose = 1;
 		  return ')';
 		}
 
 .		{
 
 // We return everything else as single character tokens, which should
 // eventually result in a parse error.
 
-		  RETURN (yytext[0]);
+		  TOK_RETURN (yytext[0]);
 		}
 
 %%
 
 /*
  * GAG.
  *
  * If we're reading a matrix and the next character is '[', make sure
@@ -796,17 +788,18 @@ do_comma_insert_check (void)
 {
   int tmp_len = yyleng;
   int c = yyinput ();
   do_comma_insert = (braceflag && c == '[');
   return tmp_len;
 }
 
 /*
- * Fix things up for errors or interrupts.
+ * Fix things up for errors or interrupts.  This could use a few
+ * comments now, eh?
  */
 void
 reset_parser (void)
 {
   BEGIN 0;
   promptflag = 1;
   doing_set = 0;
   braceflag = 0;
@@ -815,27 +808,31 @@ reset_parser (void)
   looping = 0;
   iffing = 0;
   ml.clear ();
   mlnm.clear ();
   defining_func = 0;
   curr_sym_tab = top_level_sym_tab;
   get_input_from_eval_string = 0;
   quote_is_transpose = 0;
-  current_input_column = 0;
+  current_input_column = 1;
+// Might have been reset by defining a function.
+  input_line_number = current_command_number - 1;
   do_comma_insert = 0;
   plotting = 0;
   past_plot_range = 0;
   in_plot_range = 0;
   in_plot_using = 0;
   in_plot_style = 0;
   cant_be_identifier = 0;
   convert_spaces_to_comma = 1;
   beginning_of_function = 0;
   in_brace_or_paren.clear ();
+  while (! token_stack.empty ())
+    delete token_stack.pop ();
   yyrestart (stdin);
 }
 
 static void
 do_string_escapes (char *s)
 {
   char *p1 = s;
   char *p2 = s;
@@ -901,17 +898,17 @@ do_string_escapes (char *s)
 
 static void
 fixup_column_count (char *s)
 {
   char c;
   while ((c = *s++) != '\0')
     {
       if (c == '\n')
-	  current_input_column = 0;
+	  current_input_column = 1;
       else
 	current_input_column++;
     }
 }
 
 #ifdef yywrap
 #undef yywrap
 #endif
@@ -1022,76 +1019,134 @@ static int
 is_keyword (char *s)
 {
   if (plotting && in_plot_style)
     {
       char *sty = plot_style_token (s);
       if (sty != (char *) NULL)
 	{
 	  in_plot_style = 0;
-	  yylval.string = strsave (sty);
+	  yylval.tok_val = new token (sty);
+	  token_stack.push (yylval.tok_val);
 	  return STYLE;
 	}
     }
 
+  int l = input_line_number;
+  int c = current_input_column;
+
   int end_found = 0;
   if (strcmp ("break", s) == 0)
-    return BREAK;
+    {
+      return BREAK;
+    }
   else if (strcmp ("continue", s) == 0)
-    return CONTINUE;
+    {
+      return CONTINUE;
+    }
   else if (strcmp ("else", s) == 0)
-    { return ELSE; }
+    {
+      return ELSE;
+    }
   else if (strcmp ("elseif", s) == 0)
-    { return ELSEIF; }
+    {
+      return ELSEIF;
+    }
   else if (strcmp ("end", s) == 0)
-    { end_found = 1; yylval.ettype = simple_end; }
+    {
+      end_found = 1;
+      yylval.tok_val = new token (token::simple_end, l, c);
+      token_stack.push (yylval.tok_val);
+    }
   else if (strcmp ("endfor", s) == 0)
-    { end_found = 1; yylval.ettype = for_end; }
+    {
+      end_found = 1;
+      yylval.tok_val = new token (token::for_end, l, c);
+      token_stack.push (yylval.tok_val);
+    }
   else if (strcmp ("endfunction", s) == 0)
-    { end_found = 1; yylval.ettype = function_end; }
+    {
+      end_found = 1;
+      yylval.tok_val = new token (token::function_end, l, c);
+      token_stack.push (yylval.tok_val);
+    }
   else if (strcmp ("endif", s) == 0)
-    { end_found = 1; yylval.ettype = if_end; }
+    {
+      end_found = 1;
+      yylval.tok_val = new token (token::if_end, l, c);
+      token_stack.push (yylval.tok_val);
+    }
   else if (strcmp ("endwhile", s) == 0)
-    { end_found = 1; yylval.ettype = while_end; }
+    {
+      end_found = 1;
+      yylval.tok_val = new token (token::while_end, l, c);
+      token_stack.push (yylval.tok_val);
+    }
   else if (strcmp ("for", s) == 0)
-    { promptflag--; looping++; return FOR; }
+    {
+      promptflag--;
+      looping++;
+      return FOR;
+    }
   else if (strcmp ("function", s) == 0)
     {
       if (defining_func)
 	{
 	  error ("sorry, nested functions are a no-no...");
 	  jump_to_top_level ();
 	}
       else
 	{
 	  tmp_local_sym_tab = new symbol_table ();
 	  curr_sym_tab = tmp_local_sym_tab;
 	  defining_func = 1;
 	  promptflag--;
 	  beginning_of_function = 1;
 	  help_buf[0] = '\0';
+	  input_line_number = 1;
 	  return FCN;
 	}
     }
   else if (strcmp ("global", s) == 0)
-    return GLOBAL;
+    {
+      return GLOBAL;
+    }
   else if (strcmp ("gplot", s) == 0)
-    { plotting = 1; yylval.pttype = two_dee; return PLOT; }
+    {
+      plotting = 1;
+      yylval.tok_val = new token (token::two_dee, l, c);
+      return PLOT;
+    }
   else if (strcmp ("gsplot", s) == 0)
-    { plotting = 1; yylval.pttype = three_dee; return PLOT; }
+    {
+      plotting = 1;
+      yylval.tok_val = new token (token::three_dee, l, c);
+      token_stack.push (yylval.tok_val);
+      return PLOT;
+    }
   else if (strcmp ("if", s) == 0)
-    { iffing++; promptflag--; return IF; }
+    {
+      iffing++;
+      promptflag--;
+      return IF;
+    }
   else if (strcmp ("return", s) == 0)
-    return FUNC_RET;
+    {
+      return FUNC_RET;
+    }
   else if (strcmp ("while", s) == 0)
-    { promptflag--; looping++; return WHILE; }
+    {
+      promptflag--;
+      looping++;
+      return WHILE;
+    }
 
   if (end_found)
     {
-      if (!defining_func && !looping)
+      if (! defining_func && ! looping)
 	promptflag++;
       return END;
     }
 
   return 0;
 }
 
 static symbol_record *
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -224,17 +224,17 @@ parse_and_execute (char *s, int print)
   FILE *f = get_input_from_file (s, 0);
   if (f != (FILE *) NULL)
     {
       unwind_protect_int (input_line_number);
       unwind_protect_int (current_input_column);
       unwind_protect_int (echo_input);
 
       input_line_number = 0;
-      current_input_column = 0;
+      current_input_column = 1;
       echo_input = 0;
 
       parse_and_execute (f, print);
     }
 
   run_unwind_frame ("parse_and_execute_2");
 }
 
@@ -474,16 +474,17 @@ main (int argc, char **argv)
 
   int retval;
   do
     {
       reset_parser ();
       retval = yyparse ();
       if (retval == 0 && global_command != NULL_TREE)
 	{
+	  error_state = 0;
 	  global_command->eval (1);
 	  delete global_command;
 	  current_command_number++;
 	}
     }
   while (retval == 0);
 
   clean_up_and_exit (retval);
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1,9 +1,9 @@
-/* parse.y                                              -*- text -*-
+/* parse.y						-*- text -*-
 
 Copyright (C) 1992, 1993 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
@@ -38,16 +38,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "input.h"
 #include "utils.h"
 #include "tree.h"
 #include "symtab.h"
 #include "builtins.h"
 #include "octave.h"
 #include "parse.h"
 #include "lex.h"
+#include "token.h"
 
 // Identifier to define if we are reading an M-fie.
 tree_identifier *id_to_define;
 
 // Nonzero means we're in the middle of defining a function.
 int defining_func = 0;
 
 // Nonzero means we're in the middle of defining a loop.
@@ -74,17 +75,17 @@ SLStack <tree_matrix *> ml;
 // started reading a new matrix.  This should probably be part of a
 // new struct for matrix lists... 
 SLStack <int> mlnm;
 
 // The current input line number.
 int input_line_number = 0;
 
 // The column of the current token.
-int current_input_column = 0;
+int current_input_column = 1;
 
 // Buffer for help text snagged from M-files.
 // Probably shouldn't be a fixed size...
 char help_buf [HELP_BUF_LENGTH];
 
 // Nonzero means we're working on a plot command.
 int plotting = 0;
 
@@ -96,35 +97,21 @@ int past_plot_range = 0;
 int in_plot_range = 0;
 
 // Nonzero means we're looking at the using part of a plot command.
 int in_plot_using = 0;
 
 // Nonzero means we're looking at the style part of a plot command.
 int in_plot_style = 0;
 
-// The type of an END token.  This declaration is repeated in lex.l.
-enum end_tok_type
-  {
-    simple_end,
-    for_end,
-    function_end,
-    if_end,
-    while_end,
-  };
-
-// The type of a PLOT token.  This declaration is repeated in lex.l.
-enum plot_tok_type
-  {
-    two_dee = 2,
-    three_dee = 3,
-  };
+// Check to see that end statements are properly matched.
+static int check_end (token *tok, token::end_tok_type expected);
 
 // Error mesages for mismatched end statements.
-static void end_error (char *type, end_tok_type ettype);
+static void end_error (char *type, token::end_tok_type ettype, int l, int c);
 
 // Generic error messages.
 static void yyerror (char *s);
 
 static tree *maybe_convert_to_ans_assign (tree *expr);
 static void maybe_warn_assign_as_truth_value (tree *expr);
 
 #define ABORT_PARSE \
@@ -142,16 +129,20 @@ static void maybe_warn_assign_as_truth_v
 
 %}
 
 /*
  * Bison declarations.
  */
 %union
 {
+// The type of the basic tokens returned by the lexer.
+  token *tok_val;
+
+// Types for the nonterminals we generate.
   tree *tree_type;
   tree_constant *tree_constant_type;
   tree_matrix *tree_matrix_type;
   tree_identifier *tree_identifier_type;
   tree_function *tree_function_type;
   tree_index_expression *tree_index_expression_type;
   tree_colon_expression *tree_colon_expression_type;
   tree_argument_list *tree_argument_list_type;
@@ -162,112 +153,74 @@ static void maybe_warn_assign_as_truth_v
   tree_command_list *tree_command_list_type;
   tree_word_list_command *tree_word_list_command_type;
   tree_plot_command *tree_plot_command_type;
   tree_subplot_list *tree_subplot_list_type;
   tree_plot_limits *tree_plot_limits_type;
   tree_plot_range *tree_plot_range_type;
   tree_subplot_using *tree_subplot_using_type;
   tree_subplot_style *tree_subplot_style_type;
-  symbol_record *sym_rec;
-  double number;
-  char *string;
-  end_tok_type ettype;
-  plot_tok_type pttype;
 }
 
-/*
- * There are 20 shift/reduce conflicts, ok?
- */
-%expect 20
+// Tokens with line and column information.
+%token <tok_val> '=' ':' '-' '+' '*' '/'
+%token <tok_val> EXPR_AND EXPR_OR EXPR_NOT
+%token <tok_val> EXPR_LT EXPR_LE EXPR_EQ EXPR_NE EXPR_GE EXPR_GT
+%token <tok_val> LEFTDIV EMUL EDIV ELEFTDIV QUOTE TRANSPOSE
+%token <tok_val> PLUS_PLUS MINUS_MINUS POW EPOW
+%token <tok_val> NUM IMAG_NUM
+%token <tok_val> NAME SCREW CLEAR
+%token <tok_val> END
+%token <tok_val> PLOT
+%token <tok_val> TEXT STYLE
 
-/*
- * Reserved words.
- */
+// Other tokens.
 %token FOR WHILE IF ELSEIF ELSE FCN BREAK CONTINUE FUNC_RET SCREW_TWO
-%token END_OF_INPUT GLOBAL CLEAR
-
+%token END_OF_INPUT GLOBAL
 %token USING TITLE WITH COLON OPEN_BRACE CLOSE_BRACE
 
-// tree
+// Nonterminals we construct.
 %type <tree_type> input command 
 %type <tree_type> ans_expression expression simple_expr simple_expr1
 %type <tree_type> title
-
-// tree_matrix
 %type <tree_matrix_type> matrix
-
-// tree_identifier
 %type <tree_identifier_type> identifier
-
-// tree_function 
 %type <tree_function_type> func_def func_def1 func_def2 func_def3
-
-// tree_index_expression
 %type <tree_index_expression_type> variable
-
-// tree_colon_expression
 %type <tree_colon_expression_type> colon_expr
-
-// tree_argument_list
 %type <tree_argument_list_type> arg_list arg_list1
-
-// tree_parameter_list
 %type <tree_parameter_list_type> param_list param_list1 func_def1a 
-
-// tree_word_list
 %type <tree_word_list_type> word_list word_list1
-
-// tree_command
 %type <tree_command_type> statement
-
-// tree_if_command
 %type <tree_if_command_type> elseif
-
-// tree_command_list
 %type <tree_command_list_type> simple_list simple_list1 list list1 opt_list
-
-// tree_word_list_command
 %type <tree_word_list_command_type> word_list_cmd
-
-// tree_plot_command
 %type <tree_plot_command_type> plot_command 
-
-// tree_subplot_list
 %type <tree_subplot_list_type> plot_command1 plot_command2 plot_options
-
-// tree_plot_limits
 %type <tree_plot_limits_type> ranges
-
-// tree_plot_range
 %type <tree_plot_range_type> ranges1 
-
-// tree_subplot_using
 %type <tree_subplot_using_type> using using1 
-
-// tree_subplot_style
 %type <tree_subplot_style_type> style
 
-%token <number> NUM IMAG_NUM
-%token <sym_rec> NAME SCREW
-%token <string> TEXT STYLE
-%token <ettype> END
-%token <pttype> PLOT
-
+// Precedence and associativity.
 %left ';' ',' '\n'
 %right '='
 %left EXPR_AND EXPR_OR
 %left EXPR_LT EXPR_LE EXPR_EQ EXPR_NE EXPR_GE EXPR_GT
 %left ':'
 %left '-' '+'
 %left '*' '/' LEFTDIV EMUL EDIV ELEFTDIV
 %left QUOTE TRANSPOSE
 %left UNARY PLUS_PLUS MINUS_MINUS EXPR_NOT
 %right POW EPOW
 
+// There are 20 shift/reduce conflicts, ok?
+%expect 20
+
+// Where to start.
 %start input
 
 /*
  * Grammar rules.
  */
 %%
 
 input		: '\n'
@@ -392,27 +345,27 @@ command		: plot_command
 		  { $$ = $1; }
 		| global_decl
 		  { $$ = NULL_TREE; }
 		;
 
 plot_command	: PLOT plot_command1
 		  {
 		    tree_subplot_list *tmp = $2->reverse ();
-		    $$ = new tree_plot_command (tmp, $1);
+		    $$ = new tree_plot_command (tmp, $1->pttype ());
 		    plotting = 0;
 		    past_plot_range = 0;
 		    in_plot_range = 0;
 		    in_plot_using = 0;
 		    in_plot_style = 0;
 		  }
 		| PLOT ranges plot_command1
 		  {
 		    tree_subplot_list *tmp = $3->reverse ();
-		    $$ = new tree_plot_command (tmp, $2, $1);
+		    $$ = new tree_plot_command (tmp, $2, $1->pttype ());
 		    plotting = 0;
 		    past_plot_range = 0;
 		    in_plot_range = 0;
 		    in_plot_using = 0;
 		    in_plot_style = 0;
 		  }
 		;
 
@@ -501,137 +454,117 @@ using1		: USING expression
 		  { $$ = $1->add_qualifier ($3); }
 		;
 
 title		: TITLE expression
 		  { $$ = $2; }
 		;
 
 style		: WITH STYLE
-		  { $$ = new tree_subplot_style ($2); }
+		  { $$ = new tree_subplot_style ($2->string ()); }
 		| WITH STYLE expression
-		  { $$ = new tree_subplot_style ($2, $3); }
+		  { $$ = new tree_subplot_style ($2->string (), $3); }
 		| WITH STYLE expression bogus_syntax expression
-		  { $$ = new tree_subplot_style ($2, $3, $5); }
+		  { $$ = new tree_subplot_style ($2->string (), $3, $5); }
 		;
 
 bogus_syntax	: // empty
 		;
 
 ans_expression	: expression
 		  { $$ = maybe_convert_to_ans_assign ($1); }
 		;
 
 global_decl	: GLOBAL global_decl1
 		  { }
 		;
 
 global_decl1	: NAME
-		  { force_global ($1->name ()); }
+		  { force_global ($1->sym_rec()->name ()); }
 		| NAME '=' expression
 		  {
-		    symbol_record *sr = force_global ($1->name ());
-		    tree_identifier *id = new tree_identifier (sr);
+		    symbol_record *sr = force_global ($1->sym_rec()->name ());
+		    tree_identifier *id = new tree_identifier
+		      (sr, $1->line (), $1->column ());
 		    tree_simple_assignment_expression *expr =
-		      new tree_simple_assignment_expression (id, $3);
+		      new tree_simple_assignment_expression
+			(id, $3, $2->line () , $2->column ());
 		    expr->eval (0);
 		  }
 		| global_decl1 optcomma NAME
-		  { force_global ($3->name ()); }
+		  { force_global ($3->sym_rec()->name ()); }
 		| global_decl1 optcomma NAME '=' expression
 		  {
-		    symbol_record *sr = force_global ($3->name ());
-		    tree_identifier *id = new tree_identifier (sr);
+		    symbol_record *sr = force_global ($3->sym_rec()->name ());
+		    tree_identifier *id = new tree_identifier
+		      (sr, $3->line (), $3->column ());
 		    tree_simple_assignment_expression *expr =
-		      new tree_simple_assignment_expression (id, $5);
+		      new tree_simple_assignment_expression
+			(id, $5, $4->line (), $4->column ());
 		    expr->eval (0);
 		  }
 		;
 
 optcomma	: // empty
 		| ','
 		  {
 		    if (user_pref.warn_comma_in_global_decl)
 		      warning ("comma in global declaration not\
  interpreted as a command separator");
 		  }
 		;
 
 statement	: WHILE expression optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
-		    if ($5 != while_end && $5 != simple_end)
-		      {
-			yyerror ("parse error");
-			end_error ("while", $5);
-			ABORT_PARSE;
-		      }
+		    if (check_end ($5, token::while_end))
+		      ABORT_PARSE;
 		    looping--;
 		    $$ = new tree_while_command ($2, $4);
 		  }
 		| FOR variable '=' expression optsep opt_list END
 		  {
-		    if ($7 != for_end && $7 != simple_end)
-		      {
-			yyerror ("parse error");
-			end_error ("for", $7);
-			ABORT_PARSE;
-		      }
+		    if (check_end ($7, token::for_end))
+		      ABORT_PARSE;
 		    looping--;
 		    $$ = new tree_for_command ($2, $4, $6);
 		  }
 		| IF expression optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
-		    if ($5 != if_end && $5 != simple_end)
-		      {
-			yyerror ("parse error");
-			end_error ("if", $5);
-			ABORT_PARSE;
-		      }
+		    if (check_end ($5, token::if_end))
+		      ABORT_PARSE;
 		    iffing--;
 		    $$ = new tree_if_command ($2, $4);
 		  }
 		| IF expression optsep opt_list ELSE optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
-		    if ($8 != if_end && $8 != simple_end)
-		      {
-			yyerror ("parse error");
-			end_error ("if", $8);
-			ABORT_PARSE;
-		      }
+		    if (check_end ($8, token::if_end))
+		      ABORT_PARSE;
 		    iffing--;
 		    tree_if_command *t1 = new tree_if_command ($7);
 		    $$ = t1->chain ($2, $4);
 		  }
 		| IF expression optsep opt_list elseif END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
-		    if ($6 != if_end && $6 != simple_end)
-		      {
-			yyerror ("parse error");
-			end_error ("if", $6);
-			ABORT_PARSE;
-		      }
+		    if (check_end ($6, token::if_end))
+		      ABORT_PARSE;
 		    iffing--;
 		    tree_if_command *t1 = $5->reverse ();
 		    // Add the if list to the new head of the elseif
 		    // list, and return the list.
 		    $$ = t1->chain ($2, $4);
 		  }
 		| IF expression optsep opt_list elseif ELSE optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
-		    if ($9 != if_end && $9 != simple_end)
-		      {
-			yyerror ("parse error");
-			end_error ("if", $9);
-			ABORT_PARSE;
-		      }
+		    if (check_end ($9, token::if_end))
+		      ABORT_PARSE;
 		    iffing--;
 		    // Add the else list to the head of the elseif list,
 		    // then reverse the list.
 		    tree_if_command *t1 = $5->chain ($8);
 		    t1 = t1->reverse ();
 		    // Add the if list to the new head of the elseif
 		    // list, and return the list.
 		    $$ = t1->chain ($2, $4);
@@ -694,134 +627,162 @@ sep		: ','
 		| sep '\n'
 		;
 
 screwed_again	: // empty
 		  { maybe_screwed_again++; }
 		;
 
 expression	: variable '=' expression
-		  { $$ = new tree_simple_assignment_expression ($1, $3); }
+		  { $$ = new tree_simple_assignment_expression
+		      ($1, $3, $2->line (), $2->column ()); }
 		| '[' screwed_again matrix_row SCREW_TWO '=' expression
 		  {
 
 // Will need a way to convert the matrix list to a list of
-// identifiers.  If that fails, we can abort here, without losing
+// identifiers.	 If that fails, we can abort here, without losing
 // anything -- no other possible syntax is valid if we've seen the
 // equals sign as the next token after the `]'.
 
 		    $$ = (tree_multi_assignment_expression *) NULL;
 		    maybe_screwed_again--;
 		    tree_matrix *tmp = ml.pop ();
 		    tmp = tmp->reverse ();
 		    tree_return_list *id_list = tmp->to_return_list ();
 		    if (id_list == NULL_TREE)
 		      {
 			yyerror ("parse error");
-		        error ("invalid identifier list for assignment");
+			error ("invalid identifier list for assignment");
 			$$ = (tree_multi_assignment_expression *) NULL;
 			ABORT_PARSE;
 		      }
 		    else
-		      $$ = new tree_multi_assignment_expression (id_list, $6);
+		      $$ = new tree_multi_assignment_expression
+			(id_list, $6, $5->line (), $5->column ());
 		  }
 		| NUM '=' expression
 		  {
 		    yyerror ("parse error");
 		    error ("invalid assignment to a number");
 		    $$ = (tree_simple_assignment_expression *) NULL;
 		    ABORT_PARSE;
 		  }
 		| simple_expr
 		  { $$ = $1; }
 		;
 
 simple_expr	: simple_expr1
 		  { $$ = $1; }
 		| identifier PLUS_PLUS
-		  { $$ = new tree_postfix_expression ($1, tree::increment); }
+		  { $$ = new tree_postfix_expression
+		      ($1, tree::increment, $2->line (), $2->column ()); }
 		| identifier MINUS_MINUS
-		  { $$ = new tree_postfix_expression ($1, tree::decrement); }
+		  { $$ = new tree_postfix_expression
+		      ($1, tree::decrement, $2->line (), $2->column ()); }
 		| simple_expr QUOTE
-		  { $$ = new tree_unary_expression ($1, tree::hermitian); }
+		  { $$ = new tree_unary_expression
+		      ($1, tree::hermitian, $2->line (), $2->column ()); }
 		| simple_expr TRANSPOSE
-		  { $$ = new tree_unary_expression ($1, tree::transpose); }
+		  { $$ = new tree_unary_expression
+		      ($1, tree::transpose, $2->line (), $2->column ()); }
 		| simple_expr POW simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::power); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::power, $2->line (), $2->column ()); }
 		| simple_expr EPOW simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::elem_pow); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::elem_pow, $2->line (), $2->column ()); }
 		| simple_expr '+' simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::add); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::add, $2->line (), $2->column ()); }
 		| simple_expr '-' simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::subtract); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::subtract, $2->line (), $2->column ()); }
 		| simple_expr '*' simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::multiply); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::multiply, $2->line (), $2->column ()); }
 		| simple_expr '/' simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::divide); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::divide, $2->line (), $2->column ()); }
 		| simple_expr EMUL simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::el_mul); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::el_mul, $2->line (), $2->column ()); }
 		| simple_expr EDIV simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::el_div); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::el_div, $2->line (), $2->column ()); }
 		| simple_expr LEFTDIV simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::leftdiv); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::leftdiv, $2->line (), $2->column ()); }
 		| simple_expr ELEFTDIV simple_expr
-		  { $$ = new tree_binary_expression ($1, $3,
-						     tree::el_leftdiv); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::el_leftdiv, $2->line (), $2->column ()); }
 		| simple_expr EXPR_LT simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::cmp_lt); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::cmp_lt, $2->line (), $2->column ()); }
 		| simple_expr EXPR_LE simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::cmp_le); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::cmp_le, $2->line (), $2->column ()); }
 		| simple_expr EXPR_EQ simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::cmp_eq); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::cmp_eq, $2->line (), $2->column ()); }
 		| simple_expr EXPR_GE simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::cmp_ge); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::cmp_ge, $2->line (), $2->column ()); }
 		| simple_expr EXPR_GT simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::cmp_gt); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::cmp_gt, $2->line (), $2->column ()); }
 		| simple_expr EXPR_NE simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::cmp_ne); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::cmp_ne, $2->line (), $2->column ()); }
 		| simple_expr EXPR_AND simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::and); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::and, $2->line (), $2->column ()); }
 		| simple_expr EXPR_OR simple_expr
-		  { $$ = new tree_binary_expression ($1, $3, tree::or); }
+		  { $$ = new tree_binary_expression
+		      ($1, $3, tree::or, $2->line (), $2->column ()); }
 		;
 
 simple_expr1	: NUM
-		  { $$ = new tree_constant ($1); }
+		  { $$ = new tree_constant ($1->number ()); }
 		| IMAG_NUM
-		  { $$ = new tree_constant (Complex (0.0, $1)); }
+		  { $$ = new tree_constant (Complex (0.0, $1->number ())); }
 		| TEXT
-		  { $$ = new tree_constant ($1); }
+		  { $$ = new tree_constant ($1->string ()); }
 		| word_list_cmd
 		  { $$ = $1; }
 		| '(' expression ')'
 		  {
 		    if ($2->is_assignment_expression ())
 		      ((tree_assignment_expression *) $2) -> in_parens++;
 		    $$ = $2;
 		  }
 		| variable
 		  { $$ = $1; }
 		| matrix
 		  { $$ = $1; }
 		| colon_expr
 		  { $$ = $1; }
 		| PLUS_PLUS identifier %prec UNARY
-		  { $$ = new tree_prefix_expression ($2, tree::increment); }
+		  { $$ = new tree_prefix_expression
+		      ($2, tree::increment, $1->line (), $1->column ()); }
 		| MINUS_MINUS identifier %prec UNARY
-		  { $$ = new tree_prefix_expression ($2, tree::decrement); }
+		  { $$ = new tree_prefix_expression
+		      ($2, tree::decrement, $1->line (), $1->column ()); }
 		| EXPR_NOT simple_expr
-		  { $$ = new tree_unary_expression ($2, tree::not); }
+		  { $$ = new tree_unary_expression
+		      ($2, tree::not, $1->line (), $1->column ()); }
 		| '+' simple_expr %prec UNARY
 		  { $$ = $2; }
 		| '-' simple_expr %prec UNARY
-		  { $$ = new tree_unary_expression ($2, tree::uminus); }
+		  { $$ = new tree_unary_expression
+		      ($2, tree::uminus, $1->line (), $1->column ()); }
 		;
 
 colon_expr	: simple_expr ':' simple_expr
-		  { $$ = new tree_colon_expression ($1, $3); }
+		  { $$ = new tree_colon_expression
+		      ($1, $3, $2->line (), $2->column ()); }
 		| colon_expr ':' simple_expr
 		  {
 		    $$ = $1->chain ($3);
 		    if ($$ == (tree_colon_expression *) NULL)
 		      {
 			yyerror ("parse error");
 			ABORT_PARSE;
 		      }
@@ -833,45 +794,43 @@ word_list_cmd	: identifier word_list
 		| CLEAR
 		  {
 		    if (defining_func)
 		      {
 			yyerror ("parse error");
 			error ("clear: invalid within function body");
 			ABORT_PARSE;
 		      }
-		    symbol_record *sr = global_sym_tab->lookup ("clear", 1, 0);
-		    assert (sr != (symbol_record *) NULL);
-		    tree_identifier *tmp = new tree_identifier (sr);
+		    tree_identifier *tmp = new tree_identifier
+		      ($1->sym_rec (), $1->line (), $1->column ());
 		    $$ = new tree_word_list_command (tmp,
 						     (tree_word_list *) NULL);
 		  }
 		| CLEAR word_list
 		  {
 		    if (defining_func)
 		      {
 			yyerror ("parse error");
 			error ("clear: invalid within function body");
 			ABORT_PARSE;
 		      }
-		    symbol_record *sr = global_sym_tab->lookup ("clear", 1, 0);
-		    assert (sr != (symbol_record *) NULL);
-		    tree_identifier *tmp = new tree_identifier (sr);
+		    tree_identifier *tmp = new tree_identifier
+		      ($1->sym_rec (), $1->line (), $1->column ());
 		    $$ = new tree_word_list_command (tmp, $2);
 		  }
 		;
 
 word_list	: word_list1
 		  { $$ = $1->reverse (); }
 		;
 
 word_list1	: TEXT
-		  { $$ = new tree_word_list ($1); }
+		  { $$ = new tree_word_list ($1->string ()); }
 		| word_list1 TEXT
-		  { $$ = $1->chain ($2); }
+		  { $$ = $1->chain ($2->string ()); }
 		;
 
 // This is truly disgusting.
 
 g_symtab	: // empty
 		  { curr_sym_tab = global_sym_tab; }
 		;
 
@@ -898,17 +857,18 @@ func_def	: FCN g_symtab are_we_screwed f
 		    curr_sym_tab = top_level_sym_tab;
 		    defining_func = 0;
 		    $$ = (tree_function *) NULL;
 		  }
 		;
 
 func_def1	: SCREW safe g_symtab '=' func_def2
 		  {
-		    tree_identifier *tmp = new tree_identifier ($1);
+		    tree_identifier *tmp = new tree_identifier
+		      ($1->sym_rec (), $1->line (), $1->column ());
 		    tree_parameter_list *tpl = new tree_parameter_list (tmp);
 		    tpl = tpl->reverse ();
 		    tpl->mark_as_formal_parameters ();
 		    $$ = $5->define_ret_list (tpl);
 		  }
 		| func_def1a ']' g_symtab '=' func_def2
 		  {
 		    tree_parameter_list *tpl = $1->reverse ();
@@ -953,16 +913,17 @@ func_def2	: identifier safe local_symtab
 			  warning ("function `%s' defined within\
  script file `%s.m'", id_name, curr_m_file_name);
 
 			$1->define ($4);
 			$1->document (help_buf);
 			top_level_sym_tab->clear (id_name);
 		      }
 
+		    $4->stash_function_name (id_name);
 		    $$ = $4;
 		  }
 		;
 
 func_def3	: param_list optsep opt_list fcn_end_or_eof
 		  {
 		    tree_function *fcn = new tree_function ($3, curr_sym_tab);
 		    $$ = fcn->define_param_list ($1);
@@ -970,22 +931,18 @@ func_def3	: param_list optsep opt_list f
 		| '(' ')' optsep opt_list fcn_end_or_eof
 		  { $$ = new tree_function ($4, curr_sym_tab); }
 		| optsep opt_list fcn_end_or_eof
 		  { $$ = new tree_function ($2, curr_sym_tab); }
 		;
 
 fcn_end_or_eof	: END
 		  {
-		    if ($1 != function_end && $1 != simple_end)
-		      {
-			yyerror ("parse error");
-			end_error ("function", $1);
+		    if (check_end ($1, token::function_end))
 			ABORT_PARSE;
-		      }
 
 		    if (reading_m_file)
 		      check_for_garbage_after_fcn_def ();
 		  }
 		| END_OF_INPUT
 		  {
 		    if (! (reading_m_file || reading_script_file))
 		      YYABORT;
@@ -1030,17 +987,18 @@ param_list1	: '(' identifier
 		| param_list1 ',' error
 		  {
 		    error ("parameter lists may only contain identifiers");
 		    $$ = (tree_parameter_list *) NULL;
 		  }
 		;
 
 identifier	: NAME
-		  { $$ = new tree_identifier ($1); }
+		  { $$ = new tree_identifier
+		      ($1->sym_rec (), $1->line (), $1->column ()); }
 
 arg_list	: arg_list1
 		  { $$ = $1->reverse (); }
 		;
 
 arg_list1	: ':'
 		  {
 		    tree_constant *colon;
@@ -1096,17 +1054,17 @@ rows		: matrix_row
 		;
 
 matrix_row	: expression		// First element on row.
 		  {
 		    if (mlnm.top ())
 		      {
 			mlnm.pop ();
 			mlnm.push (0);
-		        tree_matrix *tmp = new tree_matrix ($1, tree::md_none);
+			tree_matrix *tmp = new tree_matrix ($1, tree::md_none);
 			ml.push (tmp);
 		      }
 		    else
 		      {
 			tree_matrix *tmp = ml.pop ();
 			tmp = tmp->chain ($1, tree::md_down);
 			ml.push (tmp);
 		      }
@@ -1121,17 +1079,17 @@ matrix_row	: expression		// First elemen
 		;
 
 %%
 
 static void
 yyerror (char *s)
 {
   char *line = current_input_line;
-  int err_col = current_input_column;
+  int err_col = current_input_column - 1;
   if (err_col == 0)
     err_col = strlen (current_input_line) + 1;
 
 // Print a message like `parse error'.
   fprintf (stderr, "\n%s", s);
 
 // Maybe print the line number and file name.
   if (reading_m_file || reading_script_file)
@@ -1147,35 +1105,72 @@ yyerror (char *s)
 
 // Print the line, maybe with a pointer near the error token.
   if (err_col > len)
     fprintf (stderr, ":\n\n  %s\n\n", line);
   else
     fprintf (stderr, ":\n\n  %s\n  %*s\n\n", line, err_col, "^");
 }
 
+static int
+check_end (token *tok, token::end_tok_type expected)
+{
+  token::end_tok_type ettype = tok->ettype ();
+  if (ettype != expected && ettype != token::simple_end)
+    {
+      yyerror ("parse error");
+
+      int l = tok->line ();
+      int c = tok->column ();
+
+      switch (expected)
+	{
+	case token::for_end:
+	  end_error ("for", ettype, l, c);
+	  break;
+	case token::function_end:
+	  end_error ("function", ettype, l, c);
+	  break;
+	case token::if_end:
+	  end_error ("if", ettype, l, c);
+	  break;
+	case token::while_end:
+	  end_error ("while", ettype, l, c);
+	  break;
+	default:
+	  panic_impossible ();
+	  break;
+	}
+      return 1;
+    }
+  else
+    return 0;
+}
+
 static void
-end_error (char *type, end_tok_type ettype)
+end_error (char *type, token::end_tok_type ettype, int l, int c)
 {
+  static char *fmt = "%s command matched by `%s' near line %d column %d";
+
   switch (ettype)
     {
-    case simple_end:
-      error ("%s command matched by `end'", type);
+    case token::simple_end:
+      error (fmt, type, "end", l, c);
       break;
-    case for_end:
-      error ("%s command matched by `endfor'", type);
+    case token::for_end:
+      error (fmt, type, "endfor", l, c);
       break;
-    case function_end:
-      error ("%s command matched by `endfunction'", type);
+    case token::function_end:
+      error (fmt, type, "endfunction", l, c);
       break;
-    case if_end:
-      error ("%s command matched by `endif'", type);
+    case token::if_end:
+      error (fmt, type, "endif", l, c);
       break;
-    case while_end:
-      error ("%s command matched by `endwhile'", type);
+    case token::while_end:
+      error (fmt, type, "endwhile", l, c); 
       break;
     default:
       panic_impossible ();
       break;
     }
 }
 
 /*
diff --git a/src/pt-base.h b/src/pt-base.h
--- a/src/pt-base.h
+++ b/src/pt-base.h
@@ -146,16 +146,23 @@ public:
   virtual tree_constant eval (int argc, char **argv, int print);
 
   virtual tree_constant *eval (tree_constant *args, int n_in, int nout,
 			       int print)
     { assert (0); return NULL_TREE_CONST; }
 
   virtual int save (ostream& os, int mark_as_global = 0)
     { assert (0); return 0; }
+
+  virtual int line (void) { return line_num; }
+  virtual int column (void) { return column_num; }
+
+protected:
+  int line_num;
+  int column_num;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -860,44 +860,44 @@ tree_constant_rep::make_numeric (int for
       break;
     }
   return retval;
 }
 
 tree_constant
 do_binary_op (tree_constant& a, tree_constant& b, tree::expression_type t)
 {
+  tree_constant ans;
+
   int first_empty = (a.rows () == 0 || a.columns () == 0);
   int second_empty = (b.rows () == 0 || b.columns () == 0);
 
   if (first_empty || second_empty)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("binary operation on empty matrix");
       else if (flag == 0)
 	{
 	  error ("invalid binary operation on empty matrix");
-	  jump_to_top_level ();
+	  return ans;
 	}
     }
 
   tree_constant tmp_a = a.make_numeric ();
   tree_constant tmp_b = b.make_numeric ();
 
   tree_constant_rep::constant_type a_type = tmp_a.const_type ();
   tree_constant_rep::constant_type b_type = tmp_b.const_type ();
 
   double d1, d2;
   Matrix m1, m2;
   Complex c1, c2;
   ComplexMatrix cm1, cm2;
 
-  tree_constant ans;
-
   switch (a_type)
     {
     case tree_constant_rep::scalar_constant:
       d1 = tmp_a.double_value ();
       switch (b_type)
 	{
 	case tree_constant_rep::scalar_constant:
 	  d2 = tmp_b.double_value ();
@@ -1005,32 +1005,32 @@ do_binary_op (tree_constant& a, tree_con
       break;
     }
   return ans;
 }
 
 tree_constant
 do_unary_op (tree_constant& a, tree::expression_type t)
 {
+  tree_constant ans;
+
   if (a.rows () == 0 || a.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("unary operation on empty matrix");
       else if (flag == 0)
 	{
 	  error ("invalid unary operation on empty matrix");
-	  jump_to_top_level ();
+	  return ans;
 	}
     }
 
   tree_constant tmp_a = a.make_numeric ();
 
-  tree_constant ans;
-
   switch (tmp_a.const_type ())
     {
     case tree_constant_rep::scalar_constant:
       ans = do_unary_op (tmp_a.double_value (), t);
       break;
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp_a.matrix_value ();
@@ -1113,16 +1113,19 @@ tree_constant_rep::bump_value (tree::exp
       panic_impossible ();
       break;
     }
 }
 
 void
 tree_constant_rep::eval (int print)
 {
+  if (error_state)
+    return;
+
   switch (type_tag)
     {
     case complex_scalar_constant:
       if (imag (*complex_scalar) == 0.0)
 	{
 	  double d = real (*complex_scalar);
 	  delete complex_scalar;
 	  scalar = d;
@@ -1144,21 +1147,54 @@ tree_constant_rep::eval (int print)
     case range_constant:
     case magic_colon:
       break;
     default:
       panic_impossible ();
       break;
     }
 
+  int nr = rows ();
+  int nc = columns ();
+
+  if (nr == 1 && nc == 1)
+    {
+      switch (type_tag)
+	{
+	case matrix_constant:
+	  {
+	    double d = matrix->elem (0, 0);
+	    delete matrix;
+	    scalar = d;
+	    type_tag = scalar_constant;
+	  }
+	  break;
+	case complex_matrix_constant:
+	  {
+	    Complex c = complex_matrix->elem (0, 0);
+	    delete complex_matrix;
+	    complex_scalar = new Complex (c);
+	    type_tag = complex_scalar_constant;
+	  }
+	  break;
+	case range_constant:
+	  {
+	    double d = range->base ();
+	    delete range;
+	    scalar = d;
+	    type_tag = scalar_constant;
+	  }
+	  break;
+	default:
+	  break;
+	}
+    }
+
   if (print)
     {
-      int nr = rows ();
-      int nc = columns ();
-
       ostrstream output_buf;
       switch (type_tag)
 	{
 	case scalar_constant:
 	  octave_print_internal (output_buf, scalar);
 	  break;
 	case matrix_constant:
 	  if (nr == 0 || nc == 0)
@@ -1201,16 +1237,19 @@ tree_constant_rep::eval (int print)
       maybe_page_output (output_buf);
     }
 }
 
 tree_constant *
 tree_constant_rep::eval (tree_constant *args, int nargin, int nargout,
 			 int print)
 {
+  if (error_state)
+    return NULL_TREE_CONST;
+
   tree_constant *retval = new tree_constant [2];
   switch (type_tag)
     {
     case complex_scalar_constant:
     case scalar_constant:
       retval[0] = do_scalar_index (args, nargin);
       break;
     case complex_matrix_constant:
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -76,16 +76,19 @@ tree_plot_command::~tree_plot_command (v
   delete plot_list;
 }
 
 tree_constant
 tree_plot_command::eval (int print)
 {
   tree_constant retval;
 
+  if (error_state)
+    return retval;
+
   ostrstream plot_buf;
 
   switch (ndim)
     {
     case 2:
       plot_buf << "plot";
       break;
     case 3:
diff --git a/src/tc-assign.cc b/src/tc-assign.cc
--- a/src/tc-assign.cc
+++ b/src/tc-assign.cc
@@ -83,17 +83,17 @@ tree_constant_rep::do_scalar_assignment 
 	  else if (rhs.const_type () == complex_scalar_constant)
 	    {
 	      complex_scalar = new Complex (rhs.complex_value ());
 	      type_tag = complex_scalar_constant;
 	    }
 	  else
 	    {
 	      error ("invalid assignment to scalar");
-	      jump_to_top_level ();
+	      return;
 	    }
 	}
       else
 	{
 	  if (rhs.const_type () == scalar_constant)
 	    {
 	      scalar = rhs.double_value ();
 	      type_tag = scalar_constant;
@@ -101,46 +101,60 @@ tree_constant_rep::do_scalar_assignment 
 	  else if (rhs.const_type () == complex_scalar_constant)
 	    {
 	      *complex_scalar = rhs.complex_value ();
 	      type_tag = complex_scalar_constant;
 	    }
 	  else
 	    {
 	      error ("invalid assignment to scalar");
-	      jump_to_top_level ();
+	      return;
 	    }
 	}
     }
   else if (user_pref.resize_on_range_error)
     {
+      tree_constant_rep::constant_type old_type_tag = type_tag;
+
       if (type_tag == complex_scalar_constant)
 	{
 	  Complex *old_complex = complex_scalar;
 	  complex_matrix = new ComplexMatrix (1, 1, *complex_scalar);
 	  type_tag = complex_matrix_constant;
 	  delete old_complex;
 	}
       else if (type_tag == scalar_constant)
 	{
 	  matrix = new Matrix (1, 1, scalar);
 	  type_tag = matrix_constant;
 	}
+
+// If there is an error, the call to do_matrix_assignment should not
+// destroy the current value.  tree_constant_rep::eval(int) will take
+// care of converting single element matrices back to scalars.
+
       do_matrix_assignment (rhs, args, nargs);
+
+// I don't think there's any other way to revert back to unknown
+// constant types, so here it is.
+
+      if (old_type_tag == unknown_constant && error_state)
+	{
+	  if (type_tag == matrix_constant)
+	    delete matrix;
+	  else if (type_tag == complex_matrix_constant)
+	    delete complex_matrix;
+
+	  type_tag = unknown_constant;
+	}
     }
   else if (nargs > 3 || nargs < 2)
-    {
-      error ("invalid index expression for scalar type");
-      jump_to_top_level ();
-    }
+    error ("invalid index expression for scalar type");
   else
-    {
-      error ("index invalid or out of range for scalar type");
-      jump_to_top_level ();
-    }
+    error ("index invalid or out of range for scalar type");
 }
 
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant *args, int nargs)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == matrix_constant
@@ -223,53 +237,54 @@ tree_constant_rep::fortran_style_matrix_
   int rhs_nc = rhs.columns ();
 
   switch (itype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int i = NINT (tmp_i.double_value ());
-	index_check (i-1, "");
+	if (index_check (i-1, "") < 0)
+	  return;
 	if (nr <= 1 || nc <= 1)
 	  maybe_resize (i-1);
-	else
-	  range_max_check (i-1, nr * nc);
+	else if (range_max_check (i-1, nr * nc) < 0)
+	  return;
 
 	nr = rows ();
 	nc = columns ();
 
 	if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
 	  {
 	    error ("for A(int) = X: X must be a scalar");
-	    jump_to_top_level ();
+	    return;
 	  }
 	int ii = fortran_row (i, nr) - 1;
 	int jj = fortran_column (i, nr) - 1;
 	do_matrix_assignment (rhs, ii, jj);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	int len = nr * nc;
 	idx_vector ii (mi, 1, "", len);  // Always do fortran indexing here...
 	int imax = ii.max ();
 
 	if (nr <= 1 || nc <= 1)
 	  maybe_resize (imax-1);
-	else
-	  range_max_check (imax-1, len);
+	else if (range_max_check (imax-1, len) < 0)
+	  return;
 
 	if (ii.capacity () != rhs_nr * rhs_nc)
 	  {
 	    error ("A(matrix) = X: X and matrix must have the same\
  number of elements"); 
-	    jump_to_top_level ();
+	    return;
 	  }
 	fortran_style_matrix_assignment (rhs, ii);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
@@ -298,17 +313,18 @@ tree_constant_rep::vector_assignment (tr
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
   switch (itype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int i = tree_to_mat_idx (tmp_i.double_value ());
-	index_check (i, "");
+	if (index_check (i, "") < 0)
+	  return;
 	do_vector_assign (rhs, i);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	int len = nr * nc;
@@ -324,30 +340,31 @@ tree_constant_rep::vector_assignment (tr
 	Range ri = tmp_i.range_value ();
 	if (rows () == 2 && is_zero_one (ri))
 	  {
 	    do_vector_assign (rhs, 1);
 	  }
 	else
 	  {
 	    int imax;
-	    index_check (ri, imax, "");
+	    if (index_check (ri, imax, "") < 0)
+	      return;
 	    do_vector_assign (rhs, ri, imax);
 	  }
       }
       break;
     case magic_colon:
       {
 	int rhs_nr = rhs.rows ();
 	int rhs_nc = rhs.columns ();
 
 	if (! indexed_assign_conforms (nr, nc, rhs_nr, rhs_nc))
 	  {
 	    error ("A(:) = X: X and A must have the same dimensions");
-	    jump_to_top_level ();
+	    return;
 	  }
 	do_matrix_assignment (rhs, magic_colon, magic_colon);
       }
       break;
     default:
       panic_impossible ();
       break;
     }
@@ -358,54 +375,45 @@ tree_constant_rep::check_vector_assign (
 					int ilen, char *rm)
 {
   int nr = rows ();
   int nc = columns ();
 
   if (nr == 1 && nc == 1)  // No orientation to preserve
     {
       if (! ( ilen == rhs_nr || ilen == rhs_nc))
-	{
-	  error ("A(%s) = X: X and %s must have the same number of\
+	error ("A(%s) = X: X and %s must have the same number of\
  elements", rm, rm); 
-	  jump_to_top_level ();
-	}
     }
   else if (nr == 1)  // Preserve current row orientation
     {
       if (! (rhs_nr == 1 && rhs_nc == ilen))
-	{
-	  error ("A(%s) = X: where A is a row vector, X must also be a\
+	error ("A(%s) = X: where A is a row vector, X must also be a\
  row vector with the same number of elements as %s", rm, rm); 
-	  jump_to_top_level ();
-	}
     }
   else if (nc == 1)  // Preserve current column orientation
     {
       if (! (rhs_nc == 1 && rhs_nr == ilen))
-	{
-	  error ("A(%s) = X: where A is a column vector, X must also\
+	error ("A(%s) = X: where A is a column vector, X must also\
  be a column vector with the same number of elements as %s", rm, rm); 
-	  jump_to_top_level ();
-	}
     }
   else
     panic_impossible ();
 }
 
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, int i)
 {
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
   if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
     {
       error ("for A(int) = X: X must be a scalar");
-      jump_to_top_level ();
+      return;
     }
 
   maybe_resize (i);
 
   int nr = rows ();
   int nc = columns ();
 
   if (nr == 1)
@@ -525,17 +533,17 @@ tree_constant_rep::fortran_style_matrix_
 	  return;
 	}
       else
 	panic_impossible ();
     }
   else if (nr*nc != rhs_size)
     {
       error ("A(:) = X: X and A must have the same number of elements");
-      jump_to_top_level ();
+      return;
     }
 
   if (rhs.const_type () == matrix_constant)
     {
       double *cop_out = rhs_m.fortran_vec ();
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  matrix->elem (i, j) = *cop_out++;
@@ -583,41 +591,36 @@ tree_constant_rep::fortran_style_matrix_
 	      int ii = fortran_row (i.elem (k) + 1, nr) - 1;
 	      int jj = fortran_column (i.elem (k) + 1, nr) - 1;
 
 	      complex_matrix->elem (ii, jj) = *cop_out++;
 	    }
 	}
     }
   else
-    {
-      error ("number of rows and columns must match for indexed assignment");
-      jump_to_top_level ();
-    }
+    error ("number of rows and columns must match for indexed assignment");
 }
 
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant& i_arg, 
 					 tree_constant& j_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
-// index_check() and matrix_to_index_vector() jump to the top level on
-// errors.
-
   switch (itype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int i = tree_to_mat_idx (tmp_i.double_value ());
-	index_check (i, "row");
+	if (index_check (i, "row") < 0)
+	  return;
 	do_matrix_assignment (rhs, i, j_arg);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	idx_vector iv (mi, user_pref.do_fortran_indexing, "row", rows ());
@@ -632,17 +635,18 @@ tree_constant_rep::do_matrix_assignment 
 	Range ri = tmp_i.range_value ();
 	if (rows () == 2 && is_zero_one (ri))
 	  {
 	    do_matrix_assignment (rhs, 1, j_arg);
 	  }
 	else
 	  {
 	    int imax;
-	    index_check (ri, imax, "row");
+	    if (index_check (ri, imax, "row") < 0)
+	      return;
 	    do_matrix_assignment (rhs, ri, imax, j_arg);
 	  }
       }
       break;
     case magic_colon:
       do_matrix_assignment (rhs, magic_colon, j_arg);
       break;
     default:
@@ -657,71 +661,70 @@ tree_constant_rep::do_matrix_assignment 
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
-// index_check() and matrix_to_index_vector() jump to the top level on
-// errors.
-
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
+	if (index_check (j, "column") < 0)
+	  return;
 	if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
 	  {
 	    error ("A(int,int) = X, X must be a scalar");
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (i, j);
 	do_matrix_assignment (rhs, i, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
 	if (! indexed_assign_conforms (1, jv.capacity (), rhs_nr, rhs_nc))
 	  {
 	    error ("A(int,matrix) = X: X must be a row vector with the\
  same number of elements as matrix"); 
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (i, jv.max ());
 	do_matrix_assignment (rhs, i, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
 	Range rj = tmp_j.range_value ();
 	if (! indexed_assign_conforms (1, rj.nelem (), rhs_nr, rhs_nc))
 	  {
 	    error ("A(int,range) = X: X must be a row vector with the\
  same number of elements as range"); 
-	    jump_to_top_level ();
+	    return;
 	  }
 	if (columns () == 2 && is_zero_one (rj) && rhs_nc == 1)
 	  {
 	    do_matrix_assignment (rhs, i, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
+	    if (index_check (rj, jmax, "column") < 0)
+	      return;
 	    maybe_resize (i, jmax);
 	    do_matrix_assignment (rhs, i, rj);
 	  }
       }
       break;
     case magic_colon:
       {
 	int nc = columns ();
@@ -740,17 +743,17 @@ tree_constant_rep::do_matrix_assignment 
 	    maybe_resize (i, rhs_nc-1);
 	  }
 	else if (indexed_assign_conforms (1, nc, rhs_nr, rhs_nc))
 	  maybe_resize (i, nc-1);
 	else
 	  {
 	    error ("A(int,:) = X: X must be a row vector with the\
  same number of columns as A"); 
-	    jump_to_top_level ();
+	    return;
 	  }
 
 	do_matrix_assignment (rhs, i, magic_colon);
       }
       break;
     default:
       panic_impossible ();
       break;
@@ -763,31 +766,29 @@ tree_constant_rep::do_matrix_assignment 
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
-// index_check() and matrix_to_index_vector() jump to the top level on
-// errors.
-
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
+	if (index_check (j, "column") < 0)
+	  return;
 	if (! indexed_assign_conforms (iv.capacity (), 1, rhs_nr, rhs_nc))
 	  {
 	    error ("A(matrix,int) = X: X must be a column vector with\
  the same number of elements as matrix");  
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (iv.max (), j);
 	do_matrix_assignment (rhs, iv, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
@@ -795,17 +796,17 @@ tree_constant_rep::do_matrix_assignment 
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
 	if (! indexed_assign_conforms (iv.capacity (), jv.capacity (),
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(r_matrix,c_matrix) = X: the number of rows in X\
  must match the number of elements in r_matrix and the number of\
  columns in X must match the number of elements in c_matrix");  
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (iv.max (), jv.max ());
 	do_matrix_assignment (rhs, iv, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
@@ -813,40 +814,41 @@ tree_constant_rep::do_matrix_assignment 
       {
 	Range rj = tmp_j.range_value ();
 	if (! indexed_assign_conforms (iv.capacity (), rj.nelem (),
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(matrix,range) = X: the number of rows in X must\
  match the number of elements in matrix and the number of columns in X\
  must match the number of elements in range");  
-	    jump_to_top_level ();
+	    return;
 	  }
 	if (columns () == 2 && is_zero_one (rj) && rhs_nc == 1)
 	  {
 	    do_matrix_assignment (rhs, iv, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
+	    if (index_check (rj, jmax, "column") < 0)
+	      return;
 	    maybe_resize (iv.max (), jmax);
 	    do_matrix_assignment (rhs, iv, rj);
 	  }
       }
       break;
     case magic_colon:
       {
 	int nc = columns ();
 	if (! indexed_assign_conforms (iv.capacity (), nc, rhs_nr, rhs_nc))
 	  {
 	    error ("A(matrix,:) = X: the number of rows in X must\
  match the number of elements in matrix, and the number of columns in\
  X must match the number of columns in A");
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (iv.max (), nc-1);
 	do_matrix_assignment (rhs, iv, magic_colon);
       }
       break;
     default:
       panic_impossible ();
       break;
@@ -860,32 +862,29 @@ tree_constant_rep::do_matrix_assignment 
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
-// index_check() and matrix_to_index_vector() jump to the top level on
-// errors.
-
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
+	if (index_check (j, "column") < 0)
+	  return;
 	if (! indexed_assign_conforms (ri.nelem (), 1, rhs_nr, rhs_nc))
 	  {
 	    error ("A(range,int) = X: X must be a column vector with\
  the same number of elements as range");
-	    jump_to_top_level ();
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (imax, j);
 	do_matrix_assignment (rhs, ri, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
@@ -893,17 +892,17 @@ tree_constant_rep::do_matrix_assignment 
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
 	if (! indexed_assign_conforms (ri.nelem (), jv.capacity (),
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(range,matrix) = X: the number of rows in X must\
  match the number of elements in range and the number of columns in X\
  must match the number of elements in matrix");
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (imax, jv.max ());
 	do_matrix_assignment (rhs, ri, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
@@ -911,40 +910,41 @@ tree_constant_rep::do_matrix_assignment 
       {
 	Range rj = tmp_j.range_value ();
 	if (! indexed_assign_conforms (ri.nelem (), rj.nelem (),
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(r_range,c_range) = X: the number of rows in X\
  must match the number of elements in r_range and the number of\
  columns in X must match the number of elements in c_range\n");
-	    jump_to_top_level ();
+	    return;
 	  }
 	if (columns () == 2 && is_zero_one (rj) && rhs_nc == 1)
 	  {
 	    do_matrix_assignment (rhs, ri, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
+	    if (index_check (rj, jmax, "column") < 0)
+	      return;
 	    maybe_resize (imax, jmax);
 	    do_matrix_assignment (rhs, ri, rj);
 	  }
       }
       break;
     case magic_colon:
       {
 	int nc = columns ();
 	if (! indexed_assign_conforms (ri.nelem (), nc, rhs_nr, rhs_nc))
 	  {
 	    error ("A(range,:) = X: the number of rows in X must match\
  the number of elements in range, and the number of columns in X must\
  match the number of columns in A");  
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (imax, nc-1);
 	do_matrix_assignment (rhs, ri, magic_colon);
       }
       break;
     default:
       panic_impossible ();
       break;
@@ -958,26 +958,24 @@ tree_constant_rep::do_matrix_assignment 
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
-// index_check() and matrix_to_index_vector() jump to the top level on
-// errors.
-
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
+	if (index_check (j, "column") < 0)
+	  return;
 	int nr = rows ();
 	if (nr == 0 && columns () == 0 && rhs_nc == 1)
 	  {
 	    if (rhs.is_complex_type ())
 	      {
 		complex_matrix = new ComplexMatrix ();
 		type_tag = complex_matrix_constant;
 	      }
@@ -989,17 +987,17 @@ tree_constant_rep::do_matrix_assignment 
 	    maybe_resize (rhs_nr-1, j);
 	  }
 	else if (indexed_assign_conforms (nr, 1, rhs_nr, rhs_nc))
 	  maybe_resize (nr-1, j);
 	else
 	  {
 	    error ("A(:,int) = X: X must be a column vector with the\
  same number of rows as A"); 
-	    jump_to_top_level ();
+	    return;
 	  }
 
 	do_matrix_assignment (rhs, magic_colon, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
@@ -1007,17 +1005,17 @@ tree_constant_rep::do_matrix_assignment 
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
 	int nr = rows ();
 	if (! indexed_assign_conforms (nr, jv.capacity (), rhs_nr, rhs_nc))
 	  {
 	    error ("A(:,matrix) = X: the number of rows in X must\
  match the number of rows in A, and the number of columns in X must\
  match the number of elements in matrix");   
-	    jump_to_top_level ();
+	    return;
 	  }
 	maybe_resize (nr-1, jv.max ());
 	do_matrix_assignment (rhs, magic_colon, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
@@ -1025,26 +1023,27 @@ tree_constant_rep::do_matrix_assignment 
       {
 	Range rj = tmp_j.range_value ();
 	int nr = rows ();
 	if (! indexed_assign_conforms (nr, rj.nelem (), rhs_nr, rhs_nc))
 	  {
 	    error ("A(:,range) = X: the number of rows in X must match\
  the number of rows in A, and the number of columns in X must match\
  the number of elements in range");
-	    jump_to_top_level ();
+	    return;
 	  }
 	if (columns () == 2 && is_zero_one (rj) && rhs_nc == 1)
 	  {
 	    do_matrix_assignment (rhs, magic_colon, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
+	    if (index_check (rj, jmax, "column") < 0)
+	      return;
 	    maybe_resize (nr-1, jmax);
 	    do_matrix_assignment (rhs, magic_colon, rj);
 	  }
       }
       break;
     case magic_colon:
 // a(:,:) = foo is equivalent to a = foo.
       do_matrix_assignment (rhs, magic_colon, magic_colon);
diff --git a/src/tc-extras.cc b/src/tc-extras.cc
--- a/src/tc-extras.cc
+++ b/src/tc-extras.cc
@@ -99,67 +99,73 @@ get_dimensions (tree_constant& a, char *
       nr = nc = NINT (tmp);
     }
   else
     {
       nr = a.rows ();
       nc = a.columns ();
     }
 
-  check_dimensions (nr, nc, warn_for); // No return on error.
+  check_dimensions (nr, nc, warn_for); // May set error_state.
 }
 
 static void
 get_dimensions (tree_constant& a, tree_constant& b, char *warn_for,
 		int& nr, int& nc)
 {
   tree_constant tmpa = a.make_numeric ();
   tree_constant tmpb = b.make_numeric ();
 
   if (tmpa.is_scalar_type () && tmpb.is_scalar_type ())
     {
       nr = NINT (tmpa.double_value ());
       nc = NINT (tmpb.double_value ());
 
-      check_dimensions (nr, nc, warn_for); // No return on error.
+      check_dimensions (nr, nc, warn_for); // May set error_state.
     }
   else
-    {
-      error ("%s: expecting two scalar arguments", warn_for);
-      jump_to_top_level ();
-    }
+    error ("%s: expecting two scalar arguments", warn_for);
 }
 
 tree_constant
 fill_matrix (tree_constant& a, double val, char *warn_for)
 {
   int nr, nc;
-  get_dimensions (a, warn_for, nr, nc); // No return on error.
+  get_dimensions (a, warn_for, nr, nc);
+
+  if (error_state)
+    return  tree_constant ();
 
   Matrix m (nr, nc, val);
 
   return tree_constant (m);
 }
 
 tree_constant
 fill_matrix (tree_constant& a, tree_constant& b, double val, char *warn_for)
 {
   int nr, nc;
-  get_dimensions (a, b, warn_for, nr, nc); // No return on error.
+  get_dimensions (a, b, warn_for, nr, nc); // May set error_state.
+
+  if (error_state)
+    return tree_constant ();
 
   Matrix m (nr, nc, val);
 
   return tree_constant (m);
 }
 
 tree_constant
 identity_matrix (tree_constant& a)
 {
   int nr, nc;
-  get_dimensions (a, "eye", nr, nc); // No return on error.
+  get_dimensions (a, "eye", nr, nc); // May set error_state.
+
+  if (error_state)
+    return tree_constant ();
 
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
 	m.elem (i, i) = 1.0;
@@ -167,17 +173,20 @@ identity_matrix (tree_constant& a)
 
   return tree_constant (m);
 }
 
 tree_constant
 identity_matrix (tree_constant& a, tree_constant& b)
 {
   int nr, nc;
-  get_dimensions (a, b, "eye", nr, nc);  // No return on error.
+  get_dimensions (a, b, "eye", nr, nc);  // May set error_state.
+
+  if (error_state)
+    return tree_constant ();
 
   Matrix m (nr, nc, 0.0);
 
   if (nr > 0 && nc > 0)
     {
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
 	m.elem (i, i) = 1.0;
diff --git a/src/tc-index.cc b/src/tc-index.cc
--- a/src/tc-index.cc
+++ b/src/tc-index.cc
@@ -42,18 +42,16 @@ tree_constant_rep::valid_as_scalar_index
 	&& range->nelem () == 1 && NINT (range->base ()) == 1);
 
   return valid;
 }
 
 tree_constant
 tree_constant_rep::do_scalar_index (tree_constant *args, int nargs) 
 {
-  tree_constant retval;
-
   if (valid_scalar_indices (args, nargs))
     {
       if (type_tag == scalar_constant)
 	return tree_constant (scalar);
       else if (type_tag == complex_scalar_constant)
 	return tree_constant (*complex_scalar);
       else
 	panic_impossible ();
@@ -128,25 +126,23 @@ tree_constant_rep::do_scalar_index (tree
 		return tree_constant (cm);
 	      }
 	    else
 	      panic_impossible ();
 	  }
 	  break;
 	default:
 	  error ("illegal number of arguments for scalar type");
-	  jump_to_top_level ();
+	  return tree_constant ();
 	  break;
 	}
     }
 
   error ("index invalid or out of range for scalar type");
-  jump_to_top_level ();
-
-  return retval;
+  return tree_constant ();
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant *args, int nargin)
 {
   tree_constant retval;
 
   switch (nargin)
@@ -210,18 +206,20 @@ tree_constant_rep::fortran_style_matrix_
   switch (itype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int i = NINT (tmp_i.double_value ());
 	int ii = fortran_row (i, nr) - 1;
 	int jj = fortran_column (i, nr) - 1;
-	index_check (i-1, "");
-	range_max_check (i-1, nr * nc);
+	if (index_check (i-1, "") < 0)
+	  return tree_constant ();
+	if (range_max_check (i-1, nr * nc) < 0)
+	  return tree_constant ();
 	retval = do_matrix_index (ii, jj);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	if (mi.rows () == 0 || mi.columns () == 0)
@@ -233,21 +231,19 @@ tree_constant_rep::fortran_style_matrix_
 	  {
 // Yes, we really do want to call this with mi.
 	    retval = fortran_style_matrix_index (mi);
 	  }
       }
       break;
     case string_constant:
       gripe_string_invalid ();
-      jump_to_top_level ();
       break;
     case range_constant:
       gripe_range_invalid ();
-      jump_to_top_level ();
       break;
     case magic_colon:
       retval = do_matrix_index (magic_colon);
       break;
     default:
       panic_impossible ();
       break;
     }
@@ -329,17 +325,17 @@ tree_constant_rep::fortran_style_matrix_
 	}
     }
   else
     {
       if (index_nr == 0 || index_nc == 0)
 	error ("empty matrix invalid as index");
       else
 	error ("invalid matrix index");
-      jump_to_top_level ();
+      return tree_constant ();
     }
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_vector_index (tree_constant& i_arg)
 {
@@ -359,25 +355,28 @@ tree_constant_rep::do_vector_index (tree
   int swap_indices = (nr == 1);
   
   switch (itype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
         int i = tree_to_mat_idx (tmp_i.double_value ());
-        index_check (i, "");
+        if (index_check (i, "") < 0)
+	  return tree_constant ();
         if (swap_indices)
           {
-	    range_max_check (i, nc);
+	    if (range_max_check (i, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (0, i);
           }
         else
           {
-	    range_max_check (i, nr);
+	    if (range_max_check (i, nr) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (i, 0);
           }
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
         Matrix mi = tmp_i.matrix_value ();
@@ -387,22 +386,24 @@ tree_constant_rep::do_vector_index (tree
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
 	    idx_vector iv (mi, user_pref.do_fortran_indexing, "", len);
 	    int imax = iv.max ();
 	    if (swap_indices)
 	      {
-		range_max_check (imax, nc);
+		if (range_max_check (imax, nc) < 0)
+		  return tree_constant ();
 		retval = do_matrix_index (0, iv);
 	      }
 	    else
 	      {
-		range_max_check (imax, nr);
+		if (range_max_check (imax, nr) < 0)
+		  return tree_constant ();
 		retval = do_matrix_index (iv, 0);
 	      }
 	  }
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
@@ -414,25 +415,28 @@ tree_constant_rep::do_vector_index (tree
 	    if (swap_indices)
 	      retval = do_matrix_index (0, 1);
 	    else
 	      retval = do_matrix_index (1, 0);
 	  }
 	else
 	  {
 	    int imax;
-	    index_check (ri, imax, "");
+	    if (index_check (ri, imax, "") < 0)
+	      return tree_constant ();
 	    if (swap_indices)
 	      {
-		range_max_check (imax, nc);
+		if (range_max_check (imax, nc) < 0)
+		  return tree_constant ();
 		retval = do_matrix_index (0, ri);
 	      }
 	    else
 	      {
-		range_max_check (imax, nr);
+		if (range_max_check (imax, nr) < 0)
+		  return tree_constant ();
 		retval = do_matrix_index (ri, 0);
 	      }
 	  }
       }
       break;
     case magic_colon:
       if (swap_indices)
         retval = do_matrix_index (0, magic_colon);
@@ -457,17 +461,18 @@ tree_constant_rep::do_matrix_index (tree
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
   switch (itype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
         int i = tree_to_mat_idx (tmp_i.double_value ());
-	index_check (i, "row");
+	if (index_check (i, "row") < 0)
+	  return tree_constant ();
 	retval = do_matrix_index (i, j_arg);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	idx_vector iv (mi, user_pref.do_fortran_indexing, "row", rows ());
@@ -488,17 +493,18 @@ tree_constant_rep::do_matrix_index (tree
 	Range ri = tmp_i.range_value ();
 	if (rows () == 2 && is_zero_one (ri))
 	  {
 	    retval = do_matrix_index (1, j_arg);
 	  }
 	else
 	  {
 	    int imax;
-	    index_check (ri, imax, "row");
+	    if (index_check (ri, imax, "row") < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (ri, imax, j_arg);
 	  }
       }
       break;
     case magic_colon:
       retval = do_matrix_index (magic_colon, j_arg);
       break;
     default:
@@ -522,34 +528,37 @@ tree_constant_rep::do_matrix_index (int 
   int nc = columns ();
 
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
-	range_max_check (i, j, nr, nc);
+	if (index_check (j, "column") < 0)
+	  return tree_constant ();
+	if (range_max_check (i, j, nr, nc) < 0)
+	  return tree_constant ();
 	retval = do_matrix_index (i, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
-	    range_max_check (i, jv.max (), nr, nc);
+	    if (range_max_check (i, jv.max (), nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (i, jv);
 	  }
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
@@ -557,24 +566,27 @@ tree_constant_rep::do_matrix_index (int 
 	Range rj = tmp_j.range_value ();
 	if (nc == 2 && is_zero_one (rj))
 	  {
 	    retval = do_matrix_index (i, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
-	    range_max_check (i, jmax, nr, nc);
+	    if (index_check (rj, jmax, "column") < 0)
+	      return tree_constant ();
+	    if (range_max_check (i, jmax, nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (i, rj);
 	  }
       }
       break;
     case magic_colon:
-      range_max_check (i, 0, nr, nc);
+      if (range_max_check (i, 0, nr, nc) < 0)
+	return tree_constant ();
       retval = do_matrix_index (i, magic_colon);
       break;
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
@@ -593,34 +605,37 @@ tree_constant_rep::do_matrix_index (idx_
   int nc = columns ();
 
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
-	range_max_check (iv.max (), j, nr, nc);
+	if (index_check (j, "column") < 0)
+	  return tree_constant ();
+	if (range_max_check (iv.max (), j, nr, nc) < 0)
+	  return tree_constant ();
 	retval = do_matrix_index (iv, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
-	    range_max_check (iv.max (), jv.max (), nr, nc);
+	    if (range_max_check (iv.max (), jv.max (), nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (iv, jv);
 	  }
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
@@ -628,24 +643,27 @@ tree_constant_rep::do_matrix_index (idx_
 	Range rj = tmp_j.range_value ();
 	if (nc == 2 && is_zero_one (rj))
 	  {
 	    retval = do_matrix_index (iv, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
-	    range_max_check (iv.max (), jmax, nr, nc);
+	    if (index_check (rj, jmax, "column") < 0)
+	      return tree_constant ();
+	    if (range_max_check (iv.max (), jmax, nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (iv, rj);
 	  }
       }
       break;
     case magic_colon:
-      range_max_check (iv.max (), 0, nr, nc);
+      if (range_max_check (iv.max (), 0, nr, nc) < 0)
+	return tree_constant ();
       retval = do_matrix_index (iv, magic_colon);
       break;
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
@@ -664,34 +682,37 @@ tree_constant_rep::do_matrix_index (Rang
   int nc = columns ();
 
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
-	range_max_check (imax, j, nr, nc);
+	if (index_check (j, "column") < 0)
+	  return tree_constant ();
+	if (range_max_check (imax, j, nr, nc) < 0)
+	  return tree_constant ();
 	retval = do_matrix_index (ri, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
-	    range_max_check (imax, jv.max (), nr, nc);
+	    if (range_max_check (imax, jv.max (), nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (ri, jv);
 	  }
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
@@ -699,18 +720,20 @@ tree_constant_rep::do_matrix_index (Rang
 	Range rj = tmp_j.range_value ();
 	if (nc == 2 && is_zero_one (rj))
 	  {
 	    retval = do_matrix_index (ri, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
-	    range_max_check (imax, jmax, nr, nc);
+	    if (index_check (rj, jmax, "column") < 0)
+	      return tree_constant ();
+	    if (range_max_check (imax, jmax, nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (ri, rj);
 	  }
       }
       break;
     case magic_colon:
       retval = do_matrix_index (ri, magic_colon);
       break;
     default:
@@ -735,34 +758,37 @@ tree_constant_rep::do_matrix_index (tree
   int nc = columns ();
 
   switch (jtype)
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
-	index_check (j, "column");
-	range_max_check (0, j, nr, nc);
+	if (index_check (j, "column") < 0)
+	  return tree_constant ();
+	if (range_max_check (0, j, nr, nc) < 0)
+	  return tree_constant ();
 	retval = do_matrix_index (magic_colon, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
-	    range_max_check (0, jv.max (), nr, nc);
+	    if (range_max_check (0, jv.max (), nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (magic_colon, jv);
 	  }
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
@@ -770,18 +796,20 @@ tree_constant_rep::do_matrix_index (tree
 	Range rj = tmp_j.range_value ();
 	if (nc == 2 && is_zero_one (rj))
 	  {
 	    retval = do_matrix_index (magic_colon, 1);
 	  }
 	else
 	  {
 	    int jmax;
-	    index_check (rj, jmax, "column");
-	    range_max_check (0, jmax, nr, nc);
+	    if (index_check (rj, jmax, "column") < 0)
+	      return tree_constant ();
+	    if (range_max_check (0, jmax, nr, nc) < 0)
+	      return tree_constant ();
 	    retval = do_matrix_index (magic_colon, rj);
 	  }
       }
       break;
     case magic_colon:
       retval = do_matrix_index (magic_colon, magic_colon);
       break;
     default:
diff --git a/src/tc-inlines.h b/src/tc-inlines.h
--- a/src/tc-inlines.h
+++ b/src/tc-inlines.h
@@ -34,91 +34,97 @@ tree_to_mat_idx (double x)
 
 static inline int
 range_max_check (int i, int imax)
 {
   i++;
   if (i > imax)
     {
       error ("matrix index = %d exceeds maximum dimension = %d", i, imax);
-      jump_to_top_level ();
+      return -1;
     }
+  return 0;
 }
 
 static inline int
 range_max_check (int i, int j, int nr, int nc)
 {
+  int status = 0;
   i++;
   if (i > nr)
     {
       error ("matrix row index = %d exceeds maximum row dimension = %d",
 	     i, nr);
-      jump_to_top_level ();
+      status = -1;
     }
 
   j++;
   if (j > nc)
     {
       error ("matrix column index = %d exceeds maximum column dimension = %d",
-	     j, nc); 
-      jump_to_top_level ();
+	     j, nc);
+      status = -1;
     }
+  return status;
 }
 
 static inline int
 indexed_assign_conforms (int lhs_nr, int lhs_nc, int rhs_nr, int rhs_nc)
 {
   return (lhs_nr == rhs_nr && lhs_nc == rhs_nc);
 }
 
 static inline int
 is_zero_one (const Range& r)
 {
   double b = r.base ();
   double l = r.limit ();
   return (NINT (b) == 0 && NINT (l) == 1 && r.nelem () == 2);
 }
 
-static inline void
+static inline int
 index_check (int i, char *rc)
 {
   if (i < 0)
     {
       error ("invalid %s index = %d", rc, i+1);
-      jump_to_top_level ();
+      return -1;
     }
+  return 0;
 }
 
-static inline void
+static inline int
 index_check (const Range& r, int& max_val, char *rc)
 {
-  double b = r.base ();
-  int ib = tree_to_mat_idx (b);
-
   if (r.nelem () < 1)
     {
       error ("range invalid as %s index", rc);
-      jump_to_top_level ();
+      return -1;
     }
 
+  double b = r.base ();
+  int ib = tree_to_mat_idx (b);
+
   if (ib < 0)
     {
       error ("invalid %s index = %d", rc, ib+1);
-      jump_to_top_level ();
+      return -1;
     }
 
   double lim = r.limit ();
   max_val = tree_to_mat_idx (lim);
+
+  return 0;
 }
 
-static inline void
+static inline int
 index_check (const Range& r, char *rc)
 {
   int max_val;
-  index_check (r, max_val, rc);
+  return index_check (r, max_val, rc);
 }
 
 static inline int
 fortran_row (int i, int nr)
 {
   int r;
   r = i % nr;
   if (r == 0)
diff --git a/src/tree.h.old b/src/tree.h.old
--- a/src/tree.h.old
+++ b/src/tree.h.old
@@ -170,18 +170,18 @@ private:
  * Symbols from the symbol table.
  */
 class
 tree_identifier : public tree
 {
   friend class tree_index_expression;
 
 public:
-  tree_identifier (void);
-  tree_identifier (symbol_record *s);
+  tree_identifier (int l = -1, int c = -1);
+  tree_identifier (symbol_record *s, int l = -1, int c = -1);
 
   ~tree_identifier (void);
 
   int is_identifier (void);
 
   tree *def (void);
   char *name (void);
   symbol_record *symrec (void);
@@ -235,34 +235,40 @@ public:
   tree_function *define_ret_list (tree_parameter_list *t);
 
   void stash_m_file_name (char * s);
   void stash_m_file_time (time_t t);
 
   char *m_file_name (void);
   time_t time_parsed (void);
 
+  void stash_function_name (char *s);
+  char *function_name (void);
+
   tree_constant eval (int print);
 
   tree_constant *eval (int print, int nargout);
 
   tree_constant eval (int argc, char **argv, int print);
 
   tree_constant *eval (tree_constant *args, int n_in, int n_out, int print);
 
   int max_expected_args (void);
 
+  void traceback_error (void);
+
 private:
   int call_depth;
   tree_parameter_list *param_list;
   tree_parameter_list *ret_list;
   symbol_table *sym_tab;
   tree *cmd_list;
+  char *file_name;
+  char *fcn_name;
   time_t t_parsed;
-  char *file_name;
 };
 
 /*
  * A base class for expressions.
  */
 class
 tree_expression : public tree
 {
@@ -279,77 +285,89 @@ protected:
 
 /*
  * Prefix expressions.
  */
 class
 tree_prefix_expression : public tree_expression
 {
  public:
-  tree_prefix_expression (void);
-  tree_prefix_expression (tree_identifier *t, tree::expression_type et);
+  tree_prefix_expression (int l = -1, int c = -1);
+  tree_prefix_expression (tree_identifier *t, tree::expression_type et,
+			  int l = -1, int c = -1);
 
   ~tree_prefix_expression (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree_identifier *id;
 };
 
 /*
  * Postfix expressions.
  */
 class
 tree_postfix_expression : public tree_expression
 {
  public:
-  tree_postfix_expression (void);
-  tree_postfix_expression (tree_identifier *t, tree::expression_type et);
+  tree_postfix_expression (int l = -1, int c = -1);
+  tree_postfix_expression (tree_identifier *t, tree::expression_type et,
+			   int l = -1, int c = -1);
 
   ~tree_postfix_expression (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree_identifier *id;
 };
 
 /*
  * Unary expressions.
  */
 class
 tree_unary_expression : public tree_expression
 {
  public:
-  tree_unary_expression (void);
-  tree_unary_expression (tree *a, tree::expression_type t);
+  tree_unary_expression (int l = -1, int c = -1);
+  tree_unary_expression (tree *a, tree::expression_type t, int l = -1,
+			 int c = -1);
 
   ~tree_unary_expression (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree *op;
 };
 
 /*
  * Binary expressions.
  */
 class
 tree_binary_expression : public tree_expression
 {
  public:
-  tree_binary_expression (void);
-  tree_binary_expression (tree *a, tree *b, tree::expression_type t);
+  tree_binary_expression (int l = -1, int c = -1);
+  tree_binary_expression (tree *a, tree *b, tree::expression_type t,
+			  int l = -1, int c = -1);
 
   ~tree_binary_expression (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree *op1;
   tree *op2;
 };
 
 /*
  * Assignment expressions.
  */
@@ -370,96 +388,108 @@ public:
 
 /*
  * Simple assignment expressions.
  */
 class
 tree_simple_assignment_expression : public tree_assignment_expression
 {
  public:
-  tree_simple_assignment_expression (void);
-  tree_simple_assignment_expression (tree_identifier *i, tree *r);
-  tree_simple_assignment_expression (tree_index_expression *idx_expr, tree *r);
+  tree_simple_assignment_expression (int l = -1, int c = -1);
+  tree_simple_assignment_expression (tree_identifier *i, tree *r,
+				     int l = -1, int c = -1);
+  tree_simple_assignment_expression (tree_index_expression *idx_expr,
+				     tree *r, int l = -1, int c = -1);
 
   ~tree_simple_assignment_expression (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree_identifier *lhs;
   tree_argument_list *index;
   tree *rhs;
 };
 
 /*
  * Multi-valued assignment expressions.
  */
 class
 tree_multi_assignment_expression : public tree_assignment_expression
 {
  public:
-  tree_multi_assignment_expression (void);
-  tree_multi_assignment_expression (tree_return_list *l, tree *r);
+  tree_multi_assignment_expression (int l = -1, int c = -1);
+  tree_multi_assignment_expression (tree_return_list *lst, tree *r,
+				    int l = -1, int c = -1);
 
   ~tree_multi_assignment_expression (void);
 
   tree_constant eval (int print);
 
   tree_constant *eval (int print, int nargout);
 
+  void eval_error (void);
+
  private:
   tree_return_list *lhs;
   tree *rhs;
 };
 
 /*
  * Colon expressions.
  */
 class
 tree_colon_expression : public tree_expression
 {
  public:
-  tree_colon_expression (void);
-  tree_colon_expression (tree *a, tree *b);
+  tree_colon_expression (int l = -1, int c = -1);
+  tree_colon_expression (tree *a, tree *b, int l = -1, int c = -1);
 
   ~tree_colon_expression (void);
 
   tree_colon_expression *chain (tree *t);
 
   tree_constant eval (int print);
 
+  void eval_error (const char *s);
+
  private:
   tree *op1;
   tree *op2;
   tree *op3;
 };
 
 /*
  * Index expressions.
  */
 class
 tree_index_expression : public tree_expression
 {
  public:
-  tree_index_expression (void);
-  tree_index_expression (tree_identifier *i);
-  tree_index_expression (tree_identifier *i, tree_argument_list *l);
+  tree_index_expression (int l = -1, int c = -1);
+  tree_index_expression (tree_identifier *i, int l = -1, int c = -1);
+  tree_index_expression (tree_identifier *i, tree_argument_list *lst,
+			 int l = -1, int c = -1);
 
   ~tree_index_expression (void);
 
   int is_index_expression (void);
 
   tree_identifier *ident (void);
 
   tree_argument_list *arg_list (void);
 
   tree_constant eval (int print);
 
   tree_constant *eval (int print, int nargout);
 
+  void eval_error (void);
+
  private:
   tree_identifier *id;
   tree_argument_list *list;
 };
 
 /*
  * Argument lists.
  */
@@ -614,17 +644,17 @@ tree_command_list : public tree_command
  * While.
  */
 class
 tree_while_command : public tree_command
 {
  public:
   tree_while_command (void);
   tree_while_command (tree *e);
-  tree_while_command (tree *e, tree *l);
+  tree_while_command (tree *e, tree *lst);
 
   ~tree_while_command (void);
 
   tree_constant eval (int print);
 
  private:
   tree *expr;			// Expression to test.
   tree *list;			// List of commands to execute.
@@ -633,17 +663,17 @@ tree_while_command : public tree_command
 /*
  * For.
  */
 class
 tree_for_command : public tree_command
 {
  public:
   tree_for_command (void);
-  tree_for_command (tree_index_expression *id, tree *e, tree *l);
+  tree_for_command (tree_index_expression *id, tree *e, tree *lst);
 
   ~tree_for_command (void);
 
   tree_constant eval (int print);
 
  private:
   tree_index_expression *id;	// Identifier to modify.
   tree *expr;			// Expression to evaluate.
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -185,20 +185,18 @@ discard_until (istream& stream, char cha
 void
 check_dimensions (int& nr, int& nc, char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       if (user_pref.treat_neg_dim_as_zero)
 	nr = nc = 0;
       else
-	{
-	  message (warnfor, "can't create a matrix with negative dimensions");
-	  jump_to_top_level ();
-	}
+	error ("%s: can't create a matrix with negative dimensions",
+	       warnfor);
     }
 }
 
 /*
  * Set terminal in raw mode.  From less-177.
  *
  * Change terminal to "raw mode", or restore to "normal" mode.
  * "Raw mode" means 
