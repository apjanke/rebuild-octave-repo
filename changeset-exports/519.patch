# HG changeset patch
# User jwe
# Date 774628939 0
#      Tue Jul 19 14:42:19 1994 +0000
# Node ID b9284136189a2b2db518bed8fe546aa0e94f3af7
# Parent  2349d5721cd93de577a1ed1b1c31738773840150
[project @ 1994-07-19 14:40:20 by jwe]

diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -1,9 +1,9 @@
-// Very simple integer vectors for indexing              -*- C++ -*-
+// idx-vector.cc                                       -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/src/SLStack.cc b/src/SLStack.cc
--- a/src/SLStack.cc
+++ b/src/SLStack.cc
@@ -1,9 +1,9 @@
-// Template stack class                                  -*- C++ -*-
+// SLStack.cc                                           -*- C++ -*-
 /*
 
 Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/src/Stack.cc b/src/Stack.cc
--- a/src/Stack.cc
+++ b/src/Stack.cc
@@ -1,9 +1,9 @@
-// Template stack class                                  -*- C++ -*-
+// Stack.cc                                             -*- C++ -*-
 /*
 
 Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -1,9 +1,9 @@
-// tc-balance.cc                                           -*- C++ -*-
+// f-balance.cc                                           -*- C++ -*-
 /*
 
 Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -34,35 +34,50 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dbleAEPBAL.h"
 #include "CmplxAEPBAL.h"
 #include "dbleGEPBAL.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-balance.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_balance_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("balance", Fbalance, Sbalance, 4, 4,
+  "AA = balance (A [, OPT]) or [[DD,] AA] =  balance (A [, OPT])\n\
+\n\
+generalized eigenvalue problem:\n\
+\n\
+  [cc, dd, aa, bb] = balance (a, b [, opt])\n\
+\n\
+where OPT is an optional single character argument as follows: \n\
+\n\
+  N: no balancing; arguments copied, transformation(s) set to identity\n\
+  P: permute argument(s) to isolate eigenvalues where possible\n\
+  S: scale to improve accuracy of computed eigenvalues\n\
+  B: (default) permute and scale, in that order.  Rows/columns\n\
+     of a (and b) that are isolated by permutation are not scaled\n\
+\n\
+[DD, AA] = balance (A, OPT) returns aa = dd\a*dd,\n\
+\n\
+[CC, DD, AA, BB] = balance (A, B, OPT) returns AA (BB) = CC*A*DD (CC*B*DD)")
 {
-  return balance (args, nargout);
-}
-#endif
-
-Octave_object
-balance (const Octave_object& args, int nargout)
-{
-  char *bal_job;
-  int my_nargin;		// # args w/o optional string arg
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin < 2 || nargin > 4 || nargout < 0 || nargout > 4)
+    {
+      print_usage ("balance");
+      return retval;
+    }
+
+  char *bal_job;
+  int my_nargin;		// # args w/o optional string arg
+
   // determine if balancing option is listed
   // set my_nargin to the number of matrix inputs
   if (args(nargin-1).const_type () == tree_constant_rep::string_constant)
     {
       bal_job = args(nargin-1).string_value ();
       my_nargin = nargin-2;
     }
   else
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -27,47 +27,45 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleCHOL.h"
 #include "CmplxCHOL.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-chol.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object*
-builtin_chol_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("chol", Fchol, Schol, 2, 1,
+  "R = chol (X): cholesky factorization")
 {
-  Octave_object retval (1);
-  retval(0) = chol (args(1));
-  return retval;
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-tree_constant
-chol (const tree_constant& a)
-{
-  tree_constant retval;
+  if (nargin != 2 || nargout > 1)
+    {
+      print_usage ("chol");
+      return retval;
+    }
 
-  tree_constant tmp = a.make_numeric ();;
+  tree_constant tmp = args(1).make_numeric ();
     
   int nr = tmp.rows ();
   int nc = tmp.columns ();
 
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("chol", 0);
-	  Matrix m;
-	  retval = m;
+
+	  retval.resize (1, Matrix ());
 	}
       else
 	gripe_empty_arg ("chol", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -25,33 +25,31 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "config.h"
 #endif
 
 #include "CollocWt.h"
 
 #include "tree-const.h"
 #include "error.h"
 #include "utils.h"
-#include "f-colloc.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_colloc_2 (const Octave_object& args, int nargout)
-{
-  return collocation_weights (args);
-}
-#endif
-
-Octave_object
-collocation_weights (const Octave_object& args)
+DEFUN_DLD ("colloc", Fcolloc, Scolloc, 7, 4,
+  "[R, A, B, Q] = colloc (N [, \"left\"] [, \"right\"]): collocation weights")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin < 2 || nargin > 4)
+    {
+      print_usage ("colloc");
+      return retval;
+    }
+
   if (args(1).const_type () != tree_constant_rep::complex_scalar_constant
       && args(1).const_type () != tree_constant_rep::scalar_constant)
     {
       error ("colloc: first argument must be a scalar");
       return retval;
     }
 
   int ncol = NINT (args(1).double_value ());
@@ -71,25 +69,23 @@ collocation_weights (const Octave_object
 	{
 	  if (! args(i).is_string_type ())
 	    {
 	      error ("colloc: expecting string argument");
 	      return retval;
 	    }
 
 	  char *s = args(i).string_value ();
-	  if (s != (char *) NULL
-	      && (((*s == 'R' || *s == 'r') && strlen (s) == 1)
-		  || strcmp (s, "right") == 0))
+	  if (s && (((*s == 'R' || *s == 'r') && strlen (s) == 1)
+		    || strcmp (s, "right") == 0))
 	    {
 	      right = 1;
 	    }
-	  else if (s != (char *) NULL
-		   && (((*s == 'L' || *s == 'l') && strlen (s) == 1)
-		       || strcmp (s, "left") == 0))
+	  else if (s && (((*s == 'L' || *s == 'l') && strlen (s) == 1)
+			 || strcmp (s, "left") == 0))
 	    {
 	      left = 1;
 	    }
 	  else
 	    {
 	      error ("colloc: unrecognized argument");
 	      return retval;
 	    }
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -30,35 +30,21 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "DAE.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "gripes.h"
 #include "error.h"
 #include "utils.h"
 #include "pager.h"
-#include "f-dassl.h"
+#include "defun-dld.h"
 
 // Global pointer for user defined function required by dassl.
 static tree_fvc *dassl_fcn;
 
-#ifdef WITH_DLD
-Octave_object
-builtin_dassl_2 (const Octave_object& args, int nargout)
-{
-  return dassl (args, nargout);
-}
-
-Octave_object
-builtin_dassl_options_2 (const Octave_object& args, int nargout)
-{
-  return dassl_options (args, nargout);
-}
-#endif
-
 static ODE_options dassl_opts;
 
 ColumnVector
 dassl_user_function (const ColumnVector& x, const ColumnVector& xdot, double t)
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
@@ -89,17 +75,17 @@ dassl_user_function (const ColumnVector&
       double d1 = x.elem (0);
       double d2 = xdot.elem (0);
       tree_constant state (d1);
       tree_constant deriv (d2);
       args(1) = state;
       args(2) = deriv;
     }
 
-  if (dassl_fcn != (tree_fvc *) NULL)
+  if (dassl_fcn)
     {
       Octave_object tmp = dassl_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("dassl");
 	  return retval;
 	}
@@ -113,28 +99,39 @@ dassl_user_function (const ColumnVector&
 	}
       else
 	gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
-Octave_object
-dassl (const Octave_object& args, int nargout)
+DEFUN_DLD ("dassl", Fdassl, Sdassl, 5, 1,
+  "dassl (\"function_name\", x_0, xdot_0, t_out)\n\
+dassl (F, X_0, XDOT_0, T_OUT, T_CRIT)\n\
+\n\
+The first argument is the name of the function to call to\n\
+compute the vector of residuals.  It must have the form\n\
+\n\
+  res = f (x, xdot, t)\n\
+\n\
+where x, xdot, and res are vectors, and t is a scalar.")
 {
-// Assumes that we have been given the correct number of arguments.
-
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin < 5 || nargin > 6)
+    {
+      print_usage ("dassl");
+      return retval;
+    }
+
   dassl_fcn = is_valid_function (args(1), "dassl", 1);
-  if (dassl_fcn == (tree_fvc *) NULL
-      || takes_correct_nargs (dassl_fcn, 4, "dassl", 1) != 1)
+  if (! dassl_fcn || takes_correct_nargs (dassl_fcn, 4, "dassl", 1) != 1)
     return retval;
 
   ColumnVector state = args(2).to_vector ();
   ColumnVector deriv = args(3).to_vector ();
   ColumnVector out_times = args(4).to_vector ();
   ColumnVector crit_times;
   int crit_times_set = 0;
   if (nargin > 5)
@@ -182,43 +179,43 @@ struct DAE_OPTIONS
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
 static DAE_OPTIONS dassl_option_table [] =
 {
   { "absolute tolerance",
-    { "absolute", "tolerance", NULL, NULL, },
+    { "absolute", "tolerance", 0, 0, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_absolute_tolerance,
     ODE_options::absolute_tolerance, },
 
   { "initial step size",
-    { "initial", "step", "size", NULL, },
+    { "initial", "step", "size", 0, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_initial_step_size,
     ODE_options::initial_step_size, },
 
   { "maximum step size",
-    { "maximum", "step", "size", NULL, },
+    { "maximum", "step", "size", 0, },
     { 2, 0, 0, 0, }, 1,
     ODE_options::set_maximum_step_size,
     ODE_options::maximum_step_size, },
 
   { "relative tolerance",
-    { "relative", "tolerance", NULL, NULL, },
+    { "relative", "tolerance", 0, 0, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_relative_tolerance,
     ODE_options::relative_tolerance, },
 
-  { NULL,
-    { NULL, NULL, NULL, NULL, },
+  { 0,
+    { 0, 0, 0, 0, },
     { 0, 0, 0, 0, }, 0,
-    NULL, NULL, },
+    0, 0, },
 };
 
 static void
 print_dassl_option_list (void)
 {
   ostrstream output_buf;
 
   print_usage ("dassl_options", 1);
@@ -226,17 +223,17 @@ print_dassl_option_list (void)
   output_buf << "\n"
 	     << "Options for dassl include:\n\n"
 	     << "  keyword                                  value\n"
 	     << "  -------                                  -----\n\n";
 
   DAE_OPTIONS *list = dassl_option_table;
 
   char *keyword;
-  while ((keyword = list->keyword) != (char *) NULL)
+  while ((keyword = list->keyword) != 0)
     {
       output_buf.form ("  %-40s ", keyword);
 
       double val = (dassl_opts.*list->d_get_fcn) ();
       if (val < 0.0)
 	output_buf << "computed automatically";
       else
 	output_buf << val;
@@ -249,40 +246,45 @@ print_dassl_option_list (void)
   maybe_page_output (output_buf);
 }
 
 static void
 do_dassl_option (char *keyword, double val)
 {
   DAE_OPTIONS *list = dassl_option_table;
 
-  while (list->keyword != (char *) NULL)
+  while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (dassl_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
   warning ("dassl_options: no match for `%s'", keyword);
 }
 
-Octave_object
-dassl_options (const Octave_object& args, int nargout)
+DEFUN_DLD ("dassl_options", Fdassl_options, Sdassl_options, -1, 1,
+  "dassl_options (KEYWORD, VALUE)\n\
+\n\
+Set or show options for dassl.  Keywords may be abbreviated\n\
+to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
-    print_dassl_option_list ();
+    {
+      print_dassl_option_list ();
+    }
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
 	  char *keyword = args(1).string_value ();
 	  double val = args(2).double_value ();
 	  do_dassl_option (keyword, val);
 	}
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -27,34 +27,32 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleDET.h"
 #include "CmplxDET.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-det.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_det_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("det", Fdet, Sdet, 2, 1,
+  "det (X): determinant of a square matrix")
 {
-  Octave_object retval (1);
-  retval(0) = determinant (args(1));
-  return retval;
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-tree_constant
-determinant (const tree_constant& a)
-{
-  tree_constant retval;
+  if (nargin != 2)
+    {
+      print_usage ("det");
+      return retval;
+    }
 
-  tree_constant tmp = a.make_numeric ();;
+  tree_constant tmp = args(1).make_numeric ();;
     
   int nr = tmp.rows ();
   int nc = tmp.columns ();
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	gripe_empty_arg ("det", 0);
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -26,31 +26,31 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "EIG.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-eig.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_eig_2 (const Octave_object& args, int nargout)
-{
-  return eig (args, nargout);
-}
-#endif
-
-Octave_object
-eig (const Octave_object& args, int nargout)
+DEFUN_DLD ("eig", Feig, Seig, 2, 1,
+  "eig (X) or [V, D] = eig (X): compute eigenvalues and eigenvectors of X")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
+  if (nargin != 2 || nargout > 2)
+    {
+      print_usage ("eig");
+      return retval;
+    }
+
   tree_constant arg = args(1).make_numeric ();
 
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -1,9 +1,9 @@
-// tc-expm.cc                                           -*- C++ -*-
+// f-expm.cc                                           -*- C++ -*-
 /*
 
 Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -35,42 +35,41 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dbleAEPBAL.h"
 #include "CmplxAEPBAL.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-expm.h"
-
-#ifdef WITH_DLD
-Octave_object
-builtin_matrix_exp_2 (const Octave_object& args, int nargout)
-{
-  Octave_object retval (1);
-  retval(0) = matrix_exp (args(1));
-  return retval;
-}
-#endif
+#include "defun-dld.h"
 
 extern "C"
 {
   double F77_FCN (dlange) (const char*, const int*, const int*,
 			   const double*, const int*, double*);
 
   double F77_FCN (zlange) (const char*, const int*, const int*,
 			   const Complex*, const int*, double*);
 }
 
-tree_constant
-matrix_exp (const tree_constant& a)
+DEFUN_DLD ("expm", Fexpm, Sexpm, 2, 1,
+  "expm (X): matrix exponential, e^A")
 {
-  tree_constant retval;
-  tree_constant tmp = a.make_numeric ();
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    {
+      print_usage ("expm");
+      return retval;
+    }
+
+  tree_constant tmp = args(1).make_numeric ();
 
 // Constants for matrix exponential calculation.
 
   static double padec [] =
     {
       5.0000000000000000e-1,
       1.1666666666666667e-1,
       1.6666666666666667e-2,
@@ -83,18 +82,18 @@ matrix_exp (const tree_constant& a)
 
   if (tmp.is_empty ())
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("expm", 0);
-	  Matrix m;
-	  retval = m;
+
+	  retval.resize (1, Matrix ());
 	}
       else gripe_empty_arg ("expm", 1);
     }
   else if (tmp.rows () != tmp.columns ())
     gripe_square_matrix_required ("expm");
   else
     { 
       int i, j;
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -27,44 +27,42 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-fft.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_fft_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("fft", Ffft, Sfft, 2, 1,
+  "fft (X): fast fourier transform of a vector")
 {
-  Octave_object retval (1);
-  retval(0) = fft (args(1));
-  return retval;
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-tree_constant
-fft (const tree_constant& a)
-{
-  tree_constant retval;
+  if (nargin != 2)
+    {
+      print_usage ("fft");
+      return retval;
+    }
 
-  tree_constant tmp = a.make_numeric ();;
+  tree_constant tmp = args(1).make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("fft", 0);
-	  Matrix m;
-	  retval = m;
+
+	  retval.resize (1, Matrix ());
 	}
       else
 	gripe_empty_arg ("fft", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
diff --git a/src/find.cc b/src/find.cc
--- a/src/find.cc
+++ b/src/find.cc
@@ -22,17 +22,17 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "tree-const.h"
 #include "error.h"
-#include "f-find.h"
+#include "defun-dld.h"
 
 static Octave_object
 find_to_fortran_idx (const ColumnVector i_idx, const ColumnVector j_idx,
 		     const tree_constant& val, int nr, int nc, int nargout)
 {
   Octave_object retval (nargout);
 
   switch (nargout)
@@ -143,25 +143,34 @@ find_nonzero_elem_idx (const ComplexMatr
 	    count++;
 	  }
       }
 
   tree_constant tmp (v, 1);
   return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, m_nc, nargout);
 }
 
-Octave_object
-find_nonzero_elem_idx (const tree_constant& a, int nargout)
+DEFUN_DLD ("find", Ffind, Sfind, 2, 3,
+  "find (X) or [I, J, V] = find (X): Return indices of nonzero elements")
 {
-  Matrix result;
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2 || nargout > 3)
+    {
+      print_usage ("find");
+      return retval;
+    }
 
   nargout = (nargout == 0) ? 1 : nargout;
-  Octave_object retval (nargout, result);
 
-  tree_constant tmp = a.make_numeric ();
+  retval.resize (nargout, Matrix ());
+
+  tree_constant tmp = args(1).make_numeric ();
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	return find_nonzero_elem_idx (m, nargout);
       }
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -30,35 +30,21 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "NLEqn.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "gripes.h"
 #include "error.h"
 #include "utils.h"
 #include "pager.h"
-#include "f-fsolve.h"
+#include "defun-dld.h"
 
 // Global pointer for user defined function required by hybrd1.
 static tree_fvc *fsolve_fcn;
 
-#ifdef WITH_DLD
-Octave_object
-builtin_fsolve_2 (const Octave_object& args, int nargout)
-{
-  return fsolve (args, nargout);
-}
-
-Octave_object
-builtin_fsolve_options (const Octave_object& args, int nargout)
-{
-  return fsolve_options (args, nargout);
-}
-#endif
-
 static NLEqn_options fsolve_opts;
 
 int
 hybrd_info_to_fsolve_info (int info)
 {
   switch (info)
     {
     case -1:
@@ -105,45 +91,57 @@ fsolve_user_function (const ColumnVector
     }
   else
     {
       double d = x.elem (0);
       tree_constant vars (d);
       args(1) = vars;
     }
 
-  if (fsolve_fcn != (tree_fvc *) NULL)
+  if (fsolve_fcn)
     {
       Octave_object tmp = fsolve_fcn->eval (0, 1, args);
       if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
 	  retval = tmp(0).to_vector ();
 
 	  if (retval.length () <= 0)
 	    gripe_user_supplied_eval ("fsolve");
 	}
       else
 	gripe_user_supplied_eval ("fsolve");
     }
 
   return retval;
 }
 
-Octave_object
-fsolve (const Octave_object& args, int nargout)
+DEFUN_DLD ("fsolve", Ffsolve, Sfsolve, 5, 1,
+  "Solve nonlinear equations using Minpack.  Usage:\n\
+\n\
+  [X, INFO] = fsolve (F, X0)\n\
+\n\
+Where the first argument is the name of the  function to call to\n\
+compute the vector of function values.  It must have the form\n\
+\n\
+  y = f (x)
+\n\
+where y and x are vectors.")
 {
-// Assumes that we have been given the correct number of arguments.
-
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin < 3 || nargin > 7 || nargout > 3)
+    {
+      print_usage ("fsolve");
+      return retval;
+    }
+
   fsolve_fcn = is_valid_function (args(1), "fsolve", 1);
-  if (fsolve_fcn == (tree_fvc *) NULL
-      || takes_correct_nargs (fsolve_fcn, 2, "fsolve", 1) != 1)
+  if (! fsolve_fcn || takes_correct_nargs (fsolve_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
   ColumnVector x = args(2).to_vector ();
 
   if (nargin > 3)
     warning ("fsolve: ignoring extra arguments");
 
   if (nargout > 2)
@@ -180,25 +178,25 @@ struct NLEQN_OPTIONS
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
 static NLEQN_OPTIONS fsolve_option_table [] =
 {
   { "tolerance",
-    { "tolerance", NULL, },
+    { "tolerance", 0, },
     { 1, 0, }, 1,
     NLEqn_options::set_tolerance,
     NLEqn_options::tolerance, },
 
-  { NULL,
-    { NULL, NULL, },
+  { 0,
+    { 0, 0, },
     { 0, 0, }, 0,
-    NULL, NULL, },
+    0, 0, },
 };
 
 static void
 print_fsolve_option_list (void)
 {
   ostrstream output_buf;
 
   print_usage ("fsolve_options", 1);
@@ -206,17 +204,17 @@ print_fsolve_option_list (void)
   output_buf << "\n"
 	     << "Options for fsolve include:\n\n"
 	     << "  keyword                                  value\n"
 	     << "  -------                                  -----\n\n";
 
   NLEQN_OPTIONS *list = fsolve_option_table;
 
   char *keyword;
-  while ((keyword = list->keyword) != (char *) NULL)
+  while ((keyword = list->keyword) != 0)
     {
       output_buf.form ("  %-40s ", keyword);
 
       double val = (fsolve_opts.*list->d_get_fcn) ();
       if (val < 0.0)
 	output_buf << "computed automatically";
       else
 	output_buf << val;
@@ -229,40 +227,45 @@ print_fsolve_option_list (void)
   maybe_page_output (output_buf);
 }
 
 static void
 do_fsolve_option (char *keyword, double val)
 {
   NLEQN_OPTIONS *list = fsolve_option_table;
 
-  while (list->keyword != (char *) NULL)
+  while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (fsolve_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
   warning ("fsolve_options: no match for `%s'", keyword);
 }
 
-Octave_object
-fsolve_options (const Octave_object& args, int nargout)
+DEFUN_DLD ("fsolve_options", Ffsolve_options, Sfsolve_options, -1, 1,
+  "fsolve_options (KEYWORD, VALUE)\n\
+\n\
+Set or show options for fsolve.  Keywords may be abbreviated\n\
+to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
-    print_fsolve_option_list ();
+    {
+      print_fsolve_option_list ();
+    }
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
 	  char *keyword = args(1).string_value ();
 	  double val = args(2).double_value ();
 	  do_fsolve_option (keyword, val);
 	}
diff --git a/src/fsqp.cc b/src/fsqp.cc
--- a/src/fsqp.cc
+++ b/src/fsqp.cc
@@ -26,81 +26,87 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #ifndef FSQP_MISSING
 
 #include "FSQP.h"
 
 #include "tree-const.h"
 #include "error.h"
-#include "f-fsqp.h"
+#include "defun-dld.h"
 
 // Global pointers for user defined functions required by fsqp.
 // static tree *fsqp_objective;
 // static tree *fsqp_constraints;
 
-#ifdef WITH_DLD
-Octave_object
-builtin_fsqp_2 (const Octave_object& args, int nargout)
-{
-  return fsqp (args nargout);
-}
-
-Octave_object
-builtin_fsqp_options_2 (const Octave_object& args, int nargout)
-{
-  return fsqp_options (args, nargout);
-}
-#endif
-
 double
 fsqp_objective_function (const ColumnVector& x)
 {
   return 0.0;
 }
 
 ColumnVector
 fsqp_constraint_function (const ColumnVector& x)
 {
   ColumnVector retval;
   return retval;
 }
 
-Octave_object
-fsqp (const Octave_object& args, int nargout)
+#if defined (FSQP_MISSING)
+DEFUN_DLD ("fsqp", Ffsqp, Sfsqp, 11, 3,
+  "This function requires FSQP, which is not freely\n\
+redistributable.  For more information, read the file\n\
+libcruft/fsqp/README.MISSING in the source distribution.")
+#else
+DEFUN_DLD ("fsqp", Ffsqp, Sfsqp, 11, 3,
+  "[X, PHI] = fsqp (X, PHI [, LB, UB] [, LB, A, UB] [, LB, G, UB])\n\
+\n\
+Groups of arguments surrounded in `[]' are optional, but\n\
+must appear in the same relative order shown above.")
+#endif
 {
 /*
 
 Handle all of the following:
 
   1. fsqp (x, phi)
   2. fsqp (x, phi, lb, ub)
   3. fsqp (x, phi, lb, ub, llb, c, lub)
   4. fsqp (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
   5. fsqp (x, phi, lb, ub,              nllb, g, nlub)
   6. fsqp (x, phi,         llb, c, lub, nllb, g, nlub)
   7. fsqp (x, phi,         llb, c, lub)
   8. fsqp (x, phi,                      nllb, g, nlub)
 
 */
 
-// Assumes that we have been given the correct number of arguments.
+  Octave_object retval;
 
-  Octave_object retval;
   error ("fsqp: not implemented yet");
+
   return retval;
 }
 
-Octave_object
-fsqp_options (const Octave_object& args, int nargout)
+#if defined (FSQP_MISSING)
+DEFUN_DLD ("fsqp_options", Ffsqp_options, Sfsqp_options, -1, 1,
+  "This function requires FSQP, which is not freely\n\
+redistributable.  For more information, read the file\n\
+libcruft/fsqp/README.MISSING in the source distribution.")
+#else
+DEFUN_DLD ("fsqp_options", Ffsqp_options, Sfsqp_options, -1, 1,
+  "fsqp_options (KEYWORD, VALUE)\n\
+\n\
+Set or show options for fsqp.  Keywords may be abbreviated\n\
+to the shortest match.")
+#endif
 {
-// Assumes that we have been given the correct number of arguments.
+  Octave_object retval;
 
-  Octave_object retval;
   error ("fsqp_options: not implemented yet");
+
   return retval;
 }
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -1,9 +1,9 @@
-// tc-givens.cc                                           -*- C++ -*-
+// f-givens.cc                                           -*- C++ -*-
 /*
 
 Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -30,17 +30,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
-#include "f-givens.h"
+#include "defun-dld.h"
 
 extern "C"
 {
   int F77_FCN (dlartg) (const double*, const double*, double*, double*,
 			double*);
 
   int F77_FCN (zlartg) (const Complex*, const Complex*, double*,
 			Complex*, Complex*);
@@ -51,29 +51,33 @@ extern "C"
 int F77_FCN (dorgqr) (const int*, const int*, const int*, double*,
 		      const int*, double*, double*, const int*, int*);
   
 int F77_FCN (zunghr) (const int*, const int*, const int*, Complex*,
 		      const int*, Complex*, Complex*, const int*,
 		      int*, long, long);
 #endif
 
-#ifdef WITH_DLD
-Octave_object
-builtin_givens_2 (const Octave_object& args int nargout)
+DEFUN_DLD ("givens", Fgivens, Sgivens, 3, 2,
+  "G = givens (X, Y)\n\
+\n\
+compute orthogonal matrix G = [c s; -conj (s) c]\n\
+such that G [x; y] = [*; 0]  (x, y scalars)\n\
+\n\
+[c, s] = givens (x, y) returns the (c, s) values themselves.")
 {
-  return givens (args, nargout);
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-Octave_object
-givens (const Octave_object& args, int nargout)
-{
-
-  Octave_object retval;
+  if (nargin != 3 || nargout > 2)
+    {
+      print_usage ("givens");
+      return retval;
+    }
 
   tree_constant arga = args(1).make_numeric ();
   tree_constant argb = args(2).make_numeric ();
 
   if (! arga.is_scalar_type () && argb.is_scalar_type ())
     {
       error("givens: requires two scalar arguments"); 
     }
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -27,31 +27,31 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleHESS.h"
 #include "CmplxHESS.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
-#include "f-hess.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_hess_2 (const Octave_object& args, int nargout)
-{
-  return hess (args, nargout);
-}
-#endif
-
-Octave_object
-hess (const Octave_object& args, int nargout)
+DEFUN_DLD ("hess", Fhess, Shess, 2, 2,
+  "[P, H] = hess (A) or H = hess (A): Hessenberg decomposition")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
+  if (nargin != 2 || nargout > 2)
+    {
+      print_usage ("hess");
+      return retval;
+    }
+
   tree_constant arg = args(1).make_numeric ();
 
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -27,44 +27,42 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-ifft.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_ifft_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("ifft", Fifft, Sifft,2, 1,
+  "ifft (X): inverse fast fourier transform of a vector")
 {
-  Octave_object retval (1);
-  retval(0) = ifft (args(1));
-  return retval;
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-tree_constant
-ifft (const tree_constant& a)
-{
-  tree_constant retval;
+  if (nargin != 2)
+    {
+      print_usage ("ifft");
+      return retval;
+    }
 
-  tree_constant tmp = a.make_numeric ();;
+  tree_constant tmp = args(1).make_numeric ();
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("ifft", 0);
-	  Matrix m;
-	  retval = m;
+
+	  retval.resize (1, Matrix ());
 	}
       else
 	gripe_empty_arg ("ifft", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -27,34 +27,32 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-inv.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_inv_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("inv", Finv, Sinv, 2, 1,
+  "inv (X): inverse of a square matrix")
 {
-  Octave_object retval (1);
-  retval(0) = inverse (args(1));
-  return retval;
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-tree_constant
-inverse (const tree_constant& a)
-{
-  tree_constant retval;
+  if (nargin != 2)
+    {
+      print_usage ("inv");
+      return retval;
+    }
 
-  tree_constant tmp = a.make_numeric ();
+  tree_constant tmp = args(1).make_numeric ();
 
   int nr = tmp.rows ();
   int nc = tmp.columns ();
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	gripe_empty_arg ("inverse", 0);
diff --git a/src/log.cc b/src/log.cc
--- a/src/log.cc
+++ b/src/log.cc
@@ -26,37 +26,44 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "EIG.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
-#include "f-log.h"
+#include "defun-dld.h"
+
+// XXX FIXME XXX -- the next two functions should really be just one...
 
-// XXX FIXME XXX -- the next two functions (and expm) should really be just
-// one...
+DEFUN_DLD ("logm", Flogm, Slogm, 2, 1,
+  "logm (X): matrix logarithm")
+{
+  Octave_object retval;
 
-Octave_object
-matrix_log (const tree_constant& a)
-{
-  Octave_object retval (1);
+  int nargin = args.length ();
 
-  tree_constant tmp = a.make_numeric ();;
+  if (nargin != 2)
+    {
+      print_usage ("logm");
+      return retval;
+    }
+
+  tree_constant tmp = args(1).make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("logm", 0);
-	  Matrix m;
-	  retval(0) = m;
+
+	  retval.resize (1, Matrix ());
 	  return retval;
 	}
       else
 	gripe_empty_arg ("logm", 1);
     }
 
   switch (tmp.const_type ())
     {
@@ -141,32 +148,40 @@ matrix_log (const tree_constant& a)
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
-Octave_object
-matrix_sqrt (const tree_constant& a)
+DEFUN_DLD ("sqrtm", Fsqrtm, Ssqrtm, 2, 1,
+ "sqrtm (X): matrix sqrt")
 {
-  Octave_object retval (1);
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-  tree_constant tmp = a.make_numeric ();;
+  if (nargin != 2)
+    {
+      print_usage ("sqrtm");
+      return retval;
+    }
+
+  tree_constant tmp = args(1).make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("sqrtm", 0);
-	  Matrix m;
-	  retval(0) = m;
+
+	  retval.resize (1, Matrix ());
 	  return retval;
 	}
       else
 	gripe_empty_arg ("sqrtm", 1);
     }
 
   switch (tmp.const_type ())
     {
diff --git a/src/lpsolve.cc b/src/lpsolve.cc
--- a/src/lpsolve.cc
+++ b/src/lpsolve.cc
@@ -24,49 +24,44 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "LPsolve.h"
 
 #include "tree-const.h"
 #include "error.h"
-#include "f-lpsolve.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_lpsolve_2 (const Octave_object& args, int nargout)
-{
-  return lpsolve (args, nargout);
-}
-
-Octave_object
-builtin_lpsolve_options_2 (const Octave_object& args, int nargout) 
+DEFUN_DLD ("lpsolve", Flpsolve, Slpsolve, 11, 3,
+  "lp_solve (): solve linear programs using lp_solve.")
 {
-  return lpsolve_options (args, nargout);
-}
-#endif
+  Octave_object retval;
 
-Octave_object
-lpsolve (const Octave_object& args, int nargout)
-{
-// Assumes that we have been given the correct number of arguments.
+// Force a bad value of inform, and empty matrices for x and phi.
+  Matrix m;
+  retval(2) = -1.0;
+  retval(1) = m;
+  retval(0) = m;
 
-  Octave_object retval;
   error ("lpsolve: not implemented yet");
+
   return retval;
 }
 
-Octave_object
-lpsolve_options (const Octave_object& args, int nargout)
+DEFUN_DLD ("lpsolve_options", Flpsolve_options, Slpsolve_options, -1, 1,
+  "lp_solve_options (KEYWORD, VALUE)\n\
+\n\
+Set or show options for lp_solve.  Keywords may be abbreviated\n\
+to the shortest match.")
 {
-// Assumes that we have been given the correct number of arguments.
+  Octave_object retval;
 
-  Octave_object retval;
   error ("lpsolve_options: not implemented yet");
+
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -30,35 +30,21 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "ODE.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "gripes.h"
 #include "error.h"
 #include "utils.h"
 #include "pager.h"
-#include "f-lsode.h"
+#include "defun-dld.h"
 
 // Global pointer for user defined function required by lsode.
 static tree_fvc *lsode_fcn;
 
-#ifdef WITH_DLD
-Octave_object
-builtin_lsode_2 (const Octave_object& args int nargout)
-{
-  return lsode (args, nargout);
-}
-
-Octave_object
-builtin_lsode_options_2 (const Octave_object& args, int nargout)
-{
-  return lsode_options (args, nargout);
-}
-#endif
-
 static ODE_options lsode_opts;
 
 ColumnVector
 lsode_user_function (const ColumnVector& x, double t)
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
@@ -78,17 +64,17 @@ lsode_user_function (const ColumnVector&
     }
   else
     {
       double d = x.elem (0);
       tree_constant state (d);
       args(1) = state;
     }
 
-  if (lsode_fcn != (tree_fvc *) NULL)
+  if (lsode_fcn)
     {
       Octave_object tmp = lsode_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("lsode");
 	  return retval;
 	}
@@ -102,28 +88,38 @@ lsode_user_function (const ColumnVector&
 	}
       else
 	gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
-Octave_object
-lsode (const Octave_object& args, int nargout)
+DEFUN_DLD ("lsode", Flsode, Slsode, 6, 1,
+  "lsode (F, X0, T_OUT, T_CRIT)\n\
+\n\
+The first argument is the name of the function to call to\n\
+compute the vector of right hand sides.  It must have the form\n\
+\n\
+  xdot = f (x, t)\n\
+\n\
+where xdot and x are vectors and t is a scalar.\n")
 {
-// Assumes that we have been given the correct number of arguments.
-
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin < 4 || nargin > 5 || nargout > 1)
+    {
+      print_usage ("lsode");
+      return retval;
+    }
+
   lsode_fcn = is_valid_function (args(1), "lsode", 1);
-  if (lsode_fcn == (tree_fvc *) NULL
-      || takes_correct_nargs (lsode_fcn, 3, "lsode", 1) != 1)
+  if (! lsode_fcn || takes_correct_nargs (lsode_fcn, 3, "lsode", 1) != 1)
     return retval;
 
   ColumnVector state = args(2).to_vector ();
   ColumnVector out_times = args(3).to_vector ();
   ColumnVector crit_times;
   int crit_times_set = 0;
   if (nargin > 4)
     {
@@ -164,49 +160,49 @@ struct ODE_OPTIONS
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
 static ODE_OPTIONS lsode_option_table [] =
 {
   { "absolute tolerance",
-    { "absolute", "tolerance", NULL, NULL, },
+    { "absolute", "tolerance", 0, 0, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_absolute_tolerance,
     ODE_options::absolute_tolerance, },
 
   { "initial step size",
-    { "initial", "step", "size", NULL, },
+    { "initial", "step", "size", 0, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_initial_step_size,
     ODE_options::initial_step_size, },
 
   { "maximum step size",
-    { "maximum", "step", "size", NULL, },
+    { "maximum", "step", "size", 0, },
     { 2, 0, 0, 0, }, 1,
     ODE_options::set_maximum_step_size,
     ODE_options::maximum_step_size, },
 
   { "minimum step size",
-    { "minimum", "step", "size", NULL, },
+    { "minimum", "step", "size", 0, },
     { 2, 0, 0, 0, }, 1,
     ODE_options::set_minimum_step_size,
     ODE_options::minimum_step_size, },
 
   { "relative tolerance",
-    { "relative", "tolerance", NULL, NULL, },
+    { "relative", "tolerance", 0, 0, },
     { 1, 0, 0, 0, }, 1,
     ODE_options::set_relative_tolerance,
     ODE_options::relative_tolerance, },
 
-  { NULL,
-    { NULL, NULL, NULL, NULL, },
+  { 0,
+    { 0, 0, 0, 0, },
     { 0, 0, 0, 0, }, 0,
-    NULL, NULL, },
+    0, 0, },
 };
 
 static void
 print_lsode_option_list (void)
 {
   ostrstream output_buf;
 
   print_usage ("lsode_options", 1);
@@ -214,17 +210,17 @@ print_lsode_option_list (void)
   output_buf << "\n"
 	     << "Options for lsode include:\n\n"
 	     << "  keyword                                  value\n"
 	     << "  -------                                  -----\n\n";
 
   ODE_OPTIONS *list = lsode_option_table;
 
   char *keyword;
-  while ((keyword = list->keyword) != (char *) NULL)
+  while ((keyword = list->keyword) != 0)
     {
       output_buf.form ("  %-40s ", keyword);
 
       double val = (lsode_opts.*list->d_get_fcn) ();
       if (val < 0.0)
 	output_buf << "computed automatically";
       else
 	output_buf << val;
@@ -237,40 +233,45 @@ print_lsode_option_list (void)
   maybe_page_output (output_buf);
 }
 
 static void
 do_lsode_option (char *keyword, double val)
 {
   ODE_OPTIONS *list = lsode_option_table;
 
-  while (list->keyword != (char *) NULL)
+  while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (lsode_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
   warning ("lsode_options: no match for `%s'", keyword);
 }
 
-Octave_object
-lsode_options (const Octave_object& args, int nargout)
+DEFUN_DLD ("lsode_options", Flsode_options, Slsode_options, -1, 1,
+  "lsode_options (KEYWORD, VALUE)\n\
+\n\
+Set or show options for lsode.  Keywords may be abbreviated\n\
+to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
-    print_lsode_option_list ();
+    {
+      print_lsode_option_list ();
+    }
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
 	  char *keyword = args(1).string_value ();
 	  double val = args(2).double_value ();
 	  do_lsode_option (keyword, val);
 	}
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -26,45 +26,42 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "dbleLU.h"
 #include "CmplxLU.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
-#include "f-lu.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_lu_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("lu", Flu, Slu, 2, 3,
+  "[L, U, P] = lu (A): LU factorization")
 {
-  return lu (args(1), nargout);
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-Octave_object
-lu (const tree_constant& a, int nargout)
-{
-  Octave_object retval (3);
+  if (nargin != 2 || nargout > 3)
+    {
+      print_usage ("lu");
+      return retval;
+    }
 
-  tree_constant tmp = a.make_numeric ();;
+  tree_constant tmp = args(1).make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("lu", 0);
 
-	  Matrix m;
-	  retval(0) = m;
-	  retval(1) = m;
-	  retval(2) = m;
+	  retval.resize (3, Matrix ());
 	  return retval;
 	}
       else
 	gripe_empty_arg ("lu", 1);
     }
 
   switch (tmp.const_type ())
     {
@@ -76,25 +73,25 @@ lu (const tree_constant& a, int nargout)
 	    LU fact (m);
 	    switch (nargout)
 	      {
 	      case 1:
 	      case 2:
 		{
 		  Matrix P = fact.P ();
 		  Matrix L = P.transpose () * fact.L ();
+		  retval(1) = fact.U ();
 		  retval(0) = L;
-		  retval(1) = fact.U ();
 		}
 		break;
 	      case 3:
 	      default:
-		retval(0) = fact.L ();
+		retval(2) = fact.P ();
 		retval(1) = fact.U ();
-		retval(2) = fact.P ();
+		retval(0) = fact.L ();
 		break;
 	      }
 	  }
 	else
 	  gripe_square_matrix_required ("lu");
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
@@ -105,46 +102,46 @@ lu (const tree_constant& a, int nargout)
 	    ComplexLU fact (m);
 	    switch (nargout)
 	      {
 	      case 1:
 	      case 2:
 		{
 		  ComplexMatrix P = fact.P ();
 		  ComplexMatrix L = P.transpose () * fact.L ();
+		  retval(1) = fact.U ();
 		  retval(0) = L;
-		  retval(1) = fact.U ();
 		}
 		break;
 	      case 3:
 	      default:
-		retval(0) = fact.L ();
+		retval(2) = fact.P ();
 		retval(1) = fact.U ();
-		retval(2) = fact.P ();
+		retval(0) = fact.L ();
 		break;
 	      }
 	  }
 	else
 	  gripe_square_matrix_required ("lu");
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval(0) = 1.0;
+	retval(2) = 1.0;
 	retval(1) = d;
-	retval(2) = 1.0;
+	retval(0) = 1.0;
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval(0) = 1.0;
+	retval(2) = 1.0;
 	retval(1) = c;
-	retval(2) = 1.0;
+	retval(0) = 1.0;
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -24,17 +24,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include <math.h>
 
 #include "tree-const.h"
 #include "error.h"
-#include "f-minmax.h"
+#include "defun-dld.h"
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
 
 #ifndef MIN
 #define MIN(a,b) ((a) < (b) ? (a) : (b))
 #endif
@@ -136,30 +136,37 @@ max (const ComplexMatrix& a, const Compl
           result.elem (i, j) = a.elem (i, j);
         else
           result.elem (i, j) = b.elem (i, j);
       }
 
   return result;
 }
 
-Octave_object
-column_min (const Octave_object& args, int nargout)
+
+DEFUN_DLD ("min", Fmin, Smin, 3, 2,
+  "min (X): minimum value(s) of a vector (matrix)")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
+  if (nargin == 1 || nargin > 3 || nargout > 2)
+    {
+      print_usage ("min");
+      return retval;
+    }
+
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
     tree_constant_rep::unknown_constant;
 
-  int nargin = args.length ();
-
   switch (nargin)
     {
     case 3:
       arg2 = args(2).make_numeric ();
       arg2_type = arg2.const_type ();
 // Fall through...
     case 2:
       arg1 = args(1).make_numeric ();
@@ -309,30 +316,36 @@ column_min (const Octave_object& args, i
 	error ("min: nonconformant matrices");
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
-Octave_object
-column_max (const Octave_object& args, int nargout)
+DEFUN_DLD ("max", Fmax, Smax, 3, 2,
+  "max (X): maximum value(s) of a vector (matrix)")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
+  if (nargin == 1 || nargin > 3 || nargout > 2)
+    {
+      print_usage ("max");
+      return retval;
+    }
+
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
     tree_constant_rep::unknown_constant;
 
-  int nargin = args.length ();
-
   switch (nargin)
     {
     case 3:
       arg2 = args(2).make_numeric ();
       arg2_type = arg2.const_type ();
 // Fall through...
     case 2:
       arg1 = args(1).make_numeric ();
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -28,41 +28,26 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifndef NPSOL_MISSING
 
 #include <strstream.h>
 
 #include "NPSOL.h"
 
 #include "tree-const.h"
 #include "variables.h"
-#include "builtins.h"
 #include "gripes.h"
 #include "error.h"
 #include "pager.h"
 #include "utils.h"
-#include "f-npsol.h"
+#include "defun-dld.h"
 
 // Global pointers for user defined functions required by npsol.
 static tree_fvc *npsol_objective;
 static tree_fvc *npsol_constraints;
 
-#ifdef WITH_DLD
-Octave_object
-builtin_npsol_2 (const Octave_object& args, int nargout)
-{
-  return npsol (args, nargout);
-}
-
-Octave_object
-builtin_npsol_options_2 (const Octave_object& args, int nargout)
-{
-  return npsol_options (args, nargout);
-}
-#endif
-
 static NPSOL_options npsol_opts;
 
 double
 npsol_objective_function (const ColumnVector& x)
 {
   int n = x.capacity ();
 
   tree_constant decision_vars;
@@ -83,17 +68,17 @@ npsol_objective_function (const ColumnVe
   Octave_object args (2);
 //  args(0) = name;
   args(1) = decision_vars;
 
   static double retval;
   retval = 0.0;
 
   tree_constant objective_value;
-  if (npsol_objective != (tree_fvc *) NULL)
+  if (npsol_objective)
     {
       Octave_object tmp = npsol_objective->eval (0, 1, args);
 
       if (error_state)
 	{
 	  error ("npsol: error evaluating objective function");
 	  npsol_objective_error = 1; // XXX FIXME XXX
 	  return retval;
@@ -156,17 +141,17 @@ npsol_constraint_function (const ColumnV
       decision_vars = d;
     }
 
 //  tree_constant name = npsol_constraints->name ();
   Octave_object args (2);
 //  args(0) = name;
   args(1) = decision_vars;
 
-  if (npsol_constraints != (tree_fvc *)NULL)
+  if (npsol_constraints)
     {
       Octave_object tmp = npsol_constraints->eval (0, 1, args);
 
       if (error_state)
 	{
 	  error ("npsol: error evaluating constraints");
 	  return retval;
 	}
@@ -240,50 +225,91 @@ nonlinear_constraints_ok (const ColumnVe
 	  ok = 0;
 	  error ("%s: nonlinear constraints have inconsistent dimensions",
 		 warn_for);
 	}
     }
   return ok;
 }
 
-Octave_object
-npsol (const Octave_object& args, int nargout)
+#if defined (NPSOL_MISSING)
+DEFUN_DLD ("npsol", Fnpsol, Snpsol, 11, 3,
+  "This function requires NPSOL, which is not freely\n\
+redistributable.  For more information, read the file\n\
+libcruft/npsol/README.MISSING in the source distribution.")
+#else
+DEFUN_DLD ("npsol", Fnpsol, Snpsol, 11, 3,
+  "[X, OBJ, INFO, LAMBDA] = npsol (X, PHI [, LB, UB] [, LB, A, UB] [, LB, G, UB])\n\
+\n\
+Groups of arguments surrounded in `[]' are optional, but\n\
+must appear in the same relative order shown above.\n\
+\n\
+The second argument is a string containing the name of the objective\n\
+function to call.  The objective function must be of the form\n\
+\n\
+  y = phi (x)\n\
+\n\
+where x is a vector and y is a scalar.\n\
+\n\
+The argument G is a string containing the name of the function that
+defines the nonlinear constraints.  It must be of the form\n\
+\n\
+  y = g (x)\n\
+\n\
+where x is a vector and y is a vector.")
+#endif
 {
 /*
 
 Handle all of the following:
 
   1. npsol (x, phi)
   2. npsol (x, phi, lb, ub)
   3. npsol (x, phi, lb, ub, llb, c, lub)
   4. npsol (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
   5. npsol (x, phi, lb, ub,              nllb, g, nlub)
   6. npsol (x, phi,         llb, c, lub, nllb, g, nlub)
   7. npsol (x, phi,         llb, c, lub)
   8. npsol (x, phi,                      nllb, g, nlub)
 
 */
 
-// Assumes that we have been given the correct number of arguments.
-
   Octave_object retval;
 
+#if defined (NPSOL_MISSING)
+
+// Force a bad value of inform, and empty matrices for x, phi, and lambda.
+
+  retval.resize (4, Matrix ());
+
+  retval(2) = -1.0;
+
+  print_usage ("npsol");
+
+#else
+
   int nargin = args.length ();
 
+  if (nargin < 3 || nargin == 4 || nargin == 7 || nargin == 10
+      || nargin > 11 || nargout > 4)
+    {
+      print_usage ("npsol");
+      return retval;
+    }
+
   ColumnVector x = args(1).to_vector ();
 
   if (x.capacity () == 0)
     {
       error ("npsol: expecting vector as first argument");
       return retval;
     }
 
   npsol_objective = is_valid_function (args(2), "npsol", 1);
-  if (npsol_objective == (tree_fvc *) NULL
+  if (! npsol_objective
       || takes_correct_nargs (npsol_objective, 2, "npsol", 1) != 1)
     return retval;
 
   Objective func (npsol_objective_function);
 
   ColumnVector soln;
 
   Bounds bounds;
@@ -327,23 +353,23 @@ Handle all of the following:
 
       NPSOL nlp (x, func, bounds);
       nlp.copy (npsol_opts);
       soln = nlp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
-  npsol_constraints = (tree_fvc *) NULL;
+  npsol_constraints = 0;
   if (nargin == 6 || nargin == 8 || nargin == 9 || nargin == 11)
     npsol_constraints = is_valid_function (args(nargin-2), "npsol", 0);
 
   if (nargin == 8 || nargin == 6)
     {
-      if (npsol_constraints == (tree_fvc *) NULL)
+      if (! npsol_constraints)
 	{
 	  ColumnVector lub = args(nargin-1).to_vector ();
 	  Matrix c = args(nargin-2).to_matrix ();
 	  ColumnVector llb = args(nargin-3).to_vector ();
 
 	  if (llb.capacity () == 0 || lub.capacity () == 0)
 	    {
 	      error ("npsol: bounds for linear constraints must be vectors");
@@ -406,17 +432,17 @@ Handle all of the following:
 		}
 	      goto solved;
 	    }
 	}
     }
 
   if (nargin == 9 || nargin == 11)
     {
-      if (npsol_constraints == (tree_fvc *) NULL)
+      if (! npsol_constraints)
 	{
 	  // Produce error message.
 	  is_valid_function (args(nargin-2), "npsol", 1);
 	}
       else
 	{
 	  if (takes_correct_nargs (npsol_constraints, 2, "npsol", 1))
 	    {
@@ -477,16 +503,18 @@ Handle all of the following:
   retval(0) = soln, 1;
   if (nargout > 1)
     retval(1) = objf;
   if (nargout > 2)
     retval(2) = (double) inform;
   if (nargout > 3)
     retval(3) = lambda;
 
+#endif
+
   return retval;
 }
 
 typedef void (NPSOL_options::*d_set_opt_mf) (double);
 typedef void (NPSOL_options::*i_set_opt_mf) (int);
 typedef double (NPSOL_options::*d_get_opt_mf) (void);
 typedef int (NPSOL_options::*i_get_opt_mf) (void);
 
@@ -502,139 +530,139 @@ struct NPSOL_OPTIONS
   i_set_opt_mf i_set_fcn;
   d_get_opt_mf d_get_fcn;
   i_get_opt_mf i_get_fcn;
 };
 
 static NPSOL_OPTIONS npsol_option_table [] =
 {
   { "central difference interval",
-    { "central", "difference", "interval", NULL, NULL, NULL, },
+    { "central", "difference", "interval", 0, 0, 0, },
     { 2, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_central_difference_interval, NULL,
-    NPSOL_options::central_difference_interval, NULL, },
+    NPSOL_options::set_central_difference_interval, 0,
+    NPSOL_options::central_difference_interval, 0, },
 
   { "crash tolerance",
-    { "crash", "tolerance", NULL, NULL, NULL, NULL, },
+    { "crash", "tolerance", 0, 0, 0, 0, },
     { 2, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_crash_tolerance, NULL,
-    NPSOL_options::crash_tolerance, NULL, },
+    NPSOL_options::set_crash_tolerance, 0,
+    NPSOL_options::crash_tolerance, 0, },
 
   { "derivative level",
-    { "derivative", "level", NULL, NULL, NULL, NULL, },
+    { "derivative", "level", 0, 0, 0, 0, },
     { 1, 0, 0, 0, 0, 0, }, 1,
-    NULL, NPSOL_options::set_derivative_level,
-    NULL, NPSOL_options::derivative_level, },
+    0, NPSOL_options::set_derivative_level,
+    0, NPSOL_options::derivative_level, },
 
   { "difference interval",
-    { "difference", "interval", NULL, NULL, NULL, NULL, },
+    { "difference", "interval", 0, 0, 0, 0, },
     { 3, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_difference_interval, NULL,
-    NPSOL_options::difference_interval, NULL, },
+    NPSOL_options::set_difference_interval, 0,
+    NPSOL_options::difference_interval, 0, },
 
   { "function precision",
-    { "function", "precision", NULL, NULL, NULL, NULL, },
+    { "function", "precision", 0, 0, 0, 0, },
     { 2, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_function_precision, NULL,
-    NPSOL_options::function_precision, NULL, },
+    NPSOL_options::set_function_precision, 0,
+    NPSOL_options::function_precision, 0, },
 
   { "infinite bound size",
-    { "infinite", "bound", "size", NULL, NULL, NULL, },
+    { "infinite", "bound", "size", 0, 0, 0, },
     { 1, 1, 0, 0, 0, 0, }, 2,
-    NPSOL_options::set_infinite_bound, NULL,
-    NPSOL_options::infinite_bound, NULL, },
+    NPSOL_options::set_infinite_bound, 0,
+    NPSOL_options::infinite_bound, 0, },
 
   { "infinite step size",
-    { "infinite", "step", "size", NULL, NULL, NULL, },
+    { "infinite", "step", "size", 0, 0, 0, },
     { 1, 1, 0, 0, 0, 0, }, 2,
-    NPSOL_options::set_infinite_step, NULL,
-    NPSOL_options::infinite_step, NULL, },
+    NPSOL_options::set_infinite_step, 0,
+    NPSOL_options::infinite_step, 0, },
 
   { "linear feasibility tolerance",
-    { "linear", "feasibility", "tolerance", NULL, NULL, NULL, },
+    { "linear", "feasibility", "tolerance", 0, 0, 0, },
     { 5, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_linear_feasibility_tolerance, NULL,
-    NPSOL_options::linear_feasibility_tolerance, NULL, },
+    NPSOL_options::set_linear_feasibility_tolerance, 0,
+    NPSOL_options::linear_feasibility_tolerance, 0, },
 
   { "linesearch tolerance",
-    { "linesearch", "tolerance", NULL, NULL, NULL, NULL, },
+    { "linesearch", "tolerance", 0, 0, 0, 0, },
     { 5, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_linesearch_tolerance, NULL,
-    NPSOL_options::linesearch_tolerance, NULL, },
+    NPSOL_options::set_linesearch_tolerance, 0,
+    NPSOL_options::linesearch_tolerance, 0, },
 
   { "major iteration limit",
-    { "major", "iteration", "limit", NULL, NULL, NULL, },
+    { "major", "iteration", "limit", 0, 0, 0, },
     { 2, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_major_iteration_limit,
-    NULL, NPSOL_options::major_iteration_limit, },
+    0, NPSOL_options::set_major_iteration_limit,
+    0, NPSOL_options::major_iteration_limit, },
 
   { "minor iteration limit",
-    { "minor", "iteration", "limit", NULL, NULL, NULL, },
+    { "minor", "iteration", "limit", 0, 0, 0, },
     { 2, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_minor_iteration_limit,
-    NULL, NPSOL_options::minor_iteration_limit, },
+    0, NPSOL_options::set_minor_iteration_limit,
+    0, NPSOL_options::minor_iteration_limit, },
 
   { "major print level",
-    { "major", "print", "level", NULL, NULL, NULL, },
+    { "major", "print", "level", 0, 0, 0, },
     { 2, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_major_print_level,
-    NULL, NPSOL_options::major_print_level, },
+    0, NPSOL_options::set_major_print_level,
+    0, NPSOL_options::major_print_level, },
 
   { "minor print level",
-    { "minor", "print", "level", NULL, NULL, NULL, },
+    { "minor", "print", "level", 0, 0, 0, },
     { 2, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_minor_print_level,
-    NULL, NPSOL_options::minor_print_level, },
+    0, NPSOL_options::set_minor_print_level,
+    0, NPSOL_options::minor_print_level, },
 
   { "nonlinear feasibility tolerance",
-    { "nonlinear", "feasibility", "tolerance", NULL, NULL, },
+    { "nonlinear", "feasibility", "tolerance", 0, 0, },
     { 1, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_nonlinear_feasibility_tolerance, NULL,
-    NPSOL_options::nonlinear_feasibility_tolerance, NULL, },
+    NPSOL_options::set_nonlinear_feasibility_tolerance, 0,
+    NPSOL_options::nonlinear_feasibility_tolerance, 0, },
 
   { "optimality tolerance",
-    { "optimality", "tolerance", NULL, NULL, NULL, NULL, },
+    { "optimality", "tolerance", 0, 0, 0, 0, },
     { 1, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_optimality_tolerance, NULL,
-    NPSOL_options::optimality_tolerance, NULL, },
+    NPSOL_options::set_optimality_tolerance, 0,
+    NPSOL_options::optimality_tolerance, 0, },
 
   { "start objective check at variable",
-    { "start", "objective", "check", "at", "variable", NULL, },
+    { "start", "objective", "check", "at", "variable", 0, },
     { 3, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_start_objective_check,
-    NULL, NPSOL_options::start_objective_check, },
+    0, NPSOL_options::set_start_objective_check,
+    0, NPSOL_options::start_objective_check, },
 
   { "start constraint check at variable",
-    { "start", "constraint", "check", "at", "variable", NULL, },
+    { "start", "constraint", "check", "at", "variable", 0, },
     { 3, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_start_constraint_check,
-    NULL, NPSOL_options::start_constraint_check, },
+    0, NPSOL_options::set_start_constraint_check,
+    0, NPSOL_options::start_constraint_check, },
 
   { "stop objective check at variable",
-    { "stop", "objective", "check", "at", "variable", NULL, },
+    { "stop", "objective", "check", "at", "variable", 0, },
     { 3, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_stop_objective_check,
-    NULL, NPSOL_options::stop_objective_check, },
+    0, NPSOL_options::set_stop_objective_check,
+    0, NPSOL_options::stop_objective_check, },
 
   { "stop constraint check at variable",
-    { "stop", "constraint", "check", "at", "variable", NULL, },
+    { "stop", "constraint", "check", "at", "variable", 0, },
     { 3, 1, 0, 0, 0, 0, }, 2,
-    NULL, NPSOL_options::set_stop_constraint_check,
-    NULL, NPSOL_options::stop_constraint_check, },
+    0, NPSOL_options::set_stop_constraint_check,
+    0, NPSOL_options::stop_constraint_check, },
 
   { "verify level",
-    { "verify", "level", NULL, NULL, NULL, NULL, },
+    { "verify", "level", 0, 0, 0, 0, },
     { 1, 0, 0, 0, 0, 0, }, 1,
-    NULL, NPSOL_options::set_verify_level,
-    NULL, NPSOL_options::verify_level, },
+    0, NPSOL_options::set_verify_level,
+    0, NPSOL_options::verify_level, },
 
-  { NULL,
-    { NULL, NULL, NULL, NULL, NULL, NULL, },
+  { 0,
+    { 0, 0, 0, 0, 0, 0, },
     { 0, 0, 0, 0, 0, 0, }, 0,
-    NULL, NULL, NULL, NULL, },
+    0, 0, 0, 0, },
 };
 
 static void
 print_npsol_option_list (void)
 {
   ostrstream output_buf;
 
   print_usage ("npsol_options", 1);
@@ -642,17 +670,17 @@ print_npsol_option_list (void)
   output_buf << "\n"
 	     << "Options for npsol include:\n\n"
 	     << "  keyword                                  value\n"
 	     << "  -------                                  -----\n\n";
 
   NPSOL_OPTIONS *list = npsol_option_table;
 
   char *keyword;
-  while ((keyword = list->keyword) != (char *) NULL)
+  while ((keyword = list->keyword) != 0)
     {
       output_buf.form ("  %-40s ", keyword);
       if (list->d_get_fcn)
 	{
 	  double val = (npsol_opts.*list->d_get_fcn) ();
 	  if (val < 0.0)
 	    output_buf << "computed automatically";
 	  else
@@ -674,17 +702,17 @@ print_npsol_option_list (void)
   maybe_page_output (output_buf);
 }
 
 static void
 do_npsol_option (char *keyword, double val)
 {
   NPSOL_OPTIONS *list = npsol_option_table;
 
-  while (list->keyword != (char *) NULL)
+  while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  if (list->d_set_fcn)
 	    (npsol_opts.*list->d_set_fcn) (val);
 	  else
 	    (npsol_opts.*list->i_set_fcn) (NINT (val));
@@ -692,21 +720,37 @@ do_npsol_option (char *keyword, double v
 	  return;
 	}
       list++;
     }
 
   warning ("npsol_options: no match for `%s'", keyword);
 }
 
-Octave_object
-npsol_options (const Octave_object& args, int nargout)
+#if defined (NPSOL_MISSING)
+DEFUN_DLD ("npsol_options", Fnpsol_options, Snpsol_options, -1, 1,
+  "This function requires NPSOL, which is not freely\n\
+redistributable.  For more information, read the file\n\
+libcruft/npsol/README.MISSING in the source distribution.")
+#else
+DEFUN_DLD ("npsol_options", Fnpsol_options, Snpsol_options, -1, 1,
+  "npsol_options (KEYWORD, VALUE)\n\
+\n\
+Set or show options for npsol.  Keywords may be abbreviated\n\
+to the shortest match.")
+#endif
 {
   Octave_object retval;
 
+#if defined (NPSOL_MISSING)
+
+  print_usage ("npsol_options");
+
+#else
+
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       print_npsol_option_list ();
     }
   else if (nargin == 3)
     {
@@ -719,16 +763,18 @@ npsol_options (const Octave_object& args
       else
 	print_usage ("npsol_options");
     }
   else
     {
       print_usage ("npsol_options");
     }
 
+#endif
+
   return retval;
 }
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -32,61 +32,74 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "QPSOL.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "gripes.h"
 #include "error.h"
 #include "utils.h"
 #include "pager.h"
-#include "f-qpsol.h"
+#include "defun-dld.h"
 
 // This should probably be defined in some shared file and declared in
 // a header file...
 extern int linear_constraints_ok (const ColumnVector& x,
 				  const ColumnVector& llb, const Matrix& c,
 				  const ColumnVector& lub, char *warn_for,
 				  int warn);
 
-#ifdef WITH_DLD
-Octave_object
-builtin_qpsol_2 (const Octave_object& args, int nargout)
-{
-  return qpsol (args, nargout);
-}
-
-Octave_object
-builtin_qpsol_options_2 (const Octave_object& args, int nargout)
-{
-  return qpsol_options (args, nargout);
-}
-#endif
-
 static QPSOL_options qpsol_opts;
 
-Octave_object
-qpsol (const Octave_object& args, int nargout)
+#if defined (QPSOL_MISSING)
+DEFUN_DLD ("qpsol", Fqpsol, Sqpsol, 9, 3,
+  "This function requires QPSOL, which is not freely\n\
+redistributable.  For more information, read the file\n\
+libcruft/qpsol/README.MISSING in the source distribution.")
+#else
+DEFUN_DLD ("qpsol", Fqpsol, Sqpsol, 9, 3,
+  "[X, OBJ, INFO, LAMBDA] = qpsol (X, H, C [, LB, UB] [, LB, A, UB])\n\
+\n\
+Groups of arguments surrounded in `[]' are optional, but\n\
+must appear in the same relative order shown above.")
+#endif
 {
 /*
 
 Handle all of the following:
 
   1. qpsol (x, H, c)
   2. qpsol (x, H, c, lb, ub)
   3. qpsol (x, H, c, lb, ub, llb, A, lub)
   4. qpsol (x, H, c,         llb, A, lub)
 
 */
 
-// Assumes that we have been given the correct number of arguments.
-
   Octave_object retval;
 
+#if defined (QPSOL_MISSING)
+
+// Force a bad value of inform, and empty matrices for x, phi, and lambda.
+
+  retval.resize (4, Matrix ());
+
+  retval(2) = -1.0;
+
+  print_usage ("qpsol");
+
+#else
+
   int nargin = args.length ();
 
+  if (nargin < 4 || nargin == 5 || nargin == 8 || nargin > 9
+      || nargout > 4)
+    {
+      print_usage ("qpsol");
+      return retval;
+    }
+
   ColumnVector x = args(1).to_vector ();
   if (x.capacity () == 0)
     {
       error ("qpsol: expecting vector as first argument");
       return retval;
     }
 
   Matrix H = args(2).to_matrix ();
@@ -194,16 +207,18 @@ Handle all of the following:
   retval(0) = soln, 1;
   if (nargout > 1)
     retval(1) = objf;
   if (nargout > 2)
     retval(2) = (double) inform;
   if (nargout > 3)
     retval(3) = lambda;
 
+#endif
+
   return retval;
 }
 
 typedef void (QPSOL_options::*d_set_opt_mf) (double);
 typedef void (QPSOL_options::*i_set_opt_mf) (int);
 typedef double (QPSOL_options::*d_get_opt_mf) (void);
 typedef int (QPSOL_options::*i_get_opt_mf) (void);
 
@@ -219,43 +234,43 @@ struct QPSOL_OPTIONS
   i_set_opt_mf i_set_fcn;
   d_get_opt_mf d_get_fcn;
   i_get_opt_mf i_get_fcn;
 };
 
 static QPSOL_OPTIONS qpsol_option_table [] =
 {
   { "feasibility tolerance",
-    { "feasibility", "tolerance", NULL, },
+    { "feasibility", "tolerance", 0, },
     { 1, 0, 0, }, 1,
-    QPSOL_options::set_feasibility_tolerance, NULL,
-    QPSOL_options::feasibility_tolerance, NULL, },
+    QPSOL_options::set_feasibility_tolerance, 0,
+    QPSOL_options::feasibility_tolerance, 0, },
 
   { "infinite bound",
-    { "infinite", "bound", NULL, },
+    { "infinite", "bound", 0, },
     { 2, 0, 0, }, 1,
-    QPSOL_options::set_infinite_bound, NULL,
-    QPSOL_options::infinite_bound, NULL, },
+    QPSOL_options::set_infinite_bound, 0,
+    QPSOL_options::infinite_bound, 0, },
 
   { "iteration limit",
-    { "iteration", "limit", NULL, },
+    { "iteration", "limit", 0, },
     { 2, 0, 0, }, 1,
-    NULL, QPSOL_options::set_iteration_limit,
-    NULL, QPSOL_options::iteration_limit, },
+    0, QPSOL_options::set_iteration_limit,
+    0, QPSOL_options::iteration_limit, },
 
   { "print level",
-    { "print", "level", NULL, },
+    { "print", "level", 0, },
     { 1, 0, 0, }, 1,
-    NULL, QPSOL_options::set_print_level,
-    NULL, QPSOL_options::print_level, },
+    0, QPSOL_options::set_print_level,
+    0, QPSOL_options::print_level, },
 
-  { NULL,
-    { NULL, NULL, NULL, },
+  { 0,
+    { 0, 0, 0, },
     { 0, 0, 0, }, 0,
-    NULL, NULL, NULL, NULL, },
+    0, 0, 0, 0, },
 };
 
 static void
 print_qpsol_option_list (void)
 {
   ostrstream output_buf;
 
   print_usage ("qpsol_options", 1);
@@ -263,17 +278,17 @@ print_qpsol_option_list (void)
   output_buf << "\n"
 	     << "Options for qpsol include:\n\n"
 	     << "  keyword                                  value\n"
 	     << "  -------                                  -----\n\n";
 
   QPSOL_OPTIONS *list = qpsol_option_table;
 
   char *keyword;
-  while ((keyword = list->keyword) != (char *) NULL)
+  while ((keyword = list->keyword) != 0)
     {
       output_buf.form ("  %-40s ", keyword);
       if (list->d_get_fcn)
 	{
 	  double val = (qpsol_opts.*list->d_get_fcn) ();
 	  if (val < 0.0)
 	    output_buf << "computed automatically";
 	  else
@@ -295,17 +310,17 @@ print_qpsol_option_list (void)
   maybe_page_output (output_buf);
 }
 
 static void
 do_qpsol_option (char *keyword, double val)
 {
   QPSOL_OPTIONS *list = qpsol_option_table;
 
-  while (list->keyword != (char *) NULL)
+  while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  if (list->d_set_fcn)
 	    (qpsol_opts.*list->d_set_fcn) (val);
 	  else
 	    (qpsol_opts.*list->i_set_fcn) (NINT (val));
@@ -313,21 +328,37 @@ do_qpsol_option (char *keyword, double v
 	  return;
 	}
       list++;
     }
 
   warning ("qpsol_options: no match for `%s'", keyword);
 }
 
-Octave_object
-qpsol_options (const Octave_object& args, int nargout)
+#if defined (QPSOL_MISSING)
+DEFUN_DLD ("qpsol_options", Fqpsol_options, Sqpsol_options, -1, 1,
+  "This function requires QPSOL, which is not freely\n\
+redistributable.  For more information, read the file\n\
+libcruft/qpsol/README.MISSING in the source distribution.")
+#else
+DEFUN_DLD ("qpsol_options", Fqpsol_options, Sqpsol_options, -1, 1,
+  "qpsol_options (KEYWORD, VALUE)\n
+\n\
+Set or show options for qpsol.  Keywords may be abbreviated\n\
+to the shortest match.")
+#endif
 {
   Octave_object retval;
 
+#if defined (QPSOL_MISSING)
+
+  print_usage ("qpsol");
+
+#else
+
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       print_qpsol_option_list ();
     }
   else if (nargin == 3)
     {
@@ -340,16 +371,18 @@ qpsol_options (const Octave_object& args
       else
 	print_usage ("qpsol_options");
     }
   else
     {
       print_usage ("qpsol_options");
     }
 
+#endif
+
   return retval;
 }
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -26,83 +26,83 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "dbleQR.h"
 #include "CmplxQR.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
-#include "f-qr.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_qr_2 (const Octave_object& args, int nargout)
+DEFUN_DLD ("qr", Fqr, Sqr, 2, 2,
+  "[Q, R] = qr (X): form QR factorization of X")
 {
-  return qr (args(1), nargout);
-}
-#endif
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-Octave_object
-qr (const tree_constant& a, int nargout)
-{
-  Octave_object retval (2);
+  if (nargin != 2 || nargout > 2)
+    {
+      print_usage ("qr");
+      return retval;
+    }
 
-  tree_constant tmp = a.make_numeric ();;
+  tree_constant tmp = args(1).make_numeric ();
     
   int nr = tmp.rows ();
   int nc = tmp.columns ();
 
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("qr", 0);
 	  Matrix m;
+	  retval(1) = m;
 	  retval(0) = m;
-	  retval(1) = m;
 	}
       else
 	gripe_empty_arg ("qr", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	QR fact (m);
+	retval(1) = fact.R ();
 	retval(0) = fact.Q ();
-	retval(1) = fact.R ();
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 	ComplexQR fact (m);
+	retval(1) = fact.R ();
 	retval(0) = fact.Q ();
-	retval(1) = fact.R ();
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
+	retval(1) = d;
 	retval(0) = 1.0;
-	retval(1) = d;
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
+	retval(1) = c;
 	retval(0) = 1.0;
-	retval(1) = c;
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -31,48 +31,34 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "variables.h"
 #include "mappers.h"
 #include "gripes.h"
 #include "error.h"
 #include "utils.h"
 #include "pager.h"
-#include "f-quad.h"
+#include "defun-dld.h"
 
 // Global pointer for user defined function required by quadrature functions.
 static tree_fvc *quad_fcn;
 
-#ifdef WITH_DLD
-Octave_object
-builtin_quad_2 (const Octave_object& args, int nargout)
-{
-  return do_quad (args, nargout);
-}
-
-Octave_object
-builtin_quad_options_2 (const Octave_object& args, int nargout)
-{
-  return quad_options (args, nargout);
-}
-#endif
-
 static Quad_options quad_opts;
 
 double
 quad_user_function (double x)
 {
   double retval = 0.0;
 
 //  tree_constant name = quad_fcn->name ();
   Octave_object args (2);
 //  args(0) = name;
   args(1) = x;
 
-  if (quad_fcn != (tree_fvc *) NULL)
+  if (quad_fcn)
     {
       Octave_object tmp = quad_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	  return retval;
@@ -85,28 +71,43 @@ quad_user_function (double x)
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	}
     }
 
   return retval;
 }
 
-Octave_object
-do_quad (const Octave_object& args, int nargout)
+DEFUN_DLD ("quad", Fquad, Squad, 6, 3,
+  "[V, IER, NFUN] = quad (F, A, B [, TOL] [, SING])\n\
+\n\
+Where the first argument is the name of the  function to call to\n\
+compute the value of the integrand.  It must have the form\n\
+\n\
+  y = f (x)
+\n\
+where y and x are scalars.\n\
+\n\
+The second and third arguments are limits of integration.  Either or\n\
+both may be infinite.  The optional argument TOL specifies the desired\n\
+accuracy of the result.  The optional argument SING is a vector of\n\
+at which the integrand is singular.")
 {
-// Assumes that we have been given the correct number of arguments.
-
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin < 4 || nargin > 6 || nargout > 4)
+    {
+      print_usage ("quad");
+      return retval;
+    }
+
   quad_fcn = is_valid_function (args(1), "fsolve", 1);
-  if (quad_fcn == (tree_fvc *) NULL
-      || takes_correct_nargs (quad_fcn, 2, "fsolve", 1) != 1)
+  if (! quad_fcn || takes_correct_nargs (quad_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
   double a = args(2).to_scalar ();
   double b = args(3).to_scalar ();
 
   int indefinite = 0;
   IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
   double bound = 0.0;
@@ -211,31 +212,31 @@ struct QUAD_OPTIONS
   int min_toks_to_match;
   d_set_opt_mf d_set_fcn;
   d_get_opt_mf d_get_fcn;
 };
 
 static QUAD_OPTIONS quad_option_table [] =
 {
   { "absolute tolerance",
-    { "absolute", "tolerance", NULL, },
+    { "absolute", "tolerance", 0, },
     { 1, 0, 0, }, 1,
     Quad_options::set_absolute_tolerance,
     Quad_options::absolute_tolerance, },
 
   { "relative tolerance",
-    { "relative", "tolerance", NULL, },
+    { "relative", "tolerance", 0, },
     { 1, 0, 0, }, 1,
     Quad_options::set_relative_tolerance,
     Quad_options::relative_tolerance, },
 
-  { NULL,
-    { NULL, NULL, NULL, },
+  { 0,
+    { 0, 0, 0, },
     { 0, 0, 0, }, 0,
-    NULL, NULL, },
+    0, 0, },
 };
 
 static void
 print_quad_option_list (void)
 {
   ostrstream output_buf;
 
   print_usage ("quad_options", 1);
@@ -243,17 +244,17 @@ print_quad_option_list (void)
   output_buf << "\n"
 	     << "Options for quad include:\n\n"
 	     << "  keyword                                  value\n"
 	     << "  -------                                  -----\n\n";
 
   QUAD_OPTIONS *list = quad_option_table;
 
   char *keyword;
-  while ((keyword = list->keyword) != (char *) NULL)
+  while ((keyword = list->keyword) != 0)
     {
       output_buf.form ("  %-40s ", keyword);
 
       double val = (quad_opts.*list->d_get_fcn) ();
       if (val < 0.0)
 	output_buf << "computed automatically";
       else
 	output_buf << val;
@@ -266,33 +267,36 @@ print_quad_option_list (void)
   maybe_page_output (output_buf);
 }
 
 static void
 do_quad_option (char *keyword, double val)
 {
   QUAD_OPTIONS *list = quad_option_table;
 
-  while (list->keyword != (char *) NULL)
+  while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (quad_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
   warning ("quad_options: no match for `%s'", keyword);
 }
 
-Octave_object
-quad_options (const Octave_object& args, int nargout)
+DEFUN_DLD ("quad_options", Fquad_options, Squad_options, -1, 1,
+  "quad_options (KEYWORD, VALUE)\n\
+\n\
+Set or show options for quad.  Keywords may be abbreviated\n\
+to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     print_quad_option_list ();
   else if (nargin == 3)
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -1,9 +1,9 @@
-// tc-qzval.cc                                           -*- C++ -*-
+// f-qzval.cc                                           -*- C++ -*-
 /*
 
 Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -33,43 +33,46 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dColVector.h"
 #include "CColVector.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-qzval.h"
+#include "defun-dld.h"
 
 extern "C"
 {
   int F77_FCN (qzhes) (const int*, const int*, double*, double*, const
 		       long*, double*);
  
   int F77_FCN (qzit) (const int*, const int*, double*, double*, const
 		      double*, const long*, double*, int*);
  
   int F77_FCN (qzval) (const int*, const int*, double*, double*,
 		       double*, double*, double*, const long*, double*);
 }
 
-#ifdef WITH_DLD
-Octave_object
-builtin_qzvalue_2 (const Octave_object& args, int nargout)
-{
-  return qzvalue (args, nargout);
-}
-#endif
-
-Octave_object
-qzvalue (const Octave_object& args, int nargout)
+DEFUN_DLD ("qzvalue", Fqzvalue, Sqzvalue, 3, 1,
+  "X = qzval (A, B)\n\
+\n\
+compute generalized eigenvalues of the matrix pencil (A - lambda B).\n\
+A and B must be real matrices.")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
+  if (nargin != 3 || nargout > 1)
+    {
+      print_usage ("qzvalue");
+      return retval;
+    }
+
   tree_constant arga = args(1).make_numeric ();
   tree_constant argb = args(2).make_numeric();
 
   if (arga.is_empty () || argb.is_empty ())
     retval = vector_of_empties (nargout, "qzvalue");
   else
     {
 
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -20,44 +20,38 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#include <time.h>
+
 #include "tree-const.h"
 #include "f77-uscore.h"
 #include "error.h"
 #include "utils.h"
-#include "f-rand.h"
+#include "defun-dld.h"
 
 // Possible distributions of random numbers.
 enum rand_dist { uniform, normal };
 
 // Current distribution of random numbers.
 static rand_dist current_distribution = uniform;
 
 extern "C"
 {
   int *F77_FCN (dgennor) (double*, double*, double*);
   int *F77_FCN (dgenunf) (double*, double*, double*);
   int *F77_FCN (setall) (int*, int*);
   int *F77_FCN (getsd) (int*, int*);
 }
 
-#ifdef WITH_DLD
-Octave_object
-builtin_rand_2 (const Octave_object& args, int nargout)
-{
-  return rand_internal (args, nargout);
-}
-#endif
-
 static double
 curr_rand_seed (void)
 {
   union d2i { double d; int i[2]; };
   union d2i u;
   F77_FCN (getsd) (&(u.i[0]), &(u.i[1]));
   return u.d;
 }
@@ -93,29 +87,41 @@ curr_rand_dist (void)
 {
   if (current_distribution == uniform)
     return "uniform";
   else if (current_distribution == normal)
     return "normal";
   else
     {
       panic_impossible ();
-      return (char *) NULL;
+      return 0;
     }
 }
 
-Octave_object
-rand_internal (const Octave_object& args, int nargout)
+DEFUN_DLD ("rand", Frand, Srand, 2, 1,
+  "rand                  -- generate a random value\n\
+\n\
+rand (N)              -- generate N x N matrix\n\
+rand (A)              -- generate matrix the size of A\n\
+rand (N, M)           -- generate N x M matrix\n\
+rand (\"dist\")         -- get current distribution\n\
+rand (DISTRIBUTION)   -- set distribution type (\"normal\" or \"uniform\"\n\
+rand (SEED)           -- get current seed\n\
+rand (SEED, N)        -- set seed")
 {
-// Assumes that we have been given the correct number of arguments.
-
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin > 3 || nargout > 1)
+    {
+      print_usage ("rand");
+      return retval;
+    }
+
   static int initialized = 0;
   if (! initialized)
     {
 // Make the random number generator give us a different sequence every
 // time we start octave unless we specifically set the seed.
 #if 0
       int s0 = 1234567890;
       int s1 = 123456789;
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -27,33 +27,41 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleSCHUR.h"
 #include "CmplxSCHUR.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
-#include "f-schur.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_schur_2 (const Octave_object& args, int nargout)
-{
-  return schur (args, nargout);
-}
-#endif
-
-Octave_object
-schur (const Octave_object& args, int nargout)
+DEFUN_DLD ("schur", Fschur, Sschur, 3, 2,
+  "[U, S] = schur (A) or S = schur (A)\n\
+\n\
+or, for ordered Schur:\n\
+\n\
+  [U, S] = schur (A, TYPE) or S = schur (A, TYPE)\n\
+where TYPE is a string that begins with one of the following\n\
+characters:\n\
+\n\
+  A = continuous time poles\n\
+  D = discrete time poles\n\
+  U = unordered schur (default)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
+  if (nargin == 1 || nargin > 3 || nargout > 2)
+    {
+      print_usage ("schur");
+      return retval;
+    }
+
   tree_constant arg = args(1).make_numeric ();
 
   char *ord;
   if (nargin != 3)
     ord = "U";
   else
     ord = args(2).string_value ();
 
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -21,17 +21,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include "tree-const.h"
-#include "f-sort.h"
+#include "defun-dld.h"
 
 static void
 mx_sort (Matrix& m, Matrix& idx, int return_idx)
 {
   int nr = m.rows ();
   int nc = m.columns ();
   idx.resize (nr, nc);
   int i, j;
@@ -157,22 +157,30 @@ mx_sort (ComplexRowVector& cv, RowVector
 	    {
 	      double tmp = idx.elem (k);
 	      idx.elem (k) = idx.elem (k+gap);
 	      idx.elem (k+gap) = tmp;
 	    }
 	}
 }
 
-Octave_object
-sort (const Octave_object& args, int nargout)
+DEFUN_DLD ("sort", Fsort, Ssort, 2, 2,
+  "[S, I] = sort (X)\n\
+\n\
+sort the columns of X, optionally return sort index")
 {
-// Assumes that we have been given the correct number of arguments.
+  Octave_object retval;
+
+  int nargin = args.length ();
 
-  Octave_object retval;
+  if (nargin != 2)
+    {
+      print_usage ("sort");
+      return retval;
+    }
 
   int return_idx = nargout > 1;
   if (return_idx)
     retval.resize (2);
   else
     retval.resize (1);
 
   switch (args(1).const_type ())
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -27,31 +27,33 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleSVD.h"
 #include "CmplxSVD.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-svd.h"
+#include "defun-dld.h"
 
-#ifdef WITH_DLD
-Octave_object
-builtin_svd_2 (const Octave_object& args, int nargout)
-{
-  return svd (args, nargout);
-}
-#endif
-
-Octave_object
-svd (const Octave_object& args, int nargout)
+DEFUN_DLD ("svd", Fsvd, Ssvd, 2, 3,
+  "S = svd (X) or [U, S, V] = svd (X)\n\
+\n\
+compute the singular value decomposition of X")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
+  if (nargin != 2 || nargout == 2 || nargout > 3)
+    {
+      print_usage ("svd");
+      return retval;
+    }
+
   tree_constant arg = args(1).make_numeric ();
 
   if (arg.rows () == 0 || arg.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -1,9 +1,9 @@
-// tc-syl.cc                                           -*- C++ -*-
+// f-syl.cc                                           -*- C++ -*-
 /*
 
 Copyright (C) 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -32,46 +32,46 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dbleSCHUR.h"
 #include "CmplxSCHUR.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
-#include "f-syl.h"
+#include "defun-dld.h"
 
 extern "C"
 {
   int F77_FCN (dtrsyl) (const char*, const char*, const int*,
 			const int*, const int*, const double*,
 			const int*, const double*, const int*,
 			const double*, const int*, double*, int*,
 			long, long);
  
   int F77_FCN (ztrsyl) (const char*, const char*, const int*,
 			const int*, const int*, const Complex*,
 			const int*, const Complex*, const int*,
 			const Complex*, const int*, double*, int*,
 			long, long);
 }
 
-#ifdef WITH_DLD
-Octave_object
-builtin_syl_2 (const Octave_object& args, int nargout)
-{
-  return syl (args, nargout);
-}
-#endif
-
-Octave_object
-syl (const Octave_object& args, int nargout)
+DEFUN_DLD ("syl", Fsyl, Ssyl, 4, 1,
+  "X = syl (A, B, C): solve the Sylvester equation A X + X B + C = 0")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
+  if (nargin != 4 || nargout > 1)
+    {
+      print_usage ("syl");
+      return retval;
+    }
+
   tree_constant arga = args(1).make_numeric ();
   tree_constant argb = args(2).make_numeric ();
   tree_constant argc = args(3).make_numeric ();
 
   if (arga.is_empty () || argb.is_empty () || argc.is_empty ())
     retval = vector_of_empties (nargout, "syl");
   else
     {
