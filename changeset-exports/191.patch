# HG changeset patch
# User jwe
# Date 751938099 0
#      Fri Oct 29 23:41:39 1993 +0000
# Node ID b6b4d8c513fec54fdcba4610626b31e4ec25c20b
# Parent  edfb6cafe85d4129e5cbe75c21101607b5644594
[project @ 1993-10-29 23:41:39 by jwe]

diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -31,56 +31,61 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "Range.h"
 #include "idx-vector.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "utils.h"
 
 idx_vector::idx_vector (const idx_vector& a)
 {
+  initialized = a.initialized;
+
   len = a.len;
   if (len > 0)
     {
       data = new int [len];
       for (int i = 0; i < len; i++)
 	data[i] = a.data[i];
 
       num_zeros = a.num_zeros;
       num_ones = a.num_ones;
       one_zero = a.one_zero;
 
       max_val = a.max_val;
       min_val = a.min_val;
     }
   else
-    data = 0;
+    data = (int *) 0;
 }
 
 static inline int
 tree_to_mat_idx (double x)
 {
   if (x > 0)
     return ((int) (x + 0.5) - 1);
   else
     return ((int) (x - 0.5) - 1);
 }
 
 idx_vector::idx_vector (const Matrix& m, int do_ftn_idx,
 			const char *rc, int z_len = 0)
 {
+  initialized = 0;
+
   int nr = m.rows ();
   int nc = m.columns ();
 
   if (nr == 0 || nc == 0)
     {
       len = 0;
-      data = 0;
+      data = (int *) 0;
       num_zeros = 0;
       num_ones = 0;
       one_zero = 0;
+      initialized = 1;
       return;
     }
   else if (nr > 1 && nc > 1 && do_ftn_idx)
     {
       double *cop_out = m.fortran_vec ();
       len = nr * nc;
       data = new int [len];
       for (int i = 0; i < len; i++)
@@ -97,28 +102,43 @@ idx_vector::idx_vector (const Matrix& m,
     {
       len = nr;
       data = new int [len];
       for (int i = 0; i < len; i++)
 	data[i] = tree_to_mat_idx (m.elem (i, 0));
     }
   else
     {
-      message ((char *) NULL, "invalid matrix index");
-      jump_to_top_level ();
+      error ("invalid matrix used as index");
+      return;
     }
 
   init_state (rc, z_len);
 }
 
 idx_vector::idx_vector (const Range& r)
 {
+  initialized = 0;
+
   len = r.nelem ();
 
-  assert (len != 0);
+  if (len < 0)
+    {
+      error ("invalid range used as index");
+      return;
+    }
+  else if (len == 0)
+    {
+      data = (int *) 0;
+      num_zeros = 0;
+      num_ones = 0;
+      one_zero = 0;
+      initialized = 1;
+      return;
+    }
 
   double b = r.base ();
   double step = r.inc ();
 
   data = new int [len];
 
   for (int i = 0; i < len; i++)
     {
@@ -129,16 +149,18 @@ idx_vector::idx_vector (const Range& r)
   init_state ();
 }
 
 idx_vector&
 idx_vector::operator = (const idx_vector& a)
 {
   if (this != &a)
     {
+      initialized = a.initialized;
+
       delete [] data;
       len = a.len;
       data = new int [len];
       for (int i = 0; i < len; i++)
 	data[i] = a.data[i];
 
       num_zeros = a.num_zeros;
       num_ones = a.num_ones;
@@ -179,29 +201,32 @@ idx_vector::init_state (const char *rc, 
   while (++i < len);
 
   if (one_zero && z_len == len)
     {
       if (num_zeros == len)
 	{
 	  delete [] data;
 	  len = 0;
-	  data = 0;
+	  data = (int *) 0;
 	  num_zeros = 0;
 	  num_ones = 0;
 	  one_zero = 0;
 	}
       else if (num_ones != len || user_pref.prefer_zero_one_indexing)
 	convert_one_zero_to_idx ();
     }
   else if (min_val < 0)
     {
       error ("%s index %d out of range", rc, min_val+1);
-      jump_to_top_level ();
+      initialized = 0;
+      return;
     }
+
+  initialized = 1;
 }
 
 void
 idx_vector::convert_one_zero_to_idx (void)
 {
   if (num_ones == 0)
     {
       len = 0;
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -23,40 +23,41 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_idx_vector_h)
 #define _idx_vector_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include <stdlib.h>
 #include <assert.h>
 
 #define FAIL assert(0) /* XXX FIXME XXX */
 
 class ostream;
 class Matrix;
 class Range;
 
 class idx_vector
 {
 public:
   idx_vector (void);
   idx_vector (const idx_vector& a);
 
   idx_vector (const Matrix& m, int do_ftn_idx,
-	      const char *rc = (char *) NULL, int z_len = 0);
+	      const char *rc = (char *) 0, int z_len = 0);
 
   idx_vector (const Range& r);
 
  ~idx_vector (void);
 
   idx_vector& operator = (const idx_vector& a);
 
+  operator void * () const;
+
   int capacity (void) const;
   int length (void) const;
 
   int elem (int n) const;
   int checkelem (int n) const;
   int operator () (int n) const;
 
 // other stuff
@@ -75,40 +76,48 @@ public:
 private:
 
   int len;
   int one_zero;
   int num_zeros;
   int num_ones;
   int max_val;
   int min_val;
+  int initialized;
   int *data;
 
-  void init_state (const char *rc = (char *) NULL, int z_len = 0);
+  void init_state (const char *rc = (char *) 0, int z_len = 0);
   void convert_one_zero_to_idx (void);
 };
 
 inline idx_vector::idx_vector (void)
-  {
-    len = 0;
-    data = 0;
-    num_zeros = 0;
-    num_ones = 0;
-    one_zero = 0;
-  }
+{
+  len = 0;
+  data = (int *) 0;
+  num_zeros = 0;
+  num_ones = 0;
+  one_zero = 0;
+  initialized = 0;
+}
 
 inline idx_vector::~idx_vector (void)
-  {
-    delete [] data;
-    data = 0;
-    num_zeros = 0;
-    num_ones = 0;
-    len = 0;
-    one_zero = 0;
-  }
+{
+  delete [] data;
+  data = (int *) 0;
+  num_zeros = 0;
+  num_ones = 0;
+  len = 0;
+  one_zero = 0;
+  initialized = 0;
+}
+
+inline idx_vector::operator void * () const
+{
+  return initialized ? (void *) 1 : (void *) 0;
+}
 
 inline int idx_vector::capacity (void) const { return len; }
 inline int idx_vector::length (void) const { return len; }
 
 inline int idx_vector::elem (int n) const { return data[n]; }
 
 inline int
 idx_vector::checkelem (int n) const
diff --git a/src/builtins.cc b/src/builtins.cc
--- a/src/builtins.cc
+++ b/src/builtins.cc
@@ -574,16 +574,19 @@ at which the integrand is singular.\n", 
 static builtin_string_variables string_variables[] =
 {
   { "I", "??", NULL,
     "sqrt (-1)", },
 
   { "Inf", "??", NULL,
     "infinity", },
 
+  { "INFO_FILE", "??", sv_info_file,
+    "name of the Octave info file", },
+
   { "J", "??", NULL,
     "sqrt (-1)", },
 
 #if defined (HAVE_ISNAN)
   { "NaN", "??", NULL,
     "not a number", },
 #endif
 
@@ -837,16 +840,20 @@ install_builtins (void)
   tmp = new tree_constant (get_working_directory ("initialize_globals"));
   bind_protected_variable ("PWD", tmp);
   make_eternal ("PWD");
 
   tmp = new tree_constant (load_path);
   bind_variable ("LOADPATH", tmp);
   make_eternal ("LOADPATH");
 
+  tmp = new tree_constant (info_file);
+  bind_variable ("INFO_FILE", tmp);
+  make_eternal ("INFO_FILE");
+
   tmp = new tree_constant (default_pager ());
   bind_variable ("PAGER", tmp);
   make_eternal ("PAGER");
 
   tmp = new tree_constant (0.0);
   bind_variable ("SEEK_SET", tmp);
   make_eternal ("SEEK_SET");
 
diff --git a/src/g-builtins.cc b/src/g-builtins.cc
--- a/src/g-builtins.cc
+++ b/src/g-builtins.cc
@@ -427,29 +427,36 @@ builtin_eig (const tree_constant *args, 
 		 retval = eig (args, nargin, nargout);)
   else
     print_usage ("eig");
 
   return retval;
 }
 
 /*
- * Print error message and jump to top level.
+ * Print error message and set the error state.  This should
+ * eventually take us up to the top level, possibly printing traceback
+ * messages as we go.
  */
 tree_constant *
 builtin_error (tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
-  if (nargin == 2 && args != NULL_TREE_CONST && args[1].is_defined ())
-    args[1].print_if_string (cerr, 1);
-  else
-    message ((char *) NULL, "unspecified error, jumping to top level...");
+  char *msg = "unspecified_error";
 
-  jump_to_top_level ();
+  if (nargin == 2
+      && args != NULL_TREE_CONST
+      && args[1].is_defined ()
+      && args[1].is_string_type ())
+    {
+      msg = args[1].string_value ();
+    }
+
+  error (msg);
 
   return retval;
 }
 
 /*
  * Evaluate text argument as octave source.
  */
 tree_constant *
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -156,26 +156,29 @@ EXPON	([DdEe][+-]?{D}+)
 			  current_input_column = 1;
 			  quote_is_transpose = 0;
 			  cant_be_identifier = 0;
 			  convert_spaces_to_comma = 1;
 			  return '\n';
 			}
 
 <TEXT_FCN>[\;\,]	{
-			  if (doing_set)
+			  if (doing_set && strcmp (yytext, ",") == 0)
 			    {
 			      yylval.tok_val = new token (yytext);
 			      token_stack.push (yylval.tok_val);
 			      TOK_RETURN (TEXT);
 			    }
 			  else
 			    {
 			      BEGIN 0;
-			      TOK_RETURN (',');
+			      if (strcmp (yytext, ",") == 0)
+				TOK_RETURN (',');
+			      else
+				TOK_RETURN (';');
 			    }
 		        }
 
 <HELP_FCN>[^ \t\n]*{S}*	    |
 <TEXT_FCN>[^ \t\n\;\,]*{S}* {
 			      static char *tok = (char *) NULL;
 			      delete [] tok;
 			      tok = strip_trailing_whitespace (yytext);
@@ -890,28 +893,36 @@ is_keyword (char *s)
     }
 
   int l = input_line_number;
   int c = current_input_column;
 
   int end_found = 0;
   if (strcmp ("break", s) == 0)
     {
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return BREAK;
     }
   else if (strcmp ("continue", s) == 0)
     {
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return CONTINUE;
     }
   else if (strcmp ("else", s) == 0)
     {
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return ELSE;
     }
   else if (strcmp ("elseif", s) == 0)
     {
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return ELSEIF;
     }
   else if (strcmp ("end", s) == 0)
     {
       end_found = 1;
       yylval.tok_val = new token (token::simple_end, l, c);
       token_stack.push (yylval.tok_val);
     }
@@ -938,24 +949,35 @@ is_keyword (char *s)
       end_found = 1;
       yylval.tok_val = new token (token::while_end, l, c);
       token_stack.push (yylval.tok_val);
     }
   else if (strcmp ("for", s) == 0)
     {
       promptflag--;
       looping++;
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return FOR;
     }
   else if (strcmp ("function", s) == 0)
     {
       if (defining_func)
 	{
-	  error ("sorry, nested functions are a no-no...");
-	  jump_to_top_level ();
+	  error ("function keyword invalid within a function body");
+
+	  if ((reading_m_file || reading_script_file)
+	      && curr_m_file_name != (char *) NULL)
+	    error ("defining new function near line %d of file `%s'",
+		   input_line_number,
+		   curr_m_file_name);
+	  else
+	    error ("defining new function near line %d", input_line_number);
+
+	  jump_to_top_level ();  // XXX FIXME XXX
 	}
       else
 	{
 	  tmp_local_sym_tab = new symbol_table ();
 	  curr_sym_tab = tmp_local_sym_tab;
 	  defining_func = 1;
 	  promptflag--;
 	  beginning_of_function = 1;
@@ -980,26 +1002,32 @@ is_keyword (char *s)
       yylval.tok_val = new token (token::three_dee, l, c);
       token_stack.push (yylval.tok_val);
       return PLOT;
     }
   else if (strcmp ("if", s) == 0)
     {
       iffing++;
       promptflag--;
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return IF;
     }
   else if (strcmp ("return", s) == 0)
     {
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return FUNC_RET;
     }
   else if (strcmp ("while", s) == 0)
     {
       promptflag--;
       looping++;
+      yylval.tok_val = new token (l, c);
+      token_stack.push (yylval.tok_val);
       return WHILE;
     }
 
   if (end_found)
     {
       if (! defining_func && ! looping)
 	promptflag++;
       return END;
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -202,16 +202,17 @@ parse_and_execute (FILE *f, int print)
   using_readline = 0;
   saving_history = 0;
 
   unwind_protect_ptr (curr_sym_tab);
 
   int retval;
   do
     {
+      reset_parser ();
       retval = yyparse ();
       if (retval == 0 && global_command != NULL_TREE)
 	{
 	  global_command->eval (print);
 	  delete global_command;
 	}
     }
   while (retval == 0);
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -31,17 +31,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "procstream.h"
 
 #include "user-prefs.h"
 #include "input.h"
 #include "pager.h"
 
 // Where we stash output headed for the screen.
-static ostrstream *pager_buf;
+static ostrstream *pager_buf = (ostrstream *) NULL;
 
 static int
 line_count (char *s)
 {
   int count = 0;
   if (s != (char *) NULL)
     {
       char c;
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -167,19 +167,20 @@ static void maybe_warn_assign_as_truth_v
 %token <tok_val> EXPR_LT EXPR_LE EXPR_EQ EXPR_NE EXPR_GE EXPR_GT
 %token <tok_val> LEFTDIV EMUL EDIV ELEFTDIV QUOTE TRANSPOSE
 %token <tok_val> PLUS_PLUS MINUS_MINUS POW EPOW
 %token <tok_val> NUM IMAG_NUM
 %token <tok_val> NAME SCREW
 %token <tok_val> END
 %token <tok_val> PLOT
 %token <tok_val> TEXT STYLE
+%token <tok_val> FOR WHILE IF ELSEIF ELSE BREAK CONTINUE FUNC_RET
 
 // Other tokens.
-%token FOR WHILE IF ELSEIF ELSE FCN BREAK CONTINUE FUNC_RET SCREW_TWO
+%token FCN SCREW_TWO
 %token END_OF_INPUT GLOBAL
 %token USING TITLE WITH COLON OPEN_BRACE CLOSE_BRACE
 
 // Nonterminals we construct.
 %type <tree_type> input command 
 %type <tree_type> ans_expression expression simple_expr simple_expr1
 %type <tree_type> title
 %type <tree_matrix_type> matrix
@@ -188,16 +189,17 @@ static void maybe_warn_assign_as_truth_v
 %type <tree_index_expression_type> variable
 %type <tree_colon_expression_type> colon_expr
 %type <tree_argument_list_type> arg_list arg_list1
 %type <tree_parameter_list_type> param_list param_list1 func_def1a 
 %type <tree_word_list_type> word_list word_list1
 %type <tree_command_type> statement
 %type <tree_if_command_type> elseif
 %type <tree_command_list_type> simple_list simple_list1 list list1 opt_list
+%type <tree_command_list_type> global_decl global_decl1
 %type <tree_word_list_command_type> word_list_cmd
 %type <tree_plot_command_type> plot_command 
 %type <tree_subplot_list_type> plot_command1 plot_command2 plot_options
 %type <tree_plot_limits_type> ranges
 %type <tree_plot_range_type> ranges1 
 %type <tree_subplot_using_type> using using1 
 %type <tree_subplot_style_type> style
 
@@ -340,17 +342,17 @@ command		: plot_command
 		  { $$ = $1; }
 		| statement
 		  { $$ = $1; }
 		| ans_expression
 		  { $$ = $1; }
 		| func_def
 		  { $$ = $1; }
 		| global_decl
-		  { $$ = NULL_TREE; }
+		  { $$ = $1; }
 		;
 
 plot_command	: PLOT plot_command1
 		  {
 		    tree_subplot_list *tmp = $2->reverse ();
 		    $$ = new tree_plot_command (tmp, $1->pttype ());
 		    plotting = 0;
 		    past_plot_range = 0;
@@ -470,42 +472,48 @@ style		: WITH STYLE
 bogus_syntax	: // empty
 		;
 
 ans_expression	: expression
 		  { $$ = maybe_convert_to_ans_assign ($1); }
 		;
 
 global_decl	: GLOBAL global_decl1
-		  { }
+		  { $$ = $2->reverse (); }
 		;
 
 global_decl1	: NAME
-		  { force_global ($1->sym_rec()->name ()); }
+		  {
+		    force_global ($1->sym_rec()->name ());
+		    $$ = new tree_command_list ();
+		  }
 		| NAME '=' expression
 		  {
 		    symbol_record *sr = force_global ($1->sym_rec()->name ());
 		    tree_identifier *id = new tree_identifier
 		      (sr, $1->line (), $1->column ());
 		    tree_simple_assignment_expression *expr =
 		      new tree_simple_assignment_expression
 			(id, $3, $2->line (), $2->column ());
-		    expr->eval (0);
+		    $$ = new tree_command_list (expr);
 		  }
 		| global_decl1 optcomma NAME
-		  { force_global ($3->sym_rec()->name ()); }
+		  {
+		    force_global ($3->sym_rec()->name ());
+		    $$ = $1;
+		  }
 		| global_decl1 optcomma NAME '=' expression
 		  {
 		    symbol_record *sr = force_global ($3->sym_rec()->name ());
 		    tree_identifier *id = new tree_identifier
 		      (sr, $3->line (), $3->column ());
 		    tree_simple_assignment_expression *expr =
 		      new tree_simple_assignment_expression
 			(id, $5, $4->line (), $4->column ());
-		    expr->eval (0);
+		    $$ = $1->chain (expr);
 		  }
 		;
 
 optcomma	: // empty
 		| ','
 		  {
 		    if (user_pref.warn_comma_in_global_decl)
 		      warning ("comma in global declaration not\
@@ -514,110 +522,117 @@ optcomma	: // empty
 		;
 
 statement	: WHILE expression optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
 		    if (check_end ($5, token::while_end))
 		      ABORT_PARSE;
 		    looping--;
-		    $$ = new tree_while_command ($2, $4);
+		    $$ = new tree_while_command ($2, $4, $1->line (),
+						 $1->column ());
 		  }
 		| FOR variable '=' expression optsep opt_list END
 		  {
 		    if (check_end ($7, token::for_end))
 		      ABORT_PARSE;
 		    looping--;
-		    $$ = new tree_for_command ($2, $4, $6);
+		    $$ = new tree_for_command ($2, $4, $6,
+					       $1->line (), $1->column ());
 		  }
 		| IF expression optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
 		    if (check_end ($5, token::if_end))
 		      ABORT_PARSE;
 		    iffing--;
-		    $$ = new tree_if_command ($2, $4);
+		    $$ = new tree_if_command ($2, $4,
+					      $1->line (), $1->column ());
 		  }
 		| IF expression optsep opt_list ELSE optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
 		    if (check_end ($8, token::if_end))
 		      ABORT_PARSE;
 		    iffing--;
-		    tree_if_command *t1 = new tree_if_command ($7);
-		    $$ = t1->chain ($2, $4);
+		    tree_if_command *t1 = new tree_if_command
+					    ($7, $5->line (), $5->column ());
+		    $$ = t1->chain ($2, $4, $1->line (), $1->column ());
 		  }
 		| IF expression optsep opt_list elseif END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
 		    if (check_end ($6, token::if_end))
 		      ABORT_PARSE;
 		    iffing--;
 		    tree_if_command *t1 = $5->reverse ();
 		    // Add the if list to the new head of the elseif
 		    // list, and return the list.
-		    $$ = t1->chain ($2, $4);
+		    $$ = t1->chain ($2, $4, $1->line (), $1->column ());
 		  }
 		| IF expression optsep opt_list elseif ELSE optsep opt_list END
 		  {
 		    maybe_warn_assign_as_truth_value ($2);
 		    if (check_end ($9, token::if_end))
 		      ABORT_PARSE;
 		    iffing--;
 		    // Add the else list to the head of the elseif list,
 		    // then reverse the list.
-		    tree_if_command *t1 = $5->chain ($8);
+		    tree_if_command *t1 = $5->chain ($8, $6->line (),
+						     $6->column ());
 		    t1 = t1->reverse ();
 		    // Add the if list to the new head of the elseif
 		    // list, and return the list.
-		    $$ = t1->chain ($2, $4);
+		    $$ = t1->chain ($2, $4, $1->line (), $1->column ());
 		  }
 		| BREAK
 		  {
 		    if (!looping)
 		      {
 			yyerror ("parse error");
 			error ("break: only meaningful within a `for'\
  or `while' loop");
 			ABORT_PARSE;
 		      }
-		    $$ = new tree_break_command ();
+		    $$ = new tree_break_command ($1->line (), $1->column ());
 		  }
 		| CONTINUE
 		  {
 		    if (!looping)
 		      {
 			yyerror ("parse error");
 			error ("continue: only meaningful within a\
  `for' or `while' loop");
 			ABORT_PARSE;
 		      }
-		    $$ = new tree_break_command ();
+		    $$ = new tree_continue_command ($1->line (),
+						    $1->column ());
 		  }
 		| FUNC_RET
 		  {
 		    if (!defining_func)
 		      {
 			yyerror ("parse error");
 			error ("return: only meaningful within a function");
 			ABORT_PARSE;
 		      }
-		    $$ = new tree_return_command ();
+		    $$ = new tree_return_command ($1->line (), $1->column ());
 		  }
 		;
 
 elseif		: ELSEIF optsep expression optsep opt_list
 		  {
 		    maybe_warn_assign_as_truth_value ($3);
-		    $$ = new tree_if_command ($3, $5);
+		    $$ = new tree_if_command ($3, $5, $1->line (),
+					      $1->column ());
 		  }
 		| elseif ELSEIF optsep expression optsep opt_list
 		  {
 		    maybe_warn_assign_as_truth_value ($4);
-		    $$ = $1->chain ($4, $6);
+		    $$ = $1->chain ($4, $6, $2->line (), $2->column ());
 		  }
 		;
 
 optsep		: // empty
 		| sep
 		;
 
 sep		: ','
@@ -922,23 +937,30 @@ fcn_end_or_eof	: END
 		| END_OF_INPUT
 		  {
 		    if (! (reading_m_file || reading_script_file))
 		      YYABORT;
 		  }
 		;
 
 variable	: identifier
-		  { $$ = new tree_index_expression ($1); }
+		  {
+		    $$ = new tree_index_expression
+			   ($1, $1->line (), $1->column ());
+		  }
 		| identifier '(' arg_list ')'
-		  { $$ = new tree_index_expression ($1, $3); }
+		  {
+		    $$ = new tree_index_expression
+			   ($1, $3, $1->line (), $1->column ());
+		  }
 		| identifier '(' ')'
 		  {
 		    $$ = new tree_index_expression
-			       ($1, (tree_argument_list *) NULL);
+		           ($1, (tree_argument_list *) NULL,
+			    $1->line (), $1->column ());
 		  }
 		| identifier '['
 		  {
 		    yyerror ("parse error");
 		    error ("use `(\' and `)\' as index operators, not\
  `[\' and `]\'"); 
 		    $$ = (tree_index_expression *) NULL;
 		    ABORT_PARSE;
diff --git a/src/pt-base.h b/src/pt-base.h
--- a/src/pt-base.h
+++ b/src/pt-base.h
@@ -19,30 +19,31 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_tree_base_h)
 #define _tree_base_h 1
 
+#include <stdio.h>
+#include <time.h>
+#include <assert.h>
+
 // NOTE: don\'t put #pragma interface here because there is no
 // corresponding tree-base.cc file that implements this class!
 
 #ifndef NULL_TREE
 #define NULL_TREE (tree *)NULL
 #endif
 
 #ifndef NULL_TREE_CONST
 #define NULL_TREE_CONST (tree_constant *)NULL
 #endif
 
-#include <time.h>
-#include <assert.h>
-
 class ostream;
 class tree_constant;
 class tree_identifier;
 class tree_argument_list;
 
 /*
  * Base class for the parse tree.
  */
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -388,22 +388,22 @@ tree_constant_rep::tree_constant_rep (co
 }
 
 tree_constant_rep::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
   if (nel < 0)
     {
+      delete range;
+      type_tag = unknown_constant;
       if (nel == -1)
 	error ("number of elements in range exceeds INT_MAX");
       else
 	error ("invalid range");
-
-      jump_to_top_level ();
     }
   else if (nel > 1)
     type_tag = range_constant;
   else
     {
       delete range;
       if (nel == 1)
 	{
@@ -577,24 +577,21 @@ tree_constant_rep::maybe_resize (int i, 
 
   if (i > nr || j > nc)
     {
       if (user_pref.resize_on_range_error)
 	resize (MAX (i, nr), MAX (j, nc), 0.0);
       else
 	{
 	  if (i > nr)
-	    message ((char *) NULL,
-		     "row index = %d exceeds max row dimension = %d", i, nr);
+	    error ("row index = %d exceeds max row dimension = %d", i, nr);
+
 	  if (j > nc)
-	    message ((char *) NULL,
-		     "column index = %d exceeds max column dimension = %d",
-		     j, nc);
-
-	  jump_to_top_level ();
+	    error ("column index = %d exceeds max column dimension = %d",
+		   j, nc);
 	}
     }
 }
 
 void
 tree_constant_rep::maybe_resize (int i, force_orient f_orient = no_orient)
 {
   int nr = rows ();
@@ -613,43 +610,31 @@ tree_constant_rep::maybe_resize (int i, 
 	  else if (f_orient == column_orient)
 	    resize (i, 1, 0.0);
 	  else if (user_pref.prefer_column_vectors)
 	    resize (i, 1, 0.0);
 	  else
 	    resize (1, i, 0.0);
 	}
       else
-	{
-	  message ((char *) NULL,
-		   "matrix index = %d exceeds max dimension = %d", i, nc);
-	  jump_to_top_level ();
-	}
+	error ("matrix index = %d exceeds max dimension = %d", i, nc);
     }
   else if (nr == 1 && i > nc)
     {
       if (user_pref.resize_on_range_error)
 	resize (1, i, 0.0);
       else
-	{
-	  message ((char *) NULL,
-		   "matrix index = %d exceeds max dimension = %d", i, nc);
-	  jump_to_top_level ();
-	}
+	error ("matrix index = %d exceeds max dimension = %d", i, nc);
     }
   else if (nc == 1 && i > nr)
     {
       if (user_pref.resize_on_range_error)
 	resize (i, 1, 0.0);
       else
-	{
-	  message ((char *) NULL,
-		   "matrix index = %d exceeds max dimension = ", i, nc);
-	  jump_to_top_level ();
-	}
+	error ("matrix index = %d exceeds max dimension = ", i, nc);
     }
 }
 
 double
 tree_constant_rep::to_scalar (void) const
 {
   tree_constant tmp = make_numeric ();
 
@@ -2315,25 +2300,16 @@ tree_constant_rep::diag (const tree_cons
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
   return retval;
 }
 
-void
-tree_constant_rep::print_if_string (ostream& os, int warn)
-{
-  if (type_tag == string_constant)
-    os << string << "\n";
-  else if (warn)
-    warning ("expecting string, found numeric constant");
-}
-
 tree_constant
 tree_constant_rep::mapper (Mapper_fcn& m_fcn, int print) const
 {
   tree_constant retval;
 
   if (type_tag == string_constant || type_tag == range_constant)
     {
       tree_constant tmp = make_numeric ();
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -502,18 +502,16 @@ public:
 
   friend tree_constant eval_string (const tree_constant& arg, int&
 				    parse_status);
 
   friend tree_constant get_user_input (const tree_constant *args,
 				       int nargin, int nargout,
 				       int debug = 0);
 
-  void print_if_string (ostream& os, int warn);
-
   constant_type const_type (void) const { return type_tag; }
 
   tree_constant mapper (Mapper_fcn& m_fcn, int print) const;
 
 private:
   int count;
   constant_type type_tag;
   union
@@ -712,19 +710,16 @@ public:
   tree_constant cumsum (void) const { return rep->cumsum (); }
   tree_constant prod (void) const { return rep->prod (); }
   tree_constant sum (void) const { return rep->sum (); }
   tree_constant sumsq (void) const { return rep->sumsq (); }
 
   tree_constant diag (void) const { return rep->diag (); }
   tree_constant diag (const tree_constant& a) const { return rep->diag (a); }
 
-  void print_if_string (ostream& os, int warn)
-    { rep->print_if_string (os, warn); }
-
   tree_constant_rep::constant_type const_type (void) const
     { return rep->const_type (); }
 
   tree_constant mapper (Mapper_fcn& m_fcn, int print) const
     { return rep->mapper (m_fcn, print); }
 
   void bump_value (tree::expression_type et)
     {
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -97,16 +97,19 @@ tree_plot_command::eval (int print)
     default:
       panic_impossible ();
       break;
     }
 
   if (range != (tree_plot_limits *) NULL)
     range->print (ndim, plot_buf);
 
+  if (error_state)
+    return retval;
+
   plot_line_count = 0;
   tree_subplot_list *ptr = plot_list;
   for ( ; ptr != NULL_TREE ; ptr = ptr->next_elem ())
     {
       plot_line_count++;
 
       if (ptr != plot_list)
 	plot_buf << ",\\\n  ";
@@ -233,17 +236,17 @@ tree_subplot_list::eval (int print)
 
 int
 tree_subplot_list::print (int ndim, ostrstream& plot_buf)
 {
   int nc = 0;
   if (plot_data != NULL_TREE)
     {
       tree_constant data = plot_data->eval (0);
-      if (data.is_defined ())
+      if (! error_state && data.is_defined ())
 	{
 	  char *file = (char *) NULL;
 	  if (data.is_string_type ())
 	    {
 	      file = tilde_expand (data.string_value ());
 	      ifstream ftmp (file);
 	      if (ftmp)
 		{
@@ -296,17 +299,17 @@ tree_subplot_list::print (int ndim, ostr
       int status = using->print (ndim, nc, plot_buf);
       if (status < 0)
 	return -1;
     }
 
   if (title != NULL_TREE)
     {
       tree_constant tmp = title->eval (0);
-      if (tmp.is_string_type ())
+      if (! error_state && tmp.is_string_type ())
 	plot_buf << " title " << '"' << tmp.string_value () << '"';
       else
 	{
 	  warning ("line title must be a string");
 	  plot_buf << " title " << '"' << "line " << plot_line_count << '"';
 	}
     }
   else
@@ -415,27 +418,43 @@ tree_plot_range::eval (int print)
 void
 tree_plot_range::print (ostrstream& plot_buf)
 {
   plot_buf << " [";
 
   if (lower != NULL_TREE)
     {
       tree_constant lower_val = lower->eval (0);
-      double lo = lower_val.to_scalar ();
-      plot_buf << lo;
+      if (error_state)
+	{
+	  error ("evaluating lower bound of plot range");
+	  return;
+	}
+      else
+	{
+	  double lo = lower_val.to_scalar ();
+	  plot_buf << lo;
+	}
     }
 
   plot_buf << ":";
 
   if (upper != NULL_TREE)
     {
       tree_constant upper_val = upper->eval (0);
-      double hi = upper_val.to_scalar ();
-      plot_buf << hi;
+      if (error_state)
+	{
+	  error ("evaluating upper bound of plot range");
+	  return;
+	}
+      else
+	{
+	  double hi = upper_val.to_scalar ();
+	  plot_buf << hi;
+	}
     }
 
   plot_buf << "]";
 }
 
 tree_subplot_using::tree_subplot_using (void)
 {
   qualifier_count = 0;
@@ -493,16 +512,22 @@ tree_subplot_using::print (int ndim, int
       || (ndim == 3 && qualifier_count > 3))
     return -1;
 
   for (int i = 0; i < qualifier_count; i++)
     {
       if (x[i] != NULL_TREE)
 	{
 	  tree_constant tmp = x[i]->eval (0);
+	  if (error_state)
+	    {
+	      error ("evaluating plot using command");
+	      return -1;
+	    }
+
 	  double val;
 	  if (tmp.is_defined ())
 	    {
 	      val = tmp.to_scalar ();
 	      if (i == 0)
 		plot_buf << " using ";
 	      else
 		plot_buf << ":";
@@ -577,35 +602,41 @@ tree_subplot_style::print (ostrstream& p
 {
   if (style != (char *) NULL)
     {
       plot_buf << " with " << style;
 
       if (linetype != NULL_TREE)
 	{
 	  tree_constant tmp = linetype->eval (0);
-	  if (tmp.is_defined ())
+	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.to_scalar ();
 	      plot_buf << " " << NINT (val);
 	    }
 	  else
-	    return -1;
+	    {
+	      error ("evaluating plot style command");
+	      return -1;
+	    }
 	}
 
       if (pointtype != NULL_TREE)
 	{
 	  tree_constant tmp = pointtype->eval (0);
-	  if (tmp.is_defined ())
+	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.to_scalar ();
 	      plot_buf << " " << NINT (val);
 	    }
 	  else
-	    return -1;
+	    {
+	      error ("evaluating plot style command");
+	      return -1;
+	    }
 	}
     }
   else
     return -1;
 
   return 0;
 }
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -497,18 +497,18 @@ symbol_record::is_forced_global (void) c
   return forced_global;
 }
 
 void
 symbol_record::alias (symbol_record *s, int force = 0)
 {
   sv_fcn = s->sv_fcn; // Maybe this should go in the var symbol_def?
 
-  formal_param = s->formal_param; // Hmm.
-  forced_global = s->forced_global; // Hmm.
+//  formal_param = s->formal_param; // Hmm.
+//  forced_global = s->forced_global; // Hmm.
 
   if (force && s->var == (symbol_def *) NULL
       && s->fcn == (symbol_def *) NULL)
     {
       s->var = new symbol_def ();
       var = s->var;
       var->count = 2; // Yes, this is correct.
       return;
@@ -614,17 +614,17 @@ symbol_table::bind_globals (void)
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
     {
       symbol_record *ptr = table[i].next ();
 
       while (ptr != (symbol_record *) NULL && ! ptr->formal_param)
 	{
 	  char *nm = ptr->name ();
 	  symbol_record *sr = global_sym_tab->lookup (nm, 0, 0);
-	  if (sr != (symbol_record *) NULL)
+	  if (sr != (symbol_record *) NULL && sr->is_forced_global ())
 	    ptr->alias (sr, 1);
 	  ptr = ptr->next ();
 	}
     }
 }
 
 int
 symbol_table::save (ostream& os, int mark_as_global = 0)
diff --git a/src/tc-assign.cc b/src/tc-assign.cc
--- a/src/tc-assign.cc
+++ b/src/tc-assign.cc
@@ -241,17 +241,21 @@ tree_constant_rep::fortran_style_matrix_
     {
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int i = NINT (tmp_i.double_value ());
 	if (index_check (i-1, "") < 0)
 	  return;
 	if (nr <= 1 || nc <= 1)
-	  maybe_resize (i-1);
+	  {
+	    maybe_resize (i-1);
+	    if (error_state)
+	      return;
+	  }
 	else if (range_max_check (i-1, nr * nc) < 0)
 	  return;
 
 	nr = rows ();
 	nc = columns ();
 
 	if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
 	  {
@@ -264,20 +268,27 @@ tree_constant_rep::fortran_style_matrix_
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	int len = nr * nc;
 	idx_vector ii (mi, 1, "", len);  // Always do fortran indexing here...
+	if (! ii)
+	  return;
+
 	int imax = ii.max ();
 
 	if (nr <= 1 || nc <= 1)
-	  maybe_resize (imax-1);
+	  {
+	    maybe_resize (imax-1);
+	    if (error_state)
+	      return;
+	  }
 	else if (range_max_check (imax-1, len) < 0)
 	  return;
 
 	if (ii.capacity () != rhs_nr * rhs_nc)
 	  {
 	    error ("A(matrix) = X: X and matrix must have the same\
  number of elements"); 
 	    return;
@@ -325,16 +336,19 @@ tree_constant_rep::vector_assignment (tr
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	int len = nr * nc;
 	idx_vector iv (mi, user_pref.do_fortran_indexing, "", len);
+	if (! iv)
+	  return;
+
 	do_vector_assign (rhs, iv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
@@ -408,16 +422,18 @@ tree_constant_rep::do_vector_assign (tre
 
   if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
     {
       error ("for A(int) = X: X must be a scalar");
       return;
     }
 
   maybe_resize (i);
+  if (error_state)
+    return;
 
   int nr = rows ();
   int nc = columns ();
 
   if (nr == 1)
     {
       REP_ELEM_ASSIGN (0, i, rhs.double_value (), rhs.complex_value (),
 		       rhs.is_real_type ());
@@ -443,16 +459,18 @@ tree_constant_rep::do_vector_assign (tre
 
   force_orient f_orient = no_orient;
   if (rhs_nr == 1 && rhs_nc != 1)
     f_orient = row_orient;
   else if (rhs_nc == 1 && rhs_nr != 1)
     f_orient = column_orient;
 
   maybe_resize (iv.max (), f_orient);
+  if (error_state)
+    return;
 
   int nr = rows ();
   int nc = columns ();
 
   if (nr == 1)
     {
       for (int i = 0; i < iv.capacity (); i++)
 	REP_ELEM_ASSIGN (0, iv.elem (i), rhs_m.elem (0, i),
@@ -480,16 +498,18 @@ tree_constant_rep::do_vector_assign (tre
 
   force_orient f_orient = no_orient;
   if (rhs_nr == 1 && rhs_nc != 1)
     f_orient = row_orient;
   else if (rhs_nc == 1 && rhs_nr != 1)
     f_orient = column_orient;
 
   maybe_resize (imax, f_orient);
+  if (error_state)
+    return;
 
   int nr = rows ();
   int nc = columns ();
 
   double b = ri.base ();
   double increment = ri.inc ();
 
   if (nr == 1)
@@ -624,16 +644,19 @@ tree_constant_rep::do_matrix_assignment 
 	do_matrix_assignment (rhs, i, j_arg);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	idx_vector iv (mi, user_pref.do_fortran_indexing, "row", rows ());
+	if (! iv)
+	  return;
+
 	do_matrix_assignment (rhs, iv, j_arg);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
@@ -680,32 +703,41 @@ tree_constant_rep::do_matrix_assignment 
 	if (index_check (j, "column") < 0)
 	  return;
 	if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
 	  {
 	    error ("A(int,int) = X, X must be a scalar");
 	    return;
 	  }
 	maybe_resize (i, j);
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, i, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
+	if (! jv)
+	  return;
+
 	if (! indexed_assign_conforms (1, jv.capacity (), rhs_nr, rhs_nc))
 	  {
 	    error ("A(int,matrix) = X: X must be a row vector with the\
  same number of elements as matrix"); 
 	    return;
 	  }
 	maybe_resize (i, jv.max ());
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, i, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
@@ -722,16 +754,19 @@ tree_constant_rep::do_matrix_assignment 
 	    do_matrix_assignment (rhs, i, 1);
 	  }
 	else
 	  {
 	    int jmax;
 	    if (index_check (rj, jmax, "column") < 0)
 	      return;
 	    maybe_resize (i, jmax);
+	    if (error_state)
+	      return;
+
 	    do_matrix_assignment (rhs, i, rj);
 	  }
       }
       break;
     case magic_colon:
       {
 	int nc = columns ();
 	if (nc == 0 && rows () == 0 && rhs_nr == 1)
@@ -742,19 +777,25 @@ tree_constant_rep::do_matrix_assignment 
 		type_tag = complex_matrix_constant;
 	      }
 	    else
 	      {
 		matrix = new Matrix ();
 		type_tag = matrix_constant;
 	      }
 	    maybe_resize (i, rhs_nc-1);
+	    if (error_state)
+	      return;
 	  }
 	else if (indexed_assign_conforms (1, nc, rhs_nr, rhs_nc))
-	  maybe_resize (i, nc-1);
+	  {
+	    maybe_resize (i, nc-1);
+	    if (error_state)
+	      return;
+	  }
 	else
 	  {
 	    error ("A(int,:) = X: X must be a row vector with the\
  same number of columns as A"); 
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, i, magic_colon);
@@ -787,34 +828,43 @@ tree_constant_rep::do_matrix_assignment 
 	  return;
 	if (! indexed_assign_conforms (iv.capacity (), 1, rhs_nr, rhs_nc))
 	  {
 	    error ("A(matrix,int) = X: X must be a column vector with\
  the same number of elements as matrix");  
 	    return;
 	  }
 	maybe_resize (iv.max (), j);
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, iv, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
+	if (! jv)
+	  return;
+
 	if (! indexed_assign_conforms (iv.capacity (), jv.capacity (),
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(r_matrix,c_matrix) = X: the number of rows in X\
  must match the number of elements in r_matrix and the number of\
  columns in X must match the number of elements in c_matrix");  
 	    return;
 	  }
 	maybe_resize (iv.max (), jv.max ());
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, iv, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
@@ -833,16 +883,19 @@ tree_constant_rep::do_matrix_assignment 
 	    do_matrix_assignment (rhs, iv, 1);
 	  }
 	else
 	  {
 	    int jmax;
 	    if (index_check (rj, jmax, "column") < 0)
 	      return;
 	    maybe_resize (iv.max (), jmax);
+	    if (error_state)
+	      return;
+
 	    do_matrix_assignment (rhs, iv, rj);
 	  }
       }
       break;
     case magic_colon:
       {
 	int nc = columns ();
 	int new_nc = nc;
@@ -853,16 +906,19 @@ tree_constant_rep::do_matrix_assignment 
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(matrix,:) = X: the number of rows in X must\
  match the number of elements in matrix, and the number of columns in\
  X must match the number of columns in A");
 	    return;
 	  }
 	maybe_resize (iv.max (), new_nc-1);
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, iv, magic_colon);
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 }
@@ -889,34 +945,43 @@ tree_constant_rep::do_matrix_assignment 
 	  return;
 	if (! indexed_assign_conforms (ri.nelem (), 1, rhs_nr, rhs_nc))
 	  {
 	    error ("A(range,int) = X: X must be a column vector with\
  the same number of elements as range");
 	    return;
 	  }
 	maybe_resize (imax, j);
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, ri, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
+	if (! jv)
+	  return;
+
 	if (! indexed_assign_conforms (ri.nelem (), jv.capacity (),
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(range,matrix) = X: the number of rows in X must\
  match the number of elements in range and the number of columns in X\
  must match the number of elements in matrix");
 	    return;
 	  }
 	maybe_resize (imax, jv.max ());
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, ri, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
@@ -935,16 +1000,19 @@ tree_constant_rep::do_matrix_assignment 
 	    do_matrix_assignment (rhs, ri, 1);
 	  }
 	else
 	  {
 	    int jmax;
 	    if (index_check (rj, jmax, "column") < 0)
 	      return;
 	    maybe_resize (imax, jmax);
+	    if (error_state)
+	      return;
+
 	    do_matrix_assignment (rhs, ri, rj);
 	  }
       }
       break;
     case magic_colon:
       {
 	int nc = columns ();
 	int new_nc = nc;
@@ -954,16 +1022,19 @@ tree_constant_rep::do_matrix_assignment 
 	if (! indexed_assign_conforms (ri.nelem (), new_nc, rhs_nr, rhs_nc))
 	  {
 	    error ("A(range,:) = X: the number of rows in X must match\
  the number of elements in range, and the number of columns in X must\
  match the number of columns in A");  
 	    return;
 	  }
 	maybe_resize (imax, new_nc-1);
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, ri, magic_colon);
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 }
@@ -997,49 +1068,61 @@ tree_constant_rep::do_matrix_assignment 
 		type_tag = complex_matrix_constant;
 	      }
 	    else
 	      {
 		matrix = new Matrix ();
 		type_tag = matrix_constant;
 	      }
 	    maybe_resize (rhs_nr-1, j);
+	    if (error_state)
+	      return;
 	  }
 	else if (indexed_assign_conforms (nr, 1, rhs_nr, rhs_nc))
-	  maybe_resize (nr-1, j);
+	  {
+	    maybe_resize (nr-1, j);
+	    if (error_state)
+	      return;
+	  }
 	else
 	  {
 	    error ("A(:,int) = X: X must be a column vector with the\
  same number of rows as A"); 
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, magic_colon, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
+	if (! jv)
+	  return;
+
 	int nr = rows ();
 	int new_nr = nr;
 	if (nr == 0)
 	  new_nr = rhs_nr;
 
 	if (! indexed_assign_conforms (new_nr, jv.capacity (),
 				       rhs_nr, rhs_nc))
 	  {
 	    error ("A(:,matrix) = X: the number of rows in X must\
  match the number of rows in A, and the number of columns in X must\
  match the number of elements in matrix");   
 	    return;
 	  }
 	maybe_resize (new_nr-1, jv.max ());
+	if (error_state)
+	  return;
+
 	do_matrix_assignment (rhs, magic_colon, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
@@ -1062,16 +1145,19 @@ tree_constant_rep::do_matrix_assignment 
 	    do_matrix_assignment (rhs, magic_colon, 1);
 	  }
 	else
 	  {
 	    int jmax;
 	    if (index_check (rj, jmax, "column") < 0)
 	      return;
 	    maybe_resize (new_nr-1, jmax);
+	    if (error_state)
+	      return;
+
 	    do_matrix_assignment (rhs, magic_colon, rj);
 	  }
       }
       break;
     case magic_colon:
 // a(:,:) = foo is equivalent to a = foo.
       do_matrix_assignment (rhs, magic_colon, magic_colon);
       break;
diff --git a/src/tc-index.cc b/src/tc-index.cc
--- a/src/tc-index.cc
+++ b/src/tc-index.cc
@@ -67,16 +67,18 @@ tree_constant_rep::do_scalar_index (cons
 	{
 	case 3:
 	  {
 	    if (args[2].is_matrix_type ())
 	      {
 		Matrix mj = args[2].matrix_value ();
 
 		idx_vector j (mj, user_pref.do_fortran_indexing, "");
+		if (! j)
+		  return tree_constant ();
 
 		int len = j.length ();
 		if (len == j.ones_count ())
 		  cols = len;
 	      }
 	    else if (args[2].is_scalar_type ()
 		     && NINT (args[2].double_value ()) == 1)
 	      {
@@ -88,16 +90,18 @@ tree_constant_rep::do_scalar_index (cons
 // Fall through...
 	case 2:
 	  {
 	    if (args[1].is_matrix_type ())
 	      {
 		Matrix mi = args[1].matrix_value ();
 
 		idx_vector i (mi, user_pref.do_fortran_indexing, "");
+		if (! i)
+		  return tree_constant ();
 
 		int len = i.length ();
 		if (len == i.ones_count ())
 		  rows = len;
 	      }
 	    else if (args[1].is_scalar_type ()
 		     && NINT (args[1].double_value ()) == 1)
 	      {
@@ -278,16 +282,18 @@ tree_constant_rep::fortran_style_matrix_
       if (real_type)
 	cop_out = matrix->fortran_vec ();
       else
 	c_cop_out = complex_matrix->fortran_vec ();
 
       double *cop_out_index = mi.fortran_vec ();
 
       idx_vector iv (mi, 1, "", len);
+      if (! iv)
+	return tree_constant ();
 
       int result_size = iv.length ();
 
       if (columns () == 1 || iv.one_zero_only ())
 	{
 	  CRMATRIX (m, cm, result_size, 1);
 
 	  for (int i = 0; i < result_size; i++)
@@ -387,16 +393,19 @@ tree_constant_rep::do_vector_index (cons
 	if (mi.rows () == 0 || mi.columns () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
 	    idx_vector iv (mi, user_pref.do_fortran_indexing, "", len);
+	    if (! iv)
+	      return tree_constant ();
+
 	    int imax = iv.max ();
 	    if (swap_indices)
 	      {
 		if (range_max_check (imax, nc) < 0)
 		  return tree_constant ();
 		retval = do_matrix_index (0, iv);
 	      }
 	    else
@@ -476,16 +485,19 @@ tree_constant_rep::do_matrix_index (cons
 	retval = do_matrix_index (i, j_arg);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mi = tmp_i.matrix_value ();
 	idx_vector iv (mi, user_pref.do_fortran_indexing, "row", rows ());
+	if (! iv)
+	  return tree_constant ();
+
 	if (iv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  retval = do_matrix_index (iv, j_arg);
       }
@@ -545,16 +557,19 @@ tree_constant_rep::do_matrix_index (int 
 	retval = do_matrix_index (i, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
+	if (! jv)
+	  return tree_constant ();
+
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
 	    if (range_max_check (i, jv.max (), nr, nc) < 0)
@@ -623,16 +638,19 @@ tree_constant_rep::do_matrix_index (cons
 	retval = do_matrix_index (iv, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
+	if (! jv)
+	  return tree_constant ();
+
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
 	    if (range_max_check (iv.max (), jv.max (), nr, nc) < 0)
@@ -701,16 +719,19 @@ tree_constant_rep::do_matrix_index (cons
 	retval = do_matrix_index (ri, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
+	if (! jv)
+	  return tree_constant ();
+
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
 	    if (range_max_check (imax, jv.max (), nr, nc) < 0)
@@ -777,16 +798,19 @@ tree_constant_rep::do_matrix_index (tree
 	retval = do_matrix_index (magic_colon, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column", nc);
+	if (! jv)
+	  return tree_constant ();
+
 	if (jv.length () == 0)
 	  {
 	    Matrix mtmp;
 	    retval = tree_constant (mtmp);
 	  }
 	else
 	  {
 	    if (range_max_check (0, jv.max (), nr, nc) < 0)
diff --git a/src/tree.h.old b/src/tree.h.old
--- a/src/tree.h.old
+++ b/src/tree.h.old
@@ -645,110 +645,117 @@ tree_command_list : public tree_command
 
 /*
  * While.
  */
 class
 tree_while_command : public tree_command
 {
  public:
-  tree_while_command (void);
-  tree_while_command (tree *e);
-  tree_while_command (tree *e, tree *lst);
+  tree_while_command (int l = -1, int c = -1);
+  tree_while_command (tree *e, int l = -1, int c = -1);
+  tree_while_command (tree *e, tree *lst, int l = -1, int c = -1);
 
   ~tree_while_command (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree *expr;			// Expression to test.
   tree *list;			// List of commands to execute.
 };
 
 /*
  * For.
  */
 class
 tree_for_command : public tree_command
 {
  public:
-  tree_for_command (void);
-  tree_for_command (tree_index_expression *id, tree *e, tree *lst);
+  tree_for_command (int l = -1, int c = -1);
+  tree_for_command (tree_index_expression *id, tree *e, tree *lst,
+		    int l = -1, int c = -1);
 
   ~tree_for_command (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree_index_expression *id;	// Identifier to modify.
   tree *expr;			// Expression to evaluate.
   tree *list;			// List of commands to execute.
 };
 
 /*
  * Simple if.
  */
 class
 tree_if_command : public tree_command
 {
  public:
-  tree_if_command (void);
-  tree_if_command (tree *t);
-  tree_if_command (tree *e, tree *t);
+  tree_if_command (int l = -1, int c = -1);
+  tree_if_command (tree *t, int l = -1, int c = -1);
+  tree_if_command (tree *e, tree *t, int l = -1, int c = -1);
 
   ~tree_if_command (void);
 
-  tree_if_command *chain (tree *t);
-  tree_if_command *chain (tree *t1, tree *t2);
+  tree_if_command *chain (tree *t, int l = -1, int c = -1);
+  tree_if_command *chain (tree *t1, tree *t2, int l = -1, int c = -1);
   tree_if_command *reverse (void);
 
   tree_constant eval (int print);
 
+  void eval_error (void);
+
  private:
   tree *expr;			// Expression to test.
   tree *list;			// Commands to execute.
   tree_if_command *next;	// Next if command.
 };
 
 /*
  * Break.
  */
 class
 tree_break_command : public tree_command
 {
  public:
-  tree_break_command (void);
+  tree_break_command (int l = -1, int c = -1);
 
   ~tree_break_command (void);
 
   tree_constant eval (int print);
 };
 
 /*
  * Continue.
  */
 class
 tree_continue_command : public tree_command
 {
  public:
-  tree_continue_command (void);
+  tree_continue_command (int l = -1, int c = -1);
 
   ~tree_continue_command (void);
 
   tree_constant eval (int print);
 };
 
 /*
  * Return.
  */
 class
 tree_return_command : public tree_command
 {
  public:
-  tree_return_command (void);
+  tree_return_command (int l = -1, int c = -1);
 
   ~tree_return_command (void);
 
   tree_constant eval (int print);
 };
 
 /*
  * Functions that take a list of strings as arguments.
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -184,17 +184,19 @@ octave_string_variable (char *name)
       if (sr == (symbol_record *) NULL)
 	return retval;
     }
 
   tree *defn = sr->def ();
   if (defn != NULL_TREE)
     {
       tree_constant val = defn->eval (0);
-      if (val.is_string_type ())
+      if (error_state)
+	return retval;
+      else if (val.is_string_type ())
 	{
 	  char *s = val.string_value ();
 	  if (s != (char *) NULL)
 	    retval = strsave (s);
 	}
     }
 
   return retval;
@@ -217,17 +219,19 @@ octave_real_scalar_variable (char *name,
       if (sr == (symbol_record *) NULL)
 	return status;
     }
 
   tree *defn = sr->def ();
   if (defn != NULL_TREE)
     {
       tree_constant val = defn->eval (0);
-      if (val.const_type () == tree_constant_rep::scalar_constant)
+      if (error_state)
+	return status;
+      else if (val.const_type () == tree_constant_rep::scalar_constant)
 	{
 	  d = val.double_value ();
 	  status = 0;
 	}
     }
 
   return status;
 }
