# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444090915 14400
#      Mon Oct 05 20:21:55 2015 -0400
# Node ID 4bed806ee3d46878babfa79138ac97a88e8220f7
# Parent  f90c8372b7bab3bff3a6908cf43976eefdbf93cb
eliminate more simple uses of error_state

* daspk.cc, dassl.cc, dot.cc, luinc.cc, sylvester.cc, variables.cc,
__eigs__.cc: Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -359,41 +359,38 @@ parameters for @code{daspk}.\n\
                     }
                   while (0);
                   break;
 
                 case 2:
                   {
                     string_vector tmp = f_arg.all_strings ();
 
-                    if (! error_state)
+                    fcn_name = unique_symbol_name ("__daspk_fcn__");
+                    fname = "function y = ";
+                    fname.append (fcn_name);
+                    fname.append (" (x, xdot, t) y = ");
+                    daspk_fcn = extract_function (tmp(0), "daspk", fcn_name,
+                                                  fname, "; endfunction");
+
+                    if (daspk_fcn)
                       {
-                        fcn_name = unique_symbol_name ("__daspk_fcn__");
-                        fname = "function y = ";
-                        fname.append (fcn_name);
-                        fname.append (" (x, xdot, t) y = ");
-                        daspk_fcn = extract_function (tmp(0), "daspk", fcn_name,
-                                                      fname, "; endfunction");
+                        jac_name = unique_symbol_name ("__daspk_jac__");
+                        jname = "function jac = ";
+                        jname.append (jac_name);
+                        jname.append (" (x, xdot, t, cj) jac = ");
+                        daspk_jac = extract_function (tmp(1), "daspk",
+                                                      jac_name, jname,
+                                                      "; endfunction");
 
-                        if (daspk_fcn)
+                        if (!daspk_jac)
                           {
-                            jac_name = unique_symbol_name ("__daspk_jac__");
-                            jname = "function jac = ";
-                            jname.append (jac_name);
-                            jname.append (" (x, xdot, t, cj) jac = ");
-                            daspk_jac = extract_function (tmp(1), "daspk",
-                                                          jac_name, jname,
-                                                          "; endfunction");
-
-                            if (!daspk_jac)
-                              {
-                                if (fcn_name.length ())
-                                  clear_function (fcn_name);
-                                daspk_fcn = 0;
-                              }
+                            if (fcn_name.length ())
+                              clear_function (fcn_name);
+                            daspk_fcn = 0;
                           }
                       }
                   }
                 }
             }
         }
 
       if (error_state || ! daspk_fcn)
@@ -446,35 +443,32 @@ parameters for @code{daspk}.\n\
       else
         output = dae.integrate (out_times, deriv_output);
 
       if (fcn_name.length ())
         clear_function (fcn_name);
       if (jac_name.length ())
         clear_function (jac_name);
 
-      if (! error_state)
-        {
-          std::string msg = dae.error_message ();
+      std::string msg = dae.error_message ();
 
-          retval(3) = msg;
-          retval(2) = static_cast<double> (dae.integration_state ());
+      retval(3) = msg;
+      retval(2) = static_cast<double> (dae.integration_state ());
 
-          if (dae.integration_ok ())
-            {
-              retval(1) = deriv_output;
-              retval(0) = output;
-            }
-          else
-            {
-              retval(1) = Matrix ();
-              retval(0) = Matrix ();
+      if (dae.integration_ok ())
+        {
+          retval(1) = deriv_output;
+          retval(0) = output;
+        }
+      else
+        {
+          retval(1) = Matrix ();
+          retval(0) = Matrix ();
 
-              if (nargout < 3)
-                error ("daspk: %s", msg.c_str ());
-            }
+          if (nargout < 3)
+            error ("daspk: %s", msg.c_str ());
         }
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -360,41 +360,38 @@ parameters for @code{dassl}.\n\
                     }
                   while (0);
                   break;
 
                 case 2:
                   {
                     string_vector tmp = f_arg.all_strings ();
 
-                    if (! error_state)
+                    fcn_name = unique_symbol_name ("__dassl_fcn__");
+                    fname = "function y = ";
+                    fname.append (fcn_name);
+                    fname.append (" (x, xdot, t) y = ");
+                    dassl_fcn = extract_function (tmp(0), "dassl", fcn_name,
+                                                  fname, "; endfunction");
+
+                    if (dassl_fcn)
                       {
-                        fcn_name = unique_symbol_name ("__dassl_fcn__");
-                        fname = "function y = ";
-                        fname.append (fcn_name);
-                        fname.append (" (x, xdot, t) y = ");
-                        dassl_fcn = extract_function (tmp(0), "dassl", fcn_name,
-                                                      fname, "; endfunction");
+                        jac_name = unique_symbol_name ("__dassl_jac__");
+                        jname = "function jac = ";
+                        jname.append (jac_name);
+                        jname.append (" (x, xdot, t, cj) jac = ");
+                        dassl_jac = extract_function (tmp(1), "dassl",
+                                                      jac_name, jname,
+                                                      "; endfunction");
 
-                        if (dassl_fcn)
+                        if (!dassl_jac)
                           {
-                            jac_name = unique_symbol_name ("__dassl_jac__");
-                            jname = "function jac = ";
-                            jname.append (jac_name);
-                            jname.append (" (x, xdot, t, cj) jac = ");
-                            dassl_jac = extract_function (tmp(1), "dassl",
-                                                          jac_name, jname,
-                                                          "; endfunction");
-
-                            if (!dassl_jac)
-                              {
-                                if (fcn_name.length ())
-                                  clear_function (fcn_name);
-                                dassl_fcn = 0;
-                              }
+                            if (fcn_name.length ())
+                              clear_function (fcn_name);
+                            dassl_fcn = 0;
                           }
                       }
                   }
                 }
             }
         }
 
       if (error_state || ! dassl_fcn)
@@ -448,36 +445,33 @@ parameters for @code{dassl}.\n\
       else
         output = dae.integrate (out_times, deriv_output);
 
       if (fcn_name.length ())
         clear_function (fcn_name);
       if (jac_name.length ())
         clear_function (jac_name);
 
-      if (! error_state)
-        {
-          std::string msg = dae.error_message ();
+      std::string msg = dae.error_message ();
 
-          retval(3) = msg;
-          retval(2) = static_cast<double> (dae.integration_state ());
+      retval(3) = msg;
+      retval(2) = static_cast<double> (dae.integration_state ());
 
-          if (dae.integration_ok ())
-            {
-              retval(1) = deriv_output;
-              retval(0) = output;
-            }
-          else
-            {
-              retval(1) = Matrix ();
-              retval(0) = Matrix ();
+      if (dae.integration_ok ())
+        {
+          retval(1) = deriv_output;
+          retval(0) = output;
+        }
+      else
+        {
+          retval(1) = Matrix ();
+          retval(0) = Matrix ();
 
-              if (nargout < 3)
-                error ("dassl: %s", msg.c_str ());
-            }
+          if (nargout < 3)
+            error ("dassl: %s", msg.c_str ());
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -142,99 +142,95 @@ but avoids forming a temporary array and
       if (! match && nargin == 2
           && dimx.is_vector () && dimy.is_vector ())
         {
           // Change to column vectors.
           dimx = dimx.redim (1);
           argx = argx.reshape (dimx);
           dimy = dimy.redim (1);
           argy = argy.reshape (dimy);
-          match = ! error_state && (dimx == dimy);
+          match = dimx == dimy;
         }
 
       if (match)
         {
           int dim;
           if (nargin == 2)
             dim = dimx.first_non_singleton ();
           else
             dim = args(2).int_value (true) - 1;
 
-          if (error_state)
-            ;
-          else if (dim < 0)
+          if (dim < 0)
             error ("dot: DIM must be a valid dimension");
           else
             {
               octave_idx_type m, n, k;
               dim_vector dimz;
               if (argx.is_complex_type () || argy.is_complex_type ())
                 {
                   if (argx.is_single_type () || argy.is_single_type ())
                     {
                       FloatComplexNDArray x = argx.float_complex_array_value ();
                       FloatComplexNDArray y = argy.float_complex_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
                       FloatComplexNDArray z (dimz);
-                      if (! error_state)
-                        F77_XFCN (cdotc3, CDOTC3, (m, n, k,
-                                                   x.data (), y.data (),
-                                                   z.fortran_vec ()));
+
+                      F77_XFCN (cdotc3, CDOTC3, (m, n, k,
+                                                 x.data (), y.data (),
+                                                 z.fortran_vec ()));
                       retval = z;
                     }
                   else
                     {
                       ComplexNDArray x = argx.complex_array_value ();
                       ComplexNDArray y = argy.complex_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
                       ComplexNDArray z (dimz);
-                      if (! error_state)
-                        F77_XFCN (zdotc3, ZDOTC3, (m, n, k,
-                                                   x.data (), y.data (),
-                                                   z.fortran_vec ()));
+
+                      F77_XFCN (zdotc3, ZDOTC3, (m, n, k,
+                                                 x.data (), y.data (),
+                                                 z.fortran_vec ()));
                       retval = z;
                     }
                 }
               else if (argx.is_float_type () && argy.is_float_type ())
                 {
                   if (argx.is_single_type () || argy.is_single_type ())
                     {
                       FloatNDArray x = argx.float_array_value ();
                       FloatNDArray y = argy.float_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
                       FloatNDArray z (dimz);
-                      if (! error_state)
-                        F77_XFCN (sdot3, SDOT3, (m, n, k, x.data (), y.data (),
-                                                 z.fortran_vec ()));
+
+                      F77_XFCN (sdot3, SDOT3, (m, n, k, x.data (), y.data (),
+                                               z.fortran_vec ()));
                       retval = z;
                     }
                   else
                     {
                       NDArray x = argx.array_value ();
                       NDArray y = argy.array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
                       NDArray z (dimz);
-                      if (! error_state)
-                        F77_XFCN (ddot3, DDOT3, (m, n, k, x.data (), y.data (),
-                                                 z.fortran_vec ()));
+
+                      F77_XFCN (ddot3, DDOT3, (m, n, k, x.data (), y.data (),
+                                               z.fortran_vec ()));
                       retval = z;
                     }
                 }
               else
                 {
                   // Non-optimized evaluation.
                   octave_value_list tmp;
                   tmp(1) = dim + 1;
                   tmp(0) = do_binary_op (octave_value::op_el_mul, argx, argy);
-                  if (! error_state)
-                    {
-                      tmp = feval ("sum", tmp, 1);
-                      if (! tmp.empty ())
-                        retval = tmp(0);
-                    }
+
+                  tmp = feval ("sum", tmp, 1);
+                  if (! tmp.empty ())
+                    retval = tmp(0);
                 }
             }
         }
       else
         error ("dot: sizes of X and Y must match");
 
     }
   else
@@ -336,56 +332,56 @@ endfor\n\
         {
           if (argx.is_complex_type () || argy.is_complex_type ())
             {
               if (argx.is_single_type () || argy.is_single_type ())
                 {
                   FloatComplexNDArray x = argx.float_complex_array_value ();
                   FloatComplexNDArray y = argy.float_complex_array_value ();
                   FloatComplexNDArray z (dimz);
-                  if (! error_state)
-                    F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
-                                               x.data (), y.data (),
-                                               z.fortran_vec ()));
+
+                  F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
+                                             x.data (), y.data (),
+                                             z.fortran_vec ()));
                   retval = z;
                 }
               else
                 {
                   ComplexNDArray x = argx.complex_array_value ();
                   ComplexNDArray y = argy.complex_array_value ();
                   ComplexNDArray z (dimz);
-                  if (! error_state)
-                    F77_XFCN (zmatm3, ZMATM3, (m, n, k, np,
-                                               x.data (), y.data (),
-                                               z.fortran_vec ()));
+
+                  F77_XFCN (zmatm3, ZMATM3, (m, n, k, np,
+                                             x.data (), y.data (),
+                                             z.fortran_vec ()));
                   retval = z;
                 }
             }
           else
             {
               if (argx.is_single_type () || argy.is_single_type ())
                 {
                   FloatNDArray x = argx.float_array_value ();
                   FloatNDArray y = argy.float_array_value ();
                   FloatNDArray z (dimz);
-                  if (! error_state)
-                    F77_XFCN (smatm3, SMATM3, (m, n, k, np,
-                                               x.data (), y.data (),
-                                               z.fortran_vec ()));
+
+                  F77_XFCN (smatm3, SMATM3, (m, n, k, np,
+                                             x.data (), y.data (),
+                                             z.fortran_vec ()));
                   retval = z;
                 }
               else
                 {
                   NDArray x = argx.array_value ();
                   NDArray y = argy.array_value ();
                   NDArray z (dimz);
-                  if (! error_state)
-                    F77_XFCN (dmatm3, DMATM3, (m, n, k, np,
-                                               x.data (), y.data (),
-                                               z.fortran_vec ()));
+
+                  F77_XFCN (dmatm3, DMATM3, (m, n, k, np,
+                                             x.data (), y.data (),
+                                             z.fortran_vec ()));
                   retval = z;
                 }
             }
         }
       else
         error ("blkmm: A and B dimensions don't match: (%s) and (%s)",
                dimx.str ().c_str (), dimy.str ().c_str ());
 
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -174,210 +174,180 @@ values of @var{p} @var{q} as vector valu
         }
       else
         droptol = args(1).double_value ();
 
       if (nargin == 3)
         {
           std::string tmp = args(2).string_value ();
 
-          if (! error_state)
-            {
-              if (tmp.compare ("vector") == 0)
-                vecout = true;
-              else
-                error ("luinc: unrecognized string argument");
-            }
+          if (tmp.compare ("vector") == 0)
+            vecout = true;
+          else
+            error ("luinc: unrecognized string argument");
         }
 
       // FIXME: Add code for zero-level factorization
       if (zero_level)
         error ("luinc: zero-level factorization not implemented");
 
-      if (!error_state)
+      if (args(0).type_name () == "sparse matrix")
         {
-          if (args(0).type_name () == "sparse matrix")
+          SparseMatrix sm = args(0).sparse_matrix_value ();
+          octave_idx_type sm_nr = sm.rows ();
+          octave_idx_type sm_nc = sm.cols ();
+          ColumnVector Qinit (sm_nc);
+
+          for (octave_idx_type i = 0; i < sm_nc; i++)
+            Qinit (i) = i;
+
+          switch (nargout)
             {
-              SparseMatrix sm = args(0).sparse_matrix_value ();
-              octave_idx_type sm_nr = sm.rows ();
-              octave_idx_type sm_nc = sm.cols ();
-              ColumnVector Qinit (sm_nc);
+            case 0:
+            case 1:
+            case 2:
+              {
+                SparseLU fact (sm, Qinit, thresh, false, true, droptol,
+                               milu, udiag);
 
-              for (octave_idx_type i = 0; i < sm_nc; i++)
-                Qinit (i) = i;
+                SparseMatrix P = fact.Pr ();
+                SparseMatrix L = P.transpose () * fact.L ();
 
-              if (! error_state)
-                {
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                    case 2:
-                      {
-                        SparseLU fact (sm, Qinit, thresh, false, true, droptol,
-                                       milu, udiag);
+                retval(1)
+                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+
+                retval(0)
+                  = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
+                                                 sm_nr, fact.row_perm ()));
+              }
+              break;
 
-                        if (! error_state)
-                          {
-                            SparseMatrix P = fact.Pr ();
-                            SparseMatrix L = P.transpose () * fact.L ();
-                            retval(1)
-                              = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
-                            retval(0)
-                              = octave_value (L, MatrixType
-                                                   (MatrixType::Permuted_Lower,
-                                                    sm_nr, fact.row_perm ()));
-                          }
-                      }
-                      break;
+            case 3:
+              {
+                SparseLU fact (sm, Qinit, thresh, false, true, droptol,
+                               milu, udiag);
 
-                    case 3:
-                      {
-                        SparseLU fact (sm, Qinit, thresh, false, true, droptol,
-                                       milu, udiag);
+                if (vecout)
+                  retval(2) = fact.Pr_vec ();
+                else
+                  retval(2) = fact.Pr_mat ();
+
+                retval(1)
+                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
-                        if (! error_state)
-                          {
-                            if (vecout)
-                              retval(2) = fact.Pr_vec ();
-                            else
-                              retval(2) = fact.Pr_mat ();
-                            retval(1)
-                              = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
-                            retval(0)
-                              = octave_value (fact.L (),
-                                              MatrixType (MatrixType::Lower));
-                          }
-                      }
-                      break;
+                retval(0)
+                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+              }
+              break;
+
+            case 4:
+            default:
+              {
+                SparseLU fact (sm, Qinit, thresh, false, false, droptol,
+                               milu, udiag);
 
-                    case 4:
-                    default:
-                      {
-                        SparseLU fact (sm, Qinit, thresh, false, false, droptol,
-                                       milu, udiag);
+                if (vecout)
+                  {
+                    retval(3) = fact.Pc_vec ();
+                    retval(2) = fact.Pr_vec ();
+                  }
+                else
+                  {
+                    retval(3) = fact.Pc_mat ();
+                    retval(2) = fact.Pr_mat ();
+                  }
+
+                retval(1)
+                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
-                        if (! error_state)
-                          {
-                            if (vecout)
-                              {
-                                retval(3) = fact.Pc_vec ();
-                                retval(2) = fact.Pr_vec ();
-                              }
-                            else
-                              {
-                                retval(3) = fact.Pc_mat ();
-                                retval(2) = fact.Pr_mat ();
-                              }
-                            retval(1)
-                              = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
-                            retval(0)
-                              = octave_value (fact.L (),
-                                              MatrixType (MatrixType::Lower));
-                          }
-                      }
-                      break;
-                    }
-                }
+                retval(0)
+                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+              }
+              break;
             }
-          else if (args(0).type_name () == "sparse complex matrix")
-            {
-              SparseComplexMatrix sm =
-                args(0).sparse_complex_matrix_value ();
-              octave_idx_type sm_nr = sm.rows ();
-              octave_idx_type sm_nc = sm.cols ();
-              ColumnVector Qinit (sm_nc);
-
-              for (octave_idx_type i = 0; i < sm_nc; i++)
-                Qinit (i) = i;
+        }
+      else if (args(0).type_name () == "sparse complex matrix")
+        {
+          SparseComplexMatrix sm =
+            args(0).sparse_complex_matrix_value ();
+          octave_idx_type sm_nr = sm.rows ();
+          octave_idx_type sm_nc = sm.cols ();
+          ColumnVector Qinit (sm_nc);
 
-              if (! error_state)
-                {
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                    case 2:
-                      {
-                        SparseComplexLU fact (sm, Qinit, thresh, false, true,
-                                              droptol, milu, udiag);
+          for (octave_idx_type i = 0; i < sm_nc; i++)
+            Qinit (i) = i;
+
+          switch (nargout)
+            {
+            case 0:
+            case 1:
+            case 2:
+              {
+                SparseComplexLU fact (sm, Qinit, thresh, false, true,
+                                      droptol, milu, udiag);
 
 
-                        if (! error_state)
-                          {
-                            SparseMatrix P = fact.Pr ();
-                            SparseComplexMatrix L = P.transpose () * fact.L ();
-                            retval(1)
-                              = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
-                            retval(0)
-                              = octave_value (L, MatrixType
-                                                  (MatrixType::Permuted_Lower,
-                                                   sm_nr, fact.row_perm ()));
-                          }
-                      }
-                      break;
+                SparseMatrix P = fact.Pr ();
+                SparseComplexMatrix L = P.transpose () * fact.L ();
+
+                retval(1)
+                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+
+                retval(0)
+                  = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
+                                                 sm_nr, fact.row_perm ()));
+              }
+              break;
 
-                    case 3:
-                      {
-                        SparseComplexLU fact (sm, Qinit, thresh, false, true,
-                                              droptol, milu, udiag);
+            case 3:
+              {
+                SparseComplexLU fact (sm, Qinit, thresh, false, true,
+                                      droptol, milu, udiag);
+
+                if (vecout)
+                  retval(2) = fact.Pr_vec ();
+                else
+                  retval(2) = fact.Pr_mat ();
+
+                retval(1)
+                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
-                        if (! error_state)
-                          {
-                            if (vecout)
-                              retval(2) = fact.Pr_vec ();
-                            else
-                              retval(2) = fact.Pr_mat ();
-                            retval(1)
-                              = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
-                            retval(0)
-                              = octave_value (fact.L (),
-                                              MatrixType (MatrixType::Lower));
-                          }
-                      }
-                      break;
+                retval(0)
+                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+              }
+              break;
 
-                    case 4:
-                    default:
-                      {
-                        SparseComplexLU fact (sm, Qinit, thresh, false, false,
-                                              droptol, milu, udiag);
+            case 4:
+            default:
+              {
+                SparseComplexLU fact (sm, Qinit, thresh, false, false,
+                                      droptol, milu, udiag);
 
-                        if (! error_state)
-                          {
-                            if (vecout)
-                              {
-                                retval(3) = fact.Pc_vec ();
-                                retval(2) = fact.Pr_vec ();
-                              }
-                            else
-                              {
-                                retval(3) = fact.Pc_mat ();
-                                retval(2) = fact.Pr_mat ();
-                              }
-                            retval(1)
-                              = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
-                            retval(0)
-                              = octave_value (fact.L (),
-                                              MatrixType (MatrixType::Lower));
-                          }
-                      }
-                      break;
-                    }
-                }
+                if (vecout)
+                  {
+                    retval(3) = fact.Pc_vec ();
+                    retval(2) = fact.Pr_vec ();
+                  }
+                else
+                  {
+                    retval(3) = fact.Pc_mat ();
+                    retval(2) = fact.Pr_mat ();
+                  }
+
+                retval(1)
+                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+
+                retval(0)
+                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+              }
+              break;
             }
-          else
-            error ("luinc: matrix A must be sparse");
         }
+      else
+        error ("luinc: matrix A must be sparse");
     }
 
   return retval;
 }
 
 /*
 %!testif HAVE_UMFPACK
 %! a = sparse ([1,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -121,98 +121,54 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
     {
       if (arg_a.is_complex_type ()
           || arg_b.is_complex_type ()
           || arg_c.is_complex_type ())
         {
           // Do everything in complex arithmetic;
 
           FloatComplexMatrix ca = arg_a.float_complex_matrix_value ();
-
-          if (error_state)
-            return retval;
-
           FloatComplexMatrix cb = arg_b.float_complex_matrix_value ();
-
-          if (error_state)
-            return retval;
-
           FloatComplexMatrix cc = arg_c.float_complex_matrix_value ();
 
-          if (error_state)
-            return retval;
-
           retval = Sylvester (ca, cb, cc);
         }
       else
         {
           // Do everything in real arithmetic.
 
           FloatMatrix ca = arg_a.float_matrix_value ();
-
-          if (error_state)
-            return retval;
-
           FloatMatrix cb = arg_b.float_matrix_value ();
-
-          if (error_state)
-            return retval;
-
           FloatMatrix cc = arg_c.float_matrix_value ();
 
-          if (error_state)
-            return retval;
-
           retval = Sylvester (ca, cb, cc);
         }
     }
   else
     {
       if (arg_a.is_complex_type ()
           || arg_b.is_complex_type ()
           || arg_c.is_complex_type ())
         {
           // Do everything in complex arithmetic;
 
           ComplexMatrix ca = arg_a.complex_matrix_value ();
-
-          if (error_state)
-            return retval;
-
           ComplexMatrix cb = arg_b.complex_matrix_value ();
-
-          if (error_state)
-            return retval;
-
           ComplexMatrix cc = arg_c.complex_matrix_value ();
 
-          if (error_state)
-            return retval;
-
           retval = Sylvester (ca, cb, cc);
         }
       else
         {
           // Do everything in real arithmetic.
 
           Matrix ca = arg_a.matrix_value ();
-
-          if (error_state)
-            return retval;
-
           Matrix cb = arg_b.matrix_value ();
-
-          if (error_state)
-            return retval;
-
           Matrix cc = arg_c.matrix_value ();
 
-          if (error_state)
-            return retval;
-
           retval = Sylvester (ca, cb, cc);
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -262,18 +262,16 @@ generate_struct_completions (const std::
         base_name = base_name.substr (0, pos);
 
       if (is_variable (base_name))
         {
           int parse_status;
 
           unwind_protect frame;
 
-          frame.protect_var (error_state);
-
           frame.protect_var (discard_error_messages);
           frame.protect_var (discard_warning_messages);
 
           discard_error_messages = true;
           discard_warning_messages = true;
 
           octave_value tmp = eval_string (prefix, true, parse_status);
 
@@ -304,17 +302,16 @@ looks_like_struct (const std::string& te
 
   if (sr && ! sr->is_function ())
     {
       int parse_status;
 
       unwind_protect frame;
 
       frame.protect_var (discard_error_messages);
-      frame.protect_var (error_state);
 
       discard_error_messages = true;
 
       octave_value tmp = eval_string (text, true, parse_status);
 
       frame.run ();
 
       retval = (tmp.is_defined () && tmp.is_map ());
@@ -1691,23 +1688,20 @@ do_who (int argc, const string_vector& a
 
               octave_call_stack::push (tmp_scope, 0);
               frame.add_fcn (octave_call_stack::pop);
 
               frame.add_fcn (symbol_table::clear_variables);
 
               feval ("load", octave_value (nm), 0);
 
-              if (! error_state)
-                {
-                  std::string newmsg = std::string ("Variables in the file ") +
-                                       nm + ":\n\n";
-
-                  retval =  do_who (i, argv, return_list, verbose, newmsg);
-                }
+              std::string newmsg = std::string ("Variables in the file ")
+                + nm + ":\n\n";
+
+              retval =  do_who (i, argv, return_list, verbose, newmsg);
             }
 
           return retval;
         }
       else if (argv[i] == "-regexp")
         have_regexp = true;
       else if (argv[i] == "global")
         global_only = true;
@@ -1781,20 +1775,17 @@ do_who (int argc, const string_vector& a
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
                           octave_value expr_val
                             = eval_string (pat, true, parse_status);
 
-                          if (! error_state)
-                            symbol_stats.append (sr, pat, expr_val);
-                          else
-                            return retval;
+                          symbol_stats.append (sr, pat, expr_val);
                         }
                     }
                 }
             }
           else
             {
               std::list<symbol_table::symbol_record> tmp = global_only
                 ? symbol_table::glob_global_variables (pat)
@@ -1892,18 +1883,17 @@ matching the given patterns.\n\
   octave_value retval;
 
   if (nargout < 2)
     {
       int argc = args.length () + 1;
 
       string_vector argv = args.make_argv ("who");
 
-      if (! error_state)
-        retval = do_who (argc, argv, nargout == 1);
+      retval = do_who (argc, argv, nargout == 1);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (whos, args, nargout,
@@ -1973,18 +1963,17 @@ complex, nesting, persistent.\n\
   octave_value retval;
 
   if (nargout < 2)
     {
       int argc = args.length () + 1;
 
       string_vector argv = args.make_argv ("whos");
 
-      if (! error_state)
-        retval = do_who (argc, argv, nargout == 1, true);
+      retval = do_who (argc, argv, nargout == 1, true);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // Defining variables.
@@ -2463,139 +2452,136 @@ without the dash as well.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("clear");
 
-  if (! error_state)
+  if (argc == 1)
+    {
+      do_clear_globals (argv, argc, true);
+      do_clear_variables (argv, argc, true);
+
+      octave_link::clear_workspace ();
+    }
+  else
     {
-      if (argc == 1)
-        {
-          do_clear_globals (argv, argc, true);
-          do_clear_variables (argv, argc, true);
-
-          octave_link::clear_workspace ();
-        }
-      else
+      int idx = 0;
+
+      bool clear_all = false;
+      bool clear_functions = false;
+      bool clear_globals = false;
+      bool clear_variables = false;
+      bool clear_objects = false;
+      bool exclusive = false;
+      bool have_regexp = false;
+      bool have_dash_option = false;
+
+      while (++idx < argc)
         {
-          int idx = 0;
-
-          bool clear_all = false;
-          bool clear_functions = false;
-          bool clear_globals = false;
-          bool clear_variables = false;
-          bool clear_objects = false;
-          bool exclusive = false;
-          bool have_regexp = false;
-          bool have_dash_option = false;
-
-          while (++idx < argc)
+          if (argv[idx] == "-all" || argv[idx] == "-a")
+            {
+              CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+
+              have_dash_option = true;
+              clear_all = true;
+            }
+          else if (argv[idx] == "-exclusive" || argv[idx] == "-x")
+            {
+              have_dash_option = true;
+              exclusive = true;
+            }
+          else if (argv[idx] == "-functions" || argv[idx] == "-f")
+            {
+              CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+
+              have_dash_option = true;
+              clear_functions = true;
+            }
+          else if (argv[idx] == "-global" || argv[idx] == "-g")
+            {
+              CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+
+              have_dash_option = true;
+              clear_globals = true;
+            }
+          else if (argv[idx] == "-variables" || argv[idx] == "-v")
             {
-              if (argv[idx] == "-all" || argv[idx] == "-a")
-                {
-                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
-
-                  have_dash_option = true;
-                  clear_all = true;
-                }
-              else if (argv[idx] == "-exclusive" || argv[idx] == "-x")
-                {
-                  have_dash_option = true;
-                  exclusive = true;
-                }
-              else if (argv[idx] == "-functions" || argv[idx] == "-f")
+              CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+
+              have_dash_option = true;
+              clear_variables = true;
+            }
+          else if (argv[idx] == "-classes" || argv[idx] == "-c")
+            {
+              CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+
+              have_dash_option = true;
+              clear_objects = true;
+            }
+          else if (argv[idx] == "-regexp" || argv[idx] == "-r")
+            {
+              CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+
+              have_dash_option = true;
+              have_regexp = true;
+            }
+          else
+            break;
+        }
+
+      if (idx <= argc)
+        {
+          if (! have_dash_option)
+            {
+              do_matlab_compatible_clear (argv, argc, idx);
+            }
+          else
+            {
+              if (clear_all)
                 {
-                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
-
-                  have_dash_option = true;
-                  clear_functions = true;
+                  maybe_warn_exclusive (exclusive);
+
+                  if (++idx < argc)
+                    warning
+                      ("clear: ignoring extra arguments after -all");
+
+                  symbol_table::clear_all ();
                 }
-              else if (argv[idx] == "-global" || argv[idx] == "-g")
+              else if (have_regexp)
                 {
-                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
-
-                  have_dash_option = true;
-                  clear_globals = true;
+                  do_clear_variables (argv, argc, idx, exclusive, true);
                 }
-              else if (argv[idx] == "-variables" || argv[idx] == "-v")
-                {
-                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
-
-                  have_dash_option = true;
-                  clear_variables = true;
-                }
-              else if (argv[idx] == "-classes" || argv[idx] == "-c")
+              else if (clear_functions)
                 {
-                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
-
-                  have_dash_option = true;
-                  clear_objects = true;
+                  do_clear_functions (argv, argc, idx, exclusive);
                 }
-              else if (argv[idx] == "-regexp" || argv[idx] == "-r")
+              else if (clear_globals)
+                {
+                  do_clear_globals (argv, argc, idx, exclusive);
+                }
+              else if (clear_variables)
                 {
-                  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
-
-                  have_dash_option = true;
-                  have_regexp = true;
+                  do_clear_variables (argv, argc, idx, exclusive);
                 }
-              else
-                break;
-            }
-
-          if (idx <= argc)
-            {
-              if (! have_dash_option)
+              else if (clear_objects)
                 {
-                  do_matlab_compatible_clear (argv, argc, idx);
+                  symbol_table::clear_objects ();
+                  octave_class::clear_exemplar_map ();
+                  symbol_table::clear_all ();
                 }
               else
                 {
-                  if (clear_all)
-                    {
-                      maybe_warn_exclusive (exclusive);
-
-                      if (++idx < argc)
-                        warning
-                          ("clear: ignoring extra arguments after -all");
-
-                      symbol_table::clear_all ();
-                    }
-                  else if (have_regexp)
-                    {
-                      do_clear_variables (argv, argc, idx, exclusive, true);
-                    }
-                  else if (clear_functions)
-                    {
-                      do_clear_functions (argv, argc, idx, exclusive);
-                    }
-                  else if (clear_globals)
-                    {
-                      do_clear_globals (argv, argc, idx, exclusive);
-                    }
-                  else if (clear_variables)
-                    {
-                      do_clear_variables (argv, argc, idx, exclusive);
-                    }
-                  else if (clear_objects)
-                    {
-                      symbol_table::clear_objects ();
-                      octave_class::clear_exemplar_map ();
-                      symbol_table::clear_all ();
-                    }
-                  else
-                    {
-                      do_clear_symbols (argv, argc, idx, exclusive);
-                    }
+                  do_clear_symbols (argv, argc, idx, exclusive);
                 }
-
-              octave_link::set_workspace ();
             }
+
+          octave_link::set_workspace ();
         }
     }
 
   return retval;
 }
 
 DEFUN (whos_line_format, args, nargout,
        "-*- texinfo -*-\n\
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -265,17 +265,17 @@ Undocumented internal function.\n\
               amm = (args(0).matrix_value ());
             }
         }
 
     }
 
   // Note hold off reading B till later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex.
-  if (! error_state && nargin > 1 + arg_offset
+  if (nargin > 1 + arg_offset
       && ! (args(1 + arg_offset).is_real_scalar ()))
     {
       if (args(1+arg_offset).is_complex_type ())
         {
           b_arg = 1+arg_offset;
           have_b = true;
           b_is_complex = true;
           arg_offset++;
@@ -283,20 +283,20 @@ Undocumented internal function.\n\
       else
         {
           b_arg = 1+arg_offset;
           have_b = true;
           arg_offset++;
         }
     }
 
-  if (!error_state && nargin > (1+arg_offset))
+  if (nargin > (1+arg_offset))
     k = args(1+arg_offset).nint_value ();
 
-  if (!error_state && nargin > (2+arg_offset))
+  if (nargin > (2+arg_offset))
     {
       if (args(2+arg_offset).is_string ())
         {
           typ = args(2+arg_offset).string_value ();
 
           // Use STL function to convert to upper case
           transform (typ.begin (), typ.end (), typ.begin (), toupper);
 
@@ -314,17 +314,17 @@ Undocumented internal function.\n\
               return retval;
             }
         }
     }
 
   sigmar = std::real (sigma);
   sigmai = std::imag (sigma);
 
-  if (!error_state && nargin > (3+arg_offset))
+  if (nargin > (3+arg_offset))
     {
       if (args(3+arg_offset).is_map ())
         {
           octave_scalar_map map = args(3+arg_offset).scalar_map_value ();
 
           if (! error_state)
             {
               octave_value tmp;
@@ -418,205 +418,202 @@ Undocumented internal function.\n\
             bsmm = args(b_arg).sparse_matrix_value ();
           else
             bmm = args(b_arg).matrix_value ();
         }
     }
 
   // Mode 1 for SM mode seems unstable for some reason.
   // Use Mode 3 instead, with sigma = 0.
-  if (!error_state && !have_sigma && typ == "SM")
+  if (! have_sigma && typ == "SM")
     have_sigma = true;
 
-  if (!error_state)
+  octave_idx_type nconv;
+  if (a_is_complex || b_is_complex)
     {
-      octave_idx_type nconv;
-      if (a_is_complex || b_is_complex)
-        {
-          ComplexMatrix eig_vec;
-          ComplexColumnVector eig_val;
+      ComplexMatrix eig_vec;
+      ComplexColumnVector eig_val;
 
 
+      if (have_a_fun)
+        nconv = EigsComplexNonSymmetricFunc
+          (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
+           eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
+           disp, maxit);
+      else if (have_sigma)
+        {
+          if (a_is_sparse)
+            nconv = EigsComplexNonSymmetricMatrixShift
+              (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
+               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+               maxit);
+          else
+            nconv = EigsComplexNonSymmetricMatrixShift
+              (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB,
+               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+               maxit);
+        }
+      else
+        {
+          if (a_is_sparse)
+            nconv = EigsComplexNonSymmetricMatrix
+              (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB,
+               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+               maxit);
+          else
+            nconv = EigsComplexNonSymmetricMatrix
+              (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB,
+               cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+               maxit);
+        }
+
+      if (nargout < 2)
+        retval(0) = eig_val;
+      else
+        {
+          retval(2) = double (info);
+          retval(1) = ComplexDiagMatrix (eig_val);
+          retval(0) = eig_vec;
+        }
+    }
+  else if (sigmai != 0.)
+    {
+      // Promote real problem to a complex one.
+      ComplexMatrix eig_vec;
+      ComplexColumnVector eig_val;
+
+      if (have_a_fun)
+        nconv = EigsComplexNonSymmetricFunc
+          (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec,
+           eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
+           disp, maxit);
+      else
+        {
+          if (a_is_sparse)
+            nconv = EigsComplexNonSymmetricMatrixShift
+              (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
+               eig_val, SparseComplexMatrix (bsmm), permB, cresid,
+               octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+          else
+            nconv = EigsComplexNonSymmetricMatrixShift
+              (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
+               eig_val, ComplexMatrix (bmm), permB, cresid,
+               octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+        }
+
+      if (nargout < 2)
+        retval(0) = eig_val;
+      else
+        {
+          retval(2) = double (info);
+          retval(1) = ComplexDiagMatrix (eig_val);
+          retval(0) = eig_vec;
+        }
+    }
+  else
+    {
+      if (symmetric)
+        {
+          Matrix eig_vec;
+          ColumnVector eig_val;
+
           if (have_a_fun)
-            nconv = EigsComplexNonSymmetricFunc
-                    (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
-                     eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
-                     disp, maxit);
+            nconv = EigsRealSymmetricFunc
+              (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+               eig_val, resid, octave_stdout, tol, (nargout > 1),
+               cholB, disp, maxit);
           else if (have_sigma)
             {
               if (a_is_sparse)
-                nconv = EigsComplexNonSymmetricMatrixShift
-                        (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
-                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                         maxit);
+                nconv = EigsRealSymmetricMatrixShift
+                  (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
+                   permB, resid, octave_stdout, tol, (nargout > 1),
+                   cholB, disp, maxit);
               else
-                nconv = EigsComplexNonSymmetricMatrixShift
-                        (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB,
-                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                         maxit);
+                nconv = EigsRealSymmetricMatrixShift
+                  (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
+                   permB, resid, octave_stdout, tol, (nargout > 1),
+                   cholB, disp, maxit);
             }
           else
             {
               if (a_is_sparse)
-                nconv = EigsComplexNonSymmetricMatrix
-                        (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB,
-                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                         maxit);
+                nconv = EigsRealSymmetricMatrix
+                  (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
+                   permB, resid, octave_stdout, tol, (nargout > 1),
+                   cholB, disp, maxit);
               else
-                nconv = EigsComplexNonSymmetricMatrix
-                        (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB,
-                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                         maxit);
+                nconv = EigsRealSymmetricMatrix
+                  (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                   resid, octave_stdout, tol, (nargout > 1), cholB,
+                   disp, maxit);
             }
 
           if (nargout < 2)
             retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
-              retval(1) = ComplexDiagMatrix (eig_val);
+              retval(1) = DiagMatrix (eig_val);
               retval(0) = eig_vec;
             }
         }
-      else if (sigmai != 0.)
+      else
         {
-          // Promote real problem to a complex one.
           ComplexMatrix eig_vec;
           ComplexColumnVector eig_val;
 
           if (have_a_fun)
-            nconv = EigsComplexNonSymmetricFunc
-                    (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec,
-                     eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
-                     disp, maxit);
+            nconv = EigsRealNonSymmetricFunc
+              (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+               eig_val, resid, octave_stdout, tol, (nargout > 1),
+               cholB, disp, maxit);
+          else if (have_sigma)
+            {
+              if (a_is_sparse)
+                nconv = EigsRealNonSymmetricMatrixShift
+                  (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
+                   permB, resid, octave_stdout, tol, (nargout > 1),
+                   cholB, disp, maxit);
+              else
+                nconv = EigsRealNonSymmetricMatrixShift
+                  (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
+                   permB, resid, octave_stdout, tol, (nargout > 1),
+                   cholB, disp, maxit);
+            }
           else
             {
               if (a_is_sparse)
-                nconv = EigsComplexNonSymmetricMatrixShift
-                        (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
-                         eig_val, SparseComplexMatrix (bsmm), permB, cresid,
-                         octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                nconv = EigsRealNonSymmetricMatrix
+                  (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
+                   permB, resid, octave_stdout, tol, (nargout > 1),
+                   cholB, disp, maxit);
               else
-                nconv = EigsComplexNonSymmetricMatrixShift
-                        (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
-                         eig_val, ComplexMatrix (bmm), permB, cresid,
-                         octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                nconv = EigsRealNonSymmetricMatrix
+                  (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                   resid, octave_stdout, tol, (nargout > 1), cholB,
+                   disp, maxit);
             }
 
           if (nargout < 2)
             retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
               retval(1) = ComplexDiagMatrix (eig_val);
               retval(0) = eig_vec;
             }
         }
-      else
-        {
-          if (symmetric)
-            {
-              Matrix eig_vec;
-              ColumnVector eig_val;
-
-              if (have_a_fun)
-                nconv = EigsRealSymmetricFunc
-                        (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
-                         eig_val, resid, octave_stdout, tol, (nargout > 1),
-                         cholB, disp, maxit);
-              else if (have_sigma)
-                {
-                  if (a_is_sparse)
-                    nconv = EigsRealSymmetricMatrixShift
-                            (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
-                             permB, resid, octave_stdout, tol, (nargout > 1),
-                             cholB, disp, maxit);
-                  else
-                    nconv = EigsRealSymmetricMatrixShift
-                            (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
-                             permB, resid, octave_stdout, tol, (nargout > 1),
-                             cholB, disp, maxit);
-                }
-              else
-                {
-                  if (a_is_sparse)
-                    nconv = EigsRealSymmetricMatrix
-                            (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
-                             permB, resid, octave_stdout, tol, (nargout > 1),
-                             cholB, disp, maxit);
-                  else
-                    nconv = EigsRealSymmetricMatrix
-                            (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-                             resid, octave_stdout, tol, (nargout > 1), cholB,
-                             disp, maxit);
-                }
+    }
 
-              if (nargout < 2)
-                retval(0) = eig_val;
-              else
-                {
-                  retval(2) = double (info);
-                  retval(1) = DiagMatrix (eig_val);
-                  retval(0) = eig_vec;
-                }
-            }
-          else
-            {
-              ComplexMatrix eig_vec;
-              ComplexColumnVector eig_val;
-
-              if (have_a_fun)
-                nconv = EigsRealNonSymmetricFunc
-                        (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
-                         eig_val, resid, octave_stdout, tol, (nargout > 1),
-                         cholB, disp, maxit);
-              else if (have_sigma)
-                {
-                  if (a_is_sparse)
-                    nconv = EigsRealNonSymmetricMatrixShift
-                            (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
-                             permB, resid, octave_stdout, tol, (nargout > 1),
-                             cholB, disp, maxit);
-                  else
-                    nconv = EigsRealNonSymmetricMatrixShift
-                            (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
-                             permB, resid, octave_stdout, tol, (nargout > 1),
-                             cholB, disp, maxit);
-                }
-              else
-                {
-                  if (a_is_sparse)
-                    nconv = EigsRealNonSymmetricMatrix
-                            (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
-                             permB, resid, octave_stdout, tol, (nargout > 1),
-                             cholB, disp, maxit);
-                  else
-                    nconv = EigsRealNonSymmetricMatrix
-                            (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-                             resid, octave_stdout, tol, (nargout > 1), cholB,
-                             disp, maxit);
-                }
-
-              if (nargout < 2)
-                retval(0) = eig_val;
-              else
-                {
-                  retval(2) = double (info);
-                  retval(1) = ComplexDiagMatrix (eig_val);
-                  retval(0) = eig_vec;
-                }
-            }
-        }
-
-      if (nconv <= 0)
-        warning ("eigs: None of the %d requested eigenvalues converged", k);
-      else if (nconv < k)
-        warning ("eigs: Only %d of the %d requested eigenvalues converged",
-                 nconv, k);
-    }
+  if (nconv <= 0)
+    warning ("eigs: None of the %d requested eigenvalues converged", k);
+  else if (nconv < k)
+    warning ("eigs: Only %d of the %d requested eigenvalues converged",
+             nconv, k);
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 #else
   error ("eigs: not available in this version of Octave");
 #endif
 
   return retval;
