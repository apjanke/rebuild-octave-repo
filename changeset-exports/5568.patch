# HG changeset patch
# User jwe
# Date 1134008902 0
#      Thu Dec 08 02:28:22 2005 +0000
# Node ID e9cde940b271c888bbf45f31f03c9b16cdc4deec
# Parent  80e629357483f20f60c5ce99ba9f35bff9ee4e81
[project @ 2005-12-08 02:28:22 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,30 @@
+2005-12-07  John W. Eaton  <jwe@octave.org>
+
+	* statistics/base/moment.m: Don't save and restore warn_str_to_num.
+
+	* sparse/spdiags.m: Don't save and restore warn_fortran_indexing.
+	* strings/strjust.m: Likewise.
+
+	* general/shift.m: Don't save and restore warn_empty_list_elements.
+	* signal/arma_rnd.m: Likewise.
+	* strings/strcat.m: Likewise.
+	* control/base/__freqresp__.m: Likewise.
+	* control/base/place.m: Likewise.
+	* control/base/pzmap.m: Likewise.
+	* control/base/pzmap.m: Likewise.
+	* control/system/sysappend.m: Likewise.
+	* control/system/syscont.m: Likewise.
+	* control/system/sysdisc.m: Likewise.
+	* control/system/sysgroup.m: Likewise.
+	* control/system/tfout.m: Likewise.
+	* control/system/zpout.m: Likewise.
+	* control/util/__outlist__.m: Likewise.
+
 2005-12-06  John W. Eaton  <jwe@octave.org>
 
 	* audio/wavread.m, audio/wavwrite.m: Adapt to Octave coding style.
 	Avoid for loop in interleave/deinterleave steps.
 
 2005-12-06  Michael Zeising  <michael@michaels-website.de>
 
 	* audio/wavread.m, audio/wavwrite.m: New files.
diff --git a/scripts/control/base/__freqresp__.m b/scripts/control/base/__freqresp__.m
--- a/scripts/control/base/__freqresp__.m
+++ b/scripts/control/base/__freqresp__.m
@@ -42,96 +42,88 @@
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 11, 1994
 
 function [ff, w] = __freqresp__ (sys, USEW, w);
 
   ## SYS_INTERNAL accesses members of system data structure
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  ## Check Args
+  if ((nargin < 2) || (nargin > 4))
+    usage ("[ff, w] = __freqresp__ (sys, USEW, w)");
+  elseif (USEW & (nargin < 3) )
+    error ("USEW = 1 but w was not passed.");
+  elseif (USEW & isempty(w))
+    warning("USEW = 1 but w is empty; setting USEW=0");
+    USEW = 0;
+  endif
 
-    ## Check Args
-    if ((nargin < 2) || (nargin > 4))
-      usage ("[ff, w] = __freqresp__ (sys, USEW, w)");
-    elseif (USEW & (nargin < 3) )
-      error ("USEW = 1 but w was not passed.");
-    elseif (USEW & isempty(w))
-      warning("USEW = 1 but w is empty; setting USEW=0");
-      USEW = 0;
-    endif
+  DIGITAL = is_digital(sys);
 
-    DIGITAL = is_digital(sys);
-
-    ## compute default w if needed
-    if(!USEW)
-      if(is_siso(sys))
+  ## compute default w if needed
+  if(!USEW)
+    if(is_siso(sys))
 	sys = sysupdate(sys,"zp");
 	[zer,pol] = sys2zp(sys);
-      else
+    else
 	zer = tzero(sys);
 	pol = eig(sys2ss(sys));
-      endif
-
-      ## get default frequency range
-      [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,sysgettsam(sys));
-      w = logspace(wmin,wmax,50);
-    else
-      w = reshape(w,1,length(w));         # make sure it's a row vector
-    endif
-
-    ## now get complex values of s or z
-    if(DIGITAL)
-      jw = exp(i*w*sysgettsam(sys));
-    else
-      jw = i*w;
     endif
 
-    [nn,nz,mm,pp] = sysdimensions(sys);
+    ## get default frequency range
+    [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,sysgettsam(sys));
+    w = logspace(wmin,wmax,50);
+  else
+    w = reshape(w,1,length(w));         # make sure it's a row vector
+  endif
 
-    ## now compute the frequency response - divide by zero yields a warning
-    if (strcmp(sysgettype(sys),"zp"))
-      ## zero-pole form (preferred)
-      [zer,pol,sysk] = sys2zp(sys);
-      ff = ones(size(jw));
-      l1 = min(length(zer)*(1-isempty(zer)),length(pol)*(1-isempty(pol)));
-      for ii=1:l1
+  ## now get complex values of s or z
+  if(DIGITAL)
+    jw = exp(i*w*sysgettsam(sys));
+  else
+    jw = i*w;
+  endif
+
+  [nn,nz,mm,pp] = sysdimensions(sys);
+
+  ## now compute the frequency response - divide by zero yields a warning
+  if (strcmp(sysgettype(sys),"zp"))
+    ## zero-pole form (preferred)
+    [zer,pol,sysk] = sys2zp(sys);
+    ff = ones(size(jw));
+    l1 = min(length(zer)*(1-isempty(zer)),length(pol)*(1-isempty(pol)));
+    for ii=1:l1
 	ff = ff .* (jw - zer(ii)) ./ (jw - pol(ii));
-      endfor
-
-      ## require proper  transfer function, so now just get poles.
-      for ii=(l1+1):length(pol)
-	ff = ff ./ (jw - pol(ii));
-      endfor
-      ff = ff*sysk;
+    endfor
 
-    elseif (strcmp(sysgettype(sys),"tf"))
-      ## transfer function form
-      [num,den] = sys2tf(sys);
-      ff = polyval(num,jw)./polyval(den,jw);
-    elseif (mm==pp)
-      ## The system is square; do state-space form bode plot
-      [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
-      n = sysn + sysnz;
-      for ii=1:length(jw);
+    ## require proper  transfer function, so now just get poles.
+    for ii=(l1+1):length(pol)
+	ff = ff ./ (jw - pol(ii));
+    endfor
+    ff = ff*sysk;
+
+  elseif (strcmp(sysgettype(sys),"tf"))
+    ## transfer function form
+    [num,den] = sys2tf(sys);
+    ff = polyval(num,jw)./polyval(den,jw);
+  elseif (mm==pp)
+    ## The system is square; do state-space form bode plot
+    [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
+    n = sysn + sysnz;
+    for ii=1:length(jw);
 	ff(ii) = det(sysc*((jw(ii).*eye(n)-sysa)\sysb)+sysd);
-      endfor;
-    else
-      ## Must be state space... bode
-      [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
-      n = sysn + sysnz;
-      for ii=1:length(jw);
+    endfor;
+  else
+    ## Must be state space... bode
+    [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
+    n = sysn + sysnz;
+    for ii=1:length(jw);
 	ff(ii) = norm(sysc*((jw(ii)*eye(n)-sysa)\sysb)+sysd);
-      endfor
+    endfor
 
-    endif
+  endif
 
-    w = reshape(w,1,length(w));
-    ff = reshape(ff,1,length(ff));
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  w = reshape(w,1,length(w));
+  ff = reshape(ff,1,length(ff));
 
 endfunction
 
diff --git a/scripts/control/base/place.m b/scripts/control/base/place.m
--- a/scripts/control/base/place.m
+++ b/scripts/control/base/place.m
@@ -40,92 +40,84 @@
 ##
 ## Algorithm taken from "The Control Handbook", IEEE press pp. 209-212
 ##
 ## code adaped by A.S.Hodel (a.s.hodel@eng.auburn.edu) for use in controls
 ## toolbox
 
 function K = place (sys, P)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
-
-    ## check arguments
+  ## check arguments
 
-    if(!isstruct(sys))
-      error("sys must be in system data structure format (see ss)");
-    endif
-    sys = sysupdate(sys,"ss");    # make sure it has state space form up to date
-    if(!is_controllable(sys))
-      error("sys is not controllable.");
-    elseif( min(size(P)) != 1)
-      error("P must be a vector")
-    else
-      P = reshape(P,length(P),1); # make P a column vector
-    endif
-    ## system must be purely continuous or discrete
-    is_digital(sys);
-    [n,nz,m,p] = sysdimensions(sys);
-    nx = n+nz;    # already checked that it's not a mixed system.
-    if(m != 1)
-      error(["sys has ", num2str(m)," inputs; need only 1"]);
-    endif
+  if(!isstruct(sys))
+    error("sys must be in system data structure format (see ss)");
+  endif
+  sys = sysupdate(sys,"ss");    # make sure it has state space form up to date
+  if(!is_controllable(sys))
+    error("sys is not controllable.");
+  elseif( min(size(P)) != 1)
+    error("P must be a vector")
+  else
+    P = reshape(P,length(P),1); # make P a column vector
+  endif
+  ## system must be purely continuous or discrete
+  is_digital(sys);
+  [n,nz,m,p] = sysdimensions(sys);
+  nx = n+nz;    # already checked that it's not a mixed system.
+  if(m != 1)
+    error(["sys has ", num2str(m)," inputs; need only 1"]);
+  endif
 
-    ## takes the A and B matrix from the system representation
-    [A,B]=sys2ss(sys);
-    sp = length(P);
-    if(nx == 0)
-      error("place: A matrix is empty (0x0)");
-    elseif(nx != length(P))
-      error(["A=(",num2str(nx),"x",num2str(nx),", P has ", num2str(length(P)), ...
-	  "entries."])
-    endif
+  ## takes the A and B matrix from the system representation
+  [A,B]=sys2ss(sys);
+  sp = length(P);
+  if(nx == 0)
+    error("place: A matrix is empty (0x0)");
+  elseif(nx != length(P))
+    error(["A=(",num2str(nx),"x",num2str(nx),", P has ", num2str(length(P)), ...
+	"entries."])
+  endif
 
-    ## arguments appear to be compatible; let's give it a try!
-    ## The second step is the calculation of the characteristic polynomial ofA
-    PC=poly(A);
+  ## arguments appear to be compatible; let's give it a try!
+  ## The second step is the calculation of the characteristic polynomial ofA
+  PC=poly(A);
 
-    ## Third step: Calculate the transformation matrix T that transforms the state
-    ## equation in the controllable canonical form.
+  ## Third step: Calculate the transformation matrix T that transforms the state
+  ## equation in the controllable canonical form.
 
-    ## first we must calculate the controllability matrix M:
-    M=B;
-    AA=A;
-    for n = 2:nx
-      M(:,n)=AA*B;
-      AA=AA*A;
-    endfor
+  ## first we must calculate the controllability matrix M:
+  M=B;
+  AA=A;
+  for n = 2:nx
+    M(:,n)=AA*B;
+    AA=AA*A;
+  endfor
 
-    ## second, construct the matrix W
-    PCO=PC(nx:-1:1);
-    PC1=PCO;      # Matrix to shift and create W row by row
-
-    for n = 1:nx
-      W(n,:) = PC1;
-      PC1=[PCO(n+1:nx),zeros(1,n)];
-    endfor
+  ## second, construct the matrix W
+  PCO=PC(nx:-1:1);
+  PC1=PCO;      # Matrix to shift and create W row by row
 
-    T=M*W;
+  for n = 1:nx
+    W(n,:) = PC1;
+    PC1=[PCO(n+1:nx),zeros(1,n)];
+  endfor
 
-    ## finaly the matrix K is calculated
-    PD = poly(P); # The desired characteristic polynomial
-    PD = PD(nx+1:-1:2);
-    PC = PC(nx+1:-1:2);
+  T=M*W;
 
-    K = (PD-PC)/T;
+  ## finaly the matrix K is calculated
+  PD = poly(P); # The desired characteristic polynomial
+  PD = PD(nx+1:-1:2);
+  PC = PC(nx+1:-1:2);
 
-    ## Check if the eigenvalues of (A-BK) are the same specified in P
-    Pcalc = eig(A-B*K);
+  K = (PD-PC)/T;
 
-    Pcalc = sortcom(Pcalc);
-    P = sortcom(P);
+  ## Check if the eigenvalues of (A-BK) are the same specified in P
+  Pcalc = eig(A-B*K);
 
-    if(max( (abs(Pcalc)-abs(P))./abs(P) ) > 0.1)
-      disp("Place: Pole placed at more than 10% relative error from specified");
-    endif
+  Pcalc = sortcom(Pcalc);
+  P = sortcom(P);
 
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  if(max( (abs(Pcalc)-abs(P))./abs(P) ) > 0.1)
+    disp("Place: Pole placed at more than 10% relative error from specified");
+  endif
 
 endfunction
 
diff --git a/scripts/control/base/pzmap.m b/scripts/control/base/pzmap.m
--- a/scripts/control/base/pzmap.m
+++ b/scripts/control/base/pzmap.m
@@ -34,64 +34,56 @@
 ## if omitted, the poles and zeros are plotted on the screen.
 ## otherwise, @var{pol} and @var{zer} are returned as the 
 ## system poles and zeros (see @command{sys2zp} for a preferable function call).
 ## @end table
 ## @end deftypefn
 
 function [zer, pol]=pzmap (sys)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  if(nargin != 1)
+    usage("pzmap(sys) or [zer,pol] = pzmap(sys)");
+  elseif (!isstruct(sys));
+    error("sys must be in system format");
+  endif
 
-    if(nargin != 1)
-      usage("pzmap(sys) or [zer,pol] = pzmap(sys)");
-    elseif (!isstruct(sys));
-      error("sys must be in system format");
-    endif
-
-    [zer,pol] = sys2zp(sys);
+  [zer,pol] = sys2zp(sys);
 
-    ## force to column vectors, split into real, imaginary parts
-    zerdata = poldata = [];
-    if(length(zer))
-      zer = reshape(zer,length(zer),1);
-      zerdata = [real(zer(:,1)), imag(zer(:,1))];
-    endif
-    if(length(pol))
-      pol = reshape(pol,length(pol),1);
-      poldata = [real(pol(:,1)), imag(pol(:,1))];
-    endif
+  ## force to column vectors, split into real, imaginary parts
+  zerdata = poldata = [];
+  if(length(zer))
+    zer = reshape(zer,length(zer),1);
+    zerdata = [real(zer(:,1)), imag(zer(:,1))];
+  endif
+  if(length(pol))
+    pol = reshape(pol,length(pol),1);
+    poldata = [real(pol(:,1)), imag(pol(:,1))];
+  endif
 
-    ## determine continuous or discrete plane
-    vars = "sz";
-    varstr = vars(is_digital(sys) + 1);
+  ## determine continuous or discrete plane
+  vars = "sz";
+  varstr = vars(is_digital(sys) + 1);
 
-    ## Plot the data
-    __gnuplot_set__ nologscale xy;
-    if(is_siso(sys))
-      title(sprintf("Pole-zero map from %s to %s", ...
+  ## Plot the data
+  __gnuplot_set__ nologscale xy;
+  if(is_siso(sys))
+    title(sprintf("Pole-zero map from %s to %s", ...
 	 sysgetsignals(sys,"in",1,1), sysgetsignals(sys,"out",1,1) ));
-    endif
-    xlabel(["Re(",varstr,")"]);
-    ylabel(["Im(",varstr,")"]);
-    grid;
+  endif
+  xlabel(["Re(",varstr,")"]);
+  ylabel(["Im(",varstr,")"]);
+  grid;
 
-    ## compute axis limits
-    axis(axis2dlim([zerdata;poldata]));
-    grid
-    ## finally, plot the data
-    if(length(zer) == 0)
-      plot(poldata(:,1), poldata(:,2),"@12 ;poles (no zeros);");
-    elseif(length(pol) == 0)
-      plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros (no poles);");
-    else
-      plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros;", ...
+  ## compute axis limits
+  axis(axis2dlim([zerdata;poldata]));
+  grid
+  ## finally, plot the data
+  if(length(zer) == 0)
+    plot(poldata(:,1), poldata(:,2),"@12 ;poles (no zeros);");
+  elseif(length(pol) == 0)
+    plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros (no poles);");
+  else
+    plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros;", ...
 	poldata(:,1), poldata(:,2),"@12 ;poles;");
-    endif
-    replot
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  endif
+  replot
 
 endfunction
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -77,125 +77,117 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = sysappend (sys, b, c, d, outname, inname, yd)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  ## check input arguments
+  if ( (nargin < 2) | (nargin > 7) | (!isstruct(sys)))
+    usage("retsys = sysappend(sys,b,c[,d,outname,inname,yd]) ");
+  elseif(!isstruct(sys))
+    error("sys must be a system data structure");
+  endif
 
-    ## check input arguments
-    if ( (nargin < 2) | (nargin > 7) | (!isstruct(sys)))
-      usage("retsys = sysappend(sys,b,c[,d,outname,inname,yd]) ");
-    elseif(!isstruct(sys))
-      error("sys must be a system data structure");
-    endif
-
-    ## default system type must be state space form
-    [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
-    [Ann,Anz,Am,Ap] = sysdimensions(sys);
+  ## default system type must be state space form
+  [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
+  [Ann,Anz,Am,Ap] = sysdimensions(sys);
 
-    ## default c
-    if(nargin < 3)      c = [];                                endif
+  ## default c
+  if(nargin < 3)      c = [];                                endif
 
-    ## default d
-    if(nargin < 4)     make_d = 1;
-    elseif(isempty(d)) make_d = 1;
-    else               make_d = 0;                             endif
-    if(make_d)         d = zeros(rows(c)+Ap,columns(b) + Am);  endif
+  ## default d
+  if(nargin < 4)     make_d = 1;
+  elseif(isempty(d)) make_d = 1;
+  else               make_d = 0;                             endif
+  if(make_d)         d = zeros(rows(c)+Ap,columns(b) + Am);  endif
 
-    ## Append new input(s) if any
-    Bm = max(columns(d),columns(b)+Am);
-    if(Bm != Am)
-      ## construct new signal names
-      if(nargin >= 6)   # new names were passed
+  ## Append new input(s) if any
+  Bm = max(columns(d),columns(b)+Am);
+  if(Bm != Am)
+    ## construct new signal names
+    if(nargin >= 6)   # new names were passed
 	if(!ischar(inname))
 	  error("inname must be a string");
 	elseif(rows(inname) != (Bm - Am))
 	  error(sprintf("%d new inputs requested; inname(%dx%d)", ...
 	    (Bm-Am),rows(inname),columns(inname)));
 	endif
-      else
+    else
 	inname = __sysdefioname__(Bm,"u",(Am+1));
-      endif
+    endif
 
-      if(Am)
-        Ain = __sysconcat__(Ain,inname);
-      else
-        Ain = inname;
-      endif
+    if(Am)
+      Ain = __sysconcat__(Ain,inname);
+    else
+      Ain = inname;
+    endif
 
-      ## default b matrix
-      if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));
-      elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
+    ## default b matrix
+    if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));
+    elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
 	  error(sprintf("b(%dx%d); should be (%dx%d)", rows(b), columns(b), ...
 	    (Ann+Anz), (Bm-Am)));
-      endif
-
-      ## append new b matrix
-      Ab = [Ab,b];
     endif
 
-    ## Append new output(s) if any
-    Bp = max(rows(d),rows(c)+Ap);
-    if(Bp != Ap)
+    ## append new b matrix
+    Ab = [Ab,b];
+  endif
 
-      ## construct new signal names, output classification
-      if(nargin >= 5)  # new names were passed
+  ## Append new output(s) if any
+  Bp = max(rows(d),rows(c)+Ap);
+  if(Bp != Ap)
+
+    ## construct new signal names, output classification
+    if(nargin >= 5)  # new names were passed
 	if(!ischar(outname))
 	  error("outname must be a string");
 	elseif(rows(outname) != (Bp - Ap))
 	  error(sprintf("%d new outputs requested; outname(%dx%d)", ...
 	    (Bp-Ap),rows(outname),columns(outname)));
 	endif
-      else
+    else
 	outname = __sysdefioname__(Bp,"y",(Ap+1));
-      endif
-      if(Ap)   Aout = __sysconcat__(Aout,outname);
-      else     Aout = outname;                endif
+    endif
+    if(Ap)   Aout = __sysconcat__(Aout,outname);
+    else     Aout = outname;                endif
 
-      ## construct new yd entries
-      if(nargin == 7)
+    ## construct new yd entries
+    if(nargin == 7)
 	if(!isvector(yd))
 	  error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
 	elseif(rows(c) != length(yd) & rows(d) != length(yd))
 	  error(sprintf("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch", ...
 	    length(yd), rows(c), columns(c),rows(d),columns(d)));
 	endif
-      else
+    else
 	## default yd values
 	yd = ones(1,Bp)*( (Ats > 0) & (Ann == 0)  & isempty(find(Ayd == 0)) ) ;
-      endif
-      Ayd = [vec(Ayd);vec(yd)];
+    endif
+    Ayd = [vec(Ayd);vec(yd)];
 
-      ## default c matrix
-      if(isempty(c))      c = zeros((Bp-Ap),Ann+Anz);
-      elseif(columns(c) != Ann+Anz | rows(c) != (Bp-Ap))
+    ## default c matrix
+    if(isempty(c))      c = zeros((Bp-Ap),Ann+Anz);
+    elseif(columns(c) != Ann+Anz | rows(c) != (Bp-Ap))
 	  error(sprintf("c(%dx%d); should be (%dx%d)", rows(c), columns(c), ...
 	    (Bp-Ap), (Ann+Anz) ));
-      endif
-
-      ## append new c matrix
-      Ac = [Ac;c];
     endif
 
-    ## check d matrix
-    if(isempty(d)) d = zeros(Bp,Bm);
-    elseif(rows(d) != Bp | columns(d) != Bm)
-      error(sprintf("d(%dx%d) should be (%dx%d)",rows(d), columns(d), Bp, Bp));
-    endif
+    ## append new c matrix
+    Ac = [Ac;c];
+  endif
 
-    ## Splice in original D matrix
-    if(Am & Ap)          d(1:Ap, 1:Am) = Ad;       endif
-    Ad = d;
+  ## check d matrix
+  if(isempty(d)) d = zeros(Bp,Bm);
+  elseif(rows(d) != Bp | columns(d) != Bm)
+    error(sprintf("d(%dx%d) should be (%dx%d)",rows(d), columns(d), Bp, Bp));
+  endif
 
-    ## construct return system
-    retsys = ss(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
+  ## Splice in original D matrix
+  if(Am & Ap)          d(1:Ap, 1:Am) = Ad;       endif
+  Ad = d;
 
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  ## construct return system
+  retsys = ss(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
 
 endfunction
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -40,56 +40,48 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function [csys, Acd, Ccd] = syscont (sys)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  if (nargin != 1)
+    usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
+  elseif (!isstruct(sys))
+    error("sys must be in system data structure form");
+  endif
 
-    if (nargin != 1)
-      usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
-    elseif (!isstruct(sys))
-      error("sys must be in system data structure form");
-    endif
+  sys = sysupdate (sys, "ss");
+  [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
-    sys = sysupdate (sys, "ss");
-    [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
-
-    ## assume there's nothing there; build partitions as appropriate
-    Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
+  ## assume there's nothing there; build partitions as appropriate
+  Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
 
-    if(isempty(st_c) & isempty(y_c))
-      error("syscont: expecting continous states and/or continous outputs");
-    elseif (isempty(st_c))
-      warning("syscont: no continuous states");
-    elseif(isempty(y_c))
-      warning("syscont: no continuous outputs");
-    endif
+  if(isempty(st_c) & isempty(y_c))
+    error("syscont: expecting continous states and/or continous outputs");
+  elseif (isempty(st_c))
+    warning("syscont: no continuous states");
+  elseif(isempty(y_c))
+    warning("syscont: no continuous outputs");
+  endif
 
-    [sys_a, sys_b, sys_c, sys_d ] = sys2ss(sys);
-    [sys_stname, sys_inname, sys_outname] = sysgetsignals(sys);
-    [sys_n, sys_nz, sys_m, sys_p] = sysdimensions(sys);
-    if(!isempty(st_c))
-      Acc = sys_a(st_c,st_c);
-      stname = sys_stname(st_c);
-      Bcc = sys_b(st_c,:);
-      Ccc = sys_c(y_c,st_c);
-      Acd = sys_a(st_c,st_d);
-    else
-      stname=[];
-    endif
-    outname = sys_outname(y_c);
-    Dcc = sys_d(y_c,:);
-    Ccd = sys_c(y_c,st_d);
-    inname = sys_inname;
+  [sys_a, sys_b, sys_c, sys_d ] = sys2ss(sys);
+  [sys_stname, sys_inname, sys_outname] = sysgetsignals(sys);
+  [sys_n, sys_nz, sys_m, sys_p] = sysdimensions(sys);
+  if(!isempty(st_c))
+    Acc = sys_a(st_c,st_c);
+    stname = sys_stname(st_c);
+    Bcc = sys_b(st_c,:);
+    Ccc = sys_c(y_c,st_c);
+    Acd = sys_a(st_c,st_d);
+  else
+    stname=[];
+  endif
+  outname = sys_outname(y_c);
+  Dcc = sys_d(y_c,:);
+  Ccd = sys_c(y_c,st_d);
+  inname = sys_inname;
 
-    csys = ss(Acc,Bcc,Ccc,Dcc,0,sys_n,0,stname,inname,outname);
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  csys = ss(Acc,Bcc,Ccc,Dcc,0,sys_n,0,stname,inname,outname);
 
 endfunction
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -35,71 +35,63 @@
 ## @itemx   cdc
 ## Connections from continuous states to discrete states and discrete.
 ## outputs, respectively.
 ## @end table
 ## @end deftypefn
 
 function [dsys, Adc, Cdc] = sysdisc (sys)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  if (nargin != 1)
+    usage("[dsys,Adc,Cdc] = sysdisc(sys)");
+  elseif (!isstruct(sys))
+    error("sys must be in system data structure form");
+  endif
 
-    if (nargin != 1)
-      usage("[dsys,Adc,Cdc] = sysdisc(sys)");
-    elseif (!isstruct(sys))
-      error("sys must be in system data structure form");
-    endif
+  sys = sysupdate (sys, "ss");
+  [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
-    sys = sysupdate (sys, "ss");
-    [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
-
-    ## assume there's nothing there; build partitions as appropriate
-    Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
+  ## assume there's nothing there; build partitions as appropriate
+  Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
 
-    if(isempty(st_d) & isempty(y_d))
-      error("sysdisc: expecting discrete states and/or continous outputs");
-    elseif (isempty(st_d))
-      warning("sysdisc: no discrete states");
-    elseif(isempty(y_d))
-      warning("sysdisc: no discrete outputs");
-    endif
+  if(isempty(st_d) & isempty(y_d))
+    error("sysdisc: expecting discrete states and/or continous outputs");
+  elseif (isempty(st_d))
+    warning("sysdisc: no discrete states");
+  elseif(isempty(y_d))
+    warning("sysdisc: no discrete outputs");
+  endif
 
-    [aa,bb,cc,dd] = sys2ss(sys);
-    if(!isempty(st_d) )
-      Add = aa( st_d , st_d);
-      stname = sysgetsignals(sys,"st",st_d);
-      Bdd = bb( st_d , :);
-      if(!isempty(st_c))
+  [aa,bb,cc,dd] = sys2ss(sys);
+  if(!isempty(st_d) )
+    Add = aa( st_d , st_d);
+    stname = sysgetsignals(sys,"st",st_d);
+    Bdd = bb( st_d , :);
+    if(!isempty(st_c))
 	Adc = aa( st_d , st_c);
-      endif
-      if(!isempty(y_d))
-	Cdd = cc(y_d , st_d);
-      endif
-    else
-      stname = [];
     endif
     if(!isempty(y_d))
-      Ddd = dd(y_d , :);
-      outname = sysgetsignals(sys,"out",y_d);
-      if(!isempty(st_c))
+	Cdd = cc(y_d , st_d);
+    endif
+  else
+    stname = [];
+  endif
+  if(!isempty(y_d))
+    Ddd = dd(y_d , :);
+    outname = sysgetsignals(sys,"out",y_d);
+    if(!isempty(st_c))
 	Cdc = cc(y_d , st_c);
-      endif
-    else
-      outname=[];
     endif
-    inname = sysgetsignals(sys,"in");
-    outlist = 1:rows(outname);
+  else
+    outname=[];
+  endif
+  inname = sysgetsignals(sys,"in");
+  outlist = 1:rows(outname);
 
-    if(!isempty(outname))
-      tsam = sysgettsam(sys);
-      [nc,nz] = sysdimensions(sys);
-      dsys = ss(Add,Bdd,Cdd,Ddd,tsam,0,nz,stname,inname,outname,outlist);
-    else
-      dsys=[];
-    endif
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  if(!isempty(outname))
+    tsam = sysgettsam(sys);
+    [nc,nz] = sysdimensions(sys);
+    dsys = ss(Add,Bdd,Cdd,Ddd,tsam,0,nz,stname,inname,outname,outlist);
+  else
+    dsys=[];
+  endif
 
 endfunction
diff --git a/scripts/control/system/sysgroup.m b/scripts/control/system/sysgroup.m
--- a/scripts/control/system/sysgroup.m
+++ b/scripts/control/system/sysgroup.m
@@ -54,150 +54,142 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 ## A. S. Hodel: modified for variable number of arguments 1999
 
 function sys = sysgroup (varargin)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
-
-    if(nargin < 1)
-      usage("sys = sysgroup(Asys{,Bsys,...})");
-    endif
+  if(nargin < 1)
+    usage("sys = sysgroup(Asys{,Bsys,...})");
+  endif
 
-    ## collect all arguments
-    arglist = {};
-    for kk=1:nargin
-      arglist(kk) = varargin{kk};
-      if(!isstruct(arglist{kk}))
+  ## collect all arguments
+  arglist = {};
+  for kk=1:nargin
+    arglist(kk) = varargin{kk};
+    if(!isstruct(arglist{kk}))
 	error("sysgroup: argument %d is not a data structure",kk);
-      endif
-    endfor
+    endif
+  endfor
 
-    if(nargin == 2)
-      ## the usual case; group the two systems together
-      Asys = arglist{1};
-      Bsys = arglist{2};
+  if(nargin == 2)
+    ## the usual case; group the two systems together
+    Asys = arglist{1};
+    Bsys = arglist{2};
 
-      ## extract information from Asys, Bsys to consruct sys
-      Asys = sysupdate(Asys,"ss");
-      Bsys = sysupdate(Bsys,"ss");
-      [n1,nz1,m1,p1] = sysdimensions(Asys);
-      [n2,nz2,m2,p2] = sysdimensions(Bsys);
-      [Aa,Ab,Ac,Ad,Atsam,An,Anz,Ast,Ain,Aout,Ayd] = sys2ss(Asys);
-      [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bst,Bin,Bout,Byd] = sys2ss(Bsys);
-      nA = An + Anz;
-      nB = Bn + Bnz;
+    ## extract information from Asys, Bsys to consruct sys
+    Asys = sysupdate(Asys,"ss");
+    Bsys = sysupdate(Bsys,"ss");
+    [n1,nz1,m1,p1] = sysdimensions(Asys);
+    [n2,nz2,m2,p2] = sysdimensions(Bsys);
+    [Aa,Ab,Ac,Ad,Atsam,An,Anz,Ast,Ain,Aout,Ayd] = sys2ss(Asys);
+    [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bst,Bin,Bout,Byd] = sys2ss(Bsys);
+    nA = An + Anz;
+    nB = Bn + Bnz;
 
-      if(p1*m1*p2*m2 == 0)
+    if(p1*m1*p2*m2 == 0)
 	error("sysgroup: argument lacks inputs and/or outputs");
 
-      elseif((Atsam + Btsam > 0) & (Atsam * Btsam == 0) )
+    elseif((Atsam + Btsam > 0) & (Atsam * Btsam == 0) )
 	warning("sysgroup: creating combination of continuous and discrete systems")
 
-      elseif(Atsam != Btsam)
+    elseif(Atsam != Btsam)
 	error("sysgroup: Asys.tsam=%e, Bsys.tsam =%e", Atsam, Btsam);
-      endif
+    endif
+
+    if(nA*nB > 0)
+      A12 = zeros(nA,nB);
+    else
+      A12 = [];
+    endif
+    A = [Aa,A12; A12', Ba];
+
+    if(nA*m2 > 0)
+      B12 = zeros(nA,m2);
+    else
+      B12 = [];
+    endif
+    if(nB*m1 > 0)
+      B21 = zeros(nB,m1);
+    else
+      B21 = [];
+    endif
+    if(isempty(Ab))
+      Ab = [];
+    endif
+    if(isempty(Bb))
+      Bb = [];
+    endif
+    B = [Ab, B12; B21, Bb];
+
+    if(p1*nB > 0)
+      C12 = zeros(p1,nB);
+    else
+      C12 = [];
+    endif
+    if(p2*nA > 0)
+      C21 = zeros(p2,nA);
+    else
+      C21 = [];
+    endif
+    C = [Ac, C12; C21,Bc];
 
-      if(nA*nB > 0)
-        A12 = zeros(nA,nB);
-      else
-        A12 = [];
-      endif
-      A = [Aa,A12; A12', Ba];
- 
-      if(nA*m2 > 0)
-        B12 = zeros(nA,m2);
-      else
-        B12 = [];
-      endif
-      if(nB*m1 > 0)
-        B21 = zeros(nB,m1);
-      else
-        B21 = [];
-      endif
-      if(isempty(Ab))
-        Ab = [];
-      endif
-      if(isempty(Bb))
-        Bb = [];
-      endif
-      B = [Ab, B12; B21, Bb];
- 
-      if(p1*nB > 0)
-        C12 = zeros(p1,nB);
-      else
-        C12 = [];
-      endif
-      if(p2*nA > 0)
-        C21 = zeros(p2,nA);
-      else
-        C21 = [];
-      endif
-      C = [Ac, C12; C21,Bc];
- 
-      if(p1*m2 > 0)
-        D12 = zeros(p1,m2);
-      else
-        D12 = [];
-      endif
-      if(p2*m1 > 0)
-        D21 = zeros(p2,m1);
-      else
-        D21 = [];
-      endif
-      D = [Ad, D12; D21, Bd];
-      tsam = max(Atsam,Btsam);
+    if(p1*m2 > 0)
+      D12 = zeros(p1,m2);
+    else
+      D12 = [];
+    endif
+    if(p2*m1 > 0)
+      D21 = zeros(p2,m1);
+    else
+      D21 = [];
+    endif
+    D = [Ad, D12; D21, Bd];
+    tsam = max(Atsam,Btsam);
+
+    ## construct combined signal names; stnames must check for pure gain blocks
+    if(isempty(Ast))
+	stname = Bst;
+    elseif(isempty(Bst))
+	stname = Ast;
+    else
+      stname= __sysconcat__(Ast,Bst);
+    endif
+    inname = __sysconcat__(Ain,Bin);
+    outname = __sysconcat__(Aout,Bout);
 
-      ## construct combined signal names; stnames must check for pure gain blocks
-      if(isempty(Ast))
-	stname = Bst;
-      elseif(isempty(Bst))
-	stname = Ast;
-      else
-        stname= __sysconcat__(Ast,Bst);
-      endif
-      inname = __sysconcat__(Ain,Bin);
-      outname = __sysconcat__(Aout,Bout);
-
-      ## Sort states into continous first, then discrete
-      dstates = ones(1,(nA+nB));
-      if(An)
+    ## Sort states into continous first, then discrete
+    dstates = ones(1,(nA+nB));
+    if(An)
 	dstates(1:(An)) = zeros(1,An);
-      endif
-      if(Bn)
+    endif
+    if(Bn)
 	dstates((nA+1):(nA+Bn)) = zeros(1,Bn);
-      endif
-      [tmp,pv] = sort(dstates);
-      A = A(pv,pv);
-      B = B(pv,:);
-      C = C(:,pv);
-      stname = stname(pv);
+    endif
+    [tmp,pv] = sort(dstates);
+    A = A(pv,pv);
+    B = B(pv,:);
+    C = C(:,pv);
+    stname = stname(pv);
 
-      ## check for duplicate signal names
-      inname = __sysgroupn__ (inname, "input");
-      stname = __sysgroupn__ (stname, "state");
-      outname = __sysgroupn__ (outname, "output");
+    ## check for duplicate signal names
+    inname = __sysgroupn__ (inname, "input");
+    stname = __sysgroupn__ (stname, "state");
+    outname = __sysgroupn__ (outname, "output");
 
-      ## mark discrete outputs
-      outlist = find([Ayd, Byd]);
+    ## mark discrete outputs
+    outlist = find([Ayd, Byd]);
 
-      ## build new system
-      sys = ss(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
+    ## build new system
+    sys = ss(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
 
-    else
-      ## multiple systems (or a single system); combine together one by one
-      sys = arglist{1};
-      for kk=2:length(arglist)
+  else
+    ## multiple systems (or a single system); combine together one by one
+    sys = arglist{1};
+    for kk=2:length(arglist)
 	printf("sysgroup: kk=%d\n",kk);
 	sys = sysgroup(sys,arglist{kk});
-      endfor
-    endif
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+    endfor
+  endif
 
 endfunction
diff --git a/scripts/control/system/tfout.m b/scripts/control/system/tfout.m
--- a/scripts/control/system/tfout.m
+++ b/scripts/control/system/tfout.m
@@ -26,42 +26,35 @@
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, polyinteg, and polyout}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function tfout (num, denom, x)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  if (nargin < 2 ) | (nargin > 3) | (nargout != 0 )
+    usage("tfout(num,denom[,x])");
+  endif
 
-    if (nargin < 2 ) | (nargin > 3) | (nargout != 0 )
-      usage("tfout(num,denom[,x])");
-    endif
-
-    if ( (!isvector(num)) | (!isvector(denom)) )
-      error("tfout: first two argument must be vectors");
-    endif
+  if ( (!isvector(num)) | (!isvector(denom)) )
+    error("tfout: first two argument must be vectors");
+  endif
 
-    if (nargin == 2)
-      x = "s";
-    elseif( ! ischar(x) )
-      error("tfout: third argument must be a string");
-    endif
+  if (nargin == 2)
+    x = "s";
+  elseif( ! ischar(x) )
+    error("tfout: third argument must be a string");
+  endif
 
-    numstring = polyout(num,x);
-    denomstring = polyout(denom,x);
-    len = max(length(numstring),length(denomstring));
-    if(len > 0)
-      y = strrep(blanks(len)," ","-");
-      disp(numstring)
-      disp(y)
-      disp(denomstring)
-    else
-      error ("tfout: empty transfer function")
-    end
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  numstring = polyout(num,x);
+  denomstring = polyout(denom,x);
+  len = max(length(numstring),length(denomstring));
+  if(len > 0)
+    y = strrep(blanks(len)," ","-");
+    disp(numstring)
+    disp(y)
+    disp(denomstring)
+  else
+    error ("tfout: empty transfer function")
+  end
 
 endfunction
diff --git a/scripts/control/system/zpout.m b/scripts/control/system/zpout.m
--- a/scripts/control/system/zpout.m
+++ b/scripts/control/system/zpout.m
@@ -26,87 +26,79 @@
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, polyinteg, and polyout}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function zpout (zer, pol, k, x)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
+    usage("zpout(zer,pol,k[,x])");
+  endif
 
-    if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
-      usage("zpout(zer,pol,k[,x])");
-    endif
+  if( !(isvector(zer) | isempty(zer)) | !(isvector(pol) | isempty(pol)) )
+    error("zer, pol must be vectors or empty");
+  endif
 
-    if( !(isvector(zer) | isempty(zer)) | !(isvector(pol) | isempty(pol)) )
-      error("zer, pol must be vectors or empty");
-    endif
+  if(!isscalar(k))
+    error("zpout: argument k must be a scalar.")
+  endif
 
-    if(!isscalar(k))
-      error("zpout: argument k must be a scalar.")
-    endif
+  if (nargin == 3)
+    x = "s";
+  elseif( ! ischar(x) )
+    error("zpout: third argument must be a string");
+  endif
 
-    if (nargin == 3)
-      x = "s";
-    elseif( ! ischar(x) )
-      error("zpout: third argument must be a string");
-    endif
+  numstring = num2str(k);
 
-    numstring = num2str(k);
-
-    if(length(zer))
-      ## find roots at z,s = 0
-      nzr = sum(zer == 0);
-      if(nzr)
+  if(length(zer))
+    ## find roots at z,s = 0
+    nzr = sum(zer == 0);
+    if(nzr)
 	if(nzr > 1)
 	  numstring = [numstring,sprintf(" %s^%d",x,nzr)];
 	else
 	  numstring = [numstring,sprintf(" %s",x)];
 	endif
-      endif
-      zer = sortcom(-zer);
-      for ii=1:length(zer)
+    endif
+    zer = sortcom(-zer);
+    for ii=1:length(zer)
 	if(zer(ii) != 0)
 	  numstring = [numstring,sprintf(" (%s %s)",x,com2str(zer(ii),1) ) ];
 	endif
-      endfor
-    endif
+    endfor
+  endif
 
-    if(length(pol))
-      ## find roots at z,s = 0
-      nzr = sum(pol == 0);
-      if(nzr)
+  if(length(pol))
+    ## find roots at z,s = 0
+    nzr = sum(pol == 0);
+    if(nzr)
 	if(nzr > 1)
 	  denomstring = [sprintf("%s^%d",x,nzr)];
 	else
 	  denomstring = [sprintf("%s",x)];
 	endif
-      else
+    else
 	denomstring = " ";
-      endif
-      pol = sortcom(-pol);
-      for ii=1:length(pol)
+    endif
+    pol = sortcom(-pol);
+    for ii=1:length(pol)
 	if(pol(ii) != 0)
 	  denomstring = [denomstring,sprintf(" (%s %s)",x,com2str(pol(ii),1))];
 	endif
-      endfor
-    endif
+    endfor
+  endif
 
-    len = max(length(numstring),length(denomstring));
-    if(len > 0)
-      y = strrep(blanks(len)," ","-");
-      disp(numstring)
-      if(length(denomstring))
+  len = max(length(numstring),length(denomstring));
+  if(len > 0)
+    y = strrep(blanks(len)," ","-");
+    disp(numstring)
+    if(length(denomstring))
 	disp(y)
 	disp(denomstring)
-      endif
-    else
-      error ("zpout: empty transfer function")
-    end
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+    endif
+  else
+    error ("zpout: empty transfer function")
+  end
 
 endfunction
diff --git a/scripts/control/util/__outlist__.m b/scripts/control/util/__outlist__.m
--- a/scripts/control/util/__outlist__.m
+++ b/scripts/control/util/__outlist__.m
@@ -42,46 +42,38 @@
 ## prints the list to the screen, numbering each string in order.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: December 1995
 
 function str_val = __outlist__ (name_list, tabchar, yd, ilist)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
-
-    if( nargin < 1 | nargin > 4 )
-      usage("str_val = outlist(x[,tabchar,yd,ilist])");
-    endif
+  if( nargin < 1 | nargin > 4 )
+    usage("str_val = outlist(x[,tabchar,yd,ilist])");
+  endif
 
-    m = length(name_list);
-    if(nargin < 4)
-      ilist = 1:m;
-    endif
-    if(nargin ==1)
-      tabchar = "";
-    endif
+  m = length(name_list);
+  if(nargin < 4)
+    ilist = 1:m;
+  endif
+  if(nargin ==1)
+    tabchar = "";
+  endif
 
-    if(nargin < 3)
-      yd = zeros(1,m);
-    elseif(isempty(yd))
-      yd = zeros(1,m);
-    endif
+  if(nargin < 3)
+    yd = zeros(1,m);
+  elseif(isempty(yd))
+    yd = zeros(1,m);
+  endif
 
-    str_val = "";
-    dstr = {""," (discrete)"};
-    if((m >= 1) && (iscell(name_list)))
-      for ii=1:m
+  str_val = "";
+  dstr = {""," (discrete)"};
+  if((m >= 1) && (iscell(name_list)))
+    for ii=1:m
 	str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ilist(ii), ...
 			  name_list{ii},dstr{yd(ii)+1});
-      endfor
-    else
-      str_val = sprintf("%sNone",tabchar);
-    endif
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+    endfor
+  else
+    str_val = sprintf("%sNone",tabchar);
+  endif
 
 endfunction
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -46,46 +46,39 @@ function y = shift (x, b, dim)
   sz = size (x);
 
   if (nargin == 3)
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
 	dim < (nd + 1))
       error ("shift: dim must be an integer and valid dimension");
     endif
   else
-    %% Find the first non-singleton dimension
+    ## Find the first non-singleton dimension
     dim  = 1;
     while (dim < nd + 1 && sz (dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   endif
 
   if (numel (x) < 1)
     error ("shift: x must not be empty");
   endif
 
   d = sz (dim);
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
+  idx = cell ();
+  for i = 1:nd
+    idx {i} = 1:sz(i);
+  endfor
+  if (b >= 0)
+    b = rem (b, d);
+    idx {dim} = [d-b+1:d, 1:d-b];
+  elseif (b < 0)
+    b = rem (abs (b), d);
+    idx {dim} = [b+1:d, 1:b];
+  endif
+  y = x (idx {:});
 
-    idx = cell ();
-    for i = 1:nd
-      idx {i} = 1:sz(i);
-    endfor
-    if (b >= 0)
-      b = rem (b, d);
-      idx {dim} = [d-b+1:d, 1:d-b];
-    elseif (b < 0)
-      b = rem (abs (b), d);
-      idx {dim} = [b+1:d, 1:b];
-    endif
-    y = x (idx {:});
-
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
 
 endfunction
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -37,51 +37,43 @@
 ## is returned.  If @var{n} is omitted, @var{n} = 100 is used. 
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Simulate an ARMA process
 
 function x = arma_rnd (a, b, v, t, n)
 
-  save_warn_empty_list_elements = warn_empty_list_elements;
-  unwind_protect
-    warn_empty_list_elements = 0;
-
-    if (nargin == 4)
-      n = 100;
-    elseif (nargin == 5)
-      if (!isscalar (t))
-        error ("arma_rnd: n must be a scalar");
-      endif
-    else
-      usage ("arma_rnd (a, b, v, t, n)");
-    endif
-
-    if ((min (size (a)) > 1) || (min (size (b)) > 1))
-      error ("arma_rnd: a and b must not be matrices");
-    endif
-
+  if (nargin == 4)
+    n = 100;
+  elseif (nargin == 5)
     if (!isscalar (t))
-      error ("arma_rnd: t must be a scalar");
+      error ("arma_rnd: n must be a scalar");
     endif
-
-    ar = length (a);
-    br = length (b);
+  else
+    usage ("arma_rnd (a, b, v, t, n)");
+  endif
 
-    a = reshape (a, ar, 1);
-    b = reshape (b, br, 1);
+  if ((min (size (a)) > 1) || (min (size (b)) > 1))
+    error ("arma_rnd: a and b must not be matrices");
+  endif
 
-    a = [1; -a];                        # apply our notational convention
-    b = [1; b];
+  if (!isscalar (t))
+    error ("arma_rnd: t must be a scalar");
+  endif
 
-    n = min (n, ar + br);
+  ar = length (a);
+  br = length (b);
 
-    e = sqrt (v) * randn (t + n, 1);
+  a = reshape (a, ar, 1);
+  b = reshape (b, br, 1);
 
-    x = filter (b, a, e);
-    x = x(n + 1 : t + n);
+  a = [1; -a];                        # apply our notational convention
+  b = [1; b];
+
+  n = min (n, ar + br);
 
-  unwind_protect_cleanup
-    warn_empty_list_elements = save_warn_empty_list_elements;
-  end_unwind_protect
+  e = sqrt (v) * randn (t + n, 1);
+
+  x = filter (b, a, e);
+  x = x(n + 1 : t + n);
 
 endfunction
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -46,48 +46,40 @@
 ##       0  2  7 12
 ##       0  0  3  8
 ##       0  0  0  4
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
 
-function [A, c] = spdiags(v,c,m,n)
+function [A, c] = spdiags (v, c, m, n)
 
-  wfi = warn_fortran_indexing;
-  unwind_protect
-    warn_fortran_indexing = 0;
-    
-    if nargin == 1 || nargin == 2
+    if (nargin == 1 || nargin == 2)
       ## extract nonzero diagonals of v into A,c
-      [i,j,v,nr,nc] = spfind(v);
-      if nargin == 1
+      [i, j, v, nr, nc] = spfind (v);
+      if (nargin == 1)
         c = unique(j-i);  # c contains the active diagonals
       endif
       ## FIXME: we can do this without a loop if we are clever
-      offset = max(min(c,nc-nr),0);
-      A = zeros(min(nr,nc),length(c));
-      for k=1:length(c)
-	idx = find(j-i == c(k));
+      offset = max (min (c, nc-nr), 0);
+      A = zeros (min (nr, nc), length (c));
+      for k = 1:length(c)
+	idx = find (j-i == c(k));
 	A(j(idx)-offset(k),k) = v(idx);
       end
-    elseif nargin == 3
+    elseif (nargin == 3)
       ## Replace specific diagonals c of m with v,c
-      [nr,nc] = size(m);
-      B = spdiags(m,c);
-      A = m - spdiags(B,c,nr,nc) + spdiags(v,c,nr,nc);
+      [nr,nc] = size (m);
+      B = spdiags (m, c);
+      A = m - spdiags (B, c, nr, nc) + spdiags (v, c, nr, nc);
     else
       ## Create new matrix of size mxn using v,c
-      [j,i,v] = find(v);
-      offset = max(min(c(:),n-m),0);
-      j+=offset(i);
-      i=j-c(:)(i);
+      [j, i, v] = find (v);
+      offset = max (min (c(:), n-m), 0);
+      j += offset(i);
+      i = j-c(:)(i);
       idx = i>0 & i<=m & j>0 & j<=n;
-      A = sparse(i(idx),j(idx),v(idx),m,n);
+      A = sparse (i(idx), j(idx), v(idx), m, n);
       
     endif
-    
-  unwind_protect_cleanup
-    warn_fortran_indexing = wfi;
-  end_unwind_protect
 
 endfunction
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -70,17 +70,17 @@ function m = moment (x, p, opt1, opt2)
       dim = opt2;
     elseif (ischar (opt2))
       opt = opt2;
       dim = opt1;
     else
       usage ("moment: expecting opt to be a string");
     endif
   else
-    usage ("moment (x, p, dim, opt) or moment (x, p, dim, opt)");
+    usage ("moment (x, p, dim, opt)");
   endif
 
   if (need_dim)
     t = find (size (x) != 1);
     if (isempty (t))
       dim = 1;
     else
       dim = t(1);
@@ -89,26 +89,20 @@ function m = moment (x, p, opt1, opt2)
 
   sz = size (x);
   n = sz (dim);
 
   if (numel (x) < 1)
     error ("moment: x must not be empty");
   endif
 
-  tmp = warn_str_to_num;
-  unwind_protect
-    warn_str_to_num = 0;
-    if any (opt == "c")
-      rng = ones(1, length (sz));
-      rng (dim) = sz (dim);
-      x = x - repmat (sum (x, dim), rng) / n;
-    endif
-    if any (opt == "a")
-      x = abs (x);
-    endif
-  unwind_protect_cleanup
-    warn_str_to_num = tmp;
-  end_unwind_protect
+  if any (opt == "c")
+    rng = ones (1, length (sz));
+    rng(dim) = sz(dim);
+    x = x - repmat (sum (x, dim), rng) / n;
+  endif
+  if any (opt == "a")
+    x = abs (x);
+  endif
 
-  m = sum(x .^ p, dim) / n;
+  m = sum (x .^ p, dim) / n;
 
 endfunction
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -31,36 +31,30 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: jwe
 
 function st = strcat (s, varargin)
 
   if (nargin > 0)
-    save_warn_empty_list_elements = warn_empty_list_elements;
-    unwind_protect
-      warn_empty_list_elements = 0;
-      if (ischar (s))
-        tmpst = s;
+    if (ischar (s))
+      tmpst = s;
+    else
+      error ("strcat: all arguments must be strings");
+    endif
+    n = nargin - 1;
+    k = 1;
+    while (n--)
+      tmp = varargin{k++};
+      if (ischar (tmp))
+	tmpst = [tmpst, tmp];
       else
-        error ("strcat: all arguments must be strings");
+	error ("strcat: all arguments must be strings");
       endif
-      n = nargin - 1;
-      k = 1;
-      while (n--)
-        tmp = varargin{k++};
-        if (ischar (tmp))
-          tmpst = [tmpst, tmp];
-        else
-          error ("strcat: all arguments must be strings");
-        endif
-      endwhile
-    unwind_protect_cleanup
-      warn_empty_list_elements = save_warn_empty_list_elements;
-    end_unwind_protect
+    endwhile
   else
     usage ("strcat (s, t, ...)");
   endif
 
   st = tmpst;
 
 endfunction
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -32,43 +32,35 @@ function x = strjust (x, just)
   endif
 
   if (nargin == 1)
     just = "right";
   endif
 
   just = tolower (just);
 
-  wfi = warn_fortran_indexing;
-  unwind_protect
-    warn_fortran_indexing = 0;
-
-    ## convert nulls to blanks
-    idx = find (toascii (x) == 0);
-    if (! isempty (idx))
-      x(idx) = " ";
-    endif
+  ## convert nulls to blanks
+  idx = find (toascii (x) == 0);
+  if (! isempty (idx))
+    x(idx) = " ";
+  endif
 
-    ## For all cases, left, right and center, the algorithm is the same.
-    ## Find the number of blanks at the left/right end to determine the
-    ## shift, rotate the row index by using mod with that shift, then
-    ## translate the shifted row index into an array index.
-    [nr, nc] = size (x);
-    idx = (x' != " ");
-    if (strcmp (just, "right"))
-      [N, hi] = max (cumsum (idx));
-      shift = hi;
-    elseif (strcmp (just, "left"))
-      [N, lo] = max (cumsum (flipud (idx)));
-      shift = (nc - lo);
-    else
-      [N, hi] = max (cumsum (idx));
-      [N, lo] = max (cumsum (flipud (idx)));
-      shift = ceil (nc - (lo-hi)/2);
-    endif
-    idx = rem (ones(nr,1)*[0:nc-1] + shift'*ones(1,nc), nc);
-    x = x (idx*nr + [1:nr]'*ones(1,nc));
-
-  unwind_protect_cleanup
-    warn_fortran_indexing = wfi;
-  end_unwind_protect
+  ## For all cases, left, right and center, the algorithm is the same.
+  ## Find the number of blanks at the left/right end to determine the
+  ## shift, rotate the row index by using mod with that shift, then
+  ## translate the shifted row index into an array index.
+  [nr, nc] = size (x);
+  idx = (x' != " ");
+  if (strcmp (just, "right"))
+    [N, hi] = max (cumsum (idx));
+    shift = hi;
+  elseif (strcmp (just, "left"))
+    [N, lo] = max (cumsum (flipud (idx)));
+    shift = (nc - lo);
+  else
+    [N, hi] = max (cumsum (idx));
+    [N, lo] = max (cumsum (flipud (idx)));
+    shift = ceil (nc - (lo-hi)/2);
+  endif
+  idx = rem (ones(nr,1)*[0:nc-1] + shift'*ones(1,nc), nc);
+  x = x (idx*nr + [1:nr]'*ones(1,nc));
 
 endfunction
