# HG changeset patch
# User Rik <rik@octave.org>
# Date 1521825052 25200
#      Fri Mar 23 10:10:52 2018 -0700
# Branch stable
# Node ID d85b2485af9e51276a94340791be02d542e9dd3b
# Parent  8b50eab9689eda6d485dd90f8092e57956a32c0e
doc: grammarcheck m-files ahead of 4.4 release.

* repelem.m, isdefinite.m, ols.m, genvarname.m, inputParser.m, camorbit.m,
campos.m, camroll.m, camtarget.m, camup.m, camva.m, camzoom.m, camlight.m,
findobj.m, hgsave.m, ishandle.m, conv.m, bicg.m, bicgstab.m, cgs.m, gmres.m,
pcg.m, __alltohandles__.m, __default__input__.m, tfqmr.m, cov.m, kurtosis.m,
mean.m, meansq.m, median.m, moment.m, skewness.m, var.m, erase.m, isstring.m:
Use Octave conventions in documentation strings for m-files.

diff --git a/scripts/general/repelem.m b/scripts/general/repelem.m
--- a/scripts/general/repelem.m
+++ b/scripts/general/repelem.m
@@ -135,17 +135,17 @@
 ##       ans(:,:,2) =
 ##         -1  -1  -1   0   0   0
 ##         -1  -1  -1   0   0   0
 ##          0   0   0   1   1   1
 ##          0   0   0   1   1   1
 ## @end example
 ##
 ## @code{repelem} preserves the class of @var{x}, and works with strings,
-## cell arrays, NA, and NAN inputs.  If any @var{R_j} is  0 the output will
+## cell arrays, NA, and NAN inputs.  If any @var{R_j} is 0 the output will
 ## be an empty array.
 ##
 ## @example
 ## @group
 ## repelem ("Octave", 2, 3)
 ##   @result{}    OOOccctttaaavvveee
 ##         OOOccctttaaavvveee
 ##
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} isdefinite (@var{A})
 ## @deftypefnx {} {} isdefinite (@var{A}, @var{tol})
 ## Return 1 if @var{A} is symmetric positive definite within the
 ## tolerance specified by @var{tol} or 0 if @var{A} is symmetric
-## positive semidefinite.  Otherwise, return -1.
+## positive semi-definite.  Otherwise, return -1.
 ##
 ## If @var{tol} is omitted, use a tolerance of
 ## @code{100 * eps * norm (@var{A}, "fro")}
 ## @seealso{issymmetric, ishermitian}
 ## @end deftypefn
 
 ## Author: Gabriele Pannocchia <g.pannocchia@ing.unipi.it>
 ## Created: November 2003
diff --git a/scripts/linear-algebra/ols.m b/scripts/linear-algebra/ols.m
--- a/scripts/linear-algebra/ols.m
+++ b/scripts/linear-algebra/ols.m
@@ -66,18 +66,19 @@
 ## @table @var
 ## @item beta
 ## The OLS estimator for matrix @var{b}.
 ## @tex
 ## @var{beta} is calculated directly via $(@var{x}^T@var{x})^{-1} @var{x}^T
 ## @var{y}$ if the matrix $@var{x}^T@var{x}$ is of full rank.
 ## @end tex
 ## @ifnottex
-## @var{beta} is calculated directly via @code{inv (@var{x}'*@var{x}) * @var{x}' * @var{y}} if the
-## matrix @code{@var{x}'*@var{x}} is of full rank.
+## @var{beta} is calculated directly via
+## @code{inv (@var{x}'*@var{x}) * @var{x}' * @var{y}} if the matrix
+## @code{@var{x}'*@var{x}} is of full rank.
 ## @end ifnottex
 ## Otherwise, @code{@var{beta} = pinv (@var{x}) * @var{y}} where
 ## @code{pinv (@var{x})} denotes the pseudoinverse of @var{x}.
 ##
 ## @item sigma
 ## The OLS estimator for the matrix @var{s},
 ##
 ## @example
diff --git a/scripts/miscellaneous/genvarname.m b/scripts/miscellaneous/genvarname.m
--- a/scripts/miscellaneous/genvarname.m
+++ b/scripts/miscellaneous/genvarname.m
@@ -44,17 +44,17 @@
 ## x = 3.141;
 ## genvarname ("x", who ())
 ##   @result{} x1
 ## @end group
 ## @end example
 ##
 ## Note that the result is a char array or cell array of strings, not the
 ## variables themselves.  To define a variable, @code{eval()} can be used.
-## The following trivial example sets @code{x} to @code{42}.
+## The following trivial example sets @code{x} to 42.
 ##
 ## @example
 ## @group
 ## name = genvarname ("x");
 ## eval ([name " = 42"]);
 ##   @result{} x =  42
 ## @end group
 ## @end example
diff --git a/scripts/miscellaneous/inputParser.m b/scripts/miscellaneous/inputParser.m
--- a/scripts/miscellaneous/inputParser.m
+++ b/scripts/miscellaneous/inputParser.m
@@ -76,17 +76,16 @@
 ## @end deftypefn
 ## @deftypefn {} {} inputParser.StructExpand = @var{boolean}
 ## Set whether a structure can be passed to the function instead of
 ## parameter/value pairs.  Defaults to true.
 ##
 ## The following example shows how to use this class:
 ##
 ## @example
-## @group
 ## function check (varargin)
 ## @c The next two comments need to be indented by one for alignment
 ##   p = inputParser ();                      # create object
 ##   p.FunctionName = "check";                # set function name
 ##   p.addRequired ("pack", @@ischar);         # mandatory argument
 ##   p.addOptional ("path", pwd(), @@ischar);  # optional argument
 ##
 ##   ## create a function handle to anonymous functions for validators
@@ -102,17 +101,16 @@
 ##   ## create a switch type of argument
 ##   p.addSwitch ("verbose");
 ##
 ##   p.parse (varargin@{:@});  # Run created parser on inputs
 ##
 ##   ## the rest of the function can access inputs by using p.Results.
 ##   ## for example, get the tolerance input with p.Results.tolerance
 ## endfunction
-## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## check ("mech");           # valid, use defaults for other arguments
 ## check ();                 # error, one argument is mandatory
 ## check (1);                # error, since ! ischar
 ## check ("mech", "~/dev");  # valid, use defaults for other arguments
diff --git a/scripts/plot/appearance/camorbit.m b/scripts/plot/appearance/camorbit.m
--- a/scripts/plot/appearance/camorbit.m
+++ b/scripts/plot/appearance/camorbit.m
@@ -27,65 +27,69 @@
 ## @deftypefnx {} {} camorbit (@var{theta}, @var{phi}, "data", [@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {} camorbit (@var{theta}, @var{phi}, "camera")
 ## @deftypefnx {} {} camorbit (@var{hax}, @dots{})
 ## Rotate the camera up/down and left/right around its target.
 ##
 ## Move the camera @var{phi} degrees up and @var{theta} degrees to the right,
 ## as if it were in an orbit around its target.
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## sphere ()
 ## camorbit (30, 20)
 ## @end group
 ## @end example
 ##
 ## These rotations are centered around the camera target
 ## (@pxref{XREFcamtarget,,camtarget}).
 ## First the camera position is pitched up or down by rotating it @var{phi}
-## degrees around an axis orthogonal to both the viewing direction (specifically
-## @code{camtarget() - campos()}) and the camera ``up vector''
+## degrees around an axis orthogonal to both the viewing direction
+## (specifically @code{camtarget() - campos()}) and the camera ``up vector''
 ## (@pxref{XREFcamup,,camup}).
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camorbit (0, 20)
 ## @end group
 ## @end example
 ##
 ## The second rotation depends on the coordinate system @var{coorsys} and
 ## direction @var{dir} inputs.
-## The default for @var{coorsys} is @qcode{"data"}.  In this case, the camera is
-## yawed left or right by rotating it @var{theta} degrees around an axis
+## The default for @var{coorsys} is @qcode{"data"}.  In this case, the camera
+## is yawed left or right by rotating it @var{theta} degrees around an axis
 ## specified by @var{dir}.
 ## The default for @var{dir} is @qcode{"z"}, corresponding to the vector
 ## @code{[0, 0, 1]}.
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camorbit (30, 0)
 ## @end group
 ## @end example
 ##
-##
 ## When @var{coorsys} is set to @qcode{"camera"}, the camera is moved left or
 ## right by rotating it around an axis parallel to the camera up vector
 ## (@pxref{XREFcamup,,camup}).
 ## The input @var{dir} should not be specified in this case.
 ## Example:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camorbit (30, 0, "camera")
 ## @end group
 ## @end example
+##
 ## (Note: the rotation by @var{phi} is unaffected by @qcode{"camera"}.)
 ##
 ## The @code{camorbit} command modifies two camera properties:
 ## @pxref{XREFcampos,,campos} and @pxref{XREFcamup,,camup}.
 ##
 ## By default, this command affects the current axis; alternatively, an axis
 ## can be specified by the optional argument @var{hax}.
 ##
diff --git a/scripts/plot/appearance/campos.m b/scripts/plot/appearance/campos.m
--- a/scripts/plot/appearance/campos.m
+++ b/scripts/plot/appearance/campos.m
@@ -21,45 +21,49 @@
 ## @deftypefnx {} {} campos ([@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {@var{mode} =} campos ("mode")
 ## @deftypefnx {} {} campos (@var{mode})
 ## @deftypefnx {} {} campos (@var{ax}, @dots{})
 ## Set or get the camera position.
 ##
 ## The default camera position is determined automatically based on the scene.
 ## For example, to get the camera position:
+##
 ## @example
 ## @group
 ## hf = figure();
 ## peaks()
 ## p = campos ()
 ##   @result{} p =
 ##       -27.394  -35.701   64.079
 ## @end group
 ## @end example
 ##
 ## We can then move the camera further up the z-axis:
+##
 ## @example
 ## @group
 ## campos (p + [0 0 10])
 ## campos ()
 ##   @result{} ans =
 ##       -27.394  -35.701   74.079
 ## @end group
 ## @end example
 ##
 ## Having made that change, the camera position @var{mode} is now manual:
+##
 ## @example
 ## @group
 ## campos ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
 ##
 ## We can set it back to automatic:
+##
 ## @example
 ## @group
 ## campos ("auto")
 ## campos ()
 ##   @result{} ans =
 ##       -27.394  -35.701   64.079
 ## close (hf)
 ## @end group
diff --git a/scripts/plot/appearance/camroll.m b/scripts/plot/appearance/camroll.m
--- a/scripts/plot/appearance/camroll.m
+++ b/scripts/plot/appearance/camroll.m
@@ -20,33 +20,36 @@
 ## @deftypefn  {} {} camroll (@var{theta})
 ## @deftypefnx {} {} camroll (@var{ax}, @var{theta})
 ## Roll the camera.
 ##
 ## Roll the camera clockwise by @var{theta} degrees.
 ## For example, the following command will roll the camera by
 ## 30 degrees clockwise (to the right); this will cause the scene
 ## to appear to roll by 30 degrees to the left:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## peaks ()
 ## camroll (30)
 ## @end group
 ## @end example
 ##
 ## Roll the camera back:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camroll (-30)
 ## @end group
 ## @end example
 ##
 ## The following command restores the default camera roll:
+##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camup ("auto")
 ## @end group
 ## @end example
 ##
 ## By default, these commands affect the current axis; alternatively, an axis
diff --git a/scripts/plot/appearance/camtarget.m b/scripts/plot/appearance/camtarget.m
--- a/scripts/plot/appearance/camtarget.m
+++ b/scripts/plot/appearance/camtarget.m
@@ -19,56 +19,62 @@
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{T} =} camtarget ()
 ## @deftypefnx {} {} camtarget ([@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {@var{mode} =} camtarget ("mode")
 ## @deftypefnx {} {} camtarget (@var{mode})
 ## @deftypefnx {} {} camtarget (@var{ax}, @dots{})
 ## Set or get where the camera is pointed.
 ##
-## The camera target is a point in space where the camera is pointing.  Usually,
-## it is determined automatically based on the scene:
+## The camera target is a point in space where the camera is pointing.
+## Usually, it is determined automatically based on the scene:
+##
 ## @example
 ## @group
 ## hf = figure();
 ## sphere (36)
 ## v = camtarget ()
 ##   @result{} v =
 ##       0   0   0
 ## @end group
 ## @end example
 ##
 ## We can turn the camera to point at a new target:
+##
 ## @example
 ## @group
 ## camtarget ([1 1 1])
 ## camtarget ()
 ##   @result{}   1   1   1
 ## @end group
 ## @end example
 ##
 ## Having done so, the camera target @var{mode} is manual:
+##
 ## @example
 ## @group
 ## camtarget ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
+##
 ## This means, for example, adding new objects to the scene will not retarget
 ## the camera:
+##
 ## @example
 ## @group
 ## hold on;
 ## peaks ()
 ## camtarget ()
 ##   @result{}   1   1   1
 ## @end group
 ## @end example
 ##
 ## We can reset it to be automatic:
+##
 ## @example
 ## @group
 ## @c doctest: +XFAIL
 ## @c https://savannah.gnu.org/bugs/?44503
 ## camtarget ("auto")
 ## camtarget ()
 ##   @result{}   0   0   0.76426
 ## close (hf)
diff --git a/scripts/plot/appearance/camup.m b/scripts/plot/appearance/camup.m
--- a/scripts/plot/appearance/camup.m
+++ b/scripts/plot/appearance/camup.m
@@ -19,53 +19,60 @@
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{up} =} camup ()
 ## @deftypefnx {} {} camup ([@var{x} @var{y} @var{z}])
 ## @deftypefnx {} {@var{mode} =} camup ("mode")
 ## @deftypefnx {} {} camup (@var{mode})
 ## @deftypefnx {} {} camup (@var{ax}, @dots{})
 ## Set or get the camera up vector.
 ##
-## By default, the camera is oriented so that ``up'' corresponds to the positive
-## z-axis:
+## By default, the camera is oriented so that ``up'' corresponds to the
+## positive z-axis:
+##
 ## @example
 ## @group
 ## hf = figure ();
 ## sphere (36)
 ## v = camup ()
 ##   @result{} v =
 ##       0   0   1
 ## @end group
 ## @end example
 ##
 ## Specifying a new ``up vector'' rolls the camera and sets the mode to manual:
+##
 ## @example
 ## @group
 ## camup ([1 1 0])
 ## camup ()
 ##   @result{}   1   1   0
 ## camup ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
 ##
 ## Modifying the up vector does not modify the camera target
-## (@pxref{XREFcamtarget,,camtarget}). Thus, the camera up vector might not be
+## (@pxref{XREFcamtarget,,camtarget}).  Thus, the camera up vector might not be
 ## orthogonal to the direction of the camera's view:
+##
 ## @example
+## @group
 ## camup ([1 2 3])
 ## dot (camup (), camtarget () - campos ())
 ##   @result{} 6...
+## @end group
 ## @end example
+##
 ## A consequence is that ``pulling back'' on the up vector does not pitch the
 ## camera view (as that would require changing the target).  Setting the up
 ## vector is thus typically used only to roll the camera.  A more intuitive
 ## command for this purpose is @pxref{XREFcamroll,,camroll}.
 ##
 ## Finally, we can reset the up vector to automatic mode:
+##
 ## @example
 ## @group
 ## camup ("auto")
 ## camup ()
 ##   @result{}   0   0   1
 ## close (hf)
 ## @end group
 ## @end example
diff --git a/scripts/plot/appearance/camva.m b/scripts/plot/appearance/camva.m
--- a/scripts/plot/appearance/camva.m
+++ b/scripts/plot/appearance/camva.m
@@ -21,36 +21,39 @@
 ## @deftypefnx {} {} camva (@var{a})
 ## @deftypefnx {} {@var{mode} =} camva ("mode")
 ## @deftypefnx {} {} camva (@var{mode})
 ## @deftypefnx {} {} camva (@var{ax}, @dots{})
 ## Set or get the camera viewing angle.
 ##
 ## The camera has a viewing angle which determines how much can be seen.  By
 ## default this is:
+##
 ## @example
 ## @group
 ## hf = figure();
 ## sphere (36)
 ## a = camva ()
 ##   @result{} a =  10.340
 ## @end group
 ## @end example
 ##
-## To get a wider-angle view, we could double the viewing angle.  This will also
-## set the mode to manual:
+## To get a wider-angle view, we could double the viewing angle.  This will
+## also set the mode to manual:
+##
 ## @example
 ## @group
 ## camva (2*a)
 ## camva ("mode")
 ##   @result{} manual
 ## @end group
 ## @end example
 ##
 ## We can set it back to automatic:
+##
 ## @example
 ## @group
 ## camva ("auto")
 ## camva ("mode")
 ##   @result{} auto
 ## camva ()
 ##   @result{} ans =  10.340
 ## close (hf)
diff --git a/scripts/plot/appearance/camzoom.m b/scripts/plot/appearance/camzoom.m
--- a/scripts/plot/appearance/camzoom.m
+++ b/scripts/plot/appearance/camzoom.m
@@ -18,33 +18,37 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} camzoom (@var{zf})
 ## @deftypefnx {} {} camzoom (@var{ax}, @var{zf})
 ## Zoom the camera in or out.
 ##
 ## A value of @var{zf} larger than 1 ``zooms in'' such that the scene appears
 ## magnified:
+##
 ## @example
 ## @group
 ## hf = figure ();
 ## sphere (36)
 ## camzoom (1.2)
 ## @end group
 ## @end example
 ##
-## A value smaller than 1 ``zooms out'' so the camera can see more of the scene:
+## A value smaller than 1 ``zooms out'' so the camera can see more of the
+## scene:
+##
 ## @example
 ## @group
 ## camzoom (0.5)
 ## @end group
 ## @end example
 ##
 ## Technically speaking, zooming affects the ``viewing angle''.  The following
 ## command resets to the default zoom:
+##
 ## @example
 ## @group
 ## camva ("auto")
 ## close (hf)
 ## @end group
 ## @end example
 ##
 ## By default, these commands affect the current axis; alternatively, an axis
diff --git a/scripts/plot/draw/camlight.m b/scripts/plot/draw/camlight.m
--- a/scripts/plot/draw/camlight.m
+++ b/scripts/plot/draw/camlight.m
@@ -65,19 +65,19 @@
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## camlight (45, 30);
 ## @end group
 ## @end example
 ##
 ## Here the light is first pitched upwards (@pxref{XREFcamup,,camup}) from the
-## camera position (@pxref{XREFcampos,,campos}) by 30 degrees.  It is then yawed
-## by 45 degrees to the right.  Both rotations are centered around the camera
-## target (@pxref{XREFcamtarget,,camtarget}).
+## camera position (@pxref{XREFcampos,,campos}) by 30 degrees.  It is then
+## yawed by 45 degrees to the right.  Both rotations are centered around the
+## camera target (@pxref{XREFcamtarget,,camtarget}).
 ##
 ## Return a handle to further manipulate the light object
 ##
 ## @example
 ## @group
 ## @c doctest: +SKIP
 ## clf
 ## sphere (36);
diff --git a/scripts/plot/util/findobj.m b/scripts/plot/util/findobj.m
--- a/scripts/plot/util/findobj.m
+++ b/scripts/plot/util/findobj.m
@@ -55,19 +55,19 @@
 ## @end example
 ##
 ## Specifying a depth @var{d} of 0 limits the search to the set of objects
 ## passed in @var{hlist}.  A depth of 0 is also equivalent to the
 ## @qcode{"flat"} argument.  The default depth value is @code{Inf} which
 ## includes all descendants.
 ##
 ## A specified logical operator may be used between @var{prop_name},
-## @var{prop_value} pairs.  The supported logical operators are: @qcode{"-and"},
-## @qcode{"-or"}, @qcode{"-xor"}, @qcode{"-not"}.  Example code to locate all
-## figure and axes objects is
+## @var{prop_value} pairs.  The supported logical operators are:
+## @qcode{"-and"}, @qcode{"-or"}, @qcode{"-xor"}, @qcode{"-not"}.  Example code
+## to locate all figure and axes objects is
 ##
 ## @example
 ## findobj ("type", "figure", "-or", "type", "axes")
 ## @end example
 ##
 ## Objects may also be matched by comparing a regular expression to the
 ## property values, where property values that match
 ## @code{regexp (@var{prop_value}, @var{pattern})} are returned.
diff --git a/scripts/plot/util/hgsave.m b/scripts/plot/util/hgsave.m
--- a/scripts/plot/util/hgsave.m
+++ b/scripts/plot/util/hgsave.m
@@ -30,19 +30,19 @@
 ##
 ## If present, @var{fmt} should be one of the following:
 ##
 ## @itemize @bullet
 ## @item @option{-binary}, @option{-float-binary}
 ##
 ## @item @option{-hdf5}, @option{-float-hdf5}
 ##
-## @item @option{-V7}, @option{-v7}, @code{-7}, @option{-mat7-binary}
+## @item @option{-V7}, @option{-v7}, @option{-7}, @option{-mat7-binary}
 ##
-## @item @option{-V6}, @option{-v6}, @code{-6}, @option{-mat6-binary}
+## @item @option{-V6}, @option{-v6}, @option{-6}, @option{-mat6-binary}
 ##
 ## @item @option{-text}
 ##
 ## @item @option{-zip}, @option{-z}
 ## @end itemize
 ##
 ## When producing graphics for final publication use @code{print} or
 ## @code{saveas}.  When it is important to be able to continue to edit a
diff --git a/scripts/plot/util/ishandle.m b/scripts/plot/util/ishandle.m
--- a/scripts/plot/util/ishandle.m
+++ b/scripts/plot/util/ishandle.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {} ishandle (@var{h})
+## @deftypefn {} {} ishandle (@var{h})
 ## Return true if @var{h} is a handle to a graphics or Java object and false
 ## otherwise.
 ##
 ## @var{h} may also be a matrix of handles in which case a logical array is
 ## returned that is true where the elements of @var{h} are handles to graphics
 ## or Java objects and false where they are not.
 ##
 ## Programming Note: It is often more useful to test for a specific object
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -33,17 +33,18 @@
 ## The result is a vector with length equal to
 ## @code{length (@var{a}) + length (@var{b}) - 1}.
 ##
 ## @item @var{shape} = @qcode{"same"}
 ## Return the central part of the convolution with the same size as @var{a}.
 ##
 ## @item @var{shape} = @qcode{"valid"}
 ## Return only the parts which do not include zero-padded edges.
-## The size of the result is @code{max (size (@var{a}) - size (@var{b}) + 1, 0)}.
+## The size of the result is
+## @code{max (size (@var{a}) - size (@var{b}) + 1, 0)}.
 ## @end table
 ##
 ## @seealso{deconv, conv2, convn, fftconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -23,36 +23,36 @@
 ## @deftypefnx {} {@var{x} =} bicg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
 ## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the Bi-conjugate gradient iterative method.
 ##
 ## The input parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{A} it is a square matrix. @var{A} can be passed as a matrix or
+## @item @var{A} it is a square matrix.  @var{A} can be passed as a matrix or
 ## as a function handle or inline function
 ## @code{Afun} such that @code{Afun (x, "notransp") = A * x} and
 ## @code{Afun (x, "transp") = A' * x}.  Additional parameters to
 ## @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with same number of rows of @var{A}.
 ##
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
 ## @w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
 ## @w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
 ## @w{@code{@var{tol} * norm (@var{b})}}}.
 ## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
 ## set to [] the default value @code{min (20, numel (b))} is used.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The
+## @item @var{M1}, @var{M2} are the preconditioners.  The
 ## preconditioner @var{M} is given as @code{@var{M} = @var{M1} * @var{M2}}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a
 ## function handle or inline
 ## function @code{g} such that @code{g(@var{x}, "notransp") =
 ## @var{M1} \ @var{x}} or
 ## @code{g(@var{x}, "notransp") = @var{M2} \ @var{x}}
 ## and @code{g(@var{x}, "transp") = @var{M1}' \ @var{x}} or
 ## @code{g(@var{x}, "transp") = @var{M2}' \ @var{x}}.
@@ -72,17 +72,17 @@
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M}) which are passed
 ## to @code{bicg}.
 ##
 ## The output parameters are:
 ##
 ## @itemize
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -26,56 +26,56 @@
 ## method.
 ##
 ## The input parameters are:
 ##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with the same number of rows as @var{A}.
 ##
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
 ## @w{@code{@var{b} - @var{A} * @var{x}}}.  The iteration stops if
 ## @w{@code{norm (@var{b} - @var{A} * @var{x})} @leq{}
 ## @w{@code{@var{tol} * norm (@var{b})}}}.
 ## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
 ## set to [] the default value @code{min (20, numel (b))} is used.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
 ## @var{M} is given as @code{@var{M} = @var{M1} * @var{M2}}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that
 ## @code{g(@var{x}) = @var{M1} \ @var{x}} or
 ## @code {g(@var{x}) = @var{M2} \ @var{x}}.
-## The techinque used is the right preconditioning, i.e. it is
+## The techinque used is the right preconditioning, i.e., it is
 ## solved @code{@var{A} * inv (@var{M}) * @var{y} = @var{b}} and then
 ## @code{@var{x} = inv (@var{M}) * @var{y}}.
 ##
 ## @item @var{x0} the initial guess, if not given or set to [] the default
 ## value @code{zeros (size (@var{b}))} is used.
 ##
 ## @end itemize
 ##
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M}) which are passed
 ## to @code{bicstab}.
 ##
 ## The output parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
@@ -86,17 +86,17 @@
 ##
 ## @item 4: the algorithm can't continue due to a division by zero
 ## @end itemize
 ##
 ## @item @var{relres} is the relative residual obtained with as
 ## @code{(@var{A}*@var{x}-@var{b}) / @code{norm(@var{b})}}.
 ##
 ## @item @var{iter} is the (possibily half) iteration which @var{x} is
-## computed. If it is an half iteration then it is @code{@var{iter} + 0.5}
+## computed.  If it is an half iteration then it is @code{@var{iter} + 0.5}
 ##
 ## @item @var{resvec} is a vector containing the residual of each half and
 ## total iteration (There are also the half iterations since @var{x} is
 ## computed in two steps at each iteration).
 ## Doing @code{(length(@var{resvec}) - 1) / 2} is possible to see the
 ## total number of (total) iterations performed.
 ##
 ## @end itemize
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -26,49 +26,49 @@
 ## Conjugate Gradients Squared method.
 ##
 ## The input arguments are:
 ##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with same number of rows of @var{A}.
 ##
 ## @item @var{tol} is the relative tolerance, if not given or set to [] the
 ## default value 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
 ## set to [] the default value @code{min (20, numel (b))} is used.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
 ## matrix is given as @code{M = M1 * M2}.  Both @var{M1}
 ## and @var{M2} can be passed as a matrix or as a function handle or inline
 ## function @code{g} such that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.
 ## If M1 is empty or not passed then no preconditioners are applied.
-## The techinque used is the right preconditioning, i.e. it is solved
+## The techinque used is the right preconditioning, i.e., it is solved
 ## @code{@var{A}*inv(@var{M})*y = b} and then @code{@var{x} = inv(@var{M})*y}.
 ##
 ## @item @var{x0} the initial guess, if not given or set to [] the default
 ## value @code{zeros (size (b))} is used.
 ## @end itemize
 ##
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{P}) which are passed
 ## to @code{cgs}.
 ##
 ## The output parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -20,50 +20,51 @@
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0}, @dots{})
 ## @deftypefnx {} {@var{x} =} gmres (@var{A}, @var{b}, @var{restart}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
 ## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} gmres (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the Preconditioned GMRES iterative method with
 ## restart, a.k.a. PGMRES(restart).
 ##
 ## The input arguments are:
+##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with the same numbers of rows as @var{A}.
 ##
 ## @item @var{restart} is the number of iterations before that the
-## method restarts. If it is [] or N = numel (b), then the restart
+## method restarts.  If it is [] or N = numel (b), then the restart
 ## is not applied.
 ##
 ## @item @var{tol} is the required relative tolerance for the
 ## preconditioned residual error,
-## @code{inv (@var{M}) * (@var{b} - @var{a} * @var{x})}. The iteration stops if
-## @code{norm (inv (@var{M}) * (@var{b} - @var{a} * @var{x})) <=
-## @var{tol} * norm (inv (@var{M}) * @var{B})}.  If @var{tol} is omitted or
-## empty, then a tolerance of 1e-6 is used.
+## @code{inv (@var{M}) * (@var{b} - @var{a} * @var{x})}.  The iteration
+## stops if @code{norm (inv (@var{M}) * (@var{b} - @var{a} * @var{x}))
+## @leq{} @var{tol} * norm (inv (@var{M}) * @var{B})}.  If @var{tol} is
+## omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item @var{maxit} is the maximum number of outer iterations, if not given or
 ## set to [], then the default value @code{min (10, @var{N} / @var{restart})}
 ## is used.
 ## Note that, if @var{restart} is empty, then @var{maxit} is the maximum number
-## of iterations. If @var{restart} and @var{maxit} are not empty, then
+## of iterations.  If @var{restart} and @var{maxit} are not empty, then
 ## the maximum number of iterations is @code{@var{restart} * @var{maxit}}.
 ## If both @var{restart} and @var{maxit} are empty, then the maximum
 ## number of iterations is set to @code{min (10, @var{N})}.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
-## @var{M} is given as @code{M = M1 * M2}. Both @var{M1} and @var{M2} can
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
+## @var{M} is given as @code{M = M1 * M2}.  Both @var{M1} and @var{M2} can
 ## be passed as a matrix, function handle, or inline function @code{g} such
-## that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}. If @var{M1} is [] or not
+## that @code{g(x) = M1 \ x} or @code{g(x) = M2 \ x}.  If @var{M1} is [] or not
 ## given, then the preconditioner is not applied.
 ## The technique used is the left-preconditioning, i.e., it is solved
 ## @code{inv(@var{M}) * @var{A} * @var{x} = inv(@var{M}) * @var{b}} instead of
 ## @code{@var{A} * @var{x} = @var{b}}.
 ##
 ## @item @var{x0} is the initial guess,
 ## if not given or set to [], then the default value
 ## @code{zeros (size (@var{b}))} is used.
@@ -73,17 +74,17 @@
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M} or
 ## @var{M1} or @var{M2}) which are passed to @code{gmres}.
 ##
 ## The outputs are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} the computed approximation. If the method does not
+## @item @var{x} the computed approximation.  If the method does not
 ## converge, then it is the iterated with minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @table @asis
 ## @item 0 : iteration converged to within the specified tolerance
 ##
 ## @item 1 : maximum number of iterations exceeded
@@ -93,27 +94,27 @@
 ## @item 3 : algorithm reached stagnation (the relative difference between two
 ## consecutive iterations is less than eps)
 ## @end table
 ##
 ## @item @var{relres} is the value of the relative preconditioned
 ## residual of the approximation @var{x}.
 ##
 ## @item @var{iter} is a vector containing the number of outer iterations and
-## inner iterations performed to compute @var{x}. That is:
+## inner iterations performed to compute @var{x}.  That is:
 ##
 ## @itemize
-## @item @var{iter(1)}: number of outer iterations, i.e. how many
-## times the method restarted. (if @var{restart} is empty or @var{N},
-## then it is 1, if not 1 <= @var{iter(1)} <= @var{maxit}).
+## @item @var{iter(1)}: number of outer iterations, i.e., how many
+## times the method restarted.  (if @var{restart} is empty or @var{N},
+## then it is 1, if not 1 @leq{} @var{iter(1)} @leq{} @var{maxit}).
 ##
 ## @item @var{iter(2)}: the number of iterations performed before the
-## restart,  i.e., the method restarts when
-## @code{@var{iter(2)} = @var{restart}}. If @var{restart} is empty or
-## @var{N}, then 1 <= @var{iter(2)} <= @var{maxit}.
+## restart, i.e., the method restarts when
+## @code{@var{iter(2)} = @var{restart}}.  If @var{restart} is empty or
+## @var{N}, then 1 @leq{} @var{iter(2)} @leq{} @var{maxit}.
 ## @end itemize
 ##
 ## To be more clear, the approximation @var{x} is computed at the iteration
 ## @code{(@var{iter(1)} - 1) * @var{restart} + @var{iter(2)}}.
 ## Since the output @var{x} corresponds to the minimal preconditioned
 ## residual solution, the total number of iterations that
 ## the method performed is given by @code{length (resvec) - 1}.
 ##
@@ -157,16 +158,17 @@
 ## @sc{Example 3:} usage of @code{gmres} with the restart
 ##
 ## @example
 ## x = gmres (A, b, restart);
 ## @end example
 ##
 ## @sc{Example 4:} @code{gmres} with a preconditioner matrix @var{M}
 ## with and without restart
+##
 ## @example
 ## @group
 ## x = gmres (A, b, [], 1e-06, n, M)
 ## x = gmres (A, b, restart, 1e-06, n, M)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 5:} @code{gmres} with a function as preconditioner
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
+## @deftypefn  {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
 ## @deftypefnx {} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{M}, [], @var{x0}, @dots{})
 ## @deftypefnx {} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@var{A}, @var{b}, @dots{})
 ##
 ## Solve the linear system of equations @w{@code{@var{A} * @var{x} = @var{b}}}
 ## by means of the Preconditioned Conjugate Gradient iterative method.
 ##
 ## The input arguments are:
 ##
@@ -47,36 +47,36 @@
 ## @w{@code{@var{tol} * norm (@var{b})}}}.
 ## If @var{tol} is omitted or empty, then a tolerance of 1e-6 is used.
 ##
 ## @item
 ## @var{maxit} is the maximum allowed number of iterations; if @var{maxit}
 ## is omitted or empty then a value of 20 is used.
 ##
 ## @item
-## @var{m} is a HPD preconditioning matrix. For any decomposition
+## @var{m} is a HPD preconditioning matrix.  For any decomposition
 ## @code{@var{m} = @var{p1} * @var {p2}} such that
 ## @w{@code{inv (@var{p1}) * @var{A} * inv (@var{p2})}} is HPD, the
-## conjugate gradient method is formally applied to the linear  system
+## conjugate gradient method is formally applied to the linear system
 ## @w{@code{inv (@var{p1}) * @var{A} * inv (@var{p2}) * @var{y} = inv
 ## (@var{p1}) * @var{b}}},
 ## with @code{@var{x} = inv (@var{p2}) * @var{y}} (split preconditioning).
 ## In practice, at each iteration of the conjugate gradient method a
 ## linear system with matrix @var{m} is solved with @code{mldivide}.
 ## If a particular factorization
 ## @code{@var{m} = @var{m1} * @var{m2}} is available (for instance, an
 ## incomplete Cholesky factorization of @var{a}), the two matrices
 ## @var{m1} and @var{m2} can be passed and the relative linear systems
 ## are solved with the @code{mldivide} operator.
 ## Note that a proper choice of the preconditioner may dramatically improve
 ## the overall performance of the method.  Instead of matrices @var{m1} and
 ## @var{m2}, the user may pass two functions which return the results of
 ## applying the inverse of @var{m1} and @var{m2} to a vector.
 ## If @var{m1} is omitted or empty @code{[]}, then no preconditioning
-## is applied. If no factorization of @var{m} is available, @var{m2}
+## is applied.  If no factorization of @var{m} is available, @var{m2}
 ## can be omitted or left [], and the input variable @var{m1} can be
 ## used to pass the preconditioner @var{m}.
 ##
 ## @item
 ## @var{x0} is the initial guess.  If @var{x0} is omitted or empty then the
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
 ##
@@ -85,41 +85,46 @@
 ## @var{m2}) which are passed to @code{pcg}.
 ## See the examples below for further details.
 ##
 ## The output arguments are:
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
-## @w{@code{@var{A} * @var{x} = @var{b}}}. If the algorithm did not converge,
+## @w{@code{@var{A} * @var{x} = @var{b}}}.  If the algorithm did not converge,
 ## then @var{x} is the iterated which has the minimum residual.
 ##
 ## @item
 ## @var{flag} reports on the convergence:
+##
 ## @itemize
 ## @item 0: The algorithm converged at the prescribed tolerance.
+##
 ## @item 1: The algorithm did not converge and it reached the maximum
 ## number of iterations.
+##
 ## @item 2: The preconditioner matrix is singular.
-## @item 3: The algorithm stagnated, i.e. the absolute value of the
+##
+## @item 3: The algorithm stagnated, i.e., the absolute value of the
 ## difference between
 ## the actual iteration @var{x} and the previous is less than
 ## @code{@var{eps} * norm (@var{x},2)}.
+##
 ## @item 4: The algorithm detects that the input (preconditioned) matrix is not
 ## HPD.
 ## @end itemize
 ##
 ## @item
 ## @var{relres} is the ratio of the final residual to its initial value,
 ## measured in the Euclidean norm.
 ##
 ## @item
 ## @var{iter} indicates the iteration of @var{x} which it was
-## computed. Since the output @var{x} corresponds to the minimal
+## computed.  Since the output @var{x} corresponds to the minimal
 ## residual solution, the total number of iterations that
 ## the method performed is given by @code{length(resvec) - 1}.
 ##
 ## @item
 ## @var{resvec} describes the convergence history of the method.
 ## @code{@var{resvec} (@var{i}, 1)} is the Euclidean norm of the residual, and
 ## @code{@var{resvec} (@var{i}, 2)} is the preconditioned residual
 ## norm, after the
diff --git a/scripts/sparse/private/__alltohandles__.m b/scripts/sparse/private/__alltohandles__.m
--- a/scripts/sparse/private/__alltohandles__.m
+++ b/scripts/sparse/private/__alltohandles__.m
@@ -12,36 +12,37 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {[@var{Afun}, @var{M1fun}, @var{M2fun}] =} __alltohandles__ (@var{A}, @var{b}, @var{M1}, @var{M2}, @var{solver_name})
+## @deftypefn {} {[@var{Afun}, @var{M1fun}, @var{M2fun}] =} __alltohandles__ (@var{A}, @var{b}, @var{M1}, @var{M2}, @var{solver_name})
 ##
 ## Check if the parameters @var{A} (matrix of our linear system), @var{b}
 ## (right hand side vector), @var{M1}, @var{M2} (preconditioner matrices) are
 ## really matrices or functions handle, summarizing if they are void or not.
 ##
 ## The input parameters are:
 ##
 ## @itemize
 ## @item @var{A} is the matrix of the linear system.
 ##
 ## @item @var{b} is the right hand side vector.
 ##
-## @item @var{M1}, @var{M2} preconditioners. They can be [].
+## @item @var{M1}, @var{M2} preconditioners.  They can be [].
 ##
 ## @item @var{solver_name} is the name of the solver as string.
 ##
 ## @end itemize
 ##
 ## The output parameters are:
+##
 ## @itemize
 ##
 ## @item @var{Afun}, @var{M1fun}, @var{M2fun} are the corresponding
 ## function handles.
 ##
 ## @end itemize
 ## @end deftypefn
 
diff --git a/scripts/sparse/private/__default__input__.m b/scripts/sparse/private/__default__input__.m
--- a/scripts/sparse/private/__default__input__.m
+++ b/scripts/sparse/private/__default__input__.m
@@ -12,28 +12,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {@var{[varargout]} =} __default__input__ (@var{def_val}, @var{varargin})
+## @deftypefn {} {@var{[varargout]} =} __default__input__ (@var{def_val}, @var{varargin})
 ## Check if the arguments in input of a function are empty or missing
 ## and in such cases sets up them in default values.
 ##
 ## The input argoments are:
+##
 ## @itemize @minus
 ## @item @var{def_val} is a cell array that contains the values to use
-## as  default.
+## as default.
+##
 ## @item @var{varargin} are the input argument
 ## @end itemize
 ##
 ## The output argoments:
+##
 ## @itemize @minus
 ## @item @var{varargout} all the input argument with filled the empty
 ## or missing paramenters.
 ##
 ## @end itemize
 ##
 ## @end deftypefn
 
diff --git a/scripts/sparse/tfqmr.m b/scripts/sparse/tfqmr.m
--- a/scripts/sparse/tfqmr.m
+++ b/scripts/sparse/tfqmr.m
@@ -23,55 +23,55 @@
 ## Solve @code{A x = b} using the Transpose-Tree qmr method, based on the cgs.
 ##
 ## The input parameters are:
 ##
 ## @itemize @minus
 ##
 ## @item @var{A} is the matrix of the linear system and it must be square.
 ## @var{A} can be passed as a matrix, function handle, or inline
-## function @code{Afun} such that @code{Afun(x) = A * x}. Additional
+## function @code{Afun} such that @code{Afun(x) = A * x}.  Additional
 ## parameters to @code{Afun} are passed after @var{x0}.
 ##
-## @item @var{b} is the right hand side vector. It must be a column vector
+## @item @var{b} is the right hand side vector.  It must be a column vector
 ## with the same number of rows as @var{A}.
 ##
 ## @item @var{tol} is the relative tolerance, if not given or set to [] the
 ## default value 1e-6 is used.
 ##
 ## @item @var{maxit} the maximum number of outer iterations, if not given or
-## set to [] the default value @code{min (20, numel (b))} is used. To be
+## set to [] the default value @code{min (20, numel (b))} is used.  To be
 ## compatible, since the method as different behaviours in the iteration
 ## number is odd or even, is considered as iteration in @code{tfqmr} the
-## entire odd-even cycle. That is, to make an entire iteration, the algorithm
+## entire odd-even cycle.  That is, to make an entire iteration, the algorithm
 ## performs two sub-iterations: the odd one and the even one.
 ##
-## @item @var{M1}, @var{M2} are the preconditioners. The preconditioner
+## @item @var{M1}, @var{M2} are the preconditioners.  The preconditioner
 ## @var{M} is given as @code{M = M1 * M2}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
 ## @code {g(x) = M2 \ x}.
-## The technique used is the rigth-preconditioning, i.e. it is solved
+## The technique used is the rigth-preconditioning, i.e., it is solved
 ## @code{A*inv(M)*y = b} and then @code{x = inv(M)*y}, instead of
 ## @code{A x = b}.
 ##
 ## @item @var{x0} the initial guess, if not given or set to [] the default
 ## value @code{zeros (size (b))} is used.
 ##
 ## @end itemize
 ##
 ## The arguments which follow @var{x0} are treated as parameters, and passed in
 ## a proper way to any of the functions (@var{A} or @var{M}) which are passed
 ## to @code{tfqmr}.
 ##
 ## The output parameters are:
 ##
 ## @itemize @minus
 ##
-## @item @var{x} is the approximation computed. If the method doesn't
+## @item @var{x} is the approximation computed.  If the method doesn't
 ## converge then it is the iterated with the minimum residual.
 ##
 ## @item @var{flag} indicates the exit status:
 ##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
diff --git a/scripts/statistics/cov.m b/scripts/statistics/cov.m
--- a/scripts/statistics/cov.m
+++ b/scripts/statistics/cov.m
@@ -34,16 +34,17 @@
 ## where $\bar{x}$ and $\bar{y}$ are the mean values of @var{x} and @var{y}.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## cov (@var{x}) = 1/(N-1) * SUM_i (@var{x}(i) - mean(@var{x})) * (@var{y}(i) - mean(@var{y}))
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} and @var{y} vectors.
 ##
 ## @end ifnottex
 ##
 ## If called with one argument, compute @code{cov (@var{x}, @var{x})}, the
 ## covariance between the columns of @var{x}.
 ##
 ## The argument @var{opt} determines the type of normalization to use.
diff --git a/scripts/statistics/kurtosis.m b/scripts/statistics/kurtosis.m
--- a/scripts/statistics/kurtosis.m
+++ b/scripts/statistics/kurtosis.m
@@ -60,16 +60,17 @@
 ## @example
 ## @group
 ##               N - 1
 ## k0 = 3 + -------------- * ((N + 1) * k1 - 3 * (N - 1))
 ##          (N - 2)(N - 3)
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## The bias-corrected kurtosis coefficient is obtained by replacing the sample
 ## second and fourth central moments by their unbiased versions.  It is an
 ## unbiased estimate of the population kurtosis for normal populations.
 ##
 ## If @var{x} is a matrix, or more generally a multi-dimensional array, return
diff --git a/scripts/statistics/mean.m b/scripts/statistics/mean.m
--- a/scripts/statistics/mean.m
+++ b/scripts/statistics/mean.m
@@ -32,16 +32,17 @@
 ##
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## mean (@var{x}) = SUM_i @var{x}(i) / N
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the mean for each column and return them
 ## in a row vector.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
diff --git a/scripts/statistics/meansq.m b/scripts/statistics/meansq.m
--- a/scripts/statistics/meansq.m
+++ b/scripts/statistics/meansq.m
@@ -33,16 +33,17 @@
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## meansq (@var{x}) = 1/N SUM_i @var{x}(i)^2
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, return a row vector containing the mean square
 ## of each column.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{var, std, moment}
diff --git a/scripts/statistics/median.m b/scripts/statistics/median.m
--- a/scripts/statistics/median.m
+++ b/scripts/statistics/median.m
@@ -17,18 +17,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} median (@var{x})
 ## @deftypefnx {} {} median (@var{x}, @var{dim})
 ## Compute the median value of the elements of the vector @var{x}.
 ##
-## When the elements of @var{x} are sorted, say @code{@var{s} = sort (@var{x})},
-## the median is defined as
+## When the elements of @var{x} are sorted, say
+## @code{@var{s} = sort (@var{x})}, the median is defined as
 ## @tex
 ## $$
 ## {\rm median} (x) =
 ##   \cases{s(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (s(N/2)+s(N/2+1))/2, & $N$ even.}
 ## $$
 ## where $N$ is the number of elements of @var{x}.
 ##
diff --git a/scripts/statistics/moment.m b/scripts/statistics/moment.m
--- a/scripts/statistics/moment.m
+++ b/scripts/statistics/moment.m
@@ -35,16 +35,17 @@
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## 1/N SUM_i (@var{x}(i) - mean(@var{x}))^@var{p}
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ##
 ## If @var{x} is a matrix, return the row vector containing the @var{p}-th
 ## central moment of each column.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
diff --git a/scripts/statistics/skewness.m b/scripts/statistics/skewness.m
--- a/scripts/statistics/skewness.m
+++ b/scripts/statistics/skewness.m
@@ -60,16 +60,17 @@
 ## @example
 ## @group
 ##                   sqrt (N*(N-1))   mean ((@var{x} - mean (@var{x})).^3)
 ## skewness (@var{X}, 0) = -------------- * ------------------------.
 ##                       (N - 2)             std (@var{x}).^3
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## The adjusted skewness coefficient is obtained by replacing the sample second
 ## and third central moments by their bias-corrected versions.
 ##
 ## If @var{x} is a matrix, or more generally a multi-dimensional array, return
 ## the skewness along the first non-singleton dimension.  If the optional
diff --git a/scripts/statistics/var.m b/scripts/statistics/var.m
--- a/scripts/statistics/var.m
+++ b/scripts/statistics/var.m
@@ -34,16 +34,17 @@
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## var (@var{x}) = 1/(N-1) SUM_i (@var{x}(i) - mean(@var{x}))^2
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where @math{N} is the length of the @var{x} vector.
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the variance for each column and return
 ## them in a row vector.
 ##
 ## The argument @var{opt} determines the type of normalization to use.
 ## Valid values are
diff --git a/scripts/strings/erase.m b/scripts/strings/erase.m
--- a/scripts/strings/erase.m
+++ b/scripts/strings/erase.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {@var{newstr} =} erase (@var{str}, @var{ptn})
+## @deftypefn {} {@var{newstr} =} erase (@var{str}, @var{ptn})
 ## Delete all occurrences of @var{ptn} within @var{str}.
 ##
 ## @var{str} and @var{ptn} can be ordinary strings, cell array of strings, or
 ## character arrays.
 ##
 ## Examples
 ##
 ## @example
@@ -41,21 +41,23 @@
 ##
 ## ## cellstr, multiple patterns
 ## erase (@{"The ", "Octave interpreter ", "is fabulous"@}, @{"interpreter ", "The "@})
 ##     @result{} @{"", "Octave ", "is fabulous"@}
 ## @end group
 ## @end example
 ##
 ## Programming Note: @code{erase} deletes the first instance of a pattern in a
-## string when there are overlapping occurrences.  For example,
+## string when there are overlapping occurrences.  For example:
 ##
 ## @example
+## @group
 ## erase ("abababa", "aba")
 ##     @result{} "b"
+## @end group
 ## @end example
 ##
 ## See @code{strrep} for processing overlaps.
 ##
 ## @seealso{strrep, regexprep}
 ## @end deftypefn
 
 ## Author: Sahil Yadav <yadavsahil5198@gmail.com>
diff --git a/scripts/strings/isstring.m b/scripts/strings/isstring.m
--- a/scripts/strings/isstring.m
+++ b/scripts/strings/isstring.m
@@ -15,22 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} isstring (@var{x})
 ## Return true if @var{x} is a string array.
 ##
-## A string array is a data type that stores strings (row vectors of characters)
-## at each element in the array.  It is distinct from character arrays which
-## are N-dimensional arrays where each element is a single 1x1 character.  It
-## is also distinct from cell arrays of strings which store strings at each
-## element, but use cell indexing @samp{@{@}} to access elements rather than
-## string arrays which use ordinary array indexing @samp{()}.
+## A string array is a data type that stores strings (row vectors of
+## characters) at each element in the array.  It is distinct from character
+## arrays which are N-dimensional arrays where each element is a single 1x1
+## character.  It is also distinct from cell arrays of strings which store
+## strings at each element, but use cell indexing @samp{@{@}} to access
+## elements rather than string arrays which use ordinary array indexing
+## @samp{()}.
 ##
 ## Programming Note: Octave does not yet implement string arrays so this
 ## function will always return false.
 ## @seealso{ischar, iscellstr, isfloat, isinteger, islogical, isnumeric, isa}
 ## @end deftypefn
 
 function retval = isstring (s)
 
