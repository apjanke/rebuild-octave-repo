# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449262290 18000
#      Fri Dec 04 15:51:30 2015 -0500
# Node ID 20975a6f677ae9bc66b7b1b8a193ed3d675cea71
# Parent  2d6ddb2b157c2ccafe6efc1a08c825973c75008e
eliminate return statements after calls to print_usage

* data.cc: Eliminate return statements after calls to print_usage.

diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -89,27 +89,25 @@ index_error (const char *fmt, const std:
 }
 
 #define ANY_ALL(FCN) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
-  if (nargin == 1 || nargin == 2) \
-    { \
-      int dim = (nargin == 1 ? -1 : args(1).int_value (#FCN ": DIM must be an integer") - 1); \
+  if (nargin < 1 || nargin > 2) \
+    print_usage (); \
+ \
+  int dim = (nargin == 1 ? -1 : args(1).int_value (#FCN ": DIM must be an integer") - 1); \
  \
-      if (dim >= -1) \
-        retval = args(0).FCN (dim); \
-      else \
-        error (#FCN ": invalid dimension argument = %d", dim + 1); \
-    } \
+  if (dim >= -1) \
+    retval = args(0).FCN (dim); \
   else \
-    print_usage (); \
+    error (#FCN ": invalid dimension argument = %d", dim + 1); \
  \
   return retval
 
 DEFUN (all, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} all (@var{x})\n\
 @deftypefnx {Built-in Function} {} all (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if all elements of the vector\n\
@@ -218,57 +216,53 @@ Compute atan (@var{y} / @var{x}) for cor
 and @var{x}.\n\
 \n\
 @var{y} and @var{x} must match in size and orientation.\n\
 @seealso{tan, tand, tanh, atanh}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin == 2)
+  if (args.length () != 2)
+    print_usage ();
+
+  if (! args(0).is_numeric_type ())
+    gripe_wrong_type_arg ("atan2", args(0));
+  else if (! args(1).is_numeric_type ())
+    gripe_wrong_type_arg ("atan2", args(1));
+  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+    error ("atan2: not defined for complex numbers");
+  else if (args(0).is_single_type () || args(1).is_single_type ())
     {
-      if (! args(0).is_numeric_type ())
-        gripe_wrong_type_arg ("atan2", args(0));
-      else if (! args(1).is_numeric_type ())
-        gripe_wrong_type_arg ("atan2", args(1));
-      else if (args(0).is_complex_type () || args(1).is_complex_type ())
-        error ("atan2: not defined for complex numbers");
-      else if (args(0).is_single_type () || args(1).is_single_type ())
+      if (args(0).is_scalar_type () && args(1).is_scalar_type ())
+        retval = atan2f (args(0).float_value (), args(1).float_value ());
+      else
         {
-          if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-            retval = atan2f (args(0).float_value (), args(1).float_value ());
-          else
-            {
-              FloatNDArray a0 = args(0).float_array_value ();
-              FloatNDArray a1 = args(1).float_array_value ();
-              retval = binmap<float> (a0, a1, ::atan2f, "atan2");
-            }
+          FloatNDArray a0 = args(0).float_array_value ();
+          FloatNDArray a1 = args(1).float_array_value ();
+          retval = binmap<float> (a0, a1, ::atan2f, "atan2");
+        }
+    }
+  else
+    {
+      if (args(0).is_scalar_type () && args(1).is_scalar_type ())
+        retval = atan2 (args(0).scalar_value (), args(1).scalar_value ());
+      else if (args(0).is_sparse_type ())
+        {
+          SparseMatrix m0 = args(0).sparse_matrix_value ();
+          SparseMatrix m1 = args(1).sparse_matrix_value ();
+          retval = binmap<double> (m0, m1, ::atan2, "atan2");
         }
       else
         {
-          if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-            retval = atan2 (args(0).scalar_value (), args(1).scalar_value ());
-          else if (args(0).is_sparse_type ())
-            {
-              SparseMatrix m0 = args(0).sparse_matrix_value ();
-              SparseMatrix m1 = args(1).sparse_matrix_value ();
-              retval = binmap<double> (m0, m1, ::atan2, "atan2");
-            }
-          else
-            {
-              NDArray a0 = args(0).array_value ();
-              NDArray a1 = args(1).array_value ();
-              retval = binmap<double> (a0, a1, ::atan2, "atan2");
-            }
+          NDArray a0 = args(0).array_value ();
+          NDArray a1 = args(1).array_value ();
+          retval = binmap<double> (a0, a1, ::atan2, "atan2");
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (size (atan2 (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (atan2 (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (atan2 (rand (2, 3, 4), 1)), [2, 3, 4])
@@ -402,28 +396,28 @@ hypot (hypot (hypot (@var{x}, @var{y}), 
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin < 2)
+    print_usage ();
+
   if (nargin == 2)
-    {
-      retval = do_hypot (args(0), args(1));
-    }
-  else if (nargin >= 3)
+    retval = do_hypot (args(0), args(1));
+  else
     {
       retval = args(0);
+
       for (int i = 1; i < nargin; i++)
         retval = do_hypot (retval, args(i));
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (size (hypot (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (hypot (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (rand (2, 3, 4), 1)), [2, 3, 4])
@@ -497,68 +491,66 @@ and @var{e} is an integer.  If\n\
 @ifnottex\n\
 @w{@code{x = 0}}, @w{@code{f = e = 0}}.\n\
 @end ifnottex\n\
 @seealso{pow2, log, log10, exp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 1)
+  if (args.length () != 1)
+    print_usage ();
+
+  if (nargout < 2)
+    retval(0) = args(0).log2 ();
+  else if (args(0).is_single_type ())
     {
-      if (nargout < 2)
-        retval(0) = args(0).log2 ();
-      else if (args(0).is_single_type ())
+      if (args(0).is_real_type ())
         {
-          if (args(0).is_real_type ())
-            {
-              FloatNDArray f;
-              FloatNDArray x = args(0).float_array_value ();
-              // FIXME: should E be an int value?
-              FloatMatrix e;
-              map_2_xlog2 (x, f, e);
-              retval(1) = e;
-              retval(0) = f;
-            }
-          else if (args(0).is_complex_type ())
-            {
-              FloatComplexNDArray f;
-              FloatComplexNDArray x = args(0).float_complex_array_value ();
-              // FIXME: should E be an int value?
-              FloatNDArray e;
-              map_2_xlog2 (x, f, e);
-              retval(1) = e;
-              retval(0) = f;
-            }
-        }
-      else if (args(0).is_real_type ())
-        {
-          NDArray f;
-          NDArray x = args(0).array_value ();
+          FloatNDArray f;
+          FloatNDArray x = args(0).float_array_value ();
           // FIXME: should E be an int value?
-          Matrix e;
+          FloatMatrix e;
           map_2_xlog2 (x, f, e);
           retval(1) = e;
           retval(0) = f;
         }
       else if (args(0).is_complex_type ())
         {
-          ComplexNDArray f;
-          ComplexNDArray x = args(0).complex_array_value ();
+          FloatComplexNDArray f;
+          FloatComplexNDArray x = args(0).float_complex_array_value ();
           // FIXME: should E be an int value?
-          NDArray e;
+          FloatNDArray e;
           map_2_xlog2 (x, f, e);
           retval(1) = e;
           retval(0) = f;
         }
-      else
-        gripe_wrong_type_arg ("log2", args(0));
+    }
+  else if (args(0).is_real_type ())
+    {
+      NDArray f;
+      NDArray x = args(0).array_value ();
+      // FIXME: should E be an int value?
+      Matrix e;
+      map_2_xlog2 (x, f, e);
+      retval(1) = e;
+      retval(0) = f;
+    }
+  else if (args(0).is_complex_type ())
+    {
+      ComplexNDArray f;
+      ComplexNDArray x = args(0).complex_array_value ();
+      // FIXME: should E be an int value?
+      NDArray e;
+      map_2_xlog2 (x, f, e);
+      retval(1) = e;
+      retval(0) = f;
     }
   else
-    print_usage ();
+    gripe_wrong_type_arg ("log2", args(0));
 
   return retval;
 }
 
 /*
 %!assert (log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2])
 %!assert (log2 (Inf), Inf)
 %!assert (isnan (log2 (NaN)))
@@ -611,96 +603,95 @@ For the opposite conventions see the @co
 @code{rem} is best when computing the remainder after division of two\n\
 @emph{positive} numbers.  For negative numbers, or when the values are\n\
 periodic, @code{mod} is a better choice.\n\
 @seealso{mod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin == 2)
+  if (args.length () != 2)
+    print_usage ();
+
+  if (! args(0).is_numeric_type ())
+    gripe_wrong_type_arg ("rem", args(0));
+  else if (! args(1).is_numeric_type ())
+    gripe_wrong_type_arg ("rem", args(1));
+  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+    error ("rem: not defined for complex numbers");
+  else if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
-      if (! args(0).is_numeric_type ())
-        gripe_wrong_type_arg ("rem", args(0));
-      else if (! args(1).is_numeric_type ())
-        gripe_wrong_type_arg ("rem", args(1));
-      else if (args(0).is_complex_type () || args(1).is_complex_type ())
-        error ("rem: not defined for complex numbers");
-      else if (args(0).is_integer_type () || args(1).is_integer_type ())
+      builtin_type_t btyp0 = args(0).builtin_type ();
+      builtin_type_t btyp1 = args(1).builtin_type ();
+      if (btyp0 == btyp_double || btyp0 == btyp_float)
+        btyp0 = btyp1;
+      if (btyp1 == btyp_double || btyp1 == btyp_float)
+        btyp1 = btyp0;
+
+      if (btyp0 == btyp1)
         {
-          builtin_type_t btyp0 = args(0).builtin_type ();
-          builtin_type_t btyp1 = args(1).builtin_type ();
-          if (btyp0 == btyp_double || btyp0 == btyp_float)
-            btyp0 = btyp1;
-          if (btyp1 == btyp_double || btyp1 == btyp_float)
-            btyp1 = btyp0;
-
-          if (btyp0 == btyp1)
+          switch (btyp0)
             {
-              switch (btyp0)
-                {
 #define MAKE_INT_BRANCH(X) \
-                case btyp_ ## X: \
-                    { \
-                    X##NDArray a0 = args(0).X##_array_value (); \
-                    X##NDArray a1 = args(1).X##_array_value (); \
-                    retval = binmap<octave_##X,octave_##X,octave_##X> (a0, a1, rem, "rem"); \
-                    } \
-                  break;
-                MAKE_INT_BRANCH (int8);
-                MAKE_INT_BRANCH (int16);
-                MAKE_INT_BRANCH (int32);
-                MAKE_INT_BRANCH (int64);
-                MAKE_INT_BRANCH (uint8);
-                MAKE_INT_BRANCH (uint16);
-                MAKE_INT_BRANCH (uint32);
-                MAKE_INT_BRANCH (uint64);
+  case btyp_ ## X: \
+    { \
+      X##NDArray a0 = args(0).X##_array_value (); \
+      X##NDArray a1 = args(1).X##_array_value (); \
+      retval = binmap<octave_##X,octave_##X,octave_##X> (a0, a1, rem, "rem"); \
+    } \
+    break;
+
+              MAKE_INT_BRANCH (int8);
+              MAKE_INT_BRANCH (int16);
+              MAKE_INT_BRANCH (int32);
+              MAKE_INT_BRANCH (int64);
+              MAKE_INT_BRANCH (uint8);
+              MAKE_INT_BRANCH (uint16);
+              MAKE_INT_BRANCH (uint32);
+              MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
-                default:
-                  panic_impossible ();
-                }
-            }
-          else
-            error ("rem: cannot combine %s and %d",
-                   args(0).class_name ().c_str (),
-                   args(1).class_name ().c_str ());
-        }
-      else if (args(0).is_single_type () || args(1).is_single_type ())
-        {
-          if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-            retval = xrem (args(0).float_value (), args(1).float_value ());
-          else
-            {
-              FloatNDArray a0 = args(0).float_array_value ();
-              FloatNDArray a1 = args(1).float_array_value ();
-              retval = binmap<float> (a0, a1, xrem<float>, "rem");
+
+            default:
+              panic_impossible ();
             }
         }
       else
+        error ("rem: cannot combine %s and %d",
+               args(0).class_name ().c_str (),
+               args(1).class_name ().c_str ());
+    }
+  else if (args(0).is_single_type () || args(1).is_single_type ())
+    {
+      if (args(0).is_scalar_type () && args(1).is_scalar_type ())
+        retval = xrem (args(0).float_value (), args(1).float_value ());
+      else
         {
-          if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-            retval = xrem (args(0).scalar_value (), args(1).scalar_value ());
-          else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
-            {
-              SparseMatrix m0 = args(0).sparse_matrix_value ();
-              SparseMatrix m1 = args(1).sparse_matrix_value ();
-              retval = binmap<double> (m0, m1, xrem<double>, "rem");
-            }
-          else
-            {
-              NDArray a0 = args(0).array_value ();
-              NDArray a1 = args(1).array_value ();
-              retval = binmap<double> (a0, a1, xrem<double>, "rem");
-            }
+          FloatNDArray a0 = args(0).float_array_value ();
+          FloatNDArray a1 = args(1).float_array_value ();
+          retval = binmap<float> (a0, a1, xrem<float>, "rem");
         }
     }
   else
-    print_usage ();
+    {
+      if (args(0).is_scalar_type () && args(1).is_scalar_type ())
+        retval = xrem (args(0).scalar_value (), args(1).scalar_value ());
+      else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
+        {
+          SparseMatrix m0 = args(0).sparse_matrix_value ();
+          SparseMatrix m1 = args(1).sparse_matrix_value ();
+          retval = binmap<double> (m0, m1, xrem<double>, "rem");
+        }
+      else
+        {
+          NDArray a0 = args(0).array_value ();
+          NDArray a1 = args(1).array_value ();
+          retval = binmap<double> (a0, a1, xrem<double>, "rem");
+        }
+    }
 
   return retval;
 }
 
 /*
 %!assert (size (rem (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (rem (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (rem (rand (2, 3, 4), 1)), [2, 3, 4])
@@ -792,96 +783,95 @@ mod (@var{x}, @var{y})      returns a va
 For the opposite conventions see the @code{rem} function.  In general,\n\
 @code{mod} is a better choice than @code{rem} when any of the inputs are\n\
 negative numbers or when the values are periodic.\n\
 @seealso{rem}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin == 2)
+  if (args.length () != 2)
+    print_usage ();
+
+  if (! args(0).is_numeric_type ())
+    gripe_wrong_type_arg ("mod", args(0));
+  else if (! args(1).is_numeric_type ())
+    gripe_wrong_type_arg ("mod", args(1));
+  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+    error ("mod: not defined for complex numbers");
+  else if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
-      if (! args(0).is_numeric_type ())
-        gripe_wrong_type_arg ("mod", args(0));
-      else if (! args(1).is_numeric_type ())
-        gripe_wrong_type_arg ("mod", args(1));
-      else if (args(0).is_complex_type () || args(1).is_complex_type ())
-        error ("mod: not defined for complex numbers");
-      else if (args(0).is_integer_type () || args(1).is_integer_type ())
+      builtin_type_t btyp0 = args(0).builtin_type ();
+      builtin_type_t btyp1 = args(1).builtin_type ();
+      if (btyp0 == btyp_double || btyp0 == btyp_float)
+        btyp0 = btyp1;
+      if (btyp1 == btyp_double || btyp1 == btyp_float)
+        btyp1 = btyp0;
+
+      if (btyp0 == btyp1)
         {
-          builtin_type_t btyp0 = args(0).builtin_type ();
-          builtin_type_t btyp1 = args(1).builtin_type ();
-          if (btyp0 == btyp_double || btyp0 == btyp_float)
-            btyp0 = btyp1;
-          if (btyp1 == btyp_double || btyp1 == btyp_float)
-            btyp1 = btyp0;
-
-          if (btyp0 == btyp1)
+          switch (btyp0)
             {
-              switch (btyp0)
-                {
 #define MAKE_INT_BRANCH(X) \
-                case btyp_ ## X: \
-                    { \
-                    X##NDArray a0 = args(0).X##_array_value (); \
-                    X##NDArray a1 = args(1).X##_array_value (); \
-                    retval = binmap<octave_##X,octave_##X,octave_##X> (a0, a1, mod, "mod"); \
-                    } \
-                  break;
-                MAKE_INT_BRANCH (int8);
-                MAKE_INT_BRANCH (int16);
-                MAKE_INT_BRANCH (int32);
-                MAKE_INT_BRANCH (int64);
-                MAKE_INT_BRANCH (uint8);
-                MAKE_INT_BRANCH (uint16);
-                MAKE_INT_BRANCH (uint32);
-                MAKE_INT_BRANCH (uint64);
+  case btyp_ ## X: \
+    { \
+      X##NDArray a0 = args(0).X##_array_value (); \
+      X##NDArray a1 = args(1).X##_array_value (); \
+      retval = binmap<octave_##X,octave_##X,octave_##X> (a0, a1, mod, "mod"); \
+    } \
+    break;
+
+              MAKE_INT_BRANCH (int8);
+              MAKE_INT_BRANCH (int16);
+              MAKE_INT_BRANCH (int32);
+              MAKE_INT_BRANCH (int64);
+              MAKE_INT_BRANCH (uint8);
+              MAKE_INT_BRANCH (uint16);
+              MAKE_INT_BRANCH (uint32);
+              MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
-                default:
-                  panic_impossible ();
-                }
-            }
-          else
-            error ("mod: cannot combine %s and %d",
-                   args(0).class_name ().c_str (),
-                   args(1).class_name ().c_str ());
-        }
-      else if (args(0).is_single_type () || args(1).is_single_type ())
-        {
-          if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-            retval = xmod (args(0).float_value (), args(1).float_value ());
-          else
-            {
-              FloatNDArray a0 = args(0).float_array_value ();
-              FloatNDArray a1 = args(1).float_array_value ();
-              retval = binmap<float> (a0, a1, xmod<float>, "mod");
+
+            default:
+              panic_impossible ();
             }
         }
       else
+        error ("mod: cannot combine %s and %d",
+               args(0).class_name ().c_str (),
+               args(1).class_name ().c_str ());
+    }
+  else if (args(0).is_single_type () || args(1).is_single_type ())
+    {
+      if (args(0).is_scalar_type () && args(1).is_scalar_type ())
+        retval = xmod (args(0).float_value (), args(1).float_value ());
+      else
         {
-          if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-            retval = xmod (args(0).scalar_value (), args(1).scalar_value ());
-          else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
-            {
-              SparseMatrix m0 = args(0).sparse_matrix_value ();
-              SparseMatrix m1 = args(1).sparse_matrix_value ();
-              retval = binmap<double> (m0, m1, xmod<double>, "mod");
-            }
-          else
-            {
-              NDArray a0 = args(0).array_value ();
-              NDArray a1 = args(1).array_value ();
-              retval = binmap<double> (a0, a1, xmod<double>, "mod");
-            }
+          FloatNDArray a0 = args(0).float_array_value ();
+          FloatNDArray a1 = args(1).float_array_value ();
+          retval = binmap<float> (a0, a1, xmod<float>, "mod");
         }
     }
   else
-    print_usage ();
+    {
+      if (args(0).is_scalar_type () && args(1).is_scalar_type ())
+        retval = xmod (args(0).scalar_value (), args(1).scalar_value ());
+      else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
+        {
+          SparseMatrix m0 = args(0).sparse_matrix_value ();
+          SparseMatrix m1 = args(1).sparse_matrix_value ();
+          retval = binmap<double> (m0, m1, xmod<double>, "mod");
+        }
+      else
+        {
+          NDArray a0 = args(0).array_value ();
+          NDArray a1 = args(1).array_value ();
+          retval = binmap<double> (a0, a1, xmod<double>, "mod");
+        }
+    }
 
   return retval;
 }
 
 /*
 ## empty input test
 %!assert (isempty (mod ([], [])))
 
@@ -958,214 +948,209 @@ negative numbers or when the values are 
         isnative = true; \
       else if (str == "double") \
         isdouble = true; \
       else \
         error ("sum: unrecognized string argument"); \
       nargin --; \
     } \
  \
-  if (nargin == 1 || nargin == 2) \
-    { \
-      octave_value arg = args(0); \
+  if (nargin < 1 || nargin > 2) \
+    print_usage (); \
+ \
+  octave_value arg = args(0); \
  \
-      int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
+  int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
-      if (dim >= -1) \
+  if (dim >= -1) \
+    { \
+      if (arg.is_sparse_type ()) \
         { \
-          if (arg.is_sparse_type ()) \
+          if (arg.is_real_type ()) \
             { \
-              if (arg.is_real_type ()) \
-                { \
-                  SparseMatrix tmp = arg.sparse_matrix_value (); \
+              SparseMatrix tmp = arg.sparse_matrix_value (); \
  \
-                  retval = tmp.FCN (dim); \
-                } \
-              else \
-                { \
-                  SparseComplexMatrix tmp \
-                    = arg.sparse_complex_matrix_value (); \
- \
-                  retval = tmp.FCN (dim); \
-                } \
+              retval = tmp.FCN (dim); \
             } \
           else \
             { \
-              if (isnative) \
-                { \
-                  if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
-                  else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
-                  else if NATIVE_REDUCTION_1 (FCN, uint32, dim) \
-                  else if NATIVE_REDUCTION_1 (FCN, uint64, dim) \
-                  else if NATIVE_REDUCTION_1 (FCN, int8, dim) \
-                  else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
-                  else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
-                  else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
-                  else if (arg.is_bool_type ()) \
-                    { \
-                      boolNDArray tmp = arg.bool_array_value (); \
- \
-                      retval = boolNDArray (tmp.BOOL_FCN (dim)); \
-                    } \
-                  else if (arg.is_char_matrix ()) \
-                    { \
-                      error (#FCN, ": invalid char type"); \
-                    } \
-                  else if (!isdouble && arg.is_single_type ()) \
-                    { \
-                      if (arg.is_complex_type ()) \
-                        { \
-                          FloatComplexNDArray tmp = \
-                            arg.float_complex_array_value (); \
+              SparseComplexMatrix tmp \
+                = arg.sparse_complex_matrix_value (); \
  \
-                          retval = tmp.FCN (dim); \
-                        } \
-                      else if (arg.is_real_type ()) \
-                        { \
-                          FloatNDArray tmp = arg.float_array_value (); \
- \
-                          retval = tmp.FCN (dim); \
-                        } \
-                    } \
-                  else if (arg.is_complex_type ()) \
-                    { \
-                      ComplexNDArray tmp = arg.complex_array_value (); \
- \
-                      retval = tmp.FCN (dim); \
-                    } \
-                  else if (arg.is_real_type ()) \
-                    { \
-                      NDArray tmp = arg.array_value (); \
- \
-                      retval = tmp.FCN (dim); \
-                    } \
-                  else \
-                    { \
-                      gripe_wrong_type_arg (#FCN, arg); \
-                      return retval; \
-                    } \
-                } \
+              retval = tmp.FCN (dim); \
+            } \
+        } \
+      else \
+        { \
+          if (isnative) \
+            { \
+              if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
+              else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
+              else if NATIVE_REDUCTION_1 (FCN, uint32, dim) \
+              else if NATIVE_REDUCTION_1 (FCN, uint64, dim) \
+              else if NATIVE_REDUCTION_1 (FCN, int8, dim) \
+              else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
+              else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
+              else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
               else if (arg.is_bool_type ()) \
                 { \
                   boolNDArray tmp = arg.bool_array_value (); \
  \
-                  retval = tmp.FCN (dim); \
+                  retval = boolNDArray (tmp.BOOL_FCN (dim)); \
+                } \
+              else if (arg.is_char_matrix ()) \
+                { \
+                  error (#FCN, ": invalid char type"); \
                 } \
               else if (!isdouble && arg.is_single_type ()) \
                 { \
-                  if (arg.is_real_type ()) \
-                    { \
-                      FloatNDArray tmp = arg.float_array_value (); \
- \
-                      retval = tmp.FCN (dim); \
-                    } \
-                  else if (arg.is_complex_type ()) \
+                  if (arg.is_complex_type ()) \
                     { \
                       FloatComplexNDArray tmp = \
                         arg.float_complex_array_value (); \
  \
                       retval = tmp.FCN (dim); \
                     } \
+                  else if (arg.is_real_type ()) \
+                    { \
+                      FloatNDArray tmp = arg.float_array_value (); \
+ \
+                      retval = tmp.FCN (dim); \
+                    } \
+                } \
+              else if (arg.is_complex_type ()) \
+                { \
+                  ComplexNDArray tmp = arg.complex_array_value (); \
+ \
+                  retval = tmp.FCN (dim); \
                 } \
               else if (arg.is_real_type ()) \
                 { \
                   NDArray tmp = arg.array_value (); \
  \
                   retval = tmp.FCN (dim); \
                 } \
-              else if (arg.is_complex_type ()) \
-                { \
-                  ComplexNDArray tmp = arg.complex_array_value (); \
- \
-                  retval = tmp.FCN (dim); \
-                } \
               else \
                 { \
                   gripe_wrong_type_arg (#FCN, arg); \
                   return retval; \
                 } \
             } \
-          else \
-            error (#FCN ": invalid dimension argument = %d", dim + 1); \
-        } \
- \
-    } \
-  else \
-    print_usage (); \
- \
-  return retval
-
-#define DATA_REDUCTION(FCN) \
- \
-  octave_value retval; \
+          else if (arg.is_bool_type ()) \
+            { \
+              boolNDArray tmp = arg.bool_array_value (); \
  \
-  int nargin = args.length (); \
- \
-  if (nargin == 1 || nargin == 2) \
-    { \
-      octave_value arg = args(0); \
- \
-      int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
+              retval = tmp.FCN (dim); \
+            } \
+          else if (!isdouble && arg.is_single_type ()) \
+            { \
+              if (arg.is_real_type ()) \
+                { \
+                  FloatNDArray tmp = arg.float_array_value (); \
  \
-      if (dim >= -1) \
-        { \
-          if (arg.is_real_type ()) \
-            { \
-              if (arg.is_sparse_type ()) \
-                { \
-                  SparseMatrix tmp = arg.sparse_matrix_value (); \
-\
                   retval = tmp.FCN (dim); \
                 } \
-              else if (arg.is_single_type ()) \
+              else if (arg.is_complex_type ()) \
                 { \
-                  FloatNDArray tmp = arg.float_array_value (); \
-\
-                  retval = tmp.FCN (dim); \
-                } \
-              else \
-                { \
-                  NDArray tmp = arg.array_value (); \
-\
+                  FloatComplexNDArray tmp = \
+                    arg.float_complex_array_value (); \
+ \
                   retval = tmp.FCN (dim); \
                 } \
             } \
+          else if (arg.is_real_type ()) \
+            { \
+              NDArray tmp = arg.array_value (); \
+ \
+              retval = tmp.FCN (dim); \
+            } \
           else if (arg.is_complex_type ()) \
             { \
-              if (arg.is_sparse_type ()) \
-                { \
-                  SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
-\
-                  retval = tmp.FCN (dim); \
-                } \
-              else if (arg.is_single_type ()) \
-                { \
-                  FloatComplexNDArray tmp \
-                    = arg.float_complex_array_value (); \
-\
-                  retval = tmp.FCN (dim); \
-                } \
-              else \
-                { \
-                  ComplexNDArray tmp = arg.complex_array_value (); \
-\
-                  retval = tmp.FCN (dim); \
-                } \
+              ComplexNDArray tmp = arg.complex_array_value (); \
+ \
+              retval = tmp.FCN (dim); \
             } \
           else \
             { \
               gripe_wrong_type_arg (#FCN, arg); \
               return retval; \
             } \
         } \
       else \
         error (#FCN ": invalid dimension argument = %d", dim + 1); \
     } \
+ \
+  return retval
+
+#define DATA_REDUCTION(FCN) \
+ \
+  octave_value retval; \
+ \
+  int nargin = args.length (); \
+ \
+  if (nargin < 1 || nargin > 2) \
+    print_usage (); \
+ \
+  octave_value arg = args(0); \
+ \
+  int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
+ \
+  if (dim >= -1) \
+    { \
+      if (arg.is_real_type ()) \
+        { \
+          if (arg.is_sparse_type ()) \
+            { \
+              SparseMatrix tmp = arg.sparse_matrix_value (); \
+ \
+              retval = tmp.FCN (dim); \
+            } \
+          else if (arg.is_single_type ()) \
+            { \
+              FloatNDArray tmp = arg.float_array_value (); \
+ \
+              retval = tmp.FCN (dim); \
+            } \
+          else \
+            { \
+              NDArray tmp = arg.array_value (); \
+ \
+              retval = tmp.FCN (dim); \
+            } \
+        } \
+      else if (arg.is_complex_type ()) \
+        { \
+          if (arg.is_sparse_type ()) \
+            { \
+              SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
+ \
+              retval = tmp.FCN (dim); \
+            } \
+          else if (arg.is_single_type ()) \
+            { \
+              FloatComplexNDArray tmp \
+                = arg.float_complex_array_value (); \
+ \
+              retval = tmp.FCN (dim); \
+            } \
+          else \
+            { \
+              ComplexNDArray tmp = arg.complex_array_value (); \
+ \
+              retval = tmp.FCN (dim); \
+            } \
+        } \
+      else \
+        { \
+          gripe_wrong_type_arg (#FCN, arg); \
+          return retval; \
+        } \
+    } \
   else \
-    print_usage (); \
+    error (#FCN ": invalid dimension argument = %d", dim + 1); \
  \
   return retval
 
 DEFUN (cumprod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cumprod (@var{x})\n\
 @deftypefnx {Built-in Function} {} cumprod (@var{x}, @var{dim})\n\
 Cumulative product of elements along dimension @var{dim}.\n\
@@ -1228,97 +1213,97 @@ See @code{sum} for an explanation of the
         isnative = true;
       else if (str == "double")
         isdouble = true;
       else
         error ("cumsum: unrecognized string argument");
       nargin --;
     }
 
-  if (nargin == 1 || nargin == 2)
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  octave_value arg = args(0);
+
+  int dim = -1;
+  if (nargin == 2)
+    {
+      dim = args(1).int_value () - 1;
+      if (dim < 0)
+        error ("cumsum: invalid dimension argument = %d", dim + 1);
+    }
+
+  switch (arg.builtin_type ())
     {
-      octave_value arg = args(0);
-
-      int dim = -1;
-      if (nargin == 2)
-        {
-          dim = args(1).int_value () - 1;
-          if (dim < 0)
-            error ("cumsum: invalid dimension argument = %d", dim + 1);
-        }
-
-      switch (arg.builtin_type ())
-        {
-        case btyp_double:
-          if (arg.is_sparse_type ())
-            retval = arg.sparse_matrix_value ().cumsum (dim);
-          else
-            retval = arg.array_value ().cumsum (dim);
-          break;
-        case btyp_complex:
-          if (arg.is_sparse_type ())
-            retval = arg.sparse_complex_matrix_value ().cumsum (dim);
-          else
-            retval = arg.complex_array_value ().cumsum (dim);
-          break;
-        case btyp_float:
-          if (isdouble)
-            retval = arg.array_value ().cumsum (dim);
-          else
-            retval = arg.float_array_value ().cumsum (dim);
-          break;
-        case btyp_float_complex:
-          if (isdouble)
-            retval = arg.complex_array_value ().cumsum (dim);
-          else
-            retval = arg.float_complex_array_value ().cumsum (dim);
-          break;
+    case btyp_double:
+      if (arg.is_sparse_type ())
+        retval = arg.sparse_matrix_value ().cumsum (dim);
+      else
+        retval = arg.array_value ().cumsum (dim);
+      break;
+    case btyp_complex:
+      if (arg.is_sparse_type ())
+        retval = arg.sparse_complex_matrix_value ().cumsum (dim);
+      else
+        retval = arg.complex_array_value ().cumsum (dim);
+      break;
+    case btyp_float:
+      if (isdouble)
+        retval = arg.array_value ().cumsum (dim);
+      else
+        retval = arg.float_array_value ().cumsum (dim);
+      break;
+    case btyp_float_complex:
+      if (isdouble)
+        retval = arg.complex_array_value ().cumsum (dim);
+      else
+        retval = arg.float_complex_array_value ().cumsum (dim);
+      break;
 
 #define MAKE_INT_BRANCH(X) \
-          case btyp_ ## X: \
-            if (isnative) \
-              retval = arg.X ## _array_value ().cumsum (dim); \
-            else \
-              retval = arg.array_value ().cumsum (dim); \
-            break;
-          MAKE_INT_BRANCH (int8);
-          MAKE_INT_BRANCH (int16);
-          MAKE_INT_BRANCH (int32);
-          MAKE_INT_BRANCH (int64);
-          MAKE_INT_BRANCH (uint8);
-          MAKE_INT_BRANCH (uint16);
-          MAKE_INT_BRANCH (uint32);
-          MAKE_INT_BRANCH (uint64);
+  case btyp_ ## X: \
+    if (isnative) \
+      retval = arg.X ## _array_value ().cumsum (dim); \
+    else \
+      retval = arg.array_value ().cumsum (dim); \
+    break;
+
+      MAKE_INT_BRANCH (int8);
+      MAKE_INT_BRANCH (int16);
+      MAKE_INT_BRANCH (int32);
+      MAKE_INT_BRANCH (int64);
+      MAKE_INT_BRANCH (uint8);
+      MAKE_INT_BRANCH (uint16);
+      MAKE_INT_BRANCH (uint32);
+      MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
 
-        case btyp_bool:
-          if (arg.is_sparse_type ())
-            {
-              SparseMatrix cs = arg.sparse_matrix_value ().cumsum (dim);
-              if (isnative)
-                retval = cs != 0.0;
-              else
-                retval = cs;
-            }
+    case btyp_bool:
+      if (arg.is_sparse_type ())
+        {
+          SparseMatrix cs = arg.sparse_matrix_value ().cumsum (dim);
+          if (isnative)
+            retval = cs != 0.0;
           else
-            {
-              NDArray cs = arg.bool_array_value ().cumsum (dim);
-              if (isnative)
-                retval = cs != 0.0;
-              else
-                retval = cs;
-            }
-          break;
-
-        default:
-          gripe_wrong_type_arg ("cumsum", arg);
+            retval = cs;
         }
+      else
+        {
+          NDArray cs = arg.bool_array_value ().cumsum (dim);
+          if (isnative)
+            retval = cs != 0.0;
+          else
+            retval = cs;
+        }
+      break;
+
+    default:
+      gripe_wrong_type_arg ("cumsum", arg);
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (cumsum ([1, 2, 3]), [1, 3, 6])
 %!assert (cumsum ([-1; -2; -3]), [-1; -3; -6])
 %!assert (cumsum ([i, 2+i, -3+2i, 4]), [i, 2+2i, -1+4i, 3+4i])
@@ -1370,40 +1355,41 @@ columns.\n\
 Given a matrix argument, instead of a vector, @code{diag} extracts the\n\
 @var{k}-th diagonal of the matrix.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 && args(0).is_defined ())
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+
+  if (nargin == 1)
     retval = args(0).diag ();
-  else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
+  else if (nargin == 2)
     {
       octave_idx_type k = args(1).xint_value ("diag: invalid argument K");
 
       retval = args(0).diag (k);
     }
-  else if (nargin == 3)
+  else
     {
       octave_value arg0 = args(0);
 
       if (arg0.ndims () == 2 && (arg0.rows () == 1 || arg0.columns () == 1))
         {
           octave_idx_type m = args(1).xint_value ("diag: invalid dimensions");
           octave_idx_type n = args(2).xint_value ("diag: invalid dimensions");
 
           retval = arg0.diag (m, n);
         }
       else
         error ("diag: V must be a vector");
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 
 %!assert (full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3])
 %!assert (diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0])
@@ -1515,96 +1501,97 @@ in double precision even for single prec
         isnative = true;
       else if (str == "double")
         isdouble = true;
       else
         error ("prod: unrecognized type argument '%s'", str.c_str ());
       nargin --;
     }
 
-  if (nargin == 1 || nargin == 2)
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  octave_value arg = args(0);
+
+  int dim = -1;
+  if (nargin == 2)
+    {
+      dim = args(1).int_value () - 1;
+      if (dim < 0)
+        error ("prod: invalid dimension DIM = %d", dim + 1);
+    }
+
+  switch (arg.builtin_type ())
     {
-      octave_value arg = args(0);
-
-      int dim = -1;
-      if (nargin == 2)
-        {
-          dim = args(1).int_value () - 1;
-          if (dim < 0)
-            error ("prod: invalid dimension DIM = %d", dim + 1);
-        }
-
-      switch (arg.builtin_type ())
-        {
-        case btyp_double:
-          if (arg.is_sparse_type ())
-            retval = arg.sparse_matrix_value ().prod (dim);
-          else
-            retval = arg.array_value ().prod (dim);
-          break;
-        case btyp_complex:
-          if (arg.is_sparse_type ())
-            retval = arg.sparse_complex_matrix_value ().prod (dim);
-          else
-            retval = arg.complex_array_value ().prod (dim);
-          break;
-        case btyp_float:
-          if (isdouble)
-            retval = arg.float_array_value ().dprod (dim);
-          else
-            retval = arg.float_array_value ().prod (dim);
-          break;
-        case btyp_float_complex:
-          if (isdouble)
-            retval = arg.float_complex_array_value ().dprod (dim);
-          else
-            retval = arg.float_complex_array_value ().prod (dim);
-          break;
+    case btyp_double:
+      if (arg.is_sparse_type ())
+        retval = arg.sparse_matrix_value ().prod (dim);
+      else
+        retval = arg.array_value ().prod (dim);
+      break;
+    case btyp_complex:
+      if (arg.is_sparse_type ())
+        retval = arg.sparse_complex_matrix_value ().prod (dim);
+      else
+        retval = arg.complex_array_value ().prod (dim);
+      break;
+    case btyp_float:
+      if (isdouble)
+        retval = arg.float_array_value ().dprod (dim);
+      else
+        retval = arg.float_array_value ().prod (dim);
+      break;
+    case btyp_float_complex:
+      if (isdouble)
+        retval = arg.float_complex_array_value ().dprod (dim);
+      else
+        retval = arg.float_complex_array_value ().prod (dim);
+      break;
 
 #define MAKE_INT_BRANCH(X) \
-          case btyp_ ## X: \
-            if (isnative) \
-              retval = arg.X ## _array_value ().prod (dim); \
-            else \
-              retval = arg.array_value ().prod (dim); \
-            break;
-          MAKE_INT_BRANCH (int8);
-          MAKE_INT_BRANCH (int16);
-          MAKE_INT_BRANCH (int32);
-          MAKE_INT_BRANCH (int64);
-          MAKE_INT_BRANCH (uint8);
-          MAKE_INT_BRANCH (uint16);
-          MAKE_INT_BRANCH (uint32);
-          MAKE_INT_BRANCH (uint64);
+  case btyp_ ## X: \
+    if (isnative) \
+      retval = arg.X ## _array_value ().prod (dim); \
+    else \
+      retval = arg.array_value ().prod (dim); \
+    break;
+
+      MAKE_INT_BRANCH (int8);
+      MAKE_INT_BRANCH (int16);
+      MAKE_INT_BRANCH (int32);
+      MAKE_INT_BRANCH (int64);
+      MAKE_INT_BRANCH (uint8);
+      MAKE_INT_BRANCH (uint16);
+      MAKE_INT_BRANCH (uint32);
+      MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
 
           // GAGME: Accursed Matlab compatibility...
-        case btyp_char:
-          retval = arg.array_value (true).prod (dim);
-          break;
-        case btyp_bool:
-          if (arg.is_sparse_type ())
-            {
-              if (isnative)
-                retval = arg.sparse_bool_matrix_value ().all (dim);
-              else
-                retval = arg.sparse_matrix_value ().prod (dim);
-            }
-          else if (isnative)
-            retval = arg.bool_array_value ().all (dim);
+    case btyp_char:
+      retval = arg.array_value (true).prod (dim);
+      break;
+
+    case btyp_bool:
+      if (arg.is_sparse_type ())
+        {
+          if (isnative)
+            retval = arg.sparse_bool_matrix_value ().all (dim);
           else
-            retval = NDArray (arg.bool_array_value ().all (dim));
-          break;
-
-        default:
-          gripe_wrong_type_arg ("prod", arg);
+            retval = arg.sparse_matrix_value ().prod (dim);
         }
+      else if (isnative)
+        retval = arg.bool_array_value ().all (dim);
+      else
+        retval = NDArray (arg.bool_array_value ().all (dim));
+      break;
+
+    default:
+      gripe_wrong_type_arg ("prod", arg);
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (prod ([1, 2, 3]), 6)
 %!assert (prod ([-1; -2; -3]), -6)
 %!assert (prod ([i, 2+i, -3+2i, 4]), -4 - 32i)
@@ -2658,24 +2645,20 @@ Return the length of the object @var{a}.
 \n\
 The length is 0 for empty objects, 1 for scalars, and the number of elements\n\
 for vectors.  For matrix or N-dimensional objects, the length is the number\n\
 of elements along the largest dimension\n\
 (equivalent to @w{@code{max (size (@var{a}))}}).\n\
 @seealso{numel, size}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).length ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).length ());
 }
 
 DEFUN (ndims, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 \n\
 For any array, the result will always be greater than or equal to 2.\n\
@@ -2685,24 +2668,20 @@ Trailing singleton dimensions are not co
 @group\n\
 ndims (ones (4, 1, 2, 1))\n\
     @result{} 3\n\
 @end group\n\
 @end example\n\
 @seealso{size}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).ndims ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).ndims ());
 }
 
 DEFUN (numel, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} numel (@var{a})\n\
 @deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Return the number of elements in the object @var{a}.\n\
 \n\
@@ -2883,79 +2862,63 @@ When called with a single or no argument
 
 DEFUN (nnz, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{n} =} nnz (@var{a})\n\
 Return the number of nonzero elements in @var{a}.\n\
 @seealso{nzmax, nonzeros, find}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).nnz ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).nnz ());
 }
 
 DEFUN (nzmax, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{n} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
 \n\
 Note that Octave tends to crop unused memory at the first opportunity\n\
 for sparse objects.  Thus, in general the value of @code{nzmax} will be the\n\
 same as @code{nnz} except for some cases of user-created sparse objects.\n\
 @seealso{nnz, spalloc, sparse}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).nzmax ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).nzmax ());
 }
 
 DEFUN (rows, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rows (@var{a})\n\
 Return the number of rows of @var{a}.\n\
 @seealso{columns, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).rows ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).rows ());
 }
 
 DEFUN (columns, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} columns (@var{a})\n\
 Return the number of columns of @var{a}.\n\
 @seealso{rows, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).columns ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).columns ());
 }
 
 DEFUN (sum, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sum (@var{x})\n\
 @deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"double\")\n\
@@ -3008,111 +2971,115 @@ inputs, @qcode{\"extra\"} is the same as
         isdouble = true;
       else if (str == "extra")
         isextra = true;
       else
         error ("sum: unrecognized type argument '%s'", str.c_str ());
       nargin --;
     }
 
-  if (nargin == 1 || nargin == 2)
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  octave_value arg = args(0);
+
+  int dim = -1;
+  if (nargin == 2)
     {
-      octave_value arg = args(0);
-
-      int dim = -1;
-      if (nargin == 2)
-        {
-          dim = args(1).int_value () - 1;
-          if (dim < 0)
-            error ("sum: invalid dimension DIM = %d", dim + 1);
-        }
-
-      switch (arg.builtin_type ())
+      dim = args(1).int_value () - 1;
+      if (dim < 0)
+        error ("sum: invalid dimension DIM = %d", dim + 1);
+    }
+
+  switch (arg.builtin_type ())
+    {
+    case btyp_double:
+      if (arg.is_sparse_type ())
         {
-        case btyp_double:
-          if (arg.is_sparse_type ())
-            {
-              if (isextra)
-                warning ("sum: 'extra' not yet implemented for sparse matrices");
-              retval = arg.sparse_matrix_value ().sum (dim);
-            }
-          else if (isextra)
-            retval = arg.array_value ().xsum (dim);
-          else
-            retval = arg.array_value ().sum (dim);
-          break;
-        case btyp_complex:
-          if (arg.is_sparse_type ())
-            {
-              if (isextra)
-                warning ("sum: 'extra' not yet implemented for sparse matrices");
-              retval = arg.sparse_complex_matrix_value ().sum (dim);
-            }
-          else if (isextra)
-            retval = arg.complex_array_value ().xsum (dim);
-          else
-            retval = arg.complex_array_value ().sum (dim);
-          break;
-        case btyp_float:
-          if (isdouble || isextra)
-            retval = arg.float_array_value ().dsum (dim);
-          else
-            retval = arg.float_array_value ().sum (dim);
-          break;
-        case btyp_float_complex:
-          if (isdouble || isextra)
-            retval = arg.float_complex_array_value ().dsum (dim);
-          else
-            retval = arg.float_complex_array_value ().sum (dim);
-          break;
+          if (isextra)
+            warning ("sum: 'extra' not yet implemented for sparse matrices");
+          retval = arg.sparse_matrix_value ().sum (dim);
+        }
+      else if (isextra)
+        retval = arg.array_value ().xsum (dim);
+      else
+        retval = arg.array_value ().sum (dim);
+      break;
+
+    case btyp_complex:
+      if (arg.is_sparse_type ())
+        {
+          if (isextra)
+            warning ("sum: 'extra' not yet implemented for sparse matrices");
+          retval = arg.sparse_complex_matrix_value ().sum (dim);
+        }
+      else if (isextra)
+        retval = arg.complex_array_value ().xsum (dim);
+      else
+        retval = arg.complex_array_value ().sum (dim);
+      break;
+
+    case btyp_float:
+      if (isdouble || isextra)
+        retval = arg.float_array_value ().dsum (dim);
+      else
+        retval = arg.float_array_value ().sum (dim);
+      break;
+
+    case btyp_float_complex:
+      if (isdouble || isextra)
+        retval = arg.float_complex_array_value ().dsum (dim);
+      else
+        retval = arg.float_complex_array_value ().sum (dim);
+      break;
 
 #define MAKE_INT_BRANCH(X) \
-          case btyp_ ## X: \
-            if (isnative) \
-              retval = arg.X ## _array_value ().sum (dim); \
-            else \
-              retval = arg.X ## _array_value ().dsum (dim); \
-            break;
-          MAKE_INT_BRANCH (int8);
-          MAKE_INT_BRANCH (int16);
-          MAKE_INT_BRANCH (int32);
-          MAKE_INT_BRANCH (int64);
-          MAKE_INT_BRANCH (uint8);
-          MAKE_INT_BRANCH (uint16);
-          MAKE_INT_BRANCH (uint32);
-          MAKE_INT_BRANCH (uint64);
+  case btyp_ ## X: \
+    if (isnative) \
+      retval = arg.X ## _array_value ().sum (dim); \
+    else \
+      retval = arg.X ## _array_value ().dsum (dim); \
+    break;
+
+      MAKE_INT_BRANCH (int8);
+      MAKE_INT_BRANCH (int16);
+      MAKE_INT_BRANCH (int32);
+      MAKE_INT_BRANCH (int64);
+      MAKE_INT_BRANCH (uint8);
+      MAKE_INT_BRANCH (uint16);
+      MAKE_INT_BRANCH (uint32);
+      MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
 
-          // GAGME: Accursed Matlab compatibility...
-        case btyp_char:
-          if (isextra)
-            retval = arg.array_value (true).xsum (dim);
+      // GAGME: Accursed Matlab compatibility...
+    case btyp_char:
+      if (isextra)
+        retval = arg.array_value (true).xsum (dim);
+      else
+        retval = arg.array_value (true).sum (dim);
+      break;
+
+    case btyp_bool:
+      if (arg.is_sparse_type ())
+        {
+          if (isnative)
+            retval = arg.sparse_bool_matrix_value ().any (dim);
           else
-            retval = arg.array_value (true).sum (dim);
-          break;
-        case btyp_bool:
-          if (arg.is_sparse_type ())
-            {
-              if (isnative)
-                retval = arg.sparse_bool_matrix_value ().any (dim);
-              else
-                retval = arg.sparse_bool_matrix_value ().sum (dim);
-            }
-          else if (isnative)
-            retval = arg.bool_array_value ().any (dim);
-          else
-            retval = arg.bool_array_value ().sum (dim);
-          break;
-
-        default:
-          gripe_wrong_type_arg ("sum", arg);
+            retval = arg.sparse_bool_matrix_value ().sum (dim);
         }
+      else if (isnative)
+        retval = arg.bool_array_value ().any (dim);
+      else
+        retval = arg.bool_array_value ().sum (dim);
+      break;
+
+    default:
+      gripe_wrong_type_arg ("sum", arg);
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (sum ([1, 2, 3]), 6)
 %!assert (sum ([-1; -2; -3]), -6)
 %!assert (sum ([i, 2+i, -3+2i, 4]), 3+4i)
@@ -3220,24 +3187,20 @@ but it uses less memory and avoids calli
 DEFUN (islogical, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} islogical (@var{x})\n\
 @deftypefnx {Built-in Function} {} isbool (@var{x})\n\
 Return true if @var{x} is a logical object.\n\
 @seealso{isfloat, isinteger, ischar, isnumeric, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_bool_type ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_bool_type ());
 }
 
 DEFALIAS (isbool, islogical);
 
 /*
 %!assert (islogical (true), true)
 %!assert (islogical (false), true)
 %!assert (islogical ([true, false]), true)
@@ -3256,60 +3219,48 @@ DEFUN (isinteger, args, ,
 @deftypefn {Built-in Function} {} isinteger (@var{x})\n\
 Return true if @var{x} is an integer object (int8, uint8, int16, etc.).\n\
 \n\
 Note that @w{@code{isinteger (14)}} is false because numeric constants in\n\
 Octave are double precision floating point values.\n\
 @seealso{isfloat, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_integer_type ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_integer_type ());
 }
 
 DEFUN (iscomplex, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscomplex (@var{x})\n\
 Return true if @var{x} is a complex-valued numeric object.\n\
 @seealso{isreal, isnumeric, islogical, ischar, isfloat, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_complex_type ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_complex_type ());
 }
 
 DEFUN (isfloat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isfloat (@var{x})\n\
 Return true if @var{x} is a floating-point numeric object.\n\
 \n\
 Objects of class double or single are floating-point objects.\n\
 @seealso{isinteger, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_float_type ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_float_type ());
 }
 
 // FIXME: perhaps this should be implemented with an
 // octave_value member function?
 
 DEFUN (complex, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} complex (@var{x})\n\
@@ -3333,16 +3284,19 @@ complex ([1, 2], [3, 4])\n\
 @end example\n\
 @seealso{real, imag, iscomplex, abs, arg}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_complex_type ())
         retval = arg;
       else
         {
@@ -3379,17 +3333,17 @@ complex ([1, 2], [3, 4])\n\
                 {
                   ComplexNDArray val = arg.xcomplex_array_value ("complex: invalid conversion");
 
                   retval = octave_value (new octave_complex_matrix (val));
                 }
             }
         }
     }
-  else if (nargin == 2)
+  else
     {
       octave_value re = args(0);
       octave_value im = args(1);
 
       if (re.is_sparse_type () && im.is_sparse_type ())
         {
           const SparseMatrix re_val = re.sparse_matrix_value ();
           const SparseMatrix im_val = im.sparse_matrix_value ();
@@ -3570,58 +3524,48 @@ complex ([1, 2], [3, 4])\n\
                   retval = octave_value (
                                          new octave_complex_matrix (result));
                 }
               else
                 error ("complex: dimension mismatch");
             }
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (isreal, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isreal (@var{x})\n\
 Return true if @var{x} is a non-complex matrix or scalar.\n\
 \n\
 For compatibility with @sc{matlab}, this includes logical and character\n\
 matrices.\n\
 @seealso{iscomplex, isnumeric, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_real_type ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_real_type ());
 }
 
 DEFUN (isempty, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isempty (@var{a})\n\
 Return true if @var{a} is an empty matrix (any one of its dimensions is\n\
 zero).\n\
 @seealso{isnull, isa}\n\
 @end deftypefn")
 {
-  octave_value retval = false;
-
-  if (args.length () == 1)
-    retval = args(0).is_empty ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_empty ());
 }
 
 /*
 %% Debian bug #706376
 %!assert (isempty (speye(2^16)), false)
 */
 
 DEFUN (isnumeric, args, ,
@@ -3629,24 +3573,20 @@ DEFUN (isnumeric, args, ,
 @deftypefn {Built-in Function} {} isnumeric (@var{x})\n\
 Return true if @var{x} is a numeric object, i.e., an integer, real, or\n\
 complex array.\n\
 \n\
 Logical and character arrays are not considered to be numeric.\n\
 @seealso{isinteger, isfloat, isreal, iscomplex, islogical, ischar, iscell, isstruct, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_numeric_type ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_numeric_type ());
 }
 
 /*
 %!assert (isnumeric (1), true)
 %!assert (isnumeric (1i), true)
 %!assert (isnumeric ([1,1]), true)
 %!assert (isnumeric (single (1)), true)
 %!assert (isnumeric (single (1i)), true)
@@ -3662,24 +3602,20 @@ Logical and character arrays are not con
 
 DEFUN (isscalar, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isscalar (@var{x})\n\
 Return true if @var{x} is a scalar.\n\
 @seealso{isvector, ismatrix}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).numel () == 1;
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).numel () == 1);
 }
 
 /*
 %!assert (isscalar (1))
 %!assert (isscalar ([1, 2]), false)
 %!assert (isscalar ([]), false)
 %!assert (isscalar ([1, 2; 3, 4]), false)
 
@@ -3701,27 +3637,22 @@ DEFUN (isvector, args, ,
 @deftypefn {Function File} {} isvector (@var{x})\n\
 Return true if @var{x} is a vector.\n\
 \n\
 A vector is a 2-D array where one of the dimensions is equal to 1.  As a\n\
 consequence a 1x1 array, or scalar, is also a vector.\n\
 @seealso{isscalar, ismatrix, size, rows, columns, length}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      dim_vector sz = args(0).dims ();
-      retval = sz.length () == 2 && (sz(0) == 1 || sz(1) == 1);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  dim_vector sz = args(0).dims ();
+
+  return octave_value (sz.length () == 2 && (sz(0) == 1 || sz(1) == 1));
 }
 
 /*
 %!assert (isvector (1), true)
 %!assert (isvector ([1; 2; 3]), true)
 %!assert (isvector ([1, 2, 3]), true)
 %!assert (isvector ([]), false)
 %!assert (isvector ([1, 2; 3, 4]), false)
@@ -3741,27 +3672,22 @@ consequence a 1x1 array, or scalar, is a
 
 DEFUN (isrow, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Function File} {} isrow (@var{x})\n\
 Return true if @var{x} is a row vector 1xN with non-negative N.\n\
 @seealso{iscolumn, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      dim_vector sz = args(0).dims ();
-      retval = sz.length () == 2 && sz(0) == 1;
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  dim_vector sz = args(0).dims ();
+
+  return octave_value (sz.length () == 2 && sz(0) == 1);
 }
 
 /*
 %!assert (isrow ([1, 2, 3]))
 %!assert (isrow ([1; 2; 3]), false)
 %!assert (isrow (1))
 %!assert (isrow ([]), false)
 %!assert (isrow ([1, 2; 3, 4]), false)
@@ -3791,27 +3717,22 @@ Return true if @var{x} is a row vector 1
 
 DEFUN (iscolumn, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Function File} {} iscolumn (@var{x})\n\
 Return true if @var{x} is a column vector Nx1 with non-negative N.\n\
 @seealso{isrow, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      dim_vector sz = args(0).dims ();
-      retval = sz.length () == 2 && sz(1) == 1;
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  dim_vector sz = args(0).dims ();
+
+  return octave_value (sz.length () == 2 && sz(1) == 1);
 }
 
 /*
 %!assert (iscolumn ([1, 2, 3]), false)
 %!assert (iscolumn ([1; 2; 3]), true)
 %!assert (iscolumn (1), true)
 %!assert (iscolumn ([]), false)
 %!assert (iscolumn ([1, 2; 3, 4]), false)
@@ -3840,27 +3761,22 @@ Return true if @var{x} is a column vecto
 
 DEFUN (ismatrix, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
 Return true if @var{a} is a 2-D array.\n\
 @seealso{isscalar, isvector, iscell, isstruct, issparse, isa}\n\
 @end deftypefn")
 {
-  octave_value retval = false;
-
-  if (args.length () == 1)
-    {
-      dim_vector sz = args(0).dims ();
-      retval = (sz.length () == 2) && (sz(0) >= 0) && (sz(1) >= 0);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  dim_vector sz = args(0).dims ();
+
+  return octave_value (sz.length () == 2 && sz(0) >= 0 && sz(1) >= 0);
 }
 
 /*
 %!assert (ismatrix ([]), true)
 %!assert (ismatrix (1), true)
 %!assert (ismatrix ([1, 2, 3]), true)
 %!assert (ismatrix ([1, 2; 3, 4]), true)
 
@@ -3888,27 +3804,22 @@ Return true if @var{a} is a 2-D array.\n
 
 DEFUN (issquare, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Function File} {} issquare (@var{x})\n\
 Return true if @var{x} is a square matrix.\n\
 @seealso{isscalar, isvector, ismatrix, size}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      dim_vector sz = args(0).dims ();
-      retval = sz.length () == 2 && sz(0) == sz(1);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  dim_vector sz = args(0).dims ();
+
+  return octave_value (sz.length () == 2 && sz(0) == sz(1));
 }
 
 /*
 %!assert (issquare ([]))
 %!assert (issquare (1))
 %!assert (! issquare ([1, 2]))
 %!assert (issquare ([1, 2; 3, 4]))
 %!assert (! issquare ([1, 2; 3, 4; 5, 6]))
@@ -5071,43 +4982,34 @@ definitions are for compatibility with @
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
     }
 
-  switch (nargin)
+  if (nargin > 2)
+    print_usage ();
+
+  if (nargin == 0)
+    retval = identity_matrix (1, 1, dt);
+  else if (nargin == 1)
     {
-    case 0:
-      retval = identity_matrix (1, 1, dt);
-      break;
-
-    case 1:
-      {
-        octave_idx_type nr, nc;
-        get_dimensions (args(0), "eye", nr, nc);
-
-        retval = identity_matrix (nr, nc, dt);
-      }
-      break;
-
-    case 2:
-      {
-        octave_idx_type nr, nc;
-        get_dimensions (args(0), args(1), "eye", nr, nc);
-
-        retval = identity_matrix (nr, nc, dt);
-      }
-      break;
-
-    default:
-      print_usage ();
-      break;
+      octave_idx_type nr, nc;
+      get_dimensions (args(0), "eye", nr, nc);
+
+      retval = identity_matrix (nr, nc, dt);
+    }
+  else
+    {
+      octave_idx_type nr, nc;
+      get_dimensions (args(0), args(1), "eye", nr, nc);
+
+      retval = identity_matrix (nr, nc, dt);
     }
 
   return retval;
 }
 
 /*
 %!assert (full (eye (3)), [1, 0, 0; 0, 1, 0; 0, 0, 1])
 %!assert (full (eye (2, 3)), [1, 0, 0; 0, 1, 0])
@@ -5190,20 +5092,17 @@ if fewer than two values are requested.\
 {
   octave_value retval;
 
   octave_idx_type nargin = args.length ();
 
   octave_idx_type npoints = 100;
 
   if (nargin != 2 && nargin != 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (nargin == 3)
     {
       // Apparently undocumented Matlab.  If the third arg is an empty
       // numeric value, the number of points defaults to 1.
 
       octave_value arg_3 = args(2);
 
@@ -5345,18 +5244,22 @@ dimensions of the result are given by th
 \n\
 An object can be resized to more dimensions than it has;\n\
 in such case the missing dimensions are assumed to be 1.\n\
 Resizing an object to fewer dimensions is not possible.\n\
 @seealso{reshape, postpad, prepad, cat}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
 
+  if (nargin < 2)
+    print_usage ();
+
   if (nargin == 2)
     {
       Array<double> vec = args(1).vector_value ();
       int ndim = vec.numel ();
       if (ndim == 1)
         {
           octave_idx_type m = static_cast<octave_idx_type> (vec(0));
           retval = args(0);
@@ -5367,28 +5270,26 @@ Resizing an object to fewer dimensions i
           dim_vector dv;
           dv.resize (ndim);
           for (int i = 0; i < ndim; i++)
             dv(i) = static_cast<octave_idx_type> (vec(i));
           retval = args(0);
           retval = retval.resize (dv, true);
         }
     }
-  else if (nargin > 2)
+  else
     {
       dim_vector dv;
       dv.resize (nargin - 1);
       for (octave_idx_type i = 1; i < nargin; i++)
         dv(i-1) = static_cast<octave_idx_type> (args(i).scalar_value ());
 
       retval = args(0);
       retval = retval.resize (dv, true);
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 // FIXME: should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
        "-*- texinfo -*-\n\
@@ -5423,16 +5324,19 @@ will determine its size automatically.  
 the unspecified dimension.\n\
 @seealso{resize, vec, postpad, cat, squeeze}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin < 2)
+    print_usage ();
+
   dim_vector new_dims;
 
   if (nargin == 2)
     {
       Array<octave_idx_type> new_size = args(1).octave_idx_type_vector_value ();
 
       if (new_size.numel () < 2)
         {
@@ -5448,17 +5352,17 @@ the unspecified dimension.\n\
             {
               error ("reshape: SIZE must be non-negative");
               break;
             }
           else
             new_dims(i) = new_size(i);
         }
     }
-  else if (nargin > 2)
+  else
     {
       new_dims = dim_vector::alloc (nargin-1);
       int empty_dim = -1;
 
       for (int i = 1; i < nargin; i++)
         {
           if (args(i).is_empty ())
             {
@@ -5499,21 +5403,16 @@ the unspecified dimension.\n\
               if (a_nel != size_empty_dim * nel)
                 error ("reshape: SIZE is not divisible by the product of known dimensions (= %d)",
                        nel);
               else
                 new_dims(empty_dim-1) = size_empty_dim;
             }
         }
     }
-  else
-    {
-      print_usage ();
-      return retval;
-    }
 
   retval = args(0).reshape (new_dims);
 
   return retval;
 }
 
 /*
 %!assert (size (reshape (ones (4, 4), 2, 8)), [2, 8])
@@ -5610,42 +5509,34 @@ DEFUN (squeeze, args, ,
 @deftypefn {Built-in Function} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
 \n\
 Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
 @seealso{reshape}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).squeeze ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).squeeze ());
 }
 
 DEFUN (full, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{FM} =} full (@var{SM})\n\
 Return a full storage matrix from a sparse, diagonal, or permutation matrix,\n\
 or a range.\n\
 @seealso{sparse, issparse}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).full_value ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).full_value ());
 }
 
 // Compute various norms of the vector X.
 
 DEFUN (norm, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} norm (@var{A})\n\
 @deftypefnx {Built-in Function} {} norm (@var{A}, @var{p})\n\
@@ -5704,88 +5595,90 @@ Similarly, if @var{opt} is @qcode{\"colu
 compute the norms of each column and return a row vector.\n\
 @seealso{cond, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin >= 1 && nargin <= 3)
+  if (nargin < 1 && nargin > 3)
+    print_usage ();
+
+  octave_value x_arg = args(0);
+
+  if (x_arg.ndims () == 2)
     {
-      octave_value x_arg = args(0);
-
-      if (x_arg.ndims () == 2)
+      enum { sfmatrix, sfcols, sfrows, sffrob, sfinf } strflag = sfmatrix;
+      if (nargin > 1 && args(nargin-1).is_string ())
         {
-          enum { sfmatrix, sfcols, sfrows, sffrob, sfinf } strflag = sfmatrix;
-          if (nargin > 1 && args(nargin-1).is_string ())
+          std::string str = args(nargin-1).string_value ();
+          if (str == "cols" || str == "columns")
+            strflag = sfcols;
+          else if (str == "rows")
+            strflag = sfrows;
+          else if (str == "fro")
+            strflag = sffrob;
+          else if (str == "inf")
+            strflag = sfinf;
+          else
+            error ("norm: unrecognized option: %s", str.c_str ());
+          // we've handled the last parameter, so act as if it was removed
+          nargin --;
+        }
+
+      octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
+
+      if (p_arg.is_empty ())
+        p_arg = octave_value (2);
+      else if (p_arg.is_string ())
+        {
+          std::string str = p_arg.string_value ();
+          if ((strflag == sfcols || strflag == sfrows))
             {
-              std::string str = args(nargin-1).string_value ();
-              if (str == "cols" || str == "columns")
-                strflag = sfcols;
-              else if (str == "rows")
-                strflag = sfrows;
+              if (str == "cols" || str == "columns" || str == "rows")
+                error ("norm: invalid combination of options");
               else if (str == "fro")
-                strflag = sffrob;
+                p_arg = octave_value (2);
               else if (str == "inf")
-                strflag = sfinf;
+                p_arg = octave_Inf;
               else
                 error ("norm: unrecognized option: %s", str.c_str ());
-              // we've handled the last parameter, so act as if it was removed
-              nargin --;
             }
-
-          octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
-
-          if (p_arg.is_empty ())
-            p_arg = octave_value (2);
-          else if (p_arg.is_string ())
-            {
-              std::string str = p_arg.string_value ();
-              if ((strflag == sfcols || strflag == sfrows))
-                {
-                  if (str == "cols" || str == "columns" || str == "rows")
-                    error ("norm: invalid combination of options");
-                  else if (str == "fro")
-                    p_arg = octave_value (2);
-                  else if (str == "inf")
-                    p_arg = octave_Inf;
-                  else
-                    error ("norm: unrecognized option: %s", str.c_str ());
-                }
-              else
-                error ("norm: invalid combination of options");
-            }
-          else if (! p_arg.is_scalar_type ())
-            gripe_wrong_type_arg ("norm", p_arg, true);
-
-          switch (strflag)
-            {
-            case sfmatrix:
-              retval(0) = xnorm (x_arg, p_arg);
-              break;
-            case sfcols:
-              retval(0) = xcolnorms (x_arg, p_arg);
-              break;
-            case sfrows:
-              retval(0) = xrownorms (x_arg, p_arg);
-              break;
-            case sffrob:
-              retval(0) = xfrobnorm (x_arg);
-              break;
-            case sfinf:
-              retval(0) = xnorm (x_arg, octave_Inf);
-              break;
-            }
+          else
+            error ("norm: invalid combination of options");
         }
-      else
-        error ("norm: only valid for 2-D objects");
+      else if (! p_arg.is_scalar_type ())
+        gripe_wrong_type_arg ("norm", p_arg, true);
+
+      switch (strflag)
+        {
+        case sfmatrix:
+          retval(0) = xnorm (x_arg, p_arg);
+          break;
+
+        case sfcols:
+          retval(0) = xcolnorms (x_arg, p_arg);
+          break;
+
+        case sfrows:
+          retval(0) = xrownorms (x_arg, p_arg);
+          break;
+
+        case sffrob:
+          retval(0) = xfrobnorm (x_arg);
+          break;
+
+        case sfinf:
+          retval(0) = xnorm (x_arg, octave_Inf);
+          break;
+        }
     }
   else
-    print_usage ();
+    error ("norm: only valid for 2-D objects");
 
   return retval;
 }
 
 /*
 %!shared x
 %! x = [1, -3, 4, 5, -7];
 %!assert (norm (x,1), 20)
@@ -5854,23 +5747,20 @@ compute the norms of each column and ret
 %! A(2,1) = 1;
 %! assert (norm (A), 1);
 */
 
 static octave_value
 unary_op_defun_body (octave_value::unary_op op,
                      const octave_value_list& args)
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = do_unary_op (op, args(0));
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return do_unary_op (op, args(0));
 }
 
 DEFUN (not, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{z} =} not (@var{x})\n\
 Return the logical NOT of @var{x}.\n\
 \n\
 This function is equivalent to the operator syntax @w{@code{! x}}.\n\
@@ -5963,50 +5853,44 @@ This function and @tcode{x'} are equival
 
 %!assert (ctranspose (single ([1,2i;3,4])), single ([1,3;-2i,4]))
 */
 
 static octave_value
 binary_op_defun_body (octave_value::binary_op op,
                       const octave_value_list& args)
 {
-  octave_value retval;
-
-  if (args.length () == 2)
-    retval = do_binary_op (op, args(0), args(1));
-  else
+  if (args.length () != 2)
     print_usage ();
 
-  return retval;
+  return do_binary_op (op, args(0), args(1));
 }
 
 static octave_value
 binary_assoc_op_defun_body (octave_value::binary_op op,
                             octave_value::assign_op aop,
                             const octave_value_list& args)
 {
   octave_value retval;
+
   int nargin = args.length ();
 
-  switch (nargin)
+  if (nargin == 0)
+    print_usage ();
+
+  if (nargin == 1)
+    retval = args(0);
+  else if (nargin == 2)
+    retval = do_binary_op (op, args(0), args(1));
+  else
     {
-    case 0:
-      print_usage ();
-      break;
-    case 1:
-      retval = args(0);
-      break;
-    case 2:
       retval = do_binary_op (op, args(0), args(1));
-      break;
-    default:
-      retval = do_binary_op (op, args(0), args(1));
+
       for (int i = 2; i < nargin; i++)
         retval.assign (aop, args(i));
-      break;
     }
 
   return retval;
 }
 
 DEFUN (plus, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
@@ -6274,35 +6158,24 @@ DEFUN (colon, args, ,
 @deftypefnx {Built-in Function} {@var{r} =} colon (@var{base}, @var{increment}, @var{limit})\n\
 Return the result of the colon expression corresponding to @var{base},\n\
 @var{limit}, and optionally, @var{increment}.\n\
 \n\
 This function is equivalent to the operator syntax @w{@code{base : limit}}\n\
 or @w{@code{base : increment : limit}}.\n\
 @end deftypefn")
 {
-  octave_value retval;
   int nargin = args.length ();
 
-  switch (nargin)
-    {
-    case 2:
-      retval = do_colon_op (args(0), args(1));
-      break;
-
-    case 3:
-      retval = do_colon_op (args(0), args(1), args (2));
-      break;
-
-    default:
-      print_usage ();
-      break;
-    }
-
-  return retval;
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  return (nargin == 2)
+    ? do_colon_op (args(0), args(1))
+    : do_colon_op (args(0), args(1), args (2));
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} tic ()\n\
 @deftypefnx {Built-in Function} {@var{id} =} tic ()\n\
@@ -6384,46 +6257,44 @@ DEFUN (toc, args, nargout,
   octave_value retval;
 
   int nargin = args.length ();
 
   double start_time = tic_toc_timestamp;
 
   if (nargin > 1)
     print_usage ();
+
+  if (nargin == 1)
+    {
+      octave_uint64 id = args(0).xuint64_scalar_value ("toc: invalid ID");
+
+      uint64_t val = id.value ();
+
+      start_time
+        = (static_cast<double> (val / CLOCKS_PER_SEC)
+           + static_cast<double> (val % CLOCKS_PER_SEC)
+           / CLOCKS_PER_SEC);
+
+      // FIXME: should we also check to see whether the start
+      // time is after the beginning of this Octave session?
+    }
+
+  if (start_time < 0)
+    error ("toc called before timer set");
   else
     {
-      if (nargin == 1)
-        {
-          octave_uint64 id = args(0).xuint64_scalar_value ("toc: invalid ID");
-
-          uint64_t val = id.value ();
-
-          start_time
-            = (static_cast<double> (val / CLOCKS_PER_SEC)
-               + static_cast<double> (val % CLOCKS_PER_SEC)
-               / CLOCKS_PER_SEC);
-
-          // FIXME: should we also check to see whether the start
-          // time is after the beginning of this Octave session?
-        }
-
-      if (start_time < 0)
-        error ("toc called before timer set");
+      octave_time now;
+
+      double tmp = now.double_value () - start_time;
+
+      if (nargout > 0)
+        retval = tmp;
       else
-        {
-          octave_time now;
-
-          double tmp = now.double_value () - start_time;
-
-          if (nargout > 0)
-            retval = tmp;
-          else
-            octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
-        }
+        octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
     }
 
   return retval;
 }
 
 /*
 %!shared id
 %! id = tic ();
@@ -6574,79 +6445,64 @@ ordered lists.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   sortmode smode = ASCENDING;
 
   if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   bool return_idx = nargout > 1;
 
   octave_value arg = args(0);
 
   int dim = 0;
   if (nargin > 1)
     {
       if (args(1).is_string ())
         {
           std::string mode = args(1).string_value ();
           if (mode == "ascend")
             smode = ASCENDING;
           else if (mode == "descend")
             smode = DESCENDING;
           else
-            {
-              error ("sort: MODE must be either \"ascend\" or \"descend\"");
-              return retval;
-            }
+            error ("sort: MODE must be either \"ascend\" or \"descend\"");
         }
       else
         dim = args(1).nint_value () - 1;
     }
 
   if (nargin > 2)
     {
       if (args(1).is_string ())
-        {
-          print_usage ();
-          return retval;
-        }
+        error ("sort: DIM must be a valid dimension");
 
       std::string mode = args(2).xstring_value ("sort: MODE must be a string");
 
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
-        {
-          error ("sort: MODE must be either \"ascend\" or \"descend\"");
-          return retval;
-        }
+        error ("sort: MODE must be either \"ascend\" or \"descend\"");
     }
 
   const dim_vector dv = arg.dims ();
   if (nargin == 1 || args(1).is_string ())
     {
       // Find first non singleton dimension
       dim = dv.first_non_singleton ();
     }
   else
     {
       if (dim < 0)
-        {
-          error ("sort: DIM must be a valid dimension");
-          return retval;
-        }
+        error ("sort: DIM must be a valid dimension");
     }
 
   if (return_idx)
     {
       retval.resize (2);
 
       Array<octave_idx_type> sidx;
 
@@ -6846,21 +6702,21 @@ DEFUN (__sort_rows_idx__, args, ,
 Undocumented internal function.\n\
 @end deftypefn\n")
 {
   octave_value retval;
 
   int nargin = args.length ();
   sortmode smode = ASCENDING;
 
-  if (nargin < 1 || nargin > 2 || (nargin == 2 && ! args(1).is_string ()))
-    {
-      print_usage ();
-      return retval;
-    }
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  if (nargin == 2 && ! args(1).is_string ())
+    error ("__sort_rows_idx__: second argument must be a string");
 
   if (nargin > 1)
     {
       std::string mode = args(1).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
@@ -6929,20 +6785,17 @@ This function does not support sparse ma
 @seealso{sort, sortrows}\n\
 @end deftypefn\n")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   bool by_rows = false;
 
   sortmode smode = ASCENDING;
 
   if (nargin > 1)
     {
       octave_value mode_arg;
@@ -7033,79 +6886,78 @@ Programming Note: nth_element encapsulat
 algorithms nth_element and partial_sort.  On average, the complexity of the\n\
 operation is O(M*log(K)), where @w{@code{M = size (@var{x}, @var{dim})}} and\n\
 @w{@code{K = length (@var{n})}}.  This function is intended for cases where\n\
 the ratio K/M is small; otherwise, it may be better to use @code{sort}.\n\
 @seealso{sort, min, max}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  octave_value argx = args(0);
+
+  int dim = -1;
+  if (nargin == 3)
     {
-      octave_value argx = args(0);
-
-      int dim = -1;
-      if (nargin == 3)
-        {
-          dim = args(2).int_value (true) - 1;
-          if (dim < 0)
-            error ("nth_element: DIM must be a valid dimension");
-        }
+      dim = args(2).int_value (true) - 1;
       if (dim < 0)
-        dim = argx.dims ().first_non_singleton ();
-
-      try
+        error ("nth_element: DIM must be a valid dimension");
+    }
+  if (dim < 0)
+    dim = argx.dims ().first_non_singleton ();
+
+  try
+    {
+      idx_vector n = args(1).index_vector ();
+
+      switch (argx.builtin_type ())
         {
-          idx_vector n = args(1).index_vector ();
-
-          switch (argx.builtin_type ())
-            {
-            case btyp_double:
-              retval = argx.array_value ().nth_element (n, dim);
-              break;
-            case btyp_float:
-              retval = argx.float_array_value ().nth_element (n, dim);
-              break;
-            case btyp_complex:
-              retval = argx.complex_array_value ().nth_element (n, dim);
-              break;
-            case btyp_float_complex:
-              retval = argx.float_complex_array_value ().nth_element (n, dim);
-              break;
+        case btyp_double:
+          retval = argx.array_value ().nth_element (n, dim);
+          break;
+        case btyp_float:
+          retval = argx.float_array_value ().nth_element (n, dim);
+          break;
+        case btyp_complex:
+          retval = argx.complex_array_value ().nth_element (n, dim);
+          break;
+        case btyp_float_complex:
+          retval = argx.float_complex_array_value ().nth_element (n, dim);
+          break;
 #define MAKE_INT_BRANCH(X) \
-            case btyp_ ## X: \
-              retval = argx.X ## _array_value ().nth_element (n, dim); \
-              break;
-
-            MAKE_INT_BRANCH (int8);
-            MAKE_INT_BRANCH (int16);
-            MAKE_INT_BRANCH (int32);
-            MAKE_INT_BRANCH (int64);
-            MAKE_INT_BRANCH (uint8);
-            MAKE_INT_BRANCH (uint16);
-            MAKE_INT_BRANCH (uint32);
-            MAKE_INT_BRANCH (uint64);
+  case btyp_ ## X: \
+    retval = argx.X ## _array_value ().nth_element (n, dim); \
+    break;
+
+          MAKE_INT_BRANCH (int8);
+          MAKE_INT_BRANCH (int16);
+          MAKE_INT_BRANCH (int32);
+          MAKE_INT_BRANCH (int64);
+          MAKE_INT_BRANCH (uint8);
+          MAKE_INT_BRANCH (uint16);
+          MAKE_INT_BRANCH (uint32);
+          MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
-            default:
-              if (argx.is_cellstr ())
-                retval = argx.cellstr_value ().nth_element (n, dim);
-              else
-                gripe_wrong_type_arg ("nth_element", argx);
-            }
-        }
-      catch (const index_exception& e)
-        {
-          index_error ("nth_element: invalid N value %s. %s",
-                       e.idx (), e.details ());
+        default:
+          if (argx.is_cellstr ())
+            retval = argx.cellstr_value ().nth_element (n, dim);
+          else
+            gripe_wrong_type_arg ("nth_element", argx);
         }
     }
-  else
-    print_usage ();
+  catch (const index_exception& e)
+    {
+      index_error ("nth_element: invalid N value %s. %s",
+                   e.idx (), e.details ());
+    }
 
   return retval;
 }
 
 template <class NDT>
 static NDT
 do_accumarray_sum (const idx_vector& idx, const NDT& vals,
                    octave_idx_type n = -1)
@@ -7130,64 +6982,67 @@ do_accumarray_sum (const idx_vector& idx
 
 DEFUN (__accumarray_sum__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumarray_sum__ (@var{idx}, @var{vals}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
-  if (nargin >= 2 && nargin <= 3 && args(0).is_numeric_type ())
+
+  if (nargin < 2 && nargin > 3)
+    print_usage ();
+
+  if (! args(0).is_numeric_type ())
+    error ("__accumarray_sum__: first argument must be numeric");
+
+  try
     {
-      try
+      idx_vector idx = args(0).index_vector ();
+      octave_idx_type n = -1;
+      if (nargin == 3)
+        n = args(2).idx_type_value (true);
+
+      octave_value vals = args(1);
+
+      if (vals.is_range ())
         {
-          idx_vector idx = args(0).index_vector ();
-          octave_idx_type n = -1;
-          if (nargin == 3)
-            n = args(2).idx_type_value (true);
-
-          octave_value vals = args(1);
-
-          if (vals.is_range ())
-            {
-              Range r = vals.range_value ();
-              if (r.inc () == 0)
-                vals = r.base ();
-            }
-
-          if (vals.is_single_type ())
-            {
-              if (vals.is_complex_type ())
-                retval = do_accumarray_sum (idx,
-                                            vals.float_complex_array_value (),
-                                            n);
-              else
-                retval = do_accumarray_sum (idx, vals.float_array_value (), n);
-            }
-          else if (vals.is_numeric_type () || vals.is_bool_type ())
-            {
-              if (vals.is_complex_type ())
-                retval = do_accumarray_sum (idx,
-                                            vals.complex_array_value (),
-                                            n);
-              else
-                retval = do_accumarray_sum (idx, vals.array_value (), n);
-            }
+          Range r = vals.range_value ();
+          if (r.inc () == 0)
+            vals = r.base ();
+        }
+
+      if (vals.is_single_type ())
+        {
+          if (vals.is_complex_type ())
+            retval = do_accumarray_sum (idx,
+                                        vals.float_complex_array_value (),
+                                        n);
           else
-            gripe_wrong_type_arg ("accumarray", vals);
+            retval = do_accumarray_sum (idx, vals.float_array_value (), n);
         }
-      catch (const index_exception& e)
+      else if (vals.is_numeric_type () || vals.is_bool_type ())
         {
-          index_error ("__accumarray_sum__: invalid IDX %s. %s",
-                       e.idx (), e.details ());
+          if (vals.is_complex_type ())
+            retval = do_accumarray_sum (idx,
+                                        vals.complex_array_value (),
+                                        n);
+          else
+            retval = do_accumarray_sum (idx, vals.array_value (), n);
         }
+      else
+        gripe_wrong_type_arg ("accumarray", vals);
     }
-  else
-    print_usage ();
+  catch (const index_exception& e)
+    {
+      index_error ("__accumarray_sum__: invalid IDX %s. %s",
+                   e.idx (), e.details ());
+    }
 
   return retval;
 }
 
 template <class NDT>
 static NDT
 do_accumarray_minmax (const idx_vector& idx, const NDT& vals,
                       octave_idx_type n, bool ismin,
@@ -7216,82 +7071,90 @@ do_accumarray_minmax (const idx_vector& 
   return retval;
 }
 
 static octave_value_list
 do_accumarray_minmax_fun (const octave_value_list& args,
                           bool ismin)
 {
   octave_value retval;
+
   int nargin = args.length ();
-  if (nargin >= 3 && nargin <= 4 && args(0).is_numeric_type ())
+
+  if (nargin < 3 && nargin > 4)
+    print_usage ();
+
+  if (! args(0).is_numeric_type ())
+    error ("addumarray: first agument must be numeric");
+
+  try
     {
-      try
+      idx_vector idx = args(0).index_vector ();
+      octave_idx_type n = -1;
+      if (nargin == 4)
+        n = args(3).idx_type_value (true);
+
+      octave_value vals = args(1);
+      octave_value zero = args(2);
+
+      switch (vals.builtin_type ())
         {
-          idx_vector idx = args(0).index_vector ();
-          octave_idx_type n = -1;
-          if (nargin == 4)
-            n = args(3).idx_type_value (true);
-
-          octave_value vals = args(1);
-          octave_value zero = args(2);
-
-          switch (vals.builtin_type ())
-            {
-            case btyp_double:
-              retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
-                                             zero.double_value ());
-              break;
-            case btyp_float:
-              retval = do_accumarray_minmax (idx, vals.float_array_value (), n,
-                                             ismin, zero.float_value ());
-              break;
-            case btyp_complex:
-              retval = do_accumarray_minmax (idx, vals.complex_array_value (),
-                                             n, ismin, zero.complex_value ());
-              break;
-            case btyp_float_complex:
-              retval = do_accumarray_minmax (idx,
-                                             vals.float_complex_array_value (),
-                                             n, ismin,
-                                             zero.float_complex_value ());
-              break;
+        case btyp_double:
+          retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
+                                         zero.double_value ());
+          break;
+
+        case btyp_float:
+          retval = do_accumarray_minmax (idx, vals.float_array_value (), n,
+                                         ismin, zero.float_value ());
+          break;
+
+        case btyp_complex:
+          retval = do_accumarray_minmax (idx, vals.complex_array_value (),
+                                         n, ismin, zero.complex_value ());
+          break;
+
+        case btyp_float_complex:
+          retval = do_accumarray_minmax (idx,
+                                         vals.float_complex_array_value (),
+                                         n, ismin,
+                                         zero.float_complex_value ());
+          break;
+
 #define MAKE_INT_BRANCH(X) \
-              case btyp_ ## X: \
-                retval = do_accumarray_minmax (idx, vals.X ## _array_value (), \
-                                               n, ismin, \
-                                               zero.X ## _scalar_value ()); \
-                break;
-
-              MAKE_INT_BRANCH (int8);
-              MAKE_INT_BRANCH (int16);
-              MAKE_INT_BRANCH (int32);
-              MAKE_INT_BRANCH (int64);
-              MAKE_INT_BRANCH (uint8);
-              MAKE_INT_BRANCH (uint16);
-              MAKE_INT_BRANCH (uint32);
-              MAKE_INT_BRANCH (uint64);
+  case btyp_ ## X: \
+    retval = do_accumarray_minmax (idx, vals.X ## _array_value (), \
+                                   n, ismin, zero.X ## _scalar_value ()); \
+            break;
+
+          MAKE_INT_BRANCH (int8);
+          MAKE_INT_BRANCH (int16);
+          MAKE_INT_BRANCH (int32);
+          MAKE_INT_BRANCH (int64);
+          MAKE_INT_BRANCH (uint8);
+          MAKE_INT_BRANCH (uint16);
+          MAKE_INT_BRANCH (uint32);
+          MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
-            case btyp_bool:
-              retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
-                                             zero.bool_value ());
-              break;
-            default:
-              gripe_wrong_type_arg ("accumarray", vals);
-            }
+
+        case btyp_bool:
+          retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
+                                         zero.bool_value ());
+          break;
+
+        default:
+          gripe_wrong_type_arg ("accumarray", vals);
         }
-      catch (const index_exception& e)
-        {
-          index_error ("do_accumarray_minmax_fun: invalid index %s. %s",
-                       e.idx (), e.details ());
-        }
-
     }
-  else
-    print_usage ();
+  catch (const index_exception& e)
+    {
+      index_error ("do_accumarray_minmax_fun: invalid index %s. %s",
+                   e.idx (), e.details ());
+    }
 
   return retval;
 }
 
 DEFUN (__accumarray_min__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumarray_min__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
@@ -7342,61 +7205,64 @@ do_accumdim_sum (const idx_vector& idx, 
 
 DEFUN (__accumdim_sum__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
-  if (nargin >= 2 && nargin <= 4 && args(0).is_numeric_type ())
+
+  if (nargin < 2 && nargin > 4)
+    print_usage ();
+
+  if (! args(0).is_numeric_type ())
+    error ("__accumdim_sum__: first argument must be numeric");
+
+  try
     {
-      try
+      idx_vector idx = args(0).index_vector ();
+      int dim = -1;
+      if (nargin >= 3)
+        dim = args(2).int_value () - 1;
+
+      octave_idx_type n = -1;
+      if (nargin == 4)
+        n = args(3).idx_type_value (true);
+
+      octave_value vals = args(1);
+
+      if (vals.is_single_type ())
         {
-          idx_vector idx = args(0).index_vector ();
-          int dim = -1;
-          if (nargin >= 3)
-            dim = args(2).int_value () - 1;
-
-          octave_idx_type n = -1;
-          if (nargin == 4)
-            n = args(3).idx_type_value (true);
-
-          octave_value vals = args(1);
-
-          if (vals.is_single_type ())
-            {
-              if (vals.is_complex_type ())
-                retval = do_accumdim_sum (idx,
-                                          vals.float_complex_array_value (),
-                                          dim, n);
-              else
-                retval = do_accumdim_sum (idx, vals.float_array_value (),
-                                          dim, n);
-            }
-          else if (vals.is_numeric_type () || vals.is_bool_type ())
-            {
-              if (vals.is_complex_type ())
-                retval = do_accumdim_sum (idx, vals.complex_array_value (),
-                                          dim, n);
-              else
-                retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
-            }
+          if (vals.is_complex_type ())
+            retval = do_accumdim_sum (idx,
+                                      vals.float_complex_array_value (),
+                                      dim, n);
           else
-            gripe_wrong_type_arg ("accumdim", vals);
+            retval = do_accumdim_sum (idx, vals.float_array_value (),
+                                      dim, n);
         }
-      catch (const index_exception& e)
+      else if (vals.is_numeric_type () || vals.is_bool_type ())
         {
-          index_error ("__accumdim_sum__: invalid IDX %s. %s",
-                       e.idx (), e.details ());
+          if (vals.is_complex_type ())
+            retval = do_accumdim_sum (idx, vals.complex_array_value (),
+                                      dim, n);
+          else
+            retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
         }
+      else
+        gripe_wrong_type_arg ("accumdim", vals);
     }
-  else
-    print_usage ();
+  catch (const index_exception& e)
+    {
+      index_error ("__accumdim_sum__: invalid IDX %s. %s",
+                   e.idx (), e.details ());
+    }
 
   return retval;
 }
 
 template <class NDT>
 static NDT
 do_merge (const Array<bool>& mask,
           const NDT& tval, const NDT& fval)
@@ -7487,84 +7353,86 @@ result(! mask) = fval(! mask);\n\
 @end group\n\
 @end example\n\
 \n\
 @var{mask} can also be arbitrary numeric type, in which case it is first\n\
 converted to logical.\n\
 @seealso{logical, diff}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
   octave_value retval;
 
-  if (nargin == 3 && (args(0).is_bool_type () || args(0).is_numeric_type ()))
+  if (args.length () != 3)
+    print_usage ();
+
+  if (! (args(0).is_bool_type () || args(0).is_numeric_type ()))
+    error ("merge: first argument must be logical or numeric");
+
+  octave_value mask_val = args(0);
+
+  if (mask_val.is_scalar_type ())
+    retval = mask_val.is_true () ? args(1) : args(2);
+  else
     {
-      octave_value mask_val = args(0);
-
-      if (mask_val.is_scalar_type ())
-        retval = mask_val.is_true () ? args(1) : args(2);
-      else
+      boolNDArray mask = mask_val.bool_array_value ();
+
+      octave_value tval = args(1);
+      octave_value fval = args(2);
+
+      if (tval.is_double_type () && fval.is_double_type ())
+        {
+          if (tval.is_complex_type () || fval.is_complex_type ())
+            retval = do_merge (mask,
+                               tval.complex_array_value (),
+                               fval.complex_array_value ());
+          else
+            retval = do_merge (mask,
+                               tval.array_value (),
+                               fval.array_value ());
+        }
+      else if (tval.is_single_type () && fval.is_single_type ())
         {
-          boolNDArray mask = mask_val.bool_array_value ();
-          octave_value tval = args(1);
-          octave_value fval = args(2);
-          if (tval.is_double_type () && fval.is_double_type ())
-            {
-              if (tval.is_complex_type () || fval.is_complex_type ())
-                retval = do_merge (mask,
-                                   tval.complex_array_value (),
-                                   fval.complex_array_value ());
-              else
-                retval = do_merge (mask,
-                                   tval.array_value (),
-                                   fval.array_value ());
-            }
-          else if (tval.is_single_type () && fval.is_single_type ())
-            {
-              if (tval.is_complex_type () || fval.is_complex_type ())
-                retval = do_merge (mask,
-                                   tval.float_complex_array_value (),
-                                   fval.float_complex_array_value ());
-              else
-                retval = do_merge (mask,
-                                   tval.float_array_value (),
-                                   fval.float_array_value ());
-            }
-          else if (tval.is_string () && fval.is_string ())
-            {
-              bool sq_string = tval.is_sq_string () || fval.is_sq_string ();
-              retval = octave_value (do_merge (mask,
-                                               tval.char_array_value (),
-                                               fval.char_array_value ()),
-                                     sq_string ? '\'' : '"');
-            }
-          else if (tval.is_cell () && fval.is_cell ())
-            {
-              retval = do_merge (mask,
-                                 tval.cell_value (),
-                                 fval.cell_value ());
-            }
-
-          MAKE_INT_BRANCH (int8)
-          MAKE_INT_BRANCH (int16)
-          MAKE_INT_BRANCH (int32)
-          MAKE_INT_BRANCH (int64)
-          MAKE_INT_BRANCH (uint8)
-          MAKE_INT_BRANCH (uint16)
-          MAKE_INT_BRANCH (uint32)
-          MAKE_INT_BRANCH (uint64)
-
+          if (tval.is_complex_type () || fval.is_complex_type ())
+            retval = do_merge (mask,
+                               tval.float_complex_array_value (),
+                               fval.float_complex_array_value ());
           else
-            error ("merge: cannot merge %s with %s with array mask",
-                   tval.class_name ().c_str (),
-                   fval.class_name ().c_str ());
+            retval = do_merge (mask,
+                               tval.float_array_value (),
+                               fval.float_array_value ());
+        }
+      else if (tval.is_string () && fval.is_string ())
+        {
+          bool sq_string = tval.is_sq_string () || fval.is_sq_string ();
+          retval = octave_value (do_merge (mask,
+                                           tval.char_array_value (),
+                                           fval.char_array_value ()),
+                                 sq_string ? '\'' : '"');
         }
+      else if (tval.is_cell () && fval.is_cell ())
+        {
+          retval = do_merge (mask,
+                             tval.cell_value (),
+                             fval.cell_value ());
+        }
+
+        MAKE_INT_BRANCH (int8)
+        MAKE_INT_BRANCH (int16)
+        MAKE_INT_BRANCH (int32)
+        MAKE_INT_BRANCH (int64)
+        MAKE_INT_BRANCH (uint8)
+        MAKE_INT_BRANCH (uint16)
+        MAKE_INT_BRANCH (uint32)
+        MAKE_INT_BRANCH (uint64)
+
+      else
+        error ("merge: cannot merge %s with %s with array mask",
+               tval.class_name ().c_str (),
+               fval.class_name ().c_str ());
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFALIAS (ifelse, merge);
 
 #undef MAKE_INT_BRANCH
 
@@ -7719,22 +7587,24 @@ non-singleton dimension.\n\
 The dimension along which to take the difference can be explicitly\n\
 stated with the optional variable @var{dim}.  In this case the\n\
 @var{k}-th order differences are calculated along this dimension.\n\
 In the case where @var{k} exceeds @w{@code{size (@var{x}, @var{dim})}}\n\
 an empty matrix is returned.\n\
 @seealso{sort, merge}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
   int nargin = args.length ();
-  octave_value retval;
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
-  else if (! (args(0).is_numeric_type () || args(0).is_bool_type ()))
+
+  if (! (args(0).is_numeric_type () || args(0).is_bool_type ()))
     error ("diff: X must be numeric or logical");
 
   int dim = -1;
   octave_idx_type order = 1;
   if (nargin > 1)
     {
       if (args(1).is_scalar_type ())
         order = args(1).idx_type_value (true, false);
