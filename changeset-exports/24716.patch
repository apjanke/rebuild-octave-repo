# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1518202594 18000
#      Fri Feb 09 13:56:34 2018 -0500
# Node ID 2b3e0b570e7729386f138799ca9200b637fa99bf
# Parent  88bb3f086d9a24041ad462022a04407a07cb382d
move GUI file editor classes inside octave namespace

* file-editor-interface.h, file-editor-tab.cc, file-editor-tab.h,
file-editor.cc, file-editor.h, find-dialog.cc, find-dialog.h,
marker.cc, marker.h, octave-qscintilla.cc, octave-qscintilla.h,
octave-txt-lexer.cc, octave-txt-lexer.h:
Move classes inside octave namespace.

* main-window.cc, settings-dialog.cc: Update to namespace changes.

diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -23,64 +23,67 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_file_editor_interface_h)
 #define octave_file_editor_interface_h 1
 
 #include <QMenu>
 #include <QToolBar>
 #include <QSettings>
 #include "octave-dock-widget.h"
 
-class file_editor_interface : public octave_dock_widget
+namespace octave
 {
-  Q_OBJECT
-
-public:
+  class file_editor_interface : public octave_dock_widget
+  {
+    Q_OBJECT
 
-  file_editor_interface (QWidget *p)
-    : octave_dock_widget (p)
-  {
-    setObjectName ("FileEditor");
-  }
+  public:
 
-  virtual ~file_editor_interface (void) = default;
+    file_editor_interface (QWidget *p)
+      : octave_dock_widget (p)
+    {
+      setObjectName ("FileEditor");
+    }
 
-  virtual QMenu * get_mru_menu (void) = 0;
-  virtual QMenu * debug_menu (void) = 0;
-  virtual QToolBar * toolbar (void) = 0;
+    virtual ~file_editor_interface (void) = default;
 
-  virtual void insert_global_actions (QList<QAction*>) = 0;
-  virtual void handle_enter_debug_mode (void) = 0;
-  virtual void handle_exit_debug_mode (void) = 0;
+    virtual QMenu * get_mru_menu (void) = 0;
+    virtual QMenu * debug_menu (void) = 0;
+    virtual QToolBar * toolbar (void) = 0;
 
-  virtual void
-  handle_insert_debugger_pointer_request (const QString& file, int line) = 0;
+    virtual void insert_global_actions (QList<QAction*>) = 0;
+    virtual void handle_enter_debug_mode (void) = 0;
+    virtual void handle_exit_debug_mode (void) = 0;
+
+    virtual void
+    handle_insert_debugger_pointer_request (const QString& file, int line) = 0;
 
-  virtual void
-  handle_delete_debugger_pointer_request (const QString& file, int line) = 0;
+    virtual void
+    handle_delete_debugger_pointer_request (const QString& file, int line) = 0;
 
-  virtual void
-  handle_update_breakpoint_marker_request (bool insert, const QString& file,
-                                           int line, const QString& cond) = 0;
+    virtual void
+    handle_update_breakpoint_marker_request (bool insert, const QString& file,
+                                             int line, const QString& cond) = 0;
 
-  virtual void handle_edit_file_request (const QString& file) = 0;
+    virtual void handle_edit_file_request (const QString& file) = 0;
 
-  virtual bool check_closing (void) = 0;
+    virtual bool check_closing (void) = 0;
 
-  virtual void empty_script (bool, bool) = 0;
+    virtual void empty_script (bool, bool) = 0;
 
-  virtual void restore_session (QSettings *) = 0;
+    virtual void restore_session (QSettings *) = 0;
 
-  virtual void enable_menu_shortcuts (bool enable) = 0;
+    virtual void enable_menu_shortcuts (bool enable) = 0;
 
-public slots:
+  public slots:
 
-  virtual void request_new_file (const QString& command = QString ()) = 0;
+    virtual void request_new_file (const QString& command = QString ()) = 0;
 
-  virtual void request_open_file (const QString& openFileName,
-                                  const QString& encoding = QString (),
-                                  int line = -1,
-                                  bool debug_pointer = false,
-                                  bool breakpoint_marker = false,
-                                  bool insert = true,
-                                  const QString& cond = "") = 0;
-};
+    virtual void request_open_file (const QString& openFileName,
+                                    const QString& encoding = QString (),
+                                    int line = -1,
+                                    bool debug_pointer = false,
+                                    bool breakpoint_marker = false,
+                                    bool insert = true,
+                                    const QString& cond = "") = 0;
+  };
+}
 
 #endif
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -77,3002 +77,2911 @@ along with Octave; see the file COPYING.
 #include "octave-qt-link.h"
 #include "ov-usr-fcn.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "version.h"
 #include "octave-settings.h"
 
-bool file_editor_tab::_cancelled = false;
-
-//! A file_editor_tab object consists of a text area and three left margins.
-//! The first holds breakpoints, bookmarks, and the debug program counter.
-//! The second holds line numbers.  The third holds "fold" marks, to hide
-//! sections of text.
-
-// Make parent null for the file editor tab so that warning WindowModal
-// messages don't affect grandparents.
-file_editor_tab::file_editor_tab (const QString& directory_arg)
+namespace octave
 {
-  _lexer_apis = nullptr;
-  _is_octave_file = true;
-  _lines_changed = false;
-
-  _ced = directory_arg;
-
-  _file_name = "";
-  _file_system_watcher.setObjectName ("_qt_autotest_force_engine_poller");
-
-  _edit_area = new octave_qscintilla (this);
-  _line = 0;
-  _col  = 0;
-
-  _bp_lines.clear ();      // start with empty lists of breakpoints
-  _bp_conditions.clear ();
-  m_bp_restore_count = 0;
-
-  // disable editor drag & drop so parent can handle
-  _edit_area->setAcceptDrops (false);
-
-  connect (_edit_area, SIGNAL (cursorPositionChanged (int, int)),
-           this, SLOT (handle_cursor_moved (int,int)));
-
-  connect (_edit_area, SIGNAL (SCN_CHARADDED (int)),
-           this, SLOT (handle_char_added (int)));
-
-  connect (_edit_area, SIGNAL (SCN_DOUBLECLICK (int, int, int)),
-           this, SLOT (handle_double_click (int, int, int)));
-
-  connect (_edit_area, SIGNAL (linesChanged ()),
-           this, SLOT (handle_lines_changed ()));
-
-  connect (_edit_area, SIGNAL (context_menu_edit_signal (const QString&)),
-           this, SLOT (handle_context_menu_edit (const QString&)));
-
-  // create statusbar for row/col indicator and eol mode
-  _status_bar = new QStatusBar (this);
-
-  // row- and col-indicator
-  _row_indicator = new QLabel ("", this);
-  QFontMetrics fm = _row_indicator->fontMetrics ();
-  _row_indicator->setMinimumSize (4.5*fm.averageCharWidth (),0);
-  QLabel *row_label = new QLabel (tr ("line:"), this);
-  _col_indicator = new QLabel ("", this);
-  _col_indicator->setMinimumSize (4*fm.averageCharWidth (),0);
-  QLabel *col_label = new QLabel (tr ("col:"), this);
-  _status_bar->addWidget (row_label, 0);
-  _status_bar->addWidget (_row_indicator, 0);
-  _status_bar->addWidget (col_label, 0);
-  _status_bar->addWidget (_col_indicator, 0);
-
-  // status bar: encoding
-  QLabel *enc_label = new QLabel (tr ("encoding:"), this);
-  _enc_indicator = new QLabel ("",this);
-  _status_bar->addWidget (enc_label, 0);
-  _status_bar->addWidget (_enc_indicator, 0);
-  _status_bar->addWidget (new QLabel (" ", this), 0);
-
-  // status bar: eol mode
-  QLabel *eol_label = new QLabel (tr ("eol:"), this);
-  _eol_indicator = new QLabel ("",this);
-  _status_bar->addWidget (eol_label, 0);
-  _status_bar->addWidget (_eol_indicator, 0);
-  _status_bar->addWidget (new QLabel (" ", this), 0);
-
-  // Leave the find dialog box out of memory until requested.
-  _find_dialog = nullptr;
-  _find_dialog_is_visible = false;
-
-  // symbols
-  _edit_area->setMarginType (1, QsciScintilla::SymbolMargin);
-  _edit_area->setMarginSensitivity (1, true);
-  _edit_area->markerDefine (QsciScintilla::RightTriangle, marker::bookmark);
-  _edit_area->setMarkerBackgroundColor (QColor (0,0,232), marker::bookmark);
-  _edit_area->markerDefine (QsciScintilla::Circle, marker::breakpoint);
-  _edit_area->setMarkerBackgroundColor (QColor (192,0,0), marker::breakpoint);
-  _edit_area->markerDefine (QsciScintilla::Circle, marker::cond_break);
-  _edit_area->setMarkerBackgroundColor (QColor (255,127,0), marker::cond_break);
-  _edit_area->markerDefine (QsciScintilla::RightArrow, marker::debugger_position);
-  _edit_area->setMarkerBackgroundColor (QColor (255,255,0),
-                                        marker::debugger_position);
-  _edit_area->markerDefine (QsciScintilla::RightArrow,
-                            marker::unsure_debugger_position);
-  _edit_area->setMarkerBackgroundColor (QColor (192,192,192),
-                                        marker::unsure_debugger_position);
-
-  connect (_edit_area, SIGNAL (marginClicked (int, int,
-                                              Qt::KeyboardModifiers)),
-           this, SLOT (handle_margin_clicked (int, int,
-                                              Qt::KeyboardModifiers)));
-
-  connect (_edit_area, SIGNAL (context_menu_break_condition_signal (int)),
-           this, SLOT (handle_context_menu_break_condition (int)));
-
-  // line numbers
-  _edit_area->setMarginsForegroundColor (QColor (96, 96, 96));
-  _edit_area->setMarginsBackgroundColor (QColor (232, 232, 220));
-  _edit_area->setMarginType (2, QsciScintilla::TextMargin);
-
-  // other features
-  _edit_area->setBraceMatching (QsciScintilla::StrictBraceMatch);
-  _edit_area->setAutoIndent (true);
-  _edit_area->setIndentationWidth (2);
-  _edit_area->setIndentationsUseTabs (false);
-
-  _edit_area->setUtf8 (true);
-
-  // auto completion
-  _edit_area->SendScintilla (QsciScintillaBase::SCI_AUTOCSETCANCELATSTART, false);
-
-  QVBoxLayout *edit_area_layout = new QVBoxLayout ();
-  edit_area_layout->addWidget (_edit_area);
-  edit_area_layout->addWidget (_status_bar);
-  edit_area_layout->setMargin (0);
-  setLayout (edit_area_layout);
-
-  // connect modified signal
-  connect (_edit_area, SIGNAL (modificationChanged (bool)),
-           this, SLOT (update_window_title (bool)));
-
-  connect (_edit_area, SIGNAL (copyAvailable (bool)),
-           this, SLOT (handle_copy_available (bool)));
-
-  connect (&_file_system_watcher, SIGNAL (fileChanged (const QString&)),
-           this, SLOT (file_has_changed (const QString&)));
-
-  QSettings *settings = resource_manager::get_settings ();
-  if (settings)
-    notice_settings (settings, true);
-
-  setFocusProxy (_edit_area);
-
-  // encoding, not updated with the settings
+  bool file_editor_tab::_cancelled = false;
+
+  //! A file_editor_tab object consists of a text area and three left margins.
+  //! The first holds breakpoints, bookmarks, and the debug program counter.
+  //! The second holds line numbers.  The third holds "fold" marks, to hide
+  //! sections of text.
+
+  // Make parent null for the file editor tab so that warning WindowModal
+  // messages don't affect grandparents.
+  file_editor_tab::file_editor_tab (const QString& directory_arg)
+  {
+    _lexer_apis = nullptr;
+    _is_octave_file = true;
+    _lines_changed = false;
+
+    _ced = directory_arg;
+
+    _file_name = "";
+    _file_system_watcher.setObjectName ("_qt_autotest_force_engine_poller");
+
+    _edit_area = new octave_qscintilla (this);
+    _line = 0;
+    _col  = 0;
+
+    _bp_lines.clear ();      // start with empty lists of breakpoints
+    _bp_conditions.clear ();
+    m_bp_restore_count = 0;
+
+    // disable editor drag & drop so parent can handle
+    _edit_area->setAcceptDrops (false);
+
+    connect (_edit_area, SIGNAL (cursorPositionChanged (int, int)),
+             this, SLOT (handle_cursor_moved (int,int)));
+
+    connect (_edit_area, SIGNAL (SCN_CHARADDED (int)),
+             this, SLOT (handle_char_added (int)));
+
+    connect (_edit_area, SIGNAL (SCN_DOUBLECLICK (int, int, int)),
+             this, SLOT (handle_double_click (int, int, int)));
+
+    connect (_edit_area, SIGNAL (linesChanged ()),
+             this, SLOT (handle_lines_changed ()));
+
+    connect (_edit_area, SIGNAL (context_menu_edit_signal (const QString&)),
+             this, SLOT (handle_context_menu_edit (const QString&)));
+
+    // create statusbar for row/col indicator and eol mode
+    _status_bar = new QStatusBar (this);
+
+    // row- and col-indicator
+    _row_indicator = new QLabel ("", this);
+    QFontMetrics fm = _row_indicator->fontMetrics ();
+    _row_indicator->setMinimumSize (4.5*fm.averageCharWidth (),0);
+    QLabel *row_label = new QLabel (tr ("line:"), this);
+    _col_indicator = new QLabel ("", this);
+    _col_indicator->setMinimumSize (4*fm.averageCharWidth (),0);
+    QLabel *col_label = new QLabel (tr ("col:"), this);
+    _status_bar->addWidget (row_label, 0);
+    _status_bar->addWidget (_row_indicator, 0);
+    _status_bar->addWidget (col_label, 0);
+    _status_bar->addWidget (_col_indicator, 0);
+
+    // status bar: encoding
+    QLabel *enc_label = new QLabel (tr ("encoding:"), this);
+    _enc_indicator = new QLabel ("",this);
+    _status_bar->addWidget (enc_label, 0);
+    _status_bar->addWidget (_enc_indicator, 0);
+    _status_bar->addWidget (new QLabel (" ", this), 0);
+
+    // status bar: eol mode
+    QLabel *eol_label = new QLabel (tr ("eol:"), this);
+    _eol_indicator = new QLabel ("",this);
+    _status_bar->addWidget (eol_label, 0);
+    _status_bar->addWidget (_eol_indicator, 0);
+    _status_bar->addWidget (new QLabel (" ", this), 0);
+
+    // Leave the find dialog box out of memory until requested.
+    _find_dialog = nullptr;
+    _find_dialog_is_visible = false;
+
+    // symbols
+    _edit_area->setMarginType (1, QsciScintilla::SymbolMargin);
+    _edit_area->setMarginSensitivity (1, true);
+    _edit_area->markerDefine (QsciScintilla::RightTriangle, marker::bookmark);
+    _edit_area->setMarkerBackgroundColor (QColor (0,0,232), marker::bookmark);
+    _edit_area->markerDefine (QsciScintilla::Circle, marker::breakpoint);
+    _edit_area->setMarkerBackgroundColor (QColor (192,0,0), marker::breakpoint);
+    _edit_area->markerDefine (QsciScintilla::Circle, marker::cond_break);
+    _edit_area->setMarkerBackgroundColor (QColor (255,127,0), marker::cond_break);
+    _edit_area->markerDefine (QsciScintilla::RightArrow, marker::debugger_position);
+    _edit_area->setMarkerBackgroundColor (QColor (255,255,0),
+                                          marker::debugger_position);
+    _edit_area->markerDefine (QsciScintilla::RightArrow,
+                              marker::unsure_debugger_position);
+    _edit_area->setMarkerBackgroundColor (QColor (192,192,192),
+                                          marker::unsure_debugger_position);
+
+    connect (_edit_area, SIGNAL (marginClicked (int, int,
+                                                Qt::KeyboardModifiers)),
+             this, SLOT (handle_margin_clicked (int, int,
+                                                Qt::KeyboardModifiers)));
+
+    connect (_edit_area, SIGNAL (context_menu_break_condition_signal (int)),
+             this, SLOT (handle_context_menu_break_condition (int)));
+
+    // line numbers
+    _edit_area->setMarginsForegroundColor (QColor (96, 96, 96));
+    _edit_area->setMarginsBackgroundColor (QColor (232, 232, 220));
+    _edit_area->setMarginType (2, QsciScintilla::TextMargin);
+
+    // other features
+    _edit_area->setBraceMatching (QsciScintilla::StrictBraceMatch);
+    _edit_area->setAutoIndent (true);
+    _edit_area->setIndentationWidth (2);
+    _edit_area->setIndentationsUseTabs (false);
+
+    _edit_area->setUtf8 (true);
+
+    // auto completion
+    _edit_area->SendScintilla (QsciScintillaBase::SCI_AUTOCSETCANCELATSTART, false);
+
+    QVBoxLayout *edit_area_layout = new QVBoxLayout ();
+    edit_area_layout->addWidget (_edit_area);
+    edit_area_layout->addWidget (_status_bar);
+    edit_area_layout->setMargin (0);
+    setLayout (edit_area_layout);
+
+    // connect modified signal
+    connect (_edit_area, SIGNAL (modificationChanged (bool)),
+             this, SLOT (update_window_title (bool)));
+
+    connect (_edit_area, SIGNAL (copyAvailable (bool)),
+             this, SLOT (handle_copy_available (bool)));
+
+    connect (&_file_system_watcher, SIGNAL (fileChanged (const QString&)),
+             this, SLOT (file_has_changed (const QString&)));
+
+    QSettings *settings = resource_manager::get_settings ();
+    if (settings)
+      notice_settings (settings, true);
+
+    setFocusProxy (_edit_area);
+
+    // encoding, not updated with the settings
 #if defined (Q_OS_WIN32)
-  _encoding = settings->value ("editor/default_encoding", "SYSTEM")
-                               .toString ();
+    _encoding = settings->value ("editor/default_encoding", "SYSTEM")
+      .toString ();
 #else
-  _encoding = settings->value ("editor/default_encoding", "UTF-8")
-                               .toString ();
+    _encoding = settings->value ("editor/default_encoding", "UTF-8")
+      .toString ();
 #endif
-  _enc_indicator->setText (_encoding);
-  // no changes in encoding yet
-  _new_encoding = _encoding;
-}
-
-file_editor_tab::~file_editor_tab (void)
-{
-  // Tell all connected markers to self-destruct.
-  emit remove_all_breakpoints ();
-  emit remove_all_positions ();
-
-  // Destroy items attached to _edit_area.
-  QsciLexer *lexer = _edit_area->lexer ();
-  if (lexer)
-    {
-      delete lexer;
-      _edit_area->setLexer (nullptr);
-    }
-  if (_find_dialog)
-    {
-      delete _find_dialog;
-      _find_dialog = nullptr;
-    }
-
-  // Destroy _edit_area.
-  delete _edit_area;
-}
-
-void
-file_editor_tab::set_encoding (const QString& new_encoding)
-{
-  if (new_encoding.isEmpty ())
-    return;
-
-  _encoding = new_encoding;
-  _enc_indicator->setText (_encoding);
-  if (! _edit_area->text ().isEmpty ())
-    set_modified (true);
-}
-
-void
-file_editor_tab::closeEvent (QCloseEvent *e)
-{
-  _cancelled = false;  // prevent unwanted interaction of previous
-                       // exits of octave which were canceled by the user
-
-  if (check_file_modified () == QMessageBox::Cancel)
-    {
-      // ignore close event if file is not saved and user cancels
-      // closing this window
-      e->ignore ();
-    }
-  else
-    {
-      e->accept ();
-      emit tab_remove_request ();
-    }
-}
-
-void
-file_editor_tab::set_current_directory (const QString& dir)
-{
-  _ced = dir;
-}
-
-void
-file_editor_tab::handle_context_menu_edit (const QString& word_at_cursor)
-{
-  // search for a subfunction in actual file (this is done at first because
-  // octave finds this function before other with same name in the search path
-  QRegExp rxfun1 ("^[\t ]*function[^=]+=[\t ]*"
-                  + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
-  QRegExp rxfun2 ("^[\t ]*function[\t ]+"
-                  + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
-  QRegExp rxfun3 ("^[\t ]*function[\t ]+"
-                  + word_at_cursor + "[\t ]*$");
-  QRegExp rxfun4 ("^[\t ]*function[^=]+=[\t ]*"
-                  + word_at_cursor + "[\t ]*$");
-
-  int pos_fct = -1;
-  QStringList lines = _edit_area->text ().split ("\n");
-
-  int line;
-  for (line = 0; line < lines.count (); line++)
-    {
-      if ((pos_fct = rxfun1.indexIn (lines.at (line))) != -1)
-        break;
-      if ((pos_fct = rxfun2.indexIn (lines.at (line))) != -1)
-        break;
-      if ((pos_fct = rxfun3.indexIn (lines.at (line))) != -1)
-        break;
-      if ((pos_fct = rxfun4.indexIn (lines.at (line))) != -1)
-        break;
-    }
-
-  if (pos_fct > -1)
-    {
-      // reg expr. found: it is an internal function
-      _edit_area->setCursorPosition (line, pos_fct);
-      _edit_area->SendScintilla (2232, line);     // SCI_ENSUREVISIBLE
-                                                  // SCI_VISIBLEFROMDOCLINE
-      int vis_line = _edit_area->SendScintilla (2220, line);
-      _edit_area->SendScintilla (2613, vis_line); // SCI_SETFIRSTVISIBLELINE
+    _enc_indicator->setText (_encoding);
+    // no changes in encoding yet
+    _new_encoding = _encoding;
+  }
+
+  file_editor_tab::~file_editor_tab (void)
+  {
+    // Tell all connected markers to self-destruct.
+    emit remove_all_breakpoints ();
+    emit remove_all_positions ();
+
+    // Destroy items attached to _edit_area.
+    QsciLexer *lexer = _edit_area->lexer ();
+    if (lexer)
+      {
+        delete lexer;
+        _edit_area->setLexer (nullptr);
+      }
+    if (_find_dialog)
+      {
+        delete _find_dialog;
+        _find_dialog = nullptr;
+      }
+
+    // Destroy _edit_area.
+    delete _edit_area;
+  }
+
+  void file_editor_tab::set_encoding (const QString& new_encoding)
+  {
+    if (new_encoding.isEmpty ())
       return;
-    }
-
-  emit edit_mfile_request (word_at_cursor, _file_name, _ced, -1);
-}
-
-// If "dbstop if ..." selected from context menu, create a conditional
-// breakpoint.  The default condition is (a) the existing condition if there
-// is already a breakpoint (b) any selected text, or (c) empty
-void
-file_editor_tab::handle_context_menu_break_condition (int linenr)
-{
-  // Ensure editor line numbers match Octave core's line numbers.
-  // Give users the option to save modifications if necessary.
-  if (! unchanged_or_saved ())
-    return;
-
-  QString cond;
-  bp_info info (_file_name, linenr+1); // Get function name & dir from filename.
-
-  // Search for previous condition.  FIXME: is there a more direct way?
-  if (_edit_area->markersAtLine (linenr) & (1 << marker::cond_break))
-    {
-      emit report_marker_linenr (_bp_lines, _bp_conditions);
-      for (int i = 0; i < _bp_lines.length (); i++)
-        if (_bp_lines.value (i) == linenr)
+
+    _encoding = new_encoding;
+    _enc_indicator->setText (_encoding);
+    if (! _edit_area->text ().isEmpty ())
+      set_modified (true);
+  }
+
+  void file_editor_tab::closeEvent (QCloseEvent *e)
+  {
+    _cancelled = false;  // prevent unwanted interaction of previous
+    // exits of octave which were canceled by the user
+
+    if (check_file_modified () == QMessageBox::Cancel)
+      {
+        // ignore close event if file is not saved and user cancels
+        // closing this window
+        e->ignore ();
+      }
+    else
+      {
+        e->accept ();
+        emit tab_remove_request ();
+      }
+  }
+
+  void file_editor_tab::set_current_directory (const QString& dir)
+  {
+    _ced = dir;
+  }
+
+  void file_editor_tab::handle_context_menu_edit (const QString& word_at_cursor)
+  {
+    // search for a subfunction in actual file (this is done at first because
+    // octave finds this function before other with same name in the search path
+    QRegExp rxfun1 ("^[\t ]*function[^=]+=[\t ]*"
+                    + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
+    QRegExp rxfun2 ("^[\t ]*function[\t ]+"
+                    + word_at_cursor + "[\t ]*\\([^\\)]*\\)[\t ]*$");
+    QRegExp rxfun3 ("^[\t ]*function[\t ]+"
+                    + word_at_cursor + "[\t ]*$");
+    QRegExp rxfun4 ("^[\t ]*function[^=]+=[\t ]*"
+                    + word_at_cursor + "[\t ]*$");
+
+    int pos_fct = -1;
+    QStringList lines = _edit_area->text ().split ("\n");
+
+    int line;
+    for (line = 0; line < lines.count (); line++)
+      {
+        if ((pos_fct = rxfun1.indexIn (lines.at (line))) != -1)
+          break;
+        if ((pos_fct = rxfun2.indexIn (lines.at (line))) != -1)
+          break;
+        if ((pos_fct = rxfun3.indexIn (lines.at (line))) != -1)
+          break;
+        if ((pos_fct = rxfun4.indexIn (lines.at (line))) != -1)
+          break;
+      }
+
+    if (pos_fct > -1)
+      {
+        // reg expr. found: it is an internal function
+        _edit_area->setCursorPosition (line, pos_fct);
+        _edit_area->SendScintilla (2232, line);     // SCI_ENSUREVISIBLE
+        // SCI_VISIBLEFROMDOCLINE
+        int vis_line = _edit_area->SendScintilla (2220, line);
+        _edit_area->SendScintilla (2613, vis_line); // SCI_SETFIRSTVISIBLELINE
+        return;
+      }
+
+    emit edit_mfile_request (word_at_cursor, _file_name, _ced, -1);
+  }
+
+  // If "dbstop if ..." selected from context menu, create a conditional
+  // breakpoint.  The default condition is (a) the existing condition if there
+  // is already a breakpoint (b) any selected text, or (c) empty
+  void file_editor_tab::handle_context_menu_break_condition (int linenr)
+  {
+    // Ensure editor line numbers match Octave core's line numbers.
+    // Give users the option to save modifications if necessary.
+    if (! unchanged_or_saved ())
+      return;
+
+    QString cond;
+    bp_info info (_file_name, linenr+1); // Get function name & dir from filename.
+
+    // Search for previous condition.  FIXME: is there a more direct way?
+    if (_edit_area->markersAtLine (linenr) & (1 << marker::cond_break))
+      {
+        emit report_marker_linenr (_bp_lines, _bp_conditions);
+        for (int i = 0; i < _bp_lines.length (); i++)
+          if (_bp_lines.value (i) == linenr)
+            {
+              cond = _bp_conditions.value (i);
+              break;
+            }
+        _bp_lines.clear ();
+        _bp_conditions.clear ();
+      }
+
+    // If text selected by the mouse, default to that instead
+    // If both present, use the OR of them, to avoid accidental overwriting
+    // FIXME: If both are present, show old condition unselected and
+    //        the selection (in edit area) selected (in the dialog).
+    if (_edit_area->hasSelectedText ())
+      {
+        if (cond == "")
+          cond = _edit_area->selectedText ();
+        else
+          cond = '(' + cond + ") || (" + _edit_area->selectedText () + ')';
+      }
+
+    bool valid = false;
+    std::string prompt = "dbstop if";
+    bool ok;
+    while (! valid)
+      {
+        QString new_condition
+          = QInputDialog::getText (this, tr ("Breakpoint condition"),
+                                   tr (prompt.c_str ()), QLineEdit::Normal, cond,
+                                   &ok);
+        if (ok)     // If cancel, don't change breakpoint condition.
           {
-            cond = _bp_conditions.value (i);
-            break;
+            try
+              {
+                // Suppress error messages on the console.
+                unwind_protect frame;
+                frame.protect_var (buffer_error_messages);
+                buffer_error_messages++;
+
+                bp_table::condition_valid (new_condition.toStdString ());
+                valid = true;
+              }
+            catch (const index_exception& e) { }
+            catch (const execution_exception& e) { }
+            catch (const interrupt_exception&)
+              {
+                ok = false;
+                valid = true;
+              }
+
+            // In case we repeat, set new prompt.
+            prompt = "ERROR: " + last_error_message () + "\n\ndbstop if";
+            cond = new_condition;
+          }
+        else
+          valid = true;
+      }
+
+    if (ok)       // If the user didn't cancel, actually set the breakpoint.
+      {
+        info.condition = cond.toStdString ();
+
+        octave_link::post_event
+          (this, &file_editor_tab::add_breakpoint_callback, info);
+      }
+  }
+
+  void file_editor_tab::set_file_name (const QString& fileName)
+  {
+    // update tracked file if we really have a file on disk
+    QStringList trackedFiles = _file_system_watcher.files ();
+    if (! trackedFiles.isEmpty ())
+      _file_system_watcher.removePath (_file_name);
+    if (! fileName.isEmpty ())
+      _file_system_watcher.addPath (fileName);
+
+    // update lexer and file name variable if file name changes
+    if (_file_name != fileName)
+      {
+        _file_name = fileName;
+        update_lexer ();
+      }
+
+    // update the file editor with current editing directory
+    emit editor_state_changed (_copy_available, _is_octave_file);
+
+    // add the new file to the most-recently-used list
+    emit mru_add_file (_file_name, _encoding);
+  }
+
+  // valid_file_name (file): checks whether "file" names a file.
+  // By default, "file" is empty; then _file_name is checked
+  bool file_editor_tab::valid_file_name (const QString& file)
+  {
+    if (file.isEmpty ())
+      {
+        if (_file_name.isEmpty ())
+          return false;
+        else
+          return true;
+      }
+
+    return true;
+  }
+
+  // We cannot create a breakpoint when the file is modified
+  // because the line number the editor is providing might
+  // not match what Octave core is interpreting in the
+  // file on disk.  This function gives the user the option
+  // to save before creating the breakpoint.
+  bool file_editor_tab::unchanged_or_saved (void)
+  {
+    bool retval = true;
+    if (_edit_area->isModified ())
+      {
+        int ans = QMessageBox::question (nullptr, tr ("Octave Editor"),
+                                         tr ("Cannot add breakpoint to modified file.\n"
+                                             "Save and add breakpoint, or cancel?"),
+                                         QMessageBox::Save | QMessageBox::Cancel, QMessageBox::Save);
+
+        if (ans == QMessageBox::Save)
+          save_file (_file_name, false);
+        else
+          retval = false;
+      }
+
+    return retval;
+  }
+
+  // Toggle a breakpoint at the editor_linenr or, if this was called by
+  // a click with CTRL pressed, toggle a bookmark at that point.
+  void file_editor_tab::handle_margin_clicked (int margin, int editor_linenr,
+                                               Qt::KeyboardModifiers state)
+  {
+    if (margin == 1)
+      {
+        unsigned int markers_mask = _edit_area->markersAtLine (editor_linenr);
+
+        if (state & Qt::ControlModifier)
+          {
+            if (markers_mask & (1 << marker::bookmark))
+              _edit_area->markerDelete (editor_linenr, marker::bookmark);
+            else
+              _edit_area->markerAdd (editor_linenr, marker::bookmark);
           }
-      _bp_lines.clear ();
-      _bp_conditions.clear ();
-    }
-
-  // If text selected by the mouse, default to that instead
-  // If both present, use the OR of them, to avoid accidental overwriting
-  // FIXME: If both are present, show old condition unselected and
-  //        the selection (in edit area) selected (in the dialog).
-  if (_edit_area->hasSelectedText ())
-    {
-      if (cond == "")
-        cond = _edit_area->selectedText ();
-      else
-        cond = '(' + cond + ") || (" + _edit_area->selectedText () + ')';
-    }
-
-  bool valid = false;
-  std::string prompt = "dbstop if";
-  bool ok;
-  while (! valid)
-    {
-      QString new_condition
-        = QInputDialog::getText (this, tr ("Breakpoint condition"),
-                                 tr (prompt.c_str ()), QLineEdit::Normal, cond,
-                                 &ok);
-      if (ok)     // If cancel, don't change breakpoint condition.
-        {
-          try
-            {
-              // Suppress error messages on the console.
-              octave::unwind_protect frame;
-              frame.protect_var (buffer_error_messages);
-              buffer_error_messages++;
-
-              bp_table::condition_valid (new_condition.toStdString ());
-              valid = true;
-            }
-          catch (const octave::index_exception& e) { }
-          catch (const octave::execution_exception& e) { }
-          catch (const octave::interrupt_exception&)
-            {
-              ok = false;
-              valid = true;
-            }
-
-          // In case we repeat, set new prompt.
-          prompt = "ERROR: " + last_error_message () + "\n\ndbstop if";
-          cond = new_condition;
-        }
-      else
-        valid = true;
-    }
-
-  if (ok)       // If the user didn't cancel, actually set the breakpoint.
-    {
-      info.condition = cond.toStdString ();
-
-      octave_link::post_event
-        (this, &file_editor_tab::add_breakpoint_callback, info);
-    }
-}
-
-void
-file_editor_tab::set_file_name (const QString& fileName)
-{
-  // update tracked file if we really have a file on disk
-  QStringList trackedFiles = _file_system_watcher.files ();
-  if (! trackedFiles.isEmpty ())
-    _file_system_watcher.removePath (_file_name);
-  if (! fileName.isEmpty ())
-    _file_system_watcher.addPath (fileName);
-
-  // update lexer and file name variable if file name changes
-  if (_file_name != fileName)
-    {
-      _file_name = fileName;
-      update_lexer ();
-    }
-
-  // update the file editor with current editing directory
-  emit editor_state_changed (_copy_available, _is_octave_file);
-
-  // add the new file to the most-recently-used list
-  emit mru_add_file (_file_name, _encoding);
-}
-
-// valid_file_name (file): checks whether "file" names a file.
-// By default, "file" is empty; then _file_name is checked
-bool
-file_editor_tab::valid_file_name (const QString& file)
-{
-  if (file.isEmpty ())
-    {
-      if (_file_name.isEmpty ())
-        return false;
-      else
-        return true;
-    }
-
-  return true;
-}
-
-// We cannot create a breakpoint when the file is modified
-// because the line number the editor is providing might
-// not match what Octave core is interpreting in the
-// file on disk.  This function gives the user the option
-// to save before creating the breakpoint.
-bool
-file_editor_tab::unchanged_or_saved (void)
-{
-  bool retval = true;
-  if (_edit_area->isModified ())
-    {
-      int ans = QMessageBox::question (nullptr, tr ("Octave Editor"),
-                  tr ("Cannot add breakpoint to modified file.\n"
-                      "Save and add breakpoint, or cancel?"),
-                  QMessageBox::Save | QMessageBox::Cancel, QMessageBox::Save);
-
-      if (ans == QMessageBox::Save)
-        save_file (_file_name, false);
-      else
-        retval = false;
-    }
-
-  return retval;
-}
-
-// Toggle a breakpoint at the editor_linenr or, if this was called by
-// a click with CTRL pressed, toggle a bookmark at that point.
-void
-file_editor_tab::handle_margin_clicked (int margin, int editor_linenr,
-                                        Qt::KeyboardModifiers state)
-{
-  if (margin == 1)
-    {
-      unsigned int markers_mask = _edit_area->markersAtLine (editor_linenr);
-
-      if (state & Qt::ControlModifier)
-        {
-          if (markers_mask & (1 << marker::bookmark))
-            _edit_area->markerDelete (editor_linenr, marker::bookmark);
-          else
-            _edit_area->markerAdd (editor_linenr, marker::bookmark);
-        }
-      else
-        {
-          if (markers_mask & ((1 << marker::breakpoint)
-                              | (1 << marker::cond_break)))
-            handle_request_remove_breakpoint (editor_linenr + 1);
-          else
-            {
-              if (unchanged_or_saved ())
-                handle_request_add_breakpoint (editor_linenr + 1, "");
-            }
-        }
-    }
-}
-
-
-void
-file_editor_tab::update_lexer ()
-{
-  // Create a new lexer
-  QsciLexer *lexer = nullptr;
-
-  _is_octave_file = false;
-
-  // Find the required lexer from file extensions
-  if (_file_name.endsWith (".m")
-      || _file_name.endsWith ("octaverc"))
-    {
+        else
+          {
+            if (markers_mask & ((1 << marker::breakpoint)
+                                | (1 << marker::cond_break)))
+              handle_request_remove_breakpoint (editor_linenr + 1);
+            else
+              {
+                if (unchanged_or_saved ())
+                  handle_request_add_breakpoint (editor_linenr + 1, "");
+              }
+          }
+      }
+  }
+
+
+  void file_editor_tab::update_lexer (void)
+  {
+    // Create a new lexer
+    QsciLexer *lexer = nullptr;
+
+    _is_octave_file = false;
+
+    // Find the required lexer from file extensions
+    if (_file_name.endsWith (".m")
+        || _file_name.endsWith ("octaverc"))
+      {
 #if defined (HAVE_LEXER_OCTAVE)
-      lexer = new QsciLexerOctave ();
+        lexer = new QsciLexerOctave ();
 #elif defined (HAVE_LEXER_MATLAB)
-      lexer = new QsciLexerMatlab ();
+        lexer = new QsciLexerMatlab ();
 #else
-      lexer = new octave_txt_lexer ();
+        lexer = new octave_txt_lexer ();
 #endif
-      _is_octave_file = true;
-    }
-
-  if (! lexer)
-    {
-      if (_file_name.endsWith (".c")
-          || _file_name.endsWith (".cc")
-          || _file_name.endsWith (".cpp")
-          || _file_name.endsWith (".cxx")
-          || _file_name.endsWith (".c++")
-          || _file_name.endsWith (".h")
-          || _file_name.endsWith (".hh")
-          || _file_name.endsWith (".hpp")
-          || _file_name.endsWith (".h++"))
-        {
-          lexer = new QsciLexerCPP ();
-        }
-      else if (_file_name.endsWith (".pl"))
-        {
-          lexer = new QsciLexerPerl ();
-        }
-      else if (_file_name.endsWith (".bat"))
-        {
-          lexer = new QsciLexerBatch ();
-        }
-      else if (_file_name.endsWith (".diff"))
-        {
-          lexer = new QsciLexerDiff ();
-        }
-      else if (_file_name.endsWith (".sh"))
-        {
-          lexer = new QsciLexerBash ();
-        }
-      else if (! valid_file_name ())
-        {
-          // new, no yet named file: let us assume it is octave
+        _is_octave_file = true;
+      }
+
+    if (! lexer)
+      {
+        if (_file_name.endsWith (".c")
+            || _file_name.endsWith (".cc")
+            || _file_name.endsWith (".cpp")
+            || _file_name.endsWith (".cxx")
+            || _file_name.endsWith (".c++")
+            || _file_name.endsWith (".h")
+            || _file_name.endsWith (".hh")
+            || _file_name.endsWith (".hpp")
+            || _file_name.endsWith (".h++"))
+          {
+            lexer = new QsciLexerCPP ();
+          }
+        else if (_file_name.endsWith (".pl"))
+          {
+            lexer = new QsciLexerPerl ();
+          }
+        else if (_file_name.endsWith (".bat"))
+          {
+            lexer = new QsciLexerBatch ();
+          }
+        else if (_file_name.endsWith (".diff"))
+          {
+            lexer = new QsciLexerDiff ();
+          }
+        else if (_file_name.endsWith (".sh"))
+          {
+            lexer = new QsciLexerBash ();
+          }
+        else if (! valid_file_name ())
+          {
+            // new, no yet named file: let us assume it is octave
 #if defined (HAVE_LEXER_OCTAVE)
-          lexer = new QsciLexerOctave ();
-          _is_octave_file = true;
+            lexer = new QsciLexerOctave ();
+            _is_octave_file = true;
 #elif defined (HAVE_LEXER_MATLAB)
-          lexer = new QsciLexerMatlab ();
-          _is_octave_file = true;
+            lexer = new QsciLexerMatlab ();
+            _is_octave_file = true;
 #else
-          lexer = new octave_txt_lexer ();
+            lexer = new octave_txt_lexer ();
 #endif
-        }
-      else
-        {
-          // other or no extension
-          lexer = new octave_txt_lexer ();
-        }
-    }
-
-  // Get any existing lexer
-  QsciLexer *old_lexer = _edit_area->lexer ();
-
-  // If new file, no lexer, or lexer has changed,
-  // delete old one and set the newly created as current lexer
-  if (! old_lexer || ! valid_file_name ()
-      || QString(old_lexer->lexer ()) != QString(lexer->lexer ()))
-    {
-      // Delete and set new lexer
-      if (old_lexer)
-        delete old_lexer;
-      _edit_area->setLexer (lexer);
-
-      // build information for auto completion (APIs)
-      _lexer_apis = new QsciAPIs (lexer);
-
-      // Get the settings for this new lexer
-      update_lexer_settings ();
-    }
-  else
-    {
-      // Otherwise, delete the newly created lexer and
-      // use the old, exisiting one
-      if (lexer)
-        delete lexer;
-    }
-}
-
-
-// Update settings, which are lexer related and have to be updated
-// when a) the lexer changes or b) the settings have changed.
-void
-file_editor_tab::update_lexer_settings ()
-{
-  QsciLexer *lexer = _edit_area->lexer ();
-
-  QSettings *settings = resource_manager::get_settings ();
-
-  if (_lexer_apis)
-    {
-      _lexer_apis->cancelPreparation ();  // stop preparing if apis exists
-
-      bool update_apis = false;  // flag, whether update of apis files
-
-      // get path to prepared api info
+          }
+        else
+          {
+            // other or no extension
+            lexer = new octave_txt_lexer ();
+          }
+      }
+
+    // Get any existing lexer
+    QsciLexer *old_lexer = _edit_area->lexer ();
+
+    // If new file, no lexer, or lexer has changed,
+    // delete old one and set the newly created as current lexer
+    if (! old_lexer || ! valid_file_name ()
+        || QString(old_lexer->lexer ()) != QString(lexer->lexer ()))
+      {
+        // Delete and set new lexer
+        if (old_lexer)
+          delete old_lexer;
+        _edit_area->setLexer (lexer);
+
+        // build information for auto completion (APIs)
+        _lexer_apis = new QsciAPIs (lexer);
+
+        // Get the settings for this new lexer
+        update_lexer_settings ();
+      }
+    else
+      {
+        // Otherwise, delete the newly created lexer and
+        // use the old, exisiting one
+        if (lexer)
+          delete lexer;
+      }
+  }
+
+
+  // Update settings, which are lexer related and have to be updated
+  // when a) the lexer changes or b) the settings have changed.
+  void file_editor_tab::update_lexer_settings (void)
+  {
+    QsciLexer *lexer = _edit_area->lexer ();
+
+    QSettings *settings = resource_manager::get_settings ();
+
+    if (_lexer_apis)
+      {
+        _lexer_apis->cancelPreparation ();  // stop preparing if apis exists
+
+        bool update_apis = false;  // flag, whether update of apis files
+
+        // get path to prepared api info
 #if defined (HAVE_QT4)
-      QString prep_apis_path
-        = QDesktopServices::storageLocation (QDesktopServices::HomeLocation)
+        QString prep_apis_path
+          = QDesktopServices::storageLocation (QDesktopServices::HomeLocation)
           + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
 #else
-      QString prep_apis_path
-        = QStandardPaths::writableLocation (QStandardPaths::HomeLocation)
+        QString prep_apis_path
+          = QStandardPaths::writableLocation (QStandardPaths::HomeLocation)
           + "/.config/octave/" + QString (OCTAVE_VERSION) + "/qsci/";
 #endif
 
-      // get settings which infos are used for octave
-      bool octave_builtins = settings->value (
-                  "editor/codeCompletion_octave_builtins", true).toBool ();
-      bool octave_functions = settings->value (
-                  "editor/codeCompletion_octave_functions", true).toBool ();
-
-      if (_is_octave_file)
-        {
-          // Keywords and Builtins do not change, these informations can be
-          // stored in prepared form in a file. Information on function are
-          // changing frequently, then if functions should also be auto-
-          // completed, the date of any existing file is checked.
-
-          // Keywords are always used
-          _prep_apis_file = prep_apis_path + lexer->lexer () + "_k";
-
-          // Buitlins are only used if the user settings say so
-          if (octave_builtins)
-            _prep_apis_file += 'b';
-
-          if (octave_functions)
-            _prep_apis_file += 'f';
-
-         _prep_apis_file += ".pap"; // final name of apis file
-
-          // check whether the APIs info needs to be prepared and saved
-          QFileInfo apis_file = QFileInfo (_prep_apis_file);
-          // flag whether apis file needs update
-          update_apis = ! apis_file.exists ();
-
-          if (octave_functions)
-            {
-              // Functions may change frequently. Update the apis data
-              // if the file is older than a few minutes preventing from
-              // re-preparing data when the user opens several files.
-              QDateTime apis_time = apis_file.lastModified ();
-              if (QDateTime::currentDateTime () > apis_time.addSecs (180))
-                update_apis = true;
-            }
+        // get settings which infos are used for octave
+        bool octave_builtins = settings->value (
+                                                "editor/codeCompletion_octave_builtins", true).toBool ();
+        bool octave_functions = settings->value (
+                                                 "editor/codeCompletion_octave_functions", true).toBool ();
+
+        if (_is_octave_file)
+          {
+            // Keywords and Builtins do not change, these informations can be
+            // stored in prepared form in a file. Information on function are
+            // changing frequently, then if functions should also be auto-
+            // completed, the date of any existing file is checked.
+
+            // Keywords are always used
+            _prep_apis_file = prep_apis_path + lexer->lexer () + "_k";
+
+            // Buitlins are only used if the user settings say so
+            if (octave_builtins)
+              _prep_apis_file += 'b';
+
+            if (octave_functions)
+              _prep_apis_file += 'f';
+
+            _prep_apis_file += ".pap"; // final name of apis file
+
+            // check whether the APIs info needs to be prepared and saved
+            QFileInfo apis_file = QFileInfo (_prep_apis_file);
+            // flag whether apis file needs update
+            update_apis = ! apis_file.exists ();
+
+            if (octave_functions)
+              {
+                // Functions may change frequently. Update the apis data
+                // if the file is older than a few minutes preventing from
+                // re-preparing data when the user opens several files.
+                QDateTime apis_time = apis_file.lastModified ();
+                if (QDateTime::currentDateTime () > apis_time.addSecs (180))
+                  update_apis = true;
+              }
 
           }
         else  // no octave file, just add extension
           {
 
             _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
 
           }
 
-      if (update_apis || ! _lexer_apis->loadPrepared (_prep_apis_file))
-        {
-          // either we have decided to update the apis file or
-          // no prepared info was loaded, prepare and save if possible
-
-          // create raw apis info
-          QString keyword;
-          QStringList keyword_list;
-          int i,j;
-
-          if (_is_octave_file)
-            {
-              // octave: get keywords from internal informations depending on
-              //         user preferences
-
-              // keywords are always used
-              add_octave_apis (Fiskeyword ());            // add new entries
-
-              octave::interpreter& interp
-                = octave::__get_interpreter__ (
-                                    "file_editor_tab::update_lexer_settings");
-
-              if (octave_builtins)
-                add_octave_apis (F__builtins__ (interp));       // add new entries
-
-              if (octave_functions)
-                add_octave_apis (F__list_functions__ (interp)); // add new entries
-
-            }
-          else
-            {
-
-              _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
-
-              for (i=1; i<=3; i++) // test the first 5 keyword sets
-                {
-                  keyword = QString (lexer->keywords (i));           // get list
-                  keyword_list = keyword.split (QRegExp (R"(\s+)")); // split
-                  for (j = 0; j < keyword_list.size (); j++)         // add to API
-                    _lexer_apis->add (keyword_list.at (j));
-                }
-            }
-
-          // disconnect slot for saving prepared info if already connected
-          disconnect (_lexer_apis, SIGNAL (apiPreparationFinished ()), nullptr, nullptr);
-          // check whether path for prepared info exists or can be created
-          if (QDir ("/").mkpath (prep_apis_path))
-            {
-              // path exists, apis info can be saved there
-              connect (_lexer_apis, SIGNAL (apiPreparationFinished ()),
-                       this, SLOT (save_apis_info ()));
-            }
-
-          _lexer_apis->prepare ();  // prepare apis info
-
-        }
-    }
-
-  lexer->readSettings (*settings);
-
-  _edit_area->setCaretForegroundColor (lexer->color (0));
-  _edit_area->setIndentationGuidesForegroundColor (lexer->color (0));
-
-  // set some colors depending on selected background color of the lexer
-  QColor bg = lexer->paper (0);
-  QColor fg = lexer->color (0);
-
-  int bh, bs, bv, fh, fs, fv, h, s, v;
-  bg.getHsv (&bh,&bs,&bv);
-  fg.getHsv (&fh,&fs,&fv);
-
-  // margin colors
-  h = bh;
-  s = bs/2;
-  v = bv + (fv - bv)/5;
-
-  bg.setHsv (h,s,v);
-  _edit_area->setEdgeColor (bg);
-
-  v = bv + (fv - bv)/8;
-  bg.setHsv (h,s,v);
-  v = bv + (fv - bv)/4;
-  fg.setHsv (h,s,v);
-
-  _edit_area->setMarkerForegroundColor (lexer->color (0));
-  _edit_area->setMarginsForegroundColor (lexer->color (0));
-  _edit_area->setMarginsBackgroundColor (bg);
-  _edit_area->setFoldMarginColors (bg,fg);
-
-  // color indicator for highlighting all occurrences:
-  // applications highlight color with more transparency
-  QColor hg = QApplication::palette ().color (QPalette::Highlight);
-  _edit_area->set_selection_marker_color (hg);
-
-  // fix line number width with respect to the font size of the lexer and
-  // set the line numbers font depending on the lexers font
-  if (settings->value ("editor/showLineNumbers", true).toBool ())
-    {
-      // Line numbers width
-      auto_margin_width ();
-
-      // Line numbers font
-      QFont line_numbers_font = lexer->defaultFont ();
-      int font_size = line_numbers_font.pointSize ();
-      font_size = font_size
-                  + settings->value ("editor/line_numbers_size", 0).toInt ();
-      if (font_size < 4)
-        font_size = 4;
-      line_numbers_font.setPointSize (font_size);
-
-      _edit_area->setMarginsFont (line_numbers_font);
-    }
-  else
-    _edit_area->setMarginWidth (2,0);
-}
-
-
-// function for adding entries to the octave lexer's APIs
-void
-file_editor_tab::add_octave_apis (octave_value_list key_ovl)
-{
-  octave_value keys = key_ovl(0);
-  Cell key_list = keys.cell_value ();
-
-  for (int idx = 0; idx < key_list.numel (); idx++)
-    _lexer_apis->add (QString (key_list.elem (idx).string_value ().data ()));
-}
-
-void
-file_editor_tab::save_apis_info ()
-{
-  _lexer_apis->savePrepared (_prep_apis_file);
-}
-
-// slot for fetab_set_focus: sets the focus to the current edit area
-void
-file_editor_tab::set_focus (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-  _edit_area->setFocus ();
-}
-
-void
-file_editor_tab::context_help (const QWidget *ID, bool doc)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->context_help_doc (doc);
-}
-
-void
-file_editor_tab::context_edit (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->context_edit ();
-}
-
-void
-file_editor_tab::check_modified_file (void)
-{
-  if (_cancelled)
-    return;
-
-  if (check_file_modified () == QMessageBox::Cancel)
-    _cancelled = true;
-}
-
-void
-file_editor_tab::save_file (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  save_file (_file_name);
-}
-
-void
-file_editor_tab::save_file (const QWidget *ID, const QString& fileName,
-                            bool remove_on_success)
-{
-  if (ID != this)
-    return;
-
-  save_file (fileName, remove_on_success);
-}
-
-void
-file_editor_tab::save_file_as (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  save_file_as ();
-}
-
-void
-file_editor_tab::print_file (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  QsciPrinter *printer = new QsciPrinter (QPrinter::HighResolution);
-
-  QPrintDialog printDlg (printer, this);
-
-  if (printDlg.exec () == QDialog::Accepted)
-    printer->printRange (_edit_area);
-
-  delete printer;
-}
-
-void
-file_editor_tab::run_file (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  if (_edit_area->isModified () | ! valid_file_name ())
-    {
-      save_file (_file_name);  // save file dialog
-      if (! valid_file_name ())
-        return;   // still invalid filename: "save as" was cancelled
-    }
-
-  QFileInfo info (_file_name);
-  emit run_file_signal (info);
-}
-
-void
-file_editor_tab::context_run (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->context_run ();
-}
-
-void
-file_editor_tab::toggle_bookmark (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  int line, cur;
-  _edit_area->getCursorPosition (&line, &cur);
-
-  if (_edit_area->markersAtLine (line) & (1 << marker::bookmark))
-    _edit_area->markerDelete (line, marker::bookmark);
-  else
-    _edit_area->markerAdd (line, marker::bookmark);
-}
-
-// Move the text cursor to the closest bookmark
-// after the current line.
-void
-file_editor_tab::next_bookmark (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  int line, cur;
-  _edit_area->getCursorPosition (&line, &cur);
-
-  line++; // Find bookmark strictly after the current line.
-
-  int nextline = _edit_area->markerFindNext (line, (1 << marker::bookmark));
-
-  // Wrap.
-  if (nextline == -1)
-    nextline = _edit_area->markerFindNext (1, (1 << marker::bookmark));
-
-  _edit_area->setCursorPosition (nextline, 0);
-}
-
-// Move the text cursor to the closest bookmark
-// before the current line.
-void
-file_editor_tab::previous_bookmark (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  int line, cur;
-  _edit_area->getCursorPosition (&line, &cur);
-
-  line--; // Find bookmark strictly before the current line.
-
-  int prevline = _edit_area->markerFindPrevious (line, (1 << marker::bookmark));
-
-  // Wrap.  Should use the last line of the file, not 1<<15
-  if (prevline == -1)
-    prevline = _edit_area->markerFindPrevious (_edit_area->lines (),
-                                               (1 << marker::bookmark));
-
-  _edit_area->setCursorPosition (prevline, 0);
-}
-
-void
-file_editor_tab::remove_bookmark (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->markerDeleteAll (marker::bookmark);
-}
-
-void
-file_editor_tab::add_breakpoint_callback (const bp_info& info)
-{
-  bp_table::intmap line_info;
-  line_info[0] = info.line;
-
-  if (octave_qt_link::file_in_path (info.file, info.dir))
-    bp_table::add_breakpoint (info.function_name, line_info, info.condition);
-}
-
-void
-file_editor_tab::remove_breakpoint_callback (const bp_info& info)
-{
-  bp_table::intmap line_info;
-  line_info[0] = info.line;
-
-  if (octave_qt_link::file_in_path (info.file, info.dir))
-    bp_table::remove_breakpoint (info.function_name, line_info);
-}
-
-void
-file_editor_tab::remove_all_breakpoints_callback (const bp_info& info)
-{
-  if (octave_qt_link::file_in_path (info.file, info.dir))
-    bp_table::remove_all_breakpoints_in_file (info.function_name, true);
-}
-
-file_editor_tab::bp_info::bp_info (const QString& fname, int l,
-                                   const QString& cond)
-  : line (l), file (fname.toStdString ()), condition (cond.toStdString ())
-{
-  QFileInfo file_info (fname);
-
-  QString q_dir = file_info.absolutePath ();
-  QString q_function_name = file_info.fileName ();
-
-  // We have to cut off the suffix, because octave appends it.
-  q_function_name.chop (file_info.suffix ().length () + 1);
-
-  dir = q_dir.toStdString ();
-  function_name = q_function_name.toStdString ();
-
-  // Is the last component of DIR @foo?  If so, strip it and prepend it
-  // to the name of the function.
-
-  size_t pos = dir.rfind (octave::sys::file_ops::dir_sep_chars ());
-
-  if (pos != std::string::npos && pos < dir.length () - 1)
-    {
-      if (dir[pos+1] == '@')
-        {
-          function_name = octave::sys::file_ops::concat (dir.substr (pos+1), function_name);
-
-          dir = dir.substr (0, pos);
-        }
-    }
-}
-
-void
-file_editor_tab::handle_request_add_breakpoint (int line,
-                                                const QString& condition)
-{
-  bp_info info (_file_name, line, condition);
-
-  octave_link::post_event
-    (this, &file_editor_tab::add_breakpoint_callback, info);
-}
-
-void
-file_editor_tab::handle_request_remove_breakpoint (int line)
-{
-  bp_info info (_file_name, line);
-
-  octave_link::post_event
-    (this, &file_editor_tab::remove_breakpoint_callback, info);
-}
-
-void
-file_editor_tab::toggle_breakpoint (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  int editor_linenr, cur;
-  _edit_area->getCursorPosition (&editor_linenr, &cur);
-
-  if (_edit_area->markersAtLine (editor_linenr) & (1 << marker::breakpoint))
-    request_remove_breakpoint_via_editor_linenr (editor_linenr);
-  else
-    {
-      if (unchanged_or_saved ())
-        handle_request_add_breakpoint (editor_linenr + 1, "");
-    }
-}
-
-// Move the text cursor to the closest breakpoint (conditional or unconditional)
-// after the current line.
-void
-file_editor_tab::next_breakpoint (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  int line, cur;
-  _edit_area->getCursorPosition (&line, &cur);
-
-  line++; // Find breakpoint strictly after the current line.
-
-  int nextline = _edit_area->markerFindNext (line, (1 << marker::breakpoint));
-  int nextcond = _edit_area->markerFindNext (line, (1 << marker::cond_break));
-
-  // Check if the next conditional breakpoint is before next unconditional one.
-  if (nextcond != -1 && (nextcond < nextline || nextline == -1))
-    nextline = nextcond;
-
-  _edit_area->setCursorPosition (nextline, 0);
-}
-
-// Move the text cursor to the closest breakpoint (conditional or unconditional)
-// before the current line.
-void
-file_editor_tab::previous_breakpoint (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  int line, cur, prevline, prevcond;
-  _edit_area->getCursorPosition (&line, &cur);
-
-  line--; // Find breakpoint strictly before the current line.
-
-  prevline = _edit_area->markerFindPrevious (line, (1 << marker::breakpoint));
-  prevcond = _edit_area->markerFindPrevious (line, (1 << marker::cond_break));
-
-  // Check if the prev conditional breakpoint is closer than the unconditional.
-  if (prevcond != -1 && prevcond > prevline)
-    prevline = prevcond;
-
-  _edit_area->setCursorPosition (prevline, 0);
-}
-
-void
-file_editor_tab::remove_all_breakpoints (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  bp_info info (_file_name);
-
-  octave_link::post_event
-    (this, &file_editor_tab::remove_all_breakpoints_callback, info);
-}
-
-void
-file_editor_tab::scintilla_command (const QWidget *ID, unsigned int sci_msg)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->SendScintilla (sci_msg);
-}
-
-void
-file_editor_tab::comment_selected_text (const QWidget *ID, bool input_str)
-{
-  if (ID != this)
-    return;
-
-  do_comment_selected_text (true, input_str);
-}
-
-void
-file_editor_tab::uncomment_selected_text (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  do_comment_selected_text (false);
-}
-
-void
-file_editor_tab::indent_selected_text (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  do_indent_selected_text (true);
-}
-
-void
-file_editor_tab::unindent_selected_text (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  do_indent_selected_text (false);
-}
-
-void
-file_editor_tab::smart_indent_line_or_selected_text (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  do_smart_indent_line_or_selected_text ();
-}
-
-void
-file_editor_tab::convert_eol (const QWidget *ID, QsciScintilla::EolMode eol_mode)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->convertEols (eol_mode);
-  _edit_area->setEolMode (eol_mode);
-  update_eol_indicator ();
-}
-
-void
-file_editor_tab::zoom_in (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->zoomIn (1);
-  auto_margin_width ();
-}
-
-void
-file_editor_tab::zoom_out (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->zoomOut (1);
-  auto_margin_width ();
-}
-
-void
-file_editor_tab::zoom_normal (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->zoomTo (0);
-  auto_margin_width ();
-}
-
-void
-file_editor_tab::handle_find_dialog_finished (int)
-{
-  // Find dialog is going to hide.  Save location of window for
-  // when it is reshown.
-  _find_dialog_geometry = _find_dialog->geometry ();
-  _find_dialog_is_visible = false;
-}
-
-void
-file_editor_tab::find (const QWidget *ID, QList<QAction *> fetab_actions)
-{
-  if (ID != this)
-    return;
-
-  // The find_dialog feature doesn't need a slot for return info.
-  // Rather than Qt::DeleteOnClose, let the find feature hang about
-  // in case it contains useful information like previous searches
-  // and so on.  Perhaps one find dialog for the whole editor is
-  // better, but individual find dialogs has the nice feature of
-  // retaining position per file editor tabs, which can be undocked.
-
-  if (! _find_dialog)
-    {
-      _find_dialog = new find_dialog (_edit_area,
-                                      fetab_actions.mid (0,2),
-                                      qobject_cast<QWidget *> (sender ()));
-      connect (_find_dialog, SIGNAL (finished (int)),
-               this, SLOT (handle_find_dialog_finished (int)));
-
-      connect (this, SIGNAL (request_find_next ()),
-               _find_dialog, SLOT (find_next ()));
-
-      connect (this, SIGNAL (request_find_previous ()),
-               _find_dialog, SLOT (find_prev ()));
-
-      _find_dialog->setWindowModality (Qt::NonModal);
-      _find_dialog_geometry = _find_dialog->geometry ();
-    }
-  else if (! _find_dialog->isVisible ())
-    {
-      _find_dialog->setGeometry (_find_dialog_geometry);
-      QPoint p = _find_dialog->pos ();
-      _find_dialog->move (p.x ()+10, p.y ()+10);
-    }
-
-  _find_dialog->show ();
-  _find_dialog_is_visible = true;
-  _find_dialog->activateWindow ();
-  _find_dialog->init_search_text ();
-
-}
-
-void
-file_editor_tab::find_next (const QWidget *ID)
-{
-  if (ID == this)
-    emit request_find_next ();
-}
-
-void
-file_editor_tab::find_previous (const QWidget *ID)
-{
-  if (ID == this)
-    emit request_find_previous ();
-}
-
-void
-file_editor_tab::goto_line (const QWidget *ID, int line)
-{
-  if (ID != this)
-    return;
-
-  if (m_bp_restore_count > 0)
-    {
-      // This goto-line request is invoked by restoring a breakpoint during
-      // saving the file, thus, do not go to the related line
-      m_bp_restore_count--;
+        if (update_apis || ! _lexer_apis->loadPrepared (_prep_apis_file))
+          {
+            // either we have decided to update the apis file or
+            // no prepared info was loaded, prepare and save if possible
+
+            // create raw apis info
+            QString keyword;
+            QStringList keyword_list;
+            int i,j;
+
+            if (_is_octave_file)
+              {
+                // octave: get keywords from internal informations depending on
+                //         user preferences
+
+                // keywords are always used
+                add_octave_apis (Fiskeyword ());            // add new entries
+
+                interpreter& interp
+                  = __get_interpreter__ (
+                                                 "file_editor_tab::update_lexer_settings");
+
+                if (octave_builtins)
+                  add_octave_apis (F__builtins__ (interp));       // add new entries
+
+                if (octave_functions)
+                  add_octave_apis (F__list_functions__ (interp)); // add new entries
+
+              }
+            else
+              {
+
+                _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
+
+                for (i=1; i<=3; i++) // test the first 5 keyword sets
+                  {
+                    keyword = QString (lexer->keywords (i));           // get list
+                    keyword_list = keyword.split (QRegExp (R"(\s+)")); // split
+                    for (j = 0; j < keyword_list.size (); j++)         // add to API
+                      _lexer_apis->add (keyword_list.at (j));
+                  }
+              }
+
+            // disconnect slot for saving prepared info if already connected
+            disconnect (_lexer_apis, SIGNAL (apiPreparationFinished ()), nullptr, nullptr);
+            // check whether path for prepared info exists or can be created
+            if (QDir ("/").mkpath (prep_apis_path))
+              {
+                // path exists, apis info can be saved there
+                connect (_lexer_apis, SIGNAL (apiPreparationFinished ()),
+                         this, SLOT (save_apis_info ()));
+              }
+
+            _lexer_apis->prepare ();  // prepare apis info
+
+          }
+      }
+
+    lexer->readSettings (*settings);
+
+    _edit_area->setCaretForegroundColor (lexer->color (0));
+    _edit_area->setIndentationGuidesForegroundColor (lexer->color (0));
+
+    // set some colors depending on selected background color of the lexer
+    QColor bg = lexer->paper (0);
+    QColor fg = lexer->color (0);
+
+    int bh, bs, bv, fh, fs, fv, h, s, v;
+    bg.getHsv (&bh,&bs,&bv);
+    fg.getHsv (&fh,&fs,&fv);
+
+    // margin colors
+    h = bh;
+    s = bs/2;
+    v = bv + (fv - bv)/5;
+
+    bg.setHsv (h,s,v);
+    _edit_area->setEdgeColor (bg);
+
+    v = bv + (fv - bv)/8;
+    bg.setHsv (h,s,v);
+    v = bv + (fv - bv)/4;
+    fg.setHsv (h,s,v);
+
+    _edit_area->setMarkerForegroundColor (lexer->color (0));
+    _edit_area->setMarginsForegroundColor (lexer->color (0));
+    _edit_area->setMarginsBackgroundColor (bg);
+    _edit_area->setFoldMarginColors (bg,fg);
+
+    // color indicator for highlighting all occurrences:
+    // applications highlight color with more transparency
+    QColor hg = QApplication::palette ().color (QPalette::Highlight);
+    _edit_area->set_selection_marker_color (hg);
+
+    // fix line number width with respect to the font size of the lexer and
+    // set the line numbers font depending on the lexers font
+    if (settings->value ("editor/showLineNumbers", true).toBool ())
+      {
+        // Line numbers width
+        auto_margin_width ();
+
+        // Line numbers font
+        QFont line_numbers_font = lexer->defaultFont ();
+        int font_size = line_numbers_font.pointSize ();
+        font_size = font_size
+          + settings->value ("editor/line_numbers_size", 0).toInt ();
+        if (font_size < 4)
+          font_size = 4;
+        line_numbers_font.setPointSize (font_size);
+
+        _edit_area->setMarginsFont (line_numbers_font);
+      }
+    else
+      _edit_area->setMarginWidth (2,0);
+  }
+
+
+  // function for adding entries to the octave lexer's APIs
+  void file_editor_tab::add_octave_apis (octave_value_list key_ovl)
+  {
+    octave_value keys = key_ovl(0);
+    Cell key_list = keys.cell_value ();
+
+    for (int idx = 0; idx < key_list.numel (); idx++)
+      _lexer_apis->add (QString (key_list.elem (idx).string_value ().data ()));
+  }
+
+  void file_editor_tab::save_apis_info (void)
+  {
+    _lexer_apis->savePrepared (_prep_apis_file);
+  }
+
+  // slot for fetab_set_focus: sets the focus to the current edit area
+  void file_editor_tab::set_focus (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+    _edit_area->setFocus ();
+  }
+
+  void file_editor_tab::context_help (const QWidget *ID, bool doc)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->context_help_doc (doc);
+  }
+
+  void file_editor_tab::context_edit (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->context_edit ();
+  }
+
+  void file_editor_tab::check_modified_file (void)
+  {
+    if (_cancelled)
+      return;
+
+    if (check_file_modified () == QMessageBox::Cancel)
+      _cancelled = true;
+  }
+
+  void file_editor_tab::save_file (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    save_file (_file_name);
+  }
+
+  void file_editor_tab::save_file (const QWidget *ID, const QString& fileName,
+                                   bool remove_on_success)
+  {
+    if (ID != this)
+      return;
+
+    save_file (fileName, remove_on_success);
+  }
+
+  void file_editor_tab::save_file_as (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    save_file_as ();
+  }
+
+  void file_editor_tab::print_file (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    QsciPrinter *printer = new QsciPrinter (QPrinter::HighResolution);
+
+    QPrintDialog printDlg (printer, this);
+
+    if (printDlg.exec () == QDialog::Accepted)
+      printer->printRange (_edit_area);
+
+    delete printer;
+  }
+
+  void file_editor_tab::run_file (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    if (_edit_area->isModified () | ! valid_file_name ())
+      {
+        save_file (_file_name);  // save file dialog
+        if (! valid_file_name ())
+          return;   // still invalid filename: "save as" was cancelled
+      }
+
+    QFileInfo info (_file_name);
+    emit run_file_signal (info);
+  }
+
+  void file_editor_tab::context_run (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->context_run ();
+  }
+
+  void file_editor_tab::toggle_bookmark (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    int line, cur;
+    _edit_area->getCursorPosition (&line, &cur);
+
+    if (_edit_area->markersAtLine (line) & (1 << marker::bookmark))
+      _edit_area->markerDelete (line, marker::bookmark);
+    else
+      _edit_area->markerAdd (line, marker::bookmark);
+  }
+
+  // Move the text cursor to the closest bookmark
+  // after the current line.
+  void file_editor_tab::next_bookmark (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    int line, cur;
+    _edit_area->getCursorPosition (&line, &cur);
+
+    line++; // Find bookmark strictly after the current line.
+
+    int nextline = _edit_area->markerFindNext (line, (1 << marker::bookmark));
+
+    // Wrap.
+    if (nextline == -1)
+      nextline = _edit_area->markerFindNext (1, (1 << marker::bookmark));
+
+    _edit_area->setCursorPosition (nextline, 0);
+  }
+
+  // Move the text cursor to the closest bookmark
+  // before the current line.
+  void file_editor_tab::previous_bookmark (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    int line, cur;
+    _edit_area->getCursorPosition (&line, &cur);
+
+    line--; // Find bookmark strictly before the current line.
+
+    int prevline = _edit_area->markerFindPrevious (line, (1 << marker::bookmark));
+
+    // Wrap.  Should use the last line of the file, not 1<<15
+    if (prevline == -1)
+      prevline = _edit_area->markerFindPrevious (_edit_area->lines (),
+                                                 (1 << marker::bookmark));
+
+    _edit_area->setCursorPosition (prevline, 0);
+  }
+
+  void file_editor_tab::remove_bookmark (const QWidget *ID)
+  {
+    if (ID != this)
       return;
-    }
-
-  if (line <= 0)  // ask for desired line
-    {
-      bool ok = false;
-      int index;
-      _edit_area->getCursorPosition (&line, &index);
-      line = QInputDialog::getInt (_edit_area, tr ("Goto line"),
-                                   tr ("Line number"), line+1, 1,
-                                   _edit_area->lines (), 1, &ok);
-      if (ok)
-        _edit_area->setCursorPosition (line-1, 0);
-    }
-  else  // go to given line without dialog
-    _edit_area->setCursorPosition (line-1, 0);
-
-  center_current_line (false);  // only center line if at top or bottom
-}
-
-void
-file_editor_tab::move_match_brace (const QWidget *ID, bool select)
-{
-  if (ID != this)
-    return;
-
-  if (select)
-    _edit_area->selectToMatchingBrace ();
-  else
-    _edit_area->moveToMatchingBrace ();
-}
-
-void
-file_editor_tab::show_auto_completion (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  QsciScintilla::AutoCompletionSource s = _edit_area->autoCompletionSource ();
-  switch (s)
-    {
+
+    _edit_area->markerDeleteAll (marker::bookmark);
+  }
+
+  void file_editor_tab::add_breakpoint_callback (const bp_info& info)
+  {
+    bp_table::intmap line_info;
+    line_info[0] = info.line;
+
+    if (octave_qt_link::file_in_path (info.file, info.dir))
+      bp_table::add_breakpoint (info.function_name, line_info, info.condition);
+  }
+
+  void file_editor_tab::remove_breakpoint_callback (const bp_info& info)
+  {
+    bp_table::intmap line_info;
+    line_info[0] = info.line;
+
+    if (octave_qt_link::file_in_path (info.file, info.dir))
+      bp_table::remove_breakpoint (info.function_name, line_info);
+  }
+
+  void file_editor_tab::remove_all_breakpoints_callback (const bp_info& info)
+  {
+    if (octave_qt_link::file_in_path (info.file, info.dir))
+      bp_table::remove_all_breakpoints_in_file (info.function_name, true);
+  }
+
+  file_editor_tab::bp_info::bp_info (const QString& fname, int l,
+                                     const QString& cond)
+    : line (l), file (fname.toStdString ()), condition (cond.toStdString ())
+  {
+    QFileInfo file_info (fname);
+
+    QString q_dir = file_info.absolutePath ();
+    QString q_function_name = file_info.fileName ();
+
+    // We have to cut off the suffix, because octave appends it.
+    q_function_name.chop (file_info.suffix ().length () + 1);
+
+    dir = q_dir.toStdString ();
+    function_name = q_function_name.toStdString ();
+
+    // Is the last component of DIR @foo?  If so, strip it and prepend it
+    // to the name of the function.
+
+    size_t pos = dir.rfind (sys::file_ops::dir_sep_chars ());
+
+    if (pos != std::string::npos && pos < dir.length () - 1)
+      {
+        if (dir[pos+1] == '@')
+          {
+            function_name = sys::file_ops::concat (dir.substr (pos+1), function_name);
+
+            dir = dir.substr (0, pos);
+          }
+      }
+  }
+
+  void file_editor_tab::handle_request_add_breakpoint (int line,
+                                                       const QString& condition)
+  {
+    bp_info info (_file_name, line, condition);
+
+    octave_link::post_event
+      (this, &file_editor_tab::add_breakpoint_callback, info);
+  }
+
+  void file_editor_tab::handle_request_remove_breakpoint (int line)
+  {
+    bp_info info (_file_name, line);
+
+    octave_link::post_event
+      (this, &file_editor_tab::remove_breakpoint_callback, info);
+  }
+
+  void file_editor_tab::toggle_breakpoint (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    int editor_linenr, cur;
+    _edit_area->getCursorPosition (&editor_linenr, &cur);
+
+    if (_edit_area->markersAtLine (editor_linenr) & (1 << marker::breakpoint))
+      request_remove_breakpoint_via_editor_linenr (editor_linenr);
+    else
+      {
+        if (unchanged_or_saved ())
+          handle_request_add_breakpoint (editor_linenr + 1, "");
+      }
+  }
+
+  // Move the text cursor to the closest breakpoint (conditional or unconditional)
+  // after the current line.
+  void file_editor_tab::next_breakpoint (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    int line, cur;
+    _edit_area->getCursorPosition (&line, &cur);
+
+    line++; // Find breakpoint strictly after the current line.
+
+    int nextline = _edit_area->markerFindNext (line, (1 << marker::breakpoint));
+    int nextcond = _edit_area->markerFindNext (line, (1 << marker::cond_break));
+
+    // Check if the next conditional breakpoint is before next unconditional one.
+    if (nextcond != -1 && (nextcond < nextline || nextline == -1))
+      nextline = nextcond;
+
+    _edit_area->setCursorPosition (nextline, 0);
+  }
+
+  // Move the text cursor to the closest breakpoint (conditional or unconditional)
+  // before the current line.
+  void file_editor_tab::previous_breakpoint (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    int line, cur, prevline, prevcond;
+    _edit_area->getCursorPosition (&line, &cur);
+
+    line--; // Find breakpoint strictly before the current line.
+
+    prevline = _edit_area->markerFindPrevious (line, (1 << marker::breakpoint));
+    prevcond = _edit_area->markerFindPrevious (line, (1 << marker::cond_break));
+
+    // Check if the prev conditional breakpoint is closer than the unconditional.
+    if (prevcond != -1 && prevcond > prevline)
+      prevline = prevcond;
+
+    _edit_area->setCursorPosition (prevline, 0);
+  }
+
+  void file_editor_tab::remove_all_breakpoints (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    bp_info info (_file_name);
+
+    octave_link::post_event
+      (this, &file_editor_tab::remove_all_breakpoints_callback, info);
+  }
+
+  void file_editor_tab::scintilla_command (const QWidget *ID, unsigned int sci_msg)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->SendScintilla (sci_msg);
+  }
+
+  void file_editor_tab::comment_selected_text (const QWidget *ID, bool input_str)
+  {
+    if (ID != this)
+      return;
+
+    do_comment_selected_text (true, input_str);
+  }
+
+  void file_editor_tab::uncomment_selected_text (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    do_comment_selected_text (false);
+  }
+
+  void file_editor_tab::indent_selected_text (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    do_indent_selected_text (true);
+  }
+
+  void file_editor_tab::unindent_selected_text (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    do_indent_selected_text (false);
+  }
+
+  void file_editor_tab::smart_indent_line_or_selected_text (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    do_smart_indent_line_or_selected_text ();
+  }
+
+  void file_editor_tab::convert_eol (const QWidget *ID,
+                                     QsciScintilla::EolMode eol_mode)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->convertEols (eol_mode);
+    _edit_area->setEolMode (eol_mode);
+    update_eol_indicator ();
+  }
+
+  void file_editor_tab::zoom_in (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->zoomIn (1);
+    auto_margin_width ();
+  }
+
+  void file_editor_tab::zoom_out (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->zoomOut (1);
+    auto_margin_width ();
+  }
+
+  void file_editor_tab::zoom_normal (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    _edit_area->zoomTo (0);
+    auto_margin_width ();
+  }
+
+  void file_editor_tab::handle_find_dialog_finished (int)
+  {
+    // Find dialog is going to hide.  Save location of window for
+    // when it is reshown.
+    _find_dialog_geometry = _find_dialog->geometry ();
+    _find_dialog_is_visible = false;
+  }
+
+  void file_editor_tab::find (const QWidget *ID, QList<QAction *> fetab_actions)
+  {
+    if (ID != this)
+      return;
+
+    // The find_dialog feature doesn't need a slot for return info.
+    // Rather than Qt::DeleteOnClose, let the find feature hang about
+    // in case it contains useful information like previous searches
+    // and so on.  Perhaps one find dialog for the whole editor is
+    // better, but individual find dialogs has the nice feature of
+    // retaining position per file editor tabs, which can be undocked.
+
+    if (! _find_dialog)
+      {
+        _find_dialog = new find_dialog (_edit_area,
+                                        fetab_actions.mid (0,2),
+                                        qobject_cast<QWidget *> (sender ()));
+        connect (_find_dialog, SIGNAL (finished (int)),
+                 this, SLOT (handle_find_dialog_finished (int)));
+
+        connect (this, SIGNAL (request_find_next ()),
+                 _find_dialog, SLOT (find_next ()));
+
+        connect (this, SIGNAL (request_find_previous ()),
+                 _find_dialog, SLOT (find_prev ()));
+
+        _find_dialog->setWindowModality (Qt::NonModal);
+        _find_dialog_geometry = _find_dialog->geometry ();
+      }
+    else if (! _find_dialog->isVisible ())
+      {
+        _find_dialog->setGeometry (_find_dialog_geometry);
+        QPoint p = _find_dialog->pos ();
+        _find_dialog->move (p.x ()+10, p.y ()+10);
+      }
+
+    _find_dialog->show ();
+    _find_dialog_is_visible = true;
+    _find_dialog->activateWindow ();
+    _find_dialog->init_search_text ();
+
+  }
+
+  void file_editor_tab::find_next (const QWidget *ID)
+  {
+    if (ID == this)
+      emit request_find_next ();
+  }
+
+  void file_editor_tab::find_previous (const QWidget *ID)
+  {
+    if (ID == this)
+      emit request_find_previous ();
+  }
+
+  void file_editor_tab::goto_line (const QWidget *ID, int line)
+  {
+    if (ID != this)
+      return;
+
+    if (m_bp_restore_count > 0)
+      {
+        // This goto-line request is invoked by restoring a breakpoint during
+        // saving the file, thus, do not go to the related line
+        m_bp_restore_count--;
+        return;
+      }
+
+    if (line <= 0)  // ask for desired line
+      {
+        bool ok = false;
+        int index;
+        _edit_area->getCursorPosition (&line, &index);
+        line = QInputDialog::getInt (_edit_area, tr ("Goto line"),
+                                     tr ("Line number"), line+1, 1,
+                                     _edit_area->lines (), 1, &ok);
+        if (ok)
+          _edit_area->setCursorPosition (line-1, 0);
+      }
+    else  // go to given line without dialog
+      _edit_area->setCursorPosition (line-1, 0);
+
+    center_current_line (false);  // only center line if at top or bottom
+  }
+
+  void file_editor_tab::move_match_brace (const QWidget *ID, bool select)
+  {
+    if (ID != this)
+      return;
+
+    if (select)
+      _edit_area->selectToMatchingBrace ();
+    else
+      _edit_area->moveToMatchingBrace ();
+  }
+
+  void file_editor_tab::show_auto_completion (const QWidget *ID)
+  {
+    if (ID != this)
+      return;
+
+    QsciScintilla::AutoCompletionSource s = _edit_area->autoCompletionSource ();
+    switch (s)
+      {
       case QsciScintilla::AcsAll:
         _edit_area->autoCompleteFromAll ();
         break;
 
       case QsciScintilla::AcsAPIs:
         _edit_area->autoCompleteFromAPIs ();
         break;
 
       case QsciScintilla::AcsDocument:
         _edit_area->autoCompleteFromDocument ();
         break;
 
       case QsciScintilla::AcsNone:
         break;
-    }
-}
-
-void
-file_editor_tab::do_indent_selected_text (bool indent)
-{
-  // FIXME:
-  _edit_area->beginUndoAction ();
-
-  if (_edit_area->hasSelectedText ())
-    {
-      int lineFrom, lineTo, colFrom, colTo;
-      _edit_area->getSelection (&lineFrom, &colFrom, &lineTo, &colTo);
-
-      if (colTo == 0)  // the beginning of last line is not selected
-        lineTo--;        // stop at line above
-
-      for (int i = lineFrom; i <= lineTo; i++)
-        {
-          if (indent)
-            _edit_area->indent (i);
-          else
-            _edit_area->unindent (i);
-        }
-      //set selection on (un)indented section
-      _edit_area->setSelection (lineFrom, 0, lineTo,
-                                _edit_area->text (lineTo).length ()-1);
-    }
-  else
-    {
-      int cpline, col;
-      _edit_area->getCursorPosition (&cpline, &col);
-      if (indent)
-        _edit_area->indent (cpline);
-      else
-        _edit_area->unindent (cpline);
-    }
-
-  _edit_area->endUndoAction ();
-}
-
-void
-file_editor_tab::do_smart_indent_line_or_selected_text (void)
-{
-  _edit_area->beginUndoAction ();
-
-  int lineFrom, lineTo;
-
-  if (_edit_area->hasSelectedText ())
-    {
-      int colFrom, colTo;
-      _edit_area->getSelection (&lineFrom, &colFrom, &lineTo, &colTo);
-
-      if (colTo == 0)  // the beginning of last line is not selected
-        lineTo--;        // stop at line above
-    }
-  else
-    {
-      int col;
-      _edit_area->getCursorPosition (&lineFrom, &col);
-
-      lineTo = lineFrom;
-    }
-
-  _edit_area->smart_indent_line_or_selected_text (lineFrom, lineTo);
-
-  _edit_area->endUndoAction ();
-}
-
-void
-file_editor_tab::do_comment_selected_text (bool comment, bool input_str)
-{
-  QRegExp rxc;
-  QString ws = "^([ \\t]*)";
-  QStringList comment_str = _edit_area->comment_string (comment);
-  QString used_comment_str = comment_str.at (0);
-
-  if (comment)
-    {
-      if (input_str)
-        {
-          bool ok;
-          QSettings *settings = resource_manager::get_settings ();
-
-          used_comment_str = QInputDialog::getText (
-              this, tr ("Comment selected text"),
-              tr ("Comment string to use:\n"), QLineEdit::Normal,
-              settings->value (oct_last_comment_str, comment_str.at (0)).toString (),
-              &ok);
-
-          if ((! ok) || used_comment_str.isEmpty ())
-            return;  // No input, do nothing
-          else
-            settings->setValue (oct_last_comment_str, used_comment_str);  // Store last
-        }
-    }
-  else
-    {
-      // Uncommenting (several strings possible)
-
-      // Sort strings according their length
-      QStringList comment_str_sorted (comment_str.at (0));
-      bool inserted;
-
-      for (int i = 1; i < comment_str.length (); i++)
-        {
-          inserted = false;
-          for (int j = 0; j < comment_str_sorted.length (); j++)
-            {
-              if (comment_str.at (i).length () > comment_str_sorted.at (j).length ())
-                {
-                  comment_str_sorted.insert (j, comment_str.at (i));
-                  inserted = true;
-                  break;
-                }
-            }
-          if (! inserted)
-            comment_str_sorted << comment_str.at (i);
-        }
-
-      // Create regular expression
-      QString regexp;
-      for (int i = 0; i < comment_str_sorted.length (); i++)
-        {
-          if (i > 0)
-            regexp = regexp + QString ("|");
-          regexp = regexp + comment_str_sorted.at (i);
-        }
-      rxc = QRegExp (ws + "(" + regexp + ")");
-    }
-
-  // Do the commenting/uncommenting
-  int len = 0, lenc = 0;
-  _edit_area->beginUndoAction ();
-
-  if (_edit_area->hasSelectedText ())
-    {
-      int lineFrom, lineTo, colFrom, colTo;
-      int change_col_from = 1;
-      int change_col_to = 1;
-      bool removed;
-
-      _edit_area->getSelection (&lineFrom, &colFrom, &lineTo, &colTo);
-
-      if (colTo == 0)  // the beginning of last line is not selected
-        lineTo--;        // stop at line above
-
-      for (int i = lineFrom; i <= lineTo; i++)
-        {
-          if (comment)
-            {
-              _edit_area->insertAt (used_comment_str, i, 0);
-            }
-          else
-            {
-              QString line (_edit_area->text (i));
-              if ((removed = line.contains (rxc)))
-                {
-                  len = rxc.matchedLength ();   // complete length
-                  QString matched_text = rxc.capturedTexts ().at (0);
-                  lenc = matched_text.remove (QRegExp (ws)).length ();  // only comment string
-                  _edit_area->setSelection (i, len-lenc, i, len);
-                  _edit_area->removeSelectedText ();
-                }
-
-              // handle case, where the selection remains unchanged
-              if (i == lineFrom && (colFrom < len-lenc || ! removed))
-                change_col_from = 0;  // do not change start of selection
-              if (i == lineTo && (colTo < len-lenc || ! removed))
-                change_col_to = 0;    // do not change end of selection
-            }
-        }
-
-      // update the selection area
-      if (comment)
-        {
-          colFrom = colFrom + lenc;   // shift start position by comment length
-          if (colTo > 0)
-            colTo = colTo + lenc;     // shift end position by comment length
-          else
-            lineTo++;                 // colTo == 0 , fully select previous line
-        }
-      else
-        {
-          if (colTo == 0)
-            lineTo++;                 // colTo == 0 , fully select previous line
-          colFrom = colFrom - change_col_from*lenc;
-          colTo = colTo - change_col_to*lenc;
-        }
-
-      // set updated selection area
-      _edit_area->setSelection (lineFrom, colFrom, lineTo, colTo);
-    }
-  else
-    {
-      int cpline, col;
-      _edit_area->getCursorPosition (&cpline, &col);
-      if (comment)
-        _edit_area->insertAt (used_comment_str, cpline, 0);
-      else
-        {
-          QString line (_edit_area->text (cpline));
-          if (line.contains (rxc))
-            {
-              len = rxc.matchedLength ();   // complete length
-              QString matched_text = rxc.capturedTexts ().at (0);
-              lenc = matched_text.remove (QRegExp (ws)).length ();  // only comment string
-              _edit_area->setSelection (cpline, len-lenc, cpline, len);
-              _edit_area->removeSelectedText ();
-            }
-        }
-    }
-  _edit_area->endUndoAction ();
-}
-
-void
-file_editor_tab::update_window_title (bool modified)
-{
-  QString title ("");
-  QString tooltip ("");
-
-  if (! valid_file_name ())
-    title = tr ("<unnamed>");
-  else
-    {
-      if (_long_title)
-        title = _file_name;
-      else
-        {
-          QFileInfo file (_file_name);
-          title = file.fileName ();
-          tooltip = _file_name;
-        }
-    }
-
-  if (modified)
-    emit file_name_changed (title.prepend ("* "), tooltip);
-  else
-    emit file_name_changed (title, tooltip);
-}
-
-void
-file_editor_tab::handle_copy_available (bool enableCopy)
-{
-  _copy_available = enableCopy;
-  emit editor_state_changed (_copy_available, _is_octave_file);
-}
-
-// show_dialog: shows a modal or non modal dialog depending on input arg
-void
-file_editor_tab::show_dialog (QDialog *dlg, bool modal)
-{
-  dlg->setAttribute (Qt::WA_DeleteOnClose);
-  if (modal)
-    dlg->exec ();
-  else
-    {
-      dlg->setWindowModality (Qt::NonModal);
-      dlg->show ();
-    }
-}
-
-int
-file_editor_tab::check_file_modified ()
-{
-  int decision = QMessageBox::Yes;
-  if (_edit_area->isModified ())
-    {
-      // File is modified but not saved, ask user what to do.  The file
-      // editor tab can't be made parent because it may be deleted depending
-      // upon the response.  Instead, change the _edit_area to read only.
-      QMessageBox::StandardButtons buttons = QMessageBox::Save |
-                                             QMessageBox::Discard |
-                                             QMessageBox::Cancel;
-
-      // For now, just a warning message about closing a tab that has been
-      // modified seems sufficient.  Exit-condition-specific messages could
-      // be achieved by making 'available_actions' a function input string.
-      QString available_actions =
+      }
+  }
+
+  void file_editor_tab::do_indent_selected_text (bool indent)
+  {
+    // FIXME:
+    _edit_area->beginUndoAction ();
+
+    if (_edit_area->hasSelectedText ())
+      {
+        int lineFrom, lineTo, colFrom, colTo;
+        _edit_area->getSelection (&lineFrom, &colFrom, &lineTo, &colTo);
+
+        if (colTo == 0)  // the beginning of last line is not selected
+          lineTo--;        // stop at line above
+
+        for (int i = lineFrom; i <= lineTo; i++)
+          {
+            if (indent)
+              _edit_area->indent (i);
+            else
+              _edit_area->unindent (i);
+          }
+        //set selection on (un)indented section
+        _edit_area->setSelection (lineFrom, 0, lineTo,
+                                  _edit_area->text (lineTo).length ()-1);
+      }
+    else
+      {
+        int cpline, col;
+        _edit_area->getCursorPosition (&cpline, &col);
+        if (indent)
+          _edit_area->indent (cpline);
+        else
+          _edit_area->unindent (cpline);
+      }
+
+    _edit_area->endUndoAction ();
+  }
+
+  void file_editor_tab::do_smart_indent_line_or_selected_text (void)
+  {
+    _edit_area->beginUndoAction ();
+
+    int lineFrom, lineTo;
+
+    if (_edit_area->hasSelectedText ())
+      {
+        int colFrom, colTo;
+        _edit_area->getSelection (&lineFrom, &colFrom, &lineTo, &colTo);
+
+        if (colTo == 0)  // the beginning of last line is not selected
+          lineTo--;        // stop at line above
+      }
+    else
+      {
+        int col;
+        _edit_area->getCursorPosition (&lineFrom, &col);
+
+        lineTo = lineFrom;
+      }
+
+    _edit_area->smart_indent_line_or_selected_text (lineFrom, lineTo);
+
+    _edit_area->endUndoAction ();
+  }
+
+  void file_editor_tab::do_comment_selected_text (bool comment, bool input_str)
+  {
+    QRegExp rxc;
+    QString ws = "^([ \\t]*)";
+    QStringList comment_str = _edit_area->comment_string (comment);
+    QString used_comment_str = comment_str.at (0);
+
+    if (comment)
+      {
+        if (input_str)
+          {
+            bool ok;
+            QSettings *settings = resource_manager::get_settings ();
+
+            used_comment_str = QInputDialog::getText (
+                                                      this, tr ("Comment selected text"),
+                                                      tr ("Comment string to use:\n"), QLineEdit::Normal,
+                                                      settings->value (oct_last_comment_str, comment_str.at (0)).toString (),
+                                                      &ok);
+
+            if ((! ok) || used_comment_str.isEmpty ())
+              return;  // No input, do nothing
+            else
+              settings->setValue (oct_last_comment_str, used_comment_str);  // Store last
+          }
+      }
+    else
+      {
+        // Uncommenting (several strings possible)
+
+        // Sort strings according their length
+        QStringList comment_str_sorted (comment_str.at (0));
+        bool inserted;
+
+        for (int i = 1; i < comment_str.length (); i++)
+          {
+            inserted = false;
+            for (int j = 0; j < comment_str_sorted.length (); j++)
+              {
+                if (comment_str.at (i).length () > comment_str_sorted.at (j).length ())
+                  {
+                    comment_str_sorted.insert (j, comment_str.at (i));
+                    inserted = true;
+                    break;
+                  }
+              }
+            if (! inserted)
+              comment_str_sorted << comment_str.at (i);
+          }
+
+        // Create regular expression
+        QString regexp;
+        for (int i = 0; i < comment_str_sorted.length (); i++)
+          {
+            if (i > 0)
+              regexp = regexp + QString ("|");
+            regexp = regexp + comment_str_sorted.at (i);
+          }
+        rxc = QRegExp (ws + "(" + regexp + ")");
+      }
+
+    // Do the commenting/uncommenting
+    int len = 0, lenc = 0;
+    _edit_area->beginUndoAction ();
+
+    if (_edit_area->hasSelectedText ())
+      {
+        int lineFrom, lineTo, colFrom, colTo;
+        int change_col_from = 1;
+        int change_col_to = 1;
+        bool removed;
+
+        _edit_area->getSelection (&lineFrom, &colFrom, &lineTo, &colTo);
+
+        if (colTo == 0)  // the beginning of last line is not selected
+          lineTo--;        // stop at line above
+
+        for (int i = lineFrom; i <= lineTo; i++)
+          {
+            if (comment)
+              {
+                _edit_area->insertAt (used_comment_str, i, 0);
+              }
+            else
+              {
+                QString line (_edit_area->text (i));
+                if ((removed = line.contains (rxc)))
+                  {
+                    len = rxc.matchedLength ();   // complete length
+                    QString matched_text = rxc.capturedTexts ().at (0);
+                    lenc = matched_text.remove (QRegExp (ws)).length ();  // only comment string
+                    _edit_area->setSelection (i, len-lenc, i, len);
+                    _edit_area->removeSelectedText ();
+                  }
+
+                // handle case, where the selection remains unchanged
+                if (i == lineFrom && (colFrom < len-lenc || ! removed))
+                  change_col_from = 0;  // do not change start of selection
+                if (i == lineTo && (colTo < len-lenc || ! removed))
+                  change_col_to = 0;    // do not change end of selection
+              }
+          }
+
+        // update the selection area
+        if (comment)
+          {
+            colFrom = colFrom + lenc;   // shift start position by comment length
+            if (colTo > 0)
+              colTo = colTo + lenc;     // shift end position by comment length
+            else
+              lineTo++;                 // colTo == 0 , fully select previous line
+          }
+        else
+          {
+            if (colTo == 0)
+              lineTo++;                 // colTo == 0 , fully select previous line
+            colFrom = colFrom - change_col_from*lenc;
+            colTo = colTo - change_col_to*lenc;
+          }
+
+        // set updated selection area
+        _edit_area->setSelection (lineFrom, colFrom, lineTo, colTo);
+      }
+    else
+      {
+        int cpline, col;
+        _edit_area->getCursorPosition (&cpline, &col);
+        if (comment)
+          _edit_area->insertAt (used_comment_str, cpline, 0);
+        else
+          {
+            QString line (_edit_area->text (cpline));
+            if (line.contains (rxc))
+              {
+                len = rxc.matchedLength ();   // complete length
+                QString matched_text = rxc.capturedTexts ().at (0);
+                lenc = matched_text.remove (QRegExp (ws)).length ();  // only comment string
+                _edit_area->setSelection (cpline, len-lenc, cpline, len);
+                _edit_area->removeSelectedText ();
+              }
+          }
+      }
+    _edit_area->endUndoAction ();
+  }
+
+  void file_editor_tab::update_window_title (bool modified)
+  {
+    QString title ("");
+    QString tooltip ("");
+
+    if (! valid_file_name ())
+      title = tr ("<unnamed>");
+    else
+      {
+        if (_long_title)
+          title = _file_name;
+        else
+          {
+            QFileInfo file (_file_name);
+            title = file.fileName ();
+            tooltip = _file_name;
+          }
+      }
+
+    if (modified)
+      emit file_name_changed (title.prepend ("* "), tooltip);
+    else
+      emit file_name_changed (title, tooltip);
+  }
+
+  void file_editor_tab::handle_copy_available (bool enableCopy)
+  {
+    _copy_available = enableCopy;
+    emit editor_state_changed (_copy_available, _is_octave_file);
+  }
+
+  // show_dialog: shows a modal or non modal dialog depending on input arg
+  void file_editor_tab::show_dialog (QDialog *dlg, bool modal)
+  {
+    dlg->setAttribute (Qt::WA_DeleteOnClose);
+    if (modal)
+      dlg->exec ();
+    else
+      {
+        dlg->setWindowModality (Qt::NonModal);
+        dlg->show ();
+      }
+  }
+
+  int file_editor_tab::check_file_modified (void)
+  {
+    int decision = QMessageBox::Yes;
+    if (_edit_area->isModified ())
+      {
+        // File is modified but not saved, ask user what to do.  The file
+        // editor tab can't be made parent because it may be deleted depending
+        // upon the response.  Instead, change the _edit_area to read only.
+        QMessageBox::StandardButtons buttons = QMessageBox::Save |
+          QMessageBox::Discard |
+          QMessageBox::Cancel;
+
+        // For now, just a warning message about closing a tab that has been
+        // modified seems sufficient.  Exit-condition-specific messages could
+        // be achieved by making 'available_actions' a function input string.
+        QString available_actions =
           tr ("Do you want to cancel closing, save or discard the changes?");
 
-      QString file;
-      if (valid_file_name ())
+        QString file;
+        if (valid_file_name ())
           file = _file_name;
-      else
+        else
           file = tr ("<unnamed>");
 
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Warning, tr ("Octave Editor"),
-                           tr ("The file\n\n"
-                               "  %1\n\n"
-                               "is about to be closed but has been modified.  "
-                               "%2").
-                           arg (file). arg (available_actions),
-                           buttons, qobject_cast<QWidget *> (parent ()));
-
-      msgBox->setDefaultButton (QMessageBox::Save);
-      _edit_area->setReadOnly (true);
-      connect (msgBox, SIGNAL (finished (int)),
-               this, SLOT (handle_file_modified_answer (int)));
-
-      show_dialog (msgBox, true);
-
-      if (_cancelled)
-        return QMessageBox::Cancel;
-      else
-        return decision;
-    }
-  else
-    {
-      // Nothing was modified.  Leave tab present in case user
-      // decides to cancel some point further along.
-    }
-
-  return decision;
-}
-
-void
-file_editor_tab::handle_file_modified_answer (int decision)
-{
-  if (decision == QMessageBox::Save)
-    {
-      // Save file, but do not remove from editor.
-      save_file (_file_name, false, false);
-    }
-  else if (decision == QMessageBox::Discard)
-    {
-      // User doesn't want to save, leave tab and remove subsequently.
-    }
-  else
-    {
-      // User canceled, allow editing again.
-      _edit_area->setReadOnly (false);
-      _cancelled = true;
-    }
-}
-
-void
-file_editor_tab::set_modified (bool modified)
-{
-  _edit_area->setModified (modified);
-}
-
-void
-file_editor_tab::recover_from_exit ()
-{
-  // reset the possibly still existing read only state
-  _edit_area->setReadOnly (false);
-
-  // if we are in this slot and the list of breakpoint is not empty,
-  // then this tab was saved during an exit of the applications (not
-  // restoring the breakpoints and not emptying the list) and the user
-  // canceled this closing late on.
-  check_restore_breakpoints ();
-}
-
-void
-file_editor_tab::check_restore_breakpoints ()
-{
-  if (! _bp_lines.isEmpty ())
-    {
-      // At least one breakpoint is present.
-      // Get rid of breakpoints at old (now possibly invalid) linenumbers
-      remove_all_breakpoints (this);
-
-      // and set breakpoints at the new linenumbers
-      m_bp_restore_count = _bp_lines.length ();
-      for (int i = 0; i < _bp_lines.length (); i++)
-        handle_request_add_breakpoint (_bp_lines.value (i) + 1,
-                                       _bp_conditions.value (i));
-
-     // Keep the list of breakpoints empty, except after explicit requests.
-      _bp_lines.clear ();
-      _bp_conditions.clear ();
-    }
-}
-
-QString
-file_editor_tab::load_file (const QString& fileName)
-{
-  // get the absolute path
-  QFileInfo file_info = QFileInfo (fileName);
-  QString file_to_load;
-  if (file_info.exists ())
-    file_to_load = file_info.canonicalFilePath ();
-  else
-    file_to_load = fileName;
-  QFile file (file_to_load);
-  if (! file.open (QFile::ReadOnly))
-    return file.errorString ();
-
-  // read the file
-  QTextStream in (&file);
-  // set the desired codec
-  QTextCodec *codec = QTextCodec::codecForName (_encoding.toLatin1 ());
-  in.setCodec (codec);
-
-  QApplication::setOverrideCursor (Qt::WaitCursor);
-  _edit_area->setText (in.readAll ());
-  _edit_area->setEolMode (detect_eol_mode ());
-  QApplication::restoreOverrideCursor ();
-
-  _copy_available = false;     // no selection yet available
-  set_file_name (file_to_load);
-  update_window_title (false); // window title (no modification)
-  _edit_area->setModified (false); // loaded file is not modified yet
-
-  update_eol_indicator ();
-
-  // FIXME: (BREAKPOINTS) At this point it would be nice to put any set
-  // breakpoints on the margin.  In order to do this, somehow the
-  // "dbstatus" command needs to be accessed.  All it would require is a
-  // routine that does "res = feval ("dbstatus") and signals that result
-  // to some slot.
-  //
-  // See patch #8016 for a general way to get Octave results from
-  // commands processed in the background.
-
-/*
-  connect (octave_link, SIGNAL (fileSelected (QObject *, const QString&, const octave_value_list&)),
-           this, SLOT (handle_feval_result (QObject *, const QString&, const octave_value_list&)));
-  connect (this, SIGNAL (evaluate_octave_command (const QString&)),
-           octave_link, SLOT (queue_octave_command (const QString&)));
-
-  emit evaluate_octave_command ("dbstatus");
-*/
-
-  return QString ();
-}
-
-QsciScintilla::EolMode
-file_editor_tab::detect_eol_mode ()
-{
-  QByteArray text = _edit_area->text ().toLatin1 ();
-
-  QByteArray eol_lf = QByteArray (1,0x0a);
-  QByteArray eol_cr = QByteArray (1,0x0d);
-  QByteArray eol_crlf = eol_cr;
-  eol_crlf.append (eol_lf);
-
-  int count_crlf = text.count (eol_crlf);
-  int count_lf = text.count (eol_lf) - count_crlf;  // isolated lf
-  int count_cr = text.count (eol_cr) - count_crlf;  // isolated cr;
-
-  // get default from OS or from settings
+        QMessageBox *msgBox
+          = new QMessageBox (QMessageBox::Warning, tr ("Octave Editor"),
+                             tr ("The file\n\n"
+                                 "  %1\n\n"
+                                 "is about to be closed but has been modified.  "
+                                 "%2").
+                             arg (file). arg (available_actions),
+                             buttons, qobject_cast<QWidget *> (parent ()));
+
+        msgBox->setDefaultButton (QMessageBox::Save);
+        _edit_area->setReadOnly (true);
+        connect (msgBox, SIGNAL (finished (int)),
+                 this, SLOT (handle_file_modified_answer (int)));
+
+        show_dialog (msgBox, true);
+
+        if (_cancelled)
+          return QMessageBox::Cancel;
+        else
+          return decision;
+      }
+    else
+      {
+        // Nothing was modified.  Leave tab present in case user
+        // decides to cancel some point further along.
+      }
+
+    return decision;
+  }
+
+  void file_editor_tab::handle_file_modified_answer (int decision)
+  {
+    if (decision == QMessageBox::Save)
+      {
+        // Save file, but do not remove from editor.
+        save_file (_file_name, false, false);
+      }
+    else if (decision == QMessageBox::Discard)
+      {
+        // User doesn't want to save, leave tab and remove subsequently.
+      }
+    else
+      {
+        // User canceled, allow editing again.
+        _edit_area->setReadOnly (false);
+        _cancelled = true;
+      }
+  }
+
+  void file_editor_tab::set_modified (bool modified)
+  {
+    _edit_area->setModified (modified);
+  }
+
+  void file_editor_tab::recover_from_exit (void)
+  {
+    // reset the possibly still existing read only state
+    _edit_area->setReadOnly (false);
+
+    // if we are in this slot and the list of breakpoint is not empty,
+    // then this tab was saved during an exit of the applications (not
+    // restoring the breakpoints and not emptying the list) and the user
+    // canceled this closing late on.
+    check_restore_breakpoints ();
+  }
+
+  void file_editor_tab::check_restore_breakpoints (void)
+  {
+    if (! _bp_lines.isEmpty ())
+      {
+        // At least one breakpoint is present.
+        // Get rid of breakpoints at old (now possibly invalid) linenumbers
+        remove_all_breakpoints (this);
+
+        // and set breakpoints at the new linenumbers
+        m_bp_restore_count = _bp_lines.length ();
+        for (int i = 0; i < _bp_lines.length (); i++)
+          handle_request_add_breakpoint (_bp_lines.value (i) + 1,
+                                         _bp_conditions.value (i));
+
+        // Keep the list of breakpoints empty, except after explicit requests.
+        _bp_lines.clear ();
+        _bp_conditions.clear ();
+      }
+  }
+
+  QString file_editor_tab::load_file (const QString& fileName)
+  {
+    // get the absolute path
+    QFileInfo file_info = QFileInfo (fileName);
+    QString file_to_load;
+    if (file_info.exists ())
+      file_to_load = file_info.canonicalFilePath ();
+    else
+      file_to_load = fileName;
+    QFile file (file_to_load);
+    if (! file.open (QFile::ReadOnly))
+      return file.errorString ();
+
+    // read the file
+    QTextStream in (&file);
+    // set the desired codec
+    QTextCodec *codec = QTextCodec::codecForName (_encoding.toLatin1 ());
+    in.setCodec (codec);
+
+    QApplication::setOverrideCursor (Qt::WaitCursor);
+    _edit_area->setText (in.readAll ());
+    _edit_area->setEolMode (detect_eol_mode ());
+    QApplication::restoreOverrideCursor ();
+
+    _copy_available = false;     // no selection yet available
+    set_file_name (file_to_load);
+    update_window_title (false); // window title (no modification)
+    _edit_area->setModified (false); // loaded file is not modified yet
+
+    update_eol_indicator ();
+
+    // FIXME: (BREAKPOINTS) At this point it would be nice to put any set
+    // breakpoints on the margin.  In order to do this, somehow the
+    // "dbstatus" command needs to be accessed.  All it would require is a
+    // routine that does "res = feval ("dbstatus") and signals that result
+    // to some slot.
+    //
+    // See patch #8016 for a general way to get Octave results from
+    // commands processed in the background.
+
+    /*
+      connect (octave_link, SIGNAL (fileSelected (QObject *, const QString&, const octave_value_list&)),
+      this, SLOT (handle_feval_result (QObject *, const QString&, const octave_value_list&)));
+      connect (this, SIGNAL (evaluate_octave_command (const QString&)),
+      octave_link, SLOT (queue_octave_command (const QString&)));
+
+      emit evaluate_octave_command ("dbstatus");
+    */
+
+    return QString ();
+  }
+
+  QsciScintilla::EolMode file_editor_tab::detect_eol_mode (void)
+  {
+    QByteArray text = _edit_area->text ().toLatin1 ();
+
+    QByteArray eol_lf = QByteArray (1,0x0a);
+    QByteArray eol_cr = QByteArray (1,0x0d);
+    QByteArray eol_crlf = eol_cr;
+    eol_crlf.append (eol_lf);
+
+    int count_crlf = text.count (eol_crlf);
+    int count_lf = text.count (eol_lf) - count_crlf;  // isolated lf
+    int count_cr = text.count (eol_cr) - count_crlf;  // isolated cr;
+
+    // get default from OS or from settings
 #if defined (Q_OS_WIN32)
-  int os_eol_mode = QsciScintilla::EolWindows;
+    int os_eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
-  int os_eol_mode = QsciScintilla::EolMac;
+    int os_eol_mode = QsciScintilla::EolMac;
 #else
-  int os_eol_mode = QsciScintilla::EolUnix;
+    int os_eol_mode = QsciScintilla::EolUnix;
 #endif
-  QSettings *settings = resource_manager::get_settings ();
-  QsciScintilla::EolMode eol_mode = static_cast<QsciScintilla::EolMode> (
-        settings->value ("editor/default_eol_mode",os_eol_mode).toInt ());
-
-  int count_max = 0;
-
-  if (count_crlf > count_max)
-    {
-      eol_mode = QsciScintilla::EolWindows;
-      count_max = count_crlf;
-    }
-  if (count_lf > count_max)
-    {
-      eol_mode = QsciScintilla::EolUnix;
-      count_max = count_lf;
-    }
-  if (count_cr > count_max)
-    {
-      eol_mode = QsciScintilla::EolMac;
-      count_max = count_cr;
-    }
-
-  return eol_mode;
-}
-
-void
-file_editor_tab::update_eol_indicator ()
-{
-  switch (_edit_area->eolMode ())
-    {
+    QSettings *settings = resource_manager::get_settings ();
+    QsciScintilla::EolMode eol_mode = static_cast<QsciScintilla::EolMode> (
+                                                                           settings->value ("editor/default_eol_mode",os_eol_mode).toInt ());
+
+    int count_max = 0;
+
+    if (count_crlf > count_max)
+      {
+        eol_mode = QsciScintilla::EolWindows;
+        count_max = count_crlf;
+      }
+    if (count_lf > count_max)
+      {
+        eol_mode = QsciScintilla::EolUnix;
+        count_max = count_lf;
+      }
+    if (count_cr > count_max)
+      {
+        eol_mode = QsciScintilla::EolMac;
+        count_max = count_cr;
+      }
+
+    return eol_mode;
+  }
+
+  void file_editor_tab::update_eol_indicator (void)
+  {
+    switch (_edit_area->eolMode ())
+      {
       case QsciScintilla::EolWindows:
         _eol_indicator->setText ("CRLF");
         break;
       case QsciScintilla::EolMac:
         _eol_indicator->setText ("CR");
         break;
       case QsciScintilla::EolUnix:
         _eol_indicator->setText ("LF");
         break;
-    }
-}
-
-// FIXME: See patch #8016 for a general way to get Octave results from
-// commands processed in the background, e.g., dbstatus.
-void
-file_editor_tab::handle_octave_result (QObject *requester, QString& command,
-                                       octave_value_list&)
-{
-  // Check if this object initiated the command.
-  if (requester == this)
-    {
-      if (command == "dbstatus")
-        {
-          // Should be installing breakpoints in this file
-/*
-octave:1> result = dbstatus
-result =
-
-  0x1 struct array containing the fields:
-
-    name
-    file
-    line
-*/
-          // Check for results that match "file".
-        }
-    }
-}
-
-void
-file_editor_tab::new_file (const QString& commands)
-{
-  update_window_title (false); // window title (no modification)
-
-  QSettings *settings = resource_manager::get_settings ();
-
-  // set the eol mode from the settings or depending on the OS if the entry is
-  // missing in the settings
+      }
+  }
+
+  // FIXME: See patch #8016 for a general way to get Octave results from
+  // commands processed in the background, e.g., dbstatus.
+  void file_editor_tab::handle_octave_result (QObject *requester,
+                                              QString& command,
+                                              octave_value_list&)
+  {
+    // Check if this object initiated the command.
+    if (requester == this)
+      {
+        if (command == "dbstatus")
+          {
+            // Should be installing breakpoints in this file
+            /*
+              octave:1> result = dbstatus
+              result =
+
+              0x1 struct array containing the fields:
+
+              name
+              file
+              line
+            */
+            // Check for results that match "file".
+          }
+      }
+  }
+
+  void file_editor_tab::new_file (const QString& commands)
+  {
+    update_window_title (false); // window title (no modification)
+
+    QSettings *settings = resource_manager::get_settings ();
+
+    // set the eol mode from the settings or depending on the OS if the entry is
+    // missing in the settings
 #if defined (Q_OS_WIN32)
-  int eol_mode = QsciScintilla::EolWindows;
+    int eol_mode = QsciScintilla::EolWindows;
 #elif defined (Q_OS_MAC)
-  int eol_mode = QsciScintilla::EolMac;
+    int eol_mode = QsciScintilla::EolMac;
 #else
-  int eol_mode = QsciScintilla::EolUnix;
+    int eol_mode = QsciScintilla::EolUnix;
 #endif
-  _edit_area->setEolMode (
-    static_cast<QsciScintilla::EolMode> (
-      settings->value ("editor/default_eol_mode",eol_mode).toInt ()));
-
-  update_eol_indicator ();
-
-  update_lexer ();
-
-  _edit_area->setText (commands);
-  _edit_area->setModified (false); // new file is not modified yet
-}
-
-// Force reloading of a file after it is saved.
-// This is needed to get the right line numbers for breakpoints (bug #46632).
-bool
-file_editor_tab::exit_debug_and_clear (const QString& full_name_q,
-                                       const QString& base_name_q)
-{
-  octave::symbol_table& symtab
-    = octave::__get_symbol_table__ ("file_editor_tab::exit_debug_and_clear");
-
-  std::string base_name = base_name_q.toStdString ();
-  octave_value sym;
-  try
-    {
-      sym = symtab.find (base_name);
-    }
-  catch (const octave::execution_exception& e)
-    {
-      // Ignore syntax error.
-      // It was in the old file on disk; the user may have fixed it already.
-    }
-
-  // Return early if this file is not loaded in the symbol table
-  if (! sym.is_defined () || ! sym.is_user_code ())
-    return true;
-
-  octave_user_code *fcn = sym.user_code_value ();
-
-  std::string full_name = full_name_q.toStdString ();
-  if (octave::sys::canonicalize_file_name (full_name.c_str ())
-      != octave::sys::canonicalize_file_name (fcn->fcn_file_name ().c_str ()))
-    return true;
-
-  // If this file is loaded, check that we aren't currently running it
-  bool retval = true;
-  octave_idx_type curr_frame = -1;
-  size_t nskip = 0;
-  octave::call_stack& cs
-    = octave::__get_call_stack__ ("file_editor_tab::exit_debug_and_clear");
-  octave_map stk = cs.backtrace (nskip, curr_frame, false);
-  Cell names = stk.contents ("name");
-  for (octave_idx_type i = names.numel () - 1; i >= 0; i--)
-    {
-      if (names(i).string_value () == base_name)
-        {
-          int ans = QMessageBox::question (nullptr, tr ("Debug or Save"),
-             tr ("This file is currently being executed.\n"
-                          "Quit debugging and save?"),
-              QMessageBox::Save | QMessageBox::Cancel);
-
-          if (ans == QMessageBox::Save)
-            {
-              emit execute_command_in_terminal_signal ("dbquit");
-              // Wait until dbquit has actually occurred
-              while (names.numel () > i)
-                {
-                  octave_sleep (0.01);
-                  stk = cs.backtrace (nskip, curr_frame, false);
-                  names = stk.contents ("name");
-                }
-            }
-          else
-            retval = false;
-          break;
-        }
-    }
-
-  // If we aren't currently running it, or have quit above, force a reload.
-  if (retval == true)
-    symtab.clear_user_function (base_name);
-
-  return retval;
-}
-
-void
-file_editor_tab::save_file (const QString& saveFileName,
-                            bool remove_on_success, bool restore_breakpoints)
-{
-  // If it is a new file with no name, signal that saveFileAs
-  // should be performed.
-  if (! valid_file_name (saveFileName))
-    {
-      save_file_as (remove_on_success);
-      return;
-    }
-
-  // Get a list of breakpoint line numbers, before  exit_debug_and_clear().
-  emit report_marker_linenr (_bp_lines, _bp_conditions);
-
-  // get the absolute path (if existing)
-  QFileInfo file_info = QFileInfo (saveFileName);
-  QString file_to_save;
-  if (file_info.exists ())
-    {
-      file_to_save = file_info.canonicalFilePath ();
-      // Force reparse of this function next time it is used (bug #46632)
-      if ((Fisdebugmode ())(0).is_true ()
-          && ! exit_debug_and_clear (file_to_save, file_info.baseName ()))
+    _edit_area->setEolMode (
+                            static_cast<QsciScintilla::EolMode> (
+                                                                 settings->value ("editor/default_eol_mode",eol_mode).toInt ()));
+
+    update_eol_indicator ();
+
+    update_lexer ();
+
+    _edit_area->setText (commands);
+    _edit_area->setModified (false); // new file is not modified yet
+  }
+
+  // Force reloading of a file after it is saved.
+  // This is needed to get the right line numbers for breakpoints (bug #46632).
+  bool file_editor_tab::exit_debug_and_clear (const QString& full_name_q,
+                                              const QString& base_name_q)
+  {
+    symbol_table& symtab
+      = __get_symbol_table__ ("file_editor_tab::exit_debug_and_clear");
+
+    std::string base_name = base_name_q.toStdString ();
+    octave_value sym;
+    try
+      {
+        sym = symtab.find (base_name);
+      }
+    catch (const execution_exception& e)
+      {
+        // Ignore syntax error.
+        // It was in the old file on disk; the user may have fixed it already.
+      }
+
+    // Return early if this file is not loaded in the symbol table
+    if (! sym.is_defined () || ! sym.is_user_code ())
+      return true;
+
+    octave_user_code *fcn = sym.user_code_value ();
+
+    std::string full_name = full_name_q.toStdString ();
+    if (sys::canonicalize_file_name (full_name.c_str ())
+        != sys::canonicalize_file_name (fcn->fcn_file_name ().c_str ()))
+      return true;
+
+    // If this file is loaded, check that we aren't currently running it
+    bool retval = true;
+    octave_idx_type curr_frame = -1;
+    size_t nskip = 0;
+    call_stack& cs
+      = __get_call_stack__ ("file_editor_tab::exit_debug_and_clear");
+    octave_map stk = cs.backtrace (nskip, curr_frame, false);
+    Cell names = stk.contents ("name");
+    for (octave_idx_type i = names.numel () - 1; i >= 0; i--)
+      {
+        if (names(i).string_value () == base_name)
+          {
+            int ans = QMessageBox::question (nullptr, tr ("Debug or Save"),
+                                             tr ("This file is currently being executed.\n"
+                                                 "Quit debugging and save?"),
+                                             QMessageBox::Save | QMessageBox::Cancel);
+
+            if (ans == QMessageBox::Save)
+              {
+                emit execute_command_in_terminal_signal ("dbquit");
+                // Wait until dbquit has actually occurred
+                while (names.numel () > i)
+                  {
+                    octave_sleep (0.01);
+                    stk = cs.backtrace (nskip, curr_frame, false);
+                    names = stk.contents ("name");
+                  }
+              }
+            else
+              retval = false;
+            break;
+          }
+      }
+
+    // If we aren't currently running it, or have quit above, force a reload.
+    if (retval == true)
+      symtab.clear_user_function (base_name);
+
+    return retval;
+  }
+
+  void file_editor_tab::save_file (const QString& saveFileName,
+                                   bool remove_on_success,
+                                   bool restore_breakpoints)
+  {
+    // If it is a new file with no name, signal that saveFileAs
+    // should be performed.
+    if (! valid_file_name (saveFileName))
+      {
+        save_file_as (remove_on_success);
         return;
-    }
-  else
-    file_to_save = saveFileName;
-  QFile file (file_to_save);
-
-  // stop watching file
-  QStringList trackedFiles = _file_system_watcher.files ();
-  if (trackedFiles.contains (file_to_save))
-    _file_system_watcher.removePath (file_to_save);
-
-  // open the file for writing
-  if (! file.open (QIODevice::WriteOnly))
-    {
-      // Unsuccessful, begin watching file again if it was being
-      // watched previously.
-      if (trackedFiles.contains (file_to_save))
-        _file_system_watcher.addPath (file_to_save);
-
-      // Create a NonModal message about error.
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Critical,
-                           tr ("Octave Editor"),
-                           tr ("Could not open file %1 for write:\n%2.").
-                           arg (file_to_save).arg (file.errorString ()),
-                           QMessageBox::Ok, nullptr);
-      show_dialog (msgBox, false);
-
-      return;
-    }
-
-  // save the contents into the file
-
-  _encoding = _new_encoding;    // consider a possible new encoding
-
-  // set the desired codec (if suitable for contents)
-  QTextCodec *codec = QTextCodec::codecForName (_encoding.toLatin1 ());
-
-  if (check_valid_codec (codec))
-    {
-      save_file_as (remove_on_success);
-      return;
-    }
-
-  // write the file
-  QTextStream out (&file);
-  out.setCodec (codec);
-
-  QApplication::setOverrideCursor (Qt::WaitCursor);
-  out << _edit_area->text ();
-  out.flush ();
-  QApplication::restoreOverrideCursor ();
-  file.flush ();
-  file.close ();
-
-  // file exists now
-  file_info = QFileInfo (file);
-  file_to_save = file_info.canonicalFilePath ();
-
-  // save filename after closing file as set_file_name starts watching again
-  set_file_name (file_to_save);   // make absolute
-
-  // set the window title to actual filename (not modified)
-  update_window_title (false);
-
-  // files is save -> not modified, update encoding in statusbar
-  _edit_area->setModified (false);
-  _enc_indicator->setText (_encoding);
-
-  if (remove_on_success)
-    {
-      emit tab_remove_request ();
-      return;  // Don't touch member variables after removal
-    }
-
-  // Attempt to restore the breakpoints if that is desired.
-  // This is only allowed if the tab is not closing since changing
-  // breakpoints would reopen the tab in this case.
-  if (restore_breakpoints)
-    check_restore_breakpoints ();
-}
-
-void
-file_editor_tab::save_file_as (bool remove_on_success)
-{
-  // Simply put up the file chooser dialog box with a slot connection
-  // then return control to the system waiting for a file selection.
-
-  // reset _new_encoding
-  _new_encoding = _encoding;
-
-  // If the tab is removed in response to a QFileDialog signal, the tab
-  // can't be a parent.
-  QFileDialog *fileDialog;
-  if (remove_on_success)
-    {
-      // If tab is closed, "this" cannot be parent in which case modality
-      // has no effect.  Disable editing instead.
-      _edit_area->setReadOnly (true);
-      fileDialog = new QFileDialog ();
-    }
-  else
-    fileDialog = new QFileDialog (this);
-
-  // Giving trouble under KDE (problem is related to Qt signal handling on unix,
-  // see https://bugs.kde.org/show_bug.cgi?id=260719 ,
-  // it had/has no effect on Windows, though)
-  fileDialog->setOption (QFileDialog::DontUseNativeDialog, true);
-
-  // define a new grid layout with the extra elements
-  QGridLayout *extra = new QGridLayout (fileDialog);
-  QFrame *separator = new QFrame (fileDialog);
-  separator->setFrameShape (QFrame::HLine);   // horizontal line as separator
-  separator->setFrameStyle (QFrame::Sunken);
-
-  // combo box for choosing new line ending chars
-  QLabel *label_eol = new QLabel (tr ("Line Endings:"));
-  QComboBox *combo_eol = new QComboBox ();
-  combo_eol->addItem ("Windows (CRLF)");  // ensure the same order as in
-  combo_eol->addItem ("Mac (CR)");        // the settings dialog
-  combo_eol->addItem ("Unix (LF)");
-  _save_as_desired_eol = _edit_area->eolMode ();      // init with current eol
-  combo_eol->setCurrentIndex (_save_as_desired_eol);
-
-  // combo box for encoding
-  QLabel *label_enc = new QLabel (tr ("File Encoding:"));
-  QComboBox *combo_enc = new QComboBox ();
-  resource_manager::combo_encoding (combo_enc, _encoding);
-
-  // track changes in the combo boxes
-  connect (combo_eol, SIGNAL (currentIndexChanged (int)),
-           this, SLOT (handle_combo_eol_current_index (int)));
-  connect (combo_enc, SIGNAL (currentIndexChanged (QString)),
-           this, SLOT (handle_combo_enc_current_index (QString)));
-
-  // build the extra grid layout
-  extra->addWidget (separator,0,0,1,6);
-  extra->addWidget (label_eol,1,0);
-  extra->addWidget (combo_eol,1,1);
-  extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Fixed,
-                                          QSizePolicy::Fixed), 1,2);
-  extra->addWidget (label_enc,1,3);
-  extra->addWidget (combo_enc,1,4);
-  extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Expanding,
-                                          QSizePolicy::Fixed), 1,5);
-
-  // and add the extra grid layout to the dialog's layout
-  QGridLayout *dialog_layout = dynamic_cast<QGridLayout *> (fileDialog->layout ());
-  dialog_layout->addLayout (extra,dialog_layout->rowCount (),0,
-                                  1,dialog_layout->columnCount ());
-
-  // add the possible filters and the default suffix
-  QStringList filters;
-  filters << tr ("Octave Files (*.m)")
-          << tr ("All Files (*)");
-  fileDialog->setNameFilters (filters);
-  fileDialog->setDefaultSuffix ("m");
-
-  if (valid_file_name ())
-    {
-      fileDialog->selectFile (_file_name);
-      QFileInfo file_info (_file_name);
-      if (file_info.suffix () != "m")
-        { // it is not an octave file
-          fileDialog->selectNameFilter (filters.at (1));  // "All Files"
-          fileDialog->setDefaultSuffix ("");              // no default suffix
-        }
-    }
-  else
-    {
-      fileDialog->selectFile ("");
-      fileDialog->setDirectory (_ced);
-
-      // propose a name corresponding to the function name
-      QString fname = get_function_name ();
-      if (! fname.isEmpty ())
-        fileDialog->selectFile (fname + ".m");
-    }
-
-  fileDialog->setAcceptMode (QFileDialog::AcceptSave);
-  fileDialog->setViewMode (QFileDialog::Detail);
-
-  connect (fileDialog, SIGNAL (filterSelected (const QString&)),
-           this, SLOT (handle_save_as_filter_selected (const QString&)));
-
-  if (remove_on_success)
-    {
-      connect (fileDialog, SIGNAL (fileSelected (const QString&)),
-               this, SLOT (handle_save_file_as_answer_close (const QString&)));
-
-      connect (fileDialog, SIGNAL (rejected ()),
-               this, SLOT (handle_save_file_as_answer_cancel ()));
-    }
-  else
-    {
-      connect (fileDialog, SIGNAL (fileSelected (const QString&)),
-               this, SLOT (handle_save_file_as_answer (const QString&)));
-    }
-
-  show_dialog (fileDialog, ! valid_file_name ());
-}
-
-void
-file_editor_tab::handle_combo_eol_current_index (int index)
-{
-  _save_as_desired_eol = static_cast<QsciScintilla::EolMode> (index);
-}
-
-void
-file_editor_tab::handle_combo_enc_current_index (QString text)
-{
-  _new_encoding = text;
-}
-
-void
-file_editor_tab::handle_save_as_filter_selected (const QString& filter)
-{
-  QFileDialog *file_dialog = qobject_cast<QFileDialog *> (sender ());
-
-  QRegExp rx ("\\*\\.([^ ^\\)]*)[ \\)]");   // regexp for suffix in filter
-  int index = rx.indexIn (filter,0);        // get first suffix in filter
-
-  if (index > -1)
-    file_dialog->setDefaultSuffix (rx.cap (1)); // found a suffix, set default
-  else
-    file_dialog->setDefaultSuffix ("");         // not found, clear default
-}
-
-bool
-file_editor_tab::check_valid_identifier (QString file_name)
-{
-  QFileInfo file = QFileInfo (file_name);
-  QString base_name = file.baseName ();
-
-  if ((file.suffix () == "m")
-      && (! valid_identifier (base_name.toStdString ())))
-    {
-      int ans = QMessageBox::question (nullptr, tr ("Octave Editor"),
-         tr ("\"%1\"\n"
-             "is not a valid identifier.\n\n"
-             "If you keep this filename, you will not be able to\n"
-             "call your script using its name as an Octave command.\n\n"
-             "Do you want to choose another name?").arg (base_name),
-          QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-
-      if (ans == QMessageBox::Yes)
-        return true;
-    }
-
-  return false;
-}
-
-bool
-file_editor_tab::check_valid_codec (QTextCodec *codec)
-{
-  if (! codec)
-    {
-      QMessageBox::critical (nullptr,
-            tr ("Octave Editor"),
-            tr ("The current codec %1\n"
-                "can not be applied.\n\n"
-                "Please select another one or cancel saving!").arg (_encoding));
-
-      return true;
-    }
-
-  if (! codec->canEncode (_edit_area->text ()))
-    {
-      int ans = QMessageBox::warning (nullptr,
-            tr ("Octave Editor"),
-            tr ("The current editor contents can not be encoded\n"
-                "with the selected codec %1.\n"
-                "Using it will result in data loss!\n\n"
-                "Do you want to chose another codec?").arg (_encoding),
-            QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
-
-      if (ans == QMessageBox::Yes)
-        return true;
-    }
-
-  return false;
-}
-
-void
-file_editor_tab::handle_save_file_as_answer (const QString& saveFileName)
-{
-  if (_save_as_desired_eol != _edit_area->eolMode ())
-    convert_eol (this,_save_as_desired_eol);
-
-  if (saveFileName == _file_name)
-    {
-      save_file (saveFileName);
-    }
-  else
-    {
-      // Have editor check for conflict, do not delete tab after save.
-      if (check_valid_identifier (saveFileName))
-        save_file_as (false);
-      else
-        emit editor_check_conflict_save (saveFileName, false);
-    }
-}
-
-void
-file_editor_tab::handle_save_file_as_answer_close (const QString& saveFileName)
-{
-  if (_save_as_desired_eol != _edit_area->eolMode ())
-    {
-      _edit_area->setReadOnly (false);  // was set to read-only in save_file_as
-      convert_eol (this,_save_as_desired_eol);
-      _edit_area->setReadOnly (true);   // restore read-only mode
-    }
-
-  // saveFileName == _file_name can not happen, because we only can get here
-  // when we close a tab and _file_name is not a valid filename yet
-
-  // Have editor check for conflict, delete tab after save.
-  if (check_valid_identifier (saveFileName))
-    save_file_as (true);
-  else
-    emit editor_check_conflict_save (saveFileName, true);
-}
-
-void
-file_editor_tab::handle_save_file_as_answer_cancel ()
-{
-  // User canceled, allow editing again.
-  _edit_area->setReadOnly (false);
-}
-
-void
-file_editor_tab::file_has_changed (const QString&, bool do_close)
-{
-  // Prevent popping up multiple message boxes when the file has
-  // been changed multiple times by temporarily removing from the
-  // file watcher.
-  QStringList trackedFiles = _file_system_watcher.files ();
-  if (! trackedFiles.isEmpty ())
-    _file_system_watcher.removePath (_file_name);
-
-  if (QFile::exists (_file_name) && ! do_close)
-    {
-      // The file is modified
-      if (_always_reload_changed_files)
-
-              load_file (_file_name);
-
-      else
-        {
-          // give editor and this tab the focus,
-          // possibly making the editor visible if it is hidden
-          emit set_focus_editor_signal (this);
-          _edit_area->setFocus ();
-
-          // Create a WindowModal message that blocks the edit area
-          // by making _edit_area parent.
-          QMessageBox *msgBox
-            = new QMessageBox (QMessageBox::Warning,
-                               tr ("Octave Editor"),
-                               tr ("It seems that \'%1\' has been modified by another application. Do you want to reload it?").
-                               arg (_file_name),
-                               QMessageBox::Yes | QMessageBox::No, this);
-
-          connect (msgBox, SIGNAL (finished (int)),
-                   this, SLOT (handle_file_reload_answer (int)));
-
-          msgBox->setWindowModality (Qt::WindowModal);
-          msgBox->setAttribute (Qt::WA_DeleteOnClose);
-          msgBox->show ();
-        }
-    }
-  else
-    {
-      // If desired and if file is not modified,
-      // close the file without any user interaction
-      if (do_close && ! _edit_area->isModified ())
-        {
-          handle_file_resave_answer (QMessageBox::Cancel);
+      }
+
+    // Get a list of breakpoint line numbers, before  exit_debug_and_clear().
+    emit report_marker_linenr (_bp_lines, _bp_conditions);
+
+    // get the absolute path (if existing)
+    QFileInfo file_info = QFileInfo (saveFileName);
+    QString file_to_save;
+    if (file_info.exists ())
+      {
+        file_to_save = file_info.canonicalFilePath ();
+        // Force reparse of this function next time it is used (bug #46632)
+        if ((Fisdebugmode ())(0).is_true ()
+            && ! exit_debug_and_clear (file_to_save, file_info.baseName ()))
           return;
-        }
-
-      // give editor and this tab the focus,
-      // possibly making the editor visible  if it is hidden
-      emit set_focus_editor_signal (this);
-      _edit_area->setFocus ();
-
-      QString modified = "";
-      if (_edit_area->isModified ())
-        modified = tr ("\n\nWarning: The contents in the editor is modified!");
-
-      // Create a WindowModal message. The file editor tab can't be made
-      // parent because it may be deleted depending upon the response.
-      // Instead, change the _edit_area to read only.
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Warning, tr ("Octave Editor"),
-                           tr ("It seems that the file\n"
-                               "%1\n"
-                               "has been deleted or renamed. Do you want to save it now?%2").
-                           arg (_file_name).arg (modified),
-                           QMessageBox::Save | QMessageBox::Close, nullptr);
-
-      _edit_area->setReadOnly (true);
-
-      connect (msgBox, SIGNAL (finished (int)),
-               this, SLOT (handle_file_resave_answer (int)));
-
-      msgBox->setWindowModality (Qt::WindowModal);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-      msgBox->show ();
-    }
-}
-
-void
-file_editor_tab::notice_settings (const QSettings *settings, bool init)
-{
-  // QSettings pointer is checked before emitting.
-
-  if (! init)
-    update_lexer_settings ();
-
-  // code folding
-  if (settings->value ("editor/code_folding",true).toBool ())
-    {
-      _edit_area->setMarginType (3, QsciScintilla::SymbolMargin);
-      _edit_area->setFolding (QsciScintilla::BoxedTreeFoldStyle , 3);
-    }
-  else
-    {
-      _edit_area->setFolding (QsciScintilla::NoFoldStyle, 3);
-    }
-
-  // status bar
-  if (settings->value ("editor/show_edit_status_bar",true).toBool ())
-    _status_bar->show ();
-  else
-    _status_bar->hide ();
-
-  //highlight current line color
-  QVariant default_var = QColor (240, 240, 240);
-  QColor setting_color = settings->value ("editor/highlight_current_line_color",
-                                          default_var).value<QColor> ();
-  _edit_area->setCaretLineBackgroundColor (setting_color);
-  _edit_area->setCaretLineVisible
-    (settings->value ("editor/highlightCurrentLine", true).toBool ());
-
-  bool match_keywords = settings->value
-                            ("editor/codeCompletion_keywords",true).toBool ();
-  bool match_document = settings->value
-                            ("editor/codeCompletion_document",true).toBool ();
-
-  QsciScintilla::AutoCompletionSource source = QsciScintilla::AcsNone;
-  if (match_keywords)
-    if (match_document)
-      source = QsciScintilla::AcsAll;
+      }
+    else
+      file_to_save = saveFileName;
+    QFile file (file_to_save);
+
+    // stop watching file
+    QStringList trackedFiles = _file_system_watcher.files ();
+    if (trackedFiles.contains (file_to_save))
+      _file_system_watcher.removePath (file_to_save);
+
+    // open the file for writing
+    if (! file.open (QIODevice::WriteOnly))
+      {
+        // Unsuccessful, begin watching file again if it was being
+        // watched previously.
+        if (trackedFiles.contains (file_to_save))
+          _file_system_watcher.addPath (file_to_save);
+
+        // Create a NonModal message about error.
+        QMessageBox *msgBox
+          = new QMessageBox (QMessageBox::Critical,
+                             tr ("Octave Editor"),
+                             tr ("Could not open file %1 for write:\n%2.").
+                             arg (file_to_save).arg (file.errorString ()),
+                             QMessageBox::Ok, nullptr);
+        show_dialog (msgBox, false);
+
+        return;
+      }
+
+    // save the contents into the file
+
+    _encoding = _new_encoding;    // consider a possible new encoding
+
+    // set the desired codec (if suitable for contents)
+    QTextCodec *codec = QTextCodec::codecForName (_encoding.toLatin1 ());
+
+    if (check_valid_codec (codec))
+      {
+        save_file_as (remove_on_success);
+        return;
+      }
+
+    // write the file
+    QTextStream out (&file);
+    out.setCodec (codec);
+
+    QApplication::setOverrideCursor (Qt::WaitCursor);
+    out << _edit_area->text ();
+    out.flush ();
+    QApplication::restoreOverrideCursor ();
+    file.flush ();
+    file.close ();
+
+    // file exists now
+    file_info = QFileInfo (file);
+    file_to_save = file_info.canonicalFilePath ();
+
+    // save filename after closing file as set_file_name starts watching again
+    set_file_name (file_to_save);   // make absolute
+
+    // set the window title to actual filename (not modified)
+    update_window_title (false);
+
+    // files is save -> not modified, update encoding in statusbar
+    _edit_area->setModified (false);
+    _enc_indicator->setText (_encoding);
+
+    if (remove_on_success)
+      {
+        emit tab_remove_request ();
+        return;  // Don't touch member variables after removal
+      }
+
+    // Attempt to restore the breakpoints if that is desired.
+    // This is only allowed if the tab is not closing since changing
+    // breakpoints would reopen the tab in this case.
+    if (restore_breakpoints)
+      check_restore_breakpoints ();
+  }
+
+  void file_editor_tab::save_file_as (bool remove_on_success)
+  {
+    // Simply put up the file chooser dialog box with a slot connection
+    // then return control to the system waiting for a file selection.
+
+    // reset _new_encoding
+    _new_encoding = _encoding;
+
+    // If the tab is removed in response to a QFileDialog signal, the tab
+    // can't be a parent.
+    QFileDialog *fileDialog;
+    if (remove_on_success)
+      {
+        // If tab is closed, "this" cannot be parent in which case modality
+        // has no effect.  Disable editing instead.
+        _edit_area->setReadOnly (true);
+        fileDialog = new QFileDialog ();
+      }
     else
-      source = QsciScintilla::AcsAPIs;
-  else if (match_document)
-    source = QsciScintilla::AcsDocument;
-  _edit_area->setAutoCompletionSource (source);
-
-  _edit_area->setAutoCompletionReplaceWord
-      (settings->value ("editor/codeCompletion_replace",false).toBool ());
-  _edit_area->setAutoCompletionCaseSensitivity
-      (settings->value ("editor/codeCompletion_case",true).toBool ());
-
-  if (settings->value ("editor/codeCompletion", true).toBool ())
-    _edit_area->setAutoCompletionThreshold
-      (settings->value ("editor/codeCompletion_threshold",2).toInt ());
-  else
-    _edit_area->setAutoCompletionThreshold (-1);
-
-  if (settings->value ("editor/show_white_space",false).toBool ())
-    if (settings->value ("editor/show_white_space_indent",false).toBool ())
-      _edit_area->setWhitespaceVisibility (QsciScintilla::WsVisibleAfterIndent);
+      fileDialog = new QFileDialog (this);
+
+    // Giving trouble under KDE (problem is related to Qt signal handling on unix,
+    // see https://bugs.kde.org/show_bug.cgi?id=260719 ,
+    // it had/has no effect on Windows, though)
+    fileDialog->setOption (QFileDialog::DontUseNativeDialog, true);
+
+    // define a new grid layout with the extra elements
+    QGridLayout *extra = new QGridLayout (fileDialog);
+    QFrame *separator = new QFrame (fileDialog);
+    separator->setFrameShape (QFrame::HLine);   // horizontal line as separator
+    separator->setFrameStyle (QFrame::Sunken);
+
+    // combo box for choosing new line ending chars
+    QLabel *label_eol = new QLabel (tr ("Line Endings:"));
+    QComboBox *combo_eol = new QComboBox ();
+    combo_eol->addItem ("Windows (CRLF)");  // ensure the same order as in
+    combo_eol->addItem ("Mac (CR)");        // the settings dialog
+    combo_eol->addItem ("Unix (LF)");
+    _save_as_desired_eol = _edit_area->eolMode ();      // init with current eol
+    combo_eol->setCurrentIndex (_save_as_desired_eol);
+
+    // combo box for encoding
+    QLabel *label_enc = new QLabel (tr ("File Encoding:"));
+    QComboBox *combo_enc = new QComboBox ();
+    resource_manager::combo_encoding (combo_enc, _encoding);
+
+    // track changes in the combo boxes
+    connect (combo_eol, SIGNAL (currentIndexChanged (int)),
+             this, SLOT (handle_combo_eol_current_index (int)));
+    connect (combo_enc, SIGNAL (currentIndexChanged (QString)),
+             this, SLOT (handle_combo_enc_current_index (QString)));
+
+    // build the extra grid layout
+    extra->addWidget (separator,0,0,1,6);
+    extra->addWidget (label_eol,1,0);
+    extra->addWidget (combo_eol,1,1);
+    extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Fixed,
+                                       QSizePolicy::Fixed), 1,2);
+    extra->addWidget (label_enc,1,3);
+    extra->addWidget (combo_enc,1,4);
+    extra->addItem   (new QSpacerItem (1,20,QSizePolicy::Expanding,
+                                       QSizePolicy::Fixed), 1,5);
+
+    // and add the extra grid layout to the dialog's layout
+    QGridLayout *dialog_layout = dynamic_cast<QGridLayout *> (fileDialog->layout ());
+    dialog_layout->addLayout (extra,dialog_layout->rowCount (),0,
+                              1,dialog_layout->columnCount ());
+
+    // add the possible filters and the default suffix
+    QStringList filters;
+    filters << tr ("Octave Files (*.m)")
+            << tr ("All Files (*)");
+    fileDialog->setNameFilters (filters);
+    fileDialog->setDefaultSuffix ("m");
+
+    if (valid_file_name ())
+      {
+        fileDialog->selectFile (_file_name);
+        QFileInfo file_info (_file_name);
+        if (file_info.suffix () != "m")
+          { // it is not an octave file
+            fileDialog->selectNameFilter (filters.at (1));  // "All Files"
+            fileDialog->setDefaultSuffix ("");              // no default suffix
+          }
+      }
+    else
+      {
+        fileDialog->selectFile ("");
+        fileDialog->setDirectory (_ced);
+
+        // propose a name corresponding to the function name
+        QString fname = get_function_name ();
+        if (! fname.isEmpty ())
+          fileDialog->selectFile (fname + ".m");
+      }
+
+    fileDialog->setAcceptMode (QFileDialog::AcceptSave);
+    fileDialog->setViewMode (QFileDialog::Detail);
+
+    connect (fileDialog, SIGNAL (filterSelected (const QString&)),
+             this, SLOT (handle_save_as_filter_selected (const QString&)));
+
+    if (remove_on_success)
+      {
+        connect (fileDialog, SIGNAL (fileSelected (const QString&)),
+                 this, SLOT (handle_save_file_as_answer_close (const QString&)));
+
+        connect (fileDialog, SIGNAL (rejected ()),
+                 this, SLOT (handle_save_file_as_answer_cancel ()));
+      }
+    else
+      {
+        connect (fileDialog, SIGNAL (fileSelected (const QString&)),
+                 this, SLOT (handle_save_file_as_answer (const QString&)));
+      }
+
+    show_dialog (fileDialog, ! valid_file_name ());
+  }
+
+  void file_editor_tab::handle_combo_eol_current_index (int index)
+  {
+    _save_as_desired_eol = static_cast<QsciScintilla::EolMode> (index);
+  }
+
+  void file_editor_tab::handle_combo_enc_current_index (QString text)
+  {
+    _new_encoding = text;
+  }
+
+  void file_editor_tab::handle_save_as_filter_selected (const QString& filter)
+  {
+    QFileDialog *file_dialog = qobject_cast<QFileDialog *> (sender ());
+
+    QRegExp rx ("\\*\\.([^ ^\\)]*)[ \\)]");   // regexp for suffix in filter
+    int index = rx.indexIn (filter,0);        // get first suffix in filter
+
+    if (index > -1)
+      file_dialog->setDefaultSuffix (rx.cap (1)); // found a suffix, set default
+    else
+      file_dialog->setDefaultSuffix ("");         // not found, clear default
+  }
+
+  bool file_editor_tab::check_valid_identifier (QString file_name)
+  {
+    QFileInfo file = QFileInfo (file_name);
+    QString base_name = file.baseName ();
+
+    if ((file.suffix () == "m")
+        && (! valid_identifier (base_name.toStdString ())))
+      {
+        int ans = QMessageBox::question (nullptr, tr ("Octave Editor"),
+                                         tr ("\"%1\"\n"
+                                             "is not a valid identifier.\n\n"
+                                             "If you keep this filename, you will not be able to\n"
+                                             "call your script using its name as an Octave command.\n\n"
+                                             "Do you want to choose another name?").arg (base_name),
+                                         QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+
+        if (ans == QMessageBox::Yes)
+          return true;
+      }
+
+    return false;
+  }
+
+  bool file_editor_tab::check_valid_codec (QTextCodec *codec)
+  {
+    if (! codec)
+      {
+        QMessageBox::critical (nullptr,
+                               tr ("Octave Editor"),
+                               tr ("The current codec %1\n"
+                                   "can not be applied.\n\n"
+                                   "Please select another one or cancel saving!").arg (_encoding));
+
+        return true;
+      }
+
+    if (! codec->canEncode (_edit_area->text ()))
+      {
+        int ans = QMessageBox::warning (nullptr,
+                                        tr ("Octave Editor"),
+                                        tr ("The current editor contents can not be encoded\n"
+                                            "with the selected codec %1.\n"
+                                            "Using it will result in data loss!\n\n"
+                                            "Do you want to chose another codec?").arg (_encoding),
+                                        QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
+
+        if (ans == QMessageBox::Yes)
+          return true;
+      }
+
+    return false;
+  }
+
+  void file_editor_tab::handle_save_file_as_answer (const QString& saveFileName)
+  {
+    if (_save_as_desired_eol != _edit_area->eolMode ())
+      convert_eol (this,_save_as_desired_eol);
+
+    if (saveFileName == _file_name)
+      {
+        save_file (saveFileName);
+      }
     else
-      _edit_area->setWhitespaceVisibility (QsciScintilla::WsVisible);
-  else
-    _edit_area->setWhitespaceVisibility (QsciScintilla::WsInvisible);
-
-  _edit_area->setEolVisibility (
-              settings->value ("editor/show_eol_chars",false).toBool ());
-
-  if (settings->value ("editor/showLineNumbers", true).toBool ())
-    {
-      _edit_area->setMarginLineNumbers (2, true);
-      auto_margin_width ();
-      connect (_edit_area, SIGNAL (linesChanged ()),
-               this, SLOT (auto_margin_width ()));
-    }
-  else
-    {
-      _edit_area->setMarginLineNumbers (2, false);
-      disconnect (_edit_area, SIGNAL (linesChanged ()), nullptr, nullptr);
-    }
-
-  _smart_indent = settings->value ("editor/auto_indent",true).toBool ();
-  _edit_area->setAutoIndent (_smart_indent);
-  _edit_area->setTabIndents
-        (settings->value ("editor/tab_indents_line",false).toBool ());
-  _edit_area->setBackspaceUnindents
-        (settings->value ("editor/backspace_unindents_line",false).toBool ());
-  _edit_area->setIndentationGuides
-        (settings->value ("editor/show_indent_guides",false).toBool ());
-  _edit_area->setIndentationsUseTabs
-        (settings->value ("editor/indent_uses_tabs",false).toBool ());
-  _edit_area->setIndentationWidth
-        (settings->value ("editor/indent_width",2).toInt ());
-
-  _edit_area->setTabWidth
-        (settings->value ("editor/tab_width",2).toInt ());
-
-  _edit_area->SendScintilla (QsciScintillaBase::SCI_SETHSCROLLBAR,
-        settings->value ("editor/show_hscroll_bar",true).toBool ());
-  _edit_area->SendScintilla (QsciScintillaBase::SCI_SETSCROLLWIDTH,-1);
-  _edit_area->SendScintilla (QsciScintillaBase::SCI_SETSCROLLWIDTHTRACKING,true);
-
-  _long_title = settings->value ("editor/longWindowTitle", false).toBool ();
-  update_window_title (_edit_area->isModified ());
-
-  _auto_endif = settings->value ("editor/auto_endif",1).toInt ();
-
-  // long line marker
-  int line_length = settings->value ("editor/long_line_column",80).toInt ();
-  _edit_area->setEdgeColumn (line_length);
-
-  if (settings->value ("editor/long_line_marker",true).toBool ())
-    {
-      if (settings->value ("editor/long_line_marker_line",true).toBool ())
-        _edit_area->setEdgeMode (QsciScintilla::EdgeLine);
+      {
+        // Have editor check for conflict, do not delete tab after save.
+        if (check_valid_identifier (saveFileName))
+          save_file_as (false);
+        else
+          emit editor_check_conflict_save (saveFileName, false);
+      }
+  }
+
+  void file_editor_tab::handle_save_file_as_answer_close (const QString& saveFileName)
+  {
+    if (_save_as_desired_eol != _edit_area->eolMode ())
+      {
+        _edit_area->setReadOnly (false);  // was set to read-only in save_file_as
+        convert_eol (this,_save_as_desired_eol);
+        _edit_area->setReadOnly (true);   // restore read-only mode
+      }
+
+    // saveFileName == _file_name can not happen, because we only can get here
+    // when we close a tab and _file_name is not a valid filename yet
+
+    // Have editor check for conflict, delete tab after save.
+    if (check_valid_identifier (saveFileName))
+      save_file_as (true);
+    else
+      emit editor_check_conflict_save (saveFileName, true);
+  }
+
+  void file_editor_tab::handle_save_file_as_answer_cancel (void)
+  {
+    // User canceled, allow editing again.
+    _edit_area->setReadOnly (false);
+  }
+
+  void file_editor_tab::file_has_changed (const QString&, bool do_close)
+  {
+    // Prevent popping up multiple message boxes when the file has
+    // been changed multiple times by temporarily removing from the
+    // file watcher.
+    QStringList trackedFiles = _file_system_watcher.files ();
+    if (! trackedFiles.isEmpty ())
+      _file_system_watcher.removePath (_file_name);
+
+    if (QFile::exists (_file_name) && ! do_close)
+      {
+        // The file is modified
+        if (_always_reload_changed_files)
+
+          load_file (_file_name);
+
+        else
+          {
+            // give editor and this tab the focus,
+            // possibly making the editor visible if it is hidden
+            emit set_focus_editor_signal (this);
+            _edit_area->setFocus ();
+
+            // Create a WindowModal message that blocks the edit area
+            // by making _edit_area parent.
+            QMessageBox *msgBox
+              = new QMessageBox (QMessageBox::Warning,
+                                 tr ("Octave Editor"),
+                                 tr ("It seems that \'%1\' has been modified by another application. Do you want to reload it?").
+                                 arg (_file_name),
+                                 QMessageBox::Yes | QMessageBox::No, this);
+
+            connect (msgBox, SIGNAL (finished (int)),
+                     this, SLOT (handle_file_reload_answer (int)));
+
+            msgBox->setWindowModality (Qt::WindowModal);
+            msgBox->setAttribute (Qt::WA_DeleteOnClose);
+            msgBox->show ();
+          }
+      }
+    else
+      {
+        // If desired and if file is not modified,
+        // close the file without any user interaction
+        if (do_close && ! _edit_area->isModified ())
+          {
+            handle_file_resave_answer (QMessageBox::Cancel);
+            return;
+          }
+
+        // give editor and this tab the focus,
+        // possibly making the editor visible  if it is hidden
+        emit set_focus_editor_signal (this);
+        _edit_area->setFocus ();
+
+        QString modified = "";
+        if (_edit_area->isModified ())
+          modified = tr ("\n\nWarning: The contents in the editor is modified!");
+
+        // Create a WindowModal message. The file editor tab can't be made
+        // parent because it may be deleted depending upon the response.
+        // Instead, change the _edit_area to read only.
+        QMessageBox *msgBox
+          = new QMessageBox (QMessageBox::Warning, tr ("Octave Editor"),
+                             tr ("It seems that the file\n"
+                                 "%1\n"
+                                 "has been deleted or renamed. Do you want to save it now?%2").
+                             arg (_file_name).arg (modified),
+                             QMessageBox::Save | QMessageBox::Close, nullptr);
+
+        _edit_area->setReadOnly (true);
+
+        connect (msgBox, SIGNAL (finished (int)),
+                 this, SLOT (handle_file_resave_answer (int)));
+
+        msgBox->setWindowModality (Qt::WindowModal);
+        msgBox->setAttribute (Qt::WA_DeleteOnClose);
+        msgBox->show ();
+      }
+  }
+
+  void file_editor_tab::notice_settings (const QSettings *settings, bool init)
+  {
+    // QSettings pointer is checked before emitting.
+
+    if (! init)
+      update_lexer_settings ();
+
+    // code folding
+    if (settings->value ("editor/code_folding",true).toBool ())
+      {
+        _edit_area->setMarginType (3, QsciScintilla::SymbolMargin);
+        _edit_area->setFolding (QsciScintilla::BoxedTreeFoldStyle , 3);
+      }
+    else
+      {
+        _edit_area->setFolding (QsciScintilla::NoFoldStyle, 3);
+      }
+
+    // status bar
+    if (settings->value ("editor/show_edit_status_bar",true).toBool ())
+      _status_bar->show ();
+    else
+      _status_bar->hide ();
+
+    //highlight current line color
+    QVariant default_var = QColor (240, 240, 240);
+    QColor setting_color = settings->value ("editor/highlight_current_line_color",
+                                            default_var).value<QColor> ();
+    _edit_area->setCaretLineBackgroundColor (setting_color);
+    _edit_area->setCaretLineVisible
+      (settings->value ("editor/highlightCurrentLine", true).toBool ());
+
+    bool match_keywords = settings->value
+      ("editor/codeCompletion_keywords",true).toBool ();
+    bool match_document = settings->value
+      ("editor/codeCompletion_document",true).toBool ();
+
+    QsciScintilla::AutoCompletionSource source = QsciScintilla::AcsNone;
+    if (match_keywords)
+      if (match_document)
+        source = QsciScintilla::AcsAll;
       else
-        {
-          if (settings->value ("editor/long_line_marker_background",false)
-                        .toBool ())
-            _edit_area->setEdgeMode (QsciScintilla::EdgeBackground);
-          else
-            _edit_area->setEdgeMode (QsciScintilla::EdgeLine);
-        }
-    }
-  else
-    _edit_area->setEdgeMode (QsciScintilla::EdgeNone);
-
-  // line wrapping and breaking
-  _edit_area->setWrapVisualFlags (QsciScintilla::WrapFlagByBorder);
-  _edit_area->setWrapIndentMode (QsciScintilla::WrapIndentSame);
-
-  if (settings->value ("editor/wrap_lines",false).toBool ())
-    _edit_area->setWrapMode (QsciScintilla::WrapWord);
-  else
-    _edit_area->setWrapMode (QsciScintilla::WrapNone);
-
-  if (settings->value ("editor/break_lines",false).toBool ())
-    _line_break = line_length;
-  else
-    _line_break = 0;
-
-  _line_break_comments =
-        settings->value ("editor/break_lines_comments",false).toBool ();
-
-  // highlight all occurrences of a word selected by a double click
-  _highlight_all_occurrences =
-        settings->value ("editor/highlight_all_occurrences", true).toBool ();
-
-  // reload changed files
-  _always_reload_changed_files =
-        settings->value ("editor/always_reload_changed_files",false).toBool ();
-
-  // Set cursor blinking depending on the settings.
-  // QScintilla ignores the application global settings, so some special
-  // handling is required
-  bool cursor_blinking;
-
-  if (settings->contains ("cursor_blinking"))
-    cursor_blinking = settings->value ("cursor_blinking",true).toBool ();
-  else
-    cursor_blinking = settings->value ("terminal/cursorBlinking",true).toBool ();
-
-  if (cursor_blinking)
-    _edit_area->SendScintilla (QsciScintillaBase::SCI_SETCARETPERIOD,500);
-  else
-    _edit_area->SendScintilla (QsciScintillaBase::SCI_SETCARETPERIOD,0);
-
-}
-
-
-void
-file_editor_tab::auto_margin_width ()
-{
-  _edit_area->setMarginWidth (2, "1" + QString::number (_edit_area->lines ()));
-}
-
-// the following close request was changed from a signal slot into a
-// normal function because we need the return value from close whether
-// the tab really was closed (for canceling exiting octave).
-// When emitting a signal, only the return value from the last slot
-// goes back to the sender
-bool
-file_editor_tab::conditional_close (void)
-{
-  return close ();
-}
-
-void
-file_editor_tab::change_editor_state (const QWidget *ID)
-{
-  if (ID != this)
-    {
-      // Widget may be going out of focus.  If so, record location.
-      if (_find_dialog)
-        {
-          if (_find_dialog->isVisible ())
-            {
-              _find_dialog_geometry = _find_dialog->geometry ();
-              _find_dialog->hide ();
-            }
-        }
+        source = QsciScintilla::AcsAPIs;
+    else if (match_document)
+      source = QsciScintilla::AcsDocument;
+    _edit_area->setAutoCompletionSource (source);
+
+    _edit_area->setAutoCompletionReplaceWord
+      (settings->value ("editor/codeCompletion_replace",false).toBool ());
+    _edit_area->setAutoCompletionCaseSensitivity
+      (settings->value ("editor/codeCompletion_case",true).toBool ());
+
+    if (settings->value ("editor/codeCompletion", true).toBool ())
+      _edit_area->setAutoCompletionThreshold
+        (settings->value ("editor/codeCompletion_threshold",2).toInt ());
+    else
+      _edit_area->setAutoCompletionThreshold (-1);
+
+    if (settings->value ("editor/show_white_space",false).toBool ())
+      if (settings->value ("editor/show_white_space_indent",false).toBool ())
+        _edit_area->setWhitespaceVisibility (QsciScintilla::WsVisibleAfterIndent);
+      else
+        _edit_area->setWhitespaceVisibility (QsciScintilla::WsVisible);
+    else
+      _edit_area->setWhitespaceVisibility (QsciScintilla::WsInvisible);
+
+    _edit_area->setEolVisibility (
+                                  settings->value ("editor/show_eol_chars",false).toBool ());
+
+    if (settings->value ("editor/showLineNumbers", true).toBool ())
+      {
+        _edit_area->setMarginLineNumbers (2, true);
+        auto_margin_width ();
+        connect (_edit_area, SIGNAL (linesChanged ()),
+                 this, SLOT (auto_margin_width ()));
+      }
+    else
+      {
+        _edit_area->setMarginLineNumbers (2, false);
+        disconnect (_edit_area, SIGNAL (linesChanged ()), nullptr, nullptr);
+      }
+
+    _smart_indent = settings->value ("editor/auto_indent",true).toBool ();
+    _edit_area->setAutoIndent (_smart_indent);
+    _edit_area->setTabIndents
+      (settings->value ("editor/tab_indents_line",false).toBool ());
+    _edit_area->setBackspaceUnindents
+      (settings->value ("editor/backspace_unindents_line",false).toBool ());
+    _edit_area->setIndentationGuides
+      (settings->value ("editor/show_indent_guides",false).toBool ());
+    _edit_area->setIndentationsUseTabs
+      (settings->value ("editor/indent_uses_tabs",false).toBool ());
+    _edit_area->setIndentationWidth
+      (settings->value ("editor/indent_width",2).toInt ());
+
+    _edit_area->setTabWidth
+      (settings->value ("editor/tab_width",2).toInt ());
+
+    _edit_area->SendScintilla (QsciScintillaBase::SCI_SETHSCROLLBAR,
+                               settings->value ("editor/show_hscroll_bar",true).toBool ());
+    _edit_area->SendScintilla (QsciScintillaBase::SCI_SETSCROLLWIDTH,-1);
+    _edit_area->SendScintilla (QsciScintillaBase::SCI_SETSCROLLWIDTHTRACKING,true);
+
+    _long_title = settings->value ("editor/longWindowTitle", false).toBool ();
+    update_window_title (_edit_area->isModified ());
+
+    _auto_endif = settings->value ("editor/auto_endif",1).toInt ();
+
+    // long line marker
+    int line_length = settings->value ("editor/long_line_column",80).toInt ();
+    _edit_area->setEdgeColumn (line_length);
+
+    if (settings->value ("editor/long_line_marker",true).toBool ())
+      {
+        if (settings->value ("editor/long_line_marker_line",true).toBool ())
+          _edit_area->setEdgeMode (QsciScintilla::EdgeLine);
+        else
+          {
+            if (settings->value ("editor/long_line_marker_background",false)
+                .toBool ())
+              _edit_area->setEdgeMode (QsciScintilla::EdgeBackground);
+            else
+              _edit_area->setEdgeMode (QsciScintilla::EdgeLine);
+          }
+      }
+    else
+      _edit_area->setEdgeMode (QsciScintilla::EdgeNone);
+
+    // line wrapping and breaking
+    _edit_area->setWrapVisualFlags (QsciScintilla::WrapFlagByBorder);
+    _edit_area->setWrapIndentMode (QsciScintilla::WrapIndentSame);
+
+    if (settings->value ("editor/wrap_lines",false).toBool ())
+      _edit_area->setWrapMode (QsciScintilla::WrapWord);
+    else
+      _edit_area->setWrapMode (QsciScintilla::WrapNone);
+
+    if (settings->value ("editor/break_lines",false).toBool ())
+      _line_break = line_length;
+    else
+      _line_break = 0;
+
+    _line_break_comments =
+      settings->value ("editor/break_lines_comments",false).toBool ();
+
+    // highlight all occurrences of a word selected by a double click
+    _highlight_all_occurrences =
+      settings->value ("editor/highlight_all_occurrences", true).toBool ();
+
+    // reload changed files
+    _always_reload_changed_files =
+      settings->value ("editor/always_reload_changed_files",false).toBool ();
+
+    // Set cursor blinking depending on the settings.
+    // QScintilla ignores the application global settings, so some special
+    // handling is required
+    bool cursor_blinking;
+
+    if (settings->contains ("cursor_blinking"))
+      cursor_blinking = settings->value ("cursor_blinking",true).toBool ();
+    else
+      cursor_blinking = settings->value ("terminal/cursorBlinking",true).toBool ();
+
+    if (cursor_blinking)
+      _edit_area->SendScintilla (QsciScintillaBase::SCI_SETCARETPERIOD,500);
+    else
+      _edit_area->SendScintilla (QsciScintillaBase::SCI_SETCARETPERIOD,0);
+
+  }
+
+
+  void file_editor_tab::auto_margin_width (void)
+  {
+    _edit_area->setMarginWidth (2, "1" + QString::number (_edit_area->lines ()));
+  }
+
+  // the following close request was changed from a signal slot into a
+  // normal function because we need the return value from close whether
+  // the tab really was closed (for canceling exiting octave).
+  // When emitting a signal, only the return value from the last slot
+  // goes back to the sender
+  bool file_editor_tab::conditional_close (void)
+  {
+    return close ();
+  }
+
+  void file_editor_tab::change_editor_state (const QWidget *ID)
+  {
+    if (ID != this)
+      {
+        // Widget may be going out of focus.  If so, record location.
+        if (_find_dialog)
+          {
+            if (_find_dialog->isVisible ())
+              {
+                _find_dialog_geometry = _find_dialog->geometry ();
+                _find_dialog->hide ();
+              }
+          }
+        return;
+      }
+
+    if (_find_dialog && _find_dialog_is_visible)
+      {
+        _find_dialog->setGeometry (_find_dialog_geometry);
+        QPoint p = _find_dialog->pos ();
+        _find_dialog->move (p.x ()+10, p.y ()+10);
+        _find_dialog->show ();
+      }
+
+    emit editor_state_changed (_copy_available, _is_octave_file);
+  }
+
+  void file_editor_tab::file_name_query (const QWidget *ID)
+  {
+    // A zero (null pointer) means that all file editor tabs
+    // should respond, otherwise just the desired file editor tab.
+    if (ID != this && ID != nullptr)
       return;
-    }
-
-  if (_find_dialog && _find_dialog_is_visible)
-    {
-      _find_dialog->setGeometry (_find_dialog_geometry);
-      QPoint p = _find_dialog->pos ();
-      _find_dialog->move (p.x ()+10, p.y ()+10);
-      _find_dialog->show ();
-    }
-
-  emit editor_state_changed (_copy_available, _is_octave_file);
-}
-
-void
-file_editor_tab::file_name_query (const QWidget *ID)
-{
-  // A zero (null pointer) means that all file editor tabs
-  // should respond, otherwise just the desired file editor tab.
-  if (ID != this && ID != nullptr)
-    return;
-
-  // This list also includes windows with name ""
-  emit add_filename_to_list (_file_name, _encoding, this);
-}
-
-void
-file_editor_tab::handle_file_reload_answer (int decision)
-{
-  if (decision == QMessageBox::Yes)
-    {
-      // reload: file is readded to the file watcher in set_file_name ()
-      load_file (_file_name);
-    }
-  else
-    {
-      // do not reload: readd to the file watche
-      _file_system_watcher.addPath (_file_name);
-    }
-}
-
-void
-file_editor_tab::handle_file_resave_answer (int decision)
-{
-  // check decision of user in dialog
-  if (decision == QMessageBox::Save)
-    {
-      save_file (_file_name);  // readds file to watcher in set_file_name ()
-      _edit_area->setReadOnly (false);  // delete read only flag
-    }
-  else
-    {
-      // Definitely close the file.
-      // Set modified to false to prevent the dialog box when the close event
-      // is posted. If the user cancels the close in this dialog the tab is
-      // left open with a non-existing file.
-      _edit_area->setModified (false);
-      close ();
-    }
-}
-
-void
-file_editor_tab::insert_debugger_pointer (const QWidget *ID, int line)
-{
-  if (ID != this || ID == nullptr)
-    return;
-
-  emit remove_all_positions ();  // debugger_position, unsure_debugger_position
-
-  if (line > 0)
-    {
-      marker *dp;
-
-      if (_edit_area->isModified ())
-        {
-          // The best that can be done if the editor contents has been
-          // modified is to see if there is a match with the original
-          // line number of any existing breakpoints.  We can put a normal
-          // debugger pointer at that breakpoint position.  Otherwise, it
-          // isn't certain whether the original line number and current line
-          // number match.
-          int editor_linenr = -1;
-          marker *dummy;
-          emit find_translated_line_number (line, editor_linenr, dummy);
-          if (editor_linenr != -1)
-            {
-              // Match with an existing breakpoint.
-              dp = new marker (_edit_area, line,
-                               marker::debugger_position, editor_linenr);
-            }
-          else
-            {
-              int original_linenr = -1;
-              editor_linenr = -1;
-              emit find_linenr_just_before (line, original_linenr, editor_linenr);
-              if (original_linenr >= 0)
-                {
-                  // Make a guess by using an offset from the breakpoint.
-                  int linenr_guess = editor_linenr + line - original_linenr;
-                  dp = new marker (_edit_area, line,
-                                   marker::unsure_debugger_position,
-                                   linenr_guess);
-                }
-              else
-                {
-                  // Can't make a very good guess, so just use the debugger
-                  // line number.
-                  dp = new marker (_edit_area, line,
-                                   marker::unsure_debugger_position);
-                }
-            }
-        }
-      else
-        dp = new marker (_edit_area, line, marker::debugger_position);
-
-      connect (this, SIGNAL (remove_position_via_debugger_linenr (int)),
-               dp,   SLOT (handle_remove_via_original_linenr (int)));
-      connect (this, SIGNAL (remove_all_positions (void)),
-               dp,   SLOT (handle_remove (void)));
-
-      center_current_line (false);
-    }
-}
-
-void
-file_editor_tab::delete_debugger_pointer (const QWidget *ID, int line)
-{
-  if (ID != this || ID == nullptr)
-    return;
-
-  if (line > 0)
-    emit remove_position_via_debugger_linenr (line);
-}
-
-void
-file_editor_tab::do_breakpoint_marker (bool insert, const QWidget *ID, int line,
-                                       const QString& cond)
-{
-  if (ID != this || ID == nullptr)
-    return;
-
-  if (line > 0)
-    {
-      if (insert)
-        {
-          int editor_linenr = -1;
-          marker *bp = nullptr;
-
-          // If comes back indicating a non-zero breakpoint marker,
-          // reuse it if possible
-          emit find_translated_line_number (line, editor_linenr, bp);
-          if (bp != nullptr)
-            {
-              if ((cond == "") != (bp->get_cond () == ""))
-                {       // can only reuse conditional bp as conditional
-                  emit remove_breakpoint_via_debugger_linenr (line);
-                  bp = nullptr;
-                }
-              else
-                bp->set_cond (cond);
-            }
-
-          if (bp == nullptr)
-            {
-              bp = new marker (_edit_area, line,
-                               cond == "" ? marker::breakpoint
-                                          : marker::cond_break, cond);
-
-              connect (this, SIGNAL (remove_breakpoint_via_debugger_linenr
-                                     (int)),
-                       bp,   SLOT (handle_remove_via_original_linenr (int)));
-              connect (this, SIGNAL (request_remove_breakpoint_via_editor_linenr
-                                     (int)),
-                       bp,   SLOT (handle_request_remove_via_editor_linenr
+
+    // This list also includes windows with name ""
+    emit add_filename_to_list (_file_name, _encoding, this);
+  }
+
+  void file_editor_tab::handle_file_reload_answer (int decision)
+  {
+    if (decision == QMessageBox::Yes)
+      {
+        // reload: file is readded to the file watcher in set_file_name ()
+        load_file (_file_name);
+      }
+    else
+      {
+        // do not reload: readd to the file watche
+        _file_system_watcher.addPath (_file_name);
+      }
+  }
+
+  void file_editor_tab::handle_file_resave_answer (int decision)
+  {
+    // check decision of user in dialog
+    if (decision == QMessageBox::Save)
+      {
+        save_file (_file_name);  // readds file to watcher in set_file_name ()
+        _edit_area->setReadOnly (false);  // delete read only flag
+      }
+    else
+      {
+        // Definitely close the file.
+        // Set modified to false to prevent the dialog box when the close event
+        // is posted. If the user cancels the close in this dialog the tab is
+        // left open with a non-existing file.
+        _edit_area->setModified (false);
+        close ();
+      }
+  }
+
+  void file_editor_tab::insert_debugger_pointer (const QWidget *ID, int line)
+  {
+    if (ID != this || ID == nullptr)
+      return;
+
+    emit remove_all_positions ();  // debugger_position, unsure_debugger_position
+
+    if (line > 0)
+      {
+        marker *dp;
+
+        if (_edit_area->isModified ())
+          {
+            // The best that can be done if the editor contents has been
+            // modified is to see if there is a match with the original
+            // line number of any existing breakpoints.  We can put a normal
+            // debugger pointer at that breakpoint position.  Otherwise, it
+            // isn't certain whether the original line number and current line
+            // number match.
+            int editor_linenr = -1;
+            marker *dummy;
+            emit find_translated_line_number (line, editor_linenr, dummy);
+            if (editor_linenr != -1)
+              {
+                // Match with an existing breakpoint.
+                dp = new marker (_edit_area, line,
+                                 marker::debugger_position, editor_linenr);
+              }
+            else
+              {
+                int original_linenr = -1;
+                editor_linenr = -1;
+                emit find_linenr_just_before (line, original_linenr, editor_linenr);
+                if (original_linenr >= 0)
+                  {
+                    // Make a guess by using an offset from the breakpoint.
+                    int linenr_guess = editor_linenr + line - original_linenr;
+                    dp = new marker (_edit_area, line,
+                                     marker::unsure_debugger_position,
+                                     linenr_guess);
+                  }
+                else
+                  {
+                    // Can't make a very good guess, so just use the debugger
+                    // line number.
+                    dp = new marker (_edit_area, line,
+                                     marker::unsure_debugger_position);
+                  }
+              }
+          }
+        else
+          dp = new marker (_edit_area, line, marker::debugger_position);
+
+        connect (this, SIGNAL (remove_position_via_debugger_linenr (int)),
+                 dp,   SLOT (handle_remove_via_original_linenr (int)));
+        connect (this, SIGNAL (remove_all_positions (void)),
+                 dp,   SLOT (handle_remove (void)));
+
+        center_current_line (false);
+      }
+  }
+
+  void file_editor_tab::delete_debugger_pointer (const QWidget *ID, int line)
+  {
+    if (ID != this || ID == nullptr)
+      return;
+
+    if (line > 0)
+      emit remove_position_via_debugger_linenr (line);
+  }
+
+  void file_editor_tab::do_breakpoint_marker (bool insert,
+                                              const QWidget *ID, int line,
+                                              const QString& cond)
+  {
+    if (ID != this || ID == nullptr)
+      return;
+
+    if (line > 0)
+      {
+        if (insert)
+          {
+            int editor_linenr = -1;
+            marker *bp = nullptr;
+
+            // If comes back indicating a non-zero breakpoint marker,
+            // reuse it if possible
+            emit find_translated_line_number (line, editor_linenr, bp);
+            if (bp != nullptr)
+              {
+                if ((cond == "") != (bp->get_cond () == ""))
+                  {       // can only reuse conditional bp as conditional
+                    emit remove_breakpoint_via_debugger_linenr (line);
+                    bp = nullptr;
+                  }
+                else
+                  bp->set_cond (cond);
+              }
+
+            if (bp == nullptr)
+              {
+                bp = new marker (_edit_area, line,
+                                 cond == "" ? marker::breakpoint
+                                 : marker::cond_break, cond);
+
+                connect (this, SIGNAL (remove_breakpoint_via_debugger_linenr
+                                       (int)),
+                         bp,   SLOT (handle_remove_via_original_linenr (int)));
+                connect (this, SIGNAL (request_remove_breakpoint_via_editor_linenr
+                                       (int)),
+                         bp,   SLOT (handle_request_remove_via_editor_linenr
                                      (int)));
-              connect (this, SIGNAL (remove_all_breakpoints (void)),
-                       bp,   SLOT (handle_remove (void)));
-              connect (this, SIGNAL (find_translated_line_number (int, int&,
-                                                                  marker*&)),
-                       bp,   SLOT (handle_find_translation (int, int&,
-                                                            marker*&)));
-              connect (this, SIGNAL (find_linenr_just_before (int, int&, int&)),
-                       bp,   SLOT (handle_find_just_before (int, int&, int&)));
-              connect (this, SIGNAL (report_marker_linenr (QIntList&,
-                                                           QStringList&)),
-                       bp,   SLOT (handle_report_editor_linenr (QIntList&,
-                                                                QStringList&)));
-              connect (bp,   SIGNAL (request_remove (int)),
-                       this, SLOT (handle_request_remove_breakpoint (int)));
-            }
-        }
-      else
-        emit remove_breakpoint_via_debugger_linenr (line);
-    }
-}
-
-void
-file_editor_tab::center_current_line (bool always)
-{
-  long int visible_lines
-    = _edit_area->SendScintilla (QsciScintillaBase::SCI_LINESONSCREEN);
-
-  if (visible_lines > 2)
-    {
-      int line, index;
-      _edit_area->getCursorPosition (&line, &index);
-      // compensate for "folding":
-      // step 1: expand the current line, if it was folded
-      _edit_area->SendScintilla (2232, line);   // SCI_ENSUREVISIBLE
-
-      // step 2: map file line num to "visible" one // SCI_VISIBLEFROMDOCLINE
-      int vis_line = _edit_area->SendScintilla (2220, line);
-
-      int first_line = _edit_area->firstVisibleLine ();
-
-      if (always || vis_line == first_line
-          || vis_line > first_line + visible_lines - 2)
-        {
-          first_line += (vis_line - first_line - (visible_lines - 1) / 2);
-          _edit_area->SendScintilla (2613, first_line); // SCI_SETFIRSTVISIBLELINE
-        }
-    }
-}
-
-void
-file_editor_tab::handle_lines_changed ()
-{
-  // the related signal is emitted before cursor-move-signal!
-  _lines_changed = true;
-}
-
-void
-file_editor_tab::handle_cursor_moved (int line, int col)
-{
-  if (_edit_area->SendScintilla (QsciScintillaBase::SCI_AUTOCACTIVE))
-    show_auto_completion (this);
-
-  if (_lines_changed)  // cursor moved and lines have changed
-    {
-      _lines_changed = false;
-      if (_is_octave_file && line == _line+1 && col < _col)
-        {
-          // Obviously, we have a newline here
-          if (_smart_indent || _auto_endif)
-            _edit_area->smart_indent (_smart_indent, _auto_endif, _line);
-        }
-    }
-
-  _line = line;
-  _col  = col;
-
-  _row_indicator->setNum (line+1);
-  _col_indicator->setNum (col+1);
-}
-
-// Slot that is entered each time a new character was typed.
-// It is used for handling line breaking if this is desired.
-// The related signal is emitted after the signal for a moved cursor
-// such that _col and _line can not be used for current position.
-void
-file_editor_tab::handle_char_added (int)
-{
-  if (_line_break)
+                connect (this, SIGNAL (remove_all_breakpoints (void)),
+                         bp,   SLOT (handle_remove (void)));
+                connect (this, SIGNAL (find_translated_line_number (int, int&,
+                                                                    marker*&)),
+                         bp,   SLOT (handle_find_translation (int, int&,
+                                                              marker*&)));
+                connect (this, SIGNAL (find_linenr_just_before (int, int&, int&)),
+                         bp,   SLOT (handle_find_just_before (int, int&, int&)));
+                connect (this, SIGNAL (report_marker_linenr (QIntList&,
+                                                             QStringList&)),
+                         bp,   SLOT (handle_report_editor_linenr (QIntList&,
+                                                                  QStringList&)));
+                connect (bp,   SIGNAL (request_remove (int)),
+                         this, SLOT (handle_request_remove_breakpoint (int)));
+              }
+          }
+        else
+          emit remove_breakpoint_via_debugger_linenr (line);
+      }
+  }
+
+  void file_editor_tab::center_current_line (bool always)
   {
-    // If line breaking is desired, get the current line and column.
-    // For taking the tab width into consideration, use own function
-    int line, col, pos;
-    _edit_area->get_current_position (&pos, &line, &col);
-
-    // immediately return if line has not reached the max. line length
-    if (col <= _line_break)
-      return;
-
-    // If line breaking is only desired in comments,
-    // return if not in a comment
-    int style_comment = octave_qscintilla::ST_NONE;
-    if (_line_break_comments)
+    long int visible_lines
+      = _edit_area->SendScintilla (QsciScintillaBase::SCI_LINESONSCREEN);
+
+    if (visible_lines > 2)
       {
-        // line breaking only in comments, check for comment style
-        style_comment = _edit_area->is_style_comment ();
-        if (! style_comment)
-          return;       // no comment, return
+        int line, index;
+        _edit_area->getCursorPosition (&line, &index);
+        // compensate for "folding":
+        // step 1: expand the current line, if it was folded
+        _edit_area->SendScintilla (2232, line);   // SCI_ENSUREVISIBLE
+
+        // step 2: map file line num to "visible" one // SCI_VISIBLEFROMDOCLINE
+        int vis_line = _edit_area->SendScintilla (2220, line);
+
+        int first_line = _edit_area->firstVisibleLine ();
+
+        if (always || vis_line == first_line
+            || vis_line > first_line + visible_lines - 2)
+          {
+            first_line += (vis_line - first_line - (visible_lines - 1) / 2);
+            _edit_area->SendScintilla (2613, first_line); // SCI_SETFIRSTVISIBLELINE
+          }
       }
-
-    // Here we go for breaking the current line by inserting a newline.
-    // For determining the position of a specific column, we have to get
-    // the column from the QScintila function without taking tab lengths
-    // into account, since the calculation from line/col to position ignores
-    // this, too
-    _edit_area->getCursorPosition (&line, &col);
-    int c = 0;
-    int col_space = col;
-    int indentation = _edit_area->indentation (line);
-
-    // Search the first occurence of space or tab backwards starting from
-    // the current column (col_space).
-    while (c != ' ' && c != '\t' && col_space > indentation)
+  }
+
+  void file_editor_tab::handle_lines_changed (void)
+  {
+    // the related signal is emitted before cursor-move-signal!
+    _lines_changed = true;
+  }
+
+  void file_editor_tab::handle_cursor_moved (int line, int col)
+  {
+    if (_edit_area->SendScintilla (QsciScintillaBase::SCI_AUTOCACTIVE))
+      show_auto_completion (this);
+
+    if (_lines_changed)  // cursor moved and lines have changed
+      {
+        _lines_changed = false;
+        if (_is_octave_file && line == _line+1 && col < _col)
+          {
+            // Obviously, we have a newline here
+            if (_smart_indent || _auto_endif)
+              _edit_area->smart_indent (_smart_indent, _auto_endif, _line);
+          }
+      }
+
+    _line = line;
+    _col  = col;
+
+    _row_indicator->setNum (line+1);
+    _col_indicator->setNum (col+1);
+  }
+
+  // Slot that is entered each time a new character was typed.
+  // It is used for handling line breaking if this is desired.
+  // The related signal is emitted after the signal for a moved cursor
+  // such that _col and _line can not be used for current position.
+  void file_editor_tab::handle_char_added (int)
+  {
+    if (_line_break)
       {
-        pos = _edit_area->positionFromLineIndex (line, col_space--);
-        c = _edit_area->SendScintilla (QsciScintillaBase::SCI_GETCHARAT, pos);
+        // If line breaking is desired, get the current line and column.
+        // For taking the tab width into consideration, use own function
+        int line, col, pos;
+        _edit_area->get_current_position (&pos, &line, &col);
+
+        // immediately return if line has not reached the max. line length
+        if (col <= _line_break)
+          return;
+
+        // If line breaking is only desired in comments,
+        // return if not in a comment
+        int style_comment = octave_qscintilla::ST_NONE;
+        if (_line_break_comments)
+          {
+            // line breaking only in comments, check for comment style
+            style_comment = _edit_area->is_style_comment ();
+            if (! style_comment)
+              return;       // no comment, return
+          }
+
+        // Here we go for breaking the current line by inserting a newline.
+        // For determining the position of a specific column, we have to get
+        // the column from the QScintila function without taking tab lengths
+        // into account, since the calculation from line/col to position ignores
+        // this, too
+        _edit_area->getCursorPosition (&line, &col);
+        int c = 0;
+        int col_space = col;
+        int indentation = _edit_area->indentation (line);
+
+        // Search the first occurence of space or tab backwards starting from
+        // the current column (col_space).
+        while (c != ' ' && c != '\t' && col_space > indentation)
+          {
+            pos = _edit_area->positionFromLineIndex (line, col_space--);
+            c = _edit_area->SendScintilla (QsciScintillaBase::SCI_GETCHARAT, pos);
+          }
+
+        // If a space or tab was found, break at this char,
+        // otherwise break at cursor position
+        int col_newline = col - 1;
+        if (c == ' ' || c == '\t')
+          col_newline = col_space + 1;
+
+        // Insert a newline char for breaking the line possibly followed
+        // by a line comment string
+        QString newline = QString ("\n");
+        style_comment = _edit_area->is_style_comment ();
+        if (style_comment == octave_qscintilla::ST_LINE_COMMENT)
+          newline = newline + _edit_area->comment_string ().at (0);
+        _edit_area->insertAt (newline, line, col_newline);
+
+        // Automatically indent the new line to the indentation of previous line
+        // and set the cursor position to the end of the indentation.
+        _edit_area->setIndentation (line + 1, indentation);
+        _edit_area->SendScintilla (QsciScintillaBase::SCI_LINEEND);
       }
-
-    // If a space or tab was found, break at this char,
-    // otherwise break at cursor position
-    int col_newline = col - 1;
-    if (c == ' ' || c == '\t')
-      col_newline = col_space + 1;
-
-    // Insert a newline char for breaking the line possibly followed
-    // by a line comment string
-    QString newline = QString ("\n");
-    style_comment = _edit_area->is_style_comment ();
-    if (style_comment == octave_qscintilla::ST_LINE_COMMENT)
-      newline = newline + _edit_area->comment_string ().at (0);
-    _edit_area->insertAt (newline, line, col_newline);
-
-    // Automatically indent the new line to the indentation of previous line
-    // and set the cursor position to the end of the indentation.
-    _edit_area->setIndentation (line + 1, indentation);
-    _edit_area->SendScintilla (QsciScintillaBase::SCI_LINEEND);
   }
-}
-
-// Slot handling a double click into the text area
-void
-file_editor_tab::handle_double_click (int, int, int modifier)
-{
-  if (! modifier)
-    {
-      // double clicks without modifier
-      // clear any existing indicators of this type
-      _edit_area->clear_selection_markers ();
-
-      if (_highlight_all_occurrences)
-        {
-          // Clear any previous selection.
-          _edit_area->set_word_selection ();
-
-          // highlighting of all occurrences of the clicked word is enabled
-
-          // get the resulting cursor position
-          // (required if click was beyond a line ending)
-          int line, col;
-          _edit_area->getCursorPosition (&line, &col);
-
-          // get the word at the cursor (if any)
-          QString word = _edit_area->wordAtLineIndex (line, col);
-          word = word.trimmed ();
-
-          if (! word.isEmpty ())
-            {
-              // word is not empty, so find all occurrences of the word
-
-              // remember first visible line for restoring the view afterwards
-              int first_line = _edit_area->firstVisibleLine ();
-
-              // search for first occurrence of the detected word
-              bool find_result_available
-                      = _edit_area->findFirst (word,
-                                               false,   // no regexp
-                                               true,    // case sensitive
-                                               true,    // whole words only
-                                               false,   // do not wrap
-                                               true,    // forward
-                                               0,0,     // from the beginning
-                                               false
+
+  // Slot handling a double click into the text area
+  void file_editor_tab::handle_double_click (int, int, int modifier)
+  {
+    if (! modifier)
+      {
+        // double clicks without modifier
+        // clear any existing indicators of this type
+        _edit_area->clear_selection_markers ();
+
+        if (_highlight_all_occurrences)
+          {
+            // Clear any previous selection.
+            _edit_area->set_word_selection ();
+
+            // highlighting of all occurrences of the clicked word is enabled
+
+            // get the resulting cursor position
+            // (required if click was beyond a line ending)
+            int line, col;
+            _edit_area->getCursorPosition (&line, &col);
+
+            // get the word at the cursor (if any)
+            QString word = _edit_area->wordAtLineIndex (line, col);
+            word = word.trimmed ();
+
+            if (! word.isEmpty ())
+              {
+                // word is not empty, so find all occurrences of the word
+
+                // remember first visible line for restoring the view afterwards
+                int first_line = _edit_area->firstVisibleLine ();
+
+                // search for first occurrence of the detected word
+                bool find_result_available
+                  = _edit_area->findFirst (word,
+                                           false,   // no regexp
+                                           true,    // case sensitive
+                                           true,    // whole words only
+                                           false,   // do not wrap
+                                           true,    // forward
+                                           0,0,     // from the beginning
+                                           false
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-                                             , true
+                                           , true
 #endif
-                                            );
-
-              // loop over all occurrences and set the related indicator
-              int oline, ocol;
-              int wlen = word.length ();
-
-              while (find_result_available)
-                {
-                  // get cursor position after having found an occurrence
-                  _edit_area->getCursorPosition (&oline, &ocol);
-                  // mark the selection
-                  _edit_area->show_selection_markers (oline, ocol, wlen);
-
-                  // find next occurrence
-                  find_result_available = _edit_area->findNext ();
-                }
-
-              // restore the visible area of the file, the cursor position,
-              // and the selection
-              _edit_area->setFirstVisibleLine (first_line);
-              _edit_area->setCursorPosition (line, col);
-              _edit_area->setSelection (line, col - wlen, line, col);
-              _edit_area->set_word_selection (word);
-            }
-        }
-    }
-}
-
-
-QString
-file_editor_tab::get_function_name ()
-{
-  QRegExp rxfun1 ("^[\t ]*function[^=]+=([^\\(]+)\\([^\\)]*\\)[\t ]*$");
-  QRegExp rxfun2 ("^[\t ]*function[\t ]+([^\\(]+)\\([^\\)]*\\)[\t ]*$");
-  QRegExp rxfun3 ("^[\t ]*function[^=]+=[\t ]*([^\\s]+)[\t ]*$");
-  QRegExp rxfun4 ("^[\t ]*function[\t ]+([^\\s]+)[\t ]*$");
-
-  QStringList lines = _edit_area->text ().split ("\n");
-
-  for (int i = 0; i < lines.count (); i++)
-    {
-      if (rxfun1.indexIn (lines.at (i)) != -1)
-        return rxfun1.cap (1).remove (QRegExp ("[ \t]*"));
-      else if (rxfun2.indexIn (lines.at (i)) != -1)
-        return rxfun2.cap (1).remove (QRegExp ("[ \t]*"));
-      else if (rxfun3.indexIn (lines.at (i)) != -1)
-        return rxfun3.cap (1).remove (QRegExp ("[ \t]*"));
-      else if (rxfun4.indexIn (lines.at (i)) != -1)
-        return rxfun4.cap (1).remove (QRegExp ("[ \t]*"));
-    }
-
-  return QString ();
+                                           );
+
+                // loop over all occurrences and set the related indicator
+                int oline, ocol;
+                int wlen = word.length ();
+
+                while (find_result_available)
+                  {
+                    // get cursor position after having found an occurrence
+                    _edit_area->getCursorPosition (&oline, &ocol);
+                    // mark the selection
+                    _edit_area->show_selection_markers (oline, ocol, wlen);
+
+                    // find next occurrence
+                    find_result_available = _edit_area->findNext ();
+                  }
+
+                // restore the visible area of the file, the cursor position,
+                // and the selection
+                _edit_area->setFirstVisibleLine (first_line);
+                _edit_area->setCursorPosition (line, col);
+                _edit_area->setSelection (line, col - wlen, line, col);
+                _edit_area->set_word_selection (word);
+              }
+          }
+      }
+  }
+
+  QString file_editor_tab::get_function_name (void)
+  {
+    QRegExp rxfun1 ("^[\t ]*function[^=]+=([^\\(]+)\\([^\\)]*\\)[\t ]*$");
+    QRegExp rxfun2 ("^[\t ]*function[\t ]+([^\\(]+)\\([^\\)]*\\)[\t ]*$");
+    QRegExp rxfun3 ("^[\t ]*function[^=]+=[\t ]*([^\\s]+)[\t ]*$");
+    QRegExp rxfun4 ("^[\t ]*function[\t ]+([^\\s]+)[\t ]*$");
+
+    QStringList lines = _edit_area->text ().split ("\n");
+
+    for (int i = 0; i < lines.count (); i++)
+      {
+        if (rxfun1.indexIn (lines.at (i)) != -1)
+          return rxfun1.cap (1).remove (QRegExp ("[ \t]*"));
+        else if (rxfun2.indexIn (lines.at (i)) != -1)
+          return rxfun2.cap (1).remove (QRegExp ("[ \t]*"));
+        else if (rxfun3.indexIn (lines.at (i)) != -1)
+          return rxfun3.cap (1).remove (QRegExp ("[ \t]*"));
+        else if (rxfun4.indexIn (lines.at (i)) != -1)
+          return rxfun4.cap (1).remove (QRegExp ("[ \t]*"));
+      }
+
+    return QString ();
+  }
 }
 
 #endif
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -35,281 +35,285 @@ along with Octave; see the file COPYING.
 
 #include "find-dialog.h"
 #include "octave-qscintilla.h"
 #include "builtin-defun-decls.h"
 
 #include "marker.h" /* Only needed for typedef of "QIntList", which may be
                        typedefed elsewhere.  Could use common location. */
 
-
 class octave_value_list;
 
-class file_editor;
+namespace octave
+{
+  class file_editor;
 
-class file_editor_tab : public QWidget
-{
-  Q_OBJECT
+  class file_editor_tab : public QWidget
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  file_editor_tab (const QString& directory = "");
+    file_editor_tab (const QString& directory = "");
 
-  ~file_editor_tab (void);
+    ~file_editor_tab (void);
 
-  octave_qscintilla * qsci_edit_area () { return _edit_area; }
+    octave_qscintilla * qsci_edit_area (void) { return _edit_area; }
 
-  // Will initiate close if associated with the identifier tag.
-  bool conditional_close (void);
+    // Will initiate close if associated with the identifier tag.
+    bool conditional_close (void);
 
-  static void reset_cancel (void) {_cancelled = false;}
-  static bool was_cancelled (void) {return _cancelled;}
+    static void reset_cancel (void) {_cancelled = false;}
+    static bool was_cancelled (void) {return _cancelled;}
 
-public slots:
+  public slots:
 
-  void update_window_title (bool modified);
-  void handle_copy_available (bool enableCopy);
-  void handle_margin_clicked (int line, int margin,
-                              Qt::KeyboardModifiers state);
+    void update_window_title (bool modified);
+    void handle_copy_available (bool enableCopy);
+    void handle_margin_clicked (int line, int margin,
+                                Qt::KeyboardModifiers state);
 
-  // Tells the editor tab to react on changed settings.
-  void notice_settings (const QSettings *settings, bool init = false);
+    // Tells the editor tab to react on changed settings.
+    void notice_settings (const QSettings *settings, bool init = false);
 
-  // Change to a different editor tab by identifier tag.
-  void change_editor_state (const QWidget *ID);
+    // Change to a different editor tab by identifier tag.
+    void change_editor_state (const QWidget *ID);
 
-  // Simply transmit filename.
-  void file_name_query (const QWidget *ID);
+    // Simply transmit filename.
+    void file_name_query (const QWidget *ID);
 
-  void set_focus (const QWidget *ID);
-  void set_current_directory (const QString& dir);
-  void context_help (const QWidget *ID, bool);
-  void context_edit (const QWidget *ID);
-  void check_modified_file (void);
-  void save_file (const QWidget *ID);
-  void save_file (const QWidget *ID, const QString& fileName,
-                  bool remove_on_success);
-  void save_file_as (const QWidget *ID);
-  void print_file (const QWidget *ID);
-  void run_file (const QWidget *ID);
-  void context_run (const QWidget *ID);
-  void toggle_bookmark (const QWidget *ID);
-  void next_bookmark (const QWidget *ID);
-  void previous_bookmark (const QWidget *ID);
-  void remove_bookmark (const QWidget *ID);
+    void set_focus (const QWidget *ID);
+    void set_current_directory (const QString& dir);
+    void context_help (const QWidget *ID, bool);
+    void context_edit (const QWidget *ID);
+    void check_modified_file (void);
+    void save_file (const QWidget *ID);
+    void save_file (const QWidget *ID, const QString& fileName,
+                    bool remove_on_success);
+    void save_file_as (const QWidget *ID);
+    void print_file (const QWidget *ID);
+    void run_file (const QWidget *ID);
+    void context_run (const QWidget *ID);
+    void toggle_bookmark (const QWidget *ID);
+    void next_bookmark (const QWidget *ID);
+    void previous_bookmark (const QWidget *ID);
+    void remove_bookmark (const QWidget *ID);
 
-  void toggle_breakpoint (const QWidget *ID);
-  void next_breakpoint (const QWidget *ID);
-  void previous_breakpoint (const QWidget *ID);
-  void remove_all_breakpoints (const QWidget *ID);
+    void toggle_breakpoint (const QWidget *ID);
+    void next_breakpoint (const QWidget *ID);
+    void previous_breakpoint (const QWidget *ID);
+    void remove_all_breakpoints (const QWidget *ID);
 
-  void scintilla_command (const QWidget *, unsigned int);
+    void scintilla_command (const QWidget *, unsigned int);
+
+    void comment_selected_text (const QWidget *ID, bool input_str);
+    void uncomment_selected_text (const QWidget *ID);
 
-  void comment_selected_text (const QWidget *ID, bool input_str);
-  void uncomment_selected_text (const QWidget *ID);
+    void indent_selected_text (const QWidget *ID);
+    void unindent_selected_text (const QWidget *ID);
+    void smart_indent_line_or_selected_text (const QWidget *ID);
+    void convert_eol (const QWidget *ID, QsciScintilla::EolMode);
 
-  void indent_selected_text (const QWidget *ID);
-  void unindent_selected_text (const QWidget *ID);
-  void smart_indent_line_or_selected_text (const QWidget *ID);
-  void convert_eol (const QWidget *ID, QsciScintilla::EolMode);
+    void zoom_in (const QWidget *ID);
+    void zoom_out (const QWidget *ID);
+    void zoom_normal (const QWidget *ID);
 
-  void zoom_in (const QWidget *ID);
-  void zoom_out (const QWidget *ID);
-  void zoom_normal (const QWidget *ID);
+    void find (const QWidget *ID, QList<QAction *>);
+    void find_next (const QWidget *ID);
+    void find_previous (const QWidget *ID);
+    void goto_line (const QWidget *ID, int line = -1);
+    void move_match_brace (const QWidget *ID, bool select);
+    void show_auto_completion (const QWidget *ID);
 
-  void find (const QWidget *ID, QList<QAction *>);
-  void find_next (const QWidget *ID);
-  void find_previous (const QWidget *ID);
-  void goto_line (const QWidget *ID, int line = -1);
-  void move_match_brace (const QWidget *ID, bool select);
-  void show_auto_completion (const QWidget *ID);
+    void insert_debugger_pointer (const QWidget *ID, int line = -1);
+    void delete_debugger_pointer (const QWidget *ID, int line = -1);
+
+    void do_breakpoint_marker (bool insert, const QWidget *ID, int line = -1,
+                               const QString& cond = "");
+
+    void recover_from_exit (void);
+    void set_modified (bool modified = true);
 
-  void insert_debugger_pointer (const QWidget *ID, int line = -1);
-  void delete_debugger_pointer (const QWidget *ID, int line = -1);
+    void set_encoding (const QString& new_encoding);
+
+    QString load_file (const QString& fileName);
 
-  void do_breakpoint_marker (bool insert, const QWidget *ID, int line = -1,
-                             const QString& cond = "");
+    void new_file (const QString& commands = QString ());
 
-  void recover_from_exit (void);
-  void set_modified (bool modified = true);
+    void file_has_changed (const QString& path, bool do_close = false);
 
-  void set_encoding (const QString& new_encoding);
+    void handle_context_menu_edit (const QString&);
+    void handle_context_menu_break_condition (int linenr);
 
-  QString load_file (const QString& fileName);
-
-  void new_file (const QString& commands = QString ());
-
-  void file_has_changed (const QString& path, bool do_close = false);
+    void handle_request_add_breakpoint (int line, const QString& cond);
+    void handle_request_remove_breakpoint (int line);
 
-  void handle_context_menu_edit (const QString&);
-  void handle_context_menu_break_condition (int linenr);
+    void handle_octave_result (QObject *requester, QString& command,
+                               octave_value_list& result);
 
-  void handle_request_add_breakpoint (int line, const QString& cond);
-  void handle_request_remove_breakpoint (int line);
-
-  void handle_octave_result (QObject *requester, QString& command,
-                             octave_value_list& result);
+  signals:
 
-signals:
+    void file_name_changed (const QString& fileName, const QString& toolTip);
+    void editor_state_changed (bool copy_available, bool is_octave_file);
+    void set_focus_editor_signal (QWidget *);
+    void tab_remove_request (void);
+    void add_filename_to_list (const QString&, const QString&, QWidget *);
+    void mru_add_file (const QString& file_name, const QString& encoding);
+    void editor_check_conflict_save (const QString& saveFileName,
+                                     bool remove_on_success);
+    void run_file_signal (const QFileInfo& info);
+    void request_open_file (const QString&);
+    void edit_mfile_request (const QString&, const QString&,
+                             const QString&, int);
 
-  void file_name_changed (const QString& fileName, const QString& toolTip);
-  void editor_state_changed (bool copy_available, bool is_octave_file);
-  void set_focus_editor_signal (QWidget *);
-  void tab_remove_request ();
-  void add_filename_to_list (const QString&, const QString&, QWidget *);
-  void mru_add_file (const QString& file_name, const QString& encoding);
-  void editor_check_conflict_save (const QString& saveFileName,
-                                   bool remove_on_success);
-  void run_file_signal (const QFileInfo& info);
-  void request_open_file (const QString&);
-  void edit_mfile_request (const QString&, const QString&,
-                           const QString&, int);
+    void request_find_next (void);
+    void request_find_previous (void);
 
-  void request_find_next (void);
-  void request_find_previous (void);
+    void remove_breakpoint_via_debugger_linenr (int debugger_linenr);
+    void request_remove_breakpoint_via_editor_linenr (int editor_linenr);
+    void remove_all_breakpoints (void);
+    void find_translated_line_number (int original_linenr,
+                                      int& translated_linenr, marker*&);
+    void find_linenr_just_before (int linenr, int& original_linenr,
+                                  int& editor_linenr);
+    void report_marker_linenr (QIntList& lines, QStringList& conditions);
+    void remove_position_via_debugger_linenr (int debugger_linenr);
+    void remove_all_positions (void);
+    void execute_command_in_terminal_signal (const QString&);
 
-  void remove_breakpoint_via_debugger_linenr (int debugger_linenr);
-  void request_remove_breakpoint_via_editor_linenr (int editor_linenr);
-  void remove_all_breakpoints (void);
-  void find_translated_line_number (int original_linenr,
-                                    int& translated_linenr, marker*&);
-  void find_linenr_just_before (int linenr, int& original_linenr,
-                                int& editor_linenr);
-  void report_marker_linenr (QIntList& lines, QStringList& conditions);
-  void remove_position_via_debugger_linenr (int debugger_linenr);
-  void remove_all_positions (void);
-  void execute_command_in_terminal_signal (const QString&);
-  // FIXME: The following is similar to "process_octave_code" signal.  However,
-  // currently that signal is connected to something that simply focuses a
-  // window and not actually communicate with Octave.
-  // void evaluate_octave_command (const QString& command);
+    // FIXME: The following is similar to "process_octave_code"
+    // signal.  However, currently that signal is connected to
+    // something that simply focuses a window and not actually
+    // communicate with Octave.
+    //
+    // void evaluate_octave_command (const QString& command);
+
+  protected:
+
+    void closeEvent (QCloseEvent *event);
+    void set_file_name (const QString& fileName);
 
-protected:
+  private slots:
 
-  void closeEvent (QCloseEvent *event);
-  void set_file_name (const QString& fileName);
-
-private slots:
+    // When user closes message box for reload question.
+    void handle_file_reload_answer (int decision);
 
-  // When user closes message box for reload question.
-  void handle_file_reload_answer (int decision);
+    // When user closes message box for resave question.
+    void handle_file_resave_answer (int decision);
 
-  // When user closes message box for resave question.
-  void handle_file_resave_answer (int decision);
+    // When user closes message box for modified question.
+    void handle_file_modified_answer (int decision);
 
-  // When user closes message box for modified question.
-  void handle_file_modified_answer (int decision);
+    // When user closes find_dialog box.
+    void handle_find_dialog_finished (int decision);
 
-  // When user closes find_dialog box.
-  void handle_find_dialog_finished (int decision);
+    // When user closes QFileDialog box.
+    void handle_save_file_as_answer (const QString& fileName);
+    void handle_save_file_as_answer_close (const QString& fileName);
+    void handle_save_file_as_answer_cancel (void);
+    void handle_save_as_filter_selected (const QString& filter);
+    void handle_combo_eol_current_index (int index);
+    void handle_combo_enc_current_index (QString text);
 
-  // When user closes QFileDialog box.
-  void handle_save_file_as_answer (const QString& fileName);
-  void handle_save_file_as_answer_close (const QString& fileName);
-  void handle_save_file_as_answer_cancel ();
-  void handle_save_as_filter_selected (const QString& filter);
-  void handle_combo_eol_current_index (int index);
-  void handle_combo_enc_current_index (QString text);
+    // When apis preparation has finished and is ready to save
+    void save_apis_info (void);
 
-  // When apis preparation has finished and is ready to save
-  void save_apis_info ();
+    // When the numer of lines changes -> adapt width of margin
+    void auto_margin_width (void);
 
-  // When the numer of lines changes -> adapt width of margin
-  void auto_margin_width ();
+    void handle_cursor_moved (int line, int col);
+    void handle_char_added (int character);
+    void handle_double_click (int p, int l, int modifier);
+    void handle_lines_changed (void);
 
-  void handle_cursor_moved (int line, int col);
-  void handle_char_added (int character);
-  void handle_double_click (int p, int l, int modifier);
-  void handle_lines_changed (void);
+  private:
 
-private:
+    struct bp_info
+    {
+      bp_info (const QString& fname, int l = 0, const QString& cond = "");
 
-  struct bp_info
-  {
-    bp_info (const QString& fname, int l = 0, const QString& cond = "");
+      int line;
+      std::string file;
+      std::string dir;
+      std::string function_name;
+      std::string condition;
+    };
 
-    int line;
-    std::string file;
-    std::string dir;
-    std::string function_name;
-    std::string condition;
-  };
+    bool valid_file_name (const QString& file = QString ());
+    bool exit_debug_and_clear (const QString& full_name,
+                               const QString& base_name);
+    void save_file (const QString& saveFileName, bool remove_on_success = false,
+                    bool restore_breakpoints = true);
+    void save_file_as (bool remove_on_success = false);
+    bool check_valid_identifier (QString file_name);
+    bool check_valid_codec (QTextCodec *codec);
 
-  bool valid_file_name (const QString& file=QString ());
-  bool exit_debug_and_clear (const QString& full_name,
-                             const QString& base_name);
-  void save_file (const QString& saveFileName, bool remove_on_success = false,
-                                               bool restore_breakpoints = true);
-  void save_file_as (bool remove_on_success = false);
-  bool check_valid_identifier (QString file_name);
-  bool check_valid_codec (QTextCodec *codec);
+    bool unchanged_or_saved (void);
+
+    void update_lexer (void);
+    void update_lexer_settings (void);
 
-  bool unchanged_or_saved (void);
-
-  void update_lexer ();
-  void update_lexer_settings ();
+    void show_dialog (QDialog *dlg, bool modal);
+    int check_file_modified (void);
+    void do_comment_selected_text (bool comment, bool input_str = false);
+    void do_indent_selected_text (bool indent);
+    void do_smart_indent_line_or_selected_text (void);
 
-  void show_dialog (QDialog *dlg, bool modal);
-  int check_file_modified ();
-  void do_comment_selected_text (bool comment, bool input_str = false);
-  void do_indent_selected_text (bool indent);
-  void do_smart_indent_line_or_selected_text (void);
+    void add_breakpoint_callback (const bp_info& info);
+    void remove_breakpoint_callback (const bp_info& info);
+    void remove_all_breakpoints_callback (const bp_info& info);
+    void check_restore_breakpoints (void);
+    void center_current_line (bool always=true);
+
+    void add_octave_apis (octave_value_list key_ovl);
+    QString get_function_name (void);
 
-  void add_breakpoint_callback (const bp_info& info);
-  void remove_breakpoint_callback (const bp_info& info);
-  void remove_all_breakpoints_callback (const bp_info& info);
-  void check_restore_breakpoints (void);
-  void center_current_line (bool always=true);
+    QsciScintilla::EolMode detect_eol_mode (void);
+    void update_eol_indicator (void);
+
+    octave_qscintilla *_edit_area;
 
-  void add_octave_apis (octave_value_list key_ovl);
-  QString get_function_name ();
+    QStatusBar *_status_bar;
+    QLabel *_row_indicator;
+    QLabel *_col_indicator;
+    QLabel *_eol_indicator;
+    QLabel *_enc_indicator;
 
-  QsciScintilla::EolMode detect_eol_mode ();
-  void update_eol_indicator ();
-
-  octave_qscintilla *_edit_area;
+    QsciScintilla::EolMode _save_as_desired_eol;
 
-  QStatusBar *_status_bar;
-  QLabel *_row_indicator;
-  QLabel *_col_indicator;
-  QLabel *_eol_indicator;
-  QLabel *_enc_indicator;
-
-  QsciScintilla::EolMode _save_as_desired_eol;
+    QString _file_name;
+    QString _file_name_short;
+    QString _ced;
+    QString _encoding;
+    QString _new_encoding;
 
-  QString _file_name;
-  QString _file_name_short;
-  QString _ced;
-  QString _encoding;
-  QString _new_encoding;
+    bool _long_title;
+    bool _copy_available;
+    bool _is_octave_file;
+    bool _always_reload_changed_files;
+    bool _smart_indent;
+    int _auto_endif;
 
-  bool _long_title;
-  bool _copy_available;
-  bool _is_octave_file;
-  bool _always_reload_changed_files;
-  bool _smart_indent;
-  int _auto_endif;
+    QFileSystemWatcher _file_system_watcher;
+
+    QIntList _bp_lines;
+    QStringList _bp_conditions;
 
-  QFileSystemWatcher _file_system_watcher;
-
-  QIntList _bp_lines;
-  QStringList _bp_conditions;
+    find_dialog *_find_dialog;
+    bool _find_dialog_is_visible;
+    QRect _find_dialog_geometry;
 
-  find_dialog *_find_dialog;
-  bool _find_dialog_is_visible;
-  QRect _find_dialog_geometry;
+    QsciAPIs *_lexer_apis;
+    QString _prep_apis_file;
 
-  QsciAPIs *_lexer_apis;
-  QString _prep_apis_file;
+    static bool _cancelled;
 
-  static bool _cancelled;
-
-  int _line_break;
-  bool _line_break_comments;
-  int _line;
-  int _col;
-  bool _lines_changed;
-  bool _highlight_all_occurrences;
-  int m_bp_restore_count;
-
-};
+    int _line_break;
+    bool _line_break_comments;
+    int _line;
+    int _col;
+    bool _lines_changed;
+    bool _highlight_all_occurrences;
+    int m_bp_restore_count;
+  };
+}
 
 #endif
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -43,2363 +43,2257 @@ along with Octave; see the file COPYING.
 #include <QVBoxLayout>
 #include <Qsci/qscicommandset.h>
 
 #include "main-window.h"
 #include "oct-map.h"
 #include "octave-link.h"
 #include "utils.h"
 
-
-// Functions of the the reimplemented tab widget
+namespace octave
+{
+  // Functions of the the reimplemented tab widget
 
-file_editor_tab_widget::file_editor_tab_widget (QWidget *p)
-  : QTabWidget (p)
-{
-  tab_bar *bar = new tab_bar (this);
+  file_editor_tab_widget::file_editor_tab_widget (QWidget *p)
+    : QTabWidget (p)
+  {
+    tab_bar *bar = new tab_bar (this);
 
-  connect (bar, SIGNAL (close_current_tab_signal (bool)),
-           p->parent (), SLOT (request_close_file (bool)));
+    connect (bar, SIGNAL (close_current_tab_signal (bool)),
+             p->parent (), SLOT (request_close_file (bool)));
 
-  this->setTabBar (bar);
+    this->setTabBar (bar);
 
-  setTabsClosable (true);
+    setTabsClosable (true);
 #if defined (HAVE_QTABWIDGET_SETMOVABLE)
-  setMovable (true);
+    setMovable (true);
 #endif
-}
+  }
 
-tab_bar *
-file_editor_tab_widget::get_tab_bar (void) const
-{
-  return qobject_cast<tab_bar *> (tabBar ());
-}
+  tab_bar * file_editor_tab_widget::get_tab_bar (void) const
+  {
+    return qobject_cast<tab_bar *> (tabBar ());
+  }
 
 
-// File editor
+  // File editor
 
-file_editor::file_editor (QWidget *p)
-  : file_editor_interface (p)
-{
-  // Set current editing directory before construct because loaded
-  // files will change ced accordingly.
-  m_ced = QDir::currentPath ();
+  file_editor::file_editor (QWidget *p)
+    : file_editor_interface (p)
+  {
+    // Set current editing directory before construct because loaded
+    // files will change ced accordingly.
+    m_ced = QDir::currentPath ();
 
-  // set action that are later added by the main window to null,
-  // preventing access to them when they are still undefined
-  m_undo_action = nullptr;
-  m_copy_action = nullptr;
-  m_paste_action = nullptr;
-  m_selectall_action = nullptr;
-  m_closed = false;
-  m_no_focus = false;
+    // set action that are later added by the main window to null,
+    // preventing access to them when they are still undefined
+    m_undo_action = nullptr;
+    m_copy_action = nullptr;
+    m_paste_action = nullptr;
+    m_selectall_action = nullptr;
+    m_closed = false;
+    m_no_focus = false;
 
-  construct ();
-
-  // actions that should also be available in the find dialog
-  m_fetab_actions << m_find_next_action;
-  m_fetab_actions << m_find_previous_action;
+    construct ();
 
-  setVisible (false);
-  setAcceptDrops (true);
-}
+    // actions that should also be available in the find dialog
+    m_fetab_actions << m_find_next_action;
+    m_fetab_actions << m_find_previous_action;
 
-file_editor::~file_editor (void)
-{
-  delete m_mru_file_menu;
-}
+    setVisible (false);
+    setAcceptDrops (true);
+  }
+
+  file_editor::~file_editor (void)
+  {
+    delete m_mru_file_menu;
+  }
 
-// insert global actions, that should also be displayed in the editor window,
-// into the editor's menu and/or toolbar
-void
-file_editor::insert_global_actions (QList<QAction*> shared_actions)
-{
-  // actions/menus that have to be added to the toolbar or the menu
-  QAction *open_action = shared_actions.at (OPEN_ACTION);
-  QAction *new_action = shared_actions.at (NEW_SCRIPT_ACTION);
-  QAction *new_fcn_action = shared_actions.at (NEW_FUNCTION_ACTION);
-  m_fileMenu->insertAction (m_mru_file_menu->menuAction (), open_action);
-  m_fileMenu->insertAction (open_action, new_fcn_action);
-  m_fileMenu->insertAction (new_fcn_action, new_action);
-  m_tool_bar->insertAction (m_popdown_mru_action, open_action);
-  m_tool_bar->insertAction (open_action, new_action);
+  // insert global actions, that should also be displayed in the editor window,
+  // into the editor's menu and/or toolbar
+  void file_editor::insert_global_actions (QList<QAction*> shared_actions)
+  {
+    // actions/menus that have to be added to the toolbar or the menu
+    QAction *open_action = shared_actions.at (OPEN_ACTION);
+    QAction *new_action = shared_actions.at (NEW_SCRIPT_ACTION);
+    QAction *new_fcn_action = shared_actions.at (NEW_FUNCTION_ACTION);
+    m_fileMenu->insertAction (m_mru_file_menu->menuAction (), open_action);
+    m_fileMenu->insertAction (open_action, new_fcn_action);
+    m_fileMenu->insertAction (new_fcn_action, new_action);
+    m_tool_bar->insertAction (m_popdown_mru_action, open_action);
+    m_tool_bar->insertAction (open_action, new_action);
 
-  // actions that are additionally enabled/disabled later by the editor
-  // undo
-  m_undo_action = shared_actions.at (UNDO_ACTION);
-  m_tool_bar->insertAction (m_redo_action,m_undo_action);
-  m_edit_menu->insertAction (m_redo_action,m_undo_action);
-  // copy
-  m_copy_action = shared_actions.at (COPY_ACTION);
-  m_tool_bar->insertAction (m_cut_action,m_copy_action);
-  m_edit_menu->insertAction (m_cut_action,m_copy_action);
-  // select all
-  m_selectall_action = shared_actions.at (SELECTALL_ACTION);
-  m_edit_menu->insertAction (m_find_action,m_selectall_action);
-  m_edit_menu->insertSeparator (m_find_action);
-  // paste
-  m_paste_action = shared_actions.at (PASTE_ACTION);
-  m_tool_bar->insertAction (m_find_action,m_paste_action);
-  m_edit_menu->insertAction (m_selectall_action,m_paste_action);
-  m_edit_menu->insertSeparator (m_selectall_action);
-  // find files
-  m_find_files_action = shared_actions.at (FIND_FILES_ACTION);
-  m_edit_menu->insertAction (m_find_action, m_find_files_action);
-}
+    // actions that are additionally enabled/disabled later by the editor
+    // undo
+    m_undo_action = shared_actions.at (UNDO_ACTION);
+    m_tool_bar->insertAction (m_redo_action,m_undo_action);
+    m_edit_menu->insertAction (m_redo_action,m_undo_action);
+    // copy
+    m_copy_action = shared_actions.at (COPY_ACTION);
+    m_tool_bar->insertAction (m_cut_action,m_copy_action);
+    m_edit_menu->insertAction (m_cut_action,m_copy_action);
+    // select all
+    m_selectall_action = shared_actions.at (SELECTALL_ACTION);
+    m_edit_menu->insertAction (m_find_action,m_selectall_action);
+    m_edit_menu->insertSeparator (m_find_action);
+    // paste
+    m_paste_action = shared_actions.at (PASTE_ACTION);
+    m_tool_bar->insertAction (m_find_action,m_paste_action);
+    m_edit_menu->insertAction (m_selectall_action,m_paste_action);
+    m_edit_menu->insertSeparator (m_selectall_action);
+    // find files
+    m_find_files_action = shared_actions.at (FIND_FILES_ACTION);
+    m_edit_menu->insertAction (m_find_action, m_find_files_action);
+  }
 
-void
-file_editor::handle_enter_debug_mode (void)
-{
-  m_run_action->setEnabled (false);
-  m_run_action->setShortcut (QKeySequence ());
-}
+  void file_editor::handle_enter_debug_mode (void)
+  {
+    m_run_action->setEnabled (false);
+    m_run_action->setShortcut (QKeySequence ());
+  }
 
-void
-file_editor::handle_exit_debug_mode (void)
-{
-  m_run_action->setEnabled (true);
-  shortcut_manager::set_shortcut (m_run_action, "editor_run:run_file");
-}
+  void file_editor::handle_exit_debug_mode (void)
+  {
+    m_run_action->setEnabled (true);
+    shortcut_manager::set_shortcut (m_run_action, "editor_run:run_file");
+  }
 
-void
-file_editor::check_actions (void)
-{
-  bool have_tabs = m_tab_widget->count () > 0;
+  void file_editor::check_actions (void)
+  {
+    bool have_tabs = m_tab_widget->count () > 0;
 
-  m_edit_cmd_menu->setEnabled (have_tabs);
-  m_edit_fmt_menu->setEnabled (have_tabs);
-  m_edit_nav_menu->setEnabled (have_tabs);
+    m_edit_cmd_menu->setEnabled (have_tabs);
+    m_edit_fmt_menu->setEnabled (have_tabs);
+    m_edit_nav_menu->setEnabled (have_tabs);
 
-  m_comment_selection_action->setEnabled (have_tabs);
-  m_uncomment_selection_action->setEnabled (have_tabs);
-  m_comment_var_selection_action->setEnabled (have_tabs);
-  m_indent_selection_action->setEnabled (have_tabs);
-  m_unindent_selection_action->setEnabled (have_tabs);
-  m_smart_indent_line_or_selection_action->setEnabled (have_tabs);
+    m_comment_selection_action->setEnabled (have_tabs);
+    m_uncomment_selection_action->setEnabled (have_tabs);
+    m_comment_var_selection_action->setEnabled (have_tabs);
+    m_indent_selection_action->setEnabled (have_tabs);
+    m_unindent_selection_action->setEnabled (have_tabs);
+    m_smart_indent_line_or_selection_action->setEnabled (have_tabs);
 
-  m_context_help_action->setEnabled (have_tabs);
-  m_context_doc_action->setEnabled (have_tabs);
+    m_context_help_action->setEnabled (have_tabs);
+    m_context_doc_action->setEnabled (have_tabs);
 
-  m_view_editor_menu->setEnabled (have_tabs);
-  m_zoom_in_action->setEnabled (have_tabs);
-  m_zoom_out_action->setEnabled (have_tabs);
-  m_zoom_normal_action->setEnabled (have_tabs);
+    m_view_editor_menu->setEnabled (have_tabs);
+    m_zoom_in_action->setEnabled (have_tabs);
+    m_zoom_out_action->setEnabled (have_tabs);
+    m_zoom_normal_action->setEnabled (have_tabs);
 
-  m_find_action->setEnabled (have_tabs);
-  m_find_next_action->setEnabled (have_tabs);
-  m_find_previous_action->setEnabled (have_tabs);
-  m_print_action->setEnabled (have_tabs);
-  m_run_action->setEnabled (have_tabs);
+    m_find_action->setEnabled (have_tabs);
+    m_find_next_action->setEnabled (have_tabs);
+    m_find_previous_action->setEnabled (have_tabs);
+    m_print_action->setEnabled (have_tabs);
+    m_run_action->setEnabled (have_tabs);
 
-  m_edit_function_action->setEnabled (have_tabs);
-  m_save_action->setEnabled (have_tabs);
-  m_save_as_action->setEnabled (have_tabs);
-  m_close_action->setEnabled (have_tabs);
-  m_close_all_action->setEnabled (have_tabs);
-  m_close_others_action->setEnabled (have_tabs && m_tab_widget->count () > 1);
-}
+    m_edit_function_action->setEnabled (have_tabs);
+    m_save_action->setEnabled (have_tabs);
+    m_save_as_action->setEnabled (have_tabs);
+    m_close_action->setEnabled (have_tabs);
+    m_close_all_action->setEnabled (have_tabs);
+    m_close_others_action->setEnabled (have_tabs && m_tab_widget->count () > 1);
+  }
 
-// empty_script determines whether we have to create an empty script
-// 1. At startup, when the editor has to be (really) visible
-//    (Here we can not use the visibility changed signal)
-// 2. When the editor becomes visible when octave is running
-void
-file_editor::empty_script (bool startup, bool visible)
-{
-  QSettings *settings = resource_manager::get_settings ();
-  if (settings->value ("useCustomFileEditor",false).toBool ())
-    return;  // do not open an empty script in the external editor
+  // empty_script determines whether we have to create an empty script
+  // 1. At startup, when the editor has to be (really) visible
+  //    (Here we can not use the visibility changed signal)
+  // 2. When the editor becomes visible when octave is running
+  void file_editor::empty_script (bool startup, bool visible)
+  {
+    QSettings *settings = resource_manager::get_settings ();
+    if (settings->value ("useCustomFileEditor",false).toBool ())
+      return;  // do not open an empty script in the external editor
 
-  bool real_visible;
+    bool real_visible;
 
-  if (startup)
-    real_visible = isVisible ();
-  else
-    real_visible = visible;
+    if (startup)
+      real_visible = isVisible ();
+    else
+      real_visible = visible;
 
-  if (! real_visible || m_tab_widget->count () > 0)
-    return;
+    if (! real_visible || m_tab_widget->count () > 0)
+      return;
 
-  if (startup && ! isFloating ())
-    {
-      // check is editor is really visible or hidden between tabbed widgets
-      QList<QTabBar *> tab_list = main_win ()->findChildren<QTabBar *>();
+    if (startup && ! isFloating ())
+      {
+        // check is editor is really visible or hidden between tabbed widgets
+        QList<QTabBar *> tab_list = main_win ()->findChildren<QTabBar *>();
 
-      bool in_tab = false;
-      int i = 0;
-      while ((i < tab_list.count ()) && (! in_tab))
-        {
-          QTabBar *tab = tab_list.at (i);
-          i++;
+        bool in_tab = false;
+        int i = 0;
+        while ((i < tab_list.count ()) && (! in_tab))
+          {
+            QTabBar *tab = tab_list.at (i);
+            i++;
 
-          int j = 0;
-          while ((j < tab->count ()) && (! in_tab))
-            {
-              // check all tabs for the editor
-              if (tab->tabText (j) == windowTitle ())
-                {
-                  // editor is in this tab widget
-                  in_tab = true;
-                  int top = tab->currentIndex ();
-                  if (top > -1 && tab->tabText (top) == windowTitle ())
-                    real_visible = true;  // and is the current tab
-                  else
-                    return; // not current tab -> not visible
-                }
-              j++;
-            }
-        }
-    }
+            int j = 0;
+            while ((j < tab->count ()) && (! in_tab))
+              {
+                // check all tabs for the editor
+                if (tab->tabText (j) == windowTitle ())
+                  {
+                    // editor is in this tab widget
+                    in_tab = true;
+                    int top = tab->currentIndex ();
+                    if (top > -1 && tab->tabText (top) == windowTitle ())
+                      real_visible = true;  // and is the current tab
+                    else
+                      return; // not current tab -> not visible
+                  }
+                j++;
+              }
+          }
+      }
 
-  request_new_file ("");
-}
+    request_new_file ("");
+  }
 
-void
-file_editor::restore_session (QSettings *settings)
-{
-  //restore previous session
-  if (! settings->value ("editor/restoreSession", true).toBool ())
-    return;
+  void file_editor::restore_session (QSettings *settings)
+  {
+    //restore previous session
+    if (! settings->value ("editor/restoreSession", true).toBool ())
+      return;
 
-  // get the data from the settings file
-  QStringList sessionFileNames = settings->value ("editor/savedSessionTabs",
-                                          QStringList ()).toStringList ();
-  QStringList session_encodings = settings->value ("editor/saved_session_encodings",
-                                          QStringList ()).toStringList ();
-  QStringList session_index = settings->value ("editor/saved_session_tab_index",
-                                          QStringList ()).toStringList ();
+    // get the data from the settings file
+    QStringList sessionFileNames
+      = settings->value ("editor/savedSessionTabs",
+                         QStringList ()).toStringList ();
 
-  // fill a list of the struct and sort it (depending on index)
-  QList<session_data> s_data;
+    QStringList session_encodings
+      = settings->value ("editor/saved_session_encodings",
+                         QStringList ()).toStringList ();
 
-  bool do_encoding = (session_encodings.count () == sessionFileNames.count ());
-  bool do_index    = (session_index.count () == sessionFileNames.count ());
+    QStringList session_index
+      = settings->value ("editor/saved_session_tab_index",
+                         QStringList ()).toStringList ();
 
-  for (int n = 0; n < sessionFileNames.count (); ++n)
-    {
-      QFileInfo file = QFileInfo (sessionFileNames.at (n));
-      if (! file.exists ())
-        continue;
+    // fill a list of the struct and sort it (depending on index)
+    QList<session_data> s_data;
+
+    bool do_encoding = (session_encodings.count () == sessionFileNames.count ());
+    bool do_index = (session_index.count () == sessionFileNames.count ());
 
-      session_data item = { QString (), sessionFileNames.at (n), QString ()};
-      if (do_index)
-        item.index = session_index.at (n);
-      if (do_encoding)
-        item.encoding = session_encodings.at (n);
+    for (int n = 0; n < sessionFileNames.count (); ++n)
+      {
+        QFileInfo file = QFileInfo (sessionFileNames.at (n));
+        if (! file.exists ())
+          continue;
 
-      s_data << item;
-    }
-
-  qSort (s_data);
+        session_data item = { QString (), sessionFileNames.at (n), QString ()};
+        if (do_index)
+          item.index = session_index.at (n);
+        if (do_encoding)
+          item.encoding = session_encodings.at (n);
 
-  // finally open the file with the desired encoding in the desired order
-  for (int n = 0; n < s_data.count (); ++n)
-    request_open_file (s_data.at (n).file_name, s_data.at (n).encoding);
-}
+        s_data << item;
+      }
+
+    qSort (s_data);
 
-void
-file_editor::focus (void)
-{
-  if (m_no_focus)
-    return;  // No focus for the editor if external open/close request
+    // finally open the file with the desired encoding in the desired order
+    for (int n = 0; n < s_data.count (); ++n)
+      request_open_file (s_data.at (n).file_name, s_data.at (n).encoding);
+  }
 
-  octave_dock_widget::focus ();
+  void file_editor::focus (void)
+  {
+    if (m_no_focus)
+      return;  // No focus for the editor if external open/close request
 
-  // set focus to current tab
-  QWidget *fileEditorTab = m_tab_widget->currentWidget ();
-  if (fileEditorTab)
-    emit fetab_set_focus (fileEditorTab);
-}
+    octave_dock_widget::focus ();
 
-void
-file_editor::set_focus (QWidget *fet)
-{
-  octave_dock_widget::focus ();
+    // set focus to current tab
+    QWidget *fileEditorTab = m_tab_widget->currentWidget ();
+    if (fileEditorTab)
+      emit fetab_set_focus (fileEditorTab);
+  }
 
-  // set focus to desired tab
-  if (fet)
-    m_tab_widget->setCurrentWidget (fet);
-}
+  void file_editor::set_focus (QWidget *fet)
+  {
+    octave_dock_widget::focus ();
 
-// function enabling/disabling the menu accelerators depending on the
-// focus of the editor
-void
-file_editor::enable_menu_shortcuts (bool enable)
-{
-  QHash<QMenu*, QStringList>::const_iterator i = m_hash_menu_text.constBegin ();
+    // set focus to desired tab
+    if (fet)
+      m_tab_widget->setCurrentWidget (fet);
+  }
 
-  while (i != m_hash_menu_text.constEnd ())
-    {
-      i.key ()->setTitle (i.value ().at (! enable));
-      ++i;
-    }
+  // function enabling/disabling the menu accelerators depending on the
+  // focus of the editor
+  void file_editor::enable_menu_shortcuts (bool enable)
+  {
+    QHash<QMenu*, QStringList>::const_iterator i = m_hash_menu_text.constBegin ();
+
+    while (i != m_hash_menu_text.constEnd ())
+      {
+        i.key ()->setTitle (i.value ().at (! enable));
+        ++i;
+      }
 
-  // when editor loses focus, enable the actions, which are always active
-  // in the main window due to missing info on selected text and undo actions
-  if (! enable && m_copy_action && m_undo_action)
-    {
-      m_copy_action->setEnabled (true);
-      m_undo_action->setEnabled (true);
-    }
-}
+    // when editor loses focus, enable the actions, which are always active
+    // in the main window due to missing info on selected text and undo actions
+    if (! enable && m_copy_action && m_undo_action)
+      {
+        m_copy_action->setEnabled (true);
+        m_undo_action->setEnabled (true);
+      }
+  }
 
-bool
-file_editor::check_closing (void)
-{
-  // When the application or the editor is closing and the user wants to close
-  // all files in the latter case all editor tabs are checked whether
-  // they need to be saved. During these ckecked the tabs are not closed
-  // since the user might cancel closing octave during one of these saving
-  // dialogs. Therefore, saving the session for restoring at next start
-  // is not done before the application is definitely closing
-
-  // Have all file editor tabs signal what their filenames are.
-  m_editor_tab_map.clear ();
-  emit fetab_file_name_query (nullptr);
-
-  // Save all tabs with confirmation.
-  file_editor_tab::reset_cancel ();
-  emit fetab_check_modified_file ();
+  bool file_editor::check_closing (void)
+  {
+    // When the application or the editor is closing and the user wants to close
+    // all files in the latter case all editor tabs are checked whether
+    // they need to be saved. During these ckecked the tabs are not closed
+    // since the user might cancel closing octave during one of these saving
+    // dialogs. Therefore, saving the session for restoring at next start
+    // is not done before the application is definitely closing
 
-  // If there was a cancellation, make the already saved/discarded tabs
-  // recovering from the exit by removing the read-only state and by
-  // recovering the debugger breakpoints. Finally return false in order to
-  // cancel closing the application or the editor
-  if (file_editor_tab::was_cancelled ())
-    {
-      emit fetab_recover_from_exit ();
-      return false;
-    }
+    // Have all file editor tabs signal what their filenames are.
+    m_editor_tab_map.clear ();
+    emit fetab_file_name_query (nullptr);
+
+    // Save all tabs with confirmation.
+    file_editor_tab::reset_cancel ();
+    emit fetab_check_modified_file ();
 
-  // Here, the application or the editor will be closed -> store the session
-
-  // Save open files for restoring in next session; this only is possible
-  QSettings *settings = resource_manager::get_settings ();
+    // If there was a cancellation, make the already saved/discarded tabs
+    // recovering from the exit by removing the read-only state and by
+    // recovering the debugger breakpoints. Finally return false in order to
+    // cancel closing the application or the editor
+    if (file_editor_tab::was_cancelled ())
+      {
+        emit fetab_recover_from_exit ();
+        return false;
+      }
 
-  // save filenames (even if last session will not be restored next time)
-  // together with encoding and the tab index
-  QStringList fetFileNames;
-  QStringList fet_encodings;
-  QStringList fet_index;
+    // Here, the application or the editor will be closed -> store the session
+
+    // Save open files for restoring in next session; this only is possible
+    QSettings *settings = resource_manager::get_settings ();
+
+    // save filenames (even if last session will not be restored next time)
+    // together with encoding and the tab index
+    QStringList fetFileNames;
+    QStringList fet_encodings;
+    QStringList fet_index;
 
-  // save all open tabs before they are definitely closed
-  for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
-       p != m_editor_tab_map.end (); p++)
-    {
-      QString file_name = p->first;   // get file name of tab
-      if (! file_name.isEmpty ())      // do not append unnamed files
-        {
-          fetFileNames.append (file_name);
-          fet_encodings.append (m_editor_tab_map[file_name].encoding);
-          QString index;
-          fet_index.append (index.setNum
-             (m_tab_widget->indexOf (m_editor_tab_map[file_name].fet_ID)));
-        }
-    }
-
-  settings->setValue ("editor/savedSessionTabs", fetFileNames);
-  settings->setValue ("editor/saved_session_encodings", fet_encodings);
-  settings->setValue ("editor/saved_session_tab_index", fet_index);
-  settings->sync ();
+    // save all open tabs before they are definitely closed
+    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+         p != m_editor_tab_map.end (); p++)
+      {
+        QString file_name = p->first;   // get file name of tab
+        if (! file_name.isEmpty ())      // do not append unnamed files
+          {
+            fetFileNames.append (file_name);
+            fet_encodings.append (m_editor_tab_map[file_name].encoding);
+            QString index;
+            fet_index.append (index.setNum
+                              (m_tab_widget->indexOf (m_editor_tab_map[file_name].fet_ID)));
+          }
+      }
 
-  // Finally close all the tabs and return indication that we can exit
-  // the application or close the editor
-  for (int i = m_tab_widget->count () - 1; i >= 0; i--)
-    {
-      // backwards loop since m_tab_widget->count () changes during the loop
-      delete m_tab_widget->widget (i);
-      m_tab_widget->removeTab (i);
-    }
-
-  return true;
-}
+    settings->setValue ("editor/savedSessionTabs", fetFileNames);
+    settings->setValue ("editor/saved_session_encodings", fet_encodings);
+    settings->setValue ("editor/saved_session_tab_index", fet_index);
+    settings->sync ();
 
-void
-file_editor::request_new_file (const QString& commands)
-{
-  // Custom editor? If yes, we can only call the editor without passing
-  // some initial contents and even without being sure a new file is opened
-  if (call_custom_editor ())
-    return;
+    // Finally close all the tabs and return indication that we can exit
+    // the application or close the editor
+    for (int i = m_tab_widget->count () - 1; i >= 0; i--)
+      {
+        // backwards loop since m_tab_widget->count () changes during the loop
+        delete m_tab_widget->widget (i);
+        m_tab_widget->removeTab (i);
+      }
 
-  // New file isn't a file_editor_tab function since the file
-  // editor tab has yet to be created and there is no object to
-  // pass a signal to.  Hence, functionality is here.
+    return true;
+  }
+
+  void file_editor::request_new_file (const QString& commands)
+  {
+    // Custom editor? If yes, we can only call the editor without passing
+    // some initial contents and even without being sure a new file is opened
+    if (call_custom_editor ())
+      return;
 
-  file_editor_tab *fileEditorTab = new file_editor_tab (m_ced);
-  if (fileEditorTab)
-    {
-      add_file_editor_tab (fileEditorTab, "");  // new tab with empty title
-      fileEditorTab->new_file (commands);       // title is updated here
-      focus ();                                 // focus editor and new tab
-    }
-}
+    // New file isn't a file_editor_tab function since the file
+    // editor tab has yet to be created and there is no object to
+    // pass a signal to.  Hence, functionality is here.
 
-void
-file_editor::request_close_file (bool)
-{
-  file_editor_tab *editor_tab
-    = static_cast<file_editor_tab *> (m_tab_widget->currentWidget ());
-  editor_tab->conditional_close ();
-}
+    file_editor_tab *fileEditorTab = new file_editor_tab (m_ced);
+    if (fileEditorTab)
+      {
+        add_file_editor_tab (fileEditorTab, "");  // new tab with empty title
+        fileEditorTab->new_file (commands);       // title is updated here
+        focus ();                                 // focus editor and new tab
+      }
+  }
 
-void
-file_editor::request_close_all_files (bool)
-{
-  file_editor_tab *editor_tab;
+  void file_editor::request_close_file (bool)
+  {
+    file_editor_tab *editor_tab
+      = static_cast<file_editor_tab *> (m_tab_widget->currentWidget ());
+    editor_tab->conditional_close ();
+  }
 
-  // loop over all tabs starting from last one otherwise deletion changes index
-  for (int index = m_tab_widget->count ()-1; index >= 0; index--)
-    {
-      editor_tab = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
-      editor_tab->conditional_close ();
-    }
-}
+  void file_editor::request_close_all_files (bool)
+  {
+    file_editor_tab *editor_tab;
 
-void
-file_editor::request_close_other_files (bool)
-{
-  file_editor_tab *editor_tab;
-  QWidget *tabID = m_tab_widget->currentWidget ();
+    // loop over all tabs starting from last one otherwise deletion changes index
+    for (int index = m_tab_widget->count ()-1; index >= 0; index--)
+      {
+        editor_tab = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
+        editor_tab->conditional_close ();
+      }
+  }
 
-  // loop over all tabs starting from last one otherwise deletion changes index
-  for (int index = m_tab_widget->count ()-1; index >= 0; index--)
-    {
-      if (tabID != m_tab_widget->widget (index))
-        {
-          editor_tab
-            = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
-          editor_tab->conditional_close ();
-        }
-    }
-}
+  void file_editor::request_close_other_files (bool)
+  {
+    file_editor_tab *editor_tab;
+    QWidget *tabID = m_tab_widget->currentWidget ();
+
+    // loop over all tabs starting from last one otherwise deletion changes index
+    for (int index = m_tab_widget->count ()-1; index >= 0; index--)
+      {
+        if (tabID != m_tab_widget->widget (index))
+          {
+            editor_tab
+              = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
+            editor_tab->conditional_close ();
+          }
+      }
+  }
 
-// open a file from the mru list
-void
-file_editor::request_mru_open_file (QAction *action)
-{
-  if (action)
-    {
-      request_open_file (action->data ().toStringList ().at (0),
-                         action->data ().toStringList ().at (1));
-    }
-}
+  // open a file from the mru list
+  void file_editor::request_mru_open_file (QAction *action)
+  {
+    if (action)
+      {
+        request_open_file (action->data ().toStringList ().at (0),
+                           action->data ().toStringList ().at (1));
+      }
+  }
 
-void
-file_editor::request_print_file (bool)
-{
-  emit fetab_print_file (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_print_file (bool)
+  {
+    emit fetab_print_file (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_redo (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_REDO);
-}
-
-void
-file_editor::request_cut (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_CUT);
-}
+  void file_editor::request_redo (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_REDO);
+  }
 
-void
-file_editor::request_context_help (bool)
-{
-  emit fetab_context_help (m_tab_widget->currentWidget (), false);
-}
+  void file_editor::request_cut (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_CUT);
+  }
 
-void
-file_editor::request_context_doc (bool)
-{
-  emit fetab_context_help (m_tab_widget->currentWidget (), true);
-}
-
-void
-file_editor::request_context_edit (bool)
-{
-  emit fetab_context_edit (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_context_help (bool)
+  {
+    emit fetab_context_help (m_tab_widget->currentWidget (), false);
+  }
 
-void
-file_editor::request_save_file (bool)
-{
-  emit fetab_save_file (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_context_doc (bool)
+  {
+    emit fetab_context_help (m_tab_widget->currentWidget (), true);
+  }
+
+  void file_editor::request_context_edit (bool)
+  {
+    emit fetab_context_edit (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_save_file_as (bool)
-{
-  emit fetab_save_file_as (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_save_file (bool)
+  {
+    emit fetab_save_file (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_run_file (bool)
-{
-  emit fetab_run_file (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_save_file_as (bool)
+  {
+    emit fetab_save_file_as (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_context_run (bool)
-{
-  emit fetab_context_run (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_run_file (bool)
+  {
+    emit fetab_run_file (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_toggle_bookmark (bool)
-{
-  emit fetab_toggle_bookmark (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_context_run (bool)
+  {
+    emit fetab_context_run (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_next_bookmark (bool)
-{
-  emit fetab_next_bookmark (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_toggle_bookmark (bool)
+  {
+    emit fetab_toggle_bookmark (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_previous_bookmark (bool)
-{
-  emit fetab_previous_bookmark (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_next_bookmark (bool)
+  {
+    emit fetab_next_bookmark (m_tab_widget->currentWidget ());
+  }
+
+  void file_editor::request_previous_bookmark (bool)
+  {
+    emit fetab_previous_bookmark (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_remove_bookmark (bool)
-{
-  emit fetab_remove_bookmark (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_remove_bookmark (bool)
+  {
+    emit fetab_remove_bookmark (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_move_match_brace (bool)
-{
-  emit fetab_move_match_brace (m_tab_widget->currentWidget (), false);
-}
+  void file_editor::request_move_match_brace (bool)
+  {
+    emit fetab_move_match_brace (m_tab_widget->currentWidget (), false);
+  }
 
-void
-file_editor::request_sel_match_brace (bool)
-{
-  emit fetab_move_match_brace (m_tab_widget->currentWidget (), true);
-}
+  void file_editor::request_sel_match_brace (bool)
+  {
+    emit fetab_move_match_brace (m_tab_widget->currentWidget (), true);
+  }
 
-// FIXME: What should this do with conditional breakpoints?
-void
-file_editor::request_toggle_breakpoint (bool)
-{
-  emit fetab_toggle_breakpoint (m_tab_widget->currentWidget ());
-}
+  // FIXME: What should this do with conditional breakpoints?
+  void file_editor::request_toggle_breakpoint (bool)
+  {
+    emit fetab_toggle_breakpoint (m_tab_widget->currentWidget ());
+  }
+
+  void file_editor::request_next_breakpoint (bool)
+  {
+    emit fetab_next_breakpoint (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_next_breakpoint (bool)
-{
-  emit fetab_next_breakpoint (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_previous_breakpoint (bool)
+  {
+    emit fetab_previous_breakpoint (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_previous_breakpoint (bool)
-{
-  emit fetab_previous_breakpoint (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_remove_breakpoint (bool)
+  {
+    emit fetab_remove_all_breakpoints (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_remove_breakpoint (bool)
-{
-  emit fetab_remove_all_breakpoints (m_tab_widget->currentWidget ());
-}
+  // slots for Edit->Commands actions
+  void file_editor::request_delete_start_word (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_DELWORDLEFT);
+  }
 
-// slots for Edit->Commands actions
-void
-file_editor::request_delete_start_word (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELWORDLEFT);
-}
+  void file_editor::request_delete_end_word (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_DELWORDRIGHT);
+  }
 
-void
-file_editor::request_delete_end_word (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELWORDRIGHT);
-}
+  void file_editor::request_delete_start_line (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_DELLINELEFT);
+  }
+
+  void file_editor::request_delete_end_line (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_DELLINERIGHT);
+  }
 
-void
-file_editor::request_delete_start_line (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELLINELEFT);
-}
+  void file_editor::request_delete_line (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_LINEDELETE);
+  }
 
-void
-file_editor::request_delete_end_line (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELLINERIGHT);
-}
+  void file_editor::request_copy_line (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_LINECOPY);
+  }
 
-void
-file_editor::request_delete_line (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINEDELETE);
-}
+  void file_editor::request_cut_line (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_LINECUT);
+  }
 
-void
-file_editor::request_copy_line (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINECOPY);
-}
+  void file_editor::request_duplicate_selection (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_SELECTIONDUPLICATE);
+  }
 
-void
-file_editor::request_cut_line (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINECUT);
-}
+  void file_editor::request_transpose_line (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_LINETRANSPOSE);
+  }
+
+  void file_editor::request_comment_selected_text (bool)
+  {
+    emit fetab_comment_selected_text (m_tab_widget->currentWidget (), false);
+  }
 
-void
-file_editor::request_duplicate_selection (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_SELECTIONDUPLICATE);
-}
+  void file_editor::request_uncomment_selected_text (bool)
+  {
+    emit fetab_uncomment_selected_text (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_transpose_line (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINETRANSPOSE);
-}
+  void file_editor::request_comment_var_selected_text (bool)
+  {
+    emit fetab_comment_selected_text (m_tab_widget->currentWidget (), true);
+  }
 
-void
-file_editor::request_comment_selected_text (bool)
-{
-  emit fetab_comment_selected_text (m_tab_widget->currentWidget (), false);
-}
+  // slots for Edit->Format actions
+  void file_editor::request_upper_case (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_UPPERCASE);
+  }
 
-void
-file_editor::request_uncomment_selected_text (bool)
-{
-  emit fetab_uncomment_selected_text (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_lower_case (bool)
+  {
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_LOWERCASE);
+  }
 
-void
-file_editor::request_comment_var_selected_text (bool)
-{
-  emit fetab_comment_selected_text (m_tab_widget->currentWidget (), true);
-}
+  void file_editor::request_indent_selected_text (bool)
+  {
+    emit fetab_indent_selected_text (m_tab_widget->currentWidget ());
+  }
+
+  void file_editor::request_unindent_selected_text (bool)
+  {
+    emit fetab_unindent_selected_text (m_tab_widget->currentWidget ());
+  }
 
-// slots for Edit->Format actions
-void
-file_editor::request_upper_case (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_UPPERCASE);
-}
-void
-file_editor::request_lower_case (bool)
-{
-  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LOWERCASE);
-}
-void
-file_editor::request_indent_selected_text (bool)
-{
-  emit fetab_indent_selected_text (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_smart_indent_line_or_selected_text ()
+  {
+    emit fetab_smart_indent_line_or_selected_text (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_unindent_selected_text (bool)
-{
-  emit fetab_unindent_selected_text (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_conv_eol_windows (bool)
+  {
+    emit fetab_convert_eol (m_tab_widget->currentWidget (),
+                            QsciScintilla::EolWindows);
+  }
+  void
+  file_editor::request_conv_eol_unix (bool)
+  {
+    emit fetab_convert_eol (m_tab_widget->currentWidget (),
+                            QsciScintilla::EolUnix);
+  }
+
+  void file_editor::request_conv_eol_mac (bool)
+  {
+    emit fetab_convert_eol (m_tab_widget->currentWidget (),
+                            QsciScintilla::EolMac);
+  }
 
-void
-file_editor::request_smart_indent_line_or_selected_text ()
-{
-  emit fetab_smart_indent_line_or_selected_text (m_tab_widget->currentWidget ());
-}
+  void file_editor::request_find (bool)
+  {
+    emit fetab_find (m_tab_widget->currentWidget (), m_fetab_actions);
+  }
+
+  void file_editor::request_find_next (bool)
+  {
+    emit fetab_find_next (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_conv_eol_windows (bool)
-{
-  emit fetab_convert_eol (m_tab_widget->currentWidget (),
-                          QsciScintilla::EolWindows);
-}
-void
-file_editor::request_conv_eol_unix (bool)
-{
-  emit fetab_convert_eol (m_tab_widget->currentWidget (),
-                          QsciScintilla::EolUnix);
-}
-void
-file_editor::request_conv_eol_mac (bool)
-{
-  emit fetab_convert_eol (m_tab_widget->currentWidget (),
-                          QsciScintilla::EolMac);
-}
+  void file_editor::request_find_previous (bool)
+  {
+    emit fetab_find_previous (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_find (bool)
-{
-  emit fetab_find (m_tab_widget->currentWidget (), m_fetab_actions);
-}
+  void file_editor::request_goto_line (bool)
+  {
+    emit fetab_goto_line (m_tab_widget->currentWidget ());
+  }
+
+  void file_editor::request_completion (bool)
+  {
+    emit fetab_completion (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::request_find_next (bool)
-{
-  emit fetab_find_next (m_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_find_previous (bool)
-{
-  emit fetab_find_previous (m_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_goto_line (bool)
-{
-  emit fetab_goto_line (m_tab_widget->currentWidget ());
-}
+  void file_editor::handle_file_name_changed (const QString& fname,
+                                              const QString& tip)
+  {
+    QObject *fileEditorTab = sender ();
+    if (fileEditorTab)
+      {
+        for (int i = 0; i < m_tab_widget->count (); i++)
+          {
+            if (m_tab_widget->widget (i) == fileEditorTab)
+              {
+                m_tab_widget->setTabText (i, fname);
+                m_tab_widget->setTabToolTip (i, tip);
+              }
+          }
+      }
+  }
 
-void
-file_editor::request_completion (bool)
-{
-  emit fetab_completion (m_tab_widget->currentWidget ());
-}
+  void file_editor::handle_tab_close_request (int index)
+  {
+    file_editor_tab *editor_tab
+      = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
+    editor_tab->conditional_close ();
+  }
 
-void
-file_editor::handle_file_name_changed (const QString& fname,
-                                       const QString& tip)
-{
-  QObject *fileEditorTab = sender ();
-  if (fileEditorTab)
-    {
-      for (int i = 0; i < m_tab_widget->count (); i++)
-        {
-          if (m_tab_widget->widget (i) == fileEditorTab)
-            {
-              m_tab_widget->setTabText (i, fname);
-              m_tab_widget->setTabToolTip (i, tip);
-            }
-        }
-    }
-}
+  void
+  file_editor::handle_tab_remove_request (void)
+  {
+    QObject *fileEditorTab = sender ();
+    if (fileEditorTab)
+      {
+        for (int i = 0; i < m_tab_widget->count (); i++)
+          {
+            if (m_tab_widget->widget (i) == fileEditorTab)
+              {
+                m_tab_widget->removeTab (i);
+                // Deleting sender is dodgy, but works because the signal
+                // is the last item in the sender's routines.
+                delete fileEditorTab;
+                break;
+              }
+          }
+      }
+    check_actions ();
 
-void
-file_editor::handle_tab_close_request (int index)
-{
-  file_editor_tab *editor_tab
-    = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
-  editor_tab->conditional_close ();
-}
+    focus ();     // focus stays in editor when tab is closed
+
+  }
+
+  void file_editor::handle_add_filename_to_list (const QString& fileName,
+                                                 const QString& encoding, QWidget *ID)
+  {
+    // Should we allow multiple tabs for a single file?
+    m_editor_tab_map[fileName].fet_ID = ID;
+    m_editor_tab_map[fileName].encoding = encoding;
+  }
 
-void
-file_editor::handle_tab_remove_request (void)
-{
-  QObject *fileEditorTab = sender ();
-  if (fileEditorTab)
-    {
-      for (int i = 0; i < m_tab_widget->count (); i++)
-        {
-          if (m_tab_widget->widget (i) == fileEditorTab)
-            {
-              m_tab_widget->removeTab (i);
-              // Deleting sender is dodgy, but works because the signal
-              // is the last item in the sender's routines.
-              delete fileEditorTab;
-              break;
-            }
-        }
-    }
-  check_actions ();
+  // context menu of edit area
+  void file_editor::active_tab_changed (int index)
+  {
+    emit fetab_change_request (m_tab_widget->widget (index));
+  }
 
-  focus ();     // focus stays in editor when tab is closed
-
-}
+  void file_editor::handle_editor_state_changed (bool copy_available,
+                                                 bool is_octave_file)
+  {
+    // In case there is some scenario where traffic could be coming from
+    // all the file editor tabs, just process info from the current active tab.
+    if (sender () == m_tab_widget->currentWidget ())
+      {
+        if (m_copy_action)
+          m_copy_action->setEnabled (copy_available);
+        m_cut_action->setEnabled (copy_available);
+        m_run_selection_action->setEnabled (copy_available);
+        m_run_action->setEnabled (is_octave_file);
 
-void
-file_editor::handle_add_filename_to_list (const QString& fileName,
-                                          const QString& encoding, QWidget *ID)
-{
-  // Should we allow multiple tabs for a single file?
-  m_editor_tab_map[fileName].fet_ID = ID;
-  m_editor_tab_map[fileName].encoding = encoding;
-}
+        setFocusProxy (m_tab_widget->currentWidget ());
+      }
+  }
 
-// context menu of edit area
-void
-file_editor::active_tab_changed (int index)
-{
-  emit fetab_change_request (m_tab_widget->widget (index));
-}
+  void file_editor::handle_mru_add_file (const QString& file_name,
+                                         const QString& encoding)
+  {
+    int index;
+    while ((index = m_mru_files.indexOf (file_name)) >= 0)
+      {
+        m_mru_files.removeAt (index);
+        m_mru_files_encodings.removeAt (index);
+      }
+
+    m_mru_files.prepend (file_name);
+    m_mru_files_encodings.prepend (encoding);
 
-void
-file_editor::handle_editor_state_changed (bool copy_available,
-                                          bool is_octave_file)
-{
-  // In case there is some scenario where traffic could be coming from
-  // all the file editor tabs, just process info from the current active tab.
-  if (sender () == m_tab_widget->currentWidget ())
-    {
-      if (m_copy_action)
-        m_copy_action->setEnabled (copy_available);
-      m_cut_action->setEnabled (copy_available);
-      m_run_selection_action->setEnabled (copy_available);
-      m_run_action->setEnabled (is_octave_file);
+    mru_menu_update ();
+  }
+
+  void file_editor::check_conflict_save (const QString& saveFileName,
+                                         bool remove_on_success)
+  {
+    // Check whether this file is already open in the editor.
+    QWidget *tab = find_tab_widget (saveFileName);
 
-      setFocusProxy (m_tab_widget->currentWidget ());
-    }
-}
+    if (tab)
+      {
+        // Note: to overwrite the contents of some other file editor tab
+        // with the same name requires identifying which file editor tab
+        // that is (not too difficult) then close that tab.  Of course,
+        // that could trigger another dialog box if the file editor tab
+        // with the same name has modifications in it.  This could become
+        // somewhat confusing to the user.  For now, opt to do nothing.
 
-void
-file_editor::handle_mru_add_file (const QString& file_name,
-                                  const QString& encoding)
-{
-  int index;
-  while ((index = m_mru_files.indexOf (file_name)) >= 0)
-    {
-      m_mru_files.removeAt (index);
-      m_mru_files_encodings.removeAt (index);
-    }
+        // Create a NonModal message about error.
+        QMessageBox *msgBox
+          = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
+                             tr ("File not saved! A file with the selected name\n%1\n"
+                                 "is already open in the editor").
+                             arg (saveFileName),
+                             QMessageBox::Ok, nullptr);
 
-  m_mru_files.prepend (file_name);
-  m_mru_files_encodings.prepend (encoding);
+        msgBox->setWindowModality (Qt::NonModal);
+        msgBox->setAttribute (Qt::WA_DeleteOnClose);
+        msgBox->show ();
 
-  mru_menu_update ();
-}
+        return;
+      }
 
-void
-file_editor::check_conflict_save (const QString& saveFileName,
-                                  bool remove_on_success)
-{
-  // Check whether this file is already open in the editor.
-  QWidget *tab = find_tab_widget (saveFileName);
+    QObject *saveFileObject = sender ();
+    QWidget *saveFileWidget = nullptr;
 
-  if (tab)
-    {
-      // Note: to overwrite the contents of some other file editor tab
-      // with the same name requires identifying which file editor tab
-      // that is (not too difficult) then close that tab.  Of course,
-      // that could trigger another dialog box if the file editor tab
-      // with the same name has modifications in it.  This could become
-      // somewhat confusing to the user.  For now, opt to do nothing.
-
-      // Create a NonModal message about error.
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
-                           tr ("File not saved! A file with the selected name\n%1\n"
-                               "is already open in the editor").
-                           arg (saveFileName),
-                           QMessageBox::Ok, nullptr);
+    for (int i = 0; i < m_tab_widget->count (); i++)
+      {
+        if (m_tab_widget->widget (i) == saveFileObject)
+          {
+            saveFileWidget = m_tab_widget->widget (i);
+            break;
+          }
+      }
+    if (! saveFileWidget)
+      {
+        // Create a NonModal message about error.
+        QMessageBox *msgBox
+          = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
+                             tr ("The associated file editor tab has disappeared."),
+                             QMessageBox::Ok, nullptr);
 
-      msgBox->setWindowModality (Qt::NonModal);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-      msgBox->show ();
+        msgBox->setWindowModality (Qt::NonModal);
+        msgBox->setAttribute (Qt::WA_DeleteOnClose);
+        msgBox->show ();
+
+        return;
+      }
 
-      return;
-    }
+    // Can save without conflict, have the file editor tab do so.
+    emit fetab_save_file (saveFileWidget, saveFileName, remove_on_success);
+  }
 
-  QObject *saveFileObject = sender ();
-  QWidget *saveFileWidget = nullptr;
+  void file_editor::handle_insert_debugger_pointer_request (const QString& file,
+                                                            int line)
+  {
+    request_open_file (file, QString (), line, true); // default encoding
+  }
 
-  for (int i = 0; i < m_tab_widget->count (); i++)
-    {
-      if (m_tab_widget->widget (i) == saveFileObject)
-        {
-          saveFileWidget = m_tab_widget->widget (i);
-          break;
-        }
-    }
-  if (! saveFileWidget)
-    {
-      // Create a NonModal message about error.
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
-                           tr ("The associated file editor tab has disappeared."),
-                           QMessageBox::Ok, nullptr);
+  void file_editor::handle_delete_debugger_pointer_request (const QString& file,
+                                                            int line)
+  {
+    if (! file.isEmpty ())
+      {
+        // Check whether this file is already open in the editor.
+        QWidget *tab = find_tab_widget (file);
 
-      msgBox->setWindowModality (Qt::NonModal);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-      msgBox->show ();
-
-      return;
-    }
+        if (tab)
+          {
+            m_tab_widget->setCurrentWidget (tab);
 
-  // Can save without conflict, have the file editor tab do so.
-  emit fetab_save_file (saveFileWidget, saveFileName, remove_on_success);
-}
+            if (line > 0)
+              emit fetab_delete_debugger_pointer (tab, line);
 
-void
-file_editor::handle_insert_debugger_pointer_request (const QString& file,
-                                                     int line)
-{
-  request_open_file (file, QString (), line, true); // default encoding
-}
+            emit fetab_set_focus (tab);
+          }
+      }
+  }
 
-void
-file_editor::handle_delete_debugger_pointer_request (const QString& file,
-                                                     int line)
-{
-  if (! file.isEmpty ())
-    {
-      // Check whether this file is already open in the editor.
-      QWidget *tab = find_tab_widget (file);
+  void file_editor::handle_update_breakpoint_marker_request (bool insert,
+                                                             const QString& file,
+                                                             int line,
+                                                             const QString& cond)
+  {
+    request_open_file (file, QString (), line, false, true, insert, cond);
+  }
 
-      if (tab)
-        {
-          m_tab_widget->setCurrentWidget (tab);
+  void file_editor::handle_edit_file_request (const QString& file)
+  {
+    request_open_file (file);
+  }
 
-          if (line > 0)
-            emit fetab_delete_debugger_pointer (tab, line);
-
-          emit fetab_set_focus (tab);
-        }
-    }
-}
+  // Slot used for signals indicating that a file was changed/rename or
+  // is going to be deleted/renamed
+  void file_editor::handle_file_remove (const QString& old_name,
+                                        const QString& new_name)
+  {
+    // Clear old lsit of files to reload
+    m_tmp_closed_files.clear ();
 
-void
-file_editor::handle_update_breakpoint_marker_request (bool insert,
-                                                      const QString& file,
-                                                      int line,
-                                                      const QString& cond)
-{
-  request_open_file (file, QString (), line, false, true, insert, cond);
-}
+    // Check if old name is a file or directory
+    QFileInfo old (old_name);
+    if (old.isDir ())
+      {
+        // Call the function which handles directories and return
+        handle_dir_remove (old_name, new_name);
+        return;
+      }
 
-void
-file_editor::handle_edit_file_request (const QString& file)
-{
-  request_open_file (file);
-}
+    // Is old file open?
+    file_editor_tab *editor_tab
+      = static_cast<file_editor_tab *> (find_tab_widget (old_name));
 
-// Slot used for signals indicating that a file was changed/rename or
-// is going to be deleted/renamed
-void
-file_editor::handle_file_remove (const QString& old_name,
-                                 const QString& new_name)
-{
-  // Clear old lsit of files to reload
-  m_tmp_closed_files.clear ();
+    if (editor_tab)
+      {
+        // Yes, close it silently
+        m_no_focus = true;  // Remember for not focussing editor
+        editor_tab->file_has_changed (QString (), true);  // Close the tab
+        m_no_focus = false;  // Back to normal
+
+        m_tmp_closed_files << old_name;  // for reloading if error removing
 
-  // Check if old name is a file or directory
-  QFileInfo old (old_name);
-  if (old.isDir ())
-    {
-      // Call the function which handles directories and return
-      handle_dir_remove (old_name, new_name);
-      return;
-    }
+        if (! new_name.isEmpty ())
+          m_tmp_closed_files << new_name;  // store new name
+        else
+          m_tmp_closed_files << ""; // no new name, just removing this file
 
-  // Is old file open?
-  file_editor_tab *editor_tab
-    = static_cast<file_editor_tab *> (find_tab_widget (old_name));
-
-  if (editor_tab)
-    {
-      // Yes, close it silently
-      m_no_focus = true;  // Remember for not focussing editor
-      editor_tab->file_has_changed (QString (), true);  // Close the tab
-      m_no_focus = false;  // Back to normal
-
-      m_tmp_closed_files << old_name;  // for reloading if error removing
+        // Get and store the related encoding
+        for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+             p != m_editor_tab_map.end (); p++)
+          {
+            if (editor_tab == p->second.fet_ID)
+              {
+                m_tmp_closed_files << p->second.encoding;
+                break;
+              }
+          }
+      }
+  }
 
-      if (! new_name.isEmpty ())
-        m_tmp_closed_files << new_name;  // store new name
-      else
-        m_tmp_closed_files << ""; // no new name, just removing this file
+  // Slot for signal indicating that a file was renamed
+  void file_editor::handle_file_renamed (bool load_new)
+  {
+    m_no_focus = true;  // Remember for not focussing editor
+    for (int i = 0; i < m_tmp_closed_files.count (); i = i + 3)
+      {
+        if (! m_tmp_closed_files.at (i + load_new).isEmpty ())
+          request_open_file (m_tmp_closed_files.at (i + load_new),
+                             m_tmp_closed_files.at (i+2));
+      }
+    m_no_focus = false;  // Back to normal focus
+  }
 
-      // Get and store the related encoding
-      for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
-           p != m_editor_tab_map.end (); p++)
-        {
-          if (editor_tab == p->second.fet_ID)
-            {
-              m_tmp_closed_files << p->second.encoding;
-              break;
-            }
-        }
-    }
-}
+  void file_editor::notice_settings (const QSettings *settings)
+  {
+    int icon_size_settings = settings->value ("toolbar_icon_size",0).toInt ();
+    QStyle *st = style ();
+    int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
 
-// Slot for signal indicating that a file was renamed
-void
-file_editor::handle_file_renamed (bool load_new)
-{
-  m_no_focus = true;  // Remember for not focussing editor
-  for (int i = 0; i < m_tmp_closed_files.count (); i = i + 3)
-    {
-      if (! m_tmp_closed_files.at (i + load_new).isEmpty ())
-        request_open_file (m_tmp_closed_files.at (i + load_new),
-                           m_tmp_closed_files.at (i+2));
-    }
-  m_no_focus = false;  // Back to normal focus
-}
+    if (icon_size_settings == 1)
+      icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
+    else if (icon_size_settings == -1)
+      icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
+
+    m_tool_bar->setIconSize (QSize (icon_size,icon_size));
+
+    int tab_width_min = settings->value ("editor/notebook_tab_width_min", 160)
+      .toInt ();
+    int tab_width_max = settings->value ("editor/notebook_tab_width_max", 300)
+      .toInt ();
 
-void
-file_editor::notice_settings (const QSettings *settings)
-{
-  int icon_size_settings = settings->value ("toolbar_icon_size",0).toInt ();
-  QStyle *st = style ();
-  int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
+    if (settings->value ("editor/longWindowTitle", false).toBool ())
+      {
+        QString style_sheet = QString ("QTabBar::tab "
+                                       "{min-width: %1px; max-width: %2px;}")
+          .arg (tab_width_min).arg (tab_width_max);
+        m_tab_widget->setElideMode (Qt::ElideLeft);
+        m_tab_widget->setStyleSheet (style_sheet);
+      }
+    else
+      m_tab_widget->setElideMode (Qt::ElideNone);
 
-  if (icon_size_settings == 1)
-    icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
-  else if (icon_size_settings == -1)
-    icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
-
-  m_tool_bar->setIconSize (QSize (icon_size,icon_size));
-
-  int tab_width_min = settings->value ("editor/notebook_tab_width_min", 160)
-                                      .toInt ();
-  int tab_width_max = settings->value ("editor/notebook_tab_width_max", 300)
-                                      .toInt ();
+    m_tab_widget->setUsesScrollButtons (true);
 
-  if (settings->value ("editor/longWindowTitle", false).toBool ())
-    {
-      QString style_sheet = QString ("QTabBar::tab "
-                                     "{min-width: %1px; max-width: %2px;}")
-                             .arg (tab_width_min).arg (tab_width_max);
-      m_tab_widget->setElideMode (Qt::ElideLeft);
-      m_tab_widget->setStyleSheet (style_sheet);
-    }
-  else
-    m_tab_widget->setElideMode (Qt::ElideNone);
+    bool show_it;
+    show_it = settings->value ("editor/showLineNumbers",true).toBool ();
+    m_show_linenum_action->setChecked (show_it);
+    show_it = settings->value ("editor/show_white_space",false).toBool ();
+    m_show_whitespace_action->setChecked (show_it);
+    show_it = settings->value ("editor/show_eol_chars",false).toBool ();
+    m_show_eol_action->setChecked (show_it);
+    show_it = settings->value ("editor/show_indent_guides",false).toBool ();
+    m_show_indguide_action->setChecked (show_it);
+    show_it = settings->value ("editor/long_line_marker",true).toBool ();
+    m_show_longline_action->setChecked (show_it);
 
-  m_tab_widget->setUsesScrollButtons (true);
+    show_it = settings->value ("editor/show_toolbar",true).toBool ();
+    m_show_toolbar_action->setChecked (show_it);
+    m_tool_bar->setVisible (show_it);
+    show_it = settings->value ("editor/show_edit_status_bar",true).toBool ();
+    m_show_statusbar_action->setChecked (show_it);
+    show_it = settings->value ("editor/show_hscroll_bar",true).toBool ();
+    m_show_hscrollbar_action->setChecked (show_it);
 
-  bool show_it;
-  show_it = settings->value ("editor/showLineNumbers",true).toBool ();
-  m_show_linenum_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_white_space",false).toBool ();
-  m_show_whitespace_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_eol_chars",false).toBool ();
-  m_show_eol_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_indent_guides",false).toBool ();
-  m_show_indguide_action->setChecked (show_it);
-  show_it = settings->value ("editor/long_line_marker",true).toBool ();
-  m_show_longline_action->setChecked (show_it);
+    set_shortcuts ();
+
+    // Relay signal to file editor tabs.
+    emit fetab_settings_changed (settings);
+  }
+
+  void file_editor::set_shortcuts (void)
+  {
+    // Shortcuts also available in the main window, as well as the realted
+    // ahotcuts, are defined in main_window and added to the editor
 
-  show_it = settings->value ("editor/show_toolbar",true).toBool ();
-  m_show_toolbar_action->setChecked (show_it);
-  m_tool_bar->setVisible (show_it);
-  show_it = settings->value ("editor/show_edit_status_bar",true).toBool ();
-  m_show_statusbar_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_hscroll_bar",true).toBool ();
-  m_show_hscrollbar_action->setChecked (show_it);
-
-  set_shortcuts ();
-
-  // Relay signal to file editor tabs.
-  emit fetab_settings_changed (settings);
-}
+    // File menu
+    shortcut_manager::set_shortcut (m_edit_function_action, "editor_file:edit_function");
+    shortcut_manager::set_shortcut (m_save_action, "editor_file:save");
+    shortcut_manager::set_shortcut (m_save_as_action, "editor_file:save_as");
+    shortcut_manager::set_shortcut (m_close_action, "editor_file:close");
+    shortcut_manager::set_shortcut (m_close_all_action, "editor_file:close_all");
+    shortcut_manager::set_shortcut (m_close_others_action, "editor_file:close_other");
+    shortcut_manager::set_shortcut (m_print_action, "editor_file:print");
 
-void
-file_editor::set_shortcuts (void)
-{
-  // Shortcuts also available in the main window, as well as the realted
-  // ahotcuts, are defined in main_window and added to the editor
+    // Edit menu
+    shortcut_manager::set_shortcut (m_redo_action, "editor_edit:redo");
+    shortcut_manager::set_shortcut (m_cut_action, "editor_edit:cut");
+    shortcut_manager::set_shortcut (m_find_action, "editor_edit:find_replace");
+    shortcut_manager::set_shortcut (m_find_next_action, "editor_edit:find_next");
+    shortcut_manager::set_shortcut (m_find_previous_action, "editor_edit:find_previous");
 
-  // File menu
-  shortcut_manager::set_shortcut (m_edit_function_action, "editor_file:edit_function");
-  shortcut_manager::set_shortcut (m_save_action, "editor_file:save");
-  shortcut_manager::set_shortcut (m_save_as_action, "editor_file:save_as");
-  shortcut_manager::set_shortcut (m_close_action, "editor_file:close");
-  shortcut_manager::set_shortcut (m_close_all_action, "editor_file:close_all");
-  shortcut_manager::set_shortcut (m_close_others_action, "editor_file:close_other");
-  shortcut_manager::set_shortcut (m_print_action, "editor_file:print");
+    shortcut_manager::set_shortcut (m_delete_start_word_action, "editor_edit:delete_start_word");
+    shortcut_manager::set_shortcut (m_delete_end_word_action, "editor_edit:delete_end_word");
+    shortcut_manager::set_shortcut (m_delete_start_line_action, "editor_edit:delete_start_line");
+    shortcut_manager::set_shortcut (m_delete_end_line_action, "editor_edit:delete_end_line");
+    shortcut_manager::set_shortcut (m_delete_line_action, "editor_edit:delete_line");
+    shortcut_manager::set_shortcut (m_copy_line_action, "editor_edit:copy_line");
+    shortcut_manager::set_shortcut (m_cut_line_action, "editor_edit:cut_line");
+    shortcut_manager::set_shortcut (m_duplicate_selection_action, "editor_edit:duplicate_selection");
+    shortcut_manager::set_shortcut (m_transpose_line_action, "editor_edit:transpose_line");
+    shortcut_manager::set_shortcut (m_comment_selection_action, "editor_edit:comment_selection");
+    shortcut_manager::set_shortcut (m_uncomment_selection_action, "editor_edit:uncomment_selection");
+    shortcut_manager::set_shortcut (m_comment_var_selection_action, "editor_edit:comment_var_selection");
 
-  // Edit menu
-  shortcut_manager::set_shortcut (m_redo_action, "editor_edit:redo");
-  shortcut_manager::set_shortcut (m_cut_action, "editor_edit:cut");
-  shortcut_manager::set_shortcut (m_find_action, "editor_edit:find_replace");
-  shortcut_manager::set_shortcut (m_find_next_action, "editor_edit:find_next");
-  shortcut_manager::set_shortcut (m_find_previous_action, "editor_edit:find_previous");
+    shortcut_manager::set_shortcut (m_upper_case_action, "editor_edit:upper_case");
+    shortcut_manager::set_shortcut (m_lower_case_action, "editor_edit:lower_case");
+    shortcut_manager::set_shortcut (m_indent_selection_action, "editor_edit:indent_selection");
+    shortcut_manager::set_shortcut (m_unindent_selection_action, "editor_edit:unindent_selection");
+    shortcut_manager::set_shortcut (m_smart_indent_line_or_selection_action, "editor_edit:smart_indent_line_or_selection");
+    shortcut_manager::set_shortcut (m_completion_action, "editor_edit:completion_list");
+    shortcut_manager::set_shortcut (m_goto_line_action, "editor_edit:goto_line");
+    shortcut_manager::set_shortcut (m_move_to_matching_brace, "editor_edit:move_to_brace");
+    shortcut_manager::set_shortcut (m_sel_to_matching_brace, "editor_edit:select_to_brace");
+    shortcut_manager::set_shortcut (m_toggle_bookmark_action, "editor_edit:toggle_bookmark");
+    shortcut_manager::set_shortcut (m_next_bookmark_action, "editor_edit:next_bookmark");
+    shortcut_manager::set_shortcut (m_previous_bookmark_action, "editor_edit:previous_bookmark");
+    shortcut_manager::set_shortcut (m_remove_bookmark_action, "editor_edit:remove_bookmark");
+    shortcut_manager::set_shortcut (m_preferences_action, "editor_edit:preferences");
+    shortcut_manager::set_shortcut (m_styles_preferences_action, "editor_edit:styles_preferences");
 
-  shortcut_manager::set_shortcut (m_delete_start_word_action, "editor_edit:delete_start_word");
-  shortcut_manager::set_shortcut (m_delete_end_word_action, "editor_edit:delete_end_word");
-  shortcut_manager::set_shortcut (m_delete_start_line_action, "editor_edit:delete_start_line");
-  shortcut_manager::set_shortcut (m_delete_end_line_action, "editor_edit:delete_end_line");
-  shortcut_manager::set_shortcut (m_delete_line_action, "editor_edit:delete_line");
-  shortcut_manager::set_shortcut (m_copy_line_action, "editor_edit:copy_line");
-  shortcut_manager::set_shortcut (m_cut_line_action, "editor_edit:cut_line");
-  shortcut_manager::set_shortcut (m_duplicate_selection_action, "editor_edit:duplicate_selection");
-  shortcut_manager::set_shortcut (m_transpose_line_action, "editor_edit:transpose_line");
-  shortcut_manager::set_shortcut (m_comment_selection_action, "editor_edit:comment_selection");
-  shortcut_manager::set_shortcut (m_uncomment_selection_action, "editor_edit:uncomment_selection");
-  shortcut_manager::set_shortcut (m_comment_var_selection_action, "editor_edit:comment_var_selection");
+    shortcut_manager::set_shortcut (m_conv_eol_windows_action, "editor_edit:conv_eol_winows");
+    shortcut_manager::set_shortcut (m_conv_eol_unix_action,    "editor_edit:conv_eol_unix");
+    shortcut_manager::set_shortcut (m_conv_eol_mac_action,     "editor_edit:conv_eol_mac");
 
-  shortcut_manager::set_shortcut (m_upper_case_action, "editor_edit:upper_case");
-  shortcut_manager::set_shortcut (m_lower_case_action, "editor_edit:lower_case");
-  shortcut_manager::set_shortcut (m_indent_selection_action, "editor_edit:indent_selection");
-  shortcut_manager::set_shortcut (m_unindent_selection_action, "editor_edit:unindent_selection");
-  shortcut_manager::set_shortcut (m_smart_indent_line_or_selection_action, "editor_edit:smart_indent_line_or_selection");
-  shortcut_manager::set_shortcut (m_completion_action, "editor_edit:completion_list");
-  shortcut_manager::set_shortcut (m_goto_line_action, "editor_edit:goto_line");
-  shortcut_manager::set_shortcut (m_move_to_matching_brace, "editor_edit:move_to_brace");
-  shortcut_manager::set_shortcut (m_sel_to_matching_brace, "editor_edit:select_to_brace");
-  shortcut_manager::set_shortcut (m_toggle_bookmark_action, "editor_edit:toggle_bookmark");
-  shortcut_manager::set_shortcut (m_next_bookmark_action, "editor_edit:next_bookmark");
-  shortcut_manager::set_shortcut (m_previous_bookmark_action, "editor_edit:previous_bookmark");
-  shortcut_manager::set_shortcut (m_remove_bookmark_action, "editor_edit:remove_bookmark");
-  shortcut_manager::set_shortcut (m_preferences_action, "editor_edit:preferences");
-  shortcut_manager::set_shortcut (m_styles_preferences_action, "editor_edit:styles_preferences");
+    // View menu
+    shortcut_manager::set_shortcut (m_show_linenum_action, "editor_view:show_line_numbers");
+    shortcut_manager::set_shortcut (m_show_whitespace_action, "editor_view:show_white_spaces");
+    shortcut_manager::set_shortcut (m_show_eol_action, "editor_view:show_eol_chars");
+    shortcut_manager::set_shortcut (m_show_indguide_action, "editor_view:show_ind_guides");
+    shortcut_manager::set_shortcut (m_show_longline_action, "editor_view:show_long_line");
+    shortcut_manager::set_shortcut (m_show_toolbar_action, "editor_view:show_toolbar");
+    shortcut_manager::set_shortcut (m_show_statusbar_action, "editor_view:show_statusbar");
+    shortcut_manager::set_shortcut (m_show_hscrollbar_action, "editor_view:show_hscrollbar");
+    shortcut_manager::set_shortcut (m_zoom_in_action, "editor_view:zoom_in");
+    shortcut_manager::set_shortcut (m_zoom_out_action, "editor_view:zoom_out");
+    shortcut_manager::set_shortcut (m_zoom_normal_action, "editor_view:zoom_normal");
 
-  shortcut_manager::set_shortcut (m_conv_eol_windows_action, "editor_edit:conv_eol_winows");
-  shortcut_manager::set_shortcut (m_conv_eol_unix_action,    "editor_edit:conv_eol_unix");
-  shortcut_manager::set_shortcut (m_conv_eol_mac_action,     "editor_edit:conv_eol_mac");
+    // Debug menu
+    shortcut_manager::set_shortcut (m_toggle_breakpoint_action, "editor_debug:toggle_breakpoint");
+    shortcut_manager::set_shortcut (m_next_breakpoint_action, "editor_debug:next_breakpoint");
+    shortcut_manager::set_shortcut (m_previous_breakpoint_action, "editor_debug:previous_breakpoint");
+    shortcut_manager::set_shortcut (m_remove_all_breakpoints_action, "editor_debug:remove_breakpoints");
+
+    // Run menu
+    shortcut_manager::set_shortcut (m_run_action, "editor_run:run_file");
+    shortcut_manager::set_shortcut (m_run_selection_action, "editor_run:run_selection");
 
-  // View menu
-  shortcut_manager::set_shortcut (m_show_linenum_action, "editor_view:show_line_numbers");
-  shortcut_manager::set_shortcut (m_show_whitespace_action, "editor_view:show_white_spaces");
-  shortcut_manager::set_shortcut (m_show_eol_action, "editor_view:show_eol_chars");
-  shortcut_manager::set_shortcut (m_show_indguide_action, "editor_view:show_ind_guides");
-  shortcut_manager::set_shortcut (m_show_longline_action, "editor_view:show_long_line");
-  shortcut_manager::set_shortcut (m_show_toolbar_action, "editor_view:show_toolbar");
-  shortcut_manager::set_shortcut (m_show_statusbar_action, "editor_view:show_statusbar");
-  shortcut_manager::set_shortcut (m_show_hscrollbar_action, "editor_view:show_hscrollbar");
-  shortcut_manager::set_shortcut (m_zoom_in_action, "editor_view:zoom_in");
-  shortcut_manager::set_shortcut (m_zoom_out_action, "editor_view:zoom_out");
-  shortcut_manager::set_shortcut (m_zoom_normal_action, "editor_view:zoom_normal");
+    // Help menu
+    shortcut_manager::set_shortcut (m_context_help_action, "editor_help:help_keyword");
+    shortcut_manager::set_shortcut (m_context_doc_action,  "editor_help:doc_keyword");
+
+    // Tab navigation without menu entries
+    shortcut_manager::set_shortcut (m_switch_left_tab_action, "editor_tabs:switch_left_tab");
+    shortcut_manager::set_shortcut (m_switch_right_tab_action, "editor_tabs:switch_right_tab");
+    shortcut_manager::set_shortcut (m_move_tab_left_action, "editor_tabs:move_tab_left");
+    shortcut_manager::set_shortcut (m_move_tab_right_action, "editor_tabs:move_tab_right");
+
+  }
 
-  // Debug menu
-  shortcut_manager::set_shortcut (m_toggle_breakpoint_action, "editor_debug:toggle_breakpoint");
-  shortcut_manager::set_shortcut (m_next_breakpoint_action, "editor_debug:next_breakpoint");
-  shortcut_manager::set_shortcut (m_previous_breakpoint_action, "editor_debug:previous_breakpoint");
-  shortcut_manager::set_shortcut (m_remove_all_breakpoints_action, "editor_debug:remove_breakpoints");
-
-  // Run menu
-  shortcut_manager::set_shortcut (m_run_action, "editor_run:run_file");
-  shortcut_manager::set_shortcut (m_run_selection_action, "editor_run:run_selection");
+  // This slot is a reimplementation of the virtual slot in octave_dock_widget.
+  // We need this for creating an empty script when the editor has no open files
+  // and is made visible
+  void file_editor::handle_visibility (bool visible)
+  {
+    if (m_closed && visible)
+      {
+        m_closed = false;
+        QSettings *settings = resource_manager::get_settings ();
+        restore_session (settings);
+      }
 
-  // Help menu
-  shortcut_manager::set_shortcut (m_context_help_action, "editor_help:help_keyword");
-  shortcut_manager::set_shortcut (m_context_doc_action,  "editor_help:doc_keyword");
+    empty_script (false, visible);
+
+    if (visible && ! isFloating ())
+      focus ();
 
-  // Tab navigation without menu entries
-  shortcut_manager::set_shortcut (m_switch_left_tab_action, "editor_tabs:switch_left_tab");
-  shortcut_manager::set_shortcut (m_switch_right_tab_action, "editor_tabs:switch_right_tab");
-  shortcut_manager::set_shortcut (m_move_tab_left_action, "editor_tabs:move_tab_left");
-  shortcut_manager::set_shortcut (m_move_tab_right_action, "editor_tabs:move_tab_right");
+  }
 
-}
+  void file_editor::update_octave_directory (const QString& dir)
+  {
+    m_ced = dir;
+    emit fetab_set_directory (m_ced);  // for save dialog
+  }
 
-// This slot is a reimplementation of the virtual slot in octave_dock_widget.
-// We need this for creating an empty script when the editor has no open files
-// and is made visible
-void
-file_editor::handle_visibility (bool visible)
-{
-  if (m_closed && visible)
-    {
-      m_closed = false;
-      QSettings *settings = resource_manager::get_settings ();
-      restore_session (settings);
-    }
+  void file_editor::copyClipboard (void)
+  {
+    if (editor_tab_has_focus ())
+      emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                    QsciScintillaBase::SCI_COPY);
+  }
 
-  empty_script (false, visible);
-
-  if (visible && ! isFloating ())
-    focus ();
-
-}
+  void file_editor::pasteClipboard (void)
+  {
+    if (editor_tab_has_focus ())
+      emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                    QsciScintillaBase::SCI_PASTE);
+  }
 
-void
-file_editor::update_octave_directory (const QString& dir)
-{
-  m_ced = dir;
-  emit fetab_set_directory (m_ced);  // for save dialog
-}
-
-void
-file_editor::copyClipboard (void)
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_COPY);
-}
+  void file_editor::selectAll (void)
+  {
+    if (editor_tab_has_focus ())
+      emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                    QsciScintillaBase::SCI_SELECTALL);
+  }
 
-void
-file_editor::pasteClipboard (void)
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_PASTE);
-}
+  void file_editor::do_undo (void)
+  {
+    if (editor_tab_has_focus ())
+      emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                    QsciScintillaBase::SCI_UNDO);
+  }
 
-void
-file_editor::selectAll (void)
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_SELECTALL);
-}
+  // Open a file, if not already open, and mark the current execution location
+  // and/or a breakpoint with condition cond.
+  void file_editor::request_open_file (const QString& openFileName,
+                                       const QString& encoding,
+                                       int line, bool debug_pointer,
+                                       bool breakpoint_marker, bool insert,
+                                       const QString& cond)
+  {
+    if (call_custom_editor (openFileName, line))
+      return;   // custom editor called
 
-void
-file_editor::do_undo (void)
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_UNDO);
-}
+    if (openFileName.isEmpty ())
+      {
+        // This happens if edit is calles without an argument
+        // Open eitor with empty edit area instead (as new file would do)
+        request_new_file ("");
+      }
+    else
+      {
+        // Check whether this file is already open in the editor.
+        QWidget *tab = find_tab_widget (openFileName);
 
-// Open a file, if not already open, and mark the current execution location
-// and/or a breakpoint with condition cond.
-void
-file_editor::request_open_file (const QString& openFileName,
-                                const QString& encoding,
-                                int line, bool debug_pointer,
-                                bool breakpoint_marker, bool insert,
-                                const QString& cond)
-{
-  if (call_custom_editor (openFileName, line))
-    return;   // custom editor called
+        if (tab)
+          {
+            m_tab_widget->setCurrentWidget (tab);
 
-  if (openFileName.isEmpty ())
-    {
-      // This happens if edit is calles without an argument
-      // Open eitor with empty edit area instead (as new file would do)
-      request_new_file ("");
-    }
-  else
-    {
-      // Check whether this file is already open in the editor.
-      QWidget *tab = find_tab_widget (openFileName);
+            if (line > 0)
+              {
+                if (insert)
+                  emit fetab_goto_line (tab, line);
 
-      if (tab)
-        {
-          m_tab_widget->setCurrentWidget (tab);
+                if (debug_pointer)
+                  emit fetab_insert_debugger_pointer (tab, line);
 
-          if (line > 0)
-            {
-              if (insert)
-                emit fetab_goto_line (tab, line);
-
-              if (debug_pointer)
-                emit fetab_insert_debugger_pointer (tab, line);
-
-              if (breakpoint_marker)
-                emit fetab_do_breakpoint_marker (insert, tab, line, cond);
-            }
+                if (breakpoint_marker)
+                  emit fetab_do_breakpoint_marker (insert, tab, line, cond);
+              }
 
-          if (! ((breakpoint_marker || debug_pointer) && is_editor_console_tabbed ()))
-            {
-              emit fetab_set_focus (tab);
-              focus ();
-            }
-        }
-      else
-        {
-          file_editor_tab *fileEditorTab = nullptr;
-          // Reuse <unnamed> tab if it hasn't yet been modified.
-          bool reusing = false;
-          tab = find_tab_widget ("");
-          if (tab)
-            {
-              fileEditorTab = static_cast<file_editor_tab *>(tab);
-              if (fileEditorTab->qsci_edit_area ()->isModified ())
-                fileEditorTab = nullptr;
-              else
-                reusing = true;
-            }
+            if (! ((breakpoint_marker || debug_pointer) && is_editor_console_tabbed ()))
+              {
+                emit fetab_set_focus (tab);
+                focus ();
+              }
+          }
+        else
+          {
+            file_editor_tab *fileEditorTab = nullptr;
+            // Reuse <unnamed> tab if it hasn't yet been modified.
+            bool reusing = false;
+            tab = find_tab_widget ("");
+            if (tab)
+              {
+                fileEditorTab = static_cast<file_editor_tab *>(tab);
+                if (fileEditorTab->qsci_edit_area ()->isModified ())
+                  fileEditorTab = nullptr;
+                else
+                  reusing = true;
+              }
 
-          // If <unnamed> was absent or modified, create a new tab.
-          if (! fileEditorTab)
-            fileEditorTab = new file_editor_tab ();
+            // If <unnamed> was absent or modified, create a new tab.
+            if (! fileEditorTab)
+              fileEditorTab = new file_editor_tab ();
 
-          if (fileEditorTab)
-            {
-              fileEditorTab->set_encoding (encoding);
-              QString result = fileEditorTab->load_file (openFileName);
-              if (result == "")
-                {
-                  // Supply empty title then have the file_editor_tab update
-                  // with full or short name.
-                  if (! reusing)
-                    add_file_editor_tab (fileEditorTab, "");
-                  fileEditorTab->update_window_title (false);
-                  // file already loaded, add file to mru list here
-                  QFileInfo file_info = QFileInfo (openFileName);
-                  handle_mru_add_file (file_info.canonicalFilePath (),
-                                       encoding);
+            if (fileEditorTab)
+              {
+                fileEditorTab->set_encoding (encoding);
+                QString result = fileEditorTab->load_file (openFileName);
+                if (result == "")
+                  {
+                    // Supply empty title then have the file_editor_tab update
+                    // with full or short name.
+                    if (! reusing)
+                      add_file_editor_tab (fileEditorTab, "");
+                    fileEditorTab->update_window_title (false);
+                    // file already loaded, add file to mru list here
+                    QFileInfo file_info = QFileInfo (openFileName);
+                    handle_mru_add_file (file_info.canonicalFilePath (),
+                                         encoding);
 
-                  if (line > 0)
-                    {
-                      if (insert)
-                        emit fetab_goto_line (fileEditorTab, line);
+                    if (line > 0)
+                      {
+                        if (insert)
+                          emit fetab_goto_line (fileEditorTab, line);
 
-                      if (debug_pointer)
-                        emit fetab_insert_debugger_pointer (fileEditorTab,
-                                                            line);
-                      if (breakpoint_marker)
-                        emit fetab_do_breakpoint_marker (insert, fileEditorTab,
-                                                         line, cond);
-                    }
-                }
-              else
-                {
-                  delete fileEditorTab;
+                        if (debug_pointer)
+                          emit fetab_insert_debugger_pointer (fileEditorTab,
+                                                              line);
+                        if (breakpoint_marker)
+                          emit fetab_do_breakpoint_marker (insert, fileEditorTab,
+                                                           line, cond);
+                      }
+                  }
+                else
+                  {
+                    delete fileEditorTab;
 
-                  if (QFile::exists (openFileName))
-                    {
-                      // File not readable:
-                      // create a NonModal message about error.
-                      QMessageBox *msgBox
-                        = new QMessageBox (QMessageBox::Critical,
-                                           tr ("Octave Editor"),
-                                           tr ("Could not open file\n%1\nfor read: %2.").
-                                           arg (openFileName).arg (result),
-                                           QMessageBox::Ok, this);
+                    if (QFile::exists (openFileName))
+                      {
+                        // File not readable:
+                        // create a NonModal message about error.
+                        QMessageBox *msgBox
+                          = new QMessageBox (QMessageBox::Critical,
+                                             tr ("Octave Editor"),
+                                             tr ("Could not open file\n%1\nfor read: %2.").
+                                             arg (openFileName).arg (result),
+                                             QMessageBox::Ok, this);
 
-                      msgBox->setWindowModality (Qt::NonModal);
-                      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-                      msgBox->show ();
-                    }
-                  else
-                    {
-                      // File does not exist, should it be created?
-                      bool create_file = true;
-                      QMessageBox *msgBox;
-                      QSettings *settings = resource_manager::get_settings ();
+                        msgBox->setWindowModality (Qt::NonModal);
+                        msgBox->setAttribute (Qt::WA_DeleteOnClose);
+                        msgBox->show ();
+                      }
+                    else
+                      {
+                        // File does not exist, should it be created?
+                        bool create_file = true;
+                        QMessageBox *msgBox;
+                        QSettings *settings = resource_manager::get_settings ();
 
-                      if (! settings->value ("editor/create_new_file", false).toBool ())
-                        {
-                          msgBox = new QMessageBox (QMessageBox::Question,
-                                                    tr ("Octave Editor"),
-                                                    tr ("File\n%1\ndoes not exist. "
-                                                        "Do you want to create it?").arg (openFileName),
-                                                    QMessageBox::NoButton,nullptr);
-                          QPushButton *create_button =
-                            msgBox->addButton (tr ("Create"), QMessageBox::YesRole);
-                          msgBox->addButton (tr ("Cancel"), QMessageBox::RejectRole);
-                          msgBox->setDefaultButton (create_button);
-                          msgBox->exec ();
+                        if (! settings->value ("editor/create_new_file", false).toBool ())
+                          {
+                            msgBox = new QMessageBox (QMessageBox::Question,
+                                                      tr ("Octave Editor"),
+                                                      tr ("File\n%1\ndoes not exist. "
+                                                          "Do you want to create it?").arg (openFileName),
+                                                      QMessageBox::NoButton,nullptr);
+                            QPushButton *create_button =
+                              msgBox->addButton (tr ("Create"), QMessageBox::YesRole);
+                            msgBox->addButton (tr ("Cancel"), QMessageBox::RejectRole);
+                            msgBox->setDefaultButton (create_button);
+                            msgBox->exec ();
 
-                          QAbstractButton *clicked_button = msgBox->clickedButton ();
-                          if (clicked_button != create_button)
-                            create_file = false;
+                            QAbstractButton *clicked_button = msgBox->clickedButton ();
+                            if (clicked_button != create_button)
+                              create_file = false;
+
+                            delete msgBox;
+                          }
 
-                          delete msgBox;
-                        }
+                        if (create_file)
+                          {
+                            // create the file and call the editor again
+                            QFile file (openFileName);
+                            if (! file.open (QIODevice::WriteOnly))
+                              {
+                                // error opening the file
+                                msgBox = new QMessageBox (QMessageBox::Critical,
+                                                          tr ("Octave Editor"),
+                                                          tr ("Could not open file\n%1\nfor write: %2.").
+                                                          arg (openFileName).arg (file.errorString ()),
+                                                          QMessageBox::Ok, this);
 
-                      if (create_file)
-                        {
-                          // create the file and call the editor again
-                          QFile file (openFileName);
-                          if (! file.open (QIODevice::WriteOnly))
-                            {
-                              // error opening the file
-                              msgBox = new QMessageBox (QMessageBox::Critical,
-                                                        tr ("Octave Editor"),
-                                                        tr ("Could not open file\n%1\nfor write: %2.").
-                                                        arg (openFileName).arg (file.errorString ()),
-                                                        QMessageBox::Ok, this);
-
-                              msgBox->setWindowModality (Qt::NonModal);
-                              msgBox->setAttribute (Qt::WA_DeleteOnClose);
-                              msgBox->show ();
-                            }
-                          else
-                            {
-                              file.close ();
-                              request_open_file (openFileName);
-                            }
-                        }
-                    }
-                }
-            }
+                                msgBox->setWindowModality (Qt::NonModal);
+                                msgBox->setAttribute (Qt::WA_DeleteOnClose);
+                                msgBox->show ();
+                              }
+                            else
+                              {
+                                file.close ();
+                                request_open_file (openFileName);
+                              }
+                          }
+                      }
+                  }
+              }
 
-          if (! ((breakpoint_marker || debug_pointer) && is_editor_console_tabbed ()))
-            {
-              // really show editor and the current editor tab
-              focus ();
-              emit file_loaded_signal ();
-            }
-        }
-    }
-}
+            if (! ((breakpoint_marker || debug_pointer) && is_editor_console_tabbed ()))
+              {
+                // really show editor and the current editor tab
+                focus ();
+                emit file_loaded_signal ();
+              }
+          }
+      }
+  }
 
-void
-file_editor::request_preferences (bool)
-{
-  emit request_settings_dialog ("editor");
-}
+  void file_editor::request_preferences (bool)
+  {
+    emit request_settings_dialog ("editor");
+  }
+
+  void file_editor::request_styles_preferences (bool)
+  {
+    emit request_settings_dialog ("editor_styles");
+  }
 
-void
-file_editor::request_styles_preferences (bool)
-{
-  emit request_settings_dialog ("editor_styles");
-}
+  void file_editor::show_line_numbers (bool)
+  {
+    toggle_preference ("editor/showLineNumbers",true);
+  }
 
-void
-file_editor::show_line_numbers (bool)
-{
-  toggle_preference ("editor/showLineNumbers",true);
-}
+  void file_editor::show_white_space (bool)
+  {
+    toggle_preference ("editor/show_white_space",false);
+  }
 
-void
-file_editor::show_white_space (bool)
-{
-  toggle_preference ("editor/show_white_space",false);
-}
+  void file_editor::show_eol_chars (bool)
+  {
+    toggle_preference ("editor/show_eol_chars",false);
+  }
 
-void
-file_editor::show_eol_chars (bool)
-{
-  toggle_preference ("editor/show_eol_chars",false);
-}
+  void file_editor::show_indent_guides (bool)
+  {
+    toggle_preference ("editor/show_indent_guides",false);
+  }
+
+  void file_editor::show_long_line (bool)
+  {
+    toggle_preference ("editor/long_line_marker",true);
+  }
 
-void
-file_editor::show_indent_guides (bool)
-{
-  toggle_preference ("editor/show_indent_guides",false);
-}
+  void file_editor::show_toolbar (bool)
+  {
+    toggle_preference ("editor/show_toolbar",true);
+  }
 
-void
-file_editor::show_long_line (bool)
-{
-  toggle_preference ("editor/long_line_marker",true);
-}
+  void file_editor::show_statusbar (bool)
+  {
+    toggle_preference ("editor/show_edit_status_bar",true);
+  }
 
-void
-file_editor::show_toolbar (bool)
-{
-  toggle_preference ("editor/show_toolbar",true);
-}
+  void file_editor::show_hscrollbar (bool)
+  {
+    toggle_preference ("editor/show_hscroll_bar",true);
+  }
 
-void
-file_editor::show_statusbar (bool)
-{
-  toggle_preference ("editor/show_edit_status_bar",true);
-}
+  void file_editor::zoom_in (bool)
+  {
+    emit fetab_zoom_in (m_tab_widget->currentWidget ());
+  }
+
+  void file_editor::zoom_out (bool)
+  {
+    emit fetab_zoom_out (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::show_hscrollbar (bool)
-{
-  toggle_preference ("editor/show_hscroll_bar",true);
-}
+  void file_editor::zoom_normal (bool)
+  {
+    emit fetab_zoom_normal (m_tab_widget->currentWidget ());
+  }
 
-void
-file_editor::zoom_in (bool)
-{
-  emit fetab_zoom_in (m_tab_widget->currentWidget ());
-}
+  // slots for tab navigation
+  void file_editor::switch_left_tab (void)
+  {
+    switch_tab (-1);
+  }
 
-void
-file_editor::zoom_out (bool)
-{
-  emit fetab_zoom_out (m_tab_widget->currentWidget ());
-}
+  void file_editor::switch_right_tab (void)
+  {
+    switch_tab (1);
+  }
 
-void
-file_editor::zoom_normal (bool)
-{
-  emit fetab_zoom_normal (m_tab_widget->currentWidget ());
-}
+  void file_editor::move_tab_left (void)
+  {
+#if defined (HAVE_QTABWIDGET_SETMOVABLE)
+    switch_tab (-1, true);
+#endif
+  }
 
-// slots for tab navigation
-void
-file_editor::switch_left_tab (void)
-{
-  switch_tab (-1);
-}
+  void file_editor::move_tab_right (void)
+  {
+#if defined (HAVE_QTABWIDGET_SETMOVABLE)
+    switch_tab (1, true);
+#endif
+  }
 
-void
-file_editor::switch_right_tab (void)
-{
-  switch_tab (1);
-}
+  void file_editor::create_context_menu (QMenu *menu)
+  {
+    // remove all standard actions from scintilla
+    QList<QAction *> all_actions = menu->actions ();
+    QAction *a;
+
+    foreach (a, all_actions)
+      menu->removeAction (a);
 
-void
-file_editor::move_tab_left (void)
-{
-#if defined (HAVE_QTABWIDGET_SETMOVABLE)
-  switch_tab (-1, true);
-#endif
-}
-
-void
-file_editor::move_tab_right (void)
-{
-#if defined (HAVE_QTABWIDGET_SETMOVABLE)
-  switch_tab (1, true);
-#endif
-}
+    // add editor's actions with icons and customized shortcuts
+    menu->addAction (m_undo_action);
+    menu->addAction (m_redo_action);
+    menu->addSeparator ();
+    menu->addAction (m_cut_action);
+    menu->addAction (m_copy_action);
+    menu->addAction (m_paste_action);
+    menu->addSeparator ();
+    menu->addAction (m_selectall_action);
+    menu->addSeparator ();
+    menu->addAction (m_run_selection_action);
+  }
 
-void
-file_editor::create_context_menu (QMenu *menu)
-{
-  // remove all standard actions from scintilla
-  QList<QAction *> all_actions = menu->actions ();
-  QAction *a;
-
-  foreach (a, all_actions)
-    menu->removeAction (a);
+  void file_editor::edit_status_update (bool undo, bool redo)
+  {
+    if (m_undo_action)
+      m_undo_action->setEnabled (undo);
+    m_redo_action->setEnabled (redo);
+  }
 
-  // add editor's actions with icons and customized shortcuts
-  menu->addAction (m_undo_action);
-  menu->addAction (m_redo_action);
-  menu->addSeparator ();
-  menu->addAction (m_cut_action);
-  menu->addAction (m_copy_action);
-  menu->addAction (m_paste_action);
-  menu->addSeparator ();
-  menu->addAction (m_selectall_action);
-  menu->addSeparator ();
-  menu->addAction (m_run_selection_action);
-}
-
-void
-file_editor::edit_status_update (bool undo, bool redo)
-{
-  if (m_undo_action)
-    m_undo_action->setEnabled (undo);
-  m_redo_action->setEnabled (redo);
-}
+  // handler for the close event
+  void file_editor::closeEvent (QCloseEvent *e)
+  {
+    QSettings *settings = resource_manager::get_settings ();
+    if (settings->value ("editor/hiding_closes_files",false).toBool ())
+      {
+        if (check_closing ())
+          {
+            // all tabs are closed without cancelling,
+            // store closing state for restoring session when shown again
+            m_closed = true;
+            e->accept ();
+          }
+        else
+          e->ignore ();
+      }
+    else
+      e->accept ();
+  }
 
-// handler for the close event
-void
-file_editor::closeEvent (QCloseEvent *e)
-{
-  QSettings *settings = resource_manager::get_settings ();
-  if (settings->value ("editor/hiding_closes_files",false).toBool ())
-    {
-      if (check_closing ())
-        {
-          // all tabs are closed without cancelling,
-          // store closing state for restoring session when shown again
-          m_closed = true;
-          e->accept ();
-        }
-      else
-        e->ignore ();
-    }
-  else
-   e->accept ();
-}
+  void file_editor::dragEnterEvent (QDragEnterEvent *e)
+  {
+    if (e->mimeData ()->hasUrls ())
+      {
+        e->acceptProposedAction ();
+      }
+  }
+
+  void file_editor::dropEvent (QDropEvent *e)
+  {
+    if (e->mimeData ()->hasUrls ())
+      {
+        foreach (QUrl url, e->mimeData ()->urls ())
+          request_open_file (url.toLocalFile ());
+      }
+  }
 
-void
-file_editor::dragEnterEvent (QDragEnterEvent *e)
-{
-  if (e->mimeData ()->hasUrls ())
-    {
-      e->acceptProposedAction ();
-    }
-}
+  bool file_editor::is_editor_console_tabbed (void)
+  {
+    octave::main_window *w = static_cast<octave::main_window *>(main_win ());
+    QList<QDockWidget *> w_list = w->tabifiedDockWidgets (this);
+    QDockWidget *console =
+      static_cast<QDockWidget *> (w->get_dock_widget_list ().at (0));
 
-void
-file_editor::dropEvent (QDropEvent *e)
-{
-  if (e->mimeData ()->hasUrls ())
-    {
-      foreach (QUrl url, e->mimeData ()->urls ())
-        request_open_file (url.toLocalFile ());
-    }
-}
+    for (int i = 0; i < w_list.count (); i++)
+      {
+        if (w_list.at (i) == console)
+          return true;
+      }
+
+    return false;
+  }
+
+  void file_editor::construct (void)
+  {
+    QWidget *editor_widget = new QWidget (this);
+
+    // FIXME: what was the intended purpose of this unused variable?
+    // QStyle *editor_style = QApplication::style ();
 
-bool
-file_editor::is_editor_console_tabbed (void)
-{
-  octave::main_window *w = static_cast<octave::main_window *>(main_win ());
-  QList<QDockWidget *> w_list = w->tabifiedDockWidgets (this);
-  QDockWidget *console =
-    static_cast<QDockWidget *> (w->get_dock_widget_list ().at (0));
+    // Menu bar: do not set it native, required in MacOS and Ubuntu Unity (Qt5)
+    // for a visible menu bar in the editor widget. This property is ignored
+    // on other platforms.
+    m_menu_bar = new QMenuBar (editor_widget);
+    m_menu_bar->setNativeMenuBar (false);
 
-  for (int i = 0; i < w_list.count (); i++)
-    {
-      if (w_list.at (i) == console)
-        return true;
-    }
+    m_tool_bar = new QToolBar (editor_widget);
+    m_tool_bar->setMovable (true);
+
+    m_tab_widget = new file_editor_tab_widget (editor_widget);
 
-  return false;
-}
+    // the mru-list and an empty array of actions
+    QSettings *settings = resource_manager::get_settings ();
+    m_mru_files = settings->value ("editor/mru_file_list").toStringList ();
+    m_mru_files_encodings = settings->value ("editor/mru_file_encodings")
+      .toStringList ();
 
-void
-file_editor::construct (void)
-{
-  QWidget *editor_widget = new QWidget (this);
-
-  // FIXME: what was the intended purpose of this unused variable?
-  // QStyle *editor_style = QApplication::style ();
+    if (m_mru_files_encodings.count () != m_mru_files.count ())
+      {
+        // encodings don't have the same count -> do not use them!
+        m_mru_files_encodings = QStringList ();
+        for (int i = 0; i < m_mru_files.count (); i++)
+          m_mru_files_encodings << QString ();
+      }
 
-  // Menu bar: do not set it native, required in MacOS and Ubuntu Unity (Qt5)
-  // for a visible menu bar in the editor widget. This property is ignored
-  // on other platforms.
-  m_menu_bar = new QMenuBar (editor_widget);
-  m_menu_bar->setNativeMenuBar (false);
+    for (int i = 0; i < MaxMRUFiles; ++i)
+      {
+        m_mru_file_actions[i] = new QAction (this);
+        m_mru_file_actions[i]->setVisible (false);
+      }
 
-  m_tool_bar = new QToolBar (editor_widget);
-  m_tool_bar->setMovable (true);
+    // menu bar
 
-  m_tab_widget = new file_editor_tab_widget (editor_widget);
+    // file menu
 
-  // the mru-list and an empty array of actions
-  QSettings *settings = resource_manager::get_settings ();
-  m_mru_files = settings->value ("editor/mru_file_list").toStringList ();
-  m_mru_files_encodings = settings->value ("editor/mru_file_encodings")
-                                   .toStringList ();
+    m_fileMenu = add_menu (m_menu_bar, tr ("&File"));
 
-  if (m_mru_files_encodings.count () != m_mru_files.count ())
-    {
-      // encodings don't have the same count -> do not use them!
-      m_mru_files_encodings = QStringList ();
-      for (int i = 0; i < m_mru_files.count (); i++)
-        m_mru_files_encodings << QString ();
-    }
+    // new and open menus are inserted later by the main window
+    m_mru_file_menu = new QMenu (tr ("&Recent Editor Files"), m_fileMenu);
+    for (int i = 0; i < MaxMRUFiles; ++i)
+      m_mru_file_menu->addAction (m_mru_file_actions[i]);
+    m_fileMenu->addMenu (m_mru_file_menu);
+
+    m_fileMenu->addSeparator ();
+
+    m_edit_function_action = add_action (m_fileMenu, QIcon (),
+                                         tr ("&Edit Function"), SLOT (request_context_edit (bool)));
+
+    m_fileMenu->addSeparator ();
 
-  for (int i = 0; i < MaxMRUFiles; ++i)
-    {
-      m_mru_file_actions[i] = new QAction (this);
-      m_mru_file_actions[i]->setVisible (false);
-    }
+    m_save_action = add_action (m_fileMenu, resource_manager::icon ("document-save"),
+                                tr ("&Save File"), SLOT (request_save_file (bool)));
+    m_save_as_action = add_action (m_fileMenu, resource_manager::icon ("document-save-as"),
+                                   tr ("Save File &As..."), SLOT (request_save_file_as (bool)));
 
-  // menu bar
-
-  // file menu
+    m_fileMenu->addSeparator ();
 
-  m_fileMenu = add_menu (m_menu_bar, tr ("&File"));
+    m_close_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
+                                 tr ("&Close"), SLOT (request_close_file (bool)));
+    m_close_all_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
+                                     tr ("Close All"), SLOT (request_close_all_files (bool)));
+    m_close_others_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
+                                        tr ("Close Other Files"), SLOT (request_close_other_files (bool)));
 
-  // new and open menus are inserted later by the main window
-  m_mru_file_menu = new QMenu (tr ("&Recent Editor Files"), m_fileMenu);
-  for (int i = 0; i < MaxMRUFiles; ++i)
-    m_mru_file_menu->addAction (m_mru_file_actions[i]);
-  m_fileMenu->addMenu (m_mru_file_menu);
+    m_fileMenu->addSeparator ();
 
-  m_fileMenu->addSeparator ();
+    m_print_action = add_action (m_fileMenu, resource_manager::icon ("document-print"),
+                                 tr ("Print..."), SLOT (request_print_file (bool)));
 
-  m_edit_function_action = add_action (m_fileMenu, QIcon (),
-          tr ("&Edit Function"), SLOT (request_context_edit (bool)));
+    // edit menu (undo, copy, paste and select all later via main window)
+
+    m_edit_menu = add_menu (m_menu_bar, tr ("&Edit"));
 
-  m_fileMenu->addSeparator ();
+    m_redo_action = add_action (m_edit_menu, resource_manager::icon ("edit-redo"),
+                                tr ("&Redo"), SLOT (request_redo (bool)));
+    m_redo_action->setEnabled (false);
 
-  m_save_action = add_action (m_fileMenu, resource_manager::icon ("document-save"),
-          tr ("&Save File"), SLOT (request_save_file (bool)));
-  m_save_as_action = add_action (m_fileMenu, resource_manager::icon ("document-save-as"),
-          tr ("Save File &As..."), SLOT (request_save_file_as (bool)));
+    m_edit_menu->addSeparator ();
 
-  m_fileMenu->addSeparator ();
+    m_cut_action = add_action (m_edit_menu, resource_manager::icon ("edit-cut"),
+                               tr ("Cu&t"), SLOT (request_cut (bool)));
+    m_cut_action->setEnabled (false);
 
-  m_close_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
-          tr ("&Close"), SLOT (request_close_file (bool)));
-  m_close_all_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
-          tr ("Close All"), SLOT (request_close_all_files (bool)));
-  m_close_others_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
-          tr ("Close Other Files"), SLOT (request_close_other_files (bool)));
+    m_find_action = add_action (m_edit_menu, resource_manager::icon ("edit-find-replace"),
+                                tr ("&Find and Replace..."), SLOT (request_find (bool)));
+
+    m_find_next_action = add_action (m_edit_menu, QIcon (),
+                                     tr ("Find &Next..."), SLOT (request_find_next (bool)));
 
-  m_fileMenu->addSeparator ();
+    m_find_previous_action = add_action (m_edit_menu, QIcon (),
+                                         tr ("Find &Previous..."), SLOT (request_find_previous (bool)));
 
-  m_print_action = add_action (m_fileMenu, resource_manager::icon ("document-print"),
-          tr ("Print..."), SLOT (request_print_file (bool)));
+    m_edit_menu->addSeparator ();
 
-  // edit menu (undo, copy, paste and select all later via main window)
-
-  m_edit_menu = add_menu (m_menu_bar, tr ("&Edit"));
+    m_edit_cmd_menu = m_edit_menu->addMenu (tr ("&Commands"));
 
-  m_redo_action = add_action (m_edit_menu, resource_manager::icon ("edit-redo"),
-          tr ("&Redo"), SLOT (request_redo (bool)));
-  m_redo_action->setEnabled (false);
+    m_delete_line_action = add_action (m_edit_cmd_menu, QIcon (),
+                                       tr ("Delete Line"), SLOT (request_delete_line (bool)));
+    m_copy_line_action = add_action (m_edit_cmd_menu, QIcon (),
+                                     tr ("Copy Line"), SLOT (request_copy_line (bool)));
+    m_cut_line_action = add_action (m_edit_cmd_menu, QIcon (),
+                                    tr ("Cut Line"), SLOT (request_cut_line (bool)));
 
-  m_edit_menu->addSeparator ();
-
-  m_cut_action = add_action (m_edit_menu, resource_manager::icon ("edit-cut"),
-          tr ("Cu&t"), SLOT (request_cut (bool)));
-  m_cut_action->setEnabled (false);
+    m_edit_cmd_menu->addSeparator ();
 
-  m_find_action = add_action (m_edit_menu, resource_manager::icon ("edit-find-replace"),
-          tr ("&Find and Replace..."), SLOT (request_find (bool)));
-
-  m_find_next_action = add_action (m_edit_menu, QIcon (),
-          tr ("Find &Next..."), SLOT (request_find_next (bool)));
+    m_delete_start_word_action = add_action (m_edit_cmd_menu, QIcon (),
+                                             tr ("Delete to Start of Word"), SLOT (request_delete_start_word (bool)));
+    m_delete_end_word_action = add_action (m_edit_cmd_menu, QIcon (),
+                                           tr ("Delete to End of Word"), SLOT (request_delete_end_word (bool)));
+    m_delete_start_line_action = add_action (m_edit_cmd_menu, QIcon (),
+                                             tr ("Delete to Start of Line"), SLOT (request_delete_start_line (bool)));
+    m_delete_end_line_action = add_action (m_edit_cmd_menu, QIcon (),
+                                           tr ("Delete to End of Line"), SLOT (request_delete_end_line (bool)));
 
-  m_find_previous_action = add_action (m_edit_menu, QIcon (),
-          tr ("Find &Previous..."), SLOT (request_find_previous (bool)));
+    m_edit_cmd_menu->addSeparator ();
 
-  m_edit_menu->addSeparator ();
+    m_duplicate_selection_action = add_action (m_edit_cmd_menu, QIcon (),
+                                               tr ("Duplicate Selection/Line"), SLOT (request_duplicate_selection (bool)));
+    m_transpose_line_action = add_action (m_edit_cmd_menu, QIcon (),
+                                          tr ("Transpose Line"), SLOT (request_transpose_line (bool)));
 
-  m_edit_cmd_menu = m_edit_menu->addMenu (tr ("&Commands"));
+    m_edit_cmd_menu->addSeparator ();
 
-  m_delete_line_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Delete Line"), SLOT (request_delete_line (bool)));
-  m_copy_line_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Copy Line"), SLOT (request_copy_line (bool)));
-  m_cut_line_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Cut Line"), SLOT (request_cut_line (bool)));
+    m_completion_action = add_action (m_edit_cmd_menu, QIcon (),
+                                      tr ("&Show Completion List"), SLOT (request_completion (bool)));
 
-  m_edit_cmd_menu->addSeparator ();
+    m_edit_fmt_menu = m_edit_menu->addMenu (tr ("&Format"));
 
-  m_delete_start_word_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Delete to Start of Word"), SLOT (request_delete_start_word (bool)));
-  m_delete_end_word_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Delete to End of Word"), SLOT (request_delete_end_word (bool)));
-  m_delete_start_line_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Delete to Start of Line"), SLOT (request_delete_start_line (bool)));
-  m_delete_end_line_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Delete to End of Line"), SLOT (request_delete_end_line (bool)));
+    m_upper_case_action = add_action (m_edit_fmt_menu, QIcon (),
+                                      tr ("&Uppercase Selection"), SLOT (request_upper_case (bool)));
+    m_lower_case_action = add_action (m_edit_fmt_menu, QIcon (),
+                                      tr ("&Lowercase Selection"), SLOT (request_lower_case (bool)));
+
+    m_edit_fmt_menu->addSeparator ();
 
-  m_edit_cmd_menu->addSeparator ();
-
-  m_duplicate_selection_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Duplicate Selection/Line"), SLOT (request_duplicate_selection (bool)));
-  m_transpose_line_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("Transpose Line"), SLOT (request_transpose_line (bool)));
+    m_comment_selection_action = add_action (m_edit_fmt_menu, QIcon (),
+                                             tr ("&Comment"), SLOT (request_comment_selected_text (bool)));
+    m_uncomment_selection_action = add_action (m_edit_fmt_menu, QIcon (),
+                                               tr ("&Uncomment"), SLOT (request_uncomment_selected_text (bool)));
+    m_comment_var_selection_action = add_action (m_edit_fmt_menu, QIcon (),
+                                                 tr ("Comment (Choosing String)"), SLOT (request_comment_var_selected_text (bool)));
 
-  m_edit_cmd_menu->addSeparator ();
-
-  m_completion_action = add_action (m_edit_cmd_menu, QIcon (),
-          tr ("&Show Completion List"), SLOT (request_completion (bool)));
-
-  m_edit_fmt_menu = m_edit_menu->addMenu (tr ("&Format"));
+    m_edit_fmt_menu->addSeparator ();
 
-  m_upper_case_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("&Uppercase Selection"), SLOT (request_upper_case (bool)));
-  m_lower_case_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("&Lowercase Selection"), SLOT (request_lower_case (bool)));
+    m_indent_selection_action = add_action (m_edit_fmt_menu, QIcon (),
+                                            tr ("&Indent Selection Rigidly"), SLOT (request_indent_selected_text (bool)));
+    m_unindent_selection_action = add_action (m_edit_fmt_menu, QIcon (),
+                                              tr ("&Unindent Selection Rigidly"), SLOT (request_unindent_selected_text (bool)));
 
-  m_edit_fmt_menu->addSeparator ();
+    m_smart_indent_line_or_selection_action
+      = add_action (m_edit_fmt_menu, QIcon (),
+                    tr ("Indent Code"), SLOT (request_smart_indent_line_or_selected_text (void)));
+
+    m_edit_fmt_menu->addSeparator ();
 
-  m_comment_selection_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("&Comment"), SLOT (request_comment_selected_text (bool)));
-  m_uncomment_selection_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("&Uncomment"), SLOT (request_uncomment_selected_text (bool)));
-  m_comment_var_selection_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("Comment (Choosing String)"), SLOT (request_comment_var_selected_text (bool)));
-
-  m_edit_fmt_menu->addSeparator ();
+    m_conv_eol_windows_action = add_action (m_edit_fmt_menu, QIcon (),
+                                            tr ("Convert Line Endings to &Windows (CRLF)"),
+                                            SLOT (request_conv_eol_windows (bool)));
+    m_conv_eol_unix_action = add_action (m_edit_fmt_menu, QIcon (),
+                                         tr ("Convert Line Endings to &Unix (LF)"),
+                                         SLOT (request_conv_eol_unix (bool)));
+    m_conv_eol_mac_action = add_action (m_edit_fmt_menu, QIcon (),
+                                        tr ("Convert Line Endings to &Mac (CR)"),
+                                        SLOT (request_conv_eol_mac (bool)));
 
-  m_indent_selection_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("&Indent Selection Rigidly"), SLOT (request_indent_selected_text (bool)));
-  m_unindent_selection_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("&Unindent Selection Rigidly"), SLOT (request_unindent_selected_text (bool)));
+    m_edit_nav_menu = m_edit_menu->addMenu (tr ("Navi&gation"));
+
+    m_goto_line_action = add_action (m_edit_nav_menu, QIcon (),
+                                     tr ("Go &to Line..."), SLOT (request_goto_line (bool)));
 
-  m_smart_indent_line_or_selection_action
-    = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("Indent Code"), SLOT (request_smart_indent_line_or_selected_text (void)));
+    m_edit_cmd_menu->addSeparator ();
 
-  m_edit_fmt_menu->addSeparator ();
+    m_move_to_matching_brace = add_action (m_edit_nav_menu, QIcon (),
+                                           tr ("Move to Matching Brace"), SLOT (request_move_match_brace (bool)));
+    m_sel_to_matching_brace = add_action (m_edit_nav_menu, QIcon (),
+                                          tr ("Select to Matching Brace"), SLOT (request_sel_match_brace (bool)));
 
-  m_conv_eol_windows_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("Convert Line Endings to &Windows (CRLF)"),
-          SLOT (request_conv_eol_windows (bool)));
-  m_conv_eol_unix_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("Convert Line Endings to &Unix (LF)"),
-          SLOT (request_conv_eol_unix (bool)));
-  m_conv_eol_mac_action = add_action (m_edit_fmt_menu, QIcon (),
-          tr ("Convert Line Endings to &Mac (CR)"),
-          SLOT (request_conv_eol_mac (bool)));
+    m_edit_nav_menu->addSeparator ();
 
-  m_edit_nav_menu = m_edit_menu->addMenu (tr ("Navi&gation"));
+    m_next_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
+                                         tr ("&Next Bookmark"), SLOT (request_next_bookmark (bool)));
+    m_previous_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
+                                             tr ("Pre&vious Bookmark"), SLOT (request_previous_bookmark (bool)));
+    m_toggle_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
+                                           tr ("Toggle &Bookmark"), SLOT (request_toggle_bookmark (bool)));
+    m_remove_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
+                                           tr ("&Remove All Bookmarks"), SLOT (request_remove_bookmark (bool)));
 
-  m_goto_line_action = add_action (m_edit_nav_menu, QIcon (),
-          tr ("Go &to Line..."), SLOT (request_goto_line (bool)));
+    m_edit_menu->addSeparator ();
 
-  m_edit_cmd_menu->addSeparator ();
+    m_preferences_action = add_action (m_edit_menu, resource_manager::icon ("preferences-system"),
+                                       tr ("&Preferences..."), SLOT (request_preferences (bool)));
+    m_styles_preferences_action = add_action (m_edit_menu,  resource_manager::icon ("preferences-system"),
+                                              tr ("&Styles Preferences..."), SLOT (request_styles_preferences (bool)));
 
-  m_move_to_matching_brace = add_action (m_edit_nav_menu, QIcon (),
-          tr ("Move to Matching Brace"), SLOT (request_move_match_brace (bool)));
-  m_sel_to_matching_brace = add_action (m_edit_nav_menu, QIcon (),
-          tr ("Select to Matching Brace"), SLOT (request_sel_match_brace (bool)));
+    // view menu
 
-  m_edit_nav_menu->addSeparator ();
+    QMenu *view_menu = add_menu (m_menu_bar, tr ("&View"));
+
+    m_view_editor_menu = view_menu->addMenu (tr ("&Editor"));
 
-  m_next_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
-          tr ("&Next Bookmark"), SLOT (request_next_bookmark (bool)));
-  m_previous_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
-          tr ("Pre&vious Bookmark"), SLOT (request_previous_bookmark (bool)));
-  m_toggle_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
-          tr ("Toggle &Bookmark"), SLOT (request_toggle_bookmark (bool)));
-  m_remove_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
-          tr ("&Remove All Bookmarks"), SLOT (request_remove_bookmark (bool)));
+    m_show_linenum_action = add_action (m_view_editor_menu, QIcon (),
+                                        tr ("Show &Line Numbers"), SLOT (show_line_numbers (bool)));
+    m_show_linenum_action->setCheckable (true);
 
-  m_edit_menu->addSeparator ();
+    m_show_whitespace_action = add_action (m_view_editor_menu, QIcon (),
+                                           tr ("Show &Whitespace Characters"), SLOT (show_white_space (bool)));
+    m_show_whitespace_action->setCheckable (true);
 
-  m_preferences_action = add_action (m_edit_menu, resource_manager::icon ("preferences-system"),
-          tr ("&Preferences..."), SLOT (request_preferences (bool)));
-  m_styles_preferences_action = add_action (m_edit_menu,  resource_manager::icon ("preferences-system"),
-          tr ("&Styles Preferences..."), SLOT (request_styles_preferences (bool)));
+    m_show_eol_action = add_action (m_view_editor_menu, QIcon (),
+                                    tr ("Show Line &Endings"), SLOT (show_eol_chars (bool)));
+    m_show_eol_action->setCheckable (true);
 
-  // view menu
-
-  QMenu *view_menu = add_menu (m_menu_bar, tr ("&View"));
-
-  m_view_editor_menu = view_menu->addMenu (tr ("&Editor"));
+    m_show_indguide_action = add_action (m_view_editor_menu, QIcon (),
+                                         tr ("Show &Indentation Guides"), SLOT (show_indent_guides (bool)));
+    m_show_indguide_action->setCheckable (true);
 
-  m_show_linenum_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show &Line Numbers"), SLOT (show_line_numbers (bool)));
-  m_show_linenum_action->setCheckable (true);
+    m_show_longline_action = add_action (m_view_editor_menu, QIcon (),
+                                         tr ("Show Long Line &Marker"), SLOT (show_long_line (bool)));
+    m_show_longline_action->setCheckable (true);
 
-  m_show_whitespace_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show &Whitespace Characters"), SLOT (show_white_space (bool)));
-  m_show_whitespace_action->setCheckable (true);
+    m_view_editor_menu->addSeparator ();
+
+    m_show_toolbar_action = add_action (m_view_editor_menu, QIcon (),
+                                        tr ("Show &Toolbar"), SLOT (show_toolbar (bool)));
+    m_show_toolbar_action->setCheckable (true);
 
-  m_show_eol_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show Line &Endings"), SLOT (show_eol_chars (bool)));
-  m_show_eol_action->setCheckable (true);
+    m_show_statusbar_action = add_action (m_view_editor_menu, QIcon (),
+                                          tr ("Show &Statusbar"), SLOT (show_statusbar (bool)));
+    m_show_statusbar_action->setCheckable (true);
 
-  m_show_indguide_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show &Indentation Guides"), SLOT (show_indent_guides (bool)));
-  m_show_indguide_action->setCheckable (true);
+    m_show_hscrollbar_action = add_action (m_view_editor_menu, QIcon (),
+                                           tr ("Show &Horizontal Scrollbar"), SLOT (show_hscrollbar (bool)));
+    m_show_hscrollbar_action->setCheckable (true);
 
-  m_show_longline_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show Long Line &Marker"), SLOT (show_long_line (bool)));
-  m_show_longline_action->setCheckable (true);
+    view_menu->addSeparator ();
 
-  m_view_editor_menu->addSeparator ();
+    m_zoom_in_action = add_action (view_menu, resource_manager::icon ("zoom-in"),
+                                   tr ("Zoom &In"), SLOT (zoom_in (bool)));
+    m_zoom_out_action = add_action (view_menu, resource_manager::icon ("zoom-out"),
+                                    tr ("Zoom &Out"), SLOT (zoom_out (bool)));
+    m_zoom_normal_action = add_action (view_menu,  QIcon (),
+                                       tr ("&Normal Size"), SLOT (zoom_normal (bool)));
 
-  m_show_toolbar_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show &Toolbar"), SLOT (show_toolbar (bool)));
-  m_show_toolbar_action->setCheckable (true);
+    m_menu_bar->addMenu (view_menu);
 
-  m_show_statusbar_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show &Statusbar"), SLOT (show_statusbar (bool)));
-  m_show_statusbar_action->setCheckable (true);
-
-  m_show_hscrollbar_action = add_action (m_view_editor_menu, QIcon (),
-          tr ("Show &Horizontal Scrollbar"), SLOT (show_hscrollbar (bool)));
-  m_show_hscrollbar_action->setCheckable (true);
+    // debug menu
 
-  view_menu->addSeparator ();
-
-  m_zoom_in_action = add_action (view_menu, resource_manager::icon ("zoom-in"),
-          tr ("Zoom &In"), SLOT (zoom_in (bool)));
-  m_zoom_out_action = add_action (view_menu, resource_manager::icon ("zoom-out"),
-          tr ("Zoom &Out"), SLOT (zoom_out (bool)));
-  m_zoom_normal_action = add_action (view_menu,  QIcon (),
-          tr ("&Normal Size"), SLOT (zoom_normal (bool)));
-
-  m_menu_bar->addMenu (view_menu);
+    m_debug_menu = add_menu (m_menu_bar, tr ("&Debug"));
 
-  // debug menu
-
-  m_debug_menu = add_menu (m_menu_bar, tr ("&Debug"));
+    m_toggle_breakpoint_action = add_action (m_debug_menu,
+                                             resource_manager::icon ("bp-toggle"), tr ("Toggle &Breakpoint"),
+                                             SLOT (request_toggle_breakpoint (bool)));
+    m_next_breakpoint_action = add_action (m_debug_menu,
+                                           resource_manager::icon ("bp-next"), tr ("&Next Breakpoint"),
+                                           SLOT (request_next_breakpoint (bool)));
+    m_previous_breakpoint_action = add_action (m_debug_menu,
+                                               resource_manager::icon ("bp-prev"), tr ("Pre&vious Breakpoint"),
+                                               SLOT (request_previous_breakpoint (bool)));
+    m_remove_all_breakpoints_action = add_action (m_debug_menu,
+                                                  resource_manager::icon ("bp-rm-all"), tr ("&Remove All Breakpoints"),
+                                                  SLOT (request_remove_breakpoint (bool)));
 
-  m_toggle_breakpoint_action = add_action (m_debug_menu,
-          resource_manager::icon ("bp-toggle"), tr ("Toggle &Breakpoint"),
-          SLOT (request_toggle_breakpoint (bool)));
-  m_next_breakpoint_action = add_action (m_debug_menu,
-          resource_manager::icon ("bp-next"), tr ("&Next Breakpoint"),
-          SLOT (request_next_breakpoint (bool)));
-  m_previous_breakpoint_action = add_action (m_debug_menu,
-          resource_manager::icon ("bp-prev"), tr ("Pre&vious Breakpoint"),
-          SLOT (request_previous_breakpoint (bool)));
-  m_remove_all_breakpoints_action = add_action (m_debug_menu,
-          resource_manager::icon ("bp-rm-all"), tr ("&Remove All Breakpoints"),
-          SLOT (request_remove_breakpoint (bool)));
+    m_debug_menu->addSeparator ();
+
+    // The other debug actions will be added by the main window.
+
+    // run menu
+
+    QMenu *_run_menu = add_menu (m_menu_bar, tr ("&Run"));
 
-  m_debug_menu->addSeparator ();
+    m_run_action = add_action (_run_menu,  resource_manager::icon ("system-run"),
+                               tr ("Save File and Run"), SLOT (request_run_file (bool)));
+    m_run_selection_action = add_action (_run_menu, QIcon (),
+                                         tr ("Run &Selection"), SLOT (request_context_run (bool)));
+    m_run_selection_action->setEnabled (false);
+
+    // help menu
 
-  // The other debug actions will be added by the main window.
-
-  // run menu
-
-  QMenu *_run_menu = add_menu (m_menu_bar, tr ("&Run"));
+    QMenu *_help_menu = add_menu (m_menu_bar, tr ("&Help"));
 
-  m_run_action = add_action (_run_menu,  resource_manager::icon ("system-run"),
-          tr ("Save File and Run"), SLOT (request_run_file (bool)));
-  m_run_selection_action = add_action (_run_menu, QIcon (),
-          tr ("Run &Selection"), SLOT (request_context_run (bool)));
-  m_run_selection_action->setEnabled (false);
+    m_context_help_action = add_action (_help_menu, QIcon (),
+                                        tr ("&Help on Keyword"), SLOT (request_context_help (bool)));
+    m_context_doc_action = add_action (_help_menu, QIcon (),
+                                       tr ("&Documentation on Keyword"), SLOT (request_context_doc (bool)));
 
-  // help menu
-
-  QMenu *_help_menu = add_menu (m_menu_bar, tr ("&Help"));
+    // tab navigation (no menu, only actions)
 
-  m_context_help_action = add_action (_help_menu, QIcon (),
-          tr ("&Help on Keyword"), SLOT (request_context_help (bool)));
-  m_context_doc_action = add_action (_help_menu, QIcon (),
-          tr ("&Documentation on Keyword"), SLOT (request_context_doc (bool)));
-
-  // tab navigation (no menu, only actions)
+    m_switch_left_tab_action = add_action (nullptr, QIcon (), "",
+                                           SLOT (switch_left_tab (void)));
+    m_switch_right_tab_action = add_action (nullptr, QIcon (), "",
+                                            SLOT (switch_right_tab (void)));
+    m_move_tab_left_action = add_action (nullptr, QIcon (), "",
+                                         SLOT (move_tab_left (void)));
+    m_move_tab_right_action = add_action (nullptr, QIcon (), "",
+                                          SLOT (move_tab_right (void)));
 
-  m_switch_left_tab_action = add_action (nullptr, QIcon (), "",
-                                        SLOT (switch_left_tab (void)));
-  m_switch_right_tab_action = add_action (nullptr, QIcon (), "",
-                                         SLOT (switch_right_tab (void)));
-  m_move_tab_left_action = add_action (nullptr, QIcon (), "",
-                                      SLOT (move_tab_left (void)));
-  m_move_tab_right_action = add_action (nullptr, QIcon (), "",
-                                       SLOT (move_tab_right (void)));
+    // toolbar
 
-  // toolbar
+    // popdown menu with mru files
+    QToolButton *popdown_button = new QToolButton ();
+    popdown_button->setToolTip (tr ("Recent Files"));
+    popdown_button->setMenu (m_mru_file_menu);
+    popdown_button->setPopupMode (QToolButton::InstantPopup);
+    popdown_button->setToolButtonStyle (Qt::ToolButtonTextOnly);
 
-  // popdown menu with mru files
-  QToolButton *popdown_button = new QToolButton ();
-  popdown_button->setToolTip (tr ("Recent Files"));
-  popdown_button->setMenu (m_mru_file_menu);
-  popdown_button->setPopupMode (QToolButton::InstantPopup);
-  popdown_button->setToolButtonStyle (Qt::ToolButtonTextOnly);
+    // new and open actions are inserted later from main window
+    m_popdown_mru_action = m_tool_bar->addWidget (popdown_button);
+    m_tool_bar->addAction (m_save_action);
+    m_tool_bar->addAction (m_save_as_action);
+    m_tool_bar->addAction (m_print_action);
+    m_tool_bar->addSeparator ();
+    // m_undo_action: later via main window
+    m_tool_bar->addAction (m_redo_action);
+    // m_copy_action: later via the main window
+    m_tool_bar->addAction (m_cut_action);
+    // m_paste_action: later via the main window
+    m_tool_bar->addAction (m_find_action);
+    //m_tool_bar->addAction (m_find_next_action);
+    //m_tool_bar->addAction (m_find_previous_action);
+    m_tool_bar->addSeparator ();
+    m_tool_bar->addAction (m_run_action);
+    m_tool_bar->addSeparator ();
+    m_tool_bar->addAction (m_toggle_breakpoint_action);
+    m_tool_bar->addAction (m_previous_breakpoint_action);
+    m_tool_bar->addAction (m_next_breakpoint_action);
+    m_tool_bar->addAction (m_remove_all_breakpoints_action);
 
-  // new and open actions are inserted later from main window
-  m_popdown_mru_action = m_tool_bar->addWidget (popdown_button);
-  m_tool_bar->addAction (m_save_action);
-  m_tool_bar->addAction (m_save_as_action);
-  m_tool_bar->addAction (m_print_action);
-  m_tool_bar->addSeparator ();
-  // m_undo_action: later via main window
-  m_tool_bar->addAction (m_redo_action);
-  // m_copy_action: later via the main window
-  m_tool_bar->addAction (m_cut_action);
-  // m_paste_action: later via the main window
-  m_tool_bar->addAction (m_find_action);
-  //m_tool_bar->addAction (m_find_next_action);
-  //m_tool_bar->addAction (m_find_previous_action);
-  m_tool_bar->addSeparator ();
-  m_tool_bar->addAction (m_run_action);
-  m_tool_bar->addSeparator ();
-  m_tool_bar->addAction (m_toggle_breakpoint_action);
-  m_tool_bar->addAction (m_previous_breakpoint_action);
-  m_tool_bar->addAction (m_next_breakpoint_action);
-  m_tool_bar->addAction (m_remove_all_breakpoints_action);
+    // layout
+    QVBoxLayout *vbox_layout = new QVBoxLayout ();
+    vbox_layout->addWidget (m_menu_bar);
+    vbox_layout->addWidget (m_tool_bar);
+    vbox_layout->addWidget (m_tab_widget);
+    vbox_layout->setMargin (0);
+    editor_widget->setLayout (vbox_layout);
+    setWidget (editor_widget);
 
-  // layout
-  QVBoxLayout *vbox_layout = new QVBoxLayout ();
-  vbox_layout->addWidget (m_menu_bar);
-  vbox_layout->addWidget (m_tool_bar);
-  vbox_layout->addWidget (m_tab_widget);
-  vbox_layout->setMargin (0);
-  editor_widget->setLayout (vbox_layout);
-  setWidget (editor_widget);
+    // create the context menu of the tab bar
+    tab_bar *bar = m_tab_widget->get_tab_bar ();
+    QMenu *ctx_men = bar->get_context_menu ();
+    ctx_men->addAction (m_close_action);
+    ctx_men->addAction (m_close_all_action);
+    ctx_men->addAction (m_close_others_action);
+
+    // signals
+    connect (this, SIGNAL (execute_command_in_terminal_signal (const QString&)),
+             main_win (), SLOT (execute_command_in_terminal (const QString&)));
 
-  // create the context menu of the tab bar
-  tab_bar *bar = m_tab_widget->get_tab_bar ();
-  QMenu *ctx_men = bar->get_context_menu ();
-  ctx_men->addAction (m_close_action);
-  ctx_men->addAction (m_close_all_action);
-  ctx_men->addAction (m_close_others_action);
+    connect (this, SIGNAL (request_settings_dialog (const QString&)),
+             main_win (),
+             SLOT (process_settings_dialog_request (const QString&)));
+
+    connect (m_mru_file_menu, SIGNAL (triggered (QAction *)),
+             this, SLOT (request_mru_open_file (QAction *)));
 
-  // signals
-  connect (this, SIGNAL (execute_command_in_terminal_signal (const QString&)),
-           main_win (), SLOT (execute_command_in_terminal (const QString&)));
+    mru_menu_update ();
 
-  connect (this, SIGNAL (request_settings_dialog (const QString&)),
-           main_win (),
-           SLOT (process_settings_dialog_request (const QString&)));
+    connect (m_tab_widget, SIGNAL (tabCloseRequested (int)),
+             this, SLOT (handle_tab_close_request (int)));
+
+    connect (m_tab_widget, SIGNAL (currentChanged (int)),
+             this, SLOT (active_tab_changed (int)));
 
-  connect (m_mru_file_menu, SIGNAL (triggered (QAction *)),
-           this, SLOT (request_mru_open_file (QAction *)));
+    resize (500, 400);
+    setWindowIcon (QIcon (":/actions/icons/logo.png"));
+    set_title (tr ("Editor"));
 
-  mru_menu_update ();
-
-  connect (m_tab_widget, SIGNAL (tabCloseRequested (int)),
-           this, SLOT (handle_tab_close_request (int)));
+    check_actions ();
+  }
 
-  connect (m_tab_widget, SIGNAL (currentChanged (int)),
-           this, SLOT (active_tab_changed (int)));
+  void file_editor::add_file_editor_tab (file_editor_tab *f, const QString& fn)
+  {
+    m_tab_widget->addTab (f, fn);
 
-  resize (500, 400);
-  setWindowIcon (QIcon (":/actions/icons/logo.png"));
-  set_title (tr ("Editor"));
+    // signals from the qscintilla edit area
+    connect (f->qsci_edit_area (), SIGNAL (status_update (bool, bool)),
+             this, SLOT (edit_status_update (bool, bool)));
 
-  check_actions ();
-}
+    connect (f->qsci_edit_area (), SIGNAL (show_doc_signal (const QString&)),
+             main_win (), SLOT (handle_show_doc (const QString&)));
 
-void
-file_editor::add_file_editor_tab (file_editor_tab *f, const QString& fn)
-{
-  m_tab_widget->addTab (f, fn);
+    connect (f->qsci_edit_area (), SIGNAL (create_context_menu_signal (QMenu *)),
+             this, SLOT (create_context_menu (QMenu *)));
 
-  // signals from the qscintilla edit area
-  connect (f->qsci_edit_area (), SIGNAL (status_update (bool, bool)),
-           this, SLOT (edit_status_update (bool, bool)));
+    connect (f->qsci_edit_area (),
+             SIGNAL (execute_command_in_terminal_signal (const QString&)),
+             main_win (), SLOT (execute_command_in_terminal (const QString&)));
 
-  connect (f->qsci_edit_area (), SIGNAL (show_doc_signal (const QString&)),
-           main_win (), SLOT (handle_show_doc (const QString&)));
+    // Signals from the file editor_tab
+    connect (f, SIGNAL (file_name_changed (const QString&, const QString&)),
+             this, SLOT (handle_file_name_changed (const QString&,
+                                                   const QString&)));
 
-  connect (f->qsci_edit_area (), SIGNAL (create_context_menu_signal (QMenu *)),
-           this, SLOT (create_context_menu (QMenu *)));
+    connect (f, SIGNAL (editor_state_changed (bool, bool)),
+             this, SLOT (handle_editor_state_changed (bool, bool)));
 
-  connect (f->qsci_edit_area (),
-           SIGNAL (execute_command_in_terminal_signal (const QString&)),
-           main_win (), SLOT (execute_command_in_terminal (const QString&)));
+    connect (f, SIGNAL (tab_remove_request ()),
+             this, SLOT (handle_tab_remove_request ()));
 
-  // Signals from the file editor_tab
-  connect (f, SIGNAL (file_name_changed (const QString&, const QString&)),
-           this, SLOT (handle_file_name_changed (const QString&,
-                                                 const QString&)));
+    connect (f, SIGNAL (add_filename_to_list (const QString&,
+                                              const QString&, QWidget*)),
+             this, SLOT (handle_add_filename_to_list (const QString&,
+                                                      const QString&,
+                                                      QWidget*)));
 
-  connect (f, SIGNAL (editor_state_changed (bool, bool)),
-           this, SLOT (handle_editor_state_changed (bool, bool)));
+    connect (f, SIGNAL (editor_check_conflict_save (const QString&, bool)),
+             this, SLOT (check_conflict_save (const QString&, bool)));
 
-  connect (f, SIGNAL (tab_remove_request ()),
-           this, SLOT (handle_tab_remove_request ()));
+    connect (f, SIGNAL (mru_add_file (const QString&, const QString&)),
+             this, SLOT (handle_mru_add_file (const QString&, const QString&)));
 
-  connect (f, SIGNAL (add_filename_to_list (const QString&,
-                                            const QString&, QWidget*)),
-           this, SLOT (handle_add_filename_to_list (const QString&,
-                                                    const QString&,
-                                                    QWidget*)));
+    connect (f, SIGNAL (run_file_signal (const QFileInfo&)),
+             main_win (), SLOT (run_file_in_terminal (const QFileInfo&)));
 
-  connect (f, SIGNAL (editor_check_conflict_save (const QString&, bool)),
-           this, SLOT (check_conflict_save (const QString&, bool)));
+    connect (f, SIGNAL (request_open_file (const QString&)),
+             this, SLOT (request_open_file (const QString&)));
 
-  connect (f, SIGNAL (mru_add_file (const QString&, const QString&)),
-           this, SLOT (handle_mru_add_file (const QString&, const QString&)));
-
-  connect (f, SIGNAL (run_file_signal (const QFileInfo&)),
-           main_win (), SLOT (run_file_in_terminal (const QFileInfo&)));
-
-  connect (f, SIGNAL (request_open_file (const QString&)),
-           this, SLOT (request_open_file (const QString&)));
+    connect (f, SIGNAL (edit_mfile_request (const QString&, const QString&,
+                                            const QString&, int)),
+             main_win (), SLOT (handle_edit_mfile_request (const QString&,
+                                                           const QString&,
+                                                           const QString&, int)));
 
-  connect (f, SIGNAL (edit_mfile_request (const QString&, const QString&,
-                                          const QString&, int)),
-           main_win (), SLOT (handle_edit_mfile_request (const QString&,
-                                                  const QString&,
-                                                  const QString&, int)));
+    connect (f, SIGNAL (set_focus_editor_signal (QWidget*)),
+             this, SLOT (set_focus (QWidget*)));
 
-  connect (f, SIGNAL (set_focus_editor_signal (QWidget*)),
-           this, SLOT (set_focus (QWidget*)));
+    // Signals from the file_editor non-trivial operations
+    connect (this, SIGNAL (fetab_settings_changed (const QSettings *)),
+             f, SLOT (notice_settings (const QSettings *)));
+
+    connect (this, SIGNAL (fetab_change_request (const QWidget*)),
+             f, SLOT (change_editor_state (const QWidget*)));
 
-  // Signals from the file_editor non-trivial operations
-  connect (this, SIGNAL (fetab_settings_changed (const QSettings *)),
-           f, SLOT (notice_settings (const QSettings *)));
+    connect (this, SIGNAL (fetab_file_name_query (const QWidget*)),
+             f, SLOT (file_name_query (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_change_request (const QWidget*)),
-           f, SLOT (change_editor_state (const QWidget*)));
+    connect (this, SIGNAL (fetab_save_file (const QWidget*, const QString&,
+                                            bool)),
+             f, SLOT (save_file (const QWidget*, const QString&, bool)));
 
-  connect (this, SIGNAL (fetab_file_name_query (const QWidget*)),
-           f, SLOT (file_name_query (const QWidget*)));
+    connect (this, SIGNAL (fetab_check_modified_file (void)),
+             f, SLOT (check_modified_file (void)));
 
-  connect (this, SIGNAL (fetab_save_file (const QWidget*, const QString&,
-                                          bool)),
-           f, SLOT (save_file (const QWidget*, const QString&, bool)));
+    connect (f, SIGNAL (execute_command_in_terminal_signal (const QString&)),
+             main_win (), SLOT (execute_command_in_terminal (const QString&)));
 
-  connect (this, SIGNAL (fetab_check_modified_file (void)),
-           f, SLOT (check_modified_file (void)));
+    // Signals from the file_editor trivial operations
+    connect (this, SIGNAL (fetab_recover_from_exit (void)),
+             f, SLOT (recover_from_exit (void)));
 
-  connect (f, SIGNAL (execute_command_in_terminal_signal (const QString&)),
-           main_win (), SLOT (execute_command_in_terminal (const QString&)));
+    connect (this, SIGNAL (fetab_set_directory (const QString&)),
+             f, SLOT (set_current_directory (const QString&)));
 
-  // Signals from the file_editor trivial operations
-  connect (this, SIGNAL (fetab_recover_from_exit (void)),
-           f, SLOT (recover_from_exit (void)));
-
-  connect (this, SIGNAL (fetab_set_directory (const QString&)),
-           f, SLOT (set_current_directory (const QString&)));
+    connect (this, SIGNAL (fetab_zoom_in (const QWidget*)),
+             f, SLOT (zoom_in (const QWidget*)));
+    connect (this, SIGNAL (fetab_zoom_out (const QWidget*)),
+             f, SLOT (zoom_out (const QWidget*)));
+    connect (this, SIGNAL (fetab_zoom_normal (const QWidget*)),
+             f, SLOT (zoom_normal (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_zoom_in (const QWidget*)),
-           f, SLOT (zoom_in (const QWidget*)));
-  connect (this, SIGNAL (fetab_zoom_out (const QWidget*)),
-           f, SLOT (zoom_out (const QWidget*)));
-  connect (this, SIGNAL (fetab_zoom_normal (const QWidget*)),
-           f, SLOT (zoom_normal (const QWidget*)));
+    connect (this, SIGNAL (fetab_context_help (const QWidget*, bool)),
+             f, SLOT (context_help (const QWidget*, bool)));
 
-  connect (this, SIGNAL (fetab_context_help (const QWidget*, bool)),
-           f, SLOT (context_help (const QWidget*, bool)));
+    connect (this, SIGNAL (fetab_context_edit (const QWidget*)),
+             f, SLOT (context_edit (const QWidget*)));
+
+    connect (this, SIGNAL (fetab_save_file (const QWidget*)),
+             f, SLOT (save_file (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_context_edit (const QWidget*)),
-           f, SLOT (context_edit (const QWidget*)));
+    connect (this, SIGNAL (fetab_save_file_as (const QWidget*)),
+             f, SLOT (save_file_as (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_save_file (const QWidget*)),
-           f, SLOT (save_file (const QWidget*)));
+    connect (this, SIGNAL (fetab_print_file (const QWidget*)),
+             f, SLOT (print_file (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_save_file_as (const QWidget*)),
-           f, SLOT (save_file_as (const QWidget*)));
+    connect (this, SIGNAL (fetab_run_file (const QWidget*)),
+             f, SLOT (run_file (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_print_file (const QWidget*)),
-           f, SLOT (print_file (const QWidget*)));
+    connect (this, SIGNAL (fetab_context_run (const QWidget*)),
+             f, SLOT (context_run (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_run_file (const QWidget*)),
-           f, SLOT (run_file (const QWidget*)));
+    connect (this, SIGNAL (fetab_toggle_bookmark (const QWidget*)),
+             f, SLOT (toggle_bookmark (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_context_run (const QWidget*)),
-           f, SLOT (context_run (const QWidget*)));
+    connect (this, SIGNAL (fetab_next_bookmark (const QWidget*)),
+             f, SLOT (next_bookmark (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_toggle_bookmark (const QWidget*)),
-           f, SLOT (toggle_bookmark (const QWidget*)));
+    connect (this, SIGNAL (fetab_previous_bookmark (const QWidget*)),
+             f, SLOT (previous_bookmark (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_next_bookmark (const QWidget*)),
-           f, SLOT (next_bookmark (const QWidget*)));
+    connect (this, SIGNAL (fetab_remove_bookmark (const QWidget*)),
+             f, SLOT (remove_bookmark (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_previous_bookmark (const QWidget*)),
-           f, SLOT (previous_bookmark (const QWidget*)));
+    connect (this, SIGNAL (fetab_toggle_breakpoint (const QWidget*)),
+             f, SLOT (toggle_breakpoint (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_remove_bookmark (const QWidget*)),
-           f, SLOT (remove_bookmark (const QWidget*)));
+    connect (this, SIGNAL (fetab_next_breakpoint (const QWidget*)),
+             f, SLOT (next_breakpoint (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_toggle_breakpoint (const QWidget*)),
-           f, SLOT (toggle_breakpoint (const QWidget*)));
+    connect (this, SIGNAL (fetab_previous_breakpoint (const QWidget*)),
+             f, SLOT (previous_breakpoint (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_next_breakpoint (const QWidget*)),
-           f, SLOT (next_breakpoint (const QWidget*)));
+    connect (this, SIGNAL (fetab_remove_all_breakpoints (const QWidget*)),
+             f, SLOT (remove_all_breakpoints (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_previous_breakpoint (const QWidget*)),
-           f, SLOT (previous_breakpoint (const QWidget*)));
+    connect (this, SIGNAL (fetab_scintilla_command (const QWidget *,
+                                                    unsigned int)),
+             f, SLOT (scintilla_command (const QWidget *, unsigned int)));
 
-  connect (this, SIGNAL (fetab_remove_all_breakpoints (const QWidget*)),
-           f, SLOT (remove_all_breakpoints (const QWidget*)));
+    connect (this, SIGNAL (fetab_comment_selected_text (const QWidget*, bool)),
+             f, SLOT (comment_selected_text (const QWidget*, bool)));
 
-  connect (this, SIGNAL (fetab_scintilla_command (const QWidget *,
-                                                  unsigned int)),
-           f, SLOT (scintilla_command (const QWidget *, unsigned int)));
+    connect (this, SIGNAL (fetab_uncomment_selected_text (const QWidget*)),
+             f, SLOT (uncomment_selected_text (const QWidget*)));
+
+    connect (this, SIGNAL (fetab_indent_selected_text (const QWidget*)),
+             f, SLOT (indent_selected_text (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_comment_selected_text (const QWidget*, bool)),
-           f, SLOT (comment_selected_text (const QWidget*, bool)));
+    connect (this, SIGNAL (fetab_unindent_selected_text (const QWidget*)),
+             f, SLOT (unindent_selected_text (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_uncomment_selected_text (const QWidget*)),
-           f, SLOT (uncomment_selected_text (const QWidget*)));
-
-  connect (this, SIGNAL (fetab_indent_selected_text (const QWidget*)),
-           f, SLOT (indent_selected_text (const QWidget*)));
+    connect (this, SIGNAL (fetab_smart_indent_line_or_selected_text (const QWidget*)),
+             f, SLOT (smart_indent_line_or_selected_text (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_unindent_selected_text (const QWidget*)),
-           f, SLOT (unindent_selected_text (const QWidget*)));
+    connect (this,
+             SIGNAL (fetab_convert_eol (const QWidget*, QsciScintilla::EolMode)),
+             f, SLOT (convert_eol (const QWidget*, QsciScintilla::EolMode)));
 
-  connect (this, SIGNAL (fetab_smart_indent_line_or_selected_text (const QWidget*)),
-           f, SLOT (smart_indent_line_or_selected_text (const QWidget*)));
+    connect (this, SIGNAL (fetab_find (const QWidget*, QList<QAction *>)),
+             f, SLOT (find (const QWidget*, QList<QAction *>)));
 
-  connect (this,
-           SIGNAL (fetab_convert_eol (const QWidget*, QsciScintilla::EolMode)),
-           f, SLOT (convert_eol (const QWidget*, QsciScintilla::EolMode)));
+    connect (this, SIGNAL (fetab_find_next (const QWidget*)),
+             f, SLOT (find_next (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_find (const QWidget*, QList<QAction *>)),
-           f, SLOT (find (const QWidget*, QList<QAction *>)));
+    connect (this, SIGNAL (fetab_find_previous (const QWidget*)),
+             f, SLOT (find_previous (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_find_next (const QWidget*)),
-           f, SLOT (find_next (const QWidget*)));
+    connect (this, SIGNAL (fetab_goto_line (const QWidget*, int)),
+             f, SLOT (goto_line (const QWidget*, int)));
 
-  connect (this, SIGNAL (fetab_find_previous (const QWidget*)),
-           f, SLOT (find_previous (const QWidget*)));
+    connect (this, SIGNAL (fetab_move_match_brace (const QWidget*, bool)),
+             f, SLOT (move_match_brace (const QWidget*, bool)));
 
-  connect (this, SIGNAL (fetab_goto_line (const QWidget*, int)),
-           f, SLOT (goto_line (const QWidget*, int)));
+    connect (this, SIGNAL (fetab_completion (const QWidget*)),
+             f, SLOT (show_auto_completion (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_move_match_brace (const QWidget*, bool)),
-           f, SLOT (move_match_brace (const QWidget*, bool)));
+    connect (this, SIGNAL (fetab_set_focus (const QWidget*)),
+             f, SLOT (set_focus (const QWidget*)));
 
-  connect (this, SIGNAL (fetab_completion (const QWidget*)),
-           f, SLOT (show_auto_completion (const QWidget*)));
+    connect (this, SIGNAL (fetab_insert_debugger_pointer (const QWidget*, int)),
+             f, SLOT (insert_debugger_pointer (const QWidget*, int)));
 
-  connect (this, SIGNAL (fetab_set_focus (const QWidget*)),
-           f, SLOT (set_focus (const QWidget*)));
+    connect (this, SIGNAL (fetab_delete_debugger_pointer (const QWidget*, int)),
+             f, SLOT (delete_debugger_pointer (const QWidget*, int)));
 
-  connect (this, SIGNAL (fetab_insert_debugger_pointer (const QWidget*, int)),
-           f, SLOT (insert_debugger_pointer (const QWidget*, int)));
+    connect (this, SIGNAL (fetab_do_breakpoint_marker (bool, const QWidget*,
+                                                       int, const QString&)),
+             f, SLOT (do_breakpoint_marker (bool, const QWidget*, int,
+                                            const QString&)));
 
-  connect (this, SIGNAL (fetab_delete_debugger_pointer (const QWidget*, int)),
-           f, SLOT (delete_debugger_pointer (const QWidget*, int)));
+    m_tab_widget->setCurrentWidget (f);
 
-  connect (this, SIGNAL (fetab_do_breakpoint_marker (bool, const QWidget*,
-                                                     int, const QString&)),
-           f, SLOT (do_breakpoint_marker (bool, const QWidget*, int,
-                                          const QString&)));
+    check_actions ();
+  }
 
-  m_tab_widget->setCurrentWidget (f);
-
-  check_actions ();
-}
+  void file_editor::mru_menu_update (void)
+  {
+    int num_files = qMin (m_mru_files.size (), int (MaxMRUFiles));
 
-void
-file_editor::mru_menu_update (void)
-{
-  int num_files = qMin (m_mru_files.size (), int (MaxMRUFiles));
+    // configure and show active actions of mru-menu
+    for (int i = 0; i < num_files; ++i)
+      {
+        QString text = tr ("&%1 %2").
+          arg ((i+1) % int (MaxMRUFiles)).arg (m_mru_files.at (i));
+        m_mru_file_actions[i]->setText (text);
 
-  // configure and show active actions of mru-menu
-  for (int i = 0; i < num_files; ++i)
-    {
-      QString text = tr ("&%1 %2").
-                     arg ((i+1) % int (MaxMRUFiles)).arg (m_mru_files.at (i));
-      m_mru_file_actions[i]->setText (text);
+        QStringList action_data;
+        action_data << m_mru_files.at (i) << m_mru_files_encodings.at (i);
+        m_mru_file_actions[i]->setData (action_data);
+
+        m_mru_file_actions[i]->setVisible (true);
+      }
 
-      QStringList action_data;
-      action_data << m_mru_files.at (i) << m_mru_files_encodings.at (i);
-      m_mru_file_actions[i]->setData (action_data);
+    // hide unused mru-menu entries
+    for (int j = num_files; j < MaxMRUFiles; ++j)
+      m_mru_file_actions[j]->setVisible (false);
 
-      m_mru_file_actions[i]->setVisible (true);
-    }
-
-  // hide unused mru-menu entries
-  for (int j = num_files; j < MaxMRUFiles; ++j)
-    m_mru_file_actions[j]->setVisible (false);
+    // delete entries in string-list beyond MaxMRUFiles
+    while (m_mru_files.size () > MaxMRUFiles)
+      {
+        m_mru_files.removeLast ();
+        m_mru_files_encodings.removeLast ();
+      }
 
-  // delete entries in string-list beyond MaxMRUFiles
-  while (m_mru_files.size () > MaxMRUFiles)
-    {
-      m_mru_files.removeLast ();
-      m_mru_files_encodings.removeLast ();
-    }
+    // save actual mru-list in settings
+    QSettings *settings = resource_manager::get_settings ();
+
+    settings->setValue ("editor/mru_file_list", m_mru_files);
+    settings->setValue ("editor/mru_file_encodings", m_mru_files_encodings);
+    settings->sync ();
+  }
 
-  // save actual mru-list in settings
-  QSettings *settings = resource_manager::get_settings ();
+  bool file_editor::call_custom_editor (const QString& file_name, int line)
+  {
+    // Check if the user wants to use a custom file editor.
+    QSettings *settings = resource_manager::get_settings ();
 
-  settings->setValue ("editor/mru_file_list", m_mru_files);
-  settings->setValue ("editor/mru_file_encodings", m_mru_files_encodings);
-  settings->sync ();
-}
+    if (settings->value ("useCustomFileEditor",false).toBool ())
+      {
+        // use the external editor interface for handling the call
+        emit request_open_file_external (file_name, line);
 
-bool
-file_editor::call_custom_editor (const QString& file_name, int line)
-{
-  // Check if the user wants to use a custom file editor.
-  QSettings *settings = resource_manager::get_settings ();
+        if (line < 0 && ! file_name.isEmpty ())
+          handle_mru_add_file (QFileInfo (file_name).canonicalFilePath (),
+                               QString ());
+
+        return true;
+      }
 
-  if (settings->value ("useCustomFileEditor",false).toBool ())
-    {
-      // use the external editor interface for handling the call
-      emit request_open_file_external (file_name, line);
+    return false;
+  }
 
-      if (line < 0 && ! file_name.isEmpty ())
-        handle_mru_add_file (QFileInfo (file_name).canonicalFilePath (),
-                             QString ());
-
-      return true;
-    }
-
-  return false;
-}
+  void file_editor::toggle_preference (const QString& preference, bool def)
+  {
+    QSettings *settings = resource_manager::get_settings ();
+    bool old = settings->value (preference,def).toBool ();
+    settings->setValue (preference,! old);
+    notice_settings (settings);
+  }
 
-void
-file_editor::toggle_preference (const QString& preference, bool def)
-{
-  QSettings *settings = resource_manager::get_settings ();
-  bool old = settings->value (preference,def).toBool ();
-  settings->setValue (preference,! old);
-  notice_settings (settings);
-}
+  void file_editor::switch_tab (int direction, bool movetab)
+  {
+    int tabs = m_tab_widget->count ();
 
-void
-file_editor::switch_tab (int direction, bool movetab)
-{
-  int tabs = m_tab_widget->count ();
+    if (tabs < 2)
+      return;
 
-  if (tabs < 2)
-    return;
+    int old_pos = m_tab_widget->currentIndex ();
+    int new_pos = m_tab_widget->currentIndex () + direction;
+
+    if (new_pos < 0 || new_pos >= tabs)
+      new_pos = new_pos - direction*tabs;
 
-  int old_pos = m_tab_widget->currentIndex ();
-  int new_pos = m_tab_widget->currentIndex () + direction;
-
-  if (new_pos < 0 || new_pos >= tabs)
-    new_pos = new_pos - direction*tabs;
-
-  if (movetab)
-    {
+    if (movetab)
+      {
 #if defined (HAVE_QTABWIDGET_SETMOVABLE)
-      m_tab_widget->tabBar ()->moveTab (old_pos, new_pos);
-      m_tab_widget->setCurrentIndex (old_pos);
-      m_tab_widget->setCurrentIndex (new_pos);
-      focus ();
+        m_tab_widget->tabBar ()->moveTab (old_pos, new_pos);
+        m_tab_widget->setCurrentIndex (old_pos);
+        m_tab_widget->setCurrentIndex (new_pos);
+        focus ();
 #endif
-    }
-  else
-    m_tab_widget->setCurrentIndex (new_pos);
-}
+      }
+    else
+      m_tab_widget->setCurrentIndex (new_pos);
+  }
+
+  // Function for closing the files in a removed directory
+  void file_editor::handle_dir_remove (const QString& old_name,
+                                       const QString& new_name)
+  {
+    QDir old_dir (old_name);
 
-// Function for closing the files in a removed directory
-void
-file_editor::handle_dir_remove (const QString& old_name,
-                                const QString& new_name)
-{
-  QDir old_dir (old_name);
-
-  // Have all file editor tabs signal what their filenames are.
-  m_editor_tab_map.clear ();
-  emit fetab_file_name_query (nullptr);
+    // Have all file editor tabs signal what their filenames are.
+    m_editor_tab_map.clear ();
+    emit fetab_file_name_query (nullptr);
 
-  // Loop over all open files and pick those within old_dir
-  for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
-       p != m_editor_tab_map.end (); p++)
-    {
-      QString rel_path_to_file = old_dir.relativeFilePath (p->first);
-      if (rel_path_to_file.left (3) != QString ("../"))
-        {
-          // We directly go down from old_dir to reach our file: Our
-          // file is included in the removed/renamed diectory.
-          // Thus delete it.
-          m_no_focus = true;  // Remember for not focussing editor
-          file_editor_tab *editor_tab
+    // Loop over all open files and pick those within old_dir
+    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+         p != m_editor_tab_map.end (); p++)
+      {
+        QString rel_path_to_file = old_dir.relativeFilePath (p->first);
+        if (rel_path_to_file.left (3) != QString ("../"))
+          {
+            // We directly go down from old_dir to reach our file: Our
+            // file is included in the removed/renamed diectory.
+            // Thus delete it.
+            m_no_focus = true;  // Remember for not focussing editor
+            file_editor_tab *editor_tab
               = static_cast<file_editor_tab *> (p->second.fet_ID);
-          editor_tab->file_has_changed (QString (), true);  // Close
-          m_no_focus = false;  // Back to normal
+            editor_tab->file_has_changed (QString (), true);  // Close
+            m_no_focus = false;  // Back to normal
 
-          // Store file for possible later reload
-          m_tmp_closed_files << p->first;
+            // Store file for possible later reload
+            m_tmp_closed_files << p->first;
 
-          // Add the new file path and the encoding for later reloading
-          // if new_name is given
-          if (! new_name.isEmpty ())
-            {
-              QDir new_dir (new_name);
-              m_tmp_closed_files << new_dir.absoluteFilePath (rel_path_to_file);
-            }
-          else
-            m_tmp_closed_files << ""; // no new name, just removing this file
+            // Add the new file path and the encoding for later reloading
+            // if new_name is given
+            if (! new_name.isEmpty ())
+              {
+                QDir new_dir (new_name);
+                m_tmp_closed_files << new_dir.absoluteFilePath (rel_path_to_file);
+              }
+            else
+              m_tmp_closed_files << ""; // no new name, just removing this file
+
+            m_tmp_closed_files << p->second.encoding; // store the encoding
+          }
+      }
+  }
 
-          m_tmp_closed_files << p->second.encoding; // store the encoding
-        }
-    }
-}
+  bool file_editor::editor_tab_has_focus (void)
+  {
+    QWidget *foc_w = focusWidget ();
+    if (foc_w && foc_w->inherits ("octave_qscintilla"))
+      return true;
+    return false;
+  }
 
-bool
-file_editor::editor_tab_has_focus (void)
-{
-  QWidget *foc_w = focusWidget ();
-  if (foc_w && foc_w->inherits ("octave_qscintilla"))
-    return true;
-  return false;
-}
+  // Check whether this file is already open in the editor.
+  QWidget * file_editor::find_tab_widget (const QString& file)
+  {
+    // Have all file editor tabs signal what their filenames are.
+    m_editor_tab_map.clear ();
+    emit fetab_file_name_query (nullptr);
 
-// Check whether this file is already open in the editor.
-QWidget *
-file_editor::find_tab_widget (const QString& file)
-{
-  // Have all file editor tabs signal what their filenames are.
-  m_editor_tab_map.clear ();
-  emit fetab_file_name_query (nullptr);
-
-  // Check all tabs for the given file name
-  QWidget *retval = nullptr;
+    // Check all tabs for the given file name
+    QWidget *retval = nullptr;
 
-  for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
-       p != m_editor_tab_map.end (); p++)
-    {
-      QString tab_file = p->first;
-      if (same_file (file.toStdString (), tab_file.toStdString ())
-          || file == tab_file)     // needed as same_file ("","") is false.
-        {
-          retval = p->second.fet_ID;
-          break;
-        }
-    }
+    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+         p != m_editor_tab_map.end (); p++)
+      {
+        QString tab_file = p->first;
+        if (same_file (file.toStdString (), tab_file.toStdString ())
+            || file == tab_file)     // needed as same_file ("","") is false.
+          {
+            retval = p->second.fet_ID;
+            break;
+          }
+      }
+
+    return retval;
+  }
 
-  return retval;
-}
-
-QAction*
-file_editor::add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                         const char *member)
-{
-  QAction *a;
+  QAction* file_editor::add_action (QMenu *menu, const QIcon& icon,
+                                    const QString& text, const char *member)
+  {
+    QAction *a;
 
-  if (menu)
-    a = menu->addAction (icon, text, this, member);
-  else
-    {
-      a = new QAction (this);
-      connect (a, SIGNAL (triggered ()), this, member);
-    }
+    if (menu)
+      a = menu->addAction (icon, text, this, member);
+    else
+      {
+        a = new QAction (this);
+        connect (a, SIGNAL (triggered ()), this, member);
+      }
 
-  addAction (a);  // important for shortcut context
-  a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
+    addAction (a);  // important for shortcut context
+    a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
 
-  return a;
-}
+    return a;
+  }
 
-QMenu*
-file_editor::add_menu (QMenuBar *p, QString name)
-{
-  QMenu *menu = p->addMenu (name);
+  QMenu* file_editor::add_menu (QMenuBar *p, QString name)
+  {
+    QMenu *menu = p->addMenu (name);
 
-  QString base_name = name;  // get a copy
-  // replace intended '&' ("&&") by a temp. string
-  base_name.replace ("&&", "___octave_amp_replacement___");
-  // remove single '&' (shortcut)
-  base_name.remove ("&");
-  // restore intended '&'
-  base_name.replace ("___octave_amp_replacement___", "&&");
+    QString base_name = name;  // get a copy
+    // replace intended '&' ("&&") by a temp. string
+    base_name.replace ("&&", "___octave_amp_replacement___");
+    // remove single '&' (shortcut)
+    base_name.remove ("&");
+    // restore intended '&'
+    base_name.replace ("___octave_amp_replacement___", "&&");
 
-  // remember names with and without shortcut
-  m_hash_menu_text[menu] = QStringList () << name << base_name;
+    // remember names with and without shortcut
+    m_hash_menu_text[menu] = QStringList () << name << base_name;
 
-  return menu;
+    return menu;
+  }
 }
 
 #endif
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -35,429 +35,431 @@ along with Octave; see the file COPYING.
 #include <QDropEvent>
 
 #include <map>
 
 #include "file-editor-interface.h"
 #include "file-editor-tab.h"
 #include "tab-bar.h"
 
-
-// subclassed QTabWidget for using custom tabbar
-
-class file_editor_tab_widget : public QTabWidget
+namespace octave
 {
-  Q_OBJECT
-
-public:
-
-  file_editor_tab_widget (QWidget *p);
-
-  ~file_editor_tab_widget (void) = default;
-
-  tab_bar * get_tab_bar (void) const;
-};
+  // subclassed QTabWidget for using custom tabbar
 
-// the class for the file editor
-
-class file_editor : public file_editor_interface
-{
-  Q_OBJECT
-
-public:
-
-  struct tab_info
+  class file_editor_tab_widget : public QTabWidget
   {
-    QWidget *fet_ID;
-    QString encoding;
-  };
-
-  typedef std::map<QString, tab_info>::iterator editor_tab_map_iterator;
-  typedef std::map<QString, tab_info>::const_iterator editor_tab_map_const_iterator;
+    Q_OBJECT
 
-  // struct that allows to sort with respect to the tab index
-  struct session_data
-  {
-    QString index;
-    QString file_name;
-    QString encoding;
+  public:
 
-    bool operator < (const session_data& other) const
-    {
-      return index < other.index;
-    }
-  };
-
-  file_editor (QWidget *p);
-
-  ~file_editor (void);
+    file_editor_tab_widget (QWidget *p);
 
-  QMenu * get_mru_menu (void) { return m_mru_file_menu; }
-
-  QMenu * debug_menu (void) { return m_debug_menu; }
-
-  QToolBar * toolbar (void) { return m_tool_bar; }
-
-  void insert_global_actions (QList<QAction*>);
+    ~file_editor_tab_widget (void) = default;
 
-  enum shared_actions_idx
-  {
-    NEW_SCRIPT_ACTION = 0,
-    NEW_FUNCTION_ACTION,
-    OPEN_ACTION,
-    FIND_FILES_ACTION,
-    UNDO_ACTION,
-    COPY_ACTION,
-    PASTE_ACTION,
-    SELECTALL_ACTION
+    tab_bar * get_tab_bar (void) const;
   };
 
-  void handle_enter_debug_mode (void);
-  void handle_exit_debug_mode (void);
+  // the class for the file editor
+
+  class file_editor : public file_editor_interface
+  {
+    Q_OBJECT
+
+  public:
+
+    struct tab_info
+    {
+      QWidget *fet_ID;
+      QString encoding;
+    };
 
-  void check_actions (void);
-  void empty_script (bool startup, bool visible);
-  void restore_session (QSettings *settings);
+    typedef std::map<QString, tab_info>::iterator editor_tab_map_iterator;
+    typedef std::map<QString, tab_info>::const_iterator editor_tab_map_const_iterator;
 
-signals:
+    // struct that allows to sort with respect to the tab index
+    struct session_data
+    {
+      QString index;
+      QString file_name;
+      QString encoding;
+
+      bool operator < (const session_data& other) const
+      {
+        return index < other.index;
+      }
+    };
 
-  void fetab_settings_changed (const QSettings *settings);
-  void fetab_change_request (const QWidget *ID);
-  void fetab_file_name_query (const QWidget *ID);
-  // Save is a ping-pong type of communication
-  void fetab_save_file (const QWidget *ID, const QString& fileName,
-                        bool remove_on_success);
-  // No fetab_open, functionality in editor
-  // No fetab_new, functionality in editor
-  void fetab_context_help (const QWidget *ID, bool);
-  void fetab_context_edit (const QWidget *ID);
-  void fetab_check_modified_file (void);
-  void fetab_save_file (const QWidget *ID);
-  void fetab_save_file_as (const QWidget *ID);
-  void fetab_print_file (const QWidget *ID);
-  void fetab_run_file (const QWidget *ID);
-  void fetab_context_run (const QWidget *ID);
-  void fetab_toggle_bookmark (const QWidget *ID);
-  void fetab_next_bookmark (const QWidget *ID);
-  void fetab_previous_bookmark (const QWidget *ID);
-  void fetab_remove_bookmark (const QWidget *ID);
-  void fetab_toggle_breakpoint (const QWidget *ID);
-  void fetab_next_breakpoint (const QWidget *ID);
-  void fetab_previous_breakpoint (const QWidget *ID);
-  void fetab_remove_all_breakpoints (const QWidget *ID);
-  void fetab_comment_selected_text (const QWidget *ID, bool);
-  void fetab_uncomment_selected_text (const QWidget *ID);
-  void fetab_indent_selected_text (const QWidget *ID);
-  void fetab_unindent_selected_text (const QWidget *ID);
-  void fetab_smart_indent_line_or_selected_text (const QWidget *ID);
-  void fetab_convert_eol (const QWidget *ID, QsciScintilla::EolMode eol_mode);
-  void fetab_find (const QWidget *ID, QList<QAction *>);
-  void fetab_find_next (const QWidget *ID);
-  void fetab_find_previous (const QWidget *ID);
-  void fetab_goto_line (const QWidget *ID, int line = -1);
-  void fetab_move_match_brace (const QWidget *ID, bool select);
-  void fetab_completion (const QWidget*);
-  void fetab_insert_debugger_pointer (const QWidget *ID, int line = -1);
-  void fetab_delete_debugger_pointer (const QWidget *ID, int line = -1);
-  void fetab_do_breakpoint_marker (bool insert, const QWidget *ID,
-                                   int line = -1, const QString& = "");
-  void fetab_set_focus (const QWidget *ID);
-  void fetab_scintilla_command (const QWidget *ID, unsigned int sci_msg);
+    file_editor (QWidget *p);
+
+    ~file_editor (void);
+
+    QMenu * get_mru_menu (void) { return m_mru_file_menu; }
+
+    QMenu * debug_menu (void) { return m_debug_menu; }
+
+    QToolBar * toolbar (void) { return m_tool_bar; }
+
+    void insert_global_actions (QList<QAction*>);
 
-  void fetab_zoom_in (const QWidget *ID);
-  void fetab_zoom_out (const QWidget *ID);
-  void fetab_zoom_normal (const QWidget *ID);
-
-  void fetab_set_directory (const QString& dir);
-  void fetab_recover_from_exit (void);
-
-  void request_settings_dialog (const QString&);
-  void execute_command_in_terminal_signal (const QString&);
-  void request_open_file_external (const QString& file_name, int line);
-  void file_loaded_signal (void);
+    enum shared_actions_idx
+      {
+        NEW_SCRIPT_ACTION = 0,
+        NEW_FUNCTION_ACTION,
+        OPEN_ACTION,
+        FIND_FILES_ACTION,
+        UNDO_ACTION,
+        COPY_ACTION,
+        PASTE_ACTION,
+        SELECTALL_ACTION
+      };
 
-public slots:
-
-  void focus (void);
-  void set_focus (QWidget *fet);
-  void enable_menu_shortcuts (bool);
-  bool check_closing (void);
+    void handle_enter_debug_mode (void);
+    void handle_exit_debug_mode (void);
 
-  void request_new_file (const QString& commands);
-  void request_close_file (bool);
-  void request_close_all_files (bool);
-  void request_close_other_files (bool);
-  void request_mru_open_file (QAction *action);
-  void request_print_file (bool);
+    void check_actions (void);
+    void empty_script (bool startup, bool visible);
+    void restore_session (QSettings *settings);
+
+  signals:
 
-  void request_redo (bool);
-  void request_cut (bool);
-  void request_context_help (bool);
-  void request_context_doc (bool);
-  void request_context_edit (bool);
-  void request_save_file (bool);
-  void request_save_file_as (bool);
-  void request_run_file (bool);
-  void request_context_run (bool);
-  void request_toggle_bookmark (bool);
-  void request_next_bookmark (bool);
-  void request_previous_bookmark (bool);
-  void request_remove_bookmark (bool);
-
-  void request_move_match_brace (bool);
-  void request_sel_match_brace (bool);
-  void request_toggle_breakpoint (bool);
-  void request_next_breakpoint (bool);
-  void request_previous_breakpoint (bool);
-  void request_remove_breakpoint (bool);
+    void fetab_settings_changed (const QSettings *settings);
+    void fetab_change_request (const QWidget *ID);
+    void fetab_file_name_query (const QWidget *ID);
+    // Save is a ping-pong type of communication
+    void fetab_save_file (const QWidget *ID, const QString& fileName,
+                          bool remove_on_success);
+    // No fetab_open, functionality in editor
+    // No fetab_new, functionality in editor
+    void fetab_context_help (const QWidget *ID, bool);
+    void fetab_context_edit (const QWidget *ID);
+    void fetab_check_modified_file (void);
+    void fetab_save_file (const QWidget *ID);
+    void fetab_save_file_as (const QWidget *ID);
+    void fetab_print_file (const QWidget *ID);
+    void fetab_run_file (const QWidget *ID);
+    void fetab_context_run (const QWidget *ID);
+    void fetab_toggle_bookmark (const QWidget *ID);
+    void fetab_next_bookmark (const QWidget *ID);
+    void fetab_previous_bookmark (const QWidget *ID);
+    void fetab_remove_bookmark (const QWidget *ID);
+    void fetab_toggle_breakpoint (const QWidget *ID);
+    void fetab_next_breakpoint (const QWidget *ID);
+    void fetab_previous_breakpoint (const QWidget *ID);
+    void fetab_remove_all_breakpoints (const QWidget *ID);
+    void fetab_comment_selected_text (const QWidget *ID, bool);
+    void fetab_uncomment_selected_text (const QWidget *ID);
+    void fetab_indent_selected_text (const QWidget *ID);
+    void fetab_unindent_selected_text (const QWidget *ID);
+    void fetab_smart_indent_line_or_selected_text (const QWidget *ID);
+    void fetab_convert_eol (const QWidget *ID, QsciScintilla::EolMode eol_mode);
+    void fetab_find (const QWidget *ID, QList<QAction *>);
+    void fetab_find_next (const QWidget *ID);
+    void fetab_find_previous (const QWidget *ID);
+    void fetab_goto_line (const QWidget *ID, int line = -1);
+    void fetab_move_match_brace (const QWidget *ID, bool select);
+    void fetab_completion (const QWidget*);
+    void fetab_insert_debugger_pointer (const QWidget *ID, int line = -1);
+    void fetab_delete_debugger_pointer (const QWidget *ID, int line = -1);
+    void fetab_do_breakpoint_marker (bool insert, const QWidget *ID,
+                                     int line = -1, const QString& = "");
+    void fetab_set_focus (const QWidget *ID);
+    void fetab_scintilla_command (const QWidget *ID, unsigned int sci_msg);
 
-  void request_delete_start_word (bool);
-  void request_delete_end_word (bool);
-  void request_delete_start_line (bool);
-  void request_delete_end_line (bool);
-  void request_delete_line (bool);
-  void request_copy_line (bool);
-  void request_cut_line (bool);
-  void request_duplicate_selection (bool);
-  void request_transpose_line (bool);
+    void fetab_zoom_in (const QWidget *ID);
+    void fetab_zoom_out (const QWidget *ID);
+    void fetab_zoom_normal (const QWidget *ID);
+
+    void fetab_set_directory (const QString& dir);
+    void fetab_recover_from_exit (void);
+
+    void request_settings_dialog (const QString&);
+    void execute_command_in_terminal_signal (const QString&);
+    void request_open_file_external (const QString& file_name, int line);
+    void file_loaded_signal (void);
 
-  void request_comment_selected_text (bool);
-  void request_uncomment_selected_text (bool);
-  void request_comment_var_selected_text (bool);
+  public slots:
+
+    void focus (void);
+    void set_focus (QWidget *fet);
+    void enable_menu_shortcuts (bool);
+    bool check_closing (void);
 
-  void request_upper_case (bool);
-  void request_lower_case (bool);
-  void request_indent_selected_text (bool);
-  void request_unindent_selected_text (bool);
-  void request_smart_indent_line_or_selected_text (void);
-  void request_conv_eol_windows (bool);
-  void request_conv_eol_unix (bool);
-  void request_conv_eol_mac (bool);
+    void request_new_file (const QString& commands);
+    void request_close_file (bool);
+    void request_close_all_files (bool);
+    void request_close_other_files (bool);
+    void request_mru_open_file (QAction *action);
+    void request_print_file (bool);
 
-  void request_find (bool);
-  void request_find_next (bool);
-  void request_find_previous (bool);
-
-  void request_goto_line (bool);
-  void request_completion (bool);
+    void request_redo (bool);
+    void request_cut (bool);
+    void request_context_help (bool);
+    void request_context_doc (bool);
+    void request_context_edit (bool);
+    void request_save_file (bool);
+    void request_save_file_as (bool);
+    void request_run_file (bool);
+    void request_context_run (bool);
+    void request_toggle_bookmark (bool);
+    void request_next_bookmark (bool);
+    void request_previous_bookmark (bool);
+    void request_remove_bookmark (bool);
 
-  void handle_file_name_changed (const QString& fileName,
-                                 const QString& toolTip);
-  void handle_tab_close_request (int index);
-  void handle_tab_remove_request (void);
-  void handle_add_filename_to_list (const QString& fileName,
-                                    const QString& encoding, QWidget *ID);
-  void active_tab_changed (int index);
-  void handle_editor_state_changed (bool enableCopy, bool is_octave_file);
-  void handle_mru_add_file (const QString& file_name, const QString& encoding);
-  void check_conflict_save (const QString& fileName, bool remove_on_success);
+    void request_move_match_brace (bool);
+    void request_sel_match_brace (bool);
+    void request_toggle_breakpoint (bool);
+    void request_next_breakpoint (bool);
+    void request_previous_breakpoint (bool);
+    void request_remove_breakpoint (bool);
+
+    void request_delete_start_word (bool);
+    void request_delete_end_word (bool);
+    void request_delete_start_line (bool);
+    void request_delete_end_line (bool);
+    void request_delete_line (bool);
+    void request_copy_line (bool);
+    void request_cut_line (bool);
+    void request_duplicate_selection (bool);
+    void request_transpose_line (bool);
+
+    void request_comment_selected_text (bool);
+    void request_uncomment_selected_text (bool);
+    void request_comment_var_selected_text (bool);
 
-  void handle_insert_debugger_pointer_request (const QString& file, int line);
-  void handle_delete_debugger_pointer_request (const QString& file, int line);
-  void handle_update_breakpoint_marker_request (bool insert,
-                                                const QString& file, int line,
-                                                const QString& cond);
+    void request_upper_case (bool);
+    void request_lower_case (bool);
+    void request_indent_selected_text (bool);
+    void request_unindent_selected_text (bool);
+    void request_smart_indent_line_or_selected_text (void);
+    void request_conv_eol_windows (bool);
+    void request_conv_eol_unix (bool);
+    void request_conv_eol_mac (bool);
 
-  void handle_edit_file_request (const QString& file);
+    void request_find (bool);
+    void request_find_next (bool);
+    void request_find_previous (bool);
 
-  void handle_file_remove (const QString&, const QString&);
-  void handle_file_renamed (bool load_new = true);
-
-  // Tells the editor to react on changed settings.
-  void notice_settings (const QSettings *settings);
+    void request_goto_line (bool);
+    void request_completion (bool);
 
-  void set_shortcuts (void);
-
-  void handle_visibility (bool visible);
-
-  void update_octave_directory (const QString& dir);
+    void handle_file_name_changed (const QString& fileName,
+                                   const QString& toolTip);
+    void handle_tab_close_request (int index);
+    void handle_tab_remove_request (void);
+    void handle_add_filename_to_list (const QString& fileName,
+                                      const QString& encoding, QWidget *ID);
+    void active_tab_changed (int index);
+    void handle_editor_state_changed (bool enableCopy, bool is_octave_file);
+    void handle_mru_add_file (const QString& file_name, const QString& encoding);
+    void check_conflict_save (const QString& fileName, bool remove_on_success);
 
-protected slots:
+    void handle_insert_debugger_pointer_request (const QString& file, int line);
+    void handle_delete_debugger_pointer_request (const QString& file, int line);
+    void handle_update_breakpoint_marker_request (bool insert,
+                                                  const QString& file, int line,
+                                                  const QString& cond);
 
-  void copyClipboard (void);
-  void pasteClipboard (void);
-  void selectAll (void);
-  void do_undo (void);
-
-private slots:
+    void handle_edit_file_request (const QString& file);
 
-  void request_open_file (const QString& fileName,
-                          const QString& encoding = QString (),
-                          int line = -1, bool debug_pointer = false,
-                          bool breakpoint_marker = false, bool insert = true,
-                          const QString& cond = "");
-  void request_preferences (bool);
-  void request_styles_preferences (bool);
+    void handle_file_remove (const QString&, const QString&);
+    void handle_file_renamed (bool load_new = true);
+
+    // Tells the editor to react on changed settings.
+    void notice_settings (const QSettings *settings);
+
+    void set_shortcuts (void);
 
-  void show_line_numbers (bool);
-  void show_white_space (bool);
-  void show_eol_chars (bool);
-  void show_indent_guides (bool);
-  void show_long_line (bool);
-  void show_toolbar (bool);
-  void show_statusbar (bool);
-  void show_hscrollbar (bool);
-  void zoom_in (bool);
-  void zoom_out (bool);
-  void zoom_normal (bool);
+    void handle_visibility (bool visible);
+
+    void update_octave_directory (const QString& dir);
+
+  protected slots:
+
+    void copyClipboard (void);
+    void pasteClipboard (void);
+    void selectAll (void);
+    void do_undo (void);
 
-  void switch_left_tab (void);
-  void switch_right_tab (void);
-  void move_tab_left (void);
-  void move_tab_right (void);
+  private slots:
 
-  void create_context_menu (QMenu *);
-  void edit_status_update (bool, bool);
-
-protected:
+    void request_open_file (const QString& fileName,
+                            const QString& encoding = QString (),
+                            int line = -1, bool debug_pointer = false,
+                            bool breakpoint_marker = false, bool insert = true,
+                            const QString& cond = "");
+    void request_preferences (bool);
+    void request_styles_preferences (bool);
 
-  void closeEvent (QCloseEvent *event);
-  void dragEnterEvent (QDragEnterEvent *event);
-  void dropEvent (QDropEvent *event);
-
-private:
-
-  bool is_editor_console_tabbed (void);
-  void construct (void);
-  void add_file_editor_tab (file_editor_tab *f, const QString& fn);
-  void mru_menu_update (void);
-  bool call_custom_editor (const QString& file_name = QString (), int line = -1);
-
-  void toggle_preference (const QString& preference, bool def);
+    void show_line_numbers (bool);
+    void show_white_space (bool);
+    void show_eol_chars (bool);
+    void show_indent_guides (bool);
+    void show_long_line (bool);
+    void show_toolbar (bool);
+    void show_statusbar (bool);
+    void show_hscrollbar (bool);
+    void zoom_in (bool);
+    void zoom_out (bool);
+    void zoom_normal (bool);
 
-  void switch_tab (int direction, bool movetab = false);
-
-  void handle_dir_remove (const QString& old_name, const QString& new_name);
+    void switch_left_tab (void);
+    void switch_right_tab (void);
+    void move_tab_left (void);
+    void move_tab_right (void);
 
-  bool editor_tab_has_focus (void);
+    void create_context_menu (QMenu *);
+    void edit_status_update (bool, bool);
 
-  QWidget * find_tab_widget (const QString& openFileName);
-  QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                        const char *member);
+  protected:
 
-  QMenu * add_menu (QMenuBar *p, QString text);
+    void closeEvent (QCloseEvent *event);
+    void dragEnterEvent (QDragEnterEvent *event);
+    void dropEvent (QDropEvent *event);
 
-  std::map<QString, tab_info> m_editor_tab_map;
-  QHash<QMenu*, QStringList> m_hash_menu_text;
+  private:
 
-  QString m_ced;
+    bool is_editor_console_tabbed (void);
+    void construct (void);
+    void add_file_editor_tab (file_editor_tab *f, const QString& fn);
+    void mru_menu_update (void);
+    bool call_custom_editor (const QString& file_name = QString (), int line = -1);
 
-  QMenuBar *m_menu_bar;
-  QToolBar *m_tool_bar;
-  QMenu *m_debug_menu;
+    void toggle_preference (const QString& preference, bool def);
 
-  QAction *m_new_action;
-  QAction *m_new_function_action;
-  QAction *m_open_action;
+    void switch_tab (int direction, bool movetab = false);
+
+    void handle_dir_remove (const QString& old_name, const QString& new_name);
+
+    bool editor_tab_has_focus (void);
+
+    QWidget * find_tab_widget (const QString& openFileName);
+    QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                          const char *member);
+
+    QMenu * add_menu (QMenuBar *p, QString text);
 
-  QAction *m_upper_case_action;
-  QAction *m_lower_case_action;
-  QAction *m_comment_selection_action;
-  QAction *m_comment_var_selection_action;
-  QAction *m_uncomment_selection_action;
-  QAction *m_indent_selection_action;
-  QAction *m_unindent_selection_action;
-  QAction *m_smart_indent_line_or_selection_action;
-  QAction *m_conv_eol_windows_action;
-  QAction *m_conv_eol_unix_action;
-  QAction *m_conv_eol_mac_action;
+    std::map<QString, tab_info> m_editor_tab_map;
+    QHash<QMenu*, QStringList> m_hash_menu_text;
+
+    QString m_ced;
 
-  QAction *m_copy_action;
-  QAction *m_cut_action;
-  QAction *m_paste_action;
-  QAction *m_selectall_action;
-  QAction *m_context_help_action;
-  QAction *m_context_doc_action;
+    QMenuBar *m_menu_bar;
+    QToolBar *m_tool_bar;
+    QMenu *m_debug_menu;
+
+    QAction *m_new_action;
+    QAction *m_new_function_action;
+    QAction *m_open_action;
 
-  QAction *m_show_linenum_action;
-  QAction *m_show_whitespace_action;
-  QAction *m_show_eol_action;
-  QAction *m_show_indguide_action;
-  QAction *m_show_longline_action;
-  QAction *m_show_toolbar_action;
-  QAction *m_show_statusbar_action;
-  QAction *m_show_hscrollbar_action;
-  QAction *m_zoom_in_action;
-  QAction *m_zoom_out_action;
-  QAction *m_zoom_normal_action;
+    QAction *m_upper_case_action;
+    QAction *m_lower_case_action;
+    QAction *m_comment_selection_action;
+    QAction *m_comment_var_selection_action;
+    QAction *m_uncomment_selection_action;
+    QAction *m_indent_selection_action;
+    QAction *m_unindent_selection_action;
+    QAction *m_smart_indent_line_or_selection_action;
+    QAction *m_conv_eol_windows_action;
+    QAction *m_conv_eol_unix_action;
+    QAction *m_conv_eol_mac_action;
+
+    QAction *m_copy_action;
+    QAction *m_cut_action;
+    QAction *m_paste_action;
+    QAction *m_selectall_action;
+    QAction *m_context_help_action;
+    QAction *m_context_doc_action;
 
-  QAction *m_delete_start_word_action;
-  QAction *m_delete_end_word_action;
-  QAction *m_delete_start_line_action;
-  QAction *m_delete_end_line_action;
-  QAction *m_delete_line_action;
-  QAction *m_copy_line_action;
-  QAction *m_cut_line_action;
-  QAction *m_duplicate_selection_action;
-  QAction *m_transpose_line_action;
+    QAction *m_show_linenum_action;
+    QAction *m_show_whitespace_action;
+    QAction *m_show_eol_action;
+    QAction *m_show_indguide_action;
+    QAction *m_show_longline_action;
+    QAction *m_show_toolbar_action;
+    QAction *m_show_statusbar_action;
+    QAction *m_show_hscrollbar_action;
+    QAction *m_zoom_in_action;
+    QAction *m_zoom_out_action;
+    QAction *m_zoom_normal_action;
 
-  QAction *m_find_action;
-  QAction *m_find_next_action;
-  QAction *m_find_previous_action;
-  QAction *m_find_files_action;
-  QAction *m_goto_line_action;
-  QAction *m_completion_action;
+    QAction *m_delete_start_word_action;
+    QAction *m_delete_end_word_action;
+    QAction *m_delete_start_line_action;
+    QAction *m_delete_end_line_action;
+    QAction *m_delete_line_action;
+    QAction *m_copy_line_action;
+    QAction *m_cut_line_action;
+    QAction *m_duplicate_selection_action;
+    QAction *m_transpose_line_action;
 
-  QAction *m_move_to_matching_brace;
-  QAction *m_sel_to_matching_brace;
-  QAction *m_next_bookmark_action;
-  QAction *m_previous_bookmark_action;
-  QAction *m_toggle_bookmark_action;
-  QAction *m_remove_bookmark_action;
+    QAction *m_find_action;
+    QAction *m_find_next_action;
+    QAction *m_find_previous_action;
+    QAction *m_find_files_action;
+    QAction *m_goto_line_action;
+    QAction *m_completion_action;
 
-  QAction *m_print_action;
-  QAction *m_run_action;
-  QAction *m_run_selection_action;
+    QAction *m_move_to_matching_brace;
+    QAction *m_sel_to_matching_brace;
+    QAction *m_next_bookmark_action;
+    QAction *m_previous_bookmark_action;
+    QAction *m_toggle_bookmark_action;
+    QAction *m_remove_bookmark_action;
 
-  QAction *m_edit_function_action;
-  QAction *m_popdown_mru_action;
-  QAction *m_save_action;
-  QAction *m_save_as_action;
-  QAction *m_close_action;
-  QAction *m_close_all_action;
-  QAction *m_close_others_action;
+    QAction *m_print_action;
+    QAction *m_run_action;
+    QAction *m_run_selection_action;
 
-  QAction *m_redo_action;
-  QAction *m_undo_action;
+    QAction *m_edit_function_action;
+    QAction *m_popdown_mru_action;
+    QAction *m_save_action;
+    QAction *m_save_as_action;
+    QAction *m_close_action;
+    QAction *m_close_all_action;
+    QAction *m_close_others_action;
 
-  QAction *m_preferences_action;
-  QAction *m_styles_preferences_action;
+    QAction *m_redo_action;
+    QAction *m_undo_action;
+
+    QAction *m_preferences_action;
+    QAction *m_styles_preferences_action;
 
-  QAction *m_switch_left_tab_action;
-  QAction *m_switch_right_tab_action;
-  QAction *m_move_tab_left_action;
-  QAction *m_move_tab_right_action;
+    QAction *m_switch_left_tab_action;
+    QAction *m_switch_right_tab_action;
+    QAction *m_move_tab_left_action;
+    QAction *m_move_tab_right_action;
 
-  QAction *m_toggle_breakpoint_action;
-  QAction *m_next_breakpoint_action;
-  QAction *m_previous_breakpoint_action;
-  QAction *m_remove_all_breakpoints_action;
+    QAction *m_toggle_breakpoint_action;
+    QAction *m_next_breakpoint_action;
+    QAction *m_previous_breakpoint_action;
+    QAction *m_remove_all_breakpoints_action;
 
-  QMenu *m_edit_menu;
-  QMenu *m_edit_cmd_menu;
-  QMenu *m_edit_fmt_menu;
-  QMenu *m_edit_nav_menu;
-  QMenu *m_fileMenu;
-  QMenu *m_view_editor_menu;
+    QMenu *m_edit_menu;
+    QMenu *m_edit_cmd_menu;
+    QMenu *m_edit_fmt_menu;
+    QMenu *m_edit_nav_menu;
+    QMenu *m_fileMenu;
+    QMenu *m_view_editor_menu;
 
-  QList<QAction*> m_fetab_actions;
+    QList<QAction*> m_fetab_actions;
 
-  file_editor_tab_widget *m_tab_widget;
+    file_editor_tab_widget *m_tab_widget;
 
-  int m_marker_breakpoint;
+    int m_marker_breakpoint;
 
-  bool m_closed;
-  bool m_no_focus;
+    bool m_closed;
+    bool m_no_focus;
 
-  enum { MaxMRUFiles = 10 };
-  QMenu *m_mru_file_menu;
-  QAction *m_mru_file_actions[MaxMRUFiles];
-  QStringList m_mru_files;
-  QStringList m_mru_files_encodings;
+    enum { MaxMRUFiles = 10 };
+    QMenu *m_mru_file_menu;
+    QAction *m_mru_file_actions[MaxMRUFiles];
+    QStringList m_mru_files;
+    QStringList m_mru_files_encodings;
 
-  // List of temporarily closed files for later reloading.
-  // Order: first closed old file
-  //        first new location of closed file
-  //        encoding to use for reload
-  QStringList m_tmp_closed_files;
-};
+    // List of temporarily closed files for later reloading.
+    // Order: first closed old file
+    //        first new location of closed file
+    //        encoding to use for reload
+    QStringList m_tmp_closed_files;
+  };
+}
 
 #endif
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -73,379 +73,368 @@ along with Octave; see the file COPYING.
 #include <QLabel>
 #include <QLineEdit>
 #include <QMessageBox>
 #include <QPushButton>
 #include <QVBoxLayout>
 
 #include "find-dialog.h"
 
-find_dialog::find_dialog (QsciScintilla *edit_area,
-                          QList<QAction *> find_actions, QWidget *p)
-  : QDialog (p)
+namespace octave
 {
-  setWindowTitle (tr ("Find and Replace"));
-  setWindowIcon (QIcon (":/actions/icons/find.png"));
-
-  _search_label = new QLabel (tr ("Find &what:"));
-  _search_line_edit = new QLineEdit;
-  _search_label->setBuddy (_search_line_edit);
-  _replace_label = new QLabel (tr ("Re&place with:"));
-  _replace_line_edit = new QLineEdit;
-  _replace_label->setBuddy (_replace_line_edit);
+  find_dialog::find_dialog (QsciScintilla *edit_area,
+                            QList<QAction *> find_actions, QWidget *p)
+    : QDialog (p)
+  {
+    setWindowTitle (tr ("Find and Replace"));
+    setWindowIcon (QIcon (":/actions/icons/find.png"));
 
-  _case_check_box = new QCheckBox (tr ("Match &case"));
-  _from_start_check_box = new QCheckBox (tr ("Search from &start"));
-  _wrap_check_box = new QCheckBox (tr ("&Wrap while searching"));
-  _wrap_check_box->setChecked (true);
-  _find_next_button = new QPushButton (tr ("&Find Next"));
-  _find_prev_button = new QPushButton (tr ("Find &Previous"));
-  _replace_button = new QPushButton (tr ("&Replace"));
-  _replace_all_button = new QPushButton (tr ("Replace &All"));
-
-  _more_button = new QPushButton (tr ("&More..."));
-  _more_button->setCheckable (true);
-  _more_button->setAutoDefault (false);
-
-  _button_box = new QDialogButtonBox (Qt::Vertical);
-  _button_box->addButton (_find_next_button, QDialogButtonBox::ActionRole);
-  _button_box->addButton (_find_prev_button, QDialogButtonBox::ActionRole);
-  _button_box->addButton (_replace_button, QDialogButtonBox::ActionRole);
-  _button_box->addButton (_replace_all_button, QDialogButtonBox::ActionRole);
-  _button_box->addButton (_more_button, QDialogButtonBox::ActionRole);
-  _button_box->addButton (QDialogButtonBox::Close);
+    _search_label = new QLabel (tr ("Find &what:"));
+    _search_line_edit = new QLineEdit;
+    _search_label->setBuddy (_search_line_edit);
+    _replace_label = new QLabel (tr ("Re&place with:"));
+    _replace_line_edit = new QLineEdit;
+    _replace_label->setBuddy (_replace_line_edit);
 
-  _extension = new QWidget (this);
-  _whole_words_check_box = new QCheckBox (tr ("&Whole words"));
-  _regex_check_box = new QCheckBox (tr ("Regular E&xpressions"));
-  _backward_check_box = new QCheckBox (tr ("Search &backward"));
-  _search_selection_check_box = new QCheckBox (tr ("Search se&lection"));
-#if defined (HAVE_QSCI_FINDSELECTION)
-  _search_selection_check_box->setCheckable (true);
-  _search_selection_check_box->setEnabled (edit_area->hasSelectedText ());
-#else
-  _search_selection_check_box->setCheckable (false);
-  _search_selection_check_box->setEnabled (false);
-#endif
+    _case_check_box = new QCheckBox (tr ("Match &case"));
+    _from_start_check_box = new QCheckBox (tr ("Search from &start"));
+    _wrap_check_box = new QCheckBox (tr ("&Wrap while searching"));
+    _wrap_check_box->setChecked (true);
+    _find_next_button = new QPushButton (tr ("&Find Next"));
+    _find_prev_button = new QPushButton (tr ("Find &Previous"));
+    _replace_button = new QPushButton (tr ("&Replace"));
+    _replace_all_button = new QPushButton (tr ("Replace &All"));
+
+    _more_button = new QPushButton (tr ("&More..."));
+    _more_button->setCheckable (true);
+    _more_button->setAutoDefault (false);
 
-  _edit_area = edit_area;
-  connect (_find_next_button,   SIGNAL (clicked ()),
-           this,                SLOT (find_next ()));
-  connect (_find_prev_button,   SIGNAL (clicked ()),
-           this,                SLOT (find_prev ()));
-  connect (_more_button,        SIGNAL (toggled (bool)),
-           _extension,          SLOT (setVisible (bool)));
-  connect (_replace_button,     SIGNAL (clicked ()),
-           this,                SLOT (replace ()));
-  connect (_replace_all_button, SIGNAL (clicked ()),
-           this,                SLOT (replace_all ()));
-  connect (_backward_check_box, SIGNAL (stateChanged (int)),
-           this,                SLOT (handle_backward_search_changed (int)));
-  connect (_button_box,         SIGNAL (rejected ()),
-           this,                SLOT (close ()));
-  connect (_search_line_edit,   SIGNAL (textChanged (QString)),
-           this,                SLOT (handle_search_text_changed (QString)));
+    _button_box = new QDialogButtonBox (Qt::Vertical);
+    _button_box->addButton (_find_next_button, QDialogButtonBox::ActionRole);
+    _button_box->addButton (_find_prev_button, QDialogButtonBox::ActionRole);
+    _button_box->addButton (_replace_button, QDialogButtonBox::ActionRole);
+    _button_box->addButton (_replace_all_button, QDialogButtonBox::ActionRole);
+    _button_box->addButton (_more_button, QDialogButtonBox::ActionRole);
+    _button_box->addButton (QDialogButtonBox::Close);
 
+    _extension = new QWidget (this);
+    _whole_words_check_box = new QCheckBox (tr ("&Whole words"));
+    _regex_check_box = new QCheckBox (tr ("Regular E&xpressions"));
+    _backward_check_box = new QCheckBox (tr ("Search &backward"));
+    _search_selection_check_box = new QCheckBox (tr ("Search se&lection"));
 #if defined (HAVE_QSCI_FINDSELECTION)
-  connect (_edit_area, SIGNAL (copyAvailable (bool)),
-           this,       SLOT (handle_selection_changed (bool)));
-  connect (_search_selection_check_box, SIGNAL (stateChanged (int)),
-           this,                        SLOT (handle_sel_search_changed (int)));
+    _search_selection_check_box->setCheckable (true);
+    _search_selection_check_box->setEnabled (edit_area->hasSelectedText ());
+#else
+    _search_selection_check_box->setCheckable (false);
+    _search_selection_check_box->setEnabled (false);
 #endif
 
-  QVBoxLayout *extension_layout = new QVBoxLayout ();
-  extension_layout->setMargin (0);
-  extension_layout->addWidget (_whole_words_check_box);
-  extension_layout->addWidget (_backward_check_box);
-  extension_layout->addWidget (_search_selection_check_box);
-  _extension->setLayout (extension_layout);
-
-  QGridLayout *top_left_layout = new QGridLayout;
-  top_left_layout->addWidget (_search_label, 1, 1);
-  top_left_layout->addWidget (_search_line_edit, 1, 2);
-  top_left_layout->addWidget (_replace_label, 2, 1);
-  top_left_layout->addWidget (_replace_line_edit, 2, 2);
-
-  QVBoxLayout *left_layout = new QVBoxLayout;
-  left_layout->addLayout (top_left_layout);
-  left_layout->insertStretch (1, 5);
-  left_layout->addWidget (_case_check_box);
-  left_layout->addWidget (_from_start_check_box);
-  left_layout->addWidget (_wrap_check_box);
-  left_layout->addWidget (_regex_check_box);
-
-  QGridLayout *main_layout = new QGridLayout;
-  main_layout->setSizeConstraint (QLayout::SetFixedSize);
-  main_layout->addLayout (left_layout, 0, 0);
-  main_layout->addWidget (_button_box, 0, 1);
-  main_layout->addWidget (_extension, 1, 0);
-  setLayout (main_layout);
-
-  _extension->hide ();
-  _find_next_button->setDefault (true);
-  _find_result_available = false;
-  _rep_all = 0;
-  _rep_active = false;
-
-  // set the actions
-  addActions (find_actions);
-
-  // move dialog to side of the parent if there is room on the desktop to do so.
-  int xp = p->x () +20;
-  int yp = p->y () + p->frameGeometry ().height () - sizeHint ().height () -20;
-
-  if (yp < 0)
-    yp = 0;
-
-  move (xp, yp);
-
-}
-
-// set text of "search from start" depending on backward search
-void
-find_dialog::handle_backward_search_changed (int backward)
-{
-  if (backward)
-    _from_start_check_box->setText (tr ("Search from end"));
-  else
-    _from_start_check_box->setText (tr ("Search from start"));
-}
-
-// search text has changed: reset the search
-void
-find_dialog::handle_search_text_changed (QString)
-{
-  if (_search_selection_check_box->isChecked ())
-    _find_result_available = false;
-}
+    _edit_area = edit_area;
+    connect (_find_next_button,   SIGNAL (clicked ()),
+             this,                SLOT (find_next ()));
+    connect (_find_prev_button,   SIGNAL (clicked ()),
+             this,                SLOT (find_prev ()));
+    connect (_more_button,        SIGNAL (toggled (bool)),
+             _extension,          SLOT (setVisible (bool)));
+    connect (_replace_button,     SIGNAL (clicked ()),
+             this,                SLOT (replace ()));
+    connect (_replace_all_button, SIGNAL (clicked ()),
+             this,                SLOT (replace_all ()));
+    connect (_backward_check_box, SIGNAL (stateChanged (int)),
+             this,                SLOT (handle_backward_search_changed (int)));
+    connect (_button_box,         SIGNAL (rejected ()),
+             this,                SLOT (close ()));
+    connect (_search_line_edit,   SIGNAL (textChanged (QString)),
+             this,                SLOT (handle_search_text_changed (QString)));
 
 #if defined (HAVE_QSCI_FINDSELECTION)
-void
-find_dialog::handle_sel_search_changed (int selected)
-{
-  _from_start_check_box->setEnabled (! selected);
-  _find_result_available = false;
-}
+    connect (_edit_area, SIGNAL (copyAvailable (bool)),
+             this,       SLOT (handle_selection_changed (bool)));
+    connect (_search_selection_check_box, SIGNAL (stateChanged (int)),
+             this,                        SLOT (handle_sel_search_changed (int)));
+#endif
+
+    QVBoxLayout *extension_layout = new QVBoxLayout ();
+    extension_layout->setMargin (0);
+    extension_layout->addWidget (_whole_words_check_box);
+    extension_layout->addWidget (_backward_check_box);
+    extension_layout->addWidget (_search_selection_check_box);
+    _extension->setLayout (extension_layout);
+
+    QGridLayout *top_left_layout = new QGridLayout;
+    top_left_layout->addWidget (_search_label, 1, 1);
+    top_left_layout->addWidget (_search_line_edit, 1, 2);
+    top_left_layout->addWidget (_replace_label, 2, 1);
+    top_left_layout->addWidget (_replace_line_edit, 2, 2);
+
+    QVBoxLayout *left_layout = new QVBoxLayout;
+    left_layout->addLayout (top_left_layout);
+    left_layout->insertStretch (1, 5);
+    left_layout->addWidget (_case_check_box);
+    left_layout->addWidget (_from_start_check_box);
+    left_layout->addWidget (_wrap_check_box);
+    left_layout->addWidget (_regex_check_box);
+
+    QGridLayout *main_layout = new QGridLayout;
+    main_layout->setSizeConstraint (QLayout::SetFixedSize);
+    main_layout->addLayout (left_layout, 0, 0);
+    main_layout->addWidget (_button_box, 0, 1);
+    main_layout->addWidget (_extension, 1, 0);
+    setLayout (main_layout);
+
+    _extension->hide ();
+    _find_next_button->setDefault (true);
+    _find_result_available = false;
+    _rep_all = 0;
+    _rep_active = false;
+
+    // set the actions
+    addActions (find_actions);
+
+    // move dialog to side of the parent if there is room on the desktop to do so.
+    int xp = p->x () +20;
+    int yp = p->y () + p->frameGeometry ().height () - sizeHint ().height () -20;
+
+    if (yp < 0)
+      yp = 0;
+
+    move (xp, yp);
+
+  }
+
+  // set text of "search from start" depending on backward search
+  void find_dialog::handle_backward_search_changed (int backward)
+  {
+    if (backward)
+      _from_start_check_box->setText (tr ("Search from end"));
+    else
+      _from_start_check_box->setText (tr ("Search from start"));
+  }
+
+  // search text has changed: reset the search
+  void find_dialog::handle_search_text_changed (QString)
+  {
+    if (_search_selection_check_box->isChecked ())
+      _find_result_available = false;
+  }
+
+#if defined (HAVE_QSCI_FINDSELECTION)
+  void find_dialog::handle_sel_search_changed (int selected)
+  {
+    _from_start_check_box->setEnabled (! selected);
+    _find_result_available = false;
+  }
 #else
-void
-find_dialog::handle_sel_search_changed (int /* selected */) { }
+  void find_dialog::handle_sel_search_changed (int /* selected */) { }
 #endif
 
 #if defined (HAVE_QSCI_FINDSELECTION)
-void
-find_dialog::handle_selection_changed (bool has_selected)
-{
-  if (_rep_active)
-    return;
+  void find_dialog::handle_selection_changed (bool has_selected)
+  {
+    if (_rep_active)
+      return;
 
-  _search_selection_check_box->setEnabled (has_selected);
-  _find_result_available = false;
-  if (! has_selected)
-    _search_selection_check_box->setChecked (false);
-}
+    _search_selection_check_box->setEnabled (has_selected);
+    _find_result_available = false;
+    if (! has_selected)
+      _search_selection_check_box->setChecked (false);
+  }
 #else
-void
-find_dialog::handle_selection_changed (bool /* has_selected */) { }
+  void find_dialog::handle_selection_changed (bool /* has_selected */) { }
 #endif
 
-// initialize search text with selected text if this is in one single line
-void
-find_dialog::init_search_text ()
-{
-  if (_edit_area->hasSelectedText ())
-    {
-      int lbeg, lend, cbeg, cend;
-      _edit_area->getSelection (&lbeg,&cbeg,&lend,&cend);
-      if (lbeg == lend)
-        _search_line_edit->setText (_edit_area->selectedText ());
-    }
+  // initialize search text with selected text if this is in one single line
+  void find_dialog::init_search_text (void)
+  {
+    if (_edit_area->hasSelectedText ())
+      {
+        int lbeg, lend, cbeg, cend;
+        _edit_area->getSelection (&lbeg,&cbeg,&lend,&cend);
+        if (lbeg == lend)
+          _search_line_edit->setText (_edit_area->selectedText ());
+      }
 
-  // set focus to "Find what" and select all text
-  _search_line_edit->setFocus ();
-  _search_line_edit->selectAll ();
+    // set focus to "Find what" and select all text
+    _search_line_edit->setFocus ();
+    _search_line_edit->selectAll ();
 
-  // Default to "find" next time.
-  // Otherwise, it defaults to the last action, which may be "replace all".
-  _find_next_button->setDefault (true);
-}
+    // Default to "find" next time.
+    // Otherwise, it defaults to the last action, which may be "replace all".
+    _find_next_button->setDefault (true);
+  }
 
-void
-find_dialog::find_next ()
-{
-  find (! _backward_check_box->isChecked ());
-}
+  void find_dialog::find_next (void)
+  {
+    find (! _backward_check_box->isChecked ());
+  }
 
-void
-find_dialog::find_prev ()
-{
-  find (_backward_check_box->isChecked ());
-}
+  void find_dialog::find_prev (void)
+  {
+    find (_backward_check_box->isChecked ());
+  }
 
-void
-find_dialog::find (bool forward)
-{
-  int line, col;
-  line = col = -1;
-  bool do_wrap = _wrap_check_box->isChecked ();
-  bool do_forward = forward;
+  void find_dialog::find (bool forward)
+  {
+    int line, col;
+    line = col = -1;
+    bool do_wrap = _wrap_check_box->isChecked ();
+    bool do_forward = forward;
 
-  if (_rep_all)
-    {
-      if (_rep_all == 1)
-        {
-          line = 0;
-          col = 0;
-        }
-      do_wrap = false;
-      // The following line is a workaround for the issue that when replacing
-      // a text with a new one with different size within the selection,
-      // the selection is not updated leading to missing or extra replacements.
-      // This does not happen, when the selection is search backwards
-      do_forward = ! _search_selection_check_box->isChecked ();
-    }
-  else
-    {
-      if (_from_start_check_box->isChecked ())
-        {
-          if (do_forward)
-            {
-              line = 0;
-              col = 0;
-            }
-          else
-            {
-              line = _edit_area->lines () - 1;
-              col  = _edit_area->text (line).length () - 1;
-              if (col == -1)
+    if (_rep_all)
+      {
+        if (_rep_all == 1)
+          {
+            line = 0;
+            col = 0;
+          }
+        do_wrap = false;
+        // The following line is a workaround for the issue that when replacing
+        // a text with a new one with different size within the selection,
+        // the selection is not updated leading to missing or extra replacements.
+        // This does not happen, when the selection is search backwards
+        do_forward = ! _search_selection_check_box->isChecked ();
+      }
+    else
+      {
+        if (_from_start_check_box->isChecked ())
+          {
+            if (do_forward)
+              {
+                line = 0;
                 col = 0;
-            }
-        }
-      else if (! do_forward)
-        {
-          // search from position before search characters text length
-          // if search backward on existing results,
-          _edit_area->getCursorPosition (&line,&col);
-          if (_find_result_available && _edit_area->hasSelectedText ())
-            {
-              int currpos = _edit_area->positionFromLineIndex (line,col);
-              currpos -= (_search_line_edit->text ().length ());
-              if (currpos < 0)
-                currpos = 0;
-              _edit_area->lineIndexFromPosition (currpos, &line,&col);
-            }
-        }
-    }
+              }
+            else
+              {
+                line = _edit_area->lines () - 1;
+                col  = _edit_area->text (line).length () - 1;
+                if (col == -1)
+                  col = 0;
+              }
+          }
+        else if (! do_forward)
+          {
+            // search from position before search characters text length
+            // if search backward on existing results,
+            _edit_area->getCursorPosition (&line,&col);
+            if (_find_result_available && _edit_area->hasSelectedText ())
+              {
+                int currpos = _edit_area->positionFromLineIndex (line,col);
+                currpos -= (_search_line_edit->text ().length ());
+                if (currpos < 0)
+                  currpos = 0;
+                _edit_area->lineIndexFromPosition (currpos, &line,&col);
+              }
+          }
+      }
 
-  if (_edit_area)
-    {
-      if (_edit_area->hasSelectedText ()
-          && _search_selection_check_box->isChecked ())
-        {
+    if (_edit_area)
+      {
+        if (_edit_area->hasSelectedText ()
+            && _search_selection_check_box->isChecked ())
+          {
 #if defined (HAVE_QSCI_FINDSELECTION)
-          if (_find_result_available)
-            _find_result_available = _edit_area->findNext ();
-          else
+            if (_find_result_available)
+              _find_result_available = _edit_area->findNext ();
+            else
+              _find_result_available
+                = _edit_area->findFirstInSelection (
+                                                    _search_line_edit->text (),
+                                                    _regex_check_box->isChecked (),
+                                                    _case_check_box->isChecked (),
+                                                    _whole_words_check_box->isChecked (),
+                                                    do_forward,
+                                                    true
+#if defined (HAVE_QSCI_VERSION_2_6_0)
+                                                    , true
+#endif
+                                                    );
+#endif
+          }
+        else
+          {
             _find_result_available
-              = _edit_area->findFirstInSelection (
-                                      _search_line_edit->text (),
-                                      _regex_check_box->isChecked (),
-                                      _case_check_box->isChecked (),
-                                      _whole_words_check_box->isChecked (),
-                                      do_forward,
-                                      true
+              = _edit_area->findFirst (_search_line_edit->text (),
+                                       _regex_check_box->isChecked (),
+                                       _case_check_box->isChecked (),
+                                       _whole_words_check_box->isChecked (),
+                                       do_wrap,
+                                       do_forward,
+                                       line,col,
+                                       true
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-                                      , true
-#endif
-                                      );
+                                       , true
 #endif
-        }
-      else
-        {
-          _find_result_available
-            = _edit_area->findFirst (_search_line_edit->text (),
-                                     _regex_check_box->isChecked (),
-                                     _case_check_box->isChecked (),
-                                     _whole_words_check_box->isChecked (),
-                                     do_wrap,
-                                     do_forward,
-                                     line,col,
-                                     true
-#if defined (HAVE_QSCI_VERSION_2_6_0)
-                                     , true
-#endif
-                                    );
-        }
-    }
+                                       );
+          }
+      }
+
+    if (_find_result_available)
+      _from_start_check_box->setChecked (0);
+    else if (! _rep_all)
+      no_matches_message ();
+  }
 
-  if (_find_result_available)
-    _from_start_check_box->setChecked (0);
-  else if (! _rep_all)
-    no_matches_message ();
-}
+  void find_dialog::do_replace (void)
+  {
+    _rep_active = true;  // changes in selection not made by the user
+    _edit_area->replace (_replace_line_edit->text ());
+    _rep_active = false;
+  }
 
-void
-find_dialog::do_replace ()
-{
-  _rep_active = true;  // changes in selection not made by the user
-  _edit_area->replace (_replace_line_edit->text ());
-  _rep_active = false;
-}
+  void find_dialog::replace (void)
+  {
+    if (_edit_area)
+      {
+        // The following line is a workaround for the issue that when replacing
+        // a text with a new one with different size within the selection,
+        // the selection is not updated leading to missing or extra replacements.
+        // This does not happen, when the selection is search backwards
+        if (_search_selection_check_box->isChecked ())
+          _backward_check_box->setChecked (true);
 
-void
-find_dialog::replace ()
-{
-  if (_edit_area)
-    {
-      // The following line is a workaround for the issue that when replacing
-      // a text with a new one with different size within the selection,
-      // the selection is not updated leading to missing or extra replacements.
-      // This does not happen, when the selection is search backwards
-      if (_search_selection_check_box->isChecked ())
-        _backward_check_box->setChecked (true);
+        // do the replace if we have selected text
+        if (_find_result_available && _edit_area->hasSelectedText ())
+          do_replace ();
+
+        find_next ();
+      }
+  }
 
-      // do the replace if we have selected text
-      if (_find_result_available && _edit_area->hasSelectedText ())
-        do_replace ();
-
-      find_next ();
-    }
-}
+  void find_dialog::replace_all (void)
+  {
+    int line, col;
 
-void
-find_dialog::replace_all ()
-{
-  int line, col;
-
-  if (_edit_area)
-    {
-      _edit_area->getCursorPosition (&line,&col);
+    if (_edit_area)
+      {
+        _edit_area->getCursorPosition (&line,&col);
 
-      _rep_all = 1;
-      find_next ();  // find first occurence (forward)
-      while (_find_result_available)   // while search string is found
-        {
-          do_replace ();
-          _rep_all++;                                          // inc counter
-          find_next ();                                        // find next
-        }
+        _rep_all = 1;
+        find_next ();  // find first occurence (forward)
+        while (_find_result_available)   // while search string is found
+          {
+            do_replace ();
+            _rep_all++;                                          // inc counter
+            find_next ();                                        // find next
+          }
 
-      QMessageBox msg_box (QMessageBox::Information, tr ("Replace Result"),
-                           tr ("%1 items replaced").arg (_rep_all-1),
-                           QMessageBox::Ok, this);
-      msg_box.exec ();
+        QMessageBox msg_box (QMessageBox::Information, tr ("Replace Result"),
+                             tr ("%1 items replaced").arg (_rep_all-1),
+                             QMessageBox::Ok, this);
+        msg_box.exec ();
 
-      _rep_all = 0;
-      _find_result_available = false;
+        _rep_all = 0;
+        _find_result_available = false;
 
-      if (! _search_selection_check_box->isChecked ())
-        _edit_area->setCursorPosition (line,col);
-    }
-}
+        if (! _search_selection_check_box->isChecked ())
+          _edit_area->setCursorPosition (line,col);
+      }
+  }
 
-void
-find_dialog::no_matches_message ()
-{
-  QMessageBox msg_box (QMessageBox::Information, tr ("Find Result"),
-                       tr ("No more matches found"), QMessageBox::Ok, this);
-  msg_box.exec ();
+  void find_dialog::no_matches_message (void)
+  {
+    QMessageBox msg_box (QMessageBox::Information, tr ("Find Result"),
+                         tr ("No more matches found"), QMessageBox::Ok, this);
+    msg_box.exec ();
+  }
 }
 
 #endif
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -67,59 +67,62 @@ along with Octave; see the file COPYING.
 
 class QCheckBox;
 class QDialogButtonBox;
 class QGroupBox;
 class QLabel;
 class QLineEdit;
 class QPushButton;
 
-class find_dialog : public QDialog
+namespace octave
 {
-  Q_OBJECT
-public:
-  find_dialog (QsciScintilla *edit_area, QList<QAction *> find_actions,
-               QWidget *parent = nullptr);
-  void init_search_text ();
+  class find_dialog : public QDialog
+  {
+    Q_OBJECT
+  public:
+    find_dialog (QsciScintilla *edit_area, QList<QAction *> find_actions,
+                 QWidget *parent = nullptr);
+    void init_search_text (void);
 
-private slots:
-  void handle_sel_search_changed (int);
-  void handle_selection_changed (bool has_selected);
+  private slots:
+    void handle_sel_search_changed (int);
+    void handle_selection_changed (bool has_selected);
 
-  void handle_backward_search_changed (int);
-  void handle_search_text_changed (QString new_search_text);
+    void handle_backward_search_changed (int);
+    void handle_search_text_changed (QString new_search_text);
 
-  void find (bool forward = true);
-  void find_next ();
-  void find_prev ();
-  void replace ();
-  void replace_all ();
+    void find (bool forward = true);
+    void find_next (void);
+    void find_prev (void);
+    void replace (void);
+    void replace_all (void);
 
-private:
+  private:
 
-  void no_matches_message ();
-  void do_replace ();
+    void no_matches_message (void);
+    void do_replace (void);
 
-  QLabel            *_search_label;
-  QLineEdit         *_search_line_edit;
-  QLabel            *_replace_label;
-  QLineEdit         *_replace_line_edit;
-  QCheckBox         *_case_check_box;
-  QCheckBox         *_from_start_check_box;
-  QCheckBox         *_wrap_check_box;
-  QCheckBox         *_whole_words_check_box;
-  QCheckBox         *_regex_check_box;
-  QCheckBox         *_search_selection_check_box;
-  QCheckBox         *_backward_check_box;
-  QDialogButtonBox  *_button_box;
-  QPushButton       *_find_next_button;
-  QPushButton       *_find_prev_button;
-  QPushButton       *_replace_button;
-  QPushButton       *_replace_all_button;
-  QPushButton       *_more_button;
-  QWidget           *_extension;
-  QsciScintilla     *_edit_area;
-  bool               _find_result_available;
-  int                _rep_all;
-  bool               _rep_active;
-};
+    QLabel            *_search_label;
+    QLineEdit         *_search_line_edit;
+    QLabel            *_replace_label;
+    QLineEdit         *_replace_line_edit;
+    QCheckBox         *_case_check_box;
+    QCheckBox         *_from_start_check_box;
+    QCheckBox         *_wrap_check_box;
+    QCheckBox         *_whole_words_check_box;
+    QCheckBox         *_regex_check_box;
+    QCheckBox         *_search_selection_check_box;
+    QCheckBox         *_backward_check_box;
+    QDialogButtonBox  *_button_box;
+    QPushButton       *_find_next_button;
+    QPushButton       *_find_prev_button;
+    QPushButton       *_replace_button;
+    QPushButton       *_replace_all_button;
+    QPushButton       *_more_button;
+    QWidget           *_extension;
+    QsciScintilla     *_edit_area;
+    bool               _find_result_available;
+    int                _rep_all;
+    bool               _rep_active;
+  };
+}
 
 #endif
diff --git a/libgui/src/m-editor/marker.cc b/libgui/src/m-editor/marker.cc
--- a/libgui/src/m-editor/marker.cc
+++ b/libgui/src/m-editor/marker.cc
@@ -23,149 +23,143 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #if defined (HAVE_QSCINTILLA)
 
 #include "marker.h"
 
-marker::marker (QsciScintilla *area, int original_linenr, editor_markers type,
-                int editor_linenr, const QString& condition)
-  : QObject ()
-{
-  construct (area, original_linenr, type, editor_linenr, condition);
-}
-
-marker::marker (QsciScintilla *area, int original_linenr,
-                editor_markers type, const QString& condition)
-  : QObject ()
-{
-  construct (area, original_linenr, type, original_linenr - 1, condition);
-}
-
-void
-marker::construct (QsciScintilla *area, int original_linenr,
-                   editor_markers type, int editor_linenr,
-                   const QString& condition)
-{
-  m_edit_area = area;
-  m_original_linenr = original_linenr;
-  m_marker_type = type;
-  m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
-  m_condition = condition;
-}
-
-void
-marker::handle_remove_via_original_linenr (int linenr)
+namespace octave
 {
-  if (m_original_linenr == linenr)
-    {
-      m_edit_area->markerDeleteHandle (m_mhandle);
-      delete this;
-    }
-}
+  marker::marker (QsciScintilla *area, int original_linenr,
+                  editor_markers type, int editor_linenr,
+                  const QString& condition)
+    : QObject ()
+  {
+    construct (area, original_linenr, type, editor_linenr, condition);
+  }
+
+  marker::marker (QsciScintilla *area, int original_linenr,
+                  editor_markers type, const QString& condition)
+    : QObject ()
+  {
+    construct (area, original_linenr, type, original_linenr - 1, condition);
+  }
+
+  void marker::construct (QsciScintilla *area, int original_linenr,
+                          editor_markers type, int editor_linenr,
+                          const QString& condition)
+  {
+    m_edit_area = area;
+    m_original_linenr = original_linenr;
+    m_marker_type = type;
+    m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
+    m_condition = condition;
+  }
 
-void
-marker::handle_request_remove_via_editor_linenr (int linenr)
-{
-  // Get line number from the edit area and if it matches
-  // the requested line number, remove.
-  if (m_edit_area->markerLine (m_mhandle) == linenr)
-    {
-      // Rather than delete editor marker directly, issue command
-      // to Octave core.  Octave core should signal back to remove
-      // this breakpoint via debugger line number.
-      emit request_remove (m_original_linenr);
-    }
-}
+  void marker::handle_remove_via_original_linenr (int linenr)
+  {
+    if (m_original_linenr == linenr)
+      {
+        m_edit_area->markerDeleteHandle (m_mhandle);
+        delete this;
+      }
+  }
 
-void
-marker::handle_remove (void)
-{
-  m_edit_area->markerDeleteHandle (m_mhandle);
-  delete this;
-}
+  void marker::handle_request_remove_via_editor_linenr (int linenr)
+  {
+    // Get line number from the edit area and if it matches
+    // the requested line number, remove.
+    if (m_edit_area->markerLine (m_mhandle) == linenr)
+      {
+        // Rather than delete editor marker directly, issue command
+        // to Octave core.  Octave core should signal back to remove
+        // this breakpoint via debugger line number.
+        emit request_remove (m_original_linenr);
+      }
+  }
 
-void
-marker::handle_find_translation (int linenr, int& translation_linenr,
-                                 marker *& bp)
-{
-  if (m_original_linenr == linenr)
-    {
-      translation_linenr = m_edit_area->markerLine (m_mhandle);
-      bp = this;
-    }
-}
+  void marker::handle_remove (void)
+  {
+    m_edit_area->markerDeleteHandle (m_mhandle);
+    delete this;
+  }
+
+  void marker::handle_find_translation (int linenr, int& translation_linenr,
+                                        marker *& bp)
+  {
+    if (m_original_linenr == linenr)
+      {
+        translation_linenr = m_edit_area->markerLine (m_mhandle);
+        bp = this;
+      }
+  }
 
-void
-marker::handle_find_just_before (int linenr, int& original_linenr,
-                                 int& editor_linenr)
-{
-  if (m_original_linenr < linenr && m_original_linenr >= original_linenr)
-    {
-      original_linenr = m_original_linenr;
-      editor_linenr = m_edit_area->markerLine (m_mhandle);
-    }
-}
+  void marker::handle_find_just_before (int linenr, int& original_linenr,
+                                        int& editor_linenr)
+  {
+    if (m_original_linenr < linenr && m_original_linenr >= original_linenr)
+      {
+        original_linenr = m_original_linenr;
+        editor_linenr = m_edit_area->markerLine (m_mhandle);
+      }
+  }
 
-void
-marker::handle_find_just_after (int linenr, int& original_linenr,
-                                int& editor_linenr)
-{
-  if (m_original_linenr > linenr && m_original_linenr <= original_linenr)
-    {
-      original_linenr = m_original_linenr;
-      editor_linenr = m_edit_area->markerLine (m_mhandle);
-    }
-}
+  void marker::handle_find_just_after (int linenr, int& original_linenr,
+                                       int& editor_linenr)
+  {
+    if (m_original_linenr > linenr && m_original_linenr <= original_linenr)
+      {
+        original_linenr = m_original_linenr;
+        editor_linenr = m_edit_area->markerLine (m_mhandle);
+      }
+  }
 
-void
-marker::handle_report_editor_linenr (QIntList& lines, QStringList& conditions)
-{
-  lines << m_edit_area->markerLine (m_mhandle);
-  conditions << m_condition;
-}
+  void marker::handle_report_editor_linenr (QIntList& lines,
+                                            QStringList& conditions)
+  {
+    lines << m_edit_area->markerLine (m_mhandle);
+    conditions << m_condition;
+  }
 
-void
-marker::handle_marker_line_deleted (int mhandle)
-{
-  // FUTURE SUPPORT: There really should be a signal in QsciScintilla
-  // called markerLineDeleted (int mhandle) because there is no way
-  // of knowing this.  QsciScintilla will place the marker at a
-  // different line rather than remove it from the margin.  I (DJS) will
-  // lobby for such a signal.
-  if (m_mhandle == mhandle)
-    {
-      if (m_marker_type == breakpoint || m_marker_type == debugger_position)
-        {
-          int editor_linenr = m_edit_area->markerLine (m_mhandle);
-          m_edit_area->markerDeleteHandle (m_mhandle);
-          m_marker_type = (m_marker_type == breakpoint
-                           ? unsure_breakpoint : unsure_debugger_position);
-          m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
-        }
-    }
-}
+  void marker::handle_marker_line_deleted (int mhandle)
+  {
+    // FUTURE SUPPORT: There really should be a signal in QsciScintilla
+    // called markerLineDeleted (int mhandle) because there is no way
+    // of knowing this.  QsciScintilla will place the marker at a
+    // different line rather than remove it from the margin.  I (DJS) will
+    // lobby for such a signal.
+    if (m_mhandle == mhandle)
+      {
+        if (m_marker_type == breakpoint || m_marker_type == debugger_position)
+          {
+            int editor_linenr = m_edit_area->markerLine (m_mhandle);
+            m_edit_area->markerDeleteHandle (m_mhandle);
+            m_marker_type = (m_marker_type == breakpoint
+                             ? unsure_breakpoint : unsure_debugger_position);
+            m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
+          }
+      }
+  }
 
-void
-marker::handle_marker_line_undeleted (int mhandle)
-{
-  // FUTURE SUPPORT: There really should be a signal in QsciScintilla
-  // called markerLineUndeleted (int mhandle) because there is no way
-  // of knowing this.  QsciScintilla will place the marker at a
-  // different line rather than remove it from the margin.  I (DJS) will
-  // lobby for such a signal.
-  if (m_mhandle == mhandle)
-    {
-      if (m_marker_type == unsure_breakpoint
-          || m_marker_type == unsure_debugger_position)
-        {
-          int editor_linenr = m_edit_area->markerLine (m_mhandle);
-          m_edit_area->markerDeleteHandle (m_mhandle);
-          m_marker_type = (m_marker_type == unsure_breakpoint
-                           ? breakpoint : debugger_position);
-          m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
-        }
-    }
+  void marker::handle_marker_line_undeleted (int mhandle)
+  {
+    // FUTURE SUPPORT: There really should be a signal in QsciScintilla
+    // called markerLineUndeleted (int mhandle) because there is no way
+    // of knowing this.  QsciScintilla will place the marker at a
+    // different line rather than remove it from the margin.  I (DJS) will
+    // lobby for such a signal.
+    if (m_mhandle == mhandle)
+      {
+        if (m_marker_type == unsure_breakpoint
+            || m_marker_type == unsure_debugger_position)
+          {
+            int editor_linenr = m_edit_area->markerLine (m_mhandle);
+            m_edit_area->markerDeleteHandle (m_mhandle);
+            m_marker_type = (m_marker_type == unsure_breakpoint
+                             ? breakpoint : debugger_position);
+            m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
+          }
+      }
+  }
 }
-
 #endif
diff --git a/libgui/src/m-editor/marker.h b/libgui/src/m-editor/marker.h
--- a/libgui/src/m-editor/marker.h
+++ b/libgui/src/m-editor/marker.h
@@ -30,75 +30,78 @@ along with Octave; see the file COPYING.
 typedef QList<int> QIntList;
 
 // The breakpoint class keeps track of the debug line number that Octave core
 // uses and the handle of the marker inside the editor file.  If the editor
 // contents is modified, the debug line number and editor line number can be
 // out of alignment.  The marker handle can be used to retrieve the editor
 // line.
 
-class marker : public QObject
+namespace octave
 {
-  Q_OBJECT
-
-public:
-
-  // List of all marker types
-  // If multiple markers are on the same line, the first one listed
-  // is drawn at the back, so big ones should be first.
-  enum editor_markers
+  class marker : public QObject
   {
-    breakpoint,
-    cond_break,
-    unsure_breakpoint,
-    bookmark,
-    debugger_position,
-    unsure_debugger_position,
-    selection
-  };
+    Q_OBJECT
+
+  public:
 
-  marker (QsciScintilla *edit_area, int original_linenr,
-          editor_markers marker_type, const QString& condition = "");
+    // List of all marker types
+    // If multiple markers are on the same line, the first one listed
+    // is drawn at the back, so big ones should be first.
+    enum editor_markers
+      {
+        breakpoint,
+        cond_break,
+        unsure_breakpoint,
+        bookmark,
+        debugger_position,
+        unsure_debugger_position,
+        selection
+      };
 
-  marker (QsciScintilla *edit_area, int original_linenr,
-          editor_markers marker_type, int editor_linenr,
-          const QString& condition = "");
+    marker (QsciScintilla *edit_area, int original_linenr,
+            editor_markers marker_type, const QString& condition = "");
 
-  ~marker (void) = default;
+    marker (QsciScintilla *edit_area, int original_linenr,
+            editor_markers marker_type, int editor_linenr,
+            const QString& condition = "");
 
-  const QString& get_cond (void) const { return m_condition; }
+    ~marker (void) = default;
 
-  void set_cond (const QString& cond) { m_condition = cond; }
+    const QString& get_cond (void) const { return m_condition; }
 
-public slots:
+    void set_cond (const QString& cond) { m_condition = cond; }
+
+  public slots:
 
-  void handle_remove_via_original_linenr (int original_linenr);
-  void handle_request_remove_via_editor_linenr (int editor_linenr);
-  void handle_remove (void);
-  void handle_find_translation (int original_linenr, int& editor_linenr,
-                                marker*& bp);
-  void handle_find_just_before (int linenr, int& original_linenr,
-                                int& editor_linenr);
-  void handle_find_just_after (int linenr, int& original_linenr,
-                               int& editor_linenr);
-  /*  void handle_lines_changed (void);*/
-  void handle_marker_line_deleted (int mhandle);
-  void handle_marker_line_undeleted (int mhandle);
-  void handle_report_editor_linenr (QIntList& lines, QStringList& conditions);
+    void handle_remove_via_original_linenr (int original_linenr);
+    void handle_request_remove_via_editor_linenr (int editor_linenr);
+    void handle_remove (void);
+    void handle_find_translation (int original_linenr, int& editor_linenr,
+                                  marker*& bp);
+    void handle_find_just_before (int linenr, int& original_linenr,
+                                  int& editor_linenr);
+    void handle_find_just_after (int linenr, int& original_linenr,
+                                 int& editor_linenr);
+    /*  void handle_lines_changed (void);*/
+    void handle_marker_line_deleted (int mhandle);
+    void handle_marker_line_undeleted (int mhandle);
+    void handle_report_editor_linenr (QIntList& lines, QStringList& conditions);
 
-signals:
+  signals:
 
-  void request_remove (int original_linenr);
+    void request_remove (int original_linenr);
 
-private:
+  private:
 
-  void construct (QsciScintilla *edit_area, int original_linenr,
-                  editor_markers marker_type, int editor_linenr,
-                  const QString& condition);
+    void construct (QsciScintilla *edit_area, int original_linenr,
+                    editor_markers marker_type, int editor_linenr,
+                    const QString& condition);
 
-  QsciScintilla *m_edit_area;
-  int m_original_linenr;
-  editor_markers m_marker_type;
-  int m_mhandle;
-  QString m_condition;
-};
+    QsciScintilla *m_edit_area;
+    int m_original_linenr;
+    editor_markers m_marker_type;
+    int m_mhandle;
+    QString m_condition;
+  };
+}
 
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -54,21 +54,21 @@ along with Octave; see the file COPYING.
 #include "marker.h"
 
 #include "octave-qscintilla.h"
 #include "file-editor-tab.h"
 #include "shortcut-manager.h"
 #include "resource-manager.h"
 #include "octave-settings.h"
 
-
 // Return true if CANDIDATE is a "closing" that matches OPENING,
 // such as "end" or "endif" for "if", or "catch" for "try".
 // Used for testing the last word of an "if" etc. line,
 // or the first word of the following line.
+
 static bool
 is_end (const QString& candidate, const QString& opening)
 {
   bool retval = false;
 
   if (opening == "do")          // The only one that can't be ended by "end"
     {
       if (candidate == "until")
@@ -96,300 +96,293 @@ is_end (const QString& candidate, const 
           else if (opening == "if" && candidate == "else")
             retval = true;
         }
     }
 
   return retval;
 }
 
-octave_qscintilla::octave_qscintilla (QWidget *p)
-  : QsciScintilla (p), m_word_at_cursor (), m_selection (),
-    m_selection_replacement (), m_selection_line (-1),
-    m_selection_col (-1), m_indicator_id (1)
+namespace octave
 {
-  connect (this, SIGNAL (textChanged (void)), this, SLOT (text_changed (void)));
+  octave_qscintilla::octave_qscintilla (QWidget *p)
+    : QsciScintilla (p), m_word_at_cursor (), m_selection (),
+      m_selection_replacement (), m_selection_line (-1),
+      m_selection_col (-1), m_indicator_id (1)
+  {
+    connect (this, SIGNAL (textChanged (void)),
+             this, SLOT (text_changed (void)));
 
-  connect (this, SIGNAL (cursorPositionChanged (int, int)),
-           this, SLOT (cursor_position_changed (int, int)));
+    connect (this, SIGNAL (cursorPositionChanged (int, int)),
+             this, SLOT (cursor_position_changed (int, int)));
 
-  // clear scintilla edit shortcuts that are handled by the editor
-  QsciCommandSet *cmd_set = standardCommands ();
+    // clear scintilla edit shortcuts that are handled by the editor
+    QsciCommandSet *cmd_set = standardCommands ();
 
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-  // find () was added in QScintilla 2.6
-  cmd_set->find (QsciCommand::SelectionCopy)->setKey (0);
-  cmd_set->find (QsciCommand::SelectionCut)->setKey (0);
-  cmd_set->find (QsciCommand::Paste)->setKey (0);
-  cmd_set->find (QsciCommand::SelectAll)->setKey (0);
-  cmd_set->find (QsciCommand::SelectionDuplicate)->setKey (0);
-  cmd_set->find (QsciCommand::LineTranspose)->setKey (0);
-  cmd_set->find (QsciCommand::Undo)->setKey (0);
-  cmd_set->find (QsciCommand::Redo)->setKey (0);
-  cmd_set->find (QsciCommand::SelectionUpperCase)->setKey (0);
-  cmd_set->find (QsciCommand::SelectionLowerCase)->setKey (0);
-  cmd_set->find (QsciCommand::ZoomIn)->setKey (0);
-  cmd_set->find (QsciCommand::ZoomOut)->setKey (0);
-  cmd_set->find (QsciCommand::DeleteWordLeft)->setKey (0);
-  cmd_set->find (QsciCommand::DeleteWordRight)->setKey (0);
-  cmd_set->find (QsciCommand::DeleteLineLeft)->setKey (0);
-  cmd_set->find (QsciCommand::DeleteLineRight)->setKey (0);
-  cmd_set->find (QsciCommand::LineDelete)->setKey (0);
-  cmd_set->find (QsciCommand::LineCut)->setKey (0);
-  cmd_set->find (QsciCommand::LineCopy)->setKey (0);
+    // find () was added in QScintilla 2.6
+    cmd_set->find (QsciCommand::SelectionCopy)->setKey (0);
+    cmd_set->find (QsciCommand::SelectionCut)->setKey (0);
+    cmd_set->find (QsciCommand::Paste)->setKey (0);
+    cmd_set->find (QsciCommand::SelectAll)->setKey (0);
+    cmd_set->find (QsciCommand::SelectionDuplicate)->setKey (0);
+    cmd_set->find (QsciCommand::LineTranspose)->setKey (0);
+    cmd_set->find (QsciCommand::Undo)->setKey (0);
+    cmd_set->find (QsciCommand::Redo)->setKey (0);
+    cmd_set->find (QsciCommand::SelectionUpperCase)->setKey (0);
+    cmd_set->find (QsciCommand::SelectionLowerCase)->setKey (0);
+    cmd_set->find (QsciCommand::ZoomIn)->setKey (0);
+    cmd_set->find (QsciCommand::ZoomOut)->setKey (0);
+    cmd_set->find (QsciCommand::DeleteWordLeft)->setKey (0);
+    cmd_set->find (QsciCommand::DeleteWordRight)->setKey (0);
+    cmd_set->find (QsciCommand::DeleteLineLeft)->setKey (0);
+    cmd_set->find (QsciCommand::DeleteLineRight)->setKey (0);
+    cmd_set->find (QsciCommand::LineDelete)->setKey (0);
+    cmd_set->find (QsciCommand::LineCut)->setKey (0);
+    cmd_set->find (QsciCommand::LineCopy)->setKey (0);
 #else
-  // find commands via its default key (tricky way without find ())
-  QList< QsciCommand * > cmd_list = cmd_set->commands ();
-  for (int i = 0; i < cmd_list.length (); i++)
-    {
-      int cmd_key = cmd_list.at (i)->key ();
-      switch (cmd_key)
-        {
-        case Qt::Key_C | Qt::CTRL :               // SelectionCopy
-        case Qt::Key_X | Qt::CTRL :               // SelectionCut
-        case Qt::Key_V | Qt::CTRL :               // Paste
-        case Qt::Key_A | Qt::CTRL :               // SelectAll
-        case Qt::Key_D | Qt::CTRL :               // SelectionDuplicate
-        case Qt::Key_T | Qt::CTRL :               // LineTranspose
-        case Qt::Key_Z | Qt::CTRL :               // Undo
-        case Qt::Key_Y | Qt::CTRL :               // Redo
-        case Qt::Key_Z | Qt::CTRL | Qt::SHIFT :   // Redo
-        case Qt::Key_U | Qt::CTRL :               // SelectionLowerCase
-        case Qt::Key_U | Qt::CTRL | Qt::SHIFT :   // SelectionUpperCase
-        case Qt::Key_Plus | Qt::CTRL :            // ZoomIn
-        case Qt::Key_Minus | Qt::CTRL :           // ZoomOut
-        case Qt::Key_Backspace | Qt::CTRL | Qt::SHIFT :   // DeleteLineLeft
-        case Qt::Key_Delete | Qt::CTRL | Qt::SHIFT :      // DeleteLineRight
-        case Qt::Key_K | Qt::META :                       // DeleteLineRight
-        case Qt::Key_Backspace | Qt::CTRL :       // DeleteWordLeft
-        case Qt::Key_Delete | Qt::CTRL :          // DeleteWordRight
-        case Qt::Key_L | Qt::CTRL | Qt::SHIFT :   // LineDelete
-        case Qt::Key_L | Qt::CTRL :               // LineCut
-        case Qt::Key_T | Qt::CTRL | Qt::SHIFT :   // LineCopy
-          cmd_list.at (i)->setKey (0);
-        }
-    }
+    // find commands via its default key (tricky way without find ())
+    QList< QsciCommand * > cmd_list = cmd_set->commands ();
+    for (int i = 0; i < cmd_list.length (); i++)
+      {
+        int cmd_key = cmd_list.at (i)->key ();
+        switch (cmd_key)
+          {
+          case Qt::Key_C | Qt::CTRL :               // SelectionCopy
+          case Qt::Key_X | Qt::CTRL :               // SelectionCut
+          case Qt::Key_V | Qt::CTRL :               // Paste
+          case Qt::Key_A | Qt::CTRL :               // SelectAll
+          case Qt::Key_D | Qt::CTRL :               // SelectionDuplicate
+          case Qt::Key_T | Qt::CTRL :               // LineTranspose
+          case Qt::Key_Z | Qt::CTRL :               // Undo
+          case Qt::Key_Y | Qt::CTRL :               // Redo
+          case Qt::Key_Z | Qt::CTRL | Qt::SHIFT :   // Redo
+          case Qt::Key_U | Qt::CTRL :               // SelectionLowerCase
+          case Qt::Key_U | Qt::CTRL | Qt::SHIFT :   // SelectionUpperCase
+          case Qt::Key_Plus | Qt::CTRL :            // ZoomIn
+          case Qt::Key_Minus | Qt::CTRL :           // ZoomOut
+          case Qt::Key_Backspace | Qt::CTRL | Qt::SHIFT :   // DeleteLineLeft
+          case Qt::Key_Delete | Qt::CTRL | Qt::SHIFT :      // DeleteLineRight
+          case Qt::Key_K | Qt::META :                       // DeleteLineRight
+          case Qt::Key_Backspace | Qt::CTRL :       // DeleteWordLeft
+          case Qt::Key_Delete | Qt::CTRL :          // DeleteWordRight
+          case Qt::Key_L | Qt::CTRL | Qt::SHIFT :   // LineDelete
+          case Qt::Key_L | Qt::CTRL :               // LineCut
+          case Qt::Key_T | Qt::CTRL | Qt::SHIFT :   // LineCopy
+            cmd_list.at (i)->setKey (0);
+          }
+      }
 #endif
 
 #if defined (Q_OS_MAC)
-  // Octave interprets Cmd key as Meta whereas Qscintilla interprets it
-  // as Ctrl. We thus invert Meta/Ctrl in Qscintilla's shortcuts list.
-  QList< QsciCommand * > cmd_list_mac = cmd_set->commands ();
-  for (int i = 0; i < cmd_list_mac.length (); i++)
-    {
-      // Primary key
-      int key = cmd_list_mac.at (i)->key ();
+    // Octave interprets Cmd key as Meta whereas Qscintilla interprets it
+    // as Ctrl. We thus invert Meta/Ctrl in Qscintilla's shortcuts list.
+    QList< QsciCommand * > cmd_list_mac = cmd_set->commands ();
+    for (int i = 0; i < cmd_list_mac.length (); i++)
+      {
+        // Primary key
+        int key = cmd_list_mac.at (i)->key ();
 
-      if (static_cast<int> (key | Qt::META) == key &&
-          static_cast<int> (key | Qt::CTRL) != key)
-        key = (key ^ Qt::META) | Qt::CTRL;
-      else if (static_cast<int> (key | Qt::CTRL) == key)
-        key = (key ^ Qt::CTRL) | Qt::META;
+        if (static_cast<int> (key | Qt::META) == key &&
+            static_cast<int> (key | Qt::CTRL) != key)
+          key = (key ^ Qt::META) | Qt::CTRL;
+        else if (static_cast<int> (key | Qt::CTRL) == key)
+          key = (key ^ Qt::CTRL) | Qt::META;
 
-      cmd_list_mac.at (i)->setKey (key);
+        cmd_list_mac.at (i)->setKey (key);
 
-      // Alternate key
-      key = cmd_list_mac.at (i)->alternateKey ();
+        // Alternate key
+        key = cmd_list_mac.at (i)->alternateKey ();
 
-      if (static_cast<int> (key | Qt::META) == key &&
-          static_cast<int> (key | Qt::CTRL) != key)
-        key = (key ^ Qt::META) | Qt::CTRL;
-      else if (static_cast<int> (key | Qt::CTRL) == key)
-        key = (key ^ Qt::CTRL) | Qt::META;
+        if (static_cast<int> (key | Qt::META) == key &&
+            static_cast<int> (key | Qt::CTRL) != key)
+          key = (key ^ Qt::META) | Qt::CTRL;
+        else if (static_cast<int> (key | Qt::CTRL) == key)
+          key = (key ^ Qt::CTRL) | Qt::META;
 
-      cmd_list_mac.at (i)->setAlternateKey (key);
-    }
+        cmd_list_mac.at (i)->setAlternateKey (key);
+      }
 #endif
 
-  // selection markers
+    // selection markers
 
-  m_indicator_id = indicatorDefine (QsciScintilla::StraightBoxIndicator);
-  if (m_indicator_id == -1)
-    m_indicator_id = 1;
+    m_indicator_id = indicatorDefine (QsciScintilla::StraightBoxIndicator);
+    if (m_indicator_id == -1)
+      m_indicator_id = 1;
 
-  setIndicatorDrawUnder (true, m_indicator_id);
+    setIndicatorDrawUnder (true, m_indicator_id);
 
-  markerDefine (QsciScintilla::Minus, marker::selection);
+    markerDefine (QsciScintilla::Minus, marker::selection);
 
-  // init state of undo/redo action for this tab
-  emit status_update (isUndoAvailable (), isRedoAvailable ());
-}
+    // init state of undo/redo action for this tab
+    emit status_update (isUndoAvailable (), isRedoAvailable ());
+  }
 
-void
-octave_qscintilla::set_selection_marker_color (const QColor& c)
-{
-  QColor ic = c;
-  ic.setAlphaF (0.25);
-  setIndicatorForegroundColor (ic, m_indicator_id);
-  setIndicatorOutlineColor (ic, m_indicator_id);
+  void octave_qscintilla::set_selection_marker_color (const QColor& c)
+  {
+    QColor ic = c;
+    ic.setAlphaF (0.25);
+    setIndicatorForegroundColor (ic, m_indicator_id);
+    setIndicatorOutlineColor (ic, m_indicator_id);
 
-  setMarkerForegroundColor (c, marker::selection);
-  setMarkerBackgroundColor (c, marker::selection);
-}
+    setMarkerForegroundColor (c, marker::selection);
+    setMarkerBackgroundColor (c, marker::selection);
+  }
 
-// context menu requested
-void
-octave_qscintilla::contextMenuEvent (QContextMenuEvent *e)
-{
+  // context menu requested
+  void octave_qscintilla::contextMenuEvent (QContextMenuEvent *e)
+  {
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-  QPoint global_pos, local_pos;                         // the menu's position
-  QMenu *context_menu = createStandardContextMenu ();  // standard menu
+    QPoint global_pos, local_pos;                         // the menu's position
+    QMenu *context_menu = createStandardContextMenu ();  // standard menu
 
-  bool in_left_margin = false;
+    bool in_left_margin = false;
 
-  // determine position depending on mouse or keyboard event
-  if (e->reason () == QContextMenuEvent::Mouse)
-    {
-      // context menu by mouse
-      global_pos = e->globalPos ();            // global mouse position
-      local_pos  = e->pos ();                  // local mouse position
-      if (e->x () < marginWidth (1) + marginWidth (2))
-        in_left_margin = true;
-    }
-  else
-    {
-      // context menu by keyboard or other: get point of text cursor
-      get_global_textcursor_pos (&global_pos, &local_pos);
-      QRect editor_rect = geometry ();      // editor rect mapped to global
-      editor_rect.moveTopLeft
-      (parentWidget ()->mapToGlobal (editor_rect.topLeft ()));
-      if (! editor_rect.contains (global_pos))  // is cursor outside editor?
-        global_pos = editor_rect.topLeft ();   // yes, take top left corner
-    }
+    // determine position depending on mouse or keyboard event
+    if (e->reason () == QContextMenuEvent::Mouse)
+      {
+        // context menu by mouse
+        global_pos = e->globalPos ();            // global mouse position
+        local_pos  = e->pos ();                  // local mouse position
+        if (e->x () < marginWidth (1) + marginWidth (2))
+          in_left_margin = true;
+      }
+    else
+      {
+        // context menu by keyboard or other: get point of text cursor
+        get_global_textcursor_pos (&global_pos, &local_pos);
+        QRect editor_rect = geometry ();      // editor rect mapped to global
+        editor_rect.moveTopLeft
+          (parentWidget ()->mapToGlobal (editor_rect.topLeft ()));
+        if (! editor_rect.contains (global_pos))  // is cursor outside editor?
+          global_pos = editor_rect.topLeft ();   // yes, take top left corner
+      }
 
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-  if (! in_left_margin)
+    if (! in_left_margin)
 #endif
-    {
-      // fill context menu with editor's standard actions
-      emit create_context_menu_signal (context_menu);
+      {
+        // fill context menu with editor's standard actions
+        emit create_context_menu_signal (context_menu);
 
-      // additional custom entries of the context menu
-      context_menu->addSeparator ();   // separator before custom entries
+        // additional custom entries of the context menu
+        context_menu->addSeparator ();   // separator before custom entries
 
-      // help menu: get the position of the mouse or the text cursor
-      // (only for octave files)
-      QString lexer_name = lexer ()->lexer ();
-      if (lexer_name == "octave" || lexer_name == "matlab")
-        {
-          m_word_at_cursor = wordAtPoint (local_pos);
-          if (! m_word_at_cursor.isEmpty ())
-            {
-              context_menu->addAction (tr ("Help on") + ' ' + m_word_at_cursor,
-                                       this, SLOT (contextmenu_help (bool)));
-              context_menu->addAction (tr ("Documentation on")
-                                       + ' ' + m_word_at_cursor,
-                                       this, SLOT (contextmenu_doc (bool)));
-              context_menu->addAction (tr ("Edit") + ' ' + m_word_at_cursor,
-                                       this, SLOT (contextmenu_edit (bool)));
-            }
-        }
-    }
+        // help menu: get the position of the mouse or the text cursor
+        // (only for octave files)
+        QString lexer_name = lexer ()->lexer ();
+        if (lexer_name == "octave" || lexer_name == "matlab")
+          {
+            m_word_at_cursor = wordAtPoint (local_pos);
+            if (! m_word_at_cursor.isEmpty ())
+              {
+                context_menu->addAction (tr ("Help on") + ' ' + m_word_at_cursor,
+                                         this, SLOT (contextmenu_help (bool)));
+                context_menu->addAction (tr ("Documentation on")
+                                         + ' ' + m_word_at_cursor,
+                                         this, SLOT (contextmenu_doc (bool)));
+                context_menu->addAction (tr ("Edit") + ' ' + m_word_at_cursor,
+                                         this, SLOT (contextmenu_edit (bool)));
+              }
+          }
+      }
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-  else
-    {
-      // remove all standard actions from scintilla
-      QList<QAction *> all_actions = context_menu->actions ();
-      QAction *a;
+    else
+      {
+        // remove all standard actions from scintilla
+        QList<QAction *> all_actions = context_menu->actions ();
+        QAction *a;
 
-      foreach (a, all_actions)
-        context_menu->removeAction (a);
+        foreach (a, all_actions)
+          context_menu->removeAction (a);
 
-      a = context_menu->addAction (tr ("dbstop if ..."), this,
-                                   SLOT (contextmenu_break_condition (bool)));
-      a->setData (local_pos);
-    }
+        a = context_menu->addAction (tr ("dbstop if ..."), this,
+                                     SLOT (contextmenu_break_condition (bool)));
+        a->setData (local_pos);
+      }
 #endif
 
-  // finaly show the menu
-  context_menu->exec (global_pos);
+    // finaly show the menu
+    context_menu->exec (global_pos);
 #endif
-}
+  }
 
-// common function with flag for documentation
-void
-octave_qscintilla::contextmenu_help_doc (bool documentation)
-{
-  if (documentation)
-    emit show_doc_signal (m_word_at_cursor);
-  else
-    emit execute_command_in_terminal_signal ("help " + m_word_at_cursor);
-}
+  // common function with flag for documentation
+  void octave_qscintilla::contextmenu_help_doc (bool documentation)
+  {
+    if (documentation)
+      emit show_doc_signal (m_word_at_cursor);
+    else
+      emit execute_command_in_terminal_signal ("help " + m_word_at_cursor);
+  }
 
-// call edit the function related to the current word
-void
-octave_qscintilla::context_edit (void)
-{
-  if (get_actual_word ())
-    contextmenu_edit (true);
-}
+  // call edit the function related to the current word
+  void octave_qscintilla::context_edit (void)
+  {
+    if (get_actual_word ())
+      contextmenu_edit (true);
+  }
 
-// call edit the function related to the current word
-void
-octave_qscintilla::context_run (void)
-{
-  if (hasSelectedText ())
-    contextmenu_run (true);
-}
+  // call edit the function related to the current word
+  void octave_qscintilla::context_run (void)
+  {
+    if (hasSelectedText ())
+      contextmenu_run (true);
+  }
 
-void
-octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
-                                              QPoint *local_pos)
-{
-  long position = SendScintilla (SCI_GETCURRENTPOS);
-  long point_x  = SendScintilla
-                    (SCI_POINTXFROMPOSITION,0,position);
-  long point_y  = SendScintilla
-                    (SCI_POINTYFROMPOSITION,0,position);
-  *local_pos = QPoint (point_x,point_y);  // local cursor position
-  *global_pos = mapToGlobal (*local_pos); // global position of cursor
-}
+  void octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
+                                                     QPoint *local_pos)
+  {
+    long position = SendScintilla (SCI_GETCURRENTPOS);
+    long point_x  = SendScintilla
+      (SCI_POINTXFROMPOSITION,0,position);
+    long point_y  = SendScintilla
+      (SCI_POINTYFROMPOSITION,0,position);
+    *local_pos = QPoint (point_x,point_y);  // local cursor position
+    *global_pos = mapToGlobal (*local_pos); // global position of cursor
+  }
 
-// determine the actual word and whether we are in an octave or matlab script
-bool
-octave_qscintilla::get_actual_word (void)
-{
-  QPoint global_pos, local_pos;
-  get_global_textcursor_pos (&global_pos, &local_pos);
-  m_word_at_cursor = wordAtPoint (local_pos);
-  QString lexer_name = lexer ()->lexer ();
-  return ((lexer_name == "octave" || lexer_name == "matlab")
-          && ! m_word_at_cursor.isEmpty ());
-}
+  // determine the actual word and whether we are in an octave or matlab script
+  bool octave_qscintilla::get_actual_word (void)
+  {
+    QPoint global_pos, local_pos;
+    get_global_textcursor_pos (&global_pos, &local_pos);
+    m_word_at_cursor = wordAtPoint (local_pos);
+    QString lexer_name = lexer ()->lexer ();
+    return ((lexer_name == "octave" || lexer_name == "matlab")
+            && ! m_word_at_cursor.isEmpty ());
+  }
 
-// helper function for clearing all indicators of a specific style
-void
-octave_qscintilla::clear_selection_markers (void)
-{
-  int end_pos = text ().length ();
-  int end_line, end_col;
-  lineIndexFromPosition (end_pos, &end_line, &end_col);
-  clearIndicatorRange (0, 0, end_line, end_col, m_indicator_id);
+  // helper function for clearing all indicators of a specific style
+  void octave_qscintilla::clear_selection_markers (void)
+  {
+    int end_pos = text ().length ();
+    int end_line, end_col;
+    lineIndexFromPosition (end_pos, &end_line, &end_col);
+    clearIndicatorRange (0, 0, end_line, end_col, m_indicator_id);
 
-  markerDeleteAll (marker::selection);
-}
+    markerDeleteAll (marker::selection);
+  }
 
-// Function returning the true cursor position where the tab length
-// is taken into account.
-void
-octave_qscintilla::get_current_position (int *pos, int *line, int *col)
-{
-  *pos = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS);
-  *line = SendScintilla (QsciScintillaBase::SCI_LINEFROMPOSITION, *pos);
-  *col = SendScintilla (QsciScintillaBase::SCI_GETCOLUMN, *pos);
-}
+  // Function returning the true cursor position where the tab length
+  // is taken into account.
+  void octave_qscintilla::get_current_position (int *pos, int *line, int *col)
+  {
+    *pos = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS);
+    *line = SendScintilla (QsciScintillaBase::SCI_LINEFROMPOSITION, *pos);
+    *col = SendScintilla (QsciScintillaBase::SCI_GETCOLUMN, *pos);
+  }
 
-// Function returning the comment string of the current lexer
-QStringList
-octave_qscintilla::comment_string (bool comment)
-{
-  int lexer = SendScintilla (SCI_GETLEXER);
+  // Function returning the comment string of the current lexer
+  QStringList octave_qscintilla::comment_string (bool comment)
+  {
+    int lexer = SendScintilla (SCI_GETLEXER);
 
-  switch (lexer)
-    {
+    switch (lexer)
+      {
 #if defined (HAVE_LEXER_OCTAVE) || defined (HAVE_LEXER_MATLAB)
 #if defined (HAVE_LEXER_OCTAVE)
       case SCLEX_OCTAVE:
 #else
       case SCLEX_MATLAB:
 #endif
         {
           QSettings *settings = resource_manager::get_settings ();
@@ -432,54 +425,52 @@ octave_qscintilla::comment_string (bool 
       case SCLEX_DIFF:
         return QStringList ("#");
 
       case SCLEX_CPP:
         return QStringList ("//");
 
       case SCLEX_BATCH:
         return QStringList ("REM ");
-    }
+      }
 
     return QStringList ("%");  // should never happen
-}
+  }
 
 
-// provide the style at a specific position
-int
-octave_qscintilla::get_style (int pos)
-{
-  int position;
-  if (pos < 0)
-    // The positition has to be reduced by 2 for getting the real style (?)
-    position = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS) - 2;
-  else
-    position = pos;
+  // provide the style at a specific position
+  int octave_qscintilla::get_style (int pos)
+  {
+    int position;
+    if (pos < 0)
+      // The positition has to be reduced by 2 for getting the real style (?)
+      position = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS) - 2;
+    else
+      position = pos;
 
-  return SendScintilla (QsciScintillaBase::SCI_GETSTYLEAT, position);
-}
+    return SendScintilla (QsciScintillaBase::SCI_GETSTYLEAT, position);
+  }
 
-// Is a specific cursor position in a line or block comment?
-int
-octave_qscintilla::is_style_comment (int pos)
-{
-  int lexer = SendScintilla (QsciScintillaBase::SCI_GETLEXER);
-  int style = get_style (pos);
+  // Is a specific cursor position in a line or block comment?
+  int octave_qscintilla::is_style_comment (int pos)
+  {
+    int lexer = SendScintilla (QsciScintillaBase::SCI_GETLEXER);
+    int style = get_style (pos);
 
-  switch (lexer)
-    {
+    switch (lexer)
+      {
       case SCLEX_CPP:
         return (ST_LINE_COMMENT * (
-                          style == QsciLexerCPP::CommentLine
-                       || style == QsciLexerCPP::CommentLineDoc)
-              + ST_BLOCK_COMMENT * (
-                           style == QsciLexerCPP::Comment
-                        || style == QsciLexerCPP::CommentDoc
-                        || style == QsciLexerCPP::CommentDocKeyword
-                        || style == QsciLexerCPP::CommentDocKeywordError)
+                                   style == QsciLexerCPP::CommentLine
+                                   || style == QsciLexerCPP::CommentLineDoc)
+                + ST_BLOCK_COMMENT * (
+                                      style == QsciLexerCPP::Comment
+                                      || style == QsciLexerCPP::CommentDoc
+                                      || style == QsciLexerCPP::CommentDocKeyword
+                                      || style == QsciLexerCPP::CommentDocKeywordError)
                 );
 
 #if defined (HAVE_LEXER_MATLAB)
       case SCLEX_MATLAB:
         return (ST_LINE_COMMENT * (style == QsciLexerMatlab::Comment));
 #endif
 #if  defined (HAVE_LEXER_OCTAVE)
       case SCLEX_OCTAVE:
@@ -493,464 +484,449 @@ octave_qscintilla::is_style_comment (int
         return (ST_LINE_COMMENT * (style == QsciLexerBatch::Comment));
 
       case SCLEX_DIFF:
         return (ST_LINE_COMMENT * (style == QsciLexerDiff::Comment));
 
       case SCLEX_BASH:
         return (ST_LINE_COMMENT * (style == QsciLexerBash::Comment));
 
-    }
-
-  return ST_NONE;
-}
+      }
 
-// Do smart indendation after if, for, ...
-void
-octave_qscintilla::smart_indent (bool do_smart_indent,
-                                 int do_auto_close, int line)
-{
-  QString prevline = text (line);
+    return ST_NONE;
+  }
 
-  QRegExp bkey = QRegExp ("^[\t ]*(if|for|while|switch|case|otherwise"
-                          "|do|function|properties|events|classdef"
-                          "|unwind_protect|unwind_protect_cleanup|try"
-                          "|parfor|methods)"
-                          "[\r]?[\n\t #%]");
-  // last word except for comments, assuming no ' or " in comment.
-  // rx_end = QRegExp ("(\\w+)[ \t;\r\n]*([%#][^\"']*)?$");
+  // Do smart indendation after if, for, ...
+  void octave_qscintilla::smart_indent (bool do_smart_indent,
+                                        int do_auto_close, int line)
+  {
+    QString prevline = text (line);
 
-  // last word except for comments,
-  // allowing % and # in single or double quoted strings
-  // FIXME This will get confused by transpose.
-  QRegExp ekey = QRegExp ("(?:(?:['\"][^'\"]*['\"])?[^%#]*)*"
-                          "(\\w+)[ \t;\r\n]*([%#].*)?$");
+    QRegExp bkey = QRegExp ("^[\t ]*(if|for|while|switch|case|otherwise"
+                            "|do|function|properties|events|classdef"
+                            "|unwind_protect|unwind_protect_cleanup|try"
+                            "|parfor|methods)"
+                            "[\r]?[\n\t #%]");
+    // last word except for comments, assuming no ' or " in comment.
+    // rx_end = QRegExp ("(\\w+)[ \t;\r\n]*([%#][^\"']*)?$");
 
-  int bpos = bkey.indexIn (prevline, 0);
-  int epos;
+    // last word except for comments,
+    // allowing % and # in single or double quoted strings
+    // FIXME This will get confused by transpose.
+    QRegExp ekey = QRegExp ("(?:(?:['\"][^'\"]*['\"])?[^%#]*)*"
+                            "(\\w+)[ \t;\r\n]*([%#].*)?$");
 
-  if (bpos > -1)
-    {
-      // Found keyword after that indentation should be added
-
-      // Check for existing end statement in the same line
-      epos = ekey.indexIn (prevline, bpos);
-      QString first_word = bkey.cap(1);
-      bool inline_end = (epos > -1) && is_end (ekey.cap(1), first_word);
+    int bpos = bkey.indexIn (prevline, 0);
+    int epos;
 
-      if (do_smart_indent && ! inline_end)
-        {
-          // Do smart indent in the current line (line+1)
-          indent (line+1);
-          setCursorPosition (line+1, indentation (line) + indentationWidth ());
-        }
+    if (bpos > -1)
+      {
+        // Found keyword after that indentation should be added
 
-      if (do_auto_close
-              && ! inline_end
-              && ! first_word.contains (
-                      QRegExp ("(case|otherwise|unwind_protect_cleanup)")))
-        {
-          // Do auto close
-          auto_close (do_auto_close, line, prevline, first_word);
-        }
+        // Check for existing end statement in the same line
+        epos = ekey.indexIn (prevline, bpos);
+        QString first_word = bkey.cap(1);
+        bool inline_end = (epos > -1) && is_end (ekey.cap(1), first_word);
+
+        if (do_smart_indent && ! inline_end)
+          {
+            // Do smart indent in the current line (line+1)
+            indent (line+1);
+            setCursorPosition (line+1, indentation (line) + indentationWidth ());
+          }
 
-      return;
-    }
-
-  QRegExp mkey = QRegExp ("^[\t ]*(else|elseif|catch)[\r]?[\t #%\n]");
-  if (prevline.contains (mkey))
-    {
-      int prev_ind = indentation (line-1);
-      int act_ind = indentation (line);
+        if (do_auto_close
+            && ! inline_end
+            && ! first_word.contains (
+                                      QRegExp ("(case|otherwise|unwind_protect_cleanup)")))
+          {
+            // Do auto close
+            auto_close (do_auto_close, line, prevline, first_word);
+          }
 
-      if (prev_ind == act_ind)
-        unindent (line);
-      else if (prev_ind > act_ind)
-        {
-          setIndentation (line+1, prev_ind);
-          setCursorPosition (line+1, prev_ind);
-        }
-      return;
-    }
+        return;
+      }
 
-  ekey = QRegExp ("^[\t ]*(end|endif|endfor|endwhile|until|endfunction"
-                  "|end_try_catch|end_unwind_protext)[\r]?[\t #%\n(;]");
-  if (prevline.contains (ekey))
-    {
-      if (indentation (line-1) <= indentation (line))
-        {
-          unindent (line+1);
+    QRegExp mkey = QRegExp ("^[\t ]*(else|elseif|catch)[\r]?[\t #%\n]");
+    if (prevline.contains (mkey))
+      {
+        int prev_ind = indentation (line-1);
+        int act_ind = indentation (line);
+
+        if (prev_ind == act_ind)
           unindent (line);
-          setCursorPosition (line+1,
-                                         indentation (line));
-        }
-      return;
-    }
-}
-
-// Do smart indendation of current selection or line.
-void
-octave_qscintilla::smart_indent_line_or_selected_text (int lineFrom, int lineTo)
-{
-  QRegExp blank_line_regexp = QRegExp ("^[\t ]*$");
+        else if (prev_ind > act_ind)
+          {
+            setIndentation (line+1, prev_ind);
+            setCursorPosition (line+1, prev_ind);
+          }
+        return;
+      }
 
-  QRegExp begin_block_regexp
-    = QRegExp ("^([\t ]*)(if|elseif|else"
-               "|for|while|do|parfor"
-               "|switch|case|otherwise"
-               "|function"
-               "|classdef|properties|events|enumeration|methods"
-               "|unwind_protect|unwind_protect_cleanup|try|catch)"
-               "[\r\n\t #%]");
+    ekey = QRegExp ("^[\t ]*(end|endif|endfor|endwhile|until|endfunction"
+                    "|end_try_catch|end_unwind_protext)[\r]?[\t #%\n(;]");
+    if (prevline.contains (ekey))
+      {
+        if (indentation (line-1) <= indentation (line))
+          {
+            unindent (line+1);
+            unindent (line);
+            setCursorPosition (line+1,
+                               indentation (line));
+          }
+        return;
+      }
+  }
 
-  QRegExp end_block_regexp
-    = QRegExp ("^([\t ]*)(end"
-               "|end(for|function|if|parfor|switch|while"
-               "|classdef|enumeration|events|methods|properties)"
-               "|end_(try_catch|unwind_protect)"
-               "|until)"
-               "[\r\n\t #%]");
+  // Do smart indendation of current selection or line.
+  void octave_qscintilla::smart_indent_line_or_selected_text (int lineFrom,
+                                                              int lineTo)
+  {
+    QRegExp blank_line_regexp = QRegExp ("^[\t ]*$");
+
+    QRegExp begin_block_regexp
+      = QRegExp ("^([\t ]*)(if|elseif|else"
+                 "|for|while|do|parfor"
+                 "|switch|case|otherwise"
+                 "|function"
+                 "|classdef|properties|events|enumeration|methods"
+                 "|unwind_protect|unwind_protect_cleanup|try|catch)"
+                 "[\r\n\t #%]");
 
-  int indent_column = -1;
-  int indent_increment = indentationWidth ();
+    QRegExp end_block_regexp
+      = QRegExp ("^([\t ]*)(end"
+                 "|end(for|function|if|parfor|switch|while"
+                 "|classdef|enumeration|events|methods|properties)"
+                 "|end_(try_catch|unwind_protect)"
+                 "|until)"
+                 "[\r\n\t #%]");
 
-  for (int line = lineFrom-1; line >= 0; line--)
-    {
-      QString line_text = text (line);
+    int indent_column = -1;
+    int indent_increment = indentationWidth ();
 
-      if (blank_line_regexp.indexIn (line_text) < 0)
-        {
-          // Found first non-blank line above beginning of region or
-          // current line.  Base indentation from this line, increasing
-          // indentation by indentationWidth if it looks like the
-          // beginning of a code block.
-
-          indent_column = indentation (line);
+    for (int line = lineFrom-1; line >= 0; line--)
+      {
+        QString line_text = text (line);
 
-          if (begin_block_regexp.indexIn (line_text) > -1)
-            indent_column += indent_increment;
+        if (blank_line_regexp.indexIn (line_text) < 0)
+          {
+            // Found first non-blank line above beginning of region or
+            // current line.  Base indentation from this line, increasing
+            // indentation by indentationWidth if it looks like the
+            // beginning of a code block.
 
-          break;
-        }
-    }
-
-  if (indent_column < 0)
-    indent_column = indentation (lineFrom);
+            indent_column = indentation (line);
 
-  for (int line = lineFrom; line <= lineTo; line++)
-    {
-      QString line_text = text (line);
+            if (begin_block_regexp.indexIn (line_text) > -1)
+              indent_column += indent_increment;
 
-      if (end_block_regexp.indexIn (line_text) > -1)
-        indent_column -= indent_increment;
+            break;
+          }
+      }
 
-      setIndentation (line, indent_column);
+    if (indent_column < 0)
+      indent_column = indentation (lineFrom);
 
-      if (begin_block_regexp.indexIn (line_text) > -1)
-        indent_column += indent_increment;
-    }
-}
+    for (int line = lineFrom; line <= lineTo; line++)
+      {
+        QString line_text = text (line);
 
-void
-octave_qscintilla::set_word_selection (const QString& word)
-{
-  m_selection = word;
+        if (end_block_regexp.indexIn (line_text) > -1)
+          indent_column -= indent_increment;
+
+        setIndentation (line, indent_column);
 
-  if (word.isEmpty ())
-    {
-      m_selection_line = -1;
-      m_selection_col = -1;
+        if (begin_block_regexp.indexIn (line_text) > -1)
+          indent_column += indent_increment;
+      }
+  }
 
-      m_selection_replacement = "";
-
-      clear_selection_markers ();
+  void octave_qscintilla::set_word_selection (const QString& word)
+  {
+    m_selection = word;
 
-      QToolTip::hideText ();
-    }
-  else
-    {
-      int pos;
-      get_current_position (&pos, &m_selection_line, &m_selection_col);
-    }
-}
+    if (word.isEmpty ())
+      {
+        m_selection_line = -1;
+        m_selection_col = -1;
 
-void
-octave_qscintilla::show_selection_markers (int line, int col, int len)
-{
-  fillIndicatorRange (line, col - len, line, col, m_indicator_id);
+        m_selection_replacement = "";
+
+        clear_selection_markers ();
 
-  markerAdd (line, marker::selection);
-}
+        QToolTip::hideText ();
+      }
+    else
+      {
+        int pos;
+        get_current_position (&pos, &m_selection_line, &m_selection_col);
+      }
+  }
 
-void
-octave_qscintilla::contextmenu_help (bool)
-{
-  contextmenu_help_doc (false);
-}
+  void octave_qscintilla::show_selection_markers (int line, int col, int len)
+  {
+    fillIndicatorRange (line, col - len, line, col, m_indicator_id);
 
-void
-octave_qscintilla::contextmenu_doc (bool)
-{
-  contextmenu_help_doc (true);
-}
+    markerAdd (line, marker::selection);
+  }
+
+  void octave_qscintilla::contextmenu_help (bool)
+  {
+    contextmenu_help_doc (false);
+  }
 
-void
-octave_qscintilla::context_help_doc (bool documentation)
-{
-  if (get_actual_word ())
-    contextmenu_help_doc (documentation);
-}
+  void octave_qscintilla::contextmenu_doc (bool)
+  {
+    contextmenu_help_doc (true);
+  }
 
-void
-octave_qscintilla::contextmenu_edit (bool)
-{
-  emit context_menu_edit_signal (m_word_at_cursor);
-}
+  void octave_qscintilla::context_help_doc (bool documentation)
+  {
+    if (get_actual_word ())
+      contextmenu_help_doc (documentation);
+  }
 
-void
-octave_qscintilla::contextmenu_run (bool)
-{
-  QStringList commands = selectedText ().split (QRegExp ("[\r\n]"),
-                                                QString::SkipEmptyParts);
-  for (int i = 0; i < commands.size (); i++)
-    emit execute_command_in_terminal_signal (commands.at (i));
-}
+  void octave_qscintilla::contextmenu_edit (bool)
+  {
+    emit context_menu_edit_signal (m_word_at_cursor);
+  }
 
-// wrappers for dbstop related context menu items
+  void octave_qscintilla::contextmenu_run (bool)
+  {
+    QStringList commands = selectedText ().split (QRegExp ("[\r\n]"),
+                                                  QString::SkipEmptyParts);
+    for (int i = 0; i < commands.size (); i++)
+      emit execute_command_in_terminal_signal (commands.at (i));
+  }
 
-// FIXME: Why can't the data be sent as the argument to the function???
-void
-octave_qscintilla::contextmenu_break_condition (bool)
-{
+  // wrappers for dbstop related context menu items
+
+  // FIXME: Why can't the data be sent as the argument to the function???
+  void octave_qscintilla::contextmenu_break_condition (bool)
+  {
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-  QAction *action = qobject_cast<QAction *>(sender ());
-  QPoint local_pos = action->data ().value<QPoint> ();
+    QAction *action = qobject_cast<QAction *>(sender ());
+    QPoint local_pos = action->data ().value<QPoint> ();
 
-  // pick point just right of margins, so lineAt doesn't give -1
-  int margins = marginWidth (1) + marginWidth (2) + marginWidth (3);
-  local_pos = QPoint (margins + 1, local_pos.y ());
+    // pick point just right of margins, so lineAt doesn't give -1
+    int margins = marginWidth (1) + marginWidth (2) + marginWidth (3);
+    local_pos = QPoint (margins + 1, local_pos.y ());
 
-  emit context_menu_break_condition_signal (lineAt (local_pos));
+    emit context_menu_break_condition_signal (lineAt (local_pos));
 #endif
-}
+  }
 
-void
-octave_qscintilla::contextmenu_break_once (const QPoint& local_pos)
-{
+  void octave_qscintilla::contextmenu_break_once (const QPoint& local_pos)
+  {
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-  emit context_menu_break_once (lineAt (local_pos));
+    emit context_menu_break_once (lineAt (local_pos));
 #endif
-}
+  }
 
-void
-octave_qscintilla::text_changed (void)
-{
-  emit status_update (isUndoAvailable (), isRedoAvailable ());
-}
+  void octave_qscintilla::text_changed (void)
+  {
+    emit status_update (isUndoAvailable (), isRedoAvailable ());
+  }
 
-void
-octave_qscintilla::cursor_position_changed (int line, int col)
-{
-  // Clear the selection if we move away from it.  We have to check the
-  // position, because we allow entering text at the point of the
-  // selection to trigger a search and replace that does not clear the
-  // selection until it is complete.
+  void octave_qscintilla::cursor_position_changed (int line, int col)
+  {
+    // Clear the selection if we move away from it.  We have to check the
+    // position, because we allow entering text at the point of the
+    // selection to trigger a search and replace that does not clear the
+    // selection until it is complete.
 
-  if (! m_selection.isEmpty ()
-      && (line != m_selection_line || col != m_selection_col))
-    set_word_selection ();
-}
+    if (! m_selection.isEmpty ()
+        && (line != m_selection_line || col != m_selection_col))
+      set_word_selection ();
+  }
 
-// when edit area gets focus update information on undo/redo actions
-void octave_qscintilla::focusInEvent (QFocusEvent *focusEvent)
-{
-  emit status_update (isUndoAvailable (), isRedoAvailable ());
+  // when edit area gets focus update information on undo/redo actions
+  void octave_qscintilla::focusInEvent (QFocusEvent *focusEvent)
+  {
+    emit status_update (isUndoAvailable (), isRedoAvailable ());
 
-  QsciScintilla::focusInEvent (focusEvent);
-}
+    QsciScintilla::focusInEvent (focusEvent);
+  }
 
-void
-octave_qscintilla::show_replace_action_tooltip (void)
-{
-  int pos;
-  get_current_position (&pos, &m_selection_line, &m_selection_col);
+  void octave_qscintilla::show_replace_action_tooltip (void)
+  {
+    int pos;
+    get_current_position (&pos, &m_selection_line, &m_selection_col);
 
-  // Offer to replace other instances.
+    // Offer to replace other instances.
+
+    QKeySequence keyseq = Qt::SHIFT + Qt::Key_Return;
 
-  QKeySequence keyseq = Qt::SHIFT + Qt::Key_Return;
+    QString msg = (tr ("Press '%1' to replace all occurrences of '%2' with '%3'.")
+                   . arg (keyseq.toString ())
+                   . arg (m_selection)
+                   . arg (m_selection_replacement));
 
-  QString msg = (tr ("Press '%1' to replace all occurrences of '%2' with '%3'.")
-                 . arg (keyseq.toString ())
-                 . arg (m_selection)
-                 . arg (m_selection_replacement));
+    QPoint global_pos;
+    QPoint local_pos;
 
-  QPoint global_pos;
-  QPoint local_pos;
+    get_global_textcursor_pos (&global_pos, &local_pos);
+
+    QFontMetrics ttfm (QToolTip::font ());
 
-  get_global_textcursor_pos (&global_pos, &local_pos);
+    // Try to avoid overlapping with the text completion dialog
+    // and the text that is currently being edited.
 
-  QFontMetrics ttfm (QToolTip::font ());
+    global_pos += QPoint (2*ttfm.maxWidth (), -3*ttfm.height ());
+
+    QToolTip::showText (global_pos, msg);
+  }
 
-  // Try to avoid overlapping with the text completion dialog
-  // and the text that is currently being edited.
-
-  global_pos += QPoint (2*ttfm.maxWidth (), -3*ttfm.height ());
-
-  QToolTip::showText (global_pos, msg);
-}
+  void octave_qscintilla::keyPressEvent (QKeyEvent *key_event)
+  {
+    if (m_selection.isEmpty ())
+      QsciScintilla::keyPressEvent (key_event);
+    else
+      {
+        int key = key_event->key ();
+        Qt::KeyboardModifiers modifiers = key_event->modifiers ();
 
-void
-octave_qscintilla::keyPressEvent (QKeyEvent *key_event)
-{
-  if (m_selection.isEmpty ())
-    QsciScintilla::keyPressEvent (key_event);
-  else
-    {
-      int key = key_event->key ();
-      Qt::KeyboardModifiers modifiers = key_event->modifiers ();
+        if (key == Qt::Key_Return && modifiers == Qt::ShiftModifier)
+          {
+            // get the resulting cursor position
+            // (required if click was beyond a line ending)
+            int pos, line, col;
+            get_current_position (&pos, &line, &col);
 
-      if (key == Qt::Key_Return && modifiers == Qt::ShiftModifier)
-        {
-          // get the resulting cursor position
-          // (required if click was beyond a line ending)
-          int pos, line, col;
-          get_current_position (&pos, &line, &col);
+            // remember first visible line for restoring the view afterwards
+            int first_line = firstVisibleLine ();
 
-          // remember first visible line for restoring the view afterwards
-          int first_line = firstVisibleLine ();
+            // search for first occurrence of the detected word
+            bool find_result_available
+              = findFirst (m_selection,
+                           false,   // no regexp
+                           true,    // case sensitive
+                           true,    // whole words only
+                           false,   // do not wrap
+                           true,    // forward
+                           0, 0,    // from the beginning
+                           false
+#if defined (HAVE_QSCI_VERSION_2_6_0)
+                           , true
+#endif
+                           );
 
-          // search for first occurrence of the detected word
-          bool find_result_available
-            = findFirst (m_selection,
-                         false,   // no regexp
-                         true,    // case sensitive
-                         true,    // whole words only
-                         false,   // do not wrap
-                         true,    // forward
-                         0, 0,    // from the beginning
-                         false
-#if defined (HAVE_QSCI_VERSION_2_6_0)
-                         , true
-#endif
-                         );
+            while (find_result_available)
+              {
+                replace (m_selection_replacement);
 
-          while (find_result_available)
-            {
-              replace (m_selection_replacement);
+                // FIXME: is this the right thing to do?  findNext doesn't
+                // work properly if the length of the replacement text is
+                // different from the original.
 
-              // FIXME: is this the right thing to do?  findNext doesn't
-              // work properly if the length of the replacement text is
-              // different from the original.
-
-              int new_line, new_col;
-              get_current_position (&pos, &new_line, &new_col);
+                int new_line, new_col;
+                get_current_position (&pos, &new_line, &new_col);
 
-              find_result_available
-                = findFirst (m_selection,
-                             false,   // no regexp
-                             true,    // case sensitive
-                             true,    // whole words only
-                             false,   // do not wrap
-                             true,    // forward
-                             new_line, new_col,    // from new pos
-                             false
+                find_result_available
+                  = findFirst (m_selection,
+                               false,   // no regexp
+                               true,    // case sensitive
+                               true,    // whole words only
+                               false,   // do not wrap
+                               true,    // forward
+                               new_line, new_col,    // from new pos
+                               false
 #if defined (HAVE_QSCI_VERSION_2_6_0)
-                             , true
+                               , true
 #endif
-                             );
-            }
+                               );
+              }
 
-          // restore the visible area of the file, the cursor position,
-          // and the selection
-          setFirstVisibleLine (first_line);
-          setCursorPosition (line, col);
+            // restore the visible area of the file, the cursor position,
+            // and the selection
+            setFirstVisibleLine (first_line);
+            setCursorPosition (line, col);
 
-          // Clear the selection.
-          set_word_selection ();
-        }
-      else
-        {
-          // The idea here is to allow backspace to remove the last
-          // character of the replacement text to allow minimal editing
-          // and to also end the selection replacement action if text is
-          // not valid as a word constituent (control characters,
-          // etc.).  Is there a better way than having special cases for
-          // DEL and ESC here?
+            // Clear the selection.
+            set_word_selection ();
+          }
+        else
+          {
+            // The idea here is to allow backspace to remove the last
+            // character of the replacement text to allow minimal editing
+            // and to also end the selection replacement action if text is
+            // not valid as a word constituent (control characters,
+            // etc.).  Is there a better way than having special cases for
+            // DEL and ESC here?
 
-          QString text = key_event->text ();
+            QString text = key_event->text ();
 
-          bool cancel_replacement = false;
+            bool cancel_replacement = false;
 
-          if (key == Qt::Key_Backspace)
-            {
-              if (m_selection_replacement.isEmpty ())
-                cancel_replacement = true;
-              else
-                m_selection_replacement.chop (1);
-            }
-          else if (key == Qt::Key_Delete || key == Qt::Key_Escape)
-            cancel_replacement = true;
-          else if (! text.isEmpty ())
-            m_selection_replacement += text;
-          else if (modifiers != Qt::ShiftModifier)
-            cancel_replacement = true;
+            if (key == Qt::Key_Backspace)
+              {
+                if (m_selection_replacement.isEmpty ())
+                  cancel_replacement = true;
+                else
+                  m_selection_replacement.chop (1);
+              }
+            else if (key == Qt::Key_Delete || key == Qt::Key_Escape)
+              cancel_replacement = true;
+            else if (! text.isEmpty ())
+              m_selection_replacement += text;
+            else if (modifiers != Qt::ShiftModifier)
+              cancel_replacement = true;
 
-          // Perform default action.
+            // Perform default action.
 
-          QsciScintilla::keyPressEvent (key_event);
+            QsciScintilla::keyPressEvent (key_event);
 
-          if (cancel_replacement)
-            set_word_selection ();
+            if (cancel_replacement)
+              set_word_selection ();
 
-          if (! m_selection_replacement.isEmpty ())
-            show_replace_action_tooltip ();
-        }
-    }
-}
+            if (! m_selection_replacement.isEmpty ())
+              show_replace_action_tooltip ();
+          }
+      }
+  }
 
-void
-octave_qscintilla::auto_close (int auto_endif, int linenr,
-                               const QString& line, QString& first_word)
-{
-  // Insert and "end" for an "if" etc., if needed.
-  // (Use of "while" allows "return" to skip the rest.
-  // It may be clearer to use "if" and "goto",
-  // but that violates the coding standards.)
+  void octave_qscintilla::auto_close (int auto_endif, int linenr,
+                                      const QString& line, QString& first_word)
+  {
+    // Insert and "end" for an "if" etc., if needed.
+    // (Use of "while" allows "return" to skip the rest.
+    // It may be clearer to use "if" and "goto",
+    // but that violates the coding standards.)
 
-  bool autofill_simple_end = (auto_endif == 2);
+    bool autofill_simple_end = (auto_endif == 2);
 
-  size_t start = line.toStdString ().find_first_not_of (" \t");
+    size_t start = line.toStdString ().find_first_not_of (" \t");
 
-  // Check if following line has the same or less indentation
-  // Check if the following line does not start with
-  //       end* (until) (catch)
-  if (linenr < lines () - 1)
-    {
-      int offset = 1;
-      size_t next_start;
-      QString next_line;
-      do                            // find next non-blank line
-        {
-          next_line = text (linenr + offset++);
-          next_start = next_line.toStdString ().find_first_not_of (" \t\n");
-        }
-      while (linenr + offset < lines ()
-             && next_start == std::string::npos);
-      if (next_start == std::string::npos)
-        next_start = 0;
-      if (next_start > start)       // more indented => don't add "end"
-        return;
-      if (next_start == start)      // same => check if already is "end"
-        {
-          QRegExp rx_start = QRegExp (R"((\w+))");
-          int tmp = rx_start.indexIn (next_line, start);
-           if (tmp != -1 && is_end (rx_start.cap(1), first_word))
-             return;
-        }
-    }
+    // Check if following line has the same or less indentation
+    // Check if the following line does not start with
+    //       end* (until) (catch)
+    if (linenr < lines () - 1)
+      {
+        int offset = 1;
+        size_t next_start;
+        QString next_line;
+        do                            // find next non-blank line
+          {
+            next_line = text (linenr + offset++);
+            next_start = next_line.toStdString ().find_first_not_of (" \t\n");
+          }
+        while (linenr + offset < lines ()
+               && next_start == std::string::npos);
+        if (next_start == std::string::npos)
+          next_start = 0;
+        if (next_start > start)       // more indented => don't add "end"
+          return;
+        if (next_start == start)      // same => check if already is "end"
+          {
+            QRegExp rx_start = QRegExp (R"((\w+))");
+            int tmp = rx_start.indexIn (next_line, start);
+            if (tmp != -1 && is_end (rx_start.cap(1), first_word))
+              return;
+          }
+      }
 
     // If all of the above, insert a new line, with matching indent
     // and either 'end' or 'end...', depending on a flag.
 
     // If we insert directly after the last line, the "end" is autoindented,
     // so add a dummy line.
     if (linenr + 2 == lines ())
       insertAt (QString ("\n"), linenr + 2, 0);
@@ -977,11 +953,12 @@ octave_qscintilla::auto_close (int auto_
     else
       {
         if (first_word == "unwind_protect")
           first_word = '_' + first_word;
         next_line = "end" + first_word + "\n";
       }
 
     insertAt (QString (start, ' ') + next_line, linenr + 2, 0);
+  }
 }
 
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.h b/libgui/src/m-editor/octave-qscintilla.h
--- a/libgui/src/m-editor/octave-qscintilla.h
+++ b/libgui/src/m-editor/octave-qscintilla.h
@@ -27,95 +27,98 @@ along with Octave; see the file COPYING.
 
 #include <Qsci/qsciscintilla.h>
 
 #include <QContextMenuEvent>
 #include <QKeyEvent>
 #include <QLabel>
 #include <QMenu>
 
-class octave_qscintilla : public QsciScintilla
+namespace octave
 {
-  Q_OBJECT
+  class octave_qscintilla : public QsciScintilla
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  octave_qscintilla (QWidget *p);
+    octave_qscintilla (QWidget *p);
 
-  ~octave_qscintilla (void) = default;
+    ~octave_qscintilla (void) = default;
 
-  enum
-    {
-      ST_NONE = 0,
-      ST_LINE_COMMENT,
-      ST_BLOCK_COMMENT
-    };
+    enum
+      {
+        ST_NONE = 0,
+        ST_LINE_COMMENT,
+        ST_BLOCK_COMMENT
+      };
 
-  virtual void contextMenuEvent (QContextMenuEvent *e);
+    virtual void contextMenuEvent (QContextMenuEvent *e);
 
-  void context_help_doc (bool);
-  void context_edit (void);
-  void context_run (void);
-  void get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos);
-  bool get_actual_word (void);
-  void clear_selection_markers (void);
-  void get_current_position (int *pos, int *line, int *col);
-  QStringList comment_string (bool comment = true);
-  int get_style (int pos = -1);
-  int is_style_comment (int pos = -1);
-  void smart_indent (bool do_smart_indent, int do_auto_close, int line);
+    void context_help_doc (bool);
+    void context_edit (void);
+    void context_run (void);
+    void get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos);
+    bool get_actual_word (void);
+    void clear_selection_markers (void);
+    void get_current_position (int *pos, int *line, int *col);
+    QStringList comment_string (bool comment = true);
+    int get_style (int pos = -1);
+    int is_style_comment (int pos = -1);
+    void smart_indent (bool do_smart_indent, int do_auto_close, int line);
 
-  void smart_indent_line_or_selected_text (int lineFrom, int lineTo);
+    void smart_indent_line_or_selected_text (int lineFrom, int lineTo);
 
-  void set_word_selection (const QString& word = QString ());
+    void set_word_selection (const QString& word = QString ());
 
-  void show_selection_markers (int line, int col, int len);
+    void show_selection_markers (int line, int col, int len);
 
-  void set_selection_marker_color (const QColor& c);
+    void set_selection_marker_color (const QColor& c);
 
-signals:
+  signals:
 
-  void execute_command_in_terminal_signal (const QString&);
-  void create_context_menu_signal (QMenu*);
-  void context_menu_edit_signal (const QString&);
-  void qsci_has_focus_signal (bool);
-  void status_update (bool, bool);
-  void show_doc_signal (const QString&);
-  void context_menu_break_condition_signal (int);
-  void context_menu_break_once (int);
+    void execute_command_in_terminal_signal (const QString&);
+    void create_context_menu_signal (QMenu*);
+    void context_menu_edit_signal (const QString&);
+    void qsci_has_focus_signal (bool);
+    void status_update (bool, bool);
+    void show_doc_signal (const QString&);
+    void context_menu_break_condition_signal (int);
+    void context_menu_break_once (int);
+
+  private slots:
 
-private slots:
+    void contextmenu_help (bool);
+    void contextmenu_doc (bool);
+    void contextmenu_help_doc (bool);
+    void contextmenu_edit (bool);
+    void contextmenu_run (bool);
 
-  void contextmenu_help (bool);
-  void contextmenu_doc (bool);
-  void contextmenu_help_doc (bool);
-  void contextmenu_edit (bool);
-  void contextmenu_run (bool);
+    void contextmenu_break_condition (bool);
+    void contextmenu_break_once (const QPoint&);
 
-  void contextmenu_break_condition (bool);
-  void contextmenu_break_once (const QPoint&);
+    void text_changed (void);
+    void cursor_position_changed (int, int);
 
-  void text_changed (void);
-  void cursor_position_changed (int, int);
+  protected:
 
-protected:
+    void focusInEvent (QFocusEvent *focusEvent);
 
-  void focusInEvent (QFocusEvent *focusEvent);
+    void show_replace_action_tooltip (void);
 
-  void show_replace_action_tooltip (void);
+    void keyPressEvent (QKeyEvent *e);
 
-  void keyPressEvent (QKeyEvent *e);
+  private:
 
-private:
+    void auto_close (int auto_endif, int l,
+                     const QString& line, QString& first_word);
 
-  void auto_close (int auto_endif, int l,
-                   const QString& line, QString& first_word);
-
-  QString m_word_at_cursor;
+    QString m_word_at_cursor;
 
-  QString m_selection;
-  QString m_selection_replacement;
-  int m_selection_line;
-  int m_selection_col;
-  int m_indicator_id;
-};
+    QString m_selection;
+    QString m_selection_replacement;
+    int m_selection_line;
+    int m_selection_col;
+    int m_indicator_id;
+  };
+}
 
 #endif
diff --git a/libgui/src/m-editor/octave-txt-lexer.cc b/libgui/src/m-editor/octave-txt-lexer.cc
--- a/libgui/src/m-editor/octave-txt-lexer.cc
+++ b/libgui/src/m-editor/octave-txt-lexer.cc
@@ -27,30 +27,30 @@ along with Octave; see the file COPYING.
 #endif
 
 #if defined (HAVE_QSCINTILLA)
 
 #include <Qsci/qscilexer.h>
 
 #include "octave-txt-lexer.h"
 
-QString
-octave_txt_lexer::description (int style) const
+namespace octave
 {
-  if (style == 0)
-    return tr ("Default");
-  else
-    return QString ();
-};
+  QString octave_txt_lexer::description (int style) const
+  {
+    if (style == 0)
+      return tr ("Default");
+    else
+      return QString ();
+  };
 
-const char*
-octave_txt_lexer::language (void) const
-{
-  return "Text";
-}
+  const char * octave_txt_lexer::language (void) const
+  {
+    return "Text";
+  }
 
-const char*
-octave_txt_lexer::lexer (void) const
-{
-  return "text";
+  const char * octave_txt_lexer::lexer (void) const
+  {
+    return "text";
+  }
 }
 
 #endif
diff --git a/libgui/src/m-editor/octave-txt-lexer.h b/libgui/src/m-editor/octave-txt-lexer.h
--- a/libgui/src/m-editor/octave-txt-lexer.h
+++ b/libgui/src/m-editor/octave-txt-lexer.h
@@ -23,23 +23,25 @@ along with Octave; see the file COPYING.
 // Author: Torsten <ttl@justmail.de>
 
 #if ! defined (octave_octave_txt_lexer_h)
 #define octave_octave_txt_lexer_h 1
 
 #include <Qsci/qsciscintilla.h>
 #include <Qsci/qscilexer.h>
 
-
-class octave_txt_lexer : public QsciLexer
+namespace octave
 {
-  Q_OBJECT
+  class octave_txt_lexer : public QsciLexer
+  {
+    Q_OBJECT
 
-public:
+  public:
 
-  virtual const char * language (void) const;
+    virtual const char * language (void) const;
+
+    virtual const char * lexer (void) const;
 
-  virtual const char * lexer (void) const;
-
-  virtual QString description (int style) const;
-};
+    virtual QString description (int style) const;
+  };
+}
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -67,21 +67,21 @@ along with Octave; see the file COPYING.
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "oct-map.h"
 #include "octave.h"
 #include "symscope.h"
 #include "utils.h"
 #include "version.h"
 
-static file_editor_interface *
+static octave::file_editor_interface *
 create_default_editor (QWidget *p)
 {
 #if defined (HAVE_QSCINTILLA)
-  return new file_editor (p);
+  return new octave::file_editor (p);
 #else
   octave_unused_parameter (p);
 
   return 0;
 #endif
 }
 
 namespace octave
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -632,17 +632,17 @@ settings_dialog::settings_dialog (QWidge
   lexer = new QsciLexerDiff ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
 
   lexer = new QsciLexerBash ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
 
-  lexer = new octave_txt_lexer ();
+  lexer = new octave::octave_txt_lexer ();
   read_lexer_settings (ui, lexer, settings);
   delete lexer;
 
 #endif
 
   // which tab is the desired one?
   show_tab (desired_tab);
 
@@ -931,17 +931,17 @@ settings_dialog::write_changed_settings 
   lexer = new QsciLexerDiff ();
   write_lexer_settings (ui, lexer, settings);
   delete lexer;
 
   lexer = new QsciLexerBash ();
   write_lexer_settings (ui, lexer, settings);
   delete lexer;
 
-  lexer = new octave_txt_lexer ();
+  lexer = new octave::octave_txt_lexer ();
   write_lexer_settings (ui, lexer, settings);
   delete lexer;
 
 #endif
 
   // Workspace
   write_workspace_colors (settings);
   // hide tool tips
