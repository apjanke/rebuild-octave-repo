# HG changeset patch
# User jwe
# Date 892059664 0
#      Wed Apr 08 18:21:04 1998 +0000
# Node ID 7c96e85c76db275ded2b76a6a40b241b6ae5177a
# Parent  2837d1701fd9fe30969ef0c55bfd5621a2300bdb
[project @ 1998-04-08 18:19:35 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,10 +1,21 @@
+Fri Mar 27 02:54:59 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* aclocal.m4 (OCTAVE_F2C_F77_COMPAT): Use a Fortran subroutine
+	instead of a function.
+
+Tue Mar 10 17:28:20 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in (RLD_FLAG): Use $(octlibdir), not $(libdir).
+
 Mon Mar  2 00:02:26 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* install-octave.in: Explicitly set permissions on ls-R files.
+
 	* configure.in: Don't disable GNU Info on cygwin32 systems.
 
 	* install-octave.in: New file.
 	* configure.in: Create install-octave.
 	* octMakefile.in (distclean, maintainer-clean): Delete install-octave.
 	(DISTFILES): Distribute install-octave.in, not install-octave.
 
 Sun Mar  1 23:15:04 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
diff --git a/PROJECTS b/PROJECTS
--- a/PROJECTS
+++ b/PROJECTS
@@ -1,8 +1,10 @@
+<html>
+<pre>
 Octave PROJECTS                                          -*- text -*-
 ===============
 
 Check with bug-octave@bevo.che.wisc.edu for a possibly more current
 copy.  Also, if you start working steadily on a project, please let
 bug-octave@bevo.che.wisc.edu know.  We might have information that
 could help you; we'd also like to send you the GNU coding standards.
 
@@ -244,16 +246,27 @@ Input/Output:
     together, similar to the way iostreams can be tied together.
 
   * Allow comments in number-only data files.
 
 -----------
 Interpreter:
 -----------
 
+  * Allow customization of the debug prompt.
+
+  * For the keyboard function, parse return (or quit) more
+    intelligently so that something like
+
+      debug> x = 1; return
+
+    will work as expected.
+
+  * Warn about M-files with timestamps in the future.
+
   * Fix the parser so that
 
       function foo ()
         implicit_str_to_num_ok = 1;
         '#' + 0;
       endfunction
 
     succeeds, even when implicit_str_to_num_ok is 0 at the time the
@@ -351,16 +364,19 @@ Interpreter:
   * Is it necessary for do_binary_op and do_unary_op to be friends of
     the tree_constant class.
 
   * Clean up symtab and variable stuff.
 
   * Input stream class for parser files -- must manage buffers for
     flex and context for global variable settings.
 
+  * make parser do more semantic checking, continue after errors when
+    compiling functions, etc.
+
   * Make LEXICAL_ERROR have a value that is the error message for
     parse_error() to print?
 
   * Make it possible to clear dynamically loaded functions.
 
   * Add a run-time alias mechanism that would allow things like
 
       alias fun function_with_a_very_long_name 
@@ -747,8 +763,10 @@ Miscellaneous:
 
 ------
 Always:
 ------
 
   * Squash bugs.
 
 				--30--
+</pre>
+</html>
diff --git a/aclocal.m4 b/aclocal.m4
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -355,42 +355,48 @@ if test "$cross_compiling" = yes; then
   else
     AC_MSG_WARN([assuming ${F77-f77} cross compiler is f2c compatible])
   fi
 else
   AC_CACHE_CHECK([$F77/f2c compatibility], octave_cv_f2c_f77_compat,
   [trap 'rm -f ftest* ctest* core; exit 1' 1 3 15
   octave_cv_f2c_f77_compat=no
   cat > ftest.f <<EOF
-      INTEGER FUNCTION FORSUB (C, D)
+      SUBROUTINE FORSUB (C, I, D)
       CHARACTER *(*) C
-      INTEGER L
+      INTEGER L, I
       DOUBLE PRECISION D
       L = LEN (C)
       WRITE (*, '(A,1X,I2)') C(1:L), INT (D)
-      FORSUB = 1
+      I = 0
       RETURN
       END
 EOF
   ${F77-f77} -c ftest.f 1>&AC_FD_CC 2>&AC_FD_CC
   changequote(, )
   cat > ctest.c <<EOF
 #include "confdefs.h"
+#ifdef F77_APPEND_UNDERSCORE
+extern int forsub_ (const char*, int*, double*, long int);
+#else
+extern int forsub (const char*, int*, double*, long int);
+#endif
 static char s[14];
 int main ()
 {
   double d = 10.0;
-  int len;
+  int len, i = 1;
   strcpy (s, "FOO-I-HITHERE");
   len = strlen (s);
 #ifdef F77_APPEND_UNDERSCORE
-  return (! forsub_ (s, &d, len));
+  forsub_ (s, &i, &d, len);
 #else
-  return (! forsub (s, &d, len));
+  forsub (s, &i, &d, len);
 #endif
+  return i;
 }
 #if defined (sun)
 int MAIN_ () { return 0; }
 #elif defined (linux) && defined (__ELF__)
 int MAIN__ () { return 0; }
 #endif
 EOF
   changequote([, ])
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -16,17 +16,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
-AC_REVISION($Revision: 1.301 $)
+AC_REVISION($Revision: 1.302 $)
 AC_PREREQ(2.9)
 AC_INIT(src/octave.cc)
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1)
 
 OCTAVE_HOST_TYPE
 
@@ -545,23 +545,23 @@ case "$canonical_host_type" in
     SH_LDFLAGS=-Bshareable
   ;;
   alpha*-dec-osf*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
     SH_LDFLAGS="-shared -Xlinker -expect_unresolved -Xlinker '*'"
     SONAME_FLAGS='-Xlinker -soname -Xlinker $@'
-    RLD_FLAG='-Xlinker -rpath -Xlinker $(libdir)'
+    RLD_FLAG='-Xlinker -rpath -Xlinker $(octlibdir)'
   ;;
 changequote(,)dnl
   i[3456789]86-*-linux*)
 changequote([,])dnl
     SONAME_FLAGS='-Xlinker -soname -Xlinker $@'
-    RLD_FLAG='-Xlinker -rpath -Xlinker $(libdir)'
+    RLD_FLAG='-Xlinker -rpath -Xlinker $(octlibdir)'
   ;;
 changequote(,)dnl
   i[3456]86-*-sco3.2v5*)
 changequote([,])dnl
     SH_LDFLAGS=-G
   ;;
   rs6000-ibm-aix* | powerpc-ibm-aix*)
     CPICFLAG=
@@ -572,41 +572,41 @@ changequote([,])dnl
   hppa*-hp-hpux*)
     if test "$octave_cv_f77_is_g77" = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=+Z
     fi
     SHLEXT=sl
     SH_LDFLAGS="-shared -fPIC"
-    RLD_FLAG='-Xlinker +b -Xlinker $(libdir)'
+    RLD_FLAG='-Xlinker +b -Xlinker $(octlibdir)'
   ;;
   *-sgi-*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
-    RLD_FLAG='-L$(libdir)'
+    RLD_FLAG='-L$(octlibdir)'
   ;;
   sparc-sun-sunos4*)
     if test "$octave_cv_f77_is_g77" = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=-PIC
     fi
     SH_LD=ld
     SH_LDFLAGS="-assert nodefinitions"
-    RLD_FLAG='-L$(libdir)'
+    RLD_FLAG='-L$(octlibdir)'
   ;;
   sparc-sun-solaris2*)
     if test "$octave_cv_f77_is_g77" = yes; then
       FPICFLAG=-fPIC
     else
       FPICFLAG=-PIC
     fi
-    RLD_FLAG='-Xlinker -R -Xlinker $(libdir)'
+    RLD_FLAG='-Xlinker -R -Xlinker $(octlibdir)'
   ;;
 esac
 
 if $use_rpath; then
   true
 else
   RLD_FLAG=
 fi
diff --git a/doc/interpreter/basics.texi b/doc/interpreter/basics.texi
--- a/doc/interpreter/basics.texi
+++ b/doc/interpreter/basics.texi
@@ -107,17 +107,17 @@ remote shell command or inside an Emacs 
 to run Octave within Emacs, see @ref{Emacs}.
 
 @item --no-init-file
 @cindex @code{--no-init-file}
 Don't read the @file{~/.octaverc} or @file{.octaverc} files.
 
 @item --no-line-editing
 @cindex @code{--no-line-editing}
-Disable command-line editing and history.
+Disable command-line editing.
 
 @item --no-site-file
 @cindex @code{--no-site-file}
 Don't read the site-wide @file{octaverc} file.
 
 @item --norc
 @itemx -f
 @cindex @code{--norc}
@@ -937,17 +937,17 @@ parse error:
 For most parse errors, Octave uses a caret (@samp{^}) to mark the point
 on the line where it was unable to make sense of your input.  In this
 case, Octave generated an error message because the keyword
 @code{function} was misspelled.  Instead of seeing @samp{function f},
 Octave saw two consecutive variable names, which is invalid in this
 context.  It marked the error at the @code{y} because the first name by
 itself was accepted as valid input.
 
-Another class of error message occurs occurs at evaluation time.  These
+Another class of error message occurs at evaluation time.  These
 errors are called @dfn{run-time errors}, or sometimes
 @dfn{evaluation errors} because they occur when your program is being
 @dfn{run}, or @dfn{evaluated}.  For example, if after correcting the
 mistake in the previous function definition, you type
 
 @example
 octave:13> f ()
 @end example
diff --git a/doc/interpreter/expr.texi b/doc/interpreter/expr.texi
--- a/doc/interpreter/expr.texi
+++ b/doc/interpreter/expr.texi
@@ -176,17 +176,17 @@ If @code{prefer_column_vectors} is nonze
 @example
 for i = 1:10
   a (i) = i;
 endfor
 @end example
 
 @noindent
 (for @code{a} previously  undefined) produce column vectors.  Otherwise, row
-vectors are preferred.  The default value is 0.
+vectors are preferred.  The default value is 1.
 
 If a variable is already defined to be a vector (a matrix with a single
 row or column), the original orientation is respected, regardless of the
 value of @code{prefer_column_vectors}.
 @end defvr
 
 @defvr {Built-in Variable} resize_on_range_error
 If the value of @code{resize_on_range_error} is nonzero, expressions
diff --git a/doc/interpreter/var.texi b/doc/interpreter/var.texi
--- a/doc/interpreter/var.texi
+++ b/doc/interpreter/var.texi
@@ -464,17 +464,17 @@ Default value: 5.
 @item page_screen_output
 @xref{Input and Output}.
 
 Default value: 1.
 
 @item prefer_column_vectors
 @xref{Index Expressions}.
 
-Default value: 0.
+Default value: 1.
 
 @item print_answer_id_name
 @xref{Terminal Output}.
 
 Default value: 1.
 
 @item print_empty_dimensions
 @xref{Empty Matrices}.
diff --git a/examples/oregonator.cc b/examples/oregonator.cc
--- a/examples/oregonator.cc
+++ b/examples/oregonator.cc
@@ -1,14 +1,19 @@
 #include <octave/oct.h>
 
-#include <iostream.h>
-
 DEFUN_DLD (oregonator, args, ,
-  "The `oregonator'.")
+  "The `oregonator'.\n\
+\n\
+Reference:\n\
+\n\
+  Oscillations in chemical systems.  IV.  Limit cycle behavior in a\n\
+  model of a real chemical reaction. Richard J. Field and Richard\n\
+  M. Noyes, The Journal of Chemical Physics, Volume 60 Number 5,\n\
+  March 1974.")
 {
   ColumnVector dx (3);
 
   ColumnVector x = args(0).vector_value ();
 
   dx(0) = 77.27 * (x(1) - x(0)*x(1) + x(0) - 8.375e-06*pow (x(0), 2));
   dx(1) = (x(2) - x(0)*x(1) - x(1)) / 77.27;
   dx(2) = 0.161*(x(0) - x(2));
diff --git a/examples/oregonator.m b/examples/oregonator.m
--- a/examples/oregonator.m
+++ b/examples/oregonator.m
@@ -1,9 +1,16 @@
 ## The `oregonator'.
+##
+## Reference:
+##
+##   Oscillations in chemical systems.  IV.  Limit cycle behavior in a
+##   model of a real chemical reaction. Richard J. Field and Richard
+##   M. Noyes, The Journal of Chemical Physics, Volume 60 Number 5,
+##   March 1974.
 
 function dx = oregonator (x, t)
 
   dx = zeros (3, 1);
 
   dx(1) = 77.27*(x(2) - x(1)*x(2) + x(1) - 8.375e-06*x(1)^2);
   dx(2) = (x(3) - x(1)*x(2) - x(2)) / 77.27;
   dx(3) = 0.161*(x(1) - x(3));
diff --git a/install-octave.in b/install-octave.in
--- a/install-octave.in
+++ b/install-octave.in
@@ -274,19 +274,21 @@ cd $distdir
 echo "installing image files in $imagedir"
 cd scripts/image
 cp *.img $imagedir
 chmod 644 $imagedir/*.img
 cd $distdir
 
 echo "creating ls-R file in $datadir/octave"
 ls -LR $datadir/octave > $datadir/octave/ls-R
+chmod 644 $datadir/octave/ls-R
 
 echo "creating ls-R file in $libexecdir/octave"
 ls -LR $libexecdir/octave > $libexecdir/octave/ls-R
+chmod 644 $libexecdir/octave/ls-R
 
 echo "installing info files in $infodir"
 for f in doc/interpreter/octave.info*
 do
   file=`basename $f`
   cp $f $infodir/$file
   chmod 644 $infodir/$file
 done
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,12 @@
+Mon Apr  6 00:26:35 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* slatec-fn/xdgami.f (xdgami): Reorder args to match dgami.
+
 Thu Feb 19 21:00:00 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* specfun/ribesl.f, specfun/rjbesl.f: Compute NSIG correctly.
 	Add missing comma in declaration statement.
 
 Sun Feb  1 12:39:10 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (install, uninstall): Use $(octlibdir), not $(libdir).
diff --git a/libcruft/slatec-fn/xdgami.f b/libcruft/slatec-fn/xdgami.f
--- a/libcruft/slatec-fn/xdgami.f
+++ b/libcruft/slatec-fn/xdgami.f
@@ -1,5 +1,5 @@
-      subroutine xdgami (x, a, result)
-      double precision x, a, result, dgami
-      result = dgami (x, a)
+      subroutine xdgami (a, x, result)
+      double precision a, x, result, dgami
+      result = dgami (a, x)
       return
       end
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,12 @@
+Mon Apr  6 00:27:06 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* lo-specfun.cc (gammainc): Reorder args in call to xdgami.
+
 Thu Feb 19 01:16:38 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* lo-specfun.cc (xgamma, xlgamma): Define here.
 	* lo-mappers.cc: Not here.
 
 	* lo-specfun.h: Declare xgamma and xlgamma here.
 	* lo-mappers.h: Not here.
 
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -471,17 +471,17 @@ betainc (const Matrix& x, const Matrix& 
 
   return retval;
 }
 
 double
 gammainc (double x, double a)
 {
   double retval;
-  F77_XFCN (xdgami, XDGAMI, (x, a, retval));
+  F77_XFCN (xdgami, XDGAMI, (a, x, retval));
   return retval;
 }
 
 Matrix
 gammainc (double x, const Matrix& a)
 {
   int nr = a.rows ();
   int nc = a.cols ();
diff --git a/readline/ChangeLog b/readline/ChangeLog
--- a/readline/ChangeLog
+++ b/readline/ChangeLog
@@ -1,8 +1,13 @@
+Wed Mar  4 14:59:11 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* parens.c (rl_insert_close): Make time delay for showing matching
+	parentheses 0.5 seconds.
+
 Sun Jan 25 02:19:15 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* aclocal.m4 (BASH_REINSTALL_SIGHANDLERS, BASH_FUNC_STRCOLL):
 	Provide defaults for cross compiling.
 
 Fri Jan 16 21:02:58 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (install, uninstall): For Octave, do nothing.
diff --git a/readline/parens.c b/readline/parens.c
--- a/readline/parens.c
+++ b/readline/parens.c
@@ -96,18 +96,18 @@ rl_insert_close (count, invoking_key)
 	find_matching_open (rl_line_buffer, rl_point - 2, invoking_key);
 
       /* Emacs might message or ring the bell here, but I don't. */
       if (match_point < 0)
 	return -1;
 
       FD_ZERO (&readfds);
       FD_SET (fileno (rl_instream), &readfds);
-      timer.tv_sec = 1;
-      timer.tv_usec = 500;
+      timer.tv_sec = 0;
+      timer.tv_usec = 500000;
 
       orig_point = rl_point;
       rl_point = match_point;
       (*rl_redisplay_function) ();
       ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
       rl_point = orig_point;
 #else /* !HAVE_SELECT */
       rl_insert (count, invoking_key);
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,30 @@
+Wed Apr  8 13:17:58 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* plot/__pltopt1.m__: New file.
+	* plot/__pltopt.m__: Handle opt as a string array by calling
+	__pltopt1__ multiple times and returning a string array with rows
+	corresponding to the rows of opt.
+	* plot/__plt2ss__.m, plot/__plt2vv__.m, plot/__plt2vm__.m,
+	plot/__plt2mv__.m, plot/__plt2mm__.m: Handle fmt as a string
+	array.
+
+Fri Mar 27 03:00:40 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* plot/mplot.m: Fix misspellings of global variables.
+	Don't call clearplot.
+
+Tue Mar 17 17:45:25 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* plot/subplot.m, plot/multiplot.m: Set gnuplot_command_replot to
+	"cle;rep" when going in ot multiplot mode.
+	* plot/oneplot.m: Reset gnuplot_command_replot to "rep" when
+	switching out of multiplot mode.
+
 Fri Feb 20 01:31:32 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* plot/mplot.m, plot/subplot.m, plot/oneplot.m, plot/multiplot.m,
 	plot/subwindow.m: Call clearplot after setting up multiplot mode.
 
 Tue Feb  3 00:18:40 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* special-matrix/sylvester_matrix.m: Rename from hadamard.m
diff --git a/scripts/plot/__plt2mm__.m b/scripts/plot/__plt2mm__.m
--- a/scripts/plot/__plt2mm__.m
+++ b/scripts/plot/__plt2mm__.m
@@ -20,29 +20,39 @@
 ## Author: jwe
 
 function __plt2mm__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3)
     msg = sprintf ("__plt2mm__ (x, y)\n");
     msg = sprintf ("%s              __plt2mm__ (x, y, fmt)", msg);
     usage (msg);
-  elseif (nargin == 2)
-    fmt = "";
+  elseif (nargin == 2 || fmt == "")
+    fmt = " ";  ## Yes, this is intentionally not an empty string!
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
+  k = 1;
+  fmt_nr = rows (fmt);
   if (x_nr == y_nr && x_nc == y_nc)
     if (x_nc > 0)
       tmp = [x, y];
-      cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1, fmt);
+      cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1,
+		     deblank (fmt (k, :)));
+      if (k < fmt_nr)
+      	k++;
+      endif
       for i = 2:x_nc
-        cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, i, x_nc, x_nc+i, fmt);
+        cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, i, x_nc, x_nc+i,
+		       deblank (fmt (k, :)));
+	if (k < fmt_nr)
+	  k++;
+	endif
       endfor
       eval (cmd);
     else
       error ("__plt2mm__: arguments must be a matrices");
     endif
   else
     error ("__plt2mm__: matrix dimensions must match");
   endif
diff --git a/scripts/plot/__plt2mv__.m b/scripts/plot/__plt2mv__.m
--- a/scripts/plot/__plt2mv__.m
+++ b/scripts/plot/__plt2mv__.m
@@ -16,22 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Author: jwe
 
 function __plt2mv__ (x, y, fmt)
 
+  keyboard
   if (nargin < 2 || nargin > 3)
     msg = sprintf ("__plt2mv__ (x, y)\n");
     msg = sprintf ("%s              __plt2mv__ (x, y, fmt)", msg);
     usage (msg);
-  elseif (nargin == 2)
-    fmt = "";
+  elseif (nargin == 2 || fmt == "")
+    fmt = " ";  ## Yes, this is intentionally not an empty string!
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (y_nr == 1)
     y = y';
     tmp = y_nr;
@@ -45,20 +46,31 @@ function __plt2mv__ (x, y, fmt)
     x = x';
     tmp = x_nr;
     x_nr = x_nc;
     x_nc = tmp;
   else
     error ("__plt2mv__: matrix dimensions must match");
   endif
 
+  k = 1;
+  fmt_nr = rows (fmt);
   if (x_nc > 0)
     tmp = [x, y];
-    cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1, fmt);
+    keyboard
+    cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1,
+		   deblank (fmt (k, :)));
+    if (k < fmt_nr)
+      k++;
+    endif
     for i = 2:x_nc
-      cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, i, x_nc-i+1, x_nc+1, fmt);
+      cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, i, x_nc-i+1, x_nc+1,
+		     deblank (fmt (k, :)));
+      if (k < fmt_nr)
+      	k++;
+      endif
     endfor
     eval (cmd);
   else
     error ("__plt2mv__: arguments must be a matrices");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2ss__.m b/scripts/plot/__plt2ss__.m
--- a/scripts/plot/__plt2ss__.m
+++ b/scripts/plot/__plt2ss__.m
@@ -22,16 +22,18 @@
 function __plt2ss__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3)
     msg = sprintf ("__plt2ss__ (x, y)");
     msg = sprintf ("%s              __plt2ss__ (x, y, fmt)", msg);
     usage (msg);
   elseif (nargin == 2)
     fmt = "";
+  elseif (rows (fmt) > 1)
+    fmt = fmt (1, :);
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1 && x_nr == y_nr && x_nc == 1 && x_nc == y_nc)
     tmp = [x, y];
     cmd = sprintf ("gplot tmp %s", fmt);
diff --git a/scripts/plot/__plt2vm__.m b/scripts/plot/__plt2vm__.m
--- a/scripts/plot/__plt2vm__.m
+++ b/scripts/plot/__plt2vm__.m
@@ -20,18 +20,18 @@
 ## Author: jwe
 
 function __plt2vm__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3)
     msg = sprintf ("__plt2vm__ (x, y)\n");
     msg = sprintf ("%s              __plt2vm__ (x, y, fmt)", msg);
     usage (msg);
-  elseif (nargin == 2)
-    fmt = "";
+  elseif (nargin == 2 || fmt == "")
+    fmt = " ";  ## Yes, this is intentionally not an empty string!
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1)
     x = x';
     tmp = x_nr;
@@ -45,20 +45,30 @@ function __plt2vm__ (x, y, fmt)
     y = y';
     tmp = y_nr;
     y_nr = y_nc;
     y_nc = tmp;
   else
     error ("__plt2vm__: matrix dimensions must match");
   endif
 
+  k = 1;
+  fmt_nr = rows (fmt);
   if (y_nc > 0)
     tmp = [x, y];
-    cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1, fmt);
+    cmd = sprintf ("gplot tmp(:,%d:%d:%d) %s", 1, x_nc, x_nc+1,
+		   deblank (fmt (k, :)));
+    if (k < fmt_nr)
+      k++;
+    endif
     for i = 2:y_nc
-      cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, 1, i, i+1, fmt);
+      cmd = sprintf ("%s, tmp(:,%d:%d:%d) %s", cmd, 1, i, i+1,
+		     deblank (fmt (k, :)));
+      if (k < fmt_nr)
+      	k++;
+      endif
     endfor
     eval (cmd);
   else
     error ("__plt2vm__: arguments must be a matrices");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2vv__.m b/scripts/plot/__plt2vv__.m
--- a/scripts/plot/__plt2vv__.m
+++ b/scripts/plot/__plt2vv__.m
@@ -22,16 +22,18 @@
 function __plt2vv__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3)
     msg = sprintf ("__plt2vv__ (x, y)\n");
     msg = sprintf ("%s              __plt2vv__ (x, y, fmt)", msg);
     usage (msg);
   elseif (nargin == 2)
     fmt = "";
+  elseif (rows (fmt) > 1)
+    fmt = fmt (1, :);
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1)
     x = x';
     tmp = x_nr;
diff --git a/scripts/plot/__pltopt1__.m b/scripts/plot/__pltopt1__.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/__pltopt1__.m
@@ -0,0 +1,217 @@
+## Copyright (C) 1996, 1997 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 2, or (at your option)
+## any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, write to the Free
+## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+## 02111-1307, USA.
+
+## usage: fmt = __pltopt1__ (caller, opt)
+##
+## Really decode plot option strings.
+##
+## See also: __pltopt__
+
+## Author: Rick Niles <niles@axp745.gsfc.nasa.gov>
+## Adapted-By: jwe
+## Maintainer: jwe
+
+function fmt = __pltopt1__ (caller, opt)
+
+  set_color = 0;
+  set_symbol = 0;
+  set_lines = 0;
+  set_dots = 0;
+  set_points = 0;
+  set_impulses = 0;
+  set_steps = 0;
+  set_boxes = 0;
+  set_errbars = 0;
+  set_key = 0;
+  more_opts = 1;
+
+  WITH = "w";
+  LINES = "l";
+  LINESPOINTS = "linesp";
+  BOXERRORBARS = "boxer";
+  BOXES = "boxes";
+  POINTS = "p";
+  DOTS = "d";
+  IMPULSES = "i";
+  STEPS = "s";
+  ERRORBARS = "e";
+  TITLE = "title";
+
+  if (nargin != 2)
+    usage ("__pltopt1__ (opt)");
+  endif
+
+  if (! isstr (opt))
+    error ("__pltopt1__: argument must be a string");
+  endif
+
+  while (more_opts)
+
+    ## First get next char.
+
+    if (max (size (opt)) > 1)
+#      [char, opt] = sscanf (opt, "%c %s", "C");
+       char = opt(1);
+       opt = opt(2:length(opt));
+    else
+      char = opt;
+      more_opts = 0;
+    endif
+
+    ## Now set flags based on char.
+
+    if (strcmp (char, "-"))
+      set_lines = 1;
+    elseif (strcmp (char, "."))
+      set_dots  = 1;
+    elseif (strcmp (char, "@"))
+      set_points = 1;
+    elseif (strcmp (char, "^"))
+      set_impulses = 1;
+    elseif (strcmp (char, "L"))
+      set_steps = 1;
+    elseif (strcmp (char, "~"))
+      set_errbars = 1;
+    elseif (strcmp (char, "#"))
+      set_boxes = 1;
+    elseif (strcmp (char, "0") || strcmp (char, "1") ...
+            || strcmp (char, "2") || strcmp (char, "3") ...
+            || strcmp (char, "4") || strcmp (char, "5") ...
+            || strcmp (char, "6") || strcmp (char, "7") ...
+            || strcmp (char, "8") || strcmp (char, "9"))
+      if (set_color)
+	set_points = 1;
+	symbol = char;
+	set_symbol = 1;
+      else
+	color = char;
+	set_color = 1;
+      endif
+    elseif (strcmp (char, "r"))
+      set_color = 1;
+      color = "1";
+    elseif (strcmp (char, "g"))
+      set_color = 1;
+      color = "2";
+    elseif (strcmp (char, "b"))
+      set_color = 1;
+      color = "3";
+    elseif (strcmp (char, "m"))
+      set_color = 1;
+      color = "4";
+    elseif (strcmp (char, "c"))
+      set_color = 1;
+      color = "5";
+    elseif (strcmp (char, "w"))
+      set_color = 1;
+      color = "6";
+    elseif (strcmp (char, "*"))
+      set_points = 1;
+      set_symbol = 1;
+      symbol = "6";
+    elseif (strcmp (char, "+"))
+      set_points = 1;
+      set_symbol = 1;
+      symbol = "2";
+    elseif (strcmp (char, "o"))
+      set_points = 1;
+      set_symbol = 1;
+      symbol = "1";
+    elseif (strcmp (char, "x"))
+      set_points = 1;
+      set_symbol = 1;
+      symbol = "4";
+    elseif (strcmp (char, ";"))  # title mode.
+      set_key = 1;
+      working = 1;
+      key_title = ""; 
+      while (working)
+        if (max (size (opt)) > 1)
+	  char = opt(1);
+	  opt = opt(2:length(opt));
+        else
+	  char = opt;
+	  if (! strcmp (char, ";"))
+            error ("%s: unfinished key label", caller);
+          end
+          more_opts = 0;
+          working = 0;
+        endif
+        if strcmp (char, ";")
+          working = 0;
+        else
+	  if (isempty (key_title))  # needs this to avoid empty matrix warning.
+            key_title = char;
+	  else
+            key_title = strcat (key_title, char);
+	  endif
+        endif
+      endwhile
+    elseif (strcmp (char, " ")) 
+      ## whitespace -- do nothing.
+    else
+      error ("%s: unrecognized format character: '%s'", caller, char);
+    endif
+  endwhile
+
+  ## Now create format string.
+
+  fmt = WITH;
+
+  if (set_lines)
+    if (set_points)
+      fmt = strcat (fmt, " ", LINESPOINTS);
+    else
+      fmt = strcat (fmt, " ", LINES);
+    endif
+  elseif (set_boxes)
+    if (set_errbars)
+      fmt = strcat (fmt, " ", BOXERRORBARS);
+    else
+      fmt = strcat (fmt, " ", BOXES);
+    endif
+  elseif (set_points)
+    fmt = strcat (fmt, " ", POINTS);
+  elseif (set_dots)
+    fmt = strcat (fmt, " ", DOTS);
+  elseif (set_impulses)
+    fmt = strcat (fmt, " ", IMPULSES);
+  elseif (set_steps)
+    fmt = strcat (fmt, " ", STEPS);
+  elseif (set_errbars)
+    fmt = strcat (fmt, " ", ERRORBARS);
+  endif
+
+  if (strcmp (fmt, WITH))
+    fmt = strcat (fmt, " ", LINES);
+  endif
+
+  if (set_color)
+    fmt = strcat (fmt, " ", color);
+    if (set_symbol)
+      fmt = strcat (fmt, " ", symbol);
+    endif
+  elseif (set_symbol)
+    fmt = strcat (fmt, " 1 ", symbol);
+  endif
+
+  if (set_key)
+    fmt = sprintf ("%s %s \"%s\" ", fmt, TITLE, key_title);
+  endif
+endfunction
diff --git a/scripts/plot/__pltopt__.m b/scripts/plot/__pltopt__.m
--- a/scripts/plot/__pltopt__.m
+++ b/scripts/plot/__pltopt__.m
@@ -55,201 +55,29 @@
 ##          x11       postscript  postscript      x11         postscript   
 ##   =====================================================================
 ##     1    red       green       solid           "o"         "+"         
 ##     2    green     blue        long dash       "+"         "x"         
 ##     3    blue      red         short dash     square       "*"         
 ##     4    magenta   magenta     dotted          "x"        open square  
 ##     5    cyan      cyan        dot long dash  triangle    filled square
 ##     6    brown     yellow      dot short dash  "*"         "o"         
+##
+## See also: __pltopt1__
 
-## Author: Rick Niles <niles@axp745.gsfc.nasa.gov>
+## Author: jwe
 ## Adapted-By: jwe
 ## Maintainer: jwe
 
 function fmt = __pltopt__ (caller, opt)
 
-  set_color = 0;
-  set_symbol = 0;
-  set_lines = 0;
-  set_dots = 0;
-  set_points = 0;
-  set_impulses = 0;
-  set_steps = 0;
-  set_boxes = 0;
-  set_errbars = 0;
-  set_key = 0;
-  more_opts = 1;
-
-  WITH = "w";
-  LINES = "l";
-  LINESPOINTS = "linesp";
-  BOXERRORBARS = "boxer";
-  BOXES = "boxes";
-  POINTS = "p";
-  DOTS = "d";
-  IMPULSES = "i";
-  STEPS = "s";
-  ERRORBARS = "e";
-  TITLE = "title";
-
-  if (nargin != 2)
-    usage ("__pltopt__ (opt)");
-  endif
-
   if (! isstr (opt))
-    error ("__pltopt__: argument must be a string");
+    usage ("__pltopt__ (caller, opt)");
   endif
 
-  while (more_opts)
-
-    ## First get next char.
-
-    if (max (size (opt)) > 1)
-#      [char, opt] = sscanf (opt, "%c %s", "C");
-       char = opt(1);
-       opt = opt(2:length(opt));
-    else
-      char = opt;
-      more_opts = 0;
-    endif
-
-    ## Now set flags based on char.
+  nr = rows (opt);
+  fmt = "";
+  for i = 1:nr
+    t = __pltopt1__ (caller, deblank (opt(i,:)));
+    fmt(i,1:length(t)) = t;
+  endfor
 
-    if (strcmp (char, "-"))
-      set_lines = 1;
-    elseif (strcmp (char, "."))
-      set_dots  = 1;
-    elseif (strcmp (char, "@"))
-      set_points = 1;
-    elseif (strcmp (char, "^"))
-      set_impulses = 1;
-    elseif (strcmp (char, "L"))
-      set_steps = 1;
-    elseif (strcmp (char, "~"))
-      set_errbars = 1;
-    elseif (strcmp (char, "#"))
-      set_boxes = 1;
-    elseif (strcmp (char, "0") || strcmp (char, "1") ...
-            || strcmp (char, "2") || strcmp (char, "3") ...
-            || strcmp (char, "4") || strcmp (char, "5") ...
-            || strcmp (char, "6") || strcmp (char, "7") ...
-            || strcmp (char, "8") || strcmp (char, "9"))
-      if (set_color)
-	set_points = 1;
-	symbol = char;
-	set_symbol = 1;
-      else
-	color = char;
-	set_color = 1;
-      endif
-    elseif (strcmp (char, "r"))
-      set_color = 1;
-      color = "1";
-    elseif (strcmp (char, "g"))
-      set_color = 1;
-      color = "2";
-    elseif (strcmp (char, "b"))
-      set_color = 1;
-      color = "3";
-    elseif (strcmp (char, "m"))
-      set_color = 1;
-      color = "4";
-    elseif (strcmp (char, "c"))
-      set_color = 1;
-      color = "5";
-    elseif (strcmp (char, "w"))
-      set_color = 1;
-      color = "6";
-    elseif (strcmp (char, "*"))
-      set_points = 1;
-      set_symbol = 1;
-      symbol = "6";
-    elseif (strcmp (char, "+"))
-      set_points = 1;
-      set_symbol = 1;
-      symbol = "2";
-    elseif (strcmp (char, "o"))
-      set_points = 1;
-      set_symbol = 1;
-      symbol = "1";
-    elseif (strcmp (char, "x"))
-      set_points = 1;
-      set_symbol = 1;
-      symbol = "4";
-    elseif (strcmp (char, ";"))  # title mode.
-      set_key = 1;
-      working = 1;
-      key_title = ""; 
-      while (working)
-        if (max (size (opt)) > 1)
-	  char = opt(1);
-	  opt = opt(2:length(opt));
-        else
-	  char = opt;
-	  if (! strcmp (char, ";"))
-            error ("%s: unfinished key label", caller);
-          end
-          more_opts = 0;
-          working = 0;
-        endif
-        if strcmp (char, ";")
-          working = 0;
-        else
-	  if (isempty (key_title))  # needs this to avoid empty matrix warning.
-            key_title = char;
-	  else
-            key_title = strcat (key_title, char);
-	  endif
-        endif
-      endwhile
-    elseif (strcmp (char, " ")) 
-      ## whitespace -- do nothing.
-    else
-      error ("%s: unrecognized format character: '%s'", caller, char);
-    endif
-  endwhile
-
-  ## Now create format string.
-
-  fmt = WITH;
-
-  if (set_lines)
-    if (set_points)
-      fmt = strcat (fmt, " ", LINESPOINTS);
-    else
-      fmt = strcat (fmt, " ", LINES);
-    endif
-  elseif (set_boxes)
-    if (set_errbars)
-      fmt = strcat (fmt, " ", BOXERRORBARS);
-    else
-      fmt = strcat (fmt, " ", BOXES);
-    endif
-  elseif (set_points)
-    fmt = strcat (fmt, " ", POINTS);
-  elseif (set_dots)
-    fmt = strcat (fmt, " ", DOTS);
-  elseif (set_impulses)
-    fmt = strcat (fmt, " ", IMPULSES);
-  elseif (set_steps)
-    fmt = strcat (fmt, " ", STEPS);
-  elseif (set_errbars)
-    fmt = strcat (fmt, " ", ERRORBARS);
-  endif
-
-  if (strcmp (fmt, WITH))
-    fmt = strcat (fmt, " ", LINES);
-  endif
-
-  if (set_color)
-    fmt = strcat (fmt, " ", color);
-    if (set_symbol)
-      fmt = strcat (fmt, " ", symbol);
-    endif
-  elseif (set_symbol)
-    fmt = strcat (fmt, " 1 ", symbol);
-  endif
-
-  if (set_key)
-    fmt = sprintf ("%s %s \"%s\" ", fmt, TITLE, key_title);
-  endif
 endfunction
diff --git a/scripts/plot/mplot.m b/scripts/plot/mplot.m
--- a/scripts/plot/mplot.m
+++ b/scripts/plot/mplot.m
@@ -57,25 +57,23 @@ function mplot (...)
   ## update the plot position
 
   if (__multiplot_mode__)
 
     if (__multiplot_xi__ < __multiplot_xn__)
       __multiplot_xi__++;
     else
       __multiplot_xi__ = 1;
-      if (__multiplot_yi__ < multiplot_xn__)
+      if (__multiplot_yi__ < __multiplot_yn__)
 	__multiplot_yi__++;
       else
 	__multiplot_yi__ = 1;
       endif
     endif
 
     xo = (__multiplot_xi__ - 1.0) * __multiplot_xsize__;
-    yo = (__multiplot_yn__ - __multiplot_yi) * __multiplot_ysize__;
+    yo = (__multiplot_yn__ - __multiplot_yi__) * __multiplot_ysize__;
 
     eval (sprintf ("gset origin %g, %g", xo, yo));
 
-    clearplot;
-
   endif
 
 endfunction
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -93,13 +93,15 @@ function multiplot (xn, yn)
     __multiplot_mode__ = 1;
     __multiplot_xsize__ = xsize;
     __multiplot_ysize__ = ysize;
     __multiplot_xn__ = xn;
     __multiplot_yn__ = yn;
     __multiplot_xi__ = 1;
     __multiplot_yi__ = 1;
 
+    gnuplot_command_replot = "cle;rep";
+
     clearplot;
 
   endif
 
 endfunction
diff --git a/scripts/plot/oneplot.m b/scripts/plot/oneplot.m
--- a/scripts/plot/oneplot.m
+++ b/scripts/plot/oneplot.m
@@ -35,14 +35,15 @@ function oneplot ()
 
     global __multiplot_mode__ = 0;
 
     if (__multiplot_mode__)
       gset nomultiplot;
       gset size 1, 1;
       gset origin 0, 0;
       __multiplot_mode__ = 0;
+      gnuplot_command_replot "rep";
       clearplot;
     endif
 
   endif
 
 endfunction
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -125,16 +125,18 @@ function subplot (rows, columns, index)
 	|| __multiplot_yn__ != rows)
 
       __multiplot_mode__ = 1;
       __multiplot_xn__ = columns;
       __multiplot_yn__ = rows;
       __multiplot_xsize__ = 1.0 ./ columns;
       __multiplot_ysize__ = 1.0 ./ rows;
 
+      gnuplot_command_replot = "cle;rep";
+
       gset multiplot;
 
       eval (sprintf ("gset size %g, %g", __multiplot_xsize__,
 		     __multiplot_ysize__));
     endif
 
     ## get the sub plot location
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,59 @@
+Wed Apr  8 01:00:58 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* parse.y (Vwarn_future_time_stamp): New variable.
+	(symbols_of_parse): Add DEFVAR for it.
+	(warn_future_time_stamp): New function.
+	(frob_function_def): Maybe warn about files with future time stamps.
+
+Thu Apr  2 20:43:45 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* pt-arg-list.cc (tree_argument_list::convert_to_const_vector): In
+	error messages, print element numbers starting with 1, not 0.
+
+Sat Mar 28 15:25:44 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* toplev.cc (clean_up_for_exit): New function.
+	(clean_up_and_exit): Use it.
+	* sighandlers.cc (my_friendly_exit): Call it instead of
+	clean_up_and_exit, then do default action for signal.
+
+	* sighandlers.cc (octave_new_handler): Call my_friendly_exit with
+	signal set to SIGABRT if it is defined, or -1 otherwise.
+
+	* error.cc (verror): Fix thinko in attempt to skip `error: ' tag
+	when buffering error messages.
+	* pt-except.cc (tree_try_catch::eval): Reset buffer_error_messages
+	here if	just discarding unwind_protect frame.
+
+Wed Mar 18 12:35:18 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* xpow.cc (elem_xpow): For real-scalar .^ matrix case, result is
+	complex only if real-scalar is negative and matrix has some
+	non-integer values.
+
+Tue Mar 17 17:47:50 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* pt-plot.cc (Vgnuplot_command_plot, Vgnuplot_command_replot,
+	Vgnuplot_command_splot, Vgnuplot_command_using,
+	Vgnuplot_command_with, Vgnuplot_command_title,
+	Vgnuplot_command_end): New static variables.
+	(symbols_of_pt_plot): DEFVAR them.
+	(gnuplot_command_plot, gnuplot_command_replot,
+	gnuplot_command_splot, gnuplot_command_using,
+	gnuplot_command_with, gnuplot_command_title,
+	gnuplot_command_end): New functions.
+	(open_plot_stream, send_to_plot_stream, tree_plot_command::eval,
+	subplot_using::print, subplot_style::print, subplot::print, 
+	do_external_plotter_cd, Fgset, Fgshow): Use them instead of the
+	GPLOT_CMD_PLOT, GPLOT_CMD_REPLOT, GPLOT_CMD_SPLOT,
+	GPLOT_CMD_USING, GPLOT_CMD_WITH, GPLOT_CMD_TITLE, and
+	GPLOT_CMD_END macros.
+
 Fri Feb 27 12:25:27 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* help.cc (additional_help_message): Fix www address.
 
 Tue Feb 24 00:42:59 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* help.cc (simple_help): Put additional help message first.
   	(additional_help_message): Add information about web site and
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -82,18 +82,25 @@ verror (const char *name, const char *fm
 
 	  // XXX FIXME XXX -- this is ugly, but it prevents
 	  //
 	  //   eval ("error (\"msg\")", "error (__error_text__)");
 	  //
 	  // from printing `error: ' twice.  Assumes that the NAME we
 	  // have been given doesn't contain `:'.
 
-	  ptr = strchr (msg, ':') + 2;
-	  ptr = ptr ? ptr : msg;	  
+	  ptr = strchr (msg, ':');
+
+	  if (ptr)
+	    {
+	      if (*++ptr != '\0')
+		++ptr;
+	    }
+	  else
+	    ptr = msg;
 	}
 
       *error_message_buffer << ptr;
     }
   else
     {
       octave_diary << msg;
       cerr << msg;
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -408,18 +408,19 @@ DEFUN (fopen, args, ,
 	{
 	  if (os->ok () && ! error_state)
 	    {
 	      retval(1) = "";
 	      retval(0) = octave_stream_list::insert (os);
 	    }
 	  else
 	    {
-	      int errno = 0;
-	      retval(1) = os->error (false, errno);
+	      int error_number = 0;
+
+	      retval(1) = os->error (false, error_number);
 	      retval(0) = -1.0;
 	    }
 	}
       else
 	::error ("fopen: internal error");
     }
   else
     print_usage ("fopen");
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -64,16 +64,19 @@ extern bool reading_startup_message_prin
 
 // TRUE means input is coming from startup file.
 extern bool input_from_startup_file;
 
 // TRUE means that input is coming from a file that was named on
 // the command line.
 extern bool input_from_command_line_file;
 
+// TRUE means warn about function files that have time stamps in the future.
+extern bool Vwarn_future_time_stamp;
+
 extern void
 parse_and_execute (FILE *f);
 
 extern void
 parse_and_execute (const string& s, bool verbose = false,
 		   const char *warn_for = 0);
 
 extern string get_help_from_file (const string& f);
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -77,16 +77,19 @@ static bool Vwarn_assign_as_truth_value;
 
 // If TRUE, generate a warning for variable swich labels.
 static bool Vwarn_variable_switch_label;
 
 // If TRUE, generate warning if declared function name disagrees with
 // the name of the file in which it is defined.
 static bool Vwarn_function_name_clash;
 
+// TRUE means warn about function files that have time stamps in the future.
+bool Vwarn_future_time_stamp;
+
 // If TRUE, generate warning if a statement in a function is not
 // terminated with a semicolon.  Useful for checking functions that
 // should only produce output using explicit printing statements.
 static bool Vwarn_missing_semicolon;
 
 // Temporary symbol table pointer used to cope with bogus function syntax.
 symbol_table *tmp_local_sym_tab = 0;
 
@@ -2196,20 +2199,32 @@ frob_function (tree_identifier *id, octa
 	  global_sym_tab->rename (id_name, curr_fcn_file_name);
 
 	  if (error_state)
 	    return 0;
 
 	  id_name = id->name ();
 	}
 
+      time_t now = time (0);
+
       fcn->stash_function_name (id_name);
       fcn->stash_fcn_file_name ();
-      fcn->stash_fcn_file_time (time (0));
+      fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
+
+      if (Vwarn_future_time_stamp)
+	{
+	  string nm = fcn->fcn_file_name ();
+
+	  file_stat fs (nm);
+
+	  if (fs && fs.is_newer (now))
+	    warning ("time stamp for `%s' is in the future", nm.c_str ());
+	}
     }
   else if (! (input_from_tmp_history_file || input_from_startup_file)
 	   && reading_script_file
 	   && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
 	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
@@ -3123,16 +3138,24 @@ static int
 warn_function_name_clash (void)
 {
   Vwarn_function_name_clash = check_preference ("warn_function_name_clash");
 
   return 0;
 }
 
 static int
+warn_future_time_stamp (void)
+{
+  Vwarn_future_time_stamp = check_preference ("warn_future_time_stamp");
+
+  return 0;
+}
+
+static int
 warn_missing_semicolon (void)
 {
   Vwarn_missing_semicolon = check_preference ("warn_missing_semicolon");
 
   return 0;
 }
 
 static int
@@ -3152,16 +3175,19 @@ symbols_of_parse (void)
 results of commands executed by eval() that do not end with semicolons.");
 
   DEFVAR (warn_assign_as_truth_value, 1.0, 0, warn_assign_as_truth_value,
     "produce warning for assignments used as truth values");
 
   DEFVAR (warn_function_name_clash, 1.0, 0, warn_function_name_clash,
     "produce warning if function name conflicts with file name");
 
+  DEFVAR (warn_future_time_stamp, 1.0, 0, warn_future_time_stamp,
+    "warn if a function file has a time stamp that is in the future");
+
   DEFVAR (warn_missing_semicolon, 0.0, 0, warn_missing_semicolon,
     "produce a warning if a statement in a function file is not\n\
 terminated with a semicolon");
 
   DEFVAR (warn_variable_switch_label, 0.0, 0, warn_variable_switch_label,
     "produce warning for variables used as switch labels");
 }
 
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -89,17 +89,17 @@ tree_argument_list::convert_to_const_vec
       tree_expression *elt = this->operator () (p);
 
       if (elt)
 	{
 	  octave_value tmp = elt->rvalue ();
 
 	  if (error_state)
 	    {
-	      ::error ("evaluating argument list element number %d", k);
+	      ::error ("evaluating argument list element number %d", k+1);
 	      args = octave_value_list ();
 	      break;
 	    }
 	  else
 	    {
 	      if (tmp.is_all_va_args ())
 		{
 		  if (curr_function)
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -97,16 +97,18 @@ do_catch_code (void *ptr)
 
 void
 tree_try_catch_command::eval (void)
 {
   unwind_protect::begin_frame ("tree_try_catch::eval");
 
   unwind_protect::add (do_catch_code, catch_code);
 
+  bool old_buffer_error_messages = buffer_error_messages;
+
   if (catch_code)
     {
       unwind_protect_bool (buffer_error_messages);
       buffer_error_messages = true;
     }
 
   if (try_code)
     try_code->eval ();
@@ -114,16 +116,17 @@ tree_try_catch_command::eval (void)
   if (catch_code && error_state)
     {
       error_state = 0;
       unwind_protect::run_frame ("tree_try_catch::eval");
     }
   else
     {
       error_state = 0;
+      buffer_error_messages = old_buffer_error_messages;
       unwind_protect::discard_frame ("tree_try_catch::eval");
     }
 }
 
 void
 tree_try_catch_command::accept (tree_walker& tw)
 {
   tw.visit_try_catch_command (*this);
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -96,46 +96,24 @@ static bool clear_before_plotting = true
 SLStack <string> tmp_files;
 
 // Pipe to gnuplot.
 static oprocstream *plot_stream = 0;
 
 // ID of the plotter process.
 static pid_t plot_stream_pid = 0;
 
-// Use shortest possible abbreviations to minimize trouble caused by
-// gnuplot's fixed-length command line buffer.
-
-#ifndef GPLOT_CMD_PLOT  
-#define GPLOT_CMD_PLOT   "pl"
-#endif
-
-#ifndef GPLOT_CMD_REPLOT 
-#define GPLOT_CMD_REPLOT "cle;rep"
-#endif
-
-#ifndef GPLOT_CMD_SPLOT 
-#define GPLOT_CMD_SPLOT  "sp"
-#endif
-
-#ifndef GPLOT_CMD_USING
-#define GPLOT_CMD_USING  "u"
-#endif
-
-#ifndef GPLOT_CMD_WITH 
-#define GPLOT_CMD_WITH   "w"
-#endif
-
-#ifndef GPLOT_CMD_TITLE
-#define GPLOT_CMD_TITLE  "t"
-#endif
-
-#ifndef GPLOT_CMD_END
-#define GPLOT_CMD_END "\n"
-#endif
+// Gnuplot command strings that we use.
+static string Vgnuplot_command_plot;
+static string Vgnuplot_command_replot;
+static string Vgnuplot_command_splot;
+static string Vgnuplot_command_using;
+static string Vgnuplot_command_with;
+static string Vgnuplot_command_title;
+static string Vgnuplot_command_end;
 
 static void
 plot_stream_death_handler (pid_t pid, int)
 {
   close_plot_stream ();
 
   warning ("connection to external plotter (pid = %d) lost --", pid);
   warning ("please try your plot command(s) again");
@@ -205,49 +183,50 @@ open_plot_stream (void)
     }
 
   if (! error_state && plot_stream && *plot_stream && ! initialized)
     {
       initialized = true;
       *plot_stream << "set data style lines\n";
 
       if (gnuplot_terminal_type)
-	*plot_stream << "set term " << gnuplot_terminal_type << GPLOT_CMD_END;
+	*plot_stream << "set term " << gnuplot_terminal_type
+		     << Vgnuplot_command_end; 
     }
 }
 
 static int
 send_to_plot_stream (const char *cmd)
 {
   if (! (plot_stream && *plot_stream))
     {
       open_plot_stream ();
 
       if (error_state)
 	return -1;
     }
 
-  int replot_len = strlen (GPLOT_CMD_REPLOT);
-  int splot_len = strlen (GPLOT_CMD_SPLOT);
-  int plot_len = strlen (GPLOT_CMD_PLOT);
+  int replot_len = Vgnuplot_command_replot.length ();
+  int splot_len = Vgnuplot_command_splot.length ();
+  int plot_len = Vgnuplot_command_plot.length ();
 
-  bool is_replot = (strncmp (cmd, GPLOT_CMD_REPLOT, replot_len) == 0);
-  bool is_splot = (strncmp (cmd, GPLOT_CMD_SPLOT, splot_len) == 0);
-  bool is_plot = (strncmp (cmd, GPLOT_CMD_PLOT, plot_len) == 0);
+  bool is_replot = (Vgnuplot_command_replot.compare (cmd, 0, replot_len) == 0);
+  bool is_splot = (Vgnuplot_command_splot.compare (cmd, 0, splot_len) == 0);
+  bool is_plot = (Vgnuplot_command_plot.compare (cmd, 0, plot_len) == 0);
 
   if (plot_line_count == 0 && is_replot)
     error ("replot: no previous plot");
   else
     {
       *plot_stream << cmd;
 
       if (! (is_replot || is_splot || is_plot)
 	  && plot_line_count > 0
 	  && Vautomatic_replot)
-	*plot_stream << GPLOT_CMD_REPLOT << GPLOT_CMD_END;
+	*plot_stream << Vgnuplot_command_replot << Vgnuplot_command_end;
 
       plot_stream->flush ();
     }
 
   return 0;
 }
 
 // Plotting, eh?
@@ -269,45 +248,45 @@ tree_plot_command::eval (void)
   ostrstream plot_buf;
 
   switch (ndim)
     {
     case 1:
       if (plot_line_count == 0)
 	{
 	  if (plot_list)
-	    plot_buf << GPLOT_CMD_PLOT;
+	    plot_buf << Vgnuplot_command_plot;
 	  else
 	    {
 	      ::error ("replot: must have something to plot");
 	      return;
 	    }
 	}
       else
-	plot_buf << GPLOT_CMD_REPLOT;
+	plot_buf << Vgnuplot_command_replot;
       break;
 
     case 2:
       if (clear_before_plotting || plot_line_count == 0)
 	{
 	  plot_line_count = 0;
-	  plot_buf << GPLOT_CMD_PLOT;
+	  plot_buf << Vgnuplot_command_plot;
 	}
       else
-	plot_buf << GPLOT_CMD_REPLOT;
+	plot_buf << Vgnuplot_command_replot;
       break;
 
     case 3:
       if (clear_before_plotting || plot_line_count == 0)
 	{
 	  plot_line_count = 0;
-	  plot_buf << GPLOT_CMD_SPLOT;
+	  plot_buf << Vgnuplot_command_splot;
 	}
       else
-	plot_buf << GPLOT_CMD_REPLOT;
+	plot_buf << Vgnuplot_command_replot;
       break;
 
     default:
       gripe_2_or_3_dim_plot ();
       return;
     }
 
   if (range)
@@ -325,17 +304,17 @@ tree_plot_command::eval (void)
   if (plot_list)
     {
       int status = plot_list->print (ndim, plot_buf);
 
       if (error_state || status < 0)
 	return;
     }
 
-  plot_buf << GPLOT_CMD_END << ends;
+  plot_buf << Vgnuplot_command_end << ends;
 
   // Just testing...
   //  char *message = plot_buf.str ();
   //  cout << "[*]" << message << "[*]\n";
 
   if (parametric_plot && ndim == 2)
     {
       warning ("can't make 2D parametric plot -- setting noparametric...");
@@ -527,17 +506,17 @@ subplot_using::print (int ndim, int n_ma
   int status = eval (ndim, n_max);
 
   if (status < 0)
     return -1;
 
   for (int i = 0; i < qual_count; i++)
     {
       if (i == 0)
-	plot_buf << " " << GPLOT_CMD_USING << " ";
+	plot_buf << " " << Vgnuplot_command_using << " ";
       else
 	plot_buf << ":";
 
       plot_buf << val (i);
     }
 
   return 0;
 }
@@ -554,17 +533,17 @@ subplot_style::~subplot_style (void)
   delete sp_pointtype;
 }
 
 int
 subplot_style::print (ostrstream& plot_buf)
 {
   if (! sp_style.empty ())
     {
-      plot_buf << " " << GPLOT_CMD_WITH << " " << sp_style;
+      plot_buf << " " << Vgnuplot_command_with << " " << sp_style;
 
       if (sp_linetype)
 	{
 	  octave_value tmp = sp_linetype->rvalue ();
 
 	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.double_value ();
@@ -781,27 +760,27 @@ subplot::print (int ndim, ostrstream& pl
   if (status < 0)
     return -1;
 
   if (sp_title_clause)
     {
       octave_value tmp = sp_title_clause->rvalue ();
 
       if (! error_state && tmp.is_string ())
-	plot_buf << " " << GPLOT_CMD_TITLE << " "
+	plot_buf << " " << Vgnuplot_command_title << " "
 	  << '"' << tmp.string_value () << '"';
       else
 	{
 	  warning ("line title must be a string");
-	  plot_buf << " " << GPLOT_CMD_TITLE << " "
+	  plot_buf << " " << Vgnuplot_command_title << " "
 	    << '"' << "line " << plot_line_count << '"';
 	}
     }
   else
-    plot_buf << " " << GPLOT_CMD_TITLE << " "
+    plot_buf << " " << Vgnuplot_command_title << " "
       << '"' << "line " << plot_line_count << '"';
 
   if (sp_style_clause)
     {
       int status = sp_style_clause->print (plot_buf);
       if (status < 0)
 	return -1;
     }
@@ -920,17 +899,17 @@ close_plot_stream (void)
 }
 
 void
 do_external_plotter_cd (const string& newdir)
 {
   if (plot_stream && *plot_stream)
     {
       ostrstream plot_buf;
-      plot_buf << "cd \"" << newdir << "\"" GPLOT_CMD_END << ends;
+      plot_buf << "cd \"" << newdir << "\"" << Vgnuplot_command_end << ends;
       char *message = plot_buf.str ();
       send_to_plot_stream (message);
       delete [] message;
     }
 }
 
 DEFUN (clearplot, , ,
   "clearplot (): clear the plot window")
@@ -1043,25 +1022,25 @@ set plotting options for gnuplot")
       else if (almost_match ("noparametric", argv[1], 5))
 	parametric_plot = false;
       else if (almost_match ("term", argv[1], 1))
 	{
 	  delete [] gnuplot_terminal_type;
 	  ostrstream buf;
 	  for (int i = 2; i < argc; i++)
 	    buf << argv[i] << " ";
-	  buf << GPLOT_CMD_END << ends;
+	  buf << Vgnuplot_command_end << ends;
 	  gnuplot_terminal_type = buf.str ();
 	}
     }
 
   for (int i = 0; i < argc; i++)
     plot_buf << argv[i] << " ";
 
-  plot_buf << GPLOT_CMD_END << ends;
+  plot_buf << Vgnuplot_command_end << ends;
 
   char *plot_command = plot_buf.str ();
   send_to_plot_stream (plot_command);
 
   delete [] plot_command;
 
   return retval;
 }
@@ -1087,17 +1066,17 @@ show plotting options")
   if (error_state)
     return retval;
 
   ostrstream plot_buf;
 
   for (int i = 0; i < argc; i++)
     plot_buf << argv[i] << " ";
 
-  plot_buf << GPLOT_CMD_END << ends;
+  plot_buf << Vgnuplot_command_end << ends;
 
   char *plot_command = plot_buf.str ();
   send_to_plot_stream (plot_command);
 
   delete [] plot_command;
 
   return retval;
 }
@@ -1112,32 +1091,80 @@ DEFUN_TEXT (show, args, nargout,
 static int
 automatic_replot (void)
 {
   Vautomatic_replot = check_preference ("automatic_replot");
 
   return 0;
 }
 
-int
-gnuplot_binary (void)
+static int
+set_string_var (string& var, const char *nm)
 {
-  int status = 0;
+  int retval = 0;
 
-  string s = builtin_string_variable ("gnuplot_binary");
+  string s = builtin_string_variable (nm);
 
   if (s.empty ())
     {
-      gripe_invalid_value_specified ("gnuplot_binary");
-      status = -1;
+      gripe_invalid_value_specified (nm);
+      retval = -1;
     }
   else
-    Vgnuplot_binary = s;
+    var = s;
+
+  return retval;
+}
+
+static int
+gnuplot_binary (void)
+{
+  return set_string_var (Vgnuplot_binary, "gnuplot_binary");
+}
+
+static int
+gnuplot_command_plot (void)
+{
+  return set_string_var (Vgnuplot_command_plot, "gnuplot_command_plot");
+}
+
+static int
+gnuplot_command_replot (void)
+{
+  return set_string_var (Vgnuplot_command_replot, "gnuplot_command_replot");
+}
 
-  return status;
+static int
+gnuplot_command_splot (void)
+{
+  return set_string_var (Vgnuplot_command_splot, "gnuplot_command_splot");
+}
+
+static int
+gnuplot_command_using (void)
+{
+  return set_string_var (Vgnuplot_command_using, "gnuplot_command_using");
+}
+
+static int
+gnuplot_command_with (void)
+{
+  return set_string_var (Vgnuplot_command_with, "gnuplot_command_with");
+}
+
+static int
+gnuplot_command_title (void)
+{
+  return set_string_var (Vgnuplot_command_title, "gnuplot_command_title");
+}
+
+static int
+gnuplot_command_end (void)
+{
+  return set_string_var (Vgnuplot_command_end, "gnuplot_command_end");
 }
 
 static int
 gnuplot_has_frames (void)
 {
   Vgnuplot_has_frames = check_preference ("gnuplot_has_frames");
 
   return 0;
@@ -1155,16 +1182,37 @@ void
 symbols_of_pt_plot (void)
 {
   DEFVAR (automatic_replot, 0.0, 0, automatic_replot,
     "if true, auto-insert a replot command when a plot changes");
 
   DEFVAR (gnuplot_binary, "gnuplot", 0, gnuplot_binary,
     "path to gnuplot binary");
 
+  DEFVAR (gnuplot_command_plot, "pl", 0, gnuplot_command_plot,
+    "");
+
+  DEFVAR (gnuplot_command_replot, "rep", 0, gnuplot_command_replot,
+    "");
+
+  DEFVAR (gnuplot_command_splot, "sp", 0, gnuplot_command_splot,
+    "");
+
+  DEFVAR (gnuplot_command_using, "u", 0, gnuplot_command_using,
+    "");
+
+  DEFVAR (gnuplot_command_with, "w", 0, gnuplot_command_with,
+    "");
+
+  DEFVAR (gnuplot_command_title, "t", 0, gnuplot_command_title,
+    "");
+
+  DEFVAR (gnuplot_command_end, "\n", 0, gnuplot_command_end,
+    "");
+
 #ifdef GNUPLOT_HAS_FRAMES
   double with_frames = 1.0;
 #else
   double with_frames = 0.0;
 #endif
 
   DEFVAR (gnuplot_has_frames, with_frames, 0, gnuplot_has_frames,
     "true if gnuplot supports multiple plot windows on X11, false otherwise");
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -84,16 +84,22 @@ static sigset_t octave_signal_mask;
 #define MAYBE_ACK_SIGNAL(sig) \
   octave_set_signal_handler (sig, SIG_ACK)
 #define ACK_USES_SIG 1
 #else
 #define MAYBE_ACK_SIGNAL(sig) \
   do { } while (0)
 #endif
 
+#if defined (SIGABRT)
+#define OCTAVE_MEMORY_EXHAUSTED_ERROR SIGABRT
+#else
+#define OCTAVE_MEMORY_EXHAUSTED_ERROR (-1)
+#endif
+
 void
 octave_save_signal_mask (void)
 {
 #if defined (HAVE_POSIX_SIGNALS)
   sigprocmask (0, 0, &octave_signal_mask);
 #endif
 }
 
@@ -123,34 +129,41 @@ my_friendly_exit (const char *sig_name, 
   else
     {
       been_there_done_that = true;
 
       cerr << "error: " << sig_name << " -- stopping myself...\n";
 
       save_user_variables ();
 
-      clean_up_and_exit (sig_number);
+      if (sig_number < 0)
+	exit (1);
+      else
+	{
+	  octave_set_signal_handler (sig_number, SIG_DFL);
+
+	  kill (getpid (), sig_number);
+	}
     }
 }
 
 // I know, not really a signal handler.
 
 static void
 octave_new_handler (void)
 {
   cerr << "error: memory exhausted -- trying to return to prompt\n";
 
   if (can_interrupt)
     {
       jump_to_top_level ();
       panic_impossible ();
     }
   else
-    my_friendly_exit ("operator new", 1);
+    my_friendly_exit ("operator new", OCTAVE_MEMORY_EXHAUSTED_ERROR);
 }
 
 sig_handler *
 octave_set_signal_handler (int sig, sig_handler *handler)
 {
 #if defined (HAVE_POSIX_SIGNALS)
   struct sigaction act, oact;
   act.sa_handler = handler;
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -162,43 +162,41 @@ main_loop (void)
   while (retval == 0);
 
   return retval;
 }
 
 // Fix up things before exiting.
 
 void
-clean_up_and_exit (int retval)
+clean_up_for_exit (void)
 {
   command_editor::restore_terminal_state ();
 
   // XXX FIXME XXX -- is this needed?  Can it cause any trouble?
   raw_mode (0);
 
   command_history::clean_up_and_save ();
 
   close_plot_stream ();
 
   close_files ();
 
   cleanup_tmp_files ();
 
   if (!quitting_gracefully && (interactive || forced_interactive))
     cout << "\n";
-
-  if (retval == EOF)
-    retval = 0;
+}
 
-  exit (retval);
+void
+clean_up_and_exit (int retval)
+{
+  clean_up_for_exit ();
 
-  // This is bogus but should prevent g++ from giving a warning saying
-  // that this volatile function does return.
-
-  panic_impossible ();
+  exit (retval == EOF ? 0 : retval);
 }
 
 DEFUN_TEXT (casesen, args, ,
   "casesen [on|off]")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -29,16 +29,19 @@ class octave_value;
 class octave_value_list;
 class octave_user_function;
 class tree_statement_list;
 class charMatrix;
 
 #include <string>
 
 extern void
+clean_up_and_exit (void);
+
+extern void
 clean_up_and_exit (int) GCC_ATTR_NORETURN;
 
 extern int
 main_loop (void);
 
 extern void
 do_octave_atexit (void);
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -21,16 +21,17 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdio>
 #include <cstring>
+#include <ctime>
 
 #include <string>
 
 #include "file-stat.h"
 #include "oct-env.h"
 #include "glob-match.h"
 #include "str-vec.h"
 
@@ -508,19 +509,19 @@ symbol_out_of_date (symbol_record *sr)
 	  if (! (ff.empty ()
 		 || (Vignore_function_time_stamp
 		     && tmp->is_system_fcn_file ())))
 	    {
 	      time_t tp = tmp->time_parsed ();
 
 	      string fname = fcn_file_in_path (ff);
 
-	      int status = file_stat::is_newer (fname, tp);
+	      file_stat fs (fname);
 
-	      if (status > 0)
+	      if (fs && fs.is_newer (tp))
 		retval = true;
 	    }
 	}
     }
 
   return retval;
 }
 
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -441,28 +441,42 @@ xpow (const ComplexMatrix& a, const Comp
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_matrix | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
+// XXX FIXME XXX -- these functions need to be fixed so that things
+// like
+//
+//   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
+//
+// and
+//
+//   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
+//
+// produce identical results.  Also, it would be nice if -1^0.5
+// produced a pure imaginary result instead of a complex number with a
+// small real part.  But perhaps that's really a problem with the math
+// library...
+
 // -*- 1 -*-
 octave_value
 elem_xpow (double a, const Matrix& b)
 {
   octave_value retval;
 
   int nr = b.rows ();
   int nc = b.cols ();
 
-  // For now, assume the worst.
+  double d1, d2;
 
-  if (a < 0.0)
+  if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  result (i, j) = pow (atmp, b (i, j));
 
       retval = result;
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,17 @@
+Thu Mar  5 20:35:26 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* octave.test/system/gmtime-1.m, octave.test/system/localtime-1.m:
+	Not all systems have time zone info in the struct.
+
+Mon Mar  2 14:36:50 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* octave.test/io/binary-io-1.m (id): Use binary flag in fopen call.
+
 Wed Apr  2 21:59:15 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* octave.test/prefer/prefer.exp: Delete prefer-36 and prefer-37.
 	* octave.test/prefer/prefer-36.m, octave.test/prefer/prefer-37.m:
 	Delete test files.
 
 Wed Mar 12 16:56:41 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/test/octave.test/io/binary-io-1.m b/test/octave.test/io/binary-io-1.m
--- a/test/octave.test/io/binary-io-1.m
+++ b/test/octave.test/io/binary-io-1.m
@@ -4,27 +4,27 @@ type_list = ["char"; "char*1"; "integer*
 	     "uint"; "unsigned int"; "long"; "ulong"; "unsigned long";
 	     "float"; "float32"; "real*4"; "double"; "float64";
 	     "real*8"; "int16"; "integer*2"; "int32"; "integer*4"];
 
 n = rows (type_list);
 
 nm = tmpnam ();
 
-id = fopen (nm, "w");
+id = fopen (nm, "wb");
 
 if (id > 0)
 
   for i = 1:n
     fwrite (id, i, deblank (type_list(i,:)));
   endfor
 
   fclose (id);
 
-  id = fopen (nm, "r");
+  id = fopen (nm, "rb");
 
   if (id > 0)
 
     x = zeros (1, n);
 
     for i = 1:n
       x(i) = fread (id, [1, 1], deblank (type_list(i,:)));
     endfor
diff --git a/test/octave.test/system/gmtime-1.m b/test/octave.test/system/gmtime-1.m
--- a/test/octave.test/system/gmtime-1.m
+++ b/test/octave.test/system/gmtime-1.m
@@ -1,13 +1,12 @@
 ts = gmtime (time ());
 (is_struct (ts)
  && struct_contains (ts, "usec")
  && struct_contains (ts, "year")
  && struct_contains (ts, "mon")
  && struct_contains (ts, "mday")
  && struct_contains (ts, "sec")
- && struct_contains (ts, "zone")
  && struct_contains (ts, "min")
  && struct_contains (ts, "wday")
  && struct_contains (ts, "hour")
  && struct_contains (ts, "isdst")
  && struct_contains (ts, "yday"))
diff --git a/test/octave.test/system/localtime-1.m b/test/octave.test/system/localtime-1.m
--- a/test/octave.test/system/localtime-1.m
+++ b/test/octave.test/system/localtime-1.m
@@ -1,13 +1,12 @@
 ts = localtime (time ())
 (is_struct (ts)
  && struct_contains (ts, "usec")
  && struct_contains (ts, "year")
  && struct_contains (ts, "mon")
  && struct_contains (ts, "mday")
  && struct_contains (ts, "sec")
- && struct_contains (ts, "zone")
  && struct_contains (ts, "min")
  && struct_contains (ts, "wday")
  && struct_contains (ts, "hour")
  && struct_contains (ts, "isdst")
  && struct_contains (ts, "yday"))
